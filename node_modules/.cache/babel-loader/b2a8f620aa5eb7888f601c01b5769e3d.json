{"ast":null,"code":"/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the computed key syntax is unnecessarily used for the given node.\n * In particular, it determines whether removing the square brackets and using the content between them\n * directly as the key (e.g. ['foo'] -> 'foo') would produce valid syntax and preserve the same behavior.\n * Valid non-computed keys are only: identifiers, number literals and string literals.\n * Only literals can preserve the same behavior, with a few exceptions for specific node types:\n * Property\n *   - { [\"__proto__\"]: foo } defines a property named \"__proto__\"\n *     { \"__proto__\": foo } defines object's prototype\n * PropertyDefinition\n *   - class C { [\"constructor\"]; } defines an instance field named \"constructor\"\n *     class C { \"constructor\"; } produces a parsing error\n *   - class C { static [\"constructor\"]; } defines a static field named \"constructor\"\n *     class C { static \"constructor\"; } produces a parsing error\n *   - class C { static [\"prototype\"]; } produces a runtime error (doesn't break the whole script)\n *     class C { static \"prototype\"; } produces a parsing error (breaks the whole script)\n * MethodDefinition\n *   - class C { [\"constructor\"]() {} } defines a prototype method named \"constructor\"\n *     class C { \"constructor\"() {} } defines the constructor\n *   - class C { static [\"prototype\"]() {} } produces a runtime error (doesn't break the whole script)\n *     class C { static \"prototype\"() {} } produces a parsing error (breaks the whole script)\n * @param {ASTNode} node The node to check. It can be `Property`, `PropertyDefinition` or `MethodDefinition`.\n * @throws {Error} (Unreachable.)\n * @returns {void} `true` if the node has useless computed key.\n */\n\n\nfunction hasUselessComputedKey(node) {\n  if (!node.computed) {\n    return false;\n  }\n\n  const {\n    key\n  } = node;\n\n  if (key.type !== \"Literal\") {\n    return false;\n  }\n\n  const {\n    value\n  } = key;\n\n  if (typeof value !== \"number\" && typeof value !== \"string\") {\n    return false;\n  }\n\n  switch (node.type) {\n    case \"Property\":\n      return value !== \"__proto__\";\n\n    case \"PropertyDefinition\":\n      if (node.static) {\n        return value !== \"constructor\" && value !== \"prototype\";\n      }\n\n      return value !== \"constructor\";\n\n    case \"MethodDefinition\":\n      if (node.static) {\n        return value !== \"prototype\";\n      }\n\n      return value !== \"constructor\";\n\n    /* c8 ignore next */\n\n    default:\n      throw new Error(`Unexpected node type: ${node.type}`);\n  }\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow unnecessary computed property keys in objects and classes\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-computed-key\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForClassMembers: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unnecessarilyComputedProperty: \"Unnecessarily computed property [{{property}}] found.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     */\n\n    function check(node) {\n      if (hasUselessComputedKey(node)) {\n        const {\n          key\n        } = node;\n        context.report({\n          node,\n          messageId: \"unnecessarilyComputedProperty\",\n          data: {\n            property: sourceCode.getText(key)\n          },\n\n          fix(fixer) {\n            const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);\n            const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken); // If there are comments between the brackets and the property name, don't do a fix.\n\n            if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {\n              return null;\n            }\n\n            const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket); // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n\n            const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n            const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n          }\n\n        });\n      }\n    }\n    /**\n     * A no-op function to act as placeholder for checking a node when the `enforceForClassMembers` option is `false`.\n     * @returns {void}\n     * @private\n     */\n\n\n    function noop() {}\n\n    return {\n      Property: check,\n      MethodDefinition: enforceForClassMembers ? check : noop,\n      PropertyDefinition: enforceForClassMembers ? check : noop\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","hasUselessComputedKey","node","computed","key","type","value","static","Error","module","exports","meta","docs","description","recommended","url","schema","properties","enforceForClassMembers","default","additionalProperties","fixable","messages","unnecessarilyComputedProperty","create","context","sourceCode","getSourceCode","options","check","report","messageId","data","property","getText","fix","fixer","leftSquareBracket","getTokenBefore","isOpeningBracketToken","rightSquareBracket","getTokenAfter","isClosingBracketToken","commentsExistBetween","tokenBeforeLeftBracket","needsSpaceBeforeKey","range","canTokensBeAdjacent","getFirstToken","replacementKey","raw","replaceTextRange","noop","Property","MethodDefinition","PropertyDefinition"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/no-useless-computed-key.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\n * @author Burak Yigit Kaya\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the computed key syntax is unnecessarily used for the given node.\n * In particular, it determines whether removing the square brackets and using the content between them\n * directly as the key (e.g. ['foo'] -> 'foo') would produce valid syntax and preserve the same behavior.\n * Valid non-computed keys are only: identifiers, number literals and string literals.\n * Only literals can preserve the same behavior, with a few exceptions for specific node types:\n * Property\n *   - { [\"__proto__\"]: foo } defines a property named \"__proto__\"\n *     { \"__proto__\": foo } defines object's prototype\n * PropertyDefinition\n *   - class C { [\"constructor\"]; } defines an instance field named \"constructor\"\n *     class C { \"constructor\"; } produces a parsing error\n *   - class C { static [\"constructor\"]; } defines a static field named \"constructor\"\n *     class C { static \"constructor\"; } produces a parsing error\n *   - class C { static [\"prototype\"]; } produces a runtime error (doesn't break the whole script)\n *     class C { static \"prototype\"; } produces a parsing error (breaks the whole script)\n * MethodDefinition\n *   - class C { [\"constructor\"]() {} } defines a prototype method named \"constructor\"\n *     class C { \"constructor\"() {} } defines the constructor\n *   - class C { static [\"prototype\"]() {} } produces a runtime error (doesn't break the whole script)\n *     class C { static \"prototype\"() {} } produces a parsing error (breaks the whole script)\n * @param {ASTNode} node The node to check. It can be `Property`, `PropertyDefinition` or `MethodDefinition`.\n * @throws {Error} (Unreachable.)\n * @returns {void} `true` if the node has useless computed key.\n */\nfunction hasUselessComputedKey(node) {\n    if (!node.computed) {\n        return false;\n    }\n\n    const { key } = node;\n\n    if (key.type !== \"Literal\") {\n        return false;\n    }\n\n    const { value } = key;\n\n    if (typeof value !== \"number\" && typeof value !== \"string\") {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"Property\":\n            return value !== \"__proto__\";\n\n        case \"PropertyDefinition\":\n            if (node.static) {\n                return value !== \"constructor\" && value !== \"prototype\";\n            }\n\n            return value !== \"constructor\";\n\n        case \"MethodDefinition\":\n            if (node.static) {\n                return value !== \"prototype\";\n            }\n\n            return value !== \"constructor\";\n\n        /* c8 ignore next */\n        default:\n            throw new Error(`Unexpected node type: ${node.type}`);\n    }\n\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow unnecessary computed property keys in objects and classes\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-computed-key\"\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                enforceForClassMembers: {\n                    type: \"boolean\",\n                    default: false\n                }\n            },\n            additionalProperties: false\n        }],\n        fixable: \"code\",\n\n        messages: {\n            unnecessarilyComputedProperty: \"Unnecessarily computed property [{{property}}] found.\"\n        }\n    },\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            if (hasUselessComputedKey(node)) {\n                const { key } = node;\n\n                context.report({\n                    node,\n                    messageId: \"unnecessarilyComputedProperty\",\n                    data: { property: sourceCode.getText(key) },\n                    fix(fixer) {\n                        const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);\n                        const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken);\n\n                        // If there are comments between the brackets and the property name, don't do a fix.\n                        if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {\n                            return null;\n                        }\n\n                        const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\n\n                        // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n                        const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] &&\n                            !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n\n                        const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n\n                        return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n                    }\n                });\n            }\n        }\n\n        /**\n         * A no-op function to act as placeholder for checking a node when the `enforceForClassMembers` option is `false`.\n         * @returns {void}\n         * @private\n         */\n        function noop() {}\n\n        return {\n            Property: check,\n            MethodDefinition: enforceForClassMembers ? check : noop,\n            PropertyDefinition: enforceForClassMembers ? check : noop\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}