{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _slicedToArray = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(handlerOf),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(createPresetDescriptors),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime().mark(createPluginDescriptors),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime().mark(createDescriptors),\n    _marked5 = /*#__PURE__*/_regeneratorRuntime().mark(createDescriptor);\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createCachedDescriptors = createCachedDescriptors;\nexports.createDescriptor = createDescriptor;\nexports.createUncachedDescriptors = createUncachedDescriptors;\n\nfunction _gensync() {\n  var data = require(\"gensync\");\n\n  _gensync = function _gensync() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _functional = require(\"../gensync-utils/functional\");\n\nvar _files = require(\"./files\");\n\nvar _item = require(\"./item\");\n\nvar _caching = require(\"./caching\");\n\nvar _resolveTargets = require(\"./resolve-targets\");\n\nfunction isEqualDescriptor(a, b) {\n  return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && (a.file && a.file.request) === (b.file && b.file.request) && (a.file && a.file.resolved) === (b.file && b.file.resolved);\n}\n\nfunction handlerOf(value) {\n  return _regeneratorRuntime().wrap(function handlerOf$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", value);\n\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction optionsWithResolvedBrowserslistConfigFile(options, dirname) {\n  if (typeof options.browserslistConfigFile === \"string\") {\n    options.browserslistConfigFile = (0, _resolveTargets.resolveBrowserslistConfigFile)(options.browserslistConfigFile, dirname);\n  }\n\n  return options;\n}\n\nfunction createCachedDescriptors(dirname, options, alias) {\n  var plugins = options.plugins,\n      presets = options.presets,\n      passPerPreset = options.passPerPreset;\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n    plugins: plugins ? function () {\n      return createCachedPluginDescriptors(plugins, dirname)(alias);\n    } : function () {\n      return handlerOf([]);\n    },\n    presets: presets ? function () {\n      return createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset);\n    } : function () {\n      return handlerOf([]);\n    }\n  };\n}\n\nfunction createUncachedDescriptors(dirname, options, alias) {\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n    plugins: (0, _functional.once)(function () {\n      return createPluginDescriptors(options.plugins || [], dirname, alias);\n    }),\n    presets: (0, _functional.once)(function () {\n      return createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset);\n    })\n  };\n}\n\nvar PRESET_DESCRIPTOR_CACHE = new WeakMap();\nvar createCachedPresetDescriptors = (0, _caching.makeWeakCacheSync)(function (items, cache) {\n  var dirname = cache.using(function (dir) {\n    return dir;\n  });\n  return (0, _caching.makeStrongCacheSync)(function (alias) {\n    return (0, _caching.makeStrongCache)( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(passPerPreset) {\n      var descriptors;\n      return _regeneratorRuntime().wrap(function _callee$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.delegateYield(createPresetDescriptors(items, dirname, alias, passPerPreset), \"t0\", 1);\n\n            case 1:\n              descriptors = _context2.t0;\n              return _context2.abrupt(\"return\", descriptors.map(function (desc) {\n                return loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc);\n              }));\n\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee);\n    }));\n  });\n});\nvar PLUGIN_DESCRIPTOR_CACHE = new WeakMap();\nvar createCachedPluginDescriptors = (0, _caching.makeWeakCacheSync)(function (items, cache) {\n  var dirname = cache.using(function (dir) {\n    return dir;\n  });\n  return (0, _caching.makeStrongCache)( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(alias) {\n    var descriptors;\n    return _regeneratorRuntime().wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.delegateYield(createPluginDescriptors(items, dirname, alias), \"t0\", 1);\n\n          case 1:\n            descriptors = _context3.t0;\n            return _context3.abrupt(\"return\", descriptors.map(function (desc) {\n              return loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc);\n            }));\n\n          case 3:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2);\n  }));\n});\nvar DEFAULT_OPTIONS = {};\n\nfunction loadCachedDescriptor(cache, desc) {\n  var value = desc.value,\n      _desc$options = desc.options,\n      options = _desc$options === void 0 ? DEFAULT_OPTIONS : _desc$options;\n  if (options === false) return desc;\n  var cacheByOptions = cache.get(value);\n\n  if (!cacheByOptions) {\n    cacheByOptions = new WeakMap();\n    cache.set(value, cacheByOptions);\n  }\n\n  var possibilities = cacheByOptions.get(options);\n\n  if (!possibilities) {\n    possibilities = [];\n    cacheByOptions.set(options, possibilities);\n  }\n\n  if (possibilities.indexOf(desc) === -1) {\n    var matches = possibilities.filter(function (possibility) {\n      return isEqualDescriptor(possibility, desc);\n    });\n\n    if (matches.length > 0) {\n      return matches[0];\n    }\n\n    possibilities.push(desc);\n  }\n\n  return desc;\n}\n\nfunction createPresetDescriptors(items, dirname, alias, passPerPreset) {\n  return _regeneratorRuntime().wrap(function createPresetDescriptors$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          return _context4.delegateYield(createDescriptors(\"preset\", items, dirname, alias, passPerPreset), \"t0\", 1);\n\n        case 1:\n          return _context4.abrupt(\"return\", _context4.t0);\n\n        case 2:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked2);\n}\n\nfunction createPluginDescriptors(items, dirname, alias) {\n  return _regeneratorRuntime().wrap(function createPluginDescriptors$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          return _context5.delegateYield(createDescriptors(\"plugin\", items, dirname, alias), \"t0\", 1);\n\n        case 1:\n          return _context5.abrupt(\"return\", _context5.t0);\n\n        case 2:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked3);\n}\n\nfunction createDescriptors(type, items, dirname, alias, ownPass) {\n  var descriptors;\n  return _regeneratorRuntime().wrap(function createDescriptors$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          return _context6.delegateYield(_gensync().all(items.map(function (item, index) {\n            return createDescriptor(item, dirname, {\n              type: type,\n              alias: \"\".concat(alias, \"$\").concat(index),\n              ownPass: !!ownPass\n            });\n          })), \"t0\", 1);\n\n        case 1:\n          descriptors = _context6.t0;\n          assertNoDuplicates(descriptors);\n          return _context6.abrupt(\"return\", descriptors);\n\n        case 4:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, _marked4);\n}\n\nfunction createDescriptor(pair, dirname, _ref) {\n  var type, alias, ownPass, desc, name, options, value, _value, _value2, _value3, _value4, file, filepath, resolver, request, _yield$resolver;\n\n  return _regeneratorRuntime().wrap(function createDescriptor$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          type = _ref.type, alias = _ref.alias, ownPass = _ref.ownPass;\n          desc = (0, _item.getItemDescriptor)(pair);\n\n          if (!desc) {\n            _context7.next = 4;\n            break;\n          }\n\n          return _context7.abrupt(\"return\", desc);\n\n        case 4:\n          value = pair;\n\n          if (Array.isArray(value)) {\n            if (value.length === 3) {\n              _value = value;\n              _value2 = _slicedToArray(_value, 3);\n              value = _value2[0];\n              options = _value2[1];\n              name = _value2[2];\n            } else {\n              _value3 = value;\n              _value4 = _slicedToArray(_value3, 2);\n              value = _value4[0];\n              options = _value4[1];\n            }\n          }\n\n          file = undefined;\n          filepath = null;\n\n          if (!(typeof value === \"string\")) {\n            _context7.next = 18;\n            break;\n          }\n\n          if (!(typeof type !== \"string\")) {\n            _context7.next = 11;\n            break;\n          }\n\n          throw new Error(\"To resolve a string-based item, the type of item must be given\");\n\n        case 11:\n          resolver = type === \"plugin\" ? _files.loadPlugin : _files.loadPreset;\n          request = value;\n          return _context7.delegateYield(resolver(value, dirname), \"t0\", 14);\n\n        case 14:\n          _yield$resolver = _context7.t0;\n          filepath = _yield$resolver.filepath;\n          value = _yield$resolver.value;\n          file = {\n            request: request,\n            resolved: filepath\n          };\n\n        case 18:\n          if (value) {\n            _context7.next = 20;\n            break;\n          }\n\n          throw new Error(\"Unexpected falsy value: \".concat(String(value)));\n\n        case 20:\n          if (!(typeof value === \"object\" && value.__esModule)) {\n            _context7.next = 26;\n            break;\n          }\n\n          if (!value.default) {\n            _context7.next = 25;\n            break;\n          }\n\n          value = value.default;\n          _context7.next = 26;\n          break;\n\n        case 25:\n          throw new Error(\"Must export a default export when using ES6 modules.\");\n\n        case 26:\n          if (!(typeof value !== \"object\" && typeof value !== \"function\")) {\n            _context7.next = 28;\n            break;\n          }\n\n          throw new Error(\"Unsupported format: \".concat(typeof value, \". Expected an object or a function.\"));\n\n        case 28:\n          if (!(filepath !== null && typeof value === \"object\" && value)) {\n            _context7.next = 30;\n            break;\n          }\n\n          throw new Error(\"Plugin/Preset files are not allowed to export objects, only functions. In \".concat(filepath));\n\n        case 30:\n          return _context7.abrupt(\"return\", {\n            name: name,\n            alias: filepath || alias,\n            value: value,\n            options: options,\n            dirname: dirname,\n            ownPass: ownPass,\n            file: file\n          });\n\n        case 31:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, _marked5);\n}\n\nfunction assertNoDuplicates(items) {\n  var map = new Map();\n\n  var _iterator = _createForOfIteratorHelper(items),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var item = _step.value;\n      if (typeof item.value !== \"function\") return \"continue\";\n      var nameMap = map.get(item.value);\n\n      if (!nameMap) {\n        nameMap = new Set();\n        map.set(item.value, nameMap);\n      }\n\n      if (nameMap.has(item.name)) {\n        var conflicts = items.filter(function (i) {\n          return i.value === item.value;\n        });\n        throw new Error([\"Duplicate plugin/preset detected.\", \"If you'd like to use two separate instances of a plugin,\", \"they need separate names, e.g.\", \"\", \"  plugins: [\", \"    ['some-plugin', {}],\", \"    ['some-plugin', {}, 'some unique name'],\", \"  ]\", \"\", \"Duplicates detected are:\", \"\".concat(JSON.stringify(conflicts, null, 2))].join(\"\\n\"));\n      }\n\n      nameMap.add(item.name);\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\n0 && 0;","map":{"version":3,"mappings":"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","names":["handlerOf","createPresetDescriptors","createPluginDescriptors","createDescriptors","createDescriptor","_gensync","isEqualDescriptor","a","b","name","value","options","dirname","alias","ownPass","file","request","resolved","optionsWithResolvedBrowserslistConfigFile","browserslistConfigFile","createCachedDescriptors","plugins","presets","passPerPreset","createCachedPluginDescriptors","createCachedPresetDescriptors","createUncachedDescriptors","PRESET_DESCRIPTOR_CACHE","WeakMap","items","cache","using","dir","descriptors","map","desc","loadCachedDescriptor","PLUGIN_DESCRIPTOR_CACHE","DEFAULT_OPTIONS","cacheByOptions","get","set","possibilities","indexOf","matches","filter","possibility","length","push","type","gensync","all","item","index","assertNoDuplicates","pair","Array","isArray","undefined","filepath","Error","resolver","loadPlugin","loadPreset","String","__esModule","default","Map","nameMap","Set","has","conflicts","i","JSON","stringify","join","add"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\config-descriptors.ts"],"sourcesContent":["import gensync, { type Handler } from \"gensync\";\nimport { once } from \"../gensync-utils/functional\";\n\nimport { loadPlugin, loadPreset } from \"./files\";\n\nimport { getItemDescriptor } from \"./item\";\n\nimport {\n  makeWeakCacheSync,\n  makeStrongCacheSync,\n  makeStrongCache,\n} from \"./caching\";\nimport type { CacheConfigurator } from \"./caching\";\n\nimport type {\n  ValidatedOptions,\n  PluginList,\n  PluginItem,\n} from \"./validation/options\";\n\nimport { resolveBrowserslistConfigFile } from \"./resolve-targets\";\n\n// Represents a config object and functions to lazily load the descriptors\n// for the plugins and presets so we don't load the plugins/presets unless\n// the options object actually ends up being applicable.\nexport type OptionsAndDescriptors = {\n  options: ValidatedOptions;\n  plugins: () => Handler<Array<UnloadedDescriptor>>;\n  presets: () => Handler<Array<UnloadedDescriptor>>;\n};\n\n// Represents a plugin or presets at a given location in a config object.\n// At this point these have been resolved to a specific object or function,\n// but have not yet been executed to call functions with options.\nexport type UnloadedDescriptor = {\n  name: string | undefined;\n  value: any | Function;\n  options: {} | undefined | false;\n  dirname: string;\n  alias: string;\n  ownPass?: boolean;\n  file?: {\n    request: string;\n    resolved: string;\n  };\n};\n\nfunction isEqualDescriptor(\n  a: UnloadedDescriptor,\n  b: UnloadedDescriptor,\n): boolean {\n  return (\n    a.name === b.name &&\n    a.value === b.value &&\n    a.options === b.options &&\n    a.dirname === b.dirname &&\n    a.alias === b.alias &&\n    a.ownPass === b.ownPass &&\n    (a.file && a.file.request) === (b.file && b.file.request) &&\n    (a.file && a.file.resolved) === (b.file && b.file.resolved)\n  );\n}\n\nexport type ValidatedFile = {\n  filepath: string;\n  dirname: string;\n  options: ValidatedOptions;\n};\n\n// eslint-disable-next-line require-yield\nfunction* handlerOf<T>(value: T): Handler<T> {\n  return value;\n}\n\nfunction optionsWithResolvedBrowserslistConfigFile(\n  options: ValidatedOptions,\n  dirname: string,\n): ValidatedOptions {\n  if (typeof options.browserslistConfigFile === \"string\") {\n    options.browserslistConfigFile = resolveBrowserslistConfigFile(\n      options.browserslistConfigFile,\n      dirname,\n    );\n  }\n  return options;\n}\n\n/**\n * Create a set of descriptors from a given options object, preserving\n * descriptor identity based on the identity of the plugin/preset arrays\n * themselves, and potentially on the identity of the plugins/presets + options.\n */\nexport function createCachedDescriptors(\n  dirname: string,\n  options: ValidatedOptions,\n  alias: string,\n): OptionsAndDescriptors {\n  const { plugins, presets, passPerPreset } = options;\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n    plugins: plugins\n      ? () =>\n          // @ts-expect-error todo(flow->ts) ts complains about incorrect arguments\n          createCachedPluginDescriptors(plugins, dirname)(alias)\n      : () => handlerOf([]),\n    presets: presets\n      ? () =>\n          // @ts-expect-error todo(flow->ts) ts complains about incorrect arguments\n          createCachedPresetDescriptors(presets, dirname)(alias)(\n            !!passPerPreset,\n          )\n      : () => handlerOf([]),\n  };\n}\n\n/**\n * Create a set of descriptors from a given options object, with consistent\n * identity for the descriptors, but not caching based on any specific identity.\n */\nexport function createUncachedDescriptors(\n  dirname: string,\n  options: ValidatedOptions,\n  alias: string,\n): OptionsAndDescriptors {\n  return {\n    options: optionsWithResolvedBrowserslistConfigFile(options, dirname),\n    // The returned result here is cached to represent a config object in\n    // memory, so we build and memoize the descriptors to ensure the same\n    // values are returned consistently.\n    plugins: once(() =>\n      createPluginDescriptors(options.plugins || [], dirname, alias),\n    ),\n    presets: once(() =>\n      createPresetDescriptors(\n        options.presets || [],\n        dirname,\n        alias,\n        !!options.passPerPreset,\n      ),\n    ),\n  };\n}\n\nconst PRESET_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPresetDescriptors = makeWeakCacheSync(\n  (items: PluginList, cache: CacheConfigurator<string>) => {\n    const dirname = cache.using(dir => dir);\n    return makeStrongCacheSync((alias: string) =>\n      makeStrongCache(function* (\n        passPerPreset: boolean,\n      ): Handler<Array<UnloadedDescriptor>> {\n        const descriptors = yield* createPresetDescriptors(\n          items,\n          dirname,\n          alias,\n          passPerPreset,\n        );\n        return descriptors.map(\n          // Items are cached using the overall preset array identity when\n          // possibly, but individual descriptors are also cached if a match\n          // can be found in the previously-used descriptor lists.\n          desc => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc),\n        );\n      }),\n    );\n  },\n);\n\nconst PLUGIN_DESCRIPTOR_CACHE = new WeakMap();\nconst createCachedPluginDescriptors = makeWeakCacheSync(\n  (items: PluginList, cache: CacheConfigurator<string>) => {\n    const dirname = cache.using(dir => dir);\n    return makeStrongCache(function* (\n      alias: string,\n    ): Handler<Array<UnloadedDescriptor>> {\n      const descriptors = yield* createPluginDescriptors(items, dirname, alias);\n      return descriptors.map(\n        // Items are cached using the overall plugin array identity when\n        // possibly, but individual descriptors are also cached if a match\n        // can be found in the previously-used descriptor lists.\n        desc => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc),\n      );\n    });\n  },\n);\n\n/**\n * When no options object is given in a descriptor, this object is used\n * as a WeakMap key in order to have consistent identity.\n */\nconst DEFAULT_OPTIONS = {};\n\n/**\n * Given the cache and a descriptor, returns a matching descriptor from the\n * cache, or else returns the input descriptor and adds it to the cache for\n * next time.\n */\nfunction loadCachedDescriptor(\n  cache: WeakMap<{} | Function, WeakMap<{}, Array<UnloadedDescriptor>>>,\n  desc: UnloadedDescriptor,\n) {\n  const { value, options = DEFAULT_OPTIONS } = desc;\n  if (options === false) return desc;\n\n  let cacheByOptions = cache.get(value);\n  if (!cacheByOptions) {\n    cacheByOptions = new WeakMap();\n    cache.set(value, cacheByOptions);\n  }\n\n  let possibilities = cacheByOptions.get(options);\n  if (!possibilities) {\n    possibilities = [];\n    cacheByOptions.set(options, possibilities);\n  }\n\n  if (possibilities.indexOf(desc) === -1) {\n    const matches = possibilities.filter(possibility =>\n      isEqualDescriptor(possibility, desc),\n    );\n    if (matches.length > 0) {\n      return matches[0];\n    }\n\n    possibilities.push(desc);\n  }\n\n  return desc;\n}\n\nfunction* createPresetDescriptors(\n  items: PluginList,\n  dirname: string,\n  alias: string,\n  passPerPreset: boolean,\n): Handler<Array<UnloadedDescriptor>> {\n  return yield* createDescriptors(\n    \"preset\",\n    items,\n    dirname,\n    alias,\n    passPerPreset,\n  );\n}\n\nfunction* createPluginDescriptors(\n  items: PluginList,\n  dirname: string,\n  alias: string,\n): Handler<Array<UnloadedDescriptor>> {\n  return yield* createDescriptors(\"plugin\", items, dirname, alias);\n}\n\nfunction* createDescriptors(\n  type: \"plugin\" | \"preset\",\n  items: PluginList,\n  dirname: string,\n  alias: string,\n  ownPass?: boolean,\n): Handler<Array<UnloadedDescriptor>> {\n  const descriptors = yield* gensync.all(\n    items.map((item, index) =>\n      createDescriptor(item, dirname, {\n        type,\n        alias: `${alias}$${index}`,\n        ownPass: !!ownPass,\n      }),\n    ),\n  );\n\n  assertNoDuplicates(descriptors);\n\n  return descriptors;\n}\n\n/**\n * Given a plugin/preset item, resolve it into a standard format.\n */\nexport function* createDescriptor(\n  pair: PluginItem,\n  dirname: string,\n  {\n    type,\n    alias,\n    ownPass,\n  }: {\n    type?: \"plugin\" | \"preset\";\n    alias: string;\n    ownPass?: boolean;\n  },\n): Handler<UnloadedDescriptor> {\n  const desc = getItemDescriptor(pair);\n  if (desc) {\n    return desc;\n  }\n\n  let name;\n  let options;\n  // todo(flow->ts) better type annotation\n  let value: any = pair;\n  if (Array.isArray(value)) {\n    if (value.length === 3) {\n      [value, options, name] = value;\n    } else {\n      [value, options] = value;\n    }\n  }\n\n  let file = undefined;\n  let filepath = null;\n  if (typeof value === \"string\") {\n    if (typeof type !== \"string\") {\n      throw new Error(\n        \"To resolve a string-based item, the type of item must be given\",\n      );\n    }\n    const resolver = type === \"plugin\" ? loadPlugin : loadPreset;\n    const request = value;\n\n    ({ filepath, value } = yield* resolver(value, dirname));\n\n    file = {\n      request,\n      resolved: filepath,\n    };\n  }\n\n  if (!value) {\n    throw new Error(`Unexpected falsy value: ${String(value)}`);\n  }\n\n  if (typeof value === \"object\" && value.__esModule) {\n    if (value.default) {\n      value = value.default;\n    } else {\n      throw new Error(\"Must export a default export when using ES6 modules.\");\n    }\n  }\n\n  if (typeof value !== \"object\" && typeof value !== \"function\") {\n    throw new Error(\n      `Unsupported format: ${typeof value}. Expected an object or a function.`,\n    );\n  }\n\n  if (filepath !== null && typeof value === \"object\" && value) {\n    // We allow object values for plugins/presets nested directly within a\n    // config object, because it can be useful to define them in nested\n    // configuration contexts.\n    throw new Error(\n      `Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`,\n    );\n  }\n\n  return {\n    name,\n    alias: filepath || alias,\n    value,\n    options,\n    dirname,\n    ownPass,\n    file,\n  };\n}\n\nfunction assertNoDuplicates(items: Array<UnloadedDescriptor>): void {\n  const map = new Map();\n\n  for (const item of items) {\n    if (typeof item.value !== \"function\") continue;\n\n    let nameMap = map.get(item.value);\n    if (!nameMap) {\n      nameMap = new Set();\n      map.set(item.value, nameMap);\n    }\n\n    if (nameMap.has(item.name)) {\n      const conflicts = items.filter(i => i.value === item.value);\n      throw new Error(\n        [\n          `Duplicate plugin/preset detected.`,\n          `If you'd like to use two separate instances of a plugin,`,\n          `they need separate names, e.g.`,\n          ``,\n          `  plugins: [`,\n          `    ['some-plugin', {}],`,\n          `    ['some-plugin', {}, 'some unique name'],`,\n          `  ]`,\n          ``,\n          `Duplicates detected are:`,\n          `${JSON.stringify(conflicts, null, 2)}`,\n        ].join(\"\\n\"),\n      );\n    }\n\n    nameMap.add(item.name);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}