{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = wrapFunction;\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _template = require(\"@babel/template\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  blockStatement,\n  callExpression,\n  functionExpression,\n  isAssignmentPattern,\n  isFunctionDeclaration,\n  isRestElement,\n  returnStatement\n} = _t;\n\nconst buildAnonymousExpressionWrapper = _template.default.expression(`\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n`);\n\nconst buildNamedExpressionWrapper = _template.default.expression(`\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n`);\n\nconst buildDeclarationWrapper = _template.default.statements(`\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n`);\n\nfunction classOrObjectMethod(path, callId) {\n  const node = path.node;\n  const body = node.body;\n  const container = functionExpression(null, [], blockStatement(body.body), true);\n  body.body = [returnStatement(callExpression(callExpression(callId, [container]), []))];\n  node.async = false;\n  node.generator = false;\n  path.get(\"body.body.0.argument.callee.arguments.0\").unwrapFunctionEnvironment();\n}\n\nfunction plainFunction(path, callId, noNewArrows, ignoreFunctionLength) {\n  let functionId = null;\n  let node;\n\n  if (path.isArrowFunctionExpression()) {\n    {\n      var _path$arrowFunctionTo;\n\n      path = (_path$arrowFunctionTo = path.arrowFunctionToExpression({\n        noNewArrows\n      })) != null ? _path$arrowFunctionTo : path;\n    }\n    node = path.node;\n  } else {\n    node = path.node;\n  }\n\n  const isDeclaration = isFunctionDeclaration(node);\n  functionId = node.id;\n  node.id = null;\n  node.type = \"FunctionExpression\";\n  const built = callExpression(callId, [node]);\n  const params = [];\n\n  for (const param of node.params) {\n    if (isAssignmentPattern(param) || isRestElement(param)) {\n      break;\n    }\n\n    params.push(path.scope.generateUidIdentifier(\"x\"));\n  }\n\n  const wrapperArgs = {\n    NAME: functionId || null,\n    REF: path.scope.generateUidIdentifier(functionId ? functionId.name : \"ref\"),\n    FUNCTION: built,\n    PARAMS: params\n  };\n\n  if (isDeclaration) {\n    const container = buildDeclarationWrapper(wrapperArgs);\n    path.replaceWith(container[0]);\n    path.insertAfter(container[1]);\n  } else {\n    let container;\n\n    if (functionId) {\n      container = buildNamedExpressionWrapper(wrapperArgs);\n    } else {\n      container = buildAnonymousExpressionWrapper(wrapperArgs);\n      const returnFn = container.callee.body.body[1].argument;\n      (0, _helperFunctionName.default)({\n        node: returnFn,\n        parent: path.parent,\n        scope: path.scope\n      });\n      functionId = returnFn.id;\n    }\n\n    if (functionId || !ignoreFunctionLength && params.length) {\n      path.replaceWith(container);\n    } else {\n      path.replaceWith(built);\n    }\n  }\n}\n\nfunction wrapFunction(path, callId) {\n  let noNewArrows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let ignoreFunctionLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (path.isMethod()) {\n    classOrObjectMethod(path, callId);\n  } else {\n    plainFunction(path, callId, noNewArrows, ignoreFunctionLength);\n  }\n}","map":{"version":3,"mappings":"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","names":["blockStatement","callExpression","functionExpression","isAssignmentPattern","isFunctionDeclaration","isRestElement","returnStatement","buildAnonymousExpressionWrapper","template","expression","buildNamedExpressionWrapper","buildDeclarationWrapper","statements","classOrObjectMethod","path","callId","node","body","container","async","generator","get","unwrapFunctionEnvironment","plainFunction","noNewArrows","ignoreFunctionLength","functionId","isArrowFunctionExpression","arrowFunctionToExpression","isDeclaration","id","type","built","params","param","push","scope","generateUidIdentifier","wrapperArgs","NAME","REF","name","FUNCTION","PARAMS","replaceWith","insertAfter","returnFn","callee","argument","parent","length","wrapFunction","isMethod"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-wrap-function\\src\\index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport template from \"@babel/template\";\nimport {\n  blockStatement,\n  callExpression,\n  functionExpression,\n  isAssignmentPattern,\n  isFunctionDeclaration,\n  isRestElement,\n  returnStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\ntype ExpressionWrapperBuilder<ExtraBody extends t.Node[]> = (\n  replacements?: Parameters<ReturnType<typeof template.expression>>[0],\n) => t.CallExpression & {\n  callee: t.FunctionExpression & {\n    body: {\n      body: [\n        t.VariableDeclaration & {\n          declarations: [\n            { init: t.FunctionExpression | t.ArrowFunctionExpression },\n          ];\n        },\n        ...ExtraBody,\n      ];\n    };\n  };\n};\n\nconst buildAnonymousExpressionWrapper = template.expression(`\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n`) as ExpressionWrapperBuilder<\n  [t.ReturnStatement & { argument: t.FunctionExpression }]\n>;\n\nconst buildNamedExpressionWrapper = template.expression(`\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n`) as ExpressionWrapperBuilder<\n  [t.FunctionDeclaration, t.ReturnStatement & { argument: t.Identifier }]\n>;\n\nconst buildDeclarationWrapper = template.statements(`\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n`);\n\nfunction classOrObjectMethod(\n  path: NodePath<t.ClassMethod | t.ClassPrivateMethod | t.ObjectMethod>,\n  callId: t.Expression,\n) {\n  const node = path.node;\n  const body = node.body;\n\n  const container = functionExpression(\n    null,\n    [],\n    blockStatement(body.body),\n    true,\n  );\n  body.body = [\n    returnStatement(callExpression(callExpression(callId, [container]), [])),\n  ];\n\n  // Regardless of whether or not the wrapped function is a an async method\n  // or generator the outer function should not be\n  node.async = false;\n  node.generator = false;\n\n  // Unwrap the wrapper IIFE's environment so super and this and such still work.\n  (\n    path.get(\"body.body.0.argument.callee.arguments.0\") as NodePath\n  ).unwrapFunctionEnvironment();\n}\n\nfunction plainFunction(\n  path: NodePath<Exclude<t.Function, t.Method>>,\n  callId: t.Expression,\n  noNewArrows: boolean,\n  ignoreFunctionLength: boolean,\n) {\n  let functionId = null;\n  let node;\n  if (path.isArrowFunctionExpression()) {\n    if (process.env.BABEL_8_BREAKING) {\n      path = path.arrowFunctionToExpression({ noNewArrows });\n    } else {\n      // arrowFunctionToExpression returns undefined in @babel/traverse < 7.18.10\n      path = path.arrowFunctionToExpression({ noNewArrows }) ?? path;\n    }\n    node = path.node as t.FunctionDeclaration | t.FunctionExpression;\n  } else {\n    node = path.node as t.FunctionDeclaration | t.FunctionExpression;\n  }\n\n  const isDeclaration = isFunctionDeclaration(node);\n\n  functionId = node.id;\n  node.id = null;\n  node.type = \"FunctionExpression\";\n\n  const built = callExpression(callId, [\n    node as Exclude<typeof node, t.FunctionDeclaration>,\n  ]);\n\n  const params: t.Identifier[] = [];\n  for (const param of node.params) {\n    if (isAssignmentPattern(param) || isRestElement(param)) {\n      break;\n    }\n    params.push(path.scope.generateUidIdentifier(\"x\"));\n  }\n\n  const wrapperArgs = {\n    NAME: functionId || null,\n    REF: path.scope.generateUidIdentifier(functionId ? functionId.name : \"ref\"),\n    FUNCTION: built,\n    PARAMS: params,\n  };\n\n  if (isDeclaration) {\n    const container = buildDeclarationWrapper(wrapperArgs);\n    path.replaceWith(container[0]);\n    path.insertAfter(container[1]);\n  } else {\n    let container;\n\n    if (functionId) {\n      container = buildNamedExpressionWrapper(wrapperArgs);\n    } else {\n      container = buildAnonymousExpressionWrapper(wrapperArgs);\n\n      const returnFn = container.callee.body.body[1].argument;\n      nameFunction({\n        node: returnFn,\n        parent: (path as NodePath<t.FunctionExpression>).parent,\n        scope: path.scope,\n      });\n      functionId = returnFn.id;\n    }\n\n    if (functionId || (!ignoreFunctionLength && params.length)) {\n      path.replaceWith(container);\n    } else {\n      // we can omit this wrapper as the conditions it protects for do not apply\n      path.replaceWith(built);\n    }\n  }\n}\n\nexport default function wrapFunction(\n  path: NodePath<t.Function>,\n  callId: t.Expression,\n  // TODO(Babel 8): Consider defaulting to false for spec compliancy\n  noNewArrows: boolean = true,\n  ignoreFunctionLength: boolean = false,\n) {\n  if (path.isMethod()) {\n    classOrObjectMethod(path, callId);\n  } else {\n    plainFunction(\n      path as NodePath<Exclude<t.Function, t.Method>>,\n      callId,\n      noNewArrows,\n      ignoreFunctionLength,\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script"}