{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, // DISABLE_TOUCH = TRUE\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\"default\", {\n  enumerable: true,\n  get: () => setupTrackingContext\n});\n\nconst _fs = /*#__PURE__*/_interopRequireDefault(require(\"fs\"));\n\nconst _path = /*#__PURE__*/_interopRequireDefault(require(\"path\"));\n\nconst _fastGlob = /*#__PURE__*/_interopRequireDefault(require(\"fast-glob\"));\n\nconst _quickLru = /*#__PURE__*/_interopRequireDefault(require(\"quick-lru\"));\n\nconst _normalizePath = /*#__PURE__*/_interopRequireDefault(require(\"normalize-path\"));\n\nconst _hashConfig = /*#__PURE__*/_interopRequireDefault(require(\"../util/hashConfig\"));\n\nconst _getModuleDependencies = /*#__PURE__*/_interopRequireDefault(require(\"../lib/getModuleDependencies\"));\n\nconst _resolveConfig = /*#__PURE__*/_interopRequireDefault(require(\"../public/resolve-config\"));\n\nconst _resolveConfigPath = /*#__PURE__*/_interopRequireDefault(require(\"../util/resolveConfigPath\"));\n\nconst _sharedState = require(\"./sharedState\");\n\nconst _setupContextUtils = require(\"./setupContextUtils\");\n\nconst _parseDependency = /*#__PURE__*/_interopRequireDefault(require(\"../util/parseDependency\"));\n\nconst _validateConfigJs = require(\"../util/validateConfig.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nlet configPathCache = new _quickLru.default({\n  maxSize: 100\n});\nlet candidateFilesCache = new WeakMap();\n\nfunction getCandidateFiles(context, tailwindConfig) {\n  if (candidateFilesCache.has(context)) {\n    return candidateFilesCache.get(context);\n  }\n\n  let candidateFiles = tailwindConfig.content.files.filter(item => typeof item === \"string\").map(contentPath => (0, _normalizePath.default)(contentPath));\n  return candidateFilesCache.set(context, candidateFiles).get(context);\n} // Get the config object based on a path\n\n\nfunction getTailwindConfig(configOrPath) {\n  let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\n\n  if (userConfigPath !== null) {\n    let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];\n    let newDeps = (0, _getModuleDependencies.default)(userConfigPath).map(dep => dep.file);\n    let modified = false;\n    let newModified = new Map();\n\n    for (let file of newDeps) {\n      let time = _fs.default.statSync(file).mtimeMs;\n\n      newModified.set(file, time);\n\n      if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n        modified = true;\n      }\n    } // It hasn't changed (based on timestamps)\n\n\n    if (!modified) {\n      return [prevConfig, userConfigPath, prevConfigHash, prevDeps];\n    } // It has changed (based on timestamps), or first run\n\n\n    for (let file1 of newDeps) {\n      delete require.cache[file1];\n    }\n\n    let newConfig = (0, _resolveConfig.default)(require(userConfigPath));\n    newConfig = (0, _validateConfigJs.validateConfig)(newConfig);\n    let newHash = (0, _hashConfig.default)(newConfig);\n    configPathCache.set(userConfigPath, [newConfig, newHash, newDeps, newModified]);\n    return [newConfig, userConfigPath, newHash, newDeps];\n  } // It's a plain object, not a path\n\n\n  let newConfig1 = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n  newConfig1 = (0, _validateConfigJs.validateConfig)(newConfig1);\n  return [newConfig1, null, (0, _hashConfig.default)(newConfig1), []];\n}\n\nfunction resolvedChangedContent(context, candidateFiles, fileModifiedMap) {\n  let changedContent = context.tailwindConfig.content.files.filter(item => typeof item.raw === \"string\").map(_ref => {\n    let {\n      raw,\n      extension = \"html\"\n    } = _ref;\n    return {\n      content: raw,\n      extension\n    };\n  });\n\n  for (let changedFile of resolveChangedFiles(candidateFiles, fileModifiedMap)) {\n    let content = _fs.default.readFileSync(changedFile, \"utf8\");\n\n    let extension = _path.default.extname(changedFile).slice(1);\n\n    changedContent.push({\n      content,\n      extension\n    });\n  }\n\n  return changedContent;\n}\n\nfunction resolveChangedFiles(candidateFiles, fileModifiedMap) {\n  let changedFiles = new Set();\n  _sharedState.env.DEBUG && console.time(\"Finding changed files\");\n\n  let files = _fastGlob.default.sync(candidateFiles);\n\n  for (let file of files) {\n    let prevModified = fileModifiedMap.has(file) ? fileModifiedMap.get(file) : -Infinity;\n\n    let modified = _fs.default.statSync(file).mtimeMs;\n\n    if (modified > prevModified) {\n      changedFiles.add(file);\n      fileModifiedMap.set(file, modified);\n    }\n  }\n\n  _sharedState.env.DEBUG && console.timeEnd(\"Finding changed files\");\n  return changedFiles;\n}\n\nfunction setupTrackingContext(configOrPath) {\n  return _ref2 => {\n    let {\n      tailwindDirectives,\n      registerDependency\n    } = _ref2;\n    return (root, result) => {\n      let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n      let contextDependencies = new Set(configDependencies); // If there are no @tailwind or @apply rules, we don't consider this CSS\n      // file or its dependencies to be dependencies of the context. Can reuse\n      // the context even if they change. We may want to think about `@layer`\n      // being part of this trigger too, but it's tough because it's impossible\n      // for a layer in one file to end up in the actual @tailwind rule in\n      // another file since independent sources are effectively isolated.\n\n      if (tailwindDirectives.size > 0) {\n        // Add current css file as a context dependencies.\n        contextDependencies.add(result.opts.from); // Add all css @import dependencies as context dependencies.\n\n        for (let message of result.messages) {\n          if (message.type === \"dependency\") {\n            contextDependencies.add(message.file);\n          }\n        }\n      }\n\n      let [context] = (0, _setupContextUtils.getContext)(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n      let candidateFiles = getCandidateFiles(context, tailwindConfig); // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's\n      // dependencies to be dependencies of the context. Can reuse the context even if they change.\n      // We may want to think about `@layer` being part of this trigger too, but it's tough\n      // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n      // in another file since independent sources are effectively isolated.\n\n      if (tailwindDirectives.size > 0) {\n        let fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context); // Add template paths as postcss dependencies.\n\n        for (let fileOrGlob of candidateFiles) {\n          let dependency = (0, _parseDependency.default)(fileOrGlob);\n\n          if (dependency) {\n            registerDependency(dependency);\n          }\n        }\n\n        for (let changedContent of resolvedChangedContent(context, candidateFiles, fileModifiedMap)) {\n          context.changedContent.push(changedContent);\n        }\n      }\n\n      for (let file of configDependencies) {\n        registerDependency({\n          type: \"dependency\",\n          file\n        });\n      }\n\n      return context;\n    };\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","setupTrackingContext","_fs","_interopRequireDefault","require","_path","_fastGlob","_quickLru","_normalizePath","_hashConfig","_getModuleDependencies","_resolveConfig","_resolveConfigPath","_sharedState","_setupContextUtils","_parseDependency","_validateConfigJs","obj","__esModule","default","configPathCache","maxSize","candidateFilesCache","WeakMap","getCandidateFiles","context","tailwindConfig","has","candidateFiles","content","files","filter","item","map","contentPath","set","getTailwindConfig","configOrPath","userConfigPath","prevConfig","prevConfigHash","prevDeps","prevModified","newDeps","dep","file","modified","newModified","Map","time","statSync","mtimeMs","file1","cache","newConfig","validateConfig","newHash","newConfig1","config","undefined","resolvedChangedContent","fileModifiedMap","changedContent","raw","extension","changedFile","resolveChangedFiles","readFileSync","extname","slice","push","changedFiles","Set","env","DEBUG","console","sync","Infinity","add","timeEnd","tailwindDirectives","registerDependency","root","result","tailwindConfigHash","configDependencies","contextDependencies","size","opts","from","message","messages","type","getContext","getFileModifiedMap","fileOrGlob","dependency"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/lib/lib/setupTrackingContext.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, // DISABLE_TOUCH = TRUE\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\"default\", {\n    enumerable: true,\n    get: ()=>setupTrackingContext\n});\nconst _fs = /*#__PURE__*/ _interopRequireDefault(require(\"fs\"));\nconst _path = /*#__PURE__*/ _interopRequireDefault(require(\"path\"));\nconst _fastGlob = /*#__PURE__*/ _interopRequireDefault(require(\"fast-glob\"));\nconst _quickLru = /*#__PURE__*/ _interopRequireDefault(require(\"quick-lru\"));\nconst _normalizePath = /*#__PURE__*/ _interopRequireDefault(require(\"normalize-path\"));\nconst _hashConfig = /*#__PURE__*/ _interopRequireDefault(require(\"../util/hashConfig\"));\nconst _getModuleDependencies = /*#__PURE__*/ _interopRequireDefault(require(\"../lib/getModuleDependencies\"));\nconst _resolveConfig = /*#__PURE__*/ _interopRequireDefault(require(\"../public/resolve-config\"));\nconst _resolveConfigPath = /*#__PURE__*/ _interopRequireDefault(require(\"../util/resolveConfigPath\"));\nconst _sharedState = require(\"./sharedState\");\nconst _setupContextUtils = require(\"./setupContextUtils\");\nconst _parseDependency = /*#__PURE__*/ _interopRequireDefault(require(\"../util/parseDependency\"));\nconst _validateConfigJs = require(\"../util/validateConfig.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nlet configPathCache = new _quickLru.default({\n    maxSize: 100\n});\nlet candidateFilesCache = new WeakMap();\nfunction getCandidateFiles(context, tailwindConfig) {\n    if (candidateFilesCache.has(context)) {\n        return candidateFilesCache.get(context);\n    }\n    let candidateFiles = tailwindConfig.content.files.filter((item)=>typeof item === \"string\").map((contentPath)=>(0, _normalizePath.default)(contentPath));\n    return candidateFilesCache.set(context, candidateFiles).get(context);\n}\n// Get the config object based on a path\nfunction getTailwindConfig(configOrPath) {\n    let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\n    if (userConfigPath !== null) {\n        let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];\n        let newDeps = (0, _getModuleDependencies.default)(userConfigPath).map((dep)=>dep.file);\n        let modified = false;\n        let newModified = new Map();\n        for (let file of newDeps){\n            let time = _fs.default.statSync(file).mtimeMs;\n            newModified.set(file, time);\n            if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n                modified = true;\n            }\n        }\n        // It hasn't changed (based on timestamps)\n        if (!modified) {\n            return [\n                prevConfig,\n                userConfigPath,\n                prevConfigHash,\n                prevDeps\n            ];\n        }\n        // It has changed (based on timestamps), or first run\n        for (let file1 of newDeps){\n            delete require.cache[file1];\n        }\n        let newConfig = (0, _resolveConfig.default)(require(userConfigPath));\n        newConfig = (0, _validateConfigJs.validateConfig)(newConfig);\n        let newHash = (0, _hashConfig.default)(newConfig);\n        configPathCache.set(userConfigPath, [\n            newConfig,\n            newHash,\n            newDeps,\n            newModified\n        ]);\n        return [\n            newConfig,\n            userConfigPath,\n            newHash,\n            newDeps\n        ];\n    }\n    // It's a plain object, not a path\n    let newConfig1 = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n    newConfig1 = (0, _validateConfigJs.validateConfig)(newConfig1);\n    return [\n        newConfig1,\n        null,\n        (0, _hashConfig.default)(newConfig1),\n        []\n    ];\n}\nfunction resolvedChangedContent(context, candidateFiles, fileModifiedMap) {\n    let changedContent = context.tailwindConfig.content.files.filter((item)=>typeof item.raw === \"string\").map(({ raw , extension =\"html\"  })=>({\n            content: raw,\n            extension\n        }));\n    for (let changedFile of resolveChangedFiles(candidateFiles, fileModifiedMap)){\n        let content = _fs.default.readFileSync(changedFile, \"utf8\");\n        let extension = _path.default.extname(changedFile).slice(1);\n        changedContent.push({\n            content,\n            extension\n        });\n    }\n    return changedContent;\n}\nfunction resolveChangedFiles(candidateFiles, fileModifiedMap) {\n    let changedFiles = new Set();\n    _sharedState.env.DEBUG && console.time(\"Finding changed files\");\n    let files = _fastGlob.default.sync(candidateFiles);\n    for (let file of files){\n        let prevModified = fileModifiedMap.has(file) ? fileModifiedMap.get(file) : -Infinity;\n        let modified = _fs.default.statSync(file).mtimeMs;\n        if (modified > prevModified) {\n            changedFiles.add(file);\n            fileModifiedMap.set(file, modified);\n        }\n    }\n    _sharedState.env.DEBUG && console.timeEnd(\"Finding changed files\");\n    return changedFiles;\n}\nfunction setupTrackingContext(configOrPath) {\n    return ({ tailwindDirectives , registerDependency  })=>{\n        return (root, result)=>{\n            let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n            let contextDependencies = new Set(configDependencies);\n            // If there are no @tailwind or @apply rules, we don't consider this CSS\n            // file or its dependencies to be dependencies of the context. Can reuse\n            // the context even if they change. We may want to think about `@layer`\n            // being part of this trigger too, but it's tough because it's impossible\n            // for a layer in one file to end up in the actual @tailwind rule in\n            // another file since independent sources are effectively isolated.\n            if (tailwindDirectives.size > 0) {\n                // Add current css file as a context dependencies.\n                contextDependencies.add(result.opts.from);\n                // Add all css @import dependencies as context dependencies.\n                for (let message of result.messages){\n                    if (message.type === \"dependency\") {\n                        contextDependencies.add(message.file);\n                    }\n                }\n            }\n            let [context] = (0, _setupContextUtils.getContext)(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n            let candidateFiles = getCandidateFiles(context, tailwindConfig);\n            // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's\n            // dependencies to be dependencies of the context. Can reuse the context even if they change.\n            // We may want to think about `@layer` being part of this trigger too, but it's tough\n            // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n            // in another file since independent sources are effectively isolated.\n            if (tailwindDirectives.size > 0) {\n                let fileModifiedMap = (0, _setupContextUtils.getFileModifiedMap)(context);\n                // Add template paths as postcss dependencies.\n                for (let fileOrGlob of candidateFiles){\n                    let dependency = (0, _parseDependency.default)(fileOrGlob);\n                    if (dependency) {\n                        registerDependency(dependency);\n                    }\n                }\n                for (let changedContent of resolvedChangedContent(context, candidateFiles, fileModifiedMap)){\n                    context.changedContent.push(changedContent);\n                }\n            }\n            for (let file of configDependencies){\n                registerDependency({\n                    type: \"dependency\",\n                    file\n                });\n            }\n            return context;\n        };\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}