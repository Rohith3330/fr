{"ast":null,"code":"\"use strict\";\n\nconst path = require(\"path\");\n\nconst getHashDigest = require(\"./getHashDigest\");\n\nfunction interpolateName(loaderContext, name) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let filename;\n  const hasQuery = loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;\n\n  if (typeof name === \"function\") {\n    filename = name(loaderContext.resourcePath, hasQuery ? loaderContext.resourceQuery : undefined);\n  } else {\n    filename = name || \"[hash].[ext]\";\n  }\n\n  const context = options.context;\n  const content = options.content;\n  const regExp = options.regExp;\n  let ext = \"bin\";\n  let basename = \"file\";\n  let directory = \"\";\n  let folder = \"\";\n  let query = \"\";\n\n  if (loaderContext.resourcePath) {\n    const parsed = path.parse(loaderContext.resourcePath);\n    let resourcePath = loaderContext.resourcePath;\n\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path.sep;\n    }\n\n    if (typeof context !== \"undefined\") {\n      directory = path.relative(context, resourcePath + \"_\").replace(/\\\\/g, \"/\").replace(/\\.\\.(\\/)?/g, \"_$1\");\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, \"/\").replace(/\\.\\.(\\/)?/g, \"_$1\");\n    }\n\n    if (directory.length === 1) {\n      directory = \"\";\n    } else if (directory.length > 1) {\n      folder = path.basename(directory);\n    }\n  }\n\n  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {\n    query = loaderContext.resourceQuery;\n    const hashIdx = query.indexOf(\"#\");\n\n    if (hashIdx >= 0) {\n      query = query.substr(0, hashIdx);\n    }\n  }\n\n  let url = filename;\n\n  if (content) {\n    // Match hash template\n    url = url // `hash` and `contenthash` are same in `loader-utils` context\n    // let's keep `hash` for backward compatibility\n    .replace(/\\[(?:([^:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi, (all, hashType, digestType, maxLength) => getHashDigest(content, hashType, digestType, parseInt(maxLength, 10)));\n  }\n\n  url = url.replace(/\\[ext\\]/gi, () => ext).replace(/\\[name\\]/gi, () => basename).replace(/\\[path\\]/gi, () => directory).replace(/\\[folder\\]/gi, () => folder).replace(/\\[query\\]/gi, () => query);\n\n  if (regExp && loaderContext.resourcePath) {\n    const match = loaderContext.resourcePath.match(new RegExp(regExp));\n    match && match.forEach((matched, i) => {\n      url = url.replace(new RegExp(\"\\\\[\" + i + \"\\\\]\", \"ig\"), matched);\n    });\n  }\n\n  if (typeof loaderContext.options === \"object\" && typeof loaderContext.options.customInterpolateName === \"function\") {\n    url = loaderContext.options.customInterpolateName.call(loaderContext, url, name, options);\n  }\n\n  return url;\n}\n\nmodule.exports = interpolateName;","map":{"version":3,"names":["path","require","getHashDigest","interpolateName","loaderContext","name","options","filename","hasQuery","resourceQuery","length","resourcePath","undefined","context","content","regExp","ext","basename","directory","folder","query","parsed","parse","substr","dir","sep","relative","replace","hashIdx","indexOf","url","all","hashType","digestType","maxLength","parseInt","match","RegExp","forEach","matched","i","customInterpolateName","call","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/react-dev-utils/node_modules/loader-utils/lib/interpolateName.js"],"sourcesContent":["\"use strict\";\n\nconst path = require(\"path\");\nconst getHashDigest = require(\"./getHashDigest\");\n\nfunction interpolateName(loaderContext, name, options = {}) {\n  let filename;\n\n  const hasQuery =\n    loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;\n\n  if (typeof name === \"function\") {\n    filename = name(\n      loaderContext.resourcePath,\n      hasQuery ? loaderContext.resourceQuery : undefined\n    );\n  } else {\n    filename = name || \"[hash].[ext]\";\n  }\n\n  const context = options.context;\n  const content = options.content;\n  const regExp = options.regExp;\n\n  let ext = \"bin\";\n  let basename = \"file\";\n  let directory = \"\";\n  let folder = \"\";\n  let query = \"\";\n\n  if (loaderContext.resourcePath) {\n    const parsed = path.parse(loaderContext.resourcePath);\n    let resourcePath = loaderContext.resourcePath;\n\n    if (parsed.ext) {\n      ext = parsed.ext.substr(1);\n    }\n\n    if (parsed.dir) {\n      basename = parsed.name;\n      resourcePath = parsed.dir + path.sep;\n    }\n\n    if (typeof context !== \"undefined\") {\n      directory = path\n        .relative(context, resourcePath + \"_\")\n        .replace(/\\\\/g, \"/\")\n        .replace(/\\.\\.(\\/)?/g, \"_$1\");\n      directory = directory.substr(0, directory.length - 1);\n    } else {\n      directory = resourcePath.replace(/\\\\/g, \"/\").replace(/\\.\\.(\\/)?/g, \"_$1\");\n    }\n\n    if (directory.length === 1) {\n      directory = \"\";\n    } else if (directory.length > 1) {\n      folder = path.basename(directory);\n    }\n  }\n\n  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {\n    query = loaderContext.resourceQuery;\n\n    const hashIdx = query.indexOf(\"#\");\n\n    if (hashIdx >= 0) {\n      query = query.substr(0, hashIdx);\n    }\n  }\n\n  let url = filename;\n\n  if (content) {\n    // Match hash template\n    url = url\n      // `hash` and `contenthash` are same in `loader-utils` context\n      // let's keep `hash` for backward compatibility\n      .replace(\n        /\\[(?:([^:\\]]+):)?(?:hash|contenthash)(?::([a-z]+\\d*))?(?::(\\d+))?\\]/gi,\n        (all, hashType, digestType, maxLength) =>\n          getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))\n      );\n  }\n\n  url = url\n    .replace(/\\[ext\\]/gi, () => ext)\n    .replace(/\\[name\\]/gi, () => basename)\n    .replace(/\\[path\\]/gi, () => directory)\n    .replace(/\\[folder\\]/gi, () => folder)\n    .replace(/\\[query\\]/gi, () => query);\n\n  if (regExp && loaderContext.resourcePath) {\n    const match = loaderContext.resourcePath.match(new RegExp(regExp));\n\n    match &&\n      match.forEach((matched, i) => {\n        url = url.replace(new RegExp(\"\\\\[\" + i + \"\\\\]\", \"ig\"), matched);\n      });\n  }\n\n  if (\n    typeof loaderContext.options === \"object\" &&\n    typeof loaderContext.options.customInterpolateName === \"function\"\n  ) {\n    url = loaderContext.options.customInterpolateName.call(\n      loaderContext,\n      url,\n      name,\n      options\n    );\n  }\n\n  return url;\n}\n\nmodule.exports = interpolateName;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}