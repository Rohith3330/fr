{"ast":null,"code":"const definitions = require(\"../src/definitions\");\n\nconst flatMap = require(\"array.prototype.flatmap\");\n\nconst {\n  typeSignature,\n  iterateProps,\n  mapProps,\n  filterProps,\n  unique\n} = require(\"./util\");\n\nconst stdout = process.stdout;\nconst jsTypes = [\"string\", \"number\", \"boolean\"];\n\nconst quote = value => `\"${value}\"`;\n\nfunction params(fields) {\n  const optionalDefault = field => field.default ? ` = ${field.default}` : \"\";\n\n  return mapProps(fields).map(field => `${typeSignature(field)}${optionalDefault(field)}`).join(\",\");\n}\n\nfunction assertParamType(_ref) {\n  let {\n    assertNodeType,\n    array,\n    name,\n    type\n  } = _ref;\n\n  if (array) {\n    // TODO - assert contents of array?\n    return `assert(typeof ${name} === \"object\" && typeof ${name}.length !== \"undefined\")\\n`;\n  } else {\n    if (jsTypes.includes(type)) {\n      return `assert(\n          typeof ${name} === \"${type}\",\n          \"Argument ${name} must be of type ${type}, given: \" + typeof ${name}\n      )`;\n    }\n\n    if (assertNodeType === true) {\n      return `assert(\n        ${name}.type === \"${type}\",\n        \"Argument ${name} must be of type ${type}, given: \" + ${name}.type\n      )`;\n    }\n\n    return \"\";\n  }\n}\n\nfunction assertParam(meta) {\n  const paramAssertion = assertParamType(meta);\n\n  if (paramAssertion === \"\") {\n    return \"\";\n  }\n\n  if (meta.maybe || meta.optional) {\n    return `\n      if (${meta.name} !== null && ${meta.name} !== undefined) {\n        ${paramAssertion};\n      }\n    `;\n  } else {\n    return paramAssertion;\n  }\n}\n\nfunction assertParams(fields) {\n  return mapProps(fields).map(assertParam).join(\"\\n\");\n}\n\nfunction buildObject(typeDef) {\n  const optionalField = meta => {\n    if (meta.array) {\n      // omit optional array properties if the constructor function was supplied\n      // with an empty array\n      return `\n        if (typeof ${meta.name} !== \"undefined\" && ${meta.name}.length > 0) {\n          node.${meta.name} = ${meta.name};\n        }\n      `;\n    } else if (meta.type === \"Object\") {\n      // omit optional object properties if they have no keys\n      return `\n        if (typeof ${meta.name} !== \"undefined\" && Object.keys(${meta.name}).length !== 0) {\n          node.${meta.name} = ${meta.name};\n        }\n      `;\n    } else if (meta.type === \"boolean\") {\n      // omit optional boolean properties if they are not true\n      return `\n        if (${meta.name} === true) {\n          node.${meta.name} = true;\n        }\n      `;\n    } else {\n      return `\n        if (typeof ${meta.name} !== \"undefined\") {\n          node.${meta.name} = ${meta.name};\n        }\n      `;\n    }\n  };\n\n  const fields = mapProps(typeDef.fields).filter(f => !f.optional && !f.constant).map(f => f.name);\n  const constants = mapProps(typeDef.fields).filter(f => f.constant).map(f => `${f.name}: \"${f.value}\"`);\n  return `\n    const node: ${typeDef.flowTypeName || typeDef.name} = {\n      type: \"${typeDef.name}\",\n      ${constants.concat(fields).join(\",\")}\n    }\n\n    ${mapProps(typeDef.fields).filter(f => f.optional).map(optionalField).join(\"\")}\n  `;\n}\n\nfunction lowerCamelCase(name) {\n  return name.substring(0, 1).toLowerCase() + name.substring(1);\n}\n\nfunction generate() {\n  stdout.write(`\n    // @flow\n\n    // THIS FILE IS AUTOGENERATED\n    // see scripts/generateNodeUtils.js\n\n    import { assert } from \"mamacro\";\n\n    function isTypeOf(t: string) {\n      return (n: Node) => n.type === t;\n    }\n\n    function assertTypeOf(t: string) {\n      return (n: Node) => assert(n.type === t);\n    }\n  `); // Node builders\n\n  iterateProps(definitions, typeDefinition => {\n    stdout.write(`\n      export function ${lowerCamelCase(typeDefinition.name)} (\n        ${params(filterProps(typeDefinition.fields, f => !f.constant))}\n      ): ${typeDefinition.name} {\n\n        ${assertParams(filterProps(typeDefinition.fields, f => !f.constant))}\n        ${buildObject(typeDefinition)} \n\n        return node;\n      }\n    `);\n  }); // Node testers\n\n  iterateProps(definitions, typeDefinition => {\n    stdout.write(`\n      export const is${typeDefinition.name} =\n        isTypeOf(\"${typeDefinition.name}\");\n    `);\n  }); // Node union type testers\n\n  const unionTypes = unique(flatMap(mapProps(definitions).filter(d => d.unionType), d => d.unionType));\n  unionTypes.forEach(unionType => {\n    stdout.write(`\n      export const is${unionType} = (node: Node) => ` + mapProps(definitions).filter(d => d.unionType && d.unionType.includes(unionType)).map(d => `is${d.name}(node) `).join(\"||\") + \";\\n\\n\");\n  }); // Node assertion\n\n  iterateProps(definitions, typeDefinition => {\n    stdout.write(`\n      export const assert${typeDefinition.name} =\n        assertTypeOf(\"${typeDefinition.name}\");\n    `);\n  }); // a map from node type to its set of union types\n\n  stdout.write(`\n    export const unionTypesMap = {` + mapProps(definitions).filter(d => d.unionType).map(t => `\"${t.name}\": [${t.unionType.map(quote).join(\",\")}]\\n`) + `};\n      `); // an array of all node and union types\n\n  stdout.write(`\n    export const nodeAndUnionTypes = [` + mapProps(definitions).map(t => `\"${t.name}\"`).concat(unionTypes.map(quote)).join(\",\") + `];`);\n}\n\ngenerate();","map":{"version":3,"names":["definitions","require","flatMap","typeSignature","iterateProps","mapProps","filterProps","unique","stdout","process","jsTypes","quote","value","params","fields","optionalDefault","field","default","map","join","assertParamType","assertNodeType","array","name","type","includes","assertParam","meta","paramAssertion","maybe","optional","assertParams","buildObject","typeDef","optionalField","filter","f","constant","constants","flowTypeName","concat","lowerCamelCase","substring","toLowerCase","generate","write","typeDefinition","unionTypes","d","unionType","forEach","t"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@webassemblyjs/ast/scripts/generateNodeUtils.js"],"sourcesContent":["const definitions = require(\"../src/definitions\");\nconst flatMap = require(\"array.prototype.flatmap\");\nconst {\n  typeSignature,\n  iterateProps,\n  mapProps,\n  filterProps,\n  unique\n} = require(\"./util\");\n\nconst stdout = process.stdout;\n\nconst jsTypes = [\"string\", \"number\", \"boolean\"];\n\nconst quote = value => `\"${value}\"`;\n\nfunction params(fields) {\n  const optionalDefault = field => (field.default ? ` = ${field.default}` : \"\");\n  return mapProps(fields)\n    .map(field => `${typeSignature(field)}${optionalDefault(field)}`)\n    .join(\",\");\n}\n\nfunction assertParamType({ assertNodeType, array, name, type }) {\n  if (array) {\n    // TODO - assert contents of array?\n    return `assert(typeof ${name} === \"object\" && typeof ${name}.length !== \"undefined\")\\n`;\n  } else {\n    if (jsTypes.includes(type)) {\n      return `assert(\n          typeof ${name} === \"${type}\",\n          \"Argument ${name} must be of type ${type}, given: \" + typeof ${name}\n      )`;\n    }\n\n    if (assertNodeType === true) {\n      return `assert(\n        ${name}.type === \"${type}\",\n        \"Argument ${name} must be of type ${type}, given: \" + ${name}.type\n      )`;\n    }\n\n    return \"\";\n  }\n}\n\nfunction assertParam(meta) {\n  const paramAssertion = assertParamType(meta);\n\n  if (paramAssertion === \"\") {\n    return \"\";\n  }\n\n  if (meta.maybe || meta.optional) {\n    return `\n      if (${meta.name} !== null && ${meta.name} !== undefined) {\n        ${paramAssertion};\n      }\n    `;\n  } else {\n    return paramAssertion;\n  }\n}\n\nfunction assertParams(fields) {\n  return mapProps(fields)\n    .map(assertParam)\n    .join(\"\\n\");\n}\n\nfunction buildObject(typeDef) {\n  const optionalField = meta => {\n    if (meta.array) {\n      // omit optional array properties if the constructor function was supplied\n      // with an empty array\n      return `\n        if (typeof ${meta.name} !== \"undefined\" && ${meta.name}.length > 0) {\n          node.${meta.name} = ${meta.name};\n        }\n      `;\n    } else if (meta.type === \"Object\") {\n      // omit optional object properties if they have no keys\n      return `\n        if (typeof ${meta.name} !== \"undefined\" && Object.keys(${\n        meta.name\n      }).length !== 0) {\n          node.${meta.name} = ${meta.name};\n        }\n      `;\n    } else if (meta.type === \"boolean\") {\n      // omit optional boolean properties if they are not true\n      return `\n        if (${meta.name} === true) {\n          node.${meta.name} = true;\n        }\n      `;\n    } else {\n      return `\n        if (typeof ${meta.name} !== \"undefined\") {\n          node.${meta.name} = ${meta.name};\n        }\n      `;\n    }\n  };\n\n  const fields = mapProps(typeDef.fields)\n    .filter(f => !f.optional && !f.constant)\n    .map(f => f.name);\n\n  const constants = mapProps(typeDef.fields)\n    .filter(f => f.constant)\n    .map(f => `${f.name}: \"${f.value}\"`);\n\n  return `\n    const node: ${typeDef.flowTypeName || typeDef.name} = {\n      type: \"${typeDef.name}\",\n      ${constants.concat(fields).join(\",\")}\n    }\n\n    ${mapProps(typeDef.fields)\n      .filter(f => f.optional)\n      .map(optionalField)\n      .join(\"\")}\n  `;\n}\n\nfunction lowerCamelCase(name) {\n  return name.substring(0, 1).toLowerCase() + name.substring(1);\n}\n\nfunction generate() {\n  stdout.write(`\n    // @flow\n\n    // THIS FILE IS AUTOGENERATED\n    // see scripts/generateNodeUtils.js\n\n    import { assert } from \"mamacro\";\n\n    function isTypeOf(t: string) {\n      return (n: Node) => n.type === t;\n    }\n\n    function assertTypeOf(t: string) {\n      return (n: Node) => assert(n.type === t);\n    }\n  `);\n\n  // Node builders\n  iterateProps(definitions, typeDefinition => {\n    stdout.write(`\n      export function ${lowerCamelCase(typeDefinition.name)} (\n        ${params(filterProps(typeDefinition.fields, f => !f.constant))}\n      ): ${typeDefinition.name} {\n\n        ${assertParams(filterProps(typeDefinition.fields, f => !f.constant))}\n        ${buildObject(typeDefinition)} \n\n        return node;\n      }\n    `);\n  });\n\n  // Node testers\n  iterateProps(definitions, typeDefinition => {\n    stdout.write(`\n      export const is${typeDefinition.name} =\n        isTypeOf(\"${typeDefinition.name}\");\n    `);\n  });\n\n  // Node union type testers\n  const unionTypes = unique(\n    flatMap(mapProps(definitions).filter(d => d.unionType), d => d.unionType)\n  );\n  unionTypes.forEach(unionType => {\n    stdout.write(\n      `\n      export const is${unionType} = (node: Node) => ` +\n        mapProps(definitions)\n          .filter(d => d.unionType && d.unionType.includes(unionType))\n          .map(d => `is${d.name}(node) `)\n          .join(\"||\") +\n        \";\\n\\n\"\n    );\n  });\n\n  // Node assertion\n  iterateProps(definitions, typeDefinition => {\n    stdout.write(`\n      export const assert${typeDefinition.name} =\n        assertTypeOf(\"${typeDefinition.name}\");\n    `);\n  });\n\n  // a map from node type to its set of union types\n  stdout.write(\n    `\n    export const unionTypesMap = {` +\n      mapProps(definitions)\n        .filter(d => d.unionType)\n        .map(t => `\"${t.name}\": [${t.unionType.map(quote).join(\",\")}]\\n`) +\n      `};\n      `\n  );\n\n  // an array of all node and union types\n  stdout.write(\n    `\n    export const nodeAndUnionTypes = [` +\n      mapProps(definitions)\n        .map(t => `\"${t.name}\"`)\n        .concat(unionTypes.map(quote))\n        .join(\",\") +\n      `];`\n  );\n}\n\ngenerate();\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}