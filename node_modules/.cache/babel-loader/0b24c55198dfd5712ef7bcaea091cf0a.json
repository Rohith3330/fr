{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeModuleAndLoadMetadata;\nexports.hasExports = hasExports;\nexports.isSideEffectImport = isSideEffectImport;\nexports.validateImportInteropOption = validateImportInteropOption;\n\nvar _path = require(\"path\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nfunction hasExports(metadata) {\n  return metadata.hasExports;\n}\n\nfunction isSideEffectImport(source) {\n  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;\n}\n\nfunction validateImportInteropOption(importInterop) {\n  if (typeof importInterop !== \"function\" && importInterop !== \"none\" && importInterop !== \"babel\" && importInterop !== \"node\") {\n    throw new Error(`.importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received ${importInterop}).`);\n  }\n\n  return importInterop;\n}\n\nfunction resolveImportInterop(importInterop, source, filename) {\n  if (typeof importInterop === \"function\") {\n    return validateImportInteropOption(importInterop(source, filename));\n  }\n\n  return importInterop;\n}\n\nfunction normalizeModuleAndLoadMetadata(programPath, exportName, _ref) {\n  let {\n    importInterop,\n    initializeReexports = false,\n    lazy = false,\n    esNamespaceOnly = false,\n    filename\n  } = _ref;\n\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n\n  const stringSpecifiers = new Set();\n  nameAnonymousExports(programPath);\n  const {\n    local,\n    source,\n    hasExports\n  } = getModuleMetadata(programPath, {\n    initializeReexports,\n    lazy\n  }, stringSpecifiers);\n  removeModuleDeclarations(programPath);\n\n  for (const [, metadata] of source) {\n    if (metadata.importsNamespace.size > 0) {\n      metadata.name = metadata.importsNamespace.values().next().value;\n    }\n\n    const resolvedInterop = resolveImportInterop(importInterop, metadata.source, filename);\n\n    if (resolvedInterop === \"none\") {\n      metadata.interop = \"none\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"namespace\") {\n      metadata.interop = \"node-namespace\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"default\") {\n      metadata.interop = \"node-default\";\n    } else if (esNamespaceOnly && metadata.interop === \"namespace\") {\n      metadata.interop = \"default\";\n    }\n  }\n\n  return {\n    exportName,\n    exportNameListName: null,\n    hasExports,\n    local,\n    source,\n    stringSpecifiers\n  };\n}\n\nfunction getExportSpecifierName(path, stringSpecifiers) {\n  if (path.isIdentifier()) {\n    return path.node.name;\n  } else if (path.isStringLiteral()) {\n    const stringValue = path.node.value;\n\n    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n\n    return stringValue;\n  } else {\n    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`);\n  }\n}\n\nfunction assertExportSpecifier(path) {\n  if (path.isExportSpecifier()) {\n    return;\n  } else if (path.isExportNamespaceSpecifier()) {\n    throw path.buildCodeFrameError(\"Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.\");\n  } else {\n    throw path.buildCodeFrameError(\"Unexpected export specifier type\");\n  }\n}\n\nfunction getModuleMetadata(programPath, _ref2, stringSpecifiers) {\n  let {\n    lazy,\n    initializeReexports\n  } = _ref2;\n  const localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);\n  const sourceData = new Map();\n\n  const getData = sourceNode => {\n    const source = sourceNode.value;\n    let data = sourceData.get(source);\n\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,\n        interop: \"none\",\n        loc: null,\n        imports: new Map(),\n        importsNamespace: new Set(),\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n        lazy: false,\n        source\n      };\n      sourceData.set(source, data);\n    }\n\n    return data;\n  };\n\n  let hasExports = false;\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        if (spec.isImportDefaultSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, \"default\");\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, \"default\");\n            });\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.importsNamespace.add(localName);\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexportNamespace.add(name);\n            });\n          }\n        } else if (spec.isImportSpecifier()) {\n          const importName = getExportSpecifierName(spec.get(\"imported\"), stringSpecifiers);\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, importName);\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, importName);\n            });\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      data.reexportAll = {\n        loc: child.node.loc\n      };\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        assertExportSpecifier(spec);\n        const importName = getExportSpecifierName(spec.get(\"local\"), stringSpecifiers);\n        const exportName = getExportSpecifierName(spec.get(\"exported\"), stringSpecifiers);\n        data.reexports.set(exportName, importName);\n\n        if (exportName === \"__esModule\") {\n          throw spec.get(\"exported\").buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {\n      hasExports = true;\n    }\n  });\n\n  for (const metadata of sourceData.values()) {\n    let needsDefault = false;\n    let needsNamed = false;\n\n    if (metadata.importsNamespace.size > 0) {\n      needsDefault = true;\n      needsNamed = true;\n    }\n\n    if (metadata.reexportAll) {\n      needsNamed = true;\n    }\n\n    for (const importName of metadata.imports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n\n    for (const importName of metadata.reexports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n\n    if (needsDefault && needsNamed) {\n      metadata.interop = \"namespace\";\n    } else if (needsDefault) {\n      metadata.interop = \"default\";\n    }\n  }\n\n  for (const [source, metadata] of sourceData) {\n    if (lazy !== false && !(isSideEffectImport(metadata) || metadata.reexportAll)) {\n      if (lazy === true) {\n        metadata.lazy = !/\\./.test(source);\n      } else if (Array.isArray(lazy)) {\n        metadata.lazy = lazy.indexOf(source) !== -1;\n      } else if (typeof lazy === \"function\") {\n        metadata.lazy = lazy(source);\n      } else {\n        throw new Error(`.lazy must be a boolean, string array, or function`);\n      }\n    }\n  }\n\n  return {\n    hasExports,\n    local: localData,\n    source: sourceData\n  };\n}\n\nfunction getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {\n  const bindingKindLookup = new Map();\n  programPath.get(\"body\").forEach(child => {\n    let kind;\n\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) {\n        child = child.get(\"declaration\");\n      }\n\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (initializeReexports && child.node.source && child.get(\"source\").isStringLiteral()) {\n          child.get(\"specifiers\").forEach(spec => {\n            assertExportSpecifier(spec);\n            bindingKindLookup.set(spec.get(\"local\").node.name, \"block\");\n          });\n          return;\n        }\n      }\n\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({\n        kind: \"var\"\n      })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n  const localMetadata = new Map();\n\n  const getLocalMetadata = idPath => {\n    const localName = idPath.node.name;\n    let metadata = localMetadata.get(localName);\n\n    if (!metadata) {\n      const kind = bindingKindLookup.get(localName);\n\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(`Exporting local \"${localName}\", which is not declared.`);\n      }\n\n      metadata = {\n        names: [],\n        kind\n      };\n      localMetadata.set(localName, metadata);\n    }\n\n    return metadata;\n  };\n\n  programPath.get(\"body\").forEach(child => {\n    if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {\n      if (child.node.declaration) {\n        const declaration = child.get(\"declaration\");\n        const ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(name => {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(spec => {\n          const local = spec.get(\"local\");\n          const exported = spec.get(\"exported\");\n          const localMetadata = getLocalMetadata(local);\n          const exportName = getExportSpecifierName(exported, stringSpecifiers);\n\n          if (exportName === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n\n          localMetadata.names.push(exportName);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    }\n  });\n  return localMetadata;\n}\n\nfunction nameAnonymousExports(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (!child.isExportDefaultDeclaration()) return;\n    (0, _helperSplitExportDeclaration.default)(child);\n  });\n}\n\nfunction removeModuleDeclarations(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(declaration);\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["hasExports","metadata","isSideEffectImport","source","imports","size","importsNamespace","reexports","reexportNamespace","reexportAll","validateImportInteropOption","importInterop","Error","resolveImportInterop","filename","normalizeModuleAndLoadMetadata","programPath","exportName","initializeReexports","lazy","esNamespaceOnly","scope","generateUidIdentifier","name","stringSpecifiers","Set","nameAnonymousExports","local","getModuleMetadata","removeModuleDeclarations","values","next","value","resolvedInterop","interop","exportNameListName","getExportSpecifierName","path","isIdentifier","node","isStringLiteral","stringValue","add","type","assertExportSpecifier","isExportSpecifier","isExportNamespaceSpecifier","buildCodeFrameError","localData","getLocalExportMetadata","sourceData","Map","getData","sourceNode","data","get","loc","set","forEach","child","isImportDeclaration","spec","isImportDefaultSpecifier","localName","reexport","delete","names","isImportNamespaceSpecifier","isImportSpecifier","importName","isExportAllDeclaration","isExportNamedDeclaration","isExportDefaultDeclaration","needsDefault","needsNamed","test","Array","isArray","indexOf","bindingKindLookup","kind","declaration","isFunctionDeclaration","isClassDeclaration","isVariableDeclaration","Object","keys","getOuterBindingIdentifiers","localMetadata","getLocalMetadata","idPath","undefined","ids","getOuterBindingIdentifierPaths","push","exported","remove","_blockHoist","replaceWith"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-module-transforms\\src\\normalize-and-load-metadata.ts"],"sourcesContent":["import { basename, extname } from \"path\";\nimport type * as t from \"@babel/types\";\n\nimport { isIdentifierName } from \"@babel/helper-validator-identifier\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport interface ModuleMetadata {\n  exportName: string;\n  // The name of the variable that will reference an object containing export names.\n  exportNameListName: null | string;\n  hasExports: boolean;\n  // Lookup from local binding to export information.\n  local: Map<string, LocalExportMetadata>;\n  // Lookup of source file to source file metadata.\n  source: Map<string, SourceModuleMetadata>;\n  // List of names that should only be printed as string literals.\n  // i.e. `import { \"any unicode\" as foo } from \"some-module\"`\n  // `stringSpecifiers` is Set(1) [\"any unicode\"]\n  // In most cases `stringSpecifiers` is an empty Set\n  stringSpecifiers: Set<string>;\n}\n\nexport type InteropType =\n  | \"default\" // Babel interop for default-only imports\n  | \"namespace\" // Babel interop for namespace or default+named imports\n  | \"node-default\" // Node.js interop for default-only imports\n  | \"node-namespace\" // Node.js interop for namespace or default+named imports\n  | \"none\"; // No interop, or named-only imports\n\nexport type ImportInterop =\n  | \"none\"\n  | \"babel\"\n  | \"node\"\n  | ((source: string, filename?: string) => \"none\" | \"babel\" | \"node\");\n\nexport type Lazy = boolean | string[] | ((source: string) => boolean);\n\nexport interface SourceModuleMetadata {\n  // A unique variable name to use for this namespace object. Centralized for simplicity.\n  name: string;\n  loc: t.SourceLocation | undefined | null;\n  interop: InteropType;\n  // Local binding to reference from this source namespace. Key: Local name, value: Import name\n  imports: Map<string, string>;\n  // Local names that reference namespace object.\n  importsNamespace: Set<string>;\n  // Reexports to create for namespace. Key: Export name, value: Import name\n  reexports: Map<string, string>;\n  // List of names to re-export namespace as.\n  reexportNamespace: Set<string>;\n  // Tracks if the source should be re-exported.\n  reexportAll: null | {\n    loc: t.SourceLocation | undefined | null;\n  };\n  lazy?: Lazy;\n}\n\nexport interface LocalExportMetadata {\n  names: Array<string>; // names of exports,\n  kind: \"import\" | \"hoisted\" | \"block\" | \"var\";\n}\n\n/**\n * Check if the module has any exports that need handling.\n */\nexport function hasExports(metadata: ModuleMetadata) {\n  return metadata.hasExports;\n}\n\n/**\n * Check if a given source is an anonymous import, e.g. \"import 'foo';\"\n */\nexport function isSideEffectImport(source: SourceModuleMetadata) {\n  return (\n    source.imports.size === 0 &&\n    source.importsNamespace.size === 0 &&\n    source.reexports.size === 0 &&\n    source.reexportNamespace.size === 0 &&\n    !source.reexportAll\n  );\n}\n\nexport function validateImportInteropOption(\n  importInterop: any,\n): importInterop is ImportInterop {\n  if (\n    typeof importInterop !== \"function\" &&\n    importInterop !== \"none\" &&\n    importInterop !== \"babel\" &&\n    importInterop !== \"node\"\n  ) {\n    throw new Error(\n      `.importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received ${importInterop}).`,\n    );\n  }\n  return importInterop;\n}\n\nfunction resolveImportInterop(\n  importInterop: ImportInterop,\n  source: string,\n  filename: string | undefined,\n) {\n  if (typeof importInterop === \"function\") {\n    return validateImportInteropOption(importInterop(source, filename));\n  }\n  return importInterop;\n}\n\n/**\n * Remove all imports and exports from the file, and return all metadata\n * needed to reconstruct the module's behavior.\n */\nexport default function normalizeModuleAndLoadMetadata(\n  programPath: NodePath<t.Program>,\n  exportName: string,\n  {\n    importInterop,\n    initializeReexports = false,\n    lazy = false,\n    esNamespaceOnly = false,\n    filename,\n  }: {\n    importInterop: ImportInterop;\n    initializeReexports: boolean | void;\n    lazy: Lazy;\n    esNamespaceOnly: boolean;\n    filename: string;\n  },\n): ModuleMetadata {\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n  const stringSpecifiers = new Set<string>();\n\n  nameAnonymousExports(programPath);\n\n  const { local, source, hasExports } = getModuleMetadata(\n    programPath,\n    { initializeReexports, lazy },\n    stringSpecifiers,\n  );\n\n  removeModuleDeclarations(programPath);\n\n  // Reuse the imported namespace name if there is one.\n  for (const [, metadata] of source) {\n    if (metadata.importsNamespace.size > 0) {\n      // This is kind of gross. If we stop using `loose: true` we should\n      // just make this destructuring assignment.\n      metadata.name = metadata.importsNamespace.values().next().value;\n    }\n\n    const resolvedInterop = resolveImportInterop(\n      importInterop,\n      metadata.source,\n      filename,\n    );\n\n    if (resolvedInterop === \"none\") {\n      metadata.interop = \"none\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"namespace\") {\n      metadata.interop = \"node-namespace\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"default\") {\n      metadata.interop = \"node-default\";\n    } else if (esNamespaceOnly && metadata.interop === \"namespace\") {\n      // Both the default and namespace interops pass through __esModule\n      // objects, but the namespace interop is used to enable Babel's\n      // destructuring-like interop behavior for normal CommonJS.\n      // Since some tooling has started to remove that behavior, we expose\n      // it as the `esNamespace` option.\n      metadata.interop = \"default\";\n    }\n  }\n\n  return {\n    exportName,\n    exportNameListName: null,\n    hasExports,\n    local,\n    source,\n    stringSpecifiers,\n  };\n}\n\nfunction getExportSpecifierName(\n  path: NodePath,\n  stringSpecifiers: Set<string>,\n): string {\n  if (path.isIdentifier()) {\n    return path.node.name;\n  } else if (path.isStringLiteral()) {\n    const stringValue = path.node.value;\n    // add specifier value to `stringSpecifiers` only when it can not be converted to an identifier name\n    // i.e In `import { \"foo\" as bar }`\n    // we do not consider `\"foo\"` to be a `stringSpecifier` because we can treat it as\n    // `import { foo as bar }`\n    // This helps minimize the size of `stringSpecifiers` and reduce overhead of checking valid identifier names\n    // when building transpiled code from metadata\n    if (!isIdentifierName(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(\n      `Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`,\n    );\n  }\n}\n\nfunction assertExportSpecifier(\n  path: NodePath,\n): asserts path is NodePath<t.ExportSpecifier> {\n  if (path.isExportSpecifier()) {\n    return;\n  } else if (path.isExportNamespaceSpecifier()) {\n    throw path.buildCodeFrameError(\n      \"Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.\",\n    );\n  } else {\n    throw path.buildCodeFrameError(\"Unexpected export specifier type\");\n  }\n}\n\n/**\n * Get metadata about the imports and exports present in this module.\n */\nfunction getModuleMetadata(\n  programPath: NodePath<t.Program>,\n  {\n    lazy,\n    initializeReexports,\n  }: {\n    // todo(flow-ts) changed from boolean, to match expected usage inside the function\n    lazy: boolean | string[] | ((source: string) => boolean);\n    initializeReexports: boolean | void;\n  },\n  stringSpecifiers: Set<string>,\n) {\n  const localData = getLocalExportMetadata(\n    programPath,\n    initializeReexports,\n    stringSpecifiers,\n  );\n\n  const sourceData = new Map();\n  const getData = (sourceNode: t.StringLiteral) => {\n    const source = sourceNode.value;\n\n    let data = sourceData.get(source);\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier(\n          basename(source, extname(source)),\n        ).name,\n\n        interop: \"none\",\n\n        loc: null,\n\n        // Data about the requested sources and names.\n        imports: new Map(),\n        importsNamespace: new Set(),\n\n        // Metadata about data that is passed directly from source to export.\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n\n        lazy: false,\n\n        source,\n      };\n      sourceData.set(source, data);\n    }\n    return data;\n  };\n  let hasExports = false;\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n\n      child.get(\"specifiers\").forEach(spec => {\n        if (spec.isImportDefaultSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n\n          data.imports.set(localName, \"default\");\n\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexports.set(name, \"default\");\n            });\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n\n          data.importsNamespace.add(localName);\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexportNamespace.add(name);\n            });\n          }\n        } else if (spec.isImportSpecifier()) {\n          const importName = getExportSpecifierName(\n            spec.get(\"imported\"),\n            stringSpecifiers,\n          );\n          const localName = spec.get(\"local\").node.name;\n\n          data.imports.set(localName, importName);\n\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexports.set(name, importName);\n            });\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n\n      data.reexportAll = {\n        loc: child.node.loc,\n      };\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n\n      child.get(\"specifiers\").forEach(spec => {\n        assertExportSpecifier(spec);\n        const importName = getExportSpecifierName(\n          spec.get(\"local\"),\n          stringSpecifiers,\n        );\n        const exportName = getExportSpecifierName(\n          spec.get(\"exported\"),\n          stringSpecifiers,\n        );\n\n        data.reexports.set(exportName, importName);\n\n        if (exportName === \"__esModule\") {\n          throw spec\n            .get(\"exported\")\n            .buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (\n      child.isExportNamedDeclaration() ||\n      child.isExportDefaultDeclaration()\n    ) {\n      hasExports = true;\n    }\n  });\n\n  for (const metadata of sourceData.values()) {\n    let needsDefault = false;\n    let needsNamed = false;\n\n    if (metadata.importsNamespace.size > 0) {\n      needsDefault = true;\n      needsNamed = true;\n    }\n\n    if (metadata.reexportAll) {\n      needsNamed = true;\n    }\n\n    for (const importName of metadata.imports.values()) {\n      if (importName === \"default\") needsDefault = true;\n      else needsNamed = true;\n    }\n    for (const importName of metadata.reexports.values()) {\n      if (importName === \"default\") needsDefault = true;\n      else needsNamed = true;\n    }\n\n    if (needsDefault && needsNamed) {\n      // TODO(logan): Using the namespace interop here is unfortunate. Revisit.\n      metadata.interop = \"namespace\";\n    } else if (needsDefault) {\n      metadata.interop = \"default\";\n    }\n  }\n\n  for (const [source, metadata] of sourceData) {\n    if (\n      lazy !== false &&\n      !(isSideEffectImport(metadata) || metadata.reexportAll)\n    ) {\n      if (lazy === true) {\n        // 'true' means that local relative files are eagerly loaded and\n        // dependency modules are loaded lazily.\n        metadata.lazy = !/\\./.test(source);\n      } else if (Array.isArray(lazy)) {\n        metadata.lazy = lazy.indexOf(source) !== -1;\n      } else if (typeof lazy === \"function\") {\n        metadata.lazy = lazy(source);\n      } else {\n        throw new Error(`.lazy must be a boolean, string array, or function`);\n      }\n    }\n  }\n\n  return {\n    hasExports,\n    local: localData,\n    source: sourceData,\n  };\n}\n\ntype ModuleBindingKind = \"import\" | \"hoisted\" | \"block\" | \"var\";\n/**\n * Get metadata about local variables that are exported.\n */\nfunction getLocalExportMetadata(\n  programPath: NodePath<t.Program>,\n  initializeReexports: boolean | void,\n  stringSpecifiers: Set<string>,\n): Map<string, LocalExportMetadata> {\n  const bindingKindLookup = new Map();\n\n  programPath.get(\"body\").forEach((child: NodePath) => {\n    let kind: ModuleBindingKind;\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) {\n        child = child.get(\"declaration\");\n      }\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (\n          initializeReexports &&\n          child.node.source &&\n          child.get(\"source\").isStringLiteral()\n        ) {\n          child.get(\"specifiers\").forEach(spec => {\n            assertExportSpecifier(spec);\n            bindingKindLookup.set(spec.get(\"local\").node.name, \"block\");\n          });\n          return;\n        }\n      }\n\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({ kind: \"var\" })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n\n  const localMetadata = new Map();\n  const getLocalMetadata = (idPath: NodePath<t.Identifier>) => {\n    const localName = idPath.node.name;\n    let metadata = localMetadata.get(localName);\n\n    if (!metadata) {\n      const kind = bindingKindLookup.get(localName);\n\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(\n          `Exporting local \"${localName}\", which is not declared.`,\n        );\n      }\n\n      metadata = {\n        names: [],\n        kind,\n      };\n      localMetadata.set(localName, metadata);\n    }\n    return metadata;\n  };\n\n  programPath.get(\"body\").forEach(child => {\n    if (\n      child.isExportNamedDeclaration() &&\n      (initializeReexports || !child.node.source)\n    ) {\n      if (child.node.declaration) {\n        const declaration = child.get(\"declaration\");\n        const ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(name => {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError(\n              'Illegal export \"__esModule\".',\n            );\n          }\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(spec => {\n          const local = spec.get(\"local\");\n          const exported = spec.get(\"exported\");\n          const localMetadata = getLocalMetadata(local);\n          const exportName = getExportSpecifierName(exported, stringSpecifiers);\n\n          if (exportName === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n          localMetadata.names.push(exportName);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n      if (\n        declaration.isFunctionDeclaration() ||\n        declaration.isClassDeclaration()\n      ) {\n        // @ts-expect-error todo(flow->ts): improve babel-types\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        // These should have been removed by the nameAnonymousExports() call.\n        throw declaration.buildCodeFrameError(\n          \"Unexpected default expression export.\",\n        );\n      }\n    }\n  });\n  return localMetadata;\n}\n\n/**\n * Ensure that all exported values have local binding names.\n */\nfunction nameAnonymousExports(programPath: NodePath<t.Program>) {\n  // Name anonymous exported locals.\n  programPath.get(\"body\").forEach(child => {\n    if (!child.isExportDefaultDeclaration()) return;\n    splitExportDeclaration(child);\n  });\n}\n\nfunction removeModuleDeclarations(programPath: NodePath<t.Program>) {\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      // export default foo;\n      const declaration = child.get(\"declaration\");\n      if (\n        declaration.isFunctionDeclaration() ||\n        declaration.isClassDeclaration()\n      ) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(\n          declaration as NodePath<t.FunctionDeclaration | t.ClassDeclaration>,\n        );\n      } else {\n        // These should have been removed by the nameAnonymousExports() call.\n        throw declaration.buildCodeFrameError(\n          \"Unexpected default expression export.\",\n        );\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"script"}