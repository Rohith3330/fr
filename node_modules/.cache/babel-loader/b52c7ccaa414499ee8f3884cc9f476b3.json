{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transform = transform;\n\nvar _index = require(\"../../index\");\n\nvar _astModuleToModuleContext = require(\"../ast-module-to-module-context\");\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _sliceIterator(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _slicedToArray(arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    return _sliceIterator(arr, i);\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n} // FIXME(sven): do the same with all block instructions, must be more generic here\n\n\nfunction newUnexpectedFunction(i) {\n  return new Error(\"unknown function at offset: \" + i);\n}\n\nfunction transform(ast) {\n  var module;\n  (0, _index.traverse)(ast, {\n    Module: function (_Module) {\n      function Module(_x) {\n        return _Module.apply(this, arguments);\n      }\n\n      Module.toString = function () {\n        return _Module.toString();\n      };\n\n      return Module;\n    }(function (path) {\n      module = path.node;\n    })\n  });\n  var moduleContext = (0, _astModuleToModuleContext.moduleContextFromModuleAST)(module); // Transform the actual instruction in function bodies\n\n  (0, _index.traverse)(ast, {\n    Func: function (_Func) {\n      function Func(_x2) {\n        return _Func.apply(this, arguments);\n      }\n\n      Func.toString = function () {\n        return _Func.toString();\n      };\n\n      return Func;\n    }(function (path) {\n      transformFuncPath(path, moduleContext);\n    }),\n    Start: function (_Start) {\n      function Start(_x3) {\n        return _Start.apply(this, arguments);\n      }\n\n      Start.toString = function () {\n        return _Start.toString();\n      };\n\n      return Start;\n    }(function (path) {\n      var index = path.node.index;\n\n      if ((0, _index.isIdentifier)(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n\n        path.node.index = (0, _index.numberLiteralFromRaw)(offsetInModule);\n      }\n    })\n  });\n}\n\nfunction transformFuncPath(funcPath, moduleContext) {\n  var funcNode = funcPath.node;\n  var signature = funcNode.signature;\n\n  if (signature.type !== \"Signature\") {\n    throw new Error(\"Function signatures must be denormalised before execution\");\n  }\n\n  var params = signature.params; // Add func locals in the context\n\n  params.forEach(function (p) {\n    return moduleContext.addLocal(p.valtype);\n  });\n  (0, _index.traverse)(funcNode, {\n    Instr: function (_Instr) {\n      function Instr(_x4) {\n        return _Instr.apply(this, arguments);\n      }\n\n      Instr.toString = function () {\n        return _Instr.toString();\n      };\n\n      return Instr;\n    }(function (instrPath) {\n      var instrNode = instrPath.node;\n      /**\n       * Local access\n       */\n\n      if (instrNode.id === \"get_local\" || instrNode.id === \"set_local\" || instrNode.id === \"tee_local\") {\n        var _instrNode$args = _slicedToArray(instrNode.args, 1),\n            firstArg = _instrNode$args[0];\n\n        if (firstArg.type === \"Identifier\") {\n          var offsetInParams = params.findIndex(function (_ref) {\n            var id = _ref.id;\n            return id === firstArg.value;\n          });\n\n          if (offsetInParams === -1) {\n            throw new Error(\"\".concat(firstArg.value, \" not found in \").concat(instrNode.id, \": not declared in func params\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n\n          instrNode.args[0] = (0, _index.numberLiteralFromRaw)(offsetInParams);\n        }\n      }\n      /**\n       * Global access\n       */\n\n\n      if (instrNode.id === \"get_global\" || instrNode.id === \"set_global\") {\n        var _instrNode$args2 = _slicedToArray(instrNode.args, 1),\n            _firstArg = _instrNode$args2[0];\n\n        if ((0, _index.isIdentifier)(_firstArg) === true) {\n          var globalOffset = moduleContext.getGlobalOffsetByIdentifier( // $FlowIgnore: reference?\n          _firstArg.value);\n\n          if (typeof globalOffset === \"undefined\") {\n            // $FlowIgnore: reference?\n            throw new Error(\"global \".concat(_firstArg.value, \" not found in module\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n\n          instrNode.args[0] = (0, _index.numberLiteralFromRaw)(globalOffset);\n        }\n      }\n      /**\n       * Labels lookup\n       */\n\n\n      if (instrNode.id === \"br\") {\n        var _instrNode$args3 = _slicedToArray(instrNode.args, 1),\n            _firstArg2 = _instrNode$args3[0];\n\n        if ((0, _index.isIdentifier)(_firstArg2) === true) {\n          // if the labels is not found it is going to be replaced with -1\n          // which is invalid.\n          var relativeBlockCount = -1; // $FlowIgnore: reference?\n\n          instrPath.findParent(function (_ref2) {\n            var node = _ref2.node;\n\n            if ((0, _index.isBlock)(node)) {\n              relativeBlockCount++; // $FlowIgnore: reference?\n\n              var name = node.label || node.name;\n\n              if (_typeof(name) === \"object\") {\n                // $FlowIgnore: isIdentifier ensures that\n                if (name.value === _firstArg2.value) {\n                  // Found it\n                  return false;\n                }\n              }\n            }\n\n            if ((0, _index.isFunc)(node)) {\n              return false;\n            }\n          }); // Replace the Identifer node by our new NumberLiteral node\n\n          instrNode.args[0] = (0, _index.numberLiteralFromRaw)(relativeBlockCount);\n        }\n      }\n    }),\n\n    /**\n     * Func lookup\n     */\n    CallInstruction: function (_CallInstruction) {\n      function CallInstruction(_x5) {\n        return _CallInstruction.apply(this, arguments);\n      }\n\n      CallInstruction.toString = function () {\n        return _CallInstruction.toString();\n      };\n\n      return CallInstruction;\n    }(function (_ref3) {\n      var node = _ref3.node;\n      var index = node.index;\n\n      if ((0, _index.isIdentifier)(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n\n        node.index = (0, _index.numberLiteralFromRaw)(offsetInModule);\n      }\n    })\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","transform","_index","require","_astModuleToModuleContext","_typeof","obj","Symbol","iterator","constructor","prototype","_sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","length","err","_slicedToArray","Array","isArray","TypeError","newUnexpectedFunction","Error","ast","module","traverse","Module","_Module","_x","apply","arguments","toString","path","node","moduleContext","moduleContextFromModuleAST","Func","_Func","_x2","transformFuncPath","Start","_Start","_x3","index","isIdentifier","offsetInModule","getFunctionOffsetByIdentifier","numberLiteralFromRaw","funcPath","funcNode","signature","type","params","forEach","p","addLocal","valtype","Instr","_Instr","_x4","instrPath","instrNode","id","_instrNode$args","args","firstArg","offsetInParams","findIndex","_ref","concat","_instrNode$args2","_firstArg","globalOffset","getGlobalOffsetByIdentifier","_instrNode$args3","_firstArg2","relativeBlockCount","findParent","_ref2","isBlock","name","label","isFunc","CallInstruction","_CallInstruction","_x5","_ref3"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@webassemblyjs/ast/lib/transform/wast-identifier-to-index/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transform = transform;\n\nvar _index = require(\"../../index\");\n\nvar _astModuleToModuleContext = require(\"../ast-module-to-module-context\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return _sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }\n\n// FIXME(sven): do the same with all block instructions, must be more generic here\nfunction newUnexpectedFunction(i) {\n  return new Error(\"unknown function at offset: \" + i);\n}\n\nfunction transform(ast) {\n  var module;\n  (0, _index.traverse)(ast, {\n    Module: function (_Module) {\n      function Module(_x) {\n        return _Module.apply(this, arguments);\n      }\n\n      Module.toString = function () {\n        return _Module.toString();\n      };\n\n      return Module;\n    }(function (path) {\n      module = path.node;\n    })\n  });\n  var moduleContext = (0, _astModuleToModuleContext.moduleContextFromModuleAST)(module); // Transform the actual instruction in function bodies\n\n  (0, _index.traverse)(ast, {\n    Func: function (_Func) {\n      function Func(_x2) {\n        return _Func.apply(this, arguments);\n      }\n\n      Func.toString = function () {\n        return _Func.toString();\n      };\n\n      return Func;\n    }(function (path) {\n      transformFuncPath(path, moduleContext);\n    }),\n    Start: function (_Start) {\n      function Start(_x3) {\n        return _Start.apply(this, arguments);\n      }\n\n      Start.toString = function () {\n        return _Start.toString();\n      };\n\n      return Start;\n    }(function (path) {\n      var index = path.node.index;\n\n      if ((0, _index.isIdentifier)(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n\n        path.node.index = (0, _index.numberLiteralFromRaw)(offsetInModule);\n      }\n    })\n  });\n}\n\nfunction transformFuncPath(funcPath, moduleContext) {\n  var funcNode = funcPath.node;\n  var signature = funcNode.signature;\n\n  if (signature.type !== \"Signature\") {\n    throw new Error(\"Function signatures must be denormalised before execution\");\n  }\n\n  var params = signature.params; // Add func locals in the context\n\n  params.forEach(function (p) {\n    return moduleContext.addLocal(p.valtype);\n  });\n  (0, _index.traverse)(funcNode, {\n    Instr: function (_Instr) {\n      function Instr(_x4) {\n        return _Instr.apply(this, arguments);\n      }\n\n      Instr.toString = function () {\n        return _Instr.toString();\n      };\n\n      return Instr;\n    }(function (instrPath) {\n      var instrNode = instrPath.node;\n      /**\n       * Local access\n       */\n\n      if (instrNode.id === \"get_local\" || instrNode.id === \"set_local\" || instrNode.id === \"tee_local\") {\n        var _instrNode$args = _slicedToArray(instrNode.args, 1),\n            firstArg = _instrNode$args[0];\n\n        if (firstArg.type === \"Identifier\") {\n          var offsetInParams = params.findIndex(function (_ref) {\n            var id = _ref.id;\n            return id === firstArg.value;\n          });\n\n          if (offsetInParams === -1) {\n            throw new Error(\"\".concat(firstArg.value, \" not found in \").concat(instrNode.id, \": not declared in func params\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n\n          instrNode.args[0] = (0, _index.numberLiteralFromRaw)(offsetInParams);\n        }\n      }\n      /**\n       * Global access\n       */\n\n\n      if (instrNode.id === \"get_global\" || instrNode.id === \"set_global\") {\n        var _instrNode$args2 = _slicedToArray(instrNode.args, 1),\n            _firstArg = _instrNode$args2[0];\n\n        if ((0, _index.isIdentifier)(_firstArg) === true) {\n          var globalOffset = moduleContext.getGlobalOffsetByIdentifier( // $FlowIgnore: reference?\n          _firstArg.value);\n\n          if (typeof globalOffset === \"undefined\") {\n            // $FlowIgnore: reference?\n            throw new Error(\"global \".concat(_firstArg.value, \" not found in module\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n\n          instrNode.args[0] = (0, _index.numberLiteralFromRaw)(globalOffset);\n        }\n      }\n      /**\n       * Labels lookup\n       */\n\n\n      if (instrNode.id === \"br\") {\n        var _instrNode$args3 = _slicedToArray(instrNode.args, 1),\n            _firstArg2 = _instrNode$args3[0];\n\n        if ((0, _index.isIdentifier)(_firstArg2) === true) {\n          // if the labels is not found it is going to be replaced with -1\n          // which is invalid.\n          var relativeBlockCount = -1; // $FlowIgnore: reference?\n\n          instrPath.findParent(function (_ref2) {\n            var node = _ref2.node;\n\n            if ((0, _index.isBlock)(node)) {\n              relativeBlockCount++; // $FlowIgnore: reference?\n\n              var name = node.label || node.name;\n\n              if (_typeof(name) === \"object\") {\n                // $FlowIgnore: isIdentifier ensures that\n                if (name.value === _firstArg2.value) {\n                  // Found it\n                  return false;\n                }\n              }\n            }\n\n            if ((0, _index.isFunc)(node)) {\n              return false;\n            }\n          }); // Replace the Identifer node by our new NumberLiteral node\n\n          instrNode.args[0] = (0, _index.numberLiteralFromRaw)(relativeBlockCount);\n        }\n      }\n    }),\n\n    /**\n     * Func lookup\n     */\n    CallInstruction: function (_CallInstruction) {\n      function CallInstruction(_x5) {\n        return _CallInstruction.apply(this, arguments);\n      }\n\n      CallInstruction.toString = function () {\n        return _CallInstruction.toString();\n      };\n\n      return CallInstruction;\n    }(function (_ref3) {\n      var node = _ref3.node;\n      var index = node.index;\n\n      if ((0, _index.isIdentifier)(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n\n        node.index = (0, _index.numberLiteralFromRaw)(offsetInModule);\n      }\n    })\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}