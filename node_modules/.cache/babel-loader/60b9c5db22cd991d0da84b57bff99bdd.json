{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _resolve = require('eslint-module-utils/resolve');\n\nvar _resolve2 = _interopRequireDefault(_resolve);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _toArray(arr) {\n  return Array.isArray(arr) ? arr : Array.from(arr);\n}\n\nfunction checkImports(imported, context) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = imported.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _ref = _step.value;\n\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      var _module = _ref2[0];\n      var nodes = _ref2[1];\n\n      if (nodes.length > 1) {\n        var message = '\\'' + String(_module) + '\\' imported multiple times.';\n\n        var _nodes = _toArray(nodes),\n            first = _nodes[0],\n            rest = _nodes.slice(1);\n\n        var sourceCode = context.getSourceCode();\n        var fix = getFix(first, rest, sourceCode);\n        context.report({\n          node: first.source,\n          message: message,\n          fix: fix // Attach the autofix (if any) to the first import.\n\n        });\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = rest[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var node = _step2.value;\n            context.report({\n              node: node.source,\n              message: message\n            });\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n              _iterator2['return']();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator['return']) {\n        _iterator['return']();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\nfunction getFix(first, rest, sourceCode) {\n  // Sorry ESLint <= 3 users, no autofix for you. Autofixing duplicate imports\n  // requires multiple `fixer.whatever()` calls in the `fix`: We both need to\n  // update the first one, and remove the rest. Support for multiple\n  // `fixer.whatever()` in a single `fix` was added in ESLint 4.1.\n  // `sourceCode.getCommentsBefore` was added in 4.0, so that's an easy thing to\n  // check for.\n  if (typeof sourceCode.getCommentsBefore !== 'function') {\n    return undefined;\n  } // Adjusting the first import might make it multiline, which could break\n  // `eslint-disable-next-line` comments and similar, so bail if the first\n  // import has comments. Also, if the first import is `import * as ns from\n  // './foo'` there's nothing we can do.\n\n\n  if (hasProblematicComments(first, sourceCode) || hasNamespace(first)) {\n    return undefined;\n  }\n\n  var defaultImportNames = new Set([first].concat(_toConsumableArray(rest)).map(getDefaultImportName).filter(Boolean)); // Bail if there are multiple different default import names – it's up to the\n  // user to choose which one to keep.\n\n  if (defaultImportNames.size > 1) {\n    return undefined;\n  } // Leave it to the user to handle comments. Also skip `import * as ns from\n  // './foo'` imports, since they cannot be merged into another import.\n\n\n  var restWithoutComments = rest.filter(function (node) {\n    return !(hasProblematicComments(node, sourceCode) || hasNamespace(node));\n  });\n  var specifiers = restWithoutComments.map(function (node) {\n    var tokens = sourceCode.getTokens(node);\n    var openBrace = tokens.find(function (token) {\n      return isPunctuator(token, '{');\n    });\n    var closeBrace = tokens.find(function (token) {\n      return isPunctuator(token, '}');\n    });\n\n    if (openBrace == null || closeBrace == null) {\n      return undefined;\n    }\n\n    return {\n      importNode: node,\n      text: sourceCode.text.slice(openBrace.range[1], closeBrace.range[0]),\n      hasTrailingComma: isPunctuator(sourceCode.getTokenBefore(closeBrace), ','),\n      isEmpty: !hasSpecifiers(node)\n    };\n  }).filter(Boolean);\n  var unnecessaryImports = restWithoutComments.filter(function (node) {\n    return !hasSpecifiers(node) && !hasNamespace(node) && !specifiers.some(function (specifier) {\n      return specifier.importNode === node;\n    });\n  });\n  var shouldAddDefault = getDefaultImportName(first) == null && defaultImportNames.size === 1;\n  var shouldAddSpecifiers = specifiers.length > 0;\n  var shouldRemoveUnnecessary = unnecessaryImports.length > 0;\n\n  if (!(shouldAddDefault || shouldAddSpecifiers || shouldRemoveUnnecessary)) {\n    return undefined;\n  }\n\n  return function (fixer) {\n    var tokens = sourceCode.getTokens(first);\n    var openBrace = tokens.find(function (token) {\n      return isPunctuator(token, '{');\n    });\n    var closeBrace = tokens.find(function (token) {\n      return isPunctuator(token, '}');\n    });\n    var firstToken = sourceCode.getFirstToken(first);\n\n    var _defaultImportNames = _slicedToArray(defaultImportNames, 1),\n        defaultImportName = _defaultImportNames[0];\n\n    var firstHasTrailingComma = closeBrace != null && isPunctuator(sourceCode.getTokenBefore(closeBrace), ',');\n    var firstIsEmpty = !hasSpecifiers(first);\n\n    var _specifiers$reduce = specifiers.reduce(function (_ref3, specifier) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          result = _ref4[0],\n          needsComma = _ref4[1];\n\n      return [needsComma && !specifier.isEmpty ? String(result) + ',' + String(specifier.text) : '' + String(result) + String(specifier.text), specifier.isEmpty ? needsComma : true];\n    }, ['', !firstHasTrailingComma && !firstIsEmpty]),\n        _specifiers$reduce2 = _slicedToArray(_specifiers$reduce, 1),\n        specifiersText = _specifiers$reduce2[0];\n\n    var fixes = [];\n\n    if (shouldAddDefault && openBrace == null && shouldAddSpecifiers) {\n      // `import './foo'` → `import def, {...} from './foo'`\n      fixes.push(fixer.insertTextAfter(firstToken, ' ' + String(defaultImportName) + ', {' + String(specifiersText) + '} from'));\n    } else if (shouldAddDefault && openBrace == null && !shouldAddSpecifiers) {\n      // `import './foo'` → `import def from './foo'`\n      fixes.push(fixer.insertTextAfter(firstToken, ' ' + String(defaultImportName) + ' from'));\n    } else if (shouldAddDefault && openBrace != null && closeBrace != null) {\n      // `import {...} from './foo'` → `import def, {...} from './foo'`\n      fixes.push(fixer.insertTextAfter(firstToken, ' ' + String(defaultImportName) + ','));\n\n      if (shouldAddSpecifiers) {\n        // `import def, {...} from './foo'` → `import def, {..., ...} from './foo'`\n        fixes.push(fixer.insertTextBefore(closeBrace, specifiersText));\n      }\n    } else if (!shouldAddDefault && openBrace == null && shouldAddSpecifiers) {\n      if (first.specifiers.length === 0) {\n        // `import './foo'` → `import {...} from './foo'`\n        fixes.push(fixer.insertTextAfter(firstToken, ' {' + String(specifiersText) + '} from'));\n      } else {\n        // `import def from './foo'` → `import def, {...} from './foo'`\n        fixes.push(fixer.insertTextAfter(first.specifiers[0], ', {' + String(specifiersText) + '}'));\n      }\n    } else if (!shouldAddDefault && openBrace != null && closeBrace != null) {\n      // `import {...} './foo'` → `import {..., ...} from './foo'`\n      fixes.push(fixer.insertTextBefore(closeBrace, specifiersText));\n    } // Remove imports whose specifiers have been moved into the first import.\n\n\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = specifiers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var specifier = _step3.value;\n        var importNode = specifier.importNode;\n        fixes.push(fixer.remove(importNode));\n        var charAfterImportRange = [importNode.range[1], importNode.range[1] + 1];\n        var charAfterImport = sourceCode.text.substring(charAfterImportRange[0], charAfterImportRange[1]);\n\n        if (charAfterImport === '\\n') {\n          fixes.push(fixer.removeRange(charAfterImportRange));\n        }\n      } // Remove imports whose default import has been moved to the first import,\n      // and side-effect-only imports that are unnecessary due to the first\n      // import.\n\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3['return']) {\n          _iterator3['return']();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = unnecessaryImports[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var node = _step4.value;\n        fixes.push(fixer.remove(node));\n        var charAfterImportRange = [node.range[1], node.range[1] + 1];\n        var charAfterImport = sourceCode.text.substring(charAfterImportRange[0], charAfterImportRange[1]);\n\n        if (charAfterImport === '\\n') {\n          fixes.push(fixer.removeRange(charAfterImportRange));\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4['return']) {\n          _iterator4['return']();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    return fixes;\n  };\n}\n\nfunction isPunctuator(node, value) {\n  return node.type === 'Punctuator' && node.value === value;\n} // Get the name of the default import of `node`, if any.\n\n\nfunction getDefaultImportName(node) {\n  var defaultSpecifier = node.specifiers.find(function (specifier) {\n    return specifier.type === 'ImportDefaultSpecifier';\n  });\n  return defaultSpecifier != null ? defaultSpecifier.local.name : undefined;\n} // Checks whether `node` has a namespace import.\n\n\nfunction hasNamespace(node) {\n  var specifiers = node.specifiers.filter(function (specifier) {\n    return specifier.type === 'ImportNamespaceSpecifier';\n  });\n  return specifiers.length > 0;\n} // Checks whether `node` has any non-default specifiers.\n\n\nfunction hasSpecifiers(node) {\n  var specifiers = node.specifiers.filter(function (specifier) {\n    return specifier.type === 'ImportSpecifier';\n  });\n  return specifiers.length > 0;\n} // It's not obvious what the user wants to do with comments associated with\n// duplicate imports, so skip imports with comments when autofixing.\n\n\nfunction hasProblematicComments(node, sourceCode) {\n  return hasCommentBefore(node, sourceCode) || hasCommentAfter(node, sourceCode) || hasCommentInsideNonSpecifiers(node, sourceCode);\n} // Checks whether `node` has a comment (that ends) on the previous line or on\n// the same line as `node` (starts).\n\n\nfunction hasCommentBefore(node, sourceCode) {\n  return sourceCode.getCommentsBefore(node).some(function (comment) {\n    return comment.loc.end.line >= node.loc.start.line - 1;\n  });\n} // Checks whether `node` has a comment (that starts) on the same line as `node`\n// (ends).\n\n\nfunction hasCommentAfter(node, sourceCode) {\n  return sourceCode.getCommentsAfter(node).some(function (comment) {\n    return comment.loc.start.line === node.loc.end.line;\n  });\n} // Checks whether `node` has any comments _inside,_ except inside the `{...}`\n// part (if any).\n\n\nfunction hasCommentInsideNonSpecifiers(node, sourceCode) {\n  var tokens = sourceCode.getTokens(node);\n  var openBraceIndex = tokens.findIndex(function (token) {\n    return isPunctuator(token, '{');\n  });\n  var closeBraceIndex = tokens.findIndex(function (token) {\n    return isPunctuator(token, '}');\n  }); // Slice away the first token, since we're no looking for comments _before_\n  // `node` (only inside). If there's a `{...}` part, look for comments before\n  // the `{`, but not before the `}` (hence the `+1`s).\n\n  var someTokens = openBraceIndex >= 0 && closeBraceIndex >= 0 ? tokens.slice(1, openBraceIndex + 1).concat(tokens.slice(closeBraceIndex + 1)) : tokens.slice(1);\n  return someTokens.some(function (token) {\n    return sourceCode.getCommentsBefore(token).length > 0;\n  });\n}\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      url: (0, _docsUrl2['default'])('no-duplicates')\n    },\n    fixable: 'code',\n    schema: [{\n      type: 'object',\n      properties: {\n        considerQueryString: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  create: function () {\n    function create(context) {\n      // Prepare the resolver from options.\n      var considerQueryStringOption = context.options[0] && context.options[0]['considerQueryString'];\n\n      var defaultResolver = function () {\n        function defaultResolver(sourcePath) {\n          return (0, _resolve2['default'])(sourcePath, context) || sourcePath;\n        }\n\n        return defaultResolver;\n      }();\n\n      var resolver = considerQueryStringOption ? function (sourcePath) {\n        var parts = sourcePath.match(/^([^?]*)\\?(.*)$/);\n\n        if (!parts) {\n          return defaultResolver(sourcePath);\n        }\n\n        return defaultResolver(parts[1]) + '?' + parts[2];\n      } : defaultResolver;\n      var moduleMaps = new Map();\n\n      function getImportMap(n) {\n        if (!moduleMaps.has(n.parent)) {\n          moduleMaps.set(n.parent, {\n            imported: new Map(),\n            nsImported: new Map(),\n            defaultTypesImported: new Map(),\n            namedTypesImported: new Map()\n          });\n        }\n\n        var map = moduleMaps.get(n.parent);\n\n        if (n.importKind === 'type') {\n          return n.specifiers.length > 0 && n.specifiers[0].type === 'ImportDefaultSpecifier' ? map.defaultTypesImported : map.namedTypesImported;\n        }\n\n        return hasNamespace(n) ? map.nsImported : map.imported;\n      }\n\n      return {\n        ImportDeclaration: function () {\n          function ImportDeclaration(n) {\n            // resolved path will cover aliased duplicates\n            var resolvedPath = resolver(n.source.value);\n            var importMap = getImportMap(n);\n\n            if (importMap.has(resolvedPath)) {\n              importMap.get(resolvedPath).push(n);\n            } else {\n              importMap.set(resolvedPath, [n]);\n            }\n          }\n\n          return ImportDeclaration;\n        }(),\n        'Program:exit': function () {\n          function ProgramExit() {\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n              for (var _iterator5 = moduleMaps.values()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                var map = _step5.value;\n                checkImports(map.imported, context);\n                checkImports(map.nsImported, context);\n                checkImports(map.defaultTypesImported, context);\n                checkImports(map.namedTypesImported, context);\n              }\n            } catch (err) {\n              _didIteratorError5 = true;\n              _iteratorError5 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion5 && _iterator5['return']) {\n                  _iterator5['return']();\n                }\n              } finally {\n                if (_didIteratorError5) {\n                  throw _iteratorError5;\n                }\n              }\n            }\n          }\n\n          return ProgramExit;\n        }()\n      };\n    }\n\n    return create;\n  }()\n};","map":{"version":3,"mappings":"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","names":["checkImports","imported","context","entries","Symbol","module","nodes","length","message","first","rest","sourceCode","getSourceCode","fix","getFix","report","node","source","_didIteratorError2","_iteratorError2","_iterator2","_didIteratorError","_iteratorError","_iterator","getCommentsBefore","undefined","hasProblematicComments","hasNamespace","defaultImportNames","Set","map","getDefaultImportName","filter","Boolean","size","restWithoutComments","specifiers","tokens","getTokens","openBrace","find","isPunctuator","token","closeBrace","importNode","text","slice","range","hasTrailingComma","getTokenBefore","isEmpty","hasSpecifiers","unnecessaryImports","some","specifier","shouldAddDefault","shouldAddSpecifiers","shouldRemoveUnnecessary","firstToken","getFirstToken","defaultImportName","firstHasTrailingComma","firstIsEmpty","reduce","result","needsComma","specifiersText","fixes","push","fixer","insertTextAfter","insertTextBefore","remove","charAfterImportRange","charAfterImport","substring","removeRange","_didIteratorError3","_iteratorError3","_iterator3","_didIteratorError4","_iteratorError4","_iterator4","value","type","defaultSpecifier","local","name","hasCommentBefore","hasCommentAfter","hasCommentInsideNonSpecifiers","comment","loc","end","line","start","getCommentsAfter","openBraceIndex","findIndex","closeBraceIndex","someTokens","concat","exports","meta","docs","url","fixable","schema","properties","considerQueryString","additionalProperties","create","considerQueryStringOption","options","defaultResolver","sourcePath","resolver","parts","match","moduleMaps","Map","getImportMap","n","has","parent","set","nsImported","defaultTypesImported","namedTypesImported","get","importKind","ImportDeclaration","resolvedPath","importMap","values","_didIteratorError5","_iteratorError5","_iterator5"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\no-duplicates.js"],"sourcesContent":["import resolve from 'eslint-module-utils/resolve';\nimport docsUrl from '../docsUrl';\n\nfunction checkImports(imported, context) {\n  for (const [module, nodes] of imported.entries()) {\n    if (nodes.length > 1) {\n      const message = `'${module}' imported multiple times.`;\n      const [first, ...rest] = nodes;\n      const sourceCode = context.getSourceCode();\n      const fix = getFix(first, rest, sourceCode);\n\n      context.report({\n        node: first.source,\n        message,\n        fix, // Attach the autofix (if any) to the first import.\n      });\n\n      for (const node of rest) {\n        context.report({\n          node: node.source,\n          message,\n        });\n      }\n    }\n  }\n}\n\nfunction getFix(first, rest, sourceCode) {\n  // Sorry ESLint <= 3 users, no autofix for you. Autofixing duplicate imports\n  // requires multiple `fixer.whatever()` calls in the `fix`: We both need to\n  // update the first one, and remove the rest. Support for multiple\n  // `fixer.whatever()` in a single `fix` was added in ESLint 4.1.\n  // `sourceCode.getCommentsBefore` was added in 4.0, so that's an easy thing to\n  // check for.\n  if (typeof sourceCode.getCommentsBefore !== 'function') {\n    return undefined;\n  }\n\n  // Adjusting the first import might make it multiline, which could break\n  // `eslint-disable-next-line` comments and similar, so bail if the first\n  // import has comments. Also, if the first import is `import * as ns from\n  // './foo'` there's nothing we can do.\n  if (hasProblematicComments(first, sourceCode) || hasNamespace(first)) {\n    return undefined;\n  }\n\n  const defaultImportNames = new Set(\n    [first, ...rest].map(getDefaultImportName).filter(Boolean),\n  );\n\n  // Bail if there are multiple different default import names – it's up to the\n  // user to choose which one to keep.\n  if (defaultImportNames.size > 1) {\n    return undefined;\n  }\n\n  // Leave it to the user to handle comments. Also skip `import * as ns from\n  // './foo'` imports, since they cannot be merged into another import.\n  const restWithoutComments = rest.filter(node => !(\n    hasProblematicComments(node, sourceCode) ||\n    hasNamespace(node)\n  ));\n\n  const specifiers = restWithoutComments\n    .map(node => {\n      const tokens = sourceCode.getTokens(node);\n      const openBrace = tokens.find(token => isPunctuator(token, '{'));\n      const closeBrace = tokens.find(token => isPunctuator(token, '}'));\n\n      if (openBrace == null || closeBrace == null) {\n        return undefined;\n      }\n\n      return {\n        importNode: node,\n        text: sourceCode.text.slice(openBrace.range[1], closeBrace.range[0]),\n        hasTrailingComma: isPunctuator(sourceCode.getTokenBefore(closeBrace), ','),\n        isEmpty: !hasSpecifiers(node),\n      };\n    })\n    .filter(Boolean);\n\n  const unnecessaryImports = restWithoutComments.filter(node =>\n    !hasSpecifiers(node) &&\n    !hasNamespace(node) &&\n    !specifiers.some(specifier => specifier.importNode === node),\n  );\n\n  const shouldAddDefault = getDefaultImportName(first) == null && defaultImportNames.size === 1;\n  const shouldAddSpecifiers = specifiers.length > 0;\n  const shouldRemoveUnnecessary = unnecessaryImports.length > 0;\n\n  if (!(shouldAddDefault || shouldAddSpecifiers || shouldRemoveUnnecessary)) {\n    return undefined;\n  }\n\n  return fixer => {\n    const tokens = sourceCode.getTokens(first);\n    const openBrace = tokens.find(token => isPunctuator(token, '{'));\n    const closeBrace = tokens.find(token => isPunctuator(token, '}'));\n    const firstToken = sourceCode.getFirstToken(first);\n    const [defaultImportName] = defaultImportNames;\n\n    const firstHasTrailingComma =\n      closeBrace != null &&\n      isPunctuator(sourceCode.getTokenBefore(closeBrace), ',');\n    const firstIsEmpty = !hasSpecifiers(first);\n\n    const [specifiersText] = specifiers.reduce(\n      ([result, needsComma], specifier) => {\n        return [\n          needsComma && !specifier.isEmpty\n            ? `${result},${specifier.text}`\n            : `${result}${specifier.text}`,\n          specifier.isEmpty ? needsComma : true,\n        ];\n      },\n      ['', !firstHasTrailingComma && !firstIsEmpty],\n    );\n\n    const fixes = [];\n\n    if (shouldAddDefault && openBrace == null && shouldAddSpecifiers) {\n      // `import './foo'` → `import def, {...} from './foo'`\n      fixes.push(\n        fixer.insertTextAfter(firstToken, ` ${defaultImportName}, {${specifiersText}} from`),\n      );\n    } else if (shouldAddDefault && openBrace == null && !shouldAddSpecifiers) {\n      // `import './foo'` → `import def from './foo'`\n      fixes.push(fixer.insertTextAfter(firstToken, ` ${defaultImportName} from`));\n    } else if (shouldAddDefault && openBrace != null && closeBrace != null) {\n      // `import {...} from './foo'` → `import def, {...} from './foo'`\n      fixes.push(fixer.insertTextAfter(firstToken, ` ${defaultImportName},`));\n      if (shouldAddSpecifiers) {\n        // `import def, {...} from './foo'` → `import def, {..., ...} from './foo'`\n        fixes.push(fixer.insertTextBefore(closeBrace, specifiersText));\n      }\n    } else if (!shouldAddDefault && openBrace == null && shouldAddSpecifiers) {\n      if (first.specifiers.length === 0) {\n        // `import './foo'` → `import {...} from './foo'`\n        fixes.push(fixer.insertTextAfter(firstToken, ` {${specifiersText}} from`));\n      } else {\n        // `import def from './foo'` → `import def, {...} from './foo'`\n        fixes.push(fixer.insertTextAfter(first.specifiers[0], `, {${specifiersText}}`));\n      }\n    } else if (!shouldAddDefault && openBrace != null && closeBrace != null) {\n      // `import {...} './foo'` → `import {..., ...} from './foo'`\n      fixes.push(fixer.insertTextBefore(closeBrace, specifiersText));\n    }\n\n    // Remove imports whose specifiers have been moved into the first import.\n    for (const specifier of specifiers) {\n      const importNode = specifier.importNode;\n      fixes.push(fixer.remove(importNode));\n\n      const charAfterImportRange = [importNode.range[1], importNode.range[1] + 1];\n      const charAfterImport = sourceCode.text.substring(charAfterImportRange[0], charAfterImportRange[1]);\n      if (charAfterImport === '\\n') {\n        fixes.push(fixer.removeRange(charAfterImportRange));\n      }\n    }\n\n    // Remove imports whose default import has been moved to the first import,\n    // and side-effect-only imports that are unnecessary due to the first\n    // import.\n    for (const node of unnecessaryImports) {\n      fixes.push(fixer.remove(node));\n\n      const charAfterImportRange = [node.range[1], node.range[1] + 1];\n      const charAfterImport = sourceCode.text.substring(charAfterImportRange[0], charAfterImportRange[1]);\n      if (charAfterImport === '\\n') {\n        fixes.push(fixer.removeRange(charAfterImportRange));\n      }\n    }\n\n    return fixes;\n  };\n}\n\nfunction isPunctuator(node, value) {\n  return node.type === 'Punctuator' && node.value === value;\n}\n\n// Get the name of the default import of `node`, if any.\nfunction getDefaultImportName(node) {\n  const defaultSpecifier = node.specifiers\n    .find(specifier => specifier.type === 'ImportDefaultSpecifier');\n  return defaultSpecifier != null ? defaultSpecifier.local.name : undefined;\n}\n\n// Checks whether `node` has a namespace import.\nfunction hasNamespace(node) {\n  const specifiers = node.specifiers\n    .filter(specifier => specifier.type === 'ImportNamespaceSpecifier');\n  return specifiers.length > 0;\n}\n\n// Checks whether `node` has any non-default specifiers.\nfunction hasSpecifiers(node) {\n  const specifiers = node.specifiers\n    .filter(specifier => specifier.type === 'ImportSpecifier');\n  return specifiers.length > 0;\n}\n\n// It's not obvious what the user wants to do with comments associated with\n// duplicate imports, so skip imports with comments when autofixing.\nfunction hasProblematicComments(node, sourceCode) {\n  return (\n    hasCommentBefore(node, sourceCode) ||\n    hasCommentAfter(node, sourceCode) ||\n    hasCommentInsideNonSpecifiers(node, sourceCode)\n  );\n}\n\n// Checks whether `node` has a comment (that ends) on the previous line or on\n// the same line as `node` (starts).\nfunction hasCommentBefore(node, sourceCode) {\n  return sourceCode.getCommentsBefore(node)\n    .some(comment => comment.loc.end.line >= node.loc.start.line - 1);\n}\n\n// Checks whether `node` has a comment (that starts) on the same line as `node`\n// (ends).\nfunction hasCommentAfter(node, sourceCode) {\n  return sourceCode.getCommentsAfter(node)\n    .some(comment => comment.loc.start.line === node.loc.end.line);\n}\n\n// Checks whether `node` has any comments _inside,_ except inside the `{...}`\n// part (if any).\nfunction hasCommentInsideNonSpecifiers(node, sourceCode) {\n  const tokens = sourceCode.getTokens(node);\n  const openBraceIndex = tokens.findIndex(token => isPunctuator(token, '{'));\n  const closeBraceIndex = tokens.findIndex(token => isPunctuator(token, '}'));\n  // Slice away the first token, since we're no looking for comments _before_\n  // `node` (only inside). If there's a `{...}` part, look for comments before\n  // the `{`, but not before the `}` (hence the `+1`s).\n  const someTokens = openBraceIndex >= 0 && closeBraceIndex >= 0\n    ? tokens.slice(1, openBraceIndex + 1).concat(tokens.slice(closeBraceIndex + 1))\n    : tokens.slice(1);\n  return someTokens.some(token => sourceCode.getCommentsBefore(token).length > 0);\n}\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      url: docsUrl('no-duplicates'),\n    },\n    fixable: 'code',\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          considerQueryString: {\n            type: 'boolean',\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n  },\n\n  create(context) {\n    // Prepare the resolver from options.\n    const considerQueryStringOption = context.options[0] &&\n      context.options[0]['considerQueryString'];\n    const defaultResolver = sourcePath => resolve(sourcePath, context) || sourcePath;\n    const resolver = considerQueryStringOption ? (sourcePath => {\n      const parts = sourcePath.match(/^([^?]*)\\?(.*)$/);\n      if (!parts) {\n        return defaultResolver(sourcePath);\n      }\n      return defaultResolver(parts[1]) + '?' + parts[2];\n    }) : defaultResolver;\n\n    const moduleMaps = new Map();\n\n    function getImportMap(n) {\n      if (!moduleMaps.has(n.parent)) {\n        moduleMaps.set(n.parent, {\n          imported: new Map(),\n          nsImported: new Map(),\n          defaultTypesImported: new Map(),\n          namedTypesImported: new Map(),\n        });\n      }\n      const map = moduleMaps.get(n.parent);\n      if (n.importKind === 'type') {\n        return n.specifiers.length > 0 && n.specifiers[0].type === 'ImportDefaultSpecifier' ? map.defaultTypesImported : map.namedTypesImported;\n      }\n\n      return hasNamespace(n) ? map.nsImported : map.imported;\n    }\n\n    return {\n      ImportDeclaration(n) {\n        // resolved path will cover aliased duplicates\n        const resolvedPath = resolver(n.source.value);\n        const importMap = getImportMap(n);\n\n        if (importMap.has(resolvedPath)) {\n          importMap.get(resolvedPath).push(n);\n        } else {\n          importMap.set(resolvedPath, [n]);\n        }\n      },\n\n      'Program:exit': function () {\n        for (const map of moduleMaps.values()) {\n          checkImports(map.imported, context);\n          checkImports(map.nsImported, context);\n          checkImports(map.defaultTypesImported, context);\n          checkImports(map.namedTypesImported, context);\n        }\n      },\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"script"}