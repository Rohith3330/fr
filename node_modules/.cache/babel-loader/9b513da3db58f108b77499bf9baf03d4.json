{"ast":null,"code":"/**\n * Socket implementation that uses flash SocketPool class as a backend.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nrequire('./util'); // define net namespace\n\n\nvar net = module.exports = forge.net = forge.net || {}; // map of flash ID to socket pool\n\nnet.socketPools = {};\n/**\n * Creates a flash socket pool.\n *\n * @param options:\n *          flashId: the dom ID for the flash object element.\n *          policyPort: the default policy port for sockets, 0 to use the\n *            flash default.\n *          policyUrl: the default policy file URL for sockets (if provided\n *            used instead of a policy port).\n *          msie: true if the browser is msie, false if not.\n *\n * @return the created socket pool.\n */\n\nnet.createSocketPool = function (options) {\n  // set default\n  options.msie = options.msie || false; // initialize the flash interface\n\n  var spId = options.flashId;\n  var api = document.getElementById(spId);\n  api.init({\n    marshallExceptions: !options.msie\n  }); // create socket pool entry\n\n  var sp = {\n    // ID of the socket pool\n    id: spId,\n    // flash interface\n    flashApi: api,\n    // map of socket ID to sockets\n    sockets: {},\n    // default policy port\n    policyPort: options.policyPort || 0,\n    // default policy URL\n    policyUrl: options.policyUrl || null\n  };\n  net.socketPools[spId] = sp; // create event handler, subscribe to flash events\n\n  if (options.msie === true) {\n    sp.handler = function (e) {\n      if (e.id in sp.sockets) {\n        // get handler function\n        var f;\n\n        switch (e.type) {\n          case 'connect':\n            f = 'connected';\n            break;\n\n          case 'close':\n            f = 'closed';\n            break;\n\n          case 'socketData':\n            f = 'data';\n            break;\n\n          default:\n            f = 'error';\n            break;\n        }\n        /* IE calls javascript on the thread of the external object\n          that triggered the event (in this case flash) ... which will\n          either run concurrently with other javascript or pre-empt any\n          running javascript in the middle of its execution (BAD!) ...\n          calling setTimeout() will schedule the javascript to run on\n          the javascript thread and solve this EVIL problem. */\n\n\n        setTimeout(function () {\n          sp.sockets[e.id][f](e);\n        }, 0);\n      }\n    };\n  } else {\n    sp.handler = function (e) {\n      if (e.id in sp.sockets) {\n        // get handler function\n        var f;\n\n        switch (e.type) {\n          case 'connect':\n            f = 'connected';\n            break;\n\n          case 'close':\n            f = 'closed';\n            break;\n\n          case 'socketData':\n            f = 'data';\n            break;\n\n          default:\n            f = 'error';\n            break;\n        }\n\n        sp.sockets[e.id][f](e);\n      }\n    };\n  }\n\n  var handler = 'forge.net.socketPools[\\'' + spId + '\\'].handler';\n  api.subscribe('connect', handler);\n  api.subscribe('close', handler);\n  api.subscribe('socketData', handler);\n  api.subscribe('ioError', handler);\n  api.subscribe('securityError', handler);\n  /**\n   * Destroys a socket pool. The socket pool still needs to be cleaned\n   * up via net.cleanup().\n   */\n\n  sp.destroy = function () {\n    delete net.socketPools[options.flashId];\n\n    for (var id in sp.sockets) {\n      sp.sockets[id].destroy();\n    }\n\n    sp.sockets = {};\n    api.cleanup();\n  };\n  /**\n   * Creates a new socket.\n   *\n   * @param options:\n   *          connected: function(event) called when the socket connects.\n   *          closed: function(event) called when the socket closes.\n   *          data: function(event) called when socket data has arrived,\n   *            it can be read from the socket using receive().\n   *          error: function(event) called when a socket error occurs.\n   */\n\n\n  sp.createSocket = function (options) {\n    // default to empty options\n    options = options || {}; // create flash socket\n\n    var id = api.create(); // create javascript socket wrapper\n\n    var socket = {\n      id: id,\n      // set handlers\n      connected: options.connected || function (e) {},\n      closed: options.closed || function (e) {},\n      data: options.data || function (e) {},\n      error: options.error || function (e) {}\n    };\n    /**\n     * Destroys this socket.\n     */\n\n    socket.destroy = function () {\n      api.destroy(id);\n      delete sp.sockets[id];\n    };\n    /**\n     * Connects this socket.\n     *\n     * @param options:\n     *          host: the host to connect to.\n     *          port: the port to connect to.\n     *          policyPort: the policy port to use (if non-default), 0 to\n     *            use the flash default.\n     *          policyUrl: the policy file URL to use (instead of port).\n     */\n\n\n    socket.connect = function (options) {\n      // give precedence to policy URL over policy port\n      // if no policy URL and passed port isn't 0, use default port,\n      // otherwise use 0 for the port\n      var policyUrl = options.policyUrl || null;\n      var policyPort = 0;\n\n      if (policyUrl === null && options.policyPort !== 0) {\n        policyPort = options.policyPort || sp.policyPort;\n      }\n\n      api.connect(id, options.host, options.port, policyPort, policyUrl);\n    };\n    /**\n     * Closes this socket.\n     */\n\n\n    socket.close = function () {\n      api.close(id);\n      socket.closed({\n        id: socket.id,\n        type: 'close',\n        bytesAvailable: 0\n      });\n    };\n    /**\n     * Determines if the socket is connected or not.\n     *\n     * @return true if connected, false if not.\n     */\n\n\n    socket.isConnected = function () {\n      return api.isConnected(id);\n    };\n    /**\n     * Writes bytes to this socket.\n     *\n     * @param bytes the bytes (as a string) to write.\n     *\n     * @return true on success, false on failure.\n     */\n\n\n    socket.send = function (bytes) {\n      return api.send(id, forge.util.encode64(bytes));\n    };\n    /**\n     * Reads bytes from this socket (non-blocking). Fewer than the number\n     * of bytes requested may be read if enough bytes are not available.\n     *\n     * This method should be called from the data handler if there are\n     * enough bytes available. To see how many bytes are available, check\n     * the 'bytesAvailable' property on the event in the data handler or\n     * call the bytesAvailable() function on the socket. If the browser is\n     * msie, then the bytesAvailable() function should be used to avoid\n     * race conditions. Otherwise, using the property on the data handler's\n     * event may be quicker.\n     *\n     * @param count the maximum number of bytes to read.\n     *\n     * @return the bytes read (as a string) or null on error.\n     */\n\n\n    socket.receive = function (count) {\n      var rval = api.receive(id, count).rval;\n      return rval === null ? null : forge.util.decode64(rval);\n    };\n    /**\n     * Gets the number of bytes available for receiving on the socket.\n     *\n     * @return the number of bytes available for receiving.\n     */\n\n\n    socket.bytesAvailable = function () {\n      return api.getBytesAvailable(id);\n    }; // store and return socket\n\n\n    sp.sockets[id] = socket;\n    return socket;\n  };\n\n  return sp;\n};\n/**\n * Destroys a flash socket pool.\n *\n * @param options:\n *          flashId: the dom ID for the flash object element.\n */\n\n\nnet.destroySocketPool = function (options) {\n  if (options.flashId in net.socketPools) {\n    var sp = net.socketPools[options.flashId];\n    sp.destroy();\n  }\n};\n/**\n * Creates a new socket.\n *\n * @param options:\n *          flashId: the dom ID for the flash object element.\n *          connected: function(event) called when the socket connects.\n *          closed: function(event) called when the socket closes.\n *          data: function(event) called when socket data has arrived, it\n *            can be read from the socket using receive().\n *          error: function(event) called when a socket error occurs.\n *\n * @return the created socket.\n */\n\n\nnet.createSocket = function (options) {\n  var socket = null;\n\n  if (options.flashId in net.socketPools) {\n    // get related socket pool\n    var sp = net.socketPools[options.flashId];\n    socket = sp.createSocket(options);\n  }\n\n  return socket;\n};","map":{"version":3,"names":["forge","require","net","module","exports","socketPools","createSocketPool","options","msie","spId","flashId","api","document","getElementById","init","marshallExceptions","sp","id","flashApi","sockets","policyPort","policyUrl","handler","e","f","type","setTimeout","subscribe","destroy","cleanup","createSocket","create","socket","connected","closed","data","error","connect","host","port","close","bytesAvailable","isConnected","send","bytes","util","encode64","receive","count","rval","decode64","getBytesAvailable","destroySocketPool"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/node-forge/lib/socket.js"],"sourcesContent":["/**\n * Socket implementation that uses flash SocketPool class as a backend.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./util');\n\n// define net namespace\nvar net = module.exports = forge.net = forge.net || {};\n\n// map of flash ID to socket pool\nnet.socketPools = {};\n\n/**\n * Creates a flash socket pool.\n *\n * @param options:\n *          flashId: the dom ID for the flash object element.\n *          policyPort: the default policy port for sockets, 0 to use the\n *            flash default.\n *          policyUrl: the default policy file URL for sockets (if provided\n *            used instead of a policy port).\n *          msie: true if the browser is msie, false if not.\n *\n * @return the created socket pool.\n */\nnet.createSocketPool = function(options) {\n  // set default\n  options.msie = options.msie || false;\n\n  // initialize the flash interface\n  var spId = options.flashId;\n  var api = document.getElementById(spId);\n  api.init({marshallExceptions: !options.msie});\n\n  // create socket pool entry\n  var sp = {\n    // ID of the socket pool\n    id: spId,\n    // flash interface\n    flashApi: api,\n    // map of socket ID to sockets\n    sockets: {},\n    // default policy port\n    policyPort: options.policyPort || 0,\n    // default policy URL\n    policyUrl: options.policyUrl || null\n  };\n  net.socketPools[spId] = sp;\n\n  // create event handler, subscribe to flash events\n  if(options.msie === true) {\n    sp.handler = function(e) {\n      if(e.id in sp.sockets) {\n        // get handler function\n        var f;\n        switch(e.type) {\n        case 'connect':\n          f = 'connected';\n          break;\n        case 'close':\n          f = 'closed';\n          break;\n        case 'socketData':\n          f = 'data';\n          break;\n        default:\n          f = 'error';\n          break;\n        }\n        /* IE calls javascript on the thread of the external object\n          that triggered the event (in this case flash) ... which will\n          either run concurrently with other javascript or pre-empt any\n          running javascript in the middle of its execution (BAD!) ...\n          calling setTimeout() will schedule the javascript to run on\n          the javascript thread and solve this EVIL problem. */\n        setTimeout(function() {sp.sockets[e.id][f](e);}, 0);\n      }\n    };\n  } else {\n    sp.handler = function(e) {\n      if(e.id in sp.sockets) {\n        // get handler function\n        var f;\n        switch(e.type) {\n        case 'connect':\n          f = 'connected';\n          break;\n        case 'close':\n          f = 'closed';\n          break;\n        case 'socketData':\n          f = 'data';\n          break;\n        default:\n          f = 'error';\n          break;\n        }\n        sp.sockets[e.id][f](e);\n      }\n    };\n  }\n  var handler = 'forge.net.socketPools[\\'' + spId + '\\'].handler';\n  api.subscribe('connect', handler);\n  api.subscribe('close', handler);\n  api.subscribe('socketData', handler);\n  api.subscribe('ioError', handler);\n  api.subscribe('securityError', handler);\n\n  /**\n   * Destroys a socket pool. The socket pool still needs to be cleaned\n   * up via net.cleanup().\n   */\n  sp.destroy = function() {\n    delete net.socketPools[options.flashId];\n    for(var id in sp.sockets) {\n      sp.sockets[id].destroy();\n    }\n    sp.sockets = {};\n    api.cleanup();\n  };\n\n  /**\n   * Creates a new socket.\n   *\n   * @param options:\n   *          connected: function(event) called when the socket connects.\n   *          closed: function(event) called when the socket closes.\n   *          data: function(event) called when socket data has arrived,\n   *            it can be read from the socket using receive().\n   *          error: function(event) called when a socket error occurs.\n   */\n   sp.createSocket = function(options) {\n     // default to empty options\n     options = options || {};\n\n     // create flash socket\n     var id = api.create();\n\n     // create javascript socket wrapper\n     var socket = {\n       id: id,\n       // set handlers\n       connected: options.connected || function(e) {},\n       closed: options.closed || function(e) {},\n       data: options.data || function(e) {},\n       error: options.error || function(e) {}\n     };\n\n     /**\n      * Destroys this socket.\n      */\n     socket.destroy = function() {\n       api.destroy(id);\n       delete sp.sockets[id];\n     };\n\n     /**\n      * Connects this socket.\n      *\n      * @param options:\n      *          host: the host to connect to.\n      *          port: the port to connect to.\n      *          policyPort: the policy port to use (if non-default), 0 to\n      *            use the flash default.\n      *          policyUrl: the policy file URL to use (instead of port).\n      */\n     socket.connect = function(options) {\n       // give precedence to policy URL over policy port\n       // if no policy URL and passed port isn't 0, use default port,\n       // otherwise use 0 for the port\n       var policyUrl = options.policyUrl || null;\n       var policyPort = 0;\n       if(policyUrl === null && options.policyPort !== 0) {\n         policyPort = options.policyPort || sp.policyPort;\n       }\n       api.connect(id, options.host, options.port, policyPort, policyUrl);\n     };\n\n     /**\n      * Closes this socket.\n      */\n     socket.close = function() {\n       api.close(id);\n       socket.closed({\n         id: socket.id,\n         type: 'close',\n         bytesAvailable: 0\n       });\n     };\n\n     /**\n      * Determines if the socket is connected or not.\n      *\n      * @return true if connected, false if not.\n      */\n     socket.isConnected = function() {\n       return api.isConnected(id);\n     };\n\n     /**\n      * Writes bytes to this socket.\n      *\n      * @param bytes the bytes (as a string) to write.\n      *\n      * @return true on success, false on failure.\n      */\n     socket.send = function(bytes) {\n       return api.send(id, forge.util.encode64(bytes));\n     };\n\n     /**\n      * Reads bytes from this socket (non-blocking). Fewer than the number\n      * of bytes requested may be read if enough bytes are not available.\n      *\n      * This method should be called from the data handler if there are\n      * enough bytes available. To see how many bytes are available, check\n      * the 'bytesAvailable' property on the event in the data handler or\n      * call the bytesAvailable() function on the socket. If the browser is\n      * msie, then the bytesAvailable() function should be used to avoid\n      * race conditions. Otherwise, using the property on the data handler's\n      * event may be quicker.\n      *\n      * @param count the maximum number of bytes to read.\n      *\n      * @return the bytes read (as a string) or null on error.\n      */\n     socket.receive = function(count) {\n       var rval = api.receive(id, count).rval;\n       return (rval === null) ? null : forge.util.decode64(rval);\n     };\n\n     /**\n      * Gets the number of bytes available for receiving on the socket.\n      *\n      * @return the number of bytes available for receiving.\n      */\n     socket.bytesAvailable = function() {\n       return api.getBytesAvailable(id);\n     };\n\n     // store and return socket\n     sp.sockets[id] = socket;\n     return socket;\n  };\n\n  return sp;\n};\n\n/**\n * Destroys a flash socket pool.\n *\n * @param options:\n *          flashId: the dom ID for the flash object element.\n */\nnet.destroySocketPool = function(options) {\n  if(options.flashId in net.socketPools) {\n    var sp = net.socketPools[options.flashId];\n    sp.destroy();\n  }\n};\n\n/**\n * Creates a new socket.\n *\n * @param options:\n *          flashId: the dom ID for the flash object element.\n *          connected: function(event) called when the socket connects.\n *          closed: function(event) called when the socket closes.\n *          data: function(event) called when socket data has arrived, it\n *            can be read from the socket using receive().\n *          error: function(event) called when a socket error occurs.\n *\n * @return the created socket.\n */\nnet.createSocket = function(options) {\n  var socket = null;\n  if(options.flashId in net.socketPools) {\n    // get related socket pool\n    var sp = net.socketPools[options.flashId];\n    socket = sp.createSocket(options);\n  }\n  return socket;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}