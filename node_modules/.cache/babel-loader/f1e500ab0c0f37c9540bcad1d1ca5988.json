{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst validate_1 = require(\"../../compile/validate\");\n\nconst code_1 = require(\"../code\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst additionalProperties_1 = require(\"./additionalProperties\");\n\nconst def = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      it\n    } = cxt;\n\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, \"additionalProperties\"));\n    }\n\n    const allProps = (0, code_1.allSchemaProperties)(schema);\n\n    for (const prop of allProps) {\n      it.definedProperties.add(prop);\n    }\n\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);\n    }\n\n    const properties = allProps.filter(p => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n    if (properties.length === 0) return;\n    const valid = gen.name(\"valid\");\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop);\n      } else {\n        gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));\n        applyPropertySchema(prop);\n        if (!it.allErrors) gen.else().var(valid, true);\n        gen.endIf();\n      }\n\n      cxt.it.definedProperties.add(prop);\n      cxt.ok(valid);\n    }\n\n    function hasDefault(prop) {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined;\n    }\n\n    function applyPropertySchema(prop) {\n      cxt.subschema({\n        keyword: \"properties\",\n        schemaProp: prop,\n        dataProp: prop\n      }, valid);\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":";;;;;;AACA;;AACA;;AACA;;AACA;;AAEA,MAAMA,GAAG,GAA0B;EACjCC,OAAO,EAAE,YADwB;EAEjCC,IAAI,EAAE,QAF2B;EAGjCC,UAAU,EAAE,QAHqB;;EAIjCC,IAAI,CAACC,GAAD,EAAgB;IAClB,MAAM;MAACC,GAAD;MAAMC,MAAN;MAAcC,YAAd;MAA4BC,IAA5B;MAAkCC;IAAlC,IAAwCL,GAA9C;;IACA,IAAIK,EAAE,CAACC,IAAH,CAAQC,gBAAR,KAA6B,KAA7B,IAAsCJ,YAAY,CAACK,oBAAb,KAAsCC,SAAhF,EAA2F;MACzFC,+BAAMX,IAAN,CAAW,IAAIY,qBAAJ,CAAeN,EAAf,EAAmBK,8BAAnB,EAA0B,sBAA1B,CAAX;IACD;;IACD,MAAME,QAAQ,GAAG,gCAAoBV,MAApB,CAAjB;;IACA,KAAK,MAAMW,IAAX,IAAmBD,QAAnB,EAA6B;MAC3BP,EAAE,CAACS,iBAAH,CAAqBC,GAArB,CAAyBF,IAAzB;IACD;;IACD,IAAIR,EAAE,CAACC,IAAH,CAAQU,WAAR,IAAuBJ,QAAQ,CAACK,MAAhC,IAA0CZ,EAAE,CAACa,KAAH,KAAa,IAA3D,EAAiE;MAC/Db,EAAE,CAACa,KAAH,GAAWC,sBAAeD,KAAf,CAAqBjB,GAArB,EAA0B,mBAAOW,QAAP,CAA1B,EAA4CP,EAAE,CAACa,KAA/C,CAAX;IACD;;IACD,MAAME,UAAU,GAAGR,QAAQ,CAACS,MAAT,CAAiBC,CAAD,IAAO,CAAC,8BAAkBjB,EAAlB,EAAsBH,MAAM,CAACoB,CAAD,CAA5B,CAAxB,CAAnB;IACA,IAAIF,UAAU,CAACH,MAAX,KAAsB,CAA1B,EAA6B;IAC7B,MAAMM,KAAK,GAAGtB,GAAG,CAACuB,IAAJ,CAAS,OAAT,CAAd;;IAEA,KAAK,MAAMX,IAAX,IAAmBO,UAAnB,EAA+B;MAC7B,IAAIK,UAAU,CAACZ,IAAD,CAAd,EAAsB;QACpBa,mBAAmB,CAACb,IAAD,CAAnB;MACD,CAFD,MAEO;QACLZ,GAAG,CAAC0B,EAAJ,CAAO,2BAAe1B,GAAf,EAAoBG,IAApB,EAA0BS,IAA1B,EAAgCR,EAAE,CAACC,IAAH,CAAQsB,aAAxC,CAAP;QACAF,mBAAmB,CAACb,IAAD,CAAnB;QACA,IAAI,CAACR,EAAE,CAACwB,SAAR,EAAmB5B,GAAG,CAAC6B,IAAJ,GAAWC,GAAX,CAAeR,KAAf,EAAsB,IAAtB;QACnBtB,GAAG,CAAC+B,KAAJ;MACD;;MACDhC,GAAG,CAACK,EAAJ,CAAOS,iBAAP,CAAyBC,GAAzB,CAA6BF,IAA7B;MACAb,GAAG,CAACiC,EAAJ,CAAOV,KAAP;IACD;;IAED,SAASE,UAAT,CAAoBZ,IAApB,EAAgC;MAC9B,OAAOR,EAAE,CAACC,IAAH,CAAQ4B,WAAR,IAAuB,CAAC7B,EAAE,CAAC8B,aAA3B,IAA4CjC,MAAM,CAACW,IAAD,CAAN,CAAauB,OAAb,KAAyB3B,SAA5E;IACD;;IAED,SAASiB,mBAAT,CAA6Bb,IAA7B,EAAyC;MACvCb,GAAG,CAACqC,SAAJ,CACE;QACEzC,OAAO,EAAE,YADX;QAEE0C,UAAU,EAAEzB,IAFd;QAGE0B,QAAQ,EAAE1B;MAHZ,CADF,EAMEU,KANF;IAQD;EACF;;AA/CgC,CAAnC;AAkDAiB,kBAAe7C,GAAf","names":["def","keyword","type","schemaType","code","cxt","gen","schema","parentSchema","data","it","opts","removeAdditional","additionalProperties","undefined","additionalProperties_1","validate_1","allProps","prop","definedProperties","add","unevaluated","length","props","util_1","properties","filter","p","valid","name","hasDefault","applyPropertySchema","if","ownProperties","allErrors","else","var","endIf","ok","useDefaults","compositeRule","default","subschema","schemaProp","dataProp","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-webpack-plugin\\node_modules\\ajv\\lib\\vocabularies\\applicator\\properties.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}