{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transform = transform;\n\nvar t = require(\"../../index\"); // func and call_indirect instructions can either define a signature inline, or\n// reference a signature, e.g.\n//\n// ;; inline signature\n// (func (result i64)\n//   (i64.const 2)\n// )\n// ;; signature reference\n// (type (func (result i64)))\n// (func (type 0)\n//   (i64.const 2))\n// )\n//\n// this AST transform denormalises the type references, making all signatures within the module\n// inline.\n\n\nfunction transform(ast) {\n  var typeInstructions = [];\n  t.traverse(ast, {\n    TypeInstruction: function TypeInstruction(_ref) {\n      var node = _ref.node;\n      typeInstructions.push(node);\n    }\n  });\n\n  if (!typeInstructions.length) {\n    return;\n  }\n\n  function denormalizeSignature(signature) {\n    // signature referenced by identifier\n    if (signature.type === \"Identifier\") {\n      var identifier = signature;\n      var typeInstruction = typeInstructions.find(function (t) {\n        return t.id.type === identifier.type && t.id.value === identifier.value;\n      });\n\n      if (!typeInstruction) {\n        throw new Error(\"A type instruction reference was not found \".concat(JSON.stringify(signature)));\n      }\n\n      return typeInstruction.functype;\n    } // signature referenced by index\n\n\n    if (signature.type === \"NumberLiteral\") {\n      var signatureRef = signature;\n      var _typeInstruction = typeInstructions[signatureRef.value];\n      return _typeInstruction.functype;\n    }\n\n    return signature;\n  }\n\n  t.traverse(ast, {\n    Func: function (_Func) {\n      function Func(_x) {\n        return _Func.apply(this, arguments);\n      }\n\n      Func.toString = function () {\n        return _Func.toString();\n      };\n\n      return Func;\n    }(function (_ref2) {\n      var node = _ref2.node;\n      node.signature = denormalizeSignature(node.signature);\n    }),\n    CallIndirectInstruction: function CallIndirectInstruction(_ref3) {\n      var node = _ref3.node;\n      node.signature = denormalizeSignature(node.signature);\n    }\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","transform","t","require","ast","typeInstructions","traverse","TypeInstruction","_ref","node","push","length","denormalizeSignature","signature","type","identifier","typeInstruction","find","id","Error","concat","JSON","stringify","functype","signatureRef","_typeInstruction","Func","_Func","_x","apply","arguments","toString","_ref2","CallIndirectInstruction","_ref3"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@webassemblyjs/ast/lib/transform/denormalize-type-references/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transform = transform;\n\nvar t = require(\"../../index\"); // func and call_indirect instructions can either define a signature inline, or\n// reference a signature, e.g.\n//\n// ;; inline signature\n// (func (result i64)\n//   (i64.const 2)\n// )\n// ;; signature reference\n// (type (func (result i64)))\n// (func (type 0)\n//   (i64.const 2))\n// )\n//\n// this AST transform denormalises the type references, making all signatures within the module\n// inline.\n\n\nfunction transform(ast) {\n  var typeInstructions = [];\n  t.traverse(ast, {\n    TypeInstruction: function TypeInstruction(_ref) {\n      var node = _ref.node;\n      typeInstructions.push(node);\n    }\n  });\n\n  if (!typeInstructions.length) {\n    return;\n  }\n\n  function denormalizeSignature(signature) {\n    // signature referenced by identifier\n    if (signature.type === \"Identifier\") {\n      var identifier = signature;\n      var typeInstruction = typeInstructions.find(function (t) {\n        return t.id.type === identifier.type && t.id.value === identifier.value;\n      });\n\n      if (!typeInstruction) {\n        throw new Error(\"A type instruction reference was not found \".concat(JSON.stringify(signature)));\n      }\n\n      return typeInstruction.functype;\n    } // signature referenced by index\n\n\n    if (signature.type === \"NumberLiteral\") {\n      var signatureRef = signature;\n      var _typeInstruction = typeInstructions[signatureRef.value];\n      return _typeInstruction.functype;\n    }\n\n    return signature;\n  }\n\n  t.traverse(ast, {\n    Func: function (_Func) {\n      function Func(_x) {\n        return _Func.apply(this, arguments);\n      }\n\n      Func.toString = function () {\n        return _Func.toString();\n      };\n\n      return Func;\n    }(function (_ref2) {\n      var node = _ref2.node;\n      node.signature = denormalizeSignature(node.signature);\n    }),\n    CallIndirectInstruction: function CallIndirectInstruction(_ref3) {\n      var node = _ref3.node;\n      node.signature = denormalizeSignature(node.signature);\n    }\n  });\n}"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,SAAR,GAAoBA,SAApB;;AAEA,IAAIC,CAAC,GAAGC,OAAO,CAAC,aAAD,CAAf,C,CAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASF,SAAT,CAAmBG,GAAnB,EAAwB;EACtB,IAAIC,gBAAgB,GAAG,EAAvB;EACAH,CAAC,CAACI,QAAF,CAAWF,GAAX,EAAgB;IACdG,eAAe,EAAE,SAASA,eAAT,CAAyBC,IAAzB,EAA+B;MAC9C,IAAIC,IAAI,GAAGD,IAAI,CAACC,IAAhB;MACAJ,gBAAgB,CAACK,IAAjB,CAAsBD,IAAtB;IACD;EAJa,CAAhB;;EAOA,IAAI,CAACJ,gBAAgB,CAACM,MAAtB,EAA8B;IAC5B;EACD;;EAED,SAASC,oBAAT,CAA8BC,SAA9B,EAAyC;IACvC;IACA,IAAIA,SAAS,CAACC,IAAV,KAAmB,YAAvB,EAAqC;MACnC,IAAIC,UAAU,GAAGF,SAAjB;MACA,IAAIG,eAAe,GAAGX,gBAAgB,CAACY,IAAjB,CAAsB,UAAUf,CAAV,EAAa;QACvD,OAAOA,CAAC,CAACgB,EAAF,CAAKJ,IAAL,KAAcC,UAAU,CAACD,IAAzB,IAAiCZ,CAAC,CAACgB,EAAF,CAAKlB,KAAL,KAAee,UAAU,CAACf,KAAlE;MACD,CAFqB,CAAtB;;MAIA,IAAI,CAACgB,eAAL,EAAsB;QACpB,MAAM,IAAIG,KAAJ,CAAU,8CAA8CC,MAA9C,CAAqDC,IAAI,CAACC,SAAL,CAAeT,SAAf,CAArD,CAAV,CAAN;MACD;;MAED,OAAOG,eAAe,CAACO,QAAvB;IACD,CAbsC,CAarC;;;IAGF,IAAIV,SAAS,CAACC,IAAV,KAAmB,eAAvB,EAAwC;MACtC,IAAIU,YAAY,GAAGX,SAAnB;MACA,IAAIY,gBAAgB,GAAGpB,gBAAgB,CAACmB,YAAY,CAACxB,KAAd,CAAvC;MACA,OAAOyB,gBAAgB,CAACF,QAAxB;IACD;;IAED,OAAOV,SAAP;EACD;;EAEDX,CAAC,CAACI,QAAF,CAAWF,GAAX,EAAgB;IACdsB,IAAI,EAAE,UAAUC,KAAV,EAAiB;MACrB,SAASD,IAAT,CAAcE,EAAd,EAAkB;QAChB,OAAOD,KAAK,CAACE,KAAN,CAAY,IAAZ,EAAkBC,SAAlB,CAAP;MACD;;MAEDJ,IAAI,CAACK,QAAL,GAAgB,YAAY;QAC1B,OAAOJ,KAAK,CAACI,QAAN,EAAP;MACD,CAFD;;MAIA,OAAOL,IAAP;IACD,CAVK,CAUJ,UAAUM,KAAV,EAAiB;MACjB,IAAIvB,IAAI,GAAGuB,KAAK,CAACvB,IAAjB;MACAA,IAAI,CAACI,SAAL,GAAiBD,oBAAoB,CAACH,IAAI,CAACI,SAAN,CAArC;IACD,CAbK,CADQ;IAedoB,uBAAuB,EAAE,SAASA,uBAAT,CAAiCC,KAAjC,EAAwC;MAC/D,IAAIzB,IAAI,GAAGyB,KAAK,CAACzB,IAAjB;MACAA,IAAI,CAACI,SAAL,GAAiBD,oBAAoB,CAACH,IAAI,CAACI,SAAN,CAArC;IACD;EAlBa,CAAhB;AAoBD"},"metadata":{},"sourceType":"script"}