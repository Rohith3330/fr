{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar DefineOwnProperty = require('../helpers/DefineOwnProperty');\n\nvar isFullyPopulatedPropertyDescriptor = require('../helpers/isFullyPopulatedPropertyDescriptor');\n\nvar isPropertyDescriptor = require('../helpers/isPropertyDescriptor');\n\nvar FromPropertyDescriptor = require('./FromPropertyDescriptor');\n\nvar IsAccessorDescriptor = require('./IsAccessorDescriptor');\n\nvar IsDataDescriptor = require('./IsDataDescriptor');\n\nvar IsGenericDescriptor = require('./IsGenericDescriptor');\n\nvar IsPropertyKey = require('./IsPropertyKey');\n\nvar SameValue = require('./SameValue');\n\nvar Type = require('./Type'); // https://262.ecma-international.org/13.0/#sec-validateandapplypropertydescriptor\n// see https://github.com/tc39/ecma262/pull/2468 for ES2022 changes\n// eslint-disable-next-line max-lines-per-function, max-statements, max-params\n\n\nmodule.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {\n  var oType = Type(O);\n\n  if (oType !== 'Undefined' && oType !== 'Object') {\n    throw new $TypeError('Assertion failed: O must be undefined or an Object');\n  }\n\n  if (!IsPropertyKey(P)) {\n    throw new $TypeError('Assertion failed: P must be a Property Key');\n  }\n\n  if (Type(extensible) !== 'Boolean') {\n    throw new $TypeError('Assertion failed: extensible must be a Boolean');\n  }\n\n  if (!isPropertyDescriptor({\n    Type: Type,\n    IsDataDescriptor: IsDataDescriptor,\n    IsAccessorDescriptor: IsAccessorDescriptor\n  }, Desc)) {\n    throw new $TypeError('Assertion failed: Desc must be a Property Descriptor');\n  }\n\n  if (Type(current) !== 'Undefined' && !isPropertyDescriptor({\n    Type: Type,\n    IsDataDescriptor: IsDataDescriptor,\n    IsAccessorDescriptor: IsAccessorDescriptor\n  }, current)) {\n    throw new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');\n  }\n\n  if (Type(current) === 'Undefined') {\n    // step 2\n    if (!extensible) {\n      return false; // step 2.a\n    }\n\n    if (oType === 'Undefined') {\n      return true; // step 2.b\n    }\n\n    if (IsAccessorDescriptor(Desc)) {\n      // step 2.c\n      return DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, Desc);\n    } // step 2.d\n\n\n    return DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, {\n      '[[Configurable]]': !!Desc['[[Configurable]]'],\n      '[[Enumerable]]': !!Desc['[[Enumerable]]'],\n      '[[Value]]': Desc['[[Value]]'],\n      '[[Writable]]': !!Desc['[[Writable]]']\n    });\n  } // 3. Assert: current is a fully populated Property Descriptor.\n\n\n  if (!isFullyPopulatedPropertyDescriptor({\n    IsAccessorDescriptor: IsAccessorDescriptor,\n    IsDataDescriptor: IsDataDescriptor\n  }, current)) {\n    throw new $TypeError('`current`, when present, must be a fully populated and valid Property Descriptor');\n  } // 4. If every field in Desc is absent, return true.\n  // this can't really match the assertion that it's a Property Descriptor in our JS implementation\n  // 5. If current.[[Configurable]] is false, then\n\n\n  if (!current['[[Configurable]]']) {\n    if ('[[Configurable]]' in Desc && Desc['[[Configurable]]']) {\n      // step 5.a\n      return false;\n    }\n\n    if ('[[Enumerable]]' in Desc && !SameValue(Desc['[[Enumerable]]'], current['[[Enumerable]]'])) {\n      // step 5.b\n      return false;\n    }\n\n    if (!IsGenericDescriptor(Desc) && !SameValue(IsAccessorDescriptor(Desc), IsAccessorDescriptor(current))) {\n      // step 5.c\n      return false;\n    }\n\n    if (IsAccessorDescriptor(current)) {\n      // step 5.d\n      if ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {\n        return false;\n      }\n\n      if ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {\n        return false;\n      }\n    } else if (!current['[[Writable]]']) {\n      // step 5.e\n      if ('[[Writable]]' in Desc && Desc['[[Writable]]']) {\n        return false;\n      }\n\n      if ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {\n        return false;\n      }\n    }\n  } // 6. If O is not undefined, then\n\n\n  if (oType !== 'Undefined') {\n    var configurable;\n    var enumerable;\n\n    if (IsDataDescriptor(current) && IsAccessorDescriptor(Desc)) {\n      // step 6.a\n      configurable = ('[[Configurable]]' in Desc ? Desc : current)['[[Configurable]]'];\n      enumerable = ('[[Enumerable]]' in Desc ? Desc : current)['[[Enumerable]]']; // Replace the property named P of object O with an accessor property having [[Configurable]] and [[Enumerable]] attributes as described by current and each other attribute set to its default value.\n\n      return DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, {\n        '[[Configurable]]': !!configurable,\n        '[[Enumerable]]': !!enumerable,\n        '[[Get]]': ('[[Get]]' in Desc ? Desc : current)['[[Get]]'],\n        '[[Set]]': ('[[Set]]' in Desc ? Desc : current)['[[Set]]']\n      });\n    } else if (IsAccessorDescriptor(current) && IsDataDescriptor(Desc)) {\n      configurable = ('[[Configurable]]' in Desc ? Desc : current)['[[Configurable]]'];\n      enumerable = ('[[Enumerable]]' in Desc ? Desc : current)['[[Enumerable]]']; // i. Replace the property named P of object O with a data property having [[Configurable]] and [[Enumerable]] attributes as described by current and each other attribute set to its default value.\n\n      return DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, {\n        '[[Configurable]]': !!configurable,\n        '[[Enumerable]]': !!enumerable,\n        '[[Value]]': ('[[Value]]' in Desc ? Desc : current)['[[Value]]'],\n        '[[Writable]]': !!('[[Writable]]' in Desc ? Desc : current)['[[Writable]]']\n      });\n    } // For each field of Desc that is present, set the corresponding attribute of the property named P of object O to the value of the field.\n\n\n    return DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O, P, Desc);\n  }\n\n  return true; // step 7\n};","map":{"version":3,"names":["GetIntrinsic","require","$TypeError","DefineOwnProperty","isFullyPopulatedPropertyDescriptor","isPropertyDescriptor","FromPropertyDescriptor","IsAccessorDescriptor","IsDataDescriptor","IsGenericDescriptor","IsPropertyKey","SameValue","Type","module","exports","ValidateAndApplyPropertyDescriptor","O","P","extensible","Desc","current","oType","configurable","enumerable"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/es-abstract/2022/ValidateAndApplyPropertyDescriptor.js"],"sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar DefineOwnProperty = require('../helpers/DefineOwnProperty');\nvar isFullyPopulatedPropertyDescriptor = require('../helpers/isFullyPopulatedPropertyDescriptor');\nvar isPropertyDescriptor = require('../helpers/isPropertyDescriptor');\n\nvar FromPropertyDescriptor = require('./FromPropertyDescriptor');\nvar IsAccessorDescriptor = require('./IsAccessorDescriptor');\nvar IsDataDescriptor = require('./IsDataDescriptor');\nvar IsGenericDescriptor = require('./IsGenericDescriptor');\nvar IsPropertyKey = require('./IsPropertyKey');\nvar SameValue = require('./SameValue');\nvar Type = require('./Type');\n\n// https://262.ecma-international.org/13.0/#sec-validateandapplypropertydescriptor\n\n// see https://github.com/tc39/ecma262/pull/2468 for ES2022 changes\n\n// eslint-disable-next-line max-lines-per-function, max-statements, max-params\nmodule.exports = function ValidateAndApplyPropertyDescriptor(O, P, extensible, Desc, current) {\n\tvar oType = Type(O);\n\tif (oType !== 'Undefined' && oType !== 'Object') {\n\t\tthrow new $TypeError('Assertion failed: O must be undefined or an Object');\n\t}\n\tif (!IsPropertyKey(P)) {\n\t\tthrow new $TypeError('Assertion failed: P must be a Property Key');\n\t}\n\tif (Type(extensible) !== 'Boolean') {\n\t\tthrow new $TypeError('Assertion failed: extensible must be a Boolean');\n\t}\n\tif (!isPropertyDescriptor({\n\t\tType: Type,\n\t\tIsDataDescriptor: IsDataDescriptor,\n\t\tIsAccessorDescriptor: IsAccessorDescriptor\n\t}, Desc)) {\n\t\tthrow new $TypeError('Assertion failed: Desc must be a Property Descriptor');\n\t}\n\tif (Type(current) !== 'Undefined' && !isPropertyDescriptor({\n\t\tType: Type,\n\t\tIsDataDescriptor: IsDataDescriptor,\n\t\tIsAccessorDescriptor: IsAccessorDescriptor\n\t}, current)) {\n\t\tthrow new $TypeError('Assertion failed: current must be a Property Descriptor, or undefined');\n\t}\n\n\tif (Type(current) === 'Undefined') { // step 2\n\t\tif (!extensible) {\n\t\t\treturn false; // step 2.a\n\t\t}\n\t\tif (oType === 'Undefined') {\n\t\t\treturn true; // step 2.b\n\t\t}\n\t\tif (IsAccessorDescriptor(Desc)) { // step 2.c\n\t\t\treturn DefineOwnProperty(\n\t\t\t\tIsDataDescriptor,\n\t\t\t\tSameValue,\n\t\t\t\tFromPropertyDescriptor,\n\t\t\t\tO,\n\t\t\t\tP,\n\t\t\t\tDesc\n\t\t\t);\n\t\t}\n\t\t// step 2.d\n\t\treturn DefineOwnProperty(\n\t\t\tIsDataDescriptor,\n\t\t\tSameValue,\n\t\t\tFromPropertyDescriptor,\n\t\t\tO,\n\t\t\tP,\n\t\t\t{\n\t\t\t\t'[[Configurable]]': !!Desc['[[Configurable]]'],\n\t\t\t\t'[[Enumerable]]': !!Desc['[[Enumerable]]'],\n\t\t\t\t'[[Value]]': Desc['[[Value]]'],\n\t\t\t\t'[[Writable]]': !!Desc['[[Writable]]']\n\t\t\t}\n\t\t);\n\t}\n\n\t// 3. Assert: current is a fully populated Property Descriptor.\n\tif (!isFullyPopulatedPropertyDescriptor({\n\t\tIsAccessorDescriptor: IsAccessorDescriptor,\n\t\tIsDataDescriptor: IsDataDescriptor\n\t}, current)) {\n\t\tthrow new $TypeError('`current`, when present, must be a fully populated and valid Property Descriptor');\n\t}\n\n\t// 4. If every field in Desc is absent, return true.\n\t// this can't really match the assertion that it's a Property Descriptor in our JS implementation\n\n\t// 5. If current.[[Configurable]] is false, then\n\tif (!current['[[Configurable]]']) {\n\t\tif ('[[Configurable]]' in Desc && Desc['[[Configurable]]']) {\n\t\t\t// step 5.a\n\t\t\treturn false;\n\t\t}\n\t\tif ('[[Enumerable]]' in Desc && !SameValue(Desc['[[Enumerable]]'], current['[[Enumerable]]'])) {\n\t\t\t// step 5.b\n\t\t\treturn false;\n\t\t}\n\t\tif (!IsGenericDescriptor(Desc) && !SameValue(IsAccessorDescriptor(Desc), IsAccessorDescriptor(current))) {\n\t\t\t// step 5.c\n\t\t\treturn false;\n\t\t}\n\t\tif (IsAccessorDescriptor(current)) { // step 5.d\n\t\t\tif ('[[Get]]' in Desc && !SameValue(Desc['[[Get]]'], current['[[Get]]'])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ('[[Set]]' in Desc && !SameValue(Desc['[[Set]]'], current['[[Set]]'])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (!current['[[Writable]]']) { // step 5.e\n\t\t\tif ('[[Writable]]' in Desc && Desc['[[Writable]]']) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif ('[[Value]]' in Desc && !SameValue(Desc['[[Value]]'], current['[[Value]]'])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// 6. If O is not undefined, then\n\tif (oType !== 'Undefined') {\n\t\tvar configurable;\n\t\tvar enumerable;\n\t\tif (IsDataDescriptor(current) && IsAccessorDescriptor(Desc)) { // step 6.a\n\t\t\tconfigurable = ('[[Configurable]]' in Desc ? Desc : current)['[[Configurable]]'];\n\t\t\tenumerable = ('[[Enumerable]]' in Desc ? Desc : current)['[[Enumerable]]'];\n\t\t\t// Replace the property named P of object O with an accessor property having [[Configurable]] and [[Enumerable]] attributes as described by current and each other attribute set to its default value.\n\t\t\treturn DefineOwnProperty(\n\t\t\t\tIsDataDescriptor,\n\t\t\t\tSameValue,\n\t\t\t\tFromPropertyDescriptor,\n\t\t\t\tO,\n\t\t\t\tP,\n\t\t\t\t{\n\t\t\t\t\t'[[Configurable]]': !!configurable,\n\t\t\t\t\t'[[Enumerable]]': !!enumerable,\n\t\t\t\t\t'[[Get]]': ('[[Get]]' in Desc ? Desc : current)['[[Get]]'],\n\t\t\t\t\t'[[Set]]': ('[[Set]]' in Desc ? Desc : current)['[[Set]]']\n\t\t\t\t}\n\t\t\t);\n\t\t} else if (IsAccessorDescriptor(current) && IsDataDescriptor(Desc)) {\n\t\t\tconfigurable = ('[[Configurable]]' in Desc ? Desc : current)['[[Configurable]]'];\n\t\t\tenumerable = ('[[Enumerable]]' in Desc ? Desc : current)['[[Enumerable]]'];\n\t\t\t// i. Replace the property named P of object O with a data property having [[Configurable]] and [[Enumerable]] attributes as described by current and each other attribute set to its default value.\n\t\t\treturn DefineOwnProperty(\n\t\t\t\tIsDataDescriptor,\n\t\t\t\tSameValue,\n\t\t\t\tFromPropertyDescriptor,\n\t\t\t\tO,\n\t\t\t\tP,\n\t\t\t\t{\n\t\t\t\t\t'[[Configurable]]': !!configurable,\n\t\t\t\t\t'[[Enumerable]]': !!enumerable,\n\t\t\t\t\t'[[Value]]': ('[[Value]]' in Desc ? Desc : current)['[[Value]]'],\n\t\t\t\t\t'[[Writable]]': !!('[[Writable]]' in Desc ? Desc : current)['[[Writable]]']\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t// For each field of Desc that is present, set the corresponding attribute of the property named P of object O to the value of the field.\n\t\treturn DefineOwnProperty(\n\t\t\tIsDataDescriptor,\n\t\t\tSameValue,\n\t\t\tFromPropertyDescriptor,\n\t\t\tO,\n\t\t\tP,\n\t\t\tDesc\n\t\t);\n\t}\n\n\treturn true; // step 7\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}