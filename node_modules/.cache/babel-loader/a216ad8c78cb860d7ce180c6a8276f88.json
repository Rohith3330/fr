{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst error = {\n  message: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return (0, codegen_1.str)`must match format \"${schemaCode}\"`;\n  },\n  params: _ref2 => {\n    let {\n      schemaCode\n    } = _ref2;\n    return (0, codegen_1._)`{format: ${schemaCode}}`;\n  }\n};\nconst def = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n\n  code(cxt, ruleType) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    const {\n      opts,\n      errSchemaPath,\n      schemaEnv,\n      self\n    } = it;\n    if (!opts.validateFormats) return;\n    if ($data) validate$DataFormat();else validateFormat();\n\n    function validate$DataFormat() {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      const fDef = gen.const(\"fDef\", (0, codegen_1._)`${fmts}[${schemaCode}]`);\n      const fType = gen.let(\"fType\");\n      const format = gen.let(\"format\"); // TODO simplify\n\n      gen.if((0, codegen_1._)`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || \"string\"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`\"string\"`).assign(format, fDef));\n      cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));\n\n      function unknownFmt() {\n        if (opts.strictSchema === false) return codegen_1.nil;\n        return (0, codegen_1._)`${schemaCode} && !${format}`;\n      }\n\n      function invalidFmt() {\n        const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;\n        const validData = (0, codegen_1._)`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n        return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n      }\n    }\n\n    function validateFormat() {\n      const formatDef = self.formats[schema];\n\n      if (!formatDef) {\n        unknownFormat();\n        return;\n      }\n\n      if (formatDef === true) return;\n      const [fmtType, format, fmtRef] = getFormat(formatDef);\n      if (fmtType === ruleType) cxt.pass(validCondition());\n\n      function unknownFormat() {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg());\n          return;\n        }\n\n        throw new Error(unknownMsg());\n\n        function unknownMsg() {\n          return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n        }\n      }\n\n      function getFormat(fmtDef) {\n        const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : undefined;\n        const fmt = gen.scopeValue(\"formats\", {\n          key: schema,\n          ref: fmtDef,\n          code\n        });\n\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];\n        }\n\n        return [\"string\", fmtDef, fmt];\n      }\n\n      function validCondition() {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\");\n          return (0, codegen_1._)`await ${fmtRef}(${data})`;\n        }\n\n        return typeof format == \"function\" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;\n      }\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","schemaCode","params","def","keyword","type","schemaType","$data","code","cxt","ruleType","gen","data","schema","it","opts","errSchemaPath","schemaEnv","self","validateFormats","validate$DataFormat","validateFormat","fmts","scopeValue","ref","formats","fDef","const","fType","let","format","if","assign","fail$data","unknownFmt","invalidFmt","strictSchema","codegen_1","callFormat","$async","validData","formatDef","unknownFormat","fmtType","fmtRef","getFormat","pass","validCondition","logger","warn","unknownMsg","Error","fmtDef","RegExp","undefined","fmt","key","validate","async","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\vocabularies\\format\\format.ts"],"sourcesContent":["import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}