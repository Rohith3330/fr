{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isThisInTypeQuery = exports.isThisIdentifier = exports.identifierIsThisKeyword = exports.firstDefined = exports.nodeHasTokens = exports.createError = exports.TSError = exports.convertTokens = exports.convertToken = exports.getTokenType = exports.isChildUnwrappableOptionalChain = exports.isChainExpression = exports.isOptional = exports.isComputedProperty = exports.unescapeStringLiteralText = exports.hasJSXAncestor = exports.findFirstMatchingAncestor = exports.findNextToken = exports.getTSNodeAccessibility = exports.getDeclarationKind = exports.isJSXToken = exports.isToken = exports.getRange = exports.canContainDirective = exports.getLocFor = exports.getLineAndCharacterFor = exports.getBinaryExpressionType = exports.isJSDocComment = exports.isComment = exports.isComma = exports.getLastModifier = exports.hasModifier = exports.isESTreeClassMember = exports.getTextForTokenKind = exports.isLogicalOperator = exports.isAssignmentOperator = void 0;\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst getModifiers_1 = require(\"./getModifiers\");\n\nconst xhtml_entities_1 = require(\"./jsx/xhtml-entities\");\n\nconst ts_estree_1 = require(\"./ts-estree\");\n\nconst SyntaxKind = ts.SyntaxKind;\nconst LOGICAL_OPERATORS = [SyntaxKind.BarBarToken, SyntaxKind.AmpersandAmpersandToken, SyntaxKind.QuestionQuestionToken];\n/**\n * Returns true if the given ts.Token is the assignment operator\n * @param operator the operator token\n * @returns is assignment\n */\n\nfunction isAssignmentOperator(operator) {\n  return operator.kind >= SyntaxKind.FirstAssignment && operator.kind <= SyntaxKind.LastAssignment;\n}\n\nexports.isAssignmentOperator = isAssignmentOperator;\n/**\n * Returns true if the given ts.Token is a logical operator\n * @param operator the operator token\n * @returns is a logical operator\n */\n\nfunction isLogicalOperator(operator) {\n  return LOGICAL_OPERATORS.includes(operator.kind);\n}\n\nexports.isLogicalOperator = isLogicalOperator;\n/**\n * Returns the string form of the given TSToken SyntaxKind\n * @param kind the token's SyntaxKind\n * @returns the token applicable token as a string\n */\n\nfunction getTextForTokenKind(kind) {\n  return ts.tokenToString(kind);\n}\n\nexports.getTextForTokenKind = getTextForTokenKind;\n/**\n * Returns true if the given ts.Node is a valid ESTree class member\n * @param node TypeScript AST node\n * @returns is valid ESTree class member\n */\n\nfunction isESTreeClassMember(node) {\n  return node.kind !== SyntaxKind.SemicolonClassElement;\n}\n\nexports.isESTreeClassMember = isESTreeClassMember;\n/**\n * Checks if a ts.Node has a modifier\n * @param modifierKind TypeScript SyntaxKind modifier\n * @param node TypeScript AST node\n * @returns has the modifier specified\n */\n\nfunction hasModifier(modifierKind, node) {\n  const modifiers = (0, getModifiers_1.getModifiers)(node);\n  return (modifiers === null || modifiers === void 0 ? void 0 : modifiers.some(modifier => modifier.kind === modifierKind)) === true;\n}\n\nexports.hasModifier = hasModifier;\n/**\n * Get last last modifier in ast\n * @param node TypeScript AST node\n * @returns returns last modifier if present or null\n */\n\nfunction getLastModifier(node) {\n  var _a;\n\n  const modifiers = (0, getModifiers_1.getModifiers)(node);\n\n  if (modifiers == null) {\n    return null;\n  }\n\n  return (_a = modifiers[modifiers.length - 1]) !== null && _a !== void 0 ? _a : null;\n}\n\nexports.getLastModifier = getLastModifier;\n/**\n * Returns true if the given ts.Token is a comma\n * @param token the TypeScript token\n * @returns is comma\n */\n\nfunction isComma(token) {\n  return token.kind === SyntaxKind.CommaToken;\n}\n\nexports.isComma = isComma;\n/**\n * Returns true if the given ts.Node is a comment\n * @param node the TypeScript node\n * @returns is comment\n */\n\nfunction isComment(node) {\n  return node.kind === SyntaxKind.SingleLineCommentTrivia || node.kind === SyntaxKind.MultiLineCommentTrivia;\n}\n\nexports.isComment = isComment;\n/**\n * Returns true if the given ts.Node is a JSDoc comment\n * @param node the TypeScript node\n * @returns is JSDoc comment\n */\n\nfunction isJSDocComment(node) {\n  return node.kind === SyntaxKind.JSDocComment;\n}\n\nexports.isJSDocComment = isJSDocComment;\n/**\n * Returns the binary expression type of the given ts.Token\n * @param operator the operator token\n * @returns the binary expression type\n */\n\nfunction getBinaryExpressionType(operator) {\n  if (isAssignmentOperator(operator)) {\n    return ts_estree_1.AST_NODE_TYPES.AssignmentExpression;\n  } else if (isLogicalOperator(operator)) {\n    return ts_estree_1.AST_NODE_TYPES.LogicalExpression;\n  }\n\n  return ts_estree_1.AST_NODE_TYPES.BinaryExpression;\n}\n\nexports.getBinaryExpressionType = getBinaryExpressionType;\n/**\n * Returns line and column data for the given positions,\n * @param pos position to check\n * @param ast the AST object\n * @returns line and column\n */\n\nfunction getLineAndCharacterFor(pos, ast) {\n  const loc = ast.getLineAndCharacterOfPosition(pos);\n  return {\n    line: loc.line + 1,\n    column: loc.character\n  };\n}\n\nexports.getLineAndCharacterFor = getLineAndCharacterFor;\n/**\n * Returns line and column data for the given start and end positions,\n * for the given AST\n * @param start start data\n * @param end   end data\n * @param ast   the AST object\n * @returns the loc data\n */\n\nfunction getLocFor(start, end, ast) {\n  return {\n    start: getLineAndCharacterFor(start, ast),\n    end: getLineAndCharacterFor(end, ast)\n  };\n}\n\nexports.getLocFor = getLocFor;\n/**\n * Check whatever node can contain directive\n * @param node\n * @returns returns true if node can contain directive\n */\n\nfunction canContainDirective(node) {\n  if (node.kind === ts.SyntaxKind.Block) {\n    switch (node.parent.kind) {\n      case ts.SyntaxKind.Constructor:\n      case ts.SyntaxKind.GetAccessor:\n      case ts.SyntaxKind.SetAccessor:\n      case ts.SyntaxKind.ArrowFunction:\n      case ts.SyntaxKind.FunctionExpression:\n      case ts.SyntaxKind.FunctionDeclaration:\n      case ts.SyntaxKind.MethodDeclaration:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  return true;\n}\n\nexports.canContainDirective = canContainDirective;\n/**\n * Returns range for the given ts.Node\n * @param node the ts.Node or ts.Token\n * @param ast the AST object\n * @returns the range data\n */\n\nfunction getRange(node, ast) {\n  return [node.getStart(ast), node.getEnd()];\n}\n\nexports.getRange = getRange;\n/**\n * Returns true if a given ts.Node is a token\n * @param node the ts.Node\n * @returns is a token\n */\n\nfunction isToken(node) {\n  return node.kind >= SyntaxKind.FirstToken && node.kind <= SyntaxKind.LastToken;\n}\n\nexports.isToken = isToken;\n/**\n * Returns true if a given ts.Node is a JSX token\n * @param node ts.Node to be checked\n * @returns is a JSX token\n */\n\nfunction isJSXToken(node) {\n  return node.kind >= SyntaxKind.JsxElement && node.kind <= SyntaxKind.JsxAttribute;\n}\n\nexports.isJSXToken = isJSXToken;\n/**\n * Returns the declaration kind of the given ts.Node\n * @param node TypeScript AST node\n * @returns declaration kind\n */\n\nfunction getDeclarationKind(node) {\n  if (node.flags & ts.NodeFlags.Let) {\n    return 'let';\n  }\n\n  if (node.flags & ts.NodeFlags.Const) {\n    return 'const';\n  }\n\n  return 'var';\n}\n\nexports.getDeclarationKind = getDeclarationKind;\n/**\n * Gets a ts.Node's accessibility level\n * @param node The ts.Node\n * @returns accessibility \"public\", \"protected\", \"private\", or null\n */\n\nfunction getTSNodeAccessibility(node) {\n  const modifiers = (0, getModifiers_1.getModifiers)(node);\n\n  if (modifiers == null) {\n    return null;\n  }\n\n  for (const modifier of modifiers) {\n    switch (modifier.kind) {\n      case SyntaxKind.PublicKeyword:\n        return 'public';\n\n      case SyntaxKind.ProtectedKeyword:\n        return 'protected';\n\n      case SyntaxKind.PrivateKeyword:\n        return 'private';\n\n      default:\n        break;\n    }\n  }\n\n  return null;\n}\n\nexports.getTSNodeAccessibility = getTSNodeAccessibility;\n/**\n * Finds the next token based on the previous one and its parent\n * Had to copy this from TS instead of using TS's version because theirs doesn't pass the ast to getChildren\n * @param previousToken The previous TSToken\n * @param parent The parent TSNode\n * @param ast The TS AST\n * @returns the next TSToken\n */\n\nfunction findNextToken(previousToken, parent, ast) {\n  return find(parent);\n\n  function find(n) {\n    if (ts.isToken(n) && n.pos === previousToken.end) {\n      // this is token that starts at the end of previous token - return it\n      return n;\n    }\n\n    return firstDefined(n.getChildren(ast), child => {\n      const shouldDiveInChildNode = // previous token is enclosed somewhere in the child\n      child.pos <= previousToken.pos && child.end > previousToken.end || // previous token ends exactly at the beginning of child\n      child.pos === previousToken.end;\n      return shouldDiveInChildNode && nodeHasTokens(child, ast) ? find(child) : undefined;\n    });\n  }\n}\n\nexports.findNextToken = findNextToken;\n/**\n * Find the first matching ancestor based on the given predicate function.\n * @param node The current ts.Node\n * @param predicate The predicate function to apply to each checked ancestor\n * @returns a matching parent ts.Node\n */\n\nfunction findFirstMatchingAncestor(node, predicate) {\n  while (node) {\n    if (predicate(node)) {\n      return node;\n    }\n\n    node = node.parent;\n  }\n\n  return undefined;\n}\n\nexports.findFirstMatchingAncestor = findFirstMatchingAncestor;\n/**\n * Returns true if a given ts.Node has a JSX token within its hierarchy\n * @param node ts.Node to be checked\n * @returns has JSX ancestor\n */\n\nfunction hasJSXAncestor(node) {\n  return !!findFirstMatchingAncestor(node, isJSXToken);\n}\n\nexports.hasJSXAncestor = hasJSXAncestor;\n/**\n * Unescape the text content of string literals, e.g. &amp; -> &\n * @param text The escaped string literal text.\n * @returns The unescaped string literal text.\n */\n\nfunction unescapeStringLiteralText(text) {\n  return text.replace(/&(?:#\\d+|#x[\\da-fA-F]+|[0-9a-zA-Z]+);/g, entity => {\n    const item = entity.slice(1, -1);\n\n    if (item[0] === '#') {\n      const codePoint = item[1] === 'x' ? parseInt(item.slice(2), 16) : parseInt(item.slice(1), 10);\n      return codePoint > 0x10ffff // RangeError: Invalid code point\n      ? entity : String.fromCodePoint(codePoint);\n    }\n\n    return xhtml_entities_1.xhtmlEntities[item] || entity;\n  });\n}\n\nexports.unescapeStringLiteralText = unescapeStringLiteralText;\n/**\n * Returns true if a given ts.Node is a computed property\n * @param node ts.Node to be checked\n * @returns is Computed Property\n */\n\nfunction isComputedProperty(node) {\n  return node.kind === SyntaxKind.ComputedPropertyName;\n}\n\nexports.isComputedProperty = isComputedProperty;\n/**\n * Returns true if a given ts.Node is optional (has QuestionToken)\n * @param node ts.Node to be checked\n * @returns is Optional\n */\n\nfunction isOptional(node) {\n  return node.questionToken ? node.questionToken.kind === SyntaxKind.QuestionToken : false;\n}\n\nexports.isOptional = isOptional;\n/**\n * Returns true if the node is an optional chain node\n */\n\nfunction isChainExpression(node) {\n  return node.type === ts_estree_1.AST_NODE_TYPES.ChainExpression;\n}\n\nexports.isChainExpression = isChainExpression;\n/**\n * Returns true of the child of property access expression is an optional chain\n */\n\nfunction isChildUnwrappableOptionalChain(node, child) {\n  return isChainExpression(child) && // (x?.y).z is semantically different, and as such .z is no longer optional\n  node.expression.kind !== ts.SyntaxKind.ParenthesizedExpression;\n}\n\nexports.isChildUnwrappableOptionalChain = isChildUnwrappableOptionalChain;\n/**\n * Returns the type of a given ts.Token\n * @param token the ts.Token\n * @returns the token type\n */\n\nfunction getTokenType(token) {\n  if ('originalKeywordKind' in token && token.originalKeywordKind) {\n    if (token.originalKeywordKind === SyntaxKind.NullKeyword) {\n      return ts_estree_1.AST_TOKEN_TYPES.Null;\n    } else if (token.originalKeywordKind >= SyntaxKind.FirstFutureReservedWord && token.originalKeywordKind <= SyntaxKind.LastKeyword) {\n      return ts_estree_1.AST_TOKEN_TYPES.Identifier;\n    }\n\n    return ts_estree_1.AST_TOKEN_TYPES.Keyword;\n  }\n\n  if (token.kind >= SyntaxKind.FirstKeyword && token.kind <= SyntaxKind.LastFutureReservedWord) {\n    if (token.kind === SyntaxKind.FalseKeyword || token.kind === SyntaxKind.TrueKeyword) {\n      return ts_estree_1.AST_TOKEN_TYPES.Boolean;\n    }\n\n    return ts_estree_1.AST_TOKEN_TYPES.Keyword;\n  }\n\n  if (token.kind >= SyntaxKind.FirstPunctuation && token.kind <= SyntaxKind.LastPunctuation) {\n    return ts_estree_1.AST_TOKEN_TYPES.Punctuator;\n  }\n\n  if (token.kind >= SyntaxKind.NoSubstitutionTemplateLiteral && token.kind <= SyntaxKind.TemplateTail) {\n    return ts_estree_1.AST_TOKEN_TYPES.Template;\n  }\n\n  switch (token.kind) {\n    case SyntaxKind.NumericLiteral:\n      return ts_estree_1.AST_TOKEN_TYPES.Numeric;\n\n    case SyntaxKind.JsxText:\n      return ts_estree_1.AST_TOKEN_TYPES.JSXText;\n\n    case SyntaxKind.StringLiteral:\n      // A TypeScript-StringLiteral token with a TypeScript-JsxAttribute or TypeScript-JsxElement parent,\n      // must actually be an ESTree-JSXText token\n      if (token.parent && (token.parent.kind === SyntaxKind.JsxAttribute || token.parent.kind === SyntaxKind.JsxElement)) {\n        return ts_estree_1.AST_TOKEN_TYPES.JSXText;\n      }\n\n      return ts_estree_1.AST_TOKEN_TYPES.String;\n\n    case SyntaxKind.RegularExpressionLiteral:\n      return ts_estree_1.AST_TOKEN_TYPES.RegularExpression;\n\n    case SyntaxKind.Identifier:\n    case SyntaxKind.ConstructorKeyword:\n    case SyntaxKind.GetKeyword:\n    case SyntaxKind.SetKeyword: // intentional fallthrough\n\n    default:\n  } // Some JSX tokens have to be determined based on their parent\n\n\n  if (token.parent && token.kind === SyntaxKind.Identifier) {\n    if (isJSXToken(token.parent)) {\n      return ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier;\n    }\n\n    if (token.parent.kind === SyntaxKind.PropertyAccessExpression && hasJSXAncestor(token)) {\n      return ts_estree_1.AST_TOKEN_TYPES.JSXIdentifier;\n    }\n  }\n\n  return ts_estree_1.AST_TOKEN_TYPES.Identifier;\n}\n\nexports.getTokenType = getTokenType;\n/**\n * Extends and formats a given ts.Token, for a given AST\n * @param token the ts.Token\n * @param ast   the AST object\n * @returns the converted Token\n */\n\nfunction convertToken(token, ast) {\n  const start = token.kind === SyntaxKind.JsxText ? token.getFullStart() : token.getStart(ast);\n  const end = token.getEnd();\n  const value = ast.text.slice(start, end);\n  const tokenType = getTokenType(token);\n\n  if (tokenType === ts_estree_1.AST_TOKEN_TYPES.RegularExpression) {\n    return {\n      type: tokenType,\n      value,\n      range: [start, end],\n      loc: getLocFor(start, end, ast),\n      regex: {\n        pattern: value.slice(1, value.lastIndexOf('/')),\n        flags: value.slice(value.lastIndexOf('/') + 1)\n      }\n    };\n  } else {\n    // @ts-expect-error TS is complaining about `value` not being the correct\n    // type but it is\n    return {\n      type: tokenType,\n      value,\n      range: [start, end],\n      loc: getLocFor(start, end, ast)\n    };\n  }\n}\n\nexports.convertToken = convertToken;\n/**\n * Converts all tokens for the given AST\n * @param ast the AST object\n * @returns the converted Tokens\n */\n\nfunction convertTokens(ast) {\n  const result = [];\n  /**\n   * @param node the ts.Node\n   */\n\n  function walk(node) {\n    // TypeScript generates tokens for types in JSDoc blocks. Comment tokens\n    // and their children should not be walked or added to the resulting tokens list.\n    if (isComment(node) || isJSDocComment(node)) {\n      return;\n    }\n\n    if (isToken(node) && node.kind !== SyntaxKind.EndOfFileToken) {\n      const converted = convertToken(node, ast);\n\n      if (converted) {\n        result.push(converted);\n      }\n    } else {\n      node.getChildren(ast).forEach(walk);\n    }\n  }\n\n  walk(ast);\n  return result;\n}\n\nexports.convertTokens = convertTokens;\n\nclass TSError extends Error {\n  constructor(message, fileName, index, lineNumber, column) {\n    super(message);\n    this.fileName = fileName;\n    this.index = index;\n    this.lineNumber = lineNumber;\n    this.column = column;\n    Object.defineProperty(this, 'name', {\n      value: new.target.name,\n      enumerable: false,\n      configurable: true\n    });\n  }\n\n}\n\nexports.TSError = TSError;\n/**\n * @param ast     the AST object\n * @param start   the index at which the error starts\n * @param message the error message\n * @returns converted error object\n */\n\nfunction createError(ast, start, message) {\n  const loc = ast.getLineAndCharacterOfPosition(start);\n  return new TSError(message, ast.fileName, start, loc.line + 1, loc.character);\n}\n\nexports.createError = createError;\n/**\n * @param n the TSNode\n * @param ast the TS AST\n */\n\nfunction nodeHasTokens(n, ast) {\n  // If we have a token or node that has a non-zero width, it must have tokens.\n  // Note: getWidth() does not take trivia into account.\n  return n.kind === SyntaxKind.EndOfFileToken ? !!n.jsDoc : n.getWidth(ast) !== 0;\n}\n\nexports.nodeHasTokens = nodeHasTokens;\n/**\n * Like `forEach`, but suitable for use with numbers and strings (which may be falsy).\n * @template T\n * @template U\n * @param array\n * @param callback\n */\n\nfunction firstDefined(array, callback) {\n  if (array === undefined) {\n    return undefined;\n  }\n\n  for (let i = 0; i < array.length; i++) {\n    const result = callback(array[i], i);\n\n    if (result !== undefined) {\n      return result;\n    }\n  }\n\n  return undefined;\n}\n\nexports.firstDefined = firstDefined;\n\nfunction identifierIsThisKeyword(id) {\n  return id.originalKeywordKind === SyntaxKind.ThisKeyword;\n}\n\nexports.identifierIsThisKeyword = identifierIsThisKeyword;\n\nfunction isThisIdentifier(node) {\n  return !!node && node.kind === SyntaxKind.Identifier && identifierIsThisKeyword(node);\n}\n\nexports.isThisIdentifier = isThisIdentifier;\n\nfunction isThisInTypeQuery(node) {\n  if (!isThisIdentifier(node)) {\n    return false;\n  }\n\n  while (ts.isQualifiedName(node.parent) && node.parent.left === node) {\n    node = node.parent;\n  }\n\n  return node.parent.kind === SyntaxKind.TypeQuery;\n}\n\nexports.isThisInTypeQuery = isThisInTypeQuery;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAEA;;AACA;;AAEA;;AAEA,MAAMA,UAAU,GAAGC,EAAE,CAACD,UAAtB;AAEA,MAAME,iBAAiB,GAGjB,CACJF,UAAU,CAACG,WADP,EAEJH,UAAU,CAACI,uBAFP,EAGJJ,UAAU,CAACK,qBAHP,CAHN;AAmBA;;;;;;AAKA,SAAgBC,oBAAhB,CACEC,QADF,EACuB;EAErB,OACEA,QAAQ,CAACC,IAAT,IAAiBR,UAAU,CAACS,eAA5B,IACAF,QAAQ,CAACC,IAAT,IAAiBR,UAAU,CAACU,cAF9B;AAID;;AAPDC;AASA;;;;;;AAKA,SAAgBC,iBAAhB,CACEL,QADF,EACuB;EAErB,OAAQL,iBAAqC,CAACW,QAAtC,CAA+CN,QAAQ,CAACC,IAAxD,CAAR;AACD;;AAJDG;AAMA;;;;;;AAKA,SAAgBG,mBAAhB,CACEN,IADF,EACS;EAEP,OAAOP,EAAE,CAACc,aAAH,CAAiBP,IAAjB,CAAP;AAGD;;AANDG;AAQA;;;;;;AAKA,SAAgBK,mBAAhB,CAAoCC,IAApC,EAAiD;EAC/C,OAAOA,IAAI,CAACT,IAAL,KAAcR,UAAU,CAACkB,qBAAhC;AACD;;AAFDP;AAIA;;;;;;;AAMA,SAAgBQ,WAAhB,CACEC,YADF,EAEEH,IAFF,EAEe;EAEb,MAAMI,SAAS,GAAG,iCAAaJ,IAAb,CAAlB;EACA,OAAO,UAAS,SAAT,aAAS,WAAT,GAAS,MAAT,YAAS,CAAEK,IAAX,CAAgBC,QAAQ,IAAIA,QAAQ,CAACf,IAAT,KAAkBY,YAA9C,OAAgE,IAAvE;AACD;;AANDT;AAQA;;;;;;AAKA,SAAgBa,eAAhB,CAAgCP,IAAhC,EAA6C;;;EAC3C,MAAMI,SAAS,GAAG,iCAAaJ,IAAb,CAAlB;;EACA,IAAII,SAAS,IAAI,IAAjB,EAAuB;IACrB,OAAO,IAAP;EACD;;EACD,OAAO,eAAS,CAACA,SAAS,CAACI,MAAV,GAAmB,CAApB,CAAT,MAA+B,IAA/B,IAA+BC,aAA/B,GAA+BA,EAA/B,GAAmC,IAA1C;AACD;;AANDf;AAQA;;;;;;AAKA,SAAgBgB,OAAhB,CACEC,KADF,EACgB;EAEd,OAAOA,KAAK,CAACpB,IAAN,KAAeR,UAAU,CAAC6B,UAAjC;AACD;;AAJDlB;AAMA;;;;;;AAKA,SAAgBmB,SAAhB,CAA0Bb,IAA1B,EAAuC;EACrC,OACEA,IAAI,CAACT,IAAL,KAAcR,UAAU,CAAC+B,uBAAzB,IACAd,IAAI,CAACT,IAAL,KAAcR,UAAU,CAACgC,sBAF3B;AAID;;AALDrB;AAOA;;;;;;AAKA,SAAgBsB,cAAhB,CAA+BhB,IAA/B,EAA4C;EAC1C,OAAOA,IAAI,CAACT,IAAL,KAAcR,UAAU,CAACkC,YAAhC;AACD;;AAFDvB;AAIA;;;;;;AAKA,SAAgBwB,uBAAhB,CACE5B,QADF,EACuB;EAKrB,IAAID,oBAAoB,CAACC,QAAD,CAAxB,EAAoC;IAClC,OAAO6B,2BAAeC,oBAAtB;EACD,CAFD,MAEO,IAAIzB,iBAAiB,CAACL,QAAD,CAArB,EAAiC;IACtC,OAAO6B,2BAAeE,iBAAtB;EACD;;EACD,OAAOF,2BAAeG,gBAAtB;AACD;;AAZD5B;AAcA;;;;;;;AAMA,SAAgB6B,sBAAhB,CACEC,GADF,EAEEC,GAFF,EAEoB;EAElB,MAAMC,GAAG,GAAGD,GAAG,CAACE,6BAAJ,CAAkCH,GAAlC,CAAZ;EACA,OAAO;IACLI,IAAI,EAAEF,GAAG,CAACE,IAAJ,GAAW,CADZ;IAELC,MAAM,EAAEH,GAAG,CAACI;EAFP,CAAP;AAID;;AATDpC;AAWA;;;;;;;;;AAQA,SAAgBqC,SAAhB,CACEC,KADF,EAEEC,GAFF,EAGER,GAHF,EAGoB;EAElB,OAAO;IACLO,KAAK,EAAET,sBAAsB,CAACS,KAAD,EAAQP,GAAR,CADxB;IAELQ,GAAG,EAAEV,sBAAsB,CAACU,GAAD,EAAMR,GAAN;EAFtB,CAAP;AAID;;AATD/B;AAWA;;;;;;AAKA,SAAgBwC,mBAAhB,CACElC,IADF,EAKoC;EAElC,IAAIA,IAAI,CAACT,IAAL,KAAcP,EAAE,CAACD,UAAH,CAAcoD,KAAhC,EAAuC;IACrC,QAAQnC,IAAI,CAACoC,MAAL,CAAY7C,IAApB;MACE,KAAKP,EAAE,CAACD,UAAH,CAAcsD,WAAnB;MACA,KAAKrD,EAAE,CAACD,UAAH,CAAcuD,WAAnB;MACA,KAAKtD,EAAE,CAACD,UAAH,CAAcwD,WAAnB;MACA,KAAKvD,EAAE,CAACD,UAAH,CAAcyD,aAAnB;MACA,KAAKxD,EAAE,CAACD,UAAH,CAAc0D,kBAAnB;MACA,KAAKzD,EAAE,CAACD,UAAH,CAAc2D,mBAAnB;MACA,KAAK1D,EAAE,CAACD,UAAH,CAAc4D,iBAAnB;QACE,OAAO,IAAP;;MACF;QACE,OAAO,KAAP;IAVJ;EAYD;;EACD,OAAO,IAAP;AACD;;AAtBDjD;AAwBA;;;;;;;AAMA,SAAgBkD,QAAhB,CAAyB5C,IAAzB,EAAwCyB,GAAxC,EAA0D;EACxD,OAAO,CAACzB,IAAI,CAAC6C,QAAL,CAAcpB,GAAd,CAAD,EAAqBzB,IAAI,CAAC8C,MAAL,EAArB,CAAP;AACD;;AAFDpD;AAIA;;;;;;AAKA,SAAgBqD,OAAhB,CAAwB/C,IAAxB,EAAqC;EACnC,OACEA,IAAI,CAACT,IAAL,IAAaR,UAAU,CAACiE,UAAxB,IAAsChD,IAAI,CAACT,IAAL,IAAaR,UAAU,CAACkE,SADhE;AAGD;;AAJDvD;AAMA;;;;;;AAKA,SAAgBwD,UAAhB,CAA2BlD,IAA3B,EAAwC;EACtC,OACEA,IAAI,CAACT,IAAL,IAAaR,UAAU,CAACoE,UAAxB,IAAsCnD,IAAI,CAACT,IAAL,IAAaR,UAAU,CAACqE,YADhE;AAGD;;AAJD1D;AAMA;;;;;;AAKA,SAAgB2D,kBAAhB,CACErD,IADF,EACkC;EAEhC,IAAIA,IAAI,CAACsD,KAAL,GAAatE,EAAE,CAACuE,SAAH,CAAaC,GAA9B,EAAmC;IACjC,OAAO,KAAP;EACD;;EACD,IAAIxD,IAAI,CAACsD,KAAL,GAAatE,EAAE,CAACuE,SAAH,CAAaE,KAA9B,EAAqC;IACnC,OAAO,OAAP;EACD;;EACD,OAAO,KAAP;AACD;;AAVD/D;AAYA;;;;;;AAKA,SAAgBgE,sBAAhB,CACE1D,IADF,EACe;EAEb,MAAMI,SAAS,GAAG,iCAAaJ,IAAb,CAAlB;;EACA,IAAII,SAAS,IAAI,IAAjB,EAAuB;IACrB,OAAO,IAAP;EACD;;EACD,KAAK,MAAME,QAAX,IAAuBF,SAAvB,EAAkC;IAChC,QAAQE,QAAQ,CAACf,IAAjB;MACE,KAAKR,UAAU,CAAC4E,aAAhB;QACE,OAAO,QAAP;;MACF,KAAK5E,UAAU,CAAC6E,gBAAhB;QACE,OAAO,WAAP;;MACF,KAAK7E,UAAU,CAAC8E,cAAhB;QACE,OAAO,SAAP;;MACF;QACE;IARJ;EAUD;;EACD,OAAO,IAAP;AACD;;AApBDnE;AAsBA;;;;;;;;;AAQA,SAAgBoE,aAAhB,CACEC,aADF,EAEE3B,MAFF,EAGEX,GAHF,EAGoB;EAElB,OAAOuC,IAAI,CAAC5B,MAAD,CAAX;;EAEA,SAAS4B,IAAT,CAAcC,CAAd,EAAwB;IACtB,IAAIjF,EAAE,CAAC+D,OAAH,CAAWkB,CAAX,KAAiBA,CAAC,CAACzC,GAAF,KAAUuC,aAAa,CAAC9B,GAA7C,EAAkD;MAChD;MACA,OAAOgC,CAAP;IACD;;IACD,OAAOC,YAAY,CAACD,CAAC,CAACE,WAAF,CAAc1C,GAAd,CAAD,EAAsB2C,KAAD,IAAmB;MACzD,MAAMC,qBAAqB,GACzB;MACCD,KAAK,CAAC5C,GAAN,IAAauC,aAAa,CAACvC,GAA3B,IAAkC4C,KAAK,CAACnC,GAAN,GAAY8B,aAAa,CAAC9B,GAA7D,IACA;MACAmC,KAAK,CAAC5C,GAAN,KAAcuC,aAAa,CAAC9B,GAJ9B;MAKA,OAAOoC,qBAAqB,IAAIC,aAAa,CAACF,KAAD,EAAQ3C,GAAR,CAAtC,GACHuC,IAAI,CAACI,KAAD,CADD,GAEHG,SAFJ;IAGD,CATkB,CAAnB;EAUD;AACF;;AAvBD7E;AAyBA;;;;;;;AAMA,SAAgB8E,yBAAhB,CACExE,IADF,EAEEyE,SAFF,EAEuC;EAErC,OAAOzE,IAAP,EAAa;IACX,IAAIyE,SAAS,CAACzE,IAAD,CAAb,EAAqB;MACnB,OAAOA,IAAP;IACD;;IACDA,IAAI,GAAGA,IAAI,CAACoC,MAAZ;EACD;;EACD,OAAOmC,SAAP;AACD;;AAXD7E;AAaA;;;;;;AAKA,SAAgBgF,cAAhB,CAA+B1E,IAA/B,EAA4C;EAC1C,OAAO,CAAC,CAACwE,yBAAyB,CAACxE,IAAD,EAAOkD,UAAP,CAAlC;AACD;;AAFDxD;AAIA;;;;;;AAKA,SAAgBiF,yBAAhB,CAA0CC,IAA1C,EAAsD;EACpD,OAAOA,IAAI,CAACC,OAAL,CAAa,wCAAb,EAAuDC,MAAM,IAAG;IACrE,MAAMC,IAAI,GAAGD,MAAM,CAACE,KAAP,CAAa,CAAb,EAAgB,CAAC,CAAjB,CAAb;;IACA,IAAID,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAhB,EAAqB;MACnB,MAAME,SAAS,GACbF,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAZ,GACIG,QAAQ,CAACH,IAAI,CAACC,KAAL,CAAW,CAAX,CAAD,EAAgB,EAAhB,CADZ,GAEIE,QAAQ,CAACH,IAAI,CAACC,KAAL,CAAW,CAAX,CAAD,EAAgB,EAAhB,CAHd;MAIA,OAAOC,SAAS,GAAG,QAAZ,CAAqB;MAArB,EACHH,MADG,GAEHK,MAAM,CAACC,aAAP,CAAqBH,SAArB,CAFJ;IAGD;;IACD,OAAOI,+BAAcN,IAAd,KAAuBD,MAA9B;EACD,CAZM,CAAP;AAaD;;AAdDpF;AAgBA;;;;;;AAKA,SAAgB4F,kBAAhB,CACEtF,IADF,EACe;EAEb,OAAOA,IAAI,CAACT,IAAL,KAAcR,UAAU,CAACwG,oBAAhC;AACD;;AAJD7F;AAMA;;;;;;AAKA,SAAgB8F,UAAhB,CAA2BxF,IAA3B,EAEC;EACC,OAAOA,IAAI,CAACyF,aAAL,GACHzF,IAAI,CAACyF,aAAL,CAAmBlG,IAAnB,KAA4BR,UAAU,CAAC2G,aADpC,GAEH,KAFJ;AAGD;;AANDhG;AAQA;;;;AAGA,SAAgBiG,iBAAhB,CACE3F,IADF,EACqB;EAEnB,OAAOA,IAAI,CAAC4F,IAAL,KAAczE,2BAAe0E,eAApC;AACD;;AAJDnG;AAMA;;;;AAGA,SAAgBoG,+BAAhB,CACE9F,IADF,EAMEoE,KANF,EAMsB;EAEpB,OACEuB,iBAAiB,CAACvB,KAAD,CAAjB,IACA;EACApE,IAAI,CAAC+F,UAAL,CAAgBxG,IAAhB,KAAyBP,EAAE,CAACD,UAAH,CAAciH,uBAHzC;AAKD;;AAbDtG;AAeA;;;;;;AAKA,SAAgBuG,YAAhB,CACEtF,KADF,EACgD;EAE9C,IAAI,yBAAyBA,KAAzB,IAAkCA,KAAK,CAACuF,mBAA5C,EAAiE;IAC/D,IAAIvF,KAAK,CAACuF,mBAAN,KAA8BnH,UAAU,CAACoH,WAA7C,EAA0D;MACxD,OAAOhF,4BAAgBiF,IAAvB;IACD,CAFD,MAEO,IACLzF,KAAK,CAACuF,mBAAN,IAA6BnH,UAAU,CAACsH,uBAAxC,IACA1F,KAAK,CAACuF,mBAAN,IAA6BnH,UAAU,CAACuH,WAFnC,EAGL;MACA,OAAOnF,4BAAgBoF,UAAvB;IACD;;IACD,OAAOpF,4BAAgBqF,OAAvB;EACD;;EAED,IACE7F,KAAK,CAACpB,IAAN,IAAcR,UAAU,CAAC0H,YAAzB,IACA9F,KAAK,CAACpB,IAAN,IAAcR,UAAU,CAAC2H,sBAF3B,EAGE;IACA,IACE/F,KAAK,CAACpB,IAAN,KAAeR,UAAU,CAAC4H,YAA1B,IACAhG,KAAK,CAACpB,IAAN,KAAeR,UAAU,CAAC6H,WAF5B,EAGE;MACA,OAAOzF,4BAAgB0F,OAAvB;IACD;;IAED,OAAO1F,4BAAgBqF,OAAvB;EACD;;EAED,IACE7F,KAAK,CAACpB,IAAN,IAAcR,UAAU,CAAC+H,gBAAzB,IACAnG,KAAK,CAACpB,IAAN,IAAcR,UAAU,CAACgI,eAF3B,EAGE;IACA,OAAO5F,4BAAgB6F,UAAvB;EACD;;EAED,IACErG,KAAK,CAACpB,IAAN,IAAcR,UAAU,CAACkI,6BAAzB,IACAtG,KAAK,CAACpB,IAAN,IAAcR,UAAU,CAACmI,YAF3B,EAGE;IACA,OAAO/F,4BAAgBgG,QAAvB;EACD;;EAED,QAAQxG,KAAK,CAACpB,IAAd;IACE,KAAKR,UAAU,CAACqI,cAAhB;MACE,OAAOjG,4BAAgBkG,OAAvB;;IAEF,KAAKtI,UAAU,CAACuI,OAAhB;MACE,OAAOnG,4BAAgBoG,OAAvB;;IAEF,KAAKxI,UAAU,CAACyI,aAAhB;MACE;MACA;MACA,IACE7G,KAAK,CAACyB,MAAN,KACCzB,KAAK,CAACyB,MAAN,CAAa7C,IAAb,KAAsBR,UAAU,CAACqE,YAAjC,IACCzC,KAAK,CAACyB,MAAN,CAAa7C,IAAb,KAAsBR,UAAU,CAACoE,UAFnC,CADF,EAIE;QACA,OAAOhC,4BAAgBoG,OAAvB;MACD;;MAED,OAAOpG,4BAAgBgE,MAAvB;;IAEF,KAAKpG,UAAU,CAAC0I,wBAAhB;MACE,OAAOtG,4BAAgBuG,iBAAvB;;IAEF,KAAK3I,UAAU,CAACwH,UAAhB;IACA,KAAKxH,UAAU,CAAC4I,kBAAhB;IACA,KAAK5I,UAAU,CAAC6I,UAAhB;IACA,KAAK7I,UAAU,CAAC8I,UAAhB,CA1BF,CA4BE;;IACA;EA7BF,CA1C8C,CA0E9C;;;EACA,IAAIlH,KAAK,CAACyB,MAAN,IAAgBzB,KAAK,CAACpB,IAAN,KAAeR,UAAU,CAACwH,UAA9C,EAA0D;IACxD,IAAIrD,UAAU,CAACvC,KAAK,CAACyB,MAAP,CAAd,EAA8B;MAC5B,OAAOjB,4BAAgB2G,aAAvB;IACD;;IAED,IACEnH,KAAK,CAACyB,MAAN,CAAa7C,IAAb,KAAsBR,UAAU,CAACgJ,wBAAjC,IACArD,cAAc,CAAC/D,KAAD,CAFhB,EAGE;MACA,OAAOQ,4BAAgB2G,aAAvB;IACD;EACF;;EAED,OAAO3G,4BAAgBoF,UAAvB;AACD;;AA1FD7G;AA4FA;;;;;;;AAMA,SAAgBsI,YAAhB,CACErH,KADF,EAEEc,GAFF,EAEoB;EAElB,MAAMO,KAAK,GACTrB,KAAK,CAACpB,IAAN,KAAeR,UAAU,CAACuI,OAA1B,GACI3G,KAAK,CAACsH,YAAN,EADJ,GAEItH,KAAK,CAACkC,QAAN,CAAepB,GAAf,CAHN;EAIA,MAAMQ,GAAG,GAAGtB,KAAK,CAACmC,MAAN,EAAZ;EACA,MAAMoF,KAAK,GAAGzG,GAAG,CAACmD,IAAJ,CAASI,KAAT,CAAehD,KAAf,EAAsBC,GAAtB,CAAd;EACA,MAAMkG,SAAS,GAAGlC,YAAY,CAACtF,KAAD,CAA9B;;EAEA,IAAIwH,SAAS,KAAKhH,4BAAgBuG,iBAAlC,EAAqD;IACnD,OAAO;MACL9B,IAAI,EAAEuC,SADD;MAELD,KAFK;MAGLE,KAAK,EAAE,CAACpG,KAAD,EAAQC,GAAR,CAHF;MAILP,GAAG,EAAEK,SAAS,CAACC,KAAD,EAAQC,GAAR,EAAaR,GAAb,CAJT;MAKL4G,KAAK,EAAE;QACLC,OAAO,EAAEJ,KAAK,CAAClD,KAAN,CAAY,CAAZ,EAAekD,KAAK,CAACK,WAAN,CAAkB,GAAlB,CAAf,CADJ;QAELjF,KAAK,EAAE4E,KAAK,CAAClD,KAAN,CAAYkD,KAAK,CAACK,WAAN,CAAkB,GAAlB,IAAyB,CAArC;MAFF;IALF,CAAP;EAUD,CAXD,MAWO;IACL;IACA;IACA,OAAO;MACL3C,IAAI,EAAEuC,SADD;MAELD,KAFK;MAGLE,KAAK,EAAE,CAACpG,KAAD,EAAQC,GAAR,CAHF;MAILP,GAAG,EAAEK,SAAS,CAACC,KAAD,EAAQC,GAAR,EAAaR,GAAb;IAJT,CAAP;EAMD;AACF;;AAjCD/B;AAmCA;;;;;;AAKA,SAAgB8I,aAAhB,CAA8B/G,GAA9B,EAAgD;EAC9C,MAAMgH,MAAM,GAAqB,EAAjC;EACA;;;;EAGA,SAASC,IAAT,CAAc1I,IAAd,EAA2B;IACzB;IACA;IACA,IAAIa,SAAS,CAACb,IAAD,CAAT,IAAmBgB,cAAc,CAAChB,IAAD,CAArC,EAA6C;MAC3C;IACD;;IAED,IAAI+C,OAAO,CAAC/C,IAAD,CAAP,IAAiBA,IAAI,CAACT,IAAL,KAAcR,UAAU,CAAC4J,cAA9C,EAA8D;MAC5D,MAAMC,SAAS,GAAGZ,YAAY,CAAChI,IAAD,EAAOyB,GAAP,CAA9B;;MAEA,IAAImH,SAAJ,EAAe;QACbH,MAAM,CAACI,IAAP,CAAYD,SAAZ;MACD;IACF,CAND,MAMO;MACL5I,IAAI,CAACmE,WAAL,CAAiB1C,GAAjB,EAAsBqH,OAAtB,CAA8BJ,IAA9B;IACD;EACF;;EACDA,IAAI,CAACjH,GAAD,CAAJ;EACA,OAAOgH,MAAP;AACD;;AAxBD/I;;AA0BA,MAAaqJ,OAAb,SAA6BC,KAA7B,CAAkC;EAChCC,YACEC,OADF,EAEkBC,QAFlB,EAGkBC,KAHlB,EAIkBC,UAJlB,EAKkBxH,MALlB,EAKgC;IAE9B,MAAMqH,OAAN;IALgB;IACA;IACA;IACA;IAGhBI,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,MAA5B,EAAoC;MAClCrB,KAAK,EAAEsB,GAAG,CAACC,MAAJ,CAAWC,IADgB;MAElCC,UAAU,EAAE,KAFsB;MAGlCC,YAAY,EAAE;IAHoB,CAApC;EAKD;;AAd+B;;AAAlClK;AAiBA;;;;;;;AAMA,SAAgBmK,WAAhB,CACEpI,GADF,EAEEO,KAFF,EAGEkH,OAHF,EAGiB;EAEf,MAAMxH,GAAG,GAAGD,GAAG,CAACE,6BAAJ,CAAkCK,KAAlC,CAAZ;EACA,OAAO,IAAI+G,OAAJ,CAAYG,OAAZ,EAAqBzH,GAAG,CAAC0H,QAAzB,EAAmCnH,KAAnC,EAA0CN,GAAG,CAACE,IAAJ,GAAW,CAArD,EAAwDF,GAAG,CAACI,SAA5D,CAAP;AACD;;AAPDpC;AASA;;;;;AAIA,SAAgB4E,aAAhB,CAA8BL,CAA9B,EAA0CxC,GAA1C,EAA4D;EAC1D;EACA;EACA,OAAOwC,CAAC,CAAC1E,IAAF,KAAWR,UAAU,CAAC4J,cAAtB,GACH,CAAC,CAAE1E,CAAuB,CAAC6F,KADxB,GAEH7F,CAAC,CAAC8F,QAAF,CAAWtI,GAAX,MAAoB,CAFxB;AAGD;;AAND/B;AAQA;;;;;;;;AAOA,SAAgBwE,YAAhB,CACE8F,KADF,EAEEC,QAFF,EAEwD;EAEtD,IAAID,KAAK,KAAKzF,SAAd,EAAyB;IACvB,OAAOA,SAAP;EACD;;EAED,KAAK,IAAI2F,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACxJ,MAA1B,EAAkC0J,CAAC,EAAnC,EAAuC;IACrC,MAAMzB,MAAM,GAAGwB,QAAQ,CAACD,KAAK,CAACE,CAAD,CAAN,EAAWA,CAAX,CAAvB;;IACA,IAAIzB,MAAM,KAAKlE,SAAf,EAA0B;MACxB,OAAOkE,MAAP;IACD;EACF;;EACD,OAAOlE,SAAP;AACD;;AAfD7E;;AAiBA,SAAgByK,uBAAhB,CAAwCC,EAAxC,EAAyD;EACvD,OAAOA,EAAE,CAAClE,mBAAH,KAA2BnH,UAAU,CAACsL,WAA7C;AACD;;AAFD3K;;AAIA,SAAgB4K,gBAAhB,CACEtK,IADF,EAC2B;EAEzB,OACE,CAAC,CAACA,IAAF,IACAA,IAAI,CAACT,IAAL,KAAcR,UAAU,CAACwH,UADzB,IAEA4D,uBAAuB,CAACnK,IAAD,CAHzB;AAKD;;AARDN;;AAUA,SAAgB6K,iBAAhB,CAAkCvK,IAAlC,EAA+C;EAC7C,IAAI,CAACsK,gBAAgB,CAACtK,IAAD,CAArB,EAA6B;IAC3B,OAAO,KAAP;EACD;;EAED,OAAOhB,EAAE,CAACwL,eAAH,CAAmBxK,IAAI,CAACoC,MAAxB,KAAmCpC,IAAI,CAACoC,MAAL,CAAYqI,IAAZ,KAAqBzK,IAA/D,EAAqE;IACnEA,IAAI,GAAGA,IAAI,CAACoC,MAAZ;EACD;;EAED,OAAOpC,IAAI,CAACoC,MAAL,CAAY7C,IAAZ,KAAqBR,UAAU,CAAC2L,SAAvC;AACD;;AAVDhL","names":["SyntaxKind","ts","LOGICAL_OPERATORS","BarBarToken","AmpersandAmpersandToken","QuestionQuestionToken","isAssignmentOperator","operator","kind","FirstAssignment","LastAssignment","exports","isLogicalOperator","includes","getTextForTokenKind","tokenToString","isESTreeClassMember","node","SemicolonClassElement","hasModifier","modifierKind","modifiers","some","modifier","getLastModifier","length","_a","isComma","token","CommaToken","isComment","SingleLineCommentTrivia","MultiLineCommentTrivia","isJSDocComment","JSDocComment","getBinaryExpressionType","ts_estree_1","AssignmentExpression","LogicalExpression","BinaryExpression","getLineAndCharacterFor","pos","ast","loc","getLineAndCharacterOfPosition","line","column","character","getLocFor","start","end","canContainDirective","Block","parent","Constructor","GetAccessor","SetAccessor","ArrowFunction","FunctionExpression","FunctionDeclaration","MethodDeclaration","getRange","getStart","getEnd","isToken","FirstToken","LastToken","isJSXToken","JsxElement","JsxAttribute","getDeclarationKind","flags","NodeFlags","Let","Const","getTSNodeAccessibility","PublicKeyword","ProtectedKeyword","PrivateKeyword","findNextToken","previousToken","find","n","firstDefined","getChildren","child","shouldDiveInChildNode","nodeHasTokens","undefined","findFirstMatchingAncestor","predicate","hasJSXAncestor","unescapeStringLiteralText","text","replace","entity","item","slice","codePoint","parseInt","String","fromCodePoint","xhtml_entities_1","isComputedProperty","ComputedPropertyName","isOptional","questionToken","QuestionToken","isChainExpression","type","ChainExpression","isChildUnwrappableOptionalChain","expression","ParenthesizedExpression","getTokenType","originalKeywordKind","NullKeyword","Null","FirstFutureReservedWord","LastKeyword","Identifier","Keyword","FirstKeyword","LastFutureReservedWord","FalseKeyword","TrueKeyword","Boolean","FirstPunctuation","LastPunctuation","Punctuator","NoSubstitutionTemplateLiteral","TemplateTail","Template","NumericLiteral","Numeric","JsxText","JSXText","StringLiteral","RegularExpressionLiteral","RegularExpression","ConstructorKeyword","GetKeyword","SetKeyword","JSXIdentifier","PropertyAccessExpression","convertToken","getFullStart","value","tokenType","range","regex","pattern","lastIndexOf","convertTokens","result","walk","EndOfFileToken","converted","push","forEach","TSError","Error","constructor","message","fileName","index","lineNumber","Object","defineProperty","new","target","name","enumerable","configurable","createError","jsDoc","getWidth","array","callback","i","identifierIsThisKeyword","id","ThisKeyword","isThisIdentifier","isThisInTypeQuery","isQualifiedName","left","TypeQuery"],"sources":["../src/node-utils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}