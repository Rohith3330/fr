{"ast":null,"code":"/**\n * @fileoverview Validates whitespace in and around the JSX opening and closing brackets\n * @author Diogo Franco (Kovensky)\n */\n'use strict';\n\nconst getTokenBeforeClosingBracket = require('../util/getTokenBeforeClosingBracket');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report');\n\nconst messages = {\n  selfCloseSlashNoSpace: 'Whitespace is forbidden between `/` and `>`; write `/>`',\n  selfCloseSlashNeedSpace: 'Whitespace is required between `/` and `>`; write `/ >`',\n  closeSlashNoSpace: 'Whitespace is forbidden between `<` and `/`; write `</`',\n  closeSlashNeedSpace: 'Whitespace is required between `<` and `/`; write `< /`',\n  beforeSelfCloseNoSpace: 'A space is forbidden before closing bracket',\n  beforeSelfCloseNeedSpace: 'A space is required before closing bracket',\n  beforeSelfCloseNeedNewline: 'A newline is required before closing bracket',\n  afterOpenNoSpace: 'A space is forbidden after opening bracket',\n  afterOpenNeedSpace: 'A space is required after opening bracket',\n  beforeCloseNoSpace: 'A space is forbidden before closing bracket',\n  beforeCloseNeedSpace: 'Whitespace is required before closing bracket',\n  beforeCloseNeedNewline: 'A newline is required before closing bracket'\n}; // ------------------------------------------------------------------------------\n// Validators\n// ------------------------------------------------------------------------------\n\nfunction validateClosingSlash(context, node, option) {\n  const sourceCode = context.getSourceCode();\n  let adjacent;\n\n  if (node.selfClosing) {\n    const lastTokens = sourceCode.getLastTokens(node, 2);\n    adjacent = !sourceCode.isSpaceBetweenTokens(lastTokens[0], lastTokens[1]);\n\n    if (option === 'never') {\n      if (!adjacent) {\n        report(context, messages.selfCloseSlashNoSpace, 'selfCloseSlashNoSpace', {\n          node,\n          loc: {\n            start: lastTokens[0].loc.start,\n            end: lastTokens[1].loc.end\n          },\n\n          fix(fixer) {\n            return fixer.removeRange([lastTokens[0].range[1], lastTokens[1].range[0]]);\n          }\n\n        });\n      }\n    } else if (option === 'always' && adjacent) {\n      report(context, messages.selfCloseSlashNeedSpace, 'selfCloseSlashNeedSpace', {\n        node,\n        loc: {\n          start: lastTokens[0].loc.start,\n          end: lastTokens[1].loc.end\n        },\n\n        fix(fixer) {\n          return fixer.insertTextBefore(lastTokens[1], ' ');\n        }\n\n      });\n    }\n  } else {\n    const firstTokens = sourceCode.getFirstTokens(node, 2);\n    adjacent = !sourceCode.isSpaceBetweenTokens(firstTokens[0], firstTokens[1]);\n\n    if (option === 'never') {\n      if (!adjacent) {\n        report(context, messages.closeSlashNoSpace, 'closeSlashNoSpace', {\n          node,\n          loc: {\n            start: firstTokens[0].loc.start,\n            end: firstTokens[1].loc.end\n          },\n\n          fix(fixer) {\n            return fixer.removeRange([firstTokens[0].range[1], firstTokens[1].range[0]]);\n          }\n\n        });\n      }\n    } else if (option === 'always' && adjacent) {\n      report(context, messages.closeSlashNeedSpace, 'closeSlashNeedSpace', {\n        node,\n        loc: {\n          start: firstTokens[0].loc.start,\n          end: firstTokens[1].loc.end\n        },\n\n        fix(fixer) {\n          return fixer.insertTextBefore(firstTokens[1], ' ');\n        }\n\n      });\n    }\n  }\n}\n\nfunction validateBeforeSelfClosing(context, node, option) {\n  const sourceCode = context.getSourceCode();\n  const leftToken = getTokenBeforeClosingBracket(node);\n  const closingSlash = sourceCode.getTokenAfter(leftToken);\n\n  if (node.loc.start.line !== node.loc.end.line && option === 'proportional-always') {\n    if (leftToken.loc.end.line === closingSlash.loc.start.line) {\n      report(context, messages.beforeSelfCloseNeedNewline, 'beforeSelfCloseNeedNewline', {\n        node,\n        loc: leftToken.loc.end,\n\n        fix(fixer) {\n          return fixer.insertTextBefore(closingSlash, '\\n');\n        }\n\n      });\n      return;\n    }\n  }\n\n  if (leftToken.loc.end.line !== closingSlash.loc.start.line) {\n    return;\n  }\n\n  const adjacent = !sourceCode.isSpaceBetweenTokens(leftToken, closingSlash);\n\n  if ((option === 'always' || option === 'proportional-always') && adjacent) {\n    report(context, messages.beforeSelfCloseNeedSpace, 'beforeSelfCloseNeedSpace', {\n      node,\n      loc: closingSlash.loc.start,\n\n      fix(fixer) {\n        return fixer.insertTextBefore(closingSlash, ' ');\n      }\n\n    });\n  } else if (option === 'never' && !adjacent) {\n    report(context, messages.beforeSelfCloseNoSpace, 'beforeSelfCloseNoSpace', {\n      node,\n      loc: closingSlash.loc.start,\n\n      fix(fixer) {\n        const previousToken = sourceCode.getTokenBefore(closingSlash);\n        return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);\n      }\n\n    });\n  }\n}\n\nfunction validateAfterOpening(context, node, option) {\n  const sourceCode = context.getSourceCode();\n  const openingToken = sourceCode.getTokenBefore(node.name);\n\n  if (option === 'allow-multiline') {\n    if (openingToken.loc.start.line !== node.name.loc.start.line) {\n      return;\n    }\n  }\n\n  const adjacent = !sourceCode.isSpaceBetweenTokens(openingToken, node.name);\n\n  if (option === 'never' || option === 'allow-multiline') {\n    if (!adjacent) {\n      report(context, messages.afterOpenNoSpace, 'afterOpenNoSpace', {\n        node,\n        loc: {\n          start: openingToken.loc.start,\n          end: node.name.loc.start\n        },\n\n        fix(fixer) {\n          return fixer.removeRange([openingToken.range[1], node.name.range[0]]);\n        }\n\n      });\n    }\n  } else if (option === 'always' && adjacent) {\n    report(context, messages.afterOpenNeedSpace, 'afterOpenNeedSpace', {\n      node,\n      loc: {\n        start: openingToken.loc.start,\n        end: node.name.loc.start\n      },\n\n      fix(fixer) {\n        return fixer.insertTextBefore(node.name, ' ');\n      }\n\n    });\n  }\n}\n\nfunction validateBeforeClosing(context, node, option) {\n  // Don't enforce this rule for self closing tags\n  if (!node.selfClosing) {\n    const sourceCode = context.getSourceCode();\n    const leftToken = option === 'proportional-always' ? getTokenBeforeClosingBracket(node) : sourceCode.getLastTokens(node, 2)[0];\n    const closingToken = sourceCode.getTokenAfter(leftToken);\n\n    if (node.loc.start.line !== node.loc.end.line && option === 'proportional-always') {\n      if (leftToken.loc.end.line === closingToken.loc.start.line) {\n        report(context, messages.beforeCloseNeedNewline, 'beforeCloseNeedNewline', {\n          node,\n          loc: leftToken.loc.end,\n\n          fix(fixer) {\n            return fixer.insertTextBefore(closingToken, '\\n');\n          }\n\n        });\n        return;\n      }\n    }\n\n    if (leftToken.loc.start.line !== closingToken.loc.start.line) {\n      return;\n    }\n\n    const adjacent = !sourceCode.isSpaceBetweenTokens(leftToken, closingToken);\n\n    if (option === 'never' && !adjacent) {\n      report(context, messages.beforeCloseNoSpace, 'beforeCloseNoSpace', {\n        node,\n        loc: {\n          start: leftToken.loc.end,\n          end: closingToken.loc.start\n        },\n\n        fix(fixer) {\n          return fixer.removeRange([leftToken.range[1], closingToken.range[0]]);\n        }\n\n      });\n    } else if (option === 'always' && adjacent) {\n      report(context, messages.beforeCloseNeedSpace, 'beforeCloseNeedSpace', {\n        node,\n        loc: {\n          start: leftToken.loc.end,\n          end: closingToken.loc.start\n        },\n\n        fix(fixer) {\n          return fixer.insertTextBefore(closingToken, ' ');\n        }\n\n      });\n    } else if (option === 'proportional-always' && node.type === 'JSXOpeningElement' && adjacent !== (node.loc.start.line === node.loc.end.line)) {\n      report(context, messages.beforeCloseNeedSpace, 'beforeCloseNeedSpace', {\n        node,\n        loc: {\n          start: leftToken.loc.end,\n          end: closingToken.loc.start\n        },\n\n        fix(fixer) {\n          return fixer.insertTextBefore(closingToken, ' ');\n        }\n\n      });\n    }\n  }\n} // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst optionDefaults = {\n  closingSlash: 'never',\n  beforeSelfClosing: 'always',\n  afterOpening: 'never',\n  beforeClosing: 'allow'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce whitespace in and around the JSX opening and closing brackets',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-tag-spacing')\n    },\n    fixable: 'whitespace',\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        closingSlash: {\n          enum: ['always', 'never', 'allow']\n        },\n        beforeSelfClosing: {\n          enum: ['always', 'proportional-always', 'never', 'allow']\n        },\n        afterOpening: {\n          enum: ['always', 'allow-multiline', 'never', 'allow']\n        },\n        beforeClosing: {\n          enum: ['always', 'proportional-always', 'never', 'allow']\n        }\n      },\n      default: optionDefaults,\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const options = Object.assign({}, optionDefaults, context.options[0]);\n    return {\n      JSXOpeningElement(node) {\n        if (options.closingSlash !== 'allow' && node.selfClosing) {\n          validateClosingSlash(context, node, options.closingSlash);\n        }\n\n        if (options.afterOpening !== 'allow') {\n          validateAfterOpening(context, node, options.afterOpening);\n        }\n\n        if (options.beforeSelfClosing !== 'allow' && node.selfClosing) {\n          validateBeforeSelfClosing(context, node, options.beforeSelfClosing);\n        }\n\n        if (options.beforeClosing !== 'allow') {\n          validateBeforeClosing(context, node, options.beforeClosing);\n        }\n      },\n\n      JSXClosingElement(node) {\n        if (options.afterOpening !== 'allow') {\n          validateAfterOpening(context, node, options.afterOpening);\n        }\n\n        if (options.closingSlash !== 'allow') {\n          validateClosingSlash(context, node, options.closingSlash);\n        }\n\n        if (options.beforeClosing !== 'allow') {\n          validateBeforeClosing(context, node, options.beforeClosing);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["getTokenBeforeClosingBracket","require","docsUrl","report","messages","selfCloseSlashNoSpace","selfCloseSlashNeedSpace","closeSlashNoSpace","closeSlashNeedSpace","beforeSelfCloseNoSpace","beforeSelfCloseNeedSpace","beforeSelfCloseNeedNewline","afterOpenNoSpace","afterOpenNeedSpace","beforeCloseNoSpace","beforeCloseNeedSpace","beforeCloseNeedNewline","validateClosingSlash","context","node","option","sourceCode","getSourceCode","adjacent","selfClosing","lastTokens","getLastTokens","isSpaceBetweenTokens","loc","start","end","fix","fixer","removeRange","range","insertTextBefore","firstTokens","getFirstTokens","validateBeforeSelfClosing","leftToken","closingSlash","getTokenAfter","line","previousToken","getTokenBefore","validateAfterOpening","openingToken","name","validateBeforeClosing","closingToken","type","optionDefaults","beforeSelfClosing","afterOpening","beforeClosing","module","exports","meta","docs","description","category","recommended","url","fixable","schema","properties","enum","default","additionalProperties","create","options","Object","assign","JSXOpeningElement","JSXClosingElement"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-tag-spacing.js"],"sourcesContent":["/**\n * @fileoverview Validates whitespace in and around the JSX opening and closing brackets\n * @author Diogo Franco (Kovensky)\n */\n\n'use strict';\n\nconst getTokenBeforeClosingBracket = require('../util/getTokenBeforeClosingBracket');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\nconst messages = {\n  selfCloseSlashNoSpace: 'Whitespace is forbidden between `/` and `>`; write `/>`',\n  selfCloseSlashNeedSpace: 'Whitespace is required between `/` and `>`; write `/ >`',\n  closeSlashNoSpace: 'Whitespace is forbidden between `<` and `/`; write `</`',\n  closeSlashNeedSpace: 'Whitespace is required between `<` and `/`; write `< /`',\n  beforeSelfCloseNoSpace: 'A space is forbidden before closing bracket',\n  beforeSelfCloseNeedSpace: 'A space is required before closing bracket',\n  beforeSelfCloseNeedNewline: 'A newline is required before closing bracket',\n  afterOpenNoSpace: 'A space is forbidden after opening bracket',\n  afterOpenNeedSpace: 'A space is required after opening bracket',\n  beforeCloseNoSpace: 'A space is forbidden before closing bracket',\n  beforeCloseNeedSpace: 'Whitespace is required before closing bracket',\n  beforeCloseNeedNewline: 'A newline is required before closing bracket',\n};\n\n// ------------------------------------------------------------------------------\n// Validators\n// ------------------------------------------------------------------------------\n\nfunction validateClosingSlash(context, node, option) {\n  const sourceCode = context.getSourceCode();\n\n  let adjacent;\n\n  if (node.selfClosing) {\n    const lastTokens = sourceCode.getLastTokens(node, 2);\n\n    adjacent = !sourceCode.isSpaceBetweenTokens(lastTokens[0], lastTokens[1]);\n\n    if (option === 'never') {\n      if (!adjacent) {\n        report(context, messages.selfCloseSlashNoSpace, 'selfCloseSlashNoSpace', {\n          node,\n          loc: {\n            start: lastTokens[0].loc.start,\n            end: lastTokens[1].loc.end,\n          },\n          fix(fixer) {\n            return fixer.removeRange([lastTokens[0].range[1], lastTokens[1].range[0]]);\n          },\n        });\n      }\n    } else if (option === 'always' && adjacent) {\n      report(context, messages.selfCloseSlashNeedSpace, 'selfCloseSlashNeedSpace', {\n        node,\n        loc: {\n          start: lastTokens[0].loc.start,\n          end: lastTokens[1].loc.end,\n        },\n        fix(fixer) {\n          return fixer.insertTextBefore(lastTokens[1], ' ');\n        },\n      });\n    }\n  } else {\n    const firstTokens = sourceCode.getFirstTokens(node, 2);\n\n    adjacent = !sourceCode.isSpaceBetweenTokens(firstTokens[0], firstTokens[1]);\n\n    if (option === 'never') {\n      if (!adjacent) {\n        report(context, messages.closeSlashNoSpace, 'closeSlashNoSpace', {\n          node,\n          loc: {\n            start: firstTokens[0].loc.start,\n            end: firstTokens[1].loc.end,\n          },\n          fix(fixer) {\n            return fixer.removeRange([firstTokens[0].range[1], firstTokens[1].range[0]]);\n          },\n        });\n      }\n    } else if (option === 'always' && adjacent) {\n      report(context, messages.closeSlashNeedSpace, 'closeSlashNeedSpace', {\n        node,\n        loc: {\n          start: firstTokens[0].loc.start,\n          end: firstTokens[1].loc.end,\n        },\n        fix(fixer) {\n          return fixer.insertTextBefore(firstTokens[1], ' ');\n        },\n      });\n    }\n  }\n}\n\nfunction validateBeforeSelfClosing(context, node, option) {\n  const sourceCode = context.getSourceCode();\n  const leftToken = getTokenBeforeClosingBracket(node);\n  const closingSlash = sourceCode.getTokenAfter(leftToken);\n\n  if (node.loc.start.line !== node.loc.end.line && option === 'proportional-always') {\n    if (leftToken.loc.end.line === closingSlash.loc.start.line) {\n      report(context, messages.beforeSelfCloseNeedNewline, 'beforeSelfCloseNeedNewline', {\n        node,\n        loc: leftToken.loc.end,\n        fix(fixer) {\n          return fixer.insertTextBefore(closingSlash, '\\n');\n        },\n      });\n      return;\n    }\n  }\n\n  if (leftToken.loc.end.line !== closingSlash.loc.start.line) {\n    return;\n  }\n\n  const adjacent = !sourceCode.isSpaceBetweenTokens(leftToken, closingSlash);\n\n  if ((option === 'always' || option === 'proportional-always') && adjacent) {\n    report(context, messages.beforeSelfCloseNeedSpace, 'beforeSelfCloseNeedSpace', {\n      node,\n      loc: closingSlash.loc.start,\n      fix(fixer) {\n        return fixer.insertTextBefore(closingSlash, ' ');\n      },\n    });\n  } else if (option === 'never' && !adjacent) {\n    report(context, messages.beforeSelfCloseNoSpace, 'beforeSelfCloseNoSpace', {\n      node,\n      loc: closingSlash.loc.start,\n      fix(fixer) {\n        const previousToken = sourceCode.getTokenBefore(closingSlash);\n        return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);\n      },\n    });\n  }\n}\n\nfunction validateAfterOpening(context, node, option) {\n  const sourceCode = context.getSourceCode();\n  const openingToken = sourceCode.getTokenBefore(node.name);\n\n  if (option === 'allow-multiline') {\n    if (openingToken.loc.start.line !== node.name.loc.start.line) {\n      return;\n    }\n  }\n\n  const adjacent = !sourceCode.isSpaceBetweenTokens(openingToken, node.name);\n\n  if (option === 'never' || option === 'allow-multiline') {\n    if (!adjacent) {\n      report(context, messages.afterOpenNoSpace, 'afterOpenNoSpace', {\n        node,\n        loc: {\n          start: openingToken.loc.start,\n          end: node.name.loc.start,\n        },\n        fix(fixer) {\n          return fixer.removeRange([openingToken.range[1], node.name.range[0]]);\n        },\n      });\n    }\n  } else if (option === 'always' && adjacent) {\n    report(context, messages.afterOpenNeedSpace, 'afterOpenNeedSpace', {\n      node,\n      loc: {\n        start: openingToken.loc.start,\n        end: node.name.loc.start,\n      },\n      fix(fixer) {\n        return fixer.insertTextBefore(node.name, ' ');\n      },\n    });\n  }\n}\n\nfunction validateBeforeClosing(context, node, option) {\n  // Don't enforce this rule for self closing tags\n  if (!node.selfClosing) {\n    const sourceCode = context.getSourceCode();\n    const leftToken = option === 'proportional-always'\n      ? getTokenBeforeClosingBracket(node)\n      : sourceCode.getLastTokens(node, 2)[0];\n    const closingToken = sourceCode.getTokenAfter(leftToken);\n\n    if (node.loc.start.line !== node.loc.end.line && option === 'proportional-always') {\n      if (leftToken.loc.end.line === closingToken.loc.start.line) {\n        report(context, messages.beforeCloseNeedNewline, 'beforeCloseNeedNewline', {\n          node,\n          loc: leftToken.loc.end,\n          fix(fixer) {\n            return fixer.insertTextBefore(closingToken, '\\n');\n          },\n        });\n        return;\n      }\n    }\n\n    if (leftToken.loc.start.line !== closingToken.loc.start.line) {\n      return;\n    }\n\n    const adjacent = !sourceCode.isSpaceBetweenTokens(leftToken, closingToken);\n\n    if (option === 'never' && !adjacent) {\n      report(context, messages.beforeCloseNoSpace, 'beforeCloseNoSpace', {\n        node,\n        loc: {\n          start: leftToken.loc.end,\n          end: closingToken.loc.start,\n        },\n        fix(fixer) {\n          return fixer.removeRange([leftToken.range[1], closingToken.range[0]]);\n        },\n      });\n    } else if (option === 'always' && adjacent) {\n      report(context, messages.beforeCloseNeedSpace, 'beforeCloseNeedSpace', {\n        node,\n        loc: {\n          start: leftToken.loc.end,\n          end: closingToken.loc.start,\n        },\n        fix(fixer) {\n          return fixer.insertTextBefore(closingToken, ' ');\n        },\n      });\n    } else if (option === 'proportional-always' && node.type === 'JSXOpeningElement' && adjacent !== (node.loc.start.line === node.loc.end.line)) {\n      report(context, messages.beforeCloseNeedSpace, 'beforeCloseNeedSpace', {\n        node,\n        loc: {\n          start: leftToken.loc.end,\n          end: closingToken.loc.start,\n        },\n        fix(fixer) {\n          return fixer.insertTextBefore(closingToken, ' ');\n        },\n      });\n    }\n  }\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst optionDefaults = {\n  closingSlash: 'never',\n  beforeSelfClosing: 'always',\n  afterOpening: 'never',\n  beforeClosing: 'allow',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce whitespace in and around the JSX opening and closing brackets',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-tag-spacing'),\n    },\n    fixable: 'whitespace',\n\n    messages,\n\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          closingSlash: {\n            enum: ['always', 'never', 'allow'],\n          },\n          beforeSelfClosing: {\n            enum: ['always', 'proportional-always', 'never', 'allow'],\n          },\n          afterOpening: {\n            enum: ['always', 'allow-multiline', 'never', 'allow'],\n          },\n          beforeClosing: {\n            enum: ['always', 'proportional-always', 'never', 'allow'],\n          },\n        },\n        default: optionDefaults,\n        additionalProperties: false,\n      },\n    ],\n  },\n  create(context) {\n    const options = Object.assign({}, optionDefaults, context.options[0]);\n\n    return {\n      JSXOpeningElement(node) {\n        if (options.closingSlash !== 'allow' && node.selfClosing) {\n          validateClosingSlash(context, node, options.closingSlash);\n        }\n        if (options.afterOpening !== 'allow') {\n          validateAfterOpening(context, node, options.afterOpening);\n        }\n        if (options.beforeSelfClosing !== 'allow' && node.selfClosing) {\n          validateBeforeSelfClosing(context, node, options.beforeSelfClosing);\n        }\n        if (options.beforeClosing !== 'allow') {\n          validateBeforeClosing(context, node, options.beforeClosing);\n        }\n      },\n      JSXClosingElement(node) {\n        if (options.afterOpening !== 'allow') {\n          validateAfterOpening(context, node, options.afterOpening);\n        }\n        if (options.closingSlash !== 'allow') {\n          validateClosingSlash(context, node, options.closingSlash);\n        }\n        if (options.beforeClosing !== 'allow') {\n          validateBeforeClosing(context, node, options.beforeClosing);\n        }\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}