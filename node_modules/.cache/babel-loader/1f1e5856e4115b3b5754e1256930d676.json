{"ast":null,"code":"/** @license React vundefined\n * react-refresh-babel.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    function ReactFreshBabelPlugin(babel) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (typeof babel.env === 'function') {\n        // Only available in Babel 7.\n        var env = babel.env();\n\n        if (env !== 'development' && !opts.skipEnvCheck) {\n          throw new Error('React Refresh Babel transform should only be enabled in development environment. ' + 'Instead, the environment is: \"' + env + '\". If you want to override this check, pass {skipEnvCheck: true} as plugin options.');\n        }\n      }\n\n      var t = babel.types;\n      var refreshReg = t.identifier(opts.refreshReg || '$RefreshReg$');\n      var refreshSig = t.identifier(opts.refreshSig || '$RefreshSig$');\n      var registrationsByProgramPath = new Map();\n\n      function createRegistration(programPath, persistentID) {\n        var handle = programPath.scope.generateUidIdentifier('c');\n\n        if (!registrationsByProgramPath.has(programPath)) {\n          registrationsByProgramPath.set(programPath, []);\n        }\n\n        var registrations = registrationsByProgramPath.get(programPath);\n        registrations.push({\n          handle: handle,\n          persistentID: persistentID\n        });\n        return handle;\n      }\n\n      function isComponentishName(name) {\n        return typeof name === 'string' && name[0] >= 'A' && name[0] <= 'Z';\n      }\n\n      function findInnerComponents(inferredName, path, callback) {\n        var node = path.node;\n\n        switch (node.type) {\n          case 'Identifier':\n            {\n              if (!isComponentishName(node.name)) {\n                return false;\n              } // export default hoc(Foo)\n              // const X = hoc(Foo)\n\n\n              callback(inferredName, node, null);\n              return true;\n            }\n\n          case 'FunctionDeclaration':\n            {\n              // function Foo() {}\n              // export function Foo() {}\n              // export default function Foo() {}\n              callback(inferredName, node.id, null);\n              return true;\n            }\n\n          case 'ArrowFunctionExpression':\n            {\n              if (node.body.type === 'ArrowFunctionExpression') {\n                return false;\n              } // let Foo = () => {}\n              // export default hoc1(hoc2(() => {}))\n\n\n              callback(inferredName, node, path);\n              return true;\n            }\n\n          case 'FunctionExpression':\n            {\n              // let Foo = function() {}\n              // const Foo = hoc1(forwardRef(function renderFoo() {}))\n              // export default memo(function() {})\n              callback(inferredName, node, path);\n              return true;\n            }\n\n          case 'CallExpression':\n            {\n              var argsPath = path.get('arguments');\n\n              if (argsPath === undefined || argsPath.length === 0) {\n                return false;\n              }\n\n              var calleePath = path.get('callee');\n\n              switch (calleePath.node.type) {\n                case 'MemberExpression':\n                case 'Identifier':\n                  {\n                    var calleeSource = calleePath.getSource();\n                    var firstArgPath = argsPath[0];\n                    var innerName = inferredName + '$' + calleeSource;\n                    var foundInside = findInnerComponents(innerName, firstArgPath, callback);\n\n                    if (!foundInside) {\n                      return false;\n                    } // const Foo = hoc1(hoc2(() => {}))\n                    // export default memo(React.forwardRef(function() {}))\n\n\n                    callback(inferredName, node, path);\n                    return true;\n                  }\n\n                default:\n                  {\n                    return false;\n                  }\n              }\n            }\n\n          case 'VariableDeclarator':\n            {\n              var init = node.init;\n\n              if (init === null) {\n                return false;\n              }\n\n              var name = node.id.name;\n\n              if (!isComponentishName(name)) {\n                return false;\n              }\n\n              switch (init.type) {\n                case 'ArrowFunctionExpression':\n                case 'FunctionExpression':\n                  // Likely component definitions.\n                  break;\n\n                case 'CallExpression':\n                  {\n                    // Maybe a HOC.\n                    // Try to determine if this is some form of import.\n                    var callee = init.callee;\n                    var calleeType = callee.type;\n\n                    if (calleeType === 'Import') {\n                      return false;\n                    } else if (calleeType === 'Identifier') {\n                      if (callee.name.indexOf('require') === 0) {\n                        return false;\n                      } else if (callee.name.indexOf('import') === 0) {\n                        return false;\n                      } // Neither require nor import. Might be a HOC.\n                      // Pass through.\n\n                    }\n\n                    break;\n                  }\n\n                case 'TaggedTemplateExpression':\n                  // Maybe something like styled.div`...`\n                  break;\n\n                default:\n                  return false;\n              }\n\n              var initPath = path.get('init');\n\n              var _foundInside = findInnerComponents(inferredName, initPath, callback);\n\n              if (_foundInside) {\n                return true;\n              } // See if this identifier is used in JSX. Then it's a component.\n\n\n              var binding = path.scope.getBinding(name);\n\n              if (binding === undefined) {\n                return;\n              }\n\n              var isLikelyUsedAsType = false;\n              var referencePaths = binding.referencePaths;\n\n              for (var i = 0; i < referencePaths.length; i++) {\n                var ref = referencePaths[i];\n\n                if (ref.node && ref.node.type !== 'JSXIdentifier' && ref.node.type !== 'Identifier') {\n                  continue;\n                }\n\n                var refParent = ref.parent;\n\n                if (refParent.type === 'JSXOpeningElement') {\n                  isLikelyUsedAsType = true;\n                } else if (refParent.type === 'CallExpression') {\n                  var _callee = refParent.callee;\n                  var fnName = void 0;\n\n                  switch (_callee.type) {\n                    case 'Identifier':\n                      fnName = _callee.name;\n                      break;\n\n                    case 'MemberExpression':\n                      fnName = _callee.property.name;\n                      break;\n                  }\n\n                  switch (fnName) {\n                    case 'createElement':\n                    case 'jsx':\n                    case 'jsxDEV':\n                    case 'jsxs':\n                      isLikelyUsedAsType = true;\n                      break;\n                  }\n                }\n\n                if (isLikelyUsedAsType) {\n                  // const X = ... + later <X />\n                  callback(inferredName, init, initPath);\n                  return true;\n                }\n              }\n            }\n        }\n\n        return false;\n      }\n\n      function isBuiltinHook(hookName) {\n        switch (hookName) {\n          case 'useState':\n          case 'React.useState':\n          case 'useReducer':\n          case 'React.useReducer':\n          case 'useEffect':\n          case 'React.useEffect':\n          case 'useLayoutEffect':\n          case 'React.useLayoutEffect':\n          case 'useMemo':\n          case 'React.useMemo':\n          case 'useCallback':\n          case 'React.useCallback':\n          case 'useRef':\n          case 'React.useRef':\n          case 'useContext':\n          case 'React.useContext':\n          case 'useImperativeHandle':\n          case 'React.useImperativeHandle':\n          case 'useDebugValue':\n          case 'React.useDebugValue':\n            return true;\n\n          default:\n            return false;\n        }\n      }\n\n      function getHookCallsSignature(functionNode) {\n        var fnHookCalls = hookCalls.get(functionNode);\n\n        if (fnHookCalls === undefined) {\n          return null;\n        }\n\n        return {\n          key: fnHookCalls.map(function (call) {\n            return call.name + '{' + call.key + '}';\n          }).join('\\n'),\n          customHooks: fnHookCalls.filter(function (call) {\n            return !isBuiltinHook(call.name);\n          }).map(function (call) {\n            return t.cloneDeep(call.callee);\n          })\n        };\n      }\n\n      var hasForceResetCommentByFile = new WeakMap(); // We let user do /* @refresh reset */ to reset state in the whole file.\n\n      function hasForceResetComment(path) {\n        var file = path.hub.file;\n        var hasForceReset = hasForceResetCommentByFile.get(file);\n\n        if (hasForceReset !== undefined) {\n          return hasForceReset;\n        }\n\n        hasForceReset = false;\n        var comments = file.ast.comments;\n\n        for (var i = 0; i < comments.length; i++) {\n          var cmt = comments[i];\n\n          if (cmt.value.indexOf('@refresh reset') !== -1) {\n            hasForceReset = true;\n            break;\n          }\n        }\n\n        hasForceResetCommentByFile.set(file, hasForceReset);\n        return hasForceReset;\n      }\n\n      function createArgumentsForSignature(node, signature, scope) {\n        var key = signature.key,\n            customHooks = signature.customHooks;\n        var forceReset = hasForceResetComment(scope.path);\n        var customHooksInScope = [];\n        customHooks.forEach(function (callee) {\n          // Check if a corresponding binding exists where we emit the signature.\n          var bindingName;\n\n          switch (callee.type) {\n            case 'MemberExpression':\n              if (callee.object.type === 'Identifier') {\n                bindingName = callee.object.name;\n              }\n\n              break;\n\n            case 'Identifier':\n              bindingName = callee.name;\n              break;\n          }\n\n          if (scope.hasBinding(bindingName)) {\n            customHooksInScope.push(callee);\n          } else {\n            // We don't have anything to put in the array because Hook is out of scope.\n            // Since it could potentially have been edited, remount the component.\n            forceReset = true;\n          }\n        });\n        var finalKey = key;\n\n        if (typeof require === 'function' && !opts.emitFullSignatures) {\n          // Prefer to hash when we can (e.g. outside of ASTExplorer).\n          // This makes it deterministically compact, even if there's\n          // e.g. a useState initializer with some code inside.\n          // We also need it for www that has transforms like cx()\n          // that don't understand if something is part of a string.\n          finalKey = require('crypto').createHash('sha1').update(key).digest('base64');\n        }\n\n        var args = [node, t.stringLiteral(finalKey)];\n\n        if (forceReset || customHooksInScope.length > 0) {\n          args.push(t.booleanLiteral(forceReset));\n        }\n\n        if (customHooksInScope.length > 0) {\n          args.push( // TODO: We could use an arrow here to be more compact.\n          // However, don't do it until AMA can run them natively.\n          t.functionExpression(null, [], t.blockStatement([t.returnStatement(t.arrayExpression(customHooksInScope))])));\n        }\n\n        return args;\n      }\n\n      function findHOCCallPathsAbove(path) {\n        var calls = [];\n\n        while (true) {\n          if (!path) {\n            return calls;\n          }\n\n          var parentPath = path.parentPath;\n\n          if (!parentPath) {\n            return calls;\n          }\n\n          if ( // hoc(_c = function() { })\n          parentPath.node.type === 'AssignmentExpression' && path.node === parentPath.node.right) {\n            // Ignore registrations.\n            path = parentPath;\n            continue;\n          }\n\n          if ( // hoc1(hoc2(...))\n          parentPath.node.type === 'CallExpression' && path.node !== parentPath.node.callee) {\n            calls.push(parentPath);\n            path = parentPath;\n            continue;\n          }\n\n          return calls; // Stop at other types.\n        }\n      }\n\n      var seenForRegistration = new WeakSet();\n      var seenForSignature = new WeakSet();\n      var seenForOutro = new WeakSet();\n      var hookCalls = new WeakMap();\n      var HookCallsVisitor = {\n        CallExpression: function (path) {\n          var node = path.node;\n          var callee = node.callee; // Note: this visitor MUST NOT mutate the tree in any way.\n          // It runs early in a separate traversal and should be very fast.\n\n          var name = null;\n\n          switch (callee.type) {\n            case 'Identifier':\n              name = callee.name;\n              break;\n\n            case 'MemberExpression':\n              name = callee.property.name;\n              break;\n          }\n\n          if (name === null || !/^use[A-Z]/.test(name)) {\n            return;\n          }\n\n          var fnScope = path.scope.getFunctionParent();\n\n          if (fnScope === null) {\n            return;\n          } // This is a Hook call. Record it.\n\n\n          var fnNode = fnScope.block;\n\n          if (!hookCalls.has(fnNode)) {\n            hookCalls.set(fnNode, []);\n          }\n\n          var hookCallsForFn = hookCalls.get(fnNode);\n          var key = '';\n\n          if (path.parent.type === 'VariableDeclarator') {\n            // TODO: if there is no LHS, consider some other heuristic.\n            key = path.parentPath.get('id').getSource();\n          } // Some built-in Hooks reset on edits to arguments.\n\n\n          var args = path.get('arguments');\n\n          if (name === 'useState' && args.length > 0) {\n            // useState second argument is initial state.\n            key += '(' + args[0].getSource() + ')';\n          } else if (name === 'useReducer' && args.length > 1) {\n            // useReducer second argument is initial state.\n            key += '(' + args[1].getSource() + ')';\n          }\n\n          hookCallsForFn.push({\n            callee: path.node.callee,\n            name: name,\n            key: key\n          });\n        }\n      };\n      return {\n        visitor: {\n          ExportDefaultDeclaration: function (path) {\n            var node = path.node;\n            var decl = node.declaration;\n            var declPath = path.get('declaration');\n\n            if (decl.type !== 'CallExpression') {\n              // For now, we only support possible HOC calls here.\n              // Named function declarations are handled in FunctionDeclaration.\n              // Anonymous direct exports like export default function() {}\n              // are currently ignored.\n              return;\n            } // Make sure we're not mutating the same tree twice.\n            // This can happen if another Babel plugin replaces parents.\n\n\n            if (seenForRegistration.has(node)) {\n              return;\n            }\n\n            seenForRegistration.add(node); // Don't mutate the tree above this point.\n            // This code path handles nested cases like:\n            // export default memo(() => {})\n            // In those cases it is more plausible people will omit names\n            // so they're worth handling despite possible false positives.\n            // More importantly, it handles the named case:\n            // export default memo(function Named() {})\n\n            var inferredName = '%default%';\n            var programPath = path.parentPath;\n            findInnerComponents(inferredName, declPath, function (persistentID, targetExpr, targetPath) {\n              if (targetPath === null) {\n                // For case like:\n                // export default hoc(Foo)\n                // we don't want to wrap Foo inside the call.\n                // Instead we assume it's registered at definition.\n                return;\n              }\n\n              var handle = createRegistration(programPath, persistentID);\n              targetPath.replaceWith(t.assignmentExpression('=', handle, targetExpr));\n            });\n          },\n          FunctionDeclaration: {\n            enter: function (path) {\n              var node = path.node;\n              var programPath;\n              var insertAfterPath;\n              var modulePrefix = '';\n\n              switch (path.parent.type) {\n                case 'Program':\n                  insertAfterPath = path;\n                  programPath = path.parentPath;\n                  break;\n\n                case 'TSModuleBlock':\n                  insertAfterPath = path;\n                  programPath = insertAfterPath.parentPath.parentPath;\n                  break;\n\n                case 'ExportNamedDeclaration':\n                  insertAfterPath = path.parentPath;\n                  programPath = insertAfterPath.parentPath;\n                  break;\n\n                case 'ExportDefaultDeclaration':\n                  insertAfterPath = path.parentPath;\n                  programPath = insertAfterPath.parentPath;\n                  break;\n\n                default:\n                  return;\n              } // These types can be nested in typescript namespace\n              // We need to find the export chain\n              // Or return if it stays local\n\n\n              if (path.parent.type === 'TSModuleBlock' || path.parent.type === 'ExportNamedDeclaration') {\n                while (programPath.type !== 'Program') {\n                  if (programPath.type === 'TSModuleDeclaration') {\n                    if (programPath.parentPath.type !== 'Program' && programPath.parentPath.type !== 'ExportNamedDeclaration') {\n                      return;\n                    }\n\n                    modulePrefix = programPath.node.id.name + '$' + modulePrefix;\n                  }\n\n                  programPath = programPath.parentPath;\n                }\n              }\n\n              var id = node.id;\n\n              if (id === null) {\n                // We don't currently handle anonymous default exports.\n                return;\n              }\n\n              var inferredName = id.name;\n\n              if (!isComponentishName(inferredName)) {\n                return;\n              } // Make sure we're not mutating the same tree twice.\n              // This can happen if another Babel plugin replaces parents.\n\n\n              if (seenForRegistration.has(node)) {\n                return;\n              }\n\n              seenForRegistration.add(node); // Don't mutate the tree above this point.\n\n              var innerName = modulePrefix + inferredName; // export function Named() {}\n              // function Named() {}\n\n              findInnerComponents(innerName, path, function (persistentID, targetExpr) {\n                var handle = createRegistration(programPath, persistentID);\n                insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression('=', handle, targetExpr)));\n              });\n            },\n            exit: function (path) {\n              var node = path.node;\n              var id = node.id;\n\n              if (id === null) {\n                return;\n              }\n\n              var signature = getHookCallsSignature(node);\n\n              if (signature === null) {\n                return;\n              } // Make sure we're not mutating the same tree twice.\n              // This can happen if another Babel plugin replaces parents.\n\n\n              if (seenForSignature.has(node)) {\n                return;\n              }\n\n              seenForSignature.add(node); // Don't mutate the tree above this point.\n\n              var sigCallID = path.scope.generateUidIdentifier('_s');\n              path.scope.parent.push({\n                id: sigCallID,\n                init: t.callExpression(refreshSig, [])\n              }); // The signature call is split in two parts. One part is called inside the function.\n              // This is used to signal when first render happens.\n\n              path.get('body').unshiftContainer('body', t.expressionStatement(t.callExpression(sigCallID, []))); // The second call is around the function itself.\n              // This is used to associate a type with a signature.\n              // Unlike with $RefreshReg$, this needs to work for nested\n              // declarations too. So we need to search for a path where\n              // we can insert a statement rather than hard coding it.\n\n              var insertAfterPath = null;\n              path.find(function (p) {\n                if (p.parentPath.isBlock()) {\n                  insertAfterPath = p;\n                  return true;\n                }\n              });\n\n              if (insertAfterPath === null) {\n                return;\n              }\n\n              insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(id, signature, insertAfterPath.scope))));\n            }\n          },\n          'ArrowFunctionExpression|FunctionExpression': {\n            exit: function (path) {\n              var node = path.node;\n              var signature = getHookCallsSignature(node);\n\n              if (signature === null) {\n                return;\n              } // Make sure we're not mutating the same tree twice.\n              // This can happen if another Babel plugin replaces parents.\n\n\n              if (seenForSignature.has(node)) {\n                return;\n              }\n\n              seenForSignature.add(node); // Don't mutate the tree above this point.\n\n              var sigCallID = path.scope.generateUidIdentifier('_s');\n              path.scope.parent.push({\n                id: sigCallID,\n                init: t.callExpression(refreshSig, [])\n              }); // The signature call is split in two parts. One part is called inside the function.\n              // This is used to signal when first render happens.\n\n              if (path.node.body.type !== 'BlockStatement') {\n                path.node.body = t.blockStatement([t.returnStatement(path.node.body)]);\n              }\n\n              path.get('body').unshiftContainer('body', t.expressionStatement(t.callExpression(sigCallID, []))); // The second call is around the function itself.\n              // This is used to associate a type with a signature.\n\n              if (path.parent.type === 'VariableDeclarator') {\n                var insertAfterPath = null;\n                path.find(function (p) {\n                  if (p.parentPath.isBlock()) {\n                    insertAfterPath = p;\n                    return true;\n                  }\n                });\n\n                if (insertAfterPath === null) {\n                  return;\n                } // Special case when a function would get an inferred name:\n                // let Foo = () => {}\n                // let Foo = function() {}\n                // We'll add signature it on next line so that\n                // we don't mess up the inferred 'Foo' function name.\n\n\n                insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(path.parent.id, signature, insertAfterPath.scope)))); // Result: let Foo = () => {}; __signature(Foo, ...);\n              } else {\n                // let Foo = hoc(() => {})\n                var paths = [path].concat(findHOCCallPathsAbove(path));\n                paths.forEach(function (p) {\n                  p.replaceWith(t.callExpression(sigCallID, createArgumentsForSignature(p.node, signature, p.scope)));\n                }); // Result: let Foo = __signature(hoc(__signature(() => {}, ...)), ...)\n              }\n            }\n          },\n          VariableDeclaration: function (path) {\n            var node = path.node;\n            var programPath;\n            var insertAfterPath;\n            var modulePrefix = '';\n\n            switch (path.parent.type) {\n              case 'Program':\n                insertAfterPath = path;\n                programPath = path.parentPath;\n                break;\n\n              case 'TSModuleBlock':\n                insertAfterPath = path;\n                programPath = insertAfterPath.parentPath.parentPath;\n                break;\n\n              case 'ExportNamedDeclaration':\n                insertAfterPath = path.parentPath;\n                programPath = insertAfterPath.parentPath;\n                break;\n\n              case 'ExportDefaultDeclaration':\n                insertAfterPath = path.parentPath;\n                programPath = insertAfterPath.parentPath;\n                break;\n\n              default:\n                return;\n            } // These types can be nested in typescript namespace\n            // We need to find the export chain\n            // Or return if it stays local\n\n\n            if (path.parent.type === 'TSModuleBlock' || path.parent.type === 'ExportNamedDeclaration') {\n              while (programPath.type !== 'Program') {\n                if (programPath.type === 'TSModuleDeclaration') {\n                  if (programPath.parentPath.type !== 'Program' && programPath.parentPath.type !== 'ExportNamedDeclaration') {\n                    return;\n                  }\n\n                  modulePrefix = programPath.node.id.name + '$' + modulePrefix;\n                }\n\n                programPath = programPath.parentPath;\n              }\n            } // Make sure we're not mutating the same tree twice.\n            // This can happen if another Babel plugin replaces parents.\n\n\n            if (seenForRegistration.has(node)) {\n              return;\n            }\n\n            seenForRegistration.add(node); // Don't mutate the tree above this point.\n\n            var declPaths = path.get('declarations');\n\n            if (declPaths.length !== 1) {\n              return;\n            }\n\n            var declPath = declPaths[0];\n            var inferredName = declPath.node.id.name;\n            var innerName = modulePrefix + inferredName;\n            findInnerComponents(innerName, declPath, function (persistentID, targetExpr, targetPath) {\n              if (targetPath === null) {\n                // For case like:\n                // export const Something = hoc(Foo)\n                // we don't want to wrap Foo inside the call.\n                // Instead we assume it's registered at definition.\n                return;\n              }\n\n              var handle = createRegistration(programPath, persistentID);\n\n              if (targetPath.parent.type === 'VariableDeclarator') {\n                // Special case when a variable would get an inferred name:\n                // let Foo = () => {}\n                // let Foo = function() {}\n                // let Foo = styled.div``;\n                // We'll register it on next line so that\n                // we don't mess up the inferred 'Foo' function name.\n                // (eg: with @babel/plugin-transform-react-display-name or\n                // babel-plugin-styled-components)\n                insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression('=', handle, declPath.node.id))); // Result: let Foo = () => {}; _c1 = Foo;\n              } else {\n                // let Foo = hoc(() => {})\n                targetPath.replaceWith(t.assignmentExpression('=', handle, targetExpr)); // Result: let Foo = hoc(_c1 = () => {})\n              }\n            });\n          },\n          Program: {\n            enter: function (path) {\n              // This is a separate early visitor because we need to collect Hook calls\n              // and \"const [foo, setFoo] = ...\" signatures before the destructuring\n              // transform mangles them. This extra traversal is not ideal for perf,\n              // but it's the best we can do until we stop transpiling destructuring.\n              path.traverse(HookCallsVisitor);\n            },\n            exit: function (path) {\n              var registrations = registrationsByProgramPath.get(path);\n\n              if (registrations === undefined) {\n                return;\n              } // Make sure we're not mutating the same tree twice.\n              // This can happen if another Babel plugin replaces parents.\n\n\n              var node = path.node;\n\n              if (seenForOutro.has(node)) {\n                return;\n              }\n\n              seenForOutro.add(node); // Don't mutate the tree above this point.\n\n              registrationsByProgramPath.delete(path);\n              var declarators = [];\n              path.pushContainer('body', t.variableDeclaration('var', declarators));\n              registrations.forEach(function (_ref) {\n                var handle = _ref.handle,\n                    persistentID = _ref.persistentID;\n                path.pushContainer('body', t.expressionStatement(t.callExpression(refreshReg, [handle, t.stringLiteral(persistentID)])));\n                declarators.push(t.variableDeclarator(handle));\n              });\n            }\n          }\n        }\n      };\n    }\n\n    module.exports = ReactFreshBabelPlugin;\n  })();\n}","map":{"version":3,"names":["process","env","NODE_ENV","ReactFreshBabelPlugin","babel","opts","arguments","length","undefined","skipEnvCheck","Error","t","types","refreshReg","identifier","refreshSig","registrationsByProgramPath","Map","createRegistration","programPath","persistentID","handle","scope","generateUidIdentifier","has","set","registrations","get","push","isComponentishName","name","findInnerComponents","inferredName","path","callback","node","type","id","body","argsPath","calleePath","calleeSource","getSource","firstArgPath","innerName","foundInside","init","callee","calleeType","indexOf","initPath","_foundInside","binding","getBinding","isLikelyUsedAsType","referencePaths","i","ref","refParent","parent","_callee","fnName","property","isBuiltinHook","hookName","getHookCallsSignature","functionNode","fnHookCalls","hookCalls","key","map","call","join","customHooks","filter","cloneDeep","hasForceResetCommentByFile","WeakMap","hasForceResetComment","file","hub","hasForceReset","comments","ast","cmt","value","createArgumentsForSignature","signature","forceReset","customHooksInScope","forEach","bindingName","object","hasBinding","finalKey","require","emitFullSignatures","createHash","update","digest","args","stringLiteral","booleanLiteral","functionExpression","blockStatement","returnStatement","arrayExpression","findHOCCallPathsAbove","calls","parentPath","right","seenForRegistration","WeakSet","seenForSignature","seenForOutro","HookCallsVisitor","CallExpression","test","fnScope","getFunctionParent","fnNode","block","hookCallsForFn","visitor","ExportDefaultDeclaration","decl","declaration","declPath","add","targetExpr","targetPath","replaceWith","assignmentExpression","FunctionDeclaration","enter","insertAfterPath","modulePrefix","insertAfter","expressionStatement","exit","sigCallID","callExpression","unshiftContainer","find","p","isBlock","paths","concat","VariableDeclaration","declPaths","Program","traverse","delete","declarators","pushContainer","variableDeclaration","_ref","variableDeclarator","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/react-refresh/cjs/react-refresh-babel.development.js"],"sourcesContent":["/** @license React vundefined\n * react-refresh-babel.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nfunction ReactFreshBabelPlugin (babel) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof babel.env === 'function') {\n    // Only available in Babel 7.\n    var env = babel.env();\n\n    if (env !== 'development' && !opts.skipEnvCheck) {\n      throw new Error('React Refresh Babel transform should only be enabled in development environment. ' + 'Instead, the environment is: \"' + env + '\". If you want to override this check, pass {skipEnvCheck: true} as plugin options.');\n    }\n  }\n\n  var t = babel.types;\n  var refreshReg = t.identifier(opts.refreshReg || '$RefreshReg$');\n  var refreshSig = t.identifier(opts.refreshSig || '$RefreshSig$');\n  var registrationsByProgramPath = new Map();\n\n  function createRegistration(programPath, persistentID) {\n    var handle = programPath.scope.generateUidIdentifier('c');\n\n    if (!registrationsByProgramPath.has(programPath)) {\n      registrationsByProgramPath.set(programPath, []);\n    }\n\n    var registrations = registrationsByProgramPath.get(programPath);\n    registrations.push({\n      handle: handle,\n      persistentID: persistentID\n    });\n    return handle;\n  }\n\n  function isComponentishName(name) {\n    return typeof name === 'string' && name[0] >= 'A' && name[0] <= 'Z';\n  }\n\n  function findInnerComponents(inferredName, path, callback) {\n    var node = path.node;\n\n    switch (node.type) {\n      case 'Identifier':\n        {\n          if (!isComponentishName(node.name)) {\n            return false;\n          } // export default hoc(Foo)\n          // const X = hoc(Foo)\n\n\n          callback(inferredName, node, null);\n          return true;\n        }\n\n      case 'FunctionDeclaration':\n        {\n          // function Foo() {}\n          // export function Foo() {}\n          // export default function Foo() {}\n          callback(inferredName, node.id, null);\n          return true;\n        }\n\n      case 'ArrowFunctionExpression':\n        {\n          if (node.body.type === 'ArrowFunctionExpression') {\n            return false;\n          } // let Foo = () => {}\n          // export default hoc1(hoc2(() => {}))\n\n\n          callback(inferredName, node, path);\n          return true;\n        }\n\n      case 'FunctionExpression':\n        {\n          // let Foo = function() {}\n          // const Foo = hoc1(forwardRef(function renderFoo() {}))\n          // export default memo(function() {})\n          callback(inferredName, node, path);\n          return true;\n        }\n\n      case 'CallExpression':\n        {\n          var argsPath = path.get('arguments');\n\n          if (argsPath === undefined || argsPath.length === 0) {\n            return false;\n          }\n\n          var calleePath = path.get('callee');\n\n          switch (calleePath.node.type) {\n            case 'MemberExpression':\n            case 'Identifier':\n              {\n                var calleeSource = calleePath.getSource();\n                var firstArgPath = argsPath[0];\n                var innerName = inferredName + '$' + calleeSource;\n                var foundInside = findInnerComponents(innerName, firstArgPath, callback);\n\n                if (!foundInside) {\n                  return false;\n                } // const Foo = hoc1(hoc2(() => {}))\n                // export default memo(React.forwardRef(function() {}))\n\n\n                callback(inferredName, node, path);\n                return true;\n              }\n\n            default:\n              {\n                return false;\n              }\n          }\n        }\n\n      case 'VariableDeclarator':\n        {\n          var init = node.init;\n\n          if (init === null) {\n            return false;\n          }\n\n          var name = node.id.name;\n\n          if (!isComponentishName(name)) {\n            return false;\n          }\n\n          switch (init.type) {\n            case 'ArrowFunctionExpression':\n            case 'FunctionExpression':\n              // Likely component definitions.\n              break;\n\n            case 'CallExpression':\n              {\n                // Maybe a HOC.\n                // Try to determine if this is some form of import.\n                var callee = init.callee;\n                var calleeType = callee.type;\n\n                if (calleeType === 'Import') {\n                  return false;\n                } else if (calleeType === 'Identifier') {\n                  if (callee.name.indexOf('require') === 0) {\n                    return false;\n                  } else if (callee.name.indexOf('import') === 0) {\n                    return false;\n                  } // Neither require nor import. Might be a HOC.\n                  // Pass through.\n\n                }\n\n                break;\n              }\n\n            case 'TaggedTemplateExpression':\n              // Maybe something like styled.div`...`\n              break;\n\n            default:\n              return false;\n          }\n\n          var initPath = path.get('init');\n\n          var _foundInside = findInnerComponents(inferredName, initPath, callback);\n\n          if (_foundInside) {\n            return true;\n          } // See if this identifier is used in JSX. Then it's a component.\n\n\n          var binding = path.scope.getBinding(name);\n\n          if (binding === undefined) {\n            return;\n          }\n\n          var isLikelyUsedAsType = false;\n          var referencePaths = binding.referencePaths;\n\n          for (var i = 0; i < referencePaths.length; i++) {\n            var ref = referencePaths[i];\n\n            if (ref.node && ref.node.type !== 'JSXIdentifier' && ref.node.type !== 'Identifier') {\n              continue;\n            }\n\n            var refParent = ref.parent;\n\n            if (refParent.type === 'JSXOpeningElement') {\n              isLikelyUsedAsType = true;\n            } else if (refParent.type === 'CallExpression') {\n              var _callee = refParent.callee;\n              var fnName = void 0;\n\n              switch (_callee.type) {\n                case 'Identifier':\n                  fnName = _callee.name;\n                  break;\n\n                case 'MemberExpression':\n                  fnName = _callee.property.name;\n                  break;\n              }\n\n              switch (fnName) {\n                case 'createElement':\n                case 'jsx':\n                case 'jsxDEV':\n                case 'jsxs':\n                  isLikelyUsedAsType = true;\n                  break;\n              }\n            }\n\n            if (isLikelyUsedAsType) {\n              // const X = ... + later <X />\n              callback(inferredName, init, initPath);\n              return true;\n            }\n          }\n        }\n    }\n\n    return false;\n  }\n\n  function isBuiltinHook(hookName) {\n    switch (hookName) {\n      case 'useState':\n      case 'React.useState':\n      case 'useReducer':\n      case 'React.useReducer':\n      case 'useEffect':\n      case 'React.useEffect':\n      case 'useLayoutEffect':\n      case 'React.useLayoutEffect':\n      case 'useMemo':\n      case 'React.useMemo':\n      case 'useCallback':\n      case 'React.useCallback':\n      case 'useRef':\n      case 'React.useRef':\n      case 'useContext':\n      case 'React.useContext':\n      case 'useImperativeHandle':\n      case 'React.useImperativeHandle':\n      case 'useDebugValue':\n      case 'React.useDebugValue':\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  function getHookCallsSignature(functionNode) {\n    var fnHookCalls = hookCalls.get(functionNode);\n\n    if (fnHookCalls === undefined) {\n      return null;\n    }\n\n    return {\n      key: fnHookCalls.map(function (call) {\n        return call.name + '{' + call.key + '}';\n      }).join('\\n'),\n      customHooks: fnHookCalls.filter(function (call) {\n        return !isBuiltinHook(call.name);\n      }).map(function (call) {\n        return t.cloneDeep(call.callee);\n      })\n    };\n  }\n\n  var hasForceResetCommentByFile = new WeakMap(); // We let user do /* @refresh reset */ to reset state in the whole file.\n\n  function hasForceResetComment(path) {\n    var file = path.hub.file;\n    var hasForceReset = hasForceResetCommentByFile.get(file);\n\n    if (hasForceReset !== undefined) {\n      return hasForceReset;\n    }\n\n    hasForceReset = false;\n    var comments = file.ast.comments;\n\n    for (var i = 0; i < comments.length; i++) {\n      var cmt = comments[i];\n\n      if (cmt.value.indexOf('@refresh reset') !== -1) {\n        hasForceReset = true;\n        break;\n      }\n    }\n\n    hasForceResetCommentByFile.set(file, hasForceReset);\n    return hasForceReset;\n  }\n\n  function createArgumentsForSignature(node, signature, scope) {\n    var key = signature.key,\n        customHooks = signature.customHooks;\n    var forceReset = hasForceResetComment(scope.path);\n    var customHooksInScope = [];\n    customHooks.forEach(function (callee) {\n      // Check if a corresponding binding exists where we emit the signature.\n      var bindingName;\n\n      switch (callee.type) {\n        case 'MemberExpression':\n          if (callee.object.type === 'Identifier') {\n            bindingName = callee.object.name;\n          }\n\n          break;\n\n        case 'Identifier':\n          bindingName = callee.name;\n          break;\n      }\n\n      if (scope.hasBinding(bindingName)) {\n        customHooksInScope.push(callee);\n      } else {\n        // We don't have anything to put in the array because Hook is out of scope.\n        // Since it could potentially have been edited, remount the component.\n        forceReset = true;\n      }\n    });\n    var finalKey = key;\n\n    if (typeof require === 'function' && !opts.emitFullSignatures) {\n      // Prefer to hash when we can (e.g. outside of ASTExplorer).\n      // This makes it deterministically compact, even if there's\n      // e.g. a useState initializer with some code inside.\n      // We also need it for www that has transforms like cx()\n      // that don't understand if something is part of a string.\n      finalKey = require('crypto').createHash('sha1').update(key).digest('base64');\n    }\n\n    var args = [node, t.stringLiteral(finalKey)];\n\n    if (forceReset || customHooksInScope.length > 0) {\n      args.push(t.booleanLiteral(forceReset));\n    }\n\n    if (customHooksInScope.length > 0) {\n      args.push( // TODO: We could use an arrow here to be more compact.\n      // However, don't do it until AMA can run them natively.\n      t.functionExpression(null, [], t.blockStatement([t.returnStatement(t.arrayExpression(customHooksInScope))])));\n    }\n\n    return args;\n  }\n\n  function findHOCCallPathsAbove(path) {\n    var calls = [];\n\n    while (true) {\n      if (!path) {\n        return calls;\n      }\n\n      var parentPath = path.parentPath;\n\n      if (!parentPath) {\n        return calls;\n      }\n\n      if ( // hoc(_c = function() { })\n      parentPath.node.type === 'AssignmentExpression' && path.node === parentPath.node.right) {\n        // Ignore registrations.\n        path = parentPath;\n        continue;\n      }\n\n      if ( // hoc1(hoc2(...))\n      parentPath.node.type === 'CallExpression' && path.node !== parentPath.node.callee) {\n        calls.push(parentPath);\n        path = parentPath;\n        continue;\n      }\n\n      return calls; // Stop at other types.\n    }\n  }\n\n  var seenForRegistration = new WeakSet();\n  var seenForSignature = new WeakSet();\n  var seenForOutro = new WeakSet();\n  var hookCalls = new WeakMap();\n  var HookCallsVisitor = {\n    CallExpression: function (path) {\n      var node = path.node;\n      var callee = node.callee; // Note: this visitor MUST NOT mutate the tree in any way.\n      // It runs early in a separate traversal and should be very fast.\n\n      var name = null;\n\n      switch (callee.type) {\n        case 'Identifier':\n          name = callee.name;\n          break;\n\n        case 'MemberExpression':\n          name = callee.property.name;\n          break;\n      }\n\n      if (name === null || !/^use[A-Z]/.test(name)) {\n        return;\n      }\n\n      var fnScope = path.scope.getFunctionParent();\n\n      if (fnScope === null) {\n        return;\n      } // This is a Hook call. Record it.\n\n\n      var fnNode = fnScope.block;\n\n      if (!hookCalls.has(fnNode)) {\n        hookCalls.set(fnNode, []);\n      }\n\n      var hookCallsForFn = hookCalls.get(fnNode);\n      var key = '';\n\n      if (path.parent.type === 'VariableDeclarator') {\n        // TODO: if there is no LHS, consider some other heuristic.\n        key = path.parentPath.get('id').getSource();\n      } // Some built-in Hooks reset on edits to arguments.\n\n\n      var args = path.get('arguments');\n\n      if (name === 'useState' && args.length > 0) {\n        // useState second argument is initial state.\n        key += '(' + args[0].getSource() + ')';\n      } else if (name === 'useReducer' && args.length > 1) {\n        // useReducer second argument is initial state.\n        key += '(' + args[1].getSource() + ')';\n      }\n\n      hookCallsForFn.push({\n        callee: path.node.callee,\n        name: name,\n        key: key\n      });\n    }\n  };\n  return {\n    visitor: {\n      ExportDefaultDeclaration: function (path) {\n        var node = path.node;\n        var decl = node.declaration;\n        var declPath = path.get('declaration');\n\n        if (decl.type !== 'CallExpression') {\n          // For now, we only support possible HOC calls here.\n          // Named function declarations are handled in FunctionDeclaration.\n          // Anonymous direct exports like export default function() {}\n          // are currently ignored.\n          return;\n        } // Make sure we're not mutating the same tree twice.\n        // This can happen if another Babel plugin replaces parents.\n\n\n        if (seenForRegistration.has(node)) {\n          return;\n        }\n\n        seenForRegistration.add(node); // Don't mutate the tree above this point.\n        // This code path handles nested cases like:\n        // export default memo(() => {})\n        // In those cases it is more plausible people will omit names\n        // so they're worth handling despite possible false positives.\n        // More importantly, it handles the named case:\n        // export default memo(function Named() {})\n\n        var inferredName = '%default%';\n        var programPath = path.parentPath;\n        findInnerComponents(inferredName, declPath, function (persistentID, targetExpr, targetPath) {\n          if (targetPath === null) {\n            // For case like:\n            // export default hoc(Foo)\n            // we don't want to wrap Foo inside the call.\n            // Instead we assume it's registered at definition.\n            return;\n          }\n\n          var handle = createRegistration(programPath, persistentID);\n          targetPath.replaceWith(t.assignmentExpression('=', handle, targetExpr));\n        });\n      },\n      FunctionDeclaration: {\n        enter: function (path) {\n          var node = path.node;\n          var programPath;\n          var insertAfterPath;\n          var modulePrefix = '';\n\n          switch (path.parent.type) {\n            case 'Program':\n              insertAfterPath = path;\n              programPath = path.parentPath;\n              break;\n\n            case 'TSModuleBlock':\n              insertAfterPath = path;\n              programPath = insertAfterPath.parentPath.parentPath;\n              break;\n\n            case 'ExportNamedDeclaration':\n              insertAfterPath = path.parentPath;\n              programPath = insertAfterPath.parentPath;\n              break;\n\n            case 'ExportDefaultDeclaration':\n              insertAfterPath = path.parentPath;\n              programPath = insertAfterPath.parentPath;\n              break;\n\n            default:\n              return;\n          } // These types can be nested in typescript namespace\n          // We need to find the export chain\n          // Or return if it stays local\n\n\n          if (path.parent.type === 'TSModuleBlock' || path.parent.type === 'ExportNamedDeclaration') {\n            while (programPath.type !== 'Program') {\n              if (programPath.type === 'TSModuleDeclaration') {\n                if (programPath.parentPath.type !== 'Program' && programPath.parentPath.type !== 'ExportNamedDeclaration') {\n                  return;\n                }\n\n                modulePrefix = programPath.node.id.name + '$' + modulePrefix;\n              }\n\n              programPath = programPath.parentPath;\n            }\n          }\n\n          var id = node.id;\n\n          if (id === null) {\n            // We don't currently handle anonymous default exports.\n            return;\n          }\n\n          var inferredName = id.name;\n\n          if (!isComponentishName(inferredName)) {\n            return;\n          } // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n\n\n          if (seenForRegistration.has(node)) {\n            return;\n          }\n\n          seenForRegistration.add(node); // Don't mutate the tree above this point.\n\n          var innerName = modulePrefix + inferredName; // export function Named() {}\n          // function Named() {}\n\n          findInnerComponents(innerName, path, function (persistentID, targetExpr) {\n            var handle = createRegistration(programPath, persistentID);\n            insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression('=', handle, targetExpr)));\n          });\n        },\n        exit: function (path) {\n          var node = path.node;\n          var id = node.id;\n\n          if (id === null) {\n            return;\n          }\n\n          var signature = getHookCallsSignature(node);\n\n          if (signature === null) {\n            return;\n          } // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n\n\n          if (seenForSignature.has(node)) {\n            return;\n          }\n\n          seenForSignature.add(node); // Don't mutate the tree above this point.\n\n          var sigCallID = path.scope.generateUidIdentifier('_s');\n          path.scope.parent.push({\n            id: sigCallID,\n            init: t.callExpression(refreshSig, [])\n          }); // The signature call is split in two parts. One part is called inside the function.\n          // This is used to signal when first render happens.\n\n          path.get('body').unshiftContainer('body', t.expressionStatement(t.callExpression(sigCallID, []))); // The second call is around the function itself.\n          // This is used to associate a type with a signature.\n          // Unlike with $RefreshReg$, this needs to work for nested\n          // declarations too. So we need to search for a path where\n          // we can insert a statement rather than hard coding it.\n\n          var insertAfterPath = null;\n          path.find(function (p) {\n            if (p.parentPath.isBlock()) {\n              insertAfterPath = p;\n              return true;\n            }\n          });\n\n          if (insertAfterPath === null) {\n            return;\n          }\n\n          insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(id, signature, insertAfterPath.scope))));\n        }\n      },\n      'ArrowFunctionExpression|FunctionExpression': {\n        exit: function (path) {\n          var node = path.node;\n          var signature = getHookCallsSignature(node);\n\n          if (signature === null) {\n            return;\n          } // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n\n\n          if (seenForSignature.has(node)) {\n            return;\n          }\n\n          seenForSignature.add(node); // Don't mutate the tree above this point.\n\n          var sigCallID = path.scope.generateUidIdentifier('_s');\n          path.scope.parent.push({\n            id: sigCallID,\n            init: t.callExpression(refreshSig, [])\n          }); // The signature call is split in two parts. One part is called inside the function.\n          // This is used to signal when first render happens.\n\n          if (path.node.body.type !== 'BlockStatement') {\n            path.node.body = t.blockStatement([t.returnStatement(path.node.body)]);\n          }\n\n          path.get('body').unshiftContainer('body', t.expressionStatement(t.callExpression(sigCallID, []))); // The second call is around the function itself.\n          // This is used to associate a type with a signature.\n\n          if (path.parent.type === 'VariableDeclarator') {\n            var insertAfterPath = null;\n            path.find(function (p) {\n              if (p.parentPath.isBlock()) {\n                insertAfterPath = p;\n                return true;\n              }\n            });\n\n            if (insertAfterPath === null) {\n              return;\n            } // Special case when a function would get an inferred name:\n            // let Foo = () => {}\n            // let Foo = function() {}\n            // We'll add signature it on next line so that\n            // we don't mess up the inferred 'Foo' function name.\n\n\n            insertAfterPath.insertAfter(t.expressionStatement(t.callExpression(sigCallID, createArgumentsForSignature(path.parent.id, signature, insertAfterPath.scope)))); // Result: let Foo = () => {}; __signature(Foo, ...);\n          } else {\n            // let Foo = hoc(() => {})\n            var paths = [path].concat(findHOCCallPathsAbove(path));\n            paths.forEach(function (p) {\n              p.replaceWith(t.callExpression(sigCallID, createArgumentsForSignature(p.node, signature, p.scope)));\n            }); // Result: let Foo = __signature(hoc(__signature(() => {}, ...)), ...)\n          }\n        }\n      },\n      VariableDeclaration: function (path) {\n        var node = path.node;\n        var programPath;\n        var insertAfterPath;\n        var modulePrefix = '';\n\n        switch (path.parent.type) {\n          case 'Program':\n            insertAfterPath = path;\n            programPath = path.parentPath;\n            break;\n\n          case 'TSModuleBlock':\n            insertAfterPath = path;\n            programPath = insertAfterPath.parentPath.parentPath;\n            break;\n\n          case 'ExportNamedDeclaration':\n            insertAfterPath = path.parentPath;\n            programPath = insertAfterPath.parentPath;\n            break;\n\n          case 'ExportDefaultDeclaration':\n            insertAfterPath = path.parentPath;\n            programPath = insertAfterPath.parentPath;\n            break;\n\n          default:\n            return;\n        } // These types can be nested in typescript namespace\n        // We need to find the export chain\n        // Or return if it stays local\n\n\n        if (path.parent.type === 'TSModuleBlock' || path.parent.type === 'ExportNamedDeclaration') {\n          while (programPath.type !== 'Program') {\n            if (programPath.type === 'TSModuleDeclaration') {\n              if (programPath.parentPath.type !== 'Program' && programPath.parentPath.type !== 'ExportNamedDeclaration') {\n                return;\n              }\n\n              modulePrefix = programPath.node.id.name + '$' + modulePrefix;\n            }\n\n            programPath = programPath.parentPath;\n          }\n        } // Make sure we're not mutating the same tree twice.\n        // This can happen if another Babel plugin replaces parents.\n\n\n        if (seenForRegistration.has(node)) {\n          return;\n        }\n\n        seenForRegistration.add(node); // Don't mutate the tree above this point.\n\n        var declPaths = path.get('declarations');\n\n        if (declPaths.length !== 1) {\n          return;\n        }\n\n        var declPath = declPaths[0];\n        var inferredName = declPath.node.id.name;\n        var innerName = modulePrefix + inferredName;\n        findInnerComponents(innerName, declPath, function (persistentID, targetExpr, targetPath) {\n          if (targetPath === null) {\n            // For case like:\n            // export const Something = hoc(Foo)\n            // we don't want to wrap Foo inside the call.\n            // Instead we assume it's registered at definition.\n            return;\n          }\n\n          var handle = createRegistration(programPath, persistentID);\n\n          if (targetPath.parent.type === 'VariableDeclarator') {\n            // Special case when a variable would get an inferred name:\n            // let Foo = () => {}\n            // let Foo = function() {}\n            // let Foo = styled.div``;\n            // We'll register it on next line so that\n            // we don't mess up the inferred 'Foo' function name.\n            // (eg: with @babel/plugin-transform-react-display-name or\n            // babel-plugin-styled-components)\n            insertAfterPath.insertAfter(t.expressionStatement(t.assignmentExpression('=', handle, declPath.node.id))); // Result: let Foo = () => {}; _c1 = Foo;\n          } else {\n            // let Foo = hoc(() => {})\n            targetPath.replaceWith(t.assignmentExpression('=', handle, targetExpr)); // Result: let Foo = hoc(_c1 = () => {})\n          }\n        });\n      },\n      Program: {\n        enter: function (path) {\n          // This is a separate early visitor because we need to collect Hook calls\n          // and \"const [foo, setFoo] = ...\" signatures before the destructuring\n          // transform mangles them. This extra traversal is not ideal for perf,\n          // but it's the best we can do until we stop transpiling destructuring.\n          path.traverse(HookCallsVisitor);\n        },\n        exit: function (path) {\n          var registrations = registrationsByProgramPath.get(path);\n\n          if (registrations === undefined) {\n            return;\n          } // Make sure we're not mutating the same tree twice.\n          // This can happen if another Babel plugin replaces parents.\n\n\n          var node = path.node;\n\n          if (seenForOutro.has(node)) {\n            return;\n          }\n\n          seenForOutro.add(node); // Don't mutate the tree above this point.\n\n          registrationsByProgramPath.delete(path);\n          var declarators = [];\n          path.pushContainer('body', t.variableDeclaration('var', declarators));\n          registrations.forEach(function (_ref) {\n            var handle = _ref.handle,\n                persistentID = _ref.persistentID;\n            path.pushContainer('body', t.expressionStatement(t.callExpression(refreshReg, [handle, t.stringLiteral(persistentID)])));\n            declarators.push(t.variableDeclarator(handle));\n          });\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = ReactFreshBabelPlugin;\n  })();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}