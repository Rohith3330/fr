{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = auto;\n\nvar _once = require('./internal/once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _onlyOnce = require('./internal/onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _promiseCallback = require('./internal/promiseCallback.js');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n * @example\n *\n * //Using Callbacks\n * async.auto({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     if (err) {\n *         console.log('err = ', err);\n *     }\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * });\n *\n * //Using Promises\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }).then(results => {\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * }).catch(err => {\n *     console.log('err = ', err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.auto({\n *             get_data: function(callback) {\n *                 // async code to get some data\n *                 callback(null, 'data', 'converted to array');\n *             },\n *             make_folder: function(callback) {\n *                 // async code to create a directory to store a file in\n *                 // this is run at the same time as getting the data\n *                 callback(null, 'folder');\n *             },\n *             write_file: ['get_data', 'make_folder', function(results, callback) {\n *                 // once there is some data and the directory exists,\n *                 // write the data to a file in the directory\n *                 callback(null, 'filename');\n *             }],\n *             email_link: ['write_file', function(results, callback) {\n *                 // once the file is written let's email a link to it...\n *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *             }]\n *         });\n *         console.log('results = ', results);\n *         // results = {\n *         //     get_data: ['data', 'converted to array']\n *         //     make_folder; 'folder',\n *         //     write_file: 'filename'\n *         //     email_link: { file: 'filename', email: 'user@example.com' }\n *         // }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\n\n\nfunction auto(tasks, concurrency, callback) {\n  if (typeof concurrency !== 'number') {\n    // concurrency is optional, shift the args.\n    callback = concurrency;\n    concurrency = null;\n  }\n\n  callback = (0, _once2.default)(callback || (0, _promiseCallback.promiseCallback)());\n  var numTasks = Object.keys(tasks).length;\n\n  if (!numTasks) {\n    return callback(null);\n  }\n\n  if (!concurrency) {\n    concurrency = numTasks;\n  }\n\n  var results = {};\n  var runningTasks = 0;\n  var canceled = false;\n  var hasError = false;\n  var listeners = Object.create(null);\n  var readyTasks = []; // for cycle detection:\n\n  var readyToCheck = []; // tasks that have been identified as reachable\n  // without the possibility of returning to an ancestor task\n\n  var uncheckedDependencies = {};\n  Object.keys(tasks).forEach(key => {\n    var task = tasks[key];\n\n    if (!Array.isArray(task)) {\n      // no dependencies\n      enqueueTask(key, [task]);\n      readyToCheck.push(key);\n      return;\n    }\n\n    var dependencies = task.slice(0, task.length - 1);\n    var remainingDependencies = dependencies.length;\n\n    if (remainingDependencies === 0) {\n      enqueueTask(key, task);\n      readyToCheck.push(key);\n      return;\n    }\n\n    uncheckedDependencies[key] = remainingDependencies;\n    dependencies.forEach(dependencyName => {\n      if (!tasks[dependencyName]) {\n        throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies.join(', '));\n      }\n\n      addListener(dependencyName, () => {\n        remainingDependencies--;\n\n        if (remainingDependencies === 0) {\n          enqueueTask(key, task);\n        }\n      });\n    });\n  });\n  checkForDeadlocks();\n  processQueue();\n\n  function enqueueTask(key, task) {\n    readyTasks.push(() => runTask(key, task));\n  }\n\n  function processQueue() {\n    if (canceled) return;\n\n    if (readyTasks.length === 0 && runningTasks === 0) {\n      return callback(null, results);\n    }\n\n    while (readyTasks.length && runningTasks < concurrency) {\n      var run = readyTasks.shift();\n      run();\n    }\n  }\n\n  function addListener(taskName, fn) {\n    var taskListeners = listeners[taskName];\n\n    if (!taskListeners) {\n      taskListeners = listeners[taskName] = [];\n    }\n\n    taskListeners.push(fn);\n  }\n\n  function taskComplete(taskName) {\n    var taskListeners = listeners[taskName] || [];\n    taskListeners.forEach(fn => fn());\n    processQueue();\n  }\n\n  function runTask(key, task) {\n    if (hasError) return;\n    var taskCallback = (0, _onlyOnce2.default)(function (err) {\n      for (var _len = arguments.length, result = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        result[_key - 1] = arguments[_key];\n      }\n\n      runningTasks--;\n\n      if (err === false) {\n        canceled = true;\n        return;\n      }\n\n      if (result.length < 2) {\n        [result] = result;\n      }\n\n      if (err) {\n        var safeResults = {};\n        Object.keys(results).forEach(rkey => {\n          safeResults[rkey] = results[rkey];\n        });\n        safeResults[key] = result;\n        hasError = true;\n        listeners = Object.create(null);\n        if (canceled) return;\n        callback(err, safeResults);\n      } else {\n        results[key] = result;\n        taskComplete(key);\n      }\n    });\n    runningTasks++;\n    var taskFn = (0, _wrapAsync2.default)(task[task.length - 1]);\n\n    if (task.length > 1) {\n      taskFn(results, taskCallback);\n    } else {\n      taskFn(taskCallback);\n    }\n  }\n\n  function checkForDeadlocks() {\n    // Kahn's algorithm\n    // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n    // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n    var currentTask;\n    var counter = 0;\n\n    while (readyToCheck.length) {\n      currentTask = readyToCheck.pop();\n      counter++;\n      getDependents(currentTask).forEach(dependent => {\n        if (--uncheckedDependencies[dependent] === 0) {\n          readyToCheck.push(dependent);\n        }\n      });\n    }\n\n    if (counter !== numTasks) {\n      throw new Error('async.auto cannot execute tasks due to a recursive dependency');\n    }\n  }\n\n  function getDependents(taskName) {\n    var result = [];\n    Object.keys(tasks).forEach(key => {\n      const task = tasks[key];\n\n      if (Array.isArray(task) && task.indexOf(taskName) >= 0) {\n        result.push(key);\n      }\n    });\n    return result;\n  }\n\n  return callback[_promiseCallback.PROMISE_SYMBOL];\n}\n\nmodule.exports = exports['default'];","map":{"version":3,"names":["Object","defineProperty","exports","value","default","auto","_once","require","_once2","_interopRequireDefault","_onlyOnce","_onlyOnce2","_wrapAsync","_wrapAsync2","_promiseCallback","obj","__esModule","tasks","concurrency","callback","promiseCallback","numTasks","keys","length","results","runningTasks","canceled","hasError","listeners","create","readyTasks","readyToCheck","uncheckedDependencies","forEach","key","task","Array","isArray","enqueueTask","push","dependencies","slice","remainingDependencies","dependencyName","Error","join","addListener","checkForDeadlocks","processQueue","runTask","run","shift","taskName","fn","taskListeners","taskComplete","taskCallback","err","result","safeResults","rkey","taskFn","currentTask","counter","pop","getDependents","dependent","indexOf","PROMISE_SYMBOL","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/async/auto.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = auto;\n\nvar _once = require('./internal/once.js');\n\nvar _once2 = _interopRequireDefault(_once);\n\nvar _onlyOnce = require('./internal/onlyOnce.js');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nvar _promiseCallback = require('./internal/promiseCallback.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n * @example\n *\n * //Using Callbacks\n * async.auto({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     if (err) {\n *         console.log('err = ', err);\n *     }\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * });\n *\n * //Using Promises\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }).then(results => {\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * }).catch(err => {\n *     console.log('err = ', err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.auto({\n *             get_data: function(callback) {\n *                 // async code to get some data\n *                 callback(null, 'data', 'converted to array');\n *             },\n *             make_folder: function(callback) {\n *                 // async code to create a directory to store a file in\n *                 // this is run at the same time as getting the data\n *                 callback(null, 'folder');\n *             },\n *             write_file: ['get_data', 'make_folder', function(results, callback) {\n *                 // once there is some data and the directory exists,\n *                 // write the data to a file in the directory\n *                 callback(null, 'filename');\n *             }],\n *             email_link: ['write_file', function(results, callback) {\n *                 // once the file is written let's email a link to it...\n *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *             }]\n *         });\n *         console.log('results = ', results);\n *         // results = {\n *         //     get_data: ['data', 'converted to array']\n *         //     make_folder; 'folder',\n *         //     write_file: 'filename'\n *         //     email_link: { file: 'filename', email: 'user@example.com' }\n *         // }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n */\nfunction auto(tasks, concurrency, callback) {\n    if (typeof concurrency !== 'number') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = (0, _once2.default)(callback || (0, _promiseCallback.promiseCallback)());\n    var numTasks = Object.keys(tasks).length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var canceled = false;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    Object.keys(tasks).forEach(key => {\n        var task = tasks[key];\n        if (!Array.isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        dependencies.forEach(dependencyName => {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key + '` has a non-existent dependency `' + dependencyName + '` in ' + dependencies.join(', '));\n            }\n            addListener(dependencyName, () => {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(() => runTask(key, task));\n    }\n\n    function processQueue() {\n        if (canceled) return;\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while (readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        taskListeners.forEach(fn => fn());\n        processQueue();\n    }\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = (0, _onlyOnce2.default)((err, ...result) => {\n            runningTasks--;\n            if (err === false) {\n                canceled = true;\n                return;\n            }\n            if (result.length < 2) {\n                [result] = result;\n            }\n            if (err) {\n                var safeResults = {};\n                Object.keys(results).forEach(rkey => {\n                    safeResults[rkey] = results[rkey];\n                });\n                safeResults[key] = result;\n                hasError = true;\n                listeners = Object.create(null);\n                if (canceled) return;\n                callback(err, safeResults);\n            } else {\n                results[key] = result;\n                taskComplete(key);\n            }\n        });\n\n        runningTasks++;\n        var taskFn = (0, _wrapAsync2.default)(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            getDependents(currentTask).forEach(dependent => {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error('async.auto cannot execute tasks due to a recursive dependency');\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        Object.keys(tasks).forEach(key => {\n            const task = tasks[key];\n            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n\n    return callback[_promiseCallback.PROMISE_SYMBOL];\n}\nmodule.exports = exports['default'];"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EACzCC,KAAK,EAAE;AADkC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,IAAlB;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,oBAAD,CAAnB;;AAEA,IAAIC,MAAM,GAAGC,sBAAsB,CAACH,KAAD,CAAnC;;AAEA,IAAII,SAAS,GAAGH,OAAO,CAAC,wBAAD,CAAvB;;AAEA,IAAII,UAAU,GAAGF,sBAAsB,CAACC,SAAD,CAAvC;;AAEA,IAAIE,UAAU,GAAGL,OAAO,CAAC,yBAAD,CAAxB;;AAEA,IAAIM,WAAW,GAAGJ,sBAAsB,CAACG,UAAD,CAAxC;;AAEA,IAAIE,gBAAgB,GAAGP,OAAO,CAAC,+BAAD,CAA9B;;AAEA,SAASE,sBAAT,CAAgCM,GAAhC,EAAqC;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;IAAEX,OAAO,EAAEW;EAAX,CAArC;AAAwD;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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"},"metadata":{},"sourceType":"script"}