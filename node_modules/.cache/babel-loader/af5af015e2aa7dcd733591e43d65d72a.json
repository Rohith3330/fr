{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar visitors = require(\"./visitors\");\n\nexports.visitors = visitors;\n\nvar _t = require(\"@babel/types\");\n\nvar cache = require(\"./cache\");\n\nvar _traverseNode = require(\"./traverse-node\");\n\nvar _path = require(\"./path\");\n\nvar _scope = require(\"./scope\");\n\nvar _hub = require(\"./hub\");\n\nconst {\n  VISITOR_KEYS,\n  removeProperties,\n  traverseFast\n} = _t;\n\nfunction traverse(parent) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let scope = arguments.length > 2 ? arguments[2] : undefined;\n  let state = arguments.length > 3 ? arguments[3] : undefined;\n  let parentPath = arguments.length > 4 ? arguments[4] : undefined;\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, path, skipKeys) {\n  (0, _traverseNode.traverseNode)(node, opts, scope, state, path, skipKeys);\n};\n\ntraverse.clearNode = function (node, opts) {\n  removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","map":{"version":3,"mappings":"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","names":["VISITOR_KEYS","removeProperties","traverseFast","traverse","parent","opts","scope","state","parentPath","noScope","type","Error","visitors","explode","verify","cheap","node","enter","path","skipKeys","clearNode","cache","delete","tree","hasDenylistedType","has","stop","hasType","denylistTypes","includes","denylist"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\index.ts"],"sourcesContent":["import * as visitors from \"./visitors\";\nimport {\n  VISITOR_KEYS,\n  removeProperties,\n  type RemovePropertiesOptions,\n  traverseFast,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport * as cache from \"./cache\";\nimport type NodePath from \"./path\";\nimport type { default as Scope, Binding } from \"./scope\";\nimport type { Visitor } from \"./types\";\nimport { traverseNode } from \"./traverse-node\";\n\nexport type { Visitor, Binding };\nexport { default as NodePath } from \"./path\";\nexport { default as Scope } from \"./scope\";\nexport { default as Hub } from \"./hub\";\nexport type { HubInterface } from \"./hub\";\n\nexport { visitors };\n\nexport type TraverseOptions<S = t.Node> = {\n  scope?: Scope;\n  noScope?: boolean;\n  denylist?: string[];\n} & Visitor<S>;\n\nfunction traverse<S>(\n  parent: t.Node,\n  opts: TraverseOptions<S>,\n  scope: Scope | undefined,\n  state: S,\n  parentPath?: NodePath,\n): void;\n\nfunction traverse(\n  parent: t.Node,\n  opts: TraverseOptions,\n  scope?: Scope,\n  state?: any,\n  parentPath?: NodePath,\n): void;\n\nfunction traverse<Options extends TraverseOptions>(\n  parent: t.Node,\n  // @ts-expect-error provide {} as default value for Options\n  opts: Options = {},\n  scope?: Scope,\n  state?: any,\n  parentPath?: NodePath,\n) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\n        \"You must pass a scope and parentPath unless traversing a Program/File. \" +\n          `Instead of that you tried to traverse a ${parent.type} node without ` +\n          \"passing scope and parentPath.\",\n      );\n    }\n  }\n\n  if (!VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts as Visitor);\n\n  traverseNode(parent, opts, scope, state, parentPath);\n}\n\nexport default traverse;\n\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node: t.Node, enter: (node: t.Node) => void) {\n  return traverseFast(node, enter);\n};\n\ntraverse.node = function (\n  node: t.Node,\n  opts: TraverseOptions,\n  scope?: Scope,\n  state?: any,\n  path?: NodePath,\n  skipKeys?: Record<string, boolean>,\n) {\n  traverseNode(node, opts, scope, state, path, skipKeys);\n  // traverse.node always returns undefined\n};\n\ntraverse.clearNode = function (node: t.Node, opts?: RemovePropertiesOptions) {\n  removeProperties(node, opts);\n\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (\n  tree: t.Node,\n  opts?: RemovePropertiesOptions,\n) {\n  traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\ntype HasDenylistedTypeState = {\n  has: boolean;\n  type: t.Node[\"type\"];\n};\nfunction hasDenylistedType(path: NodePath, state: HasDenylistedTypeState) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (\n  tree: t.Node,\n  type: t.Node[\"type\"],\n  denylistTypes?: Array<string>,\n): boolean {\n  // the node we're searching in is denylisted\n  if (denylistTypes?.includes(tree.type)) return false;\n\n  // the type we're looking for is the same as the passed node\n  if (tree.type === type) return true;\n\n  const state: HasDenylistedTypeState = {\n    has: false,\n    type: type,\n  };\n\n  traverse(\n    tree,\n    {\n      noScope: true,\n      denylist: denylistTypes,\n      enter: hasDenylistedType,\n    },\n    null,\n    state,\n  );\n\n  return state.has;\n};\n\ntraverse.cache = cache;\n"]},"metadata":{},"sourceType":"script"}