{"ast":null,"code":"/* eslint-env mocha */\nimport assert from 'assert';\nimport { getOpeningElement, setParserName, describeIfNotBabylon } from '../helper';\nimport elementType from '../../src/elementType';\ndescribe('elementType tests', () => {\n  beforeEach(() => {\n    setParserName('babel');\n  });\n  it('should export a function', () => {\n    const expected = 'function';\n    const actual = typeof elementType;\n    assert.equal(actual, expected);\n  });\n  it('should throw an error if the argument is missing', () => {\n    assert.throws(() => {\n      elementType();\n    }, Error);\n  });\n  it('should throw an error if the argument not a JSX node', () => {\n    assert.throws(() => {\n      elementType({\n        a: 'foo'\n      });\n    }, Error);\n  });\n  it('should return the correct type of the DOM element given its node object', () => {\n    const code = '<div />';\n    const node = getOpeningElement(code);\n    const expected = 'div';\n    const actual = elementType(node);\n    assert.equal(actual, expected);\n  });\n  it('should return the correct type of the custom element given its node object', () => {\n    const code = '<Slider />';\n    const node = getOpeningElement(code);\n    const expected = 'Slider';\n    const actual = elementType(node);\n    assert.equal(actual, expected);\n  });\n  it('should return the correct type of the custom object element given its node object', () => {\n    const code = '<UX.Slider />';\n    const node = getOpeningElement(code);\n    const expected = 'UX.Slider';\n    const actual = elementType(node);\n    assert.equal(actual, expected);\n  });\n  it('should return the correct type of the namespaced element given its node object', () => {\n    const code = '<UX:Slider />';\n    const node = getOpeningElement(code);\n    const expected = 'UX:Slider';\n    const actual = elementType(node);\n    assert.equal(actual, expected);\n  });\n  it('should return the correct type of the multiple custom object element given its node object', () => {\n    const code = '<UX.Slider.Blue.Light />';\n    const node = getOpeningElement(code);\n    const expected = 'UX.Slider.Blue.Light';\n    const actual = elementType(node);\n    assert.equal(actual, expected);\n  });\n  it('should return this.Component when given its node object', () => {\n    const code = '<this.Component />';\n    const node = getOpeningElement(code);\n    const expected = 'this.Component';\n    const actual = elementType(node);\n    assert.equal(actual, expected);\n  });\n  describeIfNotBabylon('fragments', () => {\n    it('should work with fragments', () => {\n      const code = '<>foo</>';\n      const node = getOpeningElement(code);\n      const expected = '<>';\n      const actual = elementType(node);\n      assert.equal(actual, expected);\n    });\n  });\n});","map":{"version":3,"names":["assert","getOpeningElement","setParserName","describeIfNotBabylon","elementType","describe","beforeEach","it","expected","actual","equal","throws","Error","a","code","node"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jsx-ast-utils/__tests__/src/elementType-test.js"],"sourcesContent":["/* eslint-env mocha */\nimport assert from 'assert';\nimport { getOpeningElement, setParserName, describeIfNotBabylon } from '../helper';\nimport elementType from '../../src/elementType';\n\ndescribe('elementType tests', () => {\n  beforeEach(() => {\n    setParserName('babel');\n  });\n  it('should export a function', () => {\n    const expected = 'function';\n    const actual = typeof elementType;\n\n    assert.equal(actual, expected);\n  });\n\n  it('should throw an error if the argument is missing', () => {\n    assert.throws(() => { elementType(); }, Error);\n  });\n\n  it('should throw an error if the argument not a JSX node', () => {\n    assert.throws(() => { elementType({ a: 'foo' }); }, Error);\n  });\n\n  it('should return the correct type of the DOM element given its node object', () => {\n    const code = '<div />';\n    const node = getOpeningElement(code);\n\n    const expected = 'div';\n    const actual = elementType(node);\n\n    assert.equal(actual, expected);\n  });\n\n  it('should return the correct type of the custom element given its node object', () => {\n    const code = '<Slider />';\n    const node = getOpeningElement(code);\n\n    const expected = 'Slider';\n    const actual = elementType(node);\n\n    assert.equal(actual, expected);\n  });\n\n  it('should return the correct type of the custom object element given its node object', () => {\n    const code = '<UX.Slider />';\n    const node = getOpeningElement(code);\n\n    const expected = 'UX.Slider';\n    const actual = elementType(node);\n\n    assert.equal(actual, expected);\n  });\n\n  it('should return the correct type of the namespaced element given its node object', () => {\n    const code = '<UX:Slider />';\n    const node = getOpeningElement(code);\n\n    const expected = 'UX:Slider';\n    const actual = elementType(node);\n\n    assert.equal(actual, expected);\n  });\n\n  it('should return the correct type of the multiple custom object element given its node object', () => {\n    const code = '<UX.Slider.Blue.Light />';\n    const node = getOpeningElement(code);\n\n    const expected = 'UX.Slider.Blue.Light';\n    const actual = elementType(node);\n\n    assert.equal(actual, expected);\n  });\n\n  it('should return this.Component when given its node object', () => {\n    const code = '<this.Component />';\n    const node = getOpeningElement(code);\n\n    const expected = 'this.Component';\n    const actual = elementType(node);\n\n    assert.equal(actual, expected);\n  });\n\n  describeIfNotBabylon('fragments', () => {\n    it('should work with fragments', () => {\n      const code = '<>foo</>';\n      const node = getOpeningElement(code);\n\n      const expected = '<>';\n      const actual = elementType(node);\n\n      assert.equal(actual, expected);\n    });\n  });\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}