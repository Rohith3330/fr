{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: () => collapseDuplicateDeclarations\n});\n\nfunction collapseDuplicateDeclarations() {\n  return root => {\n    root.walkRules(node => {\n      let seen = new Map();\n      let droppable = new Set([]);\n      let byProperty = new Map();\n      node.walkDecls(decl => {\n        // This could happen if we have nested selectors. In that case the\n        // parent will loop over all its declarations but also the declarations\n        // of nested rules. With this we ensure that we are shallowly checking\n        // declarations.\n        if (decl.parent !== node) {\n          return;\n        }\n\n        if (seen.has(decl.prop)) {\n          // Exact same value as what we have seen so far\n          if (seen.get(decl.prop).value === decl.value) {\n            // Keep the last one, drop the one we've seen so far\n            droppable.add(seen.get(decl.prop)); // Override the existing one with the new value. This is necessary\n            // so that if we happen to have more than one declaration with the\n            // same value, that we keep removing the previous one. Otherwise we\n            // will only remove the *first* one.\n\n            seen.set(decl.prop, decl);\n            return;\n          } // Not the same value, so we need to check if we can merge it so\n          // let's collect it first.\n\n\n          if (!byProperty.has(decl.prop)) {\n            byProperty.set(decl.prop, new Set());\n          }\n\n          byProperty.get(decl.prop).add(seen.get(decl.prop));\n          byProperty.get(decl.prop).add(decl);\n        }\n\n        seen.set(decl.prop, decl);\n      }); // Drop all the duplicate declarations with the exact same value we've\n      // already seen so far.\n\n      for (let decl of droppable) {\n        decl.remove();\n      } // Analyze the declarations based on its unit, drop all the declarations\n      // with the same unit but the last one in the list.\n\n\n      for (let declarations of byProperty.values()) {\n        let byUnit = new Map();\n\n        for (let decl1 of declarations) {\n          let unit = resolveUnit(decl1.value);\n\n          if (unit === null) {\n            continue;\n          }\n\n          if (!byUnit.has(unit)) {\n            byUnit.set(unit, new Set());\n          }\n\n          byUnit.get(unit).add(decl1);\n        }\n\n        for (let declarations1 of byUnit.values()) {\n          // Get all but the last one\n          let removableDeclarations = Array.from(declarations1).slice(0, -1);\n\n          for (let decl2 of removableDeclarations) {\n            decl2.remove();\n          }\n        }\n      }\n    });\n  };\n}\n\nlet UNITLESS_NUMBER = Symbol(\"unitless-number\");\n\nfunction resolveUnit(input) {\n  let result = /^-?\\d*.?\\d+([\\w%]+)?$/g.exec(input);\n\n  if (result) {\n    var ref;\n    return (ref = result[1]) !== null && ref !== void 0 ? ref : UNITLESS_NUMBER;\n  }\n\n  return null;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","collapseDuplicateDeclarations","root","walkRules","node","seen","Map","droppable","Set","byProperty","walkDecls","decl","parent","has","prop","add","set","remove","declarations","values","byUnit","decl1","unit","resolveUnit","declarations1","removableDeclarations","Array","from","slice","decl2","UNITLESS_NUMBER","Symbol","input","result","exec","ref"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/lib/lib/collapseDuplicateDeclarations.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: ()=>collapseDuplicateDeclarations\n});\nfunction collapseDuplicateDeclarations() {\n    return (root)=>{\n        root.walkRules((node)=>{\n            let seen = new Map();\n            let droppable = new Set([]);\n            let byProperty = new Map();\n            node.walkDecls((decl)=>{\n                // This could happen if we have nested selectors. In that case the\n                // parent will loop over all its declarations but also the declarations\n                // of nested rules. With this we ensure that we are shallowly checking\n                // declarations.\n                if (decl.parent !== node) {\n                    return;\n                }\n                if (seen.has(decl.prop)) {\n                    // Exact same value as what we have seen so far\n                    if (seen.get(decl.prop).value === decl.value) {\n                        // Keep the last one, drop the one we've seen so far\n                        droppable.add(seen.get(decl.prop));\n                        // Override the existing one with the new value. This is necessary\n                        // so that if we happen to have more than one declaration with the\n                        // same value, that we keep removing the previous one. Otherwise we\n                        // will only remove the *first* one.\n                        seen.set(decl.prop, decl);\n                        return;\n                    }\n                    // Not the same value, so we need to check if we can merge it so\n                    // let's collect it first.\n                    if (!byProperty.has(decl.prop)) {\n                        byProperty.set(decl.prop, new Set());\n                    }\n                    byProperty.get(decl.prop).add(seen.get(decl.prop));\n                    byProperty.get(decl.prop).add(decl);\n                }\n                seen.set(decl.prop, decl);\n            });\n            // Drop all the duplicate declarations with the exact same value we've\n            // already seen so far.\n            for (let decl of droppable){\n                decl.remove();\n            }\n            // Analyze the declarations based on its unit, drop all the declarations\n            // with the same unit but the last one in the list.\n            for (let declarations of byProperty.values()){\n                let byUnit = new Map();\n                for (let decl1 of declarations){\n                    let unit = resolveUnit(decl1.value);\n                    if (unit === null) {\n                        continue;\n                    }\n                    if (!byUnit.has(unit)) {\n                        byUnit.set(unit, new Set());\n                    }\n                    byUnit.get(unit).add(decl1);\n                }\n                for (let declarations1 of byUnit.values()){\n                    // Get all but the last one\n                    let removableDeclarations = Array.from(declarations1).slice(0, -1);\n                    for (let decl2 of removableDeclarations){\n                        decl2.remove();\n                    }\n                }\n            }\n        });\n    };\n}\nlet UNITLESS_NUMBER = Symbol(\"unitless-number\");\nfunction resolveUnit(input) {\n    let result = /^-?\\d*.?\\d+([\\w%]+)?$/g.exec(input);\n    if (result) {\n        var ref;\n        return (ref = result[1]) !== null && ref !== void 0 ? ref : UNITLESS_NUMBER;\n    }\n    return null;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}