{"ast":null,"code":"/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  getStringIfConstant\n} = require(\"eslint-utils\");\n\nconst {\n  RegExpValidator,\n  RegExpParser,\n  visitRegExpAST\n} = require(\"regexpp\");\n\nconst {\n  isCombiningCharacter,\n  isEmojiModifier,\n  isRegionalIndicatorSymbol,\n  isSurrogatePair\n} = require(\"./utils/unicode\");\n\nconst astUtils = require(\"./utils/ast-utils.js\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst REGEXPP_LATEST_ECMA_VERSION = 2022;\n/**\n * Iterate character sequences of a given nodes.\n *\n * CharacterClassRange syntax can steal a part of character sequence,\n * so this function reverts CharacterClassRange syntax and restore the sequence.\n * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.\n * @returns {IterableIterator<number[]>} The list of character sequences.\n */\n\nfunction* iterateCharacterSequence(nodes) {\n  let seq = [];\n\n  for (const node of nodes) {\n    switch (node.type) {\n      case \"Character\":\n        seq.push(node.value);\n        break;\n\n      case \"CharacterClassRange\":\n        seq.push(node.min.value);\n        yield seq;\n        seq = [node.max.value];\n        break;\n\n      case \"CharacterSet\":\n        if (seq.length > 0) {\n          yield seq;\n          seq = [];\n        }\n\n        break;\n      // no default\n    }\n  }\n\n  if (seq.length > 0) {\n    yield seq;\n  }\n}\n\nconst hasCharacterSequence = {\n  surrogatePairWithoutUFlag(chars) {\n    return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));\n  },\n\n  combiningClass(chars) {\n    return chars.some((c, i) => i !== 0 && isCombiningCharacter(c) && !isCombiningCharacter(chars[i - 1]));\n  },\n\n  emojiModifier(chars) {\n    return chars.some((c, i) => i !== 0 && isEmojiModifier(c) && !isEmojiModifier(chars[i - 1]));\n  },\n\n  regionalIndicatorSymbol(chars) {\n    return chars.some((c, i) => i !== 0 && isRegionalIndicatorSymbol(c) && isRegionalIndicatorSymbol(chars[i - 1]));\n  },\n\n  zwj(chars) {\n    const lastIndex = chars.length - 1;\n    return chars.some((c, i) => i !== 0 && i !== lastIndex && c === 0x200d && chars[i - 1] !== 0x200d && chars[i + 1] !== 0x200d);\n  }\n\n};\nconst kinds = Object.keys(hasCharacterSequence); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow characters which are made with multiple code points in character class syntax\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-misleading-character-class\"\n    },\n    hasSuggestions: true,\n    schema: [],\n    messages: {\n      surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n      combiningClass: \"Unexpected combined character in character class.\",\n      emojiModifier: \"Unexpected modified Emoji in character class.\",\n      regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n      zwj: \"Unexpected joined character sequence in character class.\",\n      suggestUnicodeFlag: \"Add unicode 'u' flag to regex.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const parser = new RegExpParser();\n    /**\n     * Verify a given regular expression.\n     * @param {Node} node The node to report.\n     * @param {string} pattern The regular expression pattern to verify.\n     * @param {string} flags The flags of the regular expression.\n     * @param {Function} unicodeFixer Fixer for missing \"u\" flag.\n     * @returns {void}\n     */\n\n    function verify(node, pattern, flags, unicodeFixer) {\n      let patternNode;\n\n      try {\n        patternNode = parser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n      } catch {\n        // Ignore regular expressions with syntax errors\n        return;\n      }\n\n      const foundKinds = new Set();\n      visitRegExpAST(patternNode, {\n        onCharacterClassEnter(ccNode) {\n          for (const chars of iterateCharacterSequence(ccNode.elements)) {\n            for (const kind of kinds) {\n              if (hasCharacterSequence[kind](chars)) {\n                foundKinds.add(kind);\n              }\n            }\n          }\n        }\n\n      });\n\n      for (const kind of foundKinds) {\n        let suggest;\n\n        if (kind === \"surrogatePairWithoutUFlag\") {\n          suggest = [{\n            messageId: \"suggestUnicodeFlag\",\n            fix: unicodeFixer\n          }];\n        }\n\n        context.report({\n          node,\n          messageId: kind,\n          suggest\n        });\n      }\n    }\n    /**\n     * Checks if the given regular expression pattern would be valid with the `u` flag.\n     * @param {string} pattern The regular expression pattern to verify.\n     * @returns {boolean} `true` if the pattern would be valid with the `u` flag.\n     * `false` if the pattern would be invalid with the `u` flag or the configured\n     * ecmaVersion doesn't support the `u` flag.\n     */\n\n\n    function isValidWithUnicodeFlag(pattern) {\n      const {\n        ecmaVersion\n      } = context.parserOptions; // ecmaVersion is unknown or it doesn't support the 'u' flag\n\n      if (typeof ecmaVersion !== \"number\" || ecmaVersion <= 5) {\n        return false;\n      }\n\n      const validator = new RegExpValidator({\n        ecmaVersion: Math.min(ecmaVersion + 2009, REGEXPP_LATEST_ECMA_VERSION)\n      });\n\n      try {\n        validator.validatePattern(pattern, void 0, void 0,\n        /* uFlag = */\n        true);\n      } catch {\n        return false;\n      }\n\n      return true;\n    }\n\n    return {\n      \"Literal[regex]\"(node) {\n        verify(node, node.regex.pattern, node.regex.flags, fixer => {\n          if (!isValidWithUnicodeFlag(node.regex.pattern)) {\n            return null;\n          }\n\n          return fixer.insertTextAfter(node, \"u\");\n        });\n      },\n\n      \"Program\"() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        /*\n         * Iterate calls of RegExp.\n         * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\n         *       `const {RegExp: a} = window; new a()`, etc...\n         */\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences({\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        })) {\n          const [patternNode, flagsNode] = node.arguments;\n          const pattern = getStringIfConstant(patternNode, scope);\n          const flags = getStringIfConstant(flagsNode, scope);\n\n          if (typeof pattern === \"string\") {\n            verify(node, pattern, flags || \"\", fixer => {\n              if (!isValidWithUnicodeFlag(pattern)) {\n                return null;\n              }\n\n              if (node.arguments.length === 1) {\n                const penultimateToken = sourceCode.getLastToken(node, {\n                  skip: 1\n                }); // skip closing parenthesis\n\n                return fixer.insertTextAfter(penultimateToken, astUtils.isCommaToken(penultimateToken) ? ' \"u\",' : ', \"u\"');\n              }\n\n              if (flagsNode.type === \"Literal\" && typeof flagsNode.value === \"string\" || flagsNode.type === \"TemplateLiteral\") {\n                const range = [flagsNode.range[0], flagsNode.range[1] - 1];\n                return fixer.insertTextAfterRange(range, \"u\");\n              }\n\n              return null;\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["CALL","CONSTRUCT","ReferenceTracker","getStringIfConstant","require","RegExpValidator","RegExpParser","visitRegExpAST","isCombiningCharacter","isEmojiModifier","isRegionalIndicatorSymbol","isSurrogatePair","astUtils","REGEXPP_LATEST_ECMA_VERSION","iterateCharacterSequence","nodes","seq","node","type","push","value","min","max","length","hasCharacterSequence","surrogatePairWithoutUFlag","chars","some","c","i","combiningClass","emojiModifier","regionalIndicatorSymbol","zwj","lastIndex","kinds","Object","keys","module","exports","meta","docs","description","recommended","url","hasSuggestions","schema","messages","suggestUnicodeFlag","create","context","sourceCode","getSourceCode","parser","verify","pattern","flags","unicodeFixer","patternNode","parsePattern","includes","foundKinds","Set","onCharacterClassEnter","ccNode","elements","kind","add","suggest","messageId","fix","report","isValidWithUnicodeFlag","ecmaVersion","parserOptions","validator","Math","validatePattern","regex","fixer","insertTextAfter","scope","getScope","tracker","iterateGlobalReferences","RegExp","flagsNode","arguments","penultimateToken","getLastToken","skip","isCommaToken","range","insertTextAfterRange"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/no-misleading-character-class.js"],"sourcesContent":["/**\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\"use strict\";\n\nconst { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require(\"eslint-utils\");\nconst { RegExpValidator, RegExpParser, visitRegExpAST } = require(\"regexpp\");\nconst { isCombiningCharacter, isEmojiModifier, isRegionalIndicatorSymbol, isSurrogatePair } = require(\"./utils/unicode\");\nconst astUtils = require(\"./utils/ast-utils.js\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst REGEXPP_LATEST_ECMA_VERSION = 2022;\n\n/**\n * Iterate character sequences of a given nodes.\n *\n * CharacterClassRange syntax can steal a part of character sequence,\n * so this function reverts CharacterClassRange syntax and restore the sequence.\n * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.\n * @returns {IterableIterator<number[]>} The list of character sequences.\n */\nfunction *iterateCharacterSequence(nodes) {\n    let seq = [];\n\n    for (const node of nodes) {\n        switch (node.type) {\n            case \"Character\":\n                seq.push(node.value);\n                break;\n\n            case \"CharacterClassRange\":\n                seq.push(node.min.value);\n                yield seq;\n                seq = [node.max.value];\n                break;\n\n            case \"CharacterSet\":\n                if (seq.length > 0) {\n                    yield seq;\n                    seq = [];\n                }\n                break;\n\n            // no default\n        }\n    }\n\n    if (seq.length > 0) {\n        yield seq;\n    }\n}\n\nconst hasCharacterSequence = {\n    surrogatePairWithoutUFlag(chars) {\n        return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));\n    },\n\n    combiningClass(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isCombiningCharacter(c) &&\n            !isCombiningCharacter(chars[i - 1])\n        ));\n    },\n\n    emojiModifier(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isEmojiModifier(c) &&\n            !isEmojiModifier(chars[i - 1])\n        ));\n    },\n\n    regionalIndicatorSymbol(chars) {\n        return chars.some((c, i) => (\n            i !== 0 &&\n            isRegionalIndicatorSymbol(c) &&\n            isRegionalIndicatorSymbol(chars[i - 1])\n        ));\n    },\n\n    zwj(chars) {\n        const lastIndex = chars.length - 1;\n\n        return chars.some((c, i) => (\n            i !== 0 &&\n            i !== lastIndex &&\n            c === 0x200d &&\n            chars[i - 1] !== 0x200d &&\n            chars[i + 1] !== 0x200d\n        ));\n    }\n};\n\nconst kinds = Object.keys(hasCharacterSequence);\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow characters which are made with multiple code points in character class syntax\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-misleading-character-class\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [],\n\n        messages: {\n            surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n            combiningClass: \"Unexpected combined character in character class.\",\n            emojiModifier: \"Unexpected modified Emoji in character class.\",\n            regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n            zwj: \"Unexpected joined character sequence in character class.\",\n            suggestUnicodeFlag: \"Add unicode 'u' flag to regex.\"\n        }\n    },\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const parser = new RegExpParser();\n\n        /**\n         * Verify a given regular expression.\n         * @param {Node} node The node to report.\n         * @param {string} pattern The regular expression pattern to verify.\n         * @param {string} flags The flags of the regular expression.\n         * @param {Function} unicodeFixer Fixer for missing \"u\" flag.\n         * @returns {void}\n         */\n        function verify(node, pattern, flags, unicodeFixer) {\n            let patternNode;\n\n            try {\n                patternNode = parser.parsePattern(\n                    pattern,\n                    0,\n                    pattern.length,\n                    flags.includes(\"u\")\n                );\n            } catch {\n\n                // Ignore regular expressions with syntax errors\n                return;\n            }\n\n            const foundKinds = new Set();\n\n            visitRegExpAST(patternNode, {\n                onCharacterClassEnter(ccNode) {\n                    for (const chars of iterateCharacterSequence(ccNode.elements)) {\n                        for (const kind of kinds) {\n                            if (hasCharacterSequence[kind](chars)) {\n                                foundKinds.add(kind);\n                            }\n                        }\n                    }\n                }\n            });\n\n            for (const kind of foundKinds) {\n                let suggest;\n\n                if (kind === \"surrogatePairWithoutUFlag\") {\n                    suggest = [{\n                        messageId: \"suggestUnicodeFlag\",\n                        fix: unicodeFixer\n                    }];\n                }\n\n                context.report({\n                    node,\n                    messageId: kind,\n                    suggest\n                });\n            }\n        }\n\n        /**\n         * Checks if the given regular expression pattern would be valid with the `u` flag.\n         * @param {string} pattern The regular expression pattern to verify.\n         * @returns {boolean} `true` if the pattern would be valid with the `u` flag.\n         * `false` if the pattern would be invalid with the `u` flag or the configured\n         * ecmaVersion doesn't support the `u` flag.\n         */\n        function isValidWithUnicodeFlag(pattern) {\n            const { ecmaVersion } = context.parserOptions;\n\n            // ecmaVersion is unknown or it doesn't support the 'u' flag\n            if (typeof ecmaVersion !== \"number\" || ecmaVersion <= 5) {\n                return false;\n            }\n\n            const validator = new RegExpValidator({\n                ecmaVersion: Math.min(ecmaVersion + 2009, REGEXPP_LATEST_ECMA_VERSION)\n            });\n\n            try {\n                validator.validatePattern(pattern, void 0, void 0, /* uFlag = */ true);\n            } catch {\n                return false;\n            }\n\n            return true;\n        }\n\n        return {\n            \"Literal[regex]\"(node) {\n                verify(node, node.regex.pattern, node.regex.flags, fixer => {\n                    if (!isValidWithUnicodeFlag(node.regex.pattern)) {\n                        return null;\n                    }\n\n                    return fixer.insertTextAfter(node, \"u\");\n                });\n            },\n            \"Program\"() {\n                const scope = context.getScope();\n                const tracker = new ReferenceTracker(scope);\n\n                /*\n                 * Iterate calls of RegExp.\n                 * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\n                 *       `const {RegExp: a} = window; new a()`, etc...\n                 */\n                for (const { node } of tracker.iterateGlobalReferences({\n                    RegExp: { [CALL]: true, [CONSTRUCT]: true }\n                })) {\n                    const [patternNode, flagsNode] = node.arguments;\n                    const pattern = getStringIfConstant(patternNode, scope);\n                    const flags = getStringIfConstant(flagsNode, scope);\n\n                    if (typeof pattern === \"string\") {\n                        verify(node, pattern, flags || \"\", fixer => {\n\n                            if (!isValidWithUnicodeFlag(pattern)) {\n                                return null;\n                            }\n\n                            if (node.arguments.length === 1) {\n                                const penultimateToken = sourceCode.getLastToken(node, { skip: 1 }); // skip closing parenthesis\n\n                                return fixer.insertTextAfter(\n                                    penultimateToken,\n                                    astUtils.isCommaToken(penultimateToken)\n                                        ? ' \"u\",'\n                                        : ', \"u\"'\n                                );\n                            }\n\n                            if ((flagsNode.type === \"Literal\" && typeof flagsNode.value === \"string\") || flagsNode.type === \"TemplateLiteral\") {\n                                const range = [flagsNode.range[0], flagsNode.range[1] - 1];\n\n                                return fixer.insertTextAfterRange(range, \"u\");\n                            }\n\n                            return null;\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}