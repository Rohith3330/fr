{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _RuleTester_options;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RuleTester = exports.noFormat = void 0;\n\nconst path = __importStar(require(\"path\"));\n\nconst TSESLint = __importStar(require(\"../ts-eslint\"));\n\nconst parser = '@typescript-eslint/parser';\n\nclass RuleTester extends TSESLint.RuleTester {\n  // as of eslint 6 you have to provide an absolute path to the parser\n  // but that's not as clean to type, this saves us trying to manually enforce\n  // that contributors require.resolve everything\n  constructor(options) {\n    var _a, _b;\n\n    super(Object.assign(Object.assign({}, options), {\n      parserOptions: Object.assign(Object.assign({}, options.parserOptions), {\n        warnOnUnsupportedTypeScriptVersion: (_b = (_a = options.parserOptions) === null || _a === void 0 ? void 0 : _a.warnOnUnsupportedTypeScriptVersion) !== null && _b !== void 0 ? _b : false\n      }),\n      parser: require.resolve(options.parser)\n    }));\n\n    _RuleTester_options.set(this, void 0);\n\n    __classPrivateFieldSet(this, _RuleTester_options, options, \"f\"); // make sure that the parser doesn't hold onto file handles between tests\n    // on linux (i.e. our CI env), there can be very a limited number of watch handles available\n\n\n    if (typeof afterAll !== 'undefined') {\n      afterAll(() => {\n        try {\n          // instead of creating a hard dependency, just use a soft require\n          // a bit weird, but if they're using this tooling, it'll be installed\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n          require(parser).clearCaches();\n        } catch (_a) {// ignored\n        }\n      });\n    }\n  }\n\n  getFilename(options) {\n    var _a;\n\n    if (options) {\n      const filename = `file.ts${((_a = options.ecmaFeatures) === null || _a === void 0 ? void 0 : _a.jsx) ? 'x' : ''}`;\n\n      if (options.project) {\n        return path.join(options.tsconfigRootDir != null ? options.tsconfigRootDir : process.cwd(), filename);\n      }\n\n      return filename;\n    } else if (__classPrivateFieldGet(this, _RuleTester_options, \"f\").parserOptions) {\n      return this.getFilename(__classPrivateFieldGet(this, _RuleTester_options, \"f\").parserOptions);\n    }\n\n    return 'file.ts';\n  } // as of eslint 6 you have to provide an absolute path to the parser\n  // If you don't do that at the test level, the test will fail somewhat cryptically...\n  // This is a lot more explicit\n\n\n  run(name, rule, testsReadonly) {\n    const errorMessage = `Do not set the parser at the test level unless you want to use a parser other than ${parser}`;\n    const tests = Object.assign({}, testsReadonly); // standardize the valid tests as objects\n\n    tests.valid = tests.valid.map(test => {\n      if (typeof test === 'string') {\n        return {\n          code: test\n        };\n      }\n\n      return test;\n    });\n    tests.valid = tests.valid.map(test => {\n      if (typeof test !== 'string') {\n        if (test.parser === parser) {\n          throw new Error(errorMessage);\n        }\n\n        if (!test.filename) {\n          return Object.assign(Object.assign({}, test), {\n            filename: this.getFilename(test.parserOptions)\n          });\n        }\n      }\n\n      return test;\n    });\n    tests.invalid = tests.invalid.map(test => {\n      if (test.parser === parser) {\n        throw new Error(errorMessage);\n      }\n\n      if (!test.filename) {\n        return Object.assign(Object.assign({}, test), {\n          filename: this.getFilename(test.parserOptions)\n        });\n      }\n\n      return test;\n    });\n    super.run(name, rule, tests);\n  }\n\n}\n\nexports.RuleTester = RuleTester;\n_RuleTester_options = new WeakMap();\n/**\n * Simple no-op tag to mark code samples as \"should not format with prettier\"\n *   for the internal/plugin-test-formatting lint rule\n */\n\nfunction noFormat(strings) {\n  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    keys[_key - 1] = arguments[_key];\n  }\n\n  const lastIndex = strings.length - 1;\n  return strings.slice(0, lastIndex).reduce((p, s, i) => p + s + keys[i], '') + strings[lastIndex];\n}\n\nexports.noFormat = noFormat;","map":{"version":3,"mappings":"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","names":["parser","RuleTester","TSESLint","constructor","options","Object","parserOptions","warnOnUnsupportedTypeScriptVersion","_a","_b","require","resolve","_RuleTester_options","__classPrivateFieldSet","afterAll","clearCaches","getFilename","filename","ecmaFeatures","jsx","project","path","join","tsconfigRootDir","process","cwd","__classPrivateFieldGet","run","name","rule","testsReadonly","errorMessage","tests","valid","map","test","code","Error","invalid","exports","noFormat","strings","keys","lastIndex","length","slice","reduce","p","s","i"],"sources":["../../src/eslint-utils/RuleTester.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}