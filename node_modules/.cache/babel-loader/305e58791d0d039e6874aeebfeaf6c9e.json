{"ast":null,"code":"/**\n * @fileoverview Check if tag attributes to have non-valid value\n * @author Sebastian Malton\n */\n'use strict';\n\nconst matchAll = require('string.prototype.matchall');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst rel = new Map([['alternate', new Set(['link', 'area', 'a'])], ['apple-touch-icon', new Set(['link'])], ['author', new Set(['link', 'area', 'a'])], ['bookmark', new Set(['area', 'a'])], ['canonical', new Set(['link'])], ['dns-prefetch', new Set(['link'])], ['external', new Set(['area', 'a', 'form'])], ['help', new Set(['link', 'area', 'a', 'form'])], ['icon', new Set(['link'])], ['license', new Set(['link', 'area', 'a', 'form'])], ['manifest', new Set(['link'])], ['mask-icon', new Set(['link'])], ['modulepreload', new Set(['link'])], ['next', new Set(['link', 'area', 'a', 'form'])], ['nofollow', new Set(['area', 'a', 'form'])], ['noopener', new Set(['area', 'a', 'form'])], ['noreferrer', new Set(['area', 'a', 'form'])], ['opener', new Set(['area', 'a', 'form'])], ['pingback', new Set(['link'])], ['preconnect', new Set(['link'])], ['prefetch', new Set(['link'])], ['preload', new Set(['link'])], ['prerender', new Set(['link'])], ['prev', new Set(['link', 'area', 'a', 'form'])], ['search', new Set(['link', 'area', 'a', 'form'])], ['shortcut', new Set(['link'])], // generally allowed but needs pair with \"icon\"\n['shortcut\\u0020icon', new Set(['link'])], ['stylesheet', new Set(['link'])], ['tag', new Set(['area', 'a'])]]);\nconst pairs = new Map([['shortcut', new Set(['icon'])]]);\n/**\n * Map between attributes and a mapping between valid values and a set of tags they are valid on\n * @type {Map<string, Map<string, Set<string>>>}\n */\n\nconst VALID_VALUES = new Map([['rel', rel]]);\n/**\n * Map between attributes and a mapping between pair-values and a set of values they are valid with\n * @type {Map<string, Map<string, Set<string>>>}\n */\n\nconst VALID_PAIR_VALUES = new Map([['rel', pairs]]);\n/**\n * The set of all possible HTML elements. Used for skipping custom types\n * @type {Set<string>}\n */\n\nconst HTML_ELEMENTS = new Set(['a', 'abbr', 'acronym', 'address', 'applet', 'area', 'article', 'aside', 'audio', 'b', 'base', 'basefont', 'bdi', 'bdo', 'bgsound', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'image', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'math', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'nobr', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'plaintext', 'portal', 'pre', 'progress', 'q', 'rb', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'section', 'select', 'shadow', 'slot', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'svg', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr', 'xmp']);\n/**\n* Map between attributes and set of tags that the attribute is valid on\n* @type {Map<string, Set<string>>}\n*/\n\nconst COMPONENT_ATTRIBUTE_MAP = new Map();\nCOMPONENT_ATTRIBUTE_MAP.set('rel', new Set(['link', 'a', 'area', 'form']));\nconst messages = {\n  emptyIsMeaningless: 'An empty “{{attributeName}}” attribute is meaningless.',\n  neverValid: '“{{reportingValue}}” is never a valid “{{attributeName}}” attribute value.',\n  noEmpty: 'An empty “{{attributeName}}” attribute is meaningless.',\n  noMethod: 'The ”{{attributeName}}“ attribute cannot be a method.',\n  notAlone: '“{{reportingValue}}” must be directly followed by “{{missingValue}}”.',\n  notPaired: '“{{reportingValue}}” can not be directly followed by “{{secondValue}}” without “{{missingValue}}”.',\n  notValidFor: '“{{reportingValue}}” is not a valid “{{attributeName}}” attribute value for <{{elementName}}>.',\n  onlyMeaningfulFor: 'The ”{{attributeName}}“ attribute only has meaning on the tags: {{tagNames}}',\n  onlyStrings: '“{{attributeName}}” attribute only supports strings.',\n  spaceDelimited: '”{{attributeName}}“ attribute values should be space delimited.'\n};\n\nfunction splitIntoRangedParts(node, regex) {\n  const valueRangeStart = node.range[0] + 1; // the plus one is for the initial quote\n\n  return Array.from(matchAll(node.value, regex), match => {\n    const start = match.index + valueRangeStart;\n    const end = start + match[0].length;\n    return {\n      reportingValue: `${match[1]}`,\n      value: match[1],\n      range: [start, end]\n    };\n  });\n}\n\nfunction checkLiteralValueNode(context, attributeName, node, parentNode, parentNodeName) {\n  if (typeof node.value !== 'string') {\n    report(context, messages.onlyStrings, 'onlyStrings', {\n      node,\n      data: {\n        attributeName\n      },\n\n      fix(fixer) {\n        return fixer.remove(parentNode);\n      }\n\n    });\n    return;\n  }\n\n  if (!node.value.trim()) {\n    report(context, messages.noEmpty, 'noEmpty', {\n      node,\n      data: {\n        attributeName\n      },\n\n      fix(fixer) {\n        return fixer.remove(parentNode);\n      }\n\n    });\n    return;\n  }\n\n  const singleAttributeParts = splitIntoRangedParts(node, /(\\S+)/g);\n\n  for (const singlePart of singleAttributeParts) {\n    const allowedTags = VALID_VALUES.get(attributeName).get(singlePart.value);\n    const reportingValue = singlePart.reportingValue;\n\n    if (!allowedTags) {\n      report(context, messages.neverValid, 'neverValid', {\n        node,\n        data: {\n          attributeName,\n          reportingValue\n        },\n\n        fix(fixer) {\n          return fixer.removeRange(singlePart.range);\n        }\n\n      });\n    } else if (!allowedTags.has(parentNodeName)) {\n      report(context, messages.notValidFor, 'notValidFor', {\n        node,\n        data: {\n          attributeName,\n          reportingValue,\n          elementName: parentNodeName\n        },\n\n        fix(fixer) {\n          return fixer.removeRange(singlePart.range);\n        }\n\n      });\n    }\n  }\n\n  const allowedPairsForAttribute = VALID_PAIR_VALUES.get(attributeName);\n\n  if (allowedPairsForAttribute) {\n    const pairAttributeParts = splitIntoRangedParts(node, /(?=(\\b\\S+\\s*\\S+))/g);\n\n    for (const pairPart of pairAttributeParts) {\n      for (const allowedPair of allowedPairsForAttribute) {\n        const pairing = allowedPair[0];\n        const siblings = allowedPair[1];\n        const attributes = pairPart.reportingValue.split('\\u0020');\n        const firstValue = attributes[0];\n        const secondValue = attributes[1];\n\n        if (firstValue === pairing) {\n          const lastValue = attributes[attributes.length - 1]; // in case of multiple white spaces\n\n          if (!siblings.has(lastValue)) {\n            const message = secondValue ? messages.notPaired : messages.notAlone;\n            const messageId = secondValue ? 'notPaired' : 'notAlone';\n            report(context, message, messageId, {\n              node,\n              data: {\n                reportingValue: firstValue,\n                secondValue,\n                missingValue: Array.from(siblings).join(', ')\n              }\n            });\n          }\n        }\n      }\n    }\n  }\n\n  const whitespaceParts = splitIntoRangedParts(node, /(\\s+)/g);\n\n  for (const whitespacePart of whitespaceParts) {\n    if (whitespacePart.range[0] === node.range[0] + 1 || whitespacePart.range[1] === node.range[1] - 1) {\n      report(context, messages.spaceDelimited, 'spaceDelimited', {\n        node,\n        data: {\n          attributeName\n        },\n\n        fix(fixer) {\n          return fixer.removeRange(whitespacePart.range);\n        }\n\n      });\n    } else if (whitespacePart.value !== '\\u0020') {\n      report(context, messages.spaceDelimited, 'spaceDelimited', {\n        node,\n        data: {\n          attributeName\n        },\n\n        fix(fixer) {\n          return fixer.replaceTextRange(whitespacePart.range, '\\u0020');\n        }\n\n      });\n    }\n  }\n}\n\nconst DEFAULT_ATTRIBUTES = ['rel'];\n\nfunction checkAttribute(context, node) {\n  const attribute = node.name.name;\n\n  function fix(fixer) {\n    return fixer.remove(node);\n  }\n\n  const parentNodeName = node.parent.name.name;\n\n  if (!COMPONENT_ATTRIBUTE_MAP.has(attribute) || !COMPONENT_ATTRIBUTE_MAP.get(attribute).has(parentNodeName)) {\n    const tagNames = Array.from(COMPONENT_ATTRIBUTE_MAP.get(attribute).values(), tagName => `\"<${tagName}>\"`).join(', ');\n    report(context, messages.onlyMeaningfulFor, 'onlyMeaningfulFor', {\n      node,\n      data: {\n        attributeName: attribute,\n        tagNames\n      },\n      fix\n    });\n    return;\n  }\n\n  if (!node.value) {\n    report(context, messages.emptyIsMeaningless, 'emptyIsMeaningless', {\n      node,\n      data: {\n        attributeName: attribute\n      },\n      fix\n    });\n    return;\n  }\n\n  if (node.value.type === 'Literal') {\n    return checkLiteralValueNode(context, attribute, node.value, node, parentNodeName);\n  }\n\n  if (node.value.expression.type === 'Literal') {\n    return checkLiteralValueNode(context, attribute, node.value.expression, node, parentNodeName);\n  }\n\n  if (node.value.type !== 'JSXExpressionContainer') {\n    return;\n  }\n\n  if (node.value.expression.type === 'ObjectExpression') {\n    report(context, messages.onlyStrings, 'onlyStrings', {\n      node,\n      data: {\n        attributeName: attribute\n      },\n      fix\n    });\n    return;\n  }\n\n  if (node.value.expression.type === 'Identifier' && node.value.expression.name === 'undefined') {\n    report(context, messages.onlyStrings, 'onlyStrings', {\n      node,\n      data: {\n        attributeName: attribute\n      },\n      fix\n    });\n  }\n}\n\nfunction isValidCreateElement(node) {\n  return node.callee && node.callee.type === 'MemberExpression' && node.callee.object.name === 'React' && node.callee.property.name === 'createElement' && node.arguments.length > 0;\n}\n\nfunction checkPropValidValue(context, node, value, attribute) {\n  const validTags = VALID_VALUES.get(attribute);\n\n  if (value.type !== 'Literal') {\n    return; // cannot check non-literals\n  }\n\n  const validTagSet = validTags.get(value.value);\n\n  if (!validTagSet) {\n    report(context, messages.neverValid, 'neverValid', {\n      node: value,\n      data: {\n        attributeName: attribute,\n        reportingValue: value.value\n      }\n    });\n    return;\n  }\n\n  if (!validTagSet.has(node.arguments[0].value)) {\n    report(context, messages.notValidFor, 'notValidFor', {\n      node: value,\n      data: {\n        attributeName: attribute,\n        reportingValue: value.raw,\n        elementName: node.arguments[0].value\n      }\n    });\n  }\n}\n/**\n *\n * @param {*} context\n * @param {*} node\n * @param {string} attribute\n */\n\n\nfunction checkCreateProps(context, node, attribute) {\n  const propsArg = node.arguments[1];\n\n  if (!propsArg || propsArg.type !== 'ObjectExpression') {\n    return; // can't check variables, computed, or shorthands\n  }\n\n  for (const prop of propsArg.properties) {\n    if (!prop.key || prop.key.type !== 'Identifier') {\n      // eslint-disable-next-line no-continue\n      continue; // cannot check computed keys\n    }\n\n    if (prop.key.name !== attribute) {\n      // eslint-disable-next-line no-continue\n      continue; // ignore not this attribute\n    }\n\n    if (!COMPONENT_ATTRIBUTE_MAP.get(attribute).has(node.arguments[0].value)) {\n      const tagNames = Array.from(COMPONENT_ATTRIBUTE_MAP.get(attribute).values(), tagName => `\"<${tagName}>\"`).join(', ');\n      report(context, messages.onlyMeaningfulFor, 'onlyMeaningfulFor', {\n        node,\n        data: {\n          attributeName: attribute,\n          tagNames\n        }\n      }); // eslint-disable-next-line no-continue\n\n      continue;\n    }\n\n    if (prop.method) {\n      report(context, messages.noMethod, 'noMethod', {\n        node: prop,\n        data: {\n          attributeName: attribute\n        }\n      }); // eslint-disable-next-line no-continue\n\n      continue;\n    }\n\n    if (prop.shorthand || prop.computed) {\n      // eslint-disable-next-line no-continue\n      continue; // cannot check these\n    }\n\n    if (prop.value.type === 'ArrayExpression') {\n      for (const value of prop.value.elements) {\n        checkPropValidValue(context, node, value, attribute);\n      } // eslint-disable-next-line no-continue\n\n\n      continue;\n    }\n\n    checkPropValidValue(context, node, prop.value, attribute);\n  }\n}\n\nmodule.exports = {\n  meta: {\n    fixable: 'code',\n    docs: {\n      description: 'Disallow usage of invalid attributes',\n      category: 'Possible Errors',\n      url: docsUrl('no-invalid-html-attribute')\n    },\n    messages,\n    schema: [{\n      type: 'array',\n      uniqueItems: true,\n      items: {\n        enum: ['rel']\n      }\n    }]\n  },\n\n  create(context) {\n    return {\n      JSXAttribute(node) {\n        const attributes = new Set(context.options[0] || DEFAULT_ATTRIBUTES); // ignore attributes that aren't configured to be checked\n\n        if (!attributes.has(node.name.name)) {\n          return;\n        } // ignore non-HTML elements\n\n\n        if (!HTML_ELEMENTS.has(node.parent.name.name)) {\n          return;\n        }\n\n        checkAttribute(context, node);\n      },\n\n      CallExpression(node) {\n        if (!isValidCreateElement(node)) {\n          return;\n        }\n\n        const elemNameArg = node.arguments[0];\n\n        if (!elemNameArg || elemNameArg.type !== 'Literal') {\n          return; // can only check literals\n        } // ignore non-HTML elements\n\n\n        if (!HTML_ELEMENTS.has(elemNameArg.value)) {\n          return;\n        }\n\n        const attributes = new Set(context.options[0] || DEFAULT_ATTRIBUTES);\n\n        for (const attribute of attributes) {\n          checkCreateProps(context, node, attribute);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["matchAll","require","docsUrl","report","rel","Map","Set","pairs","VALID_VALUES","VALID_PAIR_VALUES","HTML_ELEMENTS","COMPONENT_ATTRIBUTE_MAP","set","messages","emptyIsMeaningless","neverValid","noEmpty","noMethod","notAlone","notPaired","notValidFor","onlyMeaningfulFor","onlyStrings","spaceDelimited","splitIntoRangedParts","node","regex","valueRangeStart","range","Array","from","value","match","start","index","end","length","reportingValue","checkLiteralValueNode","context","attributeName","parentNode","parentNodeName","data","fix","fixer","remove","trim","singleAttributeParts","singlePart","allowedTags","get","removeRange","has","elementName","allowedPairsForAttribute","pairAttributeParts","pairPart","allowedPair","pairing","siblings","attributes","split","firstValue","secondValue","lastValue","message","messageId","missingValue","join","whitespaceParts","whitespacePart","replaceTextRange","DEFAULT_ATTRIBUTES","checkAttribute","attribute","name","parent","tagNames","values","tagName","type","expression","isValidCreateElement","callee","object","property","arguments","checkPropValidValue","validTags","validTagSet","raw","checkCreateProps","propsArg","prop","properties","key","method","shorthand","computed","elements","module","exports","meta","fixable","docs","description","category","url","schema","uniqueItems","items","enum","create","JSXAttribute","options","CallExpression","elemNameArg"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/no-invalid-html-attribute.js"],"sourcesContent":["/**\n * @fileoverview Check if tag attributes to have non-valid value\n * @author Sebastian Malton\n */\n\n'use strict';\n\nconst matchAll = require('string.prototype.matchall');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst rel = new Map([\n  ['alternate', new Set(['link', 'area', 'a'])],\n  ['apple-touch-icon', new Set(['link'])],\n  ['author', new Set(['link', 'area', 'a'])],\n  ['bookmark', new Set(['area', 'a'])],\n  ['canonical', new Set(['link'])],\n  ['dns-prefetch', new Set(['link'])],\n  ['external', new Set(['area', 'a', 'form'])],\n  ['help', new Set(['link', 'area', 'a', 'form'])],\n  ['icon', new Set(['link'])],\n  ['license', new Set(['link', 'area', 'a', 'form'])],\n  ['manifest', new Set(['link'])],\n  ['mask-icon', new Set(['link'])],\n  ['modulepreload', new Set(['link'])],\n  ['next', new Set(['link', 'area', 'a', 'form'])],\n  ['nofollow', new Set(['area', 'a', 'form'])],\n  ['noopener', new Set(['area', 'a', 'form'])],\n  ['noreferrer', new Set(['area', 'a', 'form'])],\n  ['opener', new Set(['area', 'a', 'form'])],\n  ['pingback', new Set(['link'])],\n  ['preconnect', new Set(['link'])],\n  ['prefetch', new Set(['link'])],\n  ['preload', new Set(['link'])],\n  ['prerender', new Set(['link'])],\n  ['prev', new Set(['link', 'area', 'a', 'form'])],\n  ['search', new Set(['link', 'area', 'a', 'form'])],\n  ['shortcut', new Set(['link'])], // generally allowed but needs pair with \"icon\"\n  ['shortcut\\u0020icon', new Set(['link'])],\n  ['stylesheet', new Set(['link'])],\n  ['tag', new Set(['area', 'a'])],\n]);\n\nconst pairs = new Map([\n  ['shortcut', new Set(['icon'])],\n]);\n\n/**\n * Map between attributes and a mapping between valid values and a set of tags they are valid on\n * @type {Map<string, Map<string, Set<string>>>}\n */\nconst VALID_VALUES = new Map([\n  ['rel', rel],\n]);\n\n/**\n * Map between attributes and a mapping between pair-values and a set of values they are valid with\n * @type {Map<string, Map<string, Set<string>>>}\n */\nconst VALID_PAIR_VALUES = new Map([\n  ['rel', pairs],\n]);\n\n/**\n * The set of all possible HTML elements. Used for skipping custom types\n * @type {Set<string>}\n */\nconst HTML_ELEMENTS = new Set([\n  'a',\n  'abbr',\n  'acronym',\n  'address',\n  'applet',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'base',\n  'basefont',\n  'bdi',\n  'bdo',\n  'bgsound',\n  'big',\n  'blink',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'center',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'content',\n  'data',\n  'datalist',\n  'dd',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'em',\n  'embed',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'font',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'iframe',\n  'image',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'keygen',\n  'label',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'map',\n  'mark',\n  'marquee',\n  'math',\n  'menu',\n  'menuitem',\n  'meta',\n  'meter',\n  'nav',\n  'nobr',\n  'noembed',\n  'noframes',\n  'noscript',\n  'object',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'param',\n  'picture',\n  'plaintext',\n  'portal',\n  'pre',\n  'progress',\n  'q',\n  'rb',\n  'rp',\n  'rt',\n  'rtc',\n  'ruby',\n  's',\n  'samp',\n  'script',\n  'section',\n  'select',\n  'shadow',\n  'slot',\n  'small',\n  'source',\n  'spacer',\n  'span',\n  'strike',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'svg',\n  'table',\n  'tbody',\n  'td',\n  'template',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'title',\n  'tr',\n  'track',\n  'tt',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n  'xmp',\n]);\n\n/**\n* Map between attributes and set of tags that the attribute is valid on\n* @type {Map<string, Set<string>>}\n*/\nconst COMPONENT_ATTRIBUTE_MAP = new Map();\nCOMPONENT_ATTRIBUTE_MAP.set('rel', new Set(['link', 'a', 'area', 'form']));\n\nconst messages = {\n  emptyIsMeaningless: 'An empty “{{attributeName}}” attribute is meaningless.',\n  neverValid: '“{{reportingValue}}” is never a valid “{{attributeName}}” attribute value.',\n  noEmpty: 'An empty “{{attributeName}}” attribute is meaningless.',\n  noMethod: 'The ”{{attributeName}}“ attribute cannot be a method.',\n  notAlone: '“{{reportingValue}}” must be directly followed by “{{missingValue}}”.',\n  notPaired: '“{{reportingValue}}” can not be directly followed by “{{secondValue}}” without “{{missingValue}}”.',\n  notValidFor: '“{{reportingValue}}” is not a valid “{{attributeName}}” attribute value for <{{elementName}}>.',\n  onlyMeaningfulFor: 'The ”{{attributeName}}“ attribute only has meaning on the tags: {{tagNames}}',\n  onlyStrings: '“{{attributeName}}” attribute only supports strings.',\n  spaceDelimited: '”{{attributeName}}“ attribute values should be space delimited.',\n};\n\nfunction splitIntoRangedParts(node, regex) {\n  const valueRangeStart = node.range[0] + 1; // the plus one is for the initial quote\n\n  return Array.from(matchAll(node.value, regex), (match) => {\n    const start = match.index + valueRangeStart;\n    const end = start + match[0].length;\n\n    return {\n      reportingValue: `${match[1]}`,\n      value: match[1],\n      range: [start, end],\n    };\n  });\n}\n\nfunction checkLiteralValueNode(context, attributeName, node, parentNode, parentNodeName) {\n  if (typeof node.value !== 'string') {\n    report(context, messages.onlyStrings, 'onlyStrings', {\n      node,\n      data: { attributeName },\n      fix(fixer) {\n        return fixer.remove(parentNode);\n      },\n    });\n    return;\n  }\n\n  if (!node.value.trim()) {\n    report(context, messages.noEmpty, 'noEmpty', {\n      node,\n      data: { attributeName },\n      fix(fixer) {\n        return fixer.remove(parentNode);\n      },\n    });\n    return;\n  }\n\n  const singleAttributeParts = splitIntoRangedParts(node, /(\\S+)/g);\n  for (const singlePart of singleAttributeParts) {\n    const allowedTags = VALID_VALUES.get(attributeName).get(singlePart.value);\n    const reportingValue = singlePart.reportingValue;\n    if (!allowedTags) {\n      report(context, messages.neverValid, 'neverValid', {\n        node,\n        data: {\n          attributeName,\n          reportingValue,\n        },\n        fix(fixer) {\n          return fixer.removeRange(singlePart.range);\n        },\n      });\n    } else if (!allowedTags.has(parentNodeName)) {\n      report(context, messages.notValidFor, 'notValidFor', {\n        node,\n        data: {\n          attributeName,\n          reportingValue,\n          elementName: parentNodeName,\n        },\n        fix(fixer) {\n          return fixer.removeRange(singlePart.range);\n        },\n      });\n    }\n  }\n\n  const allowedPairsForAttribute = VALID_PAIR_VALUES.get(attributeName);\n  if (allowedPairsForAttribute) {\n    const pairAttributeParts = splitIntoRangedParts(node, /(?=(\\b\\S+\\s*\\S+))/g);\n    for (const pairPart of pairAttributeParts) {\n      for (const allowedPair of allowedPairsForAttribute) {\n        const pairing = allowedPair[0];\n        const siblings = allowedPair[1];\n        const attributes = pairPart.reportingValue.split('\\u0020');\n        const firstValue = attributes[0];\n        const secondValue = attributes[1];\n        if (firstValue === pairing) {\n          const lastValue = attributes[attributes.length - 1]; // in case of multiple white spaces\n          if (!siblings.has(lastValue)) {\n            const message = secondValue ? messages.notPaired : messages.notAlone;\n            const messageId = secondValue ? 'notPaired' : 'notAlone';\n            report(context, message, messageId, {\n              node,\n              data: {\n                reportingValue: firstValue,\n                secondValue,\n                missingValue: Array.from(siblings).join(', '),\n              },\n            });\n          }\n        }\n      }\n    }\n  }\n\n  const whitespaceParts = splitIntoRangedParts(node, /(\\s+)/g);\n  for (const whitespacePart of whitespaceParts) {\n    if (whitespacePart.range[0] === (node.range[0] + 1) || whitespacePart.range[1] === (node.range[1] - 1)) {\n      report(context, messages.spaceDelimited, 'spaceDelimited', {\n        node,\n        data: { attributeName },\n        fix(fixer) {\n          return fixer.removeRange(whitespacePart.range);\n        },\n      });\n    } else if (whitespacePart.value !== '\\u0020') {\n      report(context, messages.spaceDelimited, 'spaceDelimited', {\n        node,\n        data: { attributeName },\n        fix(fixer) {\n          return fixer.replaceTextRange(whitespacePart.range, '\\u0020');\n        },\n      });\n    }\n  }\n}\n\nconst DEFAULT_ATTRIBUTES = ['rel'];\n\nfunction checkAttribute(context, node) {\n  const attribute = node.name.name;\n\n  function fix(fixer) {\n    return fixer.remove(node);\n  }\n\n  const parentNodeName = node.parent.name.name;\n  if (!COMPONENT_ATTRIBUTE_MAP.has(attribute) || !COMPONENT_ATTRIBUTE_MAP.get(attribute).has(parentNodeName)) {\n    const tagNames = Array.from(\n      COMPONENT_ATTRIBUTE_MAP.get(attribute).values(),\n      (tagName) => `\"<${tagName}>\"`\n    ).join(', ');\n    report(context, messages.onlyMeaningfulFor, 'onlyMeaningfulFor', {\n      node,\n      data: {\n        attributeName: attribute,\n        tagNames,\n      },\n      fix,\n    });\n    return;\n  }\n\n  if (!node.value) {\n    report(context, messages.emptyIsMeaningless, 'emptyIsMeaningless', {\n      node,\n      data: { attributeName: attribute },\n      fix,\n    });\n    return;\n  }\n\n  if (node.value.type === 'Literal') {\n    return checkLiteralValueNode(context, attribute, node.value, node, parentNodeName);\n  }\n\n  if (node.value.expression.type === 'Literal') {\n    return checkLiteralValueNode(context, attribute, node.value.expression, node, parentNodeName);\n  }\n\n  if (node.value.type !== 'JSXExpressionContainer') {\n    return;\n  }\n\n  if (node.value.expression.type === 'ObjectExpression') {\n    report(context, messages.onlyStrings, 'onlyStrings', {\n      node,\n      data: { attributeName: attribute },\n      fix,\n    });\n    return;\n  }\n\n  if (node.value.expression.type === 'Identifier' && node.value.expression.name === 'undefined') {\n    report(context, messages.onlyStrings, 'onlyStrings', {\n      node,\n      data: { attributeName: attribute },\n      fix,\n    });\n  }\n}\n\nfunction isValidCreateElement(node) {\n  return node.callee\n    && node.callee.type === 'MemberExpression'\n    && node.callee.object.name === 'React'\n    && node.callee.property.name === 'createElement'\n    && node.arguments.length > 0;\n}\n\nfunction checkPropValidValue(context, node, value, attribute) {\n  const validTags = VALID_VALUES.get(attribute);\n\n  if (value.type !== 'Literal') {\n    return; // cannot check non-literals\n  }\n\n  const validTagSet = validTags.get(value.value);\n  if (!validTagSet) {\n    report(context, messages.neverValid, 'neverValid', {\n      node: value,\n      data: {\n        attributeName: attribute,\n        reportingValue: value.value,\n      },\n    });\n    return;\n  }\n\n  if (!validTagSet.has(node.arguments[0].value)) {\n    report(context, messages.notValidFor, 'notValidFor', {\n      node: value,\n      data: {\n        attributeName: attribute,\n        reportingValue: value.raw,\n        elementName: node.arguments[0].value,\n      },\n    });\n  }\n}\n\n/**\n *\n * @param {*} context\n * @param {*} node\n * @param {string} attribute\n */\nfunction checkCreateProps(context, node, attribute) {\n  const propsArg = node.arguments[1];\n\n  if (!propsArg || propsArg.type !== 'ObjectExpression') {\n    return; // can't check variables, computed, or shorthands\n  }\n\n  for (const prop of propsArg.properties) {\n    if (!prop.key || prop.key.type !== 'Identifier') {\n      // eslint-disable-next-line no-continue\n      continue; // cannot check computed keys\n    }\n\n    if (prop.key.name !== attribute) {\n      // eslint-disable-next-line no-continue\n      continue; // ignore not this attribute\n    }\n\n    if (!COMPONENT_ATTRIBUTE_MAP.get(attribute).has(node.arguments[0].value)) {\n      const tagNames = Array.from(\n        COMPONENT_ATTRIBUTE_MAP.get(attribute).values(),\n        (tagName) => `\"<${tagName}>\"`\n      ).join(', ');\n\n      report(context, messages.onlyMeaningfulFor, 'onlyMeaningfulFor', {\n        node,\n        data: {\n          attributeName: attribute,\n          tagNames,\n        },\n      });\n\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (prop.method) {\n      report(context, messages.noMethod, 'noMethod', {\n        node: prop,\n        data: {\n          attributeName: attribute,\n        },\n      });\n\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (prop.shorthand || prop.computed) {\n      // eslint-disable-next-line no-continue\n      continue; // cannot check these\n    }\n\n    if (prop.value.type === 'ArrayExpression') {\n      for (const value of prop.value.elements) {\n        checkPropValidValue(context, node, value, attribute);\n      }\n\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    checkPropValidValue(context, node, prop.value, attribute);\n  }\n}\n\nmodule.exports = {\n  meta: {\n    fixable: 'code',\n    docs: {\n      description: 'Disallow usage of invalid attributes',\n      category: 'Possible Errors',\n      url: docsUrl('no-invalid-html-attribute'),\n    },\n    messages,\n    schema: [{\n      type: 'array',\n      uniqueItems: true,\n      items: {\n        enum: ['rel'],\n      },\n    }],\n  },\n\n  create(context) {\n    return {\n      JSXAttribute(node) {\n        const attributes = new Set(context.options[0] || DEFAULT_ATTRIBUTES);\n\n        // ignore attributes that aren't configured to be checked\n        if (!attributes.has(node.name.name)) {\n          return;\n        }\n\n        // ignore non-HTML elements\n        if (!HTML_ELEMENTS.has(node.parent.name.name)) {\n          return;\n        }\n\n        checkAttribute(context, node);\n      },\n\n      CallExpression(node) {\n        if (!isValidCreateElement(node)) {\n          return;\n        }\n\n        const elemNameArg = node.arguments[0];\n\n        if (!elemNameArg || elemNameArg.type !== 'Literal') {\n          return; // can only check literals\n        }\n\n        // ignore non-HTML elements\n        if (!HTML_ELEMENTS.has(elemNameArg.value)) {\n          return;\n        }\n\n        const attributes = new Set(context.options[0] || DEFAULT_ATTRIBUTES);\n\n        for (const attribute of attributes) {\n          checkCreateProps(context, node, attribute);\n        }\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}