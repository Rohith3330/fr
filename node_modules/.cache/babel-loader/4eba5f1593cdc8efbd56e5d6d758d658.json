{"ast":null,"code":"import * as regex from '../lib/regex';\n/**\n * This splits a string on a top-level character.\n *\n * Regex doesn't support recursion (at least not the JS-flavored version).\n * So we have to use a tiny state machine to keep track of paren placement.\n *\n * Expected behavior using commas:\n * var(--a, 0 0 1px rgb(0, 0, 0)), 0 0 1px rgb(0, 0, 0)\n *       ─┬─             ┬  ┬    ┬\n *        x              x  x    ╰──────── Split because top-level\n *        ╰──────────────┴──┴───────────── Ignored b/c inside >= 1 levels of parens\n *\n * @param {string} input\n * @param {string} separator\n */\n\nexport function* splitAtTopLevelOnly(input, separator) {\n  let SPECIALS = new RegExp(`[(){}\\\\[\\\\]${regex.escape(separator)}]`, 'g');\n  let depth = 0;\n  let lastIndex = 0;\n  let found = false;\n  let separatorIndex = 0;\n  let separatorStart = 0;\n  let separatorLength = separator.length; // Find all paren-like things & character\n  // And only split on commas if they're top-level\n\n  for (let match of input.matchAll(SPECIALS)) {\n    let matchesSeparator = match[0] === separator[separatorIndex];\n    let atEndOfSeparator = separatorIndex === separatorLength - 1;\n    let matchesFullSeparator = matchesSeparator && atEndOfSeparator;\n    if (match[0] === '(') depth++;\n    if (match[0] === ')') depth--;\n    if (match[0] === '[') depth++;\n    if (match[0] === ']') depth--;\n    if (match[0] === '{') depth++;\n    if (match[0] === '}') depth--;\n\n    if (matchesSeparator && depth === 0) {\n      if (separatorStart === 0) {\n        separatorStart = match.index;\n      }\n\n      separatorIndex++;\n    }\n\n    if (matchesFullSeparator && depth === 0) {\n      found = true;\n      yield input.substring(lastIndex, separatorStart);\n      lastIndex = separatorStart + separatorLength;\n    }\n\n    if (separatorIndex === separatorLength) {\n      separatorIndex = 0;\n      separatorStart = 0;\n    }\n  } // Provide the last segment of the string if available\n  // Otherwise the whole string since no `char`s were found\n  // This mirrors the behavior of string.split()\n\n\n  if (found) {\n    yield input.substring(lastIndex);\n  } else {\n    yield input;\n  }\n}","map":{"version":3,"names":["regex","splitAtTopLevelOnly","input","separator","SPECIALS","RegExp","escape","depth","lastIndex","found","separatorIndex","separatorStart","separatorLength","length","match","matchAll","matchesSeparator","atEndOfSeparator","matchesFullSeparator","index","substring"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/src/util/splitAtTopLevelOnly.js"],"sourcesContent":["import * as regex from '../lib/regex'\n\n/**\n * This splits a string on a top-level character.\n *\n * Regex doesn't support recursion (at least not the JS-flavored version).\n * So we have to use a tiny state machine to keep track of paren placement.\n *\n * Expected behavior using commas:\n * var(--a, 0 0 1px rgb(0, 0, 0)), 0 0 1px rgb(0, 0, 0)\n *       ─┬─             ┬  ┬    ┬\n *        x              x  x    ╰──────── Split because top-level\n *        ╰──────────────┴──┴───────────── Ignored b/c inside >= 1 levels of parens\n *\n * @param {string} input\n * @param {string} separator\n */\nexport function* splitAtTopLevelOnly(input, separator) {\n  let SPECIALS = new RegExp(`[(){}\\\\[\\\\]${regex.escape(separator)}]`, 'g')\n\n  let depth = 0\n  let lastIndex = 0\n  let found = false\n  let separatorIndex = 0\n  let separatorStart = 0\n  let separatorLength = separator.length\n\n  // Find all paren-like things & character\n  // And only split on commas if they're top-level\n  for (let match of input.matchAll(SPECIALS)) {\n    let matchesSeparator = match[0] === separator[separatorIndex]\n    let atEndOfSeparator = separatorIndex === separatorLength - 1\n    let matchesFullSeparator = matchesSeparator && atEndOfSeparator\n\n    if (match[0] === '(') depth++\n    if (match[0] === ')') depth--\n    if (match[0] === '[') depth++\n    if (match[0] === ']') depth--\n    if (match[0] === '{') depth++\n    if (match[0] === '}') depth--\n\n    if (matchesSeparator && depth === 0) {\n      if (separatorStart === 0) {\n        separatorStart = match.index\n      }\n\n      separatorIndex++\n    }\n\n    if (matchesFullSeparator && depth === 0) {\n      found = true\n\n      yield input.substring(lastIndex, separatorStart)\n      lastIndex = separatorStart + separatorLength\n    }\n\n    if (separatorIndex === separatorLength) {\n      separatorIndex = 0\n      separatorStart = 0\n    }\n  }\n\n  // Provide the last segment of the string if available\n  // Otherwise the whole string since no `char`s were found\n  // This mirrors the behavior of string.split()\n  if (found) {\n    yield input.substring(lastIndex)\n  } else {\n    yield input\n  }\n}\n"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,cAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,UAAUC,mBAAV,CAA8BC,KAA9B,EAAqCC,SAArC,EAAgD;EACrD,IAAIC,QAAQ,GAAG,IAAIC,MAAJ,CAAY,cAAaL,KAAK,CAACM,MAAN,CAAaH,SAAb,CAAwB,GAAjD,EAAqD,GAArD,CAAf;EAEA,IAAII,KAAK,GAAG,CAAZ;EACA,IAAIC,SAAS,GAAG,CAAhB;EACA,IAAIC,KAAK,GAAG,KAAZ;EACA,IAAIC,cAAc,GAAG,CAArB;EACA,IAAIC,cAAc,GAAG,CAArB;EACA,IAAIC,eAAe,GAAGT,SAAS,CAACU,MAAhC,CARqD,CAUrD;EACA;;EACA,KAAK,IAAIC,KAAT,IAAkBZ,KAAK,CAACa,QAAN,CAAeX,QAAf,CAAlB,EAA4C;IAC1C,IAAIY,gBAAgB,GAAGF,KAAK,CAAC,CAAD,CAAL,KAAaX,SAAS,CAACO,cAAD,CAA7C;IACA,IAAIO,gBAAgB,GAAGP,cAAc,KAAKE,eAAe,GAAG,CAA5D;IACA,IAAIM,oBAAoB,GAAGF,gBAAgB,IAAIC,gBAA/C;IAEA,IAAIH,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsBP,KAAK;IAC3B,IAAIO,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsBP,KAAK;IAC3B,IAAIO,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsBP,KAAK;IAC3B,IAAIO,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsBP,KAAK;IAC3B,IAAIO,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsBP,KAAK;IAC3B,IAAIO,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsBP,KAAK;;IAE3B,IAAIS,gBAAgB,IAAIT,KAAK,KAAK,CAAlC,EAAqC;MACnC,IAAII,cAAc,KAAK,CAAvB,EAA0B;QACxBA,cAAc,GAAGG,KAAK,CAACK,KAAvB;MACD;;MAEDT,cAAc;IACf;;IAED,IAAIQ,oBAAoB,IAAIX,KAAK,KAAK,CAAtC,EAAyC;MACvCE,KAAK,GAAG,IAAR;MAEA,MAAMP,KAAK,CAACkB,SAAN,CAAgBZ,SAAhB,EAA2BG,cAA3B,CAAN;MACAH,SAAS,GAAGG,cAAc,GAAGC,eAA7B;IACD;;IAED,IAAIF,cAAc,KAAKE,eAAvB,EAAwC;MACtCF,cAAc,GAAG,CAAjB;MACAC,cAAc,GAAG,CAAjB;IACD;EACF,CA3CoD,CA6CrD;EACA;EACA;;;EACA,IAAIF,KAAJ,EAAW;IACT,MAAMP,KAAK,CAACkB,SAAN,CAAgBZ,SAAhB,CAAN;EACD,CAFD,MAEO;IACL,MAAMN,KAAN;EACD;AACF"},"metadata":{},"sourceType":"module"}