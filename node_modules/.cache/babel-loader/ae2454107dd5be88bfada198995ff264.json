{"ast":null,"code":"/**\n * @fileoverview enforce the location of arrow function bodies\n * @author Sharmila Jesupaul\n */\n\"use strict\";\n\nconst {\n  isCommentToken,\n  isNotOpeningParenToken\n} = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"Enforce the location of arrow function bodies\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"beside\", \"below\"]\n    }],\n    messages: {\n      expected: \"Expected a linebreak before this expression.\",\n      unexpected: \"Expected no linebreak before this expression.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"beside\";\n    /**\n     * Validates the location of an arrow function body\n     * @param {ASTNode} node The arrow function body\n     * @returns {void}\n     */\n\n    function validateExpression(node) {\n      if (node.body.type === \"BlockStatement\") {\n        return;\n      }\n\n      const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);\n      const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);\n\n      if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === \"below\") {\n        context.report({\n          node: firstTokenOfBody,\n          messageId: \"expected\",\n          fix: fixer => fixer.insertTextBefore(firstTokenOfBody, \"\\n\")\n        });\n      } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === \"beside\") {\n        context.report({\n          node: firstTokenOfBody,\n          messageId: \"unexpected\",\n\n          fix(fixer) {\n            if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, {\n              includeComments: true,\n              filter: isCommentToken\n            })) {\n              return null;\n            }\n\n            return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], \" \");\n          }\n\n        });\n      }\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      ArrowFunctionExpression: node => validateExpression(node)\n    };\n  }\n\n};","map":{"version":3,"names":["isCommentToken","isNotOpeningParenToken","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","enum","messages","expected","unexpected","create","context","sourceCode","getSourceCode","option","options","validateExpression","node","body","arrowToken","getTokenBefore","firstTokenOfBody","getTokenAfter","loc","end","line","start","report","messageId","fix","fixer","insertTextBefore","getFirstTokenBetween","includeComments","filter","replaceTextRange","range","ArrowFunctionExpression"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/implicit-arrow-linebreak.js"],"sourcesContent":["/**\n * @fileoverview enforce the location of arrow function bodies\n * @author Sharmila Jesupaul\n */\n\"use strict\";\n\nconst { isCommentToken, isNotOpeningParenToken } = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce the location of arrow function bodies\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"beside\", \"below\"]\n            }\n        ],\n        messages: {\n            expected: \"Expected a linebreak before this expression.\",\n            unexpected: \"Expected no linebreak before this expression.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"beside\";\n\n        /**\n         * Validates the location of an arrow function body\n         * @param {ASTNode} node The arrow function body\n         * @returns {void}\n         */\n        function validateExpression(node) {\n            if (node.body.type === \"BlockStatement\") {\n                return;\n            }\n\n            const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);\n            const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);\n\n            if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === \"below\") {\n                context.report({\n                    node: firstTokenOfBody,\n                    messageId: \"expected\",\n                    fix: fixer => fixer.insertTextBefore(firstTokenOfBody, \"\\n\")\n                });\n            } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === \"beside\") {\n                context.report({\n                    node: firstTokenOfBody,\n                    messageId: \"unexpected\",\n                    fix(fixer) {\n                        if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, { includeComments: true, filter: isCommentToken })) {\n                            return null;\n                        }\n\n                        return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], \" \");\n                    }\n                });\n            }\n        }\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n        return {\n            ArrowFunctionExpression: node => validateExpression(node)\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAM;EAAEA,cAAF;EAAkBC;AAAlB,IAA6CC,OAAO,CAAC,mBAAD,CAA1D,C,CAEA;AACA;AACA;;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,QADJ;IAGFC,IAAI,EAAE;MACFC,WAAW,EAAE,+CADX;MAEFC,WAAW,EAAE,KAFX;MAGFC,GAAG,EAAE;IAHH,CAHJ;IASFC,OAAO,EAAE,YATP;IAWFC,MAAM,EAAE,CACJ;MACIC,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX;IADV,CADI,CAXN;IAgBFC,QAAQ,EAAE;MACNC,QAAQ,EAAE,8CADJ;MAENC,UAAU,EAAE;IAFN;EAhBR,CADO;;EAuBbC,MAAM,CAACC,OAAD,EAAU;IACZ,MAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB;IACA,MAAMC,MAAM,GAAGH,OAAO,CAACI,OAAR,CAAgB,CAAhB,KAAsB,QAArC;IAEA;AACR;AACA;AACA;AACA;;IACQ,SAASC,kBAAT,CAA4BC,IAA5B,EAAkC;MAC9B,IAAIA,IAAI,CAACC,IAAL,CAAUnB,IAAV,KAAmB,gBAAvB,EAAyC;QACrC;MACH;;MAED,MAAMoB,UAAU,GAAGP,UAAU,CAACQ,cAAX,CAA0BH,IAAI,CAACC,IAA/B,EAAqCxB,sBAArC,CAAnB;MACA,MAAM2B,gBAAgB,GAAGT,UAAU,CAACU,aAAX,CAAyBH,UAAzB,CAAzB;;MAEA,IAAIA,UAAU,CAACI,GAAX,CAAeC,GAAf,CAAmBC,IAAnB,KAA4BJ,gBAAgB,CAACE,GAAjB,CAAqBG,KAArB,CAA2BD,IAAvD,IAA+DX,MAAM,KAAK,OAA9E,EAAuF;QACnFH,OAAO,CAACgB,MAAR,CAAe;UACXV,IAAI,EAAEI,gBADK;UAEXO,SAAS,EAAE,UAFA;UAGXC,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,gBAAN,CAAuBV,gBAAvB,EAAyC,IAAzC;QAHH,CAAf;MAKH,CAND,MAMO,IAAIF,UAAU,CAACI,GAAX,CAAeC,GAAf,CAAmBC,IAAnB,KAA4BJ,gBAAgB,CAACE,GAAjB,CAAqBG,KAArB,CAA2BD,IAAvD,IAA+DX,MAAM,KAAK,QAA9E,EAAwF;QAC3FH,OAAO,CAACgB,MAAR,CAAe;UACXV,IAAI,EAAEI,gBADK;UAEXO,SAAS,EAAE,YAFA;;UAGXC,GAAG,CAACC,KAAD,EAAQ;YACP,IAAIlB,UAAU,CAACoB,oBAAX,CAAgCb,UAAhC,EAA4CE,gBAA5C,EAA8D;cAAEY,eAAe,EAAE,IAAnB;cAAyBC,MAAM,EAAEzC;YAAjC,CAA9D,CAAJ,EAAsH;cAClH,OAAO,IAAP;YACH;;YAED,OAAOqC,KAAK,CAACK,gBAAN,CAAuB,CAAChB,UAAU,CAACiB,KAAX,CAAiB,CAAjB,CAAD,EAAsBf,gBAAgB,CAACe,KAAjB,CAAuB,CAAvB,CAAtB,CAAvB,EAAyE,GAAzE,CAAP;UACH;;QATU,CAAf;MAWH;IACJ,CApCW,CAsCZ;IACA;IACA;;;IACA,OAAO;MACHC,uBAAuB,EAAEpB,IAAI,IAAID,kBAAkB,CAACC,IAAD;IADhD,CAAP;EAGH;;AAnEY,CAAjB"},"metadata":{},"sourceType":"script"}