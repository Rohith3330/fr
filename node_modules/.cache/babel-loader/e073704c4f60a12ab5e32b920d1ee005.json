{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'no-unused-vars',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow unused variables',\n      recommended: 'warn',\n      extendsBaseRule: true\n    },\n    schema: [{\n      oneOf: [{\n        enum: ['all', 'local']\n      }, {\n        type: 'object',\n        properties: {\n          vars: {\n            enum: ['all', 'local']\n          },\n          varsIgnorePattern: {\n            type: 'string'\n          },\n          args: {\n            enum: ['all', 'after-used', 'none']\n          },\n          ignoreRestSiblings: {\n            type: 'boolean'\n          },\n          argsIgnorePattern: {\n            type: 'string'\n          },\n          caughtErrors: {\n            enum: ['all', 'none']\n          },\n          caughtErrorsIgnorePattern: {\n            type: 'string'\n          },\n          destructuredArrayIgnorePattern: {\n            type: 'string'\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\n    }\n  },\n  defaultOptions: [{}],\n\n  create(context) {\n    const filename = context.getFilename();\n    const sourceCode = context.getSourceCode();\n    const MODULE_DECL_CACHE = new Map();\n\n    const options = (() => {\n      var _a, _b, _c, _d;\n\n      const options = {\n        vars: 'all',\n        args: 'after-used',\n        ignoreRestSiblings: false,\n        caughtErrors: 'none'\n      };\n      const [firstOption] = context.options;\n\n      if (firstOption) {\n        if (typeof firstOption === 'string') {\n          options.vars = firstOption;\n        } else {\n          options.vars = (_a = firstOption.vars) !== null && _a !== void 0 ? _a : options.vars;\n          options.args = (_b = firstOption.args) !== null && _b !== void 0 ? _b : options.args;\n          options.ignoreRestSiblings = (_c = firstOption.ignoreRestSiblings) !== null && _c !== void 0 ? _c : options.ignoreRestSiblings;\n          options.caughtErrors = (_d = firstOption.caughtErrors) !== null && _d !== void 0 ? _d : options.caughtErrors;\n\n          if (firstOption.varsIgnorePattern) {\n            options.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, 'u');\n          }\n\n          if (firstOption.argsIgnorePattern) {\n            options.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, 'u');\n          }\n\n          if (firstOption.caughtErrorsIgnorePattern) {\n            options.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, 'u');\n          }\n\n          if (firstOption.destructuredArrayIgnorePattern) {\n            options.destructuredArrayIgnorePattern = new RegExp(firstOption.destructuredArrayIgnorePattern, 'u');\n          }\n        }\n      }\n\n      return options;\n    })();\n\n    function collectUnusedVariables() {\n      var _a, _b, _c, _d, _e;\n      /**\n       * Checks whether a node is a sibling of the rest property or not.\n       * @param {ASTNode} node a node to check\n       * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.\n       */\n\n\n      function hasRestSibling(node) {\n        var _a;\n\n        return node.type === utils_1.AST_NODE_TYPES.Property && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ObjectPattern && node.parent.properties[node.parent.properties.length - 1].type === utils_1.AST_NODE_TYPES.RestElement;\n      }\n      /**\n       * Determines if a variable has a sibling rest property\n       * @param variable eslint-scope variable object.\n       * @returns True if the variable is exported, false if not.\n       */\n\n\n      function hasRestSpreadSibling(variable) {\n        if (options.ignoreRestSiblings) {\n          const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n          const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n          return hasRestSiblingDefinition || hasRestSiblingReference;\n        }\n\n        return false;\n      }\n      /**\n       * Checks whether the given variable is after the last used parameter.\n       * @param variable The variable to check.\n       * @returns `true` if the variable is defined after the last used parameter.\n       */\n\n\n      function isAfterLastUsedArg(variable) {\n        const def = variable.defs[0];\n        const params = context.getDeclaredVariables(def.node);\n        const posteriorParams = params.slice(params.indexOf(variable) + 1); // If any used parameters occur after this parameter, do not report.\n\n        return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n      }\n\n      const unusedVariablesOriginal = util.collectUnusedVariables(context);\n      const unusedVariablesReturn = [];\n\n      for (const variable of unusedVariablesOriginal) {\n        // explicit global variables don't have definitions.\n        if (variable.defs.length === 0) {\n          unusedVariablesReturn.push(variable);\n          continue;\n        }\n\n        const def = variable.defs[0];\n\n        if (variable.scope.type === utils_1.TSESLint.Scope.ScopeType.global && options.vars === 'local') {\n          // skip variables in the global scope if configured to\n          continue;\n        }\n\n        const refUsedInArrayPatterns = variable.references.some(ref => {\n          var _a;\n\n          return ((_a = ref.identifier.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ArrayPattern;\n        }); // skip elements of array destructuring patterns\n\n        if ((((_a = def.name.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ArrayPattern || refUsedInArrayPatterns) && 'name' in def.name && ((_b = options.destructuredArrayIgnorePattern) === null || _b === void 0 ? void 0 : _b.test(def.name.name))) {\n          continue;\n        } // skip catch variables\n\n\n        if (def.type === utils_1.TSESLint.Scope.DefinitionType.CatchClause) {\n          if (options.caughtErrors === 'none') {\n            continue;\n          } // skip ignored parameters\n\n\n          if ('name' in def.name && ((_c = options.caughtErrorsIgnorePattern) === null || _c === void 0 ? void 0 : _c.test(def.name.name))) {\n            continue;\n          }\n        }\n\n        if (def.type === utils_1.TSESLint.Scope.DefinitionType.Parameter) {\n          // if \"args\" option is \"none\", skip any parameter\n          if (options.args === 'none') {\n            continue;\n          } // skip ignored parameters\n\n\n          if ('name' in def.name && ((_d = options.argsIgnorePattern) === null || _d === void 0 ? void 0 : _d.test(def.name.name))) {\n            continue;\n          } // if \"args\" option is \"after-used\", skip used variables\n\n\n          if (options.args === 'after-used' && util.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n            continue;\n          }\n        } else {\n          // skip ignored variables\n          if ('name' in def.name && ((_e = options.varsIgnorePattern) === null || _e === void 0 ? void 0 : _e.test(def.name.name))) {\n            continue;\n          }\n        }\n\n        if (hasRestSpreadSibling(variable)) {\n          continue;\n        } // in case another rule has run and used the collectUnusedVariables,\n        // we want to ensure our selectors that marked variables as used are respected\n\n\n        if (variable.eslintUsed) {\n          continue;\n        }\n\n        unusedVariablesReturn.push(variable);\n      }\n\n      return unusedVariablesReturn;\n    }\n\n    return {\n      // declaration file handling\n      [ambientDeclarationSelector(utils_1.AST_NODE_TYPES.Program, true)](node) {\n        if (!util.isDefinitionFile(filename)) {\n          return;\n        }\n\n        markDeclarationChildAsUsed(node);\n      },\n\n      // module declaration in module declaration should not report unused vars error\n      // this is workaround as this change should be done in better way\n      'TSModuleDeclaration > TSModuleDeclaration'(node) {\n        if (node.id.type === utils_1.AST_NODE_TYPES.Identifier) {\n          let scope = context.getScope();\n\n          if (scope.upper) {\n            scope = scope.upper;\n          }\n\n          const superVar = scope.set.get(node.id.name);\n\n          if (superVar) {\n            superVar.eslintUsed = true;\n          }\n        }\n      },\n\n      // children of a namespace that is a child of a declared namespace are auto-exported\n      [ambientDeclarationSelector('TSModuleDeclaration[declare = true] > TSModuleBlock TSModuleDeclaration > TSModuleBlock', false)](node) {\n        markDeclarationChildAsUsed(node);\n      },\n\n      // declared namespace handling\n      [ambientDeclarationSelector('TSModuleDeclaration[declare = true] > TSModuleBlock', false)](node) {\n        var _a;\n\n        const moduleDecl = util.nullThrows((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent, util.NullThrowsReasons.MissingParent); // declared ambient modules with an `export =` statement will only export that one thing\n        // all other statements are not automatically exported in this case\n\n        if (moduleDecl.id.type === utils_1.AST_NODE_TYPES.Literal && checkModuleDeclForExportEquals(moduleDecl)) {\n          return;\n        }\n\n        markDeclarationChildAsUsed(node);\n      },\n\n      // collect\n      'Program:exit'(programNode) {\n        /**\n         * Generates the message data about the variable being defined and unused,\n         * including the ignore pattern if configured.\n         * @param unusedVar eslint-scope variable object.\n         * @returns The message data to be used with this unused variable.\n         */\n        function getDefinedMessageData(unusedVar) {\n          var _a;\n\n          const defType = (_a = unusedVar === null || unusedVar === void 0 ? void 0 : unusedVar.defs[0]) === null || _a === void 0 ? void 0 : _a.type;\n          let type;\n          let pattern;\n\n          if (defType === utils_1.TSESLint.Scope.DefinitionType.CatchClause && options.caughtErrorsIgnorePattern) {\n            type = 'args';\n            pattern = options.caughtErrorsIgnorePattern.toString();\n          } else if (defType === utils_1.TSESLint.Scope.DefinitionType.Parameter && options.argsIgnorePattern) {\n            type = 'args';\n            pattern = options.argsIgnorePattern.toString();\n          } else if (defType !== utils_1.TSESLint.Scope.DefinitionType.Parameter && options.varsIgnorePattern) {\n            type = 'vars';\n            pattern = options.varsIgnorePattern.toString();\n          }\n\n          const additional = type ? `. Allowed unused ${type} must match ${pattern}` : '';\n          return {\n            varName: unusedVar.name,\n            action: 'defined',\n            additional\n          };\n        }\n        /**\n         * Generate the warning message about the variable being\n         * assigned and unused, including the ignore pattern if configured.\n         * @param unusedVar eslint-scope variable object.\n         * @returns The message data to be used with this unused variable.\n         */\n\n\n        function getAssignedMessageData(unusedVar) {\n          var _a;\n\n          const def = unusedVar.defs[0];\n          let additional = '';\n\n          if (options.destructuredArrayIgnorePattern && ((_a = def === null || def === void 0 ? void 0 : def.name.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ArrayPattern) {\n            additional = `. Allowed unused elements of array destructuring patterns must match ${options.destructuredArrayIgnorePattern.toString()}`;\n          } else if (options.varsIgnorePattern) {\n            additional = `. Allowed unused vars must match ${options.varsIgnorePattern.toString()}`;\n          }\n\n          return {\n            varName: unusedVar.name,\n            action: 'assigned a value',\n            additional\n          };\n        }\n\n        const unusedVars = collectUnusedVariables();\n\n        for (const unusedVar of unusedVars) {\n          // Report the first declaration.\n          if (unusedVar.defs.length > 0) {\n            const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\n            context.report({\n              node: writeReferences.length ? writeReferences[writeReferences.length - 1].identifier : unusedVar.identifiers[0],\n              messageId: 'unusedVar',\n              data: unusedVar.references.some(ref => ref.isWrite()) ? getAssignedMessageData(unusedVar) : getDefinedMessageData(unusedVar)\n            }); // If there are no regular declaration, report the first `/*globals*/` comment directive.\n          } else if ('eslintExplicitGlobalComments' in unusedVar && unusedVar.eslintExplicitGlobalComments) {\n            const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n            context.report({\n              node: programNode,\n              loc: util.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n              messageId: 'unusedVar',\n              data: getDefinedMessageData(unusedVar)\n            });\n          }\n        }\n      }\n\n    };\n\n    function checkModuleDeclForExportEquals(node) {\n      const cached = MODULE_DECL_CACHE.get(node);\n\n      if (cached != null) {\n        return cached;\n      }\n\n      if (node.body && node.body.type === utils_1.AST_NODE_TYPES.TSModuleBlock) {\n        for (const statement of node.body.body) {\n          if (statement.type === utils_1.AST_NODE_TYPES.TSExportAssignment) {\n            MODULE_DECL_CACHE.set(node, true);\n            return true;\n          }\n        }\n      }\n\n      MODULE_DECL_CACHE.set(node, false);\n      return false;\n    }\n\n    function ambientDeclarationSelector(parent, childDeclare) {\n      return [// Types are ambiently exported\n      `${parent} > :matches(${[utils_1.AST_NODE_TYPES.TSInterfaceDeclaration, utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration].join(', ')})`, // Value things are ambiently exported if they are \"declare\"d\n      `${parent} > :matches(${[utils_1.AST_NODE_TYPES.ClassDeclaration, utils_1.AST_NODE_TYPES.TSDeclareFunction, utils_1.AST_NODE_TYPES.TSEnumDeclaration, utils_1.AST_NODE_TYPES.TSModuleDeclaration, utils_1.AST_NODE_TYPES.VariableDeclaration].join(', ')})${childDeclare ? '[declare = true]' : ''}`].join(', ');\n    }\n\n    function markDeclarationChildAsUsed(node) {\n      var _a;\n\n      const identifiers = [];\n\n      switch (node.type) {\n        case utils_1.AST_NODE_TYPES.TSInterfaceDeclaration:\n        case utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration:\n        case utils_1.AST_NODE_TYPES.ClassDeclaration:\n        case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n        case utils_1.AST_NODE_TYPES.TSDeclareFunction:\n        case utils_1.AST_NODE_TYPES.TSEnumDeclaration:\n        case utils_1.AST_NODE_TYPES.TSModuleDeclaration:\n          if (((_a = node.id) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.Identifier) {\n            identifiers.push(node.id);\n          }\n\n          break;\n\n        case utils_1.AST_NODE_TYPES.VariableDeclaration:\n          for (const declaration of node.declarations) {\n            visitPattern(declaration, pattern => {\n              identifiers.push(pattern);\n            });\n          }\n\n          break;\n      }\n\n      let scope = context.getScope();\n      const shouldUseUpperScope = [utils_1.AST_NODE_TYPES.TSModuleDeclaration, utils_1.AST_NODE_TYPES.TSDeclareFunction].includes(node.type);\n\n      if (scope.variableScope !== scope) {\n        scope = scope.variableScope;\n      } else if (shouldUseUpperScope && scope.upper) {\n        scope = scope.upper;\n      }\n\n      for (const id of identifiers) {\n        const superVar = scope.set.get(id.name);\n\n        if (superVar) {\n          superVar.eslintUsed = true;\n        }\n      }\n    }\n\n    function visitPattern(node, cb) {\n      const visitor = new scope_manager_1.PatternVisitor({}, node, cb);\n      visitor.visit(node);\n    }\n  }\n\n});\n/*\n\n###### TODO ######\n\nEdge cases that aren't currently handled due to laziness and them being super edgy edge cases\n\n\n--- function params referenced in typeof type refs in the function declaration ---\n--- NOTE - TS gets these cases wrong\n\nfunction _foo(\n  arg: number // arg should be unused\n): typeof arg {\n  return 1 as any;\n}\n\nfunction _bar(\n  arg: number, // arg should be unused\n  _arg2: typeof arg,\n) {}\n\n\n--- function names referenced in typeof type refs in the function declaration ---\n--- NOTE - TS gets these cases right\n\nfunction foo( // foo should be unused\n): typeof foo {\n    return 1 as any;\n}\n\nfunction bar( // bar should be unused\n  _arg: typeof bar\n) {}\n\n\n--- if an interface is merged into a namespace  ---\n--- NOTE - TS gets these cases wrong\n\nnamespace Test {\n    interface Foo { // Foo should be unused here\n        a: string;\n    }\n    export namespace Foo {\n       export type T = 'b';\n    }\n}\ntype T = Test.Foo; // Error: Namespace 'Test' has no exported member 'Foo'.\n\n\nnamespace Test {\n    export interface Foo {\n        a: string;\n    }\n    namespace Foo { // Foo should be unused here\n       export type T = 'b';\n    }\n}\ntype T = Test.Foo.T; // Error: Namespace 'Test' has no exported member 'Foo'.\n\n*/\n\n/*\n\n###### TODO ######\n\nWe currently extend base `no-unused-vars` implementation because it's easier and lighter-weight.\n\nBecause of this, there are a few false-negatives which won't get caught.\nWe could fix these if we fork the base rule; but that's a lot of code (~650 lines) to add in.\nI didn't want to do that just yet without some real-world issues, considering these are pretty rare edge-cases.\n\nThese cases are mishandled because the base rule assumes that each variable has one def, but type-value shadowing\ncreates a variable with two defs\n\n--- type-only or value-only references to type/value shadowed variables ---\n--- NOTE - TS gets these cases wrong\n\ntype T = 1;\nconst T = 2; // this T should be unused\n\ntype U = T; // this U should be unused\nconst U = 3;\n\nconst _V = U;\n\n\n--- partially exported type/value shadowed variables ---\n--- NOTE - TS gets these cases wrong\n\nexport interface Foo {}\nconst Foo = 1; // this Foo should be unused\n\ninterface Bar {} // this Bar should be unused\nexport const Bar = 1;\n\n*/","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","extendsBaseRule","schema","oneOf","enum","properties","vars","varsIgnorePattern","args","ignoreRestSiblings","argsIgnorePattern","caughtErrors","caughtErrorsIgnorePattern","destructuredArrayIgnorePattern","additionalProperties","messages","unusedVar","defaultOptions","create","context","filename","getFilename","sourceCode","getSourceCode","MODULE_DECL_CACHE","Map","options","firstOption","_a","_b","_c","_d","RegExp","collectUnusedVariables","hasRestSibling","node","utils_1","Property","parent","ObjectPattern","length","RestElement","hasRestSpreadSibling","variable","hasRestSiblingDefinition","defs","some","def","hasRestSiblingReference","references","ref","identifier","isAfterLastUsedArg","params","getDeclaredVariables","posteriorParams","slice","indexOf","v","eslintUsed","unusedVariablesOriginal","unusedVariablesReturn","push","scope","Scope","ScopeType","global","refUsedInArrayPatterns","ArrayPattern","test","DefinitionType","CatchClause","Parameter","isFunction","_e","ambientDeclarationSelector","Program","isDefinitionFile","markDeclarationChildAsUsed","id","Identifier","getScope","upper","superVar","set","get","moduleDecl","nullThrows","NullThrowsReasons","MissingParent","Literal","checkModuleDeclForExportEquals","programNode","getDefinedMessageData","defType","pattern","toString","additional","varName","action","getAssignedMessageData","unusedVars","writeReferences","filter","isWrite","from","variableScope","report","identifiers","messageId","data","eslintExplicitGlobalComments","directiveComment","loc","getNameLocationInGlobalDirectiveComment","cached","body","TSModuleBlock","statement","TSExportAssignment","childDeclare","TSInterfaceDeclaration","TSTypeAliasDeclaration","join","ClassDeclaration","TSDeclareFunction","TSEnumDeclaration","TSModuleDeclaration","VariableDeclaration","FunctionDeclaration","declaration","declarations","visitPattern","shouldUseUpperScope","includes","cb","visitor","scope_manager_1","visit"],"sources":["../../src/rules/no-unused-vars.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}