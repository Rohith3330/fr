{"ast":null,"code":"var SyntaxReferenceError = require('./error').SyntaxReferenceError;\n\nvar SyntaxMatchError = require('./error').SyntaxMatchError;\n\nvar names = require('../utils/names');\n\nvar generic = require('./generic');\n\nvar parse = require('../definition-syntax/parse');\n\nvar generate = require('../definition-syntax/generate');\n\nvar walk = require('../definition-syntax/walk');\n\nvar prepareTokens = require('./prepare-tokens');\n\nvar buildMatchGraph = require('./match-graph').buildMatchGraph;\n\nvar matchAsTree = require('./match').matchAsTree;\n\nvar trace = require('./trace');\n\nvar search = require('./search');\n\nvar getStructureFromConfig = require('./structure').getStructureFromConfig;\n\nvar cssWideKeywords = buildMatchGraph('inherit | initial | unset');\nvar cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');\n\nfunction dumpMapSyntax(map, compact, syntaxAsAst) {\n  var result = {};\n\n  for (var name in map) {\n    if (map[name].syntax) {\n      result[name] = syntaxAsAst ? map[name].syntax : generate(map[name].syntax, {\n        compact: compact\n      });\n    }\n  }\n\n  return result;\n}\n\nfunction dumpAtruleMapSyntax(map, compact, syntaxAsAst) {\n  const result = {};\n\n  for (const [name, atrule] of Object.entries(map)) {\n    result[name] = {\n      prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate(atrule.prelude.syntax, {\n        compact\n      })),\n      descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)\n    };\n  }\n\n  return result;\n}\n\nfunction valueHasVar(tokens) {\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].value.toLowerCase() === 'var(') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction buildMatchResult(match, error, iterations) {\n  return {\n    matched: match,\n    iterations: iterations,\n    error: error,\n    getTrace: trace.getTrace,\n    isType: trace.isType,\n    isProperty: trace.isProperty,\n    isKeyword: trace.isKeyword\n  };\n}\n\nfunction matchSyntax(lexer, syntax, value, useCommon) {\n  var tokens = prepareTokens(value, lexer.syntax);\n  var result;\n\n  if (valueHasVar(tokens)) {\n    return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));\n  }\n\n  if (useCommon) {\n    result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);\n  }\n\n  if (!useCommon || !result.match) {\n    result = matchAsTree(tokens, syntax.match, lexer);\n\n    if (!result.match) {\n      return buildMatchResult(null, new SyntaxMatchError(result.reason, syntax.syntax, value, result), result.iterations);\n    }\n  }\n\n  return buildMatchResult(result.match, null, result.iterations);\n}\n\nvar Lexer = function (config, syntax, structure) {\n  this.valueCommonSyntax = cssWideKeywords;\n  this.syntax = syntax;\n  this.generic = false;\n  this.atrules = {};\n  this.properties = {};\n  this.types = {};\n  this.structure = structure || getStructureFromConfig(config);\n\n  if (config) {\n    if (config.types) {\n      for (var name in config.types) {\n        this.addType_(name, config.types[name]);\n      }\n    }\n\n    if (config.generic) {\n      this.generic = true;\n\n      for (var name in generic) {\n        this.addType_(name, generic[name]);\n      }\n    }\n\n    if (config.atrules) {\n      for (var name in config.atrules) {\n        this.addAtrule_(name, config.atrules[name]);\n      }\n    }\n\n    if (config.properties) {\n      for (var name in config.properties) {\n        this.addProperty_(name, config.properties[name]);\n      }\n    }\n  }\n};\n\nLexer.prototype = {\n  structure: {},\n  checkStructure: function (ast) {\n    function collectWarning(node, message) {\n      warns.push({\n        node: node,\n        message: message\n      });\n    }\n\n    var structure = this.structure;\n    var warns = [];\n    this.syntax.walk(ast, function (node) {\n      if (structure.hasOwnProperty(node.type)) {\n        structure[node.type].check(node, collectWarning);\n      } else {\n        collectWarning(node, 'Unknown node type `' + node.type + '`');\n      }\n    });\n    return warns.length ? warns : false;\n  },\n  createDescriptor: function (syntax, type, name) {\n    let parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var ref = {\n      type: type,\n      name: name\n    };\n    var descriptor = {\n      type: type,\n      name: name,\n      parent: parent,\n      syntax: null,\n      match: null\n    };\n\n    if (typeof syntax === 'function') {\n      descriptor.match = buildMatchGraph(syntax, ref);\n    } else {\n      if (typeof syntax === 'string') {\n        // lazy parsing on first access\n        Object.defineProperty(descriptor, 'syntax', {\n          get: function () {\n            Object.defineProperty(descriptor, 'syntax', {\n              value: parse(syntax)\n            });\n            return descriptor.syntax;\n          }\n        });\n      } else {\n        descriptor.syntax = syntax;\n      } // lazy graph build on first access\n\n\n      Object.defineProperty(descriptor, 'match', {\n        get: function () {\n          Object.defineProperty(descriptor, 'match', {\n            value: buildMatchGraph(descriptor.syntax, ref)\n          });\n          return descriptor.match;\n        }\n      });\n    }\n\n    return descriptor;\n  },\n  addAtrule_: function (name, syntax) {\n    if (!syntax) {\n      return;\n    }\n\n    this.atrules[name] = {\n      type: 'Atrule',\n      name: name,\n      prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,\n      descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce((res, descName) => {\n        res[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);\n        return res;\n      }, {}) : null\n    };\n  },\n  addProperty_: function (name, syntax) {\n    if (!syntax) {\n      return;\n    }\n\n    this.properties[name] = this.createDescriptor(syntax, 'Property', name);\n  },\n  addType_: function (name, syntax) {\n    if (!syntax) {\n      return;\n    }\n\n    this.types[name] = this.createDescriptor(syntax, 'Type', name);\n\n    if (syntax === generic['-ms-legacy-expression']) {\n      this.valueCommonSyntax = cssWideKeywordsWithExpression;\n    }\n  },\n  checkAtruleName: function (atruleName) {\n    if (!this.getAtrule(atruleName)) {\n      return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);\n    }\n  },\n  checkAtrulePrelude: function (atruleName, prelude) {\n    let error = this.checkAtruleName(atruleName);\n\n    if (error) {\n      return error;\n    }\n\n    var atrule = this.getAtrule(atruleName);\n\n    if (!atrule.prelude && prelude) {\n      return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');\n    }\n\n    if (atrule.prelude && !prelude) {\n      return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');\n    }\n  },\n  checkAtruleDescriptorName: function (atruleName, descriptorName) {\n    let error = this.checkAtruleName(atruleName);\n\n    if (error) {\n      return error;\n    }\n\n    var atrule = this.getAtrule(atruleName);\n    var descriptor = names.keyword(descriptorName);\n\n    if (!atrule.descriptors) {\n      return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');\n    }\n\n    if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {\n      return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);\n    }\n  },\n  checkPropertyName: function (propertyName) {\n    var property = names.property(propertyName); // don't match syntax for a custom property\n\n    if (property.custom) {\n      return new Error('Lexer matching doesn\\'t applicable for custom properties');\n    }\n\n    if (!this.getProperty(propertyName)) {\n      return new SyntaxReferenceError('Unknown property', propertyName);\n    }\n  },\n  matchAtrulePrelude: function (atruleName, prelude) {\n    var error = this.checkAtrulePrelude(atruleName, prelude);\n\n    if (error) {\n      return buildMatchResult(null, error);\n    }\n\n    if (!prelude) {\n      return buildMatchResult(null, null);\n    }\n\n    return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);\n  },\n  matchAtruleDescriptor: function (atruleName, descriptorName, value) {\n    var error = this.checkAtruleDescriptorName(atruleName, descriptorName);\n\n    if (error) {\n      return buildMatchResult(null, error);\n    }\n\n    var atrule = this.getAtrule(atruleName);\n    var descriptor = names.keyword(descriptorName);\n    return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);\n  },\n  matchDeclaration: function (node) {\n    if (node.type !== 'Declaration') {\n      return buildMatchResult(null, new Error('Not a Declaration node'));\n    }\n\n    return this.matchProperty(node.property, node.value);\n  },\n  matchProperty: function (propertyName, value) {\n    var error = this.checkPropertyName(propertyName);\n\n    if (error) {\n      return buildMatchResult(null, error);\n    }\n\n    return matchSyntax(this, this.getProperty(propertyName), value, true);\n  },\n  matchType: function (typeName, value) {\n    var typeSyntax = this.getType(typeName);\n\n    if (!typeSyntax) {\n      return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));\n    }\n\n    return matchSyntax(this, typeSyntax, value, false);\n  },\n  match: function (syntax, value) {\n    if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {\n      return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));\n    }\n\n    if (typeof syntax === 'string' || !syntax.match) {\n      syntax = this.createDescriptor(syntax, 'Type', 'anonymous');\n    }\n\n    return matchSyntax(this, syntax, value, false);\n  },\n  findValueFragments: function (propertyName, value, type, name) {\n    return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);\n  },\n  findDeclarationValueFragments: function (declaration, type, name) {\n    return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);\n  },\n  findAllFragments: function (ast, type, name) {\n    var result = [];\n    this.syntax.walk(ast, {\n      visit: 'Declaration',\n      enter: function (declaration) {\n        result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));\n      }.bind(this)\n    });\n    return result;\n  },\n  getAtrule: function (atruleName) {\n    let fallbackBasename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var atrule = names.keyword(atruleName);\n    var atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];\n    return atruleEntry || null;\n  },\n  getAtrulePrelude: function (atruleName) {\n    let fallbackBasename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const atrule = this.getAtrule(atruleName, fallbackBasename);\n    return atrule && atrule.prelude || null;\n  },\n  getAtruleDescriptor: function (atruleName, name) {\n    return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;\n  },\n  getProperty: function (propertyName) {\n    let fallbackBasename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var property = names.property(propertyName);\n    var propertyEntry = property.vendor && fallbackBasename ? this.properties[property.name] || this.properties[property.basename] : this.properties[property.name];\n    return propertyEntry || null;\n  },\n  getType: function (name) {\n    return this.types.hasOwnProperty(name) ? this.types[name] : null;\n  },\n  validate: function () {\n    function validate(syntax, name, broken, descriptor) {\n      if (broken.hasOwnProperty(name)) {\n        return broken[name];\n      }\n\n      broken[name] = false;\n\n      if (descriptor.syntax !== null) {\n        walk(descriptor.syntax, function (node) {\n          if (node.type !== 'Type' && node.type !== 'Property') {\n            return;\n          }\n\n          var map = node.type === 'Type' ? syntax.types : syntax.properties;\n          var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;\n\n          if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {\n            broken[name] = true;\n          }\n        }, this);\n      }\n    }\n\n    var brokenTypes = {};\n    var brokenProperties = {};\n\n    for (var key in this.types) {\n      validate(this, key, brokenTypes, this.types[key]);\n    }\n\n    for (var key in this.properties) {\n      validate(this, key, brokenProperties, this.properties[key]);\n    }\n\n    brokenTypes = Object.keys(brokenTypes).filter(function (name) {\n      return brokenTypes[name];\n    });\n    brokenProperties = Object.keys(brokenProperties).filter(function (name) {\n      return brokenProperties[name];\n    });\n\n    if (brokenTypes.length || brokenProperties.length) {\n      return {\n        types: brokenTypes,\n        properties: brokenProperties\n      };\n    }\n\n    return null;\n  },\n  dump: function (syntaxAsAst, pretty) {\n    return {\n      generic: this.generic,\n      types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),\n      properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),\n      atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)\n    };\n  },\n  toString: function () {\n    return JSON.stringify(this.dump());\n  }\n};\nmodule.exports = Lexer;","map":{"version":3,"names":["SyntaxReferenceError","require","SyntaxMatchError","names","generic","parse","generate","walk","prepareTokens","buildMatchGraph","matchAsTree","trace","search","getStructureFromConfig","cssWideKeywords","cssWideKeywordsWithExpression","dumpMapSyntax","map","compact","syntaxAsAst","result","name","syntax","dumpAtruleMapSyntax","atrule","Object","entries","prelude","descriptors","valueHasVar","tokens","i","length","value","toLowerCase","buildMatchResult","match","error","iterations","matched","getTrace","isType","isProperty","isKeyword","matchSyntax","lexer","useCommon","Error","valueCommonSyntax","reason","Lexer","config","structure","atrules","properties","types","addType_","addAtrule_","addProperty_","prototype","checkStructure","ast","collectWarning","node","message","warns","push","hasOwnProperty","type","check","createDescriptor","parent","ref","descriptor","defineProperty","get","keys","reduce","res","descName","checkAtruleName","atruleName","getAtrule","checkAtrulePrelude","SyntaxError","checkAtruleDescriptorName","descriptorName","keyword","basename","checkPropertyName","propertyName","property","custom","getProperty","matchAtrulePrelude","matchAtruleDescriptor","matchDeclaration","matchProperty","matchType","typeName","typeSyntax","getType","findValueFragments","matchFragments","findDeclarationValueFragments","declaration","findAllFragments","visit","enter","apply","bind","fallbackBasename","atruleEntry","vendor","getAtrulePrelude","getAtruleDescriptor","declarators","propertyEntry","validate","broken","brokenMap","brokenTypes","brokenProperties","key","filter","dump","pretty","toString","JSON","stringify","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/css-tree/lib/lexer/Lexer.js"],"sourcesContent":["var SyntaxReferenceError = require('./error').SyntaxReferenceError;\nvar SyntaxMatchError = require('./error').SyntaxMatchError;\nvar names = require('../utils/names');\nvar generic = require('./generic');\nvar parse = require('../definition-syntax/parse');\nvar generate = require('../definition-syntax/generate');\nvar walk = require('../definition-syntax/walk');\nvar prepareTokens = require('./prepare-tokens');\nvar buildMatchGraph = require('./match-graph').buildMatchGraph;\nvar matchAsTree = require('./match').matchAsTree;\nvar trace = require('./trace');\nvar search = require('./search');\nvar getStructureFromConfig = require('./structure').getStructureFromConfig;\nvar cssWideKeywords = buildMatchGraph('inherit | initial | unset');\nvar cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');\n\nfunction dumpMapSyntax(map, compact, syntaxAsAst) {\n    var result = {};\n\n    for (var name in map) {\n        if (map[name].syntax) {\n            result[name] = syntaxAsAst\n                ? map[name].syntax\n                : generate(map[name].syntax, { compact: compact });\n        }\n    }\n\n    return result;\n}\n\nfunction dumpAtruleMapSyntax(map, compact, syntaxAsAst) {\n    const result = {};\n\n    for (const [name, atrule] of Object.entries(map)) {\n        result[name] = {\n            prelude: atrule.prelude && (\n                syntaxAsAst\n                    ? atrule.prelude.syntax\n                    : generate(atrule.prelude.syntax, { compact })\n            ),\n            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)\n        };\n    }\n\n    return result;\n}\n\nfunction valueHasVar(tokens) {\n    for (var i = 0; i < tokens.length; i++) {\n        if (tokens[i].value.toLowerCase() === 'var(') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction buildMatchResult(match, error, iterations) {\n    return {\n        matched: match,\n        iterations: iterations,\n        error: error,\n        getTrace: trace.getTrace,\n        isType: trace.isType,\n        isProperty: trace.isProperty,\n        isKeyword: trace.isKeyword\n    };\n}\n\nfunction matchSyntax(lexer, syntax, value, useCommon) {\n    var tokens = prepareTokens(value, lexer.syntax);\n    var result;\n\n    if (valueHasVar(tokens)) {\n        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));\n    }\n\n    if (useCommon) {\n        result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);\n    }\n\n    if (!useCommon || !result.match) {\n        result = matchAsTree(tokens, syntax.match, lexer);\n        if (!result.match) {\n            return buildMatchResult(\n                null,\n                new SyntaxMatchError(result.reason, syntax.syntax, value, result),\n                result.iterations\n            );\n        }\n    }\n\n    return buildMatchResult(result.match, null, result.iterations);\n}\n\nvar Lexer = function(config, syntax, structure) {\n    this.valueCommonSyntax = cssWideKeywords;\n    this.syntax = syntax;\n    this.generic = false;\n    this.atrules = {};\n    this.properties = {};\n    this.types = {};\n    this.structure = structure || getStructureFromConfig(config);\n\n    if (config) {\n        if (config.types) {\n            for (var name in config.types) {\n                this.addType_(name, config.types[name]);\n            }\n        }\n\n        if (config.generic) {\n            this.generic = true;\n            for (var name in generic) {\n                this.addType_(name, generic[name]);\n            }\n        }\n\n        if (config.atrules) {\n            for (var name in config.atrules) {\n                this.addAtrule_(name, config.atrules[name]);\n            }\n        }\n\n        if (config.properties) {\n            for (var name in config.properties) {\n                this.addProperty_(name, config.properties[name]);\n            }\n        }\n    }\n};\n\nLexer.prototype = {\n    structure: {},\n    checkStructure: function(ast) {\n        function collectWarning(node, message) {\n            warns.push({\n                node: node,\n                message: message\n            });\n        }\n\n        var structure = this.structure;\n        var warns = [];\n\n        this.syntax.walk(ast, function(node) {\n            if (structure.hasOwnProperty(node.type)) {\n                structure[node.type].check(node, collectWarning);\n            } else {\n                collectWarning(node, 'Unknown node type `' + node.type + '`');\n            }\n        });\n\n        return warns.length ? warns : false;\n    },\n\n    createDescriptor: function(syntax, type, name, parent = null) {\n        var ref = {\n            type: type,\n            name: name\n        };\n        var descriptor = {\n            type: type,\n            name: name,\n            parent: parent,\n            syntax: null,\n            match: null\n        };\n\n        if (typeof syntax === 'function') {\n            descriptor.match = buildMatchGraph(syntax, ref);\n        } else {\n            if (typeof syntax === 'string') {\n                // lazy parsing on first access\n                Object.defineProperty(descriptor, 'syntax', {\n                    get: function() {\n                        Object.defineProperty(descriptor, 'syntax', {\n                            value: parse(syntax)\n                        });\n\n                        return descriptor.syntax;\n                    }\n                });\n            } else {\n                descriptor.syntax = syntax;\n            }\n\n            // lazy graph build on first access\n            Object.defineProperty(descriptor, 'match', {\n                get: function() {\n                    Object.defineProperty(descriptor, 'match', {\n                        value: buildMatchGraph(descriptor.syntax, ref)\n                    });\n\n                    return descriptor.match;\n                }\n            });\n        }\n\n        return descriptor;\n    },\n    addAtrule_: function(name, syntax) {\n        if (!syntax) {\n            return;\n        }\n\n        this.atrules[name] = {\n            type: 'Atrule',\n            name: name,\n            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,\n            descriptors: syntax.descriptors\n                ? Object.keys(syntax.descriptors).reduce((res, descName) => {\n                    res[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);\n                    return res;\n                }, {})\n                : null\n        };\n    },\n    addProperty_: function(name, syntax) {\n        if (!syntax) {\n            return;\n        }\n\n        this.properties[name] = this.createDescriptor(syntax, 'Property', name);\n    },\n    addType_: function(name, syntax) {\n        if (!syntax) {\n            return;\n        }\n\n        this.types[name] = this.createDescriptor(syntax, 'Type', name);\n\n        if (syntax === generic['-ms-legacy-expression']) {\n            this.valueCommonSyntax = cssWideKeywordsWithExpression;\n        }\n    },\n\n    checkAtruleName: function(atruleName) {\n        if (!this.getAtrule(atruleName)) {\n            return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);\n        }\n    },\n    checkAtrulePrelude: function(atruleName, prelude) {\n        let error = this.checkAtruleName(atruleName);\n\n        if (error) {\n            return error;\n        }\n\n        var atrule = this.getAtrule(atruleName);\n\n        if (!atrule.prelude && prelude) {\n            return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');\n        }\n\n        if (atrule.prelude && !prelude) {\n            return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');\n        }\n    },\n    checkAtruleDescriptorName: function(atruleName, descriptorName) {\n        let error = this.checkAtruleName(atruleName);\n\n        if (error) {\n            return error;\n        }\n\n        var atrule = this.getAtrule(atruleName);\n        var descriptor = names.keyword(descriptorName);\n\n        if (!atrule.descriptors) {\n            return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');\n        }\n\n        if (!atrule.descriptors[descriptor.name] &&\n            !atrule.descriptors[descriptor.basename]) {\n            return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);\n        }\n    },\n    checkPropertyName: function(propertyName) {\n        var property = names.property(propertyName);\n\n        // don't match syntax for a custom property\n        if (property.custom) {\n            return new Error('Lexer matching doesn\\'t applicable for custom properties');\n        }\n\n        if (!this.getProperty(propertyName)) {\n            return new SyntaxReferenceError('Unknown property', propertyName);\n        }\n    },\n\n    matchAtrulePrelude: function(atruleName, prelude) {\n        var error = this.checkAtrulePrelude(atruleName, prelude);\n\n        if (error) {\n            return buildMatchResult(null, error);\n        }\n\n        if (!prelude) {\n            return buildMatchResult(null, null);\n        }\n\n        return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);\n    },\n    matchAtruleDescriptor: function(atruleName, descriptorName, value) {\n        var error = this.checkAtruleDescriptorName(atruleName, descriptorName);\n\n        if (error) {\n            return buildMatchResult(null, error);\n        }\n\n        var atrule = this.getAtrule(atruleName);\n        var descriptor = names.keyword(descriptorName);\n\n        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);\n    },\n    matchDeclaration: function(node) {\n        if (node.type !== 'Declaration') {\n            return buildMatchResult(null, new Error('Not a Declaration node'));\n        }\n\n        return this.matchProperty(node.property, node.value);\n    },\n    matchProperty: function(propertyName, value) {\n        var error = this.checkPropertyName(propertyName);\n\n        if (error) {\n            return buildMatchResult(null, error);\n        }\n\n        return matchSyntax(this, this.getProperty(propertyName), value, true);\n    },\n    matchType: function(typeName, value) {\n        var typeSyntax = this.getType(typeName);\n\n        if (!typeSyntax) {\n            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));\n        }\n\n        return matchSyntax(this, typeSyntax, value, false);\n    },\n    match: function(syntax, value) {\n        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {\n            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));\n        }\n\n        if (typeof syntax === 'string' || !syntax.match) {\n            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');\n        }\n\n        return matchSyntax(this, syntax, value, false);\n    },\n\n    findValueFragments: function(propertyName, value, type, name) {\n        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);\n    },\n    findDeclarationValueFragments: function(declaration, type, name) {\n        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);\n    },\n    findAllFragments: function(ast, type, name) {\n        var result = [];\n\n        this.syntax.walk(ast, {\n            visit: 'Declaration',\n            enter: function(declaration) {\n                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));\n            }.bind(this)\n        });\n\n        return result;\n    },\n\n    getAtrule: function(atruleName, fallbackBasename = true) {\n        var atrule = names.keyword(atruleName);\n        var atruleEntry = atrule.vendor && fallbackBasename\n            ? this.atrules[atrule.name] || this.atrules[atrule.basename]\n            : this.atrules[atrule.name];\n\n        return atruleEntry || null;\n    },\n    getAtrulePrelude: function(atruleName, fallbackBasename = true) {\n        const atrule = this.getAtrule(atruleName, fallbackBasename);\n\n        return atrule && atrule.prelude || null;\n    },\n    getAtruleDescriptor: function(atruleName, name) {\n        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators\n            ? this.atrules[atruleName].declarators[name] || null\n            : null;\n    },\n    getProperty: function(propertyName, fallbackBasename = true) {\n        var property = names.property(propertyName);\n        var propertyEntry = property.vendor && fallbackBasename\n            ? this.properties[property.name] || this.properties[property.basename]\n            : this.properties[property.name];\n\n        return propertyEntry || null;\n    },\n    getType: function(name) {\n        return this.types.hasOwnProperty(name) ? this.types[name] : null;\n    },\n\n    validate: function() {\n        function validate(syntax, name, broken, descriptor) {\n            if (broken.hasOwnProperty(name)) {\n                return broken[name];\n            }\n\n            broken[name] = false;\n            if (descriptor.syntax !== null) {\n                walk(descriptor.syntax, function(node) {\n                    if (node.type !== 'Type' && node.type !== 'Property') {\n                        return;\n                    }\n\n                    var map = node.type === 'Type' ? syntax.types : syntax.properties;\n                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;\n\n                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {\n                        broken[name] = true;\n                    }\n                }, this);\n            }\n        }\n\n        var brokenTypes = {};\n        var brokenProperties = {};\n\n        for (var key in this.types) {\n            validate(this, key, brokenTypes, this.types[key]);\n        }\n\n        for (var key in this.properties) {\n            validate(this, key, brokenProperties, this.properties[key]);\n        }\n\n        brokenTypes = Object.keys(brokenTypes).filter(function(name) {\n            return brokenTypes[name];\n        });\n        brokenProperties = Object.keys(brokenProperties).filter(function(name) {\n            return brokenProperties[name];\n        });\n\n        if (brokenTypes.length || brokenProperties.length) {\n            return {\n                types: brokenTypes,\n                properties: brokenProperties\n            };\n        }\n\n        return null;\n    },\n    dump: function(syntaxAsAst, pretty) {\n        return {\n            generic: this.generic,\n            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),\n            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),\n            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)\n        };\n    },\n    toString: function() {\n        return JSON.stringify(this.dump());\n    }\n};\n\nmodule.exports = Lexer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}