{"ast":null,"code":"'use strict';\n\nvar transport = require('../spdy-transport');\n\nvar assert = require('assert');\n\nvar util = require('util');\n\nvar debug = {\n  client: require('debug')('spdy:stream:client'),\n  server: require('debug')('spdy:stream:server')\n};\n\nvar Duplex = require('readable-stream').Duplex;\n\nfunction Stream(connection, options) {\n  Duplex.call(this);\n  var connectionState = connection._spdyState;\n  var state = {};\n  this._spdyState = state;\n  this.id = options.id;\n  this.method = options.method;\n  this.path = options.path;\n  this.host = options.host;\n  this.headers = options.headers || {};\n  this.connection = connection;\n  this.parent = options.parent || null;\n  state.socket = null;\n  state.protocol = connectionState.protocol;\n  state.constants = state.protocol.constants; // See _initPriority()\n\n  state.priority = null;\n  state.version = this.connection.getVersion();\n  state.isServer = this.connection.isServer();\n  state.debug = state.isServer ? debug.server : debug.client;\n  state.framer = connectionState.framer;\n  state.parser = connectionState.parser;\n  state.request = options.request;\n  state.needResponse = options.request;\n  state.window = connectionState.streamWindow.clone(options.id);\n  state.sessionWindow = connectionState.window;\n  state.maxChunk = connectionState.maxChunk; // Can't send incoming request\n  // (See `.send()` method)\n\n  state.sent = !state.request;\n  state.readable = options.readable !== false;\n  state.writable = options.writable !== false;\n  state.aborted = false;\n  state.corked = 0;\n  state.corkQueue = [];\n  state.timeout = new transport.utils.Timeout(this);\n  this.on('finish', this._onFinish);\n  this.on('end', this._onEnd);\n  var self = this;\n\n  function _onWindowOverflow() {\n    self._onWindowOverflow();\n  }\n\n  state.window.recv.on('overflow', _onWindowOverflow);\n  state.window.send.on('overflow', _onWindowOverflow);\n\n  this._initPriority(options.priority);\n\n  if (!state.readable) {\n    this.push(null);\n  }\n\n  if (!state.writable) {\n    this._writableState.ended = true;\n    this._writableState.finished = true;\n  }\n}\n\nutil.inherits(Stream, Duplex);\nexports.Stream = Stream;\n\nStream.prototype._init = function _init(socket) {\n  this.socket = socket;\n};\n\nStream.prototype._initPriority = function _initPriority(priority) {\n  var state = this._spdyState;\n  var connectionState = this.connection._spdyState;\n  var root = connectionState.priorityRoot;\n\n  if (!priority) {\n    state.priority = root.addDefault(this.id);\n    return;\n  }\n\n  state.priority = root.add({\n    id: this.id,\n    parent: priority.parent,\n    weight: priority.weight,\n    exclusive: priority.exclusive\n  });\n};\n\nStream.prototype._handleFrame = function _handleFrame(frame) {\n  var state = this._spdyState; // Ignore any kind of data after abort\n\n  if (state.aborted) {\n    state.debug('id=%d ignoring frame=%s after abort', this.id, frame.type);\n    return;\n  } // Restart the timer on incoming frames\n\n\n  state.timeout.reset();\n\n  if (frame.type === 'DATA') {\n    this._handleData(frame);\n  } else if (frame.type === 'HEADERS') {\n    this._handleHeaders(frame);\n  } else if (frame.type === 'RST') {\n    this._handleRST(frame);\n  } else if (frame.type === 'WINDOW_UPDATE') {\n    this._handleWindowUpdate(frame);\n  } else if (frame.type === 'PRIORITY') {\n    this._handlePriority(frame);\n  } else if (frame.type === 'PUSH_PROMISE') {\n    this._handlePushPromise(frame);\n  }\n\n  if (frame.fin) {\n    state.debug('id=%d end', this.id);\n    this.push(null);\n  }\n};\n\nfunction checkAborted(stream, state, callback) {\n  if (state.aborted) {\n    state.debug('id=%d abort write', stream.id);\n    process.nextTick(function () {\n      callback(new Error('Stream write aborted'));\n    });\n    return true;\n  }\n\n  return false;\n}\n\nfunction _send(stream, state, data, callback) {\n  if (checkAborted(stream, state, callback)) {\n    return;\n  }\n\n  state.debug('id=%d presend=%d', stream.id, data.length);\n  state.timeout.reset();\n  state.window.send.update(-data.length, function () {\n    if (checkAborted(stream, state, callback)) {\n      return;\n    }\n\n    state.debug('id=%d send=%d', stream.id, data.length);\n    state.timeout.reset();\n    state.framer.dataFrame({\n      id: stream.id,\n      priority: state.priority.getPriority(),\n      fin: false,\n      data: data\n    }, function (err) {\n      state.debug('id=%d postsend=%d', stream.id, data.length);\n      callback(err);\n    });\n  });\n}\n\nStream.prototype._write = function _write(data, enc, callback) {\n  var state = this._spdyState; // Send the request if it wasn't sent\n\n  if (!state.sent) {\n    this.send();\n  } // Writes should come after pending control frames (response and headers)\n\n\n  if (state.corked !== 0) {\n    var self = this;\n    state.corkQueue.push(function () {\n      self._write(data, enc, callback);\n    });\n    return;\n  } // Split DATA in chunks to prevent window from going negative\n\n\n  this._splitStart(data, _send, callback);\n};\n\nStream.prototype._splitStart = function _splitStart(data, onChunk, callback) {\n  return this._split(data, 0, onChunk, callback);\n};\n\nStream.prototype._split = function _split(data, offset, onChunk, callback) {\n  if (offset === data.length) {\n    return process.nextTick(callback);\n  }\n\n  var state = this._spdyState;\n  var local = state.window.send;\n  var session = state.sessionWindow.send;\n  var availSession = Math.max(0, session.getCurrent());\n\n  if (availSession === 0) {\n    availSession = session.getMax();\n  }\n\n  var availLocal = Math.max(0, local.getCurrent());\n\n  if (availLocal === 0) {\n    availLocal = local.getMax();\n  }\n\n  var avail = Math.min(availSession, availLocal);\n  avail = Math.min(avail, state.maxChunk);\n  var self = this;\n\n  if (avail === 0) {\n    state.window.send.update(0, function () {\n      self._split(data, offset, onChunk, callback);\n    });\n    return;\n  } // Split data in chunks in a following way:\n\n\n  var limit = avail;\n  var size = Math.min(data.length - offset, limit);\n  var chunk = data.slice(offset, offset + size);\n  onChunk(this, state, chunk, function (err) {\n    if (err) {\n      return callback(err);\n    } // Get the next chunk\n\n\n    self._split(data, offset + size, onChunk, callback);\n  });\n};\n\nStream.prototype._read = function _read() {\n  var state = this._spdyState;\n\n  if (!state.window.recv.isDraining()) {\n    return;\n  }\n\n  var delta = state.window.recv.getDelta();\n  state.debug('id=%d window emptying, update by %d', this.id, delta);\n  state.window.recv.update(delta);\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  });\n};\n\nStream.prototype._handleData = function _handleData(frame) {\n  var state = this._spdyState; // DATA on ended or not readable stream!\n\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({\n      id: this.id,\n      code: 'STREAM_CLOSED'\n    });\n    return;\n  }\n\n  state.debug('id=%d recv=%d', this.id, frame.data.length);\n  state.window.recv.update(-frame.data.length);\n  this.push(frame.data);\n};\n\nStream.prototype._handleRST = function _handleRST(frame) {\n  if (frame.code !== 'CANCEL') {\n    this.emit('error', new Error('Got RST: ' + frame.code));\n  }\n\n  this.abort();\n};\n\nStream.prototype._handleWindowUpdate = function _handleWindowUpdate(frame) {\n  var state = this._spdyState;\n  state.window.send.update(frame.delta);\n};\n\nStream.prototype._onWindowOverflow = function _onWindowOverflow() {\n  var state = this._spdyState;\n  state.debug('id=%d window overflow', this.id);\n  state.framer.rstFrame({\n    id: this.id,\n    code: 'FLOW_CONTROL_ERROR'\n  });\n  this.aborted = true;\n  this.emit('error', new Error('HTTP2 window overflow'));\n};\n\nStream.prototype._handlePriority = function _handlePriority(frame) {\n  var state = this._spdyState;\n  state.priority.remove();\n  state.priority = null;\n\n  this._initPriority(frame.priority); // Mostly for testing purposes\n\n\n  this.emit('priority', frame.priority);\n};\n\nStream.prototype._handleHeaders = function _handleHeaders(frame) {\n  var state = this._spdyState;\n\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({\n      id: this.id,\n      code: 'STREAM_CLOSED'\n    });\n    return;\n  }\n\n  if (state.needResponse) {\n    return this._handleResponse(frame);\n  }\n\n  this.emit('headers', frame.headers);\n};\n\nStream.prototype._handleResponse = function _handleResponse(frame) {\n  var state = this._spdyState;\n\n  if (frame.headers[':status'] === undefined) {\n    state.framer.rstFrame({\n      id: this.id,\n      code: 'PROTOCOL_ERROR'\n    });\n    return;\n  }\n\n  state.needResponse = false;\n  this.emit('response', frame.headers[':status'] | 0, frame.headers);\n};\n\nStream.prototype._onFinish = function _onFinish() {\n  var state = this._spdyState; // Send the request if it wasn't sent\n\n  if (!state.sent) {\n    // NOTE: will send HEADERS with FIN flag\n    this.send();\n  } else {\n    // Just an `.end()` without any writes will trigger immediate `finish` event\n    // without any calls to `_write()`.\n    if (state.corked !== 0) {\n      var self = this;\n      state.corkQueue.push(function () {\n        self._onFinish();\n      });\n      return;\n    }\n\n    state.framer.dataFrame({\n      id: this.id,\n      priority: state.priority.getPriority(),\n      fin: true,\n      data: Buffer.alloc(0)\n    });\n  }\n\n  this._maybeClose();\n};\n\nStream.prototype._onEnd = function _onEnd() {\n  this._maybeClose();\n};\n\nStream.prototype._checkEnded = function _checkEnded(callback) {\n  var state = this._spdyState;\n  var ended = false;\n\n  if (state.aborted) {\n    ended = true;\n  }\n\n  if (!state.writable || this._writableState.finished) {\n    ended = true;\n  }\n\n  if (!ended) {\n    return true;\n  }\n\n  if (!callback) {\n    return false;\n  }\n\n  var err = new Error('Ended stream can\\'t send frames');\n  process.nextTick(function () {\n    callback(err);\n  });\n  return false;\n};\n\nStream.prototype._maybeClose = function _maybeClose() {\n  var state = this._spdyState; // .abort() emits `close`\n\n  if (state.aborted) {\n    return;\n  }\n\n  if ((!state.readable || this._readableState.ended) && this._writableState.finished) {\n    // Clear timeout\n    state.timeout.set(0);\n    this.emit('close');\n  }\n};\n\nStream.prototype._handlePushPromise = function _handlePushPromise(frame) {\n  var push = this.connection._createStream({\n    id: frame.promisedId,\n    parent: this,\n    push: true,\n    request: true,\n    method: frame.headers[':method'],\n    path: frame.headers[':path'],\n    host: frame.headers[':authority'],\n    priority: frame.priority,\n    headers: frame.headers,\n    writable: false\n  }); // GOAWAY\n\n\n  if (this.connection._isGoaway(push.id)) {\n    return;\n  }\n\n  if (!this.emit('pushPromise', push)) {\n    push.abort();\n  }\n};\n\nStream.prototype._hardCork = function _hardCork() {\n  var state = this._spdyState;\n  this.cork();\n  state.corked++;\n};\n\nStream.prototype._hardUncork = function _hardUncork() {\n  var state = this._spdyState;\n  this.uncork();\n  state.corked--;\n\n  if (state.corked !== 0) {\n    return;\n  } // Invoke callbacks\n\n\n  var queue = state.corkQueue;\n  state.corkQueue = [];\n\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n};\n\nStream.prototype._sendPush = function _sendPush(status, response, callback) {\n  var self = this;\n  var state = this._spdyState;\n\n  this._hardCork();\n\n  state.framer.pushFrame({\n    id: this.parent.id,\n    promisedId: this.id,\n    priority: state.priority.toJSON(),\n    path: this.path,\n    host: this.host,\n    method: this.method,\n    status: status,\n    headers: this.headers,\n    response: response\n  }, function (err) {\n    self._hardUncork();\n\n    callback(err);\n  });\n};\n\nStream.prototype._wasSent = function _wasSent() {\n  var state = this._spdyState;\n  return state.sent;\n}; // Public API\n\n\nStream.prototype.send = function send(callback) {\n  var state = this._spdyState;\n\n  if (state.sent) {\n    var err = new Error('Stream was already sent');\n    process.nextTick(function () {\n      if (callback) {\n        callback(err);\n      }\n    });\n    return;\n  }\n\n  state.sent = true;\n  state.timeout.reset(); // GET requests should always be auto-finished\n\n  if (this.method === 'GET') {\n    this._writableState.ended = true;\n    this._writableState.finished = true;\n  } // TODO(indunty): ideally it should just take a stream object as an input\n\n\n  var self = this;\n\n  this._hardCork();\n\n  state.framer.requestFrame({\n    id: this.id,\n    method: this.method,\n    path: this.path,\n    host: this.host,\n    priority: state.priority.toJSON(),\n    headers: this.headers,\n    fin: this._writableState.finished\n  }, function (err) {\n    self._hardUncork();\n\n    if (!callback) {\n      return;\n    }\n\n    callback(err);\n  });\n};\n\nStream.prototype.respond = function respond(status, headers, callback) {\n  var self = this;\n  var state = this._spdyState;\n  assert(!state.request, 'Can\\'t respond on request');\n  state.timeout.reset();\n\n  if (!this._checkEnded(callback)) {\n    return;\n  }\n\n  var frame = {\n    id: this.id,\n    status: status,\n    headers: headers\n  };\n\n  this._hardCork();\n\n  state.framer.responseFrame(frame, function (err) {\n    self._hardUncork();\n\n    if (callback) {\n      callback(err);\n    }\n  });\n};\n\nStream.prototype.setWindow = function setWindow(size) {\n  var state = this._spdyState;\n  state.timeout.reset();\n\n  if (!this._checkEnded()) {\n    return;\n  }\n\n  state.debug('id=%d force window max=%d', this.id, size);\n  state.window.recv.setMax(size);\n  var delta = state.window.recv.getDelta();\n\n  if (delta === 0) {\n    return;\n  }\n\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  });\n  state.window.recv.update(delta);\n};\n\nStream.prototype.sendHeaders = function sendHeaders(headers, callback) {\n  var self = this;\n  var state = this._spdyState;\n  state.timeout.reset();\n\n  if (!this._checkEnded(callback)) {\n    return;\n  } // Request wasn't yet send, coalesce headers\n\n\n  if (!state.sent) {\n    this.headers = Object.assign({}, this.headers);\n    Object.assign(this.headers, headers);\n    process.nextTick(function () {\n      if (callback) {\n        callback(null);\n      }\n    });\n    return;\n  }\n\n  this._hardCork();\n\n  state.framer.headersFrame({\n    id: this.id,\n    headers: headers\n  }, function (err) {\n    self._hardUncork();\n\n    if (callback) {\n      callback(err);\n    }\n  });\n};\n\nStream.prototype._destroy = function destroy() {\n  this.abort();\n};\n\nStream.prototype.abort = function abort(code, callback) {\n  var state = this._spdyState; // .abort(callback)\n\n  if (typeof code === 'function') {\n    callback = code;\n    code = null;\n  }\n\n  if (this._readableState.ended && this._writableState.finished) {\n    state.debug('id=%d already closed', this.id);\n\n    if (callback) {\n      process.nextTick(callback);\n    }\n\n    return;\n  }\n\n  if (state.aborted) {\n    state.debug('id=%d already aborted', this.id);\n\n    if (callback) {\n      process.nextTick(callback);\n    }\n\n    return;\n  }\n\n  state.aborted = true;\n  state.debug('id=%d abort', this.id);\n  this.setTimeout(0);\n  var abortCode = code || 'CANCEL';\n  state.framer.rstFrame({\n    id: this.id,\n    code: abortCode\n  });\n  var self = this;\n  process.nextTick(function () {\n    if (callback) {\n      callback(null);\n    }\n\n    self.emit('close', new Error('Aborted, code: ' + abortCode));\n  });\n};\n\nStream.prototype.setPriority = function setPriority(info) {\n  var state = this._spdyState;\n  state.timeout.reset();\n\n  if (!this._checkEnded()) {\n    return;\n  }\n\n  state.debug('id=%d priority change', this.id, info);\n  var frame = {\n    id: this.id,\n    priority: info\n  }; // Change priority on this side\n\n  this._handlePriority(frame); // And on the other too\n\n\n  state.framer.priorityFrame(frame);\n};\n\nStream.prototype.pushPromise = function pushPromise(uri, callback) {\n  if (!this._checkEnded(callback)) {\n    return;\n  }\n\n  var self = this;\n\n  this._hardCork();\n\n  var push = this.connection.pushPromise(this, uri, function (err) {\n    self._hardUncork();\n\n    if (!err) {\n      push._hardUncork();\n    }\n\n    if (callback) {\n      return callback(err, push);\n    }\n\n    if (err) {\n      push.emit('error', err);\n    }\n  });\n\n  push._hardCork();\n\n  return push;\n};\n\nStream.prototype.setMaxChunk = function setMaxChunk(size) {\n  var state = this._spdyState;\n  state.maxChunk = size;\n};\n\nStream.prototype.setTimeout = function setTimeout(delay, callback) {\n  var state = this._spdyState;\n  state.timeout.set(delay, callback);\n};","map":{"version":3,"names":["transport","require","assert","util","debug","client","server","Duplex","Stream","connection","options","call","connectionState","_spdyState","state","id","method","path","host","headers","parent","socket","protocol","constants","priority","version","getVersion","isServer","framer","parser","request","needResponse","window","streamWindow","clone","sessionWindow","maxChunk","sent","readable","writable","aborted","corked","corkQueue","timeout","utils","Timeout","on","_onFinish","_onEnd","self","_onWindowOverflow","recv","send","_initPriority","push","_writableState","ended","finished","inherits","exports","prototype","_init","root","priorityRoot","addDefault","add","weight","exclusive","_handleFrame","frame","type","reset","_handleData","_handleHeaders","_handleRST","_handleWindowUpdate","_handlePriority","_handlePushPromise","fin","checkAborted","stream","callback","process","nextTick","Error","_send","data","length","update","dataFrame","getPriority","err","_write","enc","_splitStart","onChunk","_split","offset","local","session","availSession","Math","max","getCurrent","getMax","availLocal","avail","min","limit","size","chunk","slice","_read","isDraining","delta","getDelta","windowUpdateFrame","_readableState","rstFrame","code","emit","abort","remove","_handleResponse","undefined","Buffer","alloc","_maybeClose","_checkEnded","set","_createStream","promisedId","_isGoaway","_hardCork","cork","_hardUncork","uncork","queue","i","_sendPush","status","response","pushFrame","toJSON","_wasSent","requestFrame","respond","responseFrame","setWindow","setMax","sendHeaders","Object","assign","headersFrame","_destroy","destroy","setTimeout","abortCode","setPriority","info","priorityFrame","pushPromise","uri","setMaxChunk","delay"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/spdy-transport/lib/spdy-transport/stream.js"],"sourcesContent":["'use strict'\n\nvar transport = require('../spdy-transport')\n\nvar assert = require('assert')\nvar util = require('util')\n\nvar debug = {\n  client: require('debug')('spdy:stream:client'),\n  server: require('debug')('spdy:stream:server')\n}\nvar Duplex = require('readable-stream').Duplex\n\nfunction Stream (connection, options) {\n  Duplex.call(this)\n\n  var connectionState = connection._spdyState\n\n  var state = {}\n  this._spdyState = state\n\n  this.id = options.id\n  this.method = options.method\n  this.path = options.path\n  this.host = options.host\n  this.headers = options.headers || {}\n  this.connection = connection\n  this.parent = options.parent || null\n\n  state.socket = null\n  state.protocol = connectionState.protocol\n  state.constants = state.protocol.constants\n\n  // See _initPriority()\n  state.priority = null\n\n  state.version = this.connection.getVersion()\n  state.isServer = this.connection.isServer()\n  state.debug = state.isServer ? debug.server : debug.client\n\n  state.framer = connectionState.framer\n  state.parser = connectionState.parser\n\n  state.request = options.request\n  state.needResponse = options.request\n  state.window = connectionState.streamWindow.clone(options.id)\n  state.sessionWindow = connectionState.window\n  state.maxChunk = connectionState.maxChunk\n\n  // Can't send incoming request\n  // (See `.send()` method)\n  state.sent = !state.request\n\n  state.readable = options.readable !== false\n  state.writable = options.writable !== false\n\n  state.aborted = false\n\n  state.corked = 0\n  state.corkQueue = []\n\n  state.timeout = new transport.utils.Timeout(this)\n\n  this.on('finish', this._onFinish)\n  this.on('end', this._onEnd)\n\n  var self = this\n  function _onWindowOverflow () {\n    self._onWindowOverflow()\n  }\n\n  state.window.recv.on('overflow', _onWindowOverflow)\n  state.window.send.on('overflow', _onWindowOverflow)\n\n  this._initPriority(options.priority)\n\n  if (!state.readable) { this.push(null) }\n  if (!state.writable) {\n    this._writableState.ended = true\n    this._writableState.finished = true\n  }\n}\nutil.inherits(Stream, Duplex)\nexports.Stream = Stream\n\nStream.prototype._init = function _init (socket) {\n  this.socket = socket\n}\n\nStream.prototype._initPriority = function _initPriority (priority) {\n  var state = this._spdyState\n  var connectionState = this.connection._spdyState\n  var root = connectionState.priorityRoot\n\n  if (!priority) {\n    state.priority = root.addDefault(this.id)\n    return\n  }\n\n  state.priority = root.add({\n    id: this.id,\n    parent: priority.parent,\n    weight: priority.weight,\n    exclusive: priority.exclusive\n  })\n}\n\nStream.prototype._handleFrame = function _handleFrame (frame) {\n  var state = this._spdyState\n\n  // Ignore any kind of data after abort\n  if (state.aborted) {\n    state.debug('id=%d ignoring frame=%s after abort', this.id, frame.type)\n    return\n  }\n\n  // Restart the timer on incoming frames\n  state.timeout.reset()\n\n  if (frame.type === 'DATA') {\n    this._handleData(frame)\n  } else if (frame.type === 'HEADERS') {\n    this._handleHeaders(frame)\n  } else if (frame.type === 'RST') {\n    this._handleRST(frame)\n  } else if (frame.type === 'WINDOW_UPDATE') { this._handleWindowUpdate(frame) } else if (frame.type === 'PRIORITY') {\n    this._handlePriority(frame)\n  } else if (frame.type === 'PUSH_PROMISE') { this._handlePushPromise(frame) }\n\n  if (frame.fin) {\n    state.debug('id=%d end', this.id)\n    this.push(null)\n  }\n}\n\nfunction checkAborted (stream, state, callback) {\n  if (state.aborted) {\n    state.debug('id=%d abort write', stream.id)\n    process.nextTick(function () {\n      callback(new Error('Stream write aborted'))\n    })\n    return true\n  }\n\n  return false\n}\n\nfunction _send (stream, state, data, callback) {\n  if (checkAborted(stream, state, callback)) {\n    return\n  }\n\n  state.debug('id=%d presend=%d', stream.id, data.length)\n\n  state.timeout.reset()\n\n  state.window.send.update(-data.length, function () {\n    if (checkAborted(stream, state, callback)) {\n      return\n    }\n\n    state.debug('id=%d send=%d', stream.id, data.length)\n\n    state.timeout.reset()\n\n    state.framer.dataFrame({\n      id: stream.id,\n      priority: state.priority.getPriority(),\n      fin: false,\n      data: data\n    }, function (err) {\n      state.debug('id=%d postsend=%d', stream.id, data.length)\n      callback(err)\n    })\n  })\n}\n\nStream.prototype._write = function _write (data, enc, callback) {\n  var state = this._spdyState\n\n  // Send the request if it wasn't sent\n  if (!state.sent) { this.send() }\n\n  // Writes should come after pending control frames (response and headers)\n  if (state.corked !== 0) {\n    var self = this\n    state.corkQueue.push(function () {\n      self._write(data, enc, callback)\n    })\n    return\n  }\n\n  // Split DATA in chunks to prevent window from going negative\n  this._splitStart(data, _send, callback)\n}\n\nStream.prototype._splitStart = function _splitStart (data, onChunk, callback) {\n  return this._split(data, 0, onChunk, callback)\n}\n\nStream.prototype._split = function _split (data, offset, onChunk, callback) {\n  if (offset === data.length) {\n    return process.nextTick(callback)\n  }\n\n  var state = this._spdyState\n  var local = state.window.send\n  var session = state.sessionWindow.send\n\n  var availSession = Math.max(0, session.getCurrent())\n  if (availSession === 0) {\n    availSession = session.getMax()\n  }\n  var availLocal = Math.max(0, local.getCurrent())\n  if (availLocal === 0) {\n    availLocal = local.getMax()\n  }\n\n  var avail = Math.min(availSession, availLocal)\n  avail = Math.min(avail, state.maxChunk)\n\n  var self = this\n\n  if (avail === 0) {\n    state.window.send.update(0, function () {\n      self._split(data, offset, onChunk, callback)\n    })\n    return\n  }\n\n  // Split data in chunks in a following way:\n  var limit = avail\n  var size = Math.min(data.length - offset, limit)\n\n  var chunk = data.slice(offset, offset + size)\n\n  onChunk(this, state, chunk, function (err) {\n    if (err) { return callback(err) }\n\n    // Get the next chunk\n    self._split(data, offset + size, onChunk, callback)\n  })\n}\n\nStream.prototype._read = function _read () {\n  var state = this._spdyState\n\n  if (!state.window.recv.isDraining()) {\n    return\n  }\n\n  var delta = state.window.recv.getDelta()\n\n  state.debug('id=%d window emptying, update by %d', this.id, delta)\n\n  state.window.recv.update(delta)\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  })\n}\n\nStream.prototype._handleData = function _handleData (frame) {\n  var state = this._spdyState\n\n  // DATA on ended or not readable stream!\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({ id: this.id, code: 'STREAM_CLOSED' })\n    return\n  }\n\n  state.debug('id=%d recv=%d', this.id, frame.data.length)\n  state.window.recv.update(-frame.data.length)\n\n  this.push(frame.data)\n}\n\nStream.prototype._handleRST = function _handleRST (frame) {\n  if (frame.code !== 'CANCEL') {\n    this.emit('error', new Error('Got RST: ' + frame.code))\n  }\n  this.abort()\n}\n\nStream.prototype._handleWindowUpdate = function _handleWindowUpdate (frame) {\n  var state = this._spdyState\n\n  state.window.send.update(frame.delta)\n}\n\nStream.prototype._onWindowOverflow = function _onWindowOverflow () {\n  var state = this._spdyState\n\n  state.debug('id=%d window overflow', this.id)\n  state.framer.rstFrame({ id: this.id, code: 'FLOW_CONTROL_ERROR' })\n\n  this.aborted = true\n  this.emit('error', new Error('HTTP2 window overflow'))\n}\n\nStream.prototype._handlePriority = function _handlePriority (frame) {\n  var state = this._spdyState\n\n  state.priority.remove()\n  state.priority = null\n  this._initPriority(frame.priority)\n\n  // Mostly for testing purposes\n  this.emit('priority', frame.priority)\n}\n\nStream.prototype._handleHeaders = function _handleHeaders (frame) {\n  var state = this._spdyState\n\n  if (!state.readable || this._readableState.ended) {\n    state.framer.rstFrame({ id: this.id, code: 'STREAM_CLOSED' })\n    return\n  }\n\n  if (state.needResponse) {\n    return this._handleResponse(frame)\n  }\n\n  this.emit('headers', frame.headers)\n}\n\nStream.prototype._handleResponse = function _handleResponse (frame) {\n  var state = this._spdyState\n\n  if (frame.headers[':status'] === undefined) {\n    state.framer.rstFrame({ id: this.id, code: 'PROTOCOL_ERROR' })\n    return\n  }\n\n  state.needResponse = false\n  this.emit('response', frame.headers[':status'] | 0, frame.headers)\n}\n\nStream.prototype._onFinish = function _onFinish () {\n  var state = this._spdyState\n\n  // Send the request if it wasn't sent\n  if (!state.sent) {\n    // NOTE: will send HEADERS with FIN flag\n    this.send()\n  } else {\n    // Just an `.end()` without any writes will trigger immediate `finish` event\n    // without any calls to `_write()`.\n    if (state.corked !== 0) {\n      var self = this\n      state.corkQueue.push(function () {\n        self._onFinish()\n      })\n      return\n    }\n\n    state.framer.dataFrame({\n      id: this.id,\n      priority: state.priority.getPriority(),\n      fin: true,\n      data: Buffer.alloc(0)\n    })\n  }\n\n  this._maybeClose()\n}\n\nStream.prototype._onEnd = function _onEnd () {\n  this._maybeClose()\n}\n\nStream.prototype._checkEnded = function _checkEnded (callback) {\n  var state = this._spdyState\n\n  var ended = false\n  if (state.aborted) { ended = true }\n\n  if (!state.writable || this._writableState.finished) { ended = true }\n\n  if (!ended) {\n    return true\n  }\n\n  if (!callback) {\n    return false\n  }\n\n  var err = new Error('Ended stream can\\'t send frames')\n  process.nextTick(function () {\n    callback(err)\n  })\n\n  return false\n}\n\nStream.prototype._maybeClose = function _maybeClose () {\n  var state = this._spdyState\n\n  // .abort() emits `close`\n  if (state.aborted) {\n    return\n  }\n\n  if ((!state.readable || this._readableState.ended) &&\n      this._writableState.finished) {\n    // Clear timeout\n    state.timeout.set(0)\n\n    this.emit('close')\n  }\n}\n\nStream.prototype._handlePushPromise = function _handlePushPromise (frame) {\n  var push = this.connection._createStream({\n    id: frame.promisedId,\n    parent: this,\n    push: true,\n    request: true,\n    method: frame.headers[':method'],\n    path: frame.headers[':path'],\n    host: frame.headers[':authority'],\n    priority: frame.priority,\n    headers: frame.headers,\n    writable: false\n  })\n\n  // GOAWAY\n  if (this.connection._isGoaway(push.id)) {\n    return\n  }\n\n  if (!this.emit('pushPromise', push)) {\n    push.abort()\n  }\n}\n\nStream.prototype._hardCork = function _hardCork () {\n  var state = this._spdyState\n\n  this.cork()\n  state.corked++\n}\n\nStream.prototype._hardUncork = function _hardUncork () {\n  var state = this._spdyState\n\n  this.uncork()\n  state.corked--\n  if (state.corked !== 0) {\n    return\n  }\n\n  // Invoke callbacks\n  var queue = state.corkQueue\n  state.corkQueue = []\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n}\n\nStream.prototype._sendPush = function _sendPush (status, response, callback) {\n  var self = this\n  var state = this._spdyState\n\n  this._hardCork()\n  state.framer.pushFrame({\n    id: this.parent.id,\n    promisedId: this.id,\n    priority: state.priority.toJSON(),\n    path: this.path,\n    host: this.host,\n    method: this.method,\n    status: status,\n    headers: this.headers,\n    response: response\n  }, function (err) {\n    self._hardUncork()\n\n    callback(err)\n  })\n}\n\nStream.prototype._wasSent = function _wasSent () {\n  var state = this._spdyState\n  return state.sent\n}\n\n// Public API\n\nStream.prototype.send = function send (callback) {\n  var state = this._spdyState\n\n  if (state.sent) {\n    var err = new Error('Stream was already sent')\n    process.nextTick(function () {\n      if (callback) {\n        callback(err)\n      }\n    })\n    return\n  }\n\n  state.sent = true\n  state.timeout.reset()\n\n  // GET requests should always be auto-finished\n  if (this.method === 'GET') {\n    this._writableState.ended = true\n    this._writableState.finished = true\n  }\n\n  // TODO(indunty): ideally it should just take a stream object as an input\n  var self = this\n  this._hardCork()\n  state.framer.requestFrame({\n    id: this.id,\n    method: this.method,\n    path: this.path,\n    host: this.host,\n    priority: state.priority.toJSON(),\n    headers: this.headers,\n    fin: this._writableState.finished\n  }, function (err) {\n    self._hardUncork()\n\n    if (!callback) {\n      return\n    }\n\n    callback(err)\n  })\n}\n\nStream.prototype.respond = function respond (status, headers, callback) {\n  var self = this\n  var state = this._spdyState\n  assert(!state.request, 'Can\\'t respond on request')\n\n  state.timeout.reset()\n\n  if (!this._checkEnded(callback)) { return }\n\n  var frame = {\n    id: this.id,\n    status: status,\n    headers: headers\n  }\n  this._hardCork()\n  state.framer.responseFrame(frame, function (err) {\n    self._hardUncork()\n    if (callback) { callback(err) }\n  })\n}\n\nStream.prototype.setWindow = function setWindow (size) {\n  var state = this._spdyState\n\n  state.timeout.reset()\n\n  if (!this._checkEnded()) {\n    return\n  }\n\n  state.debug('id=%d force window max=%d', this.id, size)\n  state.window.recv.setMax(size)\n\n  var delta = state.window.recv.getDelta()\n  if (delta === 0) { return }\n\n  state.framer.windowUpdateFrame({\n    id: this.id,\n    delta: delta\n  })\n  state.window.recv.update(delta)\n}\n\nStream.prototype.sendHeaders = function sendHeaders (headers, callback) {\n  var self = this\n  var state = this._spdyState\n\n  state.timeout.reset()\n\n  if (!this._checkEnded(callback)) {\n    return\n  }\n\n  // Request wasn't yet send, coalesce headers\n  if (!state.sent) {\n    this.headers = Object.assign({}, this.headers)\n    Object.assign(this.headers, headers)\n    process.nextTick(function () {\n      if (callback) {\n        callback(null)\n      }\n    })\n    return\n  }\n\n  this._hardCork()\n  state.framer.headersFrame({\n    id: this.id,\n    headers: headers\n  }, function (err) {\n    self._hardUncork()\n    if (callback) { callback(err) }\n  })\n}\n\nStream.prototype._destroy = function destroy () {\n  this.abort()\n}\n\nStream.prototype.abort = function abort (code, callback) {\n  var state = this._spdyState\n\n  // .abort(callback)\n  if (typeof code === 'function') {\n    callback = code\n    code = null\n  }\n\n  if (this._readableState.ended && this._writableState.finished) {\n    state.debug('id=%d already closed', this.id)\n    if (callback) {\n      process.nextTick(callback)\n    }\n    return\n  }\n\n  if (state.aborted) {\n    state.debug('id=%d already aborted', this.id)\n    if (callback) { process.nextTick(callback) }\n    return\n  }\n\n  state.aborted = true\n  state.debug('id=%d abort', this.id)\n\n  this.setTimeout(0)\n\n  var abortCode = code || 'CANCEL'\n\n  state.framer.rstFrame({\n    id: this.id,\n    code: abortCode\n  })\n\n  var self = this\n  process.nextTick(function () {\n    if (callback) {\n      callback(null)\n    }\n    self.emit('close', new Error('Aborted, code: ' + abortCode))\n  })\n}\n\nStream.prototype.setPriority = function setPriority (info) {\n  var state = this._spdyState\n\n  state.timeout.reset()\n\n  if (!this._checkEnded()) {\n    return\n  }\n\n  state.debug('id=%d priority change', this.id, info)\n\n  var frame = { id: this.id, priority: info }\n\n  // Change priority on this side\n  this._handlePriority(frame)\n\n  // And on the other too\n  state.framer.priorityFrame(frame)\n}\n\nStream.prototype.pushPromise = function pushPromise (uri, callback) {\n  if (!this._checkEnded(callback)) {\n    return\n  }\n\n  var self = this\n  this._hardCork()\n  var push = this.connection.pushPromise(this, uri, function (err) {\n    self._hardUncork()\n    if (!err) {\n      push._hardUncork()\n    }\n\n    if (callback) {\n      return callback(err, push)\n    }\n\n    if (err) { push.emit('error', err) }\n  })\n  push._hardCork()\n\n  return push\n}\n\nStream.prototype.setMaxChunk = function setMaxChunk (size) {\n  var state = this._spdyState\n  state.maxChunk = size\n}\n\nStream.prototype.setTimeout = function setTimeout (delay, callback) {\n  var state = this._spdyState\n\n  state.timeout.set(delay, callback)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}