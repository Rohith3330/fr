{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPresetChain = buildPresetChain;\nexports.buildPresetChainWalker = void 0;\nexports.buildRootChain = buildRootChain;\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  const data = require(\"debug\");\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _options = require(\"./validation/options\");\n\nvar _patternToRegex = require(\"./pattern-to-regex\");\n\nvar _printer = require(\"./printer\");\n\nvar _rewriteStackTrace = require(\"../errors/rewrite-stack-trace\");\n\nvar _configError = require(\"../errors/config-error\");\n\nvar _files = require(\"./files\");\n\nvar _caching = require(\"./caching\");\n\nvar _configDescriptors = require(\"./config-descriptors\");\n\nconst debug = _debug()(\"babel:config:config-chain\");\n\nfunction* buildPresetChain(arg, context) {\n  const chain = yield* buildPresetChainWalker(arg, context);\n  if (!chain) return null;\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o)),\n    files: new Set()\n  };\n}\n\nconst buildPresetChainWalker = makeChainWalker({\n  root: preset => loadPresetDescriptors(preset),\n  env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),\n  overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),\n  overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName),\n  createLogger: () => () => {}\n});\nexports.buildPresetChainWalker = buildPresetChainWalker;\nconst loadPresetDescriptors = (0, _caching.makeWeakCacheSync)(preset => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors));\nconst loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index)));\nconst loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));\n\nfunction* buildRootChain(opts, context) {\n  let configReport, babelRcReport;\n  const programmaticLogger = new _printer.ConfigPrinter();\n  const programmaticChain = yield* loadProgrammaticChain({\n    options: opts,\n    dirname: context.cwd\n  }, context, undefined, programmaticLogger);\n  if (!programmaticChain) return null;\n  const programmaticReport = yield* programmaticLogger.output();\n  let configFile;\n\n  if (typeof opts.configFile === \"string\") {\n    configFile = yield* (0, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);\n  } else if (opts.configFile !== false) {\n    configFile = yield* (0, _files.findRootConfig)(context.root, context.envName, context.caller);\n  }\n\n  let {\n    babelrc,\n    babelrcRoots\n  } = opts;\n  let babelrcRootsDirectory = context.cwd;\n  const configFileChain = emptyChain();\n  const configFileLogger = new _printer.ConfigPrinter();\n\n  if (configFile) {\n    const validatedFile = validateConfigFile(configFile);\n    const result = yield* loadFileChain(validatedFile, context, undefined, configFileLogger);\n    if (!result) return null;\n    configReport = yield* configFileLogger.output();\n\n    if (babelrc === undefined) {\n      babelrc = validatedFile.options.babelrc;\n    }\n\n    if (babelrcRoots === undefined) {\n      babelrcRootsDirectory = validatedFile.dirname;\n      babelrcRoots = validatedFile.options.babelrcRoots;\n    }\n\n    mergeChain(configFileChain, result);\n  }\n\n  let ignoreFile, babelrcFile;\n  let isIgnored = false;\n  const fileChain = emptyChain();\n\n  if ((babelrc === true || babelrc === undefined) && typeof context.filename === \"string\") {\n    const pkgData = yield* (0, _files.findPackageData)(context.filename);\n\n    if (pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {\n      ({\n        ignore: ignoreFile,\n        config: babelrcFile\n      } = yield* (0, _files.findRelativeConfig)(pkgData, context.envName, context.caller));\n\n      if (ignoreFile) {\n        fileChain.files.add(ignoreFile.filepath);\n      }\n\n      if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {\n        isIgnored = true;\n      }\n\n      if (babelrcFile && !isIgnored) {\n        const validatedFile = validateBabelrcFile(babelrcFile);\n        const babelrcLogger = new _printer.ConfigPrinter();\n        const result = yield* loadFileChain(validatedFile, context, undefined, babelrcLogger);\n\n        if (!result) {\n          isIgnored = true;\n        } else {\n          babelRcReport = yield* babelrcLogger.output();\n          mergeChain(fileChain, result);\n        }\n      }\n\n      if (babelrcFile && isIgnored) {\n        fileChain.files.add(babelrcFile.filepath);\n      }\n    }\n  }\n\n  if (context.showConfig) {\n    console.log(`Babel configs on \"${context.filename}\" (ascending priority):\\n` + [configReport, babelRcReport, programmaticReport].filter(x => !!x).join(\"\\n\\n\") + \"\\n-----End Babel configs-----\");\n  }\n\n  const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);\n  return {\n    plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),\n    presets: isIgnored ? [] : dedupDescriptors(chain.presets),\n    options: isIgnored ? [] : chain.options.map(o => normalizeOptions(o)),\n    fileHandling: isIgnored ? \"ignored\" : \"transpile\",\n    ignore: ignoreFile || undefined,\n    babelrc: babelrcFile || undefined,\n    config: configFile || undefined,\n    files: chain.files\n  };\n}\n\nfunction babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {\n  if (typeof babelrcRoots === \"boolean\") return babelrcRoots;\n  const absoluteRoot = context.root;\n\n  if (babelrcRoots === undefined) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  let babelrcPatterns = babelrcRoots;\n\n  if (!Array.isArray(babelrcPatterns)) {\n    babelrcPatterns = [babelrcPatterns];\n  }\n\n  babelrcPatterns = babelrcPatterns.map(pat => {\n    return typeof pat === \"string\" ? _path().resolve(babelrcRootsDirectory, pat) : pat;\n  });\n\n  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  return babelrcPatterns.some(pat => {\n    if (typeof pat === \"string\") {\n      pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);\n    }\n\n    return pkgData.directories.some(directory => {\n      return matchPattern(pat, babelrcRootsDirectory, directory, context);\n    });\n  });\n}\n\nconst validateConfigFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"configfile\", file.options, file.filepath)\n}));\nconst validateBabelrcFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"babelrcfile\", file.options, file.filepath)\n}));\nconst validateExtendFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"extendsfile\", file.options, file.filepath)\n}));\nconst loadProgrammaticChain = makeChainWalker({\n  root: input => buildRootDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors),\n  env: (input, envName) => buildEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, envName),\n  overrides: (input, index) => buildOverrideDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index),\n  overridesEnv: (input, index, envName) => buildOverrideEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index, envName),\n  createLogger: (input, context, baseLogger) => buildProgrammaticLogger(input, context, baseLogger)\n});\nconst loadFileChainWalker = makeChainWalker({\n  root: file => loadFileDescriptors(file),\n  env: (file, envName) => loadFileEnvDescriptors(file)(envName),\n  overrides: (file, index) => loadFileOverridesDescriptors(file)(index),\n  overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName),\n  createLogger: (file, context, baseLogger) => buildFileLogger(file.filepath, context, baseLogger)\n});\n\nfunction* loadFileChain(input, context, files, baseLogger) {\n  const chain = yield* loadFileChainWalker(input, context, files, baseLogger);\n\n  if (chain) {\n    chain.files.add(input.filepath);\n  }\n\n  return chain;\n}\n\nconst loadFileDescriptors = (0, _caching.makeWeakCacheSync)(file => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors));\nconst loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index)));\nconst loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));\n\nfunction buildFileLogger(filepath, context, baseLogger) {\n  if (!baseLogger) {\n    return () => {};\n  }\n\n  return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Config, {\n    filepath\n  });\n}\n\nfunction buildRootDescriptors(_ref, alias, descriptors) {\n  let {\n    dirname,\n    options\n  } = _ref;\n  return descriptors(dirname, options, alias);\n}\n\nfunction buildProgrammaticLogger(_, context, baseLogger) {\n  var _context$caller;\n\n  if (!baseLogger) {\n    return () => {};\n  }\n\n  return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Programmatic, {\n    callerName: (_context$caller = context.caller) == null ? void 0 : _context$caller.name\n  });\n}\n\nfunction buildEnvDescriptors(_ref2, alias, descriptors, envName) {\n  let {\n    dirname,\n    options\n  } = _ref2;\n  const opts = options.env && options.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.env[\"${envName}\"]`) : null;\n}\n\nfunction buildOverrideDescriptors(_ref3, alias, descriptors, index) {\n  let {\n    dirname,\n    options\n  } = _ref3;\n  const opts = options.overrides && options.overrides[index];\n  if (!opts) throw new Error(\"Assertion failure - missing override\");\n  return descriptors(dirname, opts, `${alias}.overrides[${index}]`);\n}\n\nfunction buildOverrideEnvDescriptors(_ref4, alias, descriptors, index, envName) {\n  let {\n    dirname,\n    options\n  } = _ref4;\n  const override = options.overrides && options.overrides[index];\n  if (!override) throw new Error(\"Assertion failure - missing override\");\n  const opts = override.env && override.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.overrides[${index}].env[\"${envName}\"]`) : null;\n}\n\nfunction makeChainWalker(_ref5) {\n  let {\n    root,\n    env,\n    overrides,\n    overridesEnv,\n    createLogger\n  } = _ref5;\n  return function* chainWalker(input, context) {\n    let files = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    let baseLogger = arguments.length > 3 ? arguments[3] : undefined;\n    const {\n      dirname\n    } = input;\n    const flattenedConfigs = [];\n    const rootOpts = root(input);\n\n    if (configIsApplicable(rootOpts, dirname, context, input.filepath)) {\n      flattenedConfigs.push({\n        config: rootOpts,\n        envName: undefined,\n        index: undefined\n      });\n      const envOpts = env(input, context.envName);\n\n      if (envOpts && configIsApplicable(envOpts, dirname, context, input.filepath)) {\n        flattenedConfigs.push({\n          config: envOpts,\n          envName: context.envName,\n          index: undefined\n        });\n      }\n\n      (rootOpts.options.overrides || []).forEach((_, index) => {\n        const overrideOps = overrides(input, index);\n\n        if (configIsApplicable(overrideOps, dirname, context, input.filepath)) {\n          flattenedConfigs.push({\n            config: overrideOps,\n            index,\n            envName: undefined\n          });\n          const overrideEnvOpts = overridesEnv(input, index, context.envName);\n\n          if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context, input.filepath)) {\n            flattenedConfigs.push({\n              config: overrideEnvOpts,\n              index,\n              envName: context.envName\n            });\n          }\n        }\n      });\n    }\n\n    if (flattenedConfigs.some(_ref6 => {\n      let {\n        config: {\n          options: {\n            ignore,\n            only\n          }\n        }\n      } = _ref6;\n      return shouldIgnore(context, ignore, only, dirname);\n    })) {\n      return null;\n    }\n\n    const chain = emptyChain();\n    const logger = createLogger(input, context, baseLogger);\n\n    for (const {\n      config,\n      index,\n      envName\n    } of flattenedConfigs) {\n      if (!(yield* mergeExtendsChain(chain, config.options, dirname, context, files, baseLogger))) {\n        return null;\n      }\n\n      logger(config, index, envName);\n      yield* mergeChainOpts(chain, config);\n    }\n\n    return chain;\n  };\n}\n\nfunction* mergeExtendsChain(chain, opts, dirname, context, files, baseLogger) {\n  if (opts.extends === undefined) return true;\n  const file = yield* (0, _files.loadConfig)(opts.extends, dirname, context.envName, context.caller);\n\n  if (files.has(file)) {\n    throw new Error(`Configuration cycle detected loading ${file.filepath}.\\n` + `File already loaded following the config chain:\\n` + Array.from(files, file => ` - ${file.filepath}`).join(\"\\n\"));\n  }\n\n  files.add(file);\n  const fileChain = yield* loadFileChain(validateExtendFile(file), context, files, baseLogger);\n  files.delete(file);\n  if (!fileChain) return false;\n  mergeChain(chain, fileChain);\n  return true;\n}\n\nfunction mergeChain(target, source) {\n  target.options.push(...source.options);\n  target.plugins.push(...source.plugins);\n  target.presets.push(...source.presets);\n\n  for (const file of source.files) {\n    target.files.add(file);\n  }\n\n  return target;\n}\n\nfunction* mergeChainOpts(target, _ref7) {\n  let {\n    options,\n    plugins,\n    presets\n  } = _ref7;\n  target.options.push(options);\n  target.plugins.push(...(yield* plugins()));\n  target.presets.push(...(yield* presets()));\n  return target;\n}\n\nfunction emptyChain() {\n  return {\n    options: [],\n    presets: [],\n    plugins: [],\n    files: new Set()\n  };\n}\n\nfunction normalizeOptions(opts) {\n  const options = Object.assign({}, opts);\n  delete options.extends;\n  delete options.env;\n  delete options.overrides;\n  delete options.plugins;\n  delete options.presets;\n  delete options.passPerPreset;\n  delete options.ignore;\n  delete options.only;\n  delete options.test;\n  delete options.include;\n  delete options.exclude;\n\n  if (Object.prototype.hasOwnProperty.call(options, \"sourceMap\")) {\n    options.sourceMaps = options.sourceMap;\n    delete options.sourceMap;\n  }\n\n  return options;\n}\n\nfunction dedupDescriptors(items) {\n  const map = new Map();\n  const descriptors = [];\n\n  for (const item of items) {\n    if (typeof item.value === \"function\") {\n      const fnKey = item.value;\n      let nameMap = map.get(fnKey);\n\n      if (!nameMap) {\n        nameMap = new Map();\n        map.set(fnKey, nameMap);\n      }\n\n      let desc = nameMap.get(item.name);\n\n      if (!desc) {\n        desc = {\n          value: item\n        };\n        descriptors.push(desc);\n        if (!item.ownPass) nameMap.set(item.name, desc);\n      } else {\n        desc.value = item;\n      }\n    } else {\n      descriptors.push({\n        value: item\n      });\n    }\n  }\n\n  return descriptors.reduce((acc, desc) => {\n    acc.push(desc.value);\n    return acc;\n  }, []);\n}\n\nfunction configIsApplicable(_ref8, dirname, context, configName) {\n  let {\n    options\n  } = _ref8;\n  return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname, configName)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname, configName)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname, configName));\n}\n\nfunction configFieldIsApplicable(context, test, dirname, configName) {\n  const patterns = Array.isArray(test) ? test : [test];\n  return matchesPatterns(context, patterns, dirname, configName);\n}\n\nfunction ignoreListReplacer(_key, value) {\n  if (value instanceof RegExp) {\n    return String(value);\n  }\n\n  return value;\n}\n\nfunction shouldIgnore(context, ignore, only, dirname) {\n  if (ignore && matchesPatterns(context, ignore, dirname)) {\n    var _context$filename;\n\n    const message = `No config is applied to \"${(_context$filename = context.filename) != null ? _context$filename : \"(unknown)\"}\" because it matches one of \\`ignore: ${JSON.stringify(ignore, ignoreListReplacer)}\\` from \"${dirname}\"`;\n    debug(message);\n\n    if (context.showConfig) {\n      console.log(message);\n    }\n\n    return true;\n  }\n\n  if (only && !matchesPatterns(context, only, dirname)) {\n    var _context$filename2;\n\n    const message = `No config is applied to \"${(_context$filename2 = context.filename) != null ? _context$filename2 : \"(unknown)\"}\" because it fails to match one of \\`only: ${JSON.stringify(only, ignoreListReplacer)}\\` from \"${dirname}\"`;\n    debug(message);\n\n    if (context.showConfig) {\n      console.log(message);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction matchesPatterns(context, patterns, dirname, configName) {\n  return patterns.some(pattern => matchPattern(pattern, dirname, context.filename, context, configName));\n}\n\nfunction matchPattern(pattern, dirname, pathToTest, context, configName) {\n  if (typeof pattern === \"function\") {\n    return !!(0, _rewriteStackTrace.endHiddenCallStack)(pattern)(pathToTest, {\n      dirname,\n      envName: context.envName,\n      caller: context.caller\n    });\n  }\n\n  if (typeof pathToTest !== \"string\") {\n    throw new _configError.default(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`, configName);\n  }\n\n  if (typeof pattern === \"string\") {\n    pattern = (0, _patternToRegex.default)(pattern, dirname);\n  }\n\n  return pattern.test(pathToTest);\n}\n\n0 && 0;","map":{"version":3,"mappings":"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","names":["_path","_debug","debug","buildDebug","buildPresetChain","arg","context","chain","buildPresetChainWalker","plugins","dedupDescriptors","presets","options","map","o","normalizeOptions","files","Set","makeChainWalker","root","preset","loadPresetDescriptors","env","envName","loadPresetEnvDescriptors","overrides","index","loadPresetOverridesDescriptors","overridesEnv","loadPresetOverridesEnvDescriptors","createLogger","buildRootDescriptors","alias","createUncachedDescriptors","buildEnvDescriptors","buildOverrideDescriptors","buildOverrideEnvDescriptors","buildRootChain","opts","configReport","babelRcReport","programmaticLogger","ConfigPrinter","programmaticChain","loadProgrammaticChain","dirname","cwd","undefined","programmaticReport","output","configFile","caller","babelrc","babelrcRoots","babelrcRootsDirectory","configFileChain","emptyChain","configFileLogger","validatedFile","validateConfigFile","result","loadFileChain","mergeChain","ignoreFile","babelrcFile","isIgnored","fileChain","filename","pkgData","babelrcLoadEnabled","ignore","config","add","filepath","shouldIgnore","validateBabelrcFile","babelrcLogger","showConfig","console","log","filter","x","join","fileHandling","absoluteRoot","directories","indexOf","babelrcPatterns","Array","isArray","pat","path","resolve","length","some","directory","matchPattern","file","validateExtendFile","input","createCachedDescriptors","baseLogger","buildProgrammaticLogger","loadFileChainWalker","loadFileDescriptors","loadFileEnvDescriptors","loadFileOverridesDescriptors","loadFileOverridesEnvDescriptors","buildFileLogger","configure","ChainFormatter","Config","descriptors","_","Programmatic","callerName","_context$caller","name","Error","override","chainWalker","flattenedConfigs","rootOpts","configIsApplicable","push","envOpts","forEach","overrideOps","overrideEnvOpts","only","logger","mergeExtendsChain","mergeChainOpts","extends","has","from","delete","target","source","passPerPreset","test","include","exclude","Object","prototype","hasOwnProperty","call","sourceMaps","sourceMap","items","Map","item","value","fnKey","nameMap","get","set","desc","ownPass","reduce","acc","configName","configFieldIsApplicable","patterns","matchesPatterns","ignoreListReplacer","_key","RegExp","String","message","JSON","stringify","pattern","pathToTest","ConfigError"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\config-chain.ts"],"sourcesContent":["import path from \"path\";\nimport buildDebug from \"debug\";\nimport type { Handler } from \"gensync\";\nimport { validate } from \"./validation/options\";\nimport type {\n  ValidatedOptions,\n  IgnoreList,\n  ConfigApplicableTest,\n  BabelrcSearch,\n  CallerMetadata,\n  IgnoreItem,\n} from \"./validation/options\";\nimport pathPatternToRegex from \"./pattern-to-regex\";\nimport { ConfigPrinter, ChainFormatter } from \"./printer\";\nimport type { ReadonlyDeepArray } from \"./helpers/deep-array\";\n\nimport { endHiddenCallStack } from \"../errors/rewrite-stack-trace\";\nimport ConfigError from \"../errors/config-error\";\n\nconst debug = buildDebug(\"babel:config:config-chain\");\n\nimport {\n  findPackageData,\n  findRelativeConfig,\n  findRootConfig,\n  loadConfig,\n} from \"./files\";\nimport type { ConfigFile, IgnoreFile, FilePackageData } from \"./files\";\n\nimport { makeWeakCacheSync, makeStrongCacheSync } from \"./caching\";\n\nimport {\n  createCachedDescriptors,\n  createUncachedDescriptors,\n} from \"./config-descriptors\";\nimport type {\n  UnloadedDescriptor,\n  OptionsAndDescriptors,\n  ValidatedFile,\n} from \"./config-descriptors\";\n\nexport type ConfigChain = {\n  plugins: Array<UnloadedDescriptor>;\n  presets: Array<UnloadedDescriptor>;\n  options: Array<ValidatedOptions>;\n  files: Set<string>;\n};\n\nexport type PresetInstance = {\n  options: ValidatedOptions;\n  alias: string;\n  dirname: string;\n  externalDependencies: ReadonlyDeepArray<string>;\n};\n\nexport type ConfigContext = {\n  filename: string | undefined;\n  cwd: string;\n  root: string;\n  envName: string;\n  caller: CallerMetadata | undefined;\n  showConfig: boolean;\n};\n\n/**\n * Build a config chain for a given preset.\n */\nexport function* buildPresetChain(\n  arg: PresetInstance,\n  context: any,\n): Handler<ConfigChain | null> {\n  const chain = yield* buildPresetChainWalker(arg, context);\n  if (!chain) return null;\n\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o)),\n    files: new Set(),\n  };\n}\n\nexport const buildPresetChainWalker = makeChainWalker<PresetInstance>({\n  root: preset => loadPresetDescriptors(preset),\n  env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),\n  overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),\n  overridesEnv: (preset, index, envName) =>\n    loadPresetOverridesEnvDescriptors(preset)(index)(envName),\n  createLogger: () => () => {}, // Currently we don't support logging how preset is expanded\n});\nconst loadPresetDescriptors = makeWeakCacheSync((preset: PresetInstance) =>\n  buildRootDescriptors(preset, preset.alias, createUncachedDescriptors),\n);\nconst loadPresetEnvDescriptors = makeWeakCacheSync((preset: PresetInstance) =>\n  makeStrongCacheSync((envName: string) =>\n    buildEnvDescriptors(\n      preset,\n      preset.alias,\n      createUncachedDescriptors,\n      envName,\n    ),\n  ),\n);\nconst loadPresetOverridesDescriptors = makeWeakCacheSync(\n  (preset: PresetInstance) =>\n    makeStrongCacheSync((index: number) =>\n      buildOverrideDescriptors(\n        preset,\n        preset.alias,\n        createUncachedDescriptors,\n        index,\n      ),\n    ),\n);\nconst loadPresetOverridesEnvDescriptors = makeWeakCacheSync(\n  (preset: PresetInstance) =>\n    makeStrongCacheSync((index: number) =>\n      makeStrongCacheSync((envName: string) =>\n        buildOverrideEnvDescriptors(\n          preset,\n          preset.alias,\n          createUncachedDescriptors,\n          index,\n          envName,\n        ),\n      ),\n    ),\n);\n\nexport type FileHandling = \"transpile\" | \"ignored\" | \"unsupported\";\nexport type RootConfigChain = ConfigChain & {\n  babelrc: ConfigFile | void;\n  config: ConfigFile | void;\n  ignore: IgnoreFile | void;\n  fileHandling: FileHandling;\n  files: Set<string>;\n};\n\n/**\n * Build a config chain for Babel's full root configuration.\n */\nexport function* buildRootChain(\n  opts: ValidatedOptions,\n  context: ConfigContext,\n): Handler<RootConfigChain | null> {\n  let configReport, babelRcReport;\n  const programmaticLogger = new ConfigPrinter();\n  const programmaticChain = yield* loadProgrammaticChain(\n    {\n      options: opts,\n      dirname: context.cwd,\n    },\n    context,\n    undefined,\n    programmaticLogger,\n  );\n  if (!programmaticChain) return null;\n  const programmaticReport = yield* programmaticLogger.output();\n\n  let configFile;\n  if (typeof opts.configFile === \"string\") {\n    configFile = yield* loadConfig(\n      opts.configFile,\n      context.cwd,\n      context.envName,\n      context.caller,\n    );\n  } else if (opts.configFile !== false) {\n    configFile = yield* findRootConfig(\n      context.root,\n      context.envName,\n      context.caller,\n    );\n  }\n\n  let { babelrc, babelrcRoots } = opts;\n  let babelrcRootsDirectory = context.cwd;\n\n  const configFileChain = emptyChain();\n  const configFileLogger = new ConfigPrinter();\n  if (configFile) {\n    const validatedFile = validateConfigFile(configFile);\n    const result = yield* loadFileChain(\n      validatedFile,\n      context,\n      undefined,\n      configFileLogger,\n    );\n    if (!result) return null;\n    configReport = yield* configFileLogger.output();\n\n    // Allow config files to toggle `.babelrc` resolution on and off and\n    // specify where the roots are.\n    if (babelrc === undefined) {\n      babelrc = validatedFile.options.babelrc;\n    }\n    if (babelrcRoots === undefined) {\n      babelrcRootsDirectory = validatedFile.dirname;\n      babelrcRoots = validatedFile.options.babelrcRoots;\n    }\n\n    mergeChain(configFileChain, result);\n  }\n\n  let ignoreFile, babelrcFile;\n  let isIgnored = false;\n  const fileChain = emptyChain();\n  // resolve all .babelrc files\n  if (\n    (babelrc === true || babelrc === undefined) &&\n    typeof context.filename === \"string\"\n  ) {\n    const pkgData = yield* findPackageData(context.filename);\n\n    if (\n      pkgData &&\n      babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)\n    ) {\n      ({ ignore: ignoreFile, config: babelrcFile } = yield* findRelativeConfig(\n        pkgData,\n        context.envName,\n        context.caller,\n      ));\n\n      if (ignoreFile) {\n        fileChain.files.add(ignoreFile.filepath);\n      }\n\n      if (\n        ignoreFile &&\n        shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)\n      ) {\n        isIgnored = true;\n      }\n\n      if (babelrcFile && !isIgnored) {\n        const validatedFile = validateBabelrcFile(babelrcFile);\n        const babelrcLogger = new ConfigPrinter();\n        const result = yield* loadFileChain(\n          validatedFile,\n          context,\n          undefined,\n          babelrcLogger,\n        );\n        if (!result) {\n          isIgnored = true;\n        } else {\n          babelRcReport = yield* babelrcLogger.output();\n          mergeChain(fileChain, result);\n        }\n      }\n\n      if (babelrcFile && isIgnored) {\n        fileChain.files.add(babelrcFile.filepath);\n      }\n    }\n  }\n\n  if (context.showConfig) {\n    console.log(\n      `Babel configs on \"${context.filename}\" (ascending priority):\\n` +\n        // print config by the order of ascending priority\n        [configReport, babelRcReport, programmaticReport]\n          .filter(x => !!x)\n          .join(\"\\n\\n\") +\n        \"\\n-----End Babel configs-----\",\n    );\n  }\n  // Insert file chain in front so programmatic options have priority\n  // over configuration file chain items.\n  const chain = mergeChain(\n    mergeChain(mergeChain(emptyChain(), configFileChain), fileChain),\n    programmaticChain,\n  );\n\n  return {\n    plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),\n    presets: isIgnored ? [] : dedupDescriptors(chain.presets),\n    options: isIgnored ? [] : chain.options.map(o => normalizeOptions(o)),\n    fileHandling: isIgnored ? \"ignored\" : \"transpile\",\n    ignore: ignoreFile || undefined,\n    babelrc: babelrcFile || undefined,\n    config: configFile || undefined,\n    files: chain.files,\n  };\n}\n\nfunction babelrcLoadEnabled(\n  context: ConfigContext,\n  pkgData: FilePackageData,\n  babelrcRoots: BabelrcSearch | undefined,\n  babelrcRootsDirectory: string,\n): boolean {\n  if (typeof babelrcRoots === \"boolean\") return babelrcRoots;\n\n  const absoluteRoot = context.root;\n\n  // Fast path to avoid having to match patterns if the babelrc is just\n  // loading in the standard root directory.\n  if (babelrcRoots === undefined) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  let babelrcPatterns = babelrcRoots;\n  if (!Array.isArray(babelrcPatterns)) {\n    babelrcPatterns = [babelrcPatterns as IgnoreItem];\n  }\n  babelrcPatterns = babelrcPatterns.map(pat => {\n    return typeof pat === \"string\"\n      ? path.resolve(babelrcRootsDirectory, pat)\n      : pat;\n  });\n\n  // Fast path to avoid having to match patterns if the babelrc is just\n  // loading in the standard root directory.\n  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  return babelrcPatterns.some(pat => {\n    if (typeof pat === \"string\") {\n      pat = pathPatternToRegex(pat, babelrcRootsDirectory);\n    }\n\n    return pkgData.directories.some(directory => {\n      return matchPattern(pat, babelrcRootsDirectory, directory, context);\n    });\n  });\n}\n\nconst validateConfigFile = makeWeakCacheSync(\n  (file: ConfigFile): ValidatedFile => ({\n    filepath: file.filepath,\n    dirname: file.dirname,\n    options: validate(\"configfile\", file.options, file.filepath),\n  }),\n);\n\nconst validateBabelrcFile = makeWeakCacheSync(\n  (file: ConfigFile): ValidatedFile => ({\n    filepath: file.filepath,\n    dirname: file.dirname,\n    options: validate(\"babelrcfile\", file.options, file.filepath),\n  }),\n);\n\nconst validateExtendFile = makeWeakCacheSync(\n  (file: ConfigFile): ValidatedFile => ({\n    filepath: file.filepath,\n    dirname: file.dirname,\n    options: validate(\"extendsfile\", file.options, file.filepath),\n  }),\n);\n\n/**\n * Build a config chain for just the programmatic options passed into Babel.\n */\nconst loadProgrammaticChain = makeChainWalker({\n  root: input => buildRootDescriptors(input, \"base\", createCachedDescriptors),\n  env: (input, envName) =>\n    buildEnvDescriptors(input, \"base\", createCachedDescriptors, envName),\n  overrides: (input, index) =>\n    buildOverrideDescriptors(input, \"base\", createCachedDescriptors, index),\n  overridesEnv: (input, index, envName) =>\n    buildOverrideEnvDescriptors(\n      input,\n      \"base\",\n      createCachedDescriptors,\n      index,\n      envName,\n    ),\n  createLogger: (input, context, baseLogger) =>\n    buildProgrammaticLogger(input, context, baseLogger),\n});\n\n/**\n * Build a config chain for a given file.\n */\nconst loadFileChainWalker = makeChainWalker<ValidatedFile>({\n  root: file => loadFileDescriptors(file),\n  env: (file, envName) => loadFileEnvDescriptors(file)(envName),\n  overrides: (file, index) => loadFileOverridesDescriptors(file)(index),\n  overridesEnv: (file, index, envName) =>\n    loadFileOverridesEnvDescriptors(file)(index)(envName),\n  createLogger: (file, context, baseLogger) =>\n    buildFileLogger(file.filepath, context, baseLogger),\n});\n\nfunction* loadFileChain(\n  input: ValidatedFile,\n  context: ConfigContext,\n  files: Set<ConfigFile>,\n  baseLogger: ConfigPrinter,\n) {\n  const chain = yield* loadFileChainWalker(input, context, files, baseLogger);\n  if (chain) {\n    chain.files.add(input.filepath);\n  }\n\n  return chain;\n}\n\nconst loadFileDescriptors = makeWeakCacheSync((file: ValidatedFile) =>\n  buildRootDescriptors(file, file.filepath, createUncachedDescriptors),\n);\nconst loadFileEnvDescriptors = makeWeakCacheSync((file: ValidatedFile) =>\n  makeStrongCacheSync((envName: string) =>\n    buildEnvDescriptors(\n      file,\n      file.filepath,\n      createUncachedDescriptors,\n      envName,\n    ),\n  ),\n);\nconst loadFileOverridesDescriptors = makeWeakCacheSync((file: ValidatedFile) =>\n  makeStrongCacheSync((index: number) =>\n    buildOverrideDescriptors(\n      file,\n      file.filepath,\n      createUncachedDescriptors,\n      index,\n    ),\n  ),\n);\nconst loadFileOverridesEnvDescriptors = makeWeakCacheSync(\n  (file: ValidatedFile) =>\n    makeStrongCacheSync((index: number) =>\n      makeStrongCacheSync((envName: string) =>\n        buildOverrideEnvDescriptors(\n          file,\n          file.filepath,\n          createUncachedDescriptors,\n          index,\n          envName,\n        ),\n      ),\n    ),\n);\n\nfunction buildFileLogger(\n  filepath: string,\n  context: ConfigContext,\n  baseLogger: ConfigPrinter | void,\n) {\n  if (!baseLogger) {\n    return () => {};\n  }\n  return baseLogger.configure(context.showConfig, ChainFormatter.Config, {\n    filepath,\n  });\n}\n\nfunction buildRootDescriptors(\n  { dirname, options }: Partial<ValidatedFile>,\n  alias: string,\n  descriptors: (\n    dirname: string,\n    options: ValidatedOptions,\n    alias: string,\n  ) => OptionsAndDescriptors,\n) {\n  return descriptors(dirname, options, alias);\n}\n\nfunction buildProgrammaticLogger(\n  _: unknown,\n  context: ConfigContext,\n  baseLogger: ConfigPrinter | void,\n) {\n  if (!baseLogger) {\n    return () => {};\n  }\n  return baseLogger.configure(context.showConfig, ChainFormatter.Programmatic, {\n    callerName: context.caller?.name,\n  });\n}\n\nfunction buildEnvDescriptors(\n  { dirname, options }: Partial<ValidatedFile>,\n  alias: string,\n  descriptors: (\n    dirname: string,\n    options: ValidatedOptions,\n    alias: string,\n  ) => OptionsAndDescriptors,\n  envName: string,\n) {\n  const opts = options.env && options.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.env[\"${envName}\"]`) : null;\n}\n\nfunction buildOverrideDescriptors(\n  { dirname, options }: Partial<ValidatedFile>,\n  alias: string,\n  descriptors: (\n    dirname: string,\n    options: ValidatedOptions,\n    alias: string,\n  ) => OptionsAndDescriptors,\n  index: number,\n) {\n  const opts = options.overrides && options.overrides[index];\n  if (!opts) throw new Error(\"Assertion failure - missing override\");\n\n  return descriptors(dirname, opts, `${alias}.overrides[${index}]`);\n}\n\nfunction buildOverrideEnvDescriptors(\n  { dirname, options }: Partial<ValidatedFile>,\n  alias: string,\n  descriptors: (\n    dirname: string,\n    options: ValidatedOptions,\n    alias: string,\n  ) => OptionsAndDescriptors,\n  index: number,\n  envName: string,\n) {\n  const override = options.overrides && options.overrides[index];\n  if (!override) throw new Error(\"Assertion failure - missing override\");\n\n  const opts = override.env && override.env[envName];\n  return opts\n    ? descriptors(\n        dirname,\n        opts,\n        `${alias}.overrides[${index}].env[\"${envName}\"]`,\n      )\n    : null;\n}\n\nfunction makeChainWalker<\n  ArgT extends {\n    options: ValidatedOptions;\n    dirname: string;\n    filepath?: string;\n  },\n>({\n  root,\n  env,\n  overrides,\n  overridesEnv,\n  createLogger,\n}: {\n  root: (configEntry: ArgT) => OptionsAndDescriptors;\n  env: (configEntry: ArgT, env: string) => OptionsAndDescriptors | null;\n  overrides: (configEntry: ArgT, index: number) => OptionsAndDescriptors;\n  overridesEnv: (\n    configEntry: ArgT,\n    index: number,\n    env: string,\n  ) => OptionsAndDescriptors | null;\n  createLogger: (\n    configEntry: ArgT,\n    context: ConfigContext,\n    printer: ConfigPrinter | void,\n  ) => (\n    opts: OptionsAndDescriptors,\n    index?: number | null,\n    env?: string | null,\n  ) => void;\n}): (\n  configEntry: ArgT,\n  context: ConfigContext,\n  files?: Set<ConfigFile>,\n  baseLogger?: ConfigPrinter,\n) => Handler<ConfigChain | null> {\n  return function* chainWalker(input, context, files = new Set(), baseLogger) {\n    const { dirname } = input;\n\n    const flattenedConfigs: Array<{\n      config: OptionsAndDescriptors;\n      index: number | undefined | null;\n      envName: string | undefined | null;\n    }> = [];\n\n    const rootOpts = root(input);\n    if (configIsApplicable(rootOpts, dirname, context, input.filepath)) {\n      flattenedConfigs.push({\n        config: rootOpts,\n        envName: undefined,\n        index: undefined,\n      });\n\n      const envOpts = env(input, context.envName);\n      if (\n        envOpts &&\n        configIsApplicable(envOpts, dirname, context, input.filepath)\n      ) {\n        flattenedConfigs.push({\n          config: envOpts,\n          envName: context.envName,\n          index: undefined,\n        });\n      }\n\n      (rootOpts.options.overrides || []).forEach((_, index) => {\n        const overrideOps = overrides(input, index);\n        if (configIsApplicable(overrideOps, dirname, context, input.filepath)) {\n          flattenedConfigs.push({\n            config: overrideOps,\n            index,\n            envName: undefined,\n          });\n\n          const overrideEnvOpts = overridesEnv(input, index, context.envName);\n          if (\n            overrideEnvOpts &&\n            configIsApplicable(\n              overrideEnvOpts,\n              dirname,\n              context,\n              input.filepath,\n            )\n          ) {\n            flattenedConfigs.push({\n              config: overrideEnvOpts,\n              index,\n              envName: context.envName,\n            });\n          }\n        }\n      });\n    }\n\n    // Process 'ignore' and 'only' before 'extends' items are processed so\n    // that we don't do extra work loading extended configs if a file is\n    // ignored.\n    if (\n      flattenedConfigs.some(\n        ({\n          config: {\n            options: { ignore, only },\n          },\n        }) => shouldIgnore(context, ignore, only, dirname),\n      )\n    ) {\n      return null;\n    }\n\n    const chain = emptyChain();\n    const logger = createLogger(input, context, baseLogger);\n\n    for (const { config, index, envName } of flattenedConfigs) {\n      if (\n        !(yield* mergeExtendsChain(\n          chain,\n          config.options,\n          dirname,\n          context,\n          files,\n          baseLogger,\n        ))\n      ) {\n        return null;\n      }\n\n      logger(config, index, envName);\n      yield* mergeChainOpts(chain, config);\n    }\n    return chain;\n  };\n}\n\nfunction* mergeExtendsChain(\n  chain: ConfigChain,\n  opts: ValidatedOptions,\n  dirname: string,\n  context: ConfigContext,\n  files: Set<ConfigFile>,\n  baseLogger?: ConfigPrinter,\n): Handler<boolean> {\n  if (opts.extends === undefined) return true;\n\n  const file = yield* loadConfig(\n    opts.extends,\n    dirname,\n    context.envName,\n    context.caller,\n  );\n\n  if (files.has(file)) {\n    throw new Error(\n      `Configuration cycle detected loading ${file.filepath}.\\n` +\n        `File already loaded following the config chain:\\n` +\n        Array.from(files, file => ` - ${file.filepath}`).join(\"\\n\"),\n    );\n  }\n\n  files.add(file);\n  const fileChain = yield* loadFileChain(\n    validateExtendFile(file),\n    context,\n    files,\n    baseLogger,\n  );\n  files.delete(file);\n\n  if (!fileChain) return false;\n\n  mergeChain(chain, fileChain);\n\n  return true;\n}\n\nfunction mergeChain(target: ConfigChain, source: ConfigChain): ConfigChain {\n  target.options.push(...source.options);\n  target.plugins.push(...source.plugins);\n  target.presets.push(...source.presets);\n  for (const file of source.files) {\n    target.files.add(file);\n  }\n\n  return target;\n}\n\nfunction* mergeChainOpts(\n  target: ConfigChain,\n  { options, plugins, presets }: OptionsAndDescriptors,\n): Handler<ConfigChain> {\n  target.options.push(options);\n  target.plugins.push(...(yield* plugins()));\n  target.presets.push(...(yield* presets()));\n\n  return target;\n}\n\nfunction emptyChain(): ConfigChain {\n  return {\n    options: [],\n    presets: [],\n    plugins: [],\n    files: new Set(),\n  };\n}\n\nfunction normalizeOptions(opts: ValidatedOptions): ValidatedOptions {\n  const options = {\n    ...opts,\n  };\n  delete options.extends;\n  delete options.env;\n  delete options.overrides;\n  delete options.plugins;\n  delete options.presets;\n  delete options.passPerPreset;\n  delete options.ignore;\n  delete options.only;\n  delete options.test;\n  delete options.include;\n  delete options.exclude;\n\n  // \"sourceMap\" is just aliased to sourceMap, so copy it over as\n  // we merge the options together.\n  if (Object.prototype.hasOwnProperty.call(options, \"sourceMap\")) {\n    options.sourceMaps = options.sourceMap;\n    delete options.sourceMap;\n  }\n  return options;\n}\n\nfunction dedupDescriptors(\n  items: Array<UnloadedDescriptor>,\n): Array<UnloadedDescriptor> {\n  const map: Map<\n    Function,\n    Map<string | void, { value: UnloadedDescriptor }>\n  > = new Map();\n\n  const descriptors = [];\n\n  for (const item of items) {\n    if (typeof item.value === \"function\") {\n      const fnKey = item.value;\n      let nameMap = map.get(fnKey);\n      if (!nameMap) {\n        nameMap = new Map();\n        map.set(fnKey, nameMap);\n      }\n      let desc = nameMap.get(item.name);\n      if (!desc) {\n        desc = { value: item };\n        descriptors.push(desc);\n\n        // Treat passPerPreset presets as unique, skipping them\n        // in the merge processing steps.\n        if (!item.ownPass) nameMap.set(item.name, desc);\n      } else {\n        desc.value = item;\n      }\n    } else {\n      descriptors.push({ value: item });\n    }\n  }\n\n  return descriptors.reduce((acc, desc) => {\n    acc.push(desc.value);\n    return acc;\n  }, []);\n}\n\nfunction configIsApplicable(\n  { options }: OptionsAndDescriptors,\n  dirname: string,\n  context: ConfigContext,\n  configName: string,\n): boolean {\n  return (\n    (options.test === undefined ||\n      configFieldIsApplicable(context, options.test, dirname, configName)) &&\n    (options.include === undefined ||\n      configFieldIsApplicable(context, options.include, dirname, configName)) &&\n    (options.exclude === undefined ||\n      !configFieldIsApplicable(context, options.exclude, dirname, configName))\n  );\n}\n\nfunction configFieldIsApplicable(\n  context: ConfigContext,\n  test: ConfigApplicableTest,\n  dirname: string,\n  configName: string,\n): boolean {\n  const patterns = Array.isArray(test) ? test : [test];\n\n  return matchesPatterns(context, patterns, dirname, configName);\n}\n\n/**\n * Print the ignoreList-values in a more helpful way than the default.\n */\nfunction ignoreListReplacer(\n  _key: string,\n  value: IgnoreList | IgnoreItem,\n): IgnoreList | IgnoreItem | string {\n  if (value instanceof RegExp) {\n    return String(value);\n  }\n\n  return value;\n}\n\n/**\n * Tests if a filename should be ignored based on \"ignore\" and \"only\" options.\n */\nfunction shouldIgnore(\n  context: ConfigContext,\n  ignore: IgnoreList | undefined | null,\n  only: IgnoreList | undefined | null,\n  dirname: string,\n): boolean {\n  if (ignore && matchesPatterns(context, ignore, dirname)) {\n    const message = `No config is applied to \"${\n      context.filename ?? \"(unknown)\"\n    }\" because it matches one of \\`ignore: ${JSON.stringify(\n      ignore,\n      ignoreListReplacer,\n    )}\\` from \"${dirname}\"`;\n    debug(message);\n    if (context.showConfig) {\n      console.log(message);\n    }\n    return true;\n  }\n\n  if (only && !matchesPatterns(context, only, dirname)) {\n    const message = `No config is applied to \"${\n      context.filename ?? \"(unknown)\"\n    }\" because it fails to match one of \\`only: ${JSON.stringify(\n      only,\n      ignoreListReplacer,\n    )}\\` from \"${dirname}\"`;\n    debug(message);\n    if (context.showConfig) {\n      console.log(message);\n    }\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Returns result of calling function with filename if pattern is a function.\n * Otherwise returns result of matching pattern Regex with filename.\n */\nfunction matchesPatterns(\n  context: ConfigContext,\n  patterns: IgnoreList,\n  dirname: string,\n  configName?: string,\n): boolean {\n  return patterns.some(pattern =>\n    matchPattern(pattern, dirname, context.filename, context, configName),\n  );\n}\n\nfunction matchPattern(\n  pattern: IgnoreItem,\n  dirname: string,\n  pathToTest: string | undefined,\n  context: ConfigContext,\n  configName?: string,\n): boolean {\n  if (typeof pattern === \"function\") {\n    return !!endHiddenCallStack(pattern)(pathToTest, {\n      dirname,\n      envName: context.envName,\n      caller: context.caller,\n    });\n  }\n\n  if (typeof pathToTest !== \"string\") {\n    throw new ConfigError(\n      `Configuration contains string/RegExp pattern, but no filename was passed to Babel`,\n      configName,\n    );\n  }\n\n  if (typeof pattern === \"string\") {\n    pattern = pathPatternToRegex(pattern, dirname);\n  }\n  return pattern.test(pathToTest);\n}\n"]},"metadata":{},"sourceType":"script"}