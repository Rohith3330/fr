{"ast":null,"code":"let EventEmitter = require('events').EventEmitter;\n\nlet async = require('async');\n\nlet chalk = require('chalk'); // 'rule' module is required at the bottom because circular deps\n// Used for task value, so better not to use\n// null, since value should be unset/uninitialized\n\n\nlet UNDEFINED_VALUE;\nconst ROOT_TASK_NAME = '__rootTask__';\nconst POLLING_INTERVAL = 100; // Parse any positional args attached to the task-name\n\nfunction parsePrereqName(name) {\n  let taskArr = name.split('[');\n  let taskName = taskArr[0];\n  let taskArgs = [];\n\n  if (taskArr[1]) {\n    taskArgs = taskArr[1].replace(/\\]$/, '');\n    taskArgs = taskArgs.split(',');\n  }\n\n  return {\n    name: taskName,\n    args: taskArgs\n  };\n}\n/**\n  @name jake.Task\n  @class\n  @extends EventEmitter\n  @description A Jake Task\n\n  @param {String} name The name of the Task\n  @param {Array} [prereqs] Prerequisites to be run before this task\n  @param {Function} [action] The action to perform for this task\n  @param {Object} [opts]\n    @param {Array} [opts.asyc=false] Perform this task asynchronously.\n    If you flag a task with this option, you must call the global\n    `complete` method inside the task's action, for execution to proceed\n    to the next task.\n */\n\n\nclass Task extends EventEmitter {\n  constructor(name, prereqs, action, options) {\n    // EventEmitter ctor takes no args\n    super();\n\n    if (name.indexOf(':') > -1) {\n      throw new Error('Task name cannot include a colon. It is used internally as namespace delimiter.');\n    }\n\n    let opts = options || {};\n    this._currentPrereqIndex = 0;\n    this._internal = false;\n    this._skipped = false;\n    this.name = name;\n    this.prereqs = prereqs;\n    this.action = action;\n    this.async = false;\n    this.taskStatus = Task.runStatuses.UNSTARTED;\n    this.description = null;\n    this.args = [];\n    this.value = UNDEFINED_VALUE;\n    this.concurrency = 1;\n    this.startTime = null;\n    this.endTime = null;\n    this.directory = null;\n    this.namespace = null; // Support legacy async-flag -- if not explicitly passed or falsy, will\n    // be set to empty-object\n\n    if (typeof opts == 'boolean' && opts === true) {\n      this.async = true;\n    } else {\n      if (opts.async) {\n        this.async = true;\n      }\n\n      if (opts.concurrency) {\n        this.concurrency = opts.concurrency;\n      }\n    } //Do a test on self dependencies for this task\n\n\n    if (Array.isArray(this.prereqs) && this.prereqs.indexOf(this.name) !== -1) {\n      throw new Error(\"Cannot use prereq \" + this.name + \" as a dependency of itself\");\n    }\n  }\n\n  get fullName() {\n    return this._getFullName();\n  }\n\n  get params() {\n    return this._getParams();\n  }\n\n  _initInvocationChain() {\n    // Legacy global invocation chain\n    jake._invocationChain.push(this); // New root chain\n\n\n    if (!this._invocationChain) {\n      this._invocationChainRoot = true;\n      this._invocationChain = [];\n\n      if (jake.currentRunningTask) {\n        jake.currentRunningTask._waitForChains = jake.currentRunningTask._waitForChains || [];\n\n        jake.currentRunningTask._waitForChains.push(this._invocationChain);\n      }\n    }\n  }\n  /**\n    @name jake.Task#invoke\n    @function\n    @description Runs prerequisites, then this task. If the task has already\n    been run, will not run the task again.\n   */\n\n\n  invoke() {\n    this._initInvocationChain();\n\n    this.args = Array.prototype.slice.call(arguments);\n    this.reenabled = false;\n    this.runPrereqs();\n  }\n  /**\n    @name jake.Task#execute\n    @function\n    @description Run only this task, without prereqs. If the task has already\n    been run, *will* run the task again.\n   */\n\n\n  execute() {\n    this._initInvocationChain();\n\n    this.args = Array.prototype.slice.call(arguments);\n    this.reenable();\n    this.reenabled = true;\n    this.run();\n  }\n\n  runPrereqs() {\n    if (this.prereqs && this.prereqs.length) {\n      if (this.concurrency > 1) {\n        async.eachLimit(this.prereqs, this.concurrency, (name, cb) => {\n          let parsed = parsePrereqName(name);\n          let prereq = this.namespace.resolveTask(parsed.name) || jake.attemptRule(name, this.namespace, 0) || jake.createPlaceholderFileTask(name, this.namespace);\n\n          if (!prereq) {\n            throw new Error('Unknown task \"' + name + '\"');\n          } //Test for circular invocation\n\n\n          if (prereq === this) {\n            setImmediate(function () {\n              cb(new Error(\"Cannot use prereq \" + prereq.name + \" as a dependency of itself\"));\n            });\n          }\n\n          if (prereq.taskStatus == Task.runStatuses.DONE) {\n            //prereq already done, return\n            setImmediate(cb);\n          } else {\n            //wait for complete before calling cb\n            prereq.once('_done', () => {\n              prereq.removeAllListeners('_done');\n              setImmediate(cb);\n            }); // Start the prereq if we are the first to encounter it\n\n            if (prereq.taskStatus === Task.runStatuses.UNSTARTED) {\n              prereq.taskStatus = Task.runStatuses.STARTED;\n              prereq.invoke.apply(prereq, parsed.args);\n            }\n          }\n        }, err => {\n          //async callback is called after all prereqs have run.\n          if (err) {\n            throw err;\n          } else {\n            setImmediate(this.run.bind(this));\n          }\n        });\n      } else {\n        setImmediate(this.nextPrereq.bind(this));\n      }\n    } else {\n      setImmediate(this.run.bind(this));\n    }\n  }\n\n  nextPrereq() {\n    let self = this;\n    let index = this._currentPrereqIndex;\n    let name = this.prereqs[index];\n    let prereq;\n    let parsed;\n\n    if (name) {\n      parsed = parsePrereqName(name);\n      prereq = this.namespace.resolveTask(parsed.name) || jake.attemptRule(name, this.namespace, 0) || jake.createPlaceholderFileTask(name, this.namespace);\n\n      if (!prereq) {\n        throw new Error('Unknown task \"' + name + '\"');\n      } // Do when done\n\n\n      if (prereq.taskStatus == Task.runStatuses.DONE) {\n        self.handlePrereqDone(prereq);\n      } else {\n        prereq.once('_done', () => {\n          this.handlePrereqDone(prereq);\n          prereq.removeAllListeners('_done');\n        });\n\n        if (prereq.taskStatus == Task.runStatuses.UNSTARTED) {\n          prereq.taskStatus = Task.runStatuses.STARTED;\n          prereq._invocationChain = this._invocationChain;\n          prereq.invoke.apply(prereq, parsed.args);\n        }\n      }\n    }\n  }\n  /**\n    @name jake.Task#reenable\n    @function\n    @description Reenables a task so that it can be run again.\n   */\n\n\n  reenable(deep) {\n    let prereqs;\n    let prereq;\n    this._skipped = false;\n    this.taskStatus = Task.runStatuses.UNSTARTED;\n    this.value = UNDEFINED_VALUE;\n\n    if (deep && this.prereqs) {\n      prereqs = this.prereqs;\n\n      for (let i = 0, ii = prereqs.length; i < ii; i++) {\n        prereq = jake.Task[prereqs[i]];\n\n        if (prereq) {\n          prereq.reenable(deep);\n        }\n      }\n    }\n  }\n\n  handlePrereqDone(prereq) {\n    this._currentPrereqIndex++;\n\n    if (this._currentPrereqIndex < this.prereqs.length) {\n      setImmediate(this.nextPrereq.bind(this));\n    } else {\n      setImmediate(this.run.bind(this));\n    }\n  }\n\n  isNeeded() {\n    let needed = true;\n\n    if (this.taskStatus == Task.runStatuses.DONE) {\n      needed = false;\n    }\n\n    return needed;\n  }\n\n  run() {\n    let val, previous;\n    let hasAction = typeof this.action == 'function';\n\n    if (!this.isNeeded()) {\n      this.emit('skip');\n      this.emit('_done');\n    } else {\n      if (this._invocationChain.length) {\n        previous = this._invocationChain[this._invocationChain.length - 1]; // If this task is repeating and its previous is equal to this, don't check its status because it was set to UNSTARTED by the reenable() method\n\n        if (!(this.reenabled && previous == this)) {\n          if (previous.taskStatus != Task.runStatuses.DONE) {\n            let now = new Date().getTime();\n\n            if (now - this.startTime > jake._taskTimeout) {\n              return jake.fail(`Timed out waiting for task: ${previous.name} with status of ${previous.taskStatus}`);\n            }\n\n            setTimeout(this.run.bind(this), POLLING_INTERVAL);\n            return;\n          }\n        }\n      }\n\n      if (!(this.reenabled && previous == this)) {\n        this._invocationChain.push(this);\n      }\n\n      if (!(this._internal || jake.program.opts.quiet)) {\n        console.log(\"Starting '\" + chalk.green(this.fullName) + \"'...\");\n      }\n\n      this.startTime = new Date().getTime();\n      this.emit('start');\n      jake.currentRunningTask = this;\n\n      if (hasAction) {\n        try {\n          if (this.directory) {\n            process.chdir(this.directory);\n          }\n\n          val = this.action.apply(this, this.args);\n\n          if (typeof val == 'object' && typeof val.then == 'function') {\n            this.async = true;\n            val.then(result => {\n              setImmediate(() => {\n                this.complete(result);\n              });\n            }, err => {\n              setImmediate(() => {\n                this.errorOut(err);\n              });\n            });\n          }\n        } catch (err) {\n          this.errorOut(err);\n          return; // Bail out, not complete\n        }\n      }\n\n      if (!(hasAction && this.async)) {\n        setImmediate(() => {\n          this.complete(val);\n        });\n      }\n    }\n  }\n\n  errorOut(err) {\n    this.taskStatus = Task.runStatuses.ERROR;\n    this._invocationChain.chainStatus = Task.runStatuses.ERROR;\n    this.emit('error', err);\n  }\n\n  complete(val) {\n    if (Array.isArray(this._waitForChains)) {\n      let stillWaiting = this._waitForChains.some(chain => {\n        return !(chain.chainStatus == Task.runStatuses.DONE || chain.chainStatus == Task.runStatuses.ERROR);\n      });\n\n      if (stillWaiting) {\n        let now = new Date().getTime();\n        let elapsed = now - this.startTime;\n\n        if (elapsed > jake._taskTimeout) {\n          return jake.fail(`Timed out waiting for task: ${this.name} with status of ${this.taskStatus}. Elapsed: ${elapsed}`);\n        }\n\n        setTimeout(() => {\n          this.complete(val);\n        }, POLLING_INTERVAL);\n        return;\n      }\n    }\n\n    jake._invocationChain.splice(jake._invocationChain.indexOf(this), 1);\n\n    if (this._invocationChainRoot) {\n      this._invocationChain.chainStatus = Task.runStatuses.DONE;\n    }\n\n    this._currentPrereqIndex = 0; // If 'complete' getting called because task has been\n    // run already, value will not be passed -- leave in place\n\n    if (!this._skipped) {\n      this.taskStatus = Task.runStatuses.DONE;\n      this.value = val;\n      this.emit('complete', this.value);\n      this.emit('_done');\n      this.endTime = new Date().getTime();\n      let taskTime = this.endTime - this.startTime;\n\n      if (!(this._internal || jake.program.opts.quiet)) {\n        console.log(\"Finished '\" + chalk.green(this.fullName) + \"' after \" + chalk.magenta(taskTime + ' ms'));\n      }\n    }\n  }\n\n  _getFullName() {\n    let ns = this.namespace;\n    let path = ns && ns.path || '';\n    path = path && path.split(':') || [];\n\n    if (this.namespace !== jake.defaultNamespace) {\n      path.push(this.namespace.name);\n    }\n\n    path.push(this.name);\n    return path.join(':');\n  }\n\n  _getParams() {\n    if (!this.action) return \"\";\n    let params = new RegExp('(?:' + this.action.name + '\\\\s*|^)\\\\s*\\\\((.*?)\\\\)').exec(this.action.toString().replace(/\\n/g, ''))[1].replace(/\\/\\*.*?\\*\\//g, '').replace(/ /g, '');\n    return params;\n  }\n\n  static getBaseNamespacePath(fullName) {\n    return fullName.split(':').slice(0, -1).join(':');\n  }\n\n  static getBaseTaskName(fullName) {\n    return fullName.split(':').pop();\n  }\n\n}\n\nTask.runStatuses = {\n  UNSTARTED: 'unstarted',\n  DONE: 'done',\n  STARTED: 'started',\n  ERROR: 'error'\n};\nTask.ROOT_TASK_NAME = ROOT_TASK_NAME;\nexports.Task = Task; // Required here because circular deps\n\nrequire('../rule');","map":{"version":3,"names":["EventEmitter","require","async","chalk","UNDEFINED_VALUE","ROOT_TASK_NAME","POLLING_INTERVAL","parsePrereqName","name","taskArr","split","taskName","taskArgs","replace","args","Task","constructor","prereqs","action","options","indexOf","Error","opts","_currentPrereqIndex","_internal","_skipped","taskStatus","runStatuses","UNSTARTED","description","value","concurrency","startTime","endTime","directory","namespace","Array","isArray","fullName","_getFullName","params","_getParams","_initInvocationChain","jake","_invocationChain","push","_invocationChainRoot","currentRunningTask","_waitForChains","invoke","prototype","slice","call","arguments","reenabled","runPrereqs","execute","reenable","run","length","eachLimit","cb","parsed","prereq","resolveTask","attemptRule","createPlaceholderFileTask","setImmediate","DONE","once","removeAllListeners","STARTED","apply","err","bind","nextPrereq","self","index","handlePrereqDone","deep","i","ii","isNeeded","needed","val","previous","hasAction","emit","now","Date","getTime","_taskTimeout","fail","setTimeout","program","quiet","console","log","green","process","chdir","then","result","complete","errorOut","ERROR","chainStatus","stillWaiting","some","chain","elapsed","splice","taskTime","magenta","ns","path","defaultNamespace","join","RegExp","exec","toString","getBaseNamespacePath","getBaseTaskName","pop","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jake/lib/task/task.js"],"sourcesContent":["let EventEmitter = require('events').EventEmitter;\nlet async = require('async');\nlet chalk = require('chalk');\n// 'rule' module is required at the bottom because circular deps\n\n// Used for task value, so better not to use\n// null, since value should be unset/uninitialized\nlet UNDEFINED_VALUE;\n\nconst ROOT_TASK_NAME = '__rootTask__';\nconst POLLING_INTERVAL = 100;\n\n// Parse any positional args attached to the task-name\nfunction parsePrereqName(name) {\n  let taskArr = name.split('[');\n  let taskName = taskArr[0];\n  let taskArgs = [];\n  if (taskArr[1]) {\n    taskArgs = taskArr[1].replace(/\\]$/, '');\n    taskArgs = taskArgs.split(',');\n  }\n  return {\n    name: taskName,\n    args: taskArgs\n  };\n}\n\n/**\n  @name jake.Task\n  @class\n  @extends EventEmitter\n  @description A Jake Task\n\n  @param {String} name The name of the Task\n  @param {Array} [prereqs] Prerequisites to be run before this task\n  @param {Function} [action] The action to perform for this task\n  @param {Object} [opts]\n    @param {Array} [opts.asyc=false] Perform this task asynchronously.\n    If you flag a task with this option, you must call the global\n    `complete` method inside the task's action, for execution to proceed\n    to the next task.\n */\nclass Task extends EventEmitter {\n\n  constructor(name, prereqs, action, options) {\n    // EventEmitter ctor takes no args\n    super();\n\n    if (name.indexOf(':') > -1) {\n      throw new Error('Task name cannot include a colon. It is used internally as namespace delimiter.');\n    }\n    let opts = options || {};\n\n    this._currentPrereqIndex = 0;\n    this._internal = false;\n    this._skipped = false;\n\n    this.name = name;\n    this.prereqs = prereqs;\n    this.action = action;\n    this.async = false;\n    this.taskStatus = Task.runStatuses.UNSTARTED;\n    this.description = null;\n    this.args = [];\n    this.value = UNDEFINED_VALUE;\n    this.concurrency = 1;\n    this.startTime = null;\n    this.endTime = null;\n    this.directory = null;\n    this.namespace = null;\n\n    // Support legacy async-flag -- if not explicitly passed or falsy, will\n    // be set to empty-object\n    if (typeof opts == 'boolean' && opts === true) {\n      this.async = true;\n    }\n    else {\n      if (opts.async) {\n        this.async = true;\n      }\n      if (opts.concurrency) {\n        this.concurrency = opts.concurrency;\n      }\n    }\n\n    //Do a test on self dependencies for this task\n    if(Array.isArray(this.prereqs) && this.prereqs.indexOf(this.name) !== -1) {\n      throw new Error(\"Cannot use prereq \" + this.name + \" as a dependency of itself\");\n    }\n  }\n\n  get fullName() {\n    return this._getFullName();\n  }\n\n  get params() {\n    return this._getParams();\n  }\n\n  _initInvocationChain() {\n    // Legacy global invocation chain\n    jake._invocationChain.push(this);\n\n    // New root chain\n    if (!this._invocationChain) {\n      this._invocationChainRoot = true;\n      this._invocationChain = [];\n      if (jake.currentRunningTask) {\n        jake.currentRunningTask._waitForChains = jake.currentRunningTask._waitForChains || [];\n        jake.currentRunningTask._waitForChains.push(this._invocationChain);\n      }\n    }\n  }\n\n  /**\n    @name jake.Task#invoke\n    @function\n    @description Runs prerequisites, then this task. If the task has already\n    been run, will not run the task again.\n   */\n  invoke() {\n    this._initInvocationChain();\n\n    this.args = Array.prototype.slice.call(arguments);\n    this.reenabled = false\n    this.runPrereqs();\n  }\n\n  /**\n    @name jake.Task#execute\n    @function\n    @description Run only this task, without prereqs. If the task has already\n    been run, *will* run the task again.\n   */\n  execute() {\n    this._initInvocationChain();\n\n    this.args = Array.prototype.slice.call(arguments);\n    this.reenable();\n    this.reenabled = true\n    this.run();\n  }\n\n  runPrereqs() {\n    if (this.prereqs && this.prereqs.length) {\n\n      if (this.concurrency > 1) {\n        async.eachLimit(this.prereqs, this.concurrency,\n\n          (name, cb) => {\n            let parsed = parsePrereqName(name);\n\n            let prereq = this.namespace.resolveTask(parsed.name) ||\n          jake.attemptRule(name, this.namespace, 0) ||\n          jake.createPlaceholderFileTask(name, this.namespace);\n\n            if (!prereq) {\n              throw new Error('Unknown task \"' + name + '\"');\n            }\n\n            //Test for circular invocation\n            if(prereq === this) {\n              setImmediate(function () {\n                cb(new Error(\"Cannot use prereq \" + prereq.name + \" as a dependency of itself\"));\n              });\n            }\n\n            if (prereq.taskStatus == Task.runStatuses.DONE) {\n            //prereq already done, return\n              setImmediate(cb);\n            }\n            else {\n            //wait for complete before calling cb\n              prereq.once('_done', () => {\n                prereq.removeAllListeners('_done');\n                setImmediate(cb);\n              });\n              // Start the prereq if we are the first to encounter it\n              if (prereq.taskStatus === Task.runStatuses.UNSTARTED) {\n                prereq.taskStatus = Task.runStatuses.STARTED;\n                prereq.invoke.apply(prereq, parsed.args);\n              }\n            }\n          },\n\n          (err) => {\n          //async callback is called after all prereqs have run.\n            if (err) {\n              throw err;\n            }\n            else {\n              setImmediate(this.run.bind(this));\n            }\n          }\n        );\n      }\n      else {\n        setImmediate(this.nextPrereq.bind(this));\n      }\n    }\n    else {\n      setImmediate(this.run.bind(this));\n    }\n  }\n\n  nextPrereq() {\n    let self = this;\n    let index = this._currentPrereqIndex;\n    let name = this.prereqs[index];\n    let prereq;\n    let parsed;\n\n    if (name) {\n\n      parsed = parsePrereqName(name);\n\n      prereq = this.namespace.resolveTask(parsed.name) ||\n          jake.attemptRule(name, this.namespace, 0) ||\n          jake.createPlaceholderFileTask(name, this.namespace);\n\n      if (!prereq) {\n        throw new Error('Unknown task \"' + name + '\"');\n      }\n\n      // Do when done\n      if (prereq.taskStatus == Task.runStatuses.DONE) {\n        self.handlePrereqDone(prereq);\n      }\n      else {\n        prereq.once('_done', () => {\n          this.handlePrereqDone(prereq);\n          prereq.removeAllListeners('_done');\n        });\n        if (prereq.taskStatus == Task.runStatuses.UNSTARTED) {\n          prereq.taskStatus = Task.runStatuses.STARTED;\n          prereq._invocationChain = this._invocationChain;\n          prereq.invoke.apply(prereq, parsed.args);\n        }\n      }\n    }\n  }\n\n  /**\n    @name jake.Task#reenable\n    @function\n    @description Reenables a task so that it can be run again.\n   */\n  reenable(deep) {\n    let prereqs;\n    let prereq;\n    this._skipped = false;\n    this.taskStatus = Task.runStatuses.UNSTARTED;\n    this.value = UNDEFINED_VALUE;\n    if (deep && this.prereqs) {\n      prereqs = this.prereqs;\n      for (let i = 0, ii = prereqs.length; i < ii; i++) {\n        prereq = jake.Task[prereqs[i]];\n        if (prereq) {\n          prereq.reenable(deep);\n        }\n      }\n    }\n  }\n\n  handlePrereqDone(prereq) {\n    this._currentPrereqIndex++;\n    if (this._currentPrereqIndex < this.prereqs.length) {\n      setImmediate(this.nextPrereq.bind(this));\n    }\n    else {\n      setImmediate(this.run.bind(this));\n    }\n  }\n\n  isNeeded() {\n    let needed = true;\n    if (this.taskStatus == Task.runStatuses.DONE) {\n      needed = false;\n    }\n    return needed;\n  }\n\n  run() {\n    let val, previous;\n    let hasAction = typeof this.action == 'function';\n\n    if (!this.isNeeded()) {\n      this.emit('skip');\n      this.emit('_done');\n    }\n    else {\n      if (this._invocationChain.length) {\n        previous = this._invocationChain[this._invocationChain.length - 1];\n        // If this task is repeating and its previous is equal to this, don't check its status because it was set to UNSTARTED by the reenable() method\n        if (!(this.reenabled && previous == this)) {\n          if (previous.taskStatus != Task.runStatuses.DONE) {\n            let now = (new Date()).getTime();\n            if (now - this.startTime > jake._taskTimeout) {\n              return jake.fail(`Timed out waiting for task: ${previous.name} with status of ${previous.taskStatus}`);\n            }\n            setTimeout(this.run.bind(this), POLLING_INTERVAL);\n            return;\n          }\n        }\n      }\n      if (!(this.reenabled && previous == this)) {\n        this._invocationChain.push(this);\n      }\n\n      if (!(this._internal || jake.program.opts.quiet)) {\n        console.log(\"Starting '\" + chalk.green(this.fullName) + \"'...\");\n      }\n\n      this.startTime = (new Date()).getTime();\n      this.emit('start');\n\n      jake.currentRunningTask = this;\n\n      if (hasAction) {\n        try {\n          if (this.directory) {\n            process.chdir(this.directory);\n          }\n\n          val = this.action.apply(this, this.args);\n\n          if (typeof val == 'object' && typeof val.then == 'function') {\n            this.async = true;\n\n            val.then(\n              (result) => {\n                setImmediate(() => {\n                  this.complete(result);\n                });\n              },\n              (err) => {\n                setImmediate(() => {\n                  this.errorOut(err);\n                });\n              });\n          }\n        }\n        catch (err) {\n          this.errorOut(err);\n          return; // Bail out, not complete\n        }\n      }\n\n      if (!(hasAction && this.async)) {\n        setImmediate(() => {\n          this.complete(val);\n        });\n      }\n    }\n  }\n\n  errorOut(err) {\n    this.taskStatus = Task.runStatuses.ERROR;\n    this._invocationChain.chainStatus = Task.runStatuses.ERROR;\n    this.emit('error', err);\n  }\n\n  complete(val) {\n\n    if (Array.isArray(this._waitForChains)) {\n      let stillWaiting = this._waitForChains.some((chain) => {\n        return !(chain.chainStatus == Task.runStatuses.DONE ||\n              chain.chainStatus == Task.runStatuses.ERROR);\n      });\n      if (stillWaiting) {\n        let now = (new Date()).getTime();\n        let elapsed = now - this.startTime;\n        if (elapsed > jake._taskTimeout) {\n          return jake.fail(`Timed out waiting for task: ${this.name} with status of ${this.taskStatus}. Elapsed: ${elapsed}`);\n        }\n        setTimeout(() => {\n          this.complete(val);\n        }, POLLING_INTERVAL);\n        return;\n      }\n    }\n\n    jake._invocationChain.splice(jake._invocationChain.indexOf(this), 1);\n\n    if (this._invocationChainRoot) {\n      this._invocationChain.chainStatus = Task.runStatuses.DONE;\n    }\n\n    this._currentPrereqIndex = 0;\n\n    // If 'complete' getting called because task has been\n    // run already, value will not be passed -- leave in place\n    if (!this._skipped) {\n      this.taskStatus = Task.runStatuses.DONE;\n      this.value = val;\n\n      this.emit('complete', this.value);\n      this.emit('_done');\n\n      this.endTime = (new Date()).getTime();\n      let taskTime = this.endTime - this.startTime;\n\n      if (!(this._internal || jake.program.opts.quiet)) {\n        console.log(\"Finished '\" + chalk.green(this.fullName) + \"' after \" + chalk.magenta(taskTime + ' ms'));\n      }\n\n    }\n  }\n\n  _getFullName() {\n    let ns = this.namespace;\n    let path = (ns && ns.path) || '';\n    path = (path && path.split(':')) || [];\n    if (this.namespace !== jake.defaultNamespace) {\n      path.push(this.namespace.name);\n    }\n    path.push(this.name);\n    return path.join(':');\n  }\n\n  _getParams() {\n    if (!this.action) return \"\";\n    let params = new RegExp('(?:'+this.action.name+'\\\\s*|^)\\\\s*\\\\((.*?)\\\\)').exec(this.action.toString().replace(/\\n/g, ''))[1].replace(/\\/\\*.*?\\*\\//g, '').replace(/ /g, '');\n    return params;\n  }\n\n  static getBaseNamespacePath(fullName) {\n    return fullName.split(':').slice(0, -1).join(':');\n  }\n\n  static getBaseTaskName(fullName) {\n    return fullName.split(':').pop();\n  }\n}\n\nTask.runStatuses = {\n  UNSTARTED: 'unstarted',\n  DONE: 'done',\n  STARTED: 'started',\n  ERROR: 'error'\n};\n\nTask.ROOT_TASK_NAME = ROOT_TASK_NAME;\n\nexports.Task = Task;\n\n// Required here because circular deps\nrequire('../rule');\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}