{"ast":null,"code":"/**\n * @fileoverview Common propTypes detection functionality.\n */\n'use strict';\n\nconst flatMap = require('array.prototype.flatmap');\n\nconst annotations = require('./annotations');\n\nconst propsUtil = require('./props');\n\nconst variableUtil = require('./variable');\n\nconst testFlowVersion = require('./version').testFlowVersion;\n\nconst propWrapperUtil = require('./propWrapper');\n\nconst astUtil = require('./ast');\n\nconst isFirstLetterCapitalized = require('./isFirstLetterCapitalized');\n/**\n * Check if node is function type.\n * @param {ASTNode} node\n * @returns {Boolean}\n */\n\n\nfunction isFunctionType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'FunctionDeclaration' || nodeType === 'FunctionExpression' || nodeType === 'ArrowFunctionExpression';\n}\n/**\n * Checks if we are declaring a props as a generic type in a flow-annotated class.\n *\n * @param {ASTNode} node  the AST node being checked.\n * @returns {Boolean} True if the node is a class with generic prop types, false if not.\n */\n\n\nfunction isSuperTypeParameterPropsDeclaration(node) {\n  if (node && (node.type === 'ClassDeclaration' || node.type === 'ClassExpression')) {\n    if (node.superTypeParameters && node.superTypeParameters.params.length > 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Iterates through a properties node, like a customized forEach.\n * @param {Object} context Array of properties to iterate.\n * @param {Object[]} properties Array of properties to iterate.\n * @param {Function} fn Function to call on each property, receives property key\n    and property value. (key, value) => void\n  * @param {Function} [handleSpreadFn] Function to call on each ObjectTypeSpreadProperty, receives the\n    argument\n */\n\n\nfunction iterateProperties(context, properties, fn, handleSpreadFn) {\n  if (properties && properties.length && typeof fn === 'function') {\n    for (let i = 0, j = properties.length; i < j; i++) {\n      const node = properties[i];\n      const key = astUtil.getKeyValue(context, node);\n\n      if (node.type === 'ObjectTypeSpreadProperty' && typeof handleSpreadFn === 'function') {\n        handleSpreadFn(node.argument);\n      }\n\n      const value = node.value;\n      fn(key, value, node);\n    }\n  }\n}\n/**\n * Checks if a node is inside a class body.\n *\n * @param {ASTNode} node  the AST node being checked.\n * @returns {Boolean} True if the node has a ClassBody ancestor, false if not.\n */\n\n\nfunction isInsideClassBody(node) {\n  let parent = node.parent;\n\n  while (parent) {\n    if (parent.type === 'ClassBody') {\n      return true;\n    }\n\n    parent = parent.parent;\n  }\n\n  return false;\n}\n\nfunction startWithCapitalizedLetter(node) {\n  return node.parent.type === 'VariableDeclarator' && !isFirstLetterCapitalized(node.parent.id.name);\n}\n\nmodule.exports = function propTypesInstructions(context, components, utils) {\n  // Used to track the type annotations in scope.\n  // Necessary because babel's scopes do not track type annotations.\n  let stack = null;\n  const classExpressions = [];\n  const defaults = {\n    customValidators: []\n  };\n  const configuration = Object.assign({}, defaults, context.options[0] || {});\n  const customValidators = configuration.customValidators;\n  const allowedGenericTypes = new Set(['forwardRef', 'ForwardRefRenderFunction', 'VFC', 'VoidFunctionComponent', 'PropsWithChildren', 'SFC', 'StatelessComponent', 'FunctionComponent', 'FC']);\n  const genericTypeParamIndexWherePropsArePresent = {\n    ForwardRefRenderFunction: 1,\n    forwardRef: 1,\n    VoidFunctionComponent: 0,\n    VFC: 0,\n    PropsWithChildren: 0,\n    SFC: 0,\n    StatelessComponent: 0,\n    FunctionComponent: 0,\n    FC: 0\n  };\n  const genericReactTypesImport = new Set(); // import { FC as X } from 'react' -> localToImportedMap = { x: FC }\n\n  const localToImportedMap = {};\n  /**\n   * Returns the full scope.\n   * @returns {Object} The whole scope.\n   */\n\n  function typeScope() {\n    return stack[stack.length - 1];\n  }\n  /**\n   * Gets a node from the scope.\n   * @param {string} key The name of the identifier to access.\n   * @returns {ASTNode} The ASTNode associated with the given identifier.\n   */\n\n\n  function getInTypeScope(key) {\n    return stack[stack.length - 1][key];\n  }\n  /**\n   * Sets the new value in the scope.\n   * @param {string} key The name of the identifier to access\n   * @param {ASTNode} value The new value for the identifier.\n   * @returns {ASTNode} The ASTNode associated with the given identifier.\n   */\n\n\n  function setInTypeScope(key, value) {\n    stack[stack.length - 1][key] = value;\n    return value;\n  }\n  /**\n   * Checks if prop should be validated by plugin-react-proptypes\n   * @param {String} validator Name of validator to check.\n   * @returns {Boolean} True if validator should be checked by custom validator.\n   */\n\n\n  function hasCustomValidator(validator) {\n    return customValidators.indexOf(validator) !== -1;\n  }\n  /* eslint-disable no-use-before-define */\n\n  /** @type {TypeDeclarationBuilders} */\n\n\n  const typeDeclarationBuilders = {\n    GenericTypeAnnotation(annotation, parentName, seen) {\n      if (getInTypeScope(annotation.id.name)) {\n        return buildTypeAnnotationDeclarationTypes(getInTypeScope(annotation.id.name), parentName, seen);\n      }\n\n      return {};\n    },\n\n    ObjectTypeAnnotation(annotation, parentName, seen) {\n      let containsUnresolvedObjectTypeSpread = false;\n      let containsSpread = false;\n      const containsIndexers = Boolean(annotation.indexers && annotation.indexers.length);\n      const shapeTypeDefinition = {\n        type: 'shape',\n        children: {}\n      };\n      iterateProperties(context, annotation.properties, (childKey, childValue, propNode) => {\n        const fullName = [parentName, childKey].join('.');\n\n        if (childKey || childValue) {\n          const types = buildTypeAnnotationDeclarationTypes(childValue, fullName, seen);\n          types.fullName = fullName;\n          types.name = childKey;\n          types.node = propNode;\n          types.isRequired = !childValue.optional;\n          shapeTypeDefinition.children[childKey] = types;\n        }\n      }, spreadNode => {\n        const key = astUtil.getKeyValue(context, spreadNode);\n        const types = buildTypeAnnotationDeclarationTypes(spreadNode, key, seen);\n\n        if (!types.children) {\n          containsUnresolvedObjectTypeSpread = true;\n        } else {\n          Object.assign(shapeTypeDefinition, types.children);\n        }\n\n        containsSpread = true;\n      }); // Mark if this shape has spread or an indexer. We will know to consider all props from this shape as having propTypes,\n      // but still have the ability to detect unused children of this shape.\n\n      shapeTypeDefinition.containsUnresolvedSpread = containsUnresolvedObjectTypeSpread;\n      shapeTypeDefinition.containsIndexers = containsIndexers; // Deprecated: containsSpread is not used anymore in the codebase, ensure to keep API backward compatibility\n\n      shapeTypeDefinition.containsSpread = containsSpread;\n      return shapeTypeDefinition;\n    },\n\n    UnionTypeAnnotation(annotation, parentName, seen) {\n      /** @type {UnionTypeDefinition} */\n      const unionTypeDefinition = {\n        type: 'union',\n        children: annotation.types.map(type => buildTypeAnnotationDeclarationTypes(type, parentName, seen))\n      };\n\n      if (unionTypeDefinition.children.length === 0) {\n        // no complex type found, simply accept everything\n        return {};\n      }\n\n      return unionTypeDefinition;\n    },\n\n    ArrayTypeAnnotation(annotation, parentName, seen) {\n      const fullName = [parentName, '*'].join('.');\n      const child = buildTypeAnnotationDeclarationTypes(annotation.elementType, fullName, seen);\n      child.fullName = fullName;\n      child.name = '__ANY_KEY__';\n      child.node = annotation;\n      return {\n        type: 'object',\n        children: {\n          __ANY_KEY__: child\n        }\n      };\n    }\n\n  };\n  /* eslint-enable no-use-before-define */\n\n  /**\n   * Resolve the type annotation for a given node.\n   * Flow annotations are sometimes wrapped in outer `TypeAnnotation`\n   * and `NullableTypeAnnotation` nodes which obscure the annotation we're\n   * interested in.\n   * This method also resolves type aliases where possible.\n   *\n   * @param {ASTNode} node The annotation or a node containing the type annotation.\n   * @returns {ASTNode} The resolved type annotation for the node.\n   */\n\n  function resolveTypeAnnotation(node) {\n    let annotation = node.left && node.left.typeAnnotation || node.typeAnnotation || node;\n\n    while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {\n      annotation = annotation.typeAnnotation;\n    }\n\n    if (annotation.type === 'GenericTypeAnnotation' && getInTypeScope(annotation.id.name)) {\n      return getInTypeScope(annotation.id.name);\n    }\n\n    return annotation;\n  }\n  /**\n   * Creates the representation of the React props type annotation for the component.\n   * The representation is used to verify nested used properties.\n   * @param {ASTNode} annotation Type annotation for the props class property.\n   * @param {String} parentName\n   * @param {Set<ASTNode>} [seen]\n   * @return {Object} The representation of the declaration, empty object means\n   *    the property is declared without the need for further analysis.\n   */\n\n\n  function buildTypeAnnotationDeclarationTypes(annotation, parentName, seen) {\n    if (typeof seen === 'undefined') {\n      // Keeps track of annotations we've already seen to\n      // prevent problems with recursive types.\n      seen = new Set();\n    }\n\n    if (seen.has(annotation)) {\n      // This must be a recursive type annotation, so just accept anything.\n      return {};\n    }\n\n    seen.add(annotation);\n\n    if (annotation.type in typeDeclarationBuilders) {\n      return typeDeclarationBuilders[annotation.type](annotation, parentName, seen);\n    }\n\n    return {};\n  }\n  /**\n   * Marks all props found inside ObjectTypeAnnotation as declared.\n   *\n   * Modifies the declaredProperties object\n   * @param {ASTNode} propTypes\n   * @param {Object} declaredPropTypes\n   * @returns {Boolean} True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)\n   */\n\n\n  function declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes) {\n    let ignorePropsValidation = false;\n    iterateProperties(context, propTypes.properties, (key, value, propNode) => {\n      if (!value) {\n        ignorePropsValidation = ignorePropsValidation || propNode.type !== 'ObjectTypeSpreadProperty';\n        return;\n      }\n\n      const types = buildTypeAnnotationDeclarationTypes(value, key);\n      types.fullName = key;\n      types.name = key;\n      types.node = propNode;\n      types.isRequired = !propNode.optional;\n      declaredPropTypes[key] = types;\n    }, spreadNode => {\n      const key = astUtil.getKeyValue(context, spreadNode);\n      const spreadAnnotation = getInTypeScope(key);\n\n      if (!spreadAnnotation) {\n        ignorePropsValidation = true;\n      } else {\n        const spreadIgnoreValidation = declarePropTypesForObjectTypeAnnotation(spreadAnnotation, declaredPropTypes);\n        ignorePropsValidation = ignorePropsValidation || spreadIgnoreValidation;\n      }\n    });\n    return ignorePropsValidation;\n  }\n  /**\n   * Marks all props found inside IntersectionTypeAnnotation as declared.\n   * Since InterSectionTypeAnnotations can be nested, this handles recursively.\n   *\n   * Modifies the declaredPropTypes object\n   * @param {ASTNode} propTypes\n   * @param {Object} declaredPropTypes\n   * @returns {Boolean} True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)\n   */\n\n\n  function declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes) {\n    return propTypes.types.some(annotation => {\n      if (annotation.type === 'ObjectTypeAnnotation') {\n        return declarePropTypesForObjectTypeAnnotation(annotation, declaredPropTypes);\n      }\n\n      if (annotation.type === 'UnionTypeAnnotation') {\n        return true;\n      } // Type can't be resolved\n\n\n      if (!annotation.id) {\n        return true;\n      }\n\n      const typeNode = getInTypeScope(annotation.id.name);\n\n      if (!typeNode) {\n        return true;\n      }\n\n      if (typeNode.type === 'IntersectionTypeAnnotation') {\n        return declarePropTypesForIntersectionTypeAnnotation(typeNode, declaredPropTypes);\n      }\n\n      return declarePropTypesForObjectTypeAnnotation(typeNode, declaredPropTypes);\n    });\n  }\n  /**\n   * Resolve node of type Identifier when building declaration types.\n   * @param {ASTNode} node\n   * @param {Function} callback called with the resolved value only if resolved.\n   */\n\n\n  function resolveValueForIdentifierNode(node, callback) {\n    if (node && node.type === 'Identifier') {\n      const scope = context.getScope();\n      const identVariable = scope.variableScope.variables.find(variable => variable.name === node.name);\n\n      if (identVariable) {\n        const definition = identVariable.defs[identVariable.defs.length - 1];\n        callback(definition.node.init);\n      }\n    }\n  }\n  /**\n   * Creates the representation of the React propTypes for the component.\n   * The representation is used to verify nested used properties.\n   * @param {ASTNode} value Node of the PropTypes for the desired property\n   * @param {string} parentName\n   * @return {Object} The representation of the declaration, empty object means\n   *    the property is declared without the need for further analysis.\n   */\n\n\n  function buildReactDeclarationTypes(value, parentName) {\n    if (value && value.callee && value.callee.object && hasCustomValidator(value.callee.object.name)) {\n      return {};\n    }\n\n    let identNodeResolved = false; // Resolve identifier node for cases where isRequired is set in\n    // the variable declaration or not at all.\n    // const variableType = PropTypes.shape({ foo: ... }).isRequired\n    // propTypes = {\n    //   example: variableType\n    // }\n    // --------\n    // const variableType = PropTypes.shape({ foo: ... })\n    // propTypes = {\n    //   example: variableType\n    // }\n\n    resolveValueForIdentifierNode(value, newValue => {\n      identNodeResolved = true;\n      value = newValue;\n    });\n\n    if (value && value.type === 'MemberExpression' && value.property && value.property.name && value.property.name === 'isRequired') {\n      value = value.object;\n    } // Resolve identifier node for cases where isRequired is set in\n    // the prop types.\n    // const variableType = PropTypes.shape({ foo: ... })\n    // propTypes = {\n    //   example: variableType.isRequired\n    // }\n\n\n    if (!identNodeResolved) {\n      resolveValueForIdentifierNode(value, newValue => {\n        value = newValue;\n      });\n    } // Verify PropTypes that are functions\n\n\n    if (value && value.type === 'CallExpression' && value.callee && value.callee.property && value.callee.property.name && value.arguments && value.arguments.length > 0) {\n      const callName = value.callee.property.name;\n      const argument = value.arguments[0];\n\n      switch (callName) {\n        case 'shape':\n        case 'exact':\n          {\n            if (argument.type !== 'ObjectExpression') {\n              // Invalid proptype or cannot analyse statically\n              return {};\n            }\n\n            const shapeTypeDefinition = {\n              type: callName,\n              children: {}\n            };\n            iterateProperties(context, argument.properties, (childKey, childValue, propNode) => {\n              if (childValue) {\n                // skip spread propTypes\n                const fullName = [parentName, childKey].join('.');\n                const types = buildReactDeclarationTypes(childValue, fullName);\n                types.fullName = fullName;\n                types.name = childKey;\n                types.node = propNode;\n                shapeTypeDefinition.children[childKey] = types;\n              }\n            });\n            return shapeTypeDefinition;\n          }\n\n        case 'arrayOf':\n        case 'objectOf':\n          {\n            const fullName = [parentName, '*'].join('.');\n            const child = buildReactDeclarationTypes(argument, fullName);\n            child.fullName = fullName;\n            child.name = '__ANY_KEY__';\n            child.node = argument;\n            return {\n              type: 'object',\n              children: {\n                __ANY_KEY__: child\n              }\n            };\n          }\n\n        case 'oneOfType':\n          {\n            if (!argument.elements || !argument.elements.length) {\n              // Invalid proptype or cannot analyse statically\n              return {};\n            }\n            /** @type {UnionTypeDefinition} */\n\n\n            const unionTypeDefinition = {\n              type: 'union',\n              children: argument.elements.map(element => buildReactDeclarationTypes(element, parentName))\n            };\n\n            if (unionTypeDefinition.children.length === 0) {\n              // no complex type found, simply accept everything\n              return {};\n            }\n\n            return unionTypeDefinition;\n          }\n\n        default:\n          return {};\n      }\n    } // Unknown property or accepts everything (any, object, ...)\n\n\n    return {};\n  }\n\n  function isValidReactGenericTypeAnnotation(annotation) {\n    if (annotation.typeName) {\n      if (annotation.typeName.name) {\n        // if FC<Props>\n        const typeName = annotation.typeName.name;\n\n        if (!genericReactTypesImport.has(typeName)) {\n          return false;\n        }\n      } else if (annotation.typeName.right.name) {\n        // if React.FC<Props>\n        const right = annotation.typeName.right.name;\n        const left = annotation.typeName.left.name;\n\n        if (!genericReactTypesImport.has(left) || !allowedGenericTypes.has(right)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Returns the left most typeName of a node, e.g: FC<Props>, React.FC<Props>\n   * The representation is used to verify nested used properties.\n   * @param {ASTNode} node\n   * @return {string | undefined}\n   */\n\n\n  function getLeftMostTypeName(node) {\n    if (node.name) return node.name;\n    if (node.left) return getLeftMostTypeName(node.left);\n  }\n\n  function getRightMostTypeName(node) {\n    if (node.name) return node.name;\n    if (node.right) return getRightMostTypeName(node.right);\n  }\n  /**\n   * Returns true if the node is either a interface or type alias declaration\n   * @param {ASTNode} node\n   * @return {boolean}\n   */\n\n\n  function filterInterfaceOrTypeAlias(node) {\n    return astUtil.isTSInterfaceDeclaration(node) || astUtil.isTSTypeAliasDeclaration(node);\n  }\n  /**\n   * Returns true if the interface or type alias declaration node name matches the type-name str\n   * @param {ASTNode} node\n   * @param {string} typeName\n   * @return {boolean}\n   */\n\n\n  function filterInterfaceOrAliasByName(node, typeName) {\n    return node.id && node.id.name === typeName || node.declaration && node.declaration.id && node.declaration.id.name === typeName;\n  }\n\n  class DeclarePropTypesForTSTypeAnnotation {\n    constructor(propTypes, declaredPropTypes) {\n      this.propTypes = propTypes;\n      this.declaredPropTypes = declaredPropTypes;\n      this.foundDeclaredPropertiesList = [];\n      this.referenceNameMap = new Set();\n      this.sourceCode = context.getSourceCode();\n      this.shouldIgnorePropTypes = false;\n      this.visitTSNode(this.propTypes);\n      this.endAndStructDeclaredPropTypes();\n    }\n    /**\n     * The node will be distribute to different function.\n     * @param {ASTNode} node\n     */\n\n\n    visitTSNode(node) {\n      if (!node) return;\n\n      if (astUtil.isTSTypeAnnotation(node)) {\n        const typeAnnotation = node.typeAnnotation;\n        this.visitTSNode(typeAnnotation);\n      } else if (astUtil.isTSTypeReference(node)) {\n        this.searchDeclarationByName(node);\n      } else if (astUtil.isTSInterfaceHeritage(node)) {\n        this.searchDeclarationByName(node);\n      } else if (astUtil.isTSTypeLiteral(node)) {\n        // Check node is an object literal\n        if (Array.isArray(node.members)) {\n          this.foundDeclaredPropertiesList = this.foundDeclaredPropertiesList.concat(node.members);\n        }\n      } else if (astUtil.isTSIntersectionType(node)) {\n        this.convertIntersectionTypeToPropTypes(node);\n      } else if (astUtil.isTSParenthesizedType(node)) {\n        const typeAnnotation = node.typeAnnotation;\n        this.visitTSNode(typeAnnotation);\n      } else if (astUtil.isTSTypeParameterInstantiation(node)) {\n        if (Array.isArray(node.params)) {\n          node.params.forEach(this.visitTSNode, this);\n        }\n      } else {\n        this.shouldIgnorePropTypes = true;\n      }\n    }\n    /**\n     * Search TSInterfaceDeclaration or TSTypeAliasDeclaration,\n     * by using TSTypeReference and TSInterfaceHeritage name.\n     * @param {ASTNode} node\n     */\n\n\n    searchDeclarationByName(node) {\n      let typeName;\n\n      if (astUtil.isTSTypeReference(node)) {\n        typeName = node.typeName.name;\n        const leftMostName = getLeftMostTypeName(node.typeName);\n        const shouldTraverseTypeParams = genericReactTypesImport.has(leftMostName);\n\n        if (shouldTraverseTypeParams && node.typeParameters && node.typeParameters.length !== 0) {\n          // All react Generic types are derived from:\n          // type PropsWithChildren<P> = P & { children?: ReactNode | undefined }\n          // So we should construct an optional children prop\n          this.shouldSpecifyOptionalChildrenProps = true;\n          const rightMostName = getRightMostTypeName(node.typeName);\n          const importedName = localToImportedMap[rightMostName];\n          const idx = genericTypeParamIndexWherePropsArePresent[leftMostName !== rightMostName ? rightMostName : importedName];\n          const nextNode = node.typeParameters.params[idx];\n          this.visitTSNode(nextNode);\n          return;\n        }\n      } else if (astUtil.isTSInterfaceHeritage(node)) {\n        if (!node.expression && node.id) {\n          typeName = node.id.name;\n        } else {\n          typeName = node.expression.name;\n        }\n      }\n\n      if (!typeName) {\n        this.shouldIgnorePropTypes = true;\n        return;\n      }\n\n      if (typeName === 'ReturnType') {\n        this.convertReturnTypeToPropTypes(node);\n        return;\n      } // Prevent recursive inheritance will cause maximum callstack.\n\n\n      if (this.referenceNameMap.has(typeName)) {\n        this.shouldIgnorePropTypes = true;\n        return;\n      } // Add typeName to Set and consider it as traversed.\n\n\n      this.referenceNameMap.add(typeName);\n      /**\n       * From line 577 to line 581, and line 588 to line 590 are trying to handle typescript-eslint-parser\n       * Need to be deprecated after remove typescript-eslint-parser support.\n       */\n\n      const candidateTypes = this.sourceCode.ast.body.filter(item => astUtil.isTSTypeDeclaration(item));\n      const declarations = flatMap(candidateTypes, type => type.declarations || type.declaration && type.declaration.declarations || type.declaration); // we tried to find either an interface or a type with the TypeReference name\n\n      const typeDeclaration = declarations.filter(dec => dec.id.name === typeName);\n      const interfaceDeclarations = this.sourceCode.ast.body.filter(filterInterfaceOrTypeAlias).filter(item => filterInterfaceOrAliasByName(item, typeName)).map(item => item.declaration || item);\n\n      if (typeDeclaration.length !== 0) {\n        typeDeclaration.map(t => t.init || t.typeAnnotation).forEach(this.visitTSNode, this);\n      } else if (interfaceDeclarations.length !== 0) {\n        interfaceDeclarations.forEach(this.traverseDeclaredInterfaceOrTypeAlias, this);\n      } else {\n        this.shouldIgnorePropTypes = true;\n      }\n    }\n    /**\n     * Traverse TSInterfaceDeclaration and TSTypeAliasDeclaration\n     * which retrieve from function searchDeclarationByName;\n     * @param {ASTNode} node\n     */\n\n\n    traverseDeclaredInterfaceOrTypeAlias(node) {\n      if (astUtil.isTSInterfaceDeclaration(node)) {\n        // Handle TSInterfaceDeclaration interface Props { name: string, id: number}, should put in properties list directly;\n        this.foundDeclaredPropertiesList = this.foundDeclaredPropertiesList.concat(node.body.body);\n      } // Handle TSTypeAliasDeclaration type Props = {name:string}\n\n\n      if (astUtil.isTSTypeAliasDeclaration(node)) {\n        const typeAnnotation = node.typeAnnotation;\n        this.visitTSNode(typeAnnotation);\n      }\n\n      if (Array.isArray(node.extends)) {\n        node.extends.forEach(this.visitTSNode, this); // This line is trying to handle typescript-eslint-parser\n        // typescript-eslint-parser extension is name as heritage\n      } else if (Array.isArray(node.heritage)) {\n        node.heritage.forEach(this.visitTSNode, this);\n      }\n    }\n\n    convertIntersectionTypeToPropTypes(node) {\n      if (!node) return;\n\n      if (Array.isArray(node.types)) {\n        node.types.forEach(this.visitTSNode, this);\n      } else {\n        this.shouldIgnorePropTypes = true;\n      }\n    }\n\n    convertReturnTypeToPropTypes(node) {\n      // ReturnType<T> should always have one parameter\n      if (node.typeParameters) {\n        if (node.typeParameters.params.length === 1) {\n          let returnType = node.typeParameters.params[0]; // This line is trying to handle typescript-eslint-parser\n          // typescript-eslint-parser TSTypeQuery is wrapped by TSTypeReference\n\n          if (astUtil.isTSTypeReference(returnType)) {\n            returnType = returnType.typeName;\n          } // Handle ReturnType<typeof mapStateToProps>\n\n\n          if (astUtil.isTSTypeQuery(returnType)) {\n            const returnTypeFunction = flatMap(this.sourceCode.ast.body.filter(item => item.type === 'VariableDeclaration' && item.declarations.find(dec => dec.id.name === returnType.exprName.name)), type => type.declarations).map(dec => dec.init);\n\n            if (Array.isArray(returnTypeFunction)) {\n              if (returnTypeFunction.length === 0) {\n                // Cannot find identifier in current scope. It might be an exported type.\n                this.shouldIgnorePropTypes = true;\n                return;\n              }\n\n              returnTypeFunction.forEach(func => {\n                if (isFunctionType(func)) {\n                  let res = func.body;\n\n                  if (res.type === 'BlockStatement') {\n                    res = astUtil.findReturnStatement(func);\n\n                    if (res) {\n                      res = res.argument;\n                    }\n                  }\n\n                  switch (res.type) {\n                    case 'ObjectExpression':\n                      iterateProperties(context, res.properties, (key, value, propNode) => {\n                        if (propNode && propNode.argument && propNode.argument.type === 'CallExpression') {\n                          if (propNode.argument.typeParameters) {\n                            this.visitTSNode(propNode.argument.typeParameters);\n                          } else {\n                            // Ignore this CallExpression return value since it doesn't have any typeParameters to let us know it's types.\n                            this.shouldIgnorePropTypes = true;\n                            return;\n                          }\n                        }\n\n                        if (!value) {\n                          this.shouldIgnorePropTypes = true;\n                          return;\n                        }\n\n                        const types = buildReactDeclarationTypes(value, key);\n                        types.fullName = key;\n                        types.name = key;\n                        types.node = propNode;\n                        types.isRequired = propsUtil.isRequiredPropType(value);\n                        this.declaredPropTypes[key] = types;\n                      });\n                      break;\n\n                    case 'CallExpression':\n                      if (res.typeParameters) {\n                        this.visitTSNode(res.typeParameters);\n                      } else {\n                        // Ignore this CallExpression return value since it doesn't have any typeParameters to let us know it's types.\n                        this.shouldIgnorePropTypes = true;\n                      }\n\n                      break;\n\n                    default:\n                  }\n                }\n              });\n              return;\n            }\n          } // Handle ReturnType<()=>returnType>\n\n\n          if (astUtil.isTSFunctionType(returnType)) {\n            if (astUtil.isTSTypeAnnotation(returnType.returnType)) {\n              this.visitTSNode(returnType.returnType);\n              return;\n            } // This line is trying to handle typescript-eslint-parser\n            // typescript-eslint-parser TSFunction name returnType as typeAnnotation\n\n\n            if (astUtil.isTSTypeAnnotation(returnType.typeAnnotation)) {\n              this.visitTSNode(returnType.typeAnnotation);\n              return;\n            }\n          }\n        }\n      }\n\n      this.shouldIgnorePropTypes = true;\n    }\n\n    endAndStructDeclaredPropTypes() {\n      if (this.shouldSpecifyOptionalChildrenProps) {\n        this.declaredPropTypes.children = {\n          fullName: 'children',\n          name: 'children',\n          isRequired: false\n        };\n      }\n\n      this.foundDeclaredPropertiesList.forEach(tsInterfaceBody => {\n        if (tsInterfaceBody && (tsInterfaceBody.type === 'TSPropertySignature' || tsInterfaceBody.type === 'TSMethodSignature')) {\n          let accessor = 'name';\n\n          if (tsInterfaceBody.key.type === 'Literal') {\n            if (typeof tsInterfaceBody.key.value === 'number') {\n              accessor = 'raw';\n            } else {\n              accessor = 'value';\n            }\n          }\n\n          this.declaredPropTypes[tsInterfaceBody.key[accessor]] = {\n            fullName: tsInterfaceBody.key[accessor],\n            name: tsInterfaceBody.key[accessor],\n            node: tsInterfaceBody,\n            isRequired: !tsInterfaceBody.optional\n          };\n        }\n      });\n    }\n\n  }\n  /**\n   * Mark a prop type as declared\n   * @param {ASTNode} node The AST node being checked.\n   * @param {ASTNode} propTypes The AST node containing the proptypes\n   */\n\n\n  function markPropTypesAsDeclared(node, propTypes) {\n    let componentNode = node;\n\n    while (componentNode && !components.get(componentNode)) {\n      componentNode = componentNode.parent;\n    }\n\n    const component = components.get(componentNode);\n    let declaredPropTypes = component && component.declaredPropTypes || {};\n    let ignorePropsValidation = component && component.ignorePropsValidation || false;\n\n    switch (propTypes && propTypes.type) {\n      case 'ObjectTypeAnnotation':\n        ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes);\n        break;\n\n      case 'ObjectExpression':\n        iterateProperties(context, propTypes.properties, (key, value, propNode) => {\n          if (!value) {\n            ignorePropsValidation = true;\n            return;\n          }\n\n          const types = buildReactDeclarationTypes(value, key);\n          types.fullName = key;\n          types.name = key;\n          types.node = propNode;\n          types.isRequired = propsUtil.isRequiredPropType(value);\n          declaredPropTypes[key] = types;\n        });\n        break;\n\n      case 'MemberExpression':\n        {\n          let curDeclaredPropTypes = declaredPropTypes; // Walk the list of properties, until we reach the assignment\n          // ie: ClassX.propTypes.a.b.c = ...\n\n          while (propTypes && propTypes.parent && propTypes.parent.type !== 'AssignmentExpression' && propTypes.property && curDeclaredPropTypes) {\n            const propName = propTypes.property.name;\n\n            if (propName in curDeclaredPropTypes) {\n              curDeclaredPropTypes = curDeclaredPropTypes[propName].children;\n              propTypes = propTypes.parent;\n            } else {\n              // This will crash at runtime because we haven't seen this key before\n              // stop this and do not declare it\n              propTypes = null;\n            }\n          }\n\n          if (propTypes && propTypes.parent && propTypes.property) {\n            if (!(propTypes === propTypes.parent.left && propTypes.parent.left.object)) {\n              ignorePropsValidation = true;\n              break;\n            }\n\n            const parentProp = context.getSource(propTypes.parent.left.object).replace(/^.*\\.propTypes\\./, '');\n            const types = buildReactDeclarationTypes(propTypes.parent.right, parentProp);\n            types.name = propTypes.property.name;\n            types.fullName = [parentProp, propTypes.property.name].join('.');\n            types.node = propTypes.parent;\n            types.isRequired = propsUtil.isRequiredPropType(propTypes.parent.right);\n            curDeclaredPropTypes[propTypes.property.name] = types;\n          } else {\n            let isUsedInPropTypes = false;\n            let n = propTypes;\n\n            while (n) {\n              if (n.type === 'AssignmentExpression' && propsUtil.isPropTypesDeclaration(n.left) || (n.type === 'ClassProperty' || n.type === 'PropertyDefinition' || n.type === 'Property') && propsUtil.isPropTypesDeclaration(n)) {\n                // Found a propType used inside of another propType. This is not considered usage, we'll still validate\n                // this component.\n                isUsedInPropTypes = true;\n                break;\n              }\n\n              n = n.parent;\n            }\n\n            if (!isUsedInPropTypes) {\n              ignorePropsValidation = true;\n            }\n          }\n\n          break;\n        }\n\n      case 'Identifier':\n        {\n          const variablesInScope = variableUtil.variablesInScope(context);\n          const firstMatchingVariable = variablesInScope.find(variableInScope => variableInScope.name === propTypes.name);\n\n          if (firstMatchingVariable) {\n            const defInScope = firstMatchingVariable.defs[firstMatchingVariable.defs.length - 1];\n            markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init);\n            return;\n          }\n\n          ignorePropsValidation = true;\n          break;\n        }\n\n      case 'CallExpression':\n        {\n          if (propWrapperUtil.isPropWrapperFunction(context, context.getSourceCode().getText(propTypes.callee)) && propTypes.arguments && propTypes.arguments[0]) {\n            markPropTypesAsDeclared(node, propTypes.arguments[0]);\n            return;\n          }\n\n          break;\n        }\n\n      case 'IntersectionTypeAnnotation':\n        ignorePropsValidation = declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes);\n        break;\n\n      case 'GenericTypeAnnotation':\n        if (propTypes.id.name === '$ReadOnly') {\n          ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(propTypes.typeParameters.params[0], declaredPropTypes);\n        } else {\n          ignorePropsValidation = true;\n        }\n\n        break;\n\n      case 'TSTypeReference':\n      case 'TSTypeAnnotation':\n        {\n          const tsTypeAnnotation = new DeclarePropTypesForTSTypeAnnotation(propTypes, declaredPropTypes);\n          ignorePropsValidation = tsTypeAnnotation.shouldIgnorePropTypes;\n          declaredPropTypes = tsTypeAnnotation.declaredPropTypes;\n        }\n        break;\n\n      case null:\n        break;\n\n      default:\n        ignorePropsValidation = true;\n        break;\n    }\n\n    components.set(node, {\n      declaredPropTypes,\n      ignorePropsValidation\n    });\n  }\n  /**\n   * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n   *   FunctionDeclaration, or FunctionExpression\n   */\n\n\n  function markAnnotatedFunctionArgumentsAsDeclared(node) {\n    if (!node.params || !node.params.length) {\n      return;\n    }\n\n    if (node.parent && node.parent.callee && node.parent.typeParameters && node.parent.typeParameters.params && (node.parent.callee.name === 'forwardRef' || node.parent.callee.object && node.parent.callee.property && node.parent.callee.object.name === 'React' && node.parent.callee.property.name === 'forwardRef')) {\n      const propTypes = node.parent.typeParameters.params[1];\n      const declaredPropTypes = {};\n      const obj = new DeclarePropTypesForTSTypeAnnotation(propTypes, declaredPropTypes);\n      components.set(node, {\n        declaredPropTypes: obj.declaredPropTypes,\n        ignorePropsValidation: obj.shouldIgnorePropTypes\n      });\n      return;\n    }\n\n    const siblingIdentifier = node.parent && node.parent.id;\n    const siblingHasTypeAnnotation = siblingIdentifier && siblingIdentifier.typeAnnotation;\n    const isNodeAnnotated = annotations.isAnnotatedFunctionPropsDeclaration(node, context);\n\n    if (!isNodeAnnotated && !siblingHasTypeAnnotation) {\n      return;\n    } // https://github.com/jsx-eslint/eslint-plugin-react/issues/2784\n\n\n    if (isInsideClassBody(node) && !astUtil.isFunction(node)) {\n      return;\n    } // Should ignore function that not return JSXElement\n\n\n    if (!utils.isReturningJSXOrNull(node) || startWithCapitalizedLetter(node)) {\n      return;\n    }\n\n    if (isNodeAnnotated) {\n      const param = node.params[0];\n\n      if (param.typeAnnotation && param.typeAnnotation.typeAnnotation && param.typeAnnotation.typeAnnotation.type === 'UnionTypeAnnotation') {\n        param.typeAnnotation.typeAnnotation.types.forEach(annotation => {\n          if (annotation.type === 'GenericTypeAnnotation') {\n            markPropTypesAsDeclared(node, resolveTypeAnnotation(annotation));\n          } else {\n            markPropTypesAsDeclared(node, annotation);\n          }\n        });\n      } else {\n        markPropTypesAsDeclared(node, resolveTypeAnnotation(param));\n      }\n    } else {\n      // implements what's discussed here: https://github.com/jsx-eslint/eslint-plugin-react/issues/2777#issuecomment-683944481\n      const annotation = siblingIdentifier.typeAnnotation.typeAnnotation;\n\n      if (annotation && annotation.type !== 'TSTypeReference' && annotation.typeParameters == null) {\n        return;\n      }\n\n      if (!isValidReactGenericTypeAnnotation(annotation)) return;\n      markPropTypesAsDeclared(node, resolveTypeAnnotation(siblingIdentifier));\n    }\n  }\n  /**\n   * Resolve the type annotation for a given class declaration node with superTypeParameters.\n   *\n   * @param {ASTNode} node The annotation or a node containing the type annotation.\n   * @returns {ASTNode} The resolved type annotation for the node.\n   */\n\n\n  function resolveSuperParameterPropsType(node) {\n    let propsParameterPosition;\n\n    try {\n      // Flow <=0.52 had 3 required TypedParameters of which the second one is the Props.\n      // Flow >=0.53 has 2 optional TypedParameters of which the first one is the Props.\n      propsParameterPosition = testFlowVersion(context, '>= 0.53.0') ? 0 : 1;\n    } catch (e) {\n      // In case there is no flow version defined, we can safely assume that when there are 3 Props we are dealing with version <= 0.52\n      propsParameterPosition = node.superTypeParameters.params.length <= 2 ? 0 : 1;\n    }\n\n    let annotation = node.superTypeParameters.params[propsParameterPosition];\n\n    while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {\n      annotation = annotation.typeAnnotation;\n    }\n\n    if (annotation && annotation.type === 'GenericTypeAnnotation' && getInTypeScope(annotation.id.name)) {\n      return getInTypeScope(annotation.id.name);\n    }\n\n    return annotation;\n  }\n  /**\n   * Checks if we are declaring a `props` class property with a flow type annotation.\n   * @param {ASTNode} node The AST node being checked.\n   * @returns {Boolean} True if the node is a type annotated props declaration, false if not.\n   */\n\n\n  function isAnnotatedClassPropsDeclaration(node) {\n    if (node && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition')) {\n      const tokens = context.getFirstTokens(node, 2);\n\n      if (node.typeAnnotation && (tokens[0].value === 'props' || tokens[1] && tokens[1].value === 'props')) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return {\n    ClassExpression(node) {\n      // TypeParameterDeclaration need to be added to typeScope in order to handle ClassExpressions.\n      // This visitor is executed before TypeParameterDeclaration are scoped, therefore we postpone\n      // processing class expressions until when the program exists.\n      classExpressions.push(node);\n    },\n\n    ClassDeclaration(node) {\n      if (isSuperTypeParameterPropsDeclaration(node)) {\n        markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));\n      }\n    },\n\n    'ClassProperty, PropertyDefinition'(node) {\n      if (isAnnotatedClassPropsDeclaration(node)) {\n        markPropTypesAsDeclared(node, resolveTypeAnnotation(node));\n      } else if (propsUtil.isPropTypesDeclaration(node)) {\n        markPropTypesAsDeclared(node, node.value);\n      }\n    },\n\n    ObjectExpression(node) {\n      // Search for the proptypes declaration\n      node.properties.forEach(property => {\n        if (!propsUtil.isPropTypesDeclaration(property)) {\n          return;\n        }\n\n        markPropTypesAsDeclared(node, property.value);\n      });\n    },\n\n    FunctionExpression(node) {\n      if (node.parent.type !== 'MethodDefinition') {\n        markAnnotatedFunctionArgumentsAsDeclared(node);\n      }\n    },\n\n    ImportDeclaration(node) {\n      // parse `import ... from 'react`\n      if (node.source.value === 'react') {\n        node.specifiers.forEach(specifier => {\n          if ( // handles import * as X from 'react'\n          specifier.type === 'ImportNamespaceSpecifier' // handles import React from 'react'\n          || specifier.type === 'ImportDefaultSpecifier') {\n            genericReactTypesImport.add(specifier.local.name);\n          } // handles import { FC } from 'react' or import { FC as X } from 'react'\n\n\n          if (specifier.type === 'ImportSpecifier' && allowedGenericTypes.has(specifier.imported.name)) {\n            genericReactTypesImport.add(specifier.local.name);\n            localToImportedMap[specifier.local.name] = specifier.imported.name;\n          }\n        });\n      }\n    },\n\n    FunctionDeclaration: markAnnotatedFunctionArgumentsAsDeclared,\n    ArrowFunctionExpression: markAnnotatedFunctionArgumentsAsDeclared,\n\n    MemberExpression(node) {\n      if (propsUtil.isPropTypesDeclaration(node)) {\n        const component = utils.getRelatedComponent(node);\n\n        if (!component) {\n          return;\n        }\n\n        try {\n          markPropTypesAsDeclared(component.node, node.parent.right || node.parent);\n        } catch (e) {\n          if (e.constructor !== RangeError) {\n            throw e;\n          }\n        }\n      }\n    },\n\n    MethodDefinition(node) {\n      if (!node.static || node.kind !== 'get' || !propsUtil.isPropTypesDeclaration(node)) {\n        return;\n      }\n\n      let i = node.value.body.body.length - 1;\n\n      for (; i >= 0; i--) {\n        if (node.value.body.body[i].type === 'ReturnStatement') {\n          break;\n        }\n      }\n\n      if (i >= 0) {\n        markPropTypesAsDeclared(node, node.value.body.body[i].argument);\n      }\n    },\n\n    TypeAlias(node) {\n      setInTypeScope(node.id.name, node.right);\n    },\n\n    TypeParameterDeclaration(node) {\n      const identifier = node.params[0];\n\n      if (identifier.typeAnnotation) {\n        setInTypeScope(identifier.name, identifier.typeAnnotation.typeAnnotation);\n      }\n    },\n\n    Program() {\n      stack = [{}];\n    },\n\n    BlockStatement() {\n      stack.push(Object.create(typeScope()));\n    },\n\n    'BlockStatement:exit'() {\n      stack.pop();\n    },\n\n    'Program:exit'() {\n      classExpressions.forEach(node => {\n        if (isSuperTypeParameterPropsDeclaration(node)) {\n          markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));\n        }\n      });\n    }\n\n  };\n};","map":{"version":3,"names":["flatMap","require","annotations","propsUtil","variableUtil","testFlowVersion","propWrapperUtil","astUtil","isFirstLetterCapitalized","isFunctionType","node","nodeType","type","isSuperTypeParameterPropsDeclaration","superTypeParameters","params","length","iterateProperties","context","properties","fn","handleSpreadFn","i","j","key","getKeyValue","argument","value","isInsideClassBody","parent","startWithCapitalizedLetter","id","name","module","exports","propTypesInstructions","components","utils","stack","classExpressions","defaults","customValidators","configuration","Object","assign","options","allowedGenericTypes","Set","genericTypeParamIndexWherePropsArePresent","ForwardRefRenderFunction","forwardRef","VoidFunctionComponent","VFC","PropsWithChildren","SFC","StatelessComponent","FunctionComponent","FC","genericReactTypesImport","localToImportedMap","typeScope","getInTypeScope","setInTypeScope","hasCustomValidator","validator","indexOf","typeDeclarationBuilders","GenericTypeAnnotation","annotation","parentName","seen","buildTypeAnnotationDeclarationTypes","ObjectTypeAnnotation","containsUnresolvedObjectTypeSpread","containsSpread","containsIndexers","Boolean","indexers","shapeTypeDefinition","children","childKey","childValue","propNode","fullName","join","types","isRequired","optional","spreadNode","containsUnresolvedSpread","UnionTypeAnnotation","unionTypeDefinition","map","ArrayTypeAnnotation","child","elementType","__ANY_KEY__","resolveTypeAnnotation","left","typeAnnotation","has","add","declarePropTypesForObjectTypeAnnotation","propTypes","declaredPropTypes","ignorePropsValidation","spreadAnnotation","spreadIgnoreValidation","declarePropTypesForIntersectionTypeAnnotation","some","typeNode","resolveValueForIdentifierNode","callback","scope","getScope","identVariable","variableScope","variables","find","variable","definition","defs","init","buildReactDeclarationTypes","callee","object","identNodeResolved","newValue","property","arguments","callName","elements","element","isValidReactGenericTypeAnnotation","typeName","right","getLeftMostTypeName","getRightMostTypeName","filterInterfaceOrTypeAlias","isTSInterfaceDeclaration","isTSTypeAliasDeclaration","filterInterfaceOrAliasByName","declaration","DeclarePropTypesForTSTypeAnnotation","constructor","foundDeclaredPropertiesList","referenceNameMap","sourceCode","getSourceCode","shouldIgnorePropTypes","visitTSNode","endAndStructDeclaredPropTypes","isTSTypeAnnotation","isTSTypeReference","searchDeclarationByName","isTSInterfaceHeritage","isTSTypeLiteral","Array","isArray","members","concat","isTSIntersectionType","convertIntersectionTypeToPropTypes","isTSParenthesizedType","isTSTypeParameterInstantiation","forEach","leftMostName","shouldTraverseTypeParams","typeParameters","shouldSpecifyOptionalChildrenProps","rightMostName","importedName","idx","nextNode","expression","convertReturnTypeToPropTypes","candidateTypes","ast","body","filter","item","isTSTypeDeclaration","declarations","typeDeclaration","dec","interfaceDeclarations","t","traverseDeclaredInterfaceOrTypeAlias","extends","heritage","returnType","isTSTypeQuery","returnTypeFunction","exprName","func","res","findReturnStatement","isRequiredPropType","isTSFunctionType","tsInterfaceBody","accessor","markPropTypesAsDeclared","componentNode","get","component","curDeclaredPropTypes","propName","parentProp","getSource","replace","isUsedInPropTypes","n","isPropTypesDeclaration","variablesInScope","firstMatchingVariable","variableInScope","defInScope","isPropWrapperFunction","getText","tsTypeAnnotation","set","markAnnotatedFunctionArgumentsAsDeclared","obj","siblingIdentifier","siblingHasTypeAnnotation","isNodeAnnotated","isAnnotatedFunctionPropsDeclaration","isFunction","isReturningJSXOrNull","param","resolveSuperParameterPropsType","propsParameterPosition","e","isAnnotatedClassPropsDeclaration","tokens","getFirstTokens","ClassExpression","push","ClassDeclaration","ObjectExpression","FunctionExpression","ImportDeclaration","source","specifiers","specifier","local","imported","FunctionDeclaration","ArrowFunctionExpression","MemberExpression","getRelatedComponent","RangeError","MethodDefinition","static","kind","TypeAlias","TypeParameterDeclaration","identifier","Program","BlockStatement","create","pop"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/util/propTypes.js"],"sourcesContent":["/**\n * @fileoverview Common propTypes detection functionality.\n */\n\n'use strict';\n\nconst flatMap = require('array.prototype.flatmap');\n\nconst annotations = require('./annotations');\nconst propsUtil = require('./props');\nconst variableUtil = require('./variable');\nconst testFlowVersion = require('./version').testFlowVersion;\nconst propWrapperUtil = require('./propWrapper');\nconst astUtil = require('./ast');\nconst isFirstLetterCapitalized = require('./isFirstLetterCapitalized');\n\n/**\n * Check if node is function type.\n * @param {ASTNode} node\n * @returns {Boolean}\n */\nfunction isFunctionType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'FunctionDeclaration'\n    || nodeType === 'FunctionExpression'\n    || nodeType === 'ArrowFunctionExpression';\n}\n\n/**\n * Checks if we are declaring a props as a generic type in a flow-annotated class.\n *\n * @param {ASTNode} node  the AST node being checked.\n * @returns {Boolean} True if the node is a class with generic prop types, false if not.\n */\nfunction isSuperTypeParameterPropsDeclaration(node) {\n  if (node && (node.type === 'ClassDeclaration' || node.type === 'ClassExpression')) {\n    if (node.superTypeParameters && node.superTypeParameters.params.length > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Iterates through a properties node, like a customized forEach.\n * @param {Object} context Array of properties to iterate.\n * @param {Object[]} properties Array of properties to iterate.\n * @param {Function} fn Function to call on each property, receives property key\n    and property value. (key, value) => void\n  * @param {Function} [handleSpreadFn] Function to call on each ObjectTypeSpreadProperty, receives the\n    argument\n */\nfunction iterateProperties(context, properties, fn, handleSpreadFn) {\n  if (properties && properties.length && typeof fn === 'function') {\n    for (let i = 0, j = properties.length; i < j; i++) {\n      const node = properties[i];\n      const key = astUtil.getKeyValue(context, node);\n\n      if (node.type === 'ObjectTypeSpreadProperty' && typeof handleSpreadFn === 'function') {\n        handleSpreadFn(node.argument);\n      }\n\n      const value = node.value;\n      fn(key, value, node);\n    }\n  }\n}\n\n/**\n * Checks if a node is inside a class body.\n *\n * @param {ASTNode} node  the AST node being checked.\n * @returns {Boolean} True if the node has a ClassBody ancestor, false if not.\n */\nfunction isInsideClassBody(node) {\n  let parent = node.parent;\n  while (parent) {\n    if (parent.type === 'ClassBody') {\n      return true;\n    }\n    parent = parent.parent;\n  }\n  return false;\n}\n\nfunction startWithCapitalizedLetter(node) {\n  return (\n    node.parent.type === 'VariableDeclarator'\n    && !isFirstLetterCapitalized(node.parent.id.name)\n  );\n}\n\nmodule.exports = function propTypesInstructions(context, components, utils) {\n  // Used to track the type annotations in scope.\n  // Necessary because babel's scopes do not track type annotations.\n  let stack = null;\n\n  const classExpressions = [];\n  const defaults = { customValidators: [] };\n  const configuration = Object.assign({}, defaults, context.options[0] || {});\n  const customValidators = configuration.customValidators;\n  const allowedGenericTypes = new Set(['forwardRef', 'ForwardRefRenderFunction', 'VFC', 'VoidFunctionComponent', 'PropsWithChildren', 'SFC', 'StatelessComponent', 'FunctionComponent', 'FC']);\n  const genericTypeParamIndexWherePropsArePresent = {\n    ForwardRefRenderFunction: 1,\n    forwardRef: 1,\n    VoidFunctionComponent: 0,\n    VFC: 0,\n    PropsWithChildren: 0,\n    SFC: 0,\n    StatelessComponent: 0,\n    FunctionComponent: 0,\n    FC: 0,\n  };\n  const genericReactTypesImport = new Set();\n  // import { FC as X } from 'react' -> localToImportedMap = { x: FC }\n  const localToImportedMap = {};\n\n  /**\n   * Returns the full scope.\n   * @returns {Object} The whole scope.\n   */\n  function typeScope() {\n    return stack[stack.length - 1];\n  }\n\n  /**\n   * Gets a node from the scope.\n   * @param {string} key The name of the identifier to access.\n   * @returns {ASTNode} The ASTNode associated with the given identifier.\n   */\n  function getInTypeScope(key) {\n    return stack[stack.length - 1][key];\n  }\n\n  /**\n   * Sets the new value in the scope.\n   * @param {string} key The name of the identifier to access\n   * @param {ASTNode} value The new value for the identifier.\n   * @returns {ASTNode} The ASTNode associated with the given identifier.\n   */\n  function setInTypeScope(key, value) {\n    stack[stack.length - 1][key] = value;\n    return value;\n  }\n\n  /**\n   * Checks if prop should be validated by plugin-react-proptypes\n   * @param {String} validator Name of validator to check.\n   * @returns {Boolean} True if validator should be checked by custom validator.\n   */\n  function hasCustomValidator(validator) {\n    return customValidators.indexOf(validator) !== -1;\n  }\n\n  /* eslint-disable no-use-before-define */\n  /** @type {TypeDeclarationBuilders} */\n  const typeDeclarationBuilders = {\n    GenericTypeAnnotation(annotation, parentName, seen) {\n      if (getInTypeScope(annotation.id.name)) {\n        return buildTypeAnnotationDeclarationTypes(getInTypeScope(annotation.id.name), parentName, seen);\n      }\n      return {};\n    },\n\n    ObjectTypeAnnotation(annotation, parentName, seen) {\n      let containsUnresolvedObjectTypeSpread = false;\n      let containsSpread = false;\n      const containsIndexers = Boolean(annotation.indexers && annotation.indexers.length);\n      const shapeTypeDefinition = {\n        type: 'shape',\n        children: {},\n      };\n      iterateProperties(\n        context,\n        annotation.properties,\n        (childKey, childValue, propNode) => {\n          const fullName = [parentName, childKey].join('.');\n          if (childKey || childValue) {\n            const types = buildTypeAnnotationDeclarationTypes(childValue, fullName, seen);\n            types.fullName = fullName;\n            types.name = childKey;\n            types.node = propNode;\n            types.isRequired = !childValue.optional;\n            shapeTypeDefinition.children[childKey] = types;\n          }\n        },\n        (spreadNode) => {\n          const key = astUtil.getKeyValue(context, spreadNode);\n          const types = buildTypeAnnotationDeclarationTypes(spreadNode, key, seen);\n          if (!types.children) {\n            containsUnresolvedObjectTypeSpread = true;\n          } else {\n            Object.assign(shapeTypeDefinition, types.children);\n          }\n          containsSpread = true;\n        }\n      );\n\n      // Mark if this shape has spread or an indexer. We will know to consider all props from this shape as having propTypes,\n      // but still have the ability to detect unused children of this shape.\n      shapeTypeDefinition.containsUnresolvedSpread = containsUnresolvedObjectTypeSpread;\n      shapeTypeDefinition.containsIndexers = containsIndexers;\n      // Deprecated: containsSpread is not used anymore in the codebase, ensure to keep API backward compatibility\n      shapeTypeDefinition.containsSpread = containsSpread;\n\n      return shapeTypeDefinition;\n    },\n\n    UnionTypeAnnotation(annotation, parentName, seen) {\n      /** @type {UnionTypeDefinition} */\n      const unionTypeDefinition = {\n        type: 'union',\n        children: annotation.types.map((type) => buildTypeAnnotationDeclarationTypes(type, parentName, seen)),\n      };\n      if (unionTypeDefinition.children.length === 0) {\n        // no complex type found, simply accept everything\n        return {};\n      }\n      return unionTypeDefinition;\n    },\n\n    ArrayTypeAnnotation(annotation, parentName, seen) {\n      const fullName = [parentName, '*'].join('.');\n      const child = buildTypeAnnotationDeclarationTypes(annotation.elementType, fullName, seen);\n      child.fullName = fullName;\n      child.name = '__ANY_KEY__';\n      child.node = annotation;\n      return {\n        type: 'object',\n        children: {\n          __ANY_KEY__: child,\n        },\n      };\n    },\n  };\n  /* eslint-enable no-use-before-define */\n\n  /**\n   * Resolve the type annotation for a given node.\n   * Flow annotations are sometimes wrapped in outer `TypeAnnotation`\n   * and `NullableTypeAnnotation` nodes which obscure the annotation we're\n   * interested in.\n   * This method also resolves type aliases where possible.\n   *\n   * @param {ASTNode} node The annotation or a node containing the type annotation.\n   * @returns {ASTNode} The resolved type annotation for the node.\n   */\n  function resolveTypeAnnotation(node) {\n    let annotation = (node.left && node.left.typeAnnotation) || node.typeAnnotation || node;\n    while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {\n      annotation = annotation.typeAnnotation;\n    }\n    if (annotation.type === 'GenericTypeAnnotation' && getInTypeScope(annotation.id.name)) {\n      return getInTypeScope(annotation.id.name);\n    }\n    return annotation;\n  }\n\n  /**\n   * Creates the representation of the React props type annotation for the component.\n   * The representation is used to verify nested used properties.\n   * @param {ASTNode} annotation Type annotation for the props class property.\n   * @param {String} parentName\n   * @param {Set<ASTNode>} [seen]\n   * @return {Object} The representation of the declaration, empty object means\n   *    the property is declared without the need for further analysis.\n   */\n  function buildTypeAnnotationDeclarationTypes(annotation, parentName, seen) {\n    if (typeof seen === 'undefined') {\n      // Keeps track of annotations we've already seen to\n      // prevent problems with recursive types.\n      seen = new Set();\n    }\n    if (seen.has(annotation)) {\n      // This must be a recursive type annotation, so just accept anything.\n      return {};\n    }\n    seen.add(annotation);\n\n    if (annotation.type in typeDeclarationBuilders) {\n      return typeDeclarationBuilders[annotation.type](annotation, parentName, seen);\n    }\n    return {};\n  }\n\n  /**\n   * Marks all props found inside ObjectTypeAnnotation as declared.\n   *\n   * Modifies the declaredProperties object\n   * @param {ASTNode} propTypes\n   * @param {Object} declaredPropTypes\n   * @returns {Boolean} True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)\n   */\n  function declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes) {\n    let ignorePropsValidation = false;\n\n    iterateProperties(context, propTypes.properties, (key, value, propNode) => {\n      if (!value) {\n        ignorePropsValidation = ignorePropsValidation || propNode.type !== 'ObjectTypeSpreadProperty';\n        return;\n      }\n\n      const types = buildTypeAnnotationDeclarationTypes(value, key);\n      types.fullName = key;\n      types.name = key;\n      types.node = propNode;\n      types.isRequired = !propNode.optional;\n      declaredPropTypes[key] = types;\n    }, (spreadNode) => {\n      const key = astUtil.getKeyValue(context, spreadNode);\n      const spreadAnnotation = getInTypeScope(key);\n      if (!spreadAnnotation) {\n        ignorePropsValidation = true;\n      } else {\n        const spreadIgnoreValidation = declarePropTypesForObjectTypeAnnotation(spreadAnnotation, declaredPropTypes);\n        ignorePropsValidation = ignorePropsValidation || spreadIgnoreValidation;\n      }\n    });\n\n    return ignorePropsValidation;\n  }\n\n  /**\n   * Marks all props found inside IntersectionTypeAnnotation as declared.\n   * Since InterSectionTypeAnnotations can be nested, this handles recursively.\n   *\n   * Modifies the declaredPropTypes object\n   * @param {ASTNode} propTypes\n   * @param {Object} declaredPropTypes\n   * @returns {Boolean} True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)\n   */\n  function declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes) {\n    return propTypes.types.some((annotation) => {\n      if (annotation.type === 'ObjectTypeAnnotation') {\n        return declarePropTypesForObjectTypeAnnotation(annotation, declaredPropTypes);\n      }\n\n      if (annotation.type === 'UnionTypeAnnotation') {\n        return true;\n      }\n\n      // Type can't be resolved\n      if (!annotation.id) {\n        return true;\n      }\n\n      const typeNode = getInTypeScope(annotation.id.name);\n\n      if (!typeNode) {\n        return true;\n      }\n      if (typeNode.type === 'IntersectionTypeAnnotation') {\n        return declarePropTypesForIntersectionTypeAnnotation(typeNode, declaredPropTypes);\n      }\n\n      return declarePropTypesForObjectTypeAnnotation(typeNode, declaredPropTypes);\n    });\n  }\n\n  /**\n   * Resolve node of type Identifier when building declaration types.\n   * @param {ASTNode} node\n   * @param {Function} callback called with the resolved value only if resolved.\n   */\n  function resolveValueForIdentifierNode(node, callback) {\n    if (\n      node\n      && node.type === 'Identifier'\n    ) {\n      const scope = context.getScope();\n      const identVariable = scope.variableScope.variables.find(\n        (variable) => variable.name === node.name\n      );\n      if (identVariable) {\n        const definition = identVariable.defs[identVariable.defs.length - 1];\n        callback(definition.node.init);\n      }\n    }\n  }\n\n  /**\n   * Creates the representation of the React propTypes for the component.\n   * The representation is used to verify nested used properties.\n   * @param {ASTNode} value Node of the PropTypes for the desired property\n   * @param {string} parentName\n   * @return {Object} The representation of the declaration, empty object means\n   *    the property is declared without the need for further analysis.\n   */\n  function buildReactDeclarationTypes(value, parentName) {\n    if (\n      value\n      && value.callee\n      && value.callee.object\n      && hasCustomValidator(value.callee.object.name)\n    ) {\n      return {};\n    }\n\n    let identNodeResolved = false;\n    // Resolve identifier node for cases where isRequired is set in\n    // the variable declaration or not at all.\n    // const variableType = PropTypes.shape({ foo: ... }).isRequired\n    // propTypes = {\n    //   example: variableType\n    // }\n    // --------\n    // const variableType = PropTypes.shape({ foo: ... })\n    // propTypes = {\n    //   example: variableType\n    // }\n    resolveValueForIdentifierNode(value, (newValue) => {\n      identNodeResolved = true;\n      value = newValue;\n    });\n\n    if (\n      value\n      && value.type === 'MemberExpression'\n      && value.property\n      && value.property.name\n      && value.property.name === 'isRequired'\n    ) {\n      value = value.object;\n    }\n\n    // Resolve identifier node for cases where isRequired is set in\n    // the prop types.\n    // const variableType = PropTypes.shape({ foo: ... })\n    // propTypes = {\n    //   example: variableType.isRequired\n    // }\n    if (!identNodeResolved) {\n      resolveValueForIdentifierNode(value, (newValue) => {\n        value = newValue;\n      });\n    }\n\n    // Verify PropTypes that are functions\n    if (\n      value\n      && value.type === 'CallExpression'\n      && value.callee\n      && value.callee.property\n      && value.callee.property.name\n      && value.arguments\n      && value.arguments.length > 0\n    ) {\n      const callName = value.callee.property.name;\n      const argument = value.arguments[0];\n      switch (callName) {\n        case 'shape':\n        case 'exact': {\n          if (argument.type !== 'ObjectExpression') {\n            // Invalid proptype or cannot analyse statically\n            return {};\n          }\n          const shapeTypeDefinition = {\n            type: callName,\n            children: {},\n          };\n          iterateProperties(context, argument.properties, (childKey, childValue, propNode) => {\n            if (childValue) { // skip spread propTypes\n              const fullName = [parentName, childKey].join('.');\n              const types = buildReactDeclarationTypes(childValue, fullName);\n              types.fullName = fullName;\n              types.name = childKey;\n              types.node = propNode;\n              shapeTypeDefinition.children[childKey] = types;\n            }\n          });\n          return shapeTypeDefinition;\n        }\n        case 'arrayOf':\n        case 'objectOf': {\n          const fullName = [parentName, '*'].join('.');\n          const child = buildReactDeclarationTypes(argument, fullName);\n          child.fullName = fullName;\n          child.name = '__ANY_KEY__';\n          child.node = argument;\n          return {\n            type: 'object',\n            children: {\n              __ANY_KEY__: child,\n            },\n          };\n        }\n        case 'oneOfType': {\n          if (\n            !argument.elements\n            || !argument.elements.length\n          ) {\n            // Invalid proptype or cannot analyse statically\n            return {};\n          }\n\n          /** @type {UnionTypeDefinition} */\n          const unionTypeDefinition = {\n            type: 'union',\n            children: argument.elements.map((element) => buildReactDeclarationTypes(element, parentName)),\n          };\n          if (unionTypeDefinition.children.length === 0) {\n            // no complex type found, simply accept everything\n            return {};\n          }\n          return unionTypeDefinition;\n        }\n        default:\n          return {};\n      }\n    }\n    // Unknown property or accepts everything (any, object, ...)\n    return {};\n  }\n\n  function isValidReactGenericTypeAnnotation(annotation) {\n    if (annotation.typeName) {\n      if (annotation.typeName.name) { // if FC<Props>\n        const typeName = annotation.typeName.name;\n        if (!genericReactTypesImport.has(typeName)) {\n          return false;\n        }\n      } else if (annotation.typeName.right.name) { // if React.FC<Props>\n        const right = annotation.typeName.right.name;\n        const left = annotation.typeName.left.name;\n\n        if (!genericReactTypesImport.has(left) || !allowedGenericTypes.has(right)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Returns the left most typeName of a node, e.g: FC<Props>, React.FC<Props>\n   * The representation is used to verify nested used properties.\n   * @param {ASTNode} node\n   * @return {string | undefined}\n   */\n  function getLeftMostTypeName(node) {\n    if (node.name) return node.name;\n    if (node.left) return getLeftMostTypeName(node.left);\n  }\n\n  function getRightMostTypeName(node) {\n    if (node.name) return node.name;\n    if (node.right) return getRightMostTypeName(node.right);\n  }\n\n  /**\n   * Returns true if the node is either a interface or type alias declaration\n   * @param {ASTNode} node\n   * @return {boolean}\n   */\n  function filterInterfaceOrTypeAlias(node) {\n    return (\n      astUtil.isTSInterfaceDeclaration(node) || astUtil.isTSTypeAliasDeclaration(node)\n    );\n  }\n\n  /**\n   * Returns true if the interface or type alias declaration node name matches the type-name str\n   * @param {ASTNode} node\n   * @param {string} typeName\n   * @return {boolean}\n   */\n  function filterInterfaceOrAliasByName(node, typeName) {\n    return (\n      (node.id && node.id.name === typeName)\n      || (node.declaration && node.declaration.id && node.declaration.id.name === typeName)\n    );\n  }\n\n  class DeclarePropTypesForTSTypeAnnotation {\n    constructor(propTypes, declaredPropTypes) {\n      this.propTypes = propTypes;\n      this.declaredPropTypes = declaredPropTypes;\n      this.foundDeclaredPropertiesList = [];\n      this.referenceNameMap = new Set();\n      this.sourceCode = context.getSourceCode();\n      this.shouldIgnorePropTypes = false;\n      this.visitTSNode(this.propTypes);\n      this.endAndStructDeclaredPropTypes();\n    }\n\n    /**\n     * The node will be distribute to different function.\n     * @param {ASTNode} node\n     */\n    visitTSNode(node) {\n      if (!node) return;\n      if (astUtil.isTSTypeAnnotation(node)) {\n        const typeAnnotation = node.typeAnnotation;\n        this.visitTSNode(typeAnnotation);\n      } else if (astUtil.isTSTypeReference(node)) {\n        this.searchDeclarationByName(node);\n      } else if (astUtil.isTSInterfaceHeritage(node)) {\n        this.searchDeclarationByName(node);\n      } else if (astUtil.isTSTypeLiteral(node)) {\n        // Check node is an object literal\n        if (Array.isArray(node.members)) {\n          this.foundDeclaredPropertiesList = this.foundDeclaredPropertiesList.concat(node.members);\n        }\n      } else if (astUtil.isTSIntersectionType(node)) {\n        this.convertIntersectionTypeToPropTypes(node);\n      } else if (astUtil.isTSParenthesizedType(node)) {\n        const typeAnnotation = node.typeAnnotation;\n        this.visitTSNode(typeAnnotation);\n      } else if (astUtil.isTSTypeParameterInstantiation(node)) {\n        if (Array.isArray(node.params)) {\n          node.params.forEach(this.visitTSNode, this);\n        }\n      } else {\n        this.shouldIgnorePropTypes = true;\n      }\n    }\n\n    /**\n     * Search TSInterfaceDeclaration or TSTypeAliasDeclaration,\n     * by using TSTypeReference and TSInterfaceHeritage name.\n     * @param {ASTNode} node\n     */\n    searchDeclarationByName(node) {\n      let typeName;\n      if (astUtil.isTSTypeReference(node)) {\n        typeName = node.typeName.name;\n        const leftMostName = getLeftMostTypeName(node.typeName);\n        const shouldTraverseTypeParams = genericReactTypesImport.has(leftMostName);\n        if (shouldTraverseTypeParams && node.typeParameters && node.typeParameters.length !== 0) {\n          // All react Generic types are derived from:\n          // type PropsWithChildren<P> = P & { children?: ReactNode | undefined }\n          // So we should construct an optional children prop\n          this.shouldSpecifyOptionalChildrenProps = true;\n\n          const rightMostName = getRightMostTypeName(node.typeName);\n          const importedName = localToImportedMap[rightMostName];\n          const idx = genericTypeParamIndexWherePropsArePresent[\n            leftMostName !== rightMostName ? rightMostName : importedName\n          ];\n          const nextNode = node.typeParameters.params[idx];\n          this.visitTSNode(nextNode);\n          return;\n        }\n      } else if (astUtil.isTSInterfaceHeritage(node)) {\n        if (!node.expression && node.id) {\n          typeName = node.id.name;\n        } else {\n          typeName = node.expression.name;\n        }\n      }\n      if (!typeName) {\n        this.shouldIgnorePropTypes = true;\n        return;\n      }\n      if (typeName === 'ReturnType') {\n        this.convertReturnTypeToPropTypes(node);\n        return;\n      }\n      // Prevent recursive inheritance will cause maximum callstack.\n      if (this.referenceNameMap.has(typeName)) {\n        this.shouldIgnorePropTypes = true;\n        return;\n      }\n      // Add typeName to Set and consider it as traversed.\n      this.referenceNameMap.add(typeName);\n\n      /**\n       * From line 577 to line 581, and line 588 to line 590 are trying to handle typescript-eslint-parser\n       * Need to be deprecated after remove typescript-eslint-parser support.\n       */\n      const candidateTypes = this.sourceCode.ast.body.filter((item) => astUtil.isTSTypeDeclaration(item));\n\n      const declarations = flatMap(\n        candidateTypes,\n        (type) => type.declarations || (type.declaration && type.declaration.declarations) || type.declaration);\n\n      // we tried to find either an interface or a type with the TypeReference name\n      const typeDeclaration = declarations.filter((dec) => dec.id.name === typeName);\n\n      const interfaceDeclarations = this.sourceCode.ast.body\n        .filter(filterInterfaceOrTypeAlias)\n        .filter((item) => filterInterfaceOrAliasByName(item, typeName))\n        .map((item) => (item.declaration || item));\n\n      if (typeDeclaration.length !== 0) {\n        typeDeclaration.map((t) => t.init || t.typeAnnotation).forEach(this.visitTSNode, this);\n      } else if (interfaceDeclarations.length !== 0) {\n        interfaceDeclarations.forEach(this.traverseDeclaredInterfaceOrTypeAlias, this);\n      } else {\n        this.shouldIgnorePropTypes = true;\n      }\n    }\n\n    /**\n     * Traverse TSInterfaceDeclaration and TSTypeAliasDeclaration\n     * which retrieve from function searchDeclarationByName;\n     * @param {ASTNode} node\n     */\n    traverseDeclaredInterfaceOrTypeAlias(node) {\n      if (astUtil.isTSInterfaceDeclaration(node)) {\n        // Handle TSInterfaceDeclaration interface Props { name: string, id: number}, should put in properties list directly;\n        this.foundDeclaredPropertiesList = this.foundDeclaredPropertiesList.concat(node.body.body);\n      }\n      // Handle TSTypeAliasDeclaration type Props = {name:string}\n      if (astUtil.isTSTypeAliasDeclaration(node)) {\n        const typeAnnotation = node.typeAnnotation;\n        this.visitTSNode(typeAnnotation);\n      }\n      if (Array.isArray(node.extends)) {\n        node.extends.forEach(this.visitTSNode, this);\n        // This line is trying to handle typescript-eslint-parser\n        // typescript-eslint-parser extension is name as heritage\n      } else if (Array.isArray(node.heritage)) {\n        node.heritage.forEach(this.visitTSNode, this);\n      }\n    }\n\n    convertIntersectionTypeToPropTypes(node) {\n      if (!node) return;\n      if (Array.isArray(node.types)) {\n        node.types.forEach(this.visitTSNode, this);\n      } else {\n        this.shouldIgnorePropTypes = true;\n      }\n    }\n\n    convertReturnTypeToPropTypes(node) {\n      // ReturnType<T> should always have one parameter\n      if (node.typeParameters) {\n        if (node.typeParameters.params.length === 1) {\n          let returnType = node.typeParameters.params[0];\n          // This line is trying to handle typescript-eslint-parser\n          // typescript-eslint-parser TSTypeQuery is wrapped by TSTypeReference\n          if (astUtil.isTSTypeReference(returnType)) {\n            returnType = returnType.typeName;\n          }\n          // Handle ReturnType<typeof mapStateToProps>\n          if (astUtil.isTSTypeQuery(returnType)) {\n            const returnTypeFunction = flatMap(this.sourceCode.ast.body\n              .filter((item) => item.type === 'VariableDeclaration'\n                && item.declarations.find((dec) => dec.id.name === returnType.exprName.name)\n              ), (type) => type.declarations).map((dec) => dec.init);\n\n            if (Array.isArray(returnTypeFunction)) {\n              if (returnTypeFunction.length === 0) {\n                // Cannot find identifier in current scope. It might be an exported type.\n                this.shouldIgnorePropTypes = true;\n                return;\n              }\n              returnTypeFunction.forEach((func) => {\n                if (isFunctionType(func)) {\n                  let res = func.body;\n                  if (res.type === 'BlockStatement') {\n                    res = astUtil.findReturnStatement(func);\n                    if (res) {\n                      res = res.argument;\n                    }\n                  }\n                  switch (res.type) {\n                    case 'ObjectExpression':\n                      iterateProperties(context, res.properties, (key, value, propNode) => {\n                        if (propNode && propNode.argument && propNode.argument.type === 'CallExpression') {\n                          if (propNode.argument.typeParameters) {\n                            this.visitTSNode(propNode.argument.typeParameters);\n                          } else {\n                            // Ignore this CallExpression return value since it doesn't have any typeParameters to let us know it's types.\n                            this.shouldIgnorePropTypes = true;\n                            return;\n                          }\n                        }\n                        if (!value) {\n                          this.shouldIgnorePropTypes = true;\n                          return;\n                        }\n                        const types = buildReactDeclarationTypes(value, key);\n                        types.fullName = key;\n                        types.name = key;\n                        types.node = propNode;\n                        types.isRequired = propsUtil.isRequiredPropType(value);\n                        this.declaredPropTypes[key] = types;\n                      });\n                      break;\n                    case 'CallExpression':\n                      if (res.typeParameters) {\n                        this.visitTSNode(res.typeParameters);\n                      } else {\n                        // Ignore this CallExpression return value since it doesn't have any typeParameters to let us know it's types.\n                        this.shouldIgnorePropTypes = true;\n                      }\n                      break;\n                    default:\n                  }\n                }\n              });\n              return;\n            }\n          }\n          // Handle ReturnType<()=>returnType>\n          if (astUtil.isTSFunctionType(returnType)) {\n            if (astUtil.isTSTypeAnnotation(returnType.returnType)) {\n              this.visitTSNode(returnType.returnType);\n              return;\n            }\n            // This line is trying to handle typescript-eslint-parser\n            // typescript-eslint-parser TSFunction name returnType as typeAnnotation\n            if (astUtil.isTSTypeAnnotation(returnType.typeAnnotation)) {\n              this.visitTSNode(returnType.typeAnnotation);\n              return;\n            }\n          }\n        }\n      }\n      this.shouldIgnorePropTypes = true;\n    }\n\n    endAndStructDeclaredPropTypes() {\n      if (this.shouldSpecifyOptionalChildrenProps) {\n        this.declaredPropTypes.children = {\n          fullName: 'children',\n          name: 'children',\n          isRequired: false,\n        };\n      }\n      this.foundDeclaredPropertiesList.forEach((tsInterfaceBody) => {\n        if (tsInterfaceBody && (tsInterfaceBody.type === 'TSPropertySignature' || tsInterfaceBody.type === 'TSMethodSignature')) {\n          let accessor = 'name';\n          if (tsInterfaceBody.key.type === 'Literal') {\n            if (typeof tsInterfaceBody.key.value === 'number') {\n              accessor = 'raw';\n            } else {\n              accessor = 'value';\n            }\n          }\n          this.declaredPropTypes[tsInterfaceBody.key[accessor]] = {\n            fullName: tsInterfaceBody.key[accessor],\n            name: tsInterfaceBody.key[accessor],\n            node: tsInterfaceBody,\n            isRequired: !tsInterfaceBody.optional,\n          };\n        }\n      });\n    }\n  }\n\n  /**\n   * Mark a prop type as declared\n   * @param {ASTNode} node The AST node being checked.\n   * @param {ASTNode} propTypes The AST node containing the proptypes\n   */\n  function markPropTypesAsDeclared(node, propTypes) {\n    let componentNode = node;\n    while (componentNode && !components.get(componentNode)) {\n      componentNode = componentNode.parent;\n    }\n    const component = components.get(componentNode);\n    let declaredPropTypes = (component && component.declaredPropTypes) || {};\n    let ignorePropsValidation = (component && component.ignorePropsValidation) || false;\n    switch (propTypes && propTypes.type) {\n      case 'ObjectTypeAnnotation':\n        ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes);\n        break;\n      case 'ObjectExpression':\n        iterateProperties(context, propTypes.properties, (key, value, propNode) => {\n          if (!value) {\n            ignorePropsValidation = true;\n            return;\n          }\n          const types = buildReactDeclarationTypes(value, key);\n          types.fullName = key;\n          types.name = key;\n          types.node = propNode;\n          types.isRequired = propsUtil.isRequiredPropType(value);\n          declaredPropTypes[key] = types;\n        });\n        break;\n      case 'MemberExpression': {\n        let curDeclaredPropTypes = declaredPropTypes;\n        // Walk the list of properties, until we reach the assignment\n        // ie: ClassX.propTypes.a.b.c = ...\n        while (\n          propTypes\n          && propTypes.parent\n          && propTypes.parent.type !== 'AssignmentExpression'\n          && propTypes.property\n          && curDeclaredPropTypes\n        ) {\n          const propName = propTypes.property.name;\n          if (propName in curDeclaredPropTypes) {\n            curDeclaredPropTypes = curDeclaredPropTypes[propName].children;\n            propTypes = propTypes.parent;\n          } else {\n            // This will crash at runtime because we haven't seen this key before\n            // stop this and do not declare it\n            propTypes = null;\n          }\n        }\n        if (propTypes && propTypes.parent && propTypes.property) {\n          if (!(propTypes === propTypes.parent.left && propTypes.parent.left.object)) {\n            ignorePropsValidation = true;\n            break;\n          }\n          const parentProp = context.getSource(propTypes.parent.left.object).replace(/^.*\\.propTypes\\./, '');\n          const types = buildReactDeclarationTypes(\n            propTypes.parent.right,\n            parentProp\n          );\n\n          types.name = propTypes.property.name;\n          types.fullName = [parentProp, propTypes.property.name].join('.');\n          types.node = propTypes.parent;\n          types.isRequired = propsUtil.isRequiredPropType(propTypes.parent.right);\n          curDeclaredPropTypes[propTypes.property.name] = types;\n        } else {\n          let isUsedInPropTypes = false;\n          let n = propTypes;\n          while (n) {\n            if (((n.type === 'AssignmentExpression') && propsUtil.isPropTypesDeclaration(n.left))\n              || ((n.type === 'ClassProperty' || n.type === 'PropertyDefinition' || n.type === 'Property') && propsUtil.isPropTypesDeclaration(n))) {\n              // Found a propType used inside of another propType. This is not considered usage, we'll still validate\n              // this component.\n              isUsedInPropTypes = true;\n              break;\n            }\n            n = n.parent;\n          }\n          if (!isUsedInPropTypes) {\n            ignorePropsValidation = true;\n          }\n        }\n        break;\n      }\n      case 'Identifier': {\n        const variablesInScope = variableUtil.variablesInScope(context);\n        const firstMatchingVariable = variablesInScope\n          .find((variableInScope) => variableInScope.name === propTypes.name);\n        if (firstMatchingVariable) {\n          const defInScope = firstMatchingVariable.defs[firstMatchingVariable.defs.length - 1];\n          markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init);\n          return;\n        }\n        ignorePropsValidation = true;\n        break;\n      }\n      case 'CallExpression': {\n        if (\n          propWrapperUtil.isPropWrapperFunction(\n            context,\n            context.getSourceCode().getText(propTypes.callee)\n          )\n          && propTypes.arguments && propTypes.arguments[0]\n        ) {\n          markPropTypesAsDeclared(node, propTypes.arguments[0]);\n          return;\n        }\n        break;\n      }\n      case 'IntersectionTypeAnnotation':\n        ignorePropsValidation = declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes);\n        break;\n      case 'GenericTypeAnnotation':\n        if (propTypes.id.name === '$ReadOnly') {\n          ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(\n            propTypes.typeParameters.params[0],\n            declaredPropTypes\n          );\n        } else {\n          ignorePropsValidation = true;\n        }\n        break;\n      case 'TSTypeReference':\n      case 'TSTypeAnnotation': {\n        const tsTypeAnnotation = new DeclarePropTypesForTSTypeAnnotation(propTypes, declaredPropTypes);\n        ignorePropsValidation = tsTypeAnnotation.shouldIgnorePropTypes;\n        declaredPropTypes = tsTypeAnnotation.declaredPropTypes;\n      }\n        break;\n      case null:\n        break;\n      default:\n        ignorePropsValidation = true;\n        break;\n    }\n\n    components.set(node, {\n      declaredPropTypes,\n      ignorePropsValidation,\n    });\n  }\n\n  /**\n   * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n   *   FunctionDeclaration, or FunctionExpression\n   */\n  function markAnnotatedFunctionArgumentsAsDeclared(node) {\n    if (!node.params || !node.params.length) {\n      return;\n    }\n\n    if (\n      node.parent\n      && node.parent.callee\n      && node.parent.typeParameters\n      && node.parent.typeParameters.params\n      && (\n        node.parent.callee.name === 'forwardRef' || (\n          node.parent.callee.object\n          && node.parent.callee.property\n          && node.parent.callee.object.name === 'React'\n          && node.parent.callee.property.name === 'forwardRef'\n        )\n      )\n    ) {\n      const propTypes = node.parent.typeParameters.params[1];\n      const declaredPropTypes = {};\n      const obj = new DeclarePropTypesForTSTypeAnnotation(propTypes, declaredPropTypes);\n      components.set(node, {\n        declaredPropTypes: obj.declaredPropTypes,\n        ignorePropsValidation: obj.shouldIgnorePropTypes,\n      });\n      return;\n    }\n\n    const siblingIdentifier = node.parent && node.parent.id;\n    const siblingHasTypeAnnotation = siblingIdentifier && siblingIdentifier.typeAnnotation;\n    const isNodeAnnotated = annotations.isAnnotatedFunctionPropsDeclaration(node, context);\n\n    if (!isNodeAnnotated && !siblingHasTypeAnnotation) {\n      return;\n    }\n\n    // https://github.com/jsx-eslint/eslint-plugin-react/issues/2784\n    if (isInsideClassBody(node) && !astUtil.isFunction(node)) {\n      return;\n    }\n\n    // Should ignore function that not return JSXElement\n    if (!utils.isReturningJSXOrNull(node) || startWithCapitalizedLetter(node)) {\n      return;\n    }\n\n    if (isNodeAnnotated) {\n      const param = node.params[0];\n      if (param.typeAnnotation && param.typeAnnotation.typeAnnotation && param.typeAnnotation.typeAnnotation.type === 'UnionTypeAnnotation') {\n        param.typeAnnotation.typeAnnotation.types.forEach((annotation) => {\n          if (annotation.type === 'GenericTypeAnnotation') {\n            markPropTypesAsDeclared(node, resolveTypeAnnotation(annotation));\n          } else {\n            markPropTypesAsDeclared(node, annotation);\n          }\n        });\n      } else {\n        markPropTypesAsDeclared(node, resolveTypeAnnotation(param));\n      }\n    } else {\n      // implements what's discussed here: https://github.com/jsx-eslint/eslint-plugin-react/issues/2777#issuecomment-683944481\n      const annotation = siblingIdentifier.typeAnnotation.typeAnnotation;\n\n      if (\n        annotation\n        && annotation.type !== 'TSTypeReference'\n        && annotation.typeParameters == null\n      ) {\n        return;\n      }\n\n      if (!isValidReactGenericTypeAnnotation(annotation)) return;\n\n      markPropTypesAsDeclared(node, resolveTypeAnnotation(siblingIdentifier));\n    }\n  }\n\n  /**\n   * Resolve the type annotation for a given class declaration node with superTypeParameters.\n   *\n   * @param {ASTNode} node The annotation or a node containing the type annotation.\n   * @returns {ASTNode} The resolved type annotation for the node.\n   */\n  function resolveSuperParameterPropsType(node) {\n    let propsParameterPosition;\n    try {\n      // Flow <=0.52 had 3 required TypedParameters of which the second one is the Props.\n      // Flow >=0.53 has 2 optional TypedParameters of which the first one is the Props.\n      propsParameterPosition = testFlowVersion(context, '>= 0.53.0') ? 0 : 1;\n    } catch (e) {\n      // In case there is no flow version defined, we can safely assume that when there are 3 Props we are dealing with version <= 0.52\n      propsParameterPosition = node.superTypeParameters.params.length <= 2 ? 0 : 1;\n    }\n\n    let annotation = node.superTypeParameters.params[propsParameterPosition];\n    while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {\n      annotation = annotation.typeAnnotation;\n    }\n\n    if (annotation && annotation.type === 'GenericTypeAnnotation' && getInTypeScope(annotation.id.name)) {\n      return getInTypeScope(annotation.id.name);\n    }\n    return annotation;\n  }\n\n  /**\n   * Checks if we are declaring a `props` class property with a flow type annotation.\n   * @param {ASTNode} node The AST node being checked.\n   * @returns {Boolean} True if the node is a type annotated props declaration, false if not.\n   */\n  function isAnnotatedClassPropsDeclaration(node) {\n    if (node && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition')) {\n      const tokens = context.getFirstTokens(node, 2);\n      if (\n        node.typeAnnotation && (\n          tokens[0].value === 'props'\n          || (tokens[1] && tokens[1].value === 'props')\n        )\n      ) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  return {\n    ClassExpression(node) {\n      // TypeParameterDeclaration need to be added to typeScope in order to handle ClassExpressions.\n      // This visitor is executed before TypeParameterDeclaration are scoped, therefore we postpone\n      // processing class expressions until when the program exists.\n      classExpressions.push(node);\n    },\n\n    ClassDeclaration(node) {\n      if (isSuperTypeParameterPropsDeclaration(node)) {\n        markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));\n      }\n    },\n\n    'ClassProperty, PropertyDefinition'(node) {\n      if (isAnnotatedClassPropsDeclaration(node)) {\n        markPropTypesAsDeclared(node, resolveTypeAnnotation(node));\n      } else if (propsUtil.isPropTypesDeclaration(node)) {\n        markPropTypesAsDeclared(node, node.value);\n      }\n    },\n\n    ObjectExpression(node) {\n      // Search for the proptypes declaration\n      node.properties.forEach((property) => {\n        if (!propsUtil.isPropTypesDeclaration(property)) {\n          return;\n        }\n        markPropTypesAsDeclared(node, property.value);\n      });\n    },\n\n    FunctionExpression(node) {\n      if (node.parent.type !== 'MethodDefinition') {\n        markAnnotatedFunctionArgumentsAsDeclared(node);\n      }\n    },\n\n    ImportDeclaration(node) {\n      // parse `import ... from 'react`\n      if (node.source.value === 'react') {\n        node.specifiers.forEach((specifier) => {\n          if (\n            // handles import * as X from 'react'\n            specifier.type === 'ImportNamespaceSpecifier'\n            // handles import React from 'react'\n            || specifier.type === 'ImportDefaultSpecifier'\n          ) {\n            genericReactTypesImport.add(specifier.local.name);\n          }\n\n          // handles import { FC } from 'react' or import { FC as X } from 'react'\n          if (specifier.type === 'ImportSpecifier' && allowedGenericTypes.has(specifier.imported.name)) {\n            genericReactTypesImport.add(specifier.local.name);\n            localToImportedMap[specifier.local.name] = specifier.imported.name;\n          }\n        });\n      }\n    },\n\n    FunctionDeclaration: markAnnotatedFunctionArgumentsAsDeclared,\n\n    ArrowFunctionExpression: markAnnotatedFunctionArgumentsAsDeclared,\n\n    MemberExpression(node) {\n      if (propsUtil.isPropTypesDeclaration(node)) {\n        const component = utils.getRelatedComponent(node);\n        if (!component) {\n          return;\n        }\n        try {\n          markPropTypesAsDeclared(component.node, node.parent.right || node.parent);\n        } catch (e) {\n          if (e.constructor !== RangeError) { throw e; }\n        }\n      }\n    },\n\n    MethodDefinition(node) {\n      if (!node.static || node.kind !== 'get' || !propsUtil.isPropTypesDeclaration(node)) {\n        return;\n      }\n\n      let i = node.value.body.body.length - 1;\n      for (; i >= 0; i--) {\n        if (node.value.body.body[i].type === 'ReturnStatement') {\n          break;\n        }\n      }\n\n      if (i >= 0) {\n        markPropTypesAsDeclared(node, node.value.body.body[i].argument);\n      }\n    },\n\n    TypeAlias(node) {\n      setInTypeScope(node.id.name, node.right);\n    },\n\n    TypeParameterDeclaration(node) {\n      const identifier = node.params[0];\n\n      if (identifier.typeAnnotation) {\n        setInTypeScope(identifier.name, identifier.typeAnnotation.typeAnnotation);\n      }\n    },\n\n    Program() {\n      stack = [{}];\n    },\n\n    BlockStatement() {\n      stack.push(Object.create(typeScope()));\n    },\n\n    'BlockStatement:exit'() {\n      stack.pop();\n    },\n\n    'Program:exit'() {\n      classExpressions.forEach((node) => {\n        if (isSuperTypeParameterPropsDeclaration(node)) {\n          markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));\n        }\n      });\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}