{"ast":null,"code":"import postcss from 'postcss';\nimport parser from 'postcss-selector-parser';\nimport { resolveMatches } from './generateRules';\nimport bigSign from '../util/bigSign';\nimport escapeClassName from '../util/escapeClassName';\n/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */\n\nfunction extractClasses(node) {\n  /** @type {Map<string, Set<string>>} */\n  let groups = new Map();\n  let container = postcss.root({\n    nodes: [node.clone()]\n  });\n  container.walkRules(rule => {\n    parser(selectors => {\n      selectors.walkClasses(classSelector => {\n        let parentSelector = classSelector.parent.toString();\n        let classes = groups.get(parentSelector);\n\n        if (!classes) {\n          groups.set(parentSelector, classes = new Set());\n        }\n\n        classes.add(classSelector.value);\n      });\n    }).processSync(rule.selector);\n  });\n  let normalizedGroups = Array.from(groups.values(), classes => Array.from(classes));\n  let classes = normalizedGroups.flat();\n  return Object.assign(classes, {\n    groups: normalizedGroups\n  });\n}\n\nlet selectorExtractor = parser(root => root.nodes.map(node => node.toString()));\n/**\n * @param {string} ruleSelectors\n */\n\nfunction extractSelectors(ruleSelectors) {\n  return selectorExtractor.transformSync(ruleSelectors);\n}\n\nfunction extractBaseCandidates(candidates, separator) {\n  let baseClasses = new Set();\n\n  for (let candidate of candidates) {\n    baseClasses.add(candidate.split(separator).pop());\n  }\n\n  return Array.from(baseClasses);\n}\n\nfunction prefix(context, selector) {\n  let prefix = context.tailwindConfig.prefix;\n  return typeof prefix === 'function' ? prefix(selector) : prefix + selector;\n}\n\nfunction* pathToRoot(node) {\n  yield node;\n\n  while (node.parent) {\n    yield node.parent;\n    node = node.parent;\n  }\n}\n/**\n * Only clone the node itself and not its children\n *\n * @param {*} node\n * @param {*} overrides\n * @returns\n */\n\n\nfunction shallowClone(node) {\n  let overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let children = node.nodes;\n  node.nodes = [];\n  let tmp = node.clone(overrides);\n  node.nodes = children;\n  return tmp;\n}\n/**\n * Clone just the nodes all the way to the top that are required to represent\n * this singular rule in the tree.\n *\n * For example, if we have CSS like this:\n * ```css\n * @media (min-width: 768px) {\n *   @supports (display: grid) {\n *     .foo {\n *       display: grid;\n *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n *     }\n *   }\n *\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n *\n *   .baz {\n *     color: orange;\n *   }\n * }\n * ```\n *\n * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:\n *\n * ```css\n * @media (min-width: 768px) {\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n * }\n * ```\n *\n * @param {import('postcss').Node} node\n */\n\n\nfunction nestedClone(node) {\n  for (let parent of pathToRoot(node)) {\n    if (node === parent) {\n      continue;\n    }\n\n    if (parent.type === 'root') {\n      break;\n    }\n\n    node = shallowClone(parent, {\n      nodes: [node]\n    });\n  }\n\n  return node;\n}\n/**\n * @param {import('postcss').Root} root\n */\n\n\nfunction buildLocalApplyCache(root, context) {\n  /** @type {ApplyCache} */\n  let cache = new Map();\n  let highestOffset = context.layerOrder.user >> 4n;\n  root.walkRules((rule, idx) => {\n    // Ignore rules generated by Tailwind\n    for (let node of pathToRoot(rule)) {\n      if (node.raws.tailwind?.layer !== undefined) {\n        return;\n      }\n    } // Clone what's required to represent this singular rule in the tree\n\n\n    let container = nestedClone(rule);\n\n    for (let className of extractClasses(rule)) {\n      let list = cache.get(className) || [];\n      cache.set(className, list);\n      list.push([{\n        layer: 'user',\n        sort: BigInt(idx) + highestOffset,\n        important: false\n      }, container]);\n    }\n  });\n  return cache;\n}\n/**\n * @returns {ApplyCache}\n */\n\n\nfunction buildApplyCache(applyCandidates, context) {\n  for (let candidate of applyCandidates) {\n    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n      continue;\n    }\n\n    if (context.classCache.has(candidate)) {\n      context.applyClassCache.set(candidate, context.classCache.get(candidate).map(_ref => {\n        let [meta, rule] = _ref;\n        return [meta, rule.clone()];\n      }));\n      continue;\n    }\n\n    let matches = Array.from(resolveMatches(candidate, context));\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate);\n      continue;\n    }\n\n    context.applyClassCache.set(candidate, matches);\n  }\n\n  return context.applyClassCache;\n}\n/**\n * Build a cache only when it's first used\n *\n * @param {() => ApplyCache} buildCacheFn\n * @returns {ApplyCache}\n */\n\n\nfunction lazyCache(buildCacheFn) {\n  let cache = null;\n  return {\n    get: name => {\n      cache = cache || buildCacheFn();\n      return cache.get(name);\n    },\n    has: name => {\n      cache = cache || buildCacheFn();\n      return cache.has(name);\n    }\n  };\n}\n/**\n * Take a series of multiple caches and merge\n * them so they act like one large cache\n *\n * @param {ApplyCache[]} caches\n * @returns {ApplyCache}\n */\n\n\nfunction combineCaches(caches) {\n  return {\n    get: name => caches.flatMap(cache => cache.get(name) || []),\n    has: name => caches.some(cache => cache.has(name))\n  };\n}\n\nfunction extractApplyCandidates(params) {\n  let candidates = params.split(/[\\s\\t\\n]+/g);\n\n  if (candidates[candidates.length - 1] === '!important') {\n    return [candidates.slice(0, -1), true];\n  }\n\n  return [candidates, false];\n}\n\nfunction processApply(root, context, localCache) {\n  let applyCandidates = new Set(); // Collect all @apply rules and candidates\n\n  let applies = [];\n  root.walkAtRules('apply', rule => {\n    let [candidates] = extractApplyCandidates(rule.params);\n\n    for (let util of candidates) {\n      applyCandidates.add(util);\n    }\n\n    applies.push(rule);\n  }); // Start the @apply process if we have rules with @apply in them\n\n  if (applies.length === 0) {\n    return;\n  } // Fill up some caches!\n\n\n  let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)]);\n  /**\n   * When we have an apply like this:\n   *\n   * .abc {\n   *    @apply hover:font-bold;\n   * }\n   *\n   * What we essentially will do is resolve to this:\n   *\n   * .abc {\n   *    @apply .hover\\:font-bold:hover {\n   *      font-weight: 500;\n   *    }\n   * }\n   *\n   * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n   * What happens in this function is that we prepend a `.` and escape the candidate.\n   * This will result in `.hover\\:font-bold`\n   * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n   */\n  // TODO: Should we use postcss-selector-parser for this instead?\n\n  function replaceSelector(selector, utilitySelectors, candidate) {\n    let needle = `.${escapeClassName(candidate)}`;\n    let needles = [...new Set([needle, needle.replace(/\\\\2c /g, '\\\\,')])];\n    let utilitySelectorsList = extractSelectors(utilitySelectors);\n    return extractSelectors(selector).map(s => {\n      let replaced = [];\n\n      for (let utilitySelector of utilitySelectorsList) {\n        let replacedSelector = utilitySelector;\n\n        for (const needle of needles) {\n          replacedSelector = replacedSelector.replace(needle, s);\n        }\n\n        if (replacedSelector === utilitySelector) {\n          continue;\n        }\n\n        replaced.push(replacedSelector);\n      }\n\n      return replaced.join(', ');\n    }).join(', ');\n  }\n\n  let perParentApplies = new Map(); // Collect all apply candidates and their rules\n\n  for (let apply of applies) {\n    let [candidates] = perParentApplies.get(apply.parent) || [[], apply.source];\n    perParentApplies.set(apply.parent, [candidates, apply.source]);\n    let [applyCandidates, important] = extractApplyCandidates(apply.params);\n\n    if (apply.parent.type === 'atrule') {\n      if (apply.parent.name === 'screen') {\n        const screenType = apply.parent.params;\n        throw apply.error(`@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates.map(c => `${screenType}:${c}`).join(' ')} instead.`);\n      }\n\n      throw apply.error(`@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`);\n    }\n\n    for (let applyCandidate of applyCandidates) {\n      if ([prefix(context, 'group'), prefix(context, 'peer')].includes(applyCandidate)) {\n        // TODO: Link to specific documentation page with error code.\n        throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`);\n      }\n\n      if (!applyClassCache.has(applyCandidate)) {\n        throw apply.error(`The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`);\n      }\n\n      let rules = applyClassCache.get(applyCandidate);\n      candidates.push([applyCandidate, important, rules]);\n    }\n  }\n\n  for (const [parent, [candidates, atApplySource]] of perParentApplies) {\n    let siblings = [];\n\n    for (let [applyCandidate, important, rules] of candidates) {\n      let potentialApplyCandidates = [applyCandidate, ...extractBaseCandidates([applyCandidate], context.tailwindConfig.separator)];\n\n      for (let [meta, node] of rules) {\n        let parentClasses = extractClasses(parent);\n        let nodeClasses = extractClasses(node); // When we encounter a rule like `.dark .a, .b { … }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`\n        // So we've split them into groups\n\n        nodeClasses = nodeClasses.groups.filter(classList => classList.some(className => potentialApplyCandidates.includes(className))).flat(); // Add base utility classes from the @apply node to the list of\n        // classes to check whether it intersects and therefore results in a\n        // circular dependency or not.\n        //\n        // E.g.:\n        // .foo {\n        //   @apply hover:a; // This applies \"a\" but with a modifier\n        // }\n        //\n        // We only have to do that with base classes of the `node`, not of the `parent`\n        // E.g.:\n        // .hover\\:foo {\n        //   @apply bar;\n        // }\n        // .bar {\n        //   @apply foo;\n        // }\n        //\n        // This should not result in a circular dependency because we are\n        // just applying `.foo` and the rule above is `.hover\\:foo` which is\n        // unrelated. However, if we were to apply `hover:foo` then we _did_\n        // have to include this one.\n\n        nodeClasses = nodeClasses.concat(extractBaseCandidates(nodeClasses, context.tailwindConfig.separator));\n        let intersects = parentClasses.some(selector => nodeClasses.includes(selector));\n\n        if (intersects) {\n          throw node.error(`You cannot \\`@apply\\` the \\`${applyCandidate}\\` utility here because it creates a circular dependency.`);\n        }\n\n        let root = postcss.root({\n          nodes: [node.clone()]\n        }); // Make sure every node in the entire tree points back at the @apply rule that generated it\n\n        root.walk(node => {\n          node.source = atApplySource;\n        });\n        let canRewriteSelector = node.type !== 'atrule' || node.type === 'atrule' && node.name !== 'keyframes';\n\n        if (canRewriteSelector) {\n          root.walkRules(rule => {\n            // Let's imagine you have the following structure:\n            //\n            // .foo {\n            //   @apply bar;\n            // }\n            //\n            // @supports (a: b) {\n            //   .bar {\n            //     color: blue\n            //   }\n            //\n            //   .something-unrelated {}\n            // }\n            //\n            // In this case we want to apply `.bar` but it happens to be in\n            // an atrule node. We clone that node instead of the nested one\n            // because we still want that @supports rule to be there once we\n            // applied everything.\n            //\n            // However it happens to be that the `.something-unrelated` is\n            // also in that same shared @supports atrule. This is not good,\n            // and this should not be there. The good part is that this is\n            // a clone already and it can be safely removed. The question is\n            // how do we know we can remove it. Basically what we can do is\n            // match it against the applyCandidate that you want to apply. If\n            // it doesn't match the we can safely delete it.\n            //\n            // If we didn't do this, then the `replaceSelector` function\n            // would have replaced this with something that didn't exist and\n            // therefore it removed the selector altogether. In this specific\n            // case it would result in `{}` instead of `.something-unrelated {}`\n            if (!extractClasses(rule).some(candidate => candidate === applyCandidate)) {\n              rule.remove();\n              return;\n            } // Strip the important selector from the parent selector if at the beginning\n\n\n            let importantSelector = typeof context.tailwindConfig.important === 'string' ? context.tailwindConfig.important : null; // We only want to move the \"important\" selector if this is a Tailwind-generated utility\n            // We do *not* want to do this for user CSS that happens to be structured the same\n\n            let isGenerated = parent.raws.tailwind !== undefined;\n            let parentSelector = isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0 ? parent.selector.slice(importantSelector.length) : parent.selector;\n            rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate); // And then re-add it if it was removed\n\n            if (importantSelector && parentSelector !== parent.selector) {\n              rule.selector = `${importantSelector} ${rule.selector}`;\n            }\n\n            rule.walkDecls(d => {\n              d.important = meta.important || important;\n            });\n          });\n        } // It could be that the node we were inserted was removed because the class didn't match\n        // If that was the *only* rule in the parent, then we have nothing add so we skip it\n\n\n        if (!root.nodes[0]) {\n          continue;\n        } // Insert it\n\n\n        siblings.push([// Ensure that when we are sorting, that we take the layer order into account\n        { ...meta,\n          sort: meta.sort | context.layerOrder[meta.layer]\n        }, root.nodes[0]]);\n      }\n    } // Inject the rules, sorted, correctly\n\n\n    let nodes = siblings.sort((_ref2, _ref3) => {\n      let [a] = _ref2;\n      let [z] = _ref3;\n      return bigSign(a.sort - z.sort);\n    }).map(s => s[1]); // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n\n    parent.after(nodes);\n  }\n\n  for (let apply of applies) {\n    // If there are left-over declarations, just remove the @apply\n    if (apply.parent.nodes.length > 1) {\n      apply.remove();\n    } else {\n      // The node is empty, drop the full node\n      apply.parent.remove();\n    }\n  } // Do it again, in case we have other `@apply` rules\n\n\n  processApply(root, context, localCache);\n}\n\nexport default function expandApplyAtRules(context) {\n  return root => {\n    // Build a cache of the user's CSS so we can use it to resolve classes used by @apply\n    let localCache = lazyCache(() => buildLocalApplyCache(root, context));\n    processApply(root, context, localCache);\n  };\n}","map":{"version":3,"names":["postcss","parser","resolveMatches","bigSign","escapeClassName","extractClasses","node","groups","Map","container","root","nodes","clone","walkRules","rule","selectors","walkClasses","classSelector","parentSelector","parent","toString","classes","get","set","Set","add","value","processSync","selector","normalizedGroups","Array","from","values","flat","Object","assign","selectorExtractor","map","extractSelectors","ruleSelectors","transformSync","extractBaseCandidates","candidates","separator","baseClasses","candidate","split","pop","prefix","context","tailwindConfig","pathToRoot","shallowClone","overrides","children","tmp","nestedClone","type","buildLocalApplyCache","cache","highestOffset","layerOrder","user","idx","raws","tailwind","layer","undefined","className","list","push","sort","BigInt","important","buildApplyCache","applyCandidates","notClassCache","has","applyClassCache","classCache","meta","matches","length","lazyCache","buildCacheFn","name","combineCaches","caches","flatMap","some","extractApplyCandidates","params","slice","processApply","localCache","applies","walkAtRules","util","replaceSelector","utilitySelectors","needle","needles","replace","utilitySelectorsList","s","replaced","utilitySelector","replacedSelector","join","perParentApplies","apply","source","screenType","error","c","applyCandidate","includes","rules","atApplySource","siblings","potentialApplyCandidates","parentClasses","nodeClasses","filter","classList","concat","intersects","walk","canRewriteSelector","remove","importantSelector","isGenerated","indexOf","walkDecls","d","a","z","after","expandApplyAtRules"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/src/lib/expandApplyAtRules.js"],"sourcesContent":["import postcss from 'postcss'\nimport parser from 'postcss-selector-parser'\n\nimport { resolveMatches } from './generateRules'\nimport bigSign from '../util/bigSign'\nimport escapeClassName from '../util/escapeClassName'\n\n/** @typedef {Map<string, [any, import('postcss').Rule[]]>} ApplyCache */\n\nfunction extractClasses(node) {\n  /** @type {Map<string, Set<string>>} */\n  let groups = new Map()\n\n  let container = postcss.root({ nodes: [node.clone()] })\n\n  container.walkRules((rule) => {\n    parser((selectors) => {\n      selectors.walkClasses((classSelector) => {\n        let parentSelector = classSelector.parent.toString()\n\n        let classes = groups.get(parentSelector)\n        if (!classes) {\n          groups.set(parentSelector, (classes = new Set()))\n        }\n\n        classes.add(classSelector.value)\n      })\n    }).processSync(rule.selector)\n  })\n\n  let normalizedGroups = Array.from(groups.values(), (classes) => Array.from(classes))\n  let classes = normalizedGroups.flat()\n\n  return Object.assign(classes, { groups: normalizedGroups })\n}\n\nlet selectorExtractor = parser((root) => root.nodes.map((node) => node.toString()))\n\n/**\n * @param {string} ruleSelectors\n */\nfunction extractSelectors(ruleSelectors) {\n  return selectorExtractor.transformSync(ruleSelectors)\n}\n\nfunction extractBaseCandidates(candidates, separator) {\n  let baseClasses = new Set()\n\n  for (let candidate of candidates) {\n    baseClasses.add(candidate.split(separator).pop())\n  }\n\n  return Array.from(baseClasses)\n}\n\nfunction prefix(context, selector) {\n  let prefix = context.tailwindConfig.prefix\n  return typeof prefix === 'function' ? prefix(selector) : prefix + selector\n}\n\nfunction* pathToRoot(node) {\n  yield node\n  while (node.parent) {\n    yield node.parent\n    node = node.parent\n  }\n}\n\n/**\n * Only clone the node itself and not its children\n *\n * @param {*} node\n * @param {*} overrides\n * @returns\n */\nfunction shallowClone(node, overrides = {}) {\n  let children = node.nodes\n  node.nodes = []\n\n  let tmp = node.clone(overrides)\n\n  node.nodes = children\n\n  return tmp\n}\n\n/**\n * Clone just the nodes all the way to the top that are required to represent\n * this singular rule in the tree.\n *\n * For example, if we have CSS like this:\n * ```css\n * @media (min-width: 768px) {\n *   @supports (display: grid) {\n *     .foo {\n *       display: grid;\n *       grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n *     }\n *   }\n *\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n *\n *   .baz {\n *     color: orange;\n *   }\n * }\n * ```\n *\n * And we're cloning `.bar` it'll return a cloned version of what's required for just that single node:\n *\n * ```css\n * @media (min-width: 768px) {\n *   @supports (backdrop-filter: blur(1px)) {\n *     .bar {\n *       backdrop-filter: blur(1px);\n *     }\n *   }\n * }\n * ```\n *\n * @param {import('postcss').Node} node\n */\nfunction nestedClone(node) {\n  for (let parent of pathToRoot(node)) {\n    if (node === parent) {\n      continue\n    }\n\n    if (parent.type === 'root') {\n      break\n    }\n\n    node = shallowClone(parent, {\n      nodes: [node],\n    })\n  }\n\n  return node\n}\n\n/**\n * @param {import('postcss').Root} root\n */\nfunction buildLocalApplyCache(root, context) {\n  /** @type {ApplyCache} */\n  let cache = new Map()\n\n  let highestOffset = context.layerOrder.user >> 4n\n\n  root.walkRules((rule, idx) => {\n    // Ignore rules generated by Tailwind\n    for (let node of pathToRoot(rule)) {\n      if (node.raws.tailwind?.layer !== undefined) {\n        return\n      }\n    }\n\n    // Clone what's required to represent this singular rule in the tree\n    let container = nestedClone(rule)\n\n    for (let className of extractClasses(rule)) {\n      let list = cache.get(className) || []\n      cache.set(className, list)\n\n      list.push([\n        {\n          layer: 'user',\n          sort: BigInt(idx) + highestOffset,\n          important: false,\n        },\n        container,\n      ])\n    }\n  })\n\n  return cache\n}\n\n/**\n * @returns {ApplyCache}\n */\nfunction buildApplyCache(applyCandidates, context) {\n  for (let candidate of applyCandidates) {\n    if (context.notClassCache.has(candidate) || context.applyClassCache.has(candidate)) {\n      continue\n    }\n\n    if (context.classCache.has(candidate)) {\n      context.applyClassCache.set(\n        candidate,\n        context.classCache.get(candidate).map(([meta, rule]) => [meta, rule.clone()])\n      )\n      continue\n    }\n\n    let matches = Array.from(resolveMatches(candidate, context))\n\n    if (matches.length === 0) {\n      context.notClassCache.add(candidate)\n      continue\n    }\n\n    context.applyClassCache.set(candidate, matches)\n  }\n\n  return context.applyClassCache\n}\n\n/**\n * Build a cache only when it's first used\n *\n * @param {() => ApplyCache} buildCacheFn\n * @returns {ApplyCache}\n */\nfunction lazyCache(buildCacheFn) {\n  let cache = null\n\n  return {\n    get: (name) => {\n      cache = cache || buildCacheFn()\n\n      return cache.get(name)\n    },\n    has: (name) => {\n      cache = cache || buildCacheFn()\n\n      return cache.has(name)\n    },\n  }\n}\n\n/**\n * Take a series of multiple caches and merge\n * them so they act like one large cache\n *\n * @param {ApplyCache[]} caches\n * @returns {ApplyCache}\n */\nfunction combineCaches(caches) {\n  return {\n    get: (name) => caches.flatMap((cache) => cache.get(name) || []),\n    has: (name) => caches.some((cache) => cache.has(name)),\n  }\n}\n\nfunction extractApplyCandidates(params) {\n  let candidates = params.split(/[\\s\\t\\n]+/g)\n\n  if (candidates[candidates.length - 1] === '!important') {\n    return [candidates.slice(0, -1), true]\n  }\n\n  return [candidates, false]\n}\n\nfunction processApply(root, context, localCache) {\n  let applyCandidates = new Set()\n\n  // Collect all @apply rules and candidates\n  let applies = []\n  root.walkAtRules('apply', (rule) => {\n    let [candidates] = extractApplyCandidates(rule.params)\n\n    for (let util of candidates) {\n      applyCandidates.add(util)\n    }\n\n    applies.push(rule)\n  })\n\n  // Start the @apply process if we have rules with @apply in them\n  if (applies.length === 0) {\n    return\n  }\n\n  // Fill up some caches!\n  let applyClassCache = combineCaches([localCache, buildApplyCache(applyCandidates, context)])\n\n  /**\n   * When we have an apply like this:\n   *\n   * .abc {\n   *    @apply hover:font-bold;\n   * }\n   *\n   * What we essentially will do is resolve to this:\n   *\n   * .abc {\n   *    @apply .hover\\:font-bold:hover {\n   *      font-weight: 500;\n   *    }\n   * }\n   *\n   * Notice that the to-be-applied class is `.hover\\:font-bold:hover` and that the utility candidate was `hover:font-bold`.\n   * What happens in this function is that we prepend a `.` and escape the candidate.\n   * This will result in `.hover\\:font-bold`\n   * Which means that we can replace `.hover\\:font-bold` with `.abc` in `.hover\\:font-bold:hover` resulting in `.abc:hover`\n   */\n  // TODO: Should we use postcss-selector-parser for this instead?\n  function replaceSelector(selector, utilitySelectors, candidate) {\n    let needle = `.${escapeClassName(candidate)}`\n    let needles = [...new Set([needle, needle.replace(/\\\\2c /g, '\\\\,')])]\n    let utilitySelectorsList = extractSelectors(utilitySelectors)\n\n    return extractSelectors(selector)\n      .map((s) => {\n        let replaced = []\n\n        for (let utilitySelector of utilitySelectorsList) {\n          let replacedSelector = utilitySelector\n          for (const needle of needles) {\n            replacedSelector = replacedSelector.replace(needle, s)\n          }\n          if (replacedSelector === utilitySelector) {\n            continue\n          }\n          replaced.push(replacedSelector)\n        }\n        return replaced.join(', ')\n      })\n      .join(', ')\n  }\n\n  let perParentApplies = new Map()\n\n  // Collect all apply candidates and their rules\n  for (let apply of applies) {\n    let [candidates] = perParentApplies.get(apply.parent) || [[], apply.source]\n\n    perParentApplies.set(apply.parent, [candidates, apply.source])\n\n    let [applyCandidates, important] = extractApplyCandidates(apply.params)\n\n    if (apply.parent.type === 'atrule') {\n      if (apply.parent.name === 'screen') {\n        const screenType = apply.parent.params\n\n        throw apply.error(\n          `@apply is not supported within nested at-rules like @screen. We suggest you write this as @apply ${applyCandidates\n            .map((c) => `${screenType}:${c}`)\n            .join(' ')} instead.`\n        )\n      }\n\n      throw apply.error(\n        `@apply is not supported within nested at-rules like @${apply.parent.name}. You can fix this by un-nesting @${apply.parent.name}.`\n      )\n    }\n\n    for (let applyCandidate of applyCandidates) {\n      if ([prefix(context, 'group'), prefix(context, 'peer')].includes(applyCandidate)) {\n        // TODO: Link to specific documentation page with error code.\n        throw apply.error(`@apply should not be used with the '${applyCandidate}' utility`)\n      }\n\n      if (!applyClassCache.has(applyCandidate)) {\n        throw apply.error(\n          `The \\`${applyCandidate}\\` class does not exist. If \\`${applyCandidate}\\` is a custom class, make sure it is defined within a \\`@layer\\` directive.`\n        )\n      }\n\n      let rules = applyClassCache.get(applyCandidate)\n\n      candidates.push([applyCandidate, important, rules])\n    }\n  }\n\n  for (const [parent, [candidates, atApplySource]] of perParentApplies) {\n    let siblings = []\n\n    for (let [applyCandidate, important, rules] of candidates) {\n      let potentialApplyCandidates = [\n        applyCandidate,\n        ...extractBaseCandidates([applyCandidate], context.tailwindConfig.separator),\n      ]\n\n      for (let [meta, node] of rules) {\n        let parentClasses = extractClasses(parent)\n        let nodeClasses = extractClasses(node)\n\n        // When we encounter a rule like `.dark .a, .b { … }` we only want to be left with `[.dark, .a]` if the base applyCandidate is `.a` or with `[.b]` if the base applyCandidate is `.b`\n        // So we've split them into groups\n        nodeClasses = nodeClasses.groups\n          .filter((classList) =>\n            classList.some((className) => potentialApplyCandidates.includes(className))\n          )\n          .flat()\n\n        // Add base utility classes from the @apply node to the list of\n        // classes to check whether it intersects and therefore results in a\n        // circular dependency or not.\n        //\n        // E.g.:\n        // .foo {\n        //   @apply hover:a; // This applies \"a\" but with a modifier\n        // }\n        //\n        // We only have to do that with base classes of the `node`, not of the `parent`\n        // E.g.:\n        // .hover\\:foo {\n        //   @apply bar;\n        // }\n        // .bar {\n        //   @apply foo;\n        // }\n        //\n        // This should not result in a circular dependency because we are\n        // just applying `.foo` and the rule above is `.hover\\:foo` which is\n        // unrelated. However, if we were to apply `hover:foo` then we _did_\n        // have to include this one.\n        nodeClasses = nodeClasses.concat(\n          extractBaseCandidates(nodeClasses, context.tailwindConfig.separator)\n        )\n\n        let intersects = parentClasses.some((selector) => nodeClasses.includes(selector))\n        if (intersects) {\n          throw node.error(\n            `You cannot \\`@apply\\` the \\`${applyCandidate}\\` utility here because it creates a circular dependency.`\n          )\n        }\n\n        let root = postcss.root({ nodes: [node.clone()] })\n\n        // Make sure every node in the entire tree points back at the @apply rule that generated it\n        root.walk((node) => {\n          node.source = atApplySource\n        })\n\n        let canRewriteSelector =\n          node.type !== 'atrule' || (node.type === 'atrule' && node.name !== 'keyframes')\n\n        if (canRewriteSelector) {\n          root.walkRules((rule) => {\n            // Let's imagine you have the following structure:\n            //\n            // .foo {\n            //   @apply bar;\n            // }\n            //\n            // @supports (a: b) {\n            //   .bar {\n            //     color: blue\n            //   }\n            //\n            //   .something-unrelated {}\n            // }\n            //\n            // In this case we want to apply `.bar` but it happens to be in\n            // an atrule node. We clone that node instead of the nested one\n            // because we still want that @supports rule to be there once we\n            // applied everything.\n            //\n            // However it happens to be that the `.something-unrelated` is\n            // also in that same shared @supports atrule. This is not good,\n            // and this should not be there. The good part is that this is\n            // a clone already and it can be safely removed. The question is\n            // how do we know we can remove it. Basically what we can do is\n            // match it against the applyCandidate that you want to apply. If\n            // it doesn't match the we can safely delete it.\n            //\n            // If we didn't do this, then the `replaceSelector` function\n            // would have replaced this with something that didn't exist and\n            // therefore it removed the selector altogether. In this specific\n            // case it would result in `{}` instead of `.something-unrelated {}`\n            if (!extractClasses(rule).some((candidate) => candidate === applyCandidate)) {\n              rule.remove()\n              return\n            }\n\n            // Strip the important selector from the parent selector if at the beginning\n            let importantSelector =\n              typeof context.tailwindConfig.important === 'string'\n                ? context.tailwindConfig.important\n                : null\n\n            // We only want to move the \"important\" selector if this is a Tailwind-generated utility\n            // We do *not* want to do this for user CSS that happens to be structured the same\n            let isGenerated = parent.raws.tailwind !== undefined\n\n            let parentSelector =\n              isGenerated && importantSelector && parent.selector.indexOf(importantSelector) === 0\n                ? parent.selector.slice(importantSelector.length)\n                : parent.selector\n\n            rule.selector = replaceSelector(parentSelector, rule.selector, applyCandidate)\n\n            // And then re-add it if it was removed\n            if (importantSelector && parentSelector !== parent.selector) {\n              rule.selector = `${importantSelector} ${rule.selector}`\n            }\n\n            rule.walkDecls((d) => {\n              d.important = meta.important || important\n            })\n          })\n        }\n\n        // It could be that the node we were inserted was removed because the class didn't match\n        // If that was the *only* rule in the parent, then we have nothing add so we skip it\n        if (!root.nodes[0]) {\n          continue\n        }\n\n        // Insert it\n        siblings.push([\n          // Ensure that when we are sorting, that we take the layer order into account\n          { ...meta, sort: meta.sort | context.layerOrder[meta.layer] },\n          root.nodes[0],\n        ])\n      }\n    }\n\n    // Inject the rules, sorted, correctly\n    let nodes = siblings.sort(([a], [z]) => bigSign(a.sort - z.sort)).map((s) => s[1])\n\n    // `parent` refers to the node at `.abc` in: .abc { @apply mt-2 }\n    parent.after(nodes)\n  }\n\n  for (let apply of applies) {\n    // If there are left-over declarations, just remove the @apply\n    if (apply.parent.nodes.length > 1) {\n      apply.remove()\n    } else {\n      // The node is empty, drop the full node\n      apply.parent.remove()\n    }\n  }\n\n  // Do it again, in case we have other `@apply` rules\n  processApply(root, context, localCache)\n}\n\nexport default function expandApplyAtRules(context) {\n  return (root) => {\n    // Build a cache of the user's CSS so we can use it to resolve classes used by @apply\n    let localCache = lazyCache(() => buildLocalApplyCache(root, context))\n\n    processApply(root, context, localCache)\n  }\n}\n"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,SAApB;AACA,OAAOC,MAAP,MAAmB,yBAAnB;AAEA,SAASC,cAAT,QAA+B,iBAA/B;AACA,OAAOC,OAAP,MAAoB,iBAApB;AACA,OAAOC,eAAP,MAA4B,yBAA5B;AAEA;;AAEA,SAASC,cAAT,CAAwBC,IAAxB,EAA8B;EAC5B;EACA,IAAIC,MAAM,GAAG,IAAIC,GAAJ,EAAb;EAEA,IAAIC,SAAS,GAAGT,OAAO,CAACU,IAAR,CAAa;IAAEC,KAAK,EAAE,CAACL,IAAI,CAACM,KAAL,EAAD;EAAT,CAAb,CAAhB;EAEAH,SAAS,CAACI,SAAV,CAAqBC,IAAD,IAAU;IAC5Bb,MAAM,CAAEc,SAAD,IAAe;MACpBA,SAAS,CAACC,WAAV,CAAuBC,aAAD,IAAmB;QACvC,IAAIC,cAAc,GAAGD,aAAa,CAACE,MAAd,CAAqBC,QAArB,EAArB;QAEA,IAAIC,OAAO,GAAGd,MAAM,CAACe,GAAP,CAAWJ,cAAX,CAAd;;QACA,IAAI,CAACG,OAAL,EAAc;UACZd,MAAM,CAACgB,GAAP,CAAWL,cAAX,EAA4BG,OAAO,GAAG,IAAIG,GAAJ,EAAtC;QACD;;QAEDH,OAAO,CAACI,GAAR,CAAYR,aAAa,CAACS,KAA1B;MACD,CATD;IAUD,CAXK,CAAN,CAWGC,WAXH,CAWeb,IAAI,CAACc,QAXpB;EAYD,CAbD;EAeA,IAAIC,gBAAgB,GAAGC,KAAK,CAACC,IAAN,CAAWxB,MAAM,CAACyB,MAAP,EAAX,EAA6BX,OAAD,IAAaS,KAAK,CAACC,IAAN,CAAWV,OAAX,CAAzC,CAAvB;EACA,IAAIA,OAAO,GAAGQ,gBAAgB,CAACI,IAAjB,EAAd;EAEA,OAAOC,MAAM,CAACC,MAAP,CAAcd,OAAd,EAAuB;IAAEd,MAAM,EAAEsB;EAAV,CAAvB,CAAP;AACD;;AAED,IAAIO,iBAAiB,GAAGnC,MAAM,CAAES,IAAD,IAAUA,IAAI,CAACC,KAAL,CAAW0B,GAAX,CAAgB/B,IAAD,IAAUA,IAAI,CAACc,QAAL,EAAzB,CAAX,CAA9B;AAEA;AACA;AACA;;AACA,SAASkB,gBAAT,CAA0BC,aAA1B,EAAyC;EACvC,OAAOH,iBAAiB,CAACI,aAAlB,CAAgCD,aAAhC,CAAP;AACD;;AAED,SAASE,qBAAT,CAA+BC,UAA/B,EAA2CC,SAA3C,EAAsD;EACpD,IAAIC,WAAW,GAAG,IAAIpB,GAAJ,EAAlB;;EAEA,KAAK,IAAIqB,SAAT,IAAsBH,UAAtB,EAAkC;IAChCE,WAAW,CAACnB,GAAZ,CAAgBoB,SAAS,CAACC,KAAV,CAAgBH,SAAhB,EAA2BI,GAA3B,EAAhB;EACD;;EAED,OAAOjB,KAAK,CAACC,IAAN,CAAWa,WAAX,CAAP;AACD;;AAED,SAASI,MAAT,CAAgBC,OAAhB,EAAyBrB,QAAzB,EAAmC;EACjC,IAAIoB,MAAM,GAAGC,OAAO,CAACC,cAAR,CAAuBF,MAApC;EACA,OAAO,OAAOA,MAAP,KAAkB,UAAlB,GAA+BA,MAAM,CAACpB,QAAD,CAArC,GAAkDoB,MAAM,GAAGpB,QAAlE;AACD;;AAED,UAAUuB,UAAV,CAAqB7C,IAArB,EAA2B;EACzB,MAAMA,IAAN;;EACA,OAAOA,IAAI,CAACa,MAAZ,EAAoB;IAClB,MAAMb,IAAI,CAACa,MAAX;IACAb,IAAI,GAAGA,IAAI,CAACa,MAAZ;EACD;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiC,YAAT,CAAsB9C,IAAtB,EAA4C;EAAA,IAAhB+C,SAAgB,uEAAJ,EAAI;EAC1C,IAAIC,QAAQ,GAAGhD,IAAI,CAACK,KAApB;EACAL,IAAI,CAACK,KAAL,GAAa,EAAb;EAEA,IAAI4C,GAAG,GAAGjD,IAAI,CAACM,KAAL,CAAWyC,SAAX,CAAV;EAEA/C,IAAI,CAACK,KAAL,GAAa2C,QAAb;EAEA,OAAOC,GAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,WAAT,CAAqBlD,IAArB,EAA2B;EACzB,KAAK,IAAIa,MAAT,IAAmBgC,UAAU,CAAC7C,IAAD,CAA7B,EAAqC;IACnC,IAAIA,IAAI,KAAKa,MAAb,EAAqB;MACnB;IACD;;IAED,IAAIA,MAAM,CAACsC,IAAP,KAAgB,MAApB,EAA4B;MAC1B;IACD;;IAEDnD,IAAI,GAAG8C,YAAY,CAACjC,MAAD,EAAS;MAC1BR,KAAK,EAAE,CAACL,IAAD;IADmB,CAAT,CAAnB;EAGD;;EAED,OAAOA,IAAP;AACD;AAED;AACA;AACA;;;AACA,SAASoD,oBAAT,CAA8BhD,IAA9B,EAAoCuC,OAApC,EAA6C;EAC3C;EACA,IAAIU,KAAK,GAAG,IAAInD,GAAJ,EAAZ;EAEA,IAAIoD,aAAa,GAAGX,OAAO,CAACY,UAAR,CAAmBC,IAAnB,IAA2B,EAA/C;EAEApD,IAAI,CAACG,SAAL,CAAe,CAACC,IAAD,EAAOiD,GAAP,KAAe;IAC5B;IACA,KAAK,IAAIzD,IAAT,IAAiB6C,UAAU,CAACrC,IAAD,CAA3B,EAAmC;MACjC,IAAIR,IAAI,CAAC0D,IAAL,CAAUC,QAAV,EAAoBC,KAApB,KAA8BC,SAAlC,EAA6C;QAC3C;MACD;IACF,CAN2B,CAQ5B;;;IACA,IAAI1D,SAAS,GAAG+C,WAAW,CAAC1C,IAAD,CAA3B;;IAEA,KAAK,IAAIsD,SAAT,IAAsB/D,cAAc,CAACS,IAAD,CAApC,EAA4C;MAC1C,IAAIuD,IAAI,GAAGV,KAAK,CAACrC,GAAN,CAAU8C,SAAV,KAAwB,EAAnC;MACAT,KAAK,CAACpC,GAAN,CAAU6C,SAAV,EAAqBC,IAArB;MAEAA,IAAI,CAACC,IAAL,CAAU,CACR;QACEJ,KAAK,EAAE,MADT;QAEEK,IAAI,EAAEC,MAAM,CAACT,GAAD,CAAN,GAAcH,aAFtB;QAGEa,SAAS,EAAE;MAHb,CADQ,EAMRhE,SANQ,CAAV;IAQD;EACF,CAxBD;EA0BA,OAAOkD,KAAP;AACD;AAED;AACA;AACA;;;AACA,SAASe,eAAT,CAAyBC,eAAzB,EAA0C1B,OAA1C,EAAmD;EACjD,KAAK,IAAIJ,SAAT,IAAsB8B,eAAtB,EAAuC;IACrC,IAAI1B,OAAO,CAAC2B,aAAR,CAAsBC,GAAtB,CAA0BhC,SAA1B,KAAwCI,OAAO,CAAC6B,eAAR,CAAwBD,GAAxB,CAA4BhC,SAA5B,CAA5C,EAAoF;MAClF;IACD;;IAED,IAAII,OAAO,CAAC8B,UAAR,CAAmBF,GAAnB,CAAuBhC,SAAvB,CAAJ,EAAuC;MACrCI,OAAO,CAAC6B,eAAR,CAAwBvD,GAAxB,CACEsB,SADF,EAEEI,OAAO,CAAC8B,UAAR,CAAmBzD,GAAnB,CAAuBuB,SAAvB,EAAkCR,GAAlC,CAAsC;QAAA,IAAC,CAAC2C,IAAD,EAAOlE,IAAP,CAAD;QAAA,OAAkB,CAACkE,IAAD,EAAOlE,IAAI,CAACF,KAAL,EAAP,CAAlB;MAAA,CAAtC,CAFF;MAIA;IACD;;IAED,IAAIqE,OAAO,GAAGnD,KAAK,CAACC,IAAN,CAAW7B,cAAc,CAAC2C,SAAD,EAAYI,OAAZ,CAAzB,CAAd;;IAEA,IAAIgC,OAAO,CAACC,MAAR,KAAmB,CAAvB,EAA0B;MACxBjC,OAAO,CAAC2B,aAAR,CAAsBnD,GAAtB,CAA0BoB,SAA1B;MACA;IACD;;IAEDI,OAAO,CAAC6B,eAAR,CAAwBvD,GAAxB,CAA4BsB,SAA5B,EAAuCoC,OAAvC;EACD;;EAED,OAAOhC,OAAO,CAAC6B,eAAf;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,SAAT,CAAmBC,YAAnB,EAAiC;EAC/B,IAAIzB,KAAK,GAAG,IAAZ;EAEA,OAAO;IACLrC,GAAG,EAAG+D,IAAD,IAAU;MACb1B,KAAK,GAAGA,KAAK,IAAIyB,YAAY,EAA7B;MAEA,OAAOzB,KAAK,CAACrC,GAAN,CAAU+D,IAAV,CAAP;IACD,CALI;IAMLR,GAAG,EAAGQ,IAAD,IAAU;MACb1B,KAAK,GAAGA,KAAK,IAAIyB,YAAY,EAA7B;MAEA,OAAOzB,KAAK,CAACkB,GAAN,CAAUQ,IAAV,CAAP;IACD;EAVI,CAAP;AAYD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,aAAT,CAAuBC,MAAvB,EAA+B;EAC7B,OAAO;IACLjE,GAAG,EAAG+D,IAAD,IAAUE,MAAM,CAACC,OAAP,CAAgB7B,KAAD,IAAWA,KAAK,CAACrC,GAAN,CAAU+D,IAAV,KAAmB,EAA7C,CADV;IAELR,GAAG,EAAGQ,IAAD,IAAUE,MAAM,CAACE,IAAP,CAAa9B,KAAD,IAAWA,KAAK,CAACkB,GAAN,CAAUQ,IAAV,CAAvB;EAFV,CAAP;AAID;;AAED,SAASK,sBAAT,CAAgCC,MAAhC,EAAwC;EACtC,IAAIjD,UAAU,GAAGiD,MAAM,CAAC7C,KAAP,CAAa,YAAb,CAAjB;;EAEA,IAAIJ,UAAU,CAACA,UAAU,CAACwC,MAAX,GAAoB,CAArB,CAAV,KAAsC,YAA1C,EAAwD;IACtD,OAAO,CAACxC,UAAU,CAACkD,KAAX,CAAiB,CAAjB,EAAoB,CAAC,CAArB,CAAD,EAA0B,IAA1B,CAAP;EACD;;EAED,OAAO,CAAClD,UAAD,EAAa,KAAb,CAAP;AACD;;AAED,SAASmD,YAAT,CAAsBnF,IAAtB,EAA4BuC,OAA5B,EAAqC6C,UAArC,EAAiD;EAC/C,IAAInB,eAAe,GAAG,IAAInD,GAAJ,EAAtB,CAD+C,CAG/C;;EACA,IAAIuE,OAAO,GAAG,EAAd;EACArF,IAAI,CAACsF,WAAL,CAAiB,OAAjB,EAA2BlF,IAAD,IAAU;IAClC,IAAI,CAAC4B,UAAD,IAAegD,sBAAsB,CAAC5E,IAAI,CAAC6E,MAAN,CAAzC;;IAEA,KAAK,IAAIM,IAAT,IAAiBvD,UAAjB,EAA6B;MAC3BiC,eAAe,CAAClD,GAAhB,CAAoBwE,IAApB;IACD;;IAEDF,OAAO,CAACzB,IAAR,CAAaxD,IAAb;EACD,CARD,EAL+C,CAe/C;;EACA,IAAIiF,OAAO,CAACb,MAAR,KAAmB,CAAvB,EAA0B;IACxB;EACD,CAlB8C,CAoB/C;;;EACA,IAAIJ,eAAe,GAAGQ,aAAa,CAAC,CAACQ,UAAD,EAAapB,eAAe,CAACC,eAAD,EAAkB1B,OAAlB,CAA5B,CAAD,CAAnC;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE;;EACA,SAASiD,eAAT,CAAyBtE,QAAzB,EAAmCuE,gBAAnC,EAAqDtD,SAArD,EAAgE;IAC9D,IAAIuD,MAAM,GAAI,IAAGhG,eAAe,CAACyC,SAAD,CAAY,EAA5C;IACA,IAAIwD,OAAO,GAAG,CAAC,GAAG,IAAI7E,GAAJ,CAAQ,CAAC4E,MAAD,EAASA,MAAM,CAACE,OAAP,CAAe,QAAf,EAAyB,KAAzB,CAAT,CAAR,CAAJ,CAAd;IACA,IAAIC,oBAAoB,GAAGjE,gBAAgB,CAAC6D,gBAAD,CAA3C;IAEA,OAAO7D,gBAAgB,CAACV,QAAD,CAAhB,CACJS,GADI,CACCmE,CAAD,IAAO;MACV,IAAIC,QAAQ,GAAG,EAAf;;MAEA,KAAK,IAAIC,eAAT,IAA4BH,oBAA5B,EAAkD;QAChD,IAAII,gBAAgB,GAAGD,eAAvB;;QACA,KAAK,MAAMN,MAAX,IAAqBC,OAArB,EAA8B;UAC5BM,gBAAgB,GAAGA,gBAAgB,CAACL,OAAjB,CAAyBF,MAAzB,EAAiCI,CAAjC,CAAnB;QACD;;QACD,IAAIG,gBAAgB,KAAKD,eAAzB,EAA0C;UACxC;QACD;;QACDD,QAAQ,CAACnC,IAAT,CAAcqC,gBAAd;MACD;;MACD,OAAOF,QAAQ,CAACG,IAAT,CAAc,IAAd,CAAP;IACD,CAfI,EAgBJA,IAhBI,CAgBC,IAhBD,CAAP;EAiBD;;EAED,IAAIC,gBAAgB,GAAG,IAAIrG,GAAJ,EAAvB,CApE+C,CAsE/C;;EACA,KAAK,IAAIsG,KAAT,IAAkBf,OAAlB,EAA2B;IACzB,IAAI,CAACrD,UAAD,IAAemE,gBAAgB,CAACvF,GAAjB,CAAqBwF,KAAK,CAAC3F,MAA3B,KAAsC,CAAC,EAAD,EAAK2F,KAAK,CAACC,MAAX,CAAzD;IAEAF,gBAAgB,CAACtF,GAAjB,CAAqBuF,KAAK,CAAC3F,MAA3B,EAAmC,CAACuB,UAAD,EAAaoE,KAAK,CAACC,MAAnB,CAAnC;IAEA,IAAI,CAACpC,eAAD,EAAkBF,SAAlB,IAA+BiB,sBAAsB,CAACoB,KAAK,CAACnB,MAAP,CAAzD;;IAEA,IAAImB,KAAK,CAAC3F,MAAN,CAAasC,IAAb,KAAsB,QAA1B,EAAoC;MAClC,IAAIqD,KAAK,CAAC3F,MAAN,CAAakE,IAAb,KAAsB,QAA1B,EAAoC;QAClC,MAAM2B,UAAU,GAAGF,KAAK,CAAC3F,MAAN,CAAawE,MAAhC;QAEA,MAAMmB,KAAK,CAACG,KAAN,CACH,oGAAmGtC,eAAe,CAChHtC,GADiG,CAC5F6E,CAAD,IAAQ,GAAEF,UAAW,IAAGE,CAAE,EADmE,EAEjGN,IAFiG,CAE5F,GAF4F,CAEvF,WAHT,CAAN;MAKD;;MAED,MAAME,KAAK,CAACG,KAAN,CACH,wDAAuDH,KAAK,CAAC3F,MAAN,CAAakE,IAAK,qCAAoCyB,KAAK,CAAC3F,MAAN,CAAakE,IAAK,GAD5H,CAAN;IAGD;;IAED,KAAK,IAAI8B,cAAT,IAA2BxC,eAA3B,EAA4C;MAC1C,IAAI,CAAC3B,MAAM,CAACC,OAAD,EAAU,OAAV,CAAP,EAA2BD,MAAM,CAACC,OAAD,EAAU,MAAV,CAAjC,EAAoDmE,QAApD,CAA6DD,cAA7D,CAAJ,EAAkF;QAChF;QACA,MAAML,KAAK,CAACG,KAAN,CAAa,uCAAsCE,cAAe,WAAlE,CAAN;MACD;;MAED,IAAI,CAACrC,eAAe,CAACD,GAAhB,CAAoBsC,cAApB,CAAL,EAA0C;QACxC,MAAML,KAAK,CAACG,KAAN,CACH,SAAQE,cAAe,iCAAgCA,cAAe,8EADnE,CAAN;MAGD;;MAED,IAAIE,KAAK,GAAGvC,eAAe,CAACxD,GAAhB,CAAoB6F,cAApB,CAAZ;MAEAzE,UAAU,CAAC4B,IAAX,CAAgB,CAAC6C,cAAD,EAAiB1C,SAAjB,EAA4B4C,KAA5B,CAAhB;IACD;EACF;;EAED,KAAK,MAAM,CAAClG,MAAD,EAAS,CAACuB,UAAD,EAAa4E,aAAb,CAAT,CAAX,IAAoDT,gBAApD,EAAsE;IACpE,IAAIU,QAAQ,GAAG,EAAf;;IAEA,KAAK,IAAI,CAACJ,cAAD,EAAiB1C,SAAjB,EAA4B4C,KAA5B,CAAT,IAA+C3E,UAA/C,EAA2D;MACzD,IAAI8E,wBAAwB,GAAG,CAC7BL,cAD6B,EAE7B,GAAG1E,qBAAqB,CAAC,CAAC0E,cAAD,CAAD,EAAmBlE,OAAO,CAACC,cAAR,CAAuBP,SAA1C,CAFK,CAA/B;;MAKA,KAAK,IAAI,CAACqC,IAAD,EAAO1E,IAAP,CAAT,IAAyB+G,KAAzB,EAAgC;QAC9B,IAAII,aAAa,GAAGpH,cAAc,CAACc,MAAD,CAAlC;QACA,IAAIuG,WAAW,GAAGrH,cAAc,CAACC,IAAD,CAAhC,CAF8B,CAI9B;QACA;;QACAoH,WAAW,GAAGA,WAAW,CAACnH,MAAZ,CACXoH,MADW,CACHC,SAAD,IACNA,SAAS,CAACnC,IAAV,CAAgBrB,SAAD,IAAeoD,wBAAwB,CAACJ,QAAzB,CAAkChD,SAAlC,CAA9B,CAFU,EAIXnC,IAJW,EAAd,CAN8B,CAY9B;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QACAyF,WAAW,GAAGA,WAAW,CAACG,MAAZ,CACZpF,qBAAqB,CAACiF,WAAD,EAAczE,OAAO,CAACC,cAAR,CAAuBP,SAArC,CADT,CAAd;QAIA,IAAImF,UAAU,GAAGL,aAAa,CAAChC,IAAd,CAAoB7D,QAAD,IAAc8F,WAAW,CAACN,QAAZ,CAAqBxF,QAArB,CAAjC,CAAjB;;QACA,IAAIkG,UAAJ,EAAgB;UACd,MAAMxH,IAAI,CAAC2G,KAAL,CACH,+BAA8BE,cAAe,2DAD1C,CAAN;QAGD;;QAED,IAAIzG,IAAI,GAAGV,OAAO,CAACU,IAAR,CAAa;UAAEC,KAAK,EAAE,CAACL,IAAI,CAACM,KAAL,EAAD;QAAT,CAAb,CAAX,CA7C8B,CA+C9B;;QACAF,IAAI,CAACqH,IAAL,CAAWzH,IAAD,IAAU;UAClBA,IAAI,CAACyG,MAAL,GAAcO,aAAd;QACD,CAFD;QAIA,IAAIU,kBAAkB,GACpB1H,IAAI,CAACmD,IAAL,KAAc,QAAd,IAA2BnD,IAAI,CAACmD,IAAL,KAAc,QAAd,IAA0BnD,IAAI,CAAC+E,IAAL,KAAc,WADrE;;QAGA,IAAI2C,kBAAJ,EAAwB;UACtBtH,IAAI,CAACG,SAAL,CAAgBC,IAAD,IAAU;YACvB;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA,IAAI,CAACT,cAAc,CAACS,IAAD,CAAd,CAAqB2E,IAArB,CAA2B5C,SAAD,IAAeA,SAAS,KAAKsE,cAAvD,CAAL,EAA6E;cAC3ErG,IAAI,CAACmH,MAAL;cACA;YACD,CAnCsB,CAqCvB;;;YACA,IAAIC,iBAAiB,GACnB,OAAOjF,OAAO,CAACC,cAAR,CAAuBuB,SAA9B,KAA4C,QAA5C,GACIxB,OAAO,CAACC,cAAR,CAAuBuB,SAD3B,GAEI,IAHN,CAtCuB,CA2CvB;YACA;;YACA,IAAI0D,WAAW,GAAGhH,MAAM,CAAC6C,IAAP,CAAYC,QAAZ,KAAyBE,SAA3C;YAEA,IAAIjD,cAAc,GAChBiH,WAAW,IAAID,iBAAf,IAAoC/G,MAAM,CAACS,QAAP,CAAgBwG,OAAhB,CAAwBF,iBAAxB,MAA+C,CAAnF,GACI/G,MAAM,CAACS,QAAP,CAAgBgE,KAAhB,CAAsBsC,iBAAiB,CAAChD,MAAxC,CADJ,GAEI/D,MAAM,CAACS,QAHb;YAKAd,IAAI,CAACc,QAAL,GAAgBsE,eAAe,CAAChF,cAAD,EAAiBJ,IAAI,CAACc,QAAtB,EAAgCuF,cAAhC,CAA/B,CApDuB,CAsDvB;;YACA,IAAIe,iBAAiB,IAAIhH,cAAc,KAAKC,MAAM,CAACS,QAAnD,EAA6D;cAC3Dd,IAAI,CAACc,QAAL,GAAiB,GAAEsG,iBAAkB,IAAGpH,IAAI,CAACc,QAAS,EAAtD;YACD;;YAEDd,IAAI,CAACuH,SAAL,CAAgBC,CAAD,IAAO;cACpBA,CAAC,CAAC7D,SAAF,GAAcO,IAAI,CAACP,SAAL,IAAkBA,SAAhC;YACD,CAFD;UAGD,CA9DD;QA+DD,CAvH6B,CAyH9B;QACA;;;QACA,IAAI,CAAC/D,IAAI,CAACC,KAAL,CAAW,CAAX,CAAL,EAAoB;UAClB;QACD,CA7H6B,CA+H9B;;;QACA4G,QAAQ,CAACjD,IAAT,CAAc,CACZ;QACA,EAAE,GAAGU,IAAL;UAAWT,IAAI,EAAES,IAAI,CAACT,IAAL,GAAYtB,OAAO,CAACY,UAAR,CAAmBmB,IAAI,CAACd,KAAxB;QAA7B,CAFY,EAGZxD,IAAI,CAACC,KAAL,CAAW,CAAX,CAHY,CAAd;MAKD;IACF,CA/ImE,CAiJpE;;;IACA,IAAIA,KAAK,GAAG4G,QAAQ,CAAChD,IAAT,CAAc;MAAA,IAAC,CAACgE,CAAD,CAAD;MAAA,IAAM,CAACC,CAAD,CAAN;MAAA,OAAcrI,OAAO,CAACoI,CAAC,CAAChE,IAAF,GAASiE,CAAC,CAACjE,IAAZ,CAArB;IAAA,CAAd,EAAsDlC,GAAtD,CAA2DmE,CAAD,IAAOA,CAAC,CAAC,CAAD,CAAlE,CAAZ,CAlJoE,CAoJpE;;IACArF,MAAM,CAACsH,KAAP,CAAa9H,KAAb;EACD;;EAED,KAAK,IAAImG,KAAT,IAAkBf,OAAlB,EAA2B;IACzB;IACA,IAAIe,KAAK,CAAC3F,MAAN,CAAaR,KAAb,CAAmBuE,MAAnB,GAA4B,CAAhC,EAAmC;MACjC4B,KAAK,CAACmB,MAAN;IACD,CAFD,MAEO;MACL;MACAnB,KAAK,CAAC3F,MAAN,CAAa8G,MAAb;IACD;EACF,CAhR8C,CAkR/C;;;EACApC,YAAY,CAACnF,IAAD,EAAOuC,OAAP,EAAgB6C,UAAhB,CAAZ;AACD;;AAED,eAAe,SAAS4C,kBAAT,CAA4BzF,OAA5B,EAAqC;EAClD,OAAQvC,IAAD,IAAU;IACf;IACA,IAAIoF,UAAU,GAAGX,SAAS,CAAC,MAAMzB,oBAAoB,CAAChD,IAAD,EAAOuC,OAAP,CAA3B,CAA1B;IAEA4C,YAAY,CAACnF,IAAD,EAAOuC,OAAP,EAAgB6C,UAAhB,CAAZ;EACD,CALD;AAMD"},"metadata":{},"sourceType":"module"}