{"ast":null,"code":"/**\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\n * @author Stephen Murray <spmurrayzzz>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst TEST_CONDITION_PARENT_TYPES = new Set([\"IfStatement\", \"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ConditionalExpression\"]);\nconst NODE_DESCRIPTIONS = {\n  DoWhileStatement: \"a 'do...while' statement\",\n  ForStatement: \"a 'for' statement\",\n  IfStatement: \"an 'if' statement\",\n  WhileStatement: \"a 'while' statement\"\n}; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow assignment operators in conditional expressions\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-cond-assign\"\n    },\n    schema: [{\n      enum: [\"except-parens\", \"always\"]\n    }],\n    messages: {\n      unexpected: \"Unexpected assignment within {{type}}.\",\n      // must match JSHint's error message\n      missing: \"Expected a conditional expression and instead saw an assignment.\"\n    }\n  },\n\n  create(context) {\n    const prohibitAssign = context.options[0] || \"except-parens\";\n    const sourceCode = context.getSourceCode();\n    /**\n     * Check whether an AST node is the test expression for a conditional statement.\n     * @param {!Object} node The node to test.\n     * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\n     */\n\n    function isConditionalTestExpression(node) {\n      return node.parent && TEST_CONDITION_PARENT_TYPES.has(node.parent.type) && node === node.parent.test;\n    }\n    /**\n     * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\n     * @param {!Object} node The node to use at the start of the search.\n     * @returns {?Object} The closest ancestor node that represents a conditional statement.\n     */\n\n\n    function findConditionalAncestor(node) {\n      let currentAncestor = node;\n\n      do {\n        if (isConditionalTestExpression(currentAncestor)) {\n          return currentAncestor.parent;\n        }\n      } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));\n\n      return null;\n    }\n    /**\n     * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\n     * @param {!Object} node The node to test.\n     * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\n     */\n\n\n    function isParenthesisedTwice(node) {\n      const previousToken = sourceCode.getTokenBefore(node, 1),\n            nextToken = sourceCode.getTokenAfter(node, 1);\n      return astUtils.isParenthesised(sourceCode, node) && previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n    }\n    /**\n     * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\n     * @param {!Object} node The node for the conditional statement.\n     * @returns {void}\n     */\n\n\n    function testForAssign(node) {\n      if (node.test && node.test.type === \"AssignmentExpression\" && (node.type === \"ForStatement\" ? !astUtils.isParenthesised(sourceCode, node.test) : !isParenthesisedTwice(node.test))) {\n        context.report({\n          node: node.test,\n          messageId: \"missing\"\n        });\n      }\n    }\n    /**\n     * Check whether an assignment expression is descended from a conditional statement's test expression.\n     * @param {!Object} node The node for the assignment expression.\n     * @returns {void}\n     */\n\n\n    function testForConditionalAncestor(node) {\n      const ancestor = findConditionalAncestor(node);\n\n      if (ancestor) {\n        context.report({\n          node,\n          messageId: \"unexpected\",\n          data: {\n            type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n          }\n        });\n      }\n    }\n\n    if (prohibitAssign === \"always\") {\n      return {\n        AssignmentExpression: testForConditionalAncestor\n      };\n    }\n\n    return {\n      DoWhileStatement: testForAssign,\n      ForStatement: testForAssign,\n      IfStatement: testForAssign,\n      WhileStatement: testForAssign,\n      ConditionalExpression: testForAssign\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","TEST_CONDITION_PARENT_TYPES","Set","NODE_DESCRIPTIONS","DoWhileStatement","ForStatement","IfStatement","WhileStatement","module","exports","meta","type","docs","description","recommended","url","schema","enum","messages","unexpected","missing","create","context","prohibitAssign","options","sourceCode","getSourceCode","isConditionalTestExpression","node","parent","has","test","findConditionalAncestor","currentAncestor","isFunction","isParenthesisedTwice","previousToken","getTokenBefore","nextToken","getTokenAfter","isParenthesised","isOpeningParenToken","range","isClosingParenToken","testForAssign","report","messageId","testForConditionalAncestor","ancestor","data","AssignmentExpression","ConditionalExpression"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/no-cond-assign.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\n * @author Stephen Murray <spmurrayzzz>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst TEST_CONDITION_PARENT_TYPES = new Set([\"IfStatement\", \"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ConditionalExpression\"]);\n\nconst NODE_DESCRIPTIONS = {\n    DoWhileStatement: \"a 'do...while' statement\",\n    ForStatement: \"a 'for' statement\",\n    IfStatement: \"an 'if' statement\",\n    WhileStatement: \"a 'while' statement\"\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow assignment operators in conditional expressions\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-cond-assign\"\n        },\n\n        schema: [\n            {\n                enum: [\"except-parens\", \"always\"]\n            }\n        ],\n\n        messages: {\n            unexpected: \"Unexpected assignment within {{type}}.\",\n\n            // must match JSHint's error message\n            missing: \"Expected a conditional expression and instead saw an assignment.\"\n        }\n    },\n\n    create(context) {\n\n        const prohibitAssign = (context.options[0] || \"except-parens\");\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check whether an AST node is the test expression for a conditional statement.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\n         */\n        function isConditionalTestExpression(node) {\n            return node.parent &&\n                TEST_CONDITION_PARENT_TYPES.has(node.parent.type) &&\n                node === node.parent.test;\n        }\n\n        /**\n         * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\n         * @param {!Object} node The node to use at the start of the search.\n         * @returns {?Object} The closest ancestor node that represents a conditional statement.\n         */\n        function findConditionalAncestor(node) {\n            let currentAncestor = node;\n\n            do {\n                if (isConditionalTestExpression(currentAncestor)) {\n                    return currentAncestor.parent;\n                }\n            } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));\n\n            return null;\n        }\n\n        /**\n         * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\n         */\n        function isParenthesisedTwice(node) {\n            const previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return astUtils.isParenthesised(sourceCode, node) &&\n                previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\n         * @param {!Object} node The node for the conditional statement.\n         * @returns {void}\n         */\n        function testForAssign(node) {\n            if (node.test &&\n                (node.test.type === \"AssignmentExpression\") &&\n                (node.type === \"ForStatement\"\n                    ? !astUtils.isParenthesised(sourceCode, node.test)\n                    : !isParenthesisedTwice(node.test)\n                )\n            ) {\n\n                context.report({\n                    node: node.test,\n                    messageId: \"missing\"\n                });\n            }\n        }\n\n        /**\n         * Check whether an assignment expression is descended from a conditional statement's test expression.\n         * @param {!Object} node The node for the assignment expression.\n         * @returns {void}\n         */\n        function testForConditionalAncestor(node) {\n            const ancestor = findConditionalAncestor(node);\n\n            if (ancestor) {\n                context.report({\n                    node,\n                    messageId: \"unexpected\",\n                    data: {\n                        type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n                    }\n                });\n            }\n        }\n\n        if (prohibitAssign === \"always\") {\n            return {\n                AssignmentExpression: testForConditionalAncestor\n            };\n        }\n\n        return {\n            DoWhileStatement: testForAssign,\n            ForStatement: testForAssign,\n            IfStatement: testForAssign,\n            WhileStatement: testForAssign,\n            ConditionalExpression: testForAssign\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}