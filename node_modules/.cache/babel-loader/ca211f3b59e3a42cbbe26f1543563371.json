{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nodes = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral\n} = _t;\n\nfunction crawlInternal(node, state) {\n  if (!node) return state;\n\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawlInternal(node.object, state);\n    if (node.computed) crawlInternal(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawlInternal(node.left, state);\n    crawlInternal(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawlInternal(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);\n  }\n\n  return state;\n}\n\nfunction crawl(node) {\n  return crawlInternal(node, {\n    hasCall: false,\n    hasFunction: false,\n    hasHelper: false\n  });\n}\n\nfunction isHelper(node) {\n  if (!node) return false;\n\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return node.name === \"require\" || node.name.charCodeAt(0) === 95;\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node) {\n  return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);\n}\n\nconst nodes = {\n  AssignmentExpression(node) {\n    const state = crawl(node.right);\n\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return state.hasFunction ? 1 | 2 : 2;\n    }\n  },\n\n  SwitchCase(node, parent) {\n    return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);\n  },\n\n  LogicalExpression(node) {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return 2;\n    }\n  },\n\n  Literal(node) {\n    if (isStringLiteral(node) && node.value === \"use strict\") {\n      return 2;\n    }\n  },\n\n  CallExpression(node) {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return 1 | 2;\n    }\n  },\n\n  OptionalCallExpression(node) {\n    if (isFunction(node.callee)) {\n      return 1 | 2;\n    }\n  },\n\n  VariableDeclaration(node) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n\n      if (!enabled && declar.init) {\n        const state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n\n      if (enabled) {\n        return 1 | 2;\n      }\n    }\n  },\n\n  IfStatement(node) {\n    if (isBlockStatement(node.consequent)) {\n      return 1 | 2;\n    }\n  }\n\n};\nexports.nodes = nodes;\n\nnodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return 1;\n  }\n};\n\nnodes.ObjectTypeCallProperty = function (node, parent) {\n  var _parent$properties;\n\n  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {\n    return 1;\n  }\n};\n\nnodes.ObjectTypeIndexer = function (node, parent) {\n  var _parent$properties2, _parent$callPropertie;\n\n  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {\n    return 1;\n  }\n};\n\nnodes.ObjectTypeInternalSlot = function (node, parent) {\n  var _parent$properties3, _parent$callPropertie2, _parent$indexers;\n\n  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {\n    return 1;\n  }\n};\n\n[[\"Function\", true], [\"Class\", true], [\"Loop\", true], [\"LabeledStatement\", true], [\"SwitchStatement\", true], [\"TryStatement\", true]].forEach(function (_ref) {\n  let [type, amounts] = _ref;\n  [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    const ret = amounts ? 1 | 2 : 0;\n\n    nodes[type] = () => ret;\n  });\n});","map":{"version":3,"mappings":"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","names":["FLIPPED_ALIAS_KEYS","isArrayExpression","isAssignmentExpression","isBinary","isBlockStatement","isCallExpression","isFunction","isIdentifier","isLiteral","isMemberExpression","isObjectExpression","isOptionalCallExpression","isOptionalMemberExpression","isStringLiteral","crawlInternal","node","state","object","computed","property","left","right","hasCall","callee","hasFunction","hasHelper","isHelper","crawl","name","charCodeAt","isType","nodes","AssignmentExpression","SwitchCase","parent","consequent","length","cases","LogicalExpression","Literal","value","CallExpression","OptionalCallExpression","VariableDeclaration","i","declarations","declar","enabled","id","init","IfStatement","ObjectProperty","ObjectTypeProperty","ObjectMethod","properties","ObjectTypeCallProperty","callProperties","_parent$properties","ObjectTypeIndexer","indexers","_parent$properties2","_parent$callPropertie","ObjectTypeInternalSlot","internalSlots","_parent$properties3","_parent$callPropertie2","_parent$indexers","forEach","type","amounts","concat","ret"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\generator\\src\\node\\whitespace.ts"],"sourcesContent":["import {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral,\n} from \"@babel/types\";\nimport * as charCodes from \"charcodes\";\n\nimport type { NodeHandlers } from \"./index\";\n\nimport type * as t from \"@babel/types\";\n\nconst enum WhitespaceFlag {\n  before = 1 << 0,\n  after = 1 << 1,\n}\n\nexport type { WhitespaceFlag };\n\nfunction crawlInternal(\n  node: t.Node,\n  state: { hasCall: boolean; hasFunction: boolean; hasHelper: boolean },\n) {\n  if (!node) return state;\n\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawlInternal(node.object, state);\n    if (node.computed) crawlInternal(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawlInternal(node.left, state);\n    crawlInternal(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawlInternal(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper =\n      // @ts-expect-error todo(flow->ts): node.callee is not really expected hereâ€¦\n      state.hasHelper || (node.callee && isHelper(node.callee));\n  }\n\n  return state;\n}\n\n/**\n * Crawl a node to test if it contains a CallExpression, a Function, or a Helper.\n *\n * @example\n * crawl(node)\n * // { hasCall: false, hasFunction: true, hasHelper: false }\n */\n\nfunction crawl(node: t.Node) {\n  return crawlInternal(node, {\n    hasCall: false,\n    hasFunction: false,\n    hasHelper: false,\n  });\n}\n\n/**\n * Test if a node is or has a helper.\n */\n\nfunction isHelper(node: t.Node): boolean {\n  if (!node) return false;\n\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return (\n      node.name === \"require\" ||\n      node.name.charCodeAt(0) === charCodes.underscore\n    );\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return (\n      (isIdentifier(node.left) && isHelper(node.left)) || isHelper(node.right)\n    );\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node: t.Node) {\n  return (\n    isLiteral(node) ||\n    isObjectExpression(node) ||\n    isArrayExpression(node) ||\n    isIdentifier(node) ||\n    isMemberExpression(node)\n  );\n}\n\n/**\n * Tests for node types that need whitespace.\n */\n\nexport const nodes: NodeHandlers<WhitespaceFlag> = {\n  /**\n   * Test if AssignmentExpression needs whitespace.\n   */\n\n  AssignmentExpression(node: t.AssignmentExpression): WhitespaceFlag {\n    const state = crawl(node.right);\n    if ((state.hasCall && state.hasHelper) || state.hasFunction) {\n      return state.hasFunction\n        ? WhitespaceFlag.before | WhitespaceFlag.after\n        : WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if SwitchCase needs whitespace.\n   */\n\n  SwitchCase(node: t.SwitchCase, parent: t.SwitchStatement): WhitespaceFlag {\n    return (\n      (!!node.consequent.length || parent.cases[0] === node\n        ? WhitespaceFlag.before\n        : 0) |\n      (!node.consequent.length && parent.cases[parent.cases.length - 1] === node\n        ? WhitespaceFlag.after\n        : 0)\n    );\n  },\n\n  /**\n   * Test if LogicalExpression needs whitespace.\n   */\n\n  LogicalExpression(node: t.LogicalExpression): WhitespaceFlag {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if Literal needs whitespace.\n   */\n\n  Literal(node: t.Literal): WhitespaceFlag {\n    if (isStringLiteral(node) && node.value === \"use strict\") {\n      return WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if CallExpressionish needs whitespace.\n   */\n\n  CallExpression(node: t.CallExpression): WhitespaceFlag {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n\n  OptionalCallExpression(node: t.OptionalCallExpression): WhitespaceFlag {\n    if (isFunction(node.callee)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n\n  /**\n   * Test if VariableDeclaration needs whitespace.\n   */\n\n  VariableDeclaration(node: t.VariableDeclaration): WhitespaceFlag {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n      if (!enabled && declar.init) {\n        const state = crawl(declar.init);\n        enabled = (isHelper(declar.init) && state.hasCall) || state.hasFunction;\n      }\n\n      if (enabled) {\n        return WhitespaceFlag.before | WhitespaceFlag.after;\n      }\n    }\n  },\n\n  /**\n   * Test if IfStatement needs whitespace.\n   */\n\n  IfStatement(node: t.IfStatement): WhitespaceFlag {\n    if (isBlockStatement(node.consequent)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n  },\n};\n\n/**\n * Test if Property needs whitespace.\n */\n\nnodes.ObjectProperty =\n  nodes.ObjectTypeProperty =\n  nodes.ObjectMethod =\n    function (\n      node: t.ObjectProperty | t.ObjectTypeProperty | t.ObjectMethod,\n      parent: t.ObjectExpression,\n    ): WhitespaceFlag {\n      if (parent.properties[0] === node) {\n        return WhitespaceFlag.before;\n      }\n    };\n\nnodes.ObjectTypeCallProperty = function (\n  node: t.ObjectTypeCallProperty,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (parent.callProperties[0] === node && !parent.properties?.length) {\n    return WhitespaceFlag.before;\n  }\n};\n\nnodes.ObjectTypeIndexer = function (\n  node: t.ObjectTypeIndexer,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (\n    parent.indexers[0] === node &&\n    !parent.properties?.length &&\n    !parent.callProperties?.length\n  ) {\n    return WhitespaceFlag.before;\n  }\n};\n\nnodes.ObjectTypeInternalSlot = function (\n  node: t.ObjectTypeInternalSlot,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (\n    parent.internalSlots[0] === node &&\n    !parent.properties?.length &&\n    !parent.callProperties?.length &&\n    !parent.indexers?.length\n  ) {\n    return WhitespaceFlag.before;\n  }\n};\n\n/**\n * Add whitespace tests for nodes and their aliases.\n */\n\n(\n  [\n    [\"Function\", true],\n    [\"Class\", true],\n    [\"Loop\", true],\n    [\"LabeledStatement\", true],\n    [\"SwitchStatement\", true],\n    [\"TryStatement\", true],\n  ] as const\n).forEach(function ([type, amounts]) {\n  [type as string]\n    .concat(FLIPPED_ALIAS_KEYS[type] || [])\n    .forEach(function (type) {\n      const ret = amounts ? WhitespaceFlag.before | WhitespaceFlag.after : 0;\n      nodes[type] = () => ret;\n    });\n});\n"]},"metadata":{},"sourceType":"script"}