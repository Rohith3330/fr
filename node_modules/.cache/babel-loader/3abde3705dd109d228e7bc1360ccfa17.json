{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst InsertionText = require('./insertion-text');\n\nconst lt = '\\u0001';\nconst gt = '\\u0002';\nconst RE_LT = /</g;\nconst RE_GT = />/g;\nconst RE_AMP = /&/g; // eslint-disable-next-line\n\nvar RE_lt = /\\u0001/g; // eslint-disable-next-line\n\nvar RE_gt = /\\u0002/g;\n\nfunction title(str) {\n  return ' title=\"' + str + '\" ';\n}\n\nfunction customEscape(text) {\n  text = String(text);\n  return text.replace(RE_AMP, '&amp;').replace(RE_LT, '&lt;').replace(RE_GT, '&gt;').replace(RE_lt, '<').replace(RE_gt, '>');\n}\n\nfunction annotateLines(fileCoverage, structuredText) {\n  const lineStats = fileCoverage.getLineCoverage();\n\n  if (!lineStats) {\n    return;\n  }\n\n  Object.entries(lineStats).forEach(_ref => {\n    let [lineNumber, count] = _ref;\n\n    if (structuredText[lineNumber]) {\n      structuredText[lineNumber].covered = count > 0 ? 'yes' : 'no';\n      structuredText[lineNumber].hits = count;\n    }\n  });\n}\n\nfunction annotateStatements(fileCoverage, structuredText) {\n  const statementStats = fileCoverage.s;\n  const statementMeta = fileCoverage.statementMap;\n  Object.entries(statementStats).forEach(_ref2 => {\n    let [stName, count] = _ref2;\n    const meta = statementMeta[stName];\n    const type = count > 0 ? 'yes' : 'no';\n    const startCol = meta.start.column;\n    let endCol = meta.end.column + 1;\n    const startLine = meta.start.line;\n    const endLine = meta.end.line;\n    const openSpan = lt + 'span class=\"' + (meta.skip ? 'cstat-skip' : 'cstat-no') + '\"' + title('statement not covered') + gt;\n    const closeSpan = lt + '/span' + gt;\n    let text;\n\n    if (type === 'no' && structuredText[startLine]) {\n      if (endLine !== startLine) {\n        endCol = structuredText[startLine].text.originalLength();\n      }\n\n      text = structuredText[startLine].text;\n      text.wrap(startCol, openSpan, startCol < endCol ? endCol : text.originalLength(), closeSpan);\n    }\n  });\n}\n\nfunction annotateFunctions(fileCoverage, structuredText) {\n  const fnStats = fileCoverage.f;\n  const fnMeta = fileCoverage.fnMap;\n\n  if (!fnStats) {\n    return;\n  }\n\n  Object.entries(fnStats).forEach(_ref3 => {\n    let [fName, count] = _ref3;\n    const meta = fnMeta[fName];\n    const type = count > 0 ? 'yes' : 'no'; // Some versions of the instrumenter in the wild populate 'func'\n    // but not 'decl':\n\n    const decl = meta.decl || meta.loc;\n    const startCol = decl.start.column;\n    let endCol = decl.end.column + 1;\n    const startLine = decl.start.line;\n    const endLine = decl.end.line;\n    const openSpan = lt + 'span class=\"' + (meta.skip ? 'fstat-skip' : 'fstat-no') + '\"' + title('function not covered') + gt;\n    const closeSpan = lt + '/span' + gt;\n    let text;\n\n    if (type === 'no' && structuredText[startLine]) {\n      if (endLine !== startLine) {\n        endCol = structuredText[startLine].text.originalLength();\n      }\n\n      text = structuredText[startLine].text;\n      text.wrap(startCol, openSpan, startCol < endCol ? endCol : text.originalLength(), closeSpan);\n    }\n  });\n}\n\nfunction annotateBranches(fileCoverage, structuredText) {\n  const branchStats = fileCoverage.b;\n  const branchMeta = fileCoverage.branchMap;\n\n  if (!branchStats) {\n    return;\n  }\n\n  Object.entries(branchStats).forEach(_ref4 => {\n    let [branchName, branchArray] = _ref4;\n    const sumCount = branchArray.reduce((p, n) => p + n, 0);\n    const metaArray = branchMeta[branchName].locations;\n    let i;\n    let count;\n    let meta;\n    let startCol;\n    let endCol;\n    let startLine;\n    let endLine;\n    let openSpan;\n    let closeSpan;\n    let text; // only highlight if partial branches are missing or if there is a\n    // single uncovered branch.\n\n    if (sumCount > 0 || sumCount === 0 && branchArray.length === 1) {\n      // Need to recover the metaArray placeholder item to count an implicit else\n      if ( // Check if the branch is a conditional if branch.\n      branchMeta[branchName].type === 'if' && // Check if the branch has an implicit else.\n      branchArray.length === 2 && // Check if the implicit else branch is unnacounted for.\n      metaArray.length === 1 && // Check if the implicit else branch is uncovered.\n      branchArray[1] === 0) {\n        metaArray[1] = {\n          start: {},\n          end: {}\n        };\n      }\n\n      for (i = 0; i < branchArray.length && i < metaArray.length; i += 1) {\n        count = branchArray[i];\n        meta = metaArray[i];\n        startCol = meta.start.column;\n        endCol = meta.end.column + 1;\n        startLine = meta.start.line;\n        endLine = meta.end.line;\n        openSpan = lt + 'span class=\"branch-' + i + ' ' + (meta.skip ? 'cbranch-skip' : 'cbranch-no') + '\"' + title('branch not covered') + gt;\n        closeSpan = lt + '/span' + gt; // If the branch is an implicit else from an if statement,\n        // then the coverage report won't show a statistic.\n        // Therefore, the previous branch will be used to report that\n        // there is no coverage on that implicit branch.\n\n        if (count === 0 && startLine === undefined && branchMeta[branchName].type === 'if') {\n          const prevMeta = metaArray[i - 1];\n          startCol = prevMeta.start.column;\n          endCol = prevMeta.end.column + 1;\n          startLine = prevMeta.start.line;\n          endLine = prevMeta.end.line;\n        }\n\n        if (count === 0 && structuredText[startLine]) {\n          //skip branches taken\n          if (endLine !== startLine) {\n            endCol = structuredText[startLine].text.originalLength();\n          }\n\n          text = structuredText[startLine].text;\n\n          if (branchMeta[branchName].type === 'if') {\n            // 'if' is a special case\n            // since the else branch might not be visible, being non-existent\n            text.insertAt(startCol, lt + 'span class=\"' + (meta.skip ? 'skip-if-branch' : 'missing-if-branch') + '\"' + title((i === 0 ? 'if' : 'else') + ' path not taken') + gt + (i === 0 ? 'I' : 'E') + lt + '/span' + gt, true, false);\n          } else {\n            text.wrap(startCol, openSpan, startCol < endCol ? endCol : text.originalLength(), closeSpan);\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction annotateSourceCode(fileCoverage, sourceStore) {\n  let codeArray;\n  let lineCoverageArray;\n\n  try {\n    const sourceText = sourceStore.getSource(fileCoverage.path);\n    const code = sourceText.split(/(?:\\r?\\n)|\\r/);\n    let count = 0;\n    const structured = code.map(str => {\n      count += 1;\n      return {\n        line: count,\n        covered: 'neutral',\n        hits: 0,\n        text: new InsertionText(str, true)\n      };\n    });\n    structured.unshift({\n      line: 0,\n      covered: null,\n      text: new InsertionText('')\n    });\n    annotateLines(fileCoverage, structured); //note: order is important, since statements typically result in spanning the whole line and doing branches late\n    //causes mismatched tags\n\n    annotateBranches(fileCoverage, structured);\n    annotateFunctions(fileCoverage, structured);\n    annotateStatements(fileCoverage, structured);\n    structured.shift();\n    codeArray = structured.map(item => customEscape(item.text.toString()) || '&nbsp;');\n    lineCoverageArray = structured.map(item => ({\n      covered: item.covered,\n      hits: item.hits > 0 ? item.hits + 'x' : '&nbsp;'\n    }));\n    return {\n      annotatedCode: codeArray,\n      lineCoverage: lineCoverageArray,\n      maxLines: structured.length\n    };\n  } catch (ex) {\n    codeArray = [ex.message];\n    lineCoverageArray = [{\n      covered: 'no',\n      hits: 0\n    }];\n    String(ex.stack || '').split(/\\r?\\n/).forEach(line => {\n      codeArray.push(line);\n      lineCoverageArray.push({\n        covered: 'no',\n        hits: 0\n      });\n    });\n    return {\n      annotatedCode: codeArray,\n      lineCoverage: lineCoverageArray,\n      maxLines: codeArray.length\n    };\n  }\n}\n\nmodule.exports = annotateSourceCode;","map":{"version":3,"names":["InsertionText","require","lt","gt","RE_LT","RE_GT","RE_AMP","RE_lt","RE_gt","title","str","customEscape","text","String","replace","annotateLines","fileCoverage","structuredText","lineStats","getLineCoverage","Object","entries","forEach","lineNumber","count","covered","hits","annotateStatements","statementStats","s","statementMeta","statementMap","stName","meta","type","startCol","start","column","endCol","end","startLine","line","endLine","openSpan","skip","closeSpan","originalLength","wrap","annotateFunctions","fnStats","f","fnMeta","fnMap","fName","decl","loc","annotateBranches","branchStats","b","branchMeta","branchMap","branchName","branchArray","sumCount","reduce","p","n","metaArray","locations","i","length","undefined","prevMeta","insertAt","annotateSourceCode","sourceStore","codeArray","lineCoverageArray","sourceText","getSource","path","code","split","structured","map","unshift","shift","item","toString","annotatedCode","lineCoverage","maxLines","ex","message","stack","push","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/istanbul-reports/lib/html/annotator.js"],"sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst InsertionText = require('./insertion-text');\nconst lt = '\\u0001';\nconst gt = '\\u0002';\nconst RE_LT = /</g;\nconst RE_GT = />/g;\nconst RE_AMP = /&/g;\n// eslint-disable-next-line\nvar RE_lt = /\\u0001/g;\n// eslint-disable-next-line\nvar RE_gt = /\\u0002/g;\n\nfunction title(str) {\n    return ' title=\"' + str + '\" ';\n}\n\nfunction customEscape(text) {\n    text = String(text);\n    return text\n        .replace(RE_AMP, '&amp;')\n        .replace(RE_LT, '&lt;')\n        .replace(RE_GT, '&gt;')\n        .replace(RE_lt, '<')\n        .replace(RE_gt, '>');\n}\n\nfunction annotateLines(fileCoverage, structuredText) {\n    const lineStats = fileCoverage.getLineCoverage();\n    if (!lineStats) {\n        return;\n    }\n    Object.entries(lineStats).forEach(([lineNumber, count]) => {\n        if (structuredText[lineNumber]) {\n            structuredText[lineNumber].covered = count > 0 ? 'yes' : 'no';\n            structuredText[lineNumber].hits = count;\n        }\n    });\n}\n\nfunction annotateStatements(fileCoverage, structuredText) {\n    const statementStats = fileCoverage.s;\n    const statementMeta = fileCoverage.statementMap;\n    Object.entries(statementStats).forEach(([stName, count]) => {\n        const meta = statementMeta[stName];\n        const type = count > 0 ? 'yes' : 'no';\n        const startCol = meta.start.column;\n        let endCol = meta.end.column + 1;\n        const startLine = meta.start.line;\n        const endLine = meta.end.line;\n        const openSpan =\n            lt +\n            'span class=\"' +\n            (meta.skip ? 'cstat-skip' : 'cstat-no') +\n            '\"' +\n            title('statement not covered') +\n            gt;\n        const closeSpan = lt + '/span' + gt;\n        let text;\n\n        if (type === 'no' && structuredText[startLine]) {\n            if (endLine !== startLine) {\n                endCol = structuredText[startLine].text.originalLength();\n            }\n            text = structuredText[startLine].text;\n            text.wrap(\n                startCol,\n                openSpan,\n                startCol < endCol ? endCol : text.originalLength(),\n                closeSpan\n            );\n        }\n    });\n}\n\nfunction annotateFunctions(fileCoverage, structuredText) {\n    const fnStats = fileCoverage.f;\n    const fnMeta = fileCoverage.fnMap;\n    if (!fnStats) {\n        return;\n    }\n    Object.entries(fnStats).forEach(([fName, count]) => {\n        const meta = fnMeta[fName];\n        const type = count > 0 ? 'yes' : 'no';\n        // Some versions of the instrumenter in the wild populate 'func'\n        // but not 'decl':\n        const decl = meta.decl || meta.loc;\n        const startCol = decl.start.column;\n        let endCol = decl.end.column + 1;\n        const startLine = decl.start.line;\n        const endLine = decl.end.line;\n        const openSpan =\n            lt +\n            'span class=\"' +\n            (meta.skip ? 'fstat-skip' : 'fstat-no') +\n            '\"' +\n            title('function not covered') +\n            gt;\n        const closeSpan = lt + '/span' + gt;\n        let text;\n\n        if (type === 'no' && structuredText[startLine]) {\n            if (endLine !== startLine) {\n                endCol = structuredText[startLine].text.originalLength();\n            }\n            text = structuredText[startLine].text;\n            text.wrap(\n                startCol,\n                openSpan,\n                startCol < endCol ? endCol : text.originalLength(),\n                closeSpan\n            );\n        }\n    });\n}\n\nfunction annotateBranches(fileCoverage, structuredText) {\n    const branchStats = fileCoverage.b;\n    const branchMeta = fileCoverage.branchMap;\n    if (!branchStats) {\n        return;\n    }\n\n    Object.entries(branchStats).forEach(([branchName, branchArray]) => {\n        const sumCount = branchArray.reduce((p, n) => p + n, 0);\n        const metaArray = branchMeta[branchName].locations;\n        let i;\n        let count;\n        let meta;\n        let startCol;\n        let endCol;\n        let startLine;\n        let endLine;\n        let openSpan;\n        let closeSpan;\n        let text;\n\n        // only highlight if partial branches are missing or if there is a\n        // single uncovered branch.\n        if (sumCount > 0 || (sumCount === 0 && branchArray.length === 1)) {\n            // Need to recover the metaArray placeholder item to count an implicit else\n            if (\n                // Check if the branch is a conditional if branch.\n                branchMeta[branchName].type === 'if' &&\n                // Check if the branch has an implicit else.\n                branchArray.length === 2 &&\n                // Check if the implicit else branch is unnacounted for.\n                metaArray.length === 1 &&\n                // Check if the implicit else branch is uncovered.\n                branchArray[1] === 0\n            ) {\n                metaArray[1] = {\n                    start: {},\n                    end: {}\n                };\n            }\n\n            for (\n                i = 0;\n                i < branchArray.length && i < metaArray.length;\n                i += 1\n            ) {\n                count = branchArray[i];\n                meta = metaArray[i];\n                startCol = meta.start.column;\n                endCol = meta.end.column + 1;\n                startLine = meta.start.line;\n                endLine = meta.end.line;\n                openSpan =\n                    lt +\n                    'span class=\"branch-' +\n                    i +\n                    ' ' +\n                    (meta.skip ? 'cbranch-skip' : 'cbranch-no') +\n                    '\"' +\n                    title('branch not covered') +\n                    gt;\n                closeSpan = lt + '/span' + gt;\n\n                // If the branch is an implicit else from an if statement,\n                // then the coverage report won't show a statistic.\n                // Therefore, the previous branch will be used to report that\n                // there is no coverage on that implicit branch.\n                if (\n                    count === 0 &&\n                    startLine === undefined &&\n                    branchMeta[branchName].type === 'if'\n                ) {\n                    const prevMeta = metaArray[i - 1];\n                    startCol = prevMeta.start.column;\n                    endCol = prevMeta.end.column + 1;\n                    startLine = prevMeta.start.line;\n                    endLine = prevMeta.end.line;\n                }\n\n                if (count === 0 && structuredText[startLine]) {\n                    //skip branches taken\n                    if (endLine !== startLine) {\n                        endCol = structuredText[\n                            startLine\n                        ].text.originalLength();\n                    }\n                    text = structuredText[startLine].text;\n                    if (branchMeta[branchName].type === 'if') {\n                        // 'if' is a special case\n                        // since the else branch might not be visible, being non-existent\n                        text.insertAt(\n                            startCol,\n                            lt +\n                                'span class=\"' +\n                                (meta.skip\n                                    ? 'skip-if-branch'\n                                    : 'missing-if-branch') +\n                                '\"' +\n                                title(\n                                    (i === 0 ? 'if' : 'else') +\n                                        ' path not taken'\n                                ) +\n                                gt +\n                                (i === 0 ? 'I' : 'E') +\n                                lt +\n                                '/span' +\n                                gt,\n                            true,\n                            false\n                        );\n                    } else {\n                        text.wrap(\n                            startCol,\n                            openSpan,\n                            startCol < endCol ? endCol : text.originalLength(),\n                            closeSpan\n                        );\n                    }\n                }\n            }\n        }\n    });\n}\n\nfunction annotateSourceCode(fileCoverage, sourceStore) {\n    let codeArray;\n    let lineCoverageArray;\n    try {\n        const sourceText = sourceStore.getSource(fileCoverage.path);\n        const code = sourceText.split(/(?:\\r?\\n)|\\r/);\n        let count = 0;\n        const structured = code.map(str => {\n            count += 1;\n            return {\n                line: count,\n                covered: 'neutral',\n                hits: 0,\n                text: new InsertionText(str, true)\n            };\n        });\n        structured.unshift({\n            line: 0,\n            covered: null,\n            text: new InsertionText('')\n        });\n        annotateLines(fileCoverage, structured);\n        //note: order is important, since statements typically result in spanning the whole line and doing branches late\n        //causes mismatched tags\n        annotateBranches(fileCoverage, structured);\n        annotateFunctions(fileCoverage, structured);\n        annotateStatements(fileCoverage, structured);\n        structured.shift();\n\n        codeArray = structured.map(\n            item => customEscape(item.text.toString()) || '&nbsp;'\n        );\n\n        lineCoverageArray = structured.map(item => ({\n            covered: item.covered,\n            hits: item.hits > 0 ? item.hits + 'x' : '&nbsp;'\n        }));\n\n        return {\n            annotatedCode: codeArray,\n            lineCoverage: lineCoverageArray,\n            maxLines: structured.length\n        };\n    } catch (ex) {\n        codeArray = [ex.message];\n        lineCoverageArray = [{ covered: 'no', hits: 0 }];\n        String(ex.stack || '')\n            .split(/\\r?\\n/)\n            .forEach(line => {\n                codeArray.push(line);\n                lineCoverageArray.push({ covered: 'no', hits: 0 });\n            });\n        return {\n            annotatedCode: codeArray,\n            lineCoverage: lineCoverageArray,\n            maxLines: codeArray.length\n        };\n    }\n}\n\nmodule.exports = annotateSourceCode;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,aAAa,GAAGC,OAAO,CAAC,kBAAD,CAA7B;;AACA,MAAMC,EAAE,GAAG,QAAX;AACA,MAAMC,EAAE,GAAG,QAAX;AACA,MAAMC,KAAK,GAAG,IAAd;AACA,MAAMC,KAAK,GAAG,IAAd;AACA,MAAMC,MAAM,GAAG,IAAf,C,CACA;;AACA,IAAIC,KAAK,GAAG,SAAZ,C,CACA;;AACA,IAAIC,KAAK,GAAG,SAAZ;;AAEA,SAASC,KAAT,CAAeC,GAAf,EAAoB;EAChB,OAAO,aAAaA,GAAb,GAAmB,IAA1B;AACH;;AAED,SAASC,YAAT,CAAsBC,IAAtB,EAA4B;EACxBA,IAAI,GAAGC,MAAM,CAACD,IAAD,CAAb;EACA,OAAOA,IAAI,CACNE,OADE,CACMR,MADN,EACc,OADd,EAEFQ,OAFE,CAEMV,KAFN,EAEa,MAFb,EAGFU,OAHE,CAGMT,KAHN,EAGa,MAHb,EAIFS,OAJE,CAIMP,KAJN,EAIa,GAJb,EAKFO,OALE,CAKMN,KALN,EAKa,GALb,CAAP;AAMH;;AAED,SAASO,aAAT,CAAuBC,YAAvB,EAAqCC,cAArC,EAAqD;EACjD,MAAMC,SAAS,GAAGF,YAAY,CAACG,eAAb,EAAlB;;EACA,IAAI,CAACD,SAAL,EAAgB;IACZ;EACH;;EACDE,MAAM,CAACC,OAAP,CAAeH,SAAf,EAA0BI,OAA1B,CAAkC,QAAyB;IAAA,IAAxB,CAACC,UAAD,EAAaC,KAAb,CAAwB;;IACvD,IAAIP,cAAc,CAACM,UAAD,CAAlB,EAAgC;MAC5BN,cAAc,CAACM,UAAD,CAAd,CAA2BE,OAA3B,GAAqCD,KAAK,GAAG,CAAR,GAAY,KAAZ,GAAoB,IAAzD;MACAP,cAAc,CAACM,UAAD,CAAd,CAA2BG,IAA3B,GAAkCF,KAAlC;IACH;EACJ,CALD;AAMH;;AAED,SAASG,kBAAT,CAA4BX,YAA5B,EAA0CC,cAA1C,EAA0D;EACtD,MAAMW,cAAc,GAAGZ,YAAY,CAACa,CAApC;EACA,MAAMC,aAAa,GAAGd,YAAY,CAACe,YAAnC;EACAX,MAAM,CAACC,OAAP,CAAeO,cAAf,EAA+BN,OAA/B,CAAuC,SAAqB;IAAA,IAApB,CAACU,MAAD,EAASR,KAAT,CAAoB;IACxD,MAAMS,IAAI,GAAGH,aAAa,CAACE,MAAD,CAA1B;IACA,MAAME,IAAI,GAAGV,KAAK,GAAG,CAAR,GAAY,KAAZ,GAAoB,IAAjC;IACA,MAAMW,QAAQ,GAAGF,IAAI,CAACG,KAAL,CAAWC,MAA5B;IACA,IAAIC,MAAM,GAAGL,IAAI,CAACM,GAAL,CAASF,MAAT,GAAkB,CAA/B;IACA,MAAMG,SAAS,GAAGP,IAAI,CAACG,KAAL,CAAWK,IAA7B;IACA,MAAMC,OAAO,GAAGT,IAAI,CAACM,GAAL,CAASE,IAAzB;IACA,MAAME,QAAQ,GACVzC,EAAE,GACF,cADA,IAEC+B,IAAI,CAACW,IAAL,GAAY,YAAZ,GAA2B,UAF5B,IAGA,GAHA,GAIAnC,KAAK,CAAC,uBAAD,CAJL,GAKAN,EANJ;IAOA,MAAM0C,SAAS,GAAG3C,EAAE,GAAG,OAAL,GAAeC,EAAjC;IACA,IAAIS,IAAJ;;IAEA,IAAIsB,IAAI,KAAK,IAAT,IAAiBjB,cAAc,CAACuB,SAAD,CAAnC,EAAgD;MAC5C,IAAIE,OAAO,KAAKF,SAAhB,EAA2B;QACvBF,MAAM,GAAGrB,cAAc,CAACuB,SAAD,CAAd,CAA0B5B,IAA1B,CAA+BkC,cAA/B,EAAT;MACH;;MACDlC,IAAI,GAAGK,cAAc,CAACuB,SAAD,CAAd,CAA0B5B,IAAjC;MACAA,IAAI,CAACmC,IAAL,CACIZ,QADJ,EAEIQ,QAFJ,EAGIR,QAAQ,GAAGG,MAAX,GAAoBA,MAApB,GAA6B1B,IAAI,CAACkC,cAAL,EAHjC,EAIID,SAJJ;IAMH;EACJ,CA7BD;AA8BH;;AAED,SAASG,iBAAT,CAA2BhC,YAA3B,EAAyCC,cAAzC,EAAyD;EACrD,MAAMgC,OAAO,GAAGjC,YAAY,CAACkC,CAA7B;EACA,MAAMC,MAAM,GAAGnC,YAAY,CAACoC,KAA5B;;EACA,IAAI,CAACH,OAAL,EAAc;IACV;EACH;;EACD7B,MAAM,CAACC,OAAP,CAAe4B,OAAf,EAAwB3B,OAAxB,CAAgC,SAAoB;IAAA,IAAnB,CAAC+B,KAAD,EAAQ7B,KAAR,CAAmB;IAChD,MAAMS,IAAI,GAAGkB,MAAM,CAACE,KAAD,CAAnB;IACA,MAAMnB,IAAI,GAAGV,KAAK,GAAG,CAAR,GAAY,KAAZ,GAAoB,IAAjC,CAFgD,CAGhD;IACA;;IACA,MAAM8B,IAAI,GAAGrB,IAAI,CAACqB,IAAL,IAAarB,IAAI,CAACsB,GAA/B;IACA,MAAMpB,QAAQ,GAAGmB,IAAI,CAAClB,KAAL,CAAWC,MAA5B;IACA,IAAIC,MAAM,GAAGgB,IAAI,CAACf,GAAL,CAASF,MAAT,GAAkB,CAA/B;IACA,MAAMG,SAAS,GAAGc,IAAI,CAAClB,KAAL,CAAWK,IAA7B;IACA,MAAMC,OAAO,GAAGY,IAAI,CAACf,GAAL,CAASE,IAAzB;IACA,MAAME,QAAQ,GACVzC,EAAE,GACF,cADA,IAEC+B,IAAI,CAACW,IAAL,GAAY,YAAZ,GAA2B,UAF5B,IAGA,GAHA,GAIAnC,KAAK,CAAC,sBAAD,CAJL,GAKAN,EANJ;IAOA,MAAM0C,SAAS,GAAG3C,EAAE,GAAG,OAAL,GAAeC,EAAjC;IACA,IAAIS,IAAJ;;IAEA,IAAIsB,IAAI,KAAK,IAAT,IAAiBjB,cAAc,CAACuB,SAAD,CAAnC,EAAgD;MAC5C,IAAIE,OAAO,KAAKF,SAAhB,EAA2B;QACvBF,MAAM,GAAGrB,cAAc,CAACuB,SAAD,CAAd,CAA0B5B,IAA1B,CAA+BkC,cAA/B,EAAT;MACH;;MACDlC,IAAI,GAAGK,cAAc,CAACuB,SAAD,CAAd,CAA0B5B,IAAjC;MACAA,IAAI,CAACmC,IAAL,CACIZ,QADJ,EAEIQ,QAFJ,EAGIR,QAAQ,GAAGG,MAAX,GAAoBA,MAApB,GAA6B1B,IAAI,CAACkC,cAAL,EAHjC,EAIID,SAJJ;IAMH;EACJ,CAhCD;AAiCH;;AAED,SAASW,gBAAT,CAA0BxC,YAA1B,EAAwCC,cAAxC,EAAwD;EACpD,MAAMwC,WAAW,GAAGzC,YAAY,CAAC0C,CAAjC;EACA,MAAMC,UAAU,GAAG3C,YAAY,CAAC4C,SAAhC;;EACA,IAAI,CAACH,WAAL,EAAkB;IACd;EACH;;EAEDrC,MAAM,CAACC,OAAP,CAAeoC,WAAf,EAA4BnC,OAA5B,CAAoC,SAA+B;IAAA,IAA9B,CAACuC,UAAD,EAAaC,WAAb,CAA8B;IAC/D,MAAMC,QAAQ,GAAGD,WAAW,CAACE,MAAZ,CAAmB,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAjC,EAAoC,CAApC,CAAjB;IACA,MAAMC,SAAS,GAAGR,UAAU,CAACE,UAAD,CAAV,CAAuBO,SAAzC;IACA,IAAIC,CAAJ;IACA,IAAI7C,KAAJ;IACA,IAAIS,IAAJ;IACA,IAAIE,QAAJ;IACA,IAAIG,MAAJ;IACA,IAAIE,SAAJ;IACA,IAAIE,OAAJ;IACA,IAAIC,QAAJ;IACA,IAAIE,SAAJ;IACA,IAAIjC,IAAJ,CAZ+D,CAc/D;IACA;;IACA,IAAImD,QAAQ,GAAG,CAAX,IAAiBA,QAAQ,KAAK,CAAb,IAAkBD,WAAW,CAACQ,MAAZ,KAAuB,CAA9D,EAAkE;MAC9D;MACA,KACI;MACAX,UAAU,CAACE,UAAD,CAAV,CAAuB3B,IAAvB,KAAgC,IAAhC,IACA;MACA4B,WAAW,CAACQ,MAAZ,KAAuB,CAFvB,IAGA;MACAH,SAAS,CAACG,MAAV,KAAqB,CAJrB,IAKA;MACAR,WAAW,CAAC,CAAD,CAAX,KAAmB,CARvB,EASE;QACEK,SAAS,CAAC,CAAD,CAAT,GAAe;UACX/B,KAAK,EAAE,EADI;UAEXG,GAAG,EAAE;QAFM,CAAf;MAIH;;MAED,KACI8B,CAAC,GAAG,CADR,EAEIA,CAAC,GAAGP,WAAW,CAACQ,MAAhB,IAA0BD,CAAC,GAAGF,SAAS,CAACG,MAF5C,EAGID,CAAC,IAAI,CAHT,EAIE;QACE7C,KAAK,GAAGsC,WAAW,CAACO,CAAD,CAAnB;QACApC,IAAI,GAAGkC,SAAS,CAACE,CAAD,CAAhB;QACAlC,QAAQ,GAAGF,IAAI,CAACG,KAAL,CAAWC,MAAtB;QACAC,MAAM,GAAGL,IAAI,CAACM,GAAL,CAASF,MAAT,GAAkB,CAA3B;QACAG,SAAS,GAAGP,IAAI,CAACG,KAAL,CAAWK,IAAvB;QACAC,OAAO,GAAGT,IAAI,CAACM,GAAL,CAASE,IAAnB;QACAE,QAAQ,GACJzC,EAAE,GACF,qBADA,GAEAmE,CAFA,GAGA,GAHA,IAICpC,IAAI,CAACW,IAAL,GAAY,cAAZ,GAA6B,YAJ9B,IAKA,GALA,GAMAnC,KAAK,CAAC,oBAAD,CANL,GAOAN,EARJ;QASA0C,SAAS,GAAG3C,EAAE,GAAG,OAAL,GAAeC,EAA3B,CAhBF,CAkBE;QACA;QACA;QACA;;QACA,IACIqB,KAAK,KAAK,CAAV,IACAgB,SAAS,KAAK+B,SADd,IAEAZ,UAAU,CAACE,UAAD,CAAV,CAAuB3B,IAAvB,KAAgC,IAHpC,EAIE;UACE,MAAMsC,QAAQ,GAAGL,SAAS,CAACE,CAAC,GAAG,CAAL,CAA1B;UACAlC,QAAQ,GAAGqC,QAAQ,CAACpC,KAAT,CAAeC,MAA1B;UACAC,MAAM,GAAGkC,QAAQ,CAACjC,GAAT,CAAaF,MAAb,GAAsB,CAA/B;UACAG,SAAS,GAAGgC,QAAQ,CAACpC,KAAT,CAAeK,IAA3B;UACAC,OAAO,GAAG8B,QAAQ,CAACjC,GAAT,CAAaE,IAAvB;QACH;;QAED,IAAIjB,KAAK,KAAK,CAAV,IAAeP,cAAc,CAACuB,SAAD,CAAjC,EAA8C;UAC1C;UACA,IAAIE,OAAO,KAAKF,SAAhB,EAA2B;YACvBF,MAAM,GAAGrB,cAAc,CACnBuB,SADmB,CAAd,CAEP5B,IAFO,CAEFkC,cAFE,EAAT;UAGH;;UACDlC,IAAI,GAAGK,cAAc,CAACuB,SAAD,CAAd,CAA0B5B,IAAjC;;UACA,IAAI+C,UAAU,CAACE,UAAD,CAAV,CAAuB3B,IAAvB,KAAgC,IAApC,EAA0C;YACtC;YACA;YACAtB,IAAI,CAAC6D,QAAL,CACItC,QADJ,EAEIjC,EAAE,GACE,cADJ,IAEK+B,IAAI,CAACW,IAAL,GACK,gBADL,GAEK,mBAJV,IAKI,GALJ,GAMInC,KAAK,CACD,CAAC4D,CAAC,KAAK,CAAN,GAAU,IAAV,GAAiB,MAAlB,IACI,iBAFH,CANT,GAUIlE,EAVJ,IAWKkE,CAAC,KAAK,CAAN,GAAU,GAAV,GAAgB,GAXrB,IAYInE,EAZJ,GAaI,OAbJ,GAcIC,EAhBR,EAiBI,IAjBJ,EAkBI,KAlBJ;UAoBH,CAvBD,MAuBO;YACHS,IAAI,CAACmC,IAAL,CACIZ,QADJ,EAEIQ,QAFJ,EAGIR,QAAQ,GAAGG,MAAX,GAAoBA,MAApB,GAA6B1B,IAAI,CAACkC,cAAL,EAHjC,EAIID,SAJJ;UAMH;QACJ;MACJ;IACJ;EACJ,CAlHD;AAmHH;;AAED,SAAS6B,kBAAT,CAA4B1D,YAA5B,EAA0C2D,WAA1C,EAAuD;EACnD,IAAIC,SAAJ;EACA,IAAIC,iBAAJ;;EACA,IAAI;IACA,MAAMC,UAAU,GAAGH,WAAW,CAACI,SAAZ,CAAsB/D,YAAY,CAACgE,IAAnC,CAAnB;IACA,MAAMC,IAAI,GAAGH,UAAU,CAACI,KAAX,CAAiB,cAAjB,CAAb;IACA,IAAI1D,KAAK,GAAG,CAAZ;IACA,MAAM2D,UAAU,GAAGF,IAAI,CAACG,GAAL,CAAS1E,GAAG,IAAI;MAC/Bc,KAAK,IAAI,CAAT;MACA,OAAO;QACHiB,IAAI,EAAEjB,KADH;QAEHC,OAAO,EAAE,SAFN;QAGHC,IAAI,EAAE,CAHH;QAIHd,IAAI,EAAE,IAAIZ,aAAJ,CAAkBU,GAAlB,EAAuB,IAAvB;MAJH,CAAP;IAMH,CARkB,CAAnB;IASAyE,UAAU,CAACE,OAAX,CAAmB;MACf5C,IAAI,EAAE,CADS;MAEfhB,OAAO,EAAE,IAFM;MAGfb,IAAI,EAAE,IAAIZ,aAAJ,CAAkB,EAAlB;IAHS,CAAnB;IAKAe,aAAa,CAACC,YAAD,EAAemE,UAAf,CAAb,CAlBA,CAmBA;IACA;;IACA3B,gBAAgB,CAACxC,YAAD,EAAemE,UAAf,CAAhB;IACAnC,iBAAiB,CAAChC,YAAD,EAAemE,UAAf,CAAjB;IACAxD,kBAAkB,CAACX,YAAD,EAAemE,UAAf,CAAlB;IACAA,UAAU,CAACG,KAAX;IAEAV,SAAS,GAAGO,UAAU,CAACC,GAAX,CACRG,IAAI,IAAI5E,YAAY,CAAC4E,IAAI,CAAC3E,IAAL,CAAU4E,QAAV,EAAD,CAAZ,IAAsC,QADtC,CAAZ;IAIAX,iBAAiB,GAAGM,UAAU,CAACC,GAAX,CAAeG,IAAI,KAAK;MACxC9D,OAAO,EAAE8D,IAAI,CAAC9D,OAD0B;MAExCC,IAAI,EAAE6D,IAAI,CAAC7D,IAAL,GAAY,CAAZ,GAAgB6D,IAAI,CAAC7D,IAAL,GAAY,GAA5B,GAAkC;IAFA,CAAL,CAAnB,CAApB;IAKA,OAAO;MACH+D,aAAa,EAAEb,SADZ;MAEHc,YAAY,EAAEb,iBAFX;MAGHc,QAAQ,EAAER,UAAU,CAACb;IAHlB,CAAP;EAKH,CAxCD,CAwCE,OAAOsB,EAAP,EAAW;IACThB,SAAS,GAAG,CAACgB,EAAE,CAACC,OAAJ,CAAZ;IACAhB,iBAAiB,GAAG,CAAC;MAAEpD,OAAO,EAAE,IAAX;MAAiBC,IAAI,EAAE;IAAvB,CAAD,CAApB;IACAb,MAAM,CAAC+E,EAAE,CAACE,KAAH,IAAY,EAAb,CAAN,CACKZ,KADL,CACW,OADX,EAEK5D,OAFL,CAEamB,IAAI,IAAI;MACbmC,SAAS,CAACmB,IAAV,CAAetD,IAAf;MACAoC,iBAAiB,CAACkB,IAAlB,CAAuB;QAAEtE,OAAO,EAAE,IAAX;QAAiBC,IAAI,EAAE;MAAvB,CAAvB;IACH,CALL;IAMA,OAAO;MACH+D,aAAa,EAAEb,SADZ;MAEHc,YAAY,EAAEb,iBAFX;MAGHc,QAAQ,EAAEf,SAAS,CAACN;IAHjB,CAAP;EAKH;AACJ;;AAED0B,MAAM,CAACC,OAAP,GAAiBvB,kBAAjB"},"metadata":{},"sourceType":"script"}