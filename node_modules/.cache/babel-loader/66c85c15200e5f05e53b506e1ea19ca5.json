{"ast":null,"code":"const {\n  promises: fsPromises\n} = require('fs');\n\nconst path = require('path');\n\nconst commonPathPrefix = require('common-path-prefix');\n\nconst findUp = require('find-up');\n/** @type {string | undefined} */\n\n\nlet packageJsonType;\n/**\n * Infers the current active module system from loader context and options.\n * @this {import('webpack').loader.LoaderContext}\n * @param {import('webpack').ModuleFilenameHelpers} ModuleFilenameHelpers Webpack's module filename helpers.\n * @param {import('../types').NormalizedLoaderOptions} options The normalized loader options.\n * @return {Promise<'esm' | 'cjs'>} The inferred module system.\n */\n\nasync function getModuleSystem(ModuleFilenameHelpers, options) {\n  // Check loader options -\n  // if `esModule` is set we don't have to do extra guess work.\n  switch (typeof options.esModule) {\n    case 'boolean':\n      {\n        return options.esModule ? 'esm' : 'cjs';\n      }\n\n    case 'object':\n      {\n        if (options.esModule.include && ModuleFilenameHelpers.matchPart(this.resourcePath, options.esModule.include)) {\n          return 'esm';\n        }\n\n        if (options.esModule.exclude && ModuleFilenameHelpers.matchPart(this.resourcePath, options.esModule.exclude)) {\n          return 'cjs';\n        }\n\n        break;\n      }\n\n    default: // Do nothing\n\n  } // Check current resource's extension\n\n\n  if (/\\.mjs$/.test(this.resourcePath)) return 'esm';\n  if (/\\.cjs$/.test(this.resourcePath)) return 'cjs'; // Load users' `package.json` -\n  // We will cache the results in a global variable so it will only be parsed once.\n\n  if (!packageJsonType) {\n    try {\n      const commonPath = commonPathPrefix([this.rootContext, this.resourcePath], '/');\n      const stopPath = path.resolve(commonPath, '..');\n      const packageJsonPath = await findUp(dir => {\n        if (dir === stopPath) return findUp.stop;\n        return 'package.json';\n      }, {\n        cwd: path.dirname(this.resourcePath)\n      });\n      const buffer = await fsPromises.readFile(packageJsonPath, {\n        encoding: 'utf-8'\n      });\n      const rawPackageJson = buffer.toString('utf-8');\n      ({\n        type: packageJsonType\n      } = JSON.parse(rawPackageJson));\n    } catch (e) {// Failed to parse `package.json`, do nothing.\n    }\n  } // Check `package.json` for the `type` field -\n  // fallback to use `cjs` for anything ambiguous.\n\n\n  return packageJsonType === 'module' ? 'esm' : 'cjs';\n}\n\nmodule.exports = getModuleSystem;","map":{"version":3,"names":["promises","fsPromises","require","path","commonPathPrefix","findUp","packageJsonType","getModuleSystem","ModuleFilenameHelpers","options","esModule","include","matchPart","resourcePath","exclude","test","commonPath","rootContext","stopPath","resolve","packageJsonPath","dir","stop","cwd","dirname","buffer","readFile","encoding","rawPackageJson","toString","type","JSON","parse","e","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@pmmmwh/react-refresh-webpack-plugin/loader/utils/getModuleSystem.js"],"sourcesContent":["const { promises: fsPromises } = require('fs');\nconst path = require('path');\nconst commonPathPrefix = require('common-path-prefix');\nconst findUp = require('find-up');\n\n/** @type {string | undefined} */\nlet packageJsonType;\n\n/**\n * Infers the current active module system from loader context and options.\n * @this {import('webpack').loader.LoaderContext}\n * @param {import('webpack').ModuleFilenameHelpers} ModuleFilenameHelpers Webpack's module filename helpers.\n * @param {import('../types').NormalizedLoaderOptions} options The normalized loader options.\n * @return {Promise<'esm' | 'cjs'>} The inferred module system.\n */\nasync function getModuleSystem(ModuleFilenameHelpers, options) {\n  // Check loader options -\n  // if `esModule` is set we don't have to do extra guess work.\n  switch (typeof options.esModule) {\n    case 'boolean': {\n      return options.esModule ? 'esm' : 'cjs';\n    }\n    case 'object': {\n      if (\n        options.esModule.include &&\n        ModuleFilenameHelpers.matchPart(this.resourcePath, options.esModule.include)\n      ) {\n        return 'esm';\n      }\n      if (\n        options.esModule.exclude &&\n        ModuleFilenameHelpers.matchPart(this.resourcePath, options.esModule.exclude)\n      ) {\n        return 'cjs';\n      }\n\n      break;\n    }\n    default: // Do nothing\n  }\n\n  // Check current resource's extension\n  if (/\\.mjs$/.test(this.resourcePath)) return 'esm';\n  if (/\\.cjs$/.test(this.resourcePath)) return 'cjs';\n\n  // Load users' `package.json` -\n  // We will cache the results in a global variable so it will only be parsed once.\n  if (!packageJsonType) {\n    try {\n      const commonPath = commonPathPrefix([this.rootContext, this.resourcePath], '/');\n      const stopPath = path.resolve(commonPath, '..');\n\n      const packageJsonPath = await findUp(\n        (dir) => {\n          if (dir === stopPath) return findUp.stop;\n          return 'package.json';\n        },\n        { cwd: path.dirname(this.resourcePath) }\n      );\n\n      const buffer = await fsPromises.readFile(packageJsonPath, { encoding: 'utf-8' });\n      const rawPackageJson = buffer.toString('utf-8');\n      ({ type: packageJsonType } = JSON.parse(rawPackageJson));\n    } catch (e) {\n      // Failed to parse `package.json`, do nothing.\n    }\n  }\n\n  // Check `package.json` for the `type` field -\n  // fallback to use `cjs` for anything ambiguous.\n  return packageJsonType === 'module' ? 'esm' : 'cjs';\n}\n\nmodule.exports = getModuleSystem;\n"],"mappings":"AAAA,MAAM;EAAEA,QAAQ,EAAEC;AAAZ,IAA2BC,OAAO,CAAC,IAAD,CAAxC;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,gBAAgB,GAAGF,OAAO,CAAC,oBAAD,CAAhC;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,SAAD,CAAtB;AAEA;;;AACA,IAAII,eAAJ;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAeC,eAAf,CAA+BC,qBAA/B,EAAsDC,OAAtD,EAA+D;EAC7D;EACA;EACA,QAAQ,OAAOA,OAAO,CAACC,QAAvB;IACE,KAAK,SAAL;MAAgB;QACd,OAAOD,OAAO,CAACC,QAAR,GAAmB,KAAnB,GAA2B,KAAlC;MACD;;IACD,KAAK,QAAL;MAAe;QACb,IACED,OAAO,CAACC,QAAR,CAAiBC,OAAjB,IACAH,qBAAqB,CAACI,SAAtB,CAAgC,KAAKC,YAArC,EAAmDJ,OAAO,CAACC,QAAR,CAAiBC,OAApE,CAFF,EAGE;UACA,OAAO,KAAP;QACD;;QACD,IACEF,OAAO,CAACC,QAAR,CAAiBI,OAAjB,IACAN,qBAAqB,CAACI,SAAtB,CAAgC,KAAKC,YAArC,EAAmDJ,OAAO,CAACC,QAAR,CAAiBI,OAApE,CAFF,EAGE;UACA,OAAO,KAAP;QACD;;QAED;MACD;;IACD,QApBF,CAoBW;;EApBX,CAH6D,CA0B7D;;;EACA,IAAI,SAASC,IAAT,CAAc,KAAKF,YAAnB,CAAJ,EAAsC,OAAO,KAAP;EACtC,IAAI,SAASE,IAAT,CAAc,KAAKF,YAAnB,CAAJ,EAAsC,OAAO,KAAP,CA5BuB,CA8B7D;EACA;;EACA,IAAI,CAACP,eAAL,EAAsB;IACpB,IAAI;MACF,MAAMU,UAAU,GAAGZ,gBAAgB,CAAC,CAAC,KAAKa,WAAN,EAAmB,KAAKJ,YAAxB,CAAD,EAAwC,GAAxC,CAAnC;MACA,MAAMK,QAAQ,GAAGf,IAAI,CAACgB,OAAL,CAAaH,UAAb,EAAyB,IAAzB,CAAjB;MAEA,MAAMI,eAAe,GAAG,MAAMf,MAAM,CACjCgB,GAAD,IAAS;QACP,IAAIA,GAAG,KAAKH,QAAZ,EAAsB,OAAOb,MAAM,CAACiB,IAAd;QACtB,OAAO,cAAP;MACD,CAJiC,EAKlC;QAAEC,GAAG,EAAEpB,IAAI,CAACqB,OAAL,CAAa,KAAKX,YAAlB;MAAP,CALkC,CAApC;MAQA,MAAMY,MAAM,GAAG,MAAMxB,UAAU,CAACyB,QAAX,CAAoBN,eAApB,EAAqC;QAAEO,QAAQ,EAAE;MAAZ,CAArC,CAArB;MACA,MAAMC,cAAc,GAAGH,MAAM,CAACI,QAAP,CAAgB,OAAhB,CAAvB;MACA,CAAC;QAAEC,IAAI,EAAExB;MAAR,IAA4ByB,IAAI,CAACC,KAAL,CAAWJ,cAAX,CAA7B;IACD,CAfD,CAeE,OAAOK,CAAP,EAAU,CACV;IACD;EACF,CAnD4D,CAqD7D;EACA;;;EACA,OAAO3B,eAAe,KAAK,QAApB,GAA+B,KAA/B,GAAuC,KAA9C;AACD;;AAED4B,MAAM,CAACC,OAAP,GAAiB5B,eAAjB"},"metadata":{},"sourceType":"script"}