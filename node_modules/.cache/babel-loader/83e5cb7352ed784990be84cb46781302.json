{"ast":null,"code":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _ExportMap = require('../ExportMap');\n\nvar _ExportMap2 = _interopRequireDefault(_ExportMap);\n\nvar _ignore = require('eslint-module-utils/ignore');\n\nvar _resolve = require('eslint-module-utils/resolve');\n\nvar _resolve2 = _interopRequireDefault(_resolve);\n\nvar _visit = require('eslint-module-utils/visit');\n\nvar _visit2 = _interopRequireDefault(_visit);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nvar _path = require('path');\n\nvar _readPkgUp2 = require('eslint-module-utils/readPkgUp');\n\nvar _readPkgUp3 = _interopRequireDefault(_readPkgUp2);\n\nvar _object = require('object.values');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _arrayIncludes = require('array-includes');\n\nvar _arrayIncludes2 = _interopRequireDefault(_arrayIncludes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\n * @fileOverview Ensures that modules contain exports and/or all\n * modules are consumed within other modules.\n * @author RenÃ© Fermann\n */\n\n\nvar FileEnumerator = void 0;\nvar listFilesToProcess = void 0;\n\ntry {\n  var _require = require('eslint/use-at-your-own-risk');\n\n  FileEnumerator = _require.FileEnumerator;\n} catch (e) {\n  try {\n    var _require2 = require('eslint/lib/cli-engine/file-enumerator'); // has been moved to eslint/lib/cli-engine/file-enumerator in version 6\n\n\n    FileEnumerator = _require2.FileEnumerator;\n  } catch (e) {\n    try {\n      // eslint/lib/util/glob-util has been moved to eslint/lib/util/glob-utils with version 5.3\n      var _require3 = require('eslint/lib/util/glob-utils'),\n          originalListFilesToProcess = _require3.listFilesToProcess; // Prevent passing invalid options (extensions array) to old versions of the function.\n      // https://github.com/eslint/eslint/blob/v5.16.0/lib/util/glob-utils.js#L178-L280\n      // https://github.com/eslint/eslint/blob/v5.2.0/lib/util/glob-util.js#L174-L269\n\n\n      listFilesToProcess = function listFilesToProcess(src, extensions) {\n        return originalListFilesToProcess(src, {\n          extensions: extensions\n        });\n      };\n    } catch (e) {\n      var _require4 = require('eslint/lib/util/glob-util'),\n          _originalListFilesToProcess = _require4.listFilesToProcess;\n\n      listFilesToProcess = function listFilesToProcess(src, extensions) {\n        var patterns = src.reduce(function (carry, pattern) {\n          return carry.concat(extensions.map(function (extension) {\n            return /\\*\\*|\\*\\./.test(pattern) ? pattern : String(pattern) + '/**/*' + String(extension);\n          }));\n        }, src.slice());\n        return _originalListFilesToProcess(patterns);\n      };\n    }\n  }\n}\n\nif (FileEnumerator) {\n  listFilesToProcess = function listFilesToProcess(src, extensions) {\n    var e = new FileEnumerator({\n      extensions: extensions\n    });\n    return Array.from(e.iterateFiles(src), function (_ref) {\n      var filePath = _ref.filePath,\n          ignored = _ref.ignored;\n      return {\n        ignored: ignored,\n        filename: filePath\n      };\n    });\n  };\n}\n\nvar EXPORT_DEFAULT_DECLARATION = 'ExportDefaultDeclaration';\nvar EXPORT_NAMED_DECLARATION = 'ExportNamedDeclaration';\nvar EXPORT_ALL_DECLARATION = 'ExportAllDeclaration';\nvar IMPORT_DECLARATION = 'ImportDeclaration';\nvar IMPORT_NAMESPACE_SPECIFIER = 'ImportNamespaceSpecifier';\nvar IMPORT_DEFAULT_SPECIFIER = 'ImportDefaultSpecifier';\nvar VARIABLE_DECLARATION = 'VariableDeclaration';\nvar FUNCTION_DECLARATION = 'FunctionDeclaration';\nvar CLASS_DECLARATION = 'ClassDeclaration';\nvar IDENTIFIER = 'Identifier';\nvar OBJECT_PATTERN = 'ObjectPattern';\nvar TS_INTERFACE_DECLARATION = 'TSInterfaceDeclaration';\nvar TS_TYPE_ALIAS_DECLARATION = 'TSTypeAliasDeclaration';\nvar TS_ENUM_DECLARATION = 'TSEnumDeclaration';\nvar DEFAULT = 'default';\n\nfunction forEachDeclarationIdentifier(declaration, cb) {\n  if (declaration) {\n    if (declaration.type === FUNCTION_DECLARATION || declaration.type === CLASS_DECLARATION || declaration.type === TS_INTERFACE_DECLARATION || declaration.type === TS_TYPE_ALIAS_DECLARATION || declaration.type === TS_ENUM_DECLARATION) {\n      cb(declaration.id.name);\n    } else if (declaration.type === VARIABLE_DECLARATION) {\n      declaration.declarations.forEach(function (_ref2) {\n        var id = _ref2.id;\n\n        if (id.type === OBJECT_PATTERN) {\n          (0, _ExportMap.recursivePatternCapture)(id, function (pattern) {\n            if (pattern.type === IDENTIFIER) {\n              cb(pattern.name);\n            }\n          });\n        } else {\n          cb(id.name);\n        }\n      });\n    }\n  }\n}\n/**\n   * List of imports per file.\n   *\n   * Represented by a two-level Map to a Set of identifiers. The upper-level Map\n   * keys are the paths to the modules containing the imports, while the\n   * lower-level Map keys are the paths to the files which are being imported\n   * from. Lastly, the Set of identifiers contains either names being imported\n   * or a special AST node name listed above (e.g ImportDefaultSpecifier).\n   *\n   * For example, if we have a file named foo.js containing:\n   *\n   *   import { o2 } from './bar.js';\n   *\n   * Then we will have a structure that looks like:\n   *\n   *   Map { 'foo.js' => Map { 'bar.js' => Set { 'o2' } } }\n   *\n   * @type {Map<string, Map<string, Set<string>>>}\n   */\n\n\nvar importList = new Map();\n/**\n                             * List of exports per file.\n                             *\n                             * Represented by a two-level Map to an object of metadata. The upper-level Map\n                             * keys are the paths to the modules containing the exports, while the\n                             * lower-level Map keys are the specific identifiers or special AST node names\n                             * being exported. The leaf-level metadata object at the moment only contains a\n                             * `whereUsed` property, which contains a Set of paths to modules that import\n                             * the name.\n                             *\n                             * For example, if we have a file named bar.js containing the following exports:\n                             *\n                             *   const o2 = 'bar';\n                             *   export { o2 };\n                             *\n                             * And a file named foo.js containing the following import:\n                             *\n                             *   import { o2 } from './bar.js';\n                             *\n                             * Then we will have a structure that looks like:\n                             *\n                             *   Map { 'bar.js' => Map { 'o2' => { whereUsed: Set { 'foo.js' } } } }\n                             *\n                             * @type {Map<string, Map<string, object>>}\n                             */\n\nvar exportList = new Map();\nvar visitorKeyMap = new Map();\nvar ignoredFiles = new Set();\nvar filesOutsideSrc = new Set();\n\nvar isNodeModule = function isNodeModule(path) {\n  return /\\/(node_modules)\\//.test(path);\n};\n/**\n    * read all files matching the patterns in src and ignoreExports\n    *\n    * return all files matching src pattern, which are not matching the ignoreExports pattern\n    */\n\n\nvar resolveFiles = function resolveFiles(src, ignoreExports, context) {\n  var extensions = Array.from((0, _ignore.getFileExtensions)(context.settings));\n  var srcFiles = new Set();\n  var srcFileList = listFilesToProcess(src, extensions); // prepare list of ignored files\n\n  var ignoredFilesList = listFilesToProcess(ignoreExports, extensions);\n  ignoredFilesList.forEach(function (_ref3) {\n    var filename = _ref3.filename;\n    return ignoredFiles.add(filename);\n  }); // prepare list of source files, don't consider files from node_modules\n\n  srcFileList.filter(function (_ref4) {\n    var filename = _ref4.filename;\n    return !isNodeModule(filename);\n  }).forEach(function (_ref5) {\n    var filename = _ref5.filename;\n    srcFiles.add(filename);\n  });\n  return srcFiles;\n};\n/**\n    * parse all source files and build up 2 maps containing the existing imports and exports\n    */\n\n\nvar prepareImportsAndExports = function prepareImportsAndExports(srcFiles, context) {\n  var exportAll = new Map();\n  srcFiles.forEach(function (file) {\n    var exports = new Map();\n    var imports = new Map();\n\n    var currentExports = _ExportMap2['default'].get(file, context);\n\n    if (currentExports) {\n      var dependencies = currentExports.dependencies,\n          reexports = currentExports.reexports,\n          localImportList = currentExports.imports,\n          namespace = currentExports.namespace,\n          visitorKeys = currentExports.visitorKeys;\n      visitorKeyMap.set(file, visitorKeys); // dependencies === export * from\n\n      var currentExportAll = new Set();\n      dependencies.forEach(function (getDependency) {\n        var dependency = getDependency();\n\n        if (dependency === null) {\n          return;\n        }\n\n        currentExportAll.add(dependency.path);\n      });\n      exportAll.set(file, currentExportAll);\n      reexports.forEach(function (value, key) {\n        if (key === DEFAULT) {\n          exports.set(IMPORT_DEFAULT_SPECIFIER, {\n            whereUsed: new Set()\n          });\n        } else {\n          exports.set(key, {\n            whereUsed: new Set()\n          });\n        }\n\n        var reexport = value.getImport();\n\n        if (!reexport) {\n          return;\n        }\n\n        var localImport = imports.get(reexport.path);\n        var currentValue = void 0;\n\n        if (value.local === DEFAULT) {\n          currentValue = IMPORT_DEFAULT_SPECIFIER;\n        } else {\n          currentValue = value.local;\n        }\n\n        if (typeof localImport !== 'undefined') {\n          localImport = new Set([].concat(_toConsumableArray(localImport), [currentValue]));\n        } else {\n          localImport = new Set([currentValue]);\n        }\n\n        imports.set(reexport.path, localImport);\n      });\n      localImportList.forEach(function (value, key) {\n        if (isNodeModule(key)) {\n          return;\n        }\n\n        var localImport = imports.get(key) || new Set();\n        value.declarations.forEach(function (_ref6) {\n          var importedSpecifiers = _ref6.importedSpecifiers;\n          return importedSpecifiers.forEach(function (specifier) {\n            return localImport.add(specifier);\n          });\n        });\n        imports.set(key, localImport);\n      });\n      importList.set(file, imports); // build up export list only, if file is not ignored\n\n      if (ignoredFiles.has(file)) {\n        return;\n      }\n\n      namespace.forEach(function (value, key) {\n        if (key === DEFAULT) {\n          exports.set(IMPORT_DEFAULT_SPECIFIER, {\n            whereUsed: new Set()\n          });\n        } else {\n          exports.set(key, {\n            whereUsed: new Set()\n          });\n        }\n      });\n    }\n\n    exports.set(EXPORT_ALL_DECLARATION, {\n      whereUsed: new Set()\n    });\n    exports.set(IMPORT_NAMESPACE_SPECIFIER, {\n      whereUsed: new Set()\n    });\n    exportList.set(file, exports);\n  });\n  exportAll.forEach(function (value, key) {\n    value.forEach(function (val) {\n      var currentExports = exportList.get(val);\n\n      if (currentExports) {\n        var currentExport = currentExports.get(EXPORT_ALL_DECLARATION);\n        currentExport.whereUsed.add(key);\n      }\n    });\n  });\n};\n/**\n    * traverse through all imports and add the respective path to the whereUsed-list\n    * of the corresponding export\n    */\n\n\nvar determineUsage = function determineUsage() {\n  importList.forEach(function (listValue, listKey) {\n    listValue.forEach(function (value, key) {\n      var exports = exportList.get(key);\n\n      if (typeof exports !== 'undefined') {\n        value.forEach(function (currentImport) {\n          var specifier = void 0;\n\n          if (currentImport === IMPORT_NAMESPACE_SPECIFIER) {\n            specifier = IMPORT_NAMESPACE_SPECIFIER;\n          } else if (currentImport === IMPORT_DEFAULT_SPECIFIER) {\n            specifier = IMPORT_DEFAULT_SPECIFIER;\n          } else {\n            specifier = currentImport;\n          }\n\n          if (typeof specifier !== 'undefined') {\n            var exportStatement = exports.get(specifier);\n\n            if (typeof exportStatement !== 'undefined') {\n              var whereUsed = exportStatement.whereUsed;\n              whereUsed.add(listKey);\n              exports.set(specifier, {\n                whereUsed: whereUsed\n              });\n            }\n          }\n        });\n      }\n    });\n  });\n};\n\nvar getSrc = function getSrc(src) {\n  if (src) {\n    return src;\n  }\n\n  return [process.cwd()];\n};\n/**\n    * prepare the lists of existing imports and exports - should only be executed once at\n    * the start of a new eslint run\n    */\n\n\nvar srcFiles = void 0;\nvar lastPrepareKey = void 0;\n\nvar doPreparation = function doPreparation(src, ignoreExports, context) {\n  var prepareKey = JSON.stringify({\n    src: (src || []).sort(),\n    ignoreExports: (ignoreExports || []).sort(),\n    extensions: Array.from((0, _ignore.getFileExtensions)(context.settings)).sort()\n  });\n\n  if (prepareKey === lastPrepareKey) {\n    return;\n  }\n\n  importList.clear();\n  exportList.clear();\n  ignoredFiles.clear();\n  filesOutsideSrc.clear();\n  srcFiles = resolveFiles(getSrc(src), ignoreExports, context);\n  prepareImportsAndExports(srcFiles, context);\n  determineUsage();\n  lastPrepareKey = prepareKey;\n};\n\nvar newNamespaceImportExists = function newNamespaceImportExists(specifiers) {\n  return specifiers.some(function (_ref7) {\n    var type = _ref7.type;\n    return type === IMPORT_NAMESPACE_SPECIFIER;\n  });\n};\n\nvar newDefaultImportExists = function newDefaultImportExists(specifiers) {\n  return specifiers.some(function (_ref8) {\n    var type = _ref8.type;\n    return type === IMPORT_DEFAULT_SPECIFIER;\n  });\n};\n\nvar fileIsInPkg = function fileIsInPkg(file) {\n  var _readPkgUp = (0, _readPkgUp3['default'])({\n    cwd: file\n  }),\n      path = _readPkgUp.path,\n      pkg = _readPkgUp.pkg;\n\n  var basePath = (0, _path.dirname)(path);\n\n  var checkPkgFieldString = function checkPkgFieldString(pkgField) {\n    if ((0, _path.join)(basePath, pkgField) === file) {\n      return true;\n    }\n  };\n\n  var checkPkgFieldObject = function checkPkgFieldObject(pkgField) {\n    var pkgFieldFiles = (0, _object2['default'])(pkgField).map(function (value) {\n      return (0, _path.join)(basePath, value);\n    });\n\n    if ((0, _arrayIncludes2['default'])(pkgFieldFiles, file)) {\n      return true;\n    }\n  };\n\n  var checkPkgField = function checkPkgField(pkgField) {\n    if (typeof pkgField === 'string') {\n      return checkPkgFieldString(pkgField);\n    }\n\n    if ((typeof pkgField === 'undefined' ? 'undefined' : _typeof(pkgField)) === 'object') {\n      return checkPkgFieldObject(pkgField);\n    }\n  };\n\n  if (pkg['private'] === true) {\n    return false;\n  }\n\n  if (pkg.bin) {\n    if (checkPkgField(pkg.bin)) {\n      return true;\n    }\n  }\n\n  if (pkg.browser) {\n    if (checkPkgField(pkg.browser)) {\n      return true;\n    }\n  }\n\n  if (pkg.main) {\n    if (checkPkgFieldString(pkg.main)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: (0, _docsUrl2['default'])('no-unused-modules')\n    },\n    schema: [{\n      properties: {\n        src: {\n          description: 'files/paths to be analyzed (only for unused exports)',\n          type: 'array',\n          minItems: 1,\n          items: {\n            type: 'string',\n            minLength: 1\n          }\n        },\n        ignoreExports: {\n          description: 'files/paths for which unused exports will not be reported (e.g module entry points)',\n          type: 'array',\n          minItems: 1,\n          items: {\n            type: 'string',\n            minLength: 1\n          }\n        },\n        missingExports: {\n          description: 'report modules without any exports',\n          type: 'boolean'\n        },\n        unusedExports: {\n          description: 'report exports without any usage',\n          type: 'boolean'\n        }\n      },\n      not: {\n        properties: {\n          unusedExports: {\n            'enum': [false]\n          },\n          missingExports: {\n            'enum': [false]\n          }\n        }\n      },\n      anyOf: [{\n        not: {\n          properties: {\n            unusedExports: {\n              'enum': [true]\n            }\n          }\n        },\n        required: ['missingExports']\n      }, {\n        not: {\n          properties: {\n            missingExports: {\n              'enum': [true]\n            }\n          }\n        },\n        required: ['unusedExports']\n      }, {\n        properties: {\n          unusedExports: {\n            'enum': [true]\n          }\n        },\n        required: ['unusedExports']\n      }, {\n        properties: {\n          missingExports: {\n            'enum': [true]\n          }\n        },\n        required: ['missingExports']\n      }]\n    }]\n  },\n  create: function () {\n    function create(context) {\n      var _ref9 = context.options[0] || {},\n          src = _ref9.src,\n          _ref9$ignoreExports = _ref9.ignoreExports,\n          ignoreExports = _ref9$ignoreExports === undefined ? [] : _ref9$ignoreExports,\n          missingExports = _ref9.missingExports,\n          unusedExports = _ref9.unusedExports;\n\n      if (unusedExports) {\n        doPreparation(src, ignoreExports, context);\n      }\n\n      var file = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n\n      var checkExportPresence = function () {\n        function checkExportPresence(node) {\n          if (!missingExports) {\n            return;\n          }\n\n          if (ignoredFiles.has(file)) {\n            return;\n          }\n\n          var exportCount = exportList.get(file);\n          var exportAll = exportCount.get(EXPORT_ALL_DECLARATION);\n          var namespaceImports = exportCount.get(IMPORT_NAMESPACE_SPECIFIER);\n          exportCount['delete'](EXPORT_ALL_DECLARATION);\n          exportCount['delete'](IMPORT_NAMESPACE_SPECIFIER);\n\n          if (exportCount.size < 1) {\n            // node.body[0] === 'undefined' only happens, if everything is commented out in the file\n            // being linted\n            context.report(node.body[0] ? node.body[0] : node, 'No exports found');\n          }\n\n          exportCount.set(EXPORT_ALL_DECLARATION, exportAll);\n          exportCount.set(IMPORT_NAMESPACE_SPECIFIER, namespaceImports);\n        }\n\n        return checkExportPresence;\n      }();\n\n      var checkUsage = function () {\n        function checkUsage(node, exportedValue) {\n          if (!unusedExports) {\n            return;\n          }\n\n          if (ignoredFiles.has(file)) {\n            return;\n          }\n\n          if (fileIsInPkg(file)) {\n            return;\n          }\n\n          if (filesOutsideSrc.has(file)) {\n            return;\n          } // make sure file to be linted is included in source files\n\n\n          if (!srcFiles.has(file)) {\n            srcFiles = resolveFiles(getSrc(src), ignoreExports, context);\n\n            if (!srcFiles.has(file)) {\n              filesOutsideSrc.add(file);\n              return;\n            }\n          }\n\n          exports = exportList.get(file); // special case: export * from\n\n          var exportAll = exports.get(EXPORT_ALL_DECLARATION);\n\n          if (typeof exportAll !== 'undefined' && exportedValue !== IMPORT_DEFAULT_SPECIFIER) {\n            if (exportAll.whereUsed.size > 0) {\n              return;\n            }\n          } // special case: namespace import\n\n\n          var namespaceImports = exports.get(IMPORT_NAMESPACE_SPECIFIER);\n\n          if (typeof namespaceImports !== 'undefined') {\n            if (namespaceImports.whereUsed.size > 0) {\n              return;\n            }\n          } // exportsList will always map any imported value of 'default' to 'ImportDefaultSpecifier'\n\n\n          var exportsKey = exportedValue === DEFAULT ? IMPORT_DEFAULT_SPECIFIER : exportedValue;\n          var exportStatement = exports.get(exportsKey);\n          var value = exportsKey === IMPORT_DEFAULT_SPECIFIER ? DEFAULT : exportsKey;\n\n          if (typeof exportStatement !== 'undefined') {\n            if (exportStatement.whereUsed.size < 1) {\n              context.report(node, 'exported declaration \\'' + value + '\\' not used within other modules');\n            }\n          } else {\n            context.report(node, 'exported declaration \\'' + value + '\\' not used within other modules');\n          }\n        }\n\n        return checkUsage;\n      }();\n      /**\n                                 * only useful for tools like vscode-eslint\n                                 *\n                                 * update lists of existing exports during runtime\n                                 */\n\n\n      var updateExportUsage = function () {\n        function updateExportUsage(node) {\n          if (ignoredFiles.has(file)) {\n            return;\n          }\n\n          var exports = exportList.get(file); // new module has been created during runtime\n          // include it in further processing\n\n          if (typeof exports === 'undefined') {\n            exports = new Map();\n          }\n\n          var newExports = new Map();\n          var newExportIdentifiers = new Set();\n          node.body.forEach(function (_ref10) {\n            var type = _ref10.type,\n                declaration = _ref10.declaration,\n                specifiers = _ref10.specifiers;\n\n            if (type === EXPORT_DEFAULT_DECLARATION) {\n              newExportIdentifiers.add(IMPORT_DEFAULT_SPECIFIER);\n            }\n\n            if (type === EXPORT_NAMED_DECLARATION) {\n              if (specifiers.length > 0) {\n                specifiers.forEach(function (specifier) {\n                  if (specifier.exported) {\n                    newExportIdentifiers.add(specifier.exported.name || specifier.exported.value);\n                  }\n                });\n              }\n\n              forEachDeclarationIdentifier(declaration, function (name) {\n                newExportIdentifiers.add(name);\n              });\n            }\n          }); // old exports exist within list of new exports identifiers: add to map of new exports\n\n          exports.forEach(function (value, key) {\n            if (newExportIdentifiers.has(key)) {\n              newExports.set(key, value);\n            }\n          }); // new export identifiers added: add to map of new exports\n\n          newExportIdentifiers.forEach(function (key) {\n            if (!exports.has(key)) {\n              newExports.set(key, {\n                whereUsed: new Set()\n              });\n            }\n          }); // preserve information about namespace imports\n\n          var exportAll = exports.get(EXPORT_ALL_DECLARATION);\n          var namespaceImports = exports.get(IMPORT_NAMESPACE_SPECIFIER);\n\n          if (typeof namespaceImports === 'undefined') {\n            namespaceImports = {\n              whereUsed: new Set()\n            };\n          }\n\n          newExports.set(EXPORT_ALL_DECLARATION, exportAll);\n          newExports.set(IMPORT_NAMESPACE_SPECIFIER, namespaceImports);\n          exportList.set(file, newExports);\n        }\n\n        return updateExportUsage;\n      }();\n      /**\n                                        * only useful for tools like vscode-eslint\n                                        *\n                                        * update lists of existing imports during runtime\n                                        */\n\n\n      var updateImportUsage = function () {\n        function updateImportUsage(node) {\n          if (!unusedExports) {\n            return;\n          }\n\n          var oldImportPaths = importList.get(file);\n\n          if (typeof oldImportPaths === 'undefined') {\n            oldImportPaths = new Map();\n          }\n\n          var oldNamespaceImports = new Set();\n          var newNamespaceImports = new Set();\n          var oldExportAll = new Set();\n          var newExportAll = new Set();\n          var oldDefaultImports = new Set();\n          var newDefaultImports = new Set();\n          var oldImports = new Map();\n          var newImports = new Map();\n          oldImportPaths.forEach(function (value, key) {\n            if (value.has(EXPORT_ALL_DECLARATION)) {\n              oldExportAll.add(key);\n            }\n\n            if (value.has(IMPORT_NAMESPACE_SPECIFIER)) {\n              oldNamespaceImports.add(key);\n            }\n\n            if (value.has(IMPORT_DEFAULT_SPECIFIER)) {\n              oldDefaultImports.add(key);\n            }\n\n            value.forEach(function (val) {\n              if (val !== IMPORT_NAMESPACE_SPECIFIER && val !== IMPORT_DEFAULT_SPECIFIER) {\n                oldImports.set(val, key);\n              }\n            });\n          });\n\n          function processDynamicImport(source) {\n            if (source.type !== 'Literal') {\n              return null;\n            }\n\n            var p = (0, _resolve2['default'])(source.value, context);\n\n            if (p == null) {\n              return null;\n            }\n\n            newNamespaceImports.add(p);\n          }\n\n          (0, _visit2['default'])(node, visitorKeyMap.get(file), {\n            ImportExpression: function () {\n              function ImportExpression(child) {\n                processDynamicImport(child.source);\n              }\n\n              return ImportExpression;\n            }(),\n            CallExpression: function () {\n              function CallExpression(child) {\n                if (child.callee.type === 'Import') {\n                  processDynamicImport(child.arguments[0]);\n                }\n              }\n\n              return CallExpression;\n            }()\n          });\n          node.body.forEach(function (astNode) {\n            var resolvedPath = void 0; // support for export { value } from 'module'\n\n            if (astNode.type === EXPORT_NAMED_DECLARATION) {\n              if (astNode.source) {\n                resolvedPath = (0, _resolve2['default'])(astNode.source.raw.replace(/('|\")/g, ''), context);\n                astNode.specifiers.forEach(function (specifier) {\n                  var name = specifier.local.name || specifier.local.value;\n\n                  if (name === DEFAULT) {\n                    newDefaultImports.add(resolvedPath);\n                  } else {\n                    newImports.set(name, resolvedPath);\n                  }\n                });\n              }\n            }\n\n            if (astNode.type === EXPORT_ALL_DECLARATION) {\n              resolvedPath = (0, _resolve2['default'])(astNode.source.raw.replace(/('|\")/g, ''), context);\n              newExportAll.add(resolvedPath);\n            }\n\n            if (astNode.type === IMPORT_DECLARATION) {\n              resolvedPath = (0, _resolve2['default'])(astNode.source.raw.replace(/('|\")/g, ''), context);\n\n              if (!resolvedPath) {\n                return;\n              }\n\n              if (isNodeModule(resolvedPath)) {\n                return;\n              }\n\n              if (newNamespaceImportExists(astNode.specifiers)) {\n                newNamespaceImports.add(resolvedPath);\n              }\n\n              if (newDefaultImportExists(astNode.specifiers)) {\n                newDefaultImports.add(resolvedPath);\n              }\n\n              astNode.specifiers.forEach(function (specifier) {\n                if (specifier.type === IMPORT_DEFAULT_SPECIFIER || specifier.type === IMPORT_NAMESPACE_SPECIFIER) {\n                  return;\n                }\n\n                newImports.set(specifier.imported.name || specifier.imported.value, resolvedPath);\n              });\n            }\n          });\n          newExportAll.forEach(function (value) {\n            if (!oldExportAll.has(value)) {\n              var imports = oldImportPaths.get(value);\n\n              if (typeof imports === 'undefined') {\n                imports = new Set();\n              }\n\n              imports.add(EXPORT_ALL_DECLARATION);\n              oldImportPaths.set(value, imports);\n\n              var _exports = exportList.get(value);\n\n              var currentExport = void 0;\n\n              if (typeof _exports !== 'undefined') {\n                currentExport = _exports.get(EXPORT_ALL_DECLARATION);\n              } else {\n                _exports = new Map();\n                exportList.set(value, _exports);\n              }\n\n              if (typeof currentExport !== 'undefined') {\n                currentExport.whereUsed.add(file);\n              } else {\n                var whereUsed = new Set();\n                whereUsed.add(file);\n\n                _exports.set(EXPORT_ALL_DECLARATION, {\n                  whereUsed: whereUsed\n                });\n              }\n            }\n          });\n          oldExportAll.forEach(function (value) {\n            if (!newExportAll.has(value)) {\n              var imports = oldImportPaths.get(value);\n              imports['delete'](EXPORT_ALL_DECLARATION);\n\n              var _exports2 = exportList.get(value);\n\n              if (typeof _exports2 !== 'undefined') {\n                var currentExport = _exports2.get(EXPORT_ALL_DECLARATION);\n\n                if (typeof currentExport !== 'undefined') {\n                  currentExport.whereUsed['delete'](file);\n                }\n              }\n            }\n          });\n          newDefaultImports.forEach(function (value) {\n            if (!oldDefaultImports.has(value)) {\n              var imports = oldImportPaths.get(value);\n\n              if (typeof imports === 'undefined') {\n                imports = new Set();\n              }\n\n              imports.add(IMPORT_DEFAULT_SPECIFIER);\n              oldImportPaths.set(value, imports);\n\n              var _exports3 = exportList.get(value);\n\n              var currentExport = void 0;\n\n              if (typeof _exports3 !== 'undefined') {\n                currentExport = _exports3.get(IMPORT_DEFAULT_SPECIFIER);\n              } else {\n                _exports3 = new Map();\n                exportList.set(value, _exports3);\n              }\n\n              if (typeof currentExport !== 'undefined') {\n                currentExport.whereUsed.add(file);\n              } else {\n                var whereUsed = new Set();\n                whereUsed.add(file);\n\n                _exports3.set(IMPORT_DEFAULT_SPECIFIER, {\n                  whereUsed: whereUsed\n                });\n              }\n            }\n          });\n          oldDefaultImports.forEach(function (value) {\n            if (!newDefaultImports.has(value)) {\n              var imports = oldImportPaths.get(value);\n              imports['delete'](IMPORT_DEFAULT_SPECIFIER);\n\n              var _exports4 = exportList.get(value);\n\n              if (typeof _exports4 !== 'undefined') {\n                var currentExport = _exports4.get(IMPORT_DEFAULT_SPECIFIER);\n\n                if (typeof currentExport !== 'undefined') {\n                  currentExport.whereUsed['delete'](file);\n                }\n              }\n            }\n          });\n          newNamespaceImports.forEach(function (value) {\n            if (!oldNamespaceImports.has(value)) {\n              var imports = oldImportPaths.get(value);\n\n              if (typeof imports === 'undefined') {\n                imports = new Set();\n              }\n\n              imports.add(IMPORT_NAMESPACE_SPECIFIER);\n              oldImportPaths.set(value, imports);\n\n              var _exports5 = exportList.get(value);\n\n              var currentExport = void 0;\n\n              if (typeof _exports5 !== 'undefined') {\n                currentExport = _exports5.get(IMPORT_NAMESPACE_SPECIFIER);\n              } else {\n                _exports5 = new Map();\n                exportList.set(value, _exports5);\n              }\n\n              if (typeof currentExport !== 'undefined') {\n                currentExport.whereUsed.add(file);\n              } else {\n                var whereUsed = new Set();\n                whereUsed.add(file);\n\n                _exports5.set(IMPORT_NAMESPACE_SPECIFIER, {\n                  whereUsed: whereUsed\n                });\n              }\n            }\n          });\n          oldNamespaceImports.forEach(function (value) {\n            if (!newNamespaceImports.has(value)) {\n              var imports = oldImportPaths.get(value);\n              imports['delete'](IMPORT_NAMESPACE_SPECIFIER);\n\n              var _exports6 = exportList.get(value);\n\n              if (typeof _exports6 !== 'undefined') {\n                var currentExport = _exports6.get(IMPORT_NAMESPACE_SPECIFIER);\n\n                if (typeof currentExport !== 'undefined') {\n                  currentExport.whereUsed['delete'](file);\n                }\n              }\n            }\n          });\n          newImports.forEach(function (value, key) {\n            if (!oldImports.has(key)) {\n              var imports = oldImportPaths.get(value);\n\n              if (typeof imports === 'undefined') {\n                imports = new Set();\n              }\n\n              imports.add(key);\n              oldImportPaths.set(value, imports);\n\n              var _exports7 = exportList.get(value);\n\n              var currentExport = void 0;\n\n              if (typeof _exports7 !== 'undefined') {\n                currentExport = _exports7.get(key);\n              } else {\n                _exports7 = new Map();\n                exportList.set(value, _exports7);\n              }\n\n              if (typeof currentExport !== 'undefined') {\n                currentExport.whereUsed.add(file);\n              } else {\n                var whereUsed = new Set();\n                whereUsed.add(file);\n\n                _exports7.set(key, {\n                  whereUsed: whereUsed\n                });\n              }\n            }\n          });\n          oldImports.forEach(function (value, key) {\n            if (!newImports.has(key)) {\n              var imports = oldImportPaths.get(value);\n              imports['delete'](key);\n\n              var _exports8 = exportList.get(value);\n\n              if (typeof _exports8 !== 'undefined') {\n                var currentExport = _exports8.get(key);\n\n                if (typeof currentExport !== 'undefined') {\n                  currentExport.whereUsed['delete'](file);\n                }\n              }\n            }\n          });\n        }\n\n        return updateImportUsage;\n      }();\n\n      return {\n        'Program:exit': function () {\n          function ProgramExit(node) {\n            updateExportUsage(node);\n            updateImportUsage(node);\n            checkExportPresence(node);\n          }\n\n          return ProgramExit;\n        }(),\n        'ExportDefaultDeclaration': function () {\n          function ExportDefaultDeclaration(node) {\n            checkUsage(node, IMPORT_DEFAULT_SPECIFIER);\n          }\n\n          return ExportDefaultDeclaration;\n        }(),\n        'ExportNamedDeclaration': function () {\n          function ExportNamedDeclaration(node) {\n            node.specifiers.forEach(function (specifier) {\n              checkUsage(node, specifier.exported.name || specifier.exported.value);\n            });\n            forEachDeclarationIdentifier(node.declaration, function (name) {\n              checkUsage(node, name);\n            });\n          }\n\n          return ExportNamedDeclaration;\n        }()\n      };\n    }\n\n    return create;\n  }()\n};","map":{"version":3,"mappings":"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","names":["FileEnumerator","listFilesToProcess","require","e","originalListFilesToProcess","src","extensions","patterns","reduce","carry","pattern","concat","map","extension","test","slice","Array","from","iterateFiles","filePath","ignored","filename","EXPORT_DEFAULT_DECLARATION","EXPORT_NAMED_DECLARATION","EXPORT_ALL_DECLARATION","IMPORT_DECLARATION","IMPORT_NAMESPACE_SPECIFIER","IMPORT_DEFAULT_SPECIFIER","VARIABLE_DECLARATION","FUNCTION_DECLARATION","CLASS_DECLARATION","IDENTIFIER","OBJECT_PATTERN","TS_INTERFACE_DECLARATION","TS_TYPE_ALIAS_DECLARATION","TS_ENUM_DECLARATION","DEFAULT","forEachDeclarationIdentifier","declaration","cb","type","id","name","declarations","forEach","importList","Map","exportList","visitorKeyMap","ignoredFiles","Set","filesOutsideSrc","isNodeModule","path","resolveFiles","ignoreExports","context","settings","srcFiles","srcFileList","ignoredFilesList","add","filter","prepareImportsAndExports","exportAll","exports","imports","currentExports","Exports","get","file","dependencies","reexports","localImportList","namespace","visitorKeys","set","currentExportAll","dependency","getDependency","value","key","whereUsed","reexport","getImport","localImport","currentValue","local","importedSpecifiers","specifier","has","val","currentExport","determineUsage","listValue","listKey","currentImport","exportStatement","getSrc","process","cwd","lastPrepareKey","doPreparation","prepareKey","JSON","stringify","sort","clear","newNamespaceImportExists","specifiers","some","newDefaultImportExists","fileIsInPkg","pkg","basePath","checkPkgFieldString","pkgField","checkPkgFieldObject","pkgFieldFiles","checkPkgField","bin","browser","main","module","meta","docs","url","schema","properties","description","minItems","items","minLength","missingExports","unusedExports","not","anyOf","required","create","options","getPhysicalFilename","getFilename","checkExportPresence","exportCount","namespaceImports","size","report","node","body","checkUsage","exportedValue","exportsKey","updateExportUsage","newExports","newExportIdentifiers","length","exported","updateImportUsage","oldImportPaths","oldNamespaceImports","newNamespaceImports","oldExportAll","newExportAll","oldDefaultImports","newDefaultImports","oldImports","newImports","processDynamicImport","source","p","ImportExpression","child","CallExpression","callee","arguments","resolvedPath","astNode","raw","replace","imported"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\no-unused-modules.js"],"sourcesContent":["/**\n * @fileOverview Ensures that modules contain exports and/or all\n * modules are consumed within other modules.\n * @author RenÃ© Fermann\n */\n\nimport Exports, { recursivePatternCapture } from '../ExportMap';\nimport { getFileExtensions } from 'eslint-module-utils/ignore';\nimport resolve from 'eslint-module-utils/resolve';\nimport visit from 'eslint-module-utils/visit';\nimport docsUrl from '../docsUrl';\nimport { dirname, join } from 'path';\nimport readPkgUp from 'eslint-module-utils/readPkgUp';\nimport values from 'object.values';\nimport includes from 'array-includes';\n\nlet FileEnumerator;\nlet listFilesToProcess;\n\ntry {\n  ({ FileEnumerator } = require('eslint/use-at-your-own-risk'));\n} catch (e) {\n  try {\n    // has been moved to eslint/lib/cli-engine/file-enumerator in version 6\n    ({ FileEnumerator } = require('eslint/lib/cli-engine/file-enumerator'));\n  } catch (e) {\n    try {\n      // eslint/lib/util/glob-util has been moved to eslint/lib/util/glob-utils with version 5.3\n      const { listFilesToProcess: originalListFilesToProcess } = require('eslint/lib/util/glob-utils');\n\n      // Prevent passing invalid options (extensions array) to old versions of the function.\n      // https://github.com/eslint/eslint/blob/v5.16.0/lib/util/glob-utils.js#L178-L280\n      // https://github.com/eslint/eslint/blob/v5.2.0/lib/util/glob-util.js#L174-L269\n      listFilesToProcess = function (src, extensions) {\n        return originalListFilesToProcess(src, {\n          extensions,\n        });\n      };\n    } catch (e) {\n      const { listFilesToProcess: originalListFilesToProcess } = require('eslint/lib/util/glob-util');\n      \n      listFilesToProcess = function (src, extensions) {\n        const patterns = src.reduce((carry, pattern) => {\n          return carry.concat(extensions.map((extension) => {\n            return /\\*\\*|\\*\\./.test(pattern) ? pattern : `${pattern}/**/*${extension}`;\n          }));\n        }, src.slice());\n    \n        return originalListFilesToProcess(patterns);\n      };\n    }\n  }\n}\n\nif (FileEnumerator) {\n  listFilesToProcess = function (src, extensions) {\n    const e = new FileEnumerator({\n      extensions,\n    });\n\n    return Array.from(e.iterateFiles(src), ({ filePath, ignored }) => ({\n      ignored,\n      filename: filePath,\n    }));\n  };\n}\n\nconst EXPORT_DEFAULT_DECLARATION = 'ExportDefaultDeclaration';\nconst EXPORT_NAMED_DECLARATION = 'ExportNamedDeclaration';\nconst EXPORT_ALL_DECLARATION = 'ExportAllDeclaration';\nconst IMPORT_DECLARATION = 'ImportDeclaration';\nconst IMPORT_NAMESPACE_SPECIFIER = 'ImportNamespaceSpecifier';\nconst IMPORT_DEFAULT_SPECIFIER = 'ImportDefaultSpecifier';\nconst VARIABLE_DECLARATION = 'VariableDeclaration';\nconst FUNCTION_DECLARATION = 'FunctionDeclaration';\nconst CLASS_DECLARATION = 'ClassDeclaration';\nconst IDENTIFIER = 'Identifier';\nconst OBJECT_PATTERN = 'ObjectPattern';\nconst TS_INTERFACE_DECLARATION = 'TSInterfaceDeclaration';\nconst TS_TYPE_ALIAS_DECLARATION = 'TSTypeAliasDeclaration';\nconst TS_ENUM_DECLARATION = 'TSEnumDeclaration';\nconst DEFAULT = 'default';\n\nfunction forEachDeclarationIdentifier(declaration, cb) {\n  if (declaration) {\n    if (\n      declaration.type === FUNCTION_DECLARATION ||\n      declaration.type === CLASS_DECLARATION ||\n      declaration.type === TS_INTERFACE_DECLARATION ||\n      declaration.type === TS_TYPE_ALIAS_DECLARATION ||\n      declaration.type === TS_ENUM_DECLARATION\n    ) {\n      cb(declaration.id.name);\n    } else if (declaration.type === VARIABLE_DECLARATION) {\n      declaration.declarations.forEach(({ id }) => {\n        if (id.type === OBJECT_PATTERN) {\n          recursivePatternCapture(id, (pattern) => {\n            if (pattern.type === IDENTIFIER) {\n              cb(pattern.name);\n            }\n          });\n        } else {\n          cb(id.name);\n        }\n      });\n    }\n  }\n}\n\n/**\n * List of imports per file.\n *\n * Represented by a two-level Map to a Set of identifiers. The upper-level Map\n * keys are the paths to the modules containing the imports, while the\n * lower-level Map keys are the paths to the files which are being imported\n * from. Lastly, the Set of identifiers contains either names being imported\n * or a special AST node name listed above (e.g ImportDefaultSpecifier).\n *\n * For example, if we have a file named foo.js containing:\n *\n *   import { o2 } from './bar.js';\n *\n * Then we will have a structure that looks like:\n *\n *   Map { 'foo.js' => Map { 'bar.js' => Set { 'o2' } } }\n *\n * @type {Map<string, Map<string, Set<string>>>}\n */\nconst importList = new Map();\n\n/**\n * List of exports per file.\n *\n * Represented by a two-level Map to an object of metadata. The upper-level Map\n * keys are the paths to the modules containing the exports, while the\n * lower-level Map keys are the specific identifiers or special AST node names\n * being exported. The leaf-level metadata object at the moment only contains a\n * `whereUsed` property, which contains a Set of paths to modules that import\n * the name.\n *\n * For example, if we have a file named bar.js containing the following exports:\n *\n *   const o2 = 'bar';\n *   export { o2 };\n *\n * And a file named foo.js containing the following import:\n *\n *   import { o2 } from './bar.js';\n *\n * Then we will have a structure that looks like:\n *\n *   Map { 'bar.js' => Map { 'o2' => { whereUsed: Set { 'foo.js' } } } }\n *\n * @type {Map<string, Map<string, object>>}\n */\nconst exportList = new Map();\n\nconst visitorKeyMap = new Map();\n\nconst ignoredFiles = new Set();\nconst filesOutsideSrc = new Set();\n\nconst isNodeModule = path => {\n  return /\\/(node_modules)\\//.test(path);\n};\n\n/**\n * read all files matching the patterns in src and ignoreExports\n *\n * return all files matching src pattern, which are not matching the ignoreExports pattern\n */\nconst resolveFiles = (src, ignoreExports, context) => {\n  const extensions = Array.from(getFileExtensions(context.settings));\n\n  const srcFiles = new Set();\n  const srcFileList = listFilesToProcess(src, extensions);\n\n  // prepare list of ignored files\n  const ignoredFilesList =  listFilesToProcess(ignoreExports, extensions);\n  ignoredFilesList.forEach(({ filename }) => ignoredFiles.add(filename));\n\n  // prepare list of source files, don't consider files from node_modules\n  srcFileList.filter(({ filename }) => !isNodeModule(filename)).forEach(({ filename }) => {\n    srcFiles.add(filename);\n  });\n  return srcFiles;\n};\n\n/**\n * parse all source files and build up 2 maps containing the existing imports and exports\n */\nconst prepareImportsAndExports = (srcFiles, context) => {\n  const exportAll = new Map();\n  srcFiles.forEach(file => {\n    const exports = new Map();\n    const imports = new Map();\n    const currentExports = Exports.get(file, context);\n    if (currentExports) {\n      const {\n        dependencies,\n        reexports,\n        imports: localImportList,\n        namespace,\n        visitorKeys,\n      } = currentExports;\n\n      visitorKeyMap.set(file, visitorKeys);\n      // dependencies === export * from\n      const currentExportAll = new Set();\n      dependencies.forEach(getDependency => {\n        const dependency = getDependency();\n        if (dependency === null) {\n          return;\n        }\n\n        currentExportAll.add(dependency.path);\n      });\n      exportAll.set(file, currentExportAll);\n\n      reexports.forEach((value, key) => {\n        if (key === DEFAULT) {\n          exports.set(IMPORT_DEFAULT_SPECIFIER, { whereUsed: new Set() });\n        } else {\n          exports.set(key, { whereUsed: new Set() });\n        }\n        const reexport =  value.getImport();\n        if (!reexport) {\n          return;\n        }\n        let localImport = imports.get(reexport.path);\n        let currentValue;\n        if (value.local === DEFAULT) {\n          currentValue = IMPORT_DEFAULT_SPECIFIER;\n        } else {\n          currentValue = value.local;\n        }\n        if (typeof localImport !== 'undefined') {\n          localImport = new Set([...localImport, currentValue]);\n        } else {\n          localImport = new Set([currentValue]);\n        }\n        imports.set(reexport.path, localImport);\n      });\n\n      localImportList.forEach((value, key) => {\n        if (isNodeModule(key)) {\n          return;\n        }\n        const localImport = imports.get(key) || new Set();\n        value.declarations.forEach(({ importedSpecifiers }) =>\n          importedSpecifiers.forEach(specifier => localImport.add(specifier)),\n        );\n        imports.set(key, localImport);\n      });\n      importList.set(file, imports);\n\n      // build up export list only, if file is not ignored\n      if (ignoredFiles.has(file)) {\n        return;\n      }\n      namespace.forEach((value, key) => {\n        if (key === DEFAULT) {\n          exports.set(IMPORT_DEFAULT_SPECIFIER, { whereUsed: new Set() });\n        } else {\n          exports.set(key, { whereUsed: new Set() });\n        }\n      });\n    }\n    exports.set(EXPORT_ALL_DECLARATION, { whereUsed: new Set() });\n    exports.set(IMPORT_NAMESPACE_SPECIFIER, { whereUsed: new Set() });\n    exportList.set(file, exports);\n  });\n  exportAll.forEach((value, key) => {\n    value.forEach(val => {\n      const currentExports = exportList.get(val);\n      if (currentExports) {\n        const currentExport = currentExports.get(EXPORT_ALL_DECLARATION);\n        currentExport.whereUsed.add(key);\n      }\n    });\n  });\n};\n\n/**\n * traverse through all imports and add the respective path to the whereUsed-list\n * of the corresponding export\n */\nconst determineUsage = () => {\n  importList.forEach((listValue, listKey) => {\n    listValue.forEach((value, key) => {\n      const exports = exportList.get(key);\n      if (typeof exports !== 'undefined') {\n        value.forEach(currentImport => {\n          let specifier;\n          if (currentImport === IMPORT_NAMESPACE_SPECIFIER) {\n            specifier = IMPORT_NAMESPACE_SPECIFIER;\n          } else if (currentImport === IMPORT_DEFAULT_SPECIFIER) {\n            specifier = IMPORT_DEFAULT_SPECIFIER;\n          } else {\n            specifier = currentImport;\n          }\n          if (typeof specifier !== 'undefined') {\n            const exportStatement = exports.get(specifier);\n            if (typeof exportStatement !== 'undefined') {\n              const { whereUsed } = exportStatement;\n              whereUsed.add(listKey);\n              exports.set(specifier, { whereUsed });\n            }\n          }\n        });\n      }\n    });\n  });\n};\n\nconst getSrc = src => {\n  if (src) {\n    return src;\n  }\n  return [process.cwd()];\n};\n\n/**\n * prepare the lists of existing imports and exports - should only be executed once at\n * the start of a new eslint run\n */\nlet srcFiles;\nlet lastPrepareKey;\nconst doPreparation = (src, ignoreExports, context) => {\n  const prepareKey = JSON.stringify({\n    src: (src || []).sort(),\n    ignoreExports: (ignoreExports || []).sort(),\n    extensions: Array.from(getFileExtensions(context.settings)).sort(),\n  });\n  if (prepareKey === lastPrepareKey) {\n    return;\n  }\n\n  importList.clear();\n  exportList.clear();\n  ignoredFiles.clear();\n  filesOutsideSrc.clear();\n\n  srcFiles = resolveFiles(getSrc(src), ignoreExports, context);\n  prepareImportsAndExports(srcFiles, context);\n  determineUsage();\n  lastPrepareKey = prepareKey;\n};\n\nconst newNamespaceImportExists = specifiers =>\n  specifiers.some(({ type }) => type === IMPORT_NAMESPACE_SPECIFIER);\n\nconst newDefaultImportExists = specifiers =>\n  specifiers.some(({ type }) => type === IMPORT_DEFAULT_SPECIFIER);\n\nconst fileIsInPkg = file => {\n  const { path, pkg } = readPkgUp({ cwd: file });\n  const basePath = dirname(path);\n\n  const checkPkgFieldString = pkgField => {\n    if (join(basePath, pkgField) === file) {\n      return true;\n    }\n  };\n\n  const checkPkgFieldObject = pkgField => {\n    const pkgFieldFiles = values(pkgField).map(value => join(basePath, value));\n    if (includes(pkgFieldFiles, file)) {\n      return true;\n    }\n  };\n\n  const checkPkgField = pkgField => {\n    if (typeof pkgField === 'string') {\n      return checkPkgFieldString(pkgField);\n    }\n\n    if (typeof pkgField === 'object') {\n      return checkPkgFieldObject(pkgField);\n    }\n  };\n\n  if (pkg.private === true) {\n    return false;\n  }\n\n  if (pkg.bin) {\n    if (checkPkgField(pkg.bin)) {\n      return true;\n    }\n  }\n\n  if (pkg.browser) {\n    if (checkPkgField(pkg.browser)) {\n      return true;\n    }\n  }\n\n  if (pkg.main) {\n    if (checkPkgFieldString(pkg.main)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: { url: docsUrl('no-unused-modules') },\n    schema: [{\n      properties: {\n        src: {\n          description: 'files/paths to be analyzed (only for unused exports)',\n          type: 'array',\n          minItems: 1,\n          items: {\n            type: 'string',\n            minLength: 1,\n          },\n        },\n        ignoreExports: {\n          description:\n            'files/paths for which unused exports will not be reported (e.g module entry points)',\n          type: 'array',\n          minItems: 1,\n          items: {\n            type: 'string',\n            minLength: 1,\n          },\n        },\n        missingExports: {\n          description: 'report modules without any exports',\n          type: 'boolean',\n        },\n        unusedExports: {\n          description: 'report exports without any usage',\n          type: 'boolean',\n        },\n      },\n      not: {\n        properties: {\n          unusedExports: { enum: [false] },\n          missingExports: { enum: [false] },\n        },\n      },\n      anyOf:[{\n        not: {\n          properties: {\n            unusedExports: { enum: [true] },\n          },\n        },\n        required: ['missingExports'],\n      }, {\n        not: {\n          properties: {\n            missingExports: { enum: [true] },\n          },\n        },\n        required: ['unusedExports'],\n      }, {\n        properties: {\n          unusedExports: { enum: [true] },\n        },\n        required: ['unusedExports'],\n      }, {\n        properties: {\n          missingExports: { enum: [true] },\n        },\n        required: ['missingExports'],\n      }],\n    }],\n  },\n\n  create: context => {\n    const {\n      src,\n      ignoreExports = [],\n      missingExports,\n      unusedExports,\n    } = context.options[0] || {};\n\n    if (unusedExports) {\n      doPreparation(src, ignoreExports, context);\n    }\n\n    const file = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n\n    const checkExportPresence = node => {\n      if (!missingExports) {\n        return;\n      }\n\n      if (ignoredFiles.has(file)) {\n        return;\n      }\n\n      const exportCount = exportList.get(file);\n      const exportAll = exportCount.get(EXPORT_ALL_DECLARATION);\n      const namespaceImports = exportCount.get(IMPORT_NAMESPACE_SPECIFIER);\n\n      exportCount.delete(EXPORT_ALL_DECLARATION);\n      exportCount.delete(IMPORT_NAMESPACE_SPECIFIER);\n      if (exportCount.size < 1) {\n        // node.body[0] === 'undefined' only happens, if everything is commented out in the file\n        // being linted\n        context.report(node.body[0] ? node.body[0] : node, 'No exports found');\n      }\n      exportCount.set(EXPORT_ALL_DECLARATION, exportAll);\n      exportCount.set(IMPORT_NAMESPACE_SPECIFIER, namespaceImports);\n    };\n\n    const checkUsage = (node, exportedValue) => {\n      if (!unusedExports) {\n        return;\n      }\n\n      if (ignoredFiles.has(file)) {\n        return;\n      }\n\n      if (fileIsInPkg(file)) {\n        return;\n      }\n\n      if (filesOutsideSrc.has(file)) {\n        return;\n      }\n\n      // make sure file to be linted is included in source files\n      if (!srcFiles.has(file)) {\n        srcFiles = resolveFiles(getSrc(src), ignoreExports, context);\n        if (!srcFiles.has(file)) {\n          filesOutsideSrc.add(file);\n          return;\n        }\n      }\n\n      exports = exportList.get(file);\n\n      // special case: export * from\n      const exportAll = exports.get(EXPORT_ALL_DECLARATION);\n      if (typeof exportAll !== 'undefined' && exportedValue !== IMPORT_DEFAULT_SPECIFIER) {\n        if (exportAll.whereUsed.size > 0) {\n          return;\n        }\n      }\n\n      // special case: namespace import\n      const namespaceImports = exports.get(IMPORT_NAMESPACE_SPECIFIER);\n      if (typeof namespaceImports !== 'undefined') {\n        if (namespaceImports.whereUsed.size > 0) {\n          return;\n        }\n      }\n\n      // exportsList will always map any imported value of 'default' to 'ImportDefaultSpecifier'\n      const exportsKey = exportedValue === DEFAULT ? IMPORT_DEFAULT_SPECIFIER : exportedValue;\n\n      const exportStatement = exports.get(exportsKey);\n\n      const value = exportsKey === IMPORT_DEFAULT_SPECIFIER ? DEFAULT : exportsKey;\n\n      if (typeof exportStatement !== 'undefined') {\n        if (exportStatement.whereUsed.size < 1) {\n          context.report(\n            node,\n            `exported declaration '${value}' not used within other modules`,\n          );\n        }\n      } else {\n        context.report(\n          node,\n          `exported declaration '${value}' not used within other modules`,\n        );\n      }\n    };\n\n    /**\n     * only useful for tools like vscode-eslint\n     *\n     * update lists of existing exports during runtime\n     */\n    const updateExportUsage = node => {\n      if (ignoredFiles.has(file)) {\n        return;\n      }\n\n      let exports = exportList.get(file);\n\n      // new module has been created during runtime\n      // include it in further processing\n      if (typeof exports === 'undefined') {\n        exports = new Map();\n      }\n\n      const newExports = new Map();\n      const newExportIdentifiers = new Set();\n\n      node.body.forEach(({ type, declaration, specifiers }) => {\n        if (type === EXPORT_DEFAULT_DECLARATION) {\n          newExportIdentifiers.add(IMPORT_DEFAULT_SPECIFIER);\n        }\n        if (type === EXPORT_NAMED_DECLARATION) {\n          if (specifiers.length > 0) {\n            specifiers.forEach(specifier => {\n              if (specifier.exported) {\n                newExportIdentifiers.add(specifier.exported.name || specifier.exported.value);\n              }\n            });\n          }\n          forEachDeclarationIdentifier(declaration, (name) => {\n            newExportIdentifiers.add(name);\n          });\n        }\n      });\n\n      // old exports exist within list of new exports identifiers: add to map of new exports\n      exports.forEach((value, key) => {\n        if (newExportIdentifiers.has(key)) {\n          newExports.set(key, value);\n        }\n      });\n\n      // new export identifiers added: add to map of new exports\n      newExportIdentifiers.forEach(key => {\n        if (!exports.has(key)) {\n          newExports.set(key, { whereUsed: new Set() });\n        }\n      });\n\n      // preserve information about namespace imports\n      const exportAll = exports.get(EXPORT_ALL_DECLARATION);\n      let namespaceImports = exports.get(IMPORT_NAMESPACE_SPECIFIER);\n\n      if (typeof namespaceImports === 'undefined') {\n        namespaceImports = { whereUsed: new Set() };\n      }\n\n      newExports.set(EXPORT_ALL_DECLARATION, exportAll);\n      newExports.set(IMPORT_NAMESPACE_SPECIFIER, namespaceImports);\n      exportList.set(file, newExports);\n    };\n\n    /**\n     * only useful for tools like vscode-eslint\n     *\n     * update lists of existing imports during runtime\n     */\n    const updateImportUsage = node => {\n      if (!unusedExports) {\n        return;\n      }\n\n      let oldImportPaths = importList.get(file);\n      if (typeof oldImportPaths === 'undefined') {\n        oldImportPaths = new Map();\n      }\n\n      const oldNamespaceImports = new Set();\n      const newNamespaceImports = new Set();\n\n      const oldExportAll = new Set();\n      const newExportAll = new Set();\n\n      const oldDefaultImports = new Set();\n      const newDefaultImports = new Set();\n\n      const oldImports = new Map();\n      const newImports = new Map();\n      oldImportPaths.forEach((value, key) => {\n        if (value.has(EXPORT_ALL_DECLARATION)) {\n          oldExportAll.add(key);\n        }\n        if (value.has(IMPORT_NAMESPACE_SPECIFIER)) {\n          oldNamespaceImports.add(key);\n        }\n        if (value.has(IMPORT_DEFAULT_SPECIFIER)) {\n          oldDefaultImports.add(key);\n        }\n        value.forEach(val => {\n          if (val !== IMPORT_NAMESPACE_SPECIFIER &&\n              val !== IMPORT_DEFAULT_SPECIFIER) {\n            oldImports.set(val, key);\n          }\n        });\n      });\n\n      function processDynamicImport(source) {\n        if (source.type !== 'Literal') {\n          return null;\n        }\n        const p = resolve(source.value, context);\n        if (p == null) {\n          return null;\n        }\n        newNamespaceImports.add(p);\n      }\n\n      visit(node, visitorKeyMap.get(file), {\n        ImportExpression(child) {\n          processDynamicImport(child.source);\n        },\n        CallExpression(child) {\n          if (child.callee.type === 'Import') {\n            processDynamicImport(child.arguments[0]);\n          }\n        },\n      });\n\n      node.body.forEach(astNode => {\n        let resolvedPath;\n\n        // support for export { value } from 'module'\n        if (astNode.type === EXPORT_NAMED_DECLARATION) {\n          if (astNode.source) {\n            resolvedPath = resolve(astNode.source.raw.replace(/('|\")/g, ''), context);\n            astNode.specifiers.forEach(specifier => {\n              const name = specifier.local.name || specifier.local.value;\n              if (name === DEFAULT) {\n                newDefaultImports.add(resolvedPath);\n              } else {\n                newImports.set(name, resolvedPath);\n              }\n            });\n          }\n        }\n\n        if (astNode.type === EXPORT_ALL_DECLARATION) {\n          resolvedPath = resolve(astNode.source.raw.replace(/('|\")/g, ''), context);\n          newExportAll.add(resolvedPath);\n        }\n\n        if (astNode.type === IMPORT_DECLARATION) {\n          resolvedPath = resolve(astNode.source.raw.replace(/('|\")/g, ''), context);\n          if (!resolvedPath) {\n            return;\n          }\n\n          if (isNodeModule(resolvedPath)) {\n            return;\n          }\n\n          if (newNamespaceImportExists(astNode.specifiers)) {\n            newNamespaceImports.add(resolvedPath);\n          }\n\n          if (newDefaultImportExists(astNode.specifiers)) {\n            newDefaultImports.add(resolvedPath);\n          }\n\n          astNode.specifiers.forEach(specifier => {\n            if (specifier.type === IMPORT_DEFAULT_SPECIFIER ||\n                specifier.type === IMPORT_NAMESPACE_SPECIFIER) {\n              return;\n            }\n            newImports.set(specifier.imported.name || specifier.imported.value, resolvedPath);\n          });\n        }\n      });\n\n      newExportAll.forEach(value => {\n        if (!oldExportAll.has(value)) {\n          let imports = oldImportPaths.get(value);\n          if (typeof imports === 'undefined') {\n            imports = new Set();\n          }\n          imports.add(EXPORT_ALL_DECLARATION);\n          oldImportPaths.set(value, imports);\n\n          let exports = exportList.get(value);\n          let currentExport;\n          if (typeof exports !== 'undefined') {\n            currentExport = exports.get(EXPORT_ALL_DECLARATION);\n          } else {\n            exports = new Map();\n            exportList.set(value, exports);\n          }\n\n          if (typeof currentExport !== 'undefined') {\n            currentExport.whereUsed.add(file);\n          } else {\n            const whereUsed = new Set();\n            whereUsed.add(file);\n            exports.set(EXPORT_ALL_DECLARATION, { whereUsed });\n          }\n        }\n      });\n\n      oldExportAll.forEach(value => {\n        if (!newExportAll.has(value)) {\n          const imports = oldImportPaths.get(value);\n          imports.delete(EXPORT_ALL_DECLARATION);\n\n          const exports = exportList.get(value);\n          if (typeof exports !== 'undefined') {\n            const currentExport = exports.get(EXPORT_ALL_DECLARATION);\n            if (typeof currentExport !== 'undefined') {\n              currentExport.whereUsed.delete(file);\n            }\n          }\n        }\n      });\n\n      newDefaultImports.forEach(value => {\n        if (!oldDefaultImports.has(value)) {\n          let imports = oldImportPaths.get(value);\n          if (typeof imports === 'undefined') {\n            imports = new Set();\n          }\n          imports.add(IMPORT_DEFAULT_SPECIFIER);\n          oldImportPaths.set(value, imports);\n\n          let exports = exportList.get(value);\n          let currentExport;\n          if (typeof exports !== 'undefined') {\n            currentExport = exports.get(IMPORT_DEFAULT_SPECIFIER);\n          } else {\n            exports = new Map();\n            exportList.set(value, exports);\n          }\n\n          if (typeof currentExport !== 'undefined') {\n            currentExport.whereUsed.add(file);\n          } else {\n            const whereUsed = new Set();\n            whereUsed.add(file);\n            exports.set(IMPORT_DEFAULT_SPECIFIER, { whereUsed });\n          }\n        }\n      });\n\n      oldDefaultImports.forEach(value => {\n        if (!newDefaultImports.has(value)) {\n          const imports = oldImportPaths.get(value);\n          imports.delete(IMPORT_DEFAULT_SPECIFIER);\n\n          const exports = exportList.get(value);\n          if (typeof exports !== 'undefined') {\n            const currentExport = exports.get(IMPORT_DEFAULT_SPECIFIER);\n            if (typeof currentExport !== 'undefined') {\n              currentExport.whereUsed.delete(file);\n            }\n          }\n        }\n      });\n\n      newNamespaceImports.forEach(value => {\n        if (!oldNamespaceImports.has(value)) {\n          let imports = oldImportPaths.get(value);\n          if (typeof imports === 'undefined') {\n            imports = new Set();\n          }\n          imports.add(IMPORT_NAMESPACE_SPECIFIER);\n          oldImportPaths.set(value, imports);\n\n          let exports = exportList.get(value);\n          let currentExport;\n          if (typeof exports !== 'undefined') {\n            currentExport = exports.get(IMPORT_NAMESPACE_SPECIFIER);\n          } else {\n            exports = new Map();\n            exportList.set(value, exports);\n          }\n\n          if (typeof currentExport !== 'undefined') {\n            currentExport.whereUsed.add(file);\n          } else {\n            const whereUsed = new Set();\n            whereUsed.add(file);\n            exports.set(IMPORT_NAMESPACE_SPECIFIER, { whereUsed });\n          }\n        }\n      });\n\n      oldNamespaceImports.forEach(value => {\n        if (!newNamespaceImports.has(value)) {\n          const imports = oldImportPaths.get(value);\n          imports.delete(IMPORT_NAMESPACE_SPECIFIER);\n\n          const exports = exportList.get(value);\n          if (typeof exports !== 'undefined') {\n            const currentExport = exports.get(IMPORT_NAMESPACE_SPECIFIER);\n            if (typeof currentExport !== 'undefined') {\n              currentExport.whereUsed.delete(file);\n            }\n          }\n        }\n      });\n\n      newImports.forEach((value, key) => {\n        if (!oldImports.has(key)) {\n          let imports = oldImportPaths.get(value);\n          if (typeof imports === 'undefined') {\n            imports = new Set();\n          }\n          imports.add(key);\n          oldImportPaths.set(value, imports);\n\n          let exports = exportList.get(value);\n          let currentExport;\n          if (typeof exports !== 'undefined') {\n            currentExport = exports.get(key);\n          } else {\n            exports = new Map();\n            exportList.set(value, exports);\n          }\n\n          if (typeof currentExport !== 'undefined') {\n            currentExport.whereUsed.add(file);\n          } else {\n            const whereUsed = new Set();\n            whereUsed.add(file);\n            exports.set(key, { whereUsed });\n          }\n        }\n      });\n\n      oldImports.forEach((value, key) => {\n        if (!newImports.has(key)) {\n          const imports = oldImportPaths.get(value);\n          imports.delete(key);\n\n          const exports = exportList.get(value);\n          if (typeof exports !== 'undefined') {\n            const currentExport = exports.get(key);\n            if (typeof currentExport !== 'undefined') {\n              currentExport.whereUsed.delete(file);\n            }\n          }\n        }\n      });\n    };\n\n    return {\n      'Program:exit': node => {\n        updateExportUsage(node);\n        updateImportUsage(node);\n        checkExportPresence(node);\n      },\n      'ExportDefaultDeclaration': node => {\n        checkUsage(node, IMPORT_DEFAULT_SPECIFIER);\n      },\n      'ExportNamedDeclaration': node => {\n        node.specifiers.forEach(specifier => {\n          checkUsage(node, specifier.exported.name || specifier.exported.value);\n        });\n        forEachDeclarationIdentifier(node.declaration, (name) => {\n          checkUsage(node, name);\n        });\n      },\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"script"}