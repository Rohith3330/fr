{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nconst naming_convention_utils_1 = require(\"./naming-convention-utils\"); // This essentially mirrors ESLint's `camelcase` rule\n// note that that rule ignores leading and trailing underscores and only checks those in the middle of a variable name\n\n\nconst defaultCamelCaseAllTheThingsConfig = [{\n  selector: 'default',\n  format: ['camelCase'],\n  leadingUnderscore: 'allow',\n  trailingUnderscore: 'allow'\n}, {\n  selector: 'variable',\n  format: ['camelCase', 'UPPER_CASE'],\n  leadingUnderscore: 'allow',\n  trailingUnderscore: 'allow'\n}, {\n  selector: 'typeLike',\n  format: ['PascalCase']\n}];\nexports.default = util.createRule({\n  name: 'naming-convention',\n  meta: {\n    docs: {\n      description: 'Enforce naming conventions for everything across a codebase',\n      recommended: false,\n      // technically only requires type checking if the user uses \"type\" modifiers\n      requiresTypeChecking: true\n    },\n    type: 'suggestion',\n    messages: {\n      unexpectedUnderscore: '{{type}} name `{{name}}` must not have a {{position}} underscore.',\n      missingUnderscore: '{{type}} name `{{name}}` must have {{count}} {{position}} underscore(s).',\n      missingAffix: '{{type}} name `{{name}}` must have one of the following {{position}}es: {{affixes}}',\n      satisfyCustom: '{{type}} name `{{name}}` must {{regexMatch}} the RegExp: {{regex}}',\n      doesNotMatchFormat: '{{type}} name `{{name}}` must match one of the following formats: {{formats}}',\n      doesNotMatchFormatTrimmed: '{{type}} name `{{name}}` trimmed as `{{processedName}}` must match one of the following formats: {{formats}}'\n    },\n    schema: naming_convention_utils_1.SCHEMA\n  },\n  defaultOptions: defaultCamelCaseAllTheThingsConfig,\n\n  create(contextWithoutDefaults) {\n    const context = contextWithoutDefaults.options && contextWithoutDefaults.options.length > 0 ? contextWithoutDefaults : // only apply the defaults when the user provides no config\n    Object.setPrototypeOf({\n      options: defaultCamelCaseAllTheThingsConfig\n    }, contextWithoutDefaults);\n    const validators = (0, naming_convention_utils_1.parseOptions)(context); // getParserServices(context, false) -- dirty hack to work around the docs checker test...\n\n    const compilerOptions = util.getParserServices(context, true).program.getCompilerOptions();\n\n    function handleMember(validator, node, modifiers) {\n      if (!validator) {\n        return;\n      }\n\n      const key = node.key;\n\n      if (requiresQuoting(key, compilerOptions.target)) {\n        modifiers.add(naming_convention_utils_1.Modifiers.requiresQuotes);\n      }\n\n      validator(key, modifiers);\n    }\n\n    function getMemberModifiers(node) {\n      const modifiers = new Set();\n\n      if (node.accessibility) {\n        modifiers.add(naming_convention_utils_1.Modifiers[node.accessibility]);\n      } else {\n        modifiers.add(naming_convention_utils_1.Modifiers.public);\n      }\n\n      if (node.static) {\n        modifiers.add(naming_convention_utils_1.Modifiers.static);\n      }\n\n      if ('readonly' in node && node.readonly) {\n        modifiers.add(naming_convention_utils_1.Modifiers.readonly);\n      }\n\n      if (node.type === utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition || node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition) {\n        modifiers.add(naming_convention_utils_1.Modifiers.abstract);\n      }\n\n      return modifiers;\n    }\n\n    const unusedVariables = util.collectUnusedVariables(context);\n\n    function isUnused(name) {\n      let initialScope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : context.getScope();\n\n      var _a;\n\n      let variable = null;\n      let scope = initialScope;\n\n      while (scope) {\n        variable = (_a = scope.set.get(name)) !== null && _a !== void 0 ? _a : null;\n\n        if (variable) {\n          break;\n        }\n\n        scope = scope.upper;\n      }\n\n      if (!variable) {\n        return false;\n      }\n\n      return unusedVariables.has(variable);\n    }\n\n    function isDestructured(id) {\n      var _a, _b, _c;\n\n      return (// `const { x }`\n        // does not match `const { x: y }`\n        ((_a = id.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.Property && id.parent.shorthand || // `const { x = 2 }`\n        // does not match const `{ x: y = 2 }`\n        ((_b = id.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.AssignmentPattern && ((_c = id.parent.parent) === null || _c === void 0 ? void 0 : _c.type) === utils_1.AST_NODE_TYPES.Property && id.parent.parent.shorthand\n      );\n    }\n\n    return {\n      // #region variable\n      VariableDeclarator(node) {\n        const validator = validators.variable;\n\n        if (!validator) {\n          return;\n        }\n\n        const identifiers = getIdentifiersFromPattern(node.id);\n        const baseModifiers = new Set();\n        const parent = node.parent;\n\n        if ((parent === null || parent === void 0 ? void 0 : parent.type) === utils_1.AST_NODE_TYPES.VariableDeclaration) {\n          if (parent.kind === 'const') {\n            baseModifiers.add(naming_convention_utils_1.Modifiers.const);\n          }\n\n          if (isGlobal(context.getScope())) {\n            baseModifiers.add(naming_convention_utils_1.Modifiers.global);\n          }\n        }\n\n        identifiers.forEach(id => {\n          const modifiers = new Set(baseModifiers);\n\n          if (isDestructured(id)) {\n            modifiers.add(naming_convention_utils_1.Modifiers.destructured);\n          }\n\n          if (isExported(parent, id.name, context.getScope())) {\n            modifiers.add(naming_convention_utils_1.Modifiers.exported);\n          }\n\n          if (isUnused(id.name)) {\n            modifiers.add(naming_convention_utils_1.Modifiers.unused);\n          }\n\n          validator(id, modifiers);\n        });\n      },\n\n      // #endregion\n      // #region function\n      'FunctionDeclaration, TSDeclareFunction, FunctionExpression'(node) {\n        const validator = validators.function;\n\n        if (!validator || node.id === null) {\n          return;\n        }\n\n        const modifiers = new Set(); // functions create their own nested scope\n\n        const scope = context.getScope().upper;\n\n        if (isGlobal(scope)) {\n          modifiers.add(naming_convention_utils_1.Modifiers.global);\n        }\n\n        if (isExported(node, node.id.name, scope)) {\n          modifiers.add(naming_convention_utils_1.Modifiers.exported);\n        }\n\n        if (isUnused(node.id.name, scope)) {\n          modifiers.add(naming_convention_utils_1.Modifiers.unused);\n        }\n\n        validator(node.id, modifiers);\n      },\n\n      // #endregion function\n      // #region parameter\n      'FunctionDeclaration, TSDeclareFunction, TSEmptyBodyFunctionExpression, FunctionExpression, ArrowFunctionExpression'(node) {\n        const validator = validators.parameter;\n\n        if (!validator) {\n          return;\n        }\n\n        node.params.forEach(param => {\n          if (param.type === utils_1.AST_NODE_TYPES.TSParameterProperty) {\n            return;\n          }\n\n          const identifiers = getIdentifiersFromPattern(param);\n          identifiers.forEach(i => {\n            const modifiers = new Set();\n\n            if (isDestructured(i)) {\n              modifiers.add(naming_convention_utils_1.Modifiers.destructured);\n            }\n\n            if (isUnused(i.name)) {\n              modifiers.add(naming_convention_utils_1.Modifiers.unused);\n            }\n\n            validator(i, modifiers);\n          });\n        });\n      },\n\n      // #endregion parameter\n      // #region parameterProperty\n      TSParameterProperty(node) {\n        const validator = validators.parameterProperty;\n\n        if (!validator) {\n          return;\n        }\n\n        const modifiers = getMemberModifiers(node);\n        const identifiers = getIdentifiersFromPattern(node.parameter);\n        identifiers.forEach(i => {\n          validator(i, modifiers);\n        });\n      },\n\n      // #endregion parameterProperty\n      // #region property\n      ':not(ObjectPattern) > Property[computed = false][kind = \"init\"][value.type != \"ArrowFunctionExpression\"][value.type != \"FunctionExpression\"][value.type != \"TSEmptyBodyFunctionExpression\"]'(node) {\n        const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);\n        handleMember(validators.objectLiteralProperty, node, modifiers);\n      },\n\n      ':matches(PropertyDefinition, TSAbstractPropertyDefinition)[computed = false][value.type != \"ArrowFunctionExpression\"][value.type != \"FunctionExpression\"][value.type != \"TSEmptyBodyFunctionExpression\"]'(node) {\n        const modifiers = getMemberModifiers(node);\n        handleMember(validators.classProperty, node, modifiers);\n      },\n\n      'TSPropertySignature[computed = false]'(node) {\n        const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);\n\n        if (node.readonly) {\n          modifiers.add(naming_convention_utils_1.Modifiers.readonly);\n        }\n\n        handleMember(validators.typeProperty, node, modifiers);\n      },\n\n      // #endregion property\n      // #region method\n      [['Property[computed = false][kind = \"init\"][value.type = \"ArrowFunctionExpression\"]', 'Property[computed = false][kind = \"init\"][value.type = \"FunctionExpression\"]', 'Property[computed = false][kind = \"init\"][value.type = \"TSEmptyBodyFunctionExpression\"]'].join(', ')](node) {\n        const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);\n        handleMember(validators.objectLiteralMethod, node, modifiers);\n      },\n\n      [[':matches(PropertyDefinition, TSAbstractPropertyDefinition)[computed = false][value.type = \"ArrowFunctionExpression\"]', ':matches(PropertyDefinition, TSAbstractPropertyDefinition)[computed = false][value.type = \"FunctionExpression\"]', ':matches(PropertyDefinition, TSAbstractPropertyDefinition)[computed = false][value.type = \"TSEmptyBodyFunctionExpression\"]', ':matches(MethodDefinition, TSAbstractMethodDefinition)[computed = false][kind = \"method\"]'].join(', ')](node) {\n        const modifiers = getMemberModifiers(node);\n        handleMember(validators.classMethod, node, modifiers);\n      },\n\n      'TSMethodSignature[computed = false]'(node) {\n        const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);\n        handleMember(validators.typeMethod, node, modifiers);\n      },\n\n      // #endregion method\n      // #region accessor\n      'Property[computed = false]:matches([kind = \"get\"], [kind = \"set\"])'(node) {\n        const modifiers = new Set([naming_convention_utils_1.Modifiers.public]);\n        handleMember(validators.accessor, node, modifiers);\n      },\n\n      'MethodDefinition[computed = false]:matches([kind = \"get\"], [kind = \"set\"])'(node) {\n        const modifiers = getMemberModifiers(node);\n        handleMember(validators.accessor, node, modifiers);\n      },\n\n      // #endregion accessor\n      // #region enumMember\n      // computed is optional, so can't do [computed = false]\n      'TSEnumMember[computed != true]'(node) {\n        const validator = validators.enumMember;\n\n        if (!validator) {\n          return;\n        }\n\n        const id = node.id;\n        const modifiers = new Set();\n\n        if (requiresQuoting(id, compilerOptions.target)) {\n          modifiers.add(naming_convention_utils_1.Modifiers.requiresQuotes);\n        }\n\n        validator(id, modifiers);\n      },\n\n      // #endregion enumMember\n      // #region class\n      'ClassDeclaration, ClassExpression'(node) {\n        const validator = validators.class;\n\n        if (!validator) {\n          return;\n        }\n\n        const id = node.id;\n\n        if (id === null) {\n          return;\n        }\n\n        const modifiers = new Set(); // classes create their own nested scope\n\n        const scope = context.getScope().upper;\n\n        if (node.abstract) {\n          modifiers.add(naming_convention_utils_1.Modifiers.abstract);\n        }\n\n        if (isExported(node, id.name, scope)) {\n          modifiers.add(naming_convention_utils_1.Modifiers.exported);\n        }\n\n        if (isUnused(id.name, scope)) {\n          modifiers.add(naming_convention_utils_1.Modifiers.unused);\n        }\n\n        validator(id, modifiers);\n      },\n\n      // #endregion class\n      // #region interface\n      TSInterfaceDeclaration(node) {\n        const validator = validators.interface;\n\n        if (!validator) {\n          return;\n        }\n\n        const modifiers = new Set();\n        const scope = context.getScope();\n\n        if (isExported(node, node.id.name, scope)) {\n          modifiers.add(naming_convention_utils_1.Modifiers.exported);\n        }\n\n        if (isUnused(node.id.name, scope)) {\n          modifiers.add(naming_convention_utils_1.Modifiers.unused);\n        }\n\n        validator(node.id, modifiers);\n      },\n\n      // #endregion interface\n      // #region typeAlias\n      TSTypeAliasDeclaration(node) {\n        const validator = validators.typeAlias;\n\n        if (!validator) {\n          return;\n        }\n\n        const modifiers = new Set();\n        const scope = context.getScope();\n\n        if (isExported(node, node.id.name, scope)) {\n          modifiers.add(naming_convention_utils_1.Modifiers.exported);\n        }\n\n        if (isUnused(node.id.name, scope)) {\n          modifiers.add(naming_convention_utils_1.Modifiers.unused);\n        }\n\n        validator(node.id, modifiers);\n      },\n\n      // #endregion typeAlias\n      // #region enum\n      TSEnumDeclaration(node) {\n        const validator = validators.enum;\n\n        if (!validator) {\n          return;\n        }\n\n        const modifiers = new Set(); // enums create their own nested scope\n\n        const scope = context.getScope().upper;\n\n        if (isExported(node, node.id.name, scope)) {\n          modifiers.add(naming_convention_utils_1.Modifiers.exported);\n        }\n\n        if (isUnused(node.id.name, scope)) {\n          modifiers.add(naming_convention_utils_1.Modifiers.unused);\n        }\n\n        validator(node.id, modifiers);\n      },\n\n      // #endregion enum\n      // #region typeParameter\n      'TSTypeParameterDeclaration > TSTypeParameter'(node) {\n        const validator = validators.typeParameter;\n\n        if (!validator) {\n          return;\n        }\n\n        const modifiers = new Set();\n        const scope = context.getScope();\n\n        if (isUnused(node.name.name, scope)) {\n          modifiers.add(naming_convention_utils_1.Modifiers.unused);\n        }\n\n        validator(node.name, modifiers);\n      } // #endregion typeParameter\n\n\n    };\n  }\n\n});\n\nfunction getIdentifiersFromPattern(pattern) {\n  const identifiers = [];\n  const visitor = new scope_manager_1.PatternVisitor({}, pattern, id => identifiers.push(id));\n  visitor.visit(pattern);\n  return identifiers;\n}\n\nfunction isExported(node, name, scope) {\n  var _a, _b;\n\n  if (((_a = node === null || node === void 0 ? void 0 : node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration || ((_b = node === null || node === void 0 ? void 0 : node.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.ExportNamedDeclaration) {\n    return true;\n  }\n\n  if (scope == null) {\n    return false;\n  }\n\n  const variable = scope.set.get(name);\n\n  if (variable) {\n    for (const ref of variable.references) {\n      const refParent = ref.identifier.parent;\n\n      if ((refParent === null || refParent === void 0 ? void 0 : refParent.type) === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration || (refParent === null || refParent === void 0 ? void 0 : refParent.type) === utils_1.AST_NODE_TYPES.ExportSpecifier) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isGlobal(scope) {\n  if (scope == null) {\n    return false;\n  }\n\n  return scope.type === utils_1.TSESLint.Scope.ScopeType.global || scope.type === utils_1.TSESLint.Scope.ScopeType.module;\n}\n\nfunction requiresQuoting(node, target) {\n  const name = node.type === utils_1.AST_NODE_TYPES.Identifier || node.type === utils_1.AST_NODE_TYPES.PrivateIdentifier ? node.name : `${node.value}`;\n  return util.requiresQuoting(name, target);\n}","map":{"version":3,"mappings":"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","names":["defaultCamelCaseAllTheThingsConfig","selector","format","leadingUnderscore","trailingUnderscore","exports","util","createRule","name","meta","docs","description","recommended","requiresTypeChecking","type","messages","unexpectedUnderscore","missingUnderscore","missingAffix","satisfyCustom","doesNotMatchFormat","doesNotMatchFormatTrimmed","schema","naming_convention_utils_1","defaultOptions","create","contextWithoutDefaults","context","options","length","Object","setPrototypeOf","validators","compilerOptions","getParserServices","program","getCompilerOptions","handleMember","validator","node","modifiers","key","requiresQuoting","target","add","requiresQuotes","getMemberModifiers","Set","accessibility","public","static","readonly","utils_1","TSAbstractPropertyDefinition","TSAbstractMethodDefinition","abstract","unusedVariables","collectUnusedVariables","isUnused","initialScope","getScope","variable","scope","set","get","_a","upper","has","isDestructured","id","parent","Property","shorthand","_b","AssignmentPattern","_c","VariableDeclarator","identifiers","getIdentifiersFromPattern","baseModifiers","VariableDeclaration","kind","const","isGlobal","global","forEach","destructured","isExported","exported","unused","function","parameter","params","param","TSParameterProperty","i","parameterProperty","objectLiteralProperty","classProperty","typeProperty","join","objectLiteralMethod","classMethod","typeMethod","accessor","enumMember","class","TSInterfaceDeclaration","interface","TSTypeAliasDeclaration","typeAlias","TSEnumDeclaration","enum","typeParameter","pattern","visitor","scope_manager_1","push","visit","ExportDefaultDeclaration","ExportNamedDeclaration","ref","references","refParent","identifier","ExportSpecifier","Scope","ScopeType","module","Identifier","PrivateIdentifier","value"],"sources":["../../src/rules/naming-convention.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}