{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _ClassVisitor_classNode, _ClassVisitor_referencer, _ClassVisitor_emitDecoratorMetadata;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClassVisitor = void 0;\n\nconst types_1 = require(\"@typescript-eslint/types\");\n\nconst definition_1 = require(\"../definition\");\n\nconst TypeVisitor_1 = require(\"./TypeVisitor\");\n\nconst Visitor_1 = require(\"./Visitor\");\n\nclass ClassVisitor extends Visitor_1.Visitor {\n  constructor(referencer, node, emitDecoratorMetadata) {\n    super(referencer);\n\n    _ClassVisitor_classNode.set(this, void 0);\n\n    _ClassVisitor_referencer.set(this, void 0);\n\n    _ClassVisitor_emitDecoratorMetadata.set(this, void 0);\n\n    __classPrivateFieldSet(this, _ClassVisitor_referencer, referencer, \"f\");\n\n    __classPrivateFieldSet(this, _ClassVisitor_classNode, node, \"f\");\n\n    __classPrivateFieldSet(this, _ClassVisitor_emitDecoratorMetadata, emitDecoratorMetadata, \"f\");\n  }\n\n  static visit(referencer, node, emitDecoratorMetadata) {\n    const classVisitor = new ClassVisitor(referencer, node, emitDecoratorMetadata);\n    classVisitor.visitClass(node);\n  }\n\n  visit(node) {\n    // make sure we only handle the nodes we are designed to handle\n    if (node && node.type in this) {\n      super.visit(node);\n    } else {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node);\n    }\n  } ///////////////////\n  // Visit helpers //\n  ///////////////////\n\n\n  visitClass(node) {\n    var _a, _b;\n\n    if (node.type === types_1.AST_NODE_TYPES.ClassDeclaration && node.id) {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").currentScope().defineIdentifier(node.id, new definition_1.ClassNameDefinition(node.id, node));\n    }\n\n    (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.forEach(d => __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(d));\n\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestClassScope(node);\n\n    if (node.id) {\n      // define the class name again inside the new scope\n      // references to the class should not resolve directly to the parent class\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").currentScope().defineIdentifier(node.id, new definition_1.ClassNameDefinition(node.id, node));\n    }\n\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.superClass); // visit the type param declarations\n\n\n    this.visitType(node.typeParameters); // then the usages\n\n    this.visitType(node.superTypeParameters);\n    (_b = node.implements) === null || _b === void 0 ? void 0 : _b.forEach(imp => this.visitType(imp));\n    this.visit(node.body);\n\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").close(node);\n  }\n\n  visitPropertyDefinition(node) {\n    this.visitProperty(node);\n    /**\n     * class A {\n     *   @meta     // <--- check this\n     *   foo: Type;\n     * }\n     */\n\n    this.visitMetadataType(node.typeAnnotation, !!node.decorators);\n  }\n\n  visitFunctionParameterTypeAnnotation(node, withDecorators) {\n    if ('typeAnnotation' in node) {\n      this.visitMetadataType(node.typeAnnotation, withDecorators);\n    } else if (node.type === types_1.AST_NODE_TYPES.AssignmentPattern) {\n      this.visitMetadataType(node.left.typeAnnotation, withDecorators);\n    } else if (node.type === types_1.AST_NODE_TYPES.TSParameterProperty) {\n      this.visitFunctionParameterTypeAnnotation(node.parameter, withDecorators);\n    }\n  }\n\n  visitMethodFunction(node, methodNode) {\n    var _a, _b;\n\n    if (node.id) {\n      // FunctionExpression with name creates its special scope;\n      // FunctionExpressionNameScope.\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestFunctionExpressionNameScope(node);\n    } // Consider this function is in the MethodDefinition.\n\n\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestFunctionScope(node, true);\n    /**\n     * class A {\n     *   @meta     // <--- check this\n     *   foo(a: Type) {}\n     *\n     *   @meta     // <--- check this\n     *   foo(): Type {}\n     * }\n     */\n\n\n    let withMethodDecorators = !!methodNode.decorators;\n    /**\n     * class A {\n     *   foo(\n     *     @meta    // <--- check this\n     *     a: Type\n     *   ) {}\n     *\n     *   set foo(\n     *     @meta    // <--- EXCEPT this. TS do nothing for this\n     *     a: Type\n     *   ) {}\n     * }\n     */\n\n    withMethodDecorators = withMethodDecorators || methodNode.kind !== 'set' && node.params.some(param => param.decorators);\n\n    if (!withMethodDecorators && methodNode.kind === 'set') {\n      const keyName = getLiteralMethodKeyName(methodNode);\n      /**\n       * class A {\n       *   @meta      // <--- check this\n       *   get a() {}\n       *   set ['a'](v: Type) {}\n       * }\n       */\n\n      if (keyName !== null && ((_a = __classPrivateFieldGet(this, _ClassVisitor_classNode, \"f\").body.body.find(node => node !== methodNode && node.type === types_1.AST_NODE_TYPES.MethodDefinition && // Node must both be static or not\n      node.static === methodNode.static && getLiteralMethodKeyName(node) === keyName)) === null || _a === void 0 ? void 0 : _a.decorators)) {\n        withMethodDecorators = true;\n      }\n    }\n    /**\n     * @meta      // <--- check this\n     * class A {\n     *   constructor(a: Type) {}\n     * }\n     */\n\n\n    if (!withMethodDecorators && methodNode.kind === 'constructor' && __classPrivateFieldGet(this, _ClassVisitor_classNode, \"f\").decorators) {\n      withMethodDecorators = true;\n    } // Process parameter declarations.\n\n\n    for (const param of node.params) {\n      this.visitPattern(param, (pattern, info) => {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").currentScope().defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest));\n\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").referencingDefaultValue(pattern, info.assignments, null, true);\n      }, {\n        processRightHandNodes: true\n      });\n      this.visitFunctionParameterTypeAnnotation(param, withMethodDecorators);\n      (_b = param.decorators) === null || _b === void 0 ? void 0 : _b.forEach(d => this.visit(d));\n    }\n\n    this.visitMetadataType(node.returnType, withMethodDecorators);\n    this.visitType(node.typeParameters); // In TypeScript there are a number of function-like constructs which have no body,\n    // so check it exists before traversing\n\n    if (node.body) {\n      // Skip BlockStatement to prevent creating BlockStatement scope.\n      if (node.body.type === types_1.AST_NODE_TYPES.BlockStatement) {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visitChildren(node.body);\n      } else {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.body);\n      }\n    }\n\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").close(node);\n  }\n\n  visitProperty(node) {\n    var _a;\n\n    if (node.computed) {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.key);\n    }\n\n    if (node.value) {\n      if (node.type === types_1.AST_NODE_TYPES.PropertyDefinition) {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestClassFieldInitializerScope(node.value);\n      }\n\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.value);\n\n      if (node.type === types_1.AST_NODE_TYPES.PropertyDefinition) {\n        __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").close(node.value);\n      }\n    }\n\n    if ('decorators' in node) {\n      (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.forEach(d => __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(d));\n    }\n  }\n\n  visitMethod(node) {\n    var _a;\n\n    if (node.computed) {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.key);\n    }\n\n    if (node.value.type === types_1.AST_NODE_TYPES.FunctionExpression) {\n      this.visitMethodFunction(node.value, node);\n    } else {\n      __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node.value);\n    }\n\n    if ('decorators' in node) {\n      (_a = node.decorators) === null || _a === void 0 ? void 0 : _a.forEach(d => __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(d));\n    }\n  }\n\n  visitType(node) {\n    if (!node) {\n      return;\n    }\n\n    TypeVisitor_1.TypeVisitor.visit(__classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\"), node);\n  }\n\n  visitMetadataType(node, withDecorators) {\n    if (!node) {\n      return;\n    } // emit decorators metadata only work for TSTypeReference in ClassDeclaration\n\n\n    if (__classPrivateFieldGet(this, _ClassVisitor_classNode, \"f\").type === types_1.AST_NODE_TYPES.ClassDeclaration && !__classPrivateFieldGet(this, _ClassVisitor_classNode, \"f\").declare && node.typeAnnotation.type === types_1.AST_NODE_TYPES.TSTypeReference && __classPrivateFieldGet(this, _ClassVisitor_emitDecoratorMetadata, \"f\")) {\n      let entityName;\n\n      if (node.typeAnnotation.typeName.type === types_1.AST_NODE_TYPES.TSQualifiedName) {\n        let iter = node.typeAnnotation.typeName;\n\n        while (iter.left.type === types_1.AST_NODE_TYPES.TSQualifiedName) {\n          iter = iter.left;\n        }\n\n        entityName = iter.left;\n      } else {\n        entityName = node.typeAnnotation.typeName;\n      }\n\n      if (withDecorators) {\n        if (entityName.type === types_1.AST_NODE_TYPES.Identifier) {\n          __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").currentScope().referenceDualValueType(entityName);\n        }\n\n        if (node.typeAnnotation.typeParameters) {\n          this.visitType(node.typeAnnotation.typeParameters);\n        } // everything is handled now\n\n\n        return;\n      }\n    }\n\n    this.visitType(node);\n  } /////////////////////\n  // Visit selectors //\n  /////////////////////\n\n\n  ClassBody(node) {\n    // this is here on purpose so that this visitor explicitly declares visitors\n    // for all nodes it cares about (see the instance visit method above)\n    this.visitChildren(node);\n  }\n\n  PropertyDefinition(node) {\n    this.visitPropertyDefinition(node);\n  }\n\n  MethodDefinition(node) {\n    this.visitMethod(node);\n  }\n\n  TSAbstractPropertyDefinition(node) {\n    this.visitPropertyDefinition(node);\n  }\n\n  TSAbstractMethodDefinition(node) {\n    this.visitProperty(node);\n  }\n\n  Identifier(node) {\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").visit(node);\n  }\n\n  PrivateIdentifier() {// intentionally skip\n  }\n\n  StaticBlock(node) {\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").scopeManager.nestClassStaticBlockScope(node);\n\n    node.body.forEach(b => this.visit(b));\n\n    __classPrivateFieldGet(this, _ClassVisitor_referencer, \"f\").close(node);\n  }\n\n}\n\nexports.ClassVisitor = ClassVisitor;\n_ClassVisitor_classNode = new WeakMap(), _ClassVisitor_referencer = new WeakMap(), _ClassVisitor_emitDecoratorMetadata = new WeakMap();\n/**\n * Only if key is one of [identifier, string, number], ts will combine metadata of accessors .\n * class A {\n *   get a() {}\n *   set ['a'](v: Type) {}\n *\n *   get [1]() {}\n *   set [1](v: Type) {}\n *\n *   // Following won't be combined\n *   get [key]() {}\n *   set [key](v: Type) {}\n *\n *   get [true]() {}\n *   set [true](v: Type) {}\n *\n *   get ['a'+'b']() {}\n *   set ['a'+'b']() {}\n * }\n */\n\nfunction getLiteralMethodKeyName(node) {\n  if (node.computed && node.key.type === types_1.AST_NODE_TYPES.Literal) {\n    if (typeof node.key.value === 'string' || typeof node.key.value === 'number') {\n      return node.key.value;\n    }\n  } else if (!node.computed && node.key.type === types_1.AST_NODE_TYPES.Identifier) {\n    return node.key.name;\n  }\n\n  return null;\n}","map":{"version":3,"mappings":"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","names":["ClassVisitor","Visitor_1","constructor","referencer","node","emitDecoratorMetadata","_ClassVisitor_classNode","_ClassVisitor_referencer","_ClassVisitor_emitDecoratorMetadata","__classPrivateFieldSet","visit","classVisitor","visitClass","type","__classPrivateFieldGet","types_1","ClassDeclaration","id","currentScope","defineIdentifier","definition_1","decorators","_a","forEach","d","scopeManager","nestClassScope","superClass","visitType","typeParameters","superTypeParameters","implements","_b","imp","body","close","visitPropertyDefinition","visitProperty","visitMetadataType","typeAnnotation","visitFunctionParameterTypeAnnotation","withDecorators","AssignmentPattern","left","TSParameterProperty","parameter","visitMethodFunction","methodNode","nestFunctionExpressionNameScope","nestFunctionScope","withMethodDecorators","kind","params","some","param","keyName","getLiteralMethodKeyName","find","MethodDefinition","static","visitPattern","pattern","info","rest","referencingDefaultValue","assignments","processRightHandNodes","returnType","BlockStatement","visitChildren","computed","key","value","PropertyDefinition","nestClassFieldInitializerScope","visitMethod","FunctionExpression","TypeVisitor_1","declare","TSTypeReference","entityName","typeName","TSQualifiedName","iter","Identifier","referenceDualValueType","ClassBody","TSAbstractPropertyDefinition","TSAbstractMethodDefinition","PrivateIdentifier","StaticBlock","nestClassStaticBlockScope","b","exports","Literal","name"],"sources":["../../src/referencer/ClassVisitor.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}