{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _tdz = require(\"./tdz\");\n\nvar _core = require(\"@babel/core\");\n\nconst DONE = new WeakSet();\n\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const {\n    throwIfClosureRequired = false,\n    tdz: tdzEnabled = false\n  } = opts;\n\n  if (typeof throwIfClosureRequired !== \"boolean\") {\n    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);\n  }\n\n  if (typeof tdzEnabled !== \"boolean\") {\n    throw new Error(`.tdz must be a boolean, or undefined`);\n  }\n\n  return {\n    name: \"transform-block-scoping\",\n    visitor: {\n      VariableDeclaration(path) {\n        const {\n          node,\n          parent,\n          scope\n        } = path;\n        if (!isBlockScoped(node)) return;\n        convertBlockScopedToVar(path, null, parent, scope, true);\n\n        if (node._tdzThis) {\n          const nodes = [node];\n\n          for (let i = 0; i < node.declarations.length; i++) {\n            const decl = node.declarations[i];\n\n            const assign = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(decl.id), decl.init || scope.buildUndefinedNode());\n\n            assign._ignoreBlockScopingTDZ = true;\n            nodes.push(_core.types.expressionStatement(assign));\n            decl.init = this.addHelper(\"temporalUndefined\");\n          }\n\n          node._blockHoist = 2;\n\n          if (path.isCompletionRecord()) {\n            nodes.push(_core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      Loop(path, state) {\n        const {\n          parent,\n          scope\n        } = path;\n        path.ensureBlock();\n        const blockScoping = new BlockScoping(path, path.get(\"body\"), parent, scope, throwIfClosureRequired, tdzEnabled, state);\n        const replace = blockScoping.run();\n        if (replace) path.replaceWith(replace);\n      },\n\n      CatchClause(path, state) {\n        const {\n          parent,\n          scope\n        } = path;\n        const blockScoping = new BlockScoping(null, path.get(\"body\"), parent, scope, throwIfClosureRequired, tdzEnabled, state);\n        blockScoping.run();\n      },\n\n      \"BlockStatement|SwitchStatement|Program\"(path, state) {\n        if (!ignoreBlock(path)) {\n          const blockScoping = new BlockScoping(null, path, path.parent, path.scope, throwIfClosureRequired, tdzEnabled, state);\n          blockScoping.run();\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;\n\nfunction ignoreBlock(path) {\n  return _core.types.isLoop(path.parent) || _core.types.isCatchClause(path.parent);\n}\n\nconst buildRetCheck = _core.template.statement(`\n  if (typeof RETURN === \"object\") return RETURN.v;\n`);\n\nfunction isBlockScoped(node) {\n  if (!_core.types.isVariableDeclaration(node)) return false;\n\n  if (node[_core.types.BLOCK_SCOPED_SYMBOL]) {\n    return true;\n  }\n\n  if (node.kind !== \"let\" && node.kind !== \"const\") return false;\n  return true;\n}\n\nfunction isInLoop(path) {\n  const loopOrFunctionParent = path.find(path => path.isLoop() || path.isFunction());\n  return loopOrFunctionParent == null ? void 0 : loopOrFunctionParent.isLoop();\n}\n\nfunction convertBlockScopedToVar(path, node, parent, scope) {\n  let moveBindingsToParent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  if (!node) {\n    node = path.node;\n  }\n\n  if (isInLoop(path) && !_core.types.isFor(parent)) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      declar.init = declar.init || scope.buildUndefinedNode();\n    }\n  }\n\n  node[_core.types.BLOCK_SCOPED_SYMBOL] = true;\n  node.kind = \"var\";\n\n  if (moveBindingsToParent) {\n    const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n\n    for (const name of Object.keys(path.getBindingIdentifiers())) {\n      const binding = scope.getOwnBinding(name);\n      if (binding) binding.kind = \"var\";\n      scope.moveBindingTo(name, parentScope);\n    }\n  }\n}\n\nfunction isVar(node) {\n  return _core.types.isVariableDeclaration(node, {\n    kind: \"var\"\n  }) && !isBlockScoped(node);\n}\n\nconst letReferenceBlockVisitor = _core.traverse.visitors.merge([{\n  Loop: {\n    enter(path, state) {\n      state.loopDepth++;\n    },\n\n    exit(path, state) {\n      state.loopDepth--;\n    }\n\n  },\n\n  FunctionParent(path, state) {\n    if (state.loopDepth > 0) {\n      path.traverse(letReferenceFunctionVisitor, state);\n    } else {\n      path.traverse(_tdz.visitor, state);\n    }\n\n    return path.skip();\n  }\n\n}, _tdz.visitor]);\n\nconst letReferenceFunctionVisitor = _core.traverse.visitors.merge([{\n  ReferencedIdentifier(path, state) {\n    const ref = state.letReferences.get(path.node.name);\n    if (!ref) return;\n    const localBinding = path.scope.getBindingIdentifier(path.node.name);\n    if (localBinding && localBinding !== ref) return;\n    state.closurify = true;\n  }\n\n}, _tdz.visitor]);\n\nconst hoistVarDeclarationsVisitor = {\n  enter(path, self) {\n    if (path.isForStatement()) {\n      const {\n        node\n      } = path;\n\n      if (isVar(node.init)) {\n        const nodes = self.pushDeclar(node.init);\n\n        if (nodes.length === 1) {\n          node.init = nodes[0];\n        } else {\n          node.init = _core.types.sequenceExpression(nodes);\n        }\n      }\n    } else if (path.isForInStatement() || path.isForOfStatement()) {\n      const {\n        node\n      } = path;\n\n      if (isVar(node.left)) {\n        self.pushDeclar(node.left);\n        node.left = node.left.declarations[0].id;\n      }\n    } else if (isVar(path.node)) {\n      path.replaceWithMultiple(self.pushDeclar(path.node).map(expr => _core.types.expressionStatement(expr)));\n    } else if (path.isFunction()) {\n      return path.skip();\n    }\n  }\n\n};\nconst loopLabelVisitor = {\n  LabeledStatement(_ref, state) {\n    let {\n      node\n    } = _ref;\n    state.innerLabels.push(node.label.name);\n  }\n\n};\nconst continuationVisitor = {\n  enter(path, state) {\n    if (path.isAssignmentExpression() || path.isUpdateExpression()) {\n      for (const name of Object.keys(path.getBindingIdentifiers())) {\n        if (state.outsideReferences.get(name) !== path.scope.getBindingIdentifier(name)) {\n          continue;\n        }\n\n        state.reassignments[name] = true;\n      }\n    } else if (path.isReturnStatement()) {\n      state.returnStatements.push(path);\n    }\n  }\n\n};\n\nfunction loopNodeTo(node) {\n  if (_core.types.isBreakStatement(node)) {\n    return \"break\";\n  } else if (_core.types.isContinueStatement(node)) {\n    return \"continue\";\n  }\n}\n\nconst loopVisitor = {\n  Loop(path, state) {\n    const oldIgnoreLabeless = state.ignoreLabeless;\n    state.ignoreLabeless = true;\n    path.traverse(loopVisitor, state);\n    state.ignoreLabeless = oldIgnoreLabeless;\n    path.skip();\n  },\n\n  Function(path) {\n    path.skip();\n  },\n\n  SwitchCase(path, state) {\n    const oldInSwitchCase = state.inSwitchCase;\n    state.inSwitchCase = true;\n    path.traverse(loopVisitor, state);\n    state.inSwitchCase = oldInSwitchCase;\n    path.skip();\n  },\n\n  \"BreakStatement|ContinueStatement|ReturnStatement\"(path, state) {\n    const {\n      node,\n      scope\n    } = path;\n    if (state.loopIgnored.has(node)) return;\n    let replace;\n    let loopText = loopNodeTo(node);\n\n    if (loopText) {\n      if (_core.types.isReturnStatement(node)) {\n        throw new Error(\"Internal error: unexpected return statement with `loopText`\");\n      }\n\n      if (node.label) {\n        if (state.innerLabels.indexOf(node.label.name) >= 0) {\n          return;\n        }\n\n        loopText = `${loopText}|${node.label.name}`;\n      } else {\n        if (state.ignoreLabeless) return;\n        if (_core.types.isBreakStatement(node) && state.inSwitchCase) return;\n      }\n\n      state.hasBreakContinue = true;\n      state.map.set(loopText, node);\n      replace = _core.types.stringLiteral(loopText);\n    }\n\n    if (_core.types.isReturnStatement(node)) {\n      state.hasReturn = true;\n      replace = _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier(\"v\"), node.argument || scope.buildUndefinedNode())]);\n    }\n\n    if (replace) {\n      replace = _core.types.returnStatement(replace);\n      state.loopIgnored.add(replace);\n      path.skip();\n      path.replaceWith(_core.types.inherits(replace, node));\n    }\n  }\n\n};\n\nfunction isStrict(path) {\n  return !!path.find(_ref2 => {\n    let {\n      node\n    } = _ref2;\n\n    if (_core.types.isProgram(node)) {\n      if (node.sourceType === \"module\") return true;\n    } else if (!_core.types.isBlockStatement(node)) return false;\n\n    return node.directives.some(directive => directive.value.value === \"use strict\");\n  });\n}\n\nclass BlockScoping {\n  constructor(loopPath, blockPath, parent, scope, throwIfClosureRequired, tdzEnabled, state) {\n    this.parent = void 0;\n    this.state = void 0;\n    this.scope = void 0;\n    this.throwIfClosureRequired = void 0;\n    this.tdzEnabled = void 0;\n    this.blockPath = void 0;\n    this.block = void 0;\n    this.outsideLetReferences = void 0;\n    this.hasLetReferences = void 0;\n    this.letReferences = void 0;\n    this.body = void 0;\n    this.loopParent = void 0;\n    this.loopLabel = void 0;\n    this.loopPath = void 0;\n    this.loop = void 0;\n    this.has = void 0;\n    this.parent = parent;\n    this.scope = scope;\n    this.state = state;\n    this.throwIfClosureRequired = throwIfClosureRequired;\n    this.tdzEnabled = tdzEnabled;\n    this.blockPath = blockPath;\n    this.block = blockPath.node;\n    this.outsideLetReferences = new Map();\n    this.hasLetReferences = false;\n    this.letReferences = new Map();\n    this.body = [];\n\n    if (loopPath) {\n      this.loopParent = loopPath.parent;\n      this.loopLabel = _core.types.isLabeledStatement(this.loopParent) && this.loopParent.label;\n      this.loopPath = loopPath;\n      this.loop = loopPath.node;\n    }\n  }\n\n  run() {\n    const block = this.block;\n    if (DONE.has(block)) return;\n    DONE.add(block);\n    const needsClosure = this.getLetReferences();\n    this.checkConstants();\n\n    if (_core.types.isFunction(this.parent) || _core.types.isProgram(this.block)) {\n      this.updateScopeInfo();\n      return;\n    }\n\n    if (!this.hasLetReferences) return;\n\n    if (needsClosure) {\n      this.wrapClosure();\n    } else {\n      this.remap();\n    }\n\n    this.updateScopeInfo(needsClosure);\n\n    if (this.loopLabel && !_core.types.isLabeledStatement(this.loopParent)) {\n      return _core.types.labeledStatement(this.loopLabel, this.loop);\n    }\n  }\n\n  checkConstants() {\n    const scope = this.scope;\n    const state = this.state;\n\n    for (const name of Object.keys(scope.bindings)) {\n      const binding = scope.bindings[name];\n      if (binding.kind !== \"const\") continue;\n\n      for (const violation of binding.constantViolations) {\n        const readOnlyError = state.addHelper(\"readOnlyError\");\n\n        const throwNode = _core.types.callExpression(readOnlyError, [_core.types.stringLiteral(name)]);\n\n        if (violation.isAssignmentExpression()) {\n          const {\n            operator\n          } = violation.node;\n\n          if (operator === \"=\") {\n            violation.replaceWith(_core.types.sequenceExpression([violation.get(\"right\").node, throwNode]));\n          } else if ([\"&&=\", \"||=\", \"??=\"].includes(operator)) {\n            violation.replaceWith(_core.types.logicalExpression(operator.slice(0, -1), violation.get(\"left\").node, _core.types.sequenceExpression([violation.get(\"right\").node, throwNode])));\n          } else {\n            violation.replaceWith(_core.types.sequenceExpression([_core.types.binaryExpression(operator.slice(0, -1), violation.get(\"left\").node, violation.get(\"right\").node), throwNode]));\n          }\n        } else if (violation.isUpdateExpression()) {\n          violation.replaceWith(_core.types.sequenceExpression([_core.types.unaryExpression(\"+\", violation.get(\"argument\").node), throwNode]));\n        } else if (violation.isForXStatement()) {\n          violation.ensureBlock();\n          violation.get(\"left\").replaceWith(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(violation.scope.generateUidIdentifier(name))]));\n          violation.node.body.body.unshift(_core.types.expressionStatement(throwNode));\n        }\n      }\n    }\n  }\n\n  updateScopeInfo(wrappedInClosure) {\n    const blockScope = this.blockPath.scope;\n    const parentScope = blockScope.getFunctionParent() || blockScope.getProgramParent();\n    const letRefs = this.letReferences;\n\n    for (const key of letRefs.keys()) {\n      const ref = letRefs.get(key);\n      const binding = blockScope.getBinding(ref.name);\n      if (!binding) continue;\n\n      if (binding.kind === \"let\" || binding.kind === \"const\") {\n        binding.kind = \"var\";\n\n        if (wrappedInClosure) {\n          if (blockScope.hasOwnBinding(ref.name)) {\n            blockScope.removeBinding(ref.name);\n          }\n        } else {\n          blockScope.moveBindingTo(ref.name, parentScope);\n        }\n      }\n    }\n  }\n\n  remap() {\n    const letRefs = this.letReferences;\n    const outsideLetRefs = this.outsideLetReferences;\n    const scope = this.scope;\n    const blockPathScope = this.blockPath.scope;\n\n    for (const key of letRefs.keys()) {\n      const ref = letRefs.get(key);\n\n      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {\n        const binding = scope.getOwnBinding(key);\n\n        if (binding) {\n          const parentBinding = scope.parent.getOwnBinding(key);\n\n          if (binding.kind === \"hoisted\" && !binding.path.node.async && !binding.path.node.generator && (!parentBinding || isVar(parentBinding.path.parent)) && !isStrict(binding.path.parentPath)) {\n            continue;\n          }\n\n          scope.rename(ref.name);\n        }\n\n        if (blockPathScope.hasOwnBinding(key)) {\n          blockPathScope.rename(ref.name);\n        }\n      }\n    }\n\n    for (const key of outsideLetRefs.keys()) {\n      const ref = letRefs.get(key);\n\n      if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(key)) {\n        blockPathScope.rename(ref.name);\n      }\n    }\n  }\n\n  wrapClosure() {\n    if (this.throwIfClosureRequired) {\n      throw this.blockPath.buildCodeFrameError(\"Compiling let/const in this block would add a closure \" + \"(throwIfClosureRequired).\");\n    }\n\n    const block = this.block;\n    const outsideRefs = this.outsideLetReferences;\n\n    if (this.loop) {\n      for (const name of Array.from(outsideRefs.keys())) {\n        const id = outsideRefs.get(name);\n\n        if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {\n          outsideRefs.delete(id.name);\n          this.letReferences.delete(id.name);\n          this.scope.rename(id.name);\n          this.letReferences.set(id.name, id);\n          outsideRefs.set(id.name, id);\n        }\n      }\n    }\n\n    this.has = this.checkLoop();\n    this.hoistVarDeclarations();\n    const args = Array.from(outsideRefs.values(), node => _core.types.cloneNode(node));\n    const params = args.map(id => _core.types.cloneNode(id));\n    const isSwitch = block.type === \"SwitchStatement\";\n\n    const fn = _core.types.functionExpression(null, params, _core.types.blockStatement(isSwitch ? [block] : block.body));\n\n    this.addContinuations(fn);\n\n    let call = _core.types.callExpression(_core.types.nullLiteral(), args);\n\n    let basePath = \".callee\";\n\n    const hasYield = _core.traverse.hasType(fn.body, \"YieldExpression\", _core.types.FUNCTION_TYPES);\n\n    if (hasYield) {\n      fn.generator = true;\n      call = _core.types.yieldExpression(call, true);\n      basePath = \".argument\" + basePath;\n    }\n\n    const hasAsync = _core.traverse.hasType(fn.body, \"AwaitExpression\", _core.types.FUNCTION_TYPES);\n\n    if (hasAsync) {\n      fn.async = true;\n      call = _core.types.awaitExpression(call);\n      basePath = \".argument\" + basePath;\n    }\n\n    let placeholderPath;\n    let index;\n\n    if (this.has.hasReturn || this.has.hasBreakContinue) {\n      const ret = this.scope.generateUid(\"ret\");\n      this.body.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(ret), call)]));\n      placeholderPath = \"declarations.0.init\" + basePath;\n      index = this.body.length - 1;\n      this.buildHas(ret);\n    } else {\n      this.body.push(_core.types.expressionStatement(call));\n      placeholderPath = \"expression\" + basePath;\n      index = this.body.length - 1;\n    }\n\n    let callPath;\n\n    if (isSwitch) {\n      const {\n        parentPath,\n        listKey,\n        key\n      } = this.blockPath;\n      this.blockPath.replaceWithMultiple(this.body);\n      callPath = parentPath.get(listKey)[key + index];\n    } else {\n      block.body = this.body;\n      callPath = this.blockPath.get(\"body\")[index];\n    }\n\n    const placeholder = callPath.get(placeholderPath);\n    let fnPath;\n\n    if (this.loop) {\n      const loopId = this.scope.generateUid(\"loop\");\n      const p = this.loopPath.insertBefore(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(loopId), fn)]));\n      placeholder.replaceWith(_core.types.identifier(loopId));\n      fnPath = p[0].get(\"declarations.0.init\");\n    } else {\n      placeholder.replaceWith(fn);\n      fnPath = placeholder;\n    }\n\n    fnPath.unwrapFunctionEnvironment();\n  }\n\n  addContinuations(fn) {\n    const state = {\n      reassignments: {},\n      returnStatements: [],\n      outsideReferences: this.outsideLetReferences\n    };\n    this.scope.traverse(fn, continuationVisitor, state);\n\n    for (let i = 0; i < fn.params.length; i++) {\n      const param = fn.params[i];\n      if (!state.reassignments[param.name]) continue;\n      const paramName = param.name;\n      const newParamName = this.scope.generateUid(param.name);\n      fn.params[i] = _core.types.identifier(newParamName);\n      this.scope.rename(paramName, newParamName, fn);\n      state.returnStatements.forEach(returnStatement => {\n        returnStatement.insertBefore(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(paramName), _core.types.identifier(newParamName))));\n      });\n      fn.body.body.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(paramName), _core.types.identifier(newParamName))));\n    }\n  }\n\n  getLetReferences() {\n    const block = this.block;\n    const declarators = [];\n\n    if (this.loop) {\n      const init = this.loop.left || this.loop.init;\n\n      if (isBlockScoped(init)) {\n        declarators.push(init);\n\n        const names = _core.types.getBindingIdentifiers(init);\n\n        for (const name of Object.keys(names)) {\n          this.outsideLetReferences.set(name, names[name]);\n        }\n      }\n    }\n\n    const addDeclarationsFromChild = (path, node) => {\n      if (_core.types.isClassDeclaration(node) || _core.types.isFunctionDeclaration(node) || isBlockScoped(node)) {\n        if (isBlockScoped(node)) {\n          convertBlockScopedToVar(path, node, block, this.scope);\n        }\n\n        if (node.type === \"VariableDeclaration\") {\n          for (let i = 0; i < node.declarations.length; i++) {\n            declarators.push(node.declarations[i]);\n          }\n        } else {\n          declarators.push(node);\n        }\n      }\n\n      if (_core.types.isLabeledStatement(node)) {\n        addDeclarationsFromChild(path.get(\"body\"), node.body);\n      }\n    };\n\n    if (block.type === \"SwitchStatement\") {\n      const declarPaths = this.blockPath.get(\"cases\");\n\n      for (let i = 0; i < block.cases.length; i++) {\n        const consequents = block.cases[i].consequent;\n\n        for (let j = 0; j < consequents.length; j++) {\n          const declar = consequents[j];\n          addDeclarationsFromChild(declarPaths[i], declar);\n        }\n      }\n    } else {\n      const declarPaths = this.blockPath.get(\"body\");\n\n      for (let i = 0; i < block.body.length; i++) {\n        addDeclarationsFromChild(declarPaths[i], declarPaths[i].node);\n      }\n    }\n\n    for (let i = 0; i < declarators.length; i++) {\n      const declar = declarators[i];\n\n      const keys = _core.types.getBindingIdentifiers(declar, false, true);\n\n      for (const key of Object.keys(keys)) {\n        this.letReferences.set(key, keys[key]);\n      }\n\n      this.hasLetReferences = true;\n    }\n\n    if (!this.hasLetReferences) return;\n    const state = {\n      letReferences: this.letReferences,\n      closurify: false,\n      loopDepth: 0,\n      tdzEnabled: this.tdzEnabled,\n      addHelper: name => this.state.addHelper(name)\n    };\n\n    if (isInLoop(this.blockPath)) {\n      state.loopDepth++;\n    }\n\n    this.blockPath.traverse(letReferenceBlockVisitor, state);\n    return state.closurify;\n  }\n\n  checkLoop() {\n    const state = {\n      hasBreakContinue: false,\n      ignoreLabeless: false,\n      inSwitchCase: false,\n      innerLabels: [],\n      hasReturn: false,\n      isLoop: !!this.loop,\n      map: new Map(),\n      loopIgnored: new WeakSet()\n    };\n    this.blockPath.traverse(loopLabelVisitor, state);\n    this.blockPath.traverse(loopVisitor, state);\n    return state;\n  }\n\n  hoistVarDeclarations() {\n    this.blockPath.traverse(hoistVarDeclarationsVisitor, this);\n  }\n\n  pushDeclar(node) {\n    const declars = [];\n\n    const names = _core.types.getBindingIdentifiers(node);\n\n    for (const name of Object.keys(names)) {\n      declars.push(_core.types.variableDeclarator(names[name]));\n    }\n\n    this.body.push(_core.types.variableDeclaration(node.kind, declars));\n    const replace = [];\n\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      if (!declar.init) continue;\n\n      const expr = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(declar.id), _core.types.cloneNode(declar.init));\n\n      replace.push(_core.types.inherits(expr, declar));\n    }\n\n    return replace;\n  }\n\n  buildHas(ret) {\n    const body = this.body;\n    const has = this.has;\n\n    if (has.hasBreakContinue) {\n      for (const key of has.map.keys()) {\n        body.push(_core.types.ifStatement(_core.types.binaryExpression(\"===\", _core.types.identifier(ret), _core.types.stringLiteral(key)), has.map.get(key)));\n      }\n    }\n\n    if (has.hasReturn) {\n      body.push(buildRetCheck({\n        RETURN: _core.types.identifier(ret)\n      }));\n    }\n  }\n\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_tdz","_core","DONE","WeakSet","_default","declare","api","opts","assertVersion","throwIfClosureRequired","tdz","tdzEnabled","Error","name","visitor","VariableDeclaration","path","node","parent","scope","isBlockScoped","convertBlockScopedToVar","_tdzThis","nodes","i","declarations","length","decl","assign","types","assignmentExpression","cloneNode","id","init","buildUndefinedNode","_ignoreBlockScopingTDZ","push","expressionStatement","addHelper","_blockHoist","isCompletionRecord","replaceWithMultiple","Loop","state","ensureBlock","blockScoping","BlockScoping","get","replace","run","replaceWith","CatchClause","ignoreBlock","isLoop","isCatchClause","buildRetCheck","template","statement","isVariableDeclaration","BLOCK_SCOPED_SYMBOL","kind","isInLoop","loopOrFunctionParent","find","isFunction","moveBindingsToParent","isFor","declar","parentScope","getFunctionParent","getProgramParent","keys","getBindingIdentifiers","binding","getOwnBinding","moveBindingTo","isVar","letReferenceBlockVisitor","traverse","visitors","merge","enter","loopDepth","exit","FunctionParent","letReferenceFunctionVisitor","skip","ReferencedIdentifier","ref","letReferences","localBinding","getBindingIdentifier","closurify","hoistVarDeclarationsVisitor","self","isForStatement","pushDeclar","sequenceExpression","isForInStatement","isForOfStatement","left","map","expr","loopLabelVisitor","LabeledStatement","innerLabels","label","continuationVisitor","isAssignmentExpression","isUpdateExpression","outsideReferences","reassignments","isReturnStatement","returnStatements","loopNodeTo","isBreakStatement","isContinueStatement","loopVisitor","oldIgnoreLabeless","ignoreLabeless","Function","SwitchCase","oldInSwitchCase","inSwitchCase","loopIgnored","has","loopText","indexOf","hasBreakContinue","set","stringLiteral","hasReturn","objectExpression","objectProperty","identifier","argument","returnStatement","add","inherits","isStrict","isProgram","sourceType","isBlockStatement","directives","some","directive","constructor","loopPath","blockPath","block","outsideLetReferences","hasLetReferences","body","loopParent","loopLabel","loop","Map","isLabeledStatement","needsClosure","getLetReferences","checkConstants","updateScopeInfo","wrapClosure","remap","labeledStatement","bindings","violation","constantViolations","readOnlyError","throwNode","callExpression","operator","includes","logicalExpression","slice","binaryExpression","unaryExpression","isForXStatement","variableDeclaration","variableDeclarator","generateUidIdentifier","unshift","wrappedInClosure","blockScope","letRefs","key","getBinding","hasOwnBinding","removeBinding","outsideLetRefs","blockPathScope","parentHasBinding","hasGlobal","parentBinding","async","generator","parentPath","rename","buildCodeFrameError","outsideRefs","Array","from","delete","checkLoop","hoistVarDeclarations","args","values","params","isSwitch","type","fn","functionExpression","blockStatement","addContinuations","call","nullLiteral","basePath","hasYield","hasType","FUNCTION_TYPES","yieldExpression","hasAsync","awaitExpression","placeholderPath","index","ret","generateUid","buildHas","callPath","listKey","placeholder","fnPath","loopId","p","insertBefore","unwrapFunctionEnvironment","param","paramName","newParamName","forEach","declarators","names","addDeclarationsFromChild","isClassDeclaration","isFunctionDeclaration","declarPaths","cases","consequents","consequent","j","declars","ifStatement","RETURN"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/plugin-transform-block-scoping/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _tdz = require(\"./tdz\");\n\nvar _core = require(\"@babel/core\");\n\nconst DONE = new WeakSet();\n\nvar _default = (0, _helperPluginUtils.declare)((api, opts) => {\n  api.assertVersion(7);\n  const {\n    throwIfClosureRequired = false,\n    tdz: tdzEnabled = false\n  } = opts;\n\n  if (typeof throwIfClosureRequired !== \"boolean\") {\n    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);\n  }\n\n  if (typeof tdzEnabled !== \"boolean\") {\n    throw new Error(`.tdz must be a boolean, or undefined`);\n  }\n\n  return {\n    name: \"transform-block-scoping\",\n    visitor: {\n      VariableDeclaration(path) {\n        const {\n          node,\n          parent,\n          scope\n        } = path;\n        if (!isBlockScoped(node)) return;\n        convertBlockScopedToVar(path, null, parent, scope, true);\n\n        if (node._tdzThis) {\n          const nodes = [node];\n\n          for (let i = 0; i < node.declarations.length; i++) {\n            const decl = node.declarations[i];\n\n            const assign = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(decl.id), decl.init || scope.buildUndefinedNode());\n\n            assign._ignoreBlockScopingTDZ = true;\n            nodes.push(_core.types.expressionStatement(assign));\n            decl.init = this.addHelper(\"temporalUndefined\");\n          }\n\n          node._blockHoist = 2;\n\n          if (path.isCompletionRecord()) {\n            nodes.push(_core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      Loop(path, state) {\n        const {\n          parent,\n          scope\n        } = path;\n        path.ensureBlock();\n        const blockScoping = new BlockScoping(path, path.get(\"body\"), parent, scope, throwIfClosureRequired, tdzEnabled, state);\n        const replace = blockScoping.run();\n        if (replace) path.replaceWith(replace);\n      },\n\n      CatchClause(path, state) {\n        const {\n          parent,\n          scope\n        } = path;\n        const blockScoping = new BlockScoping(null, path.get(\"body\"), parent, scope, throwIfClosureRequired, tdzEnabled, state);\n        blockScoping.run();\n      },\n\n      \"BlockStatement|SwitchStatement|Program\"(path, state) {\n        if (!ignoreBlock(path)) {\n          const blockScoping = new BlockScoping(null, path, path.parent, path.scope, throwIfClosureRequired, tdzEnabled, state);\n          blockScoping.run();\n        }\n      }\n\n    }\n  };\n});\n\nexports.default = _default;\n\nfunction ignoreBlock(path) {\n  return _core.types.isLoop(path.parent) || _core.types.isCatchClause(path.parent);\n}\n\nconst buildRetCheck = _core.template.statement(`\n  if (typeof RETURN === \"object\") return RETURN.v;\n`);\n\nfunction isBlockScoped(node) {\n  if (!_core.types.isVariableDeclaration(node)) return false;\n\n  if (node[_core.types.BLOCK_SCOPED_SYMBOL]) {\n    return true;\n  }\n\n  if (node.kind !== \"let\" && node.kind !== \"const\") return false;\n  return true;\n}\n\nfunction isInLoop(path) {\n  const loopOrFunctionParent = path.find(path => path.isLoop() || path.isFunction());\n  return loopOrFunctionParent == null ? void 0 : loopOrFunctionParent.isLoop();\n}\n\nfunction convertBlockScopedToVar(path, node, parent, scope, moveBindingsToParent = false) {\n  if (!node) {\n    node = path.node;\n  }\n\n  if (isInLoop(path) && !_core.types.isFor(parent)) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      declar.init = declar.init || scope.buildUndefinedNode();\n    }\n  }\n\n  node[_core.types.BLOCK_SCOPED_SYMBOL] = true;\n  node.kind = \"var\";\n\n  if (moveBindingsToParent) {\n    const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n\n    for (const name of Object.keys(path.getBindingIdentifiers())) {\n      const binding = scope.getOwnBinding(name);\n      if (binding) binding.kind = \"var\";\n      scope.moveBindingTo(name, parentScope);\n    }\n  }\n}\n\nfunction isVar(node) {\n  return _core.types.isVariableDeclaration(node, {\n    kind: \"var\"\n  }) && !isBlockScoped(node);\n}\n\nconst letReferenceBlockVisitor = _core.traverse.visitors.merge([{\n  Loop: {\n    enter(path, state) {\n      state.loopDepth++;\n    },\n\n    exit(path, state) {\n      state.loopDepth--;\n    }\n\n  },\n\n  FunctionParent(path, state) {\n    if (state.loopDepth > 0) {\n      path.traverse(letReferenceFunctionVisitor, state);\n    } else {\n      path.traverse(_tdz.visitor, state);\n    }\n\n    return path.skip();\n  }\n\n}, _tdz.visitor]);\n\nconst letReferenceFunctionVisitor = _core.traverse.visitors.merge([{\n  ReferencedIdentifier(path, state) {\n    const ref = state.letReferences.get(path.node.name);\n    if (!ref) return;\n    const localBinding = path.scope.getBindingIdentifier(path.node.name);\n    if (localBinding && localBinding !== ref) return;\n    state.closurify = true;\n  }\n\n}, _tdz.visitor]);\n\nconst hoistVarDeclarationsVisitor = {\n  enter(path, self) {\n    if (path.isForStatement()) {\n      const {\n        node\n      } = path;\n\n      if (isVar(node.init)) {\n        const nodes = self.pushDeclar(node.init);\n\n        if (nodes.length === 1) {\n          node.init = nodes[0];\n        } else {\n          node.init = _core.types.sequenceExpression(nodes);\n        }\n      }\n    } else if (path.isForInStatement() || path.isForOfStatement()) {\n      const {\n        node\n      } = path;\n\n      if (isVar(node.left)) {\n        self.pushDeclar(node.left);\n        node.left = node.left.declarations[0].id;\n      }\n    } else if (isVar(path.node)) {\n      path.replaceWithMultiple(self.pushDeclar(path.node).map(expr => _core.types.expressionStatement(expr)));\n    } else if (path.isFunction()) {\n      return path.skip();\n    }\n  }\n\n};\nconst loopLabelVisitor = {\n  LabeledStatement({\n    node\n  }, state) {\n    state.innerLabels.push(node.label.name);\n  }\n\n};\nconst continuationVisitor = {\n  enter(path, state) {\n    if (path.isAssignmentExpression() || path.isUpdateExpression()) {\n      for (const name of Object.keys(path.getBindingIdentifiers())) {\n        if (state.outsideReferences.get(name) !== path.scope.getBindingIdentifier(name)) {\n          continue;\n        }\n\n        state.reassignments[name] = true;\n      }\n    } else if (path.isReturnStatement()) {\n      state.returnStatements.push(path);\n    }\n  }\n\n};\n\nfunction loopNodeTo(node) {\n  if (_core.types.isBreakStatement(node)) {\n    return \"break\";\n  } else if (_core.types.isContinueStatement(node)) {\n    return \"continue\";\n  }\n}\n\nconst loopVisitor = {\n  Loop(path, state) {\n    const oldIgnoreLabeless = state.ignoreLabeless;\n    state.ignoreLabeless = true;\n    path.traverse(loopVisitor, state);\n    state.ignoreLabeless = oldIgnoreLabeless;\n    path.skip();\n  },\n\n  Function(path) {\n    path.skip();\n  },\n\n  SwitchCase(path, state) {\n    const oldInSwitchCase = state.inSwitchCase;\n    state.inSwitchCase = true;\n    path.traverse(loopVisitor, state);\n    state.inSwitchCase = oldInSwitchCase;\n    path.skip();\n  },\n\n  \"BreakStatement|ContinueStatement|ReturnStatement\"(path, state) {\n    const {\n      node,\n      scope\n    } = path;\n    if (state.loopIgnored.has(node)) return;\n    let replace;\n    let loopText = loopNodeTo(node);\n\n    if (loopText) {\n      if (_core.types.isReturnStatement(node)) {\n        throw new Error(\"Internal error: unexpected return statement with `loopText`\");\n      }\n\n      if (node.label) {\n        if (state.innerLabels.indexOf(node.label.name) >= 0) {\n          return;\n        }\n\n        loopText = `${loopText}|${node.label.name}`;\n      } else {\n        if (state.ignoreLabeless) return;\n        if (_core.types.isBreakStatement(node) && state.inSwitchCase) return;\n      }\n\n      state.hasBreakContinue = true;\n      state.map.set(loopText, node);\n      replace = _core.types.stringLiteral(loopText);\n    }\n\n    if (_core.types.isReturnStatement(node)) {\n      state.hasReturn = true;\n      replace = _core.types.objectExpression([_core.types.objectProperty(_core.types.identifier(\"v\"), node.argument || scope.buildUndefinedNode())]);\n    }\n\n    if (replace) {\n      replace = _core.types.returnStatement(replace);\n      state.loopIgnored.add(replace);\n      path.skip();\n      path.replaceWith(_core.types.inherits(replace, node));\n    }\n  }\n\n};\n\nfunction isStrict(path) {\n  return !!path.find(({\n    node\n  }) => {\n    if (_core.types.isProgram(node)) {\n      if (node.sourceType === \"module\") return true;\n    } else if (!_core.types.isBlockStatement(node)) return false;\n\n    return node.directives.some(directive => directive.value.value === \"use strict\");\n  });\n}\n\nclass BlockScoping {\n  constructor(loopPath, blockPath, parent, scope, throwIfClosureRequired, tdzEnabled, state) {\n    this.parent = void 0;\n    this.state = void 0;\n    this.scope = void 0;\n    this.throwIfClosureRequired = void 0;\n    this.tdzEnabled = void 0;\n    this.blockPath = void 0;\n    this.block = void 0;\n    this.outsideLetReferences = void 0;\n    this.hasLetReferences = void 0;\n    this.letReferences = void 0;\n    this.body = void 0;\n    this.loopParent = void 0;\n    this.loopLabel = void 0;\n    this.loopPath = void 0;\n    this.loop = void 0;\n    this.has = void 0;\n    this.parent = parent;\n    this.scope = scope;\n    this.state = state;\n    this.throwIfClosureRequired = throwIfClosureRequired;\n    this.tdzEnabled = tdzEnabled;\n    this.blockPath = blockPath;\n    this.block = blockPath.node;\n    this.outsideLetReferences = new Map();\n    this.hasLetReferences = false;\n    this.letReferences = new Map();\n    this.body = [];\n\n    if (loopPath) {\n      this.loopParent = loopPath.parent;\n      this.loopLabel = _core.types.isLabeledStatement(this.loopParent) && this.loopParent.label;\n      this.loopPath = loopPath;\n      this.loop = loopPath.node;\n    }\n  }\n\n  run() {\n    const block = this.block;\n    if (DONE.has(block)) return;\n    DONE.add(block);\n    const needsClosure = this.getLetReferences();\n    this.checkConstants();\n\n    if (_core.types.isFunction(this.parent) || _core.types.isProgram(this.block)) {\n      this.updateScopeInfo();\n      return;\n    }\n\n    if (!this.hasLetReferences) return;\n\n    if (needsClosure) {\n      this.wrapClosure();\n    } else {\n      this.remap();\n    }\n\n    this.updateScopeInfo(needsClosure);\n\n    if (this.loopLabel && !_core.types.isLabeledStatement(this.loopParent)) {\n      return _core.types.labeledStatement(this.loopLabel, this.loop);\n    }\n  }\n\n  checkConstants() {\n    const scope = this.scope;\n    const state = this.state;\n\n    for (const name of Object.keys(scope.bindings)) {\n      const binding = scope.bindings[name];\n      if (binding.kind !== \"const\") continue;\n\n      for (const violation of binding.constantViolations) {\n        const readOnlyError = state.addHelper(\"readOnlyError\");\n\n        const throwNode = _core.types.callExpression(readOnlyError, [_core.types.stringLiteral(name)]);\n\n        if (violation.isAssignmentExpression()) {\n          const {\n            operator\n          } = violation.node;\n\n          if (operator === \"=\") {\n            violation.replaceWith(_core.types.sequenceExpression([violation.get(\"right\").node, throwNode]));\n          } else if ([\"&&=\", \"||=\", \"??=\"].includes(operator)) {\n            violation.replaceWith(_core.types.logicalExpression(operator.slice(0, -1), violation.get(\"left\").node, _core.types.sequenceExpression([violation.get(\"right\").node, throwNode])));\n          } else {\n            violation.replaceWith(_core.types.sequenceExpression([_core.types.binaryExpression(operator.slice(0, -1), violation.get(\"left\").node, violation.get(\"right\").node), throwNode]));\n          }\n        } else if (violation.isUpdateExpression()) {\n          violation.replaceWith(_core.types.sequenceExpression([_core.types.unaryExpression(\"+\", violation.get(\"argument\").node), throwNode]));\n        } else if (violation.isForXStatement()) {\n          violation.ensureBlock();\n          violation.get(\"left\").replaceWith(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(violation.scope.generateUidIdentifier(name))]));\n          violation.node.body.body.unshift(_core.types.expressionStatement(throwNode));\n        }\n      }\n    }\n  }\n\n  updateScopeInfo(wrappedInClosure) {\n    const blockScope = this.blockPath.scope;\n    const parentScope = blockScope.getFunctionParent() || blockScope.getProgramParent();\n    const letRefs = this.letReferences;\n\n    for (const key of letRefs.keys()) {\n      const ref = letRefs.get(key);\n      const binding = blockScope.getBinding(ref.name);\n      if (!binding) continue;\n\n      if (binding.kind === \"let\" || binding.kind === \"const\") {\n        binding.kind = \"var\";\n\n        if (wrappedInClosure) {\n          if (blockScope.hasOwnBinding(ref.name)) {\n            blockScope.removeBinding(ref.name);\n          }\n        } else {\n          blockScope.moveBindingTo(ref.name, parentScope);\n        }\n      }\n    }\n  }\n\n  remap() {\n    const letRefs = this.letReferences;\n    const outsideLetRefs = this.outsideLetReferences;\n    const scope = this.scope;\n    const blockPathScope = this.blockPath.scope;\n\n    for (const key of letRefs.keys()) {\n      const ref = letRefs.get(key);\n\n      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {\n        const binding = scope.getOwnBinding(key);\n\n        if (binding) {\n          const parentBinding = scope.parent.getOwnBinding(key);\n\n          if (binding.kind === \"hoisted\" && !binding.path.node.async && !binding.path.node.generator && (!parentBinding || isVar(parentBinding.path.parent)) && !isStrict(binding.path.parentPath)) {\n            continue;\n          }\n\n          scope.rename(ref.name);\n        }\n\n        if (blockPathScope.hasOwnBinding(key)) {\n          blockPathScope.rename(ref.name);\n        }\n      }\n    }\n\n    for (const key of outsideLetRefs.keys()) {\n      const ref = letRefs.get(key);\n\n      if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(key)) {\n        blockPathScope.rename(ref.name);\n      }\n    }\n  }\n\n  wrapClosure() {\n    if (this.throwIfClosureRequired) {\n      throw this.blockPath.buildCodeFrameError(\"Compiling let/const in this block would add a closure \" + \"(throwIfClosureRequired).\");\n    }\n\n    const block = this.block;\n    const outsideRefs = this.outsideLetReferences;\n\n    if (this.loop) {\n      for (const name of Array.from(outsideRefs.keys())) {\n        const id = outsideRefs.get(name);\n\n        if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {\n          outsideRefs.delete(id.name);\n          this.letReferences.delete(id.name);\n          this.scope.rename(id.name);\n          this.letReferences.set(id.name, id);\n          outsideRefs.set(id.name, id);\n        }\n      }\n    }\n\n    this.has = this.checkLoop();\n    this.hoistVarDeclarations();\n    const args = Array.from(outsideRefs.values(), node => _core.types.cloneNode(node));\n    const params = args.map(id => _core.types.cloneNode(id));\n    const isSwitch = block.type === \"SwitchStatement\";\n\n    const fn = _core.types.functionExpression(null, params, _core.types.blockStatement(isSwitch ? [block] : block.body));\n\n    this.addContinuations(fn);\n\n    let call = _core.types.callExpression(_core.types.nullLiteral(), args);\n\n    let basePath = \".callee\";\n\n    const hasYield = _core.traverse.hasType(fn.body, \"YieldExpression\", _core.types.FUNCTION_TYPES);\n\n    if (hasYield) {\n      fn.generator = true;\n      call = _core.types.yieldExpression(call, true);\n      basePath = \".argument\" + basePath;\n    }\n\n    const hasAsync = _core.traverse.hasType(fn.body, \"AwaitExpression\", _core.types.FUNCTION_TYPES);\n\n    if (hasAsync) {\n      fn.async = true;\n      call = _core.types.awaitExpression(call);\n      basePath = \".argument\" + basePath;\n    }\n\n    let placeholderPath;\n    let index;\n\n    if (this.has.hasReturn || this.has.hasBreakContinue) {\n      const ret = this.scope.generateUid(\"ret\");\n      this.body.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(ret), call)]));\n      placeholderPath = \"declarations.0.init\" + basePath;\n      index = this.body.length - 1;\n      this.buildHas(ret);\n    } else {\n      this.body.push(_core.types.expressionStatement(call));\n      placeholderPath = \"expression\" + basePath;\n      index = this.body.length - 1;\n    }\n\n    let callPath;\n\n    if (isSwitch) {\n      const {\n        parentPath,\n        listKey,\n        key\n      } = this.blockPath;\n      this.blockPath.replaceWithMultiple(this.body);\n      callPath = parentPath.get(listKey)[key + index];\n    } else {\n      block.body = this.body;\n      callPath = this.blockPath.get(\"body\")[index];\n    }\n\n    const placeholder = callPath.get(placeholderPath);\n    let fnPath;\n\n    if (this.loop) {\n      const loopId = this.scope.generateUid(\"loop\");\n      const p = this.loopPath.insertBefore(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(loopId), fn)]));\n      placeholder.replaceWith(_core.types.identifier(loopId));\n      fnPath = p[0].get(\"declarations.0.init\");\n    } else {\n      placeholder.replaceWith(fn);\n      fnPath = placeholder;\n    }\n\n    fnPath.unwrapFunctionEnvironment();\n  }\n\n  addContinuations(fn) {\n    const state = {\n      reassignments: {},\n      returnStatements: [],\n      outsideReferences: this.outsideLetReferences\n    };\n    this.scope.traverse(fn, continuationVisitor, state);\n\n    for (let i = 0; i < fn.params.length; i++) {\n      const param = fn.params[i];\n      if (!state.reassignments[param.name]) continue;\n      const paramName = param.name;\n      const newParamName = this.scope.generateUid(param.name);\n      fn.params[i] = _core.types.identifier(newParamName);\n      this.scope.rename(paramName, newParamName, fn);\n      state.returnStatements.forEach(returnStatement => {\n        returnStatement.insertBefore(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(paramName), _core.types.identifier(newParamName))));\n      });\n      fn.body.body.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.identifier(paramName), _core.types.identifier(newParamName))));\n    }\n  }\n\n  getLetReferences() {\n    const block = this.block;\n    const declarators = [];\n\n    if (this.loop) {\n      const init = this.loop.left || this.loop.init;\n\n      if (isBlockScoped(init)) {\n        declarators.push(init);\n\n        const names = _core.types.getBindingIdentifiers(init);\n\n        for (const name of Object.keys(names)) {\n          this.outsideLetReferences.set(name, names[name]);\n        }\n      }\n    }\n\n    const addDeclarationsFromChild = (path, node) => {\n      if (_core.types.isClassDeclaration(node) || _core.types.isFunctionDeclaration(node) || isBlockScoped(node)) {\n        if (isBlockScoped(node)) {\n          convertBlockScopedToVar(path, node, block, this.scope);\n        }\n\n        if (node.type === \"VariableDeclaration\") {\n          for (let i = 0; i < node.declarations.length; i++) {\n            declarators.push(node.declarations[i]);\n          }\n        } else {\n          declarators.push(node);\n        }\n      }\n\n      if (_core.types.isLabeledStatement(node)) {\n        addDeclarationsFromChild(path.get(\"body\"), node.body);\n      }\n    };\n\n    if (block.type === \"SwitchStatement\") {\n      const declarPaths = this.blockPath.get(\"cases\");\n\n      for (let i = 0; i < block.cases.length; i++) {\n        const consequents = block.cases[i].consequent;\n\n        for (let j = 0; j < consequents.length; j++) {\n          const declar = consequents[j];\n          addDeclarationsFromChild(declarPaths[i], declar);\n        }\n      }\n    } else {\n      const declarPaths = this.blockPath.get(\"body\");\n\n      for (let i = 0; i < block.body.length; i++) {\n        addDeclarationsFromChild(declarPaths[i], declarPaths[i].node);\n      }\n    }\n\n    for (let i = 0; i < declarators.length; i++) {\n      const declar = declarators[i];\n\n      const keys = _core.types.getBindingIdentifiers(declar, false, true);\n\n      for (const key of Object.keys(keys)) {\n        this.letReferences.set(key, keys[key]);\n      }\n\n      this.hasLetReferences = true;\n    }\n\n    if (!this.hasLetReferences) return;\n    const state = {\n      letReferences: this.letReferences,\n      closurify: false,\n      loopDepth: 0,\n      tdzEnabled: this.tdzEnabled,\n      addHelper: name => this.state.addHelper(name)\n    };\n\n    if (isInLoop(this.blockPath)) {\n      state.loopDepth++;\n    }\n\n    this.blockPath.traverse(letReferenceBlockVisitor, state);\n    return state.closurify;\n  }\n\n  checkLoop() {\n    const state = {\n      hasBreakContinue: false,\n      ignoreLabeless: false,\n      inSwitchCase: false,\n      innerLabels: [],\n      hasReturn: false,\n      isLoop: !!this.loop,\n      map: new Map(),\n      loopIgnored: new WeakSet()\n    };\n    this.blockPath.traverse(loopLabelVisitor, state);\n    this.blockPath.traverse(loopVisitor, state);\n    return state;\n  }\n\n  hoistVarDeclarations() {\n    this.blockPath.traverse(hoistVarDeclarationsVisitor, this);\n  }\n\n  pushDeclar(node) {\n    const declars = [];\n\n    const names = _core.types.getBindingIdentifiers(node);\n\n    for (const name of Object.keys(names)) {\n      declars.push(_core.types.variableDeclarator(names[name]));\n    }\n\n    this.body.push(_core.types.variableDeclaration(node.kind, declars));\n    const replace = [];\n\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      if (!declar.init) continue;\n\n      const expr = _core.types.assignmentExpression(\"=\", _core.types.cloneNode(declar.id), _core.types.cloneNode(declar.init));\n\n      replace.push(_core.types.inherits(expr, declar));\n    }\n\n    return replace;\n  }\n\n  buildHas(ret) {\n    const body = this.body;\n    const has = this.has;\n\n    if (has.hasBreakContinue) {\n      for (const key of has.map.keys()) {\n        body.push(_core.types.ifStatement(_core.types.binaryExpression(\"===\", _core.types.identifier(ret), _core.types.stringLiteral(key)), has.map.get(key)));\n      }\n    }\n\n    if (has.hasReturn) {\n      body.push(buildRetCheck({\n        RETURN: _core.types.identifier(ret)\n      }));\n    }\n  }\n\n}"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,kBAAkB,GAAGC,OAAO,CAAC,4BAAD,CAAhC;;AAEA,IAAIC,IAAI,GAAGD,OAAO,CAAC,OAAD,CAAlB;;AAEA,IAAIE,KAAK,GAAGF,OAAO,CAAC,aAAD,CAAnB;;AAEA,MAAMG,IAAI,GAAG,IAAIC,OAAJ,EAAb;;AAEA,IAAIC,QAAQ,GAAG,CAAC,GAAGN,kBAAkB,CAACO,OAAvB,EAAgC,CAACC,GAAD,EAAMC,IAAN,KAAe;EAC5DD,GAAG,CAACE,aAAJ,CAAkB,CAAlB;EACA,MAAM;IACJC,sBAAsB,GAAG,KADrB;IAEJC,GAAG,EAAEC,UAAU,GAAG;EAFd,IAGFJ,IAHJ;;EAKA,IAAI,OAAOE,sBAAP,KAAkC,SAAtC,EAAiD;IAC/C,MAAM,IAAIG,KAAJ,CAAW,yDAAX,CAAN;EACD;;EAED,IAAI,OAAOD,UAAP,KAAsB,SAA1B,EAAqC;IACnC,MAAM,IAAIC,KAAJ,CAAW,sCAAX,CAAN;EACD;;EAED,OAAO;IACLC,IAAI,EAAE,yBADD;IAELC,OAAO,EAAE;MACPC,mBAAmB,CAACC,IAAD,EAAO;QACxB,MAAM;UACJC,IADI;UAEJC,MAFI;UAGJC;QAHI,IAIFH,IAJJ;QAKA,IAAI,CAACI,aAAa,CAACH,IAAD,CAAlB,EAA0B;QAC1BI,uBAAuB,CAACL,IAAD,EAAO,IAAP,EAAaE,MAAb,EAAqBC,KAArB,EAA4B,IAA5B,CAAvB;;QAEA,IAAIF,IAAI,CAACK,QAAT,EAAmB;UACjB,MAAMC,KAAK,GAAG,CAACN,IAAD,CAAd;;UAEA,KAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,IAAI,CAACQ,YAAL,CAAkBC,MAAtC,EAA8CF,CAAC,EAA/C,EAAmD;YACjD,MAAMG,IAAI,GAAGV,IAAI,CAACQ,YAAL,CAAkBD,CAAlB,CAAb;;YAEA,MAAMI,MAAM,GAAG3B,KAAK,CAAC4B,KAAN,CAAYC,oBAAZ,CAAiC,GAAjC,EAAsC7B,KAAK,CAAC4B,KAAN,CAAYE,SAAZ,CAAsBJ,IAAI,CAACK,EAA3B,CAAtC,EAAsEL,IAAI,CAACM,IAAL,IAAad,KAAK,CAACe,kBAAN,EAAnF,CAAf;;YAEAN,MAAM,CAACO,sBAAP,GAAgC,IAAhC;YACAZ,KAAK,CAACa,IAAN,CAAWnC,KAAK,CAAC4B,KAAN,CAAYQ,mBAAZ,CAAgCT,MAAhC,CAAX;YACAD,IAAI,CAACM,IAAL,GAAY,KAAKK,SAAL,CAAe,mBAAf,CAAZ;UACD;;UAEDrB,IAAI,CAACsB,WAAL,GAAmB,CAAnB;;UAEA,IAAIvB,IAAI,CAACwB,kBAAL,EAAJ,EAA+B;YAC7BjB,KAAK,CAACa,IAAN,CAAWnC,KAAK,CAAC4B,KAAN,CAAYQ,mBAAZ,CAAgClB,KAAK,CAACe,kBAAN,EAAhC,CAAX;UACD;;UAEDlB,IAAI,CAACyB,mBAAL,CAAyBlB,KAAzB;QACD;MACF,CA/BM;;MAiCPmB,IAAI,CAAC1B,IAAD,EAAO2B,KAAP,EAAc;QAChB,MAAM;UACJzB,MADI;UAEJC;QAFI,IAGFH,IAHJ;QAIAA,IAAI,CAAC4B,WAAL;QACA,MAAMC,YAAY,GAAG,IAAIC,YAAJ,CAAiB9B,IAAjB,EAAuBA,IAAI,CAAC+B,GAAL,CAAS,MAAT,CAAvB,EAAyC7B,MAAzC,EAAiDC,KAAjD,EAAwDV,sBAAxD,EAAgFE,UAAhF,EAA4FgC,KAA5F,CAArB;QACA,MAAMK,OAAO,GAAGH,YAAY,CAACI,GAAb,EAAhB;QACA,IAAID,OAAJ,EAAahC,IAAI,CAACkC,WAAL,CAAiBF,OAAjB;MACd,CA1CM;;MA4CPG,WAAW,CAACnC,IAAD,EAAO2B,KAAP,EAAc;QACvB,MAAM;UACJzB,MADI;UAEJC;QAFI,IAGFH,IAHJ;QAIA,MAAM6B,YAAY,GAAG,IAAIC,YAAJ,CAAiB,IAAjB,EAAuB9B,IAAI,CAAC+B,GAAL,CAAS,MAAT,CAAvB,EAAyC7B,MAAzC,EAAiDC,KAAjD,EAAwDV,sBAAxD,EAAgFE,UAAhF,EAA4FgC,KAA5F,CAArB;QACAE,YAAY,CAACI,GAAb;MACD,CAnDM;;MAqDP,yCAAyCjC,IAAzC,EAA+C2B,KAA/C,EAAsD;QACpD,IAAI,CAACS,WAAW,CAACpC,IAAD,CAAhB,EAAwB;UACtB,MAAM6B,YAAY,GAAG,IAAIC,YAAJ,CAAiB,IAAjB,EAAuB9B,IAAvB,EAA6BA,IAAI,CAACE,MAAlC,EAA0CF,IAAI,CAACG,KAA/C,EAAsDV,sBAAtD,EAA8EE,UAA9E,EAA0FgC,KAA1F,CAArB;UACAE,YAAY,CAACI,GAAb;QACD;MACF;;IA1DM;EAFJ,CAAP;AAgED,CA/Ec,CAAf;;AAiFAtD,OAAO,CAACE,OAAR,GAAkBO,QAAlB;;AAEA,SAASgD,WAAT,CAAqBpC,IAArB,EAA2B;EACzB,OAAOf,KAAK,CAAC4B,KAAN,CAAYwB,MAAZ,CAAmBrC,IAAI,CAACE,MAAxB,KAAmCjB,KAAK,CAAC4B,KAAN,CAAYyB,aAAZ,CAA0BtC,IAAI,CAACE,MAA/B,CAA1C;AACD;;AAED,MAAMqC,aAAa,GAAGtD,KAAK,CAACuD,QAAN,CAAeC,SAAf,CAA0B;AAChD;AACA,CAFsB,CAAtB;;AAIA,SAASrC,aAAT,CAAuBH,IAAvB,EAA6B;EAC3B,IAAI,CAAChB,KAAK,CAAC4B,KAAN,CAAY6B,qBAAZ,CAAkCzC,IAAlC,CAAL,EAA8C,OAAO,KAAP;;EAE9C,IAAIA,IAAI,CAAChB,KAAK,CAAC4B,KAAN,CAAY8B,mBAAb,CAAR,EAA2C;IACzC,OAAO,IAAP;EACD;;EAED,IAAI1C,IAAI,CAAC2C,IAAL,KAAc,KAAd,IAAuB3C,IAAI,CAAC2C,IAAL,KAAc,OAAzC,EAAkD,OAAO,KAAP;EAClD,OAAO,IAAP;AACD;;AAED,SAASC,QAAT,CAAkB7C,IAAlB,EAAwB;EACtB,MAAM8C,oBAAoB,GAAG9C,IAAI,CAAC+C,IAAL,CAAU/C,IAAI,IAAIA,IAAI,CAACqC,MAAL,MAAiBrC,IAAI,CAACgD,UAAL,EAAnC,CAA7B;EACA,OAAOF,oBAAoB,IAAI,IAAxB,GAA+B,KAAK,CAApC,GAAwCA,oBAAoB,CAACT,MAArB,EAA/C;AACD;;AAED,SAAShC,uBAAT,CAAiCL,IAAjC,EAAuCC,IAAvC,EAA6CC,MAA7C,EAAqDC,KAArD,EAA0F;EAAA,IAA9B8C,oBAA8B,uEAAP,KAAO;;EACxF,IAAI,CAAChD,IAAL,EAAW;IACTA,IAAI,GAAGD,IAAI,CAACC,IAAZ;EACD;;EAED,IAAI4C,QAAQ,CAAC7C,IAAD,CAAR,IAAkB,CAACf,KAAK,CAAC4B,KAAN,CAAYqC,KAAZ,CAAkBhD,MAAlB,CAAvB,EAAkD;IAChD,KAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,IAAI,CAACQ,YAAL,CAAkBC,MAAtC,EAA8CF,CAAC,EAA/C,EAAmD;MACjD,MAAM2C,MAAM,GAAGlD,IAAI,CAACQ,YAAL,CAAkBD,CAAlB,CAAf;MACA2C,MAAM,CAAClC,IAAP,GAAckC,MAAM,CAAClC,IAAP,IAAed,KAAK,CAACe,kBAAN,EAA7B;IACD;EACF;;EAEDjB,IAAI,CAAChB,KAAK,CAAC4B,KAAN,CAAY8B,mBAAb,CAAJ,GAAwC,IAAxC;EACA1C,IAAI,CAAC2C,IAAL,GAAY,KAAZ;;EAEA,IAAIK,oBAAJ,EAA0B;IACxB,MAAMG,WAAW,GAAGjD,KAAK,CAACkD,iBAAN,MAA6BlD,KAAK,CAACmD,gBAAN,EAAjD;;IAEA,KAAK,MAAMzD,IAAX,IAAmBpB,MAAM,CAAC8E,IAAP,CAAYvD,IAAI,CAACwD,qBAAL,EAAZ,CAAnB,EAA8D;MAC5D,MAAMC,OAAO,GAAGtD,KAAK,CAACuD,aAAN,CAAoB7D,IAApB,CAAhB;MACA,IAAI4D,OAAJ,EAAaA,OAAO,CAACb,IAAR,GAAe,KAAf;MACbzC,KAAK,CAACwD,aAAN,CAAoB9D,IAApB,EAA0BuD,WAA1B;IACD;EACF;AACF;;AAED,SAASQ,KAAT,CAAe3D,IAAf,EAAqB;EACnB,OAAOhB,KAAK,CAAC4B,KAAN,CAAY6B,qBAAZ,CAAkCzC,IAAlC,EAAwC;IAC7C2C,IAAI,EAAE;EADuC,CAAxC,KAED,CAACxC,aAAa,CAACH,IAAD,CAFpB;AAGD;;AAED,MAAM4D,wBAAwB,GAAG5E,KAAK,CAAC6E,QAAN,CAAeC,QAAf,CAAwBC,KAAxB,CAA8B,CAAC;EAC9DtC,IAAI,EAAE;IACJuC,KAAK,CAACjE,IAAD,EAAO2B,KAAP,EAAc;MACjBA,KAAK,CAACuC,SAAN;IACD,CAHG;;IAKJC,IAAI,CAACnE,IAAD,EAAO2B,KAAP,EAAc;MAChBA,KAAK,CAACuC,SAAN;IACD;;EAPG,CADwD;;EAY9DE,cAAc,CAACpE,IAAD,EAAO2B,KAAP,EAAc;IAC1B,IAAIA,KAAK,CAACuC,SAAN,GAAkB,CAAtB,EAAyB;MACvBlE,IAAI,CAAC8D,QAAL,CAAcO,2BAAd,EAA2C1C,KAA3C;IACD,CAFD,MAEO;MACL3B,IAAI,CAAC8D,QAAL,CAAc9E,IAAI,CAACc,OAAnB,EAA4B6B,KAA5B;IACD;;IAED,OAAO3B,IAAI,CAACsE,IAAL,EAAP;EACD;;AApB6D,CAAD,EAsB5DtF,IAAI,CAACc,OAtBuD,CAA9B,CAAjC;;AAwBA,MAAMuE,2BAA2B,GAAGpF,KAAK,CAAC6E,QAAN,CAAeC,QAAf,CAAwBC,KAAxB,CAA8B,CAAC;EACjEO,oBAAoB,CAACvE,IAAD,EAAO2B,KAAP,EAAc;IAChC,MAAM6C,GAAG,GAAG7C,KAAK,CAAC8C,aAAN,CAAoB1C,GAApB,CAAwB/B,IAAI,CAACC,IAAL,CAAUJ,IAAlC,CAAZ;IACA,IAAI,CAAC2E,GAAL,EAAU;IACV,MAAME,YAAY,GAAG1E,IAAI,CAACG,KAAL,CAAWwE,oBAAX,CAAgC3E,IAAI,CAACC,IAAL,CAAUJ,IAA1C,CAArB;IACA,IAAI6E,YAAY,IAAIA,YAAY,KAAKF,GAArC,EAA0C;IAC1C7C,KAAK,CAACiD,SAAN,GAAkB,IAAlB;EACD;;AAPgE,CAAD,EAS/D5F,IAAI,CAACc,OAT0D,CAA9B,CAApC;;AAWA,MAAM+E,2BAA2B,GAAG;EAClCZ,KAAK,CAACjE,IAAD,EAAO8E,IAAP,EAAa;IAChB,IAAI9E,IAAI,CAAC+E,cAAL,EAAJ,EAA2B;MACzB,MAAM;QACJ9E;MADI,IAEFD,IAFJ;;MAIA,IAAI4D,KAAK,CAAC3D,IAAI,CAACgB,IAAN,CAAT,EAAsB;QACpB,MAAMV,KAAK,GAAGuE,IAAI,CAACE,UAAL,CAAgB/E,IAAI,CAACgB,IAArB,CAAd;;QAEA,IAAIV,KAAK,CAACG,MAAN,KAAiB,CAArB,EAAwB;UACtBT,IAAI,CAACgB,IAAL,GAAYV,KAAK,CAAC,CAAD,CAAjB;QACD,CAFD,MAEO;UACLN,IAAI,CAACgB,IAAL,GAAYhC,KAAK,CAAC4B,KAAN,CAAYoE,kBAAZ,CAA+B1E,KAA/B,CAAZ;QACD;MACF;IACF,CAdD,MAcO,IAAIP,IAAI,CAACkF,gBAAL,MAA2BlF,IAAI,CAACmF,gBAAL,EAA/B,EAAwD;MAC7D,MAAM;QACJlF;MADI,IAEFD,IAFJ;;MAIA,IAAI4D,KAAK,CAAC3D,IAAI,CAACmF,IAAN,CAAT,EAAsB;QACpBN,IAAI,CAACE,UAAL,CAAgB/E,IAAI,CAACmF,IAArB;QACAnF,IAAI,CAACmF,IAAL,GAAYnF,IAAI,CAACmF,IAAL,CAAU3E,YAAV,CAAuB,CAAvB,EAA0BO,EAAtC;MACD;IACF,CATM,MASA,IAAI4C,KAAK,CAAC5D,IAAI,CAACC,IAAN,CAAT,EAAsB;MAC3BD,IAAI,CAACyB,mBAAL,CAAyBqD,IAAI,CAACE,UAAL,CAAgBhF,IAAI,CAACC,IAArB,EAA2BoF,GAA3B,CAA+BC,IAAI,IAAIrG,KAAK,CAAC4B,KAAN,CAAYQ,mBAAZ,CAAgCiE,IAAhC,CAAvC,CAAzB;IACD,CAFM,MAEA,IAAItF,IAAI,CAACgD,UAAL,EAAJ,EAAuB;MAC5B,OAAOhD,IAAI,CAACsE,IAAL,EAAP;IACD;EACF;;AA9BiC,CAApC;AAiCA,MAAMiB,gBAAgB,GAAG;EACvBC,gBAAgB,OAEb7D,KAFa,EAEN;IAAA,IAFO;MACf1B;IADe,CAEP;IACR0B,KAAK,CAAC8D,WAAN,CAAkBrE,IAAlB,CAAuBnB,IAAI,CAACyF,KAAL,CAAW7F,IAAlC;EACD;;AALsB,CAAzB;AAQA,MAAM8F,mBAAmB,GAAG;EAC1B1B,KAAK,CAACjE,IAAD,EAAO2B,KAAP,EAAc;IACjB,IAAI3B,IAAI,CAAC4F,sBAAL,MAAiC5F,IAAI,CAAC6F,kBAAL,EAArC,EAAgE;MAC9D,KAAK,MAAMhG,IAAX,IAAmBpB,MAAM,CAAC8E,IAAP,CAAYvD,IAAI,CAACwD,qBAAL,EAAZ,CAAnB,EAA8D;QAC5D,IAAI7B,KAAK,CAACmE,iBAAN,CAAwB/D,GAAxB,CAA4BlC,IAA5B,MAAsCG,IAAI,CAACG,KAAL,CAAWwE,oBAAX,CAAgC9E,IAAhC,CAA1C,EAAiF;UAC/E;QACD;;QAED8B,KAAK,CAACoE,aAAN,CAAoBlG,IAApB,IAA4B,IAA5B;MACD;IACF,CARD,MAQO,IAAIG,IAAI,CAACgG,iBAAL,EAAJ,EAA8B;MACnCrE,KAAK,CAACsE,gBAAN,CAAuB7E,IAAvB,CAA4BpB,IAA5B;IACD;EACF;;AAbyB,CAA5B;;AAiBA,SAASkG,UAAT,CAAoBjG,IAApB,EAA0B;EACxB,IAAIhB,KAAK,CAAC4B,KAAN,CAAYsF,gBAAZ,CAA6BlG,IAA7B,CAAJ,EAAwC;IACtC,OAAO,OAAP;EACD,CAFD,MAEO,IAAIhB,KAAK,CAAC4B,KAAN,CAAYuF,mBAAZ,CAAgCnG,IAAhC,CAAJ,EAA2C;IAChD,OAAO,UAAP;EACD;AACF;;AAED,MAAMoG,WAAW,GAAG;EAClB3E,IAAI,CAAC1B,IAAD,EAAO2B,KAAP,EAAc;IAChB,MAAM2E,iBAAiB,GAAG3E,KAAK,CAAC4E,cAAhC;IACA5E,KAAK,CAAC4E,cAAN,GAAuB,IAAvB;IACAvG,IAAI,CAAC8D,QAAL,CAAcuC,WAAd,EAA2B1E,KAA3B;IACAA,KAAK,CAAC4E,cAAN,GAAuBD,iBAAvB;IACAtG,IAAI,CAACsE,IAAL;EACD,CAPiB;;EASlBkC,QAAQ,CAACxG,IAAD,EAAO;IACbA,IAAI,CAACsE,IAAL;EACD,CAXiB;;EAalBmC,UAAU,CAACzG,IAAD,EAAO2B,KAAP,EAAc;IACtB,MAAM+E,eAAe,GAAG/E,KAAK,CAACgF,YAA9B;IACAhF,KAAK,CAACgF,YAAN,GAAqB,IAArB;IACA3G,IAAI,CAAC8D,QAAL,CAAcuC,WAAd,EAA2B1E,KAA3B;IACAA,KAAK,CAACgF,YAAN,GAAqBD,eAArB;IACA1G,IAAI,CAACsE,IAAL;EACD,CAnBiB;;EAqBlB,mDAAmDtE,IAAnD,EAAyD2B,KAAzD,EAAgE;IAC9D,MAAM;MACJ1B,IADI;MAEJE;IAFI,IAGFH,IAHJ;IAIA,IAAI2B,KAAK,CAACiF,WAAN,CAAkBC,GAAlB,CAAsB5G,IAAtB,CAAJ,EAAiC;IACjC,IAAI+B,OAAJ;IACA,IAAI8E,QAAQ,GAAGZ,UAAU,CAACjG,IAAD,CAAzB;;IAEA,IAAI6G,QAAJ,EAAc;MACZ,IAAI7H,KAAK,CAAC4B,KAAN,CAAYmF,iBAAZ,CAA8B/F,IAA9B,CAAJ,EAAyC;QACvC,MAAM,IAAIL,KAAJ,CAAU,6DAAV,CAAN;MACD;;MAED,IAAIK,IAAI,CAACyF,KAAT,EAAgB;QACd,IAAI/D,KAAK,CAAC8D,WAAN,CAAkBsB,OAAlB,CAA0B9G,IAAI,CAACyF,KAAL,CAAW7F,IAArC,KAA8C,CAAlD,EAAqD;UACnD;QACD;;QAEDiH,QAAQ,GAAI,GAAEA,QAAS,IAAG7G,IAAI,CAACyF,KAAL,CAAW7F,IAAK,EAA1C;MACD,CAND,MAMO;QACL,IAAI8B,KAAK,CAAC4E,cAAV,EAA0B;QAC1B,IAAItH,KAAK,CAAC4B,KAAN,CAAYsF,gBAAZ,CAA6BlG,IAA7B,KAAsC0B,KAAK,CAACgF,YAAhD,EAA8D;MAC/D;;MAEDhF,KAAK,CAACqF,gBAAN,GAAyB,IAAzB;MACArF,KAAK,CAAC0D,GAAN,CAAU4B,GAAV,CAAcH,QAAd,EAAwB7G,IAAxB;MACA+B,OAAO,GAAG/C,KAAK,CAAC4B,KAAN,CAAYqG,aAAZ,CAA0BJ,QAA1B,CAAV;IACD;;IAED,IAAI7H,KAAK,CAAC4B,KAAN,CAAYmF,iBAAZ,CAA8B/F,IAA9B,CAAJ,EAAyC;MACvC0B,KAAK,CAACwF,SAAN,GAAkB,IAAlB;MACAnF,OAAO,GAAG/C,KAAK,CAAC4B,KAAN,CAAYuG,gBAAZ,CAA6B,CAACnI,KAAK,CAAC4B,KAAN,CAAYwG,cAAZ,CAA2BpI,KAAK,CAAC4B,KAAN,CAAYyG,UAAZ,CAAuB,GAAvB,CAA3B,EAAwDrH,IAAI,CAACsH,QAAL,IAAiBpH,KAAK,CAACe,kBAAN,EAAzE,CAAD,CAA7B,CAAV;IACD;;IAED,IAAIc,OAAJ,EAAa;MACXA,OAAO,GAAG/C,KAAK,CAAC4B,KAAN,CAAY2G,eAAZ,CAA4BxF,OAA5B,CAAV;MACAL,KAAK,CAACiF,WAAN,CAAkBa,GAAlB,CAAsBzF,OAAtB;MACAhC,IAAI,CAACsE,IAAL;MACAtE,IAAI,CAACkC,WAAL,CAAiBjD,KAAK,CAAC4B,KAAN,CAAY6G,QAAZ,CAAqB1F,OAArB,EAA8B/B,IAA9B,CAAjB;IACD;EACF;;AA9DiB,CAApB;;AAkEA,SAAS0H,QAAT,CAAkB3H,IAAlB,EAAwB;EACtB,OAAO,CAAC,CAACA,IAAI,CAAC+C,IAAL,CAAU,SAEb;IAAA,IAFc;MAClB9C;IADkB,CAEd;;IACJ,IAAIhB,KAAK,CAAC4B,KAAN,CAAY+G,SAAZ,CAAsB3H,IAAtB,CAAJ,EAAiC;MAC/B,IAAIA,IAAI,CAAC4H,UAAL,KAAoB,QAAxB,EAAkC,OAAO,IAAP;IACnC,CAFD,MAEO,IAAI,CAAC5I,KAAK,CAAC4B,KAAN,CAAYiH,gBAAZ,CAA6B7H,IAA7B,CAAL,EAAyC,OAAO,KAAP;;IAEhD,OAAOA,IAAI,CAAC8H,UAAL,CAAgBC,IAAhB,CAAqBC,SAAS,IAAIA,SAAS,CAACrJ,KAAV,CAAgBA,KAAhB,KAA0B,YAA5D,CAAP;EACD,CARQ,CAAT;AASD;;AAED,MAAMkD,YAAN,CAAmB;EACjBoG,WAAW,CAACC,QAAD,EAAWC,SAAX,EAAsBlI,MAAtB,EAA8BC,KAA9B,EAAqCV,sBAArC,EAA6DE,UAA7D,EAAyEgC,KAAzE,EAAgF;IACzF,KAAKzB,MAAL,GAAc,KAAK,CAAnB;IACA,KAAKyB,KAAL,GAAa,KAAK,CAAlB;IACA,KAAKxB,KAAL,GAAa,KAAK,CAAlB;IACA,KAAKV,sBAAL,GAA8B,KAAK,CAAnC;IACA,KAAKE,UAAL,GAAkB,KAAK,CAAvB;IACA,KAAKyI,SAAL,GAAiB,KAAK,CAAtB;IACA,KAAKC,KAAL,GAAa,KAAK,CAAlB;IACA,KAAKC,oBAAL,GAA4B,KAAK,CAAjC;IACA,KAAKC,gBAAL,GAAwB,KAAK,CAA7B;IACA,KAAK9D,aAAL,GAAqB,KAAK,CAA1B;IACA,KAAK+D,IAAL,GAAY,KAAK,CAAjB;IACA,KAAKC,UAAL,GAAkB,KAAK,CAAvB;IACA,KAAKC,SAAL,GAAiB,KAAK,CAAtB;IACA,KAAKP,QAAL,GAAgB,KAAK,CAArB;IACA,KAAKQ,IAAL,GAAY,KAAK,CAAjB;IACA,KAAK9B,GAAL,GAAW,KAAK,CAAhB;IACA,KAAK3G,MAAL,GAAcA,MAAd;IACA,KAAKC,KAAL,GAAaA,KAAb;IACA,KAAKwB,KAAL,GAAaA,KAAb;IACA,KAAKlC,sBAAL,GAA8BA,sBAA9B;IACA,KAAKE,UAAL,GAAkBA,UAAlB;IACA,KAAKyI,SAAL,GAAiBA,SAAjB;IACA,KAAKC,KAAL,GAAaD,SAAS,CAACnI,IAAvB;IACA,KAAKqI,oBAAL,GAA4B,IAAIM,GAAJ,EAA5B;IACA,KAAKL,gBAAL,GAAwB,KAAxB;IACA,KAAK9D,aAAL,GAAqB,IAAImE,GAAJ,EAArB;IACA,KAAKJ,IAAL,GAAY,EAAZ;;IAEA,IAAIL,QAAJ,EAAc;MACZ,KAAKM,UAAL,GAAkBN,QAAQ,CAACjI,MAA3B;MACA,KAAKwI,SAAL,GAAiBzJ,KAAK,CAAC4B,KAAN,CAAYgI,kBAAZ,CAA+B,KAAKJ,UAApC,KAAmD,KAAKA,UAAL,CAAgB/C,KAApF;MACA,KAAKyC,QAAL,GAAgBA,QAAhB;MACA,KAAKQ,IAAL,GAAYR,QAAQ,CAAClI,IAArB;IACD;EACF;;EAEDgC,GAAG,GAAG;IACJ,MAAMoG,KAAK,GAAG,KAAKA,KAAnB;IACA,IAAInJ,IAAI,CAAC2H,GAAL,CAASwB,KAAT,CAAJ,EAAqB;IACrBnJ,IAAI,CAACuI,GAAL,CAASY,KAAT;IACA,MAAMS,YAAY,GAAG,KAAKC,gBAAL,EAArB;IACA,KAAKC,cAAL;;IAEA,IAAI/J,KAAK,CAAC4B,KAAN,CAAYmC,UAAZ,CAAuB,KAAK9C,MAA5B,KAAuCjB,KAAK,CAAC4B,KAAN,CAAY+G,SAAZ,CAAsB,KAAKS,KAA3B,CAA3C,EAA8E;MAC5E,KAAKY,eAAL;MACA;IACD;;IAED,IAAI,CAAC,KAAKV,gBAAV,EAA4B;;IAE5B,IAAIO,YAAJ,EAAkB;MAChB,KAAKI,WAAL;IACD,CAFD,MAEO;MACL,KAAKC,KAAL;IACD;;IAED,KAAKF,eAAL,CAAqBH,YAArB;;IAEA,IAAI,KAAKJ,SAAL,IAAkB,CAACzJ,KAAK,CAAC4B,KAAN,CAAYgI,kBAAZ,CAA+B,KAAKJ,UAApC,CAAvB,EAAwE;MACtE,OAAOxJ,KAAK,CAAC4B,KAAN,CAAYuI,gBAAZ,CAA6B,KAAKV,SAAlC,EAA6C,KAAKC,IAAlD,CAAP;IACD;EACF;;EAEDK,cAAc,GAAG;IACf,MAAM7I,KAAK,GAAG,KAAKA,KAAnB;IACA,MAAMwB,KAAK,GAAG,KAAKA,KAAnB;;IAEA,KAAK,MAAM9B,IAAX,IAAmBpB,MAAM,CAAC8E,IAAP,CAAYpD,KAAK,CAACkJ,QAAlB,CAAnB,EAAgD;MAC9C,MAAM5F,OAAO,GAAGtD,KAAK,CAACkJ,QAAN,CAAexJ,IAAf,CAAhB;MACA,IAAI4D,OAAO,CAACb,IAAR,KAAiB,OAArB,EAA8B;;MAE9B,KAAK,MAAM0G,SAAX,IAAwB7F,OAAO,CAAC8F,kBAAhC,EAAoD;QAClD,MAAMC,aAAa,GAAG7H,KAAK,CAACL,SAAN,CAAgB,eAAhB,CAAtB;;QAEA,MAAMmI,SAAS,GAAGxK,KAAK,CAAC4B,KAAN,CAAY6I,cAAZ,CAA2BF,aAA3B,EAA0C,CAACvK,KAAK,CAAC4B,KAAN,CAAYqG,aAAZ,CAA0BrH,IAA1B,CAAD,CAA1C,CAAlB;;QAEA,IAAIyJ,SAAS,CAAC1D,sBAAV,EAAJ,EAAwC;UACtC,MAAM;YACJ+D;UADI,IAEFL,SAAS,CAACrJ,IAFd;;UAIA,IAAI0J,QAAQ,KAAK,GAAjB,EAAsB;YACpBL,SAAS,CAACpH,WAAV,CAAsBjD,KAAK,CAAC4B,KAAN,CAAYoE,kBAAZ,CAA+B,CAACqE,SAAS,CAACvH,GAAV,CAAc,OAAd,EAAuB9B,IAAxB,EAA8BwJ,SAA9B,CAA/B,CAAtB;UACD,CAFD,MAEO,IAAI,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,EAAsBG,QAAtB,CAA+BD,QAA/B,CAAJ,EAA8C;YACnDL,SAAS,CAACpH,WAAV,CAAsBjD,KAAK,CAAC4B,KAAN,CAAYgJ,iBAAZ,CAA8BF,QAAQ,CAACG,KAAT,CAAe,CAAf,EAAkB,CAAC,CAAnB,CAA9B,EAAqDR,SAAS,CAACvH,GAAV,CAAc,MAAd,EAAsB9B,IAA3E,EAAiFhB,KAAK,CAAC4B,KAAN,CAAYoE,kBAAZ,CAA+B,CAACqE,SAAS,CAACvH,GAAV,CAAc,OAAd,EAAuB9B,IAAxB,EAA8BwJ,SAA9B,CAA/B,CAAjF,CAAtB;UACD,CAFM,MAEA;YACLH,SAAS,CAACpH,WAAV,CAAsBjD,KAAK,CAAC4B,KAAN,CAAYoE,kBAAZ,CAA+B,CAAChG,KAAK,CAAC4B,KAAN,CAAYkJ,gBAAZ,CAA6BJ,QAAQ,CAACG,KAAT,CAAe,CAAf,EAAkB,CAAC,CAAnB,CAA7B,EAAoDR,SAAS,CAACvH,GAAV,CAAc,MAAd,EAAsB9B,IAA1E,EAAgFqJ,SAAS,CAACvH,GAAV,CAAc,OAAd,EAAuB9B,IAAvG,CAAD,EAA+GwJ,SAA/G,CAA/B,CAAtB;UACD;QACF,CAZD,MAYO,IAAIH,SAAS,CAACzD,kBAAV,EAAJ,EAAoC;UACzCyD,SAAS,CAACpH,WAAV,CAAsBjD,KAAK,CAAC4B,KAAN,CAAYoE,kBAAZ,CAA+B,CAAChG,KAAK,CAAC4B,KAAN,CAAYmJ,eAAZ,CAA4B,GAA5B,EAAiCV,SAAS,CAACvH,GAAV,CAAc,UAAd,EAA0B9B,IAA3D,CAAD,EAAmEwJ,SAAnE,CAA/B,CAAtB;QACD,CAFM,MAEA,IAAIH,SAAS,CAACW,eAAV,EAAJ,EAAiC;UACtCX,SAAS,CAAC1H,WAAV;UACA0H,SAAS,CAACvH,GAAV,CAAc,MAAd,EAAsBG,WAAtB,CAAkCjD,KAAK,CAAC4B,KAAN,CAAYqJ,mBAAZ,CAAgC,KAAhC,EAAuC,CAACjL,KAAK,CAAC4B,KAAN,CAAYsJ,kBAAZ,CAA+Bb,SAAS,CAACnJ,KAAV,CAAgBiK,qBAAhB,CAAsCvK,IAAtC,CAA/B,CAAD,CAAvC,CAAlC;UACAyJ,SAAS,CAACrJ,IAAV,CAAeuI,IAAf,CAAoBA,IAApB,CAAyB6B,OAAzB,CAAiCpL,KAAK,CAAC4B,KAAN,CAAYQ,mBAAZ,CAAgCoI,SAAhC,CAAjC;QACD;MACF;IACF;EACF;;EAEDR,eAAe,CAACqB,gBAAD,EAAmB;IAChC,MAAMC,UAAU,GAAG,KAAKnC,SAAL,CAAejI,KAAlC;IACA,MAAMiD,WAAW,GAAGmH,UAAU,CAAClH,iBAAX,MAAkCkH,UAAU,CAACjH,gBAAX,EAAtD;IACA,MAAMkH,OAAO,GAAG,KAAK/F,aAArB;;IAEA,KAAK,MAAMgG,GAAX,IAAkBD,OAAO,CAACjH,IAAR,EAAlB,EAAkC;MAChC,MAAMiB,GAAG,GAAGgG,OAAO,CAACzI,GAAR,CAAY0I,GAAZ,CAAZ;MACA,MAAMhH,OAAO,GAAG8G,UAAU,CAACG,UAAX,CAAsBlG,GAAG,CAAC3E,IAA1B,CAAhB;MACA,IAAI,CAAC4D,OAAL,EAAc;;MAEd,IAAIA,OAAO,CAACb,IAAR,KAAiB,KAAjB,IAA0Ba,OAAO,CAACb,IAAR,KAAiB,OAA/C,EAAwD;QACtDa,OAAO,CAACb,IAAR,GAAe,KAAf;;QAEA,IAAI0H,gBAAJ,EAAsB;UACpB,IAAIC,UAAU,CAACI,aAAX,CAAyBnG,GAAG,CAAC3E,IAA7B,CAAJ,EAAwC;YACtC0K,UAAU,CAACK,aAAX,CAAyBpG,GAAG,CAAC3E,IAA7B;UACD;QACF,CAJD,MAIO;UACL0K,UAAU,CAAC5G,aAAX,CAAyBa,GAAG,CAAC3E,IAA7B,EAAmCuD,WAAnC;QACD;MACF;IACF;EACF;;EAED+F,KAAK,GAAG;IACN,MAAMqB,OAAO,GAAG,KAAK/F,aAArB;IACA,MAAMoG,cAAc,GAAG,KAAKvC,oBAA5B;IACA,MAAMnI,KAAK,GAAG,KAAKA,KAAnB;IACA,MAAM2K,cAAc,GAAG,KAAK1C,SAAL,CAAejI,KAAtC;;IAEA,KAAK,MAAMsK,GAAX,IAAkBD,OAAO,CAACjH,IAAR,EAAlB,EAAkC;MAChC,MAAMiB,GAAG,GAAGgG,OAAO,CAACzI,GAAR,CAAY0I,GAAZ,CAAZ;;MAEA,IAAItK,KAAK,CAAC4K,gBAAN,CAAuBN,GAAvB,KAA+BtK,KAAK,CAAC6K,SAAN,CAAgBP,GAAhB,CAAnC,EAAyD;QACvD,MAAMhH,OAAO,GAAGtD,KAAK,CAACuD,aAAN,CAAoB+G,GAApB,CAAhB;;QAEA,IAAIhH,OAAJ,EAAa;UACX,MAAMwH,aAAa,GAAG9K,KAAK,CAACD,MAAN,CAAawD,aAAb,CAA2B+G,GAA3B,CAAtB;;UAEA,IAAIhH,OAAO,CAACb,IAAR,KAAiB,SAAjB,IAA8B,CAACa,OAAO,CAACzD,IAAR,CAAaC,IAAb,CAAkBiL,KAAjD,IAA0D,CAACzH,OAAO,CAACzD,IAAR,CAAaC,IAAb,CAAkBkL,SAA7E,KAA2F,CAACF,aAAD,IAAkBrH,KAAK,CAACqH,aAAa,CAACjL,IAAd,CAAmBE,MAApB,CAAlH,KAAkJ,CAACyH,QAAQ,CAAClE,OAAO,CAACzD,IAAR,CAAaoL,UAAd,CAA/J,EAA0L;YACxL;UACD;;UAEDjL,KAAK,CAACkL,MAAN,CAAa7G,GAAG,CAAC3E,IAAjB;QACD;;QAED,IAAIiL,cAAc,CAACH,aAAf,CAA6BF,GAA7B,CAAJ,EAAuC;UACrCK,cAAc,CAACO,MAAf,CAAsB7G,GAAG,CAAC3E,IAA1B;QACD;MACF;IACF;;IAED,KAAK,MAAM4K,GAAX,IAAkBI,cAAc,CAACtH,IAAf,EAAlB,EAAyC;MACvC,MAAMiB,GAAG,GAAGgG,OAAO,CAACzI,GAAR,CAAY0I,GAAZ,CAAZ;;MAEA,IAAI5H,QAAQ,CAAC,KAAKuF,SAAN,CAAR,IAA4B0C,cAAc,CAACH,aAAf,CAA6BF,GAA7B,CAAhC,EAAmE;QACjEK,cAAc,CAACO,MAAf,CAAsB7G,GAAG,CAAC3E,IAA1B;MACD;IACF;EACF;;EAEDqJ,WAAW,GAAG;IACZ,IAAI,KAAKzJ,sBAAT,EAAiC;MAC/B,MAAM,KAAK2I,SAAL,CAAekD,mBAAf,CAAmC,2DAA2D,2BAA9F,CAAN;IACD;;IAED,MAAMjD,KAAK,GAAG,KAAKA,KAAnB;IACA,MAAMkD,WAAW,GAAG,KAAKjD,oBAAzB;;IAEA,IAAI,KAAKK,IAAT,EAAe;MACb,KAAK,MAAM9I,IAAX,IAAmB2L,KAAK,CAACC,IAAN,CAAWF,WAAW,CAAChI,IAAZ,EAAX,CAAnB,EAAmD;QACjD,MAAMvC,EAAE,GAAGuK,WAAW,CAACxJ,GAAZ,CAAgBlC,IAAhB,CAAX;;QAEA,IAAI,KAAKM,KAAL,CAAW6K,SAAX,CAAqBhK,EAAE,CAACnB,IAAxB,KAAiC,KAAKM,KAAL,CAAW4K,gBAAX,CAA4B/J,EAAE,CAACnB,IAA/B,CAArC,EAA2E;UACzE0L,WAAW,CAACG,MAAZ,CAAmB1K,EAAE,CAACnB,IAAtB;UACA,KAAK4E,aAAL,CAAmBiH,MAAnB,CAA0B1K,EAAE,CAACnB,IAA7B;UACA,KAAKM,KAAL,CAAWkL,MAAX,CAAkBrK,EAAE,CAACnB,IAArB;UACA,KAAK4E,aAAL,CAAmBwC,GAAnB,CAAuBjG,EAAE,CAACnB,IAA1B,EAAgCmB,EAAhC;UACAuK,WAAW,CAACtE,GAAZ,CAAgBjG,EAAE,CAACnB,IAAnB,EAAyBmB,EAAzB;QACD;MACF;IACF;;IAED,KAAK6F,GAAL,GAAW,KAAK8E,SAAL,EAAX;IACA,KAAKC,oBAAL;IACA,MAAMC,IAAI,GAAGL,KAAK,CAACC,IAAN,CAAWF,WAAW,CAACO,MAAZ,EAAX,EAAiC7L,IAAI,IAAIhB,KAAK,CAAC4B,KAAN,CAAYE,SAAZ,CAAsBd,IAAtB,CAAzC,CAAb;IACA,MAAM8L,MAAM,GAAGF,IAAI,CAACxG,GAAL,CAASrE,EAAE,IAAI/B,KAAK,CAAC4B,KAAN,CAAYE,SAAZ,CAAsBC,EAAtB,CAAf,CAAf;IACA,MAAMgL,QAAQ,GAAG3D,KAAK,CAAC4D,IAAN,KAAe,iBAAhC;;IAEA,MAAMC,EAAE,GAAGjN,KAAK,CAAC4B,KAAN,CAAYsL,kBAAZ,CAA+B,IAA/B,EAAqCJ,MAArC,EAA6C9M,KAAK,CAAC4B,KAAN,CAAYuL,cAAZ,CAA2BJ,QAAQ,GAAG,CAAC3D,KAAD,CAAH,GAAaA,KAAK,CAACG,IAAtD,CAA7C,CAAX;;IAEA,KAAK6D,gBAAL,CAAsBH,EAAtB;;IAEA,IAAII,IAAI,GAAGrN,KAAK,CAAC4B,KAAN,CAAY6I,cAAZ,CAA2BzK,KAAK,CAAC4B,KAAN,CAAY0L,WAAZ,EAA3B,EAAsDV,IAAtD,CAAX;;IAEA,IAAIW,QAAQ,GAAG,SAAf;;IAEA,MAAMC,QAAQ,GAAGxN,KAAK,CAAC6E,QAAN,CAAe4I,OAAf,CAAuBR,EAAE,CAAC1D,IAA1B,EAAgC,iBAAhC,EAAmDvJ,KAAK,CAAC4B,KAAN,CAAY8L,cAA/D,CAAjB;;IAEA,IAAIF,QAAJ,EAAc;MACZP,EAAE,CAACf,SAAH,GAAe,IAAf;MACAmB,IAAI,GAAGrN,KAAK,CAAC4B,KAAN,CAAY+L,eAAZ,CAA4BN,IAA5B,EAAkC,IAAlC,CAAP;MACAE,QAAQ,GAAG,cAAcA,QAAzB;IACD;;IAED,MAAMK,QAAQ,GAAG5N,KAAK,CAAC6E,QAAN,CAAe4I,OAAf,CAAuBR,EAAE,CAAC1D,IAA1B,EAAgC,iBAAhC,EAAmDvJ,KAAK,CAAC4B,KAAN,CAAY8L,cAA/D,CAAjB;;IAEA,IAAIE,QAAJ,EAAc;MACZX,EAAE,CAAChB,KAAH,GAAW,IAAX;MACAoB,IAAI,GAAGrN,KAAK,CAAC4B,KAAN,CAAYiM,eAAZ,CAA4BR,IAA5B,CAAP;MACAE,QAAQ,GAAG,cAAcA,QAAzB;IACD;;IAED,IAAIO,eAAJ;IACA,IAAIC,KAAJ;;IAEA,IAAI,KAAKnG,GAAL,CAASM,SAAT,IAAsB,KAAKN,GAAL,CAASG,gBAAnC,EAAqD;MACnD,MAAMiG,GAAG,GAAG,KAAK9M,KAAL,CAAW+M,WAAX,CAAuB,KAAvB,CAAZ;MACA,KAAK1E,IAAL,CAAUpH,IAAV,CAAenC,KAAK,CAAC4B,KAAN,CAAYqJ,mBAAZ,CAAgC,KAAhC,EAAuC,CAACjL,KAAK,CAAC4B,KAAN,CAAYsJ,kBAAZ,CAA+BlL,KAAK,CAAC4B,KAAN,CAAYyG,UAAZ,CAAuB2F,GAAvB,CAA/B,EAA4DX,IAA5D,CAAD,CAAvC,CAAf;MACAS,eAAe,GAAG,wBAAwBP,QAA1C;MACAQ,KAAK,GAAG,KAAKxE,IAAL,CAAU9H,MAAV,GAAmB,CAA3B;MACA,KAAKyM,QAAL,CAAcF,GAAd;IACD,CAND,MAMO;MACL,KAAKzE,IAAL,CAAUpH,IAAV,CAAenC,KAAK,CAAC4B,KAAN,CAAYQ,mBAAZ,CAAgCiL,IAAhC,CAAf;MACAS,eAAe,GAAG,eAAeP,QAAjC;MACAQ,KAAK,GAAG,KAAKxE,IAAL,CAAU9H,MAAV,GAAmB,CAA3B;IACD;;IAED,IAAI0M,QAAJ;;IAEA,IAAIpB,QAAJ,EAAc;MACZ,MAAM;QACJZ,UADI;QAEJiC,OAFI;QAGJ5C;MAHI,IAIF,KAAKrC,SAJT;MAKA,KAAKA,SAAL,CAAe3G,mBAAf,CAAmC,KAAK+G,IAAxC;MACA4E,QAAQ,GAAGhC,UAAU,CAACrJ,GAAX,CAAesL,OAAf,EAAwB5C,GAAG,GAAGuC,KAA9B,CAAX;IACD,CARD,MAQO;MACL3E,KAAK,CAACG,IAAN,GAAa,KAAKA,IAAlB;MACA4E,QAAQ,GAAG,KAAKhF,SAAL,CAAerG,GAAf,CAAmB,MAAnB,EAA2BiL,KAA3B,CAAX;IACD;;IAED,MAAMM,WAAW,GAAGF,QAAQ,CAACrL,GAAT,CAAagL,eAAb,CAApB;IACA,IAAIQ,MAAJ;;IAEA,IAAI,KAAK5E,IAAT,EAAe;MACb,MAAM6E,MAAM,GAAG,KAAKrN,KAAL,CAAW+M,WAAX,CAAuB,MAAvB,CAAf;MACA,MAAMO,CAAC,GAAG,KAAKtF,QAAL,CAAcuF,YAAd,CAA2BzO,KAAK,CAAC4B,KAAN,CAAYqJ,mBAAZ,CAAgC,KAAhC,EAAuC,CAACjL,KAAK,CAAC4B,KAAN,CAAYsJ,kBAAZ,CAA+BlL,KAAK,CAAC4B,KAAN,CAAYyG,UAAZ,CAAuBkG,MAAvB,CAA/B,EAA+DtB,EAA/D,CAAD,CAAvC,CAA3B,CAAV;MACAoB,WAAW,CAACpL,WAAZ,CAAwBjD,KAAK,CAAC4B,KAAN,CAAYyG,UAAZ,CAAuBkG,MAAvB,CAAxB;MACAD,MAAM,GAAGE,CAAC,CAAC,CAAD,CAAD,CAAK1L,GAAL,CAAS,qBAAT,CAAT;IACD,CALD,MAKO;MACLuL,WAAW,CAACpL,WAAZ,CAAwBgK,EAAxB;MACAqB,MAAM,GAAGD,WAAT;IACD;;IAEDC,MAAM,CAACI,yBAAP;EACD;;EAEDtB,gBAAgB,CAACH,EAAD,EAAK;IACnB,MAAMvK,KAAK,GAAG;MACZoE,aAAa,EAAE,EADH;MAEZE,gBAAgB,EAAE,EAFN;MAGZH,iBAAiB,EAAE,KAAKwC;IAHZ,CAAd;IAKA,KAAKnI,KAAL,CAAW2D,QAAX,CAAoBoI,EAApB,EAAwBvG,mBAAxB,EAA6ChE,KAA7C;;IAEA,KAAK,IAAInB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0L,EAAE,CAACH,MAAH,CAAUrL,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;MACzC,MAAMoN,KAAK,GAAG1B,EAAE,CAACH,MAAH,CAAUvL,CAAV,CAAd;MACA,IAAI,CAACmB,KAAK,CAACoE,aAAN,CAAoB6H,KAAK,CAAC/N,IAA1B,CAAL,EAAsC;MACtC,MAAMgO,SAAS,GAAGD,KAAK,CAAC/N,IAAxB;MACA,MAAMiO,YAAY,GAAG,KAAK3N,KAAL,CAAW+M,WAAX,CAAuBU,KAAK,CAAC/N,IAA7B,CAArB;MACAqM,EAAE,CAACH,MAAH,CAAUvL,CAAV,IAAevB,KAAK,CAAC4B,KAAN,CAAYyG,UAAZ,CAAuBwG,YAAvB,CAAf;MACA,KAAK3N,KAAL,CAAWkL,MAAX,CAAkBwC,SAAlB,EAA6BC,YAA7B,EAA2C5B,EAA3C;MACAvK,KAAK,CAACsE,gBAAN,CAAuB8H,OAAvB,CAA+BvG,eAAe,IAAI;QAChDA,eAAe,CAACkG,YAAhB,CAA6BzO,KAAK,CAAC4B,KAAN,CAAYQ,mBAAZ,CAAgCpC,KAAK,CAAC4B,KAAN,CAAYC,oBAAZ,CAAiC,GAAjC,EAAsC7B,KAAK,CAAC4B,KAAN,CAAYyG,UAAZ,CAAuBuG,SAAvB,CAAtC,EAAyE5O,KAAK,CAAC4B,KAAN,CAAYyG,UAAZ,CAAuBwG,YAAvB,CAAzE,CAAhC,CAA7B;MACD,CAFD;MAGA5B,EAAE,CAAC1D,IAAH,CAAQA,IAAR,CAAapH,IAAb,CAAkBnC,KAAK,CAAC4B,KAAN,CAAYQ,mBAAZ,CAAgCpC,KAAK,CAAC4B,KAAN,CAAYC,oBAAZ,CAAiC,GAAjC,EAAsC7B,KAAK,CAAC4B,KAAN,CAAYyG,UAAZ,CAAuBuG,SAAvB,CAAtC,EAAyE5O,KAAK,CAAC4B,KAAN,CAAYyG,UAAZ,CAAuBwG,YAAvB,CAAzE,CAAhC,CAAlB;IACD;EACF;;EAED/E,gBAAgB,GAAG;IACjB,MAAMV,KAAK,GAAG,KAAKA,KAAnB;IACA,MAAM2F,WAAW,GAAG,EAApB;;IAEA,IAAI,KAAKrF,IAAT,EAAe;MACb,MAAM1H,IAAI,GAAG,KAAK0H,IAAL,CAAUvD,IAAV,IAAkB,KAAKuD,IAAL,CAAU1H,IAAzC;;MAEA,IAAIb,aAAa,CAACa,IAAD,CAAjB,EAAyB;QACvB+M,WAAW,CAAC5M,IAAZ,CAAiBH,IAAjB;;QAEA,MAAMgN,KAAK,GAAGhP,KAAK,CAAC4B,KAAN,CAAY2C,qBAAZ,CAAkCvC,IAAlC,CAAd;;QAEA,KAAK,MAAMpB,IAAX,IAAmBpB,MAAM,CAAC8E,IAAP,CAAY0K,KAAZ,CAAnB,EAAuC;UACrC,KAAK3F,oBAAL,CAA0BrB,GAA1B,CAA8BpH,IAA9B,EAAoCoO,KAAK,CAACpO,IAAD,CAAzC;QACD;MACF;IACF;;IAED,MAAMqO,wBAAwB,GAAG,CAAClO,IAAD,EAAOC,IAAP,KAAgB;MAC/C,IAAIhB,KAAK,CAAC4B,KAAN,CAAYsN,kBAAZ,CAA+BlO,IAA/B,KAAwChB,KAAK,CAAC4B,KAAN,CAAYuN,qBAAZ,CAAkCnO,IAAlC,CAAxC,IAAmFG,aAAa,CAACH,IAAD,CAApG,EAA4G;QAC1G,IAAIG,aAAa,CAACH,IAAD,CAAjB,EAAyB;UACvBI,uBAAuB,CAACL,IAAD,EAAOC,IAAP,EAAaoI,KAAb,EAAoB,KAAKlI,KAAzB,CAAvB;QACD;;QAED,IAAIF,IAAI,CAACgM,IAAL,KAAc,qBAAlB,EAAyC;UACvC,KAAK,IAAIzL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,IAAI,CAACQ,YAAL,CAAkBC,MAAtC,EAA8CF,CAAC,EAA/C,EAAmD;YACjDwN,WAAW,CAAC5M,IAAZ,CAAiBnB,IAAI,CAACQ,YAAL,CAAkBD,CAAlB,CAAjB;UACD;QACF,CAJD,MAIO;UACLwN,WAAW,CAAC5M,IAAZ,CAAiBnB,IAAjB;QACD;MACF;;MAED,IAAIhB,KAAK,CAAC4B,KAAN,CAAYgI,kBAAZ,CAA+B5I,IAA/B,CAAJ,EAA0C;QACxCiO,wBAAwB,CAAClO,IAAI,CAAC+B,GAAL,CAAS,MAAT,CAAD,EAAmB9B,IAAI,CAACuI,IAAxB,CAAxB;MACD;IACF,CAlBD;;IAoBA,IAAIH,KAAK,CAAC4D,IAAN,KAAe,iBAAnB,EAAsC;MACpC,MAAMoC,WAAW,GAAG,KAAKjG,SAAL,CAAerG,GAAf,CAAmB,OAAnB,CAApB;;MAEA,KAAK,IAAIvB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6H,KAAK,CAACiG,KAAN,CAAY5N,MAAhC,EAAwCF,CAAC,EAAzC,EAA6C;QAC3C,MAAM+N,WAAW,GAAGlG,KAAK,CAACiG,KAAN,CAAY9N,CAAZ,EAAegO,UAAnC;;QAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,WAAW,CAAC7N,MAAhC,EAAwC+N,CAAC,EAAzC,EAA6C;UAC3C,MAAMtL,MAAM,GAAGoL,WAAW,CAACE,CAAD,CAA1B;UACAP,wBAAwB,CAACG,WAAW,CAAC7N,CAAD,CAAZ,EAAiB2C,MAAjB,CAAxB;QACD;MACF;IACF,CAXD,MAWO;MACL,MAAMkL,WAAW,GAAG,KAAKjG,SAAL,CAAerG,GAAf,CAAmB,MAAnB,CAApB;;MAEA,KAAK,IAAIvB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6H,KAAK,CAACG,IAAN,CAAW9H,MAA/B,EAAuCF,CAAC,EAAxC,EAA4C;QAC1C0N,wBAAwB,CAACG,WAAW,CAAC7N,CAAD,CAAZ,EAAiB6N,WAAW,CAAC7N,CAAD,CAAX,CAAeP,IAAhC,CAAxB;MACD;IACF;;IAED,KAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwN,WAAW,CAACtN,MAAhC,EAAwCF,CAAC,EAAzC,EAA6C;MAC3C,MAAM2C,MAAM,GAAG6K,WAAW,CAACxN,CAAD,CAA1B;;MAEA,MAAM+C,IAAI,GAAGtE,KAAK,CAAC4B,KAAN,CAAY2C,qBAAZ,CAAkCL,MAAlC,EAA0C,KAA1C,EAAiD,IAAjD,CAAb;;MAEA,KAAK,MAAMsH,GAAX,IAAkBhM,MAAM,CAAC8E,IAAP,CAAYA,IAAZ,CAAlB,EAAqC;QACnC,KAAKkB,aAAL,CAAmBwC,GAAnB,CAAuBwD,GAAvB,EAA4BlH,IAAI,CAACkH,GAAD,CAAhC;MACD;;MAED,KAAKlC,gBAAL,GAAwB,IAAxB;IACD;;IAED,IAAI,CAAC,KAAKA,gBAAV,EAA4B;IAC5B,MAAM5G,KAAK,GAAG;MACZ8C,aAAa,EAAE,KAAKA,aADR;MAEZG,SAAS,EAAE,KAFC;MAGZV,SAAS,EAAE,CAHC;MAIZvE,UAAU,EAAE,KAAKA,UAJL;MAKZ2B,SAAS,EAAEzB,IAAI,IAAI,KAAK8B,KAAL,CAAWL,SAAX,CAAqBzB,IAArB;IALP,CAAd;;IAQA,IAAIgD,QAAQ,CAAC,KAAKuF,SAAN,CAAZ,EAA8B;MAC5BzG,KAAK,CAACuC,SAAN;IACD;;IAED,KAAKkE,SAAL,CAAetE,QAAf,CAAwBD,wBAAxB,EAAkDlC,KAAlD;IACA,OAAOA,KAAK,CAACiD,SAAb;EACD;;EAED+G,SAAS,GAAG;IACV,MAAMhK,KAAK,GAAG;MACZqF,gBAAgB,EAAE,KADN;MAEZT,cAAc,EAAE,KAFJ;MAGZI,YAAY,EAAE,KAHF;MAIZlB,WAAW,EAAE,EAJD;MAKZ0B,SAAS,EAAE,KALC;MAMZ9E,MAAM,EAAE,CAAC,CAAC,KAAKsG,IANH;MAOZtD,GAAG,EAAE,IAAIuD,GAAJ,EAPO;MAQZhC,WAAW,EAAE,IAAIzH,OAAJ;IARD,CAAd;IAUA,KAAKiJ,SAAL,CAAetE,QAAf,CAAwByB,gBAAxB,EAA0C5D,KAA1C;IACA,KAAKyG,SAAL,CAAetE,QAAf,CAAwBuC,WAAxB,EAAqC1E,KAArC;IACA,OAAOA,KAAP;EACD;;EAEDiK,oBAAoB,GAAG;IACrB,KAAKxD,SAAL,CAAetE,QAAf,CAAwBe,2BAAxB,EAAqD,IAArD;EACD;;EAEDG,UAAU,CAAC/E,IAAD,EAAO;IACf,MAAMyO,OAAO,GAAG,EAAhB;;IAEA,MAAMT,KAAK,GAAGhP,KAAK,CAAC4B,KAAN,CAAY2C,qBAAZ,CAAkCvD,IAAlC,CAAd;;IAEA,KAAK,MAAMJ,IAAX,IAAmBpB,MAAM,CAAC8E,IAAP,CAAY0K,KAAZ,CAAnB,EAAuC;MACrCS,OAAO,CAACtN,IAAR,CAAanC,KAAK,CAAC4B,KAAN,CAAYsJ,kBAAZ,CAA+B8D,KAAK,CAACpO,IAAD,CAApC,CAAb;IACD;;IAED,KAAK2I,IAAL,CAAUpH,IAAV,CAAenC,KAAK,CAAC4B,KAAN,CAAYqJ,mBAAZ,CAAgCjK,IAAI,CAAC2C,IAArC,EAA2C8L,OAA3C,CAAf;IACA,MAAM1M,OAAO,GAAG,EAAhB;;IAEA,KAAK,IAAIxB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,IAAI,CAACQ,YAAL,CAAkBC,MAAtC,EAA8CF,CAAC,EAA/C,EAAmD;MACjD,MAAM2C,MAAM,GAAGlD,IAAI,CAACQ,YAAL,CAAkBD,CAAlB,CAAf;MACA,IAAI,CAAC2C,MAAM,CAAClC,IAAZ,EAAkB;;MAElB,MAAMqE,IAAI,GAAGrG,KAAK,CAAC4B,KAAN,CAAYC,oBAAZ,CAAiC,GAAjC,EAAsC7B,KAAK,CAAC4B,KAAN,CAAYE,SAAZ,CAAsBoC,MAAM,CAACnC,EAA7B,CAAtC,EAAwE/B,KAAK,CAAC4B,KAAN,CAAYE,SAAZ,CAAsBoC,MAAM,CAAClC,IAA7B,CAAxE,CAAb;;MAEAe,OAAO,CAACZ,IAAR,CAAanC,KAAK,CAAC4B,KAAN,CAAY6G,QAAZ,CAAqBpC,IAArB,EAA2BnC,MAA3B,CAAb;IACD;;IAED,OAAOnB,OAAP;EACD;;EAEDmL,QAAQ,CAACF,GAAD,EAAM;IACZ,MAAMzE,IAAI,GAAG,KAAKA,IAAlB;IACA,MAAM3B,GAAG,GAAG,KAAKA,GAAjB;;IAEA,IAAIA,GAAG,CAACG,gBAAR,EAA0B;MACxB,KAAK,MAAMyD,GAAX,IAAkB5D,GAAG,CAACxB,GAAJ,CAAQ9B,IAAR,EAAlB,EAAkC;QAChCiF,IAAI,CAACpH,IAAL,CAAUnC,KAAK,CAAC4B,KAAN,CAAY8N,WAAZ,CAAwB1P,KAAK,CAAC4B,KAAN,CAAYkJ,gBAAZ,CAA6B,KAA7B,EAAoC9K,KAAK,CAAC4B,KAAN,CAAYyG,UAAZ,CAAuB2F,GAAvB,CAApC,EAAiEhO,KAAK,CAAC4B,KAAN,CAAYqG,aAAZ,CAA0BuD,GAA1B,CAAjE,CAAxB,EAA0H5D,GAAG,CAACxB,GAAJ,CAAQtD,GAAR,CAAY0I,GAAZ,CAA1H,CAAV;MACD;IACF;;IAED,IAAI5D,GAAG,CAACM,SAAR,EAAmB;MACjBqB,IAAI,CAACpH,IAAL,CAAUmB,aAAa,CAAC;QACtBqM,MAAM,EAAE3P,KAAK,CAAC4B,KAAN,CAAYyG,UAAZ,CAAuB2F,GAAvB;MADc,CAAD,CAAvB;IAGD;EACF;;AA3agB"},"metadata":{},"sourceType":"script"}