{"ast":null,"code":"import selectorParser from 'postcss-selector-parser';\nimport unescape from 'postcss-selector-parser/dist/util/unesc';\nimport escapeClassName from '../util/escapeClassName';\nimport prefixSelector from '../util/prefixSelector';\nlet MERGE = ':merge';\nlet PARENT = '&';\nexport let selectorFunctions = new Set([MERGE]);\nexport function formatVariantSelector(current) {\n  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    others[_key - 1] = arguments[_key];\n  }\n\n  for (let other of others) {\n    let incomingValue = resolveFunctionArgument(other, MERGE);\n\n    if (incomingValue !== null) {\n      let existingValue = resolveFunctionArgument(current, MERGE, incomingValue);\n\n      if (existingValue !== null) {\n        let existingTarget = `${MERGE}(${incomingValue})`;\n        let splitIdx = other.indexOf(existingTarget);\n        let addition = other.slice(splitIdx + existingTarget.length).split(' ')[0];\n        current = current.replace(existingTarget, existingTarget + addition);\n        continue;\n      }\n    }\n\n    current = other.replace(PARENT, current);\n  }\n\n  return current;\n}\nexport function finalizeSelector(format, _ref) {\n  let {\n    selector,\n    candidate,\n    context,\n    isArbitraryVariant,\n    // Split by the separator, but ignore the separator inside square brackets:\n    //\n    // E.g.: dark:lg:hover:[paint-order:markers]\n    //           ┬  ┬     ┬            ┬\n    //           │  │     │            ╰── We will not split here\n    //           ╰──┴─────┴─────────────── We will split here\n    //\n    base = candidate.split(new RegExp(`\\\\${context?.tailwindConfig?.separator ?? ':'}(?![^[]*\\\\])`)).pop()\n  } = _ref;\n  let ast = selectorParser().astSync(selector); // We explicitly DO NOT prefix classes in arbitrary variants\n\n  if (context?.tailwindConfig?.prefix && !isArbitraryVariant) {\n    format = prefixSelector(context.tailwindConfig.prefix, format);\n  }\n\n  format = format.replace(PARENT, `.${escapeClassName(candidate)}`);\n  let formatAst = selectorParser().astSync(format); // Remove extraneous selectors that do not include the base class/candidate being matched against\n  // For example if we have a utility defined `.a, .b { color: red}`\n  // And the formatted variant is sm:b then we want the final selector to be `.sm\\:b` and not `.a, .sm\\:b`\n\n  ast.each(node => {\n    let hasClassesMatchingCandidate = node.some(n => n.type === 'class' && n.value === base);\n\n    if (!hasClassesMatchingCandidate) {\n      node.remove();\n    }\n  }); // Normalize escaped classes, e.g.:\n  //\n  // The idea would be to replace the escaped `base` in the selector with the\n  // `format`. However, in css you can escape the same selector in a few\n  // different ways. This would result in different strings and therefore we\n  // can't replace it properly.\n  //\n  //               base: bg-[rgb(255,0,0)]\n  //   base in selector: bg-\\\\[rgb\\\\(255\\\\,0\\\\,0\\\\)\\\\]\n  //       escaped base: bg-\\\\[rgb\\\\(255\\\\2c 0\\\\2c 0\\\\)\\\\]\n  //\n\n  ast.walkClasses(node => {\n    if (node.raws && node.value.includes(base)) {\n      node.raws.value = escapeClassName(unescape(node.raws.value));\n    }\n  }); // We can safely replace the escaped base now, since the `base` section is\n  // now in a normalized escaped value.\n\n  ast.walkClasses(node => {\n    if (node.value === base) {\n      node.replaceWith(...formatAst.nodes);\n    }\n  }); // This will make sure to move pseudo's to the correct spot (the end for\n  // pseudo elements) because otherwise the selector will never work\n  // anyway.\n  //\n  // E.g.:\n  //  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n  //  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n  //\n  // `::before:hover` doesn't work, which means that we can make it work for you by flipping the order.\n\n  function collectPseudoElements(selector) {\n    let nodes = [];\n\n    for (let node of selector.nodes) {\n      if (isPseudoElement(node)) {\n        nodes.push(node);\n        selector.removeChild(node);\n      }\n\n      if (node?.nodes) {\n        nodes.push(...collectPseudoElements(node));\n      }\n    }\n\n    return nodes;\n  } // Remove unnecessary pseudo selectors that we used as placeholders\n\n\n  ast.each(selector => {\n    selector.walkPseudos(p => {\n      if (selectorFunctions.has(p.value)) {\n        p.replaceWith(p.nodes);\n      }\n    });\n    let pseudoElements = collectPseudoElements(selector);\n\n    if (pseudoElements.length > 0) {\n      selector.nodes.push(pseudoElements.sort(sortSelector));\n    }\n  });\n  return ast.toString();\n} // Note: As a rule, double colons (::) should be used instead of a single colon\n// (:). This distinguishes pseudo-classes from pseudo-elements. However, since\n// this distinction was not present in older versions of the W3C spec, most\n// browsers support both syntaxes for the original pseudo-elements.\n\nlet pseudoElementsBC = [':before', ':after', ':first-line', ':first-letter']; // These pseudo-elements _can_ be combined with other pseudo selectors AND the order does matter.\n\nlet pseudoElementExceptions = ['::file-selector-button']; // This will make sure to move pseudo's to the correct spot (the end for\n// pseudo elements) because otherwise the selector will never work\n// anyway.\n//\n// E.g.:\n//  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n//  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n//\n// `::before:hover` doesn't work, which means that we can make it work\n// for you by flipping the order.\n\nfunction sortSelector(a, z) {\n  // Both nodes are non-pseudo's so we can safely ignore them and keep\n  // them in the same order.\n  if (a.type !== 'pseudo' && z.type !== 'pseudo') {\n    return 0;\n  } // If one of them is a combinator, we need to keep it in the same order\n  // because that means it will start a new \"section\" in the selector.\n\n\n  if (a.type === 'combinator' ^ z.type === 'combinator') {\n    return 0;\n  } // One of the items is a pseudo and the other one isn't. Let's move\n  // the pseudo to the right.\n\n\n  if (a.type === 'pseudo' ^ z.type === 'pseudo') {\n    return (a.type === 'pseudo') - (z.type === 'pseudo');\n  } // Both are pseudo's, move the pseudo elements (except for\n  // ::file-selector-button) to the right.\n\n\n  return isPseudoElement(a) - isPseudoElement(z);\n}\n\nfunction isPseudoElement(node) {\n  if (node.type !== 'pseudo') return false;\n  if (pseudoElementExceptions.includes(node.value)) return false;\n  return node.value.startsWith('::') || pseudoElementsBC.includes(node.value);\n}\n\nfunction resolveFunctionArgument(haystack, needle, arg) {\n  let startIdx = haystack.indexOf(arg ? `${needle}(${arg})` : needle);\n  if (startIdx === -1) return null; // Start inside the `(`\n\n  startIdx += needle.length + 1;\n  let target = '';\n  let count = 0;\n\n  for (let char of haystack.slice(startIdx)) {\n    if (char !== '(' && char !== ')') {\n      target += char;\n    } else if (char === '(') {\n      target += char;\n      count++;\n    } else if (char === ')') {\n      if (--count < 0) break; // unbalanced\n\n      target += char;\n    }\n  }\n\n  return target;\n}","map":{"version":3,"names":["selectorParser","unescape","escapeClassName","prefixSelector","MERGE","PARENT","selectorFunctions","Set","formatVariantSelector","current","others","other","incomingValue","resolveFunctionArgument","existingValue","existingTarget","splitIdx","indexOf","addition","slice","length","split","replace","finalizeSelector","format","selector","candidate","context","isArbitraryVariant","base","RegExp","tailwindConfig","separator","pop","ast","astSync","prefix","formatAst","each","node","hasClassesMatchingCandidate","some","n","type","value","remove","walkClasses","raws","includes","replaceWith","nodes","collectPseudoElements","isPseudoElement","push","removeChild","walkPseudos","p","has","pseudoElements","sort","sortSelector","toString","pseudoElementsBC","pseudoElementExceptions","a","z","startsWith","haystack","needle","arg","startIdx","target","count","char"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/src/util/formatVariantSelector.js"],"sourcesContent":["import selectorParser from 'postcss-selector-parser'\nimport unescape from 'postcss-selector-parser/dist/util/unesc'\nimport escapeClassName from '../util/escapeClassName'\nimport prefixSelector from '../util/prefixSelector'\n\nlet MERGE = ':merge'\nlet PARENT = '&'\n\nexport let selectorFunctions = new Set([MERGE])\n\nexport function formatVariantSelector(current, ...others) {\n  for (let other of others) {\n    let incomingValue = resolveFunctionArgument(other, MERGE)\n    if (incomingValue !== null) {\n      let existingValue = resolveFunctionArgument(current, MERGE, incomingValue)\n      if (existingValue !== null) {\n        let existingTarget = `${MERGE}(${incomingValue})`\n        let splitIdx = other.indexOf(existingTarget)\n        let addition = other.slice(splitIdx + existingTarget.length).split(' ')[0]\n\n        current = current.replace(existingTarget, existingTarget + addition)\n        continue\n      }\n    }\n\n    current = other.replace(PARENT, current)\n  }\n\n  return current\n}\n\nexport function finalizeSelector(\n  format,\n  {\n    selector,\n    candidate,\n    context,\n    isArbitraryVariant,\n\n    // Split by the separator, but ignore the separator inside square brackets:\n    //\n    // E.g.: dark:lg:hover:[paint-order:markers]\n    //           ┬  ┬     ┬            ┬\n    //           │  │     │            ╰── We will not split here\n    //           ╰──┴─────┴─────────────── We will split here\n    //\n    base = candidate\n      .split(new RegExp(`\\\\${context?.tailwindConfig?.separator ?? ':'}(?![^[]*\\\\])`))\n      .pop(),\n  }\n) {\n  let ast = selectorParser().astSync(selector)\n\n  // We explicitly DO NOT prefix classes in arbitrary variants\n  if (context?.tailwindConfig?.prefix && !isArbitraryVariant) {\n    format = prefixSelector(context.tailwindConfig.prefix, format)\n  }\n\n  format = format.replace(PARENT, `.${escapeClassName(candidate)}`)\n\n  let formatAst = selectorParser().astSync(format)\n\n  // Remove extraneous selectors that do not include the base class/candidate being matched against\n  // For example if we have a utility defined `.a, .b { color: red}`\n  // And the formatted variant is sm:b then we want the final selector to be `.sm\\:b` and not `.a, .sm\\:b`\n  ast.each((node) => {\n    let hasClassesMatchingCandidate = node.some((n) => n.type === 'class' && n.value === base)\n\n    if (!hasClassesMatchingCandidate) {\n      node.remove()\n    }\n  })\n\n  // Normalize escaped classes, e.g.:\n  //\n  // The idea would be to replace the escaped `base` in the selector with the\n  // `format`. However, in css you can escape the same selector in a few\n  // different ways. This would result in different strings and therefore we\n  // can't replace it properly.\n  //\n  //               base: bg-[rgb(255,0,0)]\n  //   base in selector: bg-\\\\[rgb\\\\(255\\\\,0\\\\,0\\\\)\\\\]\n  //       escaped base: bg-\\\\[rgb\\\\(255\\\\2c 0\\\\2c 0\\\\)\\\\]\n  //\n  ast.walkClasses((node) => {\n    if (node.raws && node.value.includes(base)) {\n      node.raws.value = escapeClassName(unescape(node.raws.value))\n    }\n  })\n\n  // We can safely replace the escaped base now, since the `base` section is\n  // now in a normalized escaped value.\n  ast.walkClasses((node) => {\n    if (node.value === base) {\n      node.replaceWith(...formatAst.nodes)\n    }\n  })\n\n  // This will make sure to move pseudo's to the correct spot (the end for\n  // pseudo elements) because otherwise the selector will never work\n  // anyway.\n  //\n  // E.g.:\n  //  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n  //  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n  //\n  // `::before:hover` doesn't work, which means that we can make it work for you by flipping the order.\n  function collectPseudoElements(selector) {\n    let nodes = []\n\n    for (let node of selector.nodes) {\n      if (isPseudoElement(node)) {\n        nodes.push(node)\n        selector.removeChild(node)\n      }\n\n      if (node?.nodes) {\n        nodes.push(...collectPseudoElements(node))\n      }\n    }\n\n    return nodes\n  }\n\n  // Remove unnecessary pseudo selectors that we used as placeholders\n  ast.each((selector) => {\n    selector.walkPseudos((p) => {\n      if (selectorFunctions.has(p.value)) {\n        p.replaceWith(p.nodes)\n      }\n    })\n\n    let pseudoElements = collectPseudoElements(selector)\n    if (pseudoElements.length > 0) {\n      selector.nodes.push(pseudoElements.sort(sortSelector))\n    }\n  })\n\n  return ast.toString()\n}\n\n// Note: As a rule, double colons (::) should be used instead of a single colon\n// (:). This distinguishes pseudo-classes from pseudo-elements. However, since\n// this distinction was not present in older versions of the W3C spec, most\n// browsers support both syntaxes for the original pseudo-elements.\nlet pseudoElementsBC = [':before', ':after', ':first-line', ':first-letter']\n\n// These pseudo-elements _can_ be combined with other pseudo selectors AND the order does matter.\nlet pseudoElementExceptions = ['::file-selector-button']\n\n// This will make sure to move pseudo's to the correct spot (the end for\n// pseudo elements) because otherwise the selector will never work\n// anyway.\n//\n// E.g.:\n//  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n//  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n//\n// `::before:hover` doesn't work, which means that we can make it work\n// for you by flipping the order.\nfunction sortSelector(a, z) {\n  // Both nodes are non-pseudo's so we can safely ignore them and keep\n  // them in the same order.\n  if (a.type !== 'pseudo' && z.type !== 'pseudo') {\n    return 0\n  }\n\n  // If one of them is a combinator, we need to keep it in the same order\n  // because that means it will start a new \"section\" in the selector.\n  if ((a.type === 'combinator') ^ (z.type === 'combinator')) {\n    return 0\n  }\n\n  // One of the items is a pseudo and the other one isn't. Let's move\n  // the pseudo to the right.\n  if ((a.type === 'pseudo') ^ (z.type === 'pseudo')) {\n    return (a.type === 'pseudo') - (z.type === 'pseudo')\n  }\n\n  // Both are pseudo's, move the pseudo elements (except for\n  // ::file-selector-button) to the right.\n  return isPseudoElement(a) - isPseudoElement(z)\n}\n\nfunction isPseudoElement(node) {\n  if (node.type !== 'pseudo') return false\n  if (pseudoElementExceptions.includes(node.value)) return false\n\n  return node.value.startsWith('::') || pseudoElementsBC.includes(node.value)\n}\n\nfunction resolveFunctionArgument(haystack, needle, arg) {\n  let startIdx = haystack.indexOf(arg ? `${needle}(${arg})` : needle)\n  if (startIdx === -1) return null\n\n  // Start inside the `(`\n  startIdx += needle.length + 1\n\n  let target = ''\n  let count = 0\n\n  for (let char of haystack.slice(startIdx)) {\n    if (char !== '(' && char !== ')') {\n      target += char\n    } else if (char === '(') {\n      target += char\n      count++\n    } else if (char === ')') {\n      if (--count < 0) break // unbalanced\n      target += char\n    }\n  }\n\n  return target\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}