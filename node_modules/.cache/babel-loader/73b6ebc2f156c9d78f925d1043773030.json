{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst error = {\n  message: _ref => {\n    let {\n      schemaCode\n    } = _ref;\n    return (0, codegen_1.str)`must be multiple of ${schemaCode}`;\n  },\n  params: _ref2 => {\n    let {\n      schemaCode\n    } = _ref2;\n    return (0, codegen_1._)`{multipleOf: ${schemaCode}}`;\n  }\n};\nconst def = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      schemaCode,\n      it\n    } = cxt; // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n\n    const prec = it.opts.multipleOfPrecision;\n    const res = gen.let(\"res\");\n    const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;\n    cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":";;;;;;AAEA;;AAQA,MAAMA,KAAK,GAA2B;EACpCC,OAAO,EAAE;IAAA,IAAC;MAACC;IAAD,CAAD;IAAA,OAAkB,kBAAG,uBAAuBA,UAAU,EAAtD;EAAA,CAD2B;EAEpCC,MAAM,EAAE;IAAA,IAAC;MAACD;IAAD,CAAD;IAAA,OAAkB,gBAAC,gBAAgBA,UAAU,GAA7C;EAAA;AAF4B,CAAtC;AAKA,MAAME,GAAG,GAA0B;EACjCC,OAAO,EAAE,YADwB;EAEjCC,IAAI,EAAE,QAF2B;EAGjCC,UAAU,EAAE,QAHqB;EAIjCC,KAAK,EAAE,IAJ0B;EAKjCR,KALiC;;EAMjCS,IAAI,CAACC,GAAD,EAAgB;IAClB,MAAM;MAACC,GAAD;MAAMC,IAAN;MAAYV,UAAZ;MAAwBW;IAAxB,IAA8BH,GAApC,CADkB,CAElB;;IACA,MAAMI,IAAI,GAAGD,EAAE,CAACE,IAAH,CAAQC,mBAArB;IACA,MAAMC,GAAG,GAAGN,GAAG,CAACO,GAAJ,CAAQ,KAAR,CAAZ;IACA,MAAMC,OAAO,GAAGL,IAAI,GAChB,gBAAC,uBAAuBG,GAAG,OAAOA,GAAG,UAAUH,IAAI,EADnC,GAEhB,gBAAC,GAAGG,GAAG,iBAAiBA,GAAG,GAF/B;IAGAP,GAAG,CAACU,SAAJ,CAAc,gBAAC,IAAIlB,UAAU,cAAce,GAAG,MAAML,IAAI,IAAIV,UAAU,KAAKiB,OAAO,IAAlF;EACD;;AAfgC,CAAnC;AAkBAE,kBAAejB,GAAf","names":["error","message","schemaCode","params","def","keyword","type","schemaType","$data","code","cxt","gen","data","it","prec","opts","multipleOfPrecision","res","let","invalid","fail$data","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\vocabularies\\validation\\multipleOf.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}