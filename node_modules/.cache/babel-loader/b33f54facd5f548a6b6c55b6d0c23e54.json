{"ast":null,"code":"'use strict';\n\nvar _minimatch = require('minimatch');\n\nvar _minimatch2 = _interopRequireDefault(_minimatch);\n\nvar _resolve = require('eslint-module-utils/resolve');\n\nvar _resolve2 = _interopRequireDefault(_resolve);\n\nvar _importType = require('../core/importType');\n\nvar _importType2 = _interopRequireDefault(_importType);\n\nvar _moduleVisitor = require('eslint-module-utils/moduleVisitor');\n\nvar _moduleVisitor2 = _interopRequireDefault(_moduleVisitor);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: (0, _docsUrl2['default'])('no-internal-modules')\n    },\n    schema: [{\n      oneOf: [{\n        type: 'object',\n        properties: {\n          allow: {\n            type: 'array',\n            items: {\n              type: 'string'\n            }\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: 'object',\n        properties: {\n          forbid: {\n            type: 'array',\n            items: {\n              type: 'string'\n            }\n          }\n        },\n        additionalProperties: false\n      }]\n    }]\n  },\n  create: function () {\n    function noReachingInside(context) {\n      var options = context.options[0] || {};\n      var allowRegexps = (options.allow || []).map(function (p) {\n        return _minimatch2['default'].makeRe(p);\n      });\n      var forbidRegexps = (options.forbid || []).map(function (p) {\n        return _minimatch2['default'].makeRe(p);\n      }); // minimatch patterns are expected to use / path separators, like import\n      // statements, so normalize paths to use the same\n\n      function normalizeSep(somePath) {\n        return somePath.split('\\\\').join('/');\n      }\n\n      function toSteps(somePath) {\n        return normalizeSep(somePath).split('/').reduce(function (acc, step) {\n          if (!step || step === '.') {\n            return acc;\n          } else if (step === '..') {\n            return acc.slice(0, -1);\n          } else {\n            return acc.concat(step);\n          }\n        }, []);\n      } // test if reaching to this destination is allowed\n\n\n      function reachingAllowed(importPath) {\n        return allowRegexps.some(function (re) {\n          return re.test(importPath);\n        });\n      } // test if reaching to this destination is forbidden\n\n\n      function reachingForbidden(importPath) {\n        return forbidRegexps.some(function (re) {\n          return re.test(importPath);\n        });\n      }\n\n      function isAllowViolation(importPath) {\n        var steps = toSteps(importPath);\n        var nonScopeSteps = steps.filter(function (step) {\n          return step.indexOf('@') !== 0;\n        });\n        if (nonScopeSteps.length <= 1) return false; // before trying to resolve, see if the raw import (with relative\n        // segments resolved) matches an allowed pattern\n\n        var justSteps = steps.join('/');\n        if (reachingAllowed(justSteps) || reachingAllowed('/' + String(justSteps))) return false; // if the import statement doesn't match directly, try to match the\n        // resolved path if the import is resolvable\n\n        var resolved = (0, _resolve2['default'])(importPath, context);\n        if (!resolved || reachingAllowed(normalizeSep(resolved))) return false; // this import was not allowed by the allowed paths, and reaches\n        // so it is a violation\n\n        return true;\n      }\n\n      function isForbidViolation(importPath) {\n        var steps = toSteps(importPath); // before trying to resolve, see if the raw import (with relative\n        // segments resolved) matches a forbidden pattern\n\n        var justSteps = steps.join('/');\n        if (reachingForbidden(justSteps) || reachingForbidden('/' + String(justSteps))) return true; // if the import statement doesn't match directly, try to match the\n        // resolved path if the import is resolvable\n\n        var resolved = (0, _resolve2['default'])(importPath, context);\n        if (resolved && reachingForbidden(normalizeSep(resolved))) return true; // this import was not forbidden by the forbidden paths so it is not a violation\n\n        return false;\n      } // find a directory that is being reached into, but which shouldn't be\n\n\n      var isReachViolation = options.forbid ? isForbidViolation : isAllowViolation;\n\n      function checkImportForReaching(importPath, node) {\n        var potentialViolationTypes = ['parent', 'index', 'sibling', 'external', 'internal'];\n\n        if (potentialViolationTypes.indexOf((0, _importType2['default'])(importPath, context)) !== -1 && isReachViolation(importPath)) {\n          context.report({\n            node: node,\n            message: 'Reaching to \"' + String(importPath) + '\" is not allowed.'\n          });\n        }\n      }\n\n      return (0, _moduleVisitor2['default'])(function (source) {\n        checkImportForReaching(source.value, source);\n      }, {\n        commonjs: true\n      });\n    }\n\n    return noReachingInside;\n  }()\n};","map":{"version":3,"mappings":"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","names":["module","exports","meta","type","docs","url","schema","oneOf","properties","allow","items","additionalProperties","forbid","create","noReachingInside","context","options","allowRegexps","map","minimatch","makeRe","p","forbidRegexps","normalizeSep","somePath","split","join","toSteps","reduce","acc","step","slice","concat","reachingAllowed","importPath","some","re","test","reachingForbidden","isAllowViolation","steps","nonScopeSteps","filter","indexOf","length","justSteps","resolved","isForbidViolation","isReachViolation","checkImportForReaching","node","potentialViolationTypes","report","message","source","value","commonjs"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\no-internal-modules.js"],"sourcesContent":["import minimatch from 'minimatch';\n\nimport resolve from 'eslint-module-utils/resolve';\nimport importType from '../core/importType';\nimport moduleVisitor from 'eslint-module-utils/moduleVisitor';\nimport docsUrl from '../docsUrl';\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: docsUrl('no-internal-modules'),\n    },\n\n    schema: [\n      {\n        oneOf: [\n          {\n            type: 'object',\n            properties: {\n              allow: {\n                type: 'array',\n                items: {\n                  type: 'string',\n                },\n              },\n            },\n            additionalProperties: false,\n          },\n          {\n            type: 'object',\n            properties: {\n              forbid: {\n                type: 'array',\n                items: {\n                  type: 'string',\n                },\n              },\n            },\n            additionalProperties: false,\n          },\n        ],\n      },\n    ],\n  },\n\n  create: function noReachingInside(context) {\n    const options = context.options[0] || {};\n    const allowRegexps = (options.allow || []).map(p => minimatch.makeRe(p));\n    const forbidRegexps = (options.forbid || []).map(p => minimatch.makeRe(p));\n\n    // minimatch patterns are expected to use / path separators, like import\n    // statements, so normalize paths to use the same\n    function normalizeSep(somePath) {\n      return somePath.split('\\\\').join('/');\n    }\n\n    function toSteps(somePath) {\n      return  normalizeSep(somePath)\n        .split('/')\n        .reduce((acc, step) => {\n          if (!step || step === '.') {\n            return acc;\n          } else if (step === '..') {\n            return acc.slice(0, -1);\n          } else {\n            return acc.concat(step);\n          }\n        }, []);\n    }\n\n    // test if reaching to this destination is allowed\n    function reachingAllowed(importPath) {\n      return allowRegexps.some(re => re.test(importPath));\n    }\n\n    // test if reaching to this destination is forbidden\n    function reachingForbidden(importPath) {\n      return forbidRegexps.some(re => re.test(importPath));\n    }\n\n    function isAllowViolation(importPath) {\n      const steps = toSteps(importPath);\n\n      const nonScopeSteps = steps.filter(step => step.indexOf('@') !== 0);\n      if (nonScopeSteps.length <= 1) return false;\n\n      // before trying to resolve, see if the raw import (with relative\n      // segments resolved) matches an allowed pattern\n      const justSteps = steps.join('/');\n      if (reachingAllowed(justSteps) || reachingAllowed(`/${justSteps}`)) return false;\n\n      // if the import statement doesn't match directly, try to match the\n      // resolved path if the import is resolvable\n      const resolved = resolve(importPath, context);\n      if (!resolved || reachingAllowed(normalizeSep(resolved))) return false;\n\n      // this import was not allowed by the allowed paths, and reaches\n      // so it is a violation\n      return true;\n    }\n\n    function isForbidViolation(importPath) {\n      const steps = toSteps(importPath);\n\n      // before trying to resolve, see if the raw import (with relative\n      // segments resolved) matches a forbidden pattern\n      const justSteps = steps.join('/');\n\n      if (reachingForbidden(justSteps) || reachingForbidden(`/${justSteps}`)) return true;\n\n      // if the import statement doesn't match directly, try to match the\n      // resolved path if the import is resolvable\n      const resolved = resolve(importPath, context);\n      if (resolved && reachingForbidden(normalizeSep(resolved))) return true;\n\n      // this import was not forbidden by the forbidden paths so it is not a violation\n      return false;\n    }\n\n    // find a directory that is being reached into, but which shouldn't be\n    const isReachViolation = options.forbid ? isForbidViolation : isAllowViolation;\n\n    function checkImportForReaching(importPath, node) {\n      const potentialViolationTypes = ['parent', 'index', 'sibling', 'external', 'internal'];\n      if (potentialViolationTypes.indexOf(importType(importPath, context)) !== -1 &&\n        isReachViolation(importPath)\n      ) {\n        context.report({\n          node,\n          message: `Reaching to \"${importPath}\" is not allowed.`,\n        });\n      }\n    }\n\n    return moduleVisitor((source) => {\n      checkImportForReaching(source.value, source);\n    }, { commonjs: true });\n  },\n};\n"]},"metadata":{},"sourceType":"script"}