{"ast":null,"code":"/**\n * @filedescription Object Schema\n */\n\"use strict\"; //-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst {\n  MergeStrategy\n} = require(\"./merge-strategy\");\n\nconst {\n  ValidationStrategy\n} = require(\"./validation-strategy\"); //-----------------------------------------------------------------------------\n// Private\n//-----------------------------------------------------------------------------\n\n\nconst strategies = Symbol(\"strategies\");\nconst requiredKeys = Symbol(\"requiredKeys\");\n/**\n * Validates a schema strategy.\n * @param {string} name The name of the key this strategy is for.\n * @param {Object} strategy The strategy for the object key.\n * @param {boolean} [strategy.required=true] Whether the key is required.\n * @param {string[]} [strategy.requires] Other keys that are required when\n *      this key is present.\n * @param {Function} strategy.merge A method to call when merging two objects\n *      with the same key.\n * @param {Function} strategy.validate A method to call when validating an\n *      object with the key.\n * @returns {void}\n * @throws {Error} When the strategy is missing a name.\n * @throws {Error} When the strategy is missing a merge() method.\n * @throws {Error} When the strategy is missing a validate() method.\n */\n\nfunction validateDefinition(name, strategy) {\n  let hasSchema = false;\n\n  if (strategy.schema) {\n    if (typeof strategy.schema === \"object\") {\n      hasSchema = true;\n    } else {\n      throw new TypeError(\"Schema must be an object.\");\n    }\n  }\n\n  if (typeof strategy.merge === \"string\") {\n    if (!(strategy.merge in MergeStrategy)) {\n      throw new TypeError(`Definition for key \"${name}\" missing valid merge strategy.`);\n    }\n  } else if (!hasSchema && typeof strategy.merge !== \"function\") {\n    throw new TypeError(`Definition for key \"${name}\" must have a merge property.`);\n  }\n\n  if (typeof strategy.validate === \"string\") {\n    if (!(strategy.validate in ValidationStrategy)) {\n      throw new TypeError(`Definition for key \"${name}\" missing valid validation strategy.`);\n    }\n  } else if (!hasSchema && typeof strategy.validate !== \"function\") {\n    throw new TypeError(`Definition for key \"${name}\" must have a validate() method.`);\n  }\n} //-----------------------------------------------------------------------------\n// Class\n//-----------------------------------------------------------------------------\n\n/**\n * Represents an object validation/merging schema.\n */\n\n\nclass ObjectSchema {\n  /**\n   * Creates a new instance.\n   */\n  constructor(definitions) {\n    if (!definitions) {\n      throw new Error(\"Schema definitions missing.\");\n    }\n    /**\n     * Track all strategies in the schema by key.\n     * @type {Map}\n     * @property strategies\n     */\n\n\n    this[strategies] = new Map();\n    /**\n     * Separately track any keys that are required for faster validation.\n     * @type {Map}\n     * @property requiredKeys\n     */\n\n    this[requiredKeys] = new Map(); // add in all strategies\n\n    for (const key of Object.keys(definitions)) {\n      validateDefinition(key, definitions[key]); // normalize merge and validate methods if subschema is present\n\n      if (typeof definitions[key].schema === \"object\") {\n        const schema = new ObjectSchema(definitions[key].schema);\n        definitions[key] = { ...definitions[key],\n\n          merge() {\n            let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            let second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            return schema.merge(first, second);\n          },\n\n          validate(value) {\n            ValidationStrategy.object(value);\n            schema.validate(value);\n          }\n\n        };\n      } // normalize the merge method in case there's a string\n\n\n      if (typeof definitions[key].merge === \"string\") {\n        definitions[key] = { ...definitions[key],\n          merge: MergeStrategy[definitions[key].merge]\n        };\n      }\n\n      ; // normalize the validate method in case there's a string\n\n      if (typeof definitions[key].validate === \"string\") {\n        definitions[key] = { ...definitions[key],\n          validate: ValidationStrategy[definitions[key].validate]\n        };\n      }\n\n      ;\n      this[strategies].set(key, definitions[key]);\n\n      if (definitions[key].required) {\n        this[requiredKeys].set(key, definitions[key]);\n      }\n    }\n  }\n  /**\n   * Determines if a strategy has been registered for the given object key.\n   * @param {string} key The object key to find a strategy for.\n   * @returns {boolean} True if the key has a strategy registered, false if not. \n   */\n\n\n  hasKey(key) {\n    return this[strategies].has(key);\n  }\n  /**\n   * Merges objects together to create a new object comprised of the keys\n   * of the all objects. Keys are merged based on the each key's merge\n   * strategy.\n   * @param {...Object} objects The objects to merge.\n   * @returns {Object} A new object with a mix of all objects' keys.\n   * @throws {Error} If any object is invalid.\n   */\n\n\n  merge() {\n    for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n      objects[_key] = arguments[_key];\n    }\n\n    // double check arguments\n    if (objects.length < 2) {\n      throw new Error(\"merge() requires at least two arguments.\");\n    }\n\n    if (objects.some(object => object == null || typeof object !== \"object\")) {\n      throw new Error(\"All arguments must be objects.\");\n    }\n\n    return objects.reduce((result, object) => {\n      this.validate(object);\n\n      for (const [key, strategy] of this[strategies]) {\n        try {\n          if (key in result || key in object) {\n            const value = strategy.merge.call(this, result[key], object[key]);\n\n            if (value !== undefined) {\n              result[key] = value;\n            }\n          }\n        } catch (ex) {\n          ex.message = `Key \"${key}\": ` + ex.message;\n          throw ex;\n        }\n      }\n\n      return result;\n    }, {});\n  }\n  /**\n   * Validates an object's keys based on the validate strategy for each key.\n   * @param {Object} object The object to validate.\n   * @returns {void}\n   * @throws {Error} When the object is invalid. \n   */\n\n\n  validate(object) {\n    // check existing keys first\n    for (const key of Object.keys(object)) {\n      // check to see if the key is defined\n      if (!this.hasKey(key)) {\n        throw new Error(`Unexpected key \"${key}\" found.`);\n      } // validate existing keys\n\n\n      const strategy = this[strategies].get(key); // first check to see if any other keys are required\n\n      if (Array.isArray(strategy.requires)) {\n        if (!strategy.requires.every(otherKey => otherKey in object)) {\n          throw new Error(`Key \"${key}\" requires keys \"${strategy.requires.join(\"\\\", \\\"\")}\".`);\n        }\n      } // now apply remaining validation strategy\n\n\n      try {\n        strategy.validate.call(strategy, object[key]);\n      } catch (ex) {\n        ex.message = `Key \"${key}\": ` + ex.message;\n        throw ex;\n      }\n    } // ensure required keys aren't missing\n\n\n    for (const [key] of this[requiredKeys]) {\n      if (!(key in object)) {\n        throw new Error(`Missing required key \"${key}\".`);\n      }\n    }\n  }\n\n}\n\nexports.ObjectSchema = ObjectSchema;","map":{"version":3,"names":["MergeStrategy","require","ValidationStrategy","strategies","Symbol","requiredKeys","validateDefinition","name","strategy","hasSchema","schema","TypeError","merge","validate","ObjectSchema","constructor","definitions","Error","Map","key","Object","keys","first","second","value","object","set","required","hasKey","has","objects","length","some","reduce","result","call","undefined","ex","message","get","Array","isArray","requires","every","otherKey","join","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@humanwhocodes/object-schema/src/object-schema.js"],"sourcesContent":["/**\n * @filedescription Object Schema\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst { MergeStrategy } = require(\"./merge-strategy\");\nconst { ValidationStrategy } = require(\"./validation-strategy\");\n\n//-----------------------------------------------------------------------------\n// Private\n//-----------------------------------------------------------------------------\n\nconst strategies = Symbol(\"strategies\");\nconst requiredKeys = Symbol(\"requiredKeys\");\n\n/**\n * Validates a schema strategy.\n * @param {string} name The name of the key this strategy is for.\n * @param {Object} strategy The strategy for the object key.\n * @param {boolean} [strategy.required=true] Whether the key is required.\n * @param {string[]} [strategy.requires] Other keys that are required when\n *      this key is present.\n * @param {Function} strategy.merge A method to call when merging two objects\n *      with the same key.\n * @param {Function} strategy.validate A method to call when validating an\n *      object with the key.\n * @returns {void}\n * @throws {Error} When the strategy is missing a name.\n * @throws {Error} When the strategy is missing a merge() method.\n * @throws {Error} When the strategy is missing a validate() method.\n */\nfunction validateDefinition(name, strategy) {\n\n    let hasSchema = false;\n    if (strategy.schema) {\n        if (typeof strategy.schema === \"object\") {\n            hasSchema = true;\n        } else {\n            throw new TypeError(\"Schema must be an object.\");\n        }\n    }\n\n    if (typeof strategy.merge === \"string\") {\n        if (!(strategy.merge in MergeStrategy)) {\n            throw new TypeError(`Definition for key \"${name}\" missing valid merge strategy.`);\n        }\n    } else if (!hasSchema && typeof strategy.merge !== \"function\") {\n        throw new TypeError(`Definition for key \"${name}\" must have a merge property.`);\n    }\n\n    if (typeof strategy.validate === \"string\") {\n        if (!(strategy.validate in ValidationStrategy)) {\n            throw new TypeError(`Definition for key \"${name}\" missing valid validation strategy.`);\n        }\n    } else if (!hasSchema && typeof strategy.validate !== \"function\") {\n        throw new TypeError(`Definition for key \"${name}\" must have a validate() method.`);\n    }\n}\n\n\n//-----------------------------------------------------------------------------\n// Class\n//-----------------------------------------------------------------------------\n\n/**\n * Represents an object validation/merging schema.\n */\nclass ObjectSchema {\n\n    /**\n     * Creates a new instance.\n     */\n    constructor(definitions) {\n\n        if (!definitions) {\n            throw new Error(\"Schema definitions missing.\");\n        }\n\n        /**\n         * Track all strategies in the schema by key.\n         * @type {Map}\n         * @property strategies\n         */\n        this[strategies] = new Map();\n\n        /**\n         * Separately track any keys that are required for faster validation.\n         * @type {Map}\n         * @property requiredKeys\n         */\n        this[requiredKeys] = new Map();\n\n        // add in all strategies\n        for (const key of Object.keys(definitions)) {\n            validateDefinition(key, definitions[key]);\n\n            // normalize merge and validate methods if subschema is present\n            if (typeof definitions[key].schema === \"object\") {\n                const schema = new ObjectSchema(definitions[key].schema);\n                definitions[key] = {\n                    ...definitions[key],\n                    merge(first = {}, second = {}) {\n                        return schema.merge(first, second);\n                    },\n                    validate(value) {\n                        ValidationStrategy.object(value);\n                        schema.validate(value);\n                    }\n                };\n            }\n\n            // normalize the merge method in case there's a string\n            if (typeof definitions[key].merge === \"string\") {\n                definitions[key] = {\n                    ...definitions[key],\n                    merge: MergeStrategy[definitions[key].merge]\n                };\n            };\n\n            // normalize the validate method in case there's a string\n            if (typeof definitions[key].validate === \"string\") {\n                definitions[key] = {\n                    ...definitions[key],\n                    validate: ValidationStrategy[definitions[key].validate]\n                };\n            };\n\n            this[strategies].set(key, definitions[key]);\n\n            if (definitions[key].required) {\n                this[requiredKeys].set(key, definitions[key]);\n            }\n        }\n    }\n\n    /**\n     * Determines if a strategy has been registered for the given object key.\n     * @param {string} key The object key to find a strategy for.\n     * @returns {boolean} True if the key has a strategy registered, false if not. \n     */\n    hasKey(key) {\n        return this[strategies].has(key);\n    }\n\n    /**\n     * Merges objects together to create a new object comprised of the keys\n     * of the all objects. Keys are merged based on the each key's merge\n     * strategy.\n     * @param {...Object} objects The objects to merge.\n     * @returns {Object} A new object with a mix of all objects' keys.\n     * @throws {Error} If any object is invalid.\n     */\n    merge(...objects) {\n\n        // double check arguments\n        if (objects.length < 2) {\n            throw new Error(\"merge() requires at least two arguments.\");\n        }\n\n        if (objects.some(object => (object == null || typeof object !== \"object\"))) {\n            throw new Error(\"All arguments must be objects.\");\n        }\n\n        return objects.reduce((result, object) => {\n            \n            this.validate(object);\n            \n            for (const [key, strategy] of this[strategies]) {\n                try {\n                    if (key in result || key in object) {\n                        const value = strategy.merge.call(this, result[key], object[key]);\n                        if (value !== undefined) {\n                            result[key] = value;\n                        }\n                    }\n                } catch (ex) {\n                    ex.message = `Key \"${key}\": ` + ex.message;\n                    throw ex;\n                }\n            }\n            return result;\n        }, {});\n    }\n\n    /**\n     * Validates an object's keys based on the validate strategy for each key.\n     * @param {Object} object The object to validate.\n     * @returns {void}\n     * @throws {Error} When the object is invalid. \n     */\n    validate(object) {\n\n        // check existing keys first\n        for (const key of Object.keys(object)) {\n\n            // check to see if the key is defined\n            if (!this.hasKey(key)) {\n                throw new Error(`Unexpected key \"${key}\" found.`);\n            }\n\n            // validate existing keys\n            const strategy = this[strategies].get(key);\n\n            // first check to see if any other keys are required\n            if (Array.isArray(strategy.requires)) {\n                if (!strategy.requires.every(otherKey => otherKey in object)) {\n                    throw new Error(`Key \"${key}\" requires keys \"${strategy.requires.join(\"\\\", \\\"\")}\".`);\n                }\n            }\n\n            // now apply remaining validation strategy\n            try {\n                strategy.validate.call(strategy, object[key]);\n            } catch (ex) {\n                ex.message = `Key \"${key}\": ` + ex.message;\n                throw ex;\n            }\n        }\n\n        // ensure required keys aren't missing\n        for (const [key] of this[requiredKeys]) {\n            if (!(key in object)) {\n                throw new Error(`Missing required key \"${key}\".`);\n            }\n        }\n\n    }\n}\n\nexports.ObjectSchema = ObjectSchema;\n"],"mappings":"AAAA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAM;EAAEA;AAAF,IAAoBC,OAAO,CAAC,kBAAD,CAAjC;;AACA,MAAM;EAAEC;AAAF,IAAyBD,OAAO,CAAC,uBAAD,CAAtC,C,CAEA;AACA;AACA;;;AAEA,MAAME,UAAU,GAAGC,MAAM,CAAC,YAAD,CAAzB;AACA,MAAMC,YAAY,GAAGD,MAAM,CAAC,cAAD,CAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASE,kBAAT,CAA4BC,IAA5B,EAAkCC,QAAlC,EAA4C;EAExC,IAAIC,SAAS,GAAG,KAAhB;;EACA,IAAID,QAAQ,CAACE,MAAb,EAAqB;IACjB,IAAI,OAAOF,QAAQ,CAACE,MAAhB,KAA2B,QAA/B,EAAyC;MACrCD,SAAS,GAAG,IAAZ;IACH,CAFD,MAEO;MACH,MAAM,IAAIE,SAAJ,CAAc,2BAAd,CAAN;IACH;EACJ;;EAED,IAAI,OAAOH,QAAQ,CAACI,KAAhB,KAA0B,QAA9B,EAAwC;IACpC,IAAI,EAAEJ,QAAQ,CAACI,KAAT,IAAkBZ,aAApB,CAAJ,EAAwC;MACpC,MAAM,IAAIW,SAAJ,CAAe,uBAAsBJ,IAAK,iCAA1C,CAAN;IACH;EACJ,CAJD,MAIO,IAAI,CAACE,SAAD,IAAc,OAAOD,QAAQ,CAACI,KAAhB,KAA0B,UAA5C,EAAwD;IAC3D,MAAM,IAAID,SAAJ,CAAe,uBAAsBJ,IAAK,+BAA1C,CAAN;EACH;;EAED,IAAI,OAAOC,QAAQ,CAACK,QAAhB,KAA6B,QAAjC,EAA2C;IACvC,IAAI,EAAEL,QAAQ,CAACK,QAAT,IAAqBX,kBAAvB,CAAJ,EAAgD;MAC5C,MAAM,IAAIS,SAAJ,CAAe,uBAAsBJ,IAAK,sCAA1C,CAAN;IACH;EACJ,CAJD,MAIO,IAAI,CAACE,SAAD,IAAc,OAAOD,QAAQ,CAACK,QAAhB,KAA6B,UAA/C,EAA2D;IAC9D,MAAM,IAAIF,SAAJ,CAAe,uBAAsBJ,IAAK,kCAA1C,CAAN;EACH;AACJ,C,CAGD;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMO,YAAN,CAAmB;EAEf;AACJ;AACA;EACIC,WAAW,CAACC,WAAD,EAAc;IAErB,IAAI,CAACA,WAAL,EAAkB;MACd,MAAM,IAAIC,KAAJ,CAAU,6BAAV,CAAN;IACH;IAED;AACR;AACA;AACA;AACA;;;IACQ,KAAKd,UAAL,IAAmB,IAAIe,GAAJ,EAAnB;IAEA;AACR;AACA;AACA;AACA;;IACQ,KAAKb,YAAL,IAAqB,IAAIa,GAAJ,EAArB,CAlBqB,CAoBrB;;IACA,KAAK,MAAMC,GAAX,IAAkBC,MAAM,CAACC,IAAP,CAAYL,WAAZ,CAAlB,EAA4C;MACxCV,kBAAkB,CAACa,GAAD,EAAMH,WAAW,CAACG,GAAD,CAAjB,CAAlB,CADwC,CAGxC;;MACA,IAAI,OAAOH,WAAW,CAACG,GAAD,CAAX,CAAiBT,MAAxB,KAAmC,QAAvC,EAAiD;QAC7C,MAAMA,MAAM,GAAG,IAAII,YAAJ,CAAiBE,WAAW,CAACG,GAAD,CAAX,CAAiBT,MAAlC,CAAf;QACAM,WAAW,CAACG,GAAD,CAAX,GAAmB,EACf,GAAGH,WAAW,CAACG,GAAD,CADC;;UAEfP,KAAK,GAA0B;YAAA,IAAzBU,KAAyB,uEAAjB,EAAiB;YAAA,IAAbC,MAAa,uEAAJ,EAAI;YAC3B,OAAOb,MAAM,CAACE,KAAP,CAAaU,KAAb,EAAoBC,MAApB,CAAP;UACH,CAJc;;UAKfV,QAAQ,CAACW,KAAD,EAAQ;YACZtB,kBAAkB,CAACuB,MAAnB,CAA0BD,KAA1B;YACAd,MAAM,CAACG,QAAP,CAAgBW,KAAhB;UACH;;QARc,CAAnB;MAUH,CAhBuC,CAkBxC;;;MACA,IAAI,OAAOR,WAAW,CAACG,GAAD,CAAX,CAAiBP,KAAxB,KAAkC,QAAtC,EAAgD;QAC5CI,WAAW,CAACG,GAAD,CAAX,GAAmB,EACf,GAAGH,WAAW,CAACG,GAAD,CADC;UAEfP,KAAK,EAAEZ,aAAa,CAACgB,WAAW,CAACG,GAAD,CAAX,CAAiBP,KAAlB;QAFL,CAAnB;MAIH;;MAAA,CAxBuC,CA0BxC;;MACA,IAAI,OAAOI,WAAW,CAACG,GAAD,CAAX,CAAiBN,QAAxB,KAAqC,QAAzC,EAAmD;QAC/CG,WAAW,CAACG,GAAD,CAAX,GAAmB,EACf,GAAGH,WAAW,CAACG,GAAD,CADC;UAEfN,QAAQ,EAAEX,kBAAkB,CAACc,WAAW,CAACG,GAAD,CAAX,CAAiBN,QAAlB;QAFb,CAAnB;MAIH;;MAAA;MAED,KAAKV,UAAL,EAAiBuB,GAAjB,CAAqBP,GAArB,EAA0BH,WAAW,CAACG,GAAD,CAArC;;MAEA,IAAIH,WAAW,CAACG,GAAD,CAAX,CAAiBQ,QAArB,EAA+B;QAC3B,KAAKtB,YAAL,EAAmBqB,GAAnB,CAAuBP,GAAvB,EAA4BH,WAAW,CAACG,GAAD,CAAvC;MACH;IACJ;EACJ;EAED;AACJ;AACA;AACA;AACA;;;EACIS,MAAM,CAACT,GAAD,EAAM;IACR,OAAO,KAAKhB,UAAL,EAAiB0B,GAAjB,CAAqBV,GAArB,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIP,KAAK,GAAa;IAAA,kCAATkB,OAAS;MAATA,OAAS;IAAA;;IAEd;IACA,IAAIA,OAAO,CAACC,MAAR,GAAiB,CAArB,EAAwB;MACpB,MAAM,IAAId,KAAJ,CAAU,0CAAV,CAAN;IACH;;IAED,IAAIa,OAAO,CAACE,IAAR,CAAaP,MAAM,IAAKA,MAAM,IAAI,IAAV,IAAkB,OAAOA,MAAP,KAAkB,QAA5D,CAAJ,EAA4E;MACxE,MAAM,IAAIR,KAAJ,CAAU,gCAAV,CAAN;IACH;;IAED,OAAOa,OAAO,CAACG,MAAR,CAAe,CAACC,MAAD,EAAST,MAAT,KAAoB;MAEtC,KAAKZ,QAAL,CAAcY,MAAd;;MAEA,KAAK,MAAM,CAACN,GAAD,EAAMX,QAAN,CAAX,IAA8B,KAAKL,UAAL,CAA9B,EAAgD;QAC5C,IAAI;UACA,IAAIgB,GAAG,IAAIe,MAAP,IAAiBf,GAAG,IAAIM,MAA5B,EAAoC;YAChC,MAAMD,KAAK,GAAGhB,QAAQ,CAACI,KAAT,CAAeuB,IAAf,CAAoB,IAApB,EAA0BD,MAAM,CAACf,GAAD,CAAhC,EAAuCM,MAAM,CAACN,GAAD,CAA7C,CAAd;;YACA,IAAIK,KAAK,KAAKY,SAAd,EAAyB;cACrBF,MAAM,CAACf,GAAD,CAAN,GAAcK,KAAd;YACH;UACJ;QACJ,CAPD,CAOE,OAAOa,EAAP,EAAW;UACTA,EAAE,CAACC,OAAH,GAAc,QAAOnB,GAAI,KAAZ,GAAmBkB,EAAE,CAACC,OAAnC;UACA,MAAMD,EAAN;QACH;MACJ;;MACD,OAAOH,MAAP;IACH,CAlBM,EAkBJ,EAlBI,CAAP;EAmBH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACIrB,QAAQ,CAACY,MAAD,EAAS;IAEb;IACA,KAAK,MAAMN,GAAX,IAAkBC,MAAM,CAACC,IAAP,CAAYI,MAAZ,CAAlB,EAAuC;MAEnC;MACA,IAAI,CAAC,KAAKG,MAAL,CAAYT,GAAZ,CAAL,EAAuB;QACnB,MAAM,IAAIF,KAAJ,CAAW,mBAAkBE,GAAI,UAAjC,CAAN;MACH,CALkC,CAOnC;;;MACA,MAAMX,QAAQ,GAAG,KAAKL,UAAL,EAAiBoC,GAAjB,CAAqBpB,GAArB,CAAjB,CARmC,CAUnC;;MACA,IAAIqB,KAAK,CAACC,OAAN,CAAcjC,QAAQ,CAACkC,QAAvB,CAAJ,EAAsC;QAClC,IAAI,CAAClC,QAAQ,CAACkC,QAAT,CAAkBC,KAAlB,CAAwBC,QAAQ,IAAIA,QAAQ,IAAInB,MAAhD,CAAL,EAA8D;UAC1D,MAAM,IAAIR,KAAJ,CAAW,QAAOE,GAAI,oBAAmBX,QAAQ,CAACkC,QAAT,CAAkBG,IAAlB,CAAuB,QAAvB,CAAiC,IAA1E,CAAN;QACH;MACJ,CAfkC,CAiBnC;;;MACA,IAAI;QACArC,QAAQ,CAACK,QAAT,CAAkBsB,IAAlB,CAAuB3B,QAAvB,EAAiCiB,MAAM,CAACN,GAAD,CAAvC;MACH,CAFD,CAEE,OAAOkB,EAAP,EAAW;QACTA,EAAE,CAACC,OAAH,GAAc,QAAOnB,GAAI,KAAZ,GAAmBkB,EAAE,CAACC,OAAnC;QACA,MAAMD,EAAN;MACH;IACJ,CA3BY,CA6Bb;;;IACA,KAAK,MAAM,CAAClB,GAAD,CAAX,IAAoB,KAAKd,YAAL,CAApB,EAAwC;MACpC,IAAI,EAAEc,GAAG,IAAIM,MAAT,CAAJ,EAAsB;QAClB,MAAM,IAAIR,KAAJ,CAAW,yBAAwBE,GAAI,IAAvC,CAAN;MACH;IACJ;EAEJ;;AA/Jc;;AAkKnB2B,OAAO,CAAChC,YAAR,GAAuBA,YAAvB"},"metadata":{},"sourceType":"script"}