{"ast":null,"code":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nlet parseargs = {};\n\nlet isOpt = function (arg) {\n  return arg.indexOf('-') === 0;\n};\n\nlet removeOptPrefix = function (opt) {\n  return opt.replace(/^--/, '').replace(/^-/, '');\n};\n/**\n * @constructor\n * Parses a list of command-line args into a key/value object of\n * options and an array of positional commands.\n * @ param {Array} opts A list of options in the following format:\n * [{full: 'foo', abbr: 'f'}, {full: 'bar', abbr: 'b'}]]\n */\n\n\nparseargs.Parser = function (opts) {\n  // A key/value object of matching options parsed out of the args\n  this.opts = {};\n  this.taskNames = null;\n  this.envVars = null; // Data structures used for parsing\n\n  this.reg = opts;\n  this.shortOpts = {};\n  this.longOpts = {};\n  let self = this;\n  [].forEach.call(opts, function (item) {\n    self.shortOpts[item.abbr] = item;\n    self.longOpts[item.full] = item;\n  });\n};\n\nparseargs.Parser.prototype = new function () {\n  let _trueOrNextVal = function (argParts, args) {\n    if (argParts[1]) {\n      return argParts[1];\n    } else {\n      return !args[0] || isOpt(args[0]) ? true : args.shift();\n    }\n  };\n  /**\n   * Parses an array of arguments into options and positional commands\n   * @param {Array} args The command-line args to parse\n   */\n\n\n  this.parse = function (args) {\n    let cmds = [];\n    let cmd;\n    let envVars = {};\n    let opts = {};\n    let arg;\n    let argItem;\n    let argParts;\n    let cmdItems;\n    let taskNames = [];\n    let preempt;\n\n    while (args.length) {\n      arg = args.shift();\n\n      if (isOpt(arg)) {\n        arg = removeOptPrefix(arg);\n        argParts = arg.split('=');\n        argItem = this.longOpts[argParts[0]] || this.shortOpts[argParts[0]];\n\n        if (argItem) {\n          // First-encountered preemptive opt takes precedence -- no further opts\n          // or possibility of ambiguity, so just look for a value, or set to\n          // true and then bail\n          if (argItem.preempts) {\n            opts[argItem.full] = _trueOrNextVal(argParts, args);\n            preempt = true;\n            break;\n          } // If the opt requires a value, see if we can get a value from the\n          // next arg, or infer true from no-arg -- if it's followed by another\n          // opt, throw an error\n\n\n          if (argItem.expectValue || argItem.allowValue) {\n            opts[argItem.full] = _trueOrNextVal(argParts, args);\n\n            if (argItem.expectValue && !opts[argItem.full]) {\n              throw new Error(argItem.full + ' option expects a value.');\n            }\n          } else {\n            opts[argItem.full] = true;\n          }\n        }\n      } else {\n        cmds.unshift(arg);\n      }\n    }\n\n    if (!preempt) {\n      // Parse out any env-vars and task-name\n      while (cmd = cmds.pop()) {\n        cmdItems = cmd.split('=');\n\n        if (cmdItems.length > 1) {\n          envVars[cmdItems[0]] = cmdItems[1];\n        } else {\n          taskNames.push(cmd);\n        }\n      }\n    }\n\n    return {\n      opts: opts,\n      envVars: envVars,\n      taskNames: taskNames\n    };\n  };\n}();\nmodule.exports = parseargs;","map":{"version":3,"names":["parseargs","isOpt","arg","indexOf","removeOptPrefix","opt","replace","Parser","opts","taskNames","envVars","reg","shortOpts","longOpts","self","forEach","call","item","abbr","full","prototype","_trueOrNextVal","argParts","args","shift","parse","cmds","cmd","argItem","cmdItems","preempt","length","split","preempts","expectValue","allowValue","Error","unshift","pop","push","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jake/lib/parseargs.js"],"sourcesContent":["/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nlet parseargs = {};\nlet isOpt = function (arg) { return arg.indexOf('-') === 0 };\nlet removeOptPrefix = function (opt) { return opt.replace(/^--/, '').replace(/^-/, '') };\n\n/**\n * @constructor\n * Parses a list of command-line args into a key/value object of\n * options and an array of positional commands.\n * @ param {Array} opts A list of options in the following format:\n * [{full: 'foo', abbr: 'f'}, {full: 'bar', abbr: 'b'}]]\n */\nparseargs.Parser = function (opts) {\n  // A key/value object of matching options parsed out of the args\n  this.opts = {};\n  this.taskNames = null;\n  this.envVars = null;\n\n  // Data structures used for parsing\n  this.reg = opts;\n  this.shortOpts = {};\n  this.longOpts = {};\n\n  let self = this;\n  [].forEach.call(opts, function (item) {\n    self.shortOpts[item.abbr] = item;\n    self.longOpts[item.full] = item;\n  });\n};\n\nparseargs.Parser.prototype = new function () {\n\n  let _trueOrNextVal = function (argParts, args) {\n    if (argParts[1]) {\n      return argParts[1];\n    }\n    else {\n      return (!args[0] || isOpt(args[0])) ?\n        true : args.shift();\n    }\n  };\n\n  /**\n   * Parses an array of arguments into options and positional commands\n   * @param {Array} args The command-line args to parse\n   */\n  this.parse = function (args) {\n    let cmds = [];\n    let cmd;\n    let envVars = {};\n    let opts = {};\n    let arg;\n    let argItem;\n    let argParts;\n    let cmdItems;\n    let taskNames = [];\n    let preempt;\n\n    while (args.length) {\n      arg = args.shift();\n\n      if (isOpt(arg)) {\n        arg = removeOptPrefix(arg);\n        argParts = arg.split('=');\n        argItem = this.longOpts[argParts[0]] || this.shortOpts[argParts[0]];\n        if (argItem) {\n          // First-encountered preemptive opt takes precedence -- no further opts\n          // or possibility of ambiguity, so just look for a value, or set to\n          // true and then bail\n          if (argItem.preempts) {\n            opts[argItem.full] = _trueOrNextVal(argParts, args);\n            preempt = true;\n            break;\n          }\n          // If the opt requires a value, see if we can get a value from the\n          // next arg, or infer true from no-arg -- if it's followed by another\n          // opt, throw an error\n          if (argItem.expectValue || argItem.allowValue) {\n            opts[argItem.full] = _trueOrNextVal(argParts, args);\n            if (argItem.expectValue && !opts[argItem.full]) {\n              throw new Error(argItem.full + ' option expects a value.');\n            }\n          }\n          else {\n            opts[argItem.full] = true;\n          }\n        }\n      }\n      else {\n        cmds.unshift(arg);\n      }\n    }\n\n    if (!preempt) {\n      // Parse out any env-vars and task-name\n      while ((cmd = cmds.pop())) {\n        cmdItems = cmd.split('=');\n        if (cmdItems.length > 1) {\n          envVars[cmdItems[0]] = cmdItems[1];\n        }\n        else {\n          taskNames.push(cmd);\n        }\n      }\n\n    }\n\n    return {\n      opts: opts,\n      envVars: envVars,\n      taskNames: taskNames\n    };\n  };\n\n};\n\nmodule.exports = parseargs;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}