{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils_1 = require(\"tsutils\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n/*\nThe AST is always constructed such the first element is always the deepest element.\nI.e. for this code: `foo && foo.bar && foo.bar.baz && foo.bar.baz.buzz`\nThe AST will look like this:\n{\n  left: {\n    left: {\n      left: foo\n      right: foo.bar\n    }\n    right: foo.bar.baz\n  }\n  right: foo.bar.baz.buzz\n}\n*/\n\n\nexports.default = util.createRule({\n  name: 'prefer-optional-chain',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce using concise optional chain expressions instead of chained logical ands',\n      recommended: 'strict'\n    },\n    hasSuggestions: true,\n    messages: {\n      preferOptionalChain: \"Prefer using an optional chain expression instead, as it's more concise and easier to read.\",\n      optionalChainSuggest: 'Change to an optional chain.'\n    },\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const parserServices = util.getParserServices(context, true);\n    return {\n      'LogicalExpression[operator=\"||\"], LogicalExpression[operator=\"??\"]'(node) {\n        const leftNode = node.left;\n        const rightNode = node.right;\n        const parentNode = node.parent;\n        const isRightNodeAnEmptyObjectLiteral = rightNode.type === utils_1.AST_NODE_TYPES.ObjectExpression && rightNode.properties.length === 0;\n\n        if (!isRightNodeAnEmptyObjectLiteral || !parentNode || parentNode.type !== utils_1.AST_NODE_TYPES.MemberExpression || parentNode.optional) {\n          return;\n        }\n\n        function isLeftSideLowerPrecedence() {\n          const logicalTsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n          const leftTsNode = parserServices.esTreeNodeToTSNodeMap.get(leftNode);\n          const operator = (0, tsutils_1.isBinaryExpression)(logicalTsNode) ? logicalTsNode.operatorToken.kind : ts.SyntaxKind.Unknown;\n          const leftPrecedence = util.getOperatorPrecedence(leftTsNode.kind, operator);\n          return leftPrecedence < util.OperatorPrecedence.LeftHandSide;\n        }\n\n        context.report({\n          node: parentNode,\n          messageId: 'optionalChainSuggest',\n          suggest: [{\n            messageId: 'optionalChainSuggest',\n            fix: fixer => {\n              const leftNodeText = sourceCode.getText(leftNode); // Any node that is made of an operator with higher or equal precedence,\n\n              const maybeWrappedLeftNode = isLeftSideLowerPrecedence() ? `(${leftNodeText})` : leftNodeText;\n              const propertyToBeOptionalText = sourceCode.getText(parentNode.property);\n              const maybeWrappedProperty = parentNode.computed ? `[${propertyToBeOptionalText}]` : propertyToBeOptionalText;\n              return fixer.replaceTextRange(parentNode.range, `${maybeWrappedLeftNode}?.${maybeWrappedProperty}`);\n            }\n          }]\n        });\n      },\n\n      [['LogicalExpression[operator=\"&&\"] > Identifier', 'LogicalExpression[operator=\"&&\"] > MemberExpression', 'LogicalExpression[operator=\"&&\"] > ChainExpression > MemberExpression', 'LogicalExpression[operator=\"&&\"] > BinaryExpression[operator=\"!==\"]', 'LogicalExpression[operator=\"&&\"] > BinaryExpression[operator=\"!=\"]'].join(',')](initialIdentifierOrNotEqualsExpr) {\n        var _a; // selector guarantees this cast\n\n\n        const initialExpression = ((_a = initialIdentifierOrNotEqualsExpr.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ChainExpression ? initialIdentifierOrNotEqualsExpr.parent.parent : initialIdentifierOrNotEqualsExpr.parent;\n\n        if (initialExpression.left !== initialIdentifierOrNotEqualsExpr) {\n          // the node(identifier or member expression) is not the deepest left node\n          return;\n        }\n\n        if (!isValidChainTarget(initialIdentifierOrNotEqualsExpr, true)) {\n          return;\n        } // walk up the tree to figure out how many logical expressions we can include\n\n\n        let previous = initialExpression;\n        let current = initialExpression;\n        let previousLeftText = getText(initialIdentifierOrNotEqualsExpr);\n        let optionallyChainedCode = previousLeftText;\n        let expressionCount = 1;\n\n        while (current.type === utils_1.AST_NODE_TYPES.LogicalExpression) {\n          if (!isValidChainTarget(current.right, // only allow identifiers for the first chain - foo && foo()\n          expressionCount === 1)) {\n            break;\n          }\n\n          const leftText = previousLeftText;\n          const rightText = getText(current.right); // can't just use startsWith because of cases like foo && fooBar.baz;\n\n          const matchRegex = new RegExp(`^${// escape regex characters\n          leftText.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}[^a-zA-Z0-9_$]`);\n\n          if (!matchRegex.test(rightText) && // handle redundant cases like foo.bar && foo.bar\n          leftText !== rightText) {\n            break;\n          } // omit weird doubled up expression that make no sense like foo.bar && foo.bar\n\n\n          if (rightText !== leftText) {\n            expressionCount += 1;\n            previousLeftText = rightText;\n            /*\n            Diff the left and right text to construct the fix string\n            There are the following cases:\n            1)\n            rightText === 'foo.bar.baz.buzz'\n            leftText === 'foo.bar.baz'\n            diff === '.buzz'\n            2)\n            rightText === 'foo.bar.baz.buzz()'\n            leftText === 'foo.bar.baz'\n            diff === '.buzz()'\n            3)\n            rightText === 'foo.bar.baz.buzz()'\n            leftText === 'foo.bar.baz.buzz'\n            diff === '()'\n            4)\n            rightText === 'foo.bar.baz[buzz]'\n            leftText === 'foo.bar.baz'\n            diff === '[buzz]'\n            5)\n            rightText === 'foo.bar.baz?.buzz'\n            leftText === 'foo.bar.baz'\n            diff === '?.buzz'\n            */\n\n            const diff = rightText.replace(leftText, '');\n\n            if (diff.startsWith('?')) {\n              // item was \"pre optional chained\"\n              optionallyChainedCode += diff;\n            } else {\n              const needsDot = diff.startsWith('(') || diff.startsWith('[');\n              optionallyChainedCode += `?${needsDot ? '.' : ''}${diff}`;\n            }\n          }\n\n          previous = current;\n          current = util.nullThrows(current.parent, util.NullThrowsReasons.MissingParent);\n        }\n\n        if (expressionCount > 1) {\n          if (previous.right.type === utils_1.AST_NODE_TYPES.BinaryExpression) {\n            // case like foo && foo.bar !== someValue\n            optionallyChainedCode += ` ${previous.right.operator} ${sourceCode.getText(previous.right.right)}`;\n          }\n\n          context.report({\n            node: previous,\n            messageId: 'preferOptionalChain',\n            suggest: [{\n              messageId: 'optionalChainSuggest',\n              fix: fixer => [fixer.replaceText(previous, optionallyChainedCode)]\n            }]\n          });\n        }\n      }\n\n    };\n\n    function getText(node) {\n      if (node.type === utils_1.AST_NODE_TYPES.BinaryExpression) {\n        return getText( // isValidChainTarget ensures this is type safe\n        node.left);\n      }\n\n      if (node.type === utils_1.AST_NODE_TYPES.CallExpression) {\n        const calleeText = getText( // isValidChainTarget ensures this is type safe\n        node.callee); // ensure that the call arguments are left untouched, or else we can break cases that _need_ whitespace:\n        // - JSX: <Foo Needs Space Between Attrs />\n        // - Unary Operators: typeof foo, await bar, delete baz\n\n        const closingParenToken = util.nullThrows(sourceCode.getLastToken(node), util.NullThrowsReasons.MissingToken('closing parenthesis', node.type));\n        const openingParenToken = util.nullThrows(sourceCode.getFirstTokenBetween(node.callee, closingParenToken, util.isOpeningParenToken), util.NullThrowsReasons.MissingToken('opening parenthesis', node.type));\n        const argumentsText = sourceCode.text.substring(openingParenToken.range[0], closingParenToken.range[1]);\n        return `${calleeText}${argumentsText}`;\n      }\n\n      if (node.type === utils_1.AST_NODE_TYPES.Identifier) {\n        return node.name;\n      }\n\n      if (node.type === utils_1.AST_NODE_TYPES.ThisExpression) {\n        return 'this';\n      }\n\n      if (node.type === utils_1.AST_NODE_TYPES.ChainExpression) {\n        /* istanbul ignore if */\n        if (node.expression.type === utils_1.AST_NODE_TYPES.TSNonNullExpression) {\n          // this shouldn't happen\n          return '';\n        }\n\n        return getText(node.expression);\n      }\n\n      return getMemberExpressionText(node);\n    }\n    /**\n     * Gets a normalized representation of the given MemberExpression\n     */\n\n\n    function getMemberExpressionText(node) {\n      let objectText; // cases should match the list in ALLOWED_MEMBER_OBJECT_TYPES\n\n      switch (node.object.type) {\n        case utils_1.AST_NODE_TYPES.CallExpression:\n        case utils_1.AST_NODE_TYPES.Identifier:\n          objectText = getText(node.object);\n          break;\n\n        case utils_1.AST_NODE_TYPES.MemberExpression:\n          objectText = getMemberExpressionText(node.object);\n          break;\n\n        case utils_1.AST_NODE_TYPES.ThisExpression:\n          objectText = getText(node.object);\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(`Unexpected member object type: ${node.object.type}`);\n      }\n\n      let propertyText;\n\n      if (node.computed) {\n        // cases should match the list in ALLOWED_COMPUTED_PROP_TYPES\n        switch (node.property.type) {\n          case utils_1.AST_NODE_TYPES.Identifier:\n            propertyText = getText(node.property);\n            break;\n\n          case utils_1.AST_NODE_TYPES.Literal:\n          case utils_1.AST_NODE_TYPES.TemplateLiteral:\n            propertyText = sourceCode.getText(node.property);\n            break;\n\n          case utils_1.AST_NODE_TYPES.MemberExpression:\n            propertyText = getMemberExpressionText(node.property);\n            break;\n\n          /* istanbul ignore next */\n\n          default:\n            throw new Error(`Unexpected member property type: ${node.object.type}`);\n        }\n\n        return `${objectText}${node.optional ? '?.' : ''}[${propertyText}]`;\n      } else {\n        // cases should match the list in ALLOWED_NON_COMPUTED_PROP_TYPES\n        switch (node.property.type) {\n          case utils_1.AST_NODE_TYPES.Identifier:\n            propertyText = getText(node.property);\n            break;\n\n          /* istanbul ignore next */\n\n          default:\n            throw new Error(`Unexpected member property type: ${node.object.type}`);\n        }\n\n        return `${objectText}${node.optional ? '?.' : '.'}${propertyText}`;\n      }\n    }\n  }\n\n});\nconst ALLOWED_MEMBER_OBJECT_TYPES = new Set([utils_1.AST_NODE_TYPES.CallExpression, utils_1.AST_NODE_TYPES.Identifier, utils_1.AST_NODE_TYPES.MemberExpression, utils_1.AST_NODE_TYPES.ThisExpression]);\nconst ALLOWED_COMPUTED_PROP_TYPES = new Set([utils_1.AST_NODE_TYPES.Identifier, utils_1.AST_NODE_TYPES.Literal, utils_1.AST_NODE_TYPES.MemberExpression, utils_1.AST_NODE_TYPES.TemplateLiteral]);\nconst ALLOWED_NON_COMPUTED_PROP_TYPES = new Set([utils_1.AST_NODE_TYPES.Identifier]);\n\nfunction isValidChainTarget(node, allowIdentifier) {\n  if (node.type === utils_1.AST_NODE_TYPES.ChainExpression) {\n    return isValidChainTarget(node.expression, allowIdentifier);\n  }\n\n  if (node.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n    const isObjectValid = ALLOWED_MEMBER_OBJECT_TYPES.has(node.object.type) && // make sure to validate the expression is of our expected structure\n    isValidChainTarget(node.object, true);\n    const isPropertyValid = node.computed ? ALLOWED_COMPUTED_PROP_TYPES.has(node.property.type) && ( // make sure to validate the member expression is of our expected structure\n    node.property.type === utils_1.AST_NODE_TYPES.MemberExpression ? isValidChainTarget(node.property, allowIdentifier) : true) : ALLOWED_NON_COMPUTED_PROP_TYPES.has(node.property.type);\n    return isObjectValid && isPropertyValid;\n  }\n\n  if (node.type === utils_1.AST_NODE_TYPES.CallExpression) {\n    return isValidChainTarget(node.callee, allowIdentifier);\n  }\n\n  if (allowIdentifier && (node.type === utils_1.AST_NODE_TYPES.Identifier || node.type === utils_1.AST_NODE_TYPES.ThisExpression)) {\n    return true;\n  }\n  /*\n  special case for the following, where we only want the left\n  - foo !== null\n  - foo != null\n  - foo !== undefined\n  - foo != undefined\n  */\n\n\n  return node.type === utils_1.AST_NODE_TYPES.BinaryExpression && ['!==', '!='].includes(node.operator) && isValidChainTarget(node.left, allowIdentifier) && (util.isUndefinedIdentifier(node.right) || util.isNullLiteral(node.right));\n}","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","hasSuggestions","messages","preferOptionalChain","optionalChainSuggest","schema","defaultOptions","create","context","sourceCode","getSourceCode","parserServices","getParserServices","node","leftNode","left","rightNode","right","parentNode","parent","isRightNodeAnEmptyObjectLiteral","utils_1","ObjectExpression","properties","length","MemberExpression","optional","isLeftSideLowerPrecedence","logicalTsNode","esTreeNodeToTSNodeMap","get","leftTsNode","operator","operatorToken","kind","ts","SyntaxKind","Unknown","leftPrecedence","getOperatorPrecedence","OperatorPrecedence","LeftHandSide","report","messageId","suggest","fix","fixer","leftNodeText","getText","maybeWrappedLeftNode","propertyToBeOptionalText","property","maybeWrappedProperty","computed","replaceTextRange","range","join","initialIdentifierOrNotEqualsExpr","initialExpression","_a","ChainExpression","isValidChainTarget","previous","current","previousLeftText","optionallyChainedCode","expressionCount","LogicalExpression","leftText","rightText","matchRegex","RegExp","replace","test","diff","startsWith","needsDot","nullThrows","NullThrowsReasons","MissingParent","BinaryExpression","replaceText","CallExpression","calleeText","callee","closingParenToken","getLastToken","MissingToken","openingParenToken","getFirstTokenBetween","isOpeningParenToken","argumentsText","text","substring","Identifier","ThisExpression","expression","TSNonNullExpression","getMemberExpressionText","objectText","object","Error","propertyText","Literal","TemplateLiteral","ALLOWED_MEMBER_OBJECT_TYPES","Set","ALLOWED_COMPUTED_PROP_TYPES","ALLOWED_NON_COMPUTED_PROP_TYPES","allowIdentifier","isObjectValid","has","isPropertyValid","includes","isUndefinedIdentifier","isNullLiteral"],"sources":["../../src/rules/prefer-optional-chain.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}