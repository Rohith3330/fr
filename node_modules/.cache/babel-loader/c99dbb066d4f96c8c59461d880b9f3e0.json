{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parse = exports.isTraversal = void 0;\n\nvar types_1 = require(\"./types\");\n\nvar reName = /^[^\\\\#]?(?:\\\\(?:[\\da-f]{1,6}\\s?|.)|[\\w\\-\\u00b0-\\uFFFF])+/;\nvar reEscape = /\\\\([\\da-f]{1,6}\\s?|(\\s)|.)/gi;\nvar actionTypes = new Map([[126\n/* Tilde */\n, types_1.AttributeAction.Element], [94\n/* Circumflex */\n, types_1.AttributeAction.Start], [36\n/* Dollar */\n, types_1.AttributeAction.End], [42\n/* Asterisk */\n, types_1.AttributeAction.Any], [33\n/* ExclamationMark */\n, types_1.AttributeAction.Not], [124\n/* Pipe */\n, types_1.AttributeAction.Hyphen]]); // Pseudos, whose data property is parsed as well.\n\nvar unpackPseudos = new Set([\"has\", \"not\", \"matches\", \"is\", \"where\", \"host\", \"host-context\"]);\n/**\n * Checks whether a specific selector is a traversal.\n * This is useful eg. in swapping the order of elements that\n * are not traversals.\n *\n * @param selector Selector to check.\n */\n\nfunction isTraversal(selector) {\n  switch (selector.type) {\n    case types_1.SelectorType.Adjacent:\n    case types_1.SelectorType.Child:\n    case types_1.SelectorType.Descendant:\n    case types_1.SelectorType.Parent:\n    case types_1.SelectorType.Sibling:\n    case types_1.SelectorType.ColumnCombinator:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexports.isTraversal = isTraversal;\nvar stripQuotesFromPseudos = new Set([\"contains\", \"icontains\"]); // Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152\n\nfunction funescape(_, escaped, escapedWhitespace) {\n  var high = parseInt(escaped, 16) - 0x10000; // NaN means non-codepoint\n\n  return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n  String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n  String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);\n}\n\nfunction unescapeCSS(str) {\n  return str.replace(reEscape, funescape);\n}\n\nfunction isQuote(c) {\n  return c === 39\n  /* SingleQuote */\n  || c === 34\n  /* DoubleQuote */\n  ;\n}\n\nfunction isWhitespace(c) {\n  return c === 32\n  /* Space */\n  || c === 9\n  /* Tab */\n  || c === 10\n  /* NewLine */\n  || c === 12\n  /* FormFeed */\n  || c === 13\n  /* CarriageReturn */\n  ;\n}\n/**\n * Parses `selector`, optionally with the passed `options`.\n *\n * @param selector Selector to parse.\n * @param options Options for parsing.\n * @returns Returns a two-dimensional array.\n * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),\n * the second contains the relevant tokens for that selector.\n */\n\n\nfunction parse(selector) {\n  var subselects = [];\n  var endIndex = parseSelector(subselects, \"\".concat(selector), 0);\n\n  if (endIndex < selector.length) {\n    throw new Error(\"Unmatched selector: \".concat(selector.slice(endIndex)));\n  }\n\n  return subselects;\n}\n\nexports.parse = parse;\n\nfunction parseSelector(subselects, selector, selectorIndex) {\n  var tokens = [];\n\n  function getName(offset) {\n    var match = selector.slice(selectorIndex + offset).match(reName);\n\n    if (!match) {\n      throw new Error(\"Expected name, found \".concat(selector.slice(selectorIndex)));\n    }\n\n    var name = match[0];\n    selectorIndex += offset + name.length;\n    return unescapeCSS(name);\n  }\n\n  function stripWhitespace(offset) {\n    selectorIndex += offset;\n\n    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {\n      selectorIndex++;\n    }\n  }\n\n  function readValueWithParenthesis() {\n    selectorIndex += 1;\n    var start = selectorIndex;\n    var counter = 1;\n\n    for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {\n      if (selector.charCodeAt(selectorIndex) === 40\n      /* LeftParenthesis */\n      && !isEscaped(selectorIndex)) {\n        counter++;\n      } else if (selector.charCodeAt(selectorIndex) === 41\n      /* RightParenthesis */\n      && !isEscaped(selectorIndex)) {\n        counter--;\n      }\n    }\n\n    if (counter) {\n      throw new Error(\"Parenthesis not matched\");\n    }\n\n    return unescapeCSS(selector.slice(start, selectorIndex - 1));\n  }\n\n  function isEscaped(pos) {\n    var slashCount = 0;\n\n    while (selector.charCodeAt(--pos) === 92\n    /* BackSlash */\n    ) slashCount++;\n\n    return (slashCount & 1) === 1;\n  }\n\n  function ensureNotTraversal() {\n    if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {\n      throw new Error(\"Did not expect successive traversals.\");\n    }\n  }\n\n  function addTraversal(type) {\n    if (tokens.length > 0 && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {\n      tokens[tokens.length - 1].type = type;\n      return;\n    }\n\n    ensureNotTraversal();\n    tokens.push({\n      type: type\n    });\n  }\n\n  function addSpecialAttribute(name, action) {\n    tokens.push({\n      type: types_1.SelectorType.Attribute,\n      name: name,\n      action: action,\n      value: getName(1),\n      namespace: null,\n      ignoreCase: \"quirks\"\n    });\n  }\n  /**\n   * We have finished parsing the current part of the selector.\n   *\n   * Remove descendant tokens at the end if they exist,\n   * and return the last index, so that parsing can be\n   * picked up from here.\n   */\n\n\n  function finalizeSubselector() {\n    if (tokens.length && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {\n      tokens.pop();\n    }\n\n    if (tokens.length === 0) {\n      throw new Error(\"Empty sub-selector\");\n    }\n\n    subselects.push(tokens);\n  }\n\n  stripWhitespace(0);\n\n  if (selector.length === selectorIndex) {\n    return selectorIndex;\n  }\n\n  loop: while (selectorIndex < selector.length) {\n    var firstChar = selector.charCodeAt(selectorIndex);\n\n    switch (firstChar) {\n      // Whitespace\n      case 32\n      /* Space */\n      :\n      case 9\n      /* Tab */\n      :\n      case 10\n      /* NewLine */\n      :\n      case 12\n      /* FormFeed */\n      :\n      case 13\n      /* CarriageReturn */\n      :\n        {\n          if (tokens.length === 0 || tokens[0].type !== types_1.SelectorType.Descendant) {\n            ensureNotTraversal();\n            tokens.push({\n              type: types_1.SelectorType.Descendant\n            });\n          }\n\n          stripWhitespace(1);\n          break;\n        }\n      // Traversals\n\n      case 62\n      /* GreaterThan */\n      :\n        {\n          addTraversal(types_1.SelectorType.Child);\n          stripWhitespace(1);\n          break;\n        }\n\n      case 60\n      /* LessThan */\n      :\n        {\n          addTraversal(types_1.SelectorType.Parent);\n          stripWhitespace(1);\n          break;\n        }\n\n      case 126\n      /* Tilde */\n      :\n        {\n          addTraversal(types_1.SelectorType.Sibling);\n          stripWhitespace(1);\n          break;\n        }\n\n      case 43\n      /* Plus */\n      :\n        {\n          addTraversal(types_1.SelectorType.Adjacent);\n          stripWhitespace(1);\n          break;\n        }\n      // Special attribute selectors: .class, #id\n\n      case 46\n      /* Period */\n      :\n        {\n          addSpecialAttribute(\"class\", types_1.AttributeAction.Element);\n          break;\n        }\n\n      case 35\n      /* Hash */\n      :\n        {\n          addSpecialAttribute(\"id\", types_1.AttributeAction.Equals);\n          break;\n        }\n\n      case 91\n      /* LeftSquareBracket */\n      :\n        {\n          stripWhitespace(1); // Determine attribute name and namespace\n\n          var name_1 = void 0;\n          var namespace = null;\n\n          if (selector.charCodeAt(selectorIndex) === 124\n          /* Pipe */\n          ) {\n            // Equivalent to no namespace\n            name_1 = getName(1);\n          } else if (selector.startsWith(\"*|\", selectorIndex)) {\n            namespace = \"*\";\n            name_1 = getName(2);\n          } else {\n            name_1 = getName(0);\n\n            if (selector.charCodeAt(selectorIndex) === 124\n            /* Pipe */\n            && selector.charCodeAt(selectorIndex + 1) !== 61\n            /* Equal */\n            ) {\n              namespace = name_1;\n              name_1 = getName(1);\n            }\n          }\n\n          stripWhitespace(0); // Determine comparison operation\n\n          var action = types_1.AttributeAction.Exists;\n          var possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));\n\n          if (possibleAction) {\n            action = possibleAction;\n\n            if (selector.charCodeAt(selectorIndex + 1) !== 61\n            /* Equal */\n            ) {\n              throw new Error(\"Expected `=`\");\n            }\n\n            stripWhitespace(2);\n          } else if (selector.charCodeAt(selectorIndex) === 61\n          /* Equal */\n          ) {\n            action = types_1.AttributeAction.Equals;\n            stripWhitespace(1);\n          } // Determine value\n\n\n          var value = \"\";\n          var ignoreCase = null;\n\n          if (action !== \"exists\") {\n            if (isQuote(selector.charCodeAt(selectorIndex))) {\n              var quote = selector.charCodeAt(selectorIndex);\n              var sectionEnd = selectorIndex + 1;\n\n              while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {\n                sectionEnd += 1;\n              }\n\n              if (selector.charCodeAt(sectionEnd) !== quote) {\n                throw new Error(\"Attribute value didn't end\");\n              }\n\n              value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));\n              selectorIndex = sectionEnd + 1;\n            } else {\n              var valueStart = selectorIndex;\n\n              while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93\n              /* RightSquareBracket */\n              || isEscaped(selectorIndex))) {\n                selectorIndex += 1;\n              }\n\n              value = unescapeCSS(selector.slice(valueStart, selectorIndex));\n            }\n\n            stripWhitespace(0); // See if we have a force ignore flag\n\n            var forceIgnore = selector.charCodeAt(selectorIndex) | 0x20; // If the forceIgnore flag is set (either `i` or `s`), use that value\n\n            if (forceIgnore === 115\n            /* LowerS */\n            ) {\n              ignoreCase = false;\n              stripWhitespace(1);\n            } else if (forceIgnore === 105\n            /* LowerI */\n            ) {\n              ignoreCase = true;\n              stripWhitespace(1);\n            }\n          }\n\n          if (selector.charCodeAt(selectorIndex) !== 93\n          /* RightSquareBracket */\n          ) {\n            throw new Error(\"Attribute selector didn't terminate\");\n          }\n\n          selectorIndex += 1;\n          var attributeSelector = {\n            type: types_1.SelectorType.Attribute,\n            name: name_1,\n            action: action,\n            value: value,\n            namespace: namespace,\n            ignoreCase: ignoreCase\n          };\n          tokens.push(attributeSelector);\n          break;\n        }\n\n      case 58\n      /* Colon */\n      :\n        {\n          if (selector.charCodeAt(selectorIndex + 1) === 58\n          /* Colon */\n          ) {\n            tokens.push({\n              type: types_1.SelectorType.PseudoElement,\n              name: getName(2).toLowerCase(),\n              data: selector.charCodeAt(selectorIndex) === 40\n              /* LeftParenthesis */\n              ? readValueWithParenthesis() : null\n            });\n            continue;\n          }\n\n          var name_2 = getName(1).toLowerCase();\n          var data = null;\n\n          if (selector.charCodeAt(selectorIndex) === 40\n          /* LeftParenthesis */\n          ) {\n            if (unpackPseudos.has(name_2)) {\n              if (isQuote(selector.charCodeAt(selectorIndex + 1))) {\n                throw new Error(\"Pseudo-selector \".concat(name_2, \" cannot be quoted\"));\n              }\n\n              data = [];\n              selectorIndex = parseSelector(data, selector, selectorIndex + 1);\n\n              if (selector.charCodeAt(selectorIndex) !== 41\n              /* RightParenthesis */\n              ) {\n                throw new Error(\"Missing closing parenthesis in :\".concat(name_2, \" (\").concat(selector, \")\"));\n              }\n\n              selectorIndex += 1;\n            } else {\n              data = readValueWithParenthesis();\n\n              if (stripQuotesFromPseudos.has(name_2)) {\n                var quot = data.charCodeAt(0);\n\n                if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {\n                  data = data.slice(1, -1);\n                }\n              }\n\n              data = unescapeCSS(data);\n            }\n          }\n\n          tokens.push({\n            type: types_1.SelectorType.Pseudo,\n            name: name_2,\n            data: data\n          });\n          break;\n        }\n\n      case 44\n      /* Comma */\n      :\n        {\n          finalizeSubselector();\n          tokens = [];\n          stripWhitespace(1);\n          break;\n        }\n\n      default:\n        {\n          if (selector.startsWith(\"/*\", selectorIndex)) {\n            var endIndex = selector.indexOf(\"*/\", selectorIndex + 2);\n\n            if (endIndex < 0) {\n              throw new Error(\"Comment was not terminated\");\n            }\n\n            selectorIndex = endIndex + 2; // Remove leading whitespace\n\n            if (tokens.length === 0) {\n              stripWhitespace(0);\n            }\n\n            break;\n          }\n\n          var namespace = null;\n          var name_3 = void 0;\n\n          if (firstChar === 42\n          /* Asterisk */\n          ) {\n            selectorIndex += 1;\n            name_3 = \"*\";\n          } else if (firstChar === 124\n          /* Pipe */\n          ) {\n            name_3 = \"\";\n\n            if (selector.charCodeAt(selectorIndex + 1) === 124\n            /* Pipe */\n            ) {\n              addTraversal(types_1.SelectorType.ColumnCombinator);\n              stripWhitespace(2);\n              break;\n            }\n          } else if (reName.test(selector.slice(selectorIndex))) {\n            name_3 = getName(0);\n          } else {\n            break loop;\n          }\n\n          if (selector.charCodeAt(selectorIndex) === 124\n          /* Pipe */\n          && selector.charCodeAt(selectorIndex + 1) !== 124\n          /* Pipe */\n          ) {\n            namespace = name_3;\n\n            if (selector.charCodeAt(selectorIndex + 1) === 42\n            /* Asterisk */\n            ) {\n              name_3 = \"*\";\n              selectorIndex += 2;\n            } else {\n              name_3 = getName(1);\n            }\n          }\n\n          tokens.push(name_3 === \"*\" ? {\n            type: types_1.SelectorType.Universal,\n            namespace: namespace\n          } : {\n            type: types_1.SelectorType.Tag,\n            name: name_3,\n            namespace: namespace\n          });\n        }\n    }\n  }\n\n  finalizeSubselector();\n  return selectorIndex;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","parse","isTraversal","types_1","require","reName","reEscape","actionTypes","Map","AttributeAction","Element","Start","End","Any","Not","Hyphen","unpackPseudos","Set","selector","type","SelectorType","Adjacent","Child","Descendant","Parent","Sibling","ColumnCombinator","stripQuotesFromPseudos","funescape","_","escaped","escapedWhitespace","high","parseInt","String","fromCharCode","unescapeCSS","str","replace","isQuote","c","isWhitespace","subselects","endIndex","parseSelector","concat","length","Error","slice","selectorIndex","tokens","getName","offset","match","name","stripWhitespace","charCodeAt","readValueWithParenthesis","start","counter","isEscaped","pos","slashCount","ensureNotTraversal","addTraversal","push","addSpecialAttribute","action","Attribute","namespace","ignoreCase","finalizeSubselector","pop","loop","firstChar","Equals","name_1","startsWith","Exists","possibleAction","get","quote","sectionEnd","valueStart","forceIgnore","attributeSelector","PseudoElement","toLowerCase","data","name_2","has","quot","Pseudo","indexOf","name_3","test","Universal","Tag"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/css-what/lib/commonjs/parse.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = exports.isTraversal = void 0;\nvar types_1 = require(\"./types\");\nvar reName = /^[^\\\\#]?(?:\\\\(?:[\\da-f]{1,6}\\s?|.)|[\\w\\-\\u00b0-\\uFFFF])+/;\nvar reEscape = /\\\\([\\da-f]{1,6}\\s?|(\\s)|.)/gi;\nvar actionTypes = new Map([\n    [126 /* Tilde */, types_1.AttributeAction.Element],\n    [94 /* Circumflex */, types_1.AttributeAction.Start],\n    [36 /* Dollar */, types_1.AttributeAction.End],\n    [42 /* Asterisk */, types_1.AttributeAction.Any],\n    [33 /* ExclamationMark */, types_1.AttributeAction.Not],\n    [124 /* Pipe */, types_1.AttributeAction.Hyphen],\n]);\n// Pseudos, whose data property is parsed as well.\nvar unpackPseudos = new Set([\n    \"has\",\n    \"not\",\n    \"matches\",\n    \"is\",\n    \"where\",\n    \"host\",\n    \"host-context\",\n]);\n/**\n * Checks whether a specific selector is a traversal.\n * This is useful eg. in swapping the order of elements that\n * are not traversals.\n *\n * @param selector Selector to check.\n */\nfunction isTraversal(selector) {\n    switch (selector.type) {\n        case types_1.SelectorType.Adjacent:\n        case types_1.SelectorType.Child:\n        case types_1.SelectorType.Descendant:\n        case types_1.SelectorType.Parent:\n        case types_1.SelectorType.Sibling:\n        case types_1.SelectorType.ColumnCombinator:\n            return true;\n        default:\n            return false;\n    }\n}\nexports.isTraversal = isTraversal;\nvar stripQuotesFromPseudos = new Set([\"contains\", \"icontains\"]);\n// Unescape function taken from https://github.com/jquery/sizzle/blob/master/src/sizzle.js#L152\nfunction funescape(_, escaped, escapedWhitespace) {\n    var high = parseInt(escaped, 16) - 0x10000;\n    // NaN means non-codepoint\n    return high !== high || escapedWhitespace\n        ? escaped\n        : high < 0\n            ? // BMP codepoint\n                String.fromCharCode(high + 0x10000)\n            : // Supplemental Plane codepoint (surrogate pair)\n                String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n}\nfunction unescapeCSS(str) {\n    return str.replace(reEscape, funescape);\n}\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\nfunction isWhitespace(c) {\n    return (c === 32 /* Space */ ||\n        c === 9 /* Tab */ ||\n        c === 10 /* NewLine */ ||\n        c === 12 /* FormFeed */ ||\n        c === 13 /* CarriageReturn */);\n}\n/**\n * Parses `selector`, optionally with the passed `options`.\n *\n * @param selector Selector to parse.\n * @param options Options for parsing.\n * @returns Returns a two-dimensional array.\n * The first dimension represents selectors separated by commas (eg. `sub1, sub2`),\n * the second contains the relevant tokens for that selector.\n */\nfunction parse(selector) {\n    var subselects = [];\n    var endIndex = parseSelector(subselects, \"\".concat(selector), 0);\n    if (endIndex < selector.length) {\n        throw new Error(\"Unmatched selector: \".concat(selector.slice(endIndex)));\n    }\n    return subselects;\n}\nexports.parse = parse;\nfunction parseSelector(subselects, selector, selectorIndex) {\n    var tokens = [];\n    function getName(offset) {\n        var match = selector.slice(selectorIndex + offset).match(reName);\n        if (!match) {\n            throw new Error(\"Expected name, found \".concat(selector.slice(selectorIndex)));\n        }\n        var name = match[0];\n        selectorIndex += offset + name.length;\n        return unescapeCSS(name);\n    }\n    function stripWhitespace(offset) {\n        selectorIndex += offset;\n        while (selectorIndex < selector.length &&\n            isWhitespace(selector.charCodeAt(selectorIndex))) {\n            selectorIndex++;\n        }\n    }\n    function readValueWithParenthesis() {\n        selectorIndex += 1;\n        var start = selectorIndex;\n        var counter = 1;\n        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {\n            if (selector.charCodeAt(selectorIndex) ===\n                40 /* LeftParenthesis */ &&\n                !isEscaped(selectorIndex)) {\n                counter++;\n            }\n            else if (selector.charCodeAt(selectorIndex) ===\n                41 /* RightParenthesis */ &&\n                !isEscaped(selectorIndex)) {\n                counter--;\n            }\n        }\n        if (counter) {\n            throw new Error(\"Parenthesis not matched\");\n        }\n        return unescapeCSS(selector.slice(start, selectorIndex - 1));\n    }\n    function isEscaped(pos) {\n        var slashCount = 0;\n        while (selector.charCodeAt(--pos) === 92 /* BackSlash */)\n            slashCount++;\n        return (slashCount & 1) === 1;\n    }\n    function ensureNotTraversal() {\n        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {\n            throw new Error(\"Did not expect successive traversals.\");\n        }\n    }\n    function addTraversal(type) {\n        if (tokens.length > 0 &&\n            tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {\n            tokens[tokens.length - 1].type = type;\n            return;\n        }\n        ensureNotTraversal();\n        tokens.push({ type: type });\n    }\n    function addSpecialAttribute(name, action) {\n        tokens.push({\n            type: types_1.SelectorType.Attribute,\n            name: name,\n            action: action,\n            value: getName(1),\n            namespace: null,\n            ignoreCase: \"quirks\",\n        });\n    }\n    /**\n     * We have finished parsing the current part of the selector.\n     *\n     * Remove descendant tokens at the end if they exist,\n     * and return the last index, so that parsing can be\n     * picked up from here.\n     */\n    function finalizeSubselector() {\n        if (tokens.length &&\n            tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {\n            tokens.pop();\n        }\n        if (tokens.length === 0) {\n            throw new Error(\"Empty sub-selector\");\n        }\n        subselects.push(tokens);\n    }\n    stripWhitespace(0);\n    if (selector.length === selectorIndex) {\n        return selectorIndex;\n    }\n    loop: while (selectorIndex < selector.length) {\n        var firstChar = selector.charCodeAt(selectorIndex);\n        switch (firstChar) {\n            // Whitespace\n            case 32 /* Space */:\n            case 9 /* Tab */:\n            case 10 /* NewLine */:\n            case 12 /* FormFeed */:\n            case 13 /* CarriageReturn */: {\n                if (tokens.length === 0 ||\n                    tokens[0].type !== types_1.SelectorType.Descendant) {\n                    ensureNotTraversal();\n                    tokens.push({ type: types_1.SelectorType.Descendant });\n                }\n                stripWhitespace(1);\n                break;\n            }\n            // Traversals\n            case 62 /* GreaterThan */: {\n                addTraversal(types_1.SelectorType.Child);\n                stripWhitespace(1);\n                break;\n            }\n            case 60 /* LessThan */: {\n                addTraversal(types_1.SelectorType.Parent);\n                stripWhitespace(1);\n                break;\n            }\n            case 126 /* Tilde */: {\n                addTraversal(types_1.SelectorType.Sibling);\n                stripWhitespace(1);\n                break;\n            }\n            case 43 /* Plus */: {\n                addTraversal(types_1.SelectorType.Adjacent);\n                stripWhitespace(1);\n                break;\n            }\n            // Special attribute selectors: .class, #id\n            case 46 /* Period */: {\n                addSpecialAttribute(\"class\", types_1.AttributeAction.Element);\n                break;\n            }\n            case 35 /* Hash */: {\n                addSpecialAttribute(\"id\", types_1.AttributeAction.Equals);\n                break;\n            }\n            case 91 /* LeftSquareBracket */: {\n                stripWhitespace(1);\n                // Determine attribute name and namespace\n                var name_1 = void 0;\n                var namespace = null;\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */) {\n                    // Equivalent to no namespace\n                    name_1 = getName(1);\n                }\n                else if (selector.startsWith(\"*|\", selectorIndex)) {\n                    namespace = \"*\";\n                    name_1 = getName(2);\n                }\n                else {\n                    name_1 = getName(0);\n                    if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\n                        selector.charCodeAt(selectorIndex + 1) !==\n                            61 /* Equal */) {\n                        namespace = name_1;\n                        name_1 = getName(1);\n                    }\n                }\n                stripWhitespace(0);\n                // Determine comparison operation\n                var action = types_1.AttributeAction.Exists;\n                var possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));\n                if (possibleAction) {\n                    action = possibleAction;\n                    if (selector.charCodeAt(selectorIndex + 1) !==\n                        61 /* Equal */) {\n                        throw new Error(\"Expected `=`\");\n                    }\n                    stripWhitespace(2);\n                }\n                else if (selector.charCodeAt(selectorIndex) === 61 /* Equal */) {\n                    action = types_1.AttributeAction.Equals;\n                    stripWhitespace(1);\n                }\n                // Determine value\n                var value = \"\";\n                var ignoreCase = null;\n                if (action !== \"exists\") {\n                    if (isQuote(selector.charCodeAt(selectorIndex))) {\n                        var quote = selector.charCodeAt(selectorIndex);\n                        var sectionEnd = selectorIndex + 1;\n                        while (sectionEnd < selector.length &&\n                            (selector.charCodeAt(sectionEnd) !== quote ||\n                                isEscaped(sectionEnd))) {\n                            sectionEnd += 1;\n                        }\n                        if (selector.charCodeAt(sectionEnd) !== quote) {\n                            throw new Error(\"Attribute value didn't end\");\n                        }\n                        value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));\n                        selectorIndex = sectionEnd + 1;\n                    }\n                    else {\n                        var valueStart = selectorIndex;\n                        while (selectorIndex < selector.length &&\n                            ((!isWhitespace(selector.charCodeAt(selectorIndex)) &&\n                                selector.charCodeAt(selectorIndex) !==\n                                    93 /* RightSquareBracket */) ||\n                                isEscaped(selectorIndex))) {\n                            selectorIndex += 1;\n                        }\n                        value = unescapeCSS(selector.slice(valueStart, selectorIndex));\n                    }\n                    stripWhitespace(0);\n                    // See if we have a force ignore flag\n                    var forceIgnore = selector.charCodeAt(selectorIndex) | 0x20;\n                    // If the forceIgnore flag is set (either `i` or `s`), use that value\n                    if (forceIgnore === 115 /* LowerS */) {\n                        ignoreCase = false;\n                        stripWhitespace(1);\n                    }\n                    else if (forceIgnore === 105 /* LowerI */) {\n                        ignoreCase = true;\n                        stripWhitespace(1);\n                    }\n                }\n                if (selector.charCodeAt(selectorIndex) !==\n                    93 /* RightSquareBracket */) {\n                    throw new Error(\"Attribute selector didn't terminate\");\n                }\n                selectorIndex += 1;\n                var attributeSelector = {\n                    type: types_1.SelectorType.Attribute,\n                    name: name_1,\n                    action: action,\n                    value: value,\n                    namespace: namespace,\n                    ignoreCase: ignoreCase,\n                };\n                tokens.push(attributeSelector);\n                break;\n            }\n            case 58 /* Colon */: {\n                if (selector.charCodeAt(selectorIndex + 1) === 58 /* Colon */) {\n                    tokens.push({\n                        type: types_1.SelectorType.PseudoElement,\n                        name: getName(2).toLowerCase(),\n                        data: selector.charCodeAt(selectorIndex) ===\n                            40 /* LeftParenthesis */\n                            ? readValueWithParenthesis()\n                            : null,\n                    });\n                    continue;\n                }\n                var name_2 = getName(1).toLowerCase();\n                var data = null;\n                if (selector.charCodeAt(selectorIndex) ===\n                    40 /* LeftParenthesis */) {\n                    if (unpackPseudos.has(name_2)) {\n                        if (isQuote(selector.charCodeAt(selectorIndex + 1))) {\n                            throw new Error(\"Pseudo-selector \".concat(name_2, \" cannot be quoted\"));\n                        }\n                        data = [];\n                        selectorIndex = parseSelector(data, selector, selectorIndex + 1);\n                        if (selector.charCodeAt(selectorIndex) !==\n                            41 /* RightParenthesis */) {\n                            throw new Error(\"Missing closing parenthesis in :\".concat(name_2, \" (\").concat(selector, \")\"));\n                        }\n                        selectorIndex += 1;\n                    }\n                    else {\n                        data = readValueWithParenthesis();\n                        if (stripQuotesFromPseudos.has(name_2)) {\n                            var quot = data.charCodeAt(0);\n                            if (quot === data.charCodeAt(data.length - 1) &&\n                                isQuote(quot)) {\n                                data = data.slice(1, -1);\n                            }\n                        }\n                        data = unescapeCSS(data);\n                    }\n                }\n                tokens.push({ type: types_1.SelectorType.Pseudo, name: name_2, data: data });\n                break;\n            }\n            case 44 /* Comma */: {\n                finalizeSubselector();\n                tokens = [];\n                stripWhitespace(1);\n                break;\n            }\n            default: {\n                if (selector.startsWith(\"/*\", selectorIndex)) {\n                    var endIndex = selector.indexOf(\"*/\", selectorIndex + 2);\n                    if (endIndex < 0) {\n                        throw new Error(\"Comment was not terminated\");\n                    }\n                    selectorIndex = endIndex + 2;\n                    // Remove leading whitespace\n                    if (tokens.length === 0) {\n                        stripWhitespace(0);\n                    }\n                    break;\n                }\n                var namespace = null;\n                var name_3 = void 0;\n                if (firstChar === 42 /* Asterisk */) {\n                    selectorIndex += 1;\n                    name_3 = \"*\";\n                }\n                else if (firstChar === 124 /* Pipe */) {\n                    name_3 = \"\";\n                    if (selector.charCodeAt(selectorIndex + 1) === 124 /* Pipe */) {\n                        addTraversal(types_1.SelectorType.ColumnCombinator);\n                        stripWhitespace(2);\n                        break;\n                    }\n                }\n                else if (reName.test(selector.slice(selectorIndex))) {\n                    name_3 = getName(0);\n                }\n                else {\n                    break loop;\n                }\n                if (selector.charCodeAt(selectorIndex) === 124 /* Pipe */ &&\n                    selector.charCodeAt(selectorIndex + 1) !== 124 /* Pipe */) {\n                    namespace = name_3;\n                    if (selector.charCodeAt(selectorIndex + 1) ===\n                        42 /* Asterisk */) {\n                        name_3 = \"*\";\n                        selectorIndex += 2;\n                    }\n                    else {\n                        name_3 = getName(1);\n                    }\n                }\n                tokens.push(name_3 === \"*\"\n                    ? { type: types_1.SelectorType.Universal, namespace: namespace }\n                    : { type: types_1.SelectorType.Tag, name: name_3, namespace: namespace });\n            }\n        }\n    }\n    finalizeSubselector();\n    return selectorIndex;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}