{"ast":null,"code":"/**\n * @fileoverview Enforce curly braces or disallow unnecessary curly brace in JSX\n * @author Jacky Ho\n * @author Simon Lydell\n */\n'use strict';\n\nconst arrayIncludes = require('array-includes');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst jsxUtil = require('../util/jsx');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\n\nconst OPTION_ALWAYS = 'always';\nconst OPTION_NEVER = 'never';\nconst OPTION_IGNORE = 'ignore';\nconst OPTION_VALUES = [OPTION_ALWAYS, OPTION_NEVER, OPTION_IGNORE];\nconst DEFAULT_CONFIG = {\n  props: OPTION_NEVER,\n  children: OPTION_NEVER,\n  propElementValues: OPTION_IGNORE\n}; // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  unnecessaryCurly: 'Curly braces are unnecessary here.',\n  missingCurly: 'Need to wrap this literal in a JSX expression.'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow unnecessary JSX expressions when literals alone are sufficient or enforce JSX expressions on literals in JSX children or attributes',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-curly-brace-presence')\n    },\n    fixable: 'code',\n    messages,\n    schema: [{\n      oneOf: [{\n        type: 'object',\n        properties: {\n          props: {\n            enum: OPTION_VALUES\n          },\n          children: {\n            enum: OPTION_VALUES\n          },\n          propElementValues: {\n            enum: OPTION_VALUES\n          }\n        },\n        additionalProperties: false\n      }, {\n        enum: OPTION_VALUES\n      }]\n    }]\n  },\n\n  create(context) {\n    const HTML_ENTITY_REGEX = () => /&[A-Za-z\\d#]+;/g;\n\n    const ruleOptions = context.options[0];\n    const userConfig = typeof ruleOptions === 'string' ? {\n      props: ruleOptions,\n      children: ruleOptions,\n      propElementValues: OPTION_IGNORE\n    } : Object.assign({}, DEFAULT_CONFIG, ruleOptions);\n\n    function containsLineTerminators(rawStringValue) {\n      return /[\\n\\r\\u2028\\u2029]/.test(rawStringValue);\n    }\n\n    function containsBackslash(rawStringValue) {\n      return arrayIncludes(rawStringValue, '\\\\');\n    }\n\n    function containsHTMLEntity(rawStringValue) {\n      return HTML_ENTITY_REGEX().test(rawStringValue);\n    }\n\n    function containsOnlyHtmlEntities(rawStringValue) {\n      return rawStringValue.replace(HTML_ENTITY_REGEX(), '').trim() === '';\n    }\n\n    function containsDisallowedJSXTextChars(rawStringValue) {\n      return /[{<>}]/.test(rawStringValue);\n    }\n\n    function containsQuoteCharacters(value) {\n      return /['\"]/.test(value);\n    }\n\n    function containsMultilineComment(value) {\n      return /\\/\\*/.test(value);\n    }\n\n    function escapeDoubleQuotes(rawStringValue) {\n      return rawStringValue.replace(/\\\\\"/g, '\"').replace(/\"/g, '\\\\\"');\n    }\n\n    function escapeBackslashes(rawStringValue) {\n      return rawStringValue.replace(/\\\\/g, '\\\\\\\\');\n    }\n\n    function needToEscapeCharacterForJSX(raw, node) {\n      return containsBackslash(raw) || containsHTMLEntity(raw) || node.parent.type !== 'JSXAttribute' && containsDisallowedJSXTextChars(raw);\n    }\n\n    function containsWhitespaceExpression(child) {\n      if (child.type === 'JSXExpressionContainer') {\n        const value = child.expression.value;\n        return value ? jsxUtil.isWhiteSpaces(value) : false;\n      }\n\n      return false;\n    }\n\n    function isLineBreak(text) {\n      return containsLineTerminators(text) && text.trim() === '';\n    }\n\n    function wrapNonHTMLEntities(text) {\n      const HTML_ENTITY = '<HTML_ENTITY>';\n      const withCurlyBraces = text.split(HTML_ENTITY_REGEX()).map(word => word === '' ? '' : `{${JSON.stringify(word)}}`).join(HTML_ENTITY);\n      const htmlEntities = text.match(HTML_ENTITY_REGEX());\n      return htmlEntities.reduce((acc, htmlEntity) => acc.replace(HTML_ENTITY, htmlEntity), withCurlyBraces);\n    }\n\n    function wrapWithCurlyBraces(rawText) {\n      if (!containsLineTerminators(rawText)) {\n        return `{${JSON.stringify(rawText)}}`;\n      }\n\n      return rawText.split('\\n').map(line => {\n        if (line.trim() === '') {\n          return line;\n        }\n\n        const firstCharIndex = line.search(/[^\\s]/);\n        const leftWhitespace = line.slice(0, firstCharIndex);\n        const text = line.slice(firstCharIndex);\n\n        if (containsHTMLEntity(line)) {\n          return `${leftWhitespace}${wrapNonHTMLEntities(text)}`;\n        }\n\n        return `${leftWhitespace}{${JSON.stringify(text)}}`;\n      }).join('\\n');\n    }\n    /**\n     * Report and fix an unnecessary curly brace violation on a node\n     * @param {ASTNode} JSXExpressionNode - The AST node with an unnecessary JSX expression\n     */\n\n\n    function reportUnnecessaryCurly(JSXExpressionNode) {\n      report(context, messages.unnecessaryCurly, 'unnecessaryCurly', {\n        node: JSXExpressionNode,\n\n        fix(fixer) {\n          const expression = JSXExpressionNode.expression;\n          let textToReplace;\n\n          if (jsxUtil.isJSX(expression)) {\n            const sourceCode = context.getSourceCode();\n            textToReplace = sourceCode.getText(expression);\n          } else {\n            const expressionType = expression && expression.type;\n            const parentType = JSXExpressionNode.parent.type;\n\n            if (parentType === 'JSXAttribute') {\n              textToReplace = `\"${expressionType === 'TemplateLiteral' ? expression.quasis[0].value.raw : expression.raw.substring(1, expression.raw.length - 1)}\"`;\n            } else if (jsxUtil.isJSX(expression)) {\n              const sourceCode = context.getSourceCode();\n              textToReplace = sourceCode.getText(expression);\n            } else {\n              textToReplace = expressionType === 'TemplateLiteral' ? expression.quasis[0].value.cooked : expression.value;\n            }\n          }\n\n          return fixer.replaceText(JSXExpressionNode, textToReplace);\n        }\n\n      });\n    }\n\n    function reportMissingCurly(literalNode) {\n      report(context, messages.missingCurly, 'missingCurly', {\n        node: literalNode,\n\n        fix(fixer) {\n          if (jsxUtil.isJSX(literalNode)) {\n            return fixer.replaceText(literalNode, `{${context.getSourceCode().getText(literalNode)}}`);\n          } // If a HTML entity name is found, bail out because it can be fixed\n          // by either using the real character or the unicode equivalent.\n          // If it contains any line terminator character, bail out as well.\n\n\n          if (containsOnlyHtmlEntities(literalNode.raw) || literalNode.parent.type === 'JSXAttribute' && containsLineTerminators(literalNode.raw) || isLineBreak(literalNode.raw)) {\n            return null;\n          }\n\n          const expression = literalNode.parent.type === 'JSXAttribute' ? `{\"${escapeDoubleQuotes(escapeBackslashes(literalNode.raw.substring(1, literalNode.raw.length - 1)))}\"}` : wrapWithCurlyBraces(literalNode.raw);\n          return fixer.replaceText(literalNode, expression);\n        }\n\n      });\n    }\n\n    function isWhiteSpaceLiteral(node) {\n      return node.type && node.type === 'Literal' && node.value && jsxUtil.isWhiteSpaces(node.value);\n    }\n\n    function isStringWithTrailingWhiteSpaces(value) {\n      return /^\\s|\\s$/.test(value);\n    }\n\n    function isLiteralWithTrailingWhiteSpaces(node) {\n      return node.type && node.type === 'Literal' && node.value && isStringWithTrailingWhiteSpaces(node.value);\n    } // Bail out if there is any character that needs to be escaped in JSX\n    // because escaping decreases readability and the original code may be more\n    // readable anyway or intentional for other specific reasons\n\n\n    function lintUnnecessaryCurly(JSXExpressionNode) {\n      const expression = JSXExpressionNode.expression;\n      const expressionType = expression.type;\n      const sourceCode = context.getSourceCode(); // Curly braces containing comments are necessary\n\n      if (sourceCode.getCommentsInside && sourceCode.getCommentsInside(JSXExpressionNode).length > 0) {\n        return;\n      }\n\n      if ((expressionType === 'Literal' || expressionType === 'JSXText') && typeof expression.value === 'string' && (JSXExpressionNode.parent.type === 'JSXAttribute' && !isWhiteSpaceLiteral(expression) || !isLiteralWithTrailingWhiteSpaces(expression)) && !containsMultilineComment(expression.value) && !needToEscapeCharacterForJSX(expression.raw, JSXExpressionNode) && (jsxUtil.isJSX(JSXExpressionNode.parent) || !containsQuoteCharacters(expression.value))) {\n        reportUnnecessaryCurly(JSXExpressionNode);\n      } else if (expressionType === 'TemplateLiteral' && expression.expressions.length === 0 && expression.quasis[0].value.raw.indexOf('\\n') === -1 && !isStringWithTrailingWhiteSpaces(expression.quasis[0].value.raw) && !needToEscapeCharacterForJSX(expression.quasis[0].value.raw, JSXExpressionNode) && !containsQuoteCharacters(expression.quasis[0].value.cooked)) {\n        reportUnnecessaryCurly(JSXExpressionNode);\n      } else if (jsxUtil.isJSX(expression)) {\n        reportUnnecessaryCurly(JSXExpressionNode);\n      }\n    }\n\n    function areRuleConditionsSatisfied(parent, config, ruleCondition) {\n      return parent.type === 'JSXAttribute' && typeof config.props === 'string' && config.props === ruleCondition || jsxUtil.isJSX(parent) && typeof config.children === 'string' && config.children === ruleCondition;\n    }\n\n    function getAdjacentSiblings(node, children) {\n      for (let i = 1; i < children.length - 1; i++) {\n        const child = children[i];\n\n        if (node === child) {\n          return [children[i - 1], children[i + 1]];\n        }\n      }\n\n      if (node === children[0] && children[1]) {\n        return [children[1]];\n      }\n\n      if (node === children[children.length - 1] && children[children.length - 2]) {\n        return [children[children.length - 2]];\n      }\n\n      return [];\n    }\n\n    function hasAdjacentJsxExpressionContainers(node, children) {\n      if (!children) {\n        return false;\n      }\n\n      const childrenExcludingWhitespaceLiteral = children.filter(child => !isWhiteSpaceLiteral(child));\n      const adjSiblings = getAdjacentSiblings(node, childrenExcludingWhitespaceLiteral);\n      return adjSiblings.some(x => x.type && x.type === 'JSXExpressionContainer');\n    }\n\n    function hasAdjacentJsx(node, children) {\n      if (!children) {\n        return false;\n      }\n\n      const childrenExcludingWhitespaceLiteral = children.filter(child => !isWhiteSpaceLiteral(child));\n      const adjSiblings = getAdjacentSiblings(node, childrenExcludingWhitespaceLiteral);\n      return adjSiblings.some(x => x.type && arrayIncludes(['JSXExpressionContainer', 'JSXElement'], x.type));\n    }\n\n    function shouldCheckForUnnecessaryCurly(node, config) {\n      const parent = node.parent; // Bail out if the parent is a JSXAttribute & its contents aren't\n      // StringLiteral or TemplateLiteral since e.g\n      // <App prop1={<CustomEl />} prop2={<CustomEl>...</CustomEl>} />\n\n      if (parent.type && parent.type === 'JSXAttribute' && node.expression && node.expression.type && node.expression.type !== 'Literal' && node.expression.type !== 'StringLiteral' && node.expression.type !== 'TemplateLiteral') {\n        return false;\n      } // If there are adjacent `JsxExpressionContainer` then there is no need,\n      // to check for unnecessary curly braces.\n\n\n      if (jsxUtil.isJSX(parent) && hasAdjacentJsxExpressionContainers(node, parent.children)) {\n        return false;\n      }\n\n      if (containsWhitespaceExpression(node) && hasAdjacentJsx(node, parent.children)) {\n        return false;\n      }\n\n      if (parent.children && parent.children.length === 1 && containsWhitespaceExpression(node)) {\n        return false;\n      }\n\n      return areRuleConditionsSatisfied(parent, config, OPTION_NEVER);\n    }\n\n    function shouldCheckForMissingCurly(node, config) {\n      if (jsxUtil.isJSX(node)) {\n        return config.propElementValues !== OPTION_IGNORE;\n      }\n\n      if (isLineBreak(node.raw) || containsOnlyHtmlEntities(node.raw)) {\n        return false;\n      }\n\n      const parent = node.parent;\n\n      if (parent.children && parent.children.length === 1 && containsWhitespaceExpression(parent.children[0])) {\n        return false;\n      }\n\n      return areRuleConditionsSatisfied(parent, config, OPTION_ALWAYS);\n    } // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n\n    return {\n      'JSXAttribute > JSXExpressionContainer > JSXElement'(node) {\n        if (userConfig.propElementValues === OPTION_NEVER) {\n          reportUnnecessaryCurly(node.parent);\n        }\n      },\n\n      JSXExpressionContainer(node) {\n        if (shouldCheckForUnnecessaryCurly(node, userConfig)) {\n          lintUnnecessaryCurly(node);\n        }\n      },\n\n      'JSXAttribute > JSXElement, Literal, JSXText'(node) {\n        if (shouldCheckForMissingCurly(node, userConfig)) {\n          reportMissingCurly(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["arrayIncludes","require","docsUrl","jsxUtil","report","OPTION_ALWAYS","OPTION_NEVER","OPTION_IGNORE","OPTION_VALUES","DEFAULT_CONFIG","props","children","propElementValues","messages","unnecessaryCurly","missingCurly","module","exports","meta","docs","description","category","recommended","url","fixable","schema","oneOf","type","properties","enum","additionalProperties","create","context","HTML_ENTITY_REGEX","ruleOptions","options","userConfig","Object","assign","containsLineTerminators","rawStringValue","test","containsBackslash","containsHTMLEntity","containsOnlyHtmlEntities","replace","trim","containsDisallowedJSXTextChars","containsQuoteCharacters","value","containsMultilineComment","escapeDoubleQuotes","escapeBackslashes","needToEscapeCharacterForJSX","raw","node","parent","containsWhitespaceExpression","child","expression","isWhiteSpaces","isLineBreak","text","wrapNonHTMLEntities","HTML_ENTITY","withCurlyBraces","split","map","word","JSON","stringify","join","htmlEntities","match","reduce","acc","htmlEntity","wrapWithCurlyBraces","rawText","line","firstCharIndex","search","leftWhitespace","slice","reportUnnecessaryCurly","JSXExpressionNode","fix","fixer","textToReplace","isJSX","sourceCode","getSourceCode","getText","expressionType","parentType","quasis","substring","length","cooked","replaceText","reportMissingCurly","literalNode","isWhiteSpaceLiteral","isStringWithTrailingWhiteSpaces","isLiteralWithTrailingWhiteSpaces","lintUnnecessaryCurly","getCommentsInside","expressions","indexOf","areRuleConditionsSatisfied","config","ruleCondition","getAdjacentSiblings","i","hasAdjacentJsxExpressionContainers","childrenExcludingWhitespaceLiteral","filter","adjSiblings","some","x","hasAdjacentJsx","shouldCheckForUnnecessaryCurly","shouldCheckForMissingCurly","JSXExpressionContainer"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-curly-brace-presence.js"],"sourcesContent":["/**\n * @fileoverview Enforce curly braces or disallow unnecessary curly brace in JSX\n * @author Jacky Ho\n * @author Simon Lydell\n */\n\n'use strict';\n\nconst arrayIncludes = require('array-includes');\n\nconst docsUrl = require('../util/docsUrl');\nconst jsxUtil = require('../util/jsx');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nconst OPTION_ALWAYS = 'always';\nconst OPTION_NEVER = 'never';\nconst OPTION_IGNORE = 'ignore';\n\nconst OPTION_VALUES = [\n  OPTION_ALWAYS,\n  OPTION_NEVER,\n  OPTION_IGNORE,\n];\nconst DEFAULT_CONFIG = { props: OPTION_NEVER, children: OPTION_NEVER, propElementValues: OPTION_IGNORE };\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  unnecessaryCurly: 'Curly braces are unnecessary here.',\n  missingCurly: 'Need to wrap this literal in a JSX expression.',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow unnecessary JSX expressions when literals alone are sufficient or enforce JSX expressions on literals in JSX children or attributes',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-curly-brace-presence'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [\n      {\n        oneOf: [\n          {\n            type: 'object',\n            properties: {\n              props: { enum: OPTION_VALUES },\n              children: { enum: OPTION_VALUES },\n              propElementValues: { enum: OPTION_VALUES },\n            },\n            additionalProperties: false,\n          },\n          {\n            enum: OPTION_VALUES,\n          },\n        ],\n      },\n    ],\n  },\n\n  create(context) {\n    const HTML_ENTITY_REGEX = () => /&[A-Za-z\\d#]+;/g;\n    const ruleOptions = context.options[0];\n    const userConfig = typeof ruleOptions === 'string'\n      ? { props: ruleOptions, children: ruleOptions, propElementValues: OPTION_IGNORE }\n      : Object.assign({}, DEFAULT_CONFIG, ruleOptions);\n\n    function containsLineTerminators(rawStringValue) {\n      return /[\\n\\r\\u2028\\u2029]/.test(rawStringValue);\n    }\n\n    function containsBackslash(rawStringValue) {\n      return arrayIncludes(rawStringValue, '\\\\');\n    }\n\n    function containsHTMLEntity(rawStringValue) {\n      return HTML_ENTITY_REGEX().test(rawStringValue);\n    }\n\n    function containsOnlyHtmlEntities(rawStringValue) {\n      return rawStringValue.replace(HTML_ENTITY_REGEX(), '').trim() === '';\n    }\n\n    function containsDisallowedJSXTextChars(rawStringValue) {\n      return /[{<>}]/.test(rawStringValue);\n    }\n\n    function containsQuoteCharacters(value) {\n      return /['\"]/.test(value);\n    }\n\n    function containsMultilineComment(value) {\n      return /\\/\\*/.test(value);\n    }\n\n    function escapeDoubleQuotes(rawStringValue) {\n      return rawStringValue.replace(/\\\\\"/g, '\"').replace(/\"/g, '\\\\\"');\n    }\n\n    function escapeBackslashes(rawStringValue) {\n      return rawStringValue.replace(/\\\\/g, '\\\\\\\\');\n    }\n\n    function needToEscapeCharacterForJSX(raw, node) {\n      return (\n        containsBackslash(raw)\n        || containsHTMLEntity(raw)\n        || (node.parent.type !== 'JSXAttribute' && containsDisallowedJSXTextChars(raw))\n      );\n    }\n\n    function containsWhitespaceExpression(child) {\n      if (child.type === 'JSXExpressionContainer') {\n        const value = child.expression.value;\n        return value ? jsxUtil.isWhiteSpaces(value) : false;\n      }\n      return false;\n    }\n\n    function isLineBreak(text) {\n      return containsLineTerminators(text) && text.trim() === '';\n    }\n\n    function wrapNonHTMLEntities(text) {\n      const HTML_ENTITY = '<HTML_ENTITY>';\n      const withCurlyBraces = text.split(HTML_ENTITY_REGEX()).map((word) => (\n        word === '' ? '' : `{${JSON.stringify(word)}}`\n      )).join(HTML_ENTITY);\n\n      const htmlEntities = text.match(HTML_ENTITY_REGEX());\n      return htmlEntities.reduce((acc, htmlEntity) => (\n        acc.replace(HTML_ENTITY, htmlEntity)\n      ), withCurlyBraces);\n    }\n\n    function wrapWithCurlyBraces(rawText) {\n      if (!containsLineTerminators(rawText)) {\n        return `{${JSON.stringify(rawText)}}`;\n      }\n\n      return rawText.split('\\n').map((line) => {\n        if (line.trim() === '') {\n          return line;\n        }\n        const firstCharIndex = line.search(/[^\\s]/);\n        const leftWhitespace = line.slice(0, firstCharIndex);\n        const text = line.slice(firstCharIndex);\n\n        if (containsHTMLEntity(line)) {\n          return `${leftWhitespace}${wrapNonHTMLEntities(text)}`;\n        }\n        return `${leftWhitespace}{${JSON.stringify(text)}}`;\n      }).join('\\n');\n    }\n\n    /**\n     * Report and fix an unnecessary curly brace violation on a node\n     * @param {ASTNode} JSXExpressionNode - The AST node with an unnecessary JSX expression\n     */\n    function reportUnnecessaryCurly(JSXExpressionNode) {\n      report(context, messages.unnecessaryCurly, 'unnecessaryCurly', {\n        node: JSXExpressionNode,\n        fix(fixer) {\n          const expression = JSXExpressionNode.expression;\n\n          let textToReplace;\n          if (jsxUtil.isJSX(expression)) {\n            const sourceCode = context.getSourceCode();\n            textToReplace = sourceCode.getText(expression);\n          } else {\n            const expressionType = expression && expression.type;\n            const parentType = JSXExpressionNode.parent.type;\n\n            if (parentType === 'JSXAttribute') {\n              textToReplace = `\"${expressionType === 'TemplateLiteral'\n                ? expression.quasis[0].value.raw\n                : expression.raw.substring(1, expression.raw.length - 1)\n              }\"`;\n            } else if (jsxUtil.isJSX(expression)) {\n              const sourceCode = context.getSourceCode();\n\n              textToReplace = sourceCode.getText(expression);\n            } else {\n              textToReplace = expressionType === 'TemplateLiteral'\n                ? expression.quasis[0].value.cooked : expression.value;\n            }\n          }\n\n          return fixer.replaceText(JSXExpressionNode, textToReplace);\n        },\n      });\n    }\n\n    function reportMissingCurly(literalNode) {\n      report(context, messages.missingCurly, 'missingCurly', {\n        node: literalNode,\n        fix(fixer) {\n          if (jsxUtil.isJSX(literalNode)) {\n            return fixer.replaceText(literalNode, `{${context.getSourceCode().getText(literalNode)}}`);\n          }\n\n          // If a HTML entity name is found, bail out because it can be fixed\n          // by either using the real character or the unicode equivalent.\n          // If it contains any line terminator character, bail out as well.\n          if (\n            containsOnlyHtmlEntities(literalNode.raw)\n            || (literalNode.parent.type === 'JSXAttribute' && containsLineTerminators(literalNode.raw))\n            || isLineBreak(literalNode.raw)\n          ) {\n            return null;\n          }\n\n          const expression = literalNode.parent.type === 'JSXAttribute'\n            ? `{\"${escapeDoubleQuotes(escapeBackslashes(\n              literalNode.raw.substring(1, literalNode.raw.length - 1)\n            ))}\"}`\n            : wrapWithCurlyBraces(literalNode.raw);\n\n          return fixer.replaceText(literalNode, expression);\n        },\n      });\n    }\n\n    function isWhiteSpaceLiteral(node) {\n      return node.type && node.type === 'Literal' && node.value && jsxUtil.isWhiteSpaces(node.value);\n    }\n\n    function isStringWithTrailingWhiteSpaces(value) {\n      return /^\\s|\\s$/.test(value);\n    }\n\n    function isLiteralWithTrailingWhiteSpaces(node) {\n      return node.type && node.type === 'Literal' && node.value && isStringWithTrailingWhiteSpaces(node.value);\n    }\n\n    // Bail out if there is any character that needs to be escaped in JSX\n    // because escaping decreases readability and the original code may be more\n    // readable anyway or intentional for other specific reasons\n    function lintUnnecessaryCurly(JSXExpressionNode) {\n      const expression = JSXExpressionNode.expression;\n      const expressionType = expression.type;\n\n      const sourceCode = context.getSourceCode();\n      // Curly braces containing comments are necessary\n      if (sourceCode.getCommentsInside && sourceCode.getCommentsInside(JSXExpressionNode).length > 0) {\n        return;\n      }\n\n      if (\n        (expressionType === 'Literal' || expressionType === 'JSXText')\n          && typeof expression.value === 'string'\n          && (\n            (JSXExpressionNode.parent.type === 'JSXAttribute' && !isWhiteSpaceLiteral(expression))\n            || !isLiteralWithTrailingWhiteSpaces(expression)\n          )\n          && !containsMultilineComment(expression.value)\n          && !needToEscapeCharacterForJSX(expression.raw, JSXExpressionNode) && (\n          jsxUtil.isJSX(JSXExpressionNode.parent)\n          || !containsQuoteCharacters(expression.value)\n        )\n      ) {\n        reportUnnecessaryCurly(JSXExpressionNode);\n      } else if (\n        expressionType === 'TemplateLiteral'\n        && expression.expressions.length === 0\n        && expression.quasis[0].value.raw.indexOf('\\n') === -1\n        && !isStringWithTrailingWhiteSpaces(expression.quasis[0].value.raw)\n        && !needToEscapeCharacterForJSX(expression.quasis[0].value.raw, JSXExpressionNode)\n        && !containsQuoteCharacters(expression.quasis[0].value.cooked)\n      ) {\n        reportUnnecessaryCurly(JSXExpressionNode);\n      } else if (jsxUtil.isJSX(expression)) {\n        reportUnnecessaryCurly(JSXExpressionNode);\n      }\n    }\n\n    function areRuleConditionsSatisfied(parent, config, ruleCondition) {\n      return (\n        parent.type === 'JSXAttribute'\n          && typeof config.props === 'string'\n          && config.props === ruleCondition\n      ) || (\n        jsxUtil.isJSX(parent)\n          && typeof config.children === 'string'\n          && config.children === ruleCondition\n      );\n    }\n\n    function getAdjacentSiblings(node, children) {\n      for (let i = 1; i < children.length - 1; i++) {\n        const child = children[i];\n        if (node === child) {\n          return [children[i - 1], children[i + 1]];\n        }\n      }\n      if (node === children[0] && children[1]) {\n        return [children[1]];\n      }\n      if (node === children[children.length - 1] && children[children.length - 2]) {\n        return [children[children.length - 2]];\n      }\n      return [];\n    }\n\n    function hasAdjacentJsxExpressionContainers(node, children) {\n      if (!children) {\n        return false;\n      }\n      const childrenExcludingWhitespaceLiteral = children.filter((child) => !isWhiteSpaceLiteral(child));\n      const adjSiblings = getAdjacentSiblings(node, childrenExcludingWhitespaceLiteral);\n\n      return adjSiblings.some((x) => x.type && x.type === 'JSXExpressionContainer');\n    }\n    function hasAdjacentJsx(node, children) {\n      if (!children) {\n        return false;\n      }\n      const childrenExcludingWhitespaceLiteral = children.filter((child) => !isWhiteSpaceLiteral(child));\n      const adjSiblings = getAdjacentSiblings(node, childrenExcludingWhitespaceLiteral);\n\n      return adjSiblings.some((x) => x.type && arrayIncludes(['JSXExpressionContainer', 'JSXElement'], x.type));\n    }\n    function shouldCheckForUnnecessaryCurly(node, config) {\n      const parent = node.parent;\n      // Bail out if the parent is a JSXAttribute & its contents aren't\n      // StringLiteral or TemplateLiteral since e.g\n      // <App prop1={<CustomEl />} prop2={<CustomEl>...</CustomEl>} />\n\n      if (\n        parent.type && parent.type === 'JSXAttribute'\n        && (node.expression && node.expression.type\n          && node.expression.type !== 'Literal'\n          && node.expression.type !== 'StringLiteral'\n          && node.expression.type !== 'TemplateLiteral')\n      ) {\n        return false;\n      }\n\n      // If there are adjacent `JsxExpressionContainer` then there is no need,\n      // to check for unnecessary curly braces.\n      if (jsxUtil.isJSX(parent) && hasAdjacentJsxExpressionContainers(node, parent.children)) {\n        return false;\n      }\n      if (containsWhitespaceExpression(node) && hasAdjacentJsx(node, parent.children)) {\n        return false;\n      }\n      if (\n        parent.children\n        && parent.children.length === 1\n        && containsWhitespaceExpression(node)\n      ) {\n        return false;\n      }\n\n      return areRuleConditionsSatisfied(parent, config, OPTION_NEVER);\n    }\n\n    function shouldCheckForMissingCurly(node, config) {\n      if (jsxUtil.isJSX(node)) {\n        return config.propElementValues !== OPTION_IGNORE;\n      }\n      if (\n        isLineBreak(node.raw)\n        || containsOnlyHtmlEntities(node.raw)\n      ) {\n        return false;\n      }\n      const parent = node.parent;\n      if (\n        parent.children\n        && parent.children.length === 1\n        && containsWhitespaceExpression(parent.children[0])\n      ) {\n        return false;\n      }\n\n      return areRuleConditionsSatisfied(parent, config, OPTION_ALWAYS);\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      'JSXAttribute > JSXExpressionContainer > JSXElement'(node) {\n        if (userConfig.propElementValues === OPTION_NEVER) {\n          reportUnnecessaryCurly(node.parent);\n        }\n      },\n\n      JSXExpressionContainer(node) {\n        if (shouldCheckForUnnecessaryCurly(node, userConfig)) {\n          lintUnnecessaryCurly(node);\n        }\n      },\n\n      'JSXAttribute > JSXElement, Literal, JSXText'(node) {\n        if (shouldCheckForMissingCurly(node, userConfig)) {\n          reportMissingCurly(node);\n        }\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}