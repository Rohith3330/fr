{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BlockStatement = BlockStatement;\nexports.Directive = Directive;\nexports.DirectiveLiteral = DirectiveLiteral;\nexports.File = File;\nexports.InterpreterDirective = InterpreterDirective;\nexports.Placeholder = Placeholder;\nexports.Program = Program;\n\nfunction File(node) {\n  if (node.program) {\n    this.print(node.program.interpreter, node);\n  }\n\n  this.print(node.program, node);\n}\n\nfunction Program(node) {\n  this.printInnerComments(node, false);\n  this.printSequence(node.directives, node);\n  if (node.directives && node.directives.length) this.newline();\n  this.printSequence(node.body, node);\n}\n\nfunction BlockStatement(node) {\n  var _node$directives;\n\n  this.tokenChar(123);\n  this.printInnerComments(node);\n  const hasDirectives = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;\n\n  if (node.body.length || hasDirectives) {\n    this.newline();\n    this.printSequence(node.directives, node, {\n      indent: true\n    });\n    if (hasDirectives) this.newline();\n    this.printSequence(node.body, node, {\n      indent: true\n    });\n    this.removeTrailingNewline();\n    this.source(\"end\", node.loc);\n    if (!this.endsWith(10)) this.newline();\n    this.rightBrace();\n  } else {\n    this.source(\"end\", node.loc);\n    this.tokenChar(125);\n  }\n}\n\nfunction Directive(node) {\n  this.print(node.value, node);\n  this.semicolon();\n}\n\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\n\nfunction DirectiveLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const {\n    value\n  } = node;\n\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\"Malformed AST: it is not possible to print a directive containing\" + \" both unescaped single and double quotes.\");\n  }\n}\n\nfunction InterpreterDirective(node) {\n  this.token(`#!${node.value}\\n`, true);\n}\n\nfunction Placeholder(node) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}","map":{"version":3,"mappings":"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","names":["File","node","program","print","interpreter","Program","printInnerComments","printSequence","directives","length","newline","body","BlockStatement","token","hasDirectives","_node$directives","indent","removeTrailingNewline","source","loc","endsWith","rightBrace","Directive","value","semicolon","unescapedSingleQuoteRE","unescapedDoubleQuoteRE","DirectiveLiteral","raw","getPossibleRaw","format","minified","undefined","test","Error","InterpreterDirective","Placeholder","name","expectedNode"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\generator\\src\\generators\\base.ts"],"sourcesContent":["import type Printer from \"../printer\";\nimport type * as t from \"@babel/types\";\nimport * as charCodes from \"charcodes\";\n\nexport function File(this: Printer, node: t.File) {\n  if (node.program) {\n    // Print this here to ensure that Program node 'leadingComments' still\n    // get printed after the hashbang.\n    this.print(node.program.interpreter, node);\n  }\n\n  this.print(node.program, node);\n}\n\nexport function Program(this: Printer, node: t.Program) {\n  this.printInnerComments(node, false);\n\n  this.printSequence(node.directives, node);\n  if (node.directives && node.directives.length) this.newline();\n\n  this.printSequence(node.body, node);\n}\n\nexport function BlockStatement(this: Printer, node: t.BlockStatement) {\n  this.token(\"{\");\n  this.printInnerComments(node);\n\n  const hasDirectives = node.directives?.length;\n\n  if (node.body.length || hasDirectives) {\n    this.newline();\n\n    this.printSequence(node.directives, node, { indent: true });\n    if (hasDirectives) this.newline();\n\n    this.printSequence(node.body, node, { indent: true });\n    this.removeTrailingNewline();\n\n    this.source(\"end\", node.loc);\n\n    if (!this.endsWith(charCodes.lineFeed)) this.newline();\n\n    this.rightBrace();\n  } else {\n    this.source(\"end\", node.loc);\n    this.token(\"}\");\n  }\n}\n\nexport function Directive(this: Printer, node: t.Directive) {\n  this.print(node.value, node);\n  this.semicolon();\n}\n\n// These regexes match an even number of \\ followed by a quote\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\n\nexport function DirectiveLiteral(this: Printer, node: t.DirectiveLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const { value } = node;\n\n  // NOTE: In directives we can't change escapings,\n  // because they change the behavior.\n  // e.g. \"us\\x65 string\" (\\x65 is e) is not a \"use strict\" directive.\n\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\n      \"Malformed AST: it is not possible to print a directive containing\" +\n        \" both unescaped single and double quotes.\",\n    );\n  }\n}\n\nexport function InterpreterDirective(\n  this: Printer,\n  node: t.InterpreterDirective,\n) {\n  this.token(`#!${node.value}\\n`, true);\n}\n\nexport function Placeholder(this: Printer, node: t.Placeholder) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}