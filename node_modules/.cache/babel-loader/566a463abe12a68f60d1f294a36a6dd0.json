{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'no-confusing-void-expression',\n  meta: {\n    docs: {\n      description: 'Require expressions of type void to appear in statement position',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    messages: {\n      invalidVoidExpr: 'Placing a void expression inside another expression is forbidden. ' + 'Move it to its own statement instead.',\n      invalidVoidExprWrapVoid: 'Void expressions used inside another expression ' + 'must be moved to its own statement ' + 'or marked explicitly with the `void` operator.',\n      invalidVoidExprArrow: 'Returning a void expression from an arrow function shorthand is forbidden. ' + 'Please add braces to the arrow function.',\n      invalidVoidExprArrowWrapVoid: 'Void expressions returned from an arrow function shorthand ' + 'must be marked explicitly with the `void` operator.',\n      invalidVoidExprReturn: 'Returning a void expression from a function is forbidden. ' + 'Please move it before the `return` statement.',\n      invalidVoidExprReturnLast: 'Returning a void expression from a function is forbidden. ' + 'Please remove the `return` statement.',\n      invalidVoidExprReturnWrapVoid: 'Void expressions returned from a function ' + 'must be marked explicitly with the `void` operator.',\n      voidExprWrapVoid: 'Mark with an explicit `void` operator.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreArrowShorthand: {\n          type: 'boolean'\n        },\n        ignoreVoidOperator: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    type: 'problem',\n    fixable: 'code',\n    hasSuggestions: true\n  },\n  defaultOptions: [{}],\n\n  create(context, _ref) {\n    let [options] = _ref;\n    return {\n      'AwaitExpression, CallExpression, TaggedTemplateExpression'(node) {\n        const parserServices = util.getParserServices(context);\n        const checker = parserServices.program.getTypeChecker();\n        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n        const type = util.getConstrainedTypeAtLocation(checker, tsNode);\n\n        if (!tsutils.isTypeFlagSet(type, ts.TypeFlags.VoidLike)) {\n          // not a void expression\n          return;\n        }\n\n        const invalidAncestor = findInvalidAncestor(node);\n\n        if (invalidAncestor == null) {\n          // void expression is in valid position\n          return;\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        const wrapVoidFix = fixer => {\n          const nodeText = sourceCode.getText(node);\n          const newNodeText = `void ${nodeText}`;\n          return fixer.replaceText(node, newNodeText);\n        };\n\n        if (invalidAncestor.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression) {\n          // handle arrow function shorthand\n          if (options.ignoreVoidOperator) {\n            // handle wrapping with `void`\n            return context.report({\n              node,\n              messageId: 'invalidVoidExprArrowWrapVoid',\n              fix: wrapVoidFix\n            });\n          } // handle wrapping with braces\n\n\n          const arrowFunction = invalidAncestor;\n          return context.report({\n            node,\n            messageId: 'invalidVoidExprArrow',\n\n            fix(fixer) {\n              const arrowBody = arrowFunction.body;\n              const arrowBodyText = sourceCode.getText(arrowBody);\n              const newArrowBodyText = `{ ${arrowBodyText}; }`;\n\n              if (util.isParenthesized(arrowBody, sourceCode)) {\n                const bodyOpeningParen = sourceCode.getTokenBefore(arrowBody, util.isOpeningParenToken);\n                const bodyClosingParen = sourceCode.getTokenAfter(arrowBody, util.isClosingParenToken);\n                return fixer.replaceTextRange([bodyOpeningParen.range[0], bodyClosingParen.range[1]], newArrowBodyText);\n              }\n\n              return fixer.replaceText(arrowBody, newArrowBodyText);\n            }\n\n          });\n        }\n\n        if (invalidAncestor.type === utils_1.AST_NODE_TYPES.ReturnStatement) {\n          // handle return statement\n          if (options.ignoreVoidOperator) {\n            // handle wrapping with `void`\n            return context.report({\n              node,\n              messageId: 'invalidVoidExprReturnWrapVoid',\n              fix: wrapVoidFix\n            });\n          }\n\n          const returnStmt = invalidAncestor;\n\n          if (isFinalReturn(returnStmt)) {\n            // remove the `return` keyword\n            return context.report({\n              node,\n              messageId: 'invalidVoidExprReturnLast',\n\n              fix(fixer) {\n                const returnValue = returnStmt.argument;\n                const returnValueText = sourceCode.getText(returnValue);\n                let newReturnStmtText = `${returnValueText};`;\n\n                if (isPreventingASI(returnValue, sourceCode)) {\n                  // put a semicolon at the beginning of the line\n                  newReturnStmtText = `;${newReturnStmtText}`;\n                }\n\n                return fixer.replaceText(returnStmt, newReturnStmtText);\n              }\n\n            });\n          } // move before the `return` keyword\n\n\n          return context.report({\n            node,\n            messageId: 'invalidVoidExprReturn',\n\n            fix(fixer) {\n              var _a;\n\n              const returnValue = returnStmt.argument;\n              const returnValueText = sourceCode.getText(returnValue);\n              let newReturnStmtText = `${returnValueText}; return;`;\n\n              if (isPreventingASI(returnValue, sourceCode)) {\n                // put a semicolon at the beginning of the line\n                newReturnStmtText = `;${newReturnStmtText}`;\n              }\n\n              if (((_a = returnStmt.parent) === null || _a === void 0 ? void 0 : _a.type) !== utils_1.AST_NODE_TYPES.BlockStatement) {\n                // e.g. `if (cond) return console.error();`\n                // add braces if not inside a block\n                newReturnStmtText = `{ ${newReturnStmtText} }`;\n              }\n\n              return fixer.replaceText(returnStmt, newReturnStmtText);\n            }\n\n          });\n        } // handle generic case\n\n\n        if (options.ignoreVoidOperator) {\n          // this would be reported by this rule btw. such irony\n          return context.report({\n            node,\n            messageId: 'invalidVoidExprWrapVoid',\n            suggest: [{\n              messageId: 'voidExprWrapVoid',\n              fix: wrapVoidFix\n            }]\n          });\n        }\n\n        context.report({\n          node,\n          messageId: 'invalidVoidExpr'\n        });\n      }\n\n    };\n    /**\n     * Inspects the void expression's ancestors and finds closest invalid one.\n     * By default anything other than an ExpressionStatement is invalid.\n     * Parent expressions which can be used for their short-circuiting behavior\n     * are ignored and their parents are checked instead.\n     * @param node The void expression node to check.\n     * @returns Invalid ancestor node if it was found. `null` otherwise.\n     */\n\n    function findInvalidAncestor(node) {\n      const parent = util.nullThrows(node.parent, util.NullThrowsReasons.MissingParent);\n\n      if (parent.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {\n        // e.g. `{ console.log(\"foo\"); }`\n        // this is always valid\n        return null;\n      }\n\n      if (parent.type === utils_1.AST_NODE_TYPES.LogicalExpression) {\n        if (parent.right === node) {\n          // e.g. `x && console.log(x)`\n          // this is valid only if the next ancestor is valid\n          return findInvalidAncestor(parent);\n        }\n      }\n\n      if (parent.type === utils_1.AST_NODE_TYPES.ConditionalExpression) {\n        if (parent.consequent === node || parent.alternate === node) {\n          // e.g. `cond ? console.log(true) : console.log(false)`\n          // this is valid only if the next ancestor is valid\n          return findInvalidAncestor(parent);\n        }\n      }\n\n      if (parent.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression) {\n        // e.g. `() => console.log(\"foo\")`\n        // this is valid with an appropriate option\n        if (options.ignoreArrowShorthand) {\n          return null;\n        }\n      }\n\n      if (parent.type === utils_1.AST_NODE_TYPES.UnaryExpression) {\n        if (parent.operator === 'void') {\n          // e.g. `void console.log(\"foo\")`\n          // this is valid with an appropriate option\n          if (options.ignoreVoidOperator) {\n            return null;\n          }\n        }\n      }\n\n      if (parent.type === utils_1.AST_NODE_TYPES.ChainExpression) {\n        // e.g. `console?.log('foo')`\n        return findInvalidAncestor(parent);\n      } // any other parent is invalid\n\n\n      return parent;\n    }\n    /** Checks whether the return statement is the last statement in a function body. */\n\n\n    function isFinalReturn(node) {\n      // the parent must be a block\n      const block = util.nullThrows(node.parent, util.NullThrowsReasons.MissingParent);\n\n      if (block.type !== utils_1.AST_NODE_TYPES.BlockStatement) {\n        // e.g. `if (cond) return;` (not in a block)\n        return false;\n      } // the block's parent must be a function\n\n\n      const blockParent = util.nullThrows(block.parent, util.NullThrowsReasons.MissingParent);\n\n      if (![utils_1.AST_NODE_TYPES.FunctionDeclaration, utils_1.AST_NODE_TYPES.FunctionExpression, utils_1.AST_NODE_TYPES.ArrowFunctionExpression].includes(blockParent.type)) {\n        // e.g. `if (cond) { return; }`\n        // not in a top-level function block\n        return false;\n      } // must be the last child of the block\n\n\n      if (block.body.indexOf(node) < block.body.length - 1) {\n        // not the last statement in the block\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Checks whether the given node, if placed on its own line,\n     * would prevent automatic semicolon insertion on the line before.\n     *\n     * This happens if the line begins with `(`, `[` or `` ` ``\n     */\n\n\n    function isPreventingASI(node, sourceCode) {\n      const startToken = util.nullThrows(sourceCode.getFirstToken(node), util.NullThrowsReasons.MissingToken('first token', node.type));\n      return ['(', '[', '`'].includes(startToken.value);\n    }\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","docs","description","recommended","requiresTypeChecking","messages","invalidVoidExpr","invalidVoidExprWrapVoid","invalidVoidExprArrow","invalidVoidExprArrowWrapVoid","invalidVoidExprReturn","invalidVoidExprReturnLast","invalidVoidExprReturnWrapVoid","voidExprWrapVoid","schema","type","properties","ignoreArrowShorthand","ignoreVoidOperator","additionalProperties","fixable","hasSuggestions","defaultOptions","create","context","options","node","parserServices","getParserServices","checker","program","getTypeChecker","tsNode","esTreeNodeToTSNodeMap","get","getConstrainedTypeAtLocation","tsutils","isTypeFlagSet","ts","TypeFlags","VoidLike","invalidAncestor","findInvalidAncestor","sourceCode","getSourceCode","wrapVoidFix","fixer","nodeText","getText","newNodeText","replaceText","utils_1","ArrowFunctionExpression","report","messageId","fix","arrowFunction","arrowBody","body","arrowBodyText","newArrowBodyText","isParenthesized","bodyOpeningParen","getTokenBefore","isOpeningParenToken","bodyClosingParen","getTokenAfter","isClosingParenToken","replaceTextRange","range","ReturnStatement","returnStmt","isFinalReturn","returnValue","argument","returnValueText","newReturnStmtText","isPreventingASI","parent","_a","BlockStatement","suggest","nullThrows","NullThrowsReasons","MissingParent","ExpressionStatement","LogicalExpression","right","ConditionalExpression","consequent","alternate","UnaryExpression","operator","ChainExpression","block","blockParent","FunctionDeclaration","FunctionExpression","includes","indexOf","length","startToken","getFirstToken","MissingToken","value"],"sources":["../../src/rules/no-confusing-void-expression.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}