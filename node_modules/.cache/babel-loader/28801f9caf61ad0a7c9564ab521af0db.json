{"ast":null,"code":"/**\n * @fileoverview Limit to one expression per line in JSX\n * @author Mark Ivan Allen <Vydia.com>\n */\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\n\nconst jsxUtil = require('../util/jsx');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst optionDefaults = {\n  allow: 'none'\n};\nconst messages = {\n  moveToNewLine: '`{{descriptor}}` must be placed on a new line'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Require one JSX element per line',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-one-expression-per-line')\n    },\n    fixable: 'whitespace',\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        allow: {\n          enum: ['none', 'literal', 'single-child']\n        }\n      },\n      default: optionDefaults,\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const options = Object.assign({}, optionDefaults, context.options[0]);\n\n    function nodeKey(node) {\n      return `${node.loc.start.line},${node.loc.start.column}`;\n    }\n\n    function nodeDescriptor(n) {\n      return n.openingElement ? n.openingElement.name.name : context.getSourceCode().getText(n).replace(/\\n/g, '');\n    }\n\n    function handleJSX(node) {\n      const children = node.children;\n\n      if (!children || !children.length) {\n        return;\n      }\n\n      const openingElement = node.openingElement || node.openingFragment;\n      const closingElement = node.closingElement || node.closingFragment;\n      const openingElementStartLine = openingElement.loc.start.line;\n      const openingElementEndLine = openingElement.loc.end.line;\n      const closingElementStartLine = closingElement.loc.start.line;\n      const closingElementEndLine = closingElement.loc.end.line;\n\n      if (children.length === 1) {\n        const child = children[0];\n\n        if (openingElementStartLine === openingElementEndLine && openingElementEndLine === closingElementStartLine && closingElementStartLine === closingElementEndLine && closingElementEndLine === child.loc.start.line && child.loc.start.line === child.loc.end.line) {\n          if (options.allow === 'single-child' || options.allow === 'literal' && (child.type === 'Literal' || child.type === 'JSXText')) {\n            return;\n          }\n        }\n      }\n\n      const childrenGroupedByLine = {};\n      const fixDetailsByNode = {};\n      children.forEach(child => {\n        let countNewLinesBeforeContent = 0;\n        let countNewLinesAfterContent = 0;\n\n        if (child.type === 'Literal' || child.type === 'JSXText') {\n          if (jsxUtil.isWhiteSpaces(child.raw)) {\n            return;\n          }\n\n          countNewLinesBeforeContent = (child.raw.match(/^\\s*\\n/g) || []).length;\n          countNewLinesAfterContent = (child.raw.match(/\\n\\s*$/g) || []).length;\n        }\n\n        const startLine = child.loc.start.line + countNewLinesBeforeContent;\n        const endLine = child.loc.end.line - countNewLinesAfterContent;\n\n        if (startLine === endLine) {\n          if (!childrenGroupedByLine[startLine]) {\n            childrenGroupedByLine[startLine] = [];\n          }\n\n          childrenGroupedByLine[startLine].push(child);\n        } else {\n          if (!childrenGroupedByLine[startLine]) {\n            childrenGroupedByLine[startLine] = [];\n          }\n\n          childrenGroupedByLine[startLine].push(child);\n\n          if (!childrenGroupedByLine[endLine]) {\n            childrenGroupedByLine[endLine] = [];\n          }\n\n          childrenGroupedByLine[endLine].push(child);\n        }\n      });\n      Object.keys(childrenGroupedByLine).forEach(_line => {\n        const line = parseInt(_line, 10);\n        const firstIndex = 0;\n        const lastIndex = childrenGroupedByLine[line].length - 1;\n        childrenGroupedByLine[line].forEach((child, i) => {\n          let prevChild;\n          let nextChild;\n\n          if (i === firstIndex) {\n            if (line === openingElementEndLine) {\n              prevChild = openingElement;\n            }\n          } else {\n            prevChild = childrenGroupedByLine[line][i - 1];\n          }\n\n          if (i === lastIndex) {\n            if (line === closingElementStartLine) {\n              nextChild = closingElement;\n            }\n          } else {// We don't need to append a trailing because the next child will prepend a leading.\n            // nextChild = childrenGroupedByLine[line][i + 1];\n          }\n\n          function spaceBetweenPrev() {\n            return (prevChild.type === 'Literal' || prevChild.type === 'JSXText') && / $/.test(prevChild.raw) || (child.type === 'Literal' || child.type === 'JSXText') && /^ /.test(child.raw) || context.getSourceCode().isSpaceBetweenTokens(prevChild, child);\n          }\n\n          function spaceBetweenNext() {\n            return (nextChild.type === 'Literal' || nextChild.type === 'JSXText') && /^ /.test(nextChild.raw) || (child.type === 'Literal' || child.type === 'JSXText') && / $/.test(child.raw) || context.getSourceCode().isSpaceBetweenTokens(child, nextChild);\n          }\n\n          if (!prevChild && !nextChild) {\n            return;\n          }\n\n          const source = context.getSourceCode().getText(child);\n          const leadingSpace = !!(prevChild && spaceBetweenPrev());\n          const trailingSpace = !!(nextChild && spaceBetweenNext());\n          const leadingNewLine = !!prevChild;\n          const trailingNewLine = !!nextChild;\n          const key = nodeKey(child);\n\n          if (!fixDetailsByNode[key]) {\n            fixDetailsByNode[key] = {\n              node: child,\n              source,\n              descriptor: nodeDescriptor(child)\n            };\n          }\n\n          if (leadingSpace) {\n            fixDetailsByNode[key].leadingSpace = true;\n          }\n\n          if (leadingNewLine) {\n            fixDetailsByNode[key].leadingNewLine = true;\n          }\n\n          if (trailingNewLine) {\n            fixDetailsByNode[key].trailingNewLine = true;\n          }\n\n          if (trailingSpace) {\n            fixDetailsByNode[key].trailingSpace = true;\n          }\n        });\n      });\n      Object.keys(fixDetailsByNode).forEach(key => {\n        const details = fixDetailsByNode[key];\n        const nodeToReport = details.node;\n        const descriptor = details.descriptor;\n        const source = details.source.replace(/(^ +| +(?=\\n)*$)/g, '');\n        const leadingSpaceString = details.leadingSpace ? '\\n{\\' \\'}' : '';\n        const trailingSpaceString = details.trailingSpace ? '{\\' \\'}\\n' : '';\n        const leadingNewLineString = details.leadingNewLine ? '\\n' : '';\n        const trailingNewLineString = details.trailingNewLine ? '\\n' : '';\n        const replaceText = `${leadingSpaceString}${leadingNewLineString}${source}${trailingNewLineString}${trailingSpaceString}`;\n        report(context, messages.moveToNewLine, 'moveToNewLine', {\n          node: nodeToReport,\n          data: {\n            descriptor\n          },\n\n          fix(fixer) {\n            return fixer.replaceText(nodeToReport, replaceText);\n          }\n\n        });\n      });\n    }\n\n    return {\n      JSXElement: handleJSX,\n      JSXFragment: handleJSX\n    };\n  }\n\n};","map":{"version":3,"names":["docsUrl","require","jsxUtil","report","optionDefaults","allow","messages","moveToNewLine","module","exports","meta","docs","description","category","recommended","url","fixable","schema","type","properties","enum","default","additionalProperties","create","context","options","Object","assign","nodeKey","node","loc","start","line","column","nodeDescriptor","n","openingElement","name","getSourceCode","getText","replace","handleJSX","children","length","openingFragment","closingElement","closingFragment","openingElementStartLine","openingElementEndLine","end","closingElementStartLine","closingElementEndLine","child","childrenGroupedByLine","fixDetailsByNode","forEach","countNewLinesBeforeContent","countNewLinesAfterContent","isWhiteSpaces","raw","match","startLine","endLine","push","keys","_line","parseInt","firstIndex","lastIndex","i","prevChild","nextChild","spaceBetweenPrev","test","isSpaceBetweenTokens","spaceBetweenNext","source","leadingSpace","trailingSpace","leadingNewLine","trailingNewLine","key","descriptor","details","nodeToReport","leadingSpaceString","trailingSpaceString","leadingNewLineString","trailingNewLineString","replaceText","data","fix","fixer","JSXElement","JSXFragment"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-one-expression-per-line.js"],"sourcesContent":["/**\n * @fileoverview Limit to one expression per line in JSX\n * @author Mark Ivan Allen <Vydia.com>\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst jsxUtil = require('../util/jsx');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst optionDefaults = {\n  allow: 'none',\n};\n\nconst messages = {\n  moveToNewLine: '`{{descriptor}}` must be placed on a new line',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Require one JSX element per line',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-one-expression-per-line'),\n    },\n    fixable: 'whitespace',\n\n    messages,\n\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          allow: {\n            enum: ['none', 'literal', 'single-child'],\n          },\n        },\n        default: optionDefaults,\n        additionalProperties: false,\n      },\n    ],\n  },\n\n  create(context) {\n    const options = Object.assign({}, optionDefaults, context.options[0]);\n\n    function nodeKey(node) {\n      return `${node.loc.start.line},${node.loc.start.column}`;\n    }\n\n    function nodeDescriptor(n) {\n      return n.openingElement ? n.openingElement.name.name : context.getSourceCode().getText(n).replace(/\\n/g, '');\n    }\n\n    function handleJSX(node) {\n      const children = node.children;\n\n      if (!children || !children.length) {\n        return;\n      }\n\n      const openingElement = node.openingElement || node.openingFragment;\n      const closingElement = node.closingElement || node.closingFragment;\n      const openingElementStartLine = openingElement.loc.start.line;\n      const openingElementEndLine = openingElement.loc.end.line;\n      const closingElementStartLine = closingElement.loc.start.line;\n      const closingElementEndLine = closingElement.loc.end.line;\n\n      if (children.length === 1) {\n        const child = children[0];\n        if (\n          openingElementStartLine === openingElementEndLine\n          && openingElementEndLine === closingElementStartLine\n          && closingElementStartLine === closingElementEndLine\n          && closingElementEndLine === child.loc.start.line\n          && child.loc.start.line === child.loc.end.line\n        ) {\n          if (\n            options.allow === 'single-child'\n            || (options.allow === 'literal' && (child.type === 'Literal' || child.type === 'JSXText'))\n          ) {\n            return;\n          }\n        }\n      }\n\n      const childrenGroupedByLine = {};\n      const fixDetailsByNode = {};\n\n      children.forEach((child) => {\n        let countNewLinesBeforeContent = 0;\n        let countNewLinesAfterContent = 0;\n\n        if (child.type === 'Literal' || child.type === 'JSXText') {\n          if (jsxUtil.isWhiteSpaces(child.raw)) {\n            return;\n          }\n\n          countNewLinesBeforeContent = (child.raw.match(/^\\s*\\n/g) || []).length;\n          countNewLinesAfterContent = (child.raw.match(/\\n\\s*$/g) || []).length;\n        }\n\n        const startLine = child.loc.start.line + countNewLinesBeforeContent;\n        const endLine = child.loc.end.line - countNewLinesAfterContent;\n\n        if (startLine === endLine) {\n          if (!childrenGroupedByLine[startLine]) {\n            childrenGroupedByLine[startLine] = [];\n          }\n          childrenGroupedByLine[startLine].push(child);\n        } else {\n          if (!childrenGroupedByLine[startLine]) {\n            childrenGroupedByLine[startLine] = [];\n          }\n          childrenGroupedByLine[startLine].push(child);\n          if (!childrenGroupedByLine[endLine]) {\n            childrenGroupedByLine[endLine] = [];\n          }\n          childrenGroupedByLine[endLine].push(child);\n        }\n      });\n\n      Object.keys(childrenGroupedByLine).forEach((_line) => {\n        const line = parseInt(_line, 10);\n        const firstIndex = 0;\n        const lastIndex = childrenGroupedByLine[line].length - 1;\n\n        childrenGroupedByLine[line].forEach((child, i) => {\n          let prevChild;\n          let nextChild;\n\n          if (i === firstIndex) {\n            if (line === openingElementEndLine) {\n              prevChild = openingElement;\n            }\n          } else {\n            prevChild = childrenGroupedByLine[line][i - 1];\n          }\n\n          if (i === lastIndex) {\n            if (line === closingElementStartLine) {\n              nextChild = closingElement;\n            }\n          } else {\n            // We don't need to append a trailing because the next child will prepend a leading.\n            // nextChild = childrenGroupedByLine[line][i + 1];\n          }\n\n          function spaceBetweenPrev() {\n            return ((prevChild.type === 'Literal' || prevChild.type === 'JSXText') && / $/.test(prevChild.raw))\n              || ((child.type === 'Literal' || child.type === 'JSXText') && /^ /.test(child.raw))\n              || context.getSourceCode().isSpaceBetweenTokens(prevChild, child);\n          }\n\n          function spaceBetweenNext() {\n            return ((nextChild.type === 'Literal' || nextChild.type === 'JSXText') && /^ /.test(nextChild.raw))\n              || ((child.type === 'Literal' || child.type === 'JSXText') && / $/.test(child.raw))\n              || context.getSourceCode().isSpaceBetweenTokens(child, nextChild);\n          }\n\n          if (!prevChild && !nextChild) {\n            return;\n          }\n\n          const source = context.getSourceCode().getText(child);\n          const leadingSpace = !!(prevChild && spaceBetweenPrev());\n          const trailingSpace = !!(nextChild && spaceBetweenNext());\n          const leadingNewLine = !!prevChild;\n          const trailingNewLine = !!nextChild;\n\n          const key = nodeKey(child);\n\n          if (!fixDetailsByNode[key]) {\n            fixDetailsByNode[key] = {\n              node: child,\n              source,\n              descriptor: nodeDescriptor(child),\n            };\n          }\n\n          if (leadingSpace) {\n            fixDetailsByNode[key].leadingSpace = true;\n          }\n          if (leadingNewLine) {\n            fixDetailsByNode[key].leadingNewLine = true;\n          }\n          if (trailingNewLine) {\n            fixDetailsByNode[key].trailingNewLine = true;\n          }\n          if (trailingSpace) {\n            fixDetailsByNode[key].trailingSpace = true;\n          }\n        });\n      });\n\n      Object.keys(fixDetailsByNode).forEach((key) => {\n        const details = fixDetailsByNode[key];\n\n        const nodeToReport = details.node;\n        const descriptor = details.descriptor;\n        const source = details.source.replace(/(^ +| +(?=\\n)*$)/g, '');\n\n        const leadingSpaceString = details.leadingSpace ? '\\n{\\' \\'}' : '';\n        const trailingSpaceString = details.trailingSpace ? '{\\' \\'}\\n' : '';\n        const leadingNewLineString = details.leadingNewLine ? '\\n' : '';\n        const trailingNewLineString = details.trailingNewLine ? '\\n' : '';\n\n        const replaceText = `${leadingSpaceString}${leadingNewLineString}${source}${trailingNewLineString}${trailingSpaceString}`;\n\n        report(context, messages.moveToNewLine, 'moveToNewLine', {\n          node: nodeToReport,\n          data: {\n            descriptor,\n          },\n          fix(fixer) {\n            return fixer.replaceText(nodeToReport, replaceText);\n          },\n        });\n      });\n    }\n\n    return {\n      JSXElement: handleJSX,\n      JSXFragment: handleJSX,\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}