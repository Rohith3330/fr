{"ast":null,"code":"var walk = require('css-tree').walk;\n\nvar utils = require('./utils');\n/*\n    At this step all rules has single simple selector. We try to join by equal\n    declaration blocks to first rule, e.g.\n\n    .a { color: red }\n    b { ... }\n    .b { color: red }\n    ->\n    .a, .b { color: red }\n    b { ... }\n*/\n\n\nfunction processRule(node, item, list) {\n  var selectors = node.prelude.children;\n  var declarations = node.block.children;\n  var nodeCompareMarker = selectors.first().compareMarker;\n  var skippedCompareMarkers = {};\n  list.nextUntil(item.next, function (next, nextItem) {\n    // skip non-ruleset node if safe\n    if (next.type !== 'Rule') {\n      return utils.unsafeToSkipNode.call(selectors, next);\n    }\n\n    if (node.pseudoSignature !== next.pseudoSignature) {\n      return true;\n    }\n\n    var nextFirstSelector = next.prelude.children.head;\n    var nextDeclarations = next.block.children;\n    var nextCompareMarker = nextFirstSelector.data.compareMarker; // if next ruleset has same marked as one of skipped then stop joining\n\n    if (nextCompareMarker in skippedCompareMarkers) {\n      return true;\n    } // try to join by selectors\n\n\n    if (selectors.head === selectors.tail) {\n      if (selectors.first().id === nextFirstSelector.data.id) {\n        declarations.appendList(nextDeclarations);\n        list.remove(nextItem);\n        return;\n      }\n    } // try to join by properties\n\n\n    if (utils.isEqualDeclarations(declarations, nextDeclarations)) {\n      var nextStr = nextFirstSelector.data.id;\n      selectors.some(function (data, item) {\n        var curStr = data.id;\n\n        if (nextStr < curStr) {\n          selectors.insert(nextFirstSelector, item);\n          return true;\n        }\n\n        if (!item.next) {\n          selectors.insert(nextFirstSelector);\n          return true;\n        }\n      });\n      list.remove(nextItem);\n      return;\n    } // go to next ruleset if current one can be skipped (has no equal specificity nor element selector)\n\n\n    if (nextCompareMarker === nodeCompareMarker) {\n      return true;\n    }\n\n    skippedCompareMarkers[nextCompareMarker] = true;\n  });\n}\n\nmodule.exports = function mergeRule(ast) {\n  walk(ast, {\n    visit: 'Rule',\n    enter: processRule\n  });\n};","map":{"version":3,"names":["walk","require","utils","processRule","node","item","list","selectors","prelude","children","declarations","block","nodeCompareMarker","first","compareMarker","skippedCompareMarkers","nextUntil","next","nextItem","type","unsafeToSkipNode","call","pseudoSignature","nextFirstSelector","head","nextDeclarations","nextCompareMarker","data","tail","id","appendList","remove","isEqualDeclarations","nextStr","some","curStr","insert","module","exports","mergeRule","ast","visit","enter"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/csso/lib/restructure/7-mergeRuleset.js"],"sourcesContent":["var walk = require('css-tree').walk;\nvar utils = require('./utils');\n\n/*\n    At this step all rules has single simple selector. We try to join by equal\n    declaration blocks to first rule, e.g.\n\n    .a { color: red }\n    b { ... }\n    .b { color: red }\n    ->\n    .a, .b { color: red }\n    b { ... }\n*/\n\nfunction processRule(node, item, list) {\n    var selectors = node.prelude.children;\n    var declarations = node.block.children;\n    var nodeCompareMarker = selectors.first().compareMarker;\n    var skippedCompareMarkers = {};\n\n    list.nextUntil(item.next, function(next, nextItem) {\n        // skip non-ruleset node if safe\n        if (next.type !== 'Rule') {\n            return utils.unsafeToSkipNode.call(selectors, next);\n        }\n\n        if (node.pseudoSignature !== next.pseudoSignature) {\n            return true;\n        }\n\n        var nextFirstSelector = next.prelude.children.head;\n        var nextDeclarations = next.block.children;\n        var nextCompareMarker = nextFirstSelector.data.compareMarker;\n\n        // if next ruleset has same marked as one of skipped then stop joining\n        if (nextCompareMarker in skippedCompareMarkers) {\n            return true;\n        }\n\n        // try to join by selectors\n        if (selectors.head === selectors.tail) {\n            if (selectors.first().id === nextFirstSelector.data.id) {\n                declarations.appendList(nextDeclarations);\n                list.remove(nextItem);\n                return;\n            }\n        }\n\n        // try to join by properties\n        if (utils.isEqualDeclarations(declarations, nextDeclarations)) {\n            var nextStr = nextFirstSelector.data.id;\n\n            selectors.some(function(data, item) {\n                var curStr = data.id;\n\n                if (nextStr < curStr) {\n                    selectors.insert(nextFirstSelector, item);\n                    return true;\n                }\n\n                if (!item.next) {\n                    selectors.insert(nextFirstSelector);\n                    return true;\n                }\n            });\n\n            list.remove(nextItem);\n            return;\n        }\n\n        // go to next ruleset if current one can be skipped (has no equal specificity nor element selector)\n        if (nextCompareMarker === nodeCompareMarker) {\n            return true;\n        }\n\n        skippedCompareMarkers[nextCompareMarker] = true;\n    });\n}\n\nmodule.exports = function mergeRule(ast) {\n    walk(ast, {\n        visit: 'Rule',\n        enter: processRule\n    });\n};\n"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,UAAD,CAAP,CAAoBD,IAA/B;;AACA,IAAIE,KAAK,GAAGD,OAAO,CAAC,SAAD,CAAnB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASE,WAAT,CAAqBC,IAArB,EAA2BC,IAA3B,EAAiCC,IAAjC,EAAuC;EACnC,IAAIC,SAAS,GAAGH,IAAI,CAACI,OAAL,CAAaC,QAA7B;EACA,IAAIC,YAAY,GAAGN,IAAI,CAACO,KAAL,CAAWF,QAA9B;EACA,IAAIG,iBAAiB,GAAGL,SAAS,CAACM,KAAV,GAAkBC,aAA1C;EACA,IAAIC,qBAAqB,GAAG,EAA5B;EAEAT,IAAI,CAACU,SAAL,CAAeX,IAAI,CAACY,IAApB,EAA0B,UAASA,IAAT,EAAeC,QAAf,EAAyB;IAC/C;IACA,IAAID,IAAI,CAACE,IAAL,KAAc,MAAlB,EAA0B;MACtB,OAAOjB,KAAK,CAACkB,gBAAN,CAAuBC,IAAvB,CAA4Bd,SAA5B,EAAuCU,IAAvC,CAAP;IACH;;IAED,IAAIb,IAAI,CAACkB,eAAL,KAAyBL,IAAI,CAACK,eAAlC,EAAmD;MAC/C,OAAO,IAAP;IACH;;IAED,IAAIC,iBAAiB,GAAGN,IAAI,CAACT,OAAL,CAAaC,QAAb,CAAsBe,IAA9C;IACA,IAAIC,gBAAgB,GAAGR,IAAI,CAACN,KAAL,CAAWF,QAAlC;IACA,IAAIiB,iBAAiB,GAAGH,iBAAiB,CAACI,IAAlB,CAAuBb,aAA/C,CAZ+C,CAc/C;;IACA,IAAIY,iBAAiB,IAAIX,qBAAzB,EAAgD;MAC5C,OAAO,IAAP;IACH,CAjB8C,CAmB/C;;;IACA,IAAIR,SAAS,CAACiB,IAAV,KAAmBjB,SAAS,CAACqB,IAAjC,EAAuC;MACnC,IAAIrB,SAAS,CAACM,KAAV,GAAkBgB,EAAlB,KAAyBN,iBAAiB,CAACI,IAAlB,CAAuBE,EAApD,EAAwD;QACpDnB,YAAY,CAACoB,UAAb,CAAwBL,gBAAxB;QACAnB,IAAI,CAACyB,MAAL,CAAYb,QAAZ;QACA;MACH;IACJ,CA1B8C,CA4B/C;;;IACA,IAAIhB,KAAK,CAAC8B,mBAAN,CAA0BtB,YAA1B,EAAwCe,gBAAxC,CAAJ,EAA+D;MAC3D,IAAIQ,OAAO,GAAGV,iBAAiB,CAACI,IAAlB,CAAuBE,EAArC;MAEAtB,SAAS,CAAC2B,IAAV,CAAe,UAASP,IAAT,EAAetB,IAAf,EAAqB;QAChC,IAAI8B,MAAM,GAAGR,IAAI,CAACE,EAAlB;;QAEA,IAAII,OAAO,GAAGE,MAAd,EAAsB;UAClB5B,SAAS,CAAC6B,MAAV,CAAiBb,iBAAjB,EAAoClB,IAApC;UACA,OAAO,IAAP;QACH;;QAED,IAAI,CAACA,IAAI,CAACY,IAAV,EAAgB;UACZV,SAAS,CAAC6B,MAAV,CAAiBb,iBAAjB;UACA,OAAO,IAAP;QACH;MACJ,CAZD;MAcAjB,IAAI,CAACyB,MAAL,CAAYb,QAAZ;MACA;IACH,CAhD8C,CAkD/C;;;IACA,IAAIQ,iBAAiB,KAAKd,iBAA1B,EAA6C;MACzC,OAAO,IAAP;IACH;;IAEDG,qBAAqB,CAACW,iBAAD,CAArB,GAA2C,IAA3C;EACH,CAxDD;AAyDH;;AAEDW,MAAM,CAACC,OAAP,GAAiB,SAASC,SAAT,CAAmBC,GAAnB,EAAwB;EACrCxC,IAAI,CAACwC,GAAD,EAAM;IACNC,KAAK,EAAE,MADD;IAENC,KAAK,EAAEvC;EAFD,CAAN,CAAJ;AAIH,CALD"},"metadata":{},"sourceType":"script"}