{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst names_1 = require(\"../../compile/names\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: \"must NOT have additional properties\",\n  params: _ref => {\n    let {\n      params\n    } = _ref;\n    return (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`;\n  }\n};\nconst def = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      errsCount,\n      it\n    } = cxt;\n    /* istanbul ignore if */\n\n    if (!errsCount) throw new Error(\"ajv implementation error\");\n    const {\n      allErrors,\n      opts\n    } = it;\n    it.props = true;\n    if (opts.removeAdditional !== \"all\" && (0, util_1.alwaysValidSchema)(it, schema)) return;\n    const props = (0, code_1.allSchemaProperties)(parentSchema.properties);\n    const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);\n    checkAdditionalProperties();\n    cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);\n\n    function checkAdditionalProperties() {\n      gen.forIn(\"key\", data, key => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key);else gen.if(isAdditional(key), () => additionalPropertyCode(key));\n      });\n    }\n\n    function isAdditional(key) {\n      let definedProp;\n\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, \"properties\");\n        definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);\n      } else if (props.length) {\n        definedProp = (0, codegen_1.or)(...props.map(p => (0, codegen_1._)`${key} === ${p}`));\n      } else {\n        definedProp = codegen_1.nil;\n      }\n\n      if (patProps.length) {\n        definedProp = (0, codegen_1.or)(definedProp, ...patProps.map(p => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));\n      }\n\n      return (0, codegen_1.not)(definedProp);\n    }\n\n    function deleteAdditional(key) {\n      gen.code((0, codegen_1._)`delete ${data}[${key}]`);\n    }\n\n    function additionalPropertyCode(key) {\n      if (opts.removeAdditional === \"all\" || opts.removeAdditional && schema === false) {\n        deleteAdditional(key);\n        return;\n      }\n\n      if (schema === false) {\n        cxt.setParams({\n          additionalProperty: key\n        });\n        cxt.error();\n        if (!allErrors) gen.break();\n        return;\n      }\n\n      if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n        const valid = gen.name(\"valid\");\n\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false);\n          gen.if((0, codegen_1.not)(valid), () => {\n            cxt.reset();\n            deleteAdditional(key);\n          });\n        } else {\n          applyAdditionalSchema(key, valid);\n          if (!allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key, valid, errors) {\n      const subschema = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: util_1.Type.Str\n      };\n\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false\n        });\n      }\n\n      cxt.subschema(subschema, valid);\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","additionalProperty","def","keyword","type","schemaType","allowUndefined","trackErrors","code","cxt","gen","schema","parentSchema","data","errsCount","it","Error","allErrors","opts","props","removeAdditional","properties","patProps","patternProperties","checkAdditionalProperties","ok","names_1","errors","forIn","key","length","additionalPropertyCode","if","isAdditional","definedProp","propsSchema","map","p","codegen_1","deleteAdditional","setParams","break","valid","name","applyAdditionalSchema","reset","subschema","dataProp","dataPropType","util_1","Str","Object","assign","compositeRule","createErrors","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\vocabularies\\applicator\\additionalProperties.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}