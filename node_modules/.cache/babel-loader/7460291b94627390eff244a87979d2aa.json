{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'typedef',\n  meta: {\n    docs: {\n      description: 'Require type annotations in certain places',\n      recommended: false\n    },\n    messages: {\n      expectedTypedef: 'Expected a type annotation.',\n      expectedTypedefNamed: 'Expected {{name}} to have a type annotation.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        [\"arrayDestructuring\"\n        /* OptionKeys.ArrayDestructuring */\n        ]: {\n          type: 'boolean'\n        },\n        [\"arrowParameter\"\n        /* OptionKeys.ArrowParameter */\n        ]: {\n          type: 'boolean'\n        },\n        [\"memberVariableDeclaration\"\n        /* OptionKeys.MemberVariableDeclaration */\n        ]: {\n          type: 'boolean'\n        },\n        [\"objectDestructuring\"\n        /* OptionKeys.ObjectDestructuring */\n        ]: {\n          type: 'boolean'\n        },\n        [\"parameter\"\n        /* OptionKeys.Parameter */\n        ]: {\n          type: 'boolean'\n        },\n        [\"propertyDeclaration\"\n        /* OptionKeys.PropertyDeclaration */\n        ]: {\n          type: 'boolean'\n        },\n        [\"variableDeclaration\"\n        /* OptionKeys.VariableDeclaration */\n        ]: {\n          type: 'boolean'\n        },\n        [\"variableDeclarationIgnoreFunction\"\n        /* OptionKeys.VariableDeclarationIgnoreFunction */\n        ]: {\n          type: 'boolean'\n        }\n      }\n    }],\n    type: 'suggestion'\n  },\n  defaultOptions: [{\n    [\"arrayDestructuring\"\n    /* OptionKeys.ArrayDestructuring */\n    ]: false,\n    [\"arrowParameter\"\n    /* OptionKeys.ArrowParameter */\n    ]: false,\n    [\"memberVariableDeclaration\"\n    /* OptionKeys.MemberVariableDeclaration */\n    ]: false,\n    [\"objectDestructuring\"\n    /* OptionKeys.ObjectDestructuring */\n    ]: false,\n    [\"parameter\"\n    /* OptionKeys.Parameter */\n    ]: false,\n    [\"propertyDeclaration\"\n    /* OptionKeys.PropertyDeclaration */\n    ]: false,\n    [\"variableDeclaration\"\n    /* OptionKeys.VariableDeclaration */\n    ]: false,\n    [\"variableDeclarationIgnoreFunction\"\n    /* OptionKeys.VariableDeclarationIgnoreFunction */\n    ]: false\n  }],\n\n  create(context, _ref) {\n    let [{\n      arrayDestructuring,\n      arrowParameter,\n      memberVariableDeclaration,\n      objectDestructuring,\n      parameter,\n      propertyDeclaration,\n      variableDeclaration,\n      variableDeclarationIgnoreFunction\n    }] = _ref;\n\n    function report(location, name) {\n      context.report({\n        node: location,\n        messageId: name ? 'expectedTypedefNamed' : 'expectedTypedef',\n        data: {\n          name\n        }\n      });\n    }\n\n    function getNodeName(node) {\n      return node.type === utils_1.AST_NODE_TYPES.Identifier ? node.name : undefined;\n    }\n\n    function isForOfStatementContext(node) {\n      let current = node.parent;\n\n      while (current) {\n        switch (current.type) {\n          case utils_1.AST_NODE_TYPES.VariableDeclarator:\n          case utils_1.AST_NODE_TYPES.VariableDeclaration:\n          case utils_1.AST_NODE_TYPES.ObjectPattern:\n          case utils_1.AST_NODE_TYPES.ArrayPattern:\n          case utils_1.AST_NODE_TYPES.Property:\n            current = current.parent;\n            break;\n\n          case utils_1.AST_NODE_TYPES.ForOfStatement:\n            return true;\n\n          default:\n            current = undefined;\n        }\n      }\n\n      return false;\n    }\n\n    function checkParameters(params) {\n      for (const param of params) {\n        let annotationNode;\n\n        switch (param.type) {\n          case utils_1.AST_NODE_TYPES.AssignmentPattern:\n            annotationNode = param.left;\n            break;\n\n          case utils_1.AST_NODE_TYPES.TSParameterProperty:\n            annotationNode = param.parameter; // Check TS parameter property with default value like `constructor(private param: string = 'something') {}`\n\n            if (annotationNode && annotationNode.type === utils_1.AST_NODE_TYPES.AssignmentPattern) {\n              annotationNode = annotationNode.left;\n            }\n\n            break;\n\n          default:\n            annotationNode = param;\n            break;\n        }\n\n        if (annotationNode !== undefined && !annotationNode.typeAnnotation) {\n          report(param, getNodeName(param));\n        }\n      }\n    }\n\n    function isVariableDeclarationIgnoreFunction(node) {\n      return variableDeclarationIgnoreFunction === true && (node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression || node.type === utils_1.AST_NODE_TYPES.FunctionExpression);\n    }\n\n    function isAncestorHasTypeAnnotation(node) {\n      let ancestor = node.parent;\n\n      while (ancestor) {\n        if ((ancestor.type === utils_1.AST_NODE_TYPES.ObjectPattern || ancestor.type === utils_1.AST_NODE_TYPES.ArrayPattern) && ancestor.typeAnnotation) {\n          return true;\n        }\n\n        ancestor = ancestor.parent;\n      }\n\n      return false;\n    }\n\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, arrayDestructuring && {\n      ArrayPattern(node) {\n        var _a, _b;\n\n        if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.RestElement && node.parent.typeAnnotation) {\n          return;\n        }\n\n        if (!node.typeAnnotation && !isForOfStatementContext(node) && !isAncestorHasTypeAnnotation(node) && ((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type) !== utils_1.AST_NODE_TYPES.AssignmentExpression) {\n          report(node);\n        }\n      }\n\n    }), arrowParameter && {\n      ArrowFunctionExpression(node) {\n        checkParameters(node.params);\n      }\n\n    }), memberVariableDeclaration && {\n      PropertyDefinition(node) {\n        if (!(node.value && isVariableDeclarationIgnoreFunction(node.value)) && !node.typeAnnotation) {\n          report(node, node.key.type === utils_1.AST_NODE_TYPES.Identifier ? node.key.name : undefined);\n        }\n      }\n\n    }), parameter && {\n      'FunctionDeclaration, FunctionExpression'(node) {\n        checkParameters(node.params);\n      }\n\n    }), objectDestructuring && {\n      ObjectPattern(node) {\n        if (!node.typeAnnotation && !isForOfStatementContext(node) && !isAncestorHasTypeAnnotation(node)) {\n          report(node);\n        }\n      }\n\n    }), propertyDeclaration && {\n      'TSIndexSignature, TSPropertySignature'(node) {\n        if (!node.typeAnnotation) {\n          report(node, node.type === utils_1.AST_NODE_TYPES.TSPropertySignature ? getNodeName(node.key) : undefined);\n        }\n      }\n\n    }), {\n      VariableDeclarator(node) {\n        if (!variableDeclaration || node.id.typeAnnotation || node.id.type === utils_1.AST_NODE_TYPES.ArrayPattern && !arrayDestructuring || node.id.type === utils_1.AST_NODE_TYPES.ObjectPattern && !objectDestructuring || node.init && isVariableDeclarationIgnoreFunction(node.init)) {\n          return;\n        }\n\n        let current = node.parent;\n\n        while (current) {\n          switch (current.type) {\n            case utils_1.AST_NODE_TYPES.VariableDeclaration:\n              // Keep looking upwards\n              current = current.parent;\n              break;\n\n            case utils_1.AST_NODE_TYPES.ForOfStatement:\n            case utils_1.AST_NODE_TYPES.ForInStatement:\n              // Stop traversing and don't report an error\n              return;\n\n            default:\n              // Stop traversing\n              current = undefined;\n              break;\n          }\n        }\n\n        report(node, getNodeName(node.id));\n      }\n\n    });\n  }\n\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AAEA;;AAiBAA,kBAAeC,IAAI,CAACC,UAAL,CAAuC;EACpDC,IAAI,EAAE,SAD8C;EAEpDC,IAAI,EAAE;IACJC,IAAI,EAAE;MACJC,WAAW,EAAE,4CADT;MAEJC,WAAW,EAAE;IAFT,CADF;IAKJC,QAAQ,EAAE;MACRC,eAAe,EAAE,6BADT;MAERC,oBAAoB,EAAE;IAFd,CALN;IASJC,MAAM,EAAE,CACN;MACEC,IAAI,EAAE,QADR;MAEEC,UAAU,EAAE;QACV;QAAA;QAAA,GAAiC;UAAED,IAAI,EAAE;QAAR,CADvB;QAEV;QAAA;QAAA,GAA6B;UAAEA,IAAI,EAAE;QAAR,CAFnB;QAGV;QAAA;QAAA,GAAwC;UAAEA,IAAI,EAAE;QAAR,CAH9B;QAIV;QAAA;QAAA,GAAkC;UAAEA,IAAI,EAAE;QAAR,CAJxB;QAKV;QAAA;QAAA,GAAwB;UAAEA,IAAI,EAAE;QAAR,CALd;QAMV;QAAA;QAAA,GAAkC;UAAEA,IAAI,EAAE;QAAR,CANxB;QAOV;QAAA;QAAA,GAAkC;UAAEA,IAAI,EAAE;QAAR,CAPxB;QAQV;QAAA;QAAA,GAAgD;UAAEA,IAAI,EAAE;QAAR;MARtC;IAFd,CADM,CATJ;IAwBJA,IAAI,EAAE;EAxBF,CAF8C;EA4BpDE,cAAc,EAAE,CACd;IACE;IAAA;IAAA,GAAiC,KADnC;IAEE;IAAA;IAAA,GAA6B,KAF/B;IAGE;IAAA;IAAA,GAAwC,KAH1C;IAIE;IAAA;IAAA,GAAkC,KAJpC;IAKE;IAAA;IAAA,GAAwB,KAL1B;IAME;IAAA;IAAA,GAAkC,KANpC;IAOE;IAAA;IAAA,GAAkC,KAPpC;IAQE;IAAA;IAAA,GAAgD;EARlD,CADc,CA5BoC;;EAwCpDC,MAAM,CACJC,OADI,QAaH;IAAA,IAXD,CACE;MACEC,kBADF;MAEEC,cAFF;MAGEC,yBAHF;MAIEC,mBAJF;MAKEC,SALF;MAMEC,mBANF;MAOEC,mBAPF;MAQEC;IARF,CADF,CAWC;;IAED,SAASC,MAAT,CAAgBC,QAAhB,EAAyCvB,IAAzC,EAAsD;MACpDa,OAAO,CAACS,MAAR,CAAe;QACbE,IAAI,EAAED,QADO;QAEbE,SAAS,EAAEzB,IAAI,GAAG,sBAAH,GAA4B,iBAF9B;QAGb0B,IAAI,EAAE;UAAE1B;QAAF;MAHO,CAAf;IAKD;;IAED,SAAS2B,WAAT,CACEH,IADF,EACkD;MAEhD,OAAOA,IAAI,CAACf,IAAL,KAAcmB,uBAAeC,UAA7B,GAA0CL,IAAI,CAACxB,IAA/C,GAAsD8B,SAA7D;IACD;;IAED,SAASC,uBAAT,CACEP,IADF,EACsD;MAEpD,IAAIQ,OAAO,GAA8BR,IAAI,CAACS,MAA9C;;MACA,OAAOD,OAAP,EAAgB;QACd,QAAQA,OAAO,CAACvB,IAAhB;UACE,KAAKmB,uBAAeM,kBAApB;UACA,KAAKN,uBAAeO,mBAApB;UACA,KAAKP,uBAAeQ,aAApB;UACA,KAAKR,uBAAeS,YAApB;UACA,KAAKT,uBAAeU,QAApB;YACEN,OAAO,GAAGA,OAAO,CAACC,MAAlB;YACA;;UAEF,KAAKL,uBAAeW,cAApB;YACE,OAAO,IAAP;;UAEF;YACEP,OAAO,GAAGF,SAAV;QAbJ;MAeD;;MAED,OAAO,KAAP;IACD;;IAED,SAASU,eAAT,CAAyBC,MAAzB,EAAqD;MACnD,KAAK,MAAMC,KAAX,IAAoBD,MAApB,EAA4B;QAC1B,IAAIE,cAAJ;;QAEA,QAAQD,KAAK,CAACjC,IAAd;UACE,KAAKmB,uBAAegB,iBAApB;YACED,cAAc,GAAGD,KAAK,CAACG,IAAvB;YACA;;UACF,KAAKjB,uBAAekB,mBAApB;YACEH,cAAc,GAAGD,KAAK,CAACxB,SAAvB,CADF,CAGE;;YACA,IACEyB,cAAc,IACdA,cAAc,CAAClC,IAAf,KAAwBmB,uBAAegB,iBAFzC,EAGE;cACAD,cAAc,GAAGA,cAAc,CAACE,IAAhC;YACD;;YAED;;UACF;YACEF,cAAc,GAAGD,KAAjB;YACA;QAlBJ;;QAqBA,IAAIC,cAAc,KAAKb,SAAnB,IAAgC,CAACa,cAAc,CAACI,cAApD,EAAoE;UAClEzB,MAAM,CAACoB,KAAD,EAAQf,WAAW,CAACe,KAAD,CAAnB,CAAN;QACD;MACF;IACF;;IAED,SAASM,mCAAT,CAA6CxB,IAA7C,EAAgE;MAC9D,OACEH,iCAAiC,KAAK,IAAtC,KACCG,IAAI,CAACf,IAAL,KAAcmB,uBAAeqB,uBAA7B,IACCzB,IAAI,CAACf,IAAL,KAAcmB,uBAAesB,kBAF/B,CADF;IAKD;;IAED,SAASC,2BAAT,CACE3B,IADF,EACsD;MAEpD,IAAI4B,QAAQ,GAAG5B,IAAI,CAACS,MAApB;;MAEA,OAAOmB,QAAP,EAAiB;QACf,IACE,CAACA,QAAQ,CAAC3C,IAAT,KAAkBmB,uBAAeQ,aAAjC,IACCgB,QAAQ,CAAC3C,IAAT,KAAkBmB,uBAAeS,YADnC,KAEAe,QAAQ,CAACL,cAHX,EAIE;UACA,OAAO,IAAP;QACD;;QAEDK,QAAQ,GAAGA,QAAQ,CAACnB,MAApB;MACD;;MAED,OAAO,KAAP;IACD;;IAED,6GACMnB,kBAAkB,IAAI;MACxBuB,YAAY,CAACb,IAAD,EAAK;;;QACf,IACE,WAAI,CAACS,MAAL,MAAW,IAAX,IAAWoB,aAAX,GAAW,MAAX,GAAWA,GAAE5C,IAAb,MAAsBmB,uBAAe0B,WAArC,IACA9B,IAAI,CAACS,MAAL,CAAYc,cAFd,EAGE;UACA;QACD;;QAED,IACE,CAACvB,IAAI,CAACuB,cAAN,IACA,CAAChB,uBAAuB,CAACP,IAAD,CADxB,IAEA,CAAC2B,2BAA2B,CAAC3B,IAAD,CAF5B,IAGA,WAAI,CAACS,MAAL,MAAW,IAAX,IAAWsB,aAAX,GAAW,MAAX,GAAWA,GAAE9C,IAAb,MAAsBmB,uBAAe4B,oBAJvC,EAKE;UACAlC,MAAM,CAACE,IAAD,CAAN;QACD;MACF;;IAjBuB,CAD5B,GAoBMT,cAAc,IAAI;MACpBkC,uBAAuB,CAACzB,IAAD,EAAK;QAC1BgB,eAAe,CAAChB,IAAI,CAACiB,MAAN,CAAf;MACD;;IAHmB,CApBxB,GAyBMzB,yBAAyB,IAAI;MAC/ByC,kBAAkB,CAACjC,IAAD,EAAK;QACrB,IACE,EAAEA,IAAI,CAACkC,KAAL,IAAcV,mCAAmC,CAACxB,IAAI,CAACkC,KAAN,CAAnD,KACA,CAAClC,IAAI,CAACuB,cAFR,EAGE;UACAzB,MAAM,CACJE,IADI,EAEJA,IAAI,CAACmC,GAAL,CAASlD,IAAT,KAAkBmB,uBAAeC,UAAjC,GACIL,IAAI,CAACmC,GAAL,CAAS3D,IADb,GAEI8B,SAJA,CAAN;QAMD;MACF;;IAb8B,CAzBnC,GAwCMZ,SAAS,IAAI;MACf,0CACEM,IADF,EACkE;QAEhEgB,eAAe,CAAChB,IAAI,CAACiB,MAAN,CAAf;MACD;;IALc,CAxCnB,GA+CMxB,mBAAmB,IAAI;MACzBmB,aAAa,CAACZ,IAAD,EAAK;QAChB,IACE,CAACA,IAAI,CAACuB,cAAN,IACA,CAAChB,uBAAuB,CAACP,IAAD,CADxB,IAEA,CAAC2B,2BAA2B,CAAC3B,IAAD,CAH9B,EAIE;UACAF,MAAM,CAACE,IAAD,CAAN;QACD;MACF;;IATwB,CA/C7B,GA0DML,mBAAmB,IAAI;MACzB,wCACEK,IADF,EACgE;QAE9D,IAAI,CAACA,IAAI,CAACuB,cAAV,EAA0B;UACxBzB,MAAM,CACJE,IADI,EAEJA,IAAI,CAACf,IAAL,KAAcmB,uBAAegC,mBAA7B,GACIjC,WAAW,CAACH,IAAI,CAACmC,GAAN,CADf,GAEI7B,SAJA,CAAN;QAMD;MACF;;IAZwB,CA1D7B,GAuEI;MACFI,kBAAkB,CAACV,IAAD,EAAK;QACrB,IACE,CAACJ,mBAAD,IACAI,IAAI,CAACqC,EAAL,CAAQd,cADR,IAECvB,IAAI,CAACqC,EAAL,CAAQpD,IAAR,KAAiBmB,uBAAeS,YAAhC,IACC,CAACvB,kBAHH,IAICU,IAAI,CAACqC,EAAL,CAAQpD,IAAR,KAAiBmB,uBAAeQ,aAAhC,IACC,CAACnB,mBALH,IAMCO,IAAI,CAACsC,IAAL,IAAad,mCAAmC,CAACxB,IAAI,CAACsC,IAAN,CAPnD,EAQE;UACA;QACD;;QAED,IAAI9B,OAAO,GAA8BR,IAAI,CAACS,MAA9C;;QACA,OAAOD,OAAP,EAAgB;UACd,QAAQA,OAAO,CAACvB,IAAhB;YACE,KAAKmB,uBAAeO,mBAApB;cACE;cACAH,OAAO,GAAGA,OAAO,CAACC,MAAlB;cACA;;YACF,KAAKL,uBAAeW,cAApB;YACA,KAAKX,uBAAemC,cAApB;cACE;cACA;;YACF;cACE;cACA/B,OAAO,GAAGF,SAAV;cACA;UAZJ;QAcD;;QAEDR,MAAM,CAACE,IAAD,EAAOG,WAAW,CAACH,IAAI,CAACqC,EAAN,CAAlB,CAAN;MACD;;IAjCC,CAvEJ;EA0GD;;AAnQmD,CAAvC,CAAf","names":["exports","util","createRule","name","meta","docs","description","recommended","messages","expectedTypedef","expectedTypedefNamed","schema","type","properties","defaultOptions","create","context","arrayDestructuring","arrowParameter","memberVariableDeclaration","objectDestructuring","parameter","propertyDeclaration","variableDeclaration","variableDeclarationIgnoreFunction","report","location","node","messageId","data","getNodeName","utils_1","Identifier","undefined","isForOfStatementContext","current","parent","VariableDeclarator","VariableDeclaration","ObjectPattern","ArrayPattern","Property","ForOfStatement","checkParameters","params","param","annotationNode","AssignmentPattern","left","TSParameterProperty","typeAnnotation","isVariableDeclarationIgnoreFunction","ArrowFunctionExpression","FunctionExpression","isAncestorHasTypeAnnotation","ancestor","_a","RestElement","_b","AssignmentExpression","PropertyDefinition","value","key","TSPropertySignature","id","init","ForInStatement"],"sources":["../../src/rules/typedef.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}