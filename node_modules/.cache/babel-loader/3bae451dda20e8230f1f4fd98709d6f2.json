{"ast":null,"code":"'use strict';\n\nvar _ignore = require('eslint-module-utils/ignore');\n\nvar _moduleVisitor = require('eslint-module-utils/moduleVisitor');\n\nvar _moduleVisitor2 = _interopRequireDefault(_moduleVisitor);\n\nvar _resolve = require('eslint-module-utils/resolve');\n\nvar _resolve2 = _interopRequireDefault(_resolve);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n/**\n                                                                                                                                                                                       * convert a potentially relative path from node utils into a true\n                                                                                                                                                                                       * relative path.\n                                                                                                                                                                                       *\n                                                                                                                                                                                       * ../ -> ..\n                                                                                                                                                                                       * ./ -> .\n                                                                                                                                                                                       * .foo/bar -> ./.foo/bar\n                                                                                                                                                                                       * ..foo/bar -> ./..foo/bar\n                                                                                                                                                                                       * foo/bar -> ./foo/bar\n                                                                                                                                                                                       *\n                                                                                                                                                                                       * @param relativePath {string} relative posix path potentially missing leading './'\n                                                                                                                                                                                       * @returns {string} relative posix path that always starts with a ./\n                                                                                                                                                                                       **/\n\n\nfunction toRelativePath(relativePath) {\n  var stripped = relativePath.replace(/\\/$/g, ''); // Remove trailing /\n\n  return /^((\\.\\.)|(\\.))($|\\/)/.test(stripped) ? stripped : './' + String(stripped);\n}\n/**\n * @fileOverview Ensures that there are no useless path segments\n * @author Thomas Grainger\n */\n\n\nfunction normalize(fn) {\n  return toRelativePath(_path2['default'].posix.normalize(fn));\n}\n\nfunction countRelativeParents(pathSegments) {\n  return pathSegments.reduce(function (sum, pathSegment) {\n    return pathSegment === '..' ? sum + 1 : sum;\n  }, 0);\n}\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: (0, _docsUrl2['default'])('no-useless-path-segments')\n    },\n    fixable: 'code',\n    schema: [{\n      type: 'object',\n      properties: {\n        commonjs: {\n          type: 'boolean'\n        },\n        noUselessIndex: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  create: function () {\n    function create(context) {\n      var currentDir = _path2['default'].dirname(context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename());\n\n      var options = context.options[0];\n\n      function checkSourceValue(source) {\n        var importPath = source.value;\n\n        function reportWithProposedPath(proposedPath) {\n          context.report({\n            node: source,\n            // Note: Using messageIds is not possible due to the support for ESLint 2 and 3\n            message: 'Useless path segments for \"' + String(importPath) + '\", should be \"' + String(proposedPath) + '\"',\n            fix: function () {\n              function fix(fixer) {\n                return proposedPath && fixer.replaceText(source, JSON.stringify(proposedPath));\n              }\n\n              return fix;\n            }()\n          });\n        } // Only relative imports are relevant for this rule --> Skip checking\n\n\n        if (!importPath.startsWith('.')) {\n          return;\n        } // Report rule violation if path is not the shortest possible\n\n\n        var resolvedPath = (0, _resolve2['default'])(importPath, context);\n        var normedPath = normalize(importPath);\n        var resolvedNormedPath = (0, _resolve2['default'])(normedPath, context);\n\n        if (normedPath !== importPath && resolvedPath === resolvedNormedPath) {\n          return reportWithProposedPath(normedPath);\n        }\n\n        var fileExtensions = (0, _ignore.getFileExtensions)(context.settings);\n        var regexUnnecessaryIndex = new RegExp('.*\\\\/index(\\\\' + String(Array.from(fileExtensions).join('|\\\\')) + ')?$'); // Check if path contains unnecessary index (including a configured extension)\n\n        if (options && options.noUselessIndex && regexUnnecessaryIndex.test(importPath)) {\n          var parentDirectory = _path2['default'].dirname(importPath); // Try to find ambiguous imports\n\n\n          if (parentDirectory !== '.' && parentDirectory !== '..') {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = fileExtensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var fileExtension = _step.value;\n\n                if ((0, _resolve2['default'])('' + String(parentDirectory) + String(fileExtension), context)) {\n                  return reportWithProposedPath(String(parentDirectory) + '/');\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator['return']) {\n                  _iterator['return']();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          }\n\n          return reportWithProposedPath(parentDirectory);\n        } // Path is shortest possible + starts from the current directory --> Return directly\n\n\n        if (importPath.startsWith('./')) {\n          return;\n        } // Path is not existing --> Return directly (following code requires path to be defined)\n\n\n        if (resolvedPath === undefined) {\n          return;\n        }\n\n        var expected = _path2['default'].relative(currentDir, resolvedPath); // Expected import path\n\n\n        var expectedSplit = expected.split(_path2['default'].sep); // Split by / or \\ (depending on OS)\n\n        var importPathSplit = importPath.replace(/^\\.\\//, '').split('/');\n        var countImportPathRelativeParents = countRelativeParents(importPathSplit);\n        var countExpectedRelativeParents = countRelativeParents(expectedSplit);\n        var diff = countImportPathRelativeParents - countExpectedRelativeParents; // Same number of relative parents --> Paths are the same --> Return directly\n\n        if (diff <= 0) {\n          return;\n        } // Report and propose minimal number of required relative parents\n\n\n        return reportWithProposedPath(toRelativePath(importPathSplit.slice(0, countExpectedRelativeParents).concat(importPathSplit.slice(countImportPathRelativeParents + diff)).join('/')));\n      }\n\n      return (0, _moduleVisitor2['default'])(checkSourceValue, options);\n    }\n\n    return create;\n  }()\n};","map":{"version":3,"mappings":"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","names":["toRelativePath","relativePath","stripped","replace","test","normalize","fn","path","posix","countRelativeParents","pathSegments","reduce","sum","pathSegment","module","exports","meta","type","docs","url","fixable","schema","properties","commonjs","noUselessIndex","additionalProperties","create","context","currentDir","dirname","getPhysicalFilename","getFilename","options","checkSourceValue","source","importPath","value","reportWithProposedPath","proposedPath","report","node","message","fix","fixer","replaceText","JSON","stringify","startsWith","resolvedPath","normedPath","resolvedNormedPath","fileExtensions","settings","regexUnnecessaryIndex","RegExp","Array","from","join","parentDirectory","fileExtension","_didIteratorError","_iteratorError","_iterator","undefined","expected","relative","expectedSplit","split","sep","importPathSplit","countImportPathRelativeParents","countExpectedRelativeParents","diff","slice","concat"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\no-useless-path-segments.js"],"sourcesContent":["/**\n * @fileOverview Ensures that there are no useless path segments\n * @author Thomas Grainger\n */\n\nimport { getFileExtensions } from 'eslint-module-utils/ignore';\nimport moduleVisitor from 'eslint-module-utils/moduleVisitor';\nimport resolve from 'eslint-module-utils/resolve';\nimport path from 'path';\nimport docsUrl from '../docsUrl';\n\n/**\n * convert a potentially relative path from node utils into a true\n * relative path.\n *\n * ../ -> ..\n * ./ -> .\n * .foo/bar -> ./.foo/bar\n * ..foo/bar -> ./..foo/bar\n * foo/bar -> ./foo/bar\n *\n * @param relativePath {string} relative posix path potentially missing leading './'\n * @returns {string} relative posix path that always starts with a ./\n **/\nfunction toRelativePath(relativePath) {\n  const stripped = relativePath.replace(/\\/$/g, ''); // Remove trailing /\n\n  return /^((\\.\\.)|(\\.))($|\\/)/.test(stripped) ? stripped : `./${stripped}`;\n}\n\nfunction normalize(fn) {\n  return toRelativePath(path.posix.normalize(fn));\n}\n\nfunction countRelativeParents(pathSegments) {\n  return pathSegments.reduce((sum, pathSegment) => pathSegment === '..' ? sum + 1 : sum, 0);\n}\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: docsUrl('no-useless-path-segments'),\n    },\n\n    fixable: 'code',\n\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          commonjs: { type: 'boolean' },\n          noUselessIndex: { type: 'boolean' },\n        },\n        additionalProperties: false,\n      },\n    ],\n  },\n\n  create(context) {\n    const currentDir = path.dirname(context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename());\n    const options = context.options[0];\n\n    function checkSourceValue(source) {\n      const { value: importPath } = source;\n\n      function reportWithProposedPath(proposedPath) {\n        context.report({\n          node: source,\n          // Note: Using messageIds is not possible due to the support for ESLint 2 and 3\n          message: `Useless path segments for \"${importPath}\", should be \"${proposedPath}\"`,\n          fix: fixer => proposedPath && fixer.replaceText(source, JSON.stringify(proposedPath)),\n        });\n      }\n\n      // Only relative imports are relevant for this rule --> Skip checking\n      if (!importPath.startsWith('.')) {\n        return;\n      }\n\n      // Report rule violation if path is not the shortest possible\n      const resolvedPath = resolve(importPath, context);\n      const normedPath = normalize(importPath);\n      const resolvedNormedPath = resolve(normedPath, context);\n      if (normedPath !== importPath && resolvedPath === resolvedNormedPath) {\n        return reportWithProposedPath(normedPath);\n      }\n\n      const fileExtensions = getFileExtensions(context.settings);\n      const regexUnnecessaryIndex = new RegExp(\n        `.*\\\\/index(\\\\${Array.from(fileExtensions).join('|\\\\')})?$`,\n      );\n\n      // Check if path contains unnecessary index (including a configured extension)\n      if (options && options.noUselessIndex && regexUnnecessaryIndex.test(importPath)) {\n        const parentDirectory = path.dirname(importPath);\n\n        // Try to find ambiguous imports\n        if (parentDirectory !== '.' && parentDirectory !== '..') {\n          for (const fileExtension of fileExtensions) {\n            if (resolve(`${parentDirectory}${fileExtension}`, context)) {\n              return reportWithProposedPath(`${parentDirectory}/`);\n            }\n          }\n        }\n\n        return reportWithProposedPath(parentDirectory);\n      }\n\n      // Path is shortest possible + starts from the current directory --> Return directly\n      if (importPath.startsWith('./')) {\n        return;\n      }\n\n      // Path is not existing --> Return directly (following code requires path to be defined)\n      if (resolvedPath === undefined) {\n        return;\n      }\n\n      const expected = path.relative(currentDir, resolvedPath); // Expected import path\n      const expectedSplit = expected.split(path.sep); // Split by / or \\ (depending on OS)\n      const importPathSplit = importPath.replace(/^\\.\\//, '').split('/');\n      const countImportPathRelativeParents = countRelativeParents(importPathSplit);\n      const countExpectedRelativeParents = countRelativeParents(expectedSplit);\n      const diff = countImportPathRelativeParents - countExpectedRelativeParents;\n\n      // Same number of relative parents --> Paths are the same --> Return directly\n      if (diff <= 0) {\n        return;\n      }\n\n      // Report and propose minimal number of required relative parents\n      return reportWithProposedPath(\n        toRelativePath(\n          importPathSplit\n            .slice(0, countExpectedRelativeParents)\n            .concat(importPathSplit.slice(countImportPathRelativeParents + diff))\n            .join('/'),\n        ),\n      );\n    }\n\n    return moduleVisitor(checkSourceValue, options);\n  },\n};\n"]},"metadata":{},"sourceType":"script"}