{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAccessorValue = exports.followTypeAssertionChain = exports.createRule = exports.TestCaseProperty = exports.TestCaseName = exports.ModifierName = exports.HookName = exports.EqualityMatcher = exports.DescribeProperty = exports.DescribeAlias = void 0;\nexports.getNodeName = getNodeName;\nexports.scopeHasLocalReference = exports.parseExpectCall = exports.isTestCaseCall = exports.isSupportedAccessor = exports.isStringNode = exports.isParsedEqualityMatcherCall = exports.isIdentifier = exports.isHook = exports.isFunction = exports.isExpectMember = exports.isExpectCall = exports.isDescribeCall = exports.hasOnlyOneArgument = exports.getTestCallExpressionsFromDeclaredVariables = exports.getStringValue = void 0;\n\nvar _path = require(\"path\");\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _package = require(\"../../package.json\");\n\nconst REPO_URL = 'https://github.com/jest-community/eslint-plugin-jest';\n\nconst createRule = _experimentalUtils.ESLintUtils.RuleCreator(name => {\n  const ruleName = (0, _path.parse)(name).name;\n  return `${REPO_URL}/blob/v${_package.version}/docs/rules/${ruleName}.md`;\n});\n\nexports.createRule = createRule;\n\nconst isTypeCastExpression = node => node.type === _experimentalUtils.AST_NODE_TYPES.TSAsExpression || node.type === _experimentalUtils.AST_NODE_TYPES.TSTypeAssertion;\n\nconst followTypeAssertionChain = expression => isTypeCastExpression(expression) ? followTypeAssertionChain(expression.expression) : expression;\n/**\n * A `Literal` with a `value` of type `string`.\n */\n\n\nexports.followTypeAssertionChain = followTypeAssertionChain;\n/**\n * Checks if the given `node` is a `StringLiteral`.\n *\n * If a `value` is provided & the `node` is a `StringLiteral`,\n * the `value` will be compared to that of the `StringLiteral`.\n *\n * @param {Node} node\n * @param {V} [value]\n *\n * @return {node is StringLiteral<V>}\n *\n * @template V\n */\n\nconst isStringLiteral = (node, value) => node.type === _experimentalUtils.AST_NODE_TYPES.Literal && typeof node.value === 'string' && (value === undefined || node.value === value);\n/**\n * Checks if the given `node` is a `TemplateLiteral`.\n *\n * Complex `TemplateLiteral`s are not considered specific, and so will return `false`.\n *\n * If a `value` is provided & the `node` is a `TemplateLiteral`,\n * the `value` will be compared to that of the `TemplateLiteral`.\n *\n * @param {Node} node\n * @param {V} [value]\n *\n * @return {node is TemplateLiteral<V>}\n *\n * @template V\n */\n\n\nconst isTemplateLiteral = (node, value) => node.type === _experimentalUtils.AST_NODE_TYPES.TemplateLiteral && node.quasis.length === 1 && ( // bail out if not simple\nvalue === undefined || node.quasis[0].value.raw === value);\n/**\n * Checks if the given `node` is a {@link StringNode}.\n *\n * @param {Node} node\n * @param {V} [specifics]\n *\n * @return {node is StringNode}\n *\n * @template V\n */\n\n\nconst isStringNode = (node, specifics) => isStringLiteral(node, specifics) || isTemplateLiteral(node, specifics);\n/**\n * Gets the value of the given `StringNode`.\n *\n * If the `node` is a `TemplateLiteral`, the `raw` value is used;\n * otherwise, `value` is returned instead.\n *\n * @param {StringNode<S>} node\n *\n * @return {S}\n *\n * @template S\n */\n\n\nexports.isStringNode = isStringNode;\n\nconst getStringValue = node => isTemplateLiteral(node) ? node.quasis[0].value.raw : node.value;\n/**\n * Represents a `MemberExpression` with a \"known\" `property`.\n */\n\n\nexports.getStringValue = getStringValue;\n/**\n * Guards that the given `call` has only one `argument`.\n *\n * @param {CallExpression} call\n *\n * @return {call is CallExpressionWithSingleArgument}\n */\n\nconst hasOnlyOneArgument = call => call.arguments.length === 1;\n/**\n * An `Identifier` with a known `name` value - i.e `expect`.\n */\n\n\nexports.hasOnlyOneArgument = hasOnlyOneArgument;\n/**\n * Checks if the given `node` is an `Identifier`.\n *\n * If a `name` is provided, & the `node` is an `Identifier`,\n * the `name` will be compared to that of the `identifier`.\n *\n * @param {Node} node\n * @param {V} [name]\n *\n * @return {node is KnownIdentifier<Name>}\n *\n * @template V\n */\n\nconst isIdentifier = (node, name) => node.type === _experimentalUtils.AST_NODE_TYPES.Identifier && (name === undefined || node.name === name);\n/**\n * Checks if the given `node` is a \"supported accessor\".\n *\n * This means that it's a node can be used to access properties,\n * and who's \"value\" can be statically determined.\n *\n * `MemberExpression` nodes most commonly contain accessors,\n * but it's possible for other nodes to contain them.\n *\n * If a `value` is provided & the `node` is an `AccessorNode`,\n * the `value` will be compared to that of the `AccessorNode`.\n *\n * Note that `value` here refers to the normalised value.\n * The property that holds the value is not always called `name`.\n *\n * @param {Node} node\n * @param {V} [value]\n *\n * @return {node is AccessorNode<V>}\n *\n * @template V\n */\n\n\nexports.isIdentifier = isIdentifier;\n\nconst isSupportedAccessor = (node, value) => isIdentifier(node, value) || isStringNode(node, value);\n/**\n * Gets the value of the given `AccessorNode`,\n * account for the different node types.\n *\n * @param {AccessorNode<S>} accessor\n *\n * @return {S}\n *\n * @template S\n */\n\n\nexports.isSupportedAccessor = isSupportedAccessor;\n\nconst getAccessorValue = accessor => accessor.type === _experimentalUtils.AST_NODE_TYPES.Identifier ? accessor.name : getStringValue(accessor);\n\nexports.getAccessorValue = getAccessorValue;\n/**\n * Checks if the given `node` is a valid `ExpectCall`.\n *\n * In order to be an `ExpectCall`, the `node` must:\n *  * be a `CallExpression`,\n *  * have an accessor named 'expect',\n *  * have a `parent`.\n *\n * @param {Node} node\n *\n * @return {node is ExpectCall}\n */\n\nconst isExpectCall = node => node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && isSupportedAccessor(node.callee, 'expect') && node.parent !== undefined;\n\nexports.isExpectCall = isExpectCall;\n\nconst isExpectMember = (node, name) => node.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && isSupportedAccessor(node.property, name);\n/**\n * Represents all the jest matchers.\n */\n\n\nexports.isExpectMember = isExpectMember;\nlet ModifierName;\nexports.ModifierName = ModifierName;\n\n(function (ModifierName) {\n  ModifierName[\"not\"] = \"not\";\n  ModifierName[\"rejects\"] = \"rejects\";\n  ModifierName[\"resolves\"] = \"resolves\";\n})(ModifierName || (exports.ModifierName = ModifierName = {}));\n\nlet EqualityMatcher;\nexports.EqualityMatcher = EqualityMatcher;\n\n(function (EqualityMatcher) {\n  EqualityMatcher[\"toBe\"] = \"toBe\";\n  EqualityMatcher[\"toEqual\"] = \"toEqual\";\n  EqualityMatcher[\"toStrictEqual\"] = \"toStrictEqual\";\n})(EqualityMatcher || (exports.EqualityMatcher = EqualityMatcher = {}));\n\nconst isParsedEqualityMatcherCall = (matcher, name) => (name ? matcher.name === name : EqualityMatcher.hasOwnProperty(matcher.name)) && matcher.arguments !== null && matcher.arguments.length === 1;\n/**\n * Represents a parsed expect matcher, such as `toBe`, `toContain`, and so on.\n */\n\n\nexports.isParsedEqualityMatcherCall = isParsedEqualityMatcherCall;\n\nconst parseExpectMember = expectMember => ({\n  name: getAccessorValue(expectMember.property),\n  node: expectMember\n});\n\nconst reparseAsMatcher = parsedMember => ({ ...parsedMember,\n\n  /**\n   * The arguments being passed to this `Matcher`, if any.\n   *\n   * If this matcher isn't called, this will be `null`.\n   */\n  arguments: parsedMember.node.parent.type === _experimentalUtils.AST_NODE_TYPES.CallExpression ? parsedMember.node.parent.arguments : null\n});\n/**\n * Re-parses the given `parsedMember` as a `ParsedExpectModifier`.\n *\n * If the given `parsedMember` does not have a `name` of a valid `Modifier`,\n * an exception will be thrown.\n *\n * @param {ParsedExpectMember<ModifierName>} parsedMember\n *\n * @return {ParsedExpectModifier}\n */\n\n\nconst reparseMemberAsModifier = parsedMember => {\n  if (isSpecificMember(parsedMember, ModifierName.not)) {\n    return parsedMember;\n  }\n  /* istanbul ignore if */\n\n\n  if (!isSpecificMember(parsedMember, ModifierName.resolves) && !isSpecificMember(parsedMember, ModifierName.rejects)) {\n    // ts doesn't think that the ModifierName.not check is the direct inverse as the above two checks\n    // todo: impossible at runtime, but can't be typed w/o negation support\n    throw new Error(`modifier name must be either \"${ModifierName.resolves}\" or \"${ModifierName.rejects}\" (got \"${parsedMember.name}\")`);\n  }\n\n  const negation = isExpectMember(parsedMember.node.parent, ModifierName.not) ? parsedMember.node.parent : undefined;\n  return { ...parsedMember,\n    negation\n  };\n};\n\nconst isSpecificMember = (member, specific) => member.name === specific;\n/**\n * Checks if the given `ParsedExpectMember` should be re-parsed as an `ParsedExpectModifier`.\n *\n * @param {ParsedExpectMember} member\n *\n * @return {member is ParsedExpectMember<ModifierName>}\n */\n\n\nconst shouldBeParsedExpectModifier = member => ModifierName.hasOwnProperty(member.name);\n\nconst parseExpectCall = expect => {\n  const expectation = {\n    expect\n  };\n\n  if (!isExpectMember(expect.parent)) {\n    return expectation;\n  }\n\n  const parsedMember = parseExpectMember(expect.parent);\n\n  if (!shouldBeParsedExpectModifier(parsedMember)) {\n    expectation.matcher = reparseAsMatcher(parsedMember);\n    return expectation;\n  }\n\n  const modifier = expectation.modifier = reparseMemberAsModifier(parsedMember);\n  const memberNode = modifier.negation || modifier.node;\n\n  if (!isExpectMember(memberNode.parent)) {\n    return expectation;\n  }\n\n  expectation.matcher = reparseAsMatcher(parseExpectMember(memberNode.parent));\n  return expectation;\n};\n\nexports.parseExpectCall = parseExpectCall;\nlet DescribeAlias;\nexports.DescribeAlias = DescribeAlias;\n\n(function (DescribeAlias) {\n  DescribeAlias[\"describe\"] = \"describe\";\n  DescribeAlias[\"fdescribe\"] = \"fdescribe\";\n  DescribeAlias[\"xdescribe\"] = \"xdescribe\";\n})(DescribeAlias || (exports.DescribeAlias = DescribeAlias = {}));\n\nlet TestCaseName;\nexports.TestCaseName = TestCaseName;\n\n(function (TestCaseName) {\n  TestCaseName[\"fit\"] = \"fit\";\n  TestCaseName[\"it\"] = \"it\";\n  TestCaseName[\"test\"] = \"test\";\n  TestCaseName[\"xit\"] = \"xit\";\n  TestCaseName[\"xtest\"] = \"xtest\";\n})(TestCaseName || (exports.TestCaseName = TestCaseName = {}));\n\nlet HookName;\nexports.HookName = HookName;\n\n(function (HookName) {\n  HookName[\"beforeAll\"] = \"beforeAll\";\n  HookName[\"beforeEach\"] = \"beforeEach\";\n  HookName[\"afterAll\"] = \"afterAll\";\n  HookName[\"afterEach\"] = \"afterEach\";\n})(HookName || (exports.HookName = HookName = {}));\n\nlet DescribeProperty;\nexports.DescribeProperty = DescribeProperty;\n\n(function (DescribeProperty) {\n  DescribeProperty[\"each\"] = \"each\";\n  DescribeProperty[\"only\"] = \"only\";\n  DescribeProperty[\"skip\"] = \"skip\";\n})(DescribeProperty || (exports.DescribeProperty = DescribeProperty = {}));\n\nlet TestCaseProperty;\nexports.TestCaseProperty = TestCaseProperty;\n\n(function (TestCaseProperty) {\n  TestCaseProperty[\"each\"] = \"each\";\n  TestCaseProperty[\"concurrent\"] = \"concurrent\";\n  TestCaseProperty[\"only\"] = \"only\";\n  TestCaseProperty[\"skip\"] = \"skip\";\n  TestCaseProperty[\"todo\"] = \"todo\";\n})(TestCaseProperty || (exports.TestCaseProperty = TestCaseProperty = {}));\n\nconst joinNames = (a, b) => a && b ? `${a}.${b}` : null;\n\nfunction getNodeName(node) {\n  if (isSupportedAccessor(node)) {\n    return getAccessorValue(node);\n  }\n\n  switch (node.type) {\n    case _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression:\n      return getNodeName(node.tag);\n\n    case _experimentalUtils.AST_NODE_TYPES.MemberExpression:\n      return joinNames(getNodeName(node.object), getNodeName(node.property));\n\n    case _experimentalUtils.AST_NODE_TYPES.NewExpression:\n    case _experimentalUtils.AST_NODE_TYPES.CallExpression:\n      return getNodeName(node.callee);\n  }\n\n  return null;\n}\n\nconst isFunction = node => node.type === _experimentalUtils.AST_NODE_TYPES.FunctionExpression || node.type === _experimentalUtils.AST_NODE_TYPES.ArrowFunctionExpression;\n\nexports.isFunction = isFunction;\n\nconst isHook = node => node.callee.type === _experimentalUtils.AST_NODE_TYPES.Identifier && HookName.hasOwnProperty(node.callee.name);\n\nexports.isHook = isHook;\n\nconst getTestCallExpressionsFromDeclaredVariables = declaredVariables => {\n  return declaredVariables.reduce((acc, _ref) => {\n    let {\n      references\n    } = _ref;\n    return acc.concat(references.map(_ref2 => {\n      let {\n        identifier\n      } = _ref2;\n      return identifier.parent;\n    }).filter(node => !!node && node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && isTestCaseCall(node)));\n  }, []);\n};\n\nexports.getTestCallExpressionsFromDeclaredVariables = getTestCallExpressionsFromDeclaredVariables;\n\nconst isTestCaseName = node => node.type === _experimentalUtils.AST_NODE_TYPES.Identifier && TestCaseName.hasOwnProperty(node.name);\n\nconst isTestCaseProperty = node => isSupportedAccessor(node) && TestCaseProperty.hasOwnProperty(getAccessorValue(node));\n/**\n * Checks if the given `node` is a *call* to a test case function that would\n * result in tests being run by `jest`.\n *\n * Note that `.each()` does not count as a call in this context, as it will not\n * result in `jest` running any tests.\n *\n * @param {TSESTree.CallExpression} node\n *\n * @return {node is JestFunctionCallExpression<TestCaseName>}\n */\n\n\nconst isTestCaseCall = node => {\n  if (isTestCaseName(node.callee)) {\n    return true;\n  }\n\n  const callee = node.callee.type === _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression ? node.callee.tag : node.callee.type === _experimentalUtils.AST_NODE_TYPES.CallExpression ? node.callee.callee : node.callee;\n\n  if (callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && isTestCaseProperty(callee.property)) {\n    // if we're an `each()`, ensure we're the outer CallExpression (i.e `.each()()`)\n    if (getAccessorValue(callee.property) === 'each' && node.callee.type !== _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression && node.callee.type !== _experimentalUtils.AST_NODE_TYPES.CallExpression) {\n      return false;\n    }\n\n    return callee.object.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression ? isTestCaseName(callee.object.object) : isTestCaseName(callee.object);\n  }\n\n  return false;\n};\n\nexports.isTestCaseCall = isTestCaseCall;\n\nconst isDescribeAlias = node => node.type === _experimentalUtils.AST_NODE_TYPES.Identifier && DescribeAlias.hasOwnProperty(node.name);\n\nconst isDescribeProperty = node => isSupportedAccessor(node) && DescribeProperty.hasOwnProperty(getAccessorValue(node));\n/**\n * Checks if the given `node` is a *call* to a `describe` function that would\n * result in a `describe` block being created by `jest`.\n *\n * Note that `.each()` does not count as a call in this context, as it will not\n * result in `jest` creating any `describe` blocks.\n *\n * @param {TSESTree.CallExpression} node\n *\n * @return {node is JestFunctionCallExpression<TestCaseName>}\n */\n\n\nconst isDescribeCall = node => {\n  if (isDescribeAlias(node.callee)) {\n    return true;\n  }\n\n  const callee = node.callee.type === _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression ? node.callee.tag : node.callee.type === _experimentalUtils.AST_NODE_TYPES.CallExpression ? node.callee.callee : node.callee;\n\n  if (callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && isDescribeProperty(callee.property)) {\n    // if we're an `each()`, ensure we're the outer CallExpression (i.e `.each()()`)\n    if (getAccessorValue(callee.property) === 'each' && node.callee.type !== _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression && node.callee.type !== _experimentalUtils.AST_NODE_TYPES.CallExpression) {\n      return false;\n    }\n\n    return callee.object.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression ? isDescribeAlias(callee.object.object) : isDescribeAlias(callee.object);\n  }\n\n  return false;\n};\n\nexports.isDescribeCall = isDescribeCall;\n\nconst collectReferences = scope => {\n  const locals = new Set();\n  const unresolved = new Set();\n  let currentScope = scope;\n\n  while (currentScope !== null) {\n    for (const ref of currentScope.variables) {\n      const isReferenceDefined = ref.defs.some(def => {\n        return def.type !== 'ImplicitGlobalVariable';\n      });\n\n      if (isReferenceDefined) {\n        locals.add(ref.name);\n      }\n    }\n\n    for (const ref of currentScope.through) {\n      unresolved.add(ref.identifier.name);\n    }\n\n    currentScope = currentScope.upper;\n  }\n\n  return {\n    locals,\n    unresolved\n  };\n};\n\nconst scopeHasLocalReference = (scope, referenceName) => {\n  const references = collectReferences(scope);\n  return (// referenceName was found as a local variable or function declaration.\n    references.locals.has(referenceName) || // referenceName was not found as an unresolved reference,\n    // meaning it is likely not an implicit global reference.\n    !references.unresolved.has(referenceName)\n  );\n};\n\nexports.scopeHasLocalReference = scopeHasLocalReference;","map":{"version":3,"names":["Object","defineProperty","exports","value","getAccessorValue","followTypeAssertionChain","createRule","TestCaseProperty","TestCaseName","ModifierName","HookName","EqualityMatcher","DescribeProperty","DescribeAlias","getNodeName","scopeHasLocalReference","parseExpectCall","isTestCaseCall","isSupportedAccessor","isStringNode","isParsedEqualityMatcherCall","isIdentifier","isHook","isFunction","isExpectMember","isExpectCall","isDescribeCall","hasOnlyOneArgument","getTestCallExpressionsFromDeclaredVariables","getStringValue","_path","require","_experimentalUtils","_package","REPO_URL","ESLintUtils","RuleCreator","name","ruleName","parse","version","isTypeCastExpression","node","type","AST_NODE_TYPES","TSAsExpression","TSTypeAssertion","expression","isStringLiteral","Literal","undefined","isTemplateLiteral","TemplateLiteral","quasis","length","raw","specifics","call","arguments","Identifier","accessor","CallExpression","callee","parent","MemberExpression","property","matcher","hasOwnProperty","parseExpectMember","expectMember","reparseAsMatcher","parsedMember","reparseMemberAsModifier","isSpecificMember","not","resolves","rejects","Error","negation","member","specific","shouldBeParsedExpectModifier","expect","expectation","modifier","memberNode","joinNames","a","b","TaggedTemplateExpression","tag","object","NewExpression","FunctionExpression","ArrowFunctionExpression","declaredVariables","reduce","acc","references","concat","map","identifier","filter","isTestCaseName","isTestCaseProperty","isDescribeAlias","isDescribeProperty","collectReferences","scope","locals","Set","unresolved","currentScope","ref","variables","isReferenceDefined","defs","some","def","add","through","upper","referenceName","has"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-jest/lib/rules/utils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAccessorValue = exports.followTypeAssertionChain = exports.createRule = exports.TestCaseProperty = exports.TestCaseName = exports.ModifierName = exports.HookName = exports.EqualityMatcher = exports.DescribeProperty = exports.DescribeAlias = void 0;\nexports.getNodeName = getNodeName;\nexports.scopeHasLocalReference = exports.parseExpectCall = exports.isTestCaseCall = exports.isSupportedAccessor = exports.isStringNode = exports.isParsedEqualityMatcherCall = exports.isIdentifier = exports.isHook = exports.isFunction = exports.isExpectMember = exports.isExpectCall = exports.isDescribeCall = exports.hasOnlyOneArgument = exports.getTestCallExpressionsFromDeclaredVariables = exports.getStringValue = void 0;\n\nvar _path = require(\"path\");\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _package = require(\"../../package.json\");\n\nconst REPO_URL = 'https://github.com/jest-community/eslint-plugin-jest';\n\nconst createRule = _experimentalUtils.ESLintUtils.RuleCreator(name => {\n  const ruleName = (0, _path.parse)(name).name;\n  return `${REPO_URL}/blob/v${_package.version}/docs/rules/${ruleName}.md`;\n});\n\nexports.createRule = createRule;\n\nconst isTypeCastExpression = node => node.type === _experimentalUtils.AST_NODE_TYPES.TSAsExpression || node.type === _experimentalUtils.AST_NODE_TYPES.TSTypeAssertion;\n\nconst followTypeAssertionChain = expression => isTypeCastExpression(expression) ? followTypeAssertionChain(expression.expression) : expression;\n/**\n * A `Literal` with a `value` of type `string`.\n */\n\n\nexports.followTypeAssertionChain = followTypeAssertionChain;\n\n/**\n * Checks if the given `node` is a `StringLiteral`.\n *\n * If a `value` is provided & the `node` is a `StringLiteral`,\n * the `value` will be compared to that of the `StringLiteral`.\n *\n * @param {Node} node\n * @param {V} [value]\n *\n * @return {node is StringLiteral<V>}\n *\n * @template V\n */\nconst isStringLiteral = (node, value) => node.type === _experimentalUtils.AST_NODE_TYPES.Literal && typeof node.value === 'string' && (value === undefined || node.value === value);\n\n/**\n * Checks if the given `node` is a `TemplateLiteral`.\n *\n * Complex `TemplateLiteral`s are not considered specific, and so will return `false`.\n *\n * If a `value` is provided & the `node` is a `TemplateLiteral`,\n * the `value` will be compared to that of the `TemplateLiteral`.\n *\n * @param {Node} node\n * @param {V} [value]\n *\n * @return {node is TemplateLiteral<V>}\n *\n * @template V\n */\nconst isTemplateLiteral = (node, value) => node.type === _experimentalUtils.AST_NODE_TYPES.TemplateLiteral && node.quasis.length === 1 && ( // bail out if not simple\nvalue === undefined || node.quasis[0].value.raw === value);\n\n/**\n * Checks if the given `node` is a {@link StringNode}.\n *\n * @param {Node} node\n * @param {V} [specifics]\n *\n * @return {node is StringNode}\n *\n * @template V\n */\nconst isStringNode = (node, specifics) => isStringLiteral(node, specifics) || isTemplateLiteral(node, specifics);\n/**\n * Gets the value of the given `StringNode`.\n *\n * If the `node` is a `TemplateLiteral`, the `raw` value is used;\n * otherwise, `value` is returned instead.\n *\n * @param {StringNode<S>} node\n *\n * @return {S}\n *\n * @template S\n */\n\n\nexports.isStringNode = isStringNode;\n\nconst getStringValue = node => isTemplateLiteral(node) ? node.quasis[0].value.raw : node.value;\n/**\n * Represents a `MemberExpression` with a \"known\" `property`.\n */\n\n\nexports.getStringValue = getStringValue;\n\n/**\n * Guards that the given `call` has only one `argument`.\n *\n * @param {CallExpression} call\n *\n * @return {call is CallExpressionWithSingleArgument}\n */\nconst hasOnlyOneArgument = call => call.arguments.length === 1;\n/**\n * An `Identifier` with a known `name` value - i.e `expect`.\n */\n\n\nexports.hasOnlyOneArgument = hasOnlyOneArgument;\n\n/**\n * Checks if the given `node` is an `Identifier`.\n *\n * If a `name` is provided, & the `node` is an `Identifier`,\n * the `name` will be compared to that of the `identifier`.\n *\n * @param {Node} node\n * @param {V} [name]\n *\n * @return {node is KnownIdentifier<Name>}\n *\n * @template V\n */\nconst isIdentifier = (node, name) => node.type === _experimentalUtils.AST_NODE_TYPES.Identifier && (name === undefined || node.name === name);\n/**\n * Checks if the given `node` is a \"supported accessor\".\n *\n * This means that it's a node can be used to access properties,\n * and who's \"value\" can be statically determined.\n *\n * `MemberExpression` nodes most commonly contain accessors,\n * but it's possible for other nodes to contain them.\n *\n * If a `value` is provided & the `node` is an `AccessorNode`,\n * the `value` will be compared to that of the `AccessorNode`.\n *\n * Note that `value` here refers to the normalised value.\n * The property that holds the value is not always called `name`.\n *\n * @param {Node} node\n * @param {V} [value]\n *\n * @return {node is AccessorNode<V>}\n *\n * @template V\n */\n\n\nexports.isIdentifier = isIdentifier;\n\nconst isSupportedAccessor = (node, value) => isIdentifier(node, value) || isStringNode(node, value);\n/**\n * Gets the value of the given `AccessorNode`,\n * account for the different node types.\n *\n * @param {AccessorNode<S>} accessor\n *\n * @return {S}\n *\n * @template S\n */\n\n\nexports.isSupportedAccessor = isSupportedAccessor;\n\nconst getAccessorValue = accessor => accessor.type === _experimentalUtils.AST_NODE_TYPES.Identifier ? accessor.name : getStringValue(accessor);\n\nexports.getAccessorValue = getAccessorValue;\n\n/**\n * Checks if the given `node` is a valid `ExpectCall`.\n *\n * In order to be an `ExpectCall`, the `node` must:\n *  * be a `CallExpression`,\n *  * have an accessor named 'expect',\n *  * have a `parent`.\n *\n * @param {Node} node\n *\n * @return {node is ExpectCall}\n */\nconst isExpectCall = node => node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && isSupportedAccessor(node.callee, 'expect') && node.parent !== undefined;\n\nexports.isExpectCall = isExpectCall;\n\nconst isExpectMember = (node, name) => node.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && isSupportedAccessor(node.property, name);\n/**\n * Represents all the jest matchers.\n */\n\n\nexports.isExpectMember = isExpectMember;\nlet ModifierName;\nexports.ModifierName = ModifierName;\n\n(function (ModifierName) {\n  ModifierName[\"not\"] = \"not\";\n  ModifierName[\"rejects\"] = \"rejects\";\n  ModifierName[\"resolves\"] = \"resolves\";\n})(ModifierName || (exports.ModifierName = ModifierName = {}));\n\nlet EqualityMatcher;\nexports.EqualityMatcher = EqualityMatcher;\n\n(function (EqualityMatcher) {\n  EqualityMatcher[\"toBe\"] = \"toBe\";\n  EqualityMatcher[\"toEqual\"] = \"toEqual\";\n  EqualityMatcher[\"toStrictEqual\"] = \"toStrictEqual\";\n})(EqualityMatcher || (exports.EqualityMatcher = EqualityMatcher = {}));\n\nconst isParsedEqualityMatcherCall = (matcher, name) => (name ? matcher.name === name : EqualityMatcher.hasOwnProperty(matcher.name)) && matcher.arguments !== null && matcher.arguments.length === 1;\n/**\n * Represents a parsed expect matcher, such as `toBe`, `toContain`, and so on.\n */\n\n\nexports.isParsedEqualityMatcherCall = isParsedEqualityMatcherCall;\n\nconst parseExpectMember = expectMember => ({\n  name: getAccessorValue(expectMember.property),\n  node: expectMember\n});\n\nconst reparseAsMatcher = parsedMember => ({ ...parsedMember,\n\n  /**\n   * The arguments being passed to this `Matcher`, if any.\n   *\n   * If this matcher isn't called, this will be `null`.\n   */\n  arguments: parsedMember.node.parent.type === _experimentalUtils.AST_NODE_TYPES.CallExpression ? parsedMember.node.parent.arguments : null\n});\n/**\n * Re-parses the given `parsedMember` as a `ParsedExpectModifier`.\n *\n * If the given `parsedMember` does not have a `name` of a valid `Modifier`,\n * an exception will be thrown.\n *\n * @param {ParsedExpectMember<ModifierName>} parsedMember\n *\n * @return {ParsedExpectModifier}\n */\n\n\nconst reparseMemberAsModifier = parsedMember => {\n  if (isSpecificMember(parsedMember, ModifierName.not)) {\n    return parsedMember;\n  }\n  /* istanbul ignore if */\n\n\n  if (!isSpecificMember(parsedMember, ModifierName.resolves) && !isSpecificMember(parsedMember, ModifierName.rejects)) {\n    // ts doesn't think that the ModifierName.not check is the direct inverse as the above two checks\n    // todo: impossible at runtime, but can't be typed w/o negation support\n    throw new Error(`modifier name must be either \"${ModifierName.resolves}\" or \"${ModifierName.rejects}\" (got \"${parsedMember.name}\")`);\n  }\n\n  const negation = isExpectMember(parsedMember.node.parent, ModifierName.not) ? parsedMember.node.parent : undefined;\n  return { ...parsedMember,\n    negation\n  };\n};\n\nconst isSpecificMember = (member, specific) => member.name === specific;\n/**\n * Checks if the given `ParsedExpectMember` should be re-parsed as an `ParsedExpectModifier`.\n *\n * @param {ParsedExpectMember} member\n *\n * @return {member is ParsedExpectMember<ModifierName>}\n */\n\n\nconst shouldBeParsedExpectModifier = member => ModifierName.hasOwnProperty(member.name);\n\nconst parseExpectCall = expect => {\n  const expectation = {\n    expect\n  };\n\n  if (!isExpectMember(expect.parent)) {\n    return expectation;\n  }\n\n  const parsedMember = parseExpectMember(expect.parent);\n\n  if (!shouldBeParsedExpectModifier(parsedMember)) {\n    expectation.matcher = reparseAsMatcher(parsedMember);\n    return expectation;\n  }\n\n  const modifier = expectation.modifier = reparseMemberAsModifier(parsedMember);\n  const memberNode = modifier.negation || modifier.node;\n\n  if (!isExpectMember(memberNode.parent)) {\n    return expectation;\n  }\n\n  expectation.matcher = reparseAsMatcher(parseExpectMember(memberNode.parent));\n  return expectation;\n};\n\nexports.parseExpectCall = parseExpectCall;\nlet DescribeAlias;\nexports.DescribeAlias = DescribeAlias;\n\n(function (DescribeAlias) {\n  DescribeAlias[\"describe\"] = \"describe\";\n  DescribeAlias[\"fdescribe\"] = \"fdescribe\";\n  DescribeAlias[\"xdescribe\"] = \"xdescribe\";\n})(DescribeAlias || (exports.DescribeAlias = DescribeAlias = {}));\n\nlet TestCaseName;\nexports.TestCaseName = TestCaseName;\n\n(function (TestCaseName) {\n  TestCaseName[\"fit\"] = \"fit\";\n  TestCaseName[\"it\"] = \"it\";\n  TestCaseName[\"test\"] = \"test\";\n  TestCaseName[\"xit\"] = \"xit\";\n  TestCaseName[\"xtest\"] = \"xtest\";\n})(TestCaseName || (exports.TestCaseName = TestCaseName = {}));\n\nlet HookName;\nexports.HookName = HookName;\n\n(function (HookName) {\n  HookName[\"beforeAll\"] = \"beforeAll\";\n  HookName[\"beforeEach\"] = \"beforeEach\";\n  HookName[\"afterAll\"] = \"afterAll\";\n  HookName[\"afterEach\"] = \"afterEach\";\n})(HookName || (exports.HookName = HookName = {}));\n\nlet DescribeProperty;\nexports.DescribeProperty = DescribeProperty;\n\n(function (DescribeProperty) {\n  DescribeProperty[\"each\"] = \"each\";\n  DescribeProperty[\"only\"] = \"only\";\n  DescribeProperty[\"skip\"] = \"skip\";\n})(DescribeProperty || (exports.DescribeProperty = DescribeProperty = {}));\n\nlet TestCaseProperty;\nexports.TestCaseProperty = TestCaseProperty;\n\n(function (TestCaseProperty) {\n  TestCaseProperty[\"each\"] = \"each\";\n  TestCaseProperty[\"concurrent\"] = \"concurrent\";\n  TestCaseProperty[\"only\"] = \"only\";\n  TestCaseProperty[\"skip\"] = \"skip\";\n  TestCaseProperty[\"todo\"] = \"todo\";\n})(TestCaseProperty || (exports.TestCaseProperty = TestCaseProperty = {}));\n\nconst joinNames = (a, b) => a && b ? `${a}.${b}` : null;\n\nfunction getNodeName(node) {\n  if (isSupportedAccessor(node)) {\n    return getAccessorValue(node);\n  }\n\n  switch (node.type) {\n    case _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression:\n      return getNodeName(node.tag);\n\n    case _experimentalUtils.AST_NODE_TYPES.MemberExpression:\n      return joinNames(getNodeName(node.object), getNodeName(node.property));\n\n    case _experimentalUtils.AST_NODE_TYPES.NewExpression:\n    case _experimentalUtils.AST_NODE_TYPES.CallExpression:\n      return getNodeName(node.callee);\n  }\n\n  return null;\n}\n\nconst isFunction = node => node.type === _experimentalUtils.AST_NODE_TYPES.FunctionExpression || node.type === _experimentalUtils.AST_NODE_TYPES.ArrowFunctionExpression;\n\nexports.isFunction = isFunction;\n\nconst isHook = node => node.callee.type === _experimentalUtils.AST_NODE_TYPES.Identifier && HookName.hasOwnProperty(node.callee.name);\n\nexports.isHook = isHook;\n\nconst getTestCallExpressionsFromDeclaredVariables = declaredVariables => {\n  return declaredVariables.reduce((acc, {\n    references\n  }) => acc.concat(references.map(({\n    identifier\n  }) => identifier.parent).filter(node => !!node && node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && isTestCaseCall(node))), []);\n};\n\nexports.getTestCallExpressionsFromDeclaredVariables = getTestCallExpressionsFromDeclaredVariables;\n\nconst isTestCaseName = node => node.type === _experimentalUtils.AST_NODE_TYPES.Identifier && TestCaseName.hasOwnProperty(node.name);\n\nconst isTestCaseProperty = node => isSupportedAccessor(node) && TestCaseProperty.hasOwnProperty(getAccessorValue(node));\n/**\n * Checks if the given `node` is a *call* to a test case function that would\n * result in tests being run by `jest`.\n *\n * Note that `.each()` does not count as a call in this context, as it will not\n * result in `jest` running any tests.\n *\n * @param {TSESTree.CallExpression} node\n *\n * @return {node is JestFunctionCallExpression<TestCaseName>}\n */\n\n\nconst isTestCaseCall = node => {\n  if (isTestCaseName(node.callee)) {\n    return true;\n  }\n\n  const callee = node.callee.type === _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression ? node.callee.tag : node.callee.type === _experimentalUtils.AST_NODE_TYPES.CallExpression ? node.callee.callee : node.callee;\n\n  if (callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && isTestCaseProperty(callee.property)) {\n    // if we're an `each()`, ensure we're the outer CallExpression (i.e `.each()()`)\n    if (getAccessorValue(callee.property) === 'each' && node.callee.type !== _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression && node.callee.type !== _experimentalUtils.AST_NODE_TYPES.CallExpression) {\n      return false;\n    }\n\n    return callee.object.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression ? isTestCaseName(callee.object.object) : isTestCaseName(callee.object);\n  }\n\n  return false;\n};\n\nexports.isTestCaseCall = isTestCaseCall;\n\nconst isDescribeAlias = node => node.type === _experimentalUtils.AST_NODE_TYPES.Identifier && DescribeAlias.hasOwnProperty(node.name);\n\nconst isDescribeProperty = node => isSupportedAccessor(node) && DescribeProperty.hasOwnProperty(getAccessorValue(node));\n/**\n * Checks if the given `node` is a *call* to a `describe` function that would\n * result in a `describe` block being created by `jest`.\n *\n * Note that `.each()` does not count as a call in this context, as it will not\n * result in `jest` creating any `describe` blocks.\n *\n * @param {TSESTree.CallExpression} node\n *\n * @return {node is JestFunctionCallExpression<TestCaseName>}\n */\n\n\nconst isDescribeCall = node => {\n  if (isDescribeAlias(node.callee)) {\n    return true;\n  }\n\n  const callee = node.callee.type === _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression ? node.callee.tag : node.callee.type === _experimentalUtils.AST_NODE_TYPES.CallExpression ? node.callee.callee : node.callee;\n\n  if (callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && isDescribeProperty(callee.property)) {\n    // if we're an `each()`, ensure we're the outer CallExpression (i.e `.each()()`)\n    if (getAccessorValue(callee.property) === 'each' && node.callee.type !== _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression && node.callee.type !== _experimentalUtils.AST_NODE_TYPES.CallExpression) {\n      return false;\n    }\n\n    return callee.object.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression ? isDescribeAlias(callee.object.object) : isDescribeAlias(callee.object);\n  }\n\n  return false;\n};\n\nexports.isDescribeCall = isDescribeCall;\n\nconst collectReferences = scope => {\n  const locals = new Set();\n  const unresolved = new Set();\n  let currentScope = scope;\n\n  while (currentScope !== null) {\n    for (const ref of currentScope.variables) {\n      const isReferenceDefined = ref.defs.some(def => {\n        return def.type !== 'ImplicitGlobalVariable';\n      });\n\n      if (isReferenceDefined) {\n        locals.add(ref.name);\n      }\n    }\n\n    for (const ref of currentScope.through) {\n      unresolved.add(ref.identifier.name);\n    }\n\n    currentScope = currentScope.upper;\n  }\n\n  return {\n    locals,\n    unresolved\n  };\n};\n\nconst scopeHasLocalReference = (scope, referenceName) => {\n  const references = collectReferences(scope);\n  return (// referenceName was found as a local variable or function declaration.\n    references.locals.has(referenceName) || // referenceName was not found as an unresolved reference,\n    // meaning it is likely not an implicit global reference.\n    !references.unresolved.has(referenceName)\n  );\n};\n\nexports.scopeHasLocalReference = scopeHasLocalReference;"],"mappings":"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"},"metadata":{},"sourceType":"script"}