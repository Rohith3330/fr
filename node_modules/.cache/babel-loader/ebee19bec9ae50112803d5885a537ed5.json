{"ast":null,"code":"'use strict';\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _readPkgUp = require('eslint-module-utils/readPkgUp');\n\nvar _readPkgUp2 = _interopRequireDefault(_readPkgUp);\n\nvar _resolve = require('eslint-module-utils/resolve');\n\nvar _resolve2 = _interopRequireDefault(_resolve);\n\nvar _moduleVisitor = require('eslint-module-utils/moduleVisitor');\n\nvar _moduleVisitor2 = _interopRequireDefault(_moduleVisitor);\n\nvar _importType = require('../core/importType');\n\nvar _importType2 = _interopRequireDefault(_importType);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n/** @param {string} filePath */\n\n\nfunction toPosixPath(filePath) {\n  return filePath.replace(/\\\\/g, '/');\n}\n\nfunction findNamedPackage(filePath) {\n  var found = (0, _readPkgUp2['default'])({\n    cwd: filePath\n  });\n\n  if (found.pkg && !found.pkg.name) {\n    return findNamedPackage(_path2['default'].join(found.path, '../..'));\n  }\n\n  return found;\n}\n\nfunction checkImportForRelativePackage(context, importPath, node) {\n  var potentialViolationTypes = ['parent', 'index', 'sibling'];\n\n  if (potentialViolationTypes.indexOf((0, _importType2['default'])(importPath, context)) === -1) {\n    return;\n  }\n\n  var resolvedImport = (0, _resolve2['default'])(importPath, context);\n  var resolvedContext = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n\n  if (!resolvedImport || !resolvedContext) {\n    return;\n  }\n\n  var importPkg = findNamedPackage(resolvedImport);\n  var contextPkg = findNamedPackage(resolvedContext);\n\n  if (importPkg.pkg && contextPkg.pkg && importPkg.pkg.name !== contextPkg.pkg.name) {\n    var importBaseName = _path2['default'].basename(importPath);\n\n    var importRoot = _path2['default'].dirname(importPkg.path);\n\n    var properPath = _path2['default'].relative(importRoot, resolvedImport);\n\n    var properImport = _path2['default'].join(importPkg.pkg.name, _path2['default'].dirname(properPath), importBaseName === _path2['default'].basename(importRoot) ? '' : importBaseName);\n\n    context.report({\n      node: node,\n      message: 'Relative import from another package is not allowed. Use `' + String(properImport) + '` instead of `' + String(importPath) + '`',\n      fix: function () {\n        function fix(fixer) {\n          return fixer.replaceText(node, JSON.stringify(toPosixPath(properImport)));\n        }\n\n        return fix;\n      }()\n    });\n  }\n}\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: (0, _docsUrl2['default'])('no-relative-packages')\n    },\n    fixable: 'code',\n    schema: [(0, _moduleVisitor.makeOptionsSchema)()]\n  },\n  create: function () {\n    function create(context) {\n      return (0, _moduleVisitor2['default'])(function (source) {\n        return checkImportForRelativePackage(context, source.value, source);\n      }, context.options[0]);\n    }\n\n    return create;\n  }()\n};","map":{"version":3,"mappings":";;AAAA;;;;AACA;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;AAEA;;;AACA,SAASA,WAAT,CAAqBC,QAArB,EAA+B;EAC7B,OAAOA,SAASC,OAATD,CAAiB,KAAjBA,EAAwB,GAAxBA,CAAP;AACD;;AAED,SAASE,gBAAT,CAA0BF,QAA1B,EAAoC;EAClC,IAAMG,QAAQ,4BAAU;IAAEC,KAAKJ;EAAP,CAAV,CAAd;;EACA,IAAIG,MAAME,GAANF,IAAa,CAACA,MAAME,GAANF,CAAUG,IAA5B,EAAkC;IAChC,OAAOJ,iBAAiBK,kBAAKC,IAALD,CAAUJ,MAAMI,IAAhBA,EAAsB,OAAtBA,CAAjBL,CAAP;EACD;;EACD,OAAOC,KAAP;AACD;;AAED,SAASM,6BAAT,CAAuCC,OAAvC,EAAgDC,UAAhD,EAA4DC,IAA5D,EAAkE;EAChE,IAAMC,0BAA0B,CAAC,QAAD,EAAW,OAAX,EAAoB,SAApB,CAAhC;;EACA,IAAIA,wBAAwBC,OAAxBD,CAAgC,6BAAWF,UAAX,EAAuBD,OAAvB,CAAhCG,MAAqE,CAAC,CAA1E,EAA6E;IAC3E;EACD;;EAED,IAAME,iBAAiB,0BAAQJ,UAAR,EAAoBD,OAApB,CAAvB;EACA,IAAMM,kBAAkBN,QAAQO,mBAARP,GAA8BA,QAAQO,mBAARP,EAA9BA,GAA8DA,QAAQQ,WAARR,EAAtF;;EAEA,IAAI,CAACK,cAAD,IAAmB,CAACC,eAAxB,EAAyC;IACvC;EACD;;EAED,IAAMG,YAAYjB,iBAAiBa,cAAjBb,CAAlB;EACA,IAAMkB,aAAalB,iBAAiBc,eAAjBd,CAAnB;;EAEA,IAAIiB,UAAUd,GAAVc,IAAiBC,WAAWf,GAA5Bc,IAAmCA,UAAUd,GAAVc,CAAcb,IAAda,KAAuBC,WAAWf,GAAXe,CAAed,IAA7E,EAAmF;IACjF,IAAMe,iBAAiBd,kBAAKe,QAALf,CAAcI,UAAdJ,CAAvB;;IACA,IAAMgB,aAAahB,kBAAKiB,OAALjB,CAAaY,UAAUZ,IAAvBA,CAAnB;;IACA,IAAMkB,aAAalB,kBAAKmB,QAALnB,CAAcgB,UAAdhB,EAA0BQ,cAA1BR,CAAnB;;IACA,IAAMoB,eAAepB,kBAAKC,IAALD,CACnBY,UAAUd,GAAVc,CAAcb,IADKC,EAEnBA,kBAAKiB,OAALjB,CAAakB,UAAblB,CAFmBA,EAGnBc,mBAAmBd,kBAAKe,QAALf,CAAcgB,UAAdhB,CAAnBc,GAA+C,EAA/CA,GAAoDA,cAHjCd,CAArB;;IAKAG,QAAQkB,MAARlB,CAAe;MACbE,UADa;MAEbiB,+EAAuEF,YAAvEE,8BAAsGlB,UAAtG,OAFa;MAGbmB;QAAK;UAAA,OAASC,MAAMC,WAAND,CAAkBnB,IAAlBmB,EAAwBE,KAAKC,SAALD,CAAelC,YAAY4B,YAAZ5B,CAAfkC,CAAxBF,CAAT;QAAL;;QAAA;MAAA;IAHa,CAAfrB;EAMD;AACF;;AAEDyB,OAAOC,OAAPD,GAAiB;EACfE,MAAM;IACJC,MAAM,YADF;IAEJC,MAAM;MACJC,KAAK,0BAAQ,sBAAR;IADD,CAFF;IAKJC,SAAS,MALL;IAMJC,QAAQ,CAAC,uCAAD;EANJ,CADS;EAUfC,MAVe;IAAA,gBAURjC,OAVQ,EAUC;MACd,OAAO,gCAAc,UAACkC,MAAD;QAAA,OAAYnC,8BAA8BC,OAA9BD,EAAuCmC,OAAOC,KAA9CpC,EAAqDmC,MAArDnC,CAAZ;MAAd,GAAwFC,QAAQoC,OAARpC,CAAgB,CAAhBA,CAAxF,CAAP;IAXa;;IAAA;EAAA;AAAA,CAAjByB","names":["toPosixPath","filePath","replace","findNamedPackage","found","cwd","pkg","name","path","join","checkImportForRelativePackage","context","importPath","node","potentialViolationTypes","indexOf","resolvedImport","resolvedContext","getPhysicalFilename","getFilename","importPkg","contextPkg","importBaseName","basename","importRoot","dirname","properPath","relative","properImport","report","message","fix","fixer","replaceText","JSON","stringify","module","exports","meta","type","docs","url","fixable","schema","create","source","value","options"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\no-relative-packages.js"],"sourcesContent":["import path from 'path';\nimport readPkgUp from 'eslint-module-utils/readPkgUp';\n\nimport resolve from 'eslint-module-utils/resolve';\nimport moduleVisitor, { makeOptionsSchema } from 'eslint-module-utils/moduleVisitor';\nimport importType from '../core/importType';\nimport docsUrl from '../docsUrl';\n\n/** @param {string} filePath */\nfunction toPosixPath(filePath) {\n  return filePath.replace(/\\\\/g, '/');\n}\n\nfunction findNamedPackage(filePath) {\n  const found = readPkgUp({ cwd: filePath });\n  if (found.pkg && !found.pkg.name) {\n    return findNamedPackage(path.join(found.path, '../..'));\n  }\n  return found;\n}\n\nfunction checkImportForRelativePackage(context, importPath, node) {\n  const potentialViolationTypes = ['parent', 'index', 'sibling'];\n  if (potentialViolationTypes.indexOf(importType(importPath, context)) === -1) {\n    return;\n  }\n\n  const resolvedImport = resolve(importPath, context);\n  const resolvedContext = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n\n  if (!resolvedImport || !resolvedContext) {\n    return;\n  }\n\n  const importPkg = findNamedPackage(resolvedImport);\n  const contextPkg = findNamedPackage(resolvedContext);\n\n  if (importPkg.pkg && contextPkg.pkg && importPkg.pkg.name !== contextPkg.pkg.name) {\n    const importBaseName = path.basename(importPath);\n    const importRoot = path.dirname(importPkg.path);\n    const properPath = path.relative(importRoot, resolvedImport);\n    const properImport = path.join(\n      importPkg.pkg.name,\n      path.dirname(properPath),\n      importBaseName === path.basename(importRoot) ? '' : importBaseName,\n    );\n    context.report({\n      node,\n      message: `Relative import from another package is not allowed. Use \\`${properImport}\\` instead of \\`${importPath}\\``,\n      fix: fixer => fixer.replaceText(node, JSON.stringify(toPosixPath(properImport)))\n      ,\n    });\n  }\n}\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: docsUrl('no-relative-packages'),\n    },\n    fixable: 'code',\n    schema: [makeOptionsSchema()],\n  },\n\n  create(context) {\n    return moduleVisitor((source) => checkImportForRelativePackage(context, source.value, source), context.options[0]);\n  },\n};\n"]},"metadata":{},"sourceType":"script"}