{"ast":null,"code":"/*\n  @license\n\tRollup.js v2.79.0\n\tWed, 31 Aug 2022 04:52:13 GMT - commit 8477f8ff1fe80086556021542b22942ad27a0a69\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\nimport require$$0$2, { resolve } from 'path';\nimport process$1 from 'process';\nimport { ensureArray, warnUnknownOptions, defaultOnWarn, objectifyOptionWithPresets, treeshakePresets, objectifyOption, generatedCodePresets, picomatch as picomatch$2, getAugmentedNamespace, fseventsImporter, createFilter, rollupInternal } from './rollup.js';\nimport require$$2$1, { platform } from 'os';\nimport require$$0$1 from 'fs';\nimport require$$2 from 'util';\nimport require$$1 from 'stream';\nimport require$$0$3 from 'events';\nimport 'perf_hooks';\nimport 'crypto';\nconst commandAliases = {\n  c: 'config',\n  d: 'dir',\n  e: 'external',\n  f: 'format',\n  g: 'globals',\n  h: 'help',\n  i: 'input',\n  m: 'sourcemap',\n  n: 'name',\n  o: 'file',\n  p: 'plugin',\n  v: 'version',\n  w: 'watch'\n};\n\nfunction mergeOptions(config) {\n  let rawCommandOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    external: [],\n    globals: undefined\n  };\n  let defaultOnWarnHandler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOnWarn;\n  const command = getCommandOptions(rawCommandOptions);\n  const inputOptions = mergeInputOptions(config, command, defaultOnWarnHandler);\n  const warn = inputOptions.onwarn;\n\n  if (command.output) {\n    Object.assign(command, command.output);\n  }\n\n  const outputOptionsArray = ensureArray(config.output);\n  if (outputOptionsArray.length === 0) outputOptionsArray.push({});\n  const outputOptions = outputOptionsArray.map(singleOutputOptions => mergeOutputOptions(singleOutputOptions, command, warn));\n  warnUnknownOptions(command, Object.keys(inputOptions).concat(Object.keys(outputOptions[0]).filter(option => option !== 'sourcemapPathTransform'), Object.keys(commandAliases), 'config', 'environment', 'plugin', 'silent', 'failAfterWarnings', 'stdin', 'waitForBundleInput', 'configPlugin'), 'CLI flags', warn, /^_$|output$|config/);\n  inputOptions.output = outputOptions;\n  return inputOptions;\n}\n\nfunction getCommandOptions(rawCommandOptions) {\n  const external = rawCommandOptions.external && typeof rawCommandOptions.external === 'string' ? rawCommandOptions.external.split(',') : [];\n  return { ...rawCommandOptions,\n    external,\n    globals: typeof rawCommandOptions.globals === 'string' ? rawCommandOptions.globals.split(',').reduce((globals, globalDefinition) => {\n      const [id, variableName] = globalDefinition.split(':');\n      globals[id] = variableName;\n\n      if (!external.includes(id)) {\n        external.push(id);\n      }\n\n      return globals;\n    }, Object.create(null)) : undefined\n  };\n}\n\nfunction mergeInputOptions(config, overrides, defaultOnWarnHandler) {\n  const getOption = name => {\n    var _a;\n\n    return (_a = overrides[name]) !== null && _a !== void 0 ? _a : config[name];\n  };\n\n  const inputOptions = {\n    acorn: getOption('acorn'),\n    acornInjectPlugins: config.acornInjectPlugins,\n    cache: config.cache,\n    context: getOption('context'),\n    experimentalCacheExpiry: getOption('experimentalCacheExpiry'),\n    external: getExternal(config, overrides),\n    inlineDynamicImports: getOption('inlineDynamicImports'),\n    input: getOption('input') || [],\n    makeAbsoluteExternalsRelative: getOption('makeAbsoluteExternalsRelative'),\n    manualChunks: getOption('manualChunks'),\n    maxParallelFileOps: getOption('maxParallelFileOps'),\n    maxParallelFileReads: getOption('maxParallelFileReads'),\n    moduleContext: getOption('moduleContext'),\n    onwarn: getOnWarn(config, defaultOnWarnHandler),\n    perf: getOption('perf'),\n    plugins: ensureArray(config.plugins),\n    preserveEntrySignatures: getOption('preserveEntrySignatures'),\n    preserveModules: getOption('preserveModules'),\n    preserveSymlinks: getOption('preserveSymlinks'),\n    shimMissingExports: getOption('shimMissingExports'),\n    strictDeprecations: getOption('strictDeprecations'),\n    treeshake: getObjectOption(config, overrides, 'treeshake', objectifyOptionWithPresets(treeshakePresets, 'treeshake', 'false, true, ')),\n    watch: getWatch(config, overrides)\n  };\n  warnUnknownOptions(config, Object.keys(inputOptions), 'input options', inputOptions.onwarn, /^output$/);\n  return inputOptions;\n}\n\nconst getExternal = (config, overrides) => {\n  const configExternal = config.external;\n  return typeof configExternal === 'function' ? (source, importer, isResolved) => configExternal(source, importer, isResolved) || overrides.external.includes(source) : ensureArray(configExternal).concat(overrides.external);\n};\n\nconst getOnWarn = (config, defaultOnWarnHandler) => config.onwarn ? warning => config.onwarn(warning, defaultOnWarnHandler) : defaultOnWarnHandler;\n\nconst getObjectOption = function (config, overrides, name) {\n  let objectifyValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : objectifyOption;\n  const commandOption = normalizeObjectOptionValue(overrides[name], objectifyValue);\n  const configOption = normalizeObjectOptionValue(config[name], objectifyValue);\n\n  if (commandOption !== undefined) {\n    return commandOption && { ...configOption,\n      ...commandOption\n    };\n  }\n\n  return configOption;\n};\n\nconst getWatch = (config, overrides) => config.watch !== false && getObjectOption(config, overrides, 'watch');\n\nconst normalizeObjectOptionValue = (optionValue, objectifyValue) => {\n  if (!optionValue) {\n    return optionValue;\n  }\n\n  if (Array.isArray(optionValue)) {\n    return optionValue.reduce((result, value) => value && result && { ...result,\n      ...objectifyValue(value)\n    }, {});\n  }\n\n  return objectifyValue(optionValue);\n};\n\nfunction mergeOutputOptions(config, overrides, warn) {\n  const getOption = name => {\n    var _a;\n\n    return (_a = overrides[name]) !== null && _a !== void 0 ? _a : config[name];\n  };\n\n  const outputOptions = {\n    amd: getObjectOption(config, overrides, 'amd'),\n    assetFileNames: getOption('assetFileNames'),\n    banner: getOption('banner'),\n    chunkFileNames: getOption('chunkFileNames'),\n    compact: getOption('compact'),\n    dir: getOption('dir'),\n    dynamicImportFunction: getOption('dynamicImportFunction'),\n    entryFileNames: getOption('entryFileNames'),\n    esModule: getOption('esModule'),\n    exports: getOption('exports'),\n    extend: getOption('extend'),\n    externalLiveBindings: getOption('externalLiveBindings'),\n    file: getOption('file'),\n    footer: getOption('footer'),\n    format: getOption('format'),\n    freeze: getOption('freeze'),\n    generatedCode: getObjectOption(config, overrides, 'generatedCode', objectifyOptionWithPresets(generatedCodePresets, 'output.generatedCode', '')),\n    globals: getOption('globals'),\n    hoistTransitiveImports: getOption('hoistTransitiveImports'),\n    indent: getOption('indent'),\n    inlineDynamicImports: getOption('inlineDynamicImports'),\n    interop: getOption('interop'),\n    intro: getOption('intro'),\n    manualChunks: getOption('manualChunks'),\n    minifyInternalExports: getOption('minifyInternalExports'),\n    name: getOption('name'),\n    namespaceToStringTag: getOption('namespaceToStringTag'),\n    noConflict: getOption('noConflict'),\n    outro: getOption('outro'),\n    paths: getOption('paths'),\n    plugins: ensureArray(config.plugins),\n    preferConst: getOption('preferConst'),\n    preserveModules: getOption('preserveModules'),\n    preserveModulesRoot: getOption('preserveModulesRoot'),\n    sanitizeFileName: getOption('sanitizeFileName'),\n    sourcemap: getOption('sourcemap'),\n    sourcemapBaseUrl: getOption('sourcemapBaseUrl'),\n    sourcemapExcludeSources: getOption('sourcemapExcludeSources'),\n    sourcemapFile: getOption('sourcemapFile'),\n    sourcemapPathTransform: getOption('sourcemapPathTransform'),\n    strict: getOption('strict'),\n    systemNullSetters: getOption('systemNullSetters'),\n    validate: getOption('validate')\n  };\n  warnUnknownOptions(config, Object.keys(outputOptions), 'output options', warn);\n  return outputOptions;\n}\n\nvar chokidar = {};\nconst fs$3 = require$$0$1;\nconst {\n  Readable\n} = require$$1;\nconst sysPath$3 = require$$0$2;\nconst {\n  promisify: promisify$3\n} = require$$2;\nconst picomatch$1 = picomatch$2.exports;\nconst readdir$1 = promisify$3(fs$3.readdir);\nconst stat$3 = promisify$3(fs$3.stat);\nconst lstat$2 = promisify$3(fs$3.lstat);\nconst realpath$1 = promisify$3(fs$3.realpath);\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG$2 = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch$1(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n\n    for (const item of filter) {\n      const trimmed = item.trim();\n\n      if (trimmed.charAt(0) === BANG$2) {\n        negative.push(picomatch$1(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch$1(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n\n      return entry => !negative.some(f => f(entry.basename));\n    }\n\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n\n      /* eslint-disable no-unused-vars */\n      fileFilter: path => true,\n      directoryFilter: path => true,\n\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions,\n      ...options\n    };\n    const {\n      root,\n      type\n    } = opts;\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    const statMethod = opts.lstat ? lstat$2 : stat$3; // Use bigint stats if it's windows and stat() supports options (node 10+).\n\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, {\n        bigint: true\n      });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath$3.resolve(root);\n    this._isDirent = 'Dirent' in fs$3 && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = {\n      encoding: 'utf8',\n      withFileTypes: this._isDirent\n    }; // Launch stream with one parent, the root dir.\n\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const {\n          path,\n          depth,\n          files = []\n        } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n            const entryType = await this._getEntryType(entry);\n\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n\n    try {\n      files = await readdir$1(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n\n    return {\n      files,\n      depth,\n      path\n    };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath$3.resolve(sysPath$3.join(path, basename));\n      entry = {\n        path: sysPath$3.relative(this._root, fullPath),\n        fullPath,\n        basename\n      };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n\n    if (!stats) {\n      return;\n    }\n\n    if (stats.isFile()) {\n      return 'file';\n    }\n\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n\n      try {\n        const entryRealPath = await realpath$1(full);\n        const entryRealPathStats = await lstat$2(entryRealPath);\n\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {\n            const recursiveError = new Error(`Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`);\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n\n}\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\n\n\nconst readdirp$1 = function (root) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n\n  if (type) options.type = type;\n\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = function (root) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp$1(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n  });\n};\n\nreaddirp$1.promise = readdirpPromise;\nreaddirp$1.ReaddirpStream = ReaddirpStream;\nreaddirp$1.default = readdirp$1;\nvar readdirp_1 = readdirp$1;\nvar anymatch$2 = {\n  exports: {}\n};\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath$2 = function (path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n  var len = path.length;\n  if (len <= 1) return path; // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n\n  var prefix = '';\n\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n\n  return prefix + segs.join('/');\n};\n\nObject.defineProperty(anymatch$2.exports, \"__esModule\", {\n  value: true\n});\nconst picomatch = picomatch$2.exports;\nconst normalizePath$1 = normalizePath$2;\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\n\nconst BANG$1 = '!';\nconst DEFAULT_OPTIONS = {\n  returnIndex: false\n};\n\nconst arrify$1 = item => Array.isArray(item) ? item : [item];\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\n\n\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return string => matcher === string || glob(string);\n  }\n\n  if (matcher instanceof RegExp) {\n    return string => matcher.test(string);\n  }\n\n  return string => false;\n};\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\n\n\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n\n  const _path = isList ? args[0] : args;\n\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));\n  }\n\n  const path = normalizePath$1(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\n\n\nconst anymatch$1 = function (matchers, testString) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;\n\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n\n  const opts = typeof options === 'boolean' ? {\n    returnIndex: options\n  } : options;\n  const returnIndex = opts.returnIndex || false; // Early cache for matchers.\n\n  const mtchers = arrify$1(matchers);\n  const negatedGlobs = mtchers.filter(item => typeof item === 'string' && item.charAt(0) === BANG$1).map(item => item.slice(1)).map(item => picomatch(item, opts));\n  const patterns = mtchers.filter(item => typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG$1).map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return function (testString) {\n      let ri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    };\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch$1.default = anymatch$1;\nanymatch$2.exports = anymatch$1;\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob$1 = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n\n  while (match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str)) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nvar isExtglob = isExtglob$1;\nvar chars = {\n  '{': '}',\n  '(': ')',\n  '[': ']'\n};\n\nvar strictCheck = function (str) {\n  if (str[0] === '!') {\n    return true;\n  }\n\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n\n        backSlashIndex = str.indexOf('\\\\', index);\n\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n\n  return false;\n};\n\nvar relaxedCheck = function (str) {\n  if (str[0] === '!') {\n    return true;\n  }\n\n  var index = 0;\n\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n\n  return false;\n};\n\nvar isGlob$2 = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var check = strictCheck; // optionally relax check\n\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n\n  return check(str);\n};\n\nvar isGlob$1 = isGlob$2;\nvar pathPosixDirname = require$$0$2.posix.dirname;\nvar isWin32 = require$$2$1.platform() === 'win32';\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\n\nvar globParent$1 = function globParent(str, opts) {\n  var options = Object.assign({\n    flipBackslashes: true\n  }, opts); // flip windows path separators\n\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  } // special case for strings ending in enclosure containing path separator\n\n\n  if (enclosure.test(str)) {\n    str += slash;\n  } // preserves full path in case of trailing path separator\n\n\n  str += 'a'; // remove path parts that are globby\n\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob$1(str) || globby.test(str)); // remove escape chars and return result\n\n\n  return str.replace(escaped, '$1');\n};\n\nvar utils$3 = {};\n\n(function (exports) {\n  exports.isInteger = num => {\n    if (typeof num === 'number') {\n      return Number.isInteger(num);\n    }\n\n    if (typeof num === 'string' && num.trim() !== '') {\n      return Number.isInteger(Number(num));\n    }\n\n    return false;\n  };\n  /**\n   * Find a node of the given type\n   */\n\n\n  exports.find = (node, type) => node.nodes.find(node => node.type === type);\n  /**\n   * Find a node of the given type\n   */\n\n\n  exports.exceedsLimit = function (min, max) {\n    let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let limit = arguments.length > 3 ? arguments[3] : undefined;\n    if (limit === false) return false;\n    if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n    return (Number(max) - Number(min)) / Number(step) >= limit;\n  };\n  /**\n   * Escape the given node with '\\\\' before node.value\n   */\n\n\n  exports.escapeNode = function (block) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let type = arguments.length > 2 ? arguments[2] : undefined;\n    let node = block.nodes[n];\n    if (!node) return;\n\n    if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n      if (node.escaped !== true) {\n        node.value = '\\\\' + node.value;\n        node.escaped = true;\n      }\n    }\n  };\n  /**\n   * Returns true if the given brace node should be enclosed in literal braces\n   */\n\n\n  exports.encloseBrace = node => {\n    if (node.type !== 'brace') return false;\n\n    if (node.commas >> 0 + node.ranges >> 0 === 0) {\n      node.invalid = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if a brace node is invalid.\n   */\n\n\n  exports.isInvalidBrace = block => {\n    if (block.type !== 'brace') return false;\n    if (block.invalid === true || block.dollar) return true;\n\n    if (block.commas >> 0 + block.ranges >> 0 === 0) {\n      block.invalid = true;\n      return true;\n    }\n\n    if (block.open !== true || block.close !== true) {\n      block.invalid = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if a node is an open or close node\n   */\n\n\n  exports.isOpenOrClose = node => {\n    if (node.type === 'open' || node.type === 'close') {\n      return true;\n    }\n\n    return node.open === true || node.close === true;\n  };\n  /**\n   * Reduce an array of text nodes.\n   */\n\n\n  exports.reduce = nodes => nodes.reduce((acc, node) => {\n    if (node.type === 'text') acc.push(node.value);\n    if (node.type === 'range') node.type = 'text';\n    return acc;\n  }, []);\n  /**\n   * Flatten an array\n   */\n\n\n  exports.flatten = function () {\n    const result = [];\n\n    const flat = arr => {\n      for (let i = 0; i < arr.length; i++) {\n        let ele = arr[i];\n        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n      }\n\n      return result;\n    };\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    flat(args);\n    return result;\n  };\n})(utils$3);\n\nconst utils$2 = utils$3;\n\nvar stringify$4 = function (ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  let stringify = function (node) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let invalidBlock = options.escapeInvalid && utils$2.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils$2.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n\n    return output;\n  };\n\n  return stringify(ast);\n};\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nvar isNumber$2 = function (num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n\n  return false;\n};\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nconst isNumber$1 = isNumber$2;\n\nconst toRegexRange$1 = (min, max, options) => {\n  if (isNumber$1(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber$1(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = {\n    relaxZeros: true,\n    ...options\n  };\n\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange$1.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n\n    if (opts.capture) {\n      return `(${result})`;\n    }\n\n    if (opts.wrap === false) {\n      return result;\n    }\n\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = {\n    min,\n    max,\n    a,\n    b\n  };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange$1.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {\n      pattern: start,\n      count: [],\n      digits: 0\n    };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return {\n    pattern,\n    count: [count],\n    digits\n  };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let {\n      string\n    } = ele; // only push if _both_ are negative...\n\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    } // or _both_ are positive\n\n\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n\n  return result;\n}\n/**\n * Zip strings\n */\n\n\nfunction zip(a, b) {\n  let arr = [];\n\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - integer % Math.pow(10, zeros);\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${b - a === 1 ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n\n    case 1:\n      return relax ? '0?' : '0';\n\n    case 2:\n      return relax ? '0{0,2}' : '00';\n\n    default:\n      {\n        return relax ? `0{0,${diff}}` : `0{${diff}}`;\n      }\n  }\n}\n/**\n * Cache\n */\n\n\ntoRegexRange$1.cache = {};\n\ntoRegexRange$1.clearCache = () => toRegexRange$1.cache = {};\n/**\n * Expose `toRegexRange`\n */\n\n\nvar toRegexRange_1 = toRegexRange$1;\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nconst util = require$$2;\nconst toRegexRange = toRegexRange_1;\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || typeof value === 'string' && value !== '';\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n\n  while (value[++index] === '0');\n\n  return index > 0;\n};\n\nconst stringify$3 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');\n  }\n\n  if (toNumber === false) {\n    return String(input);\n  }\n\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n\n  while (input.length < maxLength) input = '0' + input;\n\n  return negative ? '-' + input : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, {\n      wrap: false,\n      ...options\n    });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = function () {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...arguments));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n\n  return [];\n};\n\nconst fillNumbers = function (start, end) {\n  let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  } // fix negative zero\n\n\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$3(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = {\n    negatives: [],\n    positives: []\n  };\n\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1 ? toSequence(parts, options) : toRegex(range, null, {\n      wrap: false,\n      ...options\n    });\n  }\n\n  return range;\n};\n\nconst fillLetters = function (start, end) {\n  let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {\n    return invalidRange(start, end, options);\n  }\n\n  let format = options.transform || (val => String.fromCharCode(val));\n\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, {\n      wrap: false,\n      options\n    });\n  }\n\n  return range;\n};\n\nconst fill$2 = function (start, end, step) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill$2(start, end, 1, {\n      transform: step\n    });\n  }\n\n  if (isObject(step)) {\n    return fill$2(start, end, 0, step);\n  }\n\n  let opts = { ...options\n  };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill$2(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nvar fillRange = fill$2;\nconst fill$1 = fillRange;\nconst utils$1 = utils$3;\n\nconst compile$1 = function (ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  let walk = function (node) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let invalidBlock = utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? prefix + node.value : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? prefix + node.value : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n      let range = fill$1(...args, { ...options,\n        wrap: false,\n        toRegex: true\n      });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n\n    return output;\n  };\n\n  return walk(ast);\n};\n\nvar compile_1 = compile$1;\nconst fill = fillRange;\nconst stringify$2 = stringify$4;\nconst utils = utils$3;\n\nconst append = function () {\n  let queue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let stash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let enclose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let result = [];\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n  if (!stash.length) return queue;\n\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n      }\n    }\n  }\n\n  return utils.flatten(result);\n};\n\nconst expand$1 = function (ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = function (node) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    node.queue = [];\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify$2(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n\n      if (range.length === 0) {\n        range = stringify$2(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nvar expand_1 = expand$1;\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n  // Digits\n  CHAR_0: '0',\n\n  /* 0 */\n  CHAR_9: '9',\n\n  /* 9 */\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A',\n\n  /* A */\n  CHAR_LOWERCASE_A: 'a',\n\n  /* a */\n  CHAR_UPPERCASE_Z: 'Z',\n\n  /* Z */\n  CHAR_LOWERCASE_Z: 'z',\n\n  /* z */\n  CHAR_LEFT_PARENTHESES: '(',\n\n  /* ( */\n  CHAR_RIGHT_PARENTHESES: ')',\n\n  /* ) */\n  CHAR_ASTERISK: '*',\n\n  /* * */\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&',\n\n  /* & */\n  CHAR_AT: '@',\n\n  /* @ */\n  CHAR_BACKSLASH: '\\\\',\n\n  /* \\ */\n  CHAR_BACKTICK: '`',\n\n  /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r',\n\n  /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^',\n\n  /* ^ */\n  CHAR_COLON: ':',\n\n  /* : */\n  CHAR_COMMA: ',',\n\n  /* , */\n  CHAR_DOLLAR: '$',\n\n  /* . */\n  CHAR_DOT: '.',\n\n  /* . */\n  CHAR_DOUBLE_QUOTE: '\"',\n\n  /* \" */\n  CHAR_EQUAL: '=',\n\n  /* = */\n  CHAR_EXCLAMATION_MARK: '!',\n\n  /* ! */\n  CHAR_FORM_FEED: '\\f',\n\n  /* \\f */\n  CHAR_FORWARD_SLASH: '/',\n\n  /* / */\n  CHAR_HASH: '#',\n\n  /* # */\n  CHAR_HYPHEN_MINUS: '-',\n\n  /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<',\n\n  /* < */\n  CHAR_LEFT_CURLY_BRACE: '{',\n\n  /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[',\n\n  /* [ */\n  CHAR_LINE_FEED: '\\n',\n\n  /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0',\n\n  /* \\u00A0 */\n  CHAR_PERCENT: '%',\n\n  /* % */\n  CHAR_PLUS: '+',\n\n  /* + */\n  CHAR_QUESTION_MARK: '?',\n\n  /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>',\n\n  /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}',\n\n  /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']',\n\n  /* ] */\n  CHAR_SEMICOLON: ';',\n\n  /* ; */\n  CHAR_SINGLE_QUOTE: '\\'',\n\n  /* ' */\n  CHAR_SPACE: ' ',\n\n  /*   */\n  CHAR_TAB: '\\t',\n\n  /* \\t */\n  CHAR_UNDERSCORE: '_',\n\n  /* _ */\n  CHAR_VERTICAL_LINE: '|',\n\n  /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF'\n  /* \\uFEFF */\n\n};\nconst stringify$1 = stringify$4;\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH,\n\n  /* \\ */\n  CHAR_BACKTICK,\n\n  /* ` */\n  CHAR_COMMA,\n\n  /* , */\n  CHAR_DOT,\n\n  /* . */\n  CHAR_LEFT_PARENTHESES,\n\n  /* ( */\n  CHAR_RIGHT_PARENTHESES,\n\n  /* ) */\n  CHAR_LEFT_CURLY_BRACE,\n\n  /* { */\n  CHAR_RIGHT_CURLY_BRACE,\n\n  /* } */\n  CHAR_LEFT_SQUARE_BRACKET,\n\n  /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET,\n\n  /* ] */\n  CHAR_DOUBLE_QUOTE,\n\n  /* \" */\n  CHAR_SINGLE_QUOTE,\n\n  /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants$1;\n/**\n * parse\n */\n\nconst parse$1 = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = {\n    type: 'root',\n    input,\n    nodes: []\n  };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({\n    type: 'bos'\n  });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n    /**\n     * Escaped chars\n     */\n\n\n    if (value === CHAR_BACKSLASH) {\n      push({\n        type: 'text',\n        value: (options.keepEscaping ? value : '') + advance()\n      });\n      continue;\n    }\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({\n        type: 'text',\n        value: '\\\\' + value\n      });\n      continue;\n    }\n    /**\n     * Left square bracket: '['\n     */\n\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Parentheses\n     */\n\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({\n        type: 'paren',\n        nodes: []\n      });\n      stack.push(block);\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      block = stack.pop();\n      push({\n        type: 'text',\n        value\n      });\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\n     * Quotes: '|\"|`\n     */\n\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Left curly brace: '{'\n     */\n\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n      block = push(brace);\n      stack.push(block);\n      push({\n        type: 'open',\n        value\n      });\n      continue;\n    }\n    /**\n     * Right curly brace: '}'\n     */\n\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n      push({\n        type,\n        value\n      });\n      depth--;\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\n     * Comma: ','\n     */\n\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, {\n          type: 'text',\n          value: stringify$1(block)\n        }];\n      }\n\n      push({\n        type: 'comma',\n        value\n      });\n      block.commas++;\n      continue;\n    }\n    /**\n     * Dot: '.'\n     */\n\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({\n        type: 'dot',\n        value\n      });\n      continue;\n    }\n    /**\n     * Text\n     */\n\n\n    push({\n      type: 'text',\n      value\n    });\n  } // Mark imbalanced braces and brackets as invalid\n\n\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      }); // get the location of the block on parent.nodes (block's siblings)\n\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block); // replace the (invalid) block with it's nodes\n\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({\n    type: 'eos'\n  });\n  return ast;\n};\n\nvar parse_1 = parse$1;\nconst stringify = stringify$4;\nconst compile = compile_1;\nconst expand = expand_1;\nconst parse = parse_1;\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces$1 = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces$1.create(pattern, options);\n\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces$1.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n\n  return output;\n};\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\n\nbraces$1.parse = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return parse(input, options);\n};\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces$1.stringify = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof input === 'string') {\n    return stringify(braces$1.parse(input, options), options);\n  }\n\n  return stringify(input, options);\n};\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces$1.compile = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n\n  return compile(input, options);\n};\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces$1.expand = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n\n  let result = expand(input, options); // filter out empty strings if specified\n\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  } // filter out duplicates if specified\n\n\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces$1.create = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n  return options.expand !== true ? braces$1.compile(input, options) : braces$1.expand(input, options);\n};\n/**\n * Expose \"braces\"\n */\n\n\nvar braces_1 = braces$1;\nvar binaryExtensions$1 = {\n  exports: {}\n};\nconst require$$0 = [\"3dm\", \"3ds\", \"3g2\", \"3gp\", \"7z\", \"a\", \"aac\", \"adp\", \"ai\", \"aif\", \"aiff\", \"alz\", \"ape\", \"apk\", \"appimage\", \"ar\", \"arj\", \"asf\", \"au\", \"avi\", \"bak\", \"baml\", \"bh\", \"bin\", \"bk\", \"bmp\", \"btif\", \"bz2\", \"bzip2\", \"cab\", \"caf\", \"cgm\", \"class\", \"cmx\", \"cpio\", \"cr2\", \"cur\", \"dat\", \"dcm\", \"deb\", \"dex\", \"djvu\", \"dll\", \"dmg\", \"dng\", \"doc\", \"docm\", \"docx\", \"dot\", \"dotm\", \"dra\", \"DS_Store\", \"dsk\", \"dts\", \"dtshd\", \"dvb\", \"dwg\", \"dxf\", \"ecelp4800\", \"ecelp7470\", \"ecelp9600\", \"egg\", \"eol\", \"eot\", \"epub\", \"exe\", \"f4v\", \"fbs\", \"fh\", \"fla\", \"flac\", \"flatpak\", \"fli\", \"flv\", \"fpx\", \"fst\", \"fvt\", \"g3\", \"gh\", \"gif\", \"graffle\", \"gz\", \"gzip\", \"h261\", \"h263\", \"h264\", \"icns\", \"ico\", \"ief\", \"img\", \"ipa\", \"iso\", \"jar\", \"jpeg\", \"jpg\", \"jpgv\", \"jpm\", \"jxr\", \"key\", \"ktx\", \"lha\", \"lib\", \"lvp\", \"lz\", \"lzh\", \"lzma\", \"lzo\", \"m3u\", \"m4a\", \"m4v\", \"mar\", \"mdi\", \"mht\", \"mid\", \"midi\", \"mj2\", \"mka\", \"mkv\", \"mmr\", \"mng\", \"mobi\", \"mov\", \"movie\", \"mp3\", \"mp4\", \"mp4a\", \"mpeg\", \"mpg\", \"mpga\", \"mxu\", \"nef\", \"npx\", \"numbers\", \"nupkg\", \"o\", \"odp\", \"ods\", \"odt\", \"oga\", \"ogg\", \"ogv\", \"otf\", \"ott\", \"pages\", \"pbm\", \"pcx\", \"pdb\", \"pdf\", \"pea\", \"pgm\", \"pic\", \"png\", \"pnm\", \"pot\", \"potm\", \"potx\", \"ppa\", \"ppam\", \"ppm\", \"pps\", \"ppsm\", \"ppsx\", \"ppt\", \"pptm\", \"pptx\", \"psd\", \"pya\", \"pyc\", \"pyo\", \"pyv\", \"qt\", \"rar\", \"ras\", \"raw\", \"resources\", \"rgb\", \"rip\", \"rlc\", \"rmf\", \"rmvb\", \"rpm\", \"rtf\", \"rz\", \"s3m\", \"s7z\", \"scpt\", \"sgi\", \"shar\", \"snap\", \"sil\", \"sketch\", \"slk\", \"smv\", \"snk\", \"so\", \"stl\", \"suo\", \"sub\", \"swf\", \"tar\", \"tbz\", \"tbz2\", \"tga\", \"tgz\", \"thmx\", \"tif\", \"tiff\", \"tlz\", \"ttc\", \"ttf\", \"txz\", \"udf\", \"uvh\", \"uvi\", \"uvm\", \"uvp\", \"uvs\", \"uvu\", \"viv\", \"vob\", \"war\", \"wav\", \"wax\", \"wbmp\", \"wdp\", \"weba\", \"webm\", \"webp\", \"whl\", \"wim\", \"wm\", \"wma\", \"wmv\", \"wmx\", \"woff\", \"woff2\", \"wrm\", \"wvx\", \"xbm\", \"xif\", \"xla\", \"xlam\", \"xls\", \"xlsb\", \"xlsm\", \"xlsx\", \"xlt\", \"xltm\", \"xltx\", \"xm\", \"xmind\", \"xpi\", \"xpm\", \"xwd\", \"xz\", \"z\", \"zip\", \"zipx\"];\n\n(function (module) {\n  module.exports = require$$0;\n})(binaryExtensions$1);\n\nconst path = require$$0$2;\nconst binaryExtensions = binaryExtensions$1.exports;\nconst extensions = new Set(binaryExtensions);\n\nvar isBinaryPath$1 = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n\nvar constants = {};\n\n(function (exports) {\n  const {\n    sep\n  } = require$$0$2;\n  const {\n    platform\n  } = process;\n  const os = require$$2$1;\n  exports.EV_ALL = 'all';\n  exports.EV_READY = 'ready';\n  exports.EV_ADD = 'add';\n  exports.EV_CHANGE = 'change';\n  exports.EV_ADD_DIR = 'addDir';\n  exports.EV_UNLINK = 'unlink';\n  exports.EV_UNLINK_DIR = 'unlinkDir';\n  exports.EV_RAW = 'raw';\n  exports.EV_ERROR = 'error';\n  exports.STR_DATA = 'data';\n  exports.STR_END = 'end';\n  exports.STR_CLOSE = 'close';\n  exports.FSEVENT_CREATED = 'created';\n  exports.FSEVENT_MODIFIED = 'modified';\n  exports.FSEVENT_DELETED = 'deleted';\n  exports.FSEVENT_MOVED = 'moved';\n  exports.FSEVENT_CLONED = 'cloned';\n  exports.FSEVENT_UNKNOWN = 'unknown';\n  exports.FSEVENT_TYPE_FILE = 'file';\n  exports.FSEVENT_TYPE_DIRECTORY = 'directory';\n  exports.FSEVENT_TYPE_SYMLINK = 'symlink';\n  exports.KEY_LISTENERS = 'listeners';\n  exports.KEY_ERR = 'errHandlers';\n  exports.KEY_RAW = 'rawEmitters';\n  exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n  exports.DOT_SLASH = `.${sep}`;\n  exports.BACK_SLASH_RE = /\\\\/g;\n  exports.DOUBLE_SLASH_RE = /\\/\\//;\n  exports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\n  exports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n  exports.REPLACER_RE = /^\\.[/\\\\]/;\n  exports.SLASH = '/';\n  exports.SLASH_SLASH = '//';\n  exports.BRACE_START = '{';\n  exports.BANG = '!';\n  exports.ONE_DOT = '.';\n  exports.TWO_DOTS = '..';\n  exports.STAR = '*';\n  exports.GLOBSTAR = '**';\n  exports.ROOT_GLOBSTAR = '/**/*';\n  exports.SLASH_GLOBSTAR = '/**';\n  exports.DIR_SUFFIX = 'Dir';\n  exports.ANYMATCH_OPTS = {\n    dot: true\n  };\n  exports.STRING_TYPE = 'string';\n  exports.FUNCTION_TYPE = 'function';\n  exports.EMPTY_STR = '';\n\n  exports.EMPTY_FN = () => {};\n\n  exports.IDENTITY_FN = val => val;\n\n  exports.isWindows = platform === 'win32';\n  exports.isMacos = platform === 'darwin';\n  exports.isLinux = platform === 'linux';\n  exports.isIBMi = os.type() === 'OS400';\n})(constants);\n\nconst fs$2 = require$$0$1;\nconst sysPath$2 = require$$0$2;\nconst {\n  promisify: promisify$2\n} = require$$2;\nconst isBinaryPath = isBinaryPath$1;\nconst {\n  isWindows: isWindows$1,\n  isLinux,\n  EMPTY_FN: EMPTY_FN$2,\n  EMPTY_STR: EMPTY_STR$1,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE: EV_CHANGE$2,\n  EV_ADD: EV_ADD$2,\n  EV_ADD_DIR: EV_ADD_DIR$2,\n  EV_ERROR: EV_ERROR$2,\n  STR_DATA: STR_DATA$1,\n  STR_END: STR_END$2,\n  BRACE_START: BRACE_START$1,\n  STAR\n} = constants;\nconst THROTTLE_MODE_WATCH = 'watch';\nconst open = promisify$2(fs$2.open);\nconst stat$2 = promisify$2(fs$2.stat);\nconst lstat$1 = promisify$2(fs$2.lstat);\nconst close = promisify$2(fs$2.close);\nconst fsrealpath = promisify$2(fs$2.realpath);\nconst statMethods$1 = {\n  lstat: lstat$1,\n  stat: stat$2\n}; // TODO: emit errors properly. Example: EMFILE on Macos.\n\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = val => val instanceof Set ? val.size === 0 : !val;\n/**\n * @typedef {String} Path\n */\n// fs_watch helpers\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\n\n\nconst FsWatchInstances = new Map();\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\n\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {\n      watchedPath: path\n    }); // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(sysPath$2.resolve(path, evPath), KEY_LISTENERS, sysPath$2.join(path, evPath));\n    }\n  };\n\n  try {\n    return fs$2.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\n\n\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], listener => {\n    listener(val1, val2, val3);\n  });\n};\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\n\n\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    errHandler,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n  /** @type {fs.FSWatcher=} */\n\n  let watcher;\n\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n    return watcher.close.bind(watcher);\n  }\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here\n    fsWatchBroadcast.bind(null, fullPath, KEY_RAW));\n    if (!watcher) return;\n    watcher.on(EV_ERROR$2, async error => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n\n      if (isWindows$1 && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  } // const index = cont.listeners.indexOf(listener);\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n\n\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close(); // }\n\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n}; // fs_watchFile helpers\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\n\n\nconst FsWatchFileInstances = new Map();\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\n\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n  const copts = cont && cont.options;\n\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    fs$2.unwatchFile(fullPath);\n    cont = undefined;\n  }\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs$2.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, rawEmitter => {\n          rawEmitter(EV_CHANGE$2, fullPath, {\n            curr,\n            prev\n          });\n        });\n        const currmtime = curr.mtimeMs;\n\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, listener => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  } // const index = cont.listeners.indexOf(listener);\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n\n\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs$2.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n/**\n * @mixin\n */\n\n\nclass NodeFsHandler$1 {\n  /**\n   * @param {import(\"../index\").FSWatcher} fsW\n   */\n  constructor(fsW) {\n    this.fsw = fsW;\n\n    this._boundHandleError = error => fsW._handleError(error);\n  }\n  /**\n   * Watch file for changes with fs_watchFile or fs_watch.\n   * @param {String} path to file or dir\n   * @param {Function} listener on fs change\n   * @returns {Function} closer for the watcher instance\n   */\n\n\n  _watchWithNodeFs(path, listener) {\n    const opts = this.fsw.options;\n    const directory = sysPath$2.dirname(path);\n    const basename = sysPath$2.basename(path);\n\n    const parent = this.fsw._getWatchedDir(directory);\n\n    parent.add(basename);\n    const absolutePath = sysPath$2.resolve(path);\n    const options = {\n      persistent: opts.persistent\n    };\n    if (!listener) listener = EMPTY_FN$2;\n    let closer;\n\n    if (opts.usePolling) {\n      options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;\n      closer = setFsWatchFileListener(path, absolutePath, options, {\n        listener,\n        rawEmitter: this.fsw._emitRaw\n      });\n    } else {\n      closer = setFsWatchListener(path, absolutePath, options, {\n        listener,\n        errHandler: this._boundHandleError,\n        rawEmitter: this.fsw._emitRaw\n      });\n    }\n\n    return closer;\n  }\n  /**\n   * Watch a file and emit add event if warranted.\n   * @param {Path} file Path\n   * @param {fs.Stats} stats result of fs_stat\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @returns {Function} closer for the watcher instance\n   */\n\n\n  _handleFile(file, stats, initialAdd) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const dirname = sysPath$2.dirname(file);\n    const basename = sysPath$2.basename(file);\n\n    const parent = this.fsw._getWatchedDir(dirname); // stats is always present\n\n\n    let prevStats = stats; // if the file is already being watched, do nothing\n\n    if (parent.has(basename)) return;\n\n    const listener = async (path, newStats) => {\n      if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n\n      if (!newStats || newStats.mtimeMs === 0) {\n        try {\n          const newStats = await stat$2(file);\n          if (this.fsw.closed) return; // Check that change event was not fired because of changed only accessTime.\n\n          const at = newStats.atimeMs;\n          const mt = newStats.mtimeMs;\n\n          if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n            this.fsw._emit(EV_CHANGE$2, file, newStats);\n          }\n\n          if (isLinux && prevStats.ino !== newStats.ino) {\n            this.fsw._closeFile(path);\n\n            prevStats = newStats;\n\n            this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n          } else {\n            prevStats = newStats;\n          }\n        } catch (error) {\n          // Fix issues where mtime is null but file is still present\n          this.fsw._remove(dirname, basename);\n        } // add is about to be emitted if file not already tracked in parent\n\n      } else if (parent.has(basename)) {\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE$2, file, newStats);\n        }\n\n        prevStats = newStats;\n      }\n    }; // kick off the watcher\n\n\n    const closer = this._watchWithNodeFs(file, listener); // emit an add event if we're supposed to\n\n\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n      if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;\n\n      this.fsw._emit(EV_ADD$2, file, stats);\n    }\n\n    return closer;\n  }\n  /**\n   * Handle symlinks encountered while reading a dir.\n   * @param {Object} entry returned by readdirp\n   * @param {String} directory path of dir being read\n   * @param {String} path of this item\n   * @param {String} item basename of this item\n   * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n   */\n\n\n  async _handleSymlink(entry, directory, path, item) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const full = entry.fullPath;\n\n    const dir = this.fsw._getWatchedDir(directory);\n\n    if (!this.fsw.options.followSymlinks) {\n      // watch symlink directly (don't follow) and detect changes\n      this.fsw._incrReadyCount();\n\n      let linkPath;\n\n      try {\n        linkPath = await fsrealpath(path);\n      } catch (e) {\n        this.fsw._emitReady();\n\n        return true;\n      }\n\n      if (this.fsw.closed) return;\n\n      if (dir.has(item)) {\n        if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n          this.fsw._symlinkPaths.set(full, linkPath);\n\n          this.fsw._emit(EV_CHANGE$2, path, entry.stats);\n        }\n      } else {\n        dir.add(item);\n\n        this.fsw._symlinkPaths.set(full, linkPath);\n\n        this.fsw._emit(EV_ADD$2, path, entry.stats);\n      }\n\n      this.fsw._emitReady();\n\n      return true;\n    } // don't follow the same symlink more than once\n\n\n    if (this.fsw._symlinkPaths.has(full)) {\n      return true;\n    }\n\n    this.fsw._symlinkPaths.set(full, true);\n  }\n\n  _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n    // Normalize the directory name on Windows\n    directory = sysPath$2.join(directory, EMPTY_STR$1);\n\n    if (!wh.hasGlob) {\n      throttler = this.fsw._throttle('readdir', directory, 1000);\n      if (!throttler) return;\n    }\n\n    const previous = this.fsw._getWatchedDir(wh.path);\n\n    const current = new Set();\n\n    let stream = this.fsw._readdirp(directory, {\n      fileFilter: entry => wh.filterPath(entry),\n      directoryFilter: entry => wh.filterDir(entry),\n      depth: 0\n    }).on(STR_DATA$1, async entry => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n\n      const item = entry.path;\n      let path = sysPath$2.join(directory, item);\n      current.add(item);\n\n      if (entry.stats.isSymbolicLink() && (await this._handleSymlink(entry, directory, path, item))) {\n        return;\n      }\n\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      } // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n\n\n      if (item === target || !target && !previous.has(item)) {\n        this.fsw._incrReadyCount(); // ensure relativeness of path is preserved in case of watcher reuse\n\n\n        path = sysPath$2.join(dir, sysPath$2.relative(dir, path));\n\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }).on(EV_ERROR$2, this._boundHandleError);\n\n    return new Promise(resolve => stream.once(STR_END$2, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n\n      const wasThrottled = throttler ? throttler.clear() : false;\n      resolve(); // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n\n      previous.getChildren().filter(item => {\n        return item !== directory && !current.has(item) && ( // in case of intersecting globs;\n        // a path may have been filtered out of this readdir, but\n        // shouldn't be removed because it matches a different glob\n        !wh.hasGlob || wh.filterPath({\n          fullPath: sysPath$2.resolve(directory, item)\n        }));\n      }).forEach(item => {\n        this.fsw._remove(directory, item);\n      });\n      stream = undefined; // one more time for any missed in case changes came in extremely quickly\n\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    }));\n  }\n  /**\n   * Read directory to add / remove files from `@watched` list and re-read it on change.\n   * @param {String} dir fs path\n   * @param {fs.Stats} stats\n   * @param {Boolean} initialAdd\n   * @param {Number} depth relative to user-supplied path\n   * @param {String} target child path targeted for watch\n   * @param {Object} wh Common watch helpers for this path\n   * @param {String} realpath\n   * @returns {Promise<Function>} closer for the watcher instance.\n   */\n\n\n  async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n    const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));\n\n    const tracked = parentDir.has(sysPath$2.basename(dir));\n\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n      if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);\n    } // ensure dir is tracked (harmless if redundant)\n\n\n    parentDir.add(sysPath$2.basename(dir));\n\n    this.fsw._getWatchedDir(dir);\n\n    let throttler;\n    let closer;\n    const oDepth = this.fsw.options.depth;\n\n    if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n      if (!target) {\n        await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n        if (this.fsw.closed) return;\n      }\n\n      closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n        // if current directory is removed, do nothing\n        if (stats && stats.mtimeMs === 0) return;\n\n        this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n      });\n    }\n\n    return closer;\n  }\n  /**\n   * Handle added file, directory, or glob pattern.\n   * Delegates call to _handleFile / _handleDir after checks.\n   * @param {String} path to file or ir\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @param {Object} priorWh depth relative to user-supplied path\n   * @param {Number} depth Child path actually targeted for watch\n   * @param {String=} target Child path actually targeted for watch\n   * @returns {Promise}\n   */\n\n\n  async _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n    const ready = this.fsw._emitReady;\n\n    if (this.fsw._isIgnored(path) || this.fsw.closed) {\n      ready();\n      return false;\n    }\n\n    const wh = this.fsw._getWatchHelpers(path, depth);\n\n    if (!wh.hasGlob && priorWh) {\n      wh.hasGlob = priorWh.hasGlob;\n      wh.globFilter = priorWh.globFilter;\n\n      wh.filterPath = entry => priorWh.filterPath(entry);\n\n      wh.filterDir = entry => priorWh.filterDir(entry);\n    } // evaluate what is at the path we're being asked to watch\n\n\n    try {\n      const stats = await statMethods$1[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        ready();\n        return false;\n      }\n\n      const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START$1);\n      let closer;\n\n      if (stats.isDirectory()) {\n        const absPath = sysPath$2.resolve(path);\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n        if (this.fsw.closed) return; // preserve this symlink's target path\n\n        if (absPath !== targetPath && targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(absPath, targetPath);\n        }\n      } else if (stats.isSymbolicLink()) {\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        const parent = sysPath$2.dirname(wh.watchPath);\n\n        this.fsw._getWatchedDir(parent).add(wh.watchPath);\n\n        this.fsw._emit(EV_ADD$2, wh.watchPath, stats);\n\n        closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n        if (this.fsw.closed) return; // preserve this symlink's target path\n\n        if (targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(sysPath$2.resolve(path), targetPath);\n        }\n      } else {\n        closer = this._handleFile(wh.watchPath, stats, initialAdd);\n      }\n\n      ready();\n\n      this.fsw._addPathCloser(path, closer);\n\n      return false;\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        ready();\n        return path;\n      }\n    }\n  }\n\n}\n\nvar nodefsHandler = NodeFsHandler$1;\nvar fseventsHandler = {\n  exports: {}\n};\nconst require$$3 = /*@__PURE__*/getAugmentedNamespace(fseventsImporter);\nconst fs$1 = require$$0$1;\nconst sysPath$1 = require$$0$2;\nconst {\n  promisify: promisify$1\n} = require$$2;\nlet fsevents;\n\ntry {\n  fsevents = require$$3.getFsEvents();\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD: EV_ADD$1,\n  EV_CHANGE: EV_CHANGE$1,\n  EV_ADD_DIR: EV_ADD_DIR$1,\n  EV_UNLINK: EV_UNLINK$1,\n  EV_ERROR: EV_ERROR$1,\n  STR_DATA,\n  STR_END: STR_END$1,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE: FUNCTION_TYPE$1,\n  EMPTY_FN: EMPTY_FN$1,\n  IDENTITY_FN\n} = constants;\n\nconst Depth = value => isNaN(value) ? {} : {\n  depth: value\n};\n\nconst stat$1 = promisify$1(fs$1.stat);\nconst lstat = promisify$1(fs$1.lstat);\nconst realpath = promisify$1(fs$1.realpath);\nconst statMethods = {\n  stat: stat$1,\n  lstat\n};\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n// fsevents instance helper functions\n\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\n\nconst FSEventsWatchers = new Map(); // Threshold of duplicate path prefixes at which to start\n// consolidating going forward\n\nconst consolidateThreshhold = 10;\nconst wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\n\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {\n    stop\n  };\n};\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\n\n\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;\n  const parentPath = sysPath$1.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath); // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath$1.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep)) listener(fullPath, flags, info);\n  }; // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n\n\n  let watchedParent = false;\n\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  } // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n\n\n  return () => {\n    const lst = cont.listeners;\n    lst.delete(filteredListener);\n\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n} // Decide whether or not we should start a new higher-level\n// parent watcher\n\n\nconst couldConsolidate = path => {\n  let count = 0;\n\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // returns boolean indicating whether fsevents can be used\n\n\nconst canUse = () => fsevents && FSEventsWatchers.size < 128; // determines subdirectory traversal levels from root to path\n\n\nconst calcDepth = (path, root) => {\n  let i = 0;\n\n  while (!path.indexOf(root) && (path = sysPath$1.dirname(path)) !== root) i++;\n\n  return i;\n}; // returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\n\n\nconst sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();\n/**\n * @mixin\n */\n\n\nclass FsEventsHandler$1 {\n  /**\n   * @param {import('../index').FSWatcher} fsw\n   */\n  constructor(fsw) {\n    this.fsw = fsw;\n  }\n\n  checkIgnored(path, stats) {\n    const ipaths = this.fsw._ignoredPaths;\n\n    if (this.fsw._isIgnored(path, stats)) {\n      ipaths.add(path);\n\n      if (stats && stats.isDirectory()) {\n        ipaths.add(path + ROOT_GLOBSTAR);\n      }\n\n      return true;\n    }\n\n    ipaths.delete(path);\n    ipaths.delete(path + ROOT_GLOBSTAR);\n  }\n\n  addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;\n    this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n  }\n\n  async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    try {\n      const stats = await stat$1(path);\n      if (this.fsw.closed) return;\n\n      if (sameTypes(info, stats)) {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } catch (error) {\n      if (error.code === 'EACCES') {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  }\n\n  handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    if (this.fsw.closed || this.checkIgnored(path)) return;\n\n    if (event === EV_UNLINK$1) {\n      const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY; // suppress unlink events on never before seen files\n\n      if (isDirectory || watchedDir.has(item)) {\n        this.fsw._remove(parent, item, isDirectory);\n      }\n    } else {\n      if (event === EV_ADD$1) {\n        // track new directories\n        if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n        if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n          // push symlinks back to the top of the stack to get handled\n          const curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;\n          return this._addToFsEvents(path, false, true, curDepth);\n        } // track new paths\n        // (other than symlinks being followed, which will be tracked soon)\n\n\n        this.fsw._getWatchedDir(parent).add(item);\n      }\n      /**\n       * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n       */\n\n\n      const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n\n      this.fsw._emit(eventName, path);\n\n      if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);\n    }\n  }\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} watchPath  - file/dir path to be watched with fsevents\n   * @param {String} realPath   - real path (in case of symlinks)\n   * @param {Function} transform  - path transformer\n   * @param {Function} globFilter - path filter in case a glob pattern was provided\n   * @returns {Function} closer for the watcher instance\n  */\n\n\n  _watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n    if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n    const opts = this.fsw.options;\n\n    const watchCallback = async (fullPath, flags, info) => {\n      if (this.fsw.closed) return;\n      if (opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth) return;\n      const path = transform(sysPath$1.join(watchPath, sysPath$1.relative(watchPath, fullPath)));\n      if (globFilter && !globFilter(path)) return; // ensure directories are tracked\n\n      const parent = sysPath$1.dirname(path);\n      const item = sysPath$1.basename(path);\n\n      const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent); // correct for wrong events emitted\n\n\n      if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n        if (typeof opts.ignored === FUNCTION_TYPE$1) {\n          let stats;\n\n          try {\n            stats = await stat$1(path);\n          } catch (error) {}\n\n          if (this.fsw.closed) return;\n          if (this.checkIgnored(path, stats)) return;\n\n          if (sameTypes(info, stats)) {\n            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          } else {\n            this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          }\n        } else {\n          this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        switch (info.event) {\n          case FSEVENT_CREATED:\n          case FSEVENT_MODIFIED:\n            return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\n          case FSEVENT_DELETED:\n          case FSEVENT_MOVED:\n            return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      }\n    };\n\n    const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);\n\n    this.fsw._emitReady();\n\n    return closer;\n  }\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} linkPath path to symlink\n   * @param {String} fullPath absolute path to the symlink\n   * @param {Function} transform pre-existing path transformer\n   * @param {Number} curDepth level of subdirectories traversed to where symlink is\n   * @returns {Promise<void>}\n   */\n\n\n  async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n    // don't follow the same symlink more than once\n    if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n    this.fsw._symlinkPaths.set(fullPath, true);\n\n    this.fsw._incrReadyCount();\n\n    try {\n      const linkTarget = await realpath(linkPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(linkTarget)) {\n        return this.fsw._emitReady();\n      }\n\n      this.fsw._incrReadyCount(); // add the linkTarget for watching with a wrapper for transform\n      // that causes emitted paths to incorporate the link's path\n\n\n      this._addToFsEvents(linkTarget || linkPath, path => {\n        let aliasedPath = linkPath;\n\n        if (linkTarget && linkTarget !== DOT_SLASH) {\n          aliasedPath = path.replace(linkTarget, linkPath);\n        } else if (path !== DOT_SLASH) {\n          aliasedPath = sysPath$1.join(linkPath, path);\n        }\n\n        return transform(aliasedPath);\n      }, false, curDepth);\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        return this.fsw._emitReady();\n      }\n    }\n  }\n  /**\n   *\n   * @param {Path} newPath\n   * @param {fs.Stats} stats\n   */\n\n\n  emitAdd(newPath, stats, processPath, opts, forceAdd) {\n    const pp = processPath(newPath);\n    const isDir = stats.isDirectory();\n\n    const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));\n\n    const base = sysPath$1.basename(pp); // ensure empty dirs get tracked\n\n    if (isDir) this.fsw._getWatchedDir(pp);\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n\n    if (!opts.ignoreInitial || forceAdd === true) {\n      this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);\n    }\n  }\n\n  initWatch(realPath, path, wh, processPath) {\n    if (this.fsw.closed) return;\n\n    const closer = this._watchWithFsEvents(wh.watchPath, sysPath$1.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n\n    this.fsw._addPathCloser(path, closer);\n  }\n  /**\n   * Handle added path with fsevents\n   * @param {String} path file/dir path or glob pattern\n   * @param {Function|Boolean=} transform converts working path to what the user expects\n   * @param {Boolean=} forceAdd ensure add is emitted\n   * @param {Number=} priorDepth Level of subdirectories already traversed.\n   * @returns {Promise<void>}\n   */\n\n\n  async _addToFsEvents(path, transform, forceAdd, priorDepth) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const opts = this.fsw.options;\n    const processPath = typeof transform === FUNCTION_TYPE$1 ? transform : IDENTITY_FN;\n\n    const wh = this.fsw._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch\n\n\n    try {\n      const stats = await statMethods[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        throw null;\n      }\n\n      if (stats.isDirectory()) {\n        // emit addDir unless this is a glob parent\n        if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd); // don't recurse further if it would exceed depth setting\n\n        if (priorDepth && priorDepth > opts.depth) return; // scan the contents of the dir\n\n        this.fsw._readdirp(wh.watchPath, {\n          fileFilter: entry => wh.filterPath(entry),\n          directoryFilter: entry => wh.filterDir(entry),\n          ...Depth(opts.depth - (priorDepth || 0))\n        }).on(STR_DATA, entry => {\n          // need to check filterPath on dirs b/c filterDir is less restrictive\n          if (this.fsw.closed) {\n            return;\n          }\n\n          if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n          const joinedPath = sysPath$1.join(wh.watchPath, entry.path);\n          const {\n            fullPath\n          } = entry;\n\n          if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n            // preserve the current depth here since it can't be derived from\n            // real paths past the symlink\n            const curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;\n\n            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n          } else {\n            this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n          }\n        }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {\n          this.fsw._emitReady();\n        });\n      } else {\n        this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n\n        this.fsw._emitReady();\n      }\n    } catch (error) {\n      if (!error || this.fsw._handleError(error)) {\n        // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n        this.fsw._emitReady();\n\n        this.fsw._emitReady();\n      }\n    }\n\n    if (opts.persistent && forceAdd !== true) {\n      if (typeof transform === FUNCTION_TYPE$1) {\n        // realpath has already been resolved\n        this.initWatch(undefined, path, wh, processPath);\n      } else {\n        let realPath;\n\n        try {\n          realPath = await realpath(wh.watchPath);\n        } catch (e) {}\n\n        this.initWatch(realPath, path, wh, processPath);\n      }\n    }\n  }\n\n}\n\nfseventsHandler.exports = FsEventsHandler$1;\nfseventsHandler.exports.canUse = canUse;\nconst {\n  EventEmitter\n} = require$$0$3;\nconst fs = require$$0$1;\nconst sysPath = require$$0$2;\nconst {\n  promisify\n} = require$$2;\nconst readdirp = readdirp_1;\nconst anymatch = anymatch$2.exports.default;\nconst globParent = globParent$1;\nconst isGlob = isGlob$2;\nconst braces = braces_1;\nconst normalizePath = normalizePath$2;\nconst NodeFsHandler = nodefsHandler;\nconst FsEventsHandler = fseventsHandler.exports;\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n  STR_CLOSE,\n  STR_END,\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n  isWindows,\n  isMacos,\n  isIBMi\n} = constants;\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = function () {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return Array.isArray(value) ? value : [value];\n};\n\nconst flatten = function (list) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = paths_ => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n\n  return paths.map(normalizePathToUnix);\n}; // If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\n\n\nconst toUnix = string => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n\n  if (prepend) {\n    str = SLASH + str;\n  }\n\n  return str;\n}; // Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\n\n\nconst normalizePathToUnix = path => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = function () {\n  let cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_STR;\n  return path => {\n    if (typeof path !== STRING_TYPE) return path;\n    return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n  };\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\n\n\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n    const dir = this.path;\n\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return items.has(item);\n  }\n  /**\n   * @returns {Array<String>}\n   */\n\n\n  getChildren() {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\n\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach(parts => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {\n        realPath: entry.fullParentDir,\n        linkPath: this.fullWatchPath\n      };\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));\n  }\n\n  filterPath(entry) {\n    const {\n      stats\n    } = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;\n    return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach(path => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some(parts => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n\n}\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\n\n\nclass FSWatcher extends EventEmitter {\n  // Not indenting methods for history sake; for now.\n  constructor(_opts) {\n    var _this;\n\n    super();\n    _this = this;\n    const opts = {};\n    if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n    /** @type {Map<String, DirEntry>} */\n\n    this._watched = new Map();\n    /** @type {Map<String, Array>} */\n\n    this._closers = new Map();\n    /** @type {Set<String>} */\n\n    this._ignoredPaths = new Set();\n    /** @type {Map<ThrottleType, Map>} */\n\n    this._throttled = new Map();\n    /** @type {Map<Path, String|Boolean>} */\n\n    this._symlinkPaths = new Map();\n    this._streams = new Set();\n    this.closed = false; // Set up default options.\n\n    if (undef(opts, 'persistent')) opts.persistent = true;\n    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n    if (undef(opts, 'interval')) opts.interval = 100;\n    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.\n\n    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.\n\n    const canUseFsEvents = FsEventsHandler.canUse();\n    if (!canUseFsEvents) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.\n    // Other platforms use non-polling fs_watch.\n\n    if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n      opts.usePolling = isMacos;\n    } // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n\n\n    if (isIBMi) {\n      opts.usePolling = true;\n    } // Global override (useful for end-developers that need to force polling for all\n    // instances of chokidar, regardless of usage/dependency depth)\n\n\n    const envPoll = process.env.CHOKIDAR_USEPOLLING;\n\n    if (envPoll !== undefined) {\n      const envLower = envPoll.toLowerCase();\n\n      if (envLower === 'false' || envLower === '0') {\n        opts.usePolling = false;\n      } else if (envLower === 'true' || envLower === '1') {\n        opts.usePolling = true;\n      } else {\n        opts.usePolling = !!envLower;\n      }\n    }\n\n    const envInterval = process.env.CHOKIDAR_INTERVAL;\n\n    if (envInterval) {\n      opts.interval = Number.parseInt(envInterval, 10);\n    } // Editor atomic write normalization enabled by default with fs.watch\n\n\n    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n    if (opts.atomic) this._pendingUnlinks = new Map();\n    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n    const awf = opts.awaitWriteFinish;\n\n    if (awf) {\n      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n      if (!awf.pollInterval) awf.pollInterval = 100;\n      this._pendingWrites = new Map();\n    }\n\n    if (opts.ignored) opts.ignored = arrify(opts.ignored);\n    let readyCalls = 0;\n\n    this._emitReady = () => {\n      readyCalls++;\n\n      if (readyCalls >= this._readyCount) {\n        this._emitReady = EMPTY_FN;\n        this._readyEmitted = true; // use process.nextTick to allow time for listener to be bound\n\n        process.nextTick(() => this.emit(EV_READY));\n      }\n    };\n\n    this._emitRaw = function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _this.emit(EV_RAW, ...args);\n    };\n\n    this._readyEmitted = false;\n    this.options = opts; // Initialize with proper watcher.\n\n    if (opts.useFsEvents) {\n      this._fsEventsHandler = new FsEventsHandler(this);\n    } else {\n      this._nodeFsHandler = new NodeFsHandler(this);\n    } // You’re frozen when your heart’s not open.\n\n\n    Object.freeze(opts);\n  } // Public methods\n\n  /**\n   * Adds paths to be watched on an existing FSWatcher instance\n   * @param {Path|Array<Path>} paths_\n   * @param {String=} _origAdd private; for handling non-existent paths to be watched\n   * @param {Boolean=} _internal private; indicates a non-user add\n   * @returns {FSWatcher} for chaining\n   */\n\n\n  add(paths_, _origAdd, _internal) {\n    const {\n      cwd,\n      disableGlobbing\n    } = this.options;\n    this.closed = false;\n    let paths = unifyPaths(paths_);\n\n    if (cwd) {\n      paths = paths.map(path => {\n        const absPath = getAbsolutePath(path, cwd); // Check `path` instead of `absPath` because the cwd portion can't be a glob\n\n        if (disableGlobbing || !isGlob(path)) {\n          return absPath;\n        }\n\n        return normalizePath(absPath);\n      });\n    } // set aside negated glob strings\n\n\n    paths = paths.filter(path => {\n      if (path.startsWith(BANG)) {\n        this._ignoredPaths.add(path.slice(1));\n\n        return false;\n      } // if a path is being added that was previously ignored, stop ignoring it\n\n\n      this._ignoredPaths.delete(path);\n\n      this._ignoredPaths.delete(path + SLASH_GLOBSTAR); // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n\n\n      this._userIgnored = undefined;\n      return true;\n    });\n\n    if (this.options.useFsEvents && this._fsEventsHandler) {\n      if (!this._readyCount) this._readyCount = paths.length;\n      if (this.options.persistent) this._readyCount *= 2;\n      paths.forEach(path => this._fsEventsHandler._addToFsEvents(path));\n    } else {\n      if (!this._readyCount) this._readyCount = 0;\n      this._readyCount += paths.length;\n      Promise.all(paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })).then(results => {\n        if (this.closed) return;\n        results.filter(item => item).forEach(item => {\n          this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n        });\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Close watchers or start ignoring events from specified paths.\n   * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n   * @returns {FSWatcher} for chaining\n  */\n\n\n  unwatch(paths_) {\n    if (this.closed) return this;\n    const paths = unifyPaths(paths_);\n    const {\n      cwd\n    } = this.options;\n    paths.forEach(path => {\n      // convert to absolute path unless relative path already matches\n      if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n        if (cwd) path = sysPath.join(cwd, path);\n        path = sysPath.resolve(path);\n      }\n\n      this._closePath(path);\n\n      this._ignoredPaths.add(path);\n\n      if (this._watched.has(path)) {\n        this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n      } // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n\n\n      this._userIgnored = undefined;\n    });\n    return this;\n  }\n  /**\n   * Close watchers and remove all listeners from watched paths.\n   * @returns {Promise<void>}.\n  */\n\n\n  close() {\n    if (this.closed) return this._closePromise;\n    this.closed = true; // Memory management.\n\n    this.removeAllListeners();\n    const closers = [];\n\n    this._closers.forEach(closerList => closerList.forEach(closer => {\n      const promise = closer();\n      if (promise instanceof Promise) closers.push(promise);\n    }));\n\n    this._streams.forEach(stream => stream.destroy());\n\n    this._userIgnored = undefined;\n    this._readyCount = 0;\n    this._readyEmitted = false;\n\n    this._watched.forEach(dirent => dirent.dispose());\n\n    ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n      this[`_${key}`].clear();\n    });\n    this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n    return this._closePromise;\n  }\n  /**\n   * Expose list of watched paths\n   * @returns {Object} for chaining\n  */\n\n\n  getWatched() {\n    const watchList = {};\n\n    this._watched.forEach((entry, dir) => {\n      const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n      watchList[key || ONE_DOT] = entry.getChildren().sort();\n    });\n\n    return watchList;\n  }\n\n  emitWithAll(event, args) {\n    this.emit(...args);\n    if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n  } // Common helpers\n  // --------------\n\n  /**\n   * Normalize and emit events.\n   * Calling _emit DOES NOT MEAN emit() would be called!\n   * @param {EventName} event Type of event\n   * @param {Path} path File or directory path\n   * @param {*=} val1 arguments to be passed with event\n   * @param {*=} val2\n   * @param {*=} val3\n   * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n\n\n  async _emit(event, path, val1, val2, val3) {\n    if (this.closed) return;\n    const opts = this.options;\n    if (isWindows) path = sysPath.normalize(path);\n    if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n    /** @type Array<any> */\n\n    const args = [event, path];\n    if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n    const awf = opts.awaitWriteFinish;\n    let pw;\n\n    if (awf && (pw = this._pendingWrites.get(path))) {\n      pw.lastChange = new Date();\n      return this;\n    }\n\n    if (opts.atomic) {\n      if (event === EV_UNLINK) {\n        this._pendingUnlinks.set(path, args);\n\n        setTimeout(() => {\n          this._pendingUnlinks.forEach((entry, path) => {\n            this.emit(...entry);\n            this.emit(EV_ALL, ...entry);\n\n            this._pendingUnlinks.delete(path);\n          });\n        }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n        return this;\n      }\n\n      if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n        event = args[0] = EV_CHANGE;\n\n        this._pendingUnlinks.delete(path);\n      }\n    }\n\n    if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n      const awfEmit = (err, stats) => {\n        if (err) {\n          event = args[0] = EV_ERROR;\n          args[1] = err;\n          this.emitWithAll(event, args);\n        } else if (stats) {\n          // if stats doesn't exist the file must have been deleted\n          if (args.length > 2) {\n            args[2] = stats;\n          } else {\n            args.push(stats);\n          }\n\n          this.emitWithAll(event, args);\n        }\n      };\n\n      this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n\n      return this;\n    }\n\n    if (event === EV_CHANGE) {\n      const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n      if (isThrottled) return this;\n    }\n\n    if (opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {\n      const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n      let stats;\n\n      try {\n        stats = await stat(fullPath);\n      } catch (err) {} // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n\n\n      if (!stats || this.closed) return;\n      args.push(stats);\n    }\n\n    this.emitWithAll(event, args);\n    return this;\n  }\n  /**\n   * Common handler for errors\n   * @param {Error} error\n   * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n\n\n  _handleError(error) {\n    const code = error && error.code;\n\n    if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {\n      this.emit(EV_ERROR, error);\n    }\n\n    return error || this.closed;\n  }\n  /**\n   * Helper utility for throttling\n   * @param {ThrottleType} actionType type being throttled\n   * @param {Path} path being acted upon\n   * @param {Number} timeout duration of time to suppress duplicate actions\n   * @returns {Object|false} tracking object or false if action should be suppressed\n   */\n\n\n  _throttle(actionType, path, timeout) {\n    if (!this._throttled.has(actionType)) {\n      this._throttled.set(actionType, new Map());\n    }\n    /** @type {Map<Path, Object>} */\n\n\n    const action = this._throttled.get(actionType);\n    /** @type {Object} */\n\n\n    const actionPath = action.get(path);\n\n    if (actionPath) {\n      actionPath.count++;\n      return false;\n    }\n\n    let timeoutObject;\n\n    const clear = () => {\n      const item = action.get(path);\n      const count = item ? item.count : 0;\n      action.delete(path);\n      clearTimeout(timeoutObject);\n      if (item) clearTimeout(item.timeoutObject);\n      return count;\n    };\n\n    timeoutObject = setTimeout(clear, timeout);\n    const thr = {\n      timeoutObject,\n      clear,\n      count: 0\n    };\n    action.set(path, thr);\n    return thr;\n  }\n\n  _incrReadyCount() {\n    return this._readyCount++;\n  }\n  /**\n   * Awaits write operation to finish.\n   * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n   * @param {Path} path being acted upon\n   * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n   * @param {EventName} event\n   * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n   */\n\n\n  _awaitWriteFinish(path, threshold, event, awfEmit) {\n    let timeoutHandler;\n    let fullPath = path;\n\n    if (this.options.cwd && !sysPath.isAbsolute(path)) {\n      fullPath = sysPath.join(this.options.cwd, path);\n    }\n\n    const now = new Date();\n\n    const awaitWriteFinish = prevStat => {\n      fs.stat(fullPath, (err, curStat) => {\n        if (err || !this._pendingWrites.has(path)) {\n          if (err && err.code !== 'ENOENT') awfEmit(err);\n          return;\n        }\n\n        const now = Number(new Date());\n\n        if (prevStat && curStat.size !== prevStat.size) {\n          this._pendingWrites.get(path).lastChange = now;\n        }\n\n        const pw = this._pendingWrites.get(path);\n\n        const df = now - pw.lastChange;\n\n        if (df >= threshold) {\n          this._pendingWrites.delete(path);\n\n          awfEmit(undefined, curStat);\n        } else {\n          timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);\n        }\n      });\n    };\n\n    if (!this._pendingWrites.has(path)) {\n      this._pendingWrites.set(path, {\n        lastChange: now,\n        cancelWait: () => {\n          this._pendingWrites.delete(path);\n\n          clearTimeout(timeoutHandler);\n          return event;\n        }\n      });\n\n      timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);\n    }\n  }\n\n  _getGlobIgnored() {\n    return [...this._ignoredPaths.values()];\n  }\n  /**\n   * Determines whether user has asked to ignore this path.\n   * @param {Path} path filepath or dir\n   * @param {fs.Stats=} stats result of fs.stat\n   * @returns {Boolean}\n   */\n\n\n  _isIgnored(path, stats) {\n    if (this.options.atomic && DOT_RE.test(path)) return true;\n\n    if (!this._userIgnored) {\n      const {\n        cwd\n      } = this.options;\n      const ign = this.options.ignored;\n      const ignored = ign && ign.map(normalizeIgnored(cwd));\n      const paths = arrify(ignored).filter(path => typeof path === STRING_TYPE && !isGlob(path)).map(path => path + SLASH_GLOBSTAR);\n\n      const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n\n      this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n    }\n\n    return this._userIgnored([path, stats]);\n  }\n\n  _isntIgnored(path, stat) {\n    return !this._isIgnored(path, stat);\n  }\n  /**\n   * Provides a set of common helpers and properties relating to symlink and glob handling.\n   * @param {Path} path file, directory, or glob pattern being watched\n   * @param {Number=} depth at any depth > 0, this isn't a glob\n   * @returns {WatchHelper} object containing helpers for this path\n   */\n\n\n  _getWatchHelpers(path, depth) {\n    const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n    const follow = this.options.followSymlinks;\n    return new WatchHelper(path, watchPath, follow, this);\n  } // Directory helpers\n  // -----------------\n\n  /**\n   * Provides directory tracking objects\n   * @param {String} directory path of the directory\n   * @returns {DirEntry} the directory's tracking object\n   */\n\n\n  _getWatchedDir(directory) {\n    if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n    const dir = sysPath.resolve(directory);\n    if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n    return this._watched.get(dir);\n  } // File helpers\n  // ------------\n\n  /**\n   * Check for read permissions.\n   * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n   * @param {fs.Stats} stats - object, result of fs_stat\n   * @returns {Boolean} indicates whether the file can be read\n  */\n\n\n  _hasReadPermissions(stats) {\n    if (this.options.ignorePermissionErrors) return true; // stats.mode may be bigint\n\n    const md = stats && Number.parseInt(stats.mode, 10);\n    const st = md & 0o777;\n    const it = Number.parseInt(st.toString(8)[0], 10);\n    return Boolean(4 & it);\n  }\n  /**\n   * Handles emitting unlink events for\n   * files and directories, and via recursion, for\n   * files and directories within directories that are unlinked\n   * @param {String} directory within which the following item is located\n   * @param {String} item      base path of item/directory\n   * @returns {void}\n  */\n\n\n  _remove(directory, item, isDirectory) {\n    // if what is being deleted is a directory, get that directory's paths\n    // for recursive deleting and cleaning of watched object\n    // if it is not a directory, nestedDirectoryChildren will be empty array\n    const path = sysPath.join(directory, item);\n    const fullPath = sysPath.resolve(path);\n    isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath); // prevent duplicate handling in case of arriving here nearly simultaneously\n    // via multiple paths (such as _handleFile and _handleDir)\n\n    if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return\n\n    if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n      this.add(directory, item, true);\n    } // This will create a new entry in the watched object in either case\n    // so we got to do the directory check beforehand\n\n\n    const wp = this._getWatchedDir(path);\n\n    const nestedDirectoryChildren = wp.getChildren(); // Recursively remove children directories / files.\n\n    nestedDirectoryChildren.forEach(nested => this._remove(path, nested)); // Check if item was on the watched list and remove it\n\n    const parent = this._getWatchedDir(directory);\n\n    const wasTracked = parent.has(item);\n    parent.remove(item); // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n    // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n    // but never removed from the map in case the path was deleted.\n    // This leads to an incorrect state if the path was recreated:\n    // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n\n    if (this._symlinkPaths.has(fullPath)) {\n      this._symlinkPaths.delete(fullPath);\n    } // If we wait for this file to be fully written, cancel the wait.\n\n\n    let relPath = path;\n    if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n\n    if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n      const event = this._pendingWrites.get(relPath).cancelWait();\n\n      if (event === EV_ADD) return;\n    } // The Entry will either be a directory that just got removed\n    // or a bogus entry to a file, in either case we have to remove it\n\n\n    this._watched.delete(path);\n\n    this._watched.delete(fullPath);\n\n    const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n    if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name\n\n    if (!this.options.useFsEvents) {\n      this._closePath(path);\n    }\n  }\n  /**\n   * Closes all watchers for a path\n   * @param {Path} path\n   */\n\n\n  _closePath(path) {\n    this._closeFile(path);\n\n    const dir = sysPath.dirname(path);\n\n    this._getWatchedDir(dir).remove(sysPath.basename(path));\n  }\n  /**\n   * Closes only file-specific watchers\n   * @param {Path} path\n   */\n\n\n  _closeFile(path) {\n    const closers = this._closers.get(path);\n\n    if (!closers) return;\n    closers.forEach(closer => closer());\n\n    this._closers.delete(path);\n  }\n  /**\n   *\n   * @param {Path} path\n   * @param {Function} closer\n   */\n\n\n  _addPathCloser(path, closer) {\n    if (!closer) return;\n\n    let list = this._closers.get(path);\n\n    if (!list) {\n      list = [];\n\n      this._closers.set(path, list);\n    }\n\n    list.push(closer);\n  }\n\n  _readdirp(root, opts) {\n    if (this.closed) return;\n    const options = {\n      type: EV_ALL,\n      alwaysStat: true,\n      lstat: true,\n      ...opts\n    };\n    let stream = readdirp(root, options);\n\n    this._streams.add(stream);\n\n    stream.once(STR_CLOSE, () => {\n      stream = undefined;\n    });\n    stream.once(STR_END, () => {\n      if (stream) {\n        this._streams.delete(stream);\n\n        stream = undefined;\n      }\n    });\n    return stream;\n  }\n\n} // Export FSWatcher class\n\n\nchokidar.FSWatcher = FSWatcher;\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\n\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nchokidar.watch = watch;\n\nclass FileWatcher {\n  constructor(task, chokidarOptions) {\n    this.transformWatchers = new Map();\n    this.chokidarOptions = chokidarOptions;\n    this.task = task;\n    this.watcher = this.createWatcher(null);\n  }\n\n  close() {\n    this.watcher.close();\n\n    for (const watcher of this.transformWatchers.values()) {\n      watcher.close();\n    }\n  }\n\n  unwatch(id) {\n    this.watcher.unwatch(id);\n    const transformWatcher = this.transformWatchers.get(id);\n\n    if (transformWatcher) {\n      this.transformWatchers.delete(id);\n      transformWatcher.close();\n    }\n  }\n\n  watch(id, isTransformDependency) {\n    var _a;\n\n    if (isTransformDependency) {\n      const watcher = (_a = this.transformWatchers.get(id)) !== null && _a !== void 0 ? _a : this.createWatcher(id);\n      watcher.add(id);\n      this.transformWatchers.set(id, watcher);\n    } else {\n      this.watcher.add(id);\n    }\n  }\n\n  createWatcher(transformWatcherId) {\n    const task = this.task;\n    const isLinux = platform() === 'linux';\n    const isTransformDependency = transformWatcherId !== null;\n\n    const handleChange = (id, event) => {\n      const changedId = transformWatcherId || id;\n\n      if (isLinux) {\n        // unwatching and watching fixes an issue with chokidar where on certain systems,\n        // a file that was unlinked and immediately recreated would create a change event\n        // but then no longer any further events\n        watcher.unwatch(changedId);\n        watcher.add(changedId);\n      }\n\n      task.invalidate(changedId, {\n        event,\n        isTransformDependency\n      });\n    };\n\n    const watcher = chokidar.watch([], this.chokidarOptions).on('add', id => handleChange(id, 'create')).on('change', id => handleChange(id, 'update')).on('unlink', id => handleChange(id, 'delete'));\n    return watcher;\n  }\n\n}\n\nconst eventsRewrites = {\n  create: {\n    create: 'buggy',\n    delete: null,\n    update: 'create'\n  },\n  delete: {\n    create: 'update',\n    delete: 'buggy',\n    update: 'buggy'\n  },\n  update: {\n    create: 'buggy',\n    delete: 'delete',\n    update: 'update'\n  }\n};\n\nclass Watcher {\n  constructor(configs, emitter) {\n    this.buildDelay = 0;\n    this.buildTimeout = null;\n    this.invalidatedIds = new Map();\n    this.rerun = false;\n    this.running = true;\n    this.emitter = emitter;\n    emitter.close = this.close.bind(this);\n    this.tasks = configs.map(config => new Task(this, config));\n    this.buildDelay = configs.reduce((buildDelay, _ref) => {\n      let {\n        watch\n      } = _ref;\n      return watch && typeof watch.buildDelay === 'number' ? Math.max(buildDelay, watch.buildDelay) : buildDelay;\n    }, this.buildDelay);\n    process$1.nextTick(() => this.run());\n  }\n\n  async close() {\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n\n    for (const task of this.tasks) {\n      task.close();\n    }\n\n    await this.emitter.emitAndAwait('close');\n    this.emitter.removeAllListeners();\n  }\n\n  invalidate(file) {\n    if (file) {\n      const prevEvent = this.invalidatedIds.get(file.id);\n      const event = prevEvent ? eventsRewrites[prevEvent][file.event] : file.event;\n\n      if (event === 'buggy') {\n        //TODO: throws or warn? Currently just ignore, uses new event\n        this.invalidatedIds.set(file.id, file.event);\n      } else if (event === null) {\n        this.invalidatedIds.delete(file.id);\n      } else {\n        this.invalidatedIds.set(file.id, event);\n      }\n    }\n\n    if (this.running) {\n      this.rerun = true;\n      return;\n    }\n\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n    this.buildTimeout = setTimeout(async () => {\n      this.buildTimeout = null;\n\n      try {\n        await Promise.all([...this.invalidatedIds].map(_ref2 => {\n          let [id, event] = _ref2;\n          return this.emitter.emitAndAwait('change', id, {\n            event\n          });\n        }));\n        this.invalidatedIds.clear();\n        this.emitter.emit('restart');\n        this.emitter.removeAwaited();\n        this.run();\n      } catch (error) {\n        this.invalidatedIds.clear();\n        this.emitter.emit('event', {\n          code: 'ERROR',\n          error,\n          result: null\n        });\n        this.emitter.emit('event', {\n          code: 'END'\n        });\n      }\n    }, this.buildDelay);\n  }\n\n  async run() {\n    this.running = true;\n    this.emitter.emit('event', {\n      code: 'START'\n    });\n\n    for (const task of this.tasks) {\n      await task.run();\n    }\n\n    this.running = false;\n    this.emitter.emit('event', {\n      code: 'END'\n    });\n\n    if (this.rerun) {\n      this.rerun = false;\n      this.invalidate();\n    }\n  }\n\n}\n\nclass Task {\n  constructor(watcher, config) {\n    this.cache = {\n      modules: []\n    };\n    this.watchFiles = [];\n    this.closed = false;\n    this.invalidated = true;\n    this.watched = new Set();\n    this.watcher = watcher;\n    this.skipWrite = Boolean(config.watch && config.watch.skipWrite);\n    this.options = mergeOptions(config);\n    this.outputs = this.options.output;\n    this.outputFiles = this.outputs.map(output => {\n      if (output.file || output.dir) return resolve(output.file || output.dir);\n      return undefined;\n    });\n    const watchOptions = this.options.watch || {};\n    this.filter = createFilter(watchOptions.include, watchOptions.exclude);\n    this.fileWatcher = new FileWatcher(this, { ...watchOptions.chokidar,\n      disableGlobbing: true,\n      ignoreInitial: true\n    });\n  }\n\n  close() {\n    this.closed = true;\n    this.fileWatcher.close();\n  }\n\n  invalidate(id, details) {\n    this.invalidated = true;\n\n    if (details.isTransformDependency) {\n      for (const module of this.cache.modules) {\n        if (!module.transformDependencies.includes(id)) continue; // effective invalidation\n\n        module.originalCode = null;\n      }\n    }\n\n    this.watcher.invalidate({\n      event: details.event,\n      id\n    });\n  }\n\n  async run() {\n    if (!this.invalidated) return;\n    this.invalidated = false;\n    const options = { ...this.options,\n      cache: this.cache\n    };\n    const start = Date.now();\n    this.watcher.emitter.emit('event', {\n      code: 'BUNDLE_START',\n      input: this.options.input,\n      output: this.outputFiles\n    });\n    let result = null;\n\n    try {\n      result = await rollupInternal(options, this.watcher.emitter);\n\n      if (this.closed) {\n        return;\n      }\n\n      this.updateWatchedFiles(result);\n      this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));\n      this.watcher.emitter.emit('event', {\n        code: 'BUNDLE_END',\n        duration: Date.now() - start,\n        input: this.options.input,\n        output: this.outputFiles,\n        result\n      });\n    } catch (error) {\n      if (!this.closed) {\n        if (Array.isArray(error.watchFiles)) {\n          for (const id of error.watchFiles) {\n            this.watchFile(id);\n          }\n        }\n\n        if (error.id) {\n          this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n        }\n      }\n\n      this.watcher.emitter.emit('event', {\n        code: 'ERROR',\n        error,\n        result\n      });\n    }\n  }\n\n  updateWatchedFiles(result) {\n    const previouslyWatched = this.watched;\n    this.watched = new Set();\n    this.watchFiles = result.watchFiles;\n    this.cache = result.cache;\n\n    for (const id of this.watchFiles) {\n      this.watchFile(id);\n    }\n\n    for (const module of this.cache.modules) {\n      for (const depId of module.transformDependencies) {\n        this.watchFile(depId, true);\n      }\n    }\n\n    for (const id of previouslyWatched) {\n      if (!this.watched.has(id)) {\n        this.fileWatcher.unwatch(id);\n      }\n    }\n  }\n\n  watchFile(id) {\n    let isTransformDependency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!this.filter(id)) return;\n    this.watched.add(id);\n\n    if (this.outputFiles.some(file => file === id)) {\n      throw new Error('Cannot import the generated bundle');\n    } // this is necessary to ensure that any 'renamed' files\n    // continue to be watched following an error\n\n\n    this.fileWatcher.watch(id, isTransformDependency);\n  }\n\n}\n\nexport { Task, Watcher };","map":{"version":3,"names":["require$$0$2","resolve","process$1","ensureArray","warnUnknownOptions","defaultOnWarn","objectifyOptionWithPresets","treeshakePresets","objectifyOption","generatedCodePresets","picomatch","picomatch$2","getAugmentedNamespace","fseventsImporter","createFilter","rollupInternal","require$$2$1","platform","require$$0$1","require$$2","require$$1","require$$0$3","commandAliases","c","d","e","f","g","h","i","m","n","o","p","v","w","mergeOptions","config","rawCommandOptions","external","globals","undefined","defaultOnWarnHandler","command","getCommandOptions","inputOptions","mergeInputOptions","warn","onwarn","output","Object","assign","outputOptionsArray","length","push","outputOptions","map","singleOutputOptions","mergeOutputOptions","keys","concat","filter","option","split","reduce","globalDefinition","id","variableName","includes","create","overrides","getOption","name","_a","acorn","acornInjectPlugins","cache","context","experimentalCacheExpiry","getExternal","inlineDynamicImports","input","makeAbsoluteExternalsRelative","manualChunks","maxParallelFileOps","maxParallelFileReads","moduleContext","getOnWarn","perf","plugins","preserveEntrySignatures","preserveModules","preserveSymlinks","shimMissingExports","strictDeprecations","treeshake","getObjectOption","watch","getWatch","configExternal","source","importer","isResolved","warning","objectifyValue","commandOption","normalizeObjectOptionValue","configOption","optionValue","Array","isArray","result","value","amd","assetFileNames","banner","chunkFileNames","compact","dir","dynamicImportFunction","entryFileNames","esModule","exports","extend","externalLiveBindings","file","footer","format","freeze","generatedCode","hoistTransitiveImports","indent","interop","intro","minifyInternalExports","namespaceToStringTag","noConflict","outro","paths","preferConst","preserveModulesRoot","sanitizeFileName","sourcemap","sourcemapBaseUrl","sourcemapExcludeSources","sourcemapFile","sourcemapPathTransform","strict","systemNullSetters","validate","chokidar","fs$3","Readable","sysPath$3","promisify","promisify$3","picomatch$1","readdir$1","readdir","stat$3","stat","lstat$2","lstat","realpath$1","realpath","BANG$2","RECURSIVE_ERROR_CODE","NORMAL_FLOW_ERRORS","Set","FILE_TYPE","DIR_TYPE","FILE_DIR_TYPE","EVERYTHING_TYPE","ALL_TYPES","isNormalFlowError","error","has","code","maj","min","process","versions","node","slice","Number","parseInt","wantBigintFsStats","normalizeFilter","glob","trim","entry","basename","positive","negative","item","trimmed","charAt","some","ReaddirpStream","defaultOptions","root","fileFilter","path","directoryFilter","type","depth","alwaysStat","constructor","options","objectMode","autoDestroy","highWaterMark","opts","_fileFilter","_directoryFilter","statMethod","_stat","bigint","_maxDepth","_wantsDir","_wantsFile","_wantsEverything","_root","_isDirent","_statsProp","_rdOptions","encoding","withFileTypes","parents","_exploreDir","reading","parent","_read","batch","destroyed","files","splice","dirent","_formatEntry","Promise","all","entryType","_getEntryType","fullPath","_includeAsFile","pop","destroy","_onError","join","relative","err","emit","stats","isFile","isDirectory","isSymbolicLink","full","entryRealPath","entryRealPathStats","len","startsWith","substr","sep","recursiveError","Error","readdirp$1","TypeError","readdirpPromise","reject","on","promise","default","readdirp_1","anymatch$2","normalizePath$2","stripTrailing","prefix","ch","segs","defineProperty","normalizePath$1","BANG$1","DEFAULT_OPTIONS","returnIndex","arrify$1","createPattern","matcher","string","RegExp","test","matchPatterns","patterns","negPatterns","args","isList","_path","prototype","toString","call","index","nglob","applied","pattern","anymatch$1","matchers","testString","mtchers","negatedGlobs","ri","isExtglob$1","isExtglob","str","match","exec","chars","strictCheck","pipeIndex","closeSquareIndex","closeCurlyIndex","closeParenIndex","backSlashIndex","indexOf","open","close","relaxedCheck","isGlob$2","isGlob","check","isGlob$1","pathPosixDirname","posix","dirname","isWin32","slash","backslash","enclosure","globby","escaped","globParent$1","globParent","flipBackslashes","replace","utils$3","isInteger","num","find","nodes","exceedsLimit","max","step","limit","escapeNode","block","encloseBrace","commas","ranges","invalid","isInvalidBrace","dollar","isOpenOrClose","acc","flatten","flat","arr","ele","utils$2","stringify$4","ast","stringify","invalidBlock","escapeInvalid","invalidNode","child","isNumber$2","isFinite","isNumber$1","toRegexRange$1","String","relaxZeros","strictZeros","relax","shorthand","capture","wrap","cacheKey","hasOwnProperty","a","Math","b","abs","isPadded","hasPadding","state","positives","negatives","maxLen","newMin","splitToPatterns","collatePatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","subpatterns","splitToRanges","nines","zeros","stop","countNines","stops","add","countZeros","sort","compare","rangeToPattern","start","count","digits","zipped","zip","startDigit","stopDigit","toCharacterClass","tok","tokens","prev","obj","toQuantifier","padZeros","comparison","intersection","contains","key","val","repeat","integer","pow","diff","clearCache","toRegexRange_1","util","toRegexRange","isObject","transform","toNumber","isValidValue","isNumber","stringify$3","end","pad","maxLength","dash","padStart","toMaxLen","toSequence","parts","toRange","isNumbers","fromCharCode","toRegex","rangeError","RangeError","inspect","invalidRange","strictRanges","invalidStep","fillNumbers","descending","startString","endString","stepString","padded","range","fillLetters","charCodeAt","fill$2","fillRange","fill$1","utils$1","compile$1","walk","isOpen","isClose","compile_1","fill","stringify$2","utils","append","queue","stash","enclose","expand$1","rangeLimit","q","expand_1","constants$1","MAX_LENGTH","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKSLASH","CHAR_BACKTICK","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_COMMA","CHAR_DOLLAR","CHAR_DOT","CHAR_DOUBLE_QUOTE","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_LINE_FEED","CHAR_NO_BREAK_SPACE","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_SQUARE_BRACKET","CHAR_SEMICOLON","CHAR_SINGLE_QUOTE","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","stringify$1","parse$1","SyntaxError","stack","brackets","advance","keepEscaping","next","keepQuotes","brace","shift","siblings","before","forEach","parse_1","compile","expand","parse","braces$1","nodupes","noempty","Boolean","braces_1","binaryExtensions$1","require$$0","module","binaryExtensions","extensions","isBinaryPath$1","filePath","extname","toLowerCase","constants","os","EV_ALL","EV_READY","EV_ADD","EV_CHANGE","EV_ADD_DIR","EV_UNLINK","EV_UNLINK_DIR","EV_RAW","EV_ERROR","STR_DATA","STR_END","STR_CLOSE","FSEVENT_CREATED","FSEVENT_MODIFIED","FSEVENT_DELETED","FSEVENT_MOVED","FSEVENT_CLONED","FSEVENT_UNKNOWN","FSEVENT_TYPE_FILE","FSEVENT_TYPE_DIRECTORY","FSEVENT_TYPE_SYMLINK","KEY_LISTENERS","KEY_ERR","KEY_RAW","HANDLER_KEYS","DOT_SLASH","BACK_SLASH_RE","DOUBLE_SLASH_RE","SLASH_OR_BACK_SLASH_RE","DOT_RE","REPLACER_RE","SLASH","SLASH_SLASH","BRACE_START","BANG","ONE_DOT","TWO_DOTS","STAR","GLOBSTAR","ROOT_GLOBSTAR","SLASH_GLOBSTAR","DIR_SUFFIX","ANYMATCH_OPTS","dot","STRING_TYPE","FUNCTION_TYPE","EMPTY_STR","EMPTY_FN","IDENTITY_FN","isWindows","isMacos","isLinux","isIBMi","fs$2","sysPath$2","promisify$2","isBinaryPath","isWindows$1","EMPTY_FN$2","EMPTY_STR$1","EV_CHANGE$2","EV_ADD$2","EV_ADD_DIR$2","EV_ERROR$2","STR_DATA$1","STR_END$2","BRACE_START$1","THROTTLE_MODE_WATCH","stat$2","lstat$1","fsrealpath","statMethods$1","foreach","fn","addAndConvert","main","prop","container","clearItem","cont","set","clear","delFromSet","delete","isEmptySet","size","FsWatchInstances","Map","createFsWatchInstance","listener","errHandler","emitRaw","handleEvent","rawEvent","evPath","watchedPath","fsWatchBroadcast","val1","val2","val3","get","setFsWatchListener","handlers","rawEmitter","watcher","persistent","bind","broadcastErr","watcherUnusable","fd","listeners","errHandlers","rawEmitters","FsWatchFileInstances","setFsWatchFileListener","copts","interval","unwatchFile","watchFile","curr","currmtime","mtimeMs","NodeFsHandler$1","fsW","fsw","_boundHandleError","_handleError","_watchWithNodeFs","directory","_getWatchedDir","absolutePath","closer","usePolling","enableBinaryInterval","binaryInterval","_emitRaw","_handleFile","initialAdd","closed","prevStats","newStats","_throttle","at","atimeMs","mt","_emit","ino","_closeFile","_addPathCloser","_remove","ignoreInitial","_isntIgnored","_handleSymlink","followSymlinks","_incrReadyCount","linkPath","_emitReady","_symlinkPaths","_handleRead","wh","target","throttler","hasGlob","previous","current","stream","_readdirp","filterPath","filterDir","_addToNodeFs","once","wasThrottled","getChildren","_handleDir","parentDir","tracked","globFilter","oDepth","dirPath","priorWh","ready","_isIgnored","_getWatchHelpers","watchPath","follow","absPath","targetPath","nodefsHandler","fseventsHandler","require$$3","fs$1","sysPath$1","promisify$1","fsevents","getFsEvents","env","CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR","console","mtch","version","EV_ADD$1","EV_CHANGE$1","EV_ADD_DIR$1","EV_UNLINK$1","EV_ERROR$1","STR_END$1","FUNCTION_TYPE$1","EMPTY_FN$1","Depth","isNaN","stat$1","statMethods","FSEventsWatchers","consolidateThreshhold","wrongEventFlags","createFSEventsInstance","callback","setFSEventsListener","realPath","parentPath","couldConsolidate","resolvedPath","hasSymlink","filteredListener","flags","info","watchedParent","getInfo","list","event","lst","then","canUse","calcDepth","sameTypes","FsEventsHandler$1","checkIgnored","ipaths","_ignoredPaths","addOrChange","watchedDir","checkExists","curDepth","_addToFsEvents","eventName","_watchWithFsEvents","watchCallback","ignored","_handleFsEventsSymlink","linkTarget","aliasedPath","emitAdd","newPath","processPath","forceAdd","pp","isDir","dirObj","base","initWatch","priorDepth","joinedPath","EventEmitter","fs","sysPath","readdirp","anymatch","braces","normalizePath","NodeFsHandler","FsEventsHandler","arrify","unifyPaths","paths_","every","normalizePathToUnix","toUnix","prepend","normalize","normalizeIgnored","cwd","isAbsolute","getAbsolutePath","undef","DirEntry","removeWatcher","_removeWatcher","items","remove","values","dispose","STAT_METHOD_F","STAT_METHOD_L","WatchHelper","fullWatchPath","globSymlink","dirParts","getDirParts","checkGlobSymlink","fullParentDir","entryPath","matchesGlob","_hasReadPermissions","expandedPath","entryParts","globstar","unmatchedGlob","part","FSWatcher","_opts","_watched","_closers","_throttled","_streams","ignorePermissionErrors","disableGlobbing","useFsEvents","canUseFsEvents","envPoll","CHOKIDAR_USEPOLLING","envLower","envInterval","CHOKIDAR_INTERVAL","atomic","_pendingUnlinks","awaitWriteFinish","awf","stabilityThreshold","pollInterval","_pendingWrites","readyCalls","_readyCount","_readyEmitted","nextTick","_fsEventsHandler","_nodeFsHandler","_origAdd","_internal","_userIgnored","res","results","unwatch","_closePath","_closePromise","removeAllListeners","closers","closerList","getWatched","watchList","emitWithAll","pw","lastChange","Date","setTimeout","awfEmit","_awaitWriteFinish","isThrottled","actionType","timeout","action","actionPath","timeoutObject","clearTimeout","thr","threshold","timeoutHandler","now","prevStat","curStat","df","cancelWait","_getGlobIgnored","ign","_boundRemove","md","mode","st","it","wp","nestedDirectoryChildren","nested","wasTracked","relPath","FileWatcher","task","chokidarOptions","transformWatchers","createWatcher","transformWatcher","isTransformDependency","transformWatcherId","handleChange","changedId","invalidate","eventsRewrites","update","Watcher","configs","emitter","buildDelay","buildTimeout","invalidatedIds","rerun","running","tasks","Task","run","emitAndAwait","prevEvent","removeAwaited","modules","watchFiles","invalidated","watched","skipWrite","outputs","outputFiles","watchOptions","include","exclude","fileWatcher","details","transformDependencies","originalCode","updateWatchedFiles","write","duration","previouslyWatched","depId"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/rollup/dist/es/shared/watch.js"],"sourcesContent":["/*\n  @license\n\tRollup.js v2.79.0\n\tWed, 31 Aug 2022 04:52:13 GMT - commit 8477f8ff1fe80086556021542b22942ad27a0a69\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\nimport require$$0$2, { resolve } from 'path';\nimport process$1 from 'process';\nimport { ensureArray, warnUnknownOptions, defaultOnWarn, objectifyOptionWithPresets, treeshakePresets, objectifyOption, generatedCodePresets, picomatch as picomatch$2, getAugmentedNamespace, fseventsImporter, createFilter, rollupInternal } from './rollup.js';\nimport require$$2$1, { platform } from 'os';\nimport require$$0$1 from 'fs';\nimport require$$2 from 'util';\nimport require$$1 from 'stream';\nimport require$$0$3 from 'events';\nimport 'perf_hooks';\nimport 'crypto';\n\nconst commandAliases = {\n    c: 'config',\n    d: 'dir',\n    e: 'external',\n    f: 'format',\n    g: 'globals',\n    h: 'help',\n    i: 'input',\n    m: 'sourcemap',\n    n: 'name',\n    o: 'file',\n    p: 'plugin',\n    v: 'version',\n    w: 'watch'\n};\nfunction mergeOptions(config, rawCommandOptions = { external: [], globals: undefined }, defaultOnWarnHandler = defaultOnWarn) {\n    const command = getCommandOptions(rawCommandOptions);\n    const inputOptions = mergeInputOptions(config, command, defaultOnWarnHandler);\n    const warn = inputOptions.onwarn;\n    if (command.output) {\n        Object.assign(command, command.output);\n    }\n    const outputOptionsArray = ensureArray(config.output);\n    if (outputOptionsArray.length === 0)\n        outputOptionsArray.push({});\n    const outputOptions = outputOptionsArray.map(singleOutputOptions => mergeOutputOptions(singleOutputOptions, command, warn));\n    warnUnknownOptions(command, Object.keys(inputOptions).concat(Object.keys(outputOptions[0]).filter(option => option !== 'sourcemapPathTransform'), Object.keys(commandAliases), 'config', 'environment', 'plugin', 'silent', 'failAfterWarnings', 'stdin', 'waitForBundleInput', 'configPlugin'), 'CLI flags', warn, /^_$|output$|config/);\n    inputOptions.output = outputOptions;\n    return inputOptions;\n}\nfunction getCommandOptions(rawCommandOptions) {\n    const external = rawCommandOptions.external && typeof rawCommandOptions.external === 'string'\n        ? rawCommandOptions.external.split(',')\n        : [];\n    return {\n        ...rawCommandOptions,\n        external,\n        globals: typeof rawCommandOptions.globals === 'string'\n            ? rawCommandOptions.globals.split(',').reduce((globals, globalDefinition) => {\n                const [id, variableName] = globalDefinition.split(':');\n                globals[id] = variableName;\n                if (!external.includes(id)) {\n                    external.push(id);\n                }\n                return globals;\n            }, Object.create(null))\n            : undefined\n    };\n}\nfunction mergeInputOptions(config, overrides, defaultOnWarnHandler) {\n    const getOption = (name) => { var _a; return (_a = overrides[name]) !== null && _a !== void 0 ? _a : config[name]; };\n    const inputOptions = {\n        acorn: getOption('acorn'),\n        acornInjectPlugins: config.acornInjectPlugins,\n        cache: config.cache,\n        context: getOption('context'),\n        experimentalCacheExpiry: getOption('experimentalCacheExpiry'),\n        external: getExternal(config, overrides),\n        inlineDynamicImports: getOption('inlineDynamicImports'),\n        input: getOption('input') || [],\n        makeAbsoluteExternalsRelative: getOption('makeAbsoluteExternalsRelative'),\n        manualChunks: getOption('manualChunks'),\n        maxParallelFileOps: getOption('maxParallelFileOps'),\n        maxParallelFileReads: getOption('maxParallelFileReads'),\n        moduleContext: getOption('moduleContext'),\n        onwarn: getOnWarn(config, defaultOnWarnHandler),\n        perf: getOption('perf'),\n        plugins: ensureArray(config.plugins),\n        preserveEntrySignatures: getOption('preserveEntrySignatures'),\n        preserveModules: getOption('preserveModules'),\n        preserveSymlinks: getOption('preserveSymlinks'),\n        shimMissingExports: getOption('shimMissingExports'),\n        strictDeprecations: getOption('strictDeprecations'),\n        treeshake: getObjectOption(config, overrides, 'treeshake', objectifyOptionWithPresets(treeshakePresets, 'treeshake', 'false, true, ')),\n        watch: getWatch(config, overrides)\n    };\n    warnUnknownOptions(config, Object.keys(inputOptions), 'input options', inputOptions.onwarn, /^output$/);\n    return inputOptions;\n}\nconst getExternal = (config, overrides) => {\n    const configExternal = config.external;\n    return typeof configExternal === 'function'\n        ? (source, importer, isResolved) => configExternal(source, importer, isResolved) || overrides.external.includes(source)\n        : ensureArray(configExternal).concat(overrides.external);\n};\nconst getOnWarn = (config, defaultOnWarnHandler) => config.onwarn\n    ? warning => config.onwarn(warning, defaultOnWarnHandler)\n    : defaultOnWarnHandler;\nconst getObjectOption = (config, overrides, name, objectifyValue = objectifyOption) => {\n    const commandOption = normalizeObjectOptionValue(overrides[name], objectifyValue);\n    const configOption = normalizeObjectOptionValue(config[name], objectifyValue);\n    if (commandOption !== undefined) {\n        return commandOption && { ...configOption, ...commandOption };\n    }\n    return configOption;\n};\nconst getWatch = (config, overrides) => config.watch !== false && getObjectOption(config, overrides, 'watch');\nconst normalizeObjectOptionValue = (optionValue, objectifyValue) => {\n    if (!optionValue) {\n        return optionValue;\n    }\n    if (Array.isArray(optionValue)) {\n        return optionValue.reduce((result, value) => value && result && { ...result, ...objectifyValue(value) }, {});\n    }\n    return objectifyValue(optionValue);\n};\nfunction mergeOutputOptions(config, overrides, warn) {\n    const getOption = (name) => { var _a; return (_a = overrides[name]) !== null && _a !== void 0 ? _a : config[name]; };\n    const outputOptions = {\n        amd: getObjectOption(config, overrides, 'amd'),\n        assetFileNames: getOption('assetFileNames'),\n        banner: getOption('banner'),\n        chunkFileNames: getOption('chunkFileNames'),\n        compact: getOption('compact'),\n        dir: getOption('dir'),\n        dynamicImportFunction: getOption('dynamicImportFunction'),\n        entryFileNames: getOption('entryFileNames'),\n        esModule: getOption('esModule'),\n        exports: getOption('exports'),\n        extend: getOption('extend'),\n        externalLiveBindings: getOption('externalLiveBindings'),\n        file: getOption('file'),\n        footer: getOption('footer'),\n        format: getOption('format'),\n        freeze: getOption('freeze'),\n        generatedCode: getObjectOption(config, overrides, 'generatedCode', objectifyOptionWithPresets(generatedCodePresets, 'output.generatedCode', '')),\n        globals: getOption('globals'),\n        hoistTransitiveImports: getOption('hoistTransitiveImports'),\n        indent: getOption('indent'),\n        inlineDynamicImports: getOption('inlineDynamicImports'),\n        interop: getOption('interop'),\n        intro: getOption('intro'),\n        manualChunks: getOption('manualChunks'),\n        minifyInternalExports: getOption('minifyInternalExports'),\n        name: getOption('name'),\n        namespaceToStringTag: getOption('namespaceToStringTag'),\n        noConflict: getOption('noConflict'),\n        outro: getOption('outro'),\n        paths: getOption('paths'),\n        plugins: ensureArray(config.plugins),\n        preferConst: getOption('preferConst'),\n        preserveModules: getOption('preserveModules'),\n        preserveModulesRoot: getOption('preserveModulesRoot'),\n        sanitizeFileName: getOption('sanitizeFileName'),\n        sourcemap: getOption('sourcemap'),\n        sourcemapBaseUrl: getOption('sourcemapBaseUrl'),\n        sourcemapExcludeSources: getOption('sourcemapExcludeSources'),\n        sourcemapFile: getOption('sourcemapFile'),\n        sourcemapPathTransform: getOption('sourcemapPathTransform'),\n        strict: getOption('strict'),\n        systemNullSetters: getOption('systemNullSetters'),\n        validate: getOption('validate')\n    };\n    warnUnknownOptions(config, Object.keys(outputOptions), 'output options', warn);\n    return outputOptions;\n}\n\nvar chokidar = {};\n\nconst fs$3 = require$$0$1;\nconst { Readable } = require$$1;\nconst sysPath$3 = require$$0$2;\nconst { promisify: promisify$3 } = require$$2;\nconst picomatch$1 = picomatch$2.exports;\n\nconst readdir$1 = promisify$3(fs$3.readdir);\nconst stat$3 = promisify$3(fs$3.stat);\nconst lstat$2 = promisify$3(fs$3.lstat);\nconst realpath$1 = promisify$3(fs$3.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG$2 = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch$1(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG$2) {\n        negative.push(picomatch$1(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch$1(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat$2 : stat$3;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath$3.resolve(root);\n    this._isDirent = ('Dirent' in fs$3) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir$1(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return { files, depth, path };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath$3.resolve(sysPath$3.join(path, basename));\n      entry = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath$1(full);\n        const entryRealPathStats = await lstat$2(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {\n            const recursiveError = new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            );\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp$1 = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp$1(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp$1.promise = readdirpPromise;\nreaddirp$1.ReaddirpStream = ReaddirpStream;\nreaddirp$1.default = readdirp$1;\n\nvar readdirp_1 = readdirp$1;\n\nvar anymatch$2 = {exports: {}};\n\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath$2 = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n\nObject.defineProperty(anymatch$2.exports, \"__esModule\", { value: true });\n\nconst picomatch = picomatch$2.exports;\nconst normalizePath$1 = normalizePath$2;\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG$1 = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify$1 = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath$1(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch$1 = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify$1(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG$1)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers\n    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG$1))\n    .map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch$1.default = anymatch$1;\nanymatch$2.exports = anymatch$1;\n\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob$1 = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = isExtglob$1;\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar relaxedCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar isGlob$2 = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var check = strictCheck;\n\n  // optionally relax check\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n\n  return check(str);\n};\n\nvar isGlob$1 = isGlob$2;\nvar pathPosixDirname = require$$0$2.posix.dirname;\nvar isWin32 = require$$2$1.platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\nvar globParent$1 = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob$1(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n\nvar utils$3 = {};\n\n(function (exports) {\n\n\texports.isInteger = num => {\n\t  if (typeof num === 'number') {\n\t    return Number.isInteger(num);\n\t  }\n\t  if (typeof num === 'string' && num.trim() !== '') {\n\t    return Number.isInteger(Number(num));\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Find a node of the given type\n\t */\n\n\texports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n\t/**\n\t * Find a node of the given type\n\t */\n\n\texports.exceedsLimit = (min, max, step = 1, limit) => {\n\t  if (limit === false) return false;\n\t  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n\t  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n\t};\n\n\t/**\n\t * Escape the given node with '\\\\' before node.value\n\t */\n\n\texports.escapeNode = (block, n = 0, type) => {\n\t  let node = block.nodes[n];\n\t  if (!node) return;\n\n\t  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n\t    if (node.escaped !== true) {\n\t      node.value = '\\\\' + node.value;\n\t      node.escaped = true;\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Returns true if the given brace node should be enclosed in literal braces\n\t */\n\n\texports.encloseBrace = node => {\n\t  if (node.type !== 'brace') return false;\n\t  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n\t    node.invalid = true;\n\t    return true;\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Returns true if a brace node is invalid.\n\t */\n\n\texports.isInvalidBrace = block => {\n\t  if (block.type !== 'brace') return false;\n\t  if (block.invalid === true || block.dollar) return true;\n\t  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n\t    block.invalid = true;\n\t    return true;\n\t  }\n\t  if (block.open !== true || block.close !== true) {\n\t    block.invalid = true;\n\t    return true;\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Returns true if a node is an open or close node\n\t */\n\n\texports.isOpenOrClose = node => {\n\t  if (node.type === 'open' || node.type === 'close') {\n\t    return true;\n\t  }\n\t  return node.open === true || node.close === true;\n\t};\n\n\t/**\n\t * Reduce an array of text nodes.\n\t */\n\n\texports.reduce = nodes => nodes.reduce((acc, node) => {\n\t  if (node.type === 'text') acc.push(node.value);\n\t  if (node.type === 'range') node.type = 'text';\n\t  return acc;\n\t}, []);\n\n\t/**\n\t * Flatten an array\n\t */\n\n\texports.flatten = (...args) => {\n\t  const result = [];\n\t  const flat = arr => {\n\t    for (let i = 0; i < arr.length; i++) {\n\t      let ele = arr[i];\n\t      Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n\t    }\n\t    return result;\n\t  };\n\t  flat(args);\n\t  return result;\n\t};\n} (utils$3));\n\nconst utils$2 = utils$3;\n\nvar stringify$4 = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils$2.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils$2.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isNumber$2 = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nconst isNumber$1 = isNumber$2;\n\nconst toRegexRange$1 = (min, max, options) => {\n  if (isNumber$1(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber$1(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange$1.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange$1.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange$1.cache = {};\ntoRegexRange$1.clearCache = () => (toRegexRange$1.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nvar toRegexRange_1 = toRegexRange$1;\n\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nconst util = require$$2;\nconst toRegexRange = toRegexRange_1;\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify$3 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$3(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill$2 = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill$2(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill$2(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill$2(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nvar fillRange = fill$2;\n\nconst fill$1 = fillRange;\nconst utils$1 = utils$3;\n\nconst compile$1 = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n      let range = fill$1(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nvar compile_1 = compile$1;\n\nconst fill = fillRange;\nconst stringify$2 = stringify$4;\nconst utils = utils$3;\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand$1 = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify$2(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify$2(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nvar expand_1 = expand$1;\n\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n\nconst stringify$1 = stringify$4;\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants$1;\n\n/**\n * parse\n */\n\nconst parse$1 = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify$1(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nvar parse_1 = parse$1;\n\nconst stringify = stringify$4;\nconst compile = compile_1;\nconst expand = expand_1;\nconst parse = parse_1;\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces$1 = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces$1.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces$1.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces$1.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces$1.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces$1.compile(input, options)\n    : braces$1.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nvar braces_1 = braces$1;\n\nvar binaryExtensions$1 = {exports: {}};\n\nconst require$$0 = [\n\t\"3dm\",\n\t\"3ds\",\n\t\"3g2\",\n\t\"3gp\",\n\t\"7z\",\n\t\"a\",\n\t\"aac\",\n\t\"adp\",\n\t\"ai\",\n\t\"aif\",\n\t\"aiff\",\n\t\"alz\",\n\t\"ape\",\n\t\"apk\",\n\t\"appimage\",\n\t\"ar\",\n\t\"arj\",\n\t\"asf\",\n\t\"au\",\n\t\"avi\",\n\t\"bak\",\n\t\"baml\",\n\t\"bh\",\n\t\"bin\",\n\t\"bk\",\n\t\"bmp\",\n\t\"btif\",\n\t\"bz2\",\n\t\"bzip2\",\n\t\"cab\",\n\t\"caf\",\n\t\"cgm\",\n\t\"class\",\n\t\"cmx\",\n\t\"cpio\",\n\t\"cr2\",\n\t\"cur\",\n\t\"dat\",\n\t\"dcm\",\n\t\"deb\",\n\t\"dex\",\n\t\"djvu\",\n\t\"dll\",\n\t\"dmg\",\n\t\"dng\",\n\t\"doc\",\n\t\"docm\",\n\t\"docx\",\n\t\"dot\",\n\t\"dotm\",\n\t\"dra\",\n\t\"DS_Store\",\n\t\"dsk\",\n\t\"dts\",\n\t\"dtshd\",\n\t\"dvb\",\n\t\"dwg\",\n\t\"dxf\",\n\t\"ecelp4800\",\n\t\"ecelp7470\",\n\t\"ecelp9600\",\n\t\"egg\",\n\t\"eol\",\n\t\"eot\",\n\t\"epub\",\n\t\"exe\",\n\t\"f4v\",\n\t\"fbs\",\n\t\"fh\",\n\t\"fla\",\n\t\"flac\",\n\t\"flatpak\",\n\t\"fli\",\n\t\"flv\",\n\t\"fpx\",\n\t\"fst\",\n\t\"fvt\",\n\t\"g3\",\n\t\"gh\",\n\t\"gif\",\n\t\"graffle\",\n\t\"gz\",\n\t\"gzip\",\n\t\"h261\",\n\t\"h263\",\n\t\"h264\",\n\t\"icns\",\n\t\"ico\",\n\t\"ief\",\n\t\"img\",\n\t\"ipa\",\n\t\"iso\",\n\t\"jar\",\n\t\"jpeg\",\n\t\"jpg\",\n\t\"jpgv\",\n\t\"jpm\",\n\t\"jxr\",\n\t\"key\",\n\t\"ktx\",\n\t\"lha\",\n\t\"lib\",\n\t\"lvp\",\n\t\"lz\",\n\t\"lzh\",\n\t\"lzma\",\n\t\"lzo\",\n\t\"m3u\",\n\t\"m4a\",\n\t\"m4v\",\n\t\"mar\",\n\t\"mdi\",\n\t\"mht\",\n\t\"mid\",\n\t\"midi\",\n\t\"mj2\",\n\t\"mka\",\n\t\"mkv\",\n\t\"mmr\",\n\t\"mng\",\n\t\"mobi\",\n\t\"mov\",\n\t\"movie\",\n\t\"mp3\",\n\t\"mp4\",\n\t\"mp4a\",\n\t\"mpeg\",\n\t\"mpg\",\n\t\"mpga\",\n\t\"mxu\",\n\t\"nef\",\n\t\"npx\",\n\t\"numbers\",\n\t\"nupkg\",\n\t\"o\",\n\t\"odp\",\n\t\"ods\",\n\t\"odt\",\n\t\"oga\",\n\t\"ogg\",\n\t\"ogv\",\n\t\"otf\",\n\t\"ott\",\n\t\"pages\",\n\t\"pbm\",\n\t\"pcx\",\n\t\"pdb\",\n\t\"pdf\",\n\t\"pea\",\n\t\"pgm\",\n\t\"pic\",\n\t\"png\",\n\t\"pnm\",\n\t\"pot\",\n\t\"potm\",\n\t\"potx\",\n\t\"ppa\",\n\t\"ppam\",\n\t\"ppm\",\n\t\"pps\",\n\t\"ppsm\",\n\t\"ppsx\",\n\t\"ppt\",\n\t\"pptm\",\n\t\"pptx\",\n\t\"psd\",\n\t\"pya\",\n\t\"pyc\",\n\t\"pyo\",\n\t\"pyv\",\n\t\"qt\",\n\t\"rar\",\n\t\"ras\",\n\t\"raw\",\n\t\"resources\",\n\t\"rgb\",\n\t\"rip\",\n\t\"rlc\",\n\t\"rmf\",\n\t\"rmvb\",\n\t\"rpm\",\n\t\"rtf\",\n\t\"rz\",\n\t\"s3m\",\n\t\"s7z\",\n\t\"scpt\",\n\t\"sgi\",\n\t\"shar\",\n\t\"snap\",\n\t\"sil\",\n\t\"sketch\",\n\t\"slk\",\n\t\"smv\",\n\t\"snk\",\n\t\"so\",\n\t\"stl\",\n\t\"suo\",\n\t\"sub\",\n\t\"swf\",\n\t\"tar\",\n\t\"tbz\",\n\t\"tbz2\",\n\t\"tga\",\n\t\"tgz\",\n\t\"thmx\",\n\t\"tif\",\n\t\"tiff\",\n\t\"tlz\",\n\t\"ttc\",\n\t\"ttf\",\n\t\"txz\",\n\t\"udf\",\n\t\"uvh\",\n\t\"uvi\",\n\t\"uvm\",\n\t\"uvp\",\n\t\"uvs\",\n\t\"uvu\",\n\t\"viv\",\n\t\"vob\",\n\t\"war\",\n\t\"wav\",\n\t\"wax\",\n\t\"wbmp\",\n\t\"wdp\",\n\t\"weba\",\n\t\"webm\",\n\t\"webp\",\n\t\"whl\",\n\t\"wim\",\n\t\"wm\",\n\t\"wma\",\n\t\"wmv\",\n\t\"wmx\",\n\t\"woff\",\n\t\"woff2\",\n\t\"wrm\",\n\t\"wvx\",\n\t\"xbm\",\n\t\"xif\",\n\t\"xla\",\n\t\"xlam\",\n\t\"xls\",\n\t\"xlsb\",\n\t\"xlsm\",\n\t\"xlsx\",\n\t\"xlt\",\n\t\"xltm\",\n\t\"xltx\",\n\t\"xm\",\n\t\"xmind\",\n\t\"xpi\",\n\t\"xpm\",\n\t\"xwd\",\n\t\"xz\",\n\t\"z\",\n\t\"zip\",\n\t\"zipx\"\n];\n\n(function (module) {\n\tmodule.exports = require$$0;\n} (binaryExtensions$1));\n\nconst path = require$$0$2;\nconst binaryExtensions = binaryExtensions$1.exports;\n\nconst extensions = new Set(binaryExtensions);\n\nvar isBinaryPath$1 = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n\nvar constants = {};\n\n(function (exports) {\n\n\tconst {sep} = require$$0$2;\n\tconst {platform} = process;\n\tconst os = require$$2$1;\n\n\texports.EV_ALL = 'all';\n\texports.EV_READY = 'ready';\n\texports.EV_ADD = 'add';\n\texports.EV_CHANGE = 'change';\n\texports.EV_ADD_DIR = 'addDir';\n\texports.EV_UNLINK = 'unlink';\n\texports.EV_UNLINK_DIR = 'unlinkDir';\n\texports.EV_RAW = 'raw';\n\texports.EV_ERROR = 'error';\n\n\texports.STR_DATA = 'data';\n\texports.STR_END = 'end';\n\texports.STR_CLOSE = 'close';\n\n\texports.FSEVENT_CREATED = 'created';\n\texports.FSEVENT_MODIFIED = 'modified';\n\texports.FSEVENT_DELETED = 'deleted';\n\texports.FSEVENT_MOVED = 'moved';\n\texports.FSEVENT_CLONED = 'cloned';\n\texports.FSEVENT_UNKNOWN = 'unknown';\n\texports.FSEVENT_TYPE_FILE = 'file';\n\texports.FSEVENT_TYPE_DIRECTORY = 'directory';\n\texports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\n\texports.KEY_LISTENERS = 'listeners';\n\texports.KEY_ERR = 'errHandlers';\n\texports.KEY_RAW = 'rawEmitters';\n\texports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\n\texports.DOT_SLASH = `.${sep}`;\n\n\texports.BACK_SLASH_RE = /\\\\/g;\n\texports.DOUBLE_SLASH_RE = /\\/\\//;\n\texports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\n\texports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n\texports.REPLACER_RE = /^\\.[/\\\\]/;\n\n\texports.SLASH = '/';\n\texports.SLASH_SLASH = '//';\n\texports.BRACE_START = '{';\n\texports.BANG = '!';\n\texports.ONE_DOT = '.';\n\texports.TWO_DOTS = '..';\n\texports.STAR = '*';\n\texports.GLOBSTAR = '**';\n\texports.ROOT_GLOBSTAR = '/**/*';\n\texports.SLASH_GLOBSTAR = '/**';\n\texports.DIR_SUFFIX = 'Dir';\n\texports.ANYMATCH_OPTS = {dot: true};\n\texports.STRING_TYPE = 'string';\n\texports.FUNCTION_TYPE = 'function';\n\texports.EMPTY_STR = '';\n\texports.EMPTY_FN = () => {};\n\texports.IDENTITY_FN = val => val;\n\n\texports.isWindows = platform === 'win32';\n\texports.isMacos = platform === 'darwin';\n\texports.isLinux = platform === 'linux';\n\texports.isIBMi = os.type() === 'OS400';\n} (constants));\n\nconst fs$2 = require$$0$1;\nconst sysPath$2 = require$$0$2;\nconst { promisify: promisify$2 } = require$$2;\nconst isBinaryPath = isBinaryPath$1;\nconst {\n  isWindows: isWindows$1,\n  isLinux,\n  EMPTY_FN: EMPTY_FN$2,\n  EMPTY_STR: EMPTY_STR$1,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE: EV_CHANGE$2,\n  EV_ADD: EV_ADD$2,\n  EV_ADD_DIR: EV_ADD_DIR$2,\n  EV_ERROR: EV_ERROR$2,\n  STR_DATA: STR_DATA$1,\n  STR_END: STR_END$2,\n  BRACE_START: BRACE_START$1,\n  STAR\n} = constants;\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify$2(fs$2.open);\nconst stat$2 = promisify$2(fs$2.stat);\nconst lstat$1 = promisify$2(fs$2.lstat);\nconst close = promisify$2(fs$2.close);\nconst fsrealpath = promisify$2(fs$2.realpath);\n\nconst statMethods$1 = { lstat: lstat$1, stat: stat$2 };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath$2.resolve(path, evPath), KEY_LISTENERS, sysPath$2.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs$2.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR$2, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows$1 && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    fs$2.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs$2.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE$2, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs$2.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nclass NodeFsHandler$1 {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath$2.dirname(path);\n  const basename = sysPath$2.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath$2.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN$2;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath$2.dirname(file);\n  const basename = sysPath$2.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  const listener = async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat$2(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE$2, file, newStats);\n        }\n        if (isLinux && prevStats.ino !== newStats.ino) {\n          this.fsw._closeFile(path);\n          prevStats = newStats;\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n        } else {\n          prevStats = newStats;\n        }\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE$2, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  };\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, listener);\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;\n    this.fsw._emit(EV_ADD$2, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n\n    let linkPath;\n    try {\n      linkPath = await fsrealpath(path);\n    } catch (e) {\n      this.fsw._emitReady();\n      return true;\n    }\n\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE$2, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD$2, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath$2.join(directory, EMPTY_STR$1);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA$1, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath$2.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath$2.join(dir, sysPath$2.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR$2, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END$2, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath$2.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));\n  const tracked = parentDir.has(sysPath$2.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath$2.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods$1[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START$1);\n    let closer;\n    if (stats.isDirectory()) {\n      const absPath = sysPath$2.resolve(path);\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (absPath !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(absPath, targetPath);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath$2.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD$2, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath$2.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n}\n\nvar nodefsHandler = NodeFsHandler$1;\n\nvar fseventsHandler = {exports: {}};\n\nconst require$$3 = /*@__PURE__*/getAugmentedNamespace(fseventsImporter);\n\nconst fs$1 = require$$0$1;\nconst sysPath$1 = require$$0$2;\nconst { promisify: promisify$1 } = require$$2;\n\nlet fsevents;\ntry {\n  fsevents = require$$3.getFsEvents();\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD: EV_ADD$1,\n  EV_CHANGE: EV_CHANGE$1,\n  EV_ADD_DIR: EV_ADD_DIR$1,\n  EV_UNLINK: EV_UNLINK$1,\n  EV_ERROR: EV_ERROR$1,\n  STR_DATA,\n  STR_END: STR_END$1,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE: FUNCTION_TYPE$1,\n  EMPTY_FN: EMPTY_FN$1,\n  IDENTITY_FN\n} = constants;\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat$1 = promisify$1(fs$1.stat);\nconst lstat = promisify$1(fs$1.lstat);\nconst realpath = promisify$1(fs$1.realpath);\n\nconst statMethods = { stat: stat$1, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;\n\n  const parentPath = sysPath$1.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath$1.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath$1.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath$1.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n);\n\n/**\n * @mixin\n */\nclass FsEventsHandler$1 {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat$1(path);\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK$1) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD$1) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath$1.join(\n      watchPath, sysPath$1.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath$1.dirname(path);\n    const item = sysPath$1.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE$1) {\n        let stats;\n        try {\n          stats = await stat$1(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath$1.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));\n  const base = sysPath$1.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath$1.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE$1 ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath$1.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE$1) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n}\n\nfseventsHandler.exports = FsEventsHandler$1;\nfseventsHandler.exports.canUse = canUse;\n\nconst { EventEmitter } = require$$0$3;\nconst fs = require$$0$1;\nconst sysPath = require$$0$2;\nconst { promisify } = require$$2;\nconst readdirp = readdirp_1;\nconst anymatch = anymatch$2.exports.default;\nconst globParent = globParent$1;\nconst isGlob = isGlob$2;\nconst braces = braces_1;\nconst normalizePath = normalizePath$2;\n\nconst NodeFsHandler = nodefsHandler;\nconst FsEventsHandler = fseventsHandler.exports;\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos,\n  isIBMi\n} = constants;\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n  if(isIBMi) {\n    opts.usePolling = true;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // You’re frozen when your heart’s not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n  // but never removed from the map in case the path was deleted.\n  // This leads to an incorrect state if the path was recreated:\n  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n  if (this._symlinkPaths.has(fullPath)) {\n    this._symlinkPaths.delete(fullPath);\n  }\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path);\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nchokidar.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nchokidar.watch = watch;\n\nclass FileWatcher {\n    constructor(task, chokidarOptions) {\n        this.transformWatchers = new Map();\n        this.chokidarOptions = chokidarOptions;\n        this.task = task;\n        this.watcher = this.createWatcher(null);\n    }\n    close() {\n        this.watcher.close();\n        for (const watcher of this.transformWatchers.values()) {\n            watcher.close();\n        }\n    }\n    unwatch(id) {\n        this.watcher.unwatch(id);\n        const transformWatcher = this.transformWatchers.get(id);\n        if (transformWatcher) {\n            this.transformWatchers.delete(id);\n            transformWatcher.close();\n        }\n    }\n    watch(id, isTransformDependency) {\n        var _a;\n        if (isTransformDependency) {\n            const watcher = (_a = this.transformWatchers.get(id)) !== null && _a !== void 0 ? _a : this.createWatcher(id);\n            watcher.add(id);\n            this.transformWatchers.set(id, watcher);\n        }\n        else {\n            this.watcher.add(id);\n        }\n    }\n    createWatcher(transformWatcherId) {\n        const task = this.task;\n        const isLinux = platform() === 'linux';\n        const isTransformDependency = transformWatcherId !== null;\n        const handleChange = (id, event) => {\n            const changedId = transformWatcherId || id;\n            if (isLinux) {\n                // unwatching and watching fixes an issue with chokidar where on certain systems,\n                // a file that was unlinked and immediately recreated would create a change event\n                // but then no longer any further events\n                watcher.unwatch(changedId);\n                watcher.add(changedId);\n            }\n            task.invalidate(changedId, { event, isTransformDependency });\n        };\n        const watcher = chokidar\n            .watch([], this.chokidarOptions)\n            .on('add', id => handleChange(id, 'create'))\n            .on('change', id => handleChange(id, 'update'))\n            .on('unlink', id => handleChange(id, 'delete'));\n        return watcher;\n    }\n}\n\nconst eventsRewrites = {\n    create: {\n        create: 'buggy',\n        delete: null,\n        update: 'create'\n    },\n    delete: {\n        create: 'update',\n        delete: 'buggy',\n        update: 'buggy'\n    },\n    update: {\n        create: 'buggy',\n        delete: 'delete',\n        update: 'update'\n    }\n};\nclass Watcher {\n    constructor(configs, emitter) {\n        this.buildDelay = 0;\n        this.buildTimeout = null;\n        this.invalidatedIds = new Map();\n        this.rerun = false;\n        this.running = true;\n        this.emitter = emitter;\n        emitter.close = this.close.bind(this);\n        this.tasks = configs.map(config => new Task(this, config));\n        this.buildDelay = configs.reduce((buildDelay, { watch }) => watch && typeof watch.buildDelay === 'number'\n            ? Math.max(buildDelay, watch.buildDelay)\n            : buildDelay, this.buildDelay);\n        process$1.nextTick(() => this.run());\n    }\n    async close() {\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        for (const task of this.tasks) {\n            task.close();\n        }\n        await this.emitter.emitAndAwait('close');\n        this.emitter.removeAllListeners();\n    }\n    invalidate(file) {\n        if (file) {\n            const prevEvent = this.invalidatedIds.get(file.id);\n            const event = prevEvent ? eventsRewrites[prevEvent][file.event] : file.event;\n            if (event === 'buggy') {\n                //TODO: throws or warn? Currently just ignore, uses new event\n                this.invalidatedIds.set(file.id, file.event);\n            }\n            else if (event === null) {\n                this.invalidatedIds.delete(file.id);\n            }\n            else {\n                this.invalidatedIds.set(file.id, event);\n            }\n        }\n        if (this.running) {\n            this.rerun = true;\n            return;\n        }\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        this.buildTimeout = setTimeout(async () => {\n            this.buildTimeout = null;\n            try {\n                await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emitAndAwait('change', id, { event })));\n                this.invalidatedIds.clear();\n                this.emitter.emit('restart');\n                this.emitter.removeAwaited();\n                this.run();\n            }\n            catch (error) {\n                this.invalidatedIds.clear();\n                this.emitter.emit('event', {\n                    code: 'ERROR',\n                    error,\n                    result: null\n                });\n                this.emitter.emit('event', {\n                    code: 'END'\n                });\n            }\n        }, this.buildDelay);\n    }\n    async run() {\n        this.running = true;\n        this.emitter.emit('event', {\n            code: 'START'\n        });\n        for (const task of this.tasks) {\n            await task.run();\n        }\n        this.running = false;\n        this.emitter.emit('event', {\n            code: 'END'\n        });\n        if (this.rerun) {\n            this.rerun = false;\n            this.invalidate();\n        }\n    }\n}\nclass Task {\n    constructor(watcher, config) {\n        this.cache = { modules: [] };\n        this.watchFiles = [];\n        this.closed = false;\n        this.invalidated = true;\n        this.watched = new Set();\n        this.watcher = watcher;\n        this.skipWrite = Boolean(config.watch && config.watch.skipWrite);\n        this.options = mergeOptions(config);\n        this.outputs = this.options.output;\n        this.outputFiles = this.outputs.map(output => {\n            if (output.file || output.dir)\n                return resolve(output.file || output.dir);\n            return undefined;\n        });\n        const watchOptions = this.options.watch || {};\n        this.filter = createFilter(watchOptions.include, watchOptions.exclude);\n        this.fileWatcher = new FileWatcher(this, {\n            ...watchOptions.chokidar,\n            disableGlobbing: true,\n            ignoreInitial: true\n        });\n    }\n    close() {\n        this.closed = true;\n        this.fileWatcher.close();\n    }\n    invalidate(id, details) {\n        this.invalidated = true;\n        if (details.isTransformDependency) {\n            for (const module of this.cache.modules) {\n                if (!module.transformDependencies.includes(id))\n                    continue;\n                // effective invalidation\n                module.originalCode = null;\n            }\n        }\n        this.watcher.invalidate({ event: details.event, id });\n    }\n    async run() {\n        if (!this.invalidated)\n            return;\n        this.invalidated = false;\n        const options = {\n            ...this.options,\n            cache: this.cache\n        };\n        const start = Date.now();\n        this.watcher.emitter.emit('event', {\n            code: 'BUNDLE_START',\n            input: this.options.input,\n            output: this.outputFiles\n        });\n        let result = null;\n        try {\n            result = await rollupInternal(options, this.watcher.emitter);\n            if (this.closed) {\n                return;\n            }\n            this.updateWatchedFiles(result);\n            this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));\n            this.watcher.emitter.emit('event', {\n                code: 'BUNDLE_END',\n                duration: Date.now() - start,\n                input: this.options.input,\n                output: this.outputFiles,\n                result\n            });\n        }\n        catch (error) {\n            if (!this.closed) {\n                if (Array.isArray(error.watchFiles)) {\n                    for (const id of error.watchFiles) {\n                        this.watchFile(id);\n                    }\n                }\n                if (error.id) {\n                    this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n                }\n            }\n            this.watcher.emitter.emit('event', {\n                code: 'ERROR',\n                error,\n                result\n            });\n        }\n    }\n    updateWatchedFiles(result) {\n        const previouslyWatched = this.watched;\n        this.watched = new Set();\n        this.watchFiles = result.watchFiles;\n        this.cache = result.cache;\n        for (const id of this.watchFiles) {\n            this.watchFile(id);\n        }\n        for (const module of this.cache.modules) {\n            for (const depId of module.transformDependencies) {\n                this.watchFile(depId, true);\n            }\n        }\n        for (const id of previouslyWatched) {\n            if (!this.watched.has(id)) {\n                this.fileWatcher.unwatch(id);\n            }\n        }\n    }\n    watchFile(id, isTransformDependency = false) {\n        if (!this.filter(id))\n            return;\n        this.watched.add(id);\n        if (this.outputFiles.some(file => file === id)) {\n            throw new Error('Cannot import the generated bundle');\n        }\n        // this is necessary to ensure that any 'renamed' files\n        // continue to be watched following an error\n        this.fileWatcher.watch(id, isTransformDependency);\n    }\n}\n\nexport { Task, Watcher };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}