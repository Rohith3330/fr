{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar mapping_entry_1 = require(\"../mapping-entry\");\n\nvar path_1 = require(\"path\");\n\ndescribe(\"mapping-entry\", function () {\n  it(\"should change to absolute paths and sort in longest prefix order\", function () {\n    var result = (0, mapping_entry_1.getAbsoluteMappingEntries)(\"/absolute/base/url\", {\n      \"*\": [\"/foo1\", \"/foo2\"],\n      \"longest/pre/fix/*\": [\"/foo2/bar\"],\n      \"pre/fix/*\": [\"/foo3\"]\n    }, true); // assert.deepEqual(result, [\n    //   {\n    //     pattern: \"longest/pre/fix/*\",\n    //     paths: [join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\")],\n    //   },\n    //   {\n    //     pattern: \"pre/fix/*\",\n    //     paths: [join(\"/absolute\", \"base\", \"url\", \"foo3\")],\n    //   },\n    //   {\n    //     pattern: \"*\",\n    //     paths: [\n    //       join(\"/absolute\", \"base\", \"url\", \"foo1\"),\n    //       join(\"/absolute\", \"base\", \"url\", \"foo2\"),\n    //     ],\n    //   },\n    // ]);\n\n    expect(result).toEqual([{\n      pattern: \"longest/pre/fix/*\",\n      paths: [(0, path_1.join)(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\")]\n    }, {\n      pattern: \"pre/fix/*\",\n      paths: [(0, path_1.join)(\"/absolute\", \"base\", \"url\", \"foo3\")]\n    }, {\n      pattern: \"*\",\n      paths: [(0, path_1.join)(\"/absolute\", \"base\", \"url\", \"foo1\"), (0, path_1.join)(\"/absolute\", \"base\", \"url\", \"foo2\")]\n    }]);\n  });\n  it(\"should should add a match-all pattern when requested\", function () {\n    var result = (0, mapping_entry_1.getAbsoluteMappingEntries)(\"/absolute/base/url\", {}, true); // assert.deepEqual(result, [\n    //   {\n    //     pattern: \"*\",\n    //     paths: [join(\"/absolute\", \"base\", \"url\", \"*\")],\n    //   },\n    // ]);\n\n    expect(result).toEqual([{\n      pattern: \"*\",\n      paths: [(0, path_1.join)(\"/absolute\", \"base\", \"url\", \"*\")]\n    }]);\n    result = (0, mapping_entry_1.getAbsoluteMappingEntries)(\"/absolute/base/url\", {}, false); // assert.deepEqual(result, []);\n\n    expect(result).toEqual([]);\n  });\n});","map":{"version":3,"mappings":";;;;;;AAAA;;AACA;;AAEAA,QAAQ,CAAC,eAAD,EAAkB;EACxBC,EAAE,CAAC,kEAAD,EAAqE;IACrE,IAAMC,MAAM,GAAG,+CACb,oBADa,EAEb;MACE,KAAK,CAAC,OAAD,EAAU,OAAV,CADP;MAEE,qBAAqB,CAAC,WAAD,CAFvB;MAGE,aAAa,CAAC,OAAD;IAHf,CAFa,EAOb,IAPa,CAAf,CADqE,CAUrE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IACAC,MAAM,CAACD,MAAD,CAAN,CAAeE,OAAf,CAAuB,CACrB;MACEC,OAAO,EAAE,mBADX;MAEEC,KAAK,EAAE,CAAC,iBAAK,WAAL,EAAkB,MAAlB,EAA0B,KAA1B,EAAiC,MAAjC,EAAyC,KAAzC,CAAD;IAFT,CADqB,EAKrB;MACED,OAAO,EAAE,WADX;MAEEC,KAAK,EAAE,CAAC,iBAAK,WAAL,EAAkB,MAAlB,EAA0B,KAA1B,EAAiC,MAAjC,CAAD;IAFT,CALqB,EASrB;MACED,OAAO,EAAE,GADX;MAEEC,KAAK,EAAE,CACL,iBAAK,WAAL,EAAkB,MAAlB,EAA0B,KAA1B,EAAiC,MAAjC,CADK,EAEL,iBAAK,WAAL,EAAkB,MAAlB,EAA0B,KAA1B,EAAiC,MAAjC,CAFK;IAFT,CATqB,CAAvB;EAiBD,CA5CC,CAAF;EA8CAL,EAAE,CAAC,sDAAD,EAAyD;IACzD,IAAIC,MAAM,GAAG,+CAA0B,oBAA1B,EAAgD,EAAhD,EAAoD,IAApD,CAAb,CADyD,CAEzD;IACA;IACA;IACA;IACA;IACA;;IACAC,MAAM,CAACD,MAAD,CAAN,CAAeE,OAAf,CAAuB,CACrB;MACEC,OAAO,EAAE,GADX;MAEEC,KAAK,EAAE,CAAC,iBAAK,WAAL,EAAkB,MAAlB,EAA0B,KAA1B,EAAiC,GAAjC,CAAD;IAFT,CADqB,CAAvB;IAOAJ,MAAM,GAAG,+CAA0B,oBAA1B,EAAgD,EAAhD,EAAoD,KAApD,CAAT,CAfyD,CAgBzD;;IACAC,MAAM,CAACD,MAAD,CAAN,CAAeE,OAAf,CAAuB,EAAvB;EACD,CAlBC,CAAF;AAmBD,CAlEO,CAAR","names":["describe","it","result","expect","toEqual","pattern","paths"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\tsconfig-paths\\src\\__tests__\\mapping-entry.test.ts"],"sourcesContent":["import { getAbsoluteMappingEntries } from \"../mapping-entry\";\nimport { join } from \"path\";\n\ndescribe(\"mapping-entry\", () => {\n  it(\"should change to absolute paths and sort in longest prefix order\", () => {\n    const result = getAbsoluteMappingEntries(\n      \"/absolute/base/url\",\n      {\n        \"*\": [\"/foo1\", \"/foo2\"],\n        \"longest/pre/fix/*\": [\"/foo2/bar\"],\n        \"pre/fix/*\": [\"/foo3\"],\n      },\n      true\n    );\n    // assert.deepEqual(result, [\n    //   {\n    //     pattern: \"longest/pre/fix/*\",\n    //     paths: [join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\")],\n    //   },\n    //   {\n    //     pattern: \"pre/fix/*\",\n    //     paths: [join(\"/absolute\", \"base\", \"url\", \"foo3\")],\n    //   },\n    //   {\n    //     pattern: \"*\",\n    //     paths: [\n    //       join(\"/absolute\", \"base\", \"url\", \"foo1\"),\n    //       join(\"/absolute\", \"base\", \"url\", \"foo2\"),\n    //     ],\n    //   },\n    // ]);\n    expect(result).toEqual([\n      {\n        pattern: \"longest/pre/fix/*\",\n        paths: [join(\"/absolute\", \"base\", \"url\", \"foo2\", \"bar\")],\n      },\n      {\n        pattern: \"pre/fix/*\",\n        paths: [join(\"/absolute\", \"base\", \"url\", \"foo3\")],\n      },\n      {\n        pattern: \"*\",\n        paths: [\n          join(\"/absolute\", \"base\", \"url\", \"foo1\"),\n          join(\"/absolute\", \"base\", \"url\", \"foo2\"),\n        ],\n      },\n    ]);\n  });\n\n  it(\"should should add a match-all pattern when requested\", () => {\n    let result = getAbsoluteMappingEntries(\"/absolute/base/url\", {}, true);\n    // assert.deepEqual(result, [\n    //   {\n    //     pattern: \"*\",\n    //     paths: [join(\"/absolute\", \"base\", \"url\", \"*\")],\n    //   },\n    // ]);\n    expect(result).toEqual([\n      {\n        pattern: \"*\",\n        paths: [join(\"/absolute\", \"base\", \"url\", \"*\")],\n      },\n    ]);\n\n    result = getAbsoluteMappingEntries(\"/absolute/base/url\", {}, false);\n    // assert.deepEqual(result, []);\n    expect(result).toEqual([]);\n  });\n});\n"]},"metadata":{},"sourceType":"script"}