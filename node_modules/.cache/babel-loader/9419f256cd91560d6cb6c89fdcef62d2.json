{"ast":null,"code":"'use strict';\n\nconst check = require('check-types');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst events = require('./events');\n\nconst promise = require('./promise');\n\nconst invalidTypes = {\n  undefined: true,\n  // eslint-disable-line no-undefined\n  function: true,\n  symbol: true\n};\nmodule.exports = eventify;\n/**\n * Public function `eventify`.\n *\n * Returns an event emitter and asynchronously traverses a data structure\n * (depth-first), emitting events as it encounters items. Sanely handles\n * promises, buffers, maps and other iterables. The event emitter is\n * decorated with a `pause` method that can be called to pause processing.\n *\n * @param data:       The data structure to traverse.\n *\n * @option promises:  'resolve' or 'ignore', default is 'resolve'.\n *\n * @option buffers:   'toString' or 'ignore', default is 'toString'.\n *\n * @option maps:      'object' or 'ignore', default is 'object'.\n *\n * @option iterables:  'array' or 'ignore', default is 'array'.\n *\n * @option circular:   'error' or 'ignore', default is 'error'.\n *\n * @option yieldRate:  The number of data items to process per timeslice,\n *                     default is 16384.\n *\n * @option Promise:      The promise constructor to use, defaults to bluebird.\n **/\n\nfunction eventify(data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const coercions = {};\n  const emitter = new EventEmitter();\n  const Promise = promise(options);\n  const references = new Map();\n  let count = 0;\n  let disableCoercions = false;\n  let ignoreCircularReferences;\n  let ignoreItems;\n  let pause;\n  let yieldRate;\n\n  emitter.pause = () => {\n    let resolve;\n    pause = new Promise(res => resolve = res);\n    return () => {\n      pause = null;\n      count = 0;\n      resolve();\n    };\n  };\n\n  parseOptions();\n  setImmediate(begin);\n  return emitter;\n\n  function parseOptions() {\n    parseCoercionOption('promises');\n    parseCoercionOption('buffers');\n    parseCoercionOption('maps');\n    parseCoercionOption('iterables');\n\n    if (Object.keys(coercions).length === 0) {\n      disableCoercions = true;\n    }\n\n    if (options.circular === 'ignore') {\n      ignoreCircularReferences = true;\n    }\n\n    check.assert.maybe.positive(options.yieldRate);\n    yieldRate = options.yieldRate || 16384;\n  }\n\n  function parseCoercionOption(key) {\n    if (options[key] !== 'ignore') {\n      coercions[key] = true;\n    }\n  }\n\n  function begin() {\n    return proceed(data).catch(error => emit(events.error, error)).then(() => emit(events.end));\n  }\n\n  function proceed(datum) {\n    if (++count % yieldRate !== 0) {\n      return coerce(datum).then(after);\n    }\n\n    return new Promise((resolve, reject) => {\n      setImmediate(() => {\n        coerce(datum).then(after).then(resolve).catch(reject);\n      });\n    });\n\n    function after(coerced) {\n      if (isInvalid(coerced)) {\n        return;\n      }\n\n      if (coerced === false || coerced === true || coerced === null) {\n        return literal(coerced);\n      }\n\n      if (Array.isArray(coerced)) {\n        return array(coerced);\n      }\n\n      const type = typeof coerced;\n\n      switch (type) {\n        case 'number':\n          return value(coerced, type);\n\n        case 'string':\n          return value(escapeString(coerced), type);\n\n        default:\n          return object(coerced);\n      }\n    }\n  }\n\n  function coerce(datum) {\n    if (disableCoercions || check.primitive(datum)) {\n      return Promise.resolve(datum);\n    }\n\n    if (check.thenable(datum)) {\n      return coerceThing(datum, 'promises', coercePromise).then(coerce);\n    }\n\n    if (check.instanceStrict(datum, Buffer)) {\n      return coerceThing(datum, 'buffers', coerceBuffer);\n    }\n\n    if (check.instanceStrict(datum, Map)) {\n      return coerceThing(datum, 'maps', coerceMap);\n    }\n\n    if (check.iterable(datum) && check.not.string(datum) && check.not.array(datum)) {\n      return coerceThing(datum, 'iterables', coerceIterable);\n    }\n\n    if (check.function(datum.toJSON)) {\n      return Promise.resolve(datum.toJSON());\n    }\n\n    return Promise.resolve(datum);\n  }\n\n  function coerceThing(datum, thing, fn) {\n    if (coercions[thing]) {\n      return fn(datum);\n    }\n\n    return Promise.resolve();\n  }\n\n  function coercePromise(p) {\n    return p;\n  }\n\n  function coerceBuffer(buffer) {\n    return Promise.resolve(buffer.toString());\n  }\n\n  function coerceMap(map) {\n    const result = {};\n    return coerceCollection(map, result, (item, key) => {\n      result[key] = item;\n    });\n  }\n\n  function coerceCollection(coll, target, push) {\n    coll.forEach(push);\n    return Promise.resolve(target);\n  }\n\n  function coerceIterable(iterable) {\n    const result = [];\n    return coerceCollection(iterable, result, item => {\n      result.push(item);\n    });\n  }\n\n  function isInvalid(datum) {\n    const type = typeof datum;\n    return !!invalidTypes[type] || type === 'number' && !isValidNumber(datum);\n  }\n\n  function isValidNumber(datum) {\n    return datum > Number.NEGATIVE_INFINITY && datum < Number.POSITIVE_INFINITY;\n  }\n\n  function literal(datum) {\n    return value(datum, 'literal');\n  }\n\n  function value(datum, type) {\n    return emit(events[type], datum);\n  }\n\n  function emit(event, eventData) {\n    return (pause || Promise.resolve()).then(() => emitter.emit(event, eventData)).catch(err => {\n      try {\n        emitter.emit(events.error, err);\n      } catch (_) {// When calling user code, anything is possible\n      }\n    });\n  }\n\n  function array(datum) {\n    // For an array, collection:object and collection:array are the same.\n    return collection(datum, datum, 'array', item => {\n      if (isInvalid(item)) {\n        return proceed(null);\n      }\n\n      return proceed(item);\n    });\n  }\n\n  function collection(obj, arr, type, action) {\n    let ignoreThisItem;\n    return Promise.resolve().then(() => {\n      if (references.has(obj)) {\n        ignoreThisItem = ignoreItems = true;\n\n        if (!ignoreCircularReferences) {\n          return emit(events.dataError, new Error('Circular reference.'));\n        }\n      } else {\n        references.set(obj, true);\n      }\n    }).then(() => emit(events[type])).then(() => item(0));\n\n    function item(index) {\n      if (index >= arr.length) {\n        if (ignoreThisItem) {\n          ignoreItems = false;\n        }\n\n        if (ignoreItems) {\n          return Promise.resolve();\n        }\n\n        return emit(events.endPrefix + events[type]).then(() => references.delete(obj));\n      }\n\n      if (ignoreItems) {\n        return item(index + 1);\n      }\n\n      return action(arr[index]).then(() => item(index + 1));\n    }\n  }\n\n  function object(datum) {\n    // For an object, collection:object and collection:array are different.\n    return collection(datum, Object.keys(datum), 'object', key => {\n      const item = datum[key];\n\n      if (isInvalid(item)) {\n        return Promise.resolve();\n      }\n\n      return emit(events.property, escapeString(key)).then(() => proceed(item));\n    });\n  }\n\n  function escapeString(string) {\n    string = JSON.stringify(string);\n    return string.substring(1, string.length - 1);\n  }\n}","map":{"version":3,"names":["check","require","EventEmitter","events","promise","invalidTypes","undefined","function","symbol","module","exports","eventify","data","options","coercions","emitter","Promise","references","Map","count","disableCoercions","ignoreCircularReferences","ignoreItems","pause","yieldRate","resolve","res","parseOptions","setImmediate","begin","parseCoercionOption","Object","keys","length","circular","assert","maybe","positive","key","proceed","catch","error","emit","then","end","datum","coerce","after","reject","coerced","isInvalid","literal","Array","isArray","array","type","value","escapeString","object","primitive","thenable","coerceThing","coercePromise","instanceStrict","Buffer","coerceBuffer","coerceMap","iterable","not","string","coerceIterable","toJSON","thing","fn","p","buffer","toString","map","result","coerceCollection","item","coll","target","push","forEach","isValidNumber","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","event","eventData","err","_","collection","obj","arr","action","ignoreThisItem","has","dataError","Error","set","index","endPrefix","delete","property","JSON","stringify","substring"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/bfj/src/eventify.js"],"sourcesContent":["'use strict'\n\nconst check = require('check-types')\nconst EventEmitter = require('events').EventEmitter\nconst events = require('./events')\nconst promise = require('./promise')\n\nconst invalidTypes = {\n  undefined: true, // eslint-disable-line no-undefined\n  function: true,\n  symbol: true\n}\n\nmodule.exports = eventify\n\n/**\n * Public function `eventify`.\n *\n * Returns an event emitter and asynchronously traverses a data structure\n * (depth-first), emitting events as it encounters items. Sanely handles\n * promises, buffers, maps and other iterables. The event emitter is\n * decorated with a `pause` method that can be called to pause processing.\n *\n * @param data:       The data structure to traverse.\n *\n * @option promises:  'resolve' or 'ignore', default is 'resolve'.\n *\n * @option buffers:   'toString' or 'ignore', default is 'toString'.\n *\n * @option maps:      'object' or 'ignore', default is 'object'.\n *\n * @option iterables:  'array' or 'ignore', default is 'array'.\n *\n * @option circular:   'error' or 'ignore', default is 'error'.\n *\n * @option yieldRate:  The number of data items to process per timeslice,\n *                     default is 16384.\n *\n * @option Promise:      The promise constructor to use, defaults to bluebird.\n **/\nfunction eventify (data, options = {}) {\n  const coercions = {}\n  const emitter = new EventEmitter()\n  const Promise = promise(options)\n  const references = new Map()\n\n  let count = 0\n  let disableCoercions = false\n  let ignoreCircularReferences\n  let ignoreItems\n  let pause\n  let yieldRate\n\n  emitter.pause = () => {\n    let resolve\n    pause = new Promise(res => resolve = res)\n    return () => {\n      pause = null\n      count = 0\n      resolve()\n    }\n  }\n  parseOptions()\n  setImmediate(begin)\n\n  return emitter\n\n  function parseOptions () {\n    parseCoercionOption('promises')\n    parseCoercionOption('buffers')\n    parseCoercionOption('maps')\n    parseCoercionOption('iterables')\n\n    if (Object.keys(coercions).length === 0) {\n      disableCoercions = true\n    }\n\n    if (options.circular === 'ignore') {\n      ignoreCircularReferences = true\n    }\n\n    check.assert.maybe.positive(options.yieldRate)\n    yieldRate = options.yieldRate || 16384\n  }\n\n  function parseCoercionOption (key) {\n    if (options[key] !== 'ignore') {\n      coercions[key] = true\n    }\n  }\n\n  function begin () {\n    return proceed(data)\n      .catch(error => emit(events.error, error))\n      .then(() => emit(events.end))\n  }\n\n  function proceed (datum) {\n    if (++count % yieldRate !== 0) {\n      return coerce(datum).then(after)\n    }\n\n    return new Promise((resolve, reject) => {\n      setImmediate(() => {\n        coerce(datum)\n          .then(after)\n          .then(resolve)\n          .catch(reject)\n      })\n    })\n\n    function after (coerced) {\n      if (isInvalid(coerced)) {\n        return\n      }\n\n      if (coerced === false || coerced === true || coerced === null) {\n        return literal(coerced)\n      }\n\n      if (Array.isArray(coerced)) {\n        return array(coerced)\n      }\n\n      const type = typeof coerced\n\n      switch (type) {\n        case 'number':\n          return value(coerced, type)\n        case 'string':\n          return value(escapeString(coerced), type)\n        default:\n          return object(coerced)\n      }\n    }\n  }\n\n  function coerce (datum) {\n    if (disableCoercions || check.primitive(datum)) {\n      return Promise.resolve(datum)\n    }\n\n    if (check.thenable(datum)) {\n      return coerceThing(datum, 'promises', coercePromise).then(coerce)\n    }\n\n    if (check.instanceStrict(datum, Buffer)) {\n      return coerceThing(datum, 'buffers', coerceBuffer)\n    }\n\n    if (check.instanceStrict(datum, Map)) {\n      return coerceThing(datum, 'maps', coerceMap)\n    }\n\n    if (\n      check.iterable(datum) &&\n      check.not.string(datum) &&\n      check.not.array(datum)\n    ) {\n      return coerceThing(datum, 'iterables', coerceIterable)\n    }\n\n    if (check.function(datum.toJSON)) {\n      return Promise.resolve(datum.toJSON())\n    }\n\n    return Promise.resolve(datum)\n  }\n\n  function coerceThing (datum, thing, fn) {\n    if (coercions[thing]) {\n      return fn(datum)\n    }\n\n    return Promise.resolve()\n  }\n\n  function coercePromise (p) {\n    return p\n  }\n\n  function coerceBuffer (buffer) {\n    return Promise.resolve(buffer.toString())\n  }\n\n  function coerceMap (map) {\n    const result = {}\n\n    return coerceCollection(map, result, (item, key) => {\n      result[key] = item\n    })\n  }\n\n  function coerceCollection (coll, target, push) {\n    coll.forEach(push)\n\n    return Promise.resolve(target)\n  }\n\n  function coerceIterable (iterable) {\n    const result = []\n\n    return coerceCollection(iterable, result, item => {\n      result.push(item)\n    })\n  }\n\n  function isInvalid (datum) {\n    const type = typeof datum\n    return !! invalidTypes[type] || (\n      type === 'number' && ! isValidNumber(datum)\n    )\n  }\n\n  function isValidNumber (datum) {\n    return datum > Number.NEGATIVE_INFINITY && datum < Number.POSITIVE_INFINITY\n  }\n\n  function literal (datum) {\n    return value(datum, 'literal')\n  }\n\n  function value (datum, type) {\n    return emit(events[type], datum)\n  }\n\n  function emit (event, eventData) {\n    return (pause || Promise.resolve())\n      .then(() => emitter.emit(event, eventData))\n      .catch(err => {\n        try {\n          emitter.emit(events.error, err)\n        } catch (_) {\n          // When calling user code, anything is possible\n        }\n      })\n  }\n\n  function array (datum) {\n    // For an array, collection:object and collection:array are the same.\n    return collection(datum, datum, 'array', item => {\n      if (isInvalid(item)) {\n        return proceed(null)\n      }\n\n      return proceed(item)\n    })\n  }\n\n  function collection (obj, arr, type, action) {\n    let ignoreThisItem\n\n    return Promise.resolve()\n      .then(() => {\n        if (references.has(obj)) {\n          ignoreThisItem = ignoreItems = true\n\n          if (! ignoreCircularReferences) {\n            return emit(events.dataError, new Error('Circular reference.'))\n          }\n        } else {\n          references.set(obj, true)\n        }\n      })\n      .then(() => emit(events[type]))\n      .then(() => item(0))\n\n    function item (index) {\n      if (index >= arr.length) {\n        if (ignoreThisItem) {\n          ignoreItems = false\n        }\n\n        if (ignoreItems) {\n          return Promise.resolve()\n        }\n\n        return emit(events.endPrefix + events[type])\n          .then(() => references.delete(obj))\n      }\n\n      if (ignoreItems) {\n        return item(index + 1)\n      }\n\n      return action(arr[index])\n        .then(() => item(index + 1))\n    }\n  }\n\n  function object (datum) {\n    // For an object, collection:object and collection:array are different.\n    return collection(datum, Object.keys(datum), 'object', key => {\n      const item = datum[key]\n\n      if (isInvalid(item)) {\n        return Promise.resolve()\n      }\n\n      return emit(events.property, escapeString(key))\n        .then(() => proceed(item))\n    })\n  }\n\n  function escapeString (string) {\n    string = JSON.stringify(string)\n    return string.substring(1, string.length - 1)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}