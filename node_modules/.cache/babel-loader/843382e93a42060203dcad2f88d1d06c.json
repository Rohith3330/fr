{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        missingProperty\n      }\n    } = _ref;\n    return (0, codegen_1.str)`must have required property '${missingProperty}'`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        missingProperty\n      }\n    } = _ref2;\n    return (0, codegen_1._)`{missingProperty: ${missingProperty}}`;\n  }\n};\nconst def = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      schemaCode,\n      data,\n      $data,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    if (!$data && schema.length === 0) return;\n    const useLoop = schema.length >= opts.loopRequired;\n    if (it.allErrors) allErrorsMode();else exitOnErrorMode();\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties;\n      const {\n        definedProperties\n      } = cxt.it;\n\n      for (const requiredKey of schema) {\n        if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`;\n          (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);\n        }\n      }\n    }\n\n    function allErrorsMode() {\n      if (useLoop || $data) {\n        cxt.block$data(codegen_1.nil, loopAllRequired);\n      } else {\n        for (const prop of schema) {\n          (0, code_1.checkReportMissingProp)(cxt, prop);\n        }\n      }\n    }\n\n    function exitOnErrorMode() {\n      const missing = gen.let(\"missing\");\n\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true);\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid));\n        cxt.ok(valid);\n      } else {\n        gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));\n        (0, code_1.reportMissingProp)(cxt, missing);\n        gen.else();\n      }\n    }\n\n    function loopAllRequired() {\n      gen.forOf(\"prop\", schemaCode, prop => {\n        cxt.setParams({\n          missingProperty: prop\n        });\n        gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());\n      });\n    }\n\n    function loopUntilMissing(missing, valid) {\n      cxt.setParams({\n        missingProperty: missing\n      });\n      gen.forOf(missing, schemaCode, () => {\n        gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));\n        gen.if((0, codegen_1.not)(valid), () => {\n          cxt.error();\n          gen.break();\n        });\n      }, codegen_1.nil);\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","missingProperty","def","keyword","type","schemaType","$data","code","cxt","gen","schema","schemaCode","data","it","opts","length","useLoop","loopRequired","allErrors","allErrorsMode","exitOnErrorMode","strictRequired","props","parentSchema","properties","definedProperties","requiredKey","undefined","has","schemaPath","schemaEnv","baseId","errSchemaPath","msg","block$data","codegen_1","loopAllRequired","prop","missing","let","valid","loopUntilMissing","ok","if","else","forOf","setParams","ownProperties","assign","break","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\mini-css-extract-plugin\\node_modules\\ajv\\lib\\vocabularies\\validation\\required.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}