{"ast":null,"code":"/**\n * XmlHttpRequest implementation that uses TLS and flash SocketPool.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nrequire('./socket');\n\nrequire('./http');\n/* XHR API */\n\n\nvar xhrApi = module.exports = forge.xhr = forge.xhr || {};\n\n(function ($) {\n  // logging category\n  var cat = 'forge.xhr';\n  /*\n  XMLHttpRequest interface definition from:\n  http://www.w3.org/TR/XMLHttpRequest\n  \n  interface XMLHttpRequest {\n    // event handler\n    attribute EventListener onreadystatechange;\n  \n    // state\n    const unsigned short UNSENT = 0;\n    const unsigned short OPENED = 1;\n    const unsigned short HEADERS_RECEIVED = 2;\n    const unsigned short LOADING = 3;\n    const unsigned short DONE = 4;\n    readonly attribute unsigned short readyState;\n  \n    // request\n    void open(in DOMString method, in DOMString url);\n    void open(in DOMString method, in DOMString url, in boolean async);\n    void open(in DOMString method, in DOMString url,\n              in boolean async, in DOMString user);\n    void open(in DOMString method, in DOMString url,\n              in boolean async, in DOMString user, in DOMString password);\n    void setRequestHeader(in DOMString header, in DOMString value);\n    void send();\n    void send(in DOMString data);\n    void send(in Document data);\n    void abort();\n  \n    // response\n    DOMString getAllResponseHeaders();\n    DOMString getResponseHeader(in DOMString header);\n    readonly attribute DOMString responseText;\n    readonly attribute Document responseXML;\n    readonly attribute unsigned short status;\n    readonly attribute DOMString statusText;\n  };\n  */\n  // readyStates\n\n  var UNSENT = 0;\n  var OPENED = 1;\n  var HEADERS_RECEIVED = 2;\n  var LOADING = 3;\n  var DONE = 4; // exceptions\n\n  var INVALID_STATE_ERR = 11;\n  var SYNTAX_ERR = 12;\n  var SECURITY_ERR = 18;\n  var NETWORK_ERR = 19;\n  var ABORT_ERR = 20; // private flash socket pool vars\n\n  var _sp = null;\n  var _policyPort = 0;\n  var _policyUrl = null; // default client (used if no special URL provided when creating an XHR)\n\n  var _client = null; // all clients including the default, key'd by full base url\n  // (multiple cross-domain http clients are permitted so there may be more\n  // than one client in this map)\n  // TODO: provide optional clean up API for non-default clients\n\n  var _clients = {}; // the default maximum number of concurrents connections per client\n\n  var _maxConnections = 10;\n  var net = forge.net;\n  var http = forge.http;\n  /**\n   * Initializes flash XHR support.\n   *\n   * @param options:\n   *   url: the default base URL to connect to if xhr URLs are relative,\n   *     ie: https://myserver.com.\n   *   flashId: the dom ID of the flash SocketPool.\n   *   policyPort: the port that provides the server's flash policy, 0 to use\n   *     the flash default.\n   *   policyUrl: the policy file URL to use instead of a policy port.\n   *   msie: true if browser is internet explorer, false if not.\n   *   connections: the maximum number of concurrent connections.\n   *   caCerts: a list of PEM-formatted certificates to trust.\n   *   cipherSuites: an optional array of cipher suites to use,\n   *     see forge.tls.CipherSuites.\n   *   verify: optional TLS certificate verify callback to use (see forge.tls\n   *     for details).\n   *   getCertificate: an optional callback used to get a client-side\n   *     certificate (see forge.tls for details).\n   *   getPrivateKey: an optional callback used to get a client-side private\n   *     key (see forge.tls for details).\n   *   getSignature: an optional callback used to get a client-side signature\n   *     (see forge.tls for details).\n   *   persistCookies: true to use persistent cookies via flash local storage,\n   *     false to only keep cookies in javascript.\n   *   primeTlsSockets: true to immediately connect TLS sockets on their\n   *     creation so that they will cache TLS sessions for reuse.\n   */\n\n  xhrApi.init = function (options) {\n    forge.log.debug(cat, 'initializing', options); // update default policy port and max connections\n\n    _policyPort = options.policyPort || _policyPort;\n    _policyUrl = options.policyUrl || _policyUrl;\n    _maxConnections = options.connections || _maxConnections; // create the flash socket pool\n\n    _sp = net.createSocketPool({\n      flashId: options.flashId,\n      policyPort: _policyPort,\n      policyUrl: _policyUrl,\n      msie: options.msie || false\n    }); // create default http client\n\n    _client = http.createClient({\n      url: options.url || window.location.protocol + '//' + window.location.host,\n      socketPool: _sp,\n      policyPort: _policyPort,\n      policyUrl: _policyUrl,\n      connections: options.connections || _maxConnections,\n      caCerts: options.caCerts,\n      cipherSuites: options.cipherSuites,\n      persistCookies: options.persistCookies || true,\n      primeTlsSockets: options.primeTlsSockets || false,\n      verify: options.verify,\n      getCertificate: options.getCertificate,\n      getPrivateKey: options.getPrivateKey,\n      getSignature: options.getSignature\n    });\n    _clients[_client.url.origin] = _client;\n    forge.log.debug(cat, 'ready');\n  };\n  /**\n   * Called to clean up the clients and socket pool.\n   */\n\n\n  xhrApi.cleanup = function () {\n    // destroy all clients\n    for (var key in _clients) {\n      _clients[key].destroy();\n    }\n\n    _clients = {};\n    _client = null; // destroy socket pool\n\n    _sp.destroy();\n\n    _sp = null;\n  };\n  /**\n   * Sets a cookie.\n   *\n   * @param cookie the cookie with parameters:\n   *   name: the name of the cookie.\n   *   value: the value of the cookie.\n   *   comment: an optional comment string.\n   *   maxAge: the age of the cookie in seconds relative to created time.\n   *   secure: true if the cookie must be sent over a secure protocol.\n   *   httpOnly: true to restrict access to the cookie from javascript\n   *     (inaffective since the cookies are stored in javascript).\n   *   path: the path for the cookie.\n   *   domain: optional domain the cookie belongs to (must start with dot).\n   *   version: optional version of the cookie.\n   *   created: creation time, in UTC seconds, of the cookie.\n   */\n\n\n  xhrApi.setCookie = function (cookie) {\n    // default cookie expiration to never\n    cookie.maxAge = cookie.maxAge || -1; // if the cookie's domain is set, use the appropriate client\n\n    if (cookie.domain) {\n      // add the cookies to the applicable domains\n      for (var key in _clients) {\n        var client = _clients[key];\n\n        if (http.withinCookieDomain(client.url, cookie) && client.secure === cookie.secure) {\n          client.setCookie(cookie);\n        }\n      }\n    } else {\n      // use the default domain\n      // FIXME: should a null domain cookie be added to all clients? should\n      // this be an option?\n      _client.setCookie(cookie);\n    }\n  };\n  /**\n   * Gets a cookie.\n   *\n   * @param name the name of the cookie.\n   * @param path an optional path for the cookie (if there are multiple cookies\n   *          with the same name but different paths).\n   * @param domain an optional domain for the cookie (if not using the default\n   *          domain).\n   *\n   * @return the cookie, cookies (if multiple matches), or null if not found.\n   */\n\n\n  xhrApi.getCookie = function (name, path, domain) {\n    var rval = null;\n\n    if (domain) {\n      // get the cookies from the applicable domains\n      for (var key in _clients) {\n        var client = _clients[key];\n\n        if (http.withinCookieDomain(client.url, domain)) {\n          var cookie = client.getCookie(name, path);\n\n          if (cookie !== null) {\n            if (rval === null) {\n              rval = cookie;\n            } else if (!forge.util.isArray(rval)) {\n              rval = [rval, cookie];\n            } else {\n              rval.push(cookie);\n            }\n          }\n        }\n      }\n    } else {\n      // get cookie from default domain\n      rval = _client.getCookie(name, path);\n    }\n\n    return rval;\n  };\n  /**\n   * Removes a cookie.\n   *\n   * @param name the name of the cookie.\n   * @param path an optional path for the cookie (if there are multiple cookies\n   *          with the same name but different paths).\n   * @param domain an optional domain for the cookie (if not using the default\n   *          domain).\n   *\n   * @return true if a cookie was removed, false if not.\n   */\n\n\n  xhrApi.removeCookie = function (name, path, domain) {\n    var rval = false;\n\n    if (domain) {\n      // remove the cookies from the applicable domains\n      for (var key in _clients) {\n        var client = _clients[key];\n\n        if (http.withinCookieDomain(client.url, domain)) {\n          if (client.removeCookie(name, path)) {\n            rval = true;\n          }\n        }\n      }\n    } else {\n      // remove cookie from default domain\n      rval = _client.removeCookie(name, path);\n    }\n\n    return rval;\n  };\n  /**\n   * Creates a new XmlHttpRequest. By default the base URL, flash policy port,\n   * etc, will be used. However, an XHR can be created to point at another\n   * cross-domain URL.\n   *\n   * @param options:\n   *   logWarningOnError: If true and an HTTP error status code is received then\n   *     log a warning, otherwise log a verbose message.\n   *   verbose: If true be very verbose in the output including the response\n   *     event and response body, otherwise only include status, timing, and\n   *     data size.\n   *   logError: a multi-var log function for warnings that takes the log\n   *     category as the first var.\n   *   logWarning: a multi-var log function for warnings that takes the log\n   *     category as the first var.\n   *   logDebug: a multi-var log function for warnings that takes the log\n   *     category as the first var.\n   *   logVerbose: a multi-var log function for warnings that takes the log\n   *     category as the first var.\n   *   url: the default base URL to connect to if xhr URLs are relative,\n   *     eg: https://myserver.com, and note that the following options will be\n   *     ignored if the URL is absent or the same as the default base URL.\n   *   policyPort: the port that provides the server's flash policy, 0 to use\n   *     the flash default.\n   *   policyUrl: the policy file URL to use instead of a policy port.\n   *   connections: the maximum number of concurrent connections.\n   *   caCerts: a list of PEM-formatted certificates to trust.\n   *   cipherSuites: an optional array of cipher suites to use, see\n   *     forge.tls.CipherSuites.\n   *   verify: optional TLS certificate verify callback to use (see forge.tls\n   *     for details).\n   *   getCertificate: an optional callback used to get a client-side\n   *     certificate.\n   *   getPrivateKey: an optional callback used to get a client-side private key.\n   *   getSignature: an optional callback used to get a client-side signature.\n   *   persistCookies: true to use persistent cookies via flash local storage,\n   *     false to only keep cookies in javascript.\n   *   primeTlsSockets: true to immediately connect TLS sockets on their\n   *     creation so that they will cache TLS sessions for reuse.\n   *\n   * @return the XmlHttpRequest.\n   */\n\n\n  xhrApi.create = function (options) {\n    // set option defaults\n    options = $.extend({\n      logWarningOnError: true,\n      verbose: false,\n      logError: function () {},\n      logWarning: function () {},\n      logDebug: function () {},\n      logVerbose: function () {},\n      url: null\n    }, options || {}); // private xhr state\n\n    var _state = {\n      // the http client to use\n      client: null,\n      // request storage\n      request: null,\n      // response storage\n      response: null,\n      // asynchronous, true if doing asynchronous communication\n      asynchronous: true,\n      // sendFlag, true if send has been called\n      sendFlag: false,\n      // errorFlag, true if a network error occurred\n      errorFlag: false\n    }; // private log functions\n\n    var _log = {\n      error: options.logError || forge.log.error,\n      warning: options.logWarning || forge.log.warning,\n      debug: options.logDebug || forge.log.debug,\n      verbose: options.logVerbose || forge.log.verbose\n    }; // create public xhr interface\n\n    var xhr = {\n      // an EventListener\n      onreadystatechange: null,\n      // readonly, the current readyState\n      readyState: UNSENT,\n      // a string with the response entity-body\n      responseText: '',\n      // a Document for response entity-bodies that are XML\n      responseXML: null,\n      // readonly, returns the HTTP status code (i.e. 404)\n      status: 0,\n      // readonly, returns the HTTP status message (i.e. 'Not Found')\n      statusText: ''\n    }; // determine which http client to use\n\n    if (options.url === null) {\n      // use default\n      _state.client = _client;\n    } else {\n      var url;\n\n      try {\n        url = new URL(options.url);\n      } catch (e) {\n        var error = new Error('Invalid url.');\n        error.details = {\n          url: options.url\n        };\n      } // find client\n\n\n      if (url.origin in _clients) {\n        // client found\n        _state.client = _clients[url.origin];\n      } else {\n        // create client\n        _state.client = http.createClient({\n          url: options.url,\n          socketPool: _sp,\n          policyPort: options.policyPort || _policyPort,\n          policyUrl: options.policyUrl || _policyUrl,\n          connections: options.connections || _maxConnections,\n          caCerts: options.caCerts,\n          cipherSuites: options.cipherSuites,\n          persistCookies: options.persistCookies || true,\n          primeTlsSockets: options.primeTlsSockets || false,\n          verify: options.verify,\n          getCertificate: options.getCertificate,\n          getPrivateKey: options.getPrivateKey,\n          getSignature: options.getSignature\n        });\n        _clients[url.origin] = _state.client;\n      }\n    }\n    /**\n     * Opens the request. This method will create the HTTP request to send.\n     *\n     * @param method the HTTP method (i.e. 'GET').\n     * @param url the relative url (the HTTP request path).\n     * @param async always true, ignored.\n     * @param user always null, ignored.\n     * @param password always null, ignored.\n     */\n\n\n    xhr.open = function (method, url, async, user, password) {\n      // 1. validate Document if one is associated\n      // TODO: not implemented (not used yet)\n      // 2. validate method token\n      // 3. change method to uppercase if it matches a known\n      // method (here we just require it to be uppercase, and\n      // we do not allow the standard methods)\n      // 4. disallow CONNECT, TRACE, or TRACK with a security error\n      switch (method) {\n        case 'DELETE':\n        case 'GET':\n        case 'HEAD':\n        case 'OPTIONS':\n        case 'PATCH':\n        case 'POST':\n        case 'PUT':\n          // valid method\n          break;\n\n        case 'CONNECT':\n        case 'TRACE':\n        case 'TRACK':\n          throw new Error('CONNECT, TRACE and TRACK methods are disallowed');\n\n        default:\n          throw new Error('Invalid method: ' + method);\n      } // TODO: other validation steps in algorithm are not implemented\n      // 19. set send flag to false\n      // set response body to null\n      // empty list of request headers\n      // set request method to given method\n      // set request URL\n      // set username, password\n      // set asychronous flag\n\n\n      _state.sendFlag = false;\n      xhr.responseText = '';\n      xhr.responseXML = null; // custom: reset status and statusText\n\n      xhr.status = 0;\n      xhr.statusText = ''; // create the HTTP request\n\n      _state.request = http.createRequest({\n        method: method,\n        path: url\n      }); // 20. set state to OPENED\n\n      xhr.readyState = OPENED; // 21. dispatch onreadystatechange\n\n      if (xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n    };\n    /**\n     * Adds an HTTP header field to the request.\n     *\n     * @param header the name of the header field.\n     * @param value the value of the header field.\n     */\n\n\n    xhr.setRequestHeader = function (header, value) {\n      // 1. if state is not OPENED or send flag is true, raise exception\n      if (xhr.readyState != OPENED || _state.sendFlag) {\n        throw new Error('XHR not open or sending');\n      } // TODO: other validation steps in spec aren't implemented\n      // set header\n\n\n      _state.request.setField(header, value);\n    };\n    /**\n     * Sends the request and any associated data.\n     *\n     * @param data a string or Document object to send, null to send no data.\n     */\n\n\n    xhr.send = function (data) {\n      // 1. if state is not OPENED or 2. send flag is true, raise\n      // an invalid state exception\n      if (xhr.readyState != OPENED || _state.sendFlag) {\n        throw new Error('XHR not open or sending');\n      } // 3. ignore data if method is GET or HEAD\n\n\n      if (data && _state.request.method !== 'GET' && _state.request.method !== 'HEAD') {\n        // handle non-IE case\n        if (typeof XMLSerializer !== 'undefined') {\n          if (data instanceof Document) {\n            var xs = new XMLSerializer();\n            _state.request.body = xs.serializeToString(data);\n          } else {\n            _state.request.body = data;\n          }\n        } else {\n          // poorly implemented IE case\n          if (typeof data.xml !== 'undefined') {\n            _state.request.body = data.xml;\n          } else {\n            _state.request.body = data;\n          }\n        }\n      } // 4. release storage mutex (not used)\n      // 5. set error flag to false\n\n\n      _state.errorFlag = false; // 6. if asynchronous is true (must be in this implementation)\n      // 6.1 set send flag to true\n\n      _state.sendFlag = true; // 6.2 dispatch onreadystatechange\n\n      if (xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      } // create send options\n\n\n      var options = {};\n      options.request = _state.request;\n\n      options.headerReady = function (e) {\n        // make cookies available for ease of use/iteration\n        xhr.cookies = _state.client.cookies; // TODO: update document.cookie with any cookies where the\n        // script's domain matches\n        // headers received\n\n        xhr.readyState = HEADERS_RECEIVED;\n        xhr.status = e.response.code;\n        xhr.statusText = e.response.message;\n        _state.response = e.response;\n\n        if (xhr.onreadystatechange) {\n          xhr.onreadystatechange();\n        }\n\n        if (!_state.response.aborted) {\n          // now loading body\n          xhr.readyState = LOADING;\n\n          if (xhr.onreadystatechange) {\n            xhr.onreadystatechange();\n          }\n        }\n      };\n\n      options.bodyReady = function (e) {\n        xhr.readyState = DONE;\n        var ct = e.response.getField('Content-Type'); // Note: this null/undefined check is done outside because IE\n        // dies otherwise on a \"'null' is null\" error\n\n        if (ct) {\n          if (ct.indexOf('text/xml') === 0 || ct.indexOf('application/xml') === 0 || ct.indexOf('+xml') !== -1) {\n            try {\n              var doc = new ActiveXObject('MicrosoftXMLDOM');\n              doc.async = false;\n              doc.loadXML(e.response.body);\n              xhr.responseXML = doc;\n            } catch (ex) {\n              var parser = new DOMParser();\n              xhr.responseXML = parser.parseFromString(ex.body, 'text/xml');\n            }\n          }\n        }\n\n        var length = 0;\n\n        if (e.response.body !== null) {\n          xhr.responseText = e.response.body;\n          length = e.response.body.length;\n        } // build logging output\n\n\n        var req = _state.request;\n        var output = req.method + ' ' + req.path + ' ' + xhr.status + ' ' + xhr.statusText + ' ' + length + 'B ' + (e.request.connectTime + e.request.time + e.response.time) + 'ms';\n        var lFunc;\n\n        if (options.verbose) {\n          lFunc = xhr.status >= 400 && options.logWarningOnError ? _log.warning : _log.verbose;\n          lFunc(cat, output, e, e.response.body ? '\\n' + e.response.body : '\\nNo content');\n        } else {\n          lFunc = xhr.status >= 400 && options.logWarningOnError ? _log.warning : _log.debug;\n          lFunc(cat, output);\n        }\n\n        if (xhr.onreadystatechange) {\n          xhr.onreadystatechange();\n        }\n      };\n\n      options.error = function (e) {\n        var req = _state.request;\n\n        _log.error(cat, req.method + ' ' + req.path, e); // 1. set response body to null\n\n\n        xhr.responseText = '';\n        xhr.responseXML = null; // 2. set error flag to true (and reset status)\n\n        _state.errorFlag = true;\n        xhr.status = 0;\n        xhr.statusText = ''; // 3. set state to done\n\n        xhr.readyState = DONE; // 4. asyc flag is always true, so dispatch onreadystatechange\n\n        if (xhr.onreadystatechange) {\n          xhr.onreadystatechange();\n        }\n      }; // 7. send request\n\n\n      _state.client.send(options);\n    };\n    /**\n     * Aborts the request.\n     */\n\n\n    xhr.abort = function () {\n      // 1. abort send\n      // 2. stop network activity\n      _state.request.abort(); // 3. set response to null\n\n\n      xhr.responseText = '';\n      xhr.responseXML = null; // 4. set error flag to true (and reset status)\n\n      _state.errorFlag = true;\n      xhr.status = 0;\n      xhr.statusText = ''; // 5. clear user headers\n\n      _state.request = null;\n      _state.response = null; // 6. if state is DONE or UNSENT, or if OPENED and send flag is false\n\n      if (xhr.readyState === DONE || xhr.readyState === UNSENT || xhr.readyState === OPENED && !_state.sendFlag) {\n        // 7. set ready state to unsent\n        xhr.readyState = UNSENT;\n      } else {\n        // 6.1 set state to DONE\n        xhr.readyState = DONE; // 6.2 set send flag to false\n\n        _state.sendFlag = false; // 6.3 dispatch onreadystatechange\n\n        if (xhr.onreadystatechange) {\n          xhr.onreadystatechange();\n        } // 7. set state to UNSENT\n\n\n        xhr.readyState = UNSENT;\n      }\n    };\n    /**\n     * Gets all response headers as a string.\n     *\n     * @return the HTTP-encoded response header fields.\n     */\n\n\n    xhr.getAllResponseHeaders = function () {\n      var rval = '';\n\n      if (_state.response !== null) {\n        var fields = _state.response.fields;\n        $.each(fields, function (name, array) {\n          $.each(array, function (i, value) {\n            rval += name + ': ' + value + '\\r\\n';\n          });\n        });\n      }\n\n      return rval;\n    };\n    /**\n     * Gets a single header field value or, if there are multiple\n     * fields with the same name, a comma-separated list of header\n     * values.\n     *\n     * @return the header field value(s) or null.\n     */\n\n\n    xhr.getResponseHeader = function (header) {\n      var rval = null;\n\n      if (_state.response !== null) {\n        if (header in _state.response.fields) {\n          rval = _state.response.fields[header];\n\n          if (forge.util.isArray(rval)) {\n            rval = rval.join();\n          }\n        }\n      }\n\n      return rval;\n    };\n\n    return xhr;\n  };\n})(jQuery);","map":{"version":3,"names":["forge","require","xhrApi","module","exports","xhr","$","cat","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","INVALID_STATE_ERR","SYNTAX_ERR","SECURITY_ERR","NETWORK_ERR","ABORT_ERR","_sp","_policyPort","_policyUrl","_client","_clients","_maxConnections","net","http","init","options","log","debug","policyPort","policyUrl","connections","createSocketPool","flashId","msie","createClient","url","window","location","protocol","host","socketPool","caCerts","cipherSuites","persistCookies","primeTlsSockets","verify","getCertificate","getPrivateKey","getSignature","origin","cleanup","key","destroy","setCookie","cookie","maxAge","domain","client","withinCookieDomain","secure","getCookie","name","path","rval","util","isArray","push","removeCookie","create","extend","logWarningOnError","verbose","logError","logWarning","logDebug","logVerbose","_state","request","response","asynchronous","sendFlag","errorFlag","_log","error","warning","onreadystatechange","readyState","responseText","responseXML","status","statusText","URL","e","Error","details","open","method","async","user","password","createRequest","setRequestHeader","header","value","setField","send","data","XMLSerializer","Document","xs","body","serializeToString","xml","headerReady","cookies","code","message","aborted","bodyReady","ct","getField","indexOf","doc","ActiveXObject","loadXML","ex","parser","DOMParser","parseFromString","length","req","output","connectTime","time","lFunc","abort","getAllResponseHeaders","fields","each","array","i","getResponseHeader","join","jQuery"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/node-forge/lib/xhr.js"],"sourcesContent":["/**\n * XmlHttpRequest implementation that uses TLS and flash SocketPool.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2013 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./socket');\nrequire('./http');\n\n/* XHR API */\nvar xhrApi = module.exports = forge.xhr = forge.xhr || {};\n\n(function($) {\n\n// logging category\nvar cat = 'forge.xhr';\n\n/*\nXMLHttpRequest interface definition from:\nhttp://www.w3.org/TR/XMLHttpRequest\n\ninterface XMLHttpRequest {\n  // event handler\n  attribute EventListener onreadystatechange;\n\n  // state\n  const unsigned short UNSENT = 0;\n  const unsigned short OPENED = 1;\n  const unsigned short HEADERS_RECEIVED = 2;\n  const unsigned short LOADING = 3;\n  const unsigned short DONE = 4;\n  readonly attribute unsigned short readyState;\n\n  // request\n  void open(in DOMString method, in DOMString url);\n  void open(in DOMString method, in DOMString url, in boolean async);\n  void open(in DOMString method, in DOMString url,\n            in boolean async, in DOMString user);\n  void open(in DOMString method, in DOMString url,\n            in boolean async, in DOMString user, in DOMString password);\n  void setRequestHeader(in DOMString header, in DOMString value);\n  void send();\n  void send(in DOMString data);\n  void send(in Document data);\n  void abort();\n\n  // response\n  DOMString getAllResponseHeaders();\n  DOMString getResponseHeader(in DOMString header);\n  readonly attribute DOMString responseText;\n  readonly attribute Document responseXML;\n  readonly attribute unsigned short status;\n  readonly attribute DOMString statusText;\n};\n*/\n\n// readyStates\nvar UNSENT = 0;\nvar OPENED = 1;\nvar HEADERS_RECEIVED = 2;\nvar LOADING = 3;\nvar DONE = 4;\n\n// exceptions\nvar INVALID_STATE_ERR = 11;\nvar SYNTAX_ERR = 12;\nvar SECURITY_ERR = 18;\nvar NETWORK_ERR = 19;\nvar ABORT_ERR = 20;\n\n// private flash socket pool vars\nvar _sp = null;\nvar _policyPort = 0;\nvar _policyUrl = null;\n\n// default client (used if no special URL provided when creating an XHR)\nvar _client = null;\n\n// all clients including the default, key'd by full base url\n// (multiple cross-domain http clients are permitted so there may be more\n// than one client in this map)\n// TODO: provide optional clean up API for non-default clients\nvar _clients = {};\n\n// the default maximum number of concurrents connections per client\nvar _maxConnections = 10;\n\nvar net = forge.net;\nvar http = forge.http;\n\n/**\n * Initializes flash XHR support.\n *\n * @param options:\n *   url: the default base URL to connect to if xhr URLs are relative,\n *     ie: https://myserver.com.\n *   flashId: the dom ID of the flash SocketPool.\n *   policyPort: the port that provides the server's flash policy, 0 to use\n *     the flash default.\n *   policyUrl: the policy file URL to use instead of a policy port.\n *   msie: true if browser is internet explorer, false if not.\n *   connections: the maximum number of concurrent connections.\n *   caCerts: a list of PEM-formatted certificates to trust.\n *   cipherSuites: an optional array of cipher suites to use,\n *     see forge.tls.CipherSuites.\n *   verify: optional TLS certificate verify callback to use (see forge.tls\n *     for details).\n *   getCertificate: an optional callback used to get a client-side\n *     certificate (see forge.tls for details).\n *   getPrivateKey: an optional callback used to get a client-side private\n *     key (see forge.tls for details).\n *   getSignature: an optional callback used to get a client-side signature\n *     (see forge.tls for details).\n *   persistCookies: true to use persistent cookies via flash local storage,\n *     false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on their\n *     creation so that they will cache TLS sessions for reuse.\n */\nxhrApi.init = function(options) {\n  forge.log.debug(cat, 'initializing', options);\n\n  // update default policy port and max connections\n  _policyPort = options.policyPort || _policyPort;\n  _policyUrl = options.policyUrl || _policyUrl;\n  _maxConnections = options.connections || _maxConnections;\n\n  // create the flash socket pool\n  _sp = net.createSocketPool({\n    flashId: options.flashId,\n    policyPort: _policyPort,\n    policyUrl: _policyUrl,\n    msie: options.msie || false\n  });\n\n  // create default http client\n  _client = http.createClient({\n    url: options.url || (\n      window.location.protocol + '//' + window.location.host),\n    socketPool: _sp,\n    policyPort: _policyPort,\n    policyUrl: _policyUrl,\n    connections: options.connections || _maxConnections,\n    caCerts: options.caCerts,\n    cipherSuites: options.cipherSuites,\n    persistCookies: options.persistCookies || true,\n    primeTlsSockets: options.primeTlsSockets || false,\n    verify: options.verify,\n    getCertificate: options.getCertificate,\n    getPrivateKey: options.getPrivateKey,\n    getSignature: options.getSignature\n  });\n  _clients[_client.url.origin] = _client;\n\n  forge.log.debug(cat, 'ready');\n};\n\n/**\n * Called to clean up the clients and socket pool.\n */\nxhrApi.cleanup = function() {\n  // destroy all clients\n  for(var key in _clients) {\n    _clients[key].destroy();\n  }\n  _clients = {};\n  _client = null;\n\n  // destroy socket pool\n  _sp.destroy();\n  _sp = null;\n};\n\n/**\n * Sets a cookie.\n *\n * @param cookie the cookie with parameters:\n *   name: the name of the cookie.\n *   value: the value of the cookie.\n *   comment: an optional comment string.\n *   maxAge: the age of the cookie in seconds relative to created time.\n *   secure: true if the cookie must be sent over a secure protocol.\n *   httpOnly: true to restrict access to the cookie from javascript\n *     (inaffective since the cookies are stored in javascript).\n *   path: the path for the cookie.\n *   domain: optional domain the cookie belongs to (must start with dot).\n *   version: optional version of the cookie.\n *   created: creation time, in UTC seconds, of the cookie.\n */\nxhrApi.setCookie = function(cookie) {\n  // default cookie expiration to never\n  cookie.maxAge = cookie.maxAge || -1;\n\n  // if the cookie's domain is set, use the appropriate client\n  if(cookie.domain) {\n    // add the cookies to the applicable domains\n    for(var key in _clients) {\n      var client = _clients[key];\n      if(http.withinCookieDomain(client.url, cookie) &&\n        client.secure === cookie.secure) {\n        client.setCookie(cookie);\n      }\n    }\n  } else {\n    // use the default domain\n    // FIXME: should a null domain cookie be added to all clients? should\n    // this be an option?\n    _client.setCookie(cookie);\n  }\n};\n\n/**\n * Gets a cookie.\n *\n * @param name the name of the cookie.\n * @param path an optional path for the cookie (if there are multiple cookies\n *          with the same name but different paths).\n * @param domain an optional domain for the cookie (if not using the default\n *          domain).\n *\n * @return the cookie, cookies (if multiple matches), or null if not found.\n */\nxhrApi.getCookie = function(name, path, domain) {\n  var rval = null;\n\n  if(domain) {\n    // get the cookies from the applicable domains\n    for(var key in _clients) {\n      var client = _clients[key];\n      if(http.withinCookieDomain(client.url, domain)) {\n        var cookie = client.getCookie(name, path);\n        if(cookie !== null) {\n          if(rval === null) {\n            rval = cookie;\n          } else if(!forge.util.isArray(rval)) {\n            rval = [rval, cookie];\n          } else {\n            rval.push(cookie);\n          }\n        }\n      }\n    }\n  } else {\n    // get cookie from default domain\n    rval = _client.getCookie(name, path);\n  }\n\n  return rval;\n};\n\n/**\n * Removes a cookie.\n *\n * @param name the name of the cookie.\n * @param path an optional path for the cookie (if there are multiple cookies\n *          with the same name but different paths).\n * @param domain an optional domain for the cookie (if not using the default\n *          domain).\n *\n * @return true if a cookie was removed, false if not.\n */\nxhrApi.removeCookie = function(name, path, domain) {\n  var rval = false;\n\n  if(domain) {\n    // remove the cookies from the applicable domains\n    for(var key in _clients) {\n      var client = _clients[key];\n      if(http.withinCookieDomain(client.url, domain)) {\n        if(client.removeCookie(name, path)) {\n           rval = true;\n        }\n      }\n    }\n  } else {\n    // remove cookie from default domain\n    rval = _client.removeCookie(name, path);\n  }\n\n  return rval;\n};\n\n/**\n * Creates a new XmlHttpRequest. By default the base URL, flash policy port,\n * etc, will be used. However, an XHR can be created to point at another\n * cross-domain URL.\n *\n * @param options:\n *   logWarningOnError: If true and an HTTP error status code is received then\n *     log a warning, otherwise log a verbose message.\n *   verbose: If true be very verbose in the output including the response\n *     event and response body, otherwise only include status, timing, and\n *     data size.\n *   logError: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   logWarning: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   logDebug: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   logVerbose: a multi-var log function for warnings that takes the log\n *     category as the first var.\n *   url: the default base URL to connect to if xhr URLs are relative,\n *     eg: https://myserver.com, and note that the following options will be\n *     ignored if the URL is absent or the same as the default base URL.\n *   policyPort: the port that provides the server's flash policy, 0 to use\n *     the flash default.\n *   policyUrl: the policy file URL to use instead of a policy port.\n *   connections: the maximum number of concurrent connections.\n *   caCerts: a list of PEM-formatted certificates to trust.\n *   cipherSuites: an optional array of cipher suites to use, see\n *     forge.tls.CipherSuites.\n *   verify: optional TLS certificate verify callback to use (see forge.tls\n *     for details).\n *   getCertificate: an optional callback used to get a client-side\n *     certificate.\n *   getPrivateKey: an optional callback used to get a client-side private key.\n *   getSignature: an optional callback used to get a client-side signature.\n *   persistCookies: true to use persistent cookies via flash local storage,\n *     false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on their\n *     creation so that they will cache TLS sessions for reuse.\n *\n * @return the XmlHttpRequest.\n */\nxhrApi.create = function(options) {\n  // set option defaults\n  options = $.extend({\n    logWarningOnError: true,\n    verbose: false,\n    logError: function() {},\n    logWarning: function() {},\n    logDebug: function() {},\n    logVerbose: function() {},\n    url: null\n  }, options || {});\n\n  // private xhr state\n  var _state = {\n    // the http client to use\n    client: null,\n    // request storage\n    request: null,\n    // response storage\n    response: null,\n    // asynchronous, true if doing asynchronous communication\n    asynchronous: true,\n    // sendFlag, true if send has been called\n    sendFlag: false,\n    // errorFlag, true if a network error occurred\n    errorFlag: false\n  };\n\n  // private log functions\n  var _log = {\n    error: options.logError || forge.log.error,\n    warning: options.logWarning || forge.log.warning,\n    debug: options.logDebug || forge.log.debug,\n    verbose: options.logVerbose || forge.log.verbose\n  };\n\n  // create public xhr interface\n  var xhr = {\n    // an EventListener\n    onreadystatechange: null,\n    // readonly, the current readyState\n    readyState: UNSENT,\n    // a string with the response entity-body\n    responseText: '',\n    // a Document for response entity-bodies that are XML\n    responseXML: null,\n    // readonly, returns the HTTP status code (i.e. 404)\n    status: 0,\n    // readonly, returns the HTTP status message (i.e. 'Not Found')\n    statusText: ''\n  };\n\n  // determine which http client to use\n  if(options.url === null) {\n    // use default\n    _state.client = _client;\n  } else {\n    var url;\n    try {\n      url = new URL(options.url);\n    } catch(e) {\n      var error = new Error('Invalid url.');\n      error.details = {\n        url: options.url\n      };\n    }\n\n    // find client\n    if(url.origin in _clients) {\n      // client found\n      _state.client = _clients[url.origin];\n    } else {\n      // create client\n      _state.client = http.createClient({\n        url: options.url,\n        socketPool: _sp,\n        policyPort: options.policyPort || _policyPort,\n        policyUrl: options.policyUrl || _policyUrl,\n        connections: options.connections || _maxConnections,\n        caCerts: options.caCerts,\n        cipherSuites: options.cipherSuites,\n        persistCookies: options.persistCookies || true,\n        primeTlsSockets: options.primeTlsSockets || false,\n        verify: options.verify,\n        getCertificate: options.getCertificate,\n        getPrivateKey: options.getPrivateKey,\n        getSignature: options.getSignature\n      });\n      _clients[url.origin] = _state.client;\n    }\n  }\n\n  /**\n   * Opens the request. This method will create the HTTP request to send.\n   *\n   * @param method the HTTP method (i.e. 'GET').\n   * @param url the relative url (the HTTP request path).\n   * @param async always true, ignored.\n   * @param user always null, ignored.\n   * @param password always null, ignored.\n   */\n  xhr.open = function(method, url, async, user, password) {\n    // 1. validate Document if one is associated\n    // TODO: not implemented (not used yet)\n\n    // 2. validate method token\n    // 3. change method to uppercase if it matches a known\n    // method (here we just require it to be uppercase, and\n    // we do not allow the standard methods)\n    // 4. disallow CONNECT, TRACE, or TRACK with a security error\n    switch(method) {\n    case 'DELETE':\n    case 'GET':\n    case 'HEAD':\n    case 'OPTIONS':\n    case 'PATCH':\n    case 'POST':\n    case 'PUT':\n      // valid method\n      break;\n    case 'CONNECT':\n    case 'TRACE':\n    case 'TRACK':\n      throw new Error('CONNECT, TRACE and TRACK methods are disallowed');\n    default:\n      throw new Error('Invalid method: ' + method);\n    }\n\n    // TODO: other validation steps in algorithm are not implemented\n\n    // 19. set send flag to false\n    // set response body to null\n    // empty list of request headers\n    // set request method to given method\n    // set request URL\n    // set username, password\n    // set asychronous flag\n    _state.sendFlag = false;\n    xhr.responseText = '';\n    xhr.responseXML = null;\n\n    // custom: reset status and statusText\n    xhr.status = 0;\n    xhr.statusText = '';\n\n    // create the HTTP request\n    _state.request = http.createRequest({\n      method: method,\n      path: url\n    });\n\n    // 20. set state to OPENED\n    xhr.readyState = OPENED;\n\n    // 21. dispatch onreadystatechange\n    if(xhr.onreadystatechange) {\n       xhr.onreadystatechange();\n    }\n  };\n\n  /**\n   * Adds an HTTP header field to the request.\n   *\n   * @param header the name of the header field.\n   * @param value the value of the header field.\n   */\n  xhr.setRequestHeader = function(header, value) {\n    // 1. if state is not OPENED or send flag is true, raise exception\n    if(xhr.readyState != OPENED || _state.sendFlag) {\n      throw new Error('XHR not open or sending');\n    }\n\n    // TODO: other validation steps in spec aren't implemented\n\n    // set header\n    _state.request.setField(header, value);\n  };\n\n  /**\n   * Sends the request and any associated data.\n   *\n   * @param data a string or Document object to send, null to send no data.\n   */\n  xhr.send = function(data) {\n    // 1. if state is not OPENED or 2. send flag is true, raise\n    // an invalid state exception\n    if(xhr.readyState != OPENED || _state.sendFlag) {\n      throw new Error('XHR not open or sending');\n    }\n\n    // 3. ignore data if method is GET or HEAD\n    if(data &&\n      _state.request.method !== 'GET' &&\n      _state.request.method !== 'HEAD') {\n      // handle non-IE case\n      if(typeof(XMLSerializer) !== 'undefined') {\n        if(data instanceof Document) {\n          var xs = new XMLSerializer();\n          _state.request.body = xs.serializeToString(data);\n        } else {\n          _state.request.body = data;\n        }\n      } else {\n        // poorly implemented IE case\n        if(typeof(data.xml) !== 'undefined') {\n          _state.request.body = data.xml;\n        } else {\n          _state.request.body = data;\n        }\n      }\n    }\n\n    // 4. release storage mutex (not used)\n\n    // 5. set error flag to false\n    _state.errorFlag = false;\n\n    // 6. if asynchronous is true (must be in this implementation)\n\n    // 6.1 set send flag to true\n    _state.sendFlag = true;\n\n    // 6.2 dispatch onreadystatechange\n    if(xhr.onreadystatechange) {\n      xhr.onreadystatechange();\n    }\n\n    // create send options\n    var options = {};\n    options.request = _state.request;\n    options.headerReady = function(e) {\n      // make cookies available for ease of use/iteration\n      xhr.cookies = _state.client.cookies;\n\n      // TODO: update document.cookie with any cookies where the\n      // script's domain matches\n\n      // headers received\n      xhr.readyState = HEADERS_RECEIVED;\n      xhr.status = e.response.code;\n      xhr.statusText = e.response.message;\n      _state.response = e.response;\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n      if(!_state.response.aborted) {\n        // now loading body\n        xhr.readyState = LOADING;\n        if(xhr.onreadystatechange) {\n           xhr.onreadystatechange();\n        }\n      }\n    };\n    options.bodyReady = function(e) {\n      xhr.readyState = DONE;\n      var ct = e.response.getField('Content-Type');\n      // Note: this null/undefined check is done outside because IE\n      // dies otherwise on a \"'null' is null\" error\n      if(ct) {\n        if(ct.indexOf('text/xml') === 0 ||\n          ct.indexOf('application/xml') === 0 ||\n          ct.indexOf('+xml') !== -1) {\n          try {\n            var doc = new ActiveXObject('MicrosoftXMLDOM');\n            doc.async = false;\n            doc.loadXML(e.response.body);\n            xhr.responseXML = doc;\n          } catch(ex) {\n            var parser = new DOMParser();\n            xhr.responseXML = parser.parseFromString(ex.body, 'text/xml');\n          }\n        }\n      }\n\n      var length = 0;\n      if(e.response.body !== null) {\n        xhr.responseText = e.response.body;\n        length = e.response.body.length;\n      }\n      // build logging output\n      var req = _state.request;\n      var output =\n        req.method + ' ' + req.path + ' ' +\n        xhr.status + ' ' + xhr.statusText + ' ' +\n        length + 'B ' +\n        (e.request.connectTime + e.request.time + e.response.time) +\n        'ms';\n      var lFunc;\n      if(options.verbose) {\n        lFunc = (xhr.status >= 400 && options.logWarningOnError) ?\n          _log.warning : _log.verbose;\n        lFunc(cat, output,\n          e, e.response.body ? '\\n' + e.response.body : '\\nNo content');\n      } else {\n        lFunc = (xhr.status >= 400 && options.logWarningOnError) ?\n          _log.warning : _log.debug;\n        lFunc(cat, output);\n      }\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n    };\n    options.error = function(e) {\n      var req = _state.request;\n      _log.error(cat, req.method + ' ' + req.path, e);\n\n      // 1. set response body to null\n      xhr.responseText = '';\n      xhr.responseXML = null;\n\n      // 2. set error flag to true (and reset status)\n      _state.errorFlag = true;\n      xhr.status = 0;\n      xhr.statusText = '';\n\n      // 3. set state to done\n      xhr.readyState = DONE;\n\n      // 4. asyc flag is always true, so dispatch onreadystatechange\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n    };\n\n    // 7. send request\n    _state.client.send(options);\n  };\n\n  /**\n   * Aborts the request.\n   */\n  xhr.abort = function() {\n    // 1. abort send\n    // 2. stop network activity\n    _state.request.abort();\n\n    // 3. set response to null\n    xhr.responseText = '';\n    xhr.responseXML = null;\n\n    // 4. set error flag to true (and reset status)\n    _state.errorFlag = true;\n    xhr.status = 0;\n    xhr.statusText = '';\n\n    // 5. clear user headers\n    _state.request = null;\n    _state.response = null;\n\n    // 6. if state is DONE or UNSENT, or if OPENED and send flag is false\n    if(xhr.readyState === DONE || xhr.readyState === UNSENT ||\n     (xhr.readyState === OPENED && !_state.sendFlag)) {\n      // 7. set ready state to unsent\n      xhr.readyState = UNSENT;\n    } else {\n      // 6.1 set state to DONE\n      xhr.readyState = DONE;\n\n      // 6.2 set send flag to false\n      _state.sendFlag = false;\n\n      // 6.3 dispatch onreadystatechange\n      if(xhr.onreadystatechange) {\n        xhr.onreadystatechange();\n      }\n\n      // 7. set state to UNSENT\n      xhr.readyState = UNSENT;\n    }\n  };\n\n  /**\n   * Gets all response headers as a string.\n   *\n   * @return the HTTP-encoded response header fields.\n   */\n  xhr.getAllResponseHeaders = function() {\n    var rval = '';\n    if(_state.response !== null) {\n      var fields = _state.response.fields;\n      $.each(fields, function(name, array) {\n        $.each(array, function(i, value) {\n          rval += name + ': ' + value + '\\r\\n';\n        });\n      });\n    }\n    return rval;\n  };\n\n  /**\n   * Gets a single header field value or, if there are multiple\n   * fields with the same name, a comma-separated list of header\n   * values.\n   *\n   * @return the header field value(s) or null.\n   */\n  xhr.getResponseHeader = function(header) {\n    var rval = null;\n    if(_state.response !== null) {\n      if(header in _state.response.fields) {\n        rval = _state.response.fields[header];\n        if(forge.util.isArray(rval)) {\n          rval = rval.join();\n        }\n      }\n    }\n    return rval;\n  };\n\n  return xhr;\n};\n\n})(jQuery);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}