{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst regexpp_1 = require(\"regexpp\");\n\nconst util_1 = require(\"../util\");\n\nconst EQ_OPERATORS = /^[=!]=/;\nconst regexpp = new regexpp_1.RegExpParser();\nexports.default = (0, util_1.createRule)({\n  name: 'prefer-string-starts-ends-with',\n  defaultOptions: [],\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce using `String#startsWith` and `String#endsWith` over other equivalent methods of checking substrings',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    messages: {\n      preferStartsWith: \"Use 'String#startsWith' method instead.\",\n      preferEndsWith: \"Use the 'String#endsWith' method instead.\"\n    },\n    schema: [],\n    fixable: 'code'\n  },\n\n  create(context) {\n    const globalScope = context.getScope();\n    const sourceCode = context.getSourceCode();\n    const service = (0, util_1.getParserServices)(context);\n    const typeChecker = service.program.getTypeChecker();\n    /**\n     * Check if a given node is a string.\n     * @param node The node to check.\n     */\n\n    function isStringType(node) {\n      const objectType = typeChecker.getTypeAtLocation(service.esTreeNodeToTSNodeMap.get(node));\n      return (0, util_1.getTypeName)(typeChecker, objectType) === 'string';\n    }\n    /**\n     * Check if a given node is a `Literal` node that is null.\n     * @param node The node to check.\n     */\n\n\n    function isNull(node) {\n      const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n      return evaluated != null && evaluated.value === null;\n    }\n    /**\n     * Check if a given node is a `Literal` node that is a given value.\n     * @param node The node to check.\n     * @param value The expected value of the `Literal` node.\n     */\n\n\n    function isNumber(node, value) {\n      const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n      return evaluated != null && evaluated.value === value;\n    }\n    /**\n     * Check if a given node is a `Literal` node that is a character.\n     * @param node The node to check.\n     * @param kind The method name to get a character.\n     */\n\n\n    function isCharacter(node) {\n      const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n      return evaluated != null && typeof evaluated.value === 'string' && // checks if the string is a character long\n      evaluated.value[0] === evaluated.value;\n    }\n    /**\n     * Check if a given node is `==`, `===`, `!=`, or `!==`.\n     * @param node The node to check.\n     */\n\n\n    function isEqualityComparison(node) {\n      return node.type === utils_1.AST_NODE_TYPES.BinaryExpression && EQ_OPERATORS.test(node.operator);\n    }\n    /**\n     * Check if two given nodes are the same meaning.\n     * @param node1 A node to compare.\n     * @param node2 Another node to compare.\n     */\n\n\n    function isSameTokens(node1, node2) {\n      const tokens1 = sourceCode.getTokens(node1);\n      const tokens2 = sourceCode.getTokens(node2);\n\n      if (tokens1.length !== tokens2.length) {\n        return false;\n      }\n\n      for (let i = 0; i < tokens1.length; ++i) {\n        const token1 = tokens1[i];\n        const token2 = tokens2[i];\n\n        if (token1.type !== token2.type || token1.value !== token2.value) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Check if a given node is the expression of the length of a string.\n     *\n     * - If `length` property access of `expectedObjectNode`, it's `true`.\n     *   E.g., `foo` → `foo.length` / `\"foo\"` → `\"foo\".length`\n     * - If `expectedObjectNode` is a string literal, `node` can be a number.\n     *   E.g., `\"foo\"` → `3`\n     *\n     * @param node The node to check.\n     * @param expectedObjectNode The node which is expected as the receiver of `length` property.\n     */\n\n\n    function isLengthExpression(node, expectedObjectNode) {\n      if (node.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n        return (0, util_1.getPropertyName)(node, globalScope) === 'length' && isSameTokens(node.object, expectedObjectNode);\n      }\n\n      const evaluatedLength = (0, util_1.getStaticValue)(node, globalScope);\n      const evaluatedString = (0, util_1.getStaticValue)(expectedObjectNode, globalScope);\n      return evaluatedLength != null && evaluatedString != null && typeof evaluatedLength.value === 'number' && typeof evaluatedString.value === 'string' && evaluatedLength.value === evaluatedString.value.length;\n    }\n    /**\n     * Check if a given node is a negative index expression\n     *\n     * E.g. `s.slice(- <expr>)`, `s.substring(s.length - <expr>)`\n     *\n     * @param node The node to check.\n     * @param expectedIndexedNode The node which is expected as the receiver of index expression.\n     */\n\n\n    function isNegativeIndexExpression(node, expectedIndexedNode) {\n      return node.type === utils_1.AST_NODE_TYPES.UnaryExpression && node.operator === '-' || node.type === utils_1.AST_NODE_TYPES.BinaryExpression && node.operator === '-' && isLengthExpression(node.left, expectedIndexedNode);\n    }\n    /**\n     * Check if a given node is the expression of the last index.\n     *\n     * E.g. `foo.length - 1`\n     *\n     * @param node The node to check.\n     * @param expectedObjectNode The node which is expected as the receiver of `length` property.\n     */\n\n\n    function isLastIndexExpression(node, expectedObjectNode) {\n      return node.type === utils_1.AST_NODE_TYPES.BinaryExpression && node.operator === '-' && isLengthExpression(node.left, expectedObjectNode) && isNumber(node.right, 1);\n    }\n    /**\n     * Get the range of the property of a given `MemberExpression` node.\n     *\n     * - `obj[foo]` → the range of `[foo]`\n     * - `obf.foo` → the range of `.foo`\n     * - `(obj).foo` → the range of `.foo`\n     *\n     * @param node The member expression node to get.\n     */\n\n\n    function getPropertyRange(node) {\n      const dotOrOpenBracket = sourceCode.getTokenAfter(node.object, util_1.isNotClosingParenToken);\n      return [dotOrOpenBracket.range[0], node.range[1]];\n    }\n    /**\n     * Parse a given `RegExp` pattern to that string if it's a static string.\n     * @param pattern The RegExp pattern text to parse.\n     * @param uFlag The Unicode flag of the RegExp.\n     */\n\n\n    function parseRegExpText(pattern, uFlag) {\n      // Parse it.\n      const ast = regexpp.parsePattern(pattern, undefined, undefined, uFlag);\n\n      if (ast.alternatives.length !== 1) {\n        return null;\n      } // Drop `^`/`$` assertion.\n\n\n      const chars = ast.alternatives[0].elements;\n      const first = chars[0];\n\n      if (first.type === 'Assertion' && first.kind === 'start') {\n        chars.shift();\n      } else {\n        chars.pop();\n      } // Check if it can determine a unique string.\n\n\n      if (!chars.every(c => c.type === 'Character')) {\n        return null;\n      } // To string.\n\n\n      return String.fromCodePoint(...chars.map(c => c.value));\n    }\n    /**\n     * Parse a given node if it's a `RegExp` instance.\n     * @param node The node to parse.\n     */\n\n\n    function parseRegExp(node) {\n      const evaluated = (0, util_1.getStaticValue)(node, globalScope);\n\n      if (evaluated == null || !(evaluated.value instanceof RegExp)) {\n        return null;\n      }\n\n      const {\n        source,\n        flags\n      } = evaluated.value;\n      const isStartsWith = source.startsWith('^');\n      const isEndsWith = source.endsWith('$');\n\n      if (isStartsWith === isEndsWith || flags.includes('i') || flags.includes('m')) {\n        return null;\n      }\n\n      const text = parseRegExpText(source, flags.includes('u'));\n\n      if (text == null) {\n        return null;\n      }\n\n      return {\n        isEndsWith,\n        isStartsWith,\n        text\n      };\n    }\n\n    function getLeftNode(node) {\n      if (node.type === utils_1.AST_NODE_TYPES.ChainExpression) {\n        return getLeftNode(node.expression);\n      }\n\n      let leftNode;\n\n      if (node.type === utils_1.AST_NODE_TYPES.CallExpression) {\n        leftNode = node.callee;\n      } else {\n        leftNode = node;\n      }\n\n      if (leftNode.type !== utils_1.AST_NODE_TYPES.MemberExpression) {\n        throw new Error(`Expected a MemberExpression, got ${leftNode.type}`);\n      }\n\n      return leftNode;\n    }\n    /**\n     * Fix code with using the right operand as the search string.\n     * For example: `foo.slice(0, 3) === 'bar'` → `foo.startsWith('bar')`\n     * @param fixer The rule fixer.\n     * @param node The node which was reported.\n     * @param kind The kind of the report.\n     * @param isNegative The flag to fix to negative condition.\n     */\n\n\n    function* fixWithRightOperand(fixer, node, kind, isNegative, isOptional) {\n      // left is CallExpression or MemberExpression.\n      const leftNode = getLeftNode(node.left);\n      const propertyRange = getPropertyRange(leftNode);\n\n      if (isNegative) {\n        yield fixer.insertTextBefore(node, '!');\n      }\n\n      yield fixer.replaceTextRange([propertyRange[0], node.right.range[0]], `${isOptional ? '?.' : '.'}${kind}sWith(`);\n      yield fixer.replaceTextRange([node.right.range[1], node.range[1]], ')');\n    }\n    /**\n     * Fix code with using the first argument as the search string.\n     * For example: `foo.indexOf('bar') === 0` → `foo.startsWith('bar')`\n     * @param fixer The rule fixer.\n     * @param node The node which was reported.\n     * @param kind The kind of the report.\n     * @param negative The flag to fix to negative condition.\n     */\n\n\n    function* fixWithArgument(fixer, node, callNode, calleeNode, kind, negative, isOptional) {\n      if (negative) {\n        yield fixer.insertTextBefore(node, '!');\n      }\n\n      yield fixer.replaceTextRange(getPropertyRange(calleeNode), `${isOptional ? '?.' : '.'}${kind}sWith`);\n      yield fixer.removeRange([callNode.range[1], node.range[1]]);\n    }\n\n    function getParent(node) {\n      var _a;\n\n      return (0, util_1.nullThrows)(((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ChainExpression ? node.parent.parent : node.parent, util_1.NullThrowsReasons.MissingParent);\n    }\n\n    return {\n      // foo[0] === \"a\"\n      // foo.charAt(0) === \"a\"\n      // foo[foo.length - 1] === \"a\"\n      // foo.charAt(foo.length - 1) === \"a\"\n      [['BinaryExpression > MemberExpression.left[computed=true]', 'BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"charAt\"][computed=false]', 'BinaryExpression > ChainExpression.left > MemberExpression[computed=true]', 'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"charAt\"][computed=false]'].join(', ')](node) {\n        let parentNode = getParent(node);\n        let indexNode = null;\n\n        if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.type) === utils_1.AST_NODE_TYPES.CallExpression) {\n          if (parentNode.arguments.length === 1) {\n            indexNode = parentNode.arguments[0];\n          }\n\n          parentNode = getParent(parentNode);\n        } else {\n          indexNode = node.property;\n        }\n\n        if (indexNode == null || !isEqualityComparison(parentNode) || !isStringType(node.object)) {\n          return;\n        }\n\n        const isEndsWith = isLastIndexExpression(indexNode, node.object);\n        const isStartsWith = !isEndsWith && isNumber(indexNode, 0);\n\n        if (!isStartsWith && !isEndsWith) {\n          return;\n        }\n\n        const eqNode = parentNode;\n        context.report({\n          node: parentNode,\n          messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',\n\n          fix(fixer) {\n            // Don't fix if it can change the behavior.\n            if (!isCharacter(eqNode.right)) {\n              return null;\n            }\n\n            return fixWithRightOperand(fixer, eqNode, isStartsWith ? 'start' : 'end', eqNode.operator.startsWith('!'), node.optional);\n          }\n\n        });\n      },\n\n      // foo.indexOf('bar') === 0\n      [['BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"indexOf\"][computed=false]', 'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"indexOf\"][computed=false]'].join(', ')](node) {\n        const callNode = getParent(node);\n        const parentNode = getParent(callNode);\n\n        if (callNode.arguments.length !== 1 || !isEqualityComparison(parentNode) || !isNumber(parentNode.right, 0) || !isStringType(node.object)) {\n          return;\n        }\n\n        context.report({\n          node: parentNode,\n          messageId: 'preferStartsWith',\n\n          fix(fixer) {\n            return fixWithArgument(fixer, parentNode, callNode, node, 'start', parentNode.operator.startsWith('!'), node.optional);\n          }\n\n        });\n      },\n\n      // foo.lastIndexOf('bar') === foo.length - 3\n      // foo.lastIndexOf(bar) === foo.length - bar.length\n      [['BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"lastIndexOf\"][computed=false]', 'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"lastIndexOf\"][computed=false]'].join(', ')](node) {\n        const callNode = getParent(node);\n        const parentNode = getParent(callNode);\n\n        if (callNode.arguments.length !== 1 || !isEqualityComparison(parentNode) || parentNode.right.type !== utils_1.AST_NODE_TYPES.BinaryExpression || parentNode.right.operator !== '-' || !isLengthExpression(parentNode.right.left, node.object) || !isLengthExpression(parentNode.right.right, callNode.arguments[0]) || !isStringType(node.object)) {\n          return;\n        }\n\n        context.report({\n          node: parentNode,\n          messageId: 'preferEndsWith',\n\n          fix(fixer) {\n            return fixWithArgument(fixer, parentNode, callNode, node, 'end', parentNode.operator.startsWith('!'), node.optional);\n          }\n\n        });\n      },\n\n      // foo.match(/^bar/) === null\n      // foo.match(/bar$/) === null\n      [['BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"match\"][computed=false]', 'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"match\"][computed=false]'].join(', ')](node) {\n        const callNode = getParent(node);\n        const parentNode = getParent(callNode);\n\n        if (!isEqualityComparison(parentNode) || !isNull(parentNode.right) || !isStringType(node.object)) {\n          return;\n        }\n\n        const parsed = callNode.arguments.length === 1 ? parseRegExp(callNode.arguments[0]) : null;\n\n        if (parsed == null) {\n          return;\n        }\n\n        const {\n          isStartsWith,\n          text\n        } = parsed;\n        context.report({\n          node: callNode,\n          messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',\n\n          *fix(fixer) {\n            if (!parentNode.operator.startsWith('!')) {\n              yield fixer.insertTextBefore(parentNode, '!');\n            }\n\n            yield fixer.replaceTextRange(getPropertyRange(node), `${node.optional ? '?.' : '.'}${isStartsWith ? 'start' : 'end'}sWith`);\n            yield fixer.replaceText(callNode.arguments[0], JSON.stringify(text));\n            yield fixer.removeRange([callNode.range[1], parentNode.range[1]]);\n          }\n\n        });\n      },\n\n      // foo.slice(0, 3) === 'bar'\n      // foo.slice(-3) === 'bar'\n      // foo.slice(-3, foo.length) === 'bar'\n      // foo.substring(0, 3) === 'bar'\n      // foo.substring(foo.length - 3) === 'bar'\n      // foo.substring(foo.length - 3, foo.length) === 'bar'\n      [['BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"slice\"][computed=false]', 'BinaryExpression > CallExpression.left > MemberExpression.callee[property.name=\"substring\"][computed=false]', 'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"slice\"][computed=false]', 'BinaryExpression > ChainExpression.left > CallExpression > MemberExpression.callee[property.name=\"substring\"][computed=false]'].join(', ')](node) {\n        const callNode = getParent(node);\n        const parentNode = getParent(callNode);\n\n        if (!isEqualityComparison(parentNode) || !isStringType(node.object)) {\n          return;\n        }\n\n        const isEndsWith = (callNode.arguments.length === 1 || callNode.arguments.length === 2 && isLengthExpression(callNode.arguments[1], node.object)) && isNegativeIndexExpression(callNode.arguments[0], node.object);\n        const isStartsWith = !isEndsWith && callNode.arguments.length === 2 && isNumber(callNode.arguments[0], 0) && !isNegativeIndexExpression(callNode.arguments[1], node.object);\n\n        if (!isStartsWith && !isEndsWith) {\n          return;\n        }\n\n        const eqNode = parentNode;\n        const negativeIndexSupported = node.property.name === 'slice';\n        context.report({\n          node: parentNode,\n          messageId: isStartsWith ? 'preferStartsWith' : 'preferEndsWith',\n\n          fix(fixer) {\n            // Don't fix if it can change the behavior.\n            if (eqNode.operator.length === 2 && (eqNode.right.type !== utils_1.AST_NODE_TYPES.Literal || typeof eqNode.right.value !== 'string')) {\n              return null;\n            } // code being checked is likely mistake:\n            // unequal length of strings being checked for equality\n            // or reliant on behavior of substring (negative indices interpreted as 0)\n\n\n            if (isStartsWith) {\n              if (!isLengthExpression(callNode.arguments[1], eqNode.right)) {\n                return null;\n              }\n            } else {\n              const posNode = callNode.arguments[0];\n              const posNodeIsAbsolutelyValid = posNode.type === utils_1.AST_NODE_TYPES.BinaryExpression && posNode.operator === '-' && isLengthExpression(posNode.left, node.object) && isLengthExpression(posNode.right, eqNode.right) || negativeIndexSupported && posNode.type === utils_1.AST_NODE_TYPES.UnaryExpression && posNode.operator === '-' && isLengthExpression(posNode.argument, eqNode.right);\n\n              if (!posNodeIsAbsolutelyValid) {\n                return null;\n              }\n            }\n\n            return fixWithRightOperand(fixer, parentNode, isStartsWith ? 'start' : 'end', parentNode.operator.startsWith('!'), node.optional);\n          }\n\n        });\n      },\n\n      // /^bar/.test(foo)\n      // /bar$/.test(foo)\n      'CallExpression > MemberExpression.callee[property.name=\"test\"][computed=false]'(node) {\n        const callNode = getParent(node);\n        const parsed = callNode.arguments.length === 1 ? parseRegExp(node.object) : null;\n\n        if (parsed == null) {\n          return;\n        }\n\n        const {\n          isStartsWith,\n          text\n        } = parsed;\n        const messageId = isStartsWith ? 'preferStartsWith' : 'preferEndsWith';\n        const methodName = isStartsWith ? 'startsWith' : 'endsWith';\n        context.report({\n          node: callNode,\n          messageId,\n\n          *fix(fixer) {\n            const argNode = callNode.arguments[0];\n            const needsParen = argNode.type !== utils_1.AST_NODE_TYPES.Literal && argNode.type !== utils_1.AST_NODE_TYPES.TemplateLiteral && argNode.type !== utils_1.AST_NODE_TYPES.Identifier && argNode.type !== utils_1.AST_NODE_TYPES.MemberExpression && argNode.type !== utils_1.AST_NODE_TYPES.CallExpression;\n            yield fixer.removeRange([callNode.range[0], argNode.range[0]]);\n\n            if (needsParen) {\n              yield fixer.insertTextBefore(argNode, '(');\n              yield fixer.insertTextAfter(argNode, ')');\n            }\n\n            yield fixer.insertTextAfter(argNode, `${node.optional ? '?.' : '.'}${methodName}(${JSON.stringify(text)}`);\n          }\n\n        });\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["EQ_OPERATORS","regexpp","regexpp_1","exports","name","defaultOptions","meta","type","docs","description","recommended","requiresTypeChecking","messages","preferStartsWith","preferEndsWith","schema","fixable","create","context","globalScope","getScope","sourceCode","getSourceCode","service","typeChecker","program","getTypeChecker","isStringType","node","objectType","getTypeAtLocation","esTreeNodeToTSNodeMap","get","isNull","evaluated","value","isNumber","isCharacter","isEqualityComparison","utils_1","BinaryExpression","test","operator","isSameTokens","node1","node2","tokens1","getTokens","tokens2","length","i","token1","token2","isLengthExpression","expectedObjectNode","MemberExpression","object","evaluatedLength","evaluatedString","isNegativeIndexExpression","expectedIndexedNode","UnaryExpression","left","isLastIndexExpression","right","getPropertyRange","dotOrOpenBracket","getTokenAfter","util_1","range","parseRegExpText","pattern","uFlag","ast","parsePattern","undefined","alternatives","chars","elements","first","kind","shift","pop","every","c","String","fromCodePoint","map","parseRegExp","RegExp","source","flags","isStartsWith","startsWith","isEndsWith","endsWith","includes","text","getLeftNode","ChainExpression","expression","leftNode","CallExpression","callee","Error","fixWithRightOperand","fixer","isNegative","isOptional","propertyRange","insertTextBefore","replaceTextRange","fixWithArgument","callNode","calleeNode","negative","removeRange","getParent","parent","_a","MissingParent","join","parentNode","indexNode","arguments","property","eqNode","report","messageId","fix","optional","parsed","replaceText","JSON","stringify","negativeIndexSupported","Literal","posNode","posNodeIsAbsolutelyValid","argument","methodName","argNode","needsParen","TemplateLiteral","Identifier","insertTextAfter"],"sources":["../../src/rules/prefer-string-starts-ends-with.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}