{"ast":null,"code":"import { compareRangeCovs } from \"./compare\";\nexport function emitForest(trees) {\n  return emitForestLines(trees).join(\"\\n\");\n}\nexport function emitForestLines(trees) {\n  const colMap = getColMap(trees);\n  const header = emitOffsets(colMap);\n  return [header, ...trees.map(tree => emitTree(tree, colMap).join(\"\\n\"))];\n}\n\nfunction getColMap(trees) {\n  const eventSet = new Set();\n\n  for (const tree of trees) {\n    const stack = [tree];\n\n    while (stack.length > 0) {\n      const cur = stack.pop();\n      eventSet.add(cur.start);\n      eventSet.add(cur.end);\n\n      for (const child of cur.children) {\n        stack.push(child);\n      }\n    }\n  }\n\n  const events = [...eventSet];\n  events.sort((a, b) => a - b);\n  let maxDigits = 1;\n\n  for (const event of events) {\n    maxDigits = Math.max(maxDigits, event.toString(10).length);\n  }\n\n  const colWidth = maxDigits + 3;\n  const colMap = new Map();\n\n  for (const [i, event] of events.entries()) {\n    colMap.set(event, i * colWidth);\n  }\n\n  return colMap;\n}\n\nfunction emitTree(tree, colMap) {\n  const layers = [];\n  let nextLayer = [tree];\n\n  while (nextLayer.length > 0) {\n    const layer = nextLayer;\n    layers.push(layer);\n    nextLayer = [];\n\n    for (const node of layer) {\n      for (const child of node.children) {\n        nextLayer.push(child);\n      }\n    }\n  }\n\n  return layers.map(layer => emitTreeLayer(layer, colMap));\n}\n\nexport function parseFunctionRanges(text, offsetMap) {\n  const result = [];\n\n  for (const line of text.split(\"\\n\")) {\n    for (const range of parseTreeLayer(line, offsetMap)) {\n      result.push(range);\n    }\n  }\n\n  result.sort(compareRangeCovs);\n  return result;\n}\n/**\n *\n * @param layer Sorted list of disjoint trees.\n * @param colMap\n */\n\nfunction emitTreeLayer(layer, colMap) {\n  const line = [];\n  let curIdx = 0;\n\n  for (const {\n    start,\n    end,\n    count\n  } of layer) {\n    const startIdx = colMap.get(start);\n    const endIdx = colMap.get(end);\n\n    if (startIdx > curIdx) {\n      line.push(\" \".repeat(startIdx - curIdx));\n    }\n\n    line.push(emitRange(count, endIdx - startIdx));\n    curIdx = endIdx;\n  }\n\n  return line.join(\"\");\n}\n\nfunction parseTreeLayer(text, offsetMap) {\n  const result = [];\n  const regex = /\\[(\\d+)-*\\)/gs;\n\n  while (true) {\n    const match = regex.exec(text);\n\n    if (match === null) {\n      break;\n    }\n\n    const startIdx = match.index;\n    const endIdx = startIdx + match[0].length;\n    const count = parseInt(match[1], 10);\n    const startOffset = offsetMap.get(startIdx);\n    const endOffset = offsetMap.get(endIdx);\n\n    if (startOffset === undefined || endOffset === undefined) {\n      throw new Error(`Invalid offsets for: ${JSON.stringify(text)}`);\n    }\n\n    result.push({\n      startOffset,\n      endOffset,\n      count\n    });\n  }\n\n  return result;\n}\n\nfunction emitRange(count, len) {\n  const rangeStart = `[${count.toString(10)}`;\n  const rangeEnd = \")\";\n  const hyphensLen = len - (rangeStart.length + rangeEnd.length);\n  const hyphens = \"-\".repeat(Math.max(0, hyphensLen));\n  return `${rangeStart}${hyphens}${rangeEnd}`;\n}\n\nfunction emitOffsets(colMap) {\n  let line = \"\";\n\n  for (const [event, col] of colMap) {\n    if (line.length < col) {\n      line += \" \".repeat(col - line.length);\n    }\n\n    line += event.toString(10);\n  }\n\n  return line;\n}\n\nexport function parseOffsets(text) {\n  const result = new Map();\n  const regex = /\\d+/gs;\n\n  while (true) {\n    const match = regex.exec(text);\n\n    if (match === null) {\n      break;\n    }\n\n    result.set(match.index, parseInt(match[0], 10));\n  }\n\n  return result;\n}","map":{"version":3,"mappings":"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","names":["compareRangeCovs","emitForest","trees","emitForestLines","join","colMap","getColMap","header","emitOffsets","map","tree","emitTree","eventSet","Set","stack","length","cur","pop","add","start","end","child","children","push","events","sort","a","b","maxDigits","event","Math","max","toString","colWidth","Map","i","entries","set","layers","nextLayer","layer","node","emitTreeLayer","parseFunctionRanges","text","offsetMap","result","line","split","range","parseTreeLayer","curIdx","count","startIdx","get","endIdx","repeat","emitRange","regex","match","exec","index","parseInt","startOffset","endOffset","undefined","Error","JSON","stringify","len","rangeStart","rangeEnd","hyphensLen","hyphens","col","parseOffsets"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@bcoe\\v8-coverage\\dist\\lib\\_src\\ascii.ts"],"sourcesContent":["import { compareRangeCovs } from \"./compare\";\nimport { RangeCov } from \"./types\";\n\ninterface ReadonlyRangeTree {\n  readonly start: number;\n  readonly end: number;\n  readonly count: number;\n  readonly children: ReadonlyRangeTree[];\n}\n\nexport function emitForest(trees: ReadonlyArray<ReadonlyRangeTree>): string {\n  return emitForestLines(trees).join(\"\\n\");\n}\n\nexport function emitForestLines(trees: ReadonlyArray<ReadonlyRangeTree>): string[] {\n  const colMap: Map<number, number> = getColMap(trees);\n  const header: string = emitOffsets(colMap);\n  return [header, ...trees.map(tree => emitTree(tree, colMap).join(\"\\n\"))];\n}\n\nfunction getColMap(trees: Iterable<ReadonlyRangeTree>): Map<number, number> {\n  const eventSet: Set<number> = new Set();\n  for (const tree of trees) {\n    const stack: ReadonlyRangeTree[] = [tree];\n    while (stack.length > 0) {\n      const cur: ReadonlyRangeTree = stack.pop()!;\n      eventSet.add(cur.start);\n      eventSet.add(cur.end);\n      for (const child of cur.children) {\n        stack.push(child);\n      }\n    }\n  }\n  const events: number[] = [...eventSet];\n  events.sort((a, b) => a - b);\n  let maxDigits: number = 1;\n  for (const event of events) {\n    maxDigits = Math.max(maxDigits, event.toString(10).length);\n  }\n  const colWidth: number = maxDigits + 3;\n  const colMap: Map<number, number> = new Map();\n  for (const [i, event] of events.entries()) {\n    colMap.set(event, i * colWidth);\n  }\n  return colMap;\n}\n\nfunction emitTree(tree: ReadonlyRangeTree, colMap: Map<number, number>): string[] {\n  const layers: ReadonlyRangeTree[][] = [];\n  let nextLayer: ReadonlyRangeTree[] = [tree];\n  while (nextLayer.length > 0) {\n    const layer: ReadonlyRangeTree[] = nextLayer;\n    layers.push(layer);\n    nextLayer = [];\n    for (const node of layer) {\n      for (const child of node.children) {\n        nextLayer.push(child);\n      }\n    }\n  }\n  return layers.map(layer => emitTreeLayer(layer, colMap));\n}\n\nexport function parseFunctionRanges(text: string, offsetMap: Map<number, number>): RangeCov[] {\n  const result: RangeCov[] = [];\n  for (const line of text.split(\"\\n\")) {\n    for (const range of parseTreeLayer(line, offsetMap)) {\n      result.push(range);\n    }\n  }\n  result.sort(compareRangeCovs);\n  return result;\n}\n\n/**\n *\n * @param layer Sorted list of disjoint trees.\n * @param colMap\n */\nfunction emitTreeLayer(layer: ReadonlyRangeTree[], colMap: Map<number, number>): string {\n  const line: string[] = [];\n  let curIdx: number = 0;\n  for (const {start, end, count} of layer) {\n    const startIdx: number = colMap.get(start)!;\n    const endIdx: number = colMap.get(end)!;\n    if (startIdx > curIdx) {\n      line.push(\" \".repeat(startIdx - curIdx));\n    }\n    line.push(emitRange(count, endIdx - startIdx));\n    curIdx = endIdx;\n  }\n  return line.join(\"\");\n}\n\nfunction parseTreeLayer(text: string, offsetMap: Map<number, number>): RangeCov[] {\n  const result: RangeCov[] = [];\n  const regex: RegExp = /\\[(\\d+)-*\\)/gs;\n  while (true) {\n    const match: RegExpMatchArray | null = regex.exec(text);\n    if (match === null) {\n      break;\n    }\n    const startIdx: number = match.index!;\n    const endIdx: number = startIdx + match[0].length;\n    const count: number = parseInt(match[1], 10);\n    const startOffset: number | undefined = offsetMap.get(startIdx);\n    const endOffset: number | undefined = offsetMap.get(endIdx);\n    if (startOffset === undefined || endOffset === undefined) {\n      throw new Error(`Invalid offsets for: ${JSON.stringify(text)}`);\n    }\n    result.push({startOffset, endOffset, count});\n  }\n  return result;\n}\n\nfunction emitRange(count: number, len: number): string {\n  const rangeStart: string = `[${count.toString(10)}`;\n  const rangeEnd: string = \")\";\n  const hyphensLen: number = len - (rangeStart.length + rangeEnd.length);\n  const hyphens: string = \"-\".repeat(Math.max(0, hyphensLen));\n  return `${rangeStart}${hyphens}${rangeEnd}`;\n}\n\nfunction emitOffsets(colMap: Map<number, number>): string {\n  let line: string = \"\";\n  for (const [event, col] of colMap) {\n    if (line.length < col) {\n      line += \" \".repeat(col - line.length);\n    }\n    line += event.toString(10);\n  }\n  return line;\n}\n\nexport function parseOffsets(text: string): Map<number, number> {\n  const result: Map<number, number> = new Map();\n  const regex: RegExp = /\\d+/gs;\n  while (true) {\n    const match: RegExpExecArray | null = regex.exec(text);\n    if (match === null) {\n      break;\n    }\n    result.set(match.index, parseInt(match[0], 10));\n  }\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}