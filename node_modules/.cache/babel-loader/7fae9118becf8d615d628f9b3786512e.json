{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst isNullLiteral = node => node.type === _experimentalUtils.AST_NODE_TYPES.Literal && node.value === null;\n/**\n * Checks if the given `ParsedEqualityMatcherCall` is a call to one of the equality matchers,\n * with a `null` literal as the sole argument.\n */\n\n\nconst isNullEqualityMatcher = matcher => isNullLiteral(getFirstArgument(matcher));\n\nconst isFirstArgumentIdentifier = (matcher, name) => (0, _utils.isIdentifier)(getFirstArgument(matcher), name);\n\nconst shouldUseToBe = matcher => {\n  const firstArg = getFirstArgument(matcher);\n\n  if (firstArg.type === _experimentalUtils.AST_NODE_TYPES.Literal) {\n    // regex literals are classed as literals, but they're actually objects\n    // which means \"toBe\" will give different results than other matchers\n    return !('regex' in firstArg);\n  }\n\n  return firstArg.type === _experimentalUtils.AST_NODE_TYPES.TemplateLiteral;\n};\n\nconst getFirstArgument = matcher => {\n  return (0, _utils.followTypeAssertionChain)(matcher.arguments[0]);\n};\n\nconst reportPreferToBe = (context, whatToBe, matcher, modifier) => {\n  const modifierNode = (modifier === null || modifier === void 0 ? void 0 : modifier.negation) || (modifier === null || modifier === void 0 ? void 0 : modifier.name) === _utils.ModifierName.not && (modifier === null || modifier === void 0 ? void 0 : modifier.node);\n  context.report({\n    messageId: `useToBe${whatToBe}`,\n\n    fix(fixer) {\n      var _matcher$arguments;\n\n      const fixes = [fixer.replaceText(matcher.node.property, `toBe${whatToBe}`)];\n\n      if ((_matcher$arguments = matcher.arguments) !== null && _matcher$arguments !== void 0 && _matcher$arguments.length && whatToBe !== '') {\n        fixes.push(fixer.remove(matcher.arguments[0]));\n      }\n\n      if (modifierNode) {\n        fixes.push(fixer.removeRange([modifierNode.property.range[0] - 1, modifierNode.property.range[1]]));\n      }\n\n      return fixes;\n    },\n\n    node: matcher.node.property\n  });\n};\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Suggest using `toBe()` for primitive literals',\n      recommended: false\n    },\n    messages: {\n      useToBe: 'Use `toBe` when expecting primitive literals',\n      useToBeUndefined: 'Use `toBeUndefined` instead',\n      useToBeDefined: 'Use `toBeDefined` instead',\n      useToBeNull: 'Use `toBeNull` instead',\n      useToBeNaN: 'Use `toBeNaN` instead'\n    },\n    fixable: 'code',\n    type: 'suggestion',\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        if (!(0, _utils.isExpectCall)(node)) {\n          return;\n        }\n\n        const {\n          matcher,\n          modifier\n        } = (0, _utils.parseExpectCall)(node);\n\n        if (!matcher) {\n          return;\n        }\n\n        if (((modifier === null || modifier === void 0 ? void 0 : modifier.name) === _utils.ModifierName.not || modifier !== null && modifier !== void 0 && modifier.negation) && ['toBeUndefined', 'toBeDefined'].includes(matcher.name)) {\n          reportPreferToBe(context, matcher.name === 'toBeDefined' ? 'Undefined' : 'Defined', matcher, modifier);\n          return;\n        }\n\n        if (!(0, _utils.isParsedEqualityMatcherCall)(matcher)) {\n          return;\n        }\n\n        if (isNullEqualityMatcher(matcher)) {\n          reportPreferToBe(context, 'Null', matcher);\n          return;\n        }\n\n        if (isFirstArgumentIdentifier(matcher, 'undefined')) {\n          const name = (modifier === null || modifier === void 0 ? void 0 : modifier.name) === _utils.ModifierName.not || modifier !== null && modifier !== void 0 && modifier.negation ? 'Defined' : 'Undefined';\n          reportPreferToBe(context, name, matcher, modifier);\n          return;\n        }\n\n        if (isFirstArgumentIdentifier(matcher, 'NaN')) {\n          reportPreferToBe(context, 'NaN', matcher);\n          return;\n        }\n\n        if (shouldUseToBe(matcher) && matcher.name !== _utils.EqualityMatcher.toBe) {\n          reportPreferToBe(context, '', matcher);\n        }\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_experimentalUtils","require","_utils","isNullLiteral","node","type","AST_NODE_TYPES","Literal","isNullEqualityMatcher","matcher","getFirstArgument","isFirstArgumentIdentifier","name","isIdentifier","shouldUseToBe","firstArg","TemplateLiteral","followTypeAssertionChain","arguments","reportPreferToBe","context","whatToBe","modifier","modifierNode","negation","ModifierName","not","report","messageId","fix","fixer","_matcher$arguments","fixes","replaceText","property","length","push","remove","removeRange","range","_default","createRule","__filename","meta","docs","category","description","recommended","messages","useToBe","useToBeUndefined","useToBeDefined","useToBeNull","useToBeNaN","fixable","schema","defaultOptions","create","CallExpression","isExpectCall","parseExpectCall","includes","isParsedEqualityMatcherCall","EqualityMatcher","toBe"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-jest/lib/rules/prefer-to-be.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst isNullLiteral = node => node.type === _experimentalUtils.AST_NODE_TYPES.Literal && node.value === null;\n/**\n * Checks if the given `ParsedEqualityMatcherCall` is a call to one of the equality matchers,\n * with a `null` literal as the sole argument.\n */\n\n\nconst isNullEqualityMatcher = matcher => isNullLiteral(getFirstArgument(matcher));\n\nconst isFirstArgumentIdentifier = (matcher, name) => (0, _utils.isIdentifier)(getFirstArgument(matcher), name);\n\nconst shouldUseToBe = matcher => {\n  const firstArg = getFirstArgument(matcher);\n\n  if (firstArg.type === _experimentalUtils.AST_NODE_TYPES.Literal) {\n    // regex literals are classed as literals, but they're actually objects\n    // which means \"toBe\" will give different results than other matchers\n    return !('regex' in firstArg);\n  }\n\n  return firstArg.type === _experimentalUtils.AST_NODE_TYPES.TemplateLiteral;\n};\n\nconst getFirstArgument = matcher => {\n  return (0, _utils.followTypeAssertionChain)(matcher.arguments[0]);\n};\n\nconst reportPreferToBe = (context, whatToBe, matcher, modifier) => {\n  const modifierNode = (modifier === null || modifier === void 0 ? void 0 : modifier.negation) || (modifier === null || modifier === void 0 ? void 0 : modifier.name) === _utils.ModifierName.not && (modifier === null || modifier === void 0 ? void 0 : modifier.node);\n  context.report({\n    messageId: `useToBe${whatToBe}`,\n\n    fix(fixer) {\n      var _matcher$arguments;\n\n      const fixes = [fixer.replaceText(matcher.node.property, `toBe${whatToBe}`)];\n\n      if ((_matcher$arguments = matcher.arguments) !== null && _matcher$arguments !== void 0 && _matcher$arguments.length && whatToBe !== '') {\n        fixes.push(fixer.remove(matcher.arguments[0]));\n      }\n\n      if (modifierNode) {\n        fixes.push(fixer.removeRange([modifierNode.property.range[0] - 1, modifierNode.property.range[1]]));\n      }\n\n      return fixes;\n    },\n\n    node: matcher.node.property\n  });\n};\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Suggest using `toBe()` for primitive literals',\n      recommended: false\n    },\n    messages: {\n      useToBe: 'Use `toBe` when expecting primitive literals',\n      useToBeUndefined: 'Use `toBeUndefined` instead',\n      useToBeDefined: 'Use `toBeDefined` instead',\n      useToBeNull: 'Use `toBeNull` instead',\n      useToBeNaN: 'Use `toBeNaN` instead'\n    },\n    fixable: 'code',\n    type: 'suggestion',\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        if (!(0, _utils.isExpectCall)(node)) {\n          return;\n        }\n\n        const {\n          matcher,\n          modifier\n        } = (0, _utils.parseExpectCall)(node);\n\n        if (!matcher) {\n          return;\n        }\n\n        if (((modifier === null || modifier === void 0 ? void 0 : modifier.name) === _utils.ModifierName.not || modifier !== null && modifier !== void 0 && modifier.negation) && ['toBeUndefined', 'toBeDefined'].includes(matcher.name)) {\n          reportPreferToBe(context, matcher.name === 'toBeDefined' ? 'Undefined' : 'Defined', matcher, modifier);\n          return;\n        }\n\n        if (!(0, _utils.isParsedEqualityMatcherCall)(matcher)) {\n          return;\n        }\n\n        if (isNullEqualityMatcher(matcher)) {\n          reportPreferToBe(context, 'Null', matcher);\n          return;\n        }\n\n        if (isFirstArgumentIdentifier(matcher, 'undefined')) {\n          const name = (modifier === null || modifier === void 0 ? void 0 : modifier.name) === _utils.ModifierName.not || modifier !== null && modifier !== void 0 && modifier.negation ? 'Defined' : 'Undefined';\n          reportPreferToBe(context, name, matcher, modifier);\n          return;\n        }\n\n        if (isFirstArgumentIdentifier(matcher, 'NaN')) {\n          reportPreferToBe(context, 'NaN', matcher);\n          return;\n        }\n\n        if (shouldUseToBe(matcher) && matcher.name !== _utils.EqualityMatcher.toBe) {\n          reportPreferToBe(context, '', matcher);\n        }\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}