{"ast":null,"code":"'use strict';\n\nconst valueParser = require('postcss-value-parser');\n/*\n * Constants (parser usage)\n */\n\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0);\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0);\nconst BACKSLASH = '\\\\'.charCodeAt(0);\nconst NEWLINE = '\\n'.charCodeAt(0);\nconst SPACE = ' '.charCodeAt(0);\nconst FEED = '\\f'.charCodeAt(0);\nconst TAB = '\\t'.charCodeAt(0);\nconst CR = '\\r'.charCodeAt(0);\nconst WORD_END = /[ \\n\\t\\r\\f'\"\\\\]/g;\n/*\n * Constants (node type strings)\n */\n\nconst C_STRING = 'string';\nconst C_ESCAPED_SINGLE_QUOTE = 'escapedSingleQuote';\nconst C_ESCAPED_DOUBLE_QUOTE = 'escapedDoubleQuote';\nconst C_SINGLE_QUOTE = 'singleQuote';\nconst C_DOUBLE_QUOTE = 'doubleQuote';\nconst C_NEWLINE = 'newline';\nconst C_SINGLE = 'single';\n/*\n * Literals\n */\n\nconst L_SINGLE_QUOTE = `'`;\nconst L_DOUBLE_QUOTE = `\"`;\nconst L_NEWLINE = `\\\\\\n`;\n/*\n * Parser nodes\n */\n\nconst T_ESCAPED_SINGLE_QUOTE = {\n  type: C_ESCAPED_SINGLE_QUOTE,\n  value: `\\\\'`\n};\nconst T_ESCAPED_DOUBLE_QUOTE = {\n  type: C_ESCAPED_DOUBLE_QUOTE,\n  value: `\\\\\"`\n};\nconst T_SINGLE_QUOTE = {\n  type: C_SINGLE_QUOTE,\n  value: L_SINGLE_QUOTE\n};\nconst T_DOUBLE_QUOTE = {\n  type: C_DOUBLE_QUOTE,\n  value: L_DOUBLE_QUOTE\n};\nconst T_NEWLINE = {\n  type: C_NEWLINE,\n  value: L_NEWLINE\n};\n/** @typedef {T_ESCAPED_SINGLE_QUOTE | T_ESCAPED_DOUBLE_QUOTE | T_SINGLE_QUOTE | T_NEWLINE} StringAstNode */\n\n/**\n * @typedef {{nodes: StringAstNode[],\n *            types: {escapedSingleQuote: number, escapedDoubleQuote: number, singleQuote: number, doubleQuote: number},\n *            quotes: boolean}} StringAst\n */\n\n/**\n * @param {StringAst} ast\n * @return {string}\n */\n\nfunction stringify(ast) {\n  return ast.nodes.reduce((str, _ref) => {\n    let {\n      value\n    } = _ref;\n\n    // Collapse multiple line strings automatically\n    if (value === L_NEWLINE) {\n      return str;\n    }\n\n    return str + value;\n  }, '');\n}\n/**\n * @param {string} str\n * @return {StringAst}\n */\n\n\nfunction parse(str) {\n  let code, next, value;\n  let pos = 0;\n  let len = str.length;\n  /** @type StringAst */\n\n  const ast = {\n    nodes: [],\n    types: {\n      escapedSingleQuote: 0,\n      escapedDoubleQuote: 0,\n      singleQuote: 0,\n      doubleQuote: 0\n    },\n    quotes: false\n  };\n\n  while (pos < len) {\n    code = str.charCodeAt(pos);\n\n    switch (code) {\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED:\n        next = pos;\n\n        do {\n          next += 1;\n          code = str.charCodeAt(next);\n        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n\n        ast.nodes.push({\n          type: 'space',\n          value: str.slice(pos, next)\n        });\n        pos = next - 1;\n        break;\n\n      case SINGLE_QUOTE:\n        ast.nodes.push(T_SINGLE_QUOTE);\n        ast.types[C_SINGLE_QUOTE]++;\n        ast.quotes = true;\n        break;\n\n      case DOUBLE_QUOTE:\n        ast.nodes.push(T_DOUBLE_QUOTE);\n        ast.types[C_DOUBLE_QUOTE]++;\n        ast.quotes = true;\n        break;\n\n      case BACKSLASH:\n        next = pos + 1;\n\n        if (str.charCodeAt(next) === SINGLE_QUOTE) {\n          ast.nodes.push(T_ESCAPED_SINGLE_QUOTE);\n          ast.types[C_ESCAPED_SINGLE_QUOTE]++;\n          ast.quotes = true;\n          pos = next;\n          break;\n        } else if (str.charCodeAt(next) === DOUBLE_QUOTE) {\n          ast.nodes.push(T_ESCAPED_DOUBLE_QUOTE);\n          ast.types[C_ESCAPED_DOUBLE_QUOTE]++;\n          ast.quotes = true;\n          pos = next;\n          break;\n        } else if (str.charCodeAt(next) === NEWLINE) {\n          ast.nodes.push(T_NEWLINE);\n          pos = next;\n          break;\n        }\n\n      /*\n       * We need to fall through here to handle the token as\n       * a whole word. The missing 'break' is intentional.\n       */\n\n      default:\n        WORD_END.lastIndex = pos + 1;\n        WORD_END.test(str);\n\n        if (WORD_END.lastIndex === 0) {\n          next = len - 1;\n        } else {\n          next = WORD_END.lastIndex - 2;\n        }\n\n        value = str.slice(pos, next + 1);\n        ast.nodes.push({\n          type: C_STRING,\n          value\n        });\n        pos = next;\n    }\n\n    pos++;\n  }\n\n  return ast;\n}\n/**\n * @param {valueParser.StringNode} node\n * @param {StringAst} ast\n * @return {void}\n */\n\n\nfunction changeWrappingQuotes(node, ast) {\n  const {\n    types\n  } = ast;\n\n  if (types[C_SINGLE_QUOTE] || types[C_DOUBLE_QUOTE]) {\n    return;\n  }\n\n  if (node.quote === L_SINGLE_QUOTE && types[C_ESCAPED_SINGLE_QUOTE] > 0 && !types[C_ESCAPED_DOUBLE_QUOTE]) {\n    node.quote = L_DOUBLE_QUOTE;\n  }\n\n  if (node.quote === L_DOUBLE_QUOTE && types[C_ESCAPED_DOUBLE_QUOTE] > 0 && !types[C_ESCAPED_SINGLE_QUOTE]) {\n    node.quote = L_SINGLE_QUOTE;\n  }\n\n  ast.nodes = changeChildQuotes(ast.nodes, node.quote);\n}\n/**\n * @param {StringAstNode[]} childNodes\n * @param {string} parentQuote\n * @return {StringAstNode[]}\n */\n\n\nfunction changeChildQuotes(childNodes, parentQuote) {\n  const updatedChildren = [];\n\n  for (const child of childNodes) {\n    if (child.type === C_ESCAPED_DOUBLE_QUOTE && parentQuote === L_SINGLE_QUOTE) {\n      updatedChildren.push(T_DOUBLE_QUOTE);\n    } else if (child.type === C_ESCAPED_SINGLE_QUOTE && parentQuote === L_DOUBLE_QUOTE) {\n      updatedChildren.push(T_SINGLE_QUOTE);\n    } else {\n      updatedChildren.push(child);\n    }\n  }\n\n  return updatedChildren;\n}\n/**\n * @param {string} value\n * @param {'single' | 'double'} preferredQuote\n * @return {string}\n */\n\n\nfunction normalize(value, preferredQuote) {\n  if (!value || !value.length) {\n    return value;\n  }\n\n  return valueParser(value).walk(child => {\n    if (child.type !== C_STRING) {\n      return;\n    }\n\n    const ast = parse(child.value);\n\n    if (ast.quotes) {\n      changeWrappingQuotes(child, ast);\n    } else if (preferredQuote === C_SINGLE) {\n      child.quote = L_SINGLE_QUOTE;\n    } else {\n      child.quote = L_DOUBLE_QUOTE;\n    }\n\n    child.value = stringify(ast);\n  }).toString();\n}\n/**\n * @param {string} original\n * @param {Map<string, string>} cache\n * @param {'single' | 'double'} preferredQuote\n * @return {string}\n */\n\n\nfunction minify(original, cache, preferredQuote) {\n  const key = original + '|' + preferredQuote;\n\n  if (cache.has(key)) {\n    return (\n      /** @type {string} */\n      cache.get(key)\n    );\n  }\n\n  const newValue = normalize(original, preferredQuote);\n  cache.set(key, newValue);\n  return newValue;\n}\n/** @typedef {{preferredQuote?: 'double' | 'single'}} Options */\n\n/**\n * @type {import('postcss').PluginCreator<Options>}\n * @param {Options} opts\n * @return {import('postcss').Plugin}\n */\n\n\nfunction pluginCreator(opts) {\n  const {\n    preferredQuote\n  } = Object.assign({}, {\n    preferredQuote: 'double'\n  }, opts);\n  return {\n    postcssPlugin: 'postcss-normalize-string',\n\n    OnceExit(css) {\n      const cache = new Map();\n      css.walk(node => {\n        switch (node.type) {\n          case 'rule':\n            node.selector = minify(node.selector, cache, preferredQuote);\n            break;\n\n          case 'decl':\n            node.value = minify(node.value, cache, preferredQuote);\n            break;\n\n          case 'atrule':\n            node.params = minify(node.params, cache, preferredQuote);\n            break;\n        }\n      });\n    }\n\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;","map":{"version":3,"names":["valueParser","require","SINGLE_QUOTE","charCodeAt","DOUBLE_QUOTE","BACKSLASH","NEWLINE","SPACE","FEED","TAB","CR","WORD_END","C_STRING","C_ESCAPED_SINGLE_QUOTE","C_ESCAPED_DOUBLE_QUOTE","C_SINGLE_QUOTE","C_DOUBLE_QUOTE","C_NEWLINE","C_SINGLE","L_SINGLE_QUOTE","L_DOUBLE_QUOTE","L_NEWLINE","T_ESCAPED_SINGLE_QUOTE","type","value","T_ESCAPED_DOUBLE_QUOTE","T_SINGLE_QUOTE","T_DOUBLE_QUOTE","T_NEWLINE","stringify","ast","nodes","reduce","str","parse","code","next","pos","len","length","types","escapedSingleQuote","escapedDoubleQuote","singleQuote","doubleQuote","quotes","push","slice","lastIndex","test","changeWrappingQuotes","node","quote","changeChildQuotes","childNodes","parentQuote","updatedChildren","child","normalize","preferredQuote","walk","toString","minify","original","cache","key","has","get","newValue","set","pluginCreator","opts","Object","assign","postcssPlugin","OnceExit","css","Map","selector","params","postcss","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-normalize-string/src/index.js"],"sourcesContent":["'use strict';\nconst valueParser = require('postcss-value-parser');\n\n/*\n * Constants (parser usage)\n */\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0);\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0);\nconst BACKSLASH = '\\\\'.charCodeAt(0);\nconst NEWLINE = '\\n'.charCodeAt(0);\nconst SPACE = ' '.charCodeAt(0);\nconst FEED = '\\f'.charCodeAt(0);\nconst TAB = '\\t'.charCodeAt(0);\nconst CR = '\\r'.charCodeAt(0);\n\nconst WORD_END = /[ \\n\\t\\r\\f'\"\\\\]/g;\n\n/*\n * Constants (node type strings)\n */\n\nconst C_STRING = 'string';\nconst C_ESCAPED_SINGLE_QUOTE = 'escapedSingleQuote';\nconst C_ESCAPED_DOUBLE_QUOTE = 'escapedDoubleQuote';\nconst C_SINGLE_QUOTE = 'singleQuote';\nconst C_DOUBLE_QUOTE = 'doubleQuote';\nconst C_NEWLINE = 'newline';\nconst C_SINGLE = 'single';\n\n/*\n * Literals\n */\n\nconst L_SINGLE_QUOTE = `'`;\nconst L_DOUBLE_QUOTE = `\"`;\nconst L_NEWLINE = `\\\\\\n`;\n\n/*\n * Parser nodes\n */\n\nconst T_ESCAPED_SINGLE_QUOTE = { type: C_ESCAPED_SINGLE_QUOTE, value: `\\\\'` };\nconst T_ESCAPED_DOUBLE_QUOTE = { type: C_ESCAPED_DOUBLE_QUOTE, value: `\\\\\"` };\nconst T_SINGLE_QUOTE = { type: C_SINGLE_QUOTE, value: L_SINGLE_QUOTE };\nconst T_DOUBLE_QUOTE = { type: C_DOUBLE_QUOTE, value: L_DOUBLE_QUOTE };\nconst T_NEWLINE = { type: C_NEWLINE, value: L_NEWLINE };\n\n/** @typedef {T_ESCAPED_SINGLE_QUOTE | T_ESCAPED_DOUBLE_QUOTE | T_SINGLE_QUOTE | T_NEWLINE} StringAstNode */\n/**\n * @typedef {{nodes: StringAstNode[],\n *            types: {escapedSingleQuote: number, escapedDoubleQuote: number, singleQuote: number, doubleQuote: number},\n *            quotes: boolean}} StringAst\n */\n\n/**\n * @param {StringAst} ast\n * @return {string}\n */\nfunction stringify(ast) {\n  return ast.nodes.reduce((str, { value }) => {\n    // Collapse multiple line strings automatically\n    if (value === L_NEWLINE) {\n      return str;\n    }\n\n    return str + value;\n  }, '');\n}\n\n/**\n * @param {string} str\n * @return {StringAst}\n */\nfunction parse(str) {\n  let code, next, value;\n  let pos = 0;\n  let len = str.length;\n\n  /** @type StringAst */\n  const ast = {\n    nodes: [],\n    types: {\n      escapedSingleQuote: 0,\n      escapedDoubleQuote: 0,\n      singleQuote: 0,\n      doubleQuote: 0,\n    },\n    quotes: false,\n  };\n\n  while (pos < len) {\n    code = str.charCodeAt(pos);\n\n    switch (code) {\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED:\n        next = pos;\n\n        do {\n          next += 1;\n          code = str.charCodeAt(next);\n        } while (\n          code === SPACE ||\n          code === NEWLINE ||\n          code === TAB ||\n          code === CR ||\n          code === FEED\n        );\n\n        ast.nodes.push({\n          type: 'space',\n          value: str.slice(pos, next),\n        });\n        pos = next - 1;\n        break;\n      case SINGLE_QUOTE:\n        ast.nodes.push(T_SINGLE_QUOTE);\n        ast.types[C_SINGLE_QUOTE]++;\n        ast.quotes = true;\n        break;\n      case DOUBLE_QUOTE:\n        ast.nodes.push(T_DOUBLE_QUOTE);\n        ast.types[C_DOUBLE_QUOTE]++;\n        ast.quotes = true;\n        break;\n      case BACKSLASH:\n        next = pos + 1;\n\n        if (str.charCodeAt(next) === SINGLE_QUOTE) {\n          ast.nodes.push(T_ESCAPED_SINGLE_QUOTE);\n          ast.types[C_ESCAPED_SINGLE_QUOTE]++;\n          ast.quotes = true;\n          pos = next;\n          break;\n        } else if (str.charCodeAt(next) === DOUBLE_QUOTE) {\n          ast.nodes.push(T_ESCAPED_DOUBLE_QUOTE);\n          ast.types[C_ESCAPED_DOUBLE_QUOTE]++;\n          ast.quotes = true;\n          pos = next;\n          break;\n        } else if (str.charCodeAt(next) === NEWLINE) {\n          ast.nodes.push(T_NEWLINE);\n          pos = next;\n          break;\n        }\n      /*\n       * We need to fall through here to handle the token as\n       * a whole word. The missing 'break' is intentional.\n       */\n      default:\n        WORD_END.lastIndex = pos + 1;\n        WORD_END.test(str);\n\n        if (WORD_END.lastIndex === 0) {\n          next = len - 1;\n        } else {\n          next = WORD_END.lastIndex - 2;\n        }\n\n        value = str.slice(pos, next + 1);\n\n        ast.nodes.push({\n          type: C_STRING,\n          value,\n        });\n\n        pos = next;\n    }\n    pos++;\n  }\n\n  return ast;\n}\n\n/**\n * @param {valueParser.StringNode} node\n * @param {StringAst} ast\n * @return {void}\n */\nfunction changeWrappingQuotes(node, ast) {\n  const { types } = ast;\n\n  if (types[C_SINGLE_QUOTE] || types[C_DOUBLE_QUOTE]) {\n    return;\n  }\n\n  if (\n    node.quote === L_SINGLE_QUOTE &&\n    types[C_ESCAPED_SINGLE_QUOTE] > 0 &&\n    !types[C_ESCAPED_DOUBLE_QUOTE]\n  ) {\n    node.quote = L_DOUBLE_QUOTE;\n  }\n\n  if (\n    node.quote === L_DOUBLE_QUOTE &&\n    types[C_ESCAPED_DOUBLE_QUOTE] > 0 &&\n    !types[C_ESCAPED_SINGLE_QUOTE]\n  ) {\n    node.quote = L_SINGLE_QUOTE;\n  }\n\n  ast.nodes = changeChildQuotes(ast.nodes, node.quote);\n}\n/**\n * @param {StringAstNode[]} childNodes\n * @param {string} parentQuote\n * @return {StringAstNode[]}\n */\nfunction changeChildQuotes(childNodes, parentQuote) {\n  const updatedChildren = [];\n  for (const child of childNodes) {\n    if (\n      child.type === C_ESCAPED_DOUBLE_QUOTE &&\n      parentQuote === L_SINGLE_QUOTE\n    ) {\n      updatedChildren.push(T_DOUBLE_QUOTE);\n    } else if (\n      child.type === C_ESCAPED_SINGLE_QUOTE &&\n      parentQuote === L_DOUBLE_QUOTE\n    ) {\n      updatedChildren.push(T_SINGLE_QUOTE);\n    } else {\n      updatedChildren.push(child);\n    }\n  }\n  return updatedChildren;\n}\n\n/**\n * @param {string} value\n * @param {'single' | 'double'} preferredQuote\n * @return {string}\n */\nfunction normalize(value, preferredQuote) {\n  if (!value || !value.length) {\n    return value;\n  }\n\n  return valueParser(value)\n    .walk((child) => {\n      if (child.type !== C_STRING) {\n        return;\n      }\n\n      const ast = parse(child.value);\n\n      if (ast.quotes) {\n        changeWrappingQuotes(child, ast);\n      } else if (preferredQuote === C_SINGLE) {\n        child.quote = L_SINGLE_QUOTE;\n      } else {\n        child.quote = L_DOUBLE_QUOTE;\n      }\n\n      child.value = stringify(ast);\n    })\n    .toString();\n}\n\n/**\n * @param {string} original\n * @param {Map<string, string>} cache\n * @param {'single' | 'double'} preferredQuote\n * @return {string}\n */\nfunction minify(original, cache, preferredQuote) {\n  const key = original + '|' + preferredQuote;\n  if (cache.has(key)) {\n    return /** @type {string} */ (cache.get(key));\n  }\n  const newValue = normalize(original, preferredQuote);\n  cache.set(key, newValue);\n  return newValue;\n}\n\n/** @typedef {{preferredQuote?: 'double' | 'single'}} Options */\n/**\n * @type {import('postcss').PluginCreator<Options>}\n * @param {Options} opts\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator(opts) {\n  const { preferredQuote } = Object.assign(\n    {},\n    {\n      preferredQuote: 'double',\n    },\n    opts\n  );\n\n  return {\n    postcssPlugin: 'postcss-normalize-string',\n\n    OnceExit(css) {\n      const cache = new Map();\n\n      css.walk((node) => {\n        switch (node.type) {\n          case 'rule':\n            node.selector = minify(node.selector, cache, preferredQuote);\n            break;\n          case 'decl':\n            node.value = minify(node.value, cache, preferredQuote);\n            break;\n          case 'atrule':\n            node.params = minify(node.params, cache, preferredQuote);\n            break;\n        }\n      });\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}