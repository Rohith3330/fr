{"ast":null,"code":"/**\n * @fileoverview Prevent problematic leaked values from being rendered\n * @author Mario Beltrán\n */\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report');\n\nconst isParenthesized = require('../util/ast').isParenthesized; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst messages = {\n  noPotentialLeakedRender: 'Potential leaked value that might cause unintentionally rendered values or rendering crashes'\n};\nconst COERCE_STRATEGY = 'coerce';\nconst TERNARY_STRATEGY = 'ternary';\nconst DEFAULT_VALID_STRATEGIES = [TERNARY_STRATEGY, COERCE_STRATEGY];\nconst COERCE_VALID_LEFT_SIDE_EXPRESSIONS = ['UnaryExpression', 'BinaryExpression', 'CallExpression'];\nconst TERNARY_INVALID_ALTERNATE_VALUES = [undefined, null, false];\n\nfunction trimLeftNode(node) {\n  // Remove double unary expression (boolean coercion), so we avoid trimming valid negations\n  if (node.type === 'UnaryExpression' && node.argument.type === 'UnaryExpression') {\n    return trimLeftNode(node.argument.argument);\n  }\n\n  return node;\n}\n\nfunction getIsCoerceValidNestedLogicalExpression(node) {\n  if (node.type === 'LogicalExpression') {\n    return getIsCoerceValidNestedLogicalExpression(node.left) && getIsCoerceValidNestedLogicalExpression(node.right);\n  }\n\n  return COERCE_VALID_LEFT_SIDE_EXPRESSIONS.some(validExpression => validExpression === node.type);\n}\n\nfunction extractExpressionBetweenLogicalAnds(node) {\n  if (node.type !== 'LogicalExpression') return [node];\n  if (node.operator !== '&&') return [node];\n  return [].concat(extractExpressionBetweenLogicalAnds(node.left), extractExpressionBetweenLogicalAnds(node.right));\n}\n\nfunction ruleFixer(context, fixStrategy, fixer, reportedNode, leftNode, rightNode) {\n  const sourceCode = context.getSourceCode();\n  const rightSideText = sourceCode.getText(rightNode);\n\n  if (fixStrategy === COERCE_STRATEGY) {\n    const expressions = extractExpressionBetweenLogicalAnds(leftNode);\n    const newText = expressions.map(node => {\n      let nodeText = sourceCode.getText(node);\n\n      if (isParenthesized(context, node)) {\n        nodeText = `(${nodeText})`;\n      }\n\n      return `${getIsCoerceValidNestedLogicalExpression(node) ? '' : '!!'}${nodeText}`;\n    }).join(' && ');\n    return fixer.replaceText(reportedNode, `${newText} && ${rightSideText}`);\n  }\n\n  if (fixStrategy === TERNARY_STRATEGY) {\n    let leftSideText = sourceCode.getText(trimLeftNode(leftNode));\n\n    if (isParenthesized(context, leftNode)) {\n      leftSideText = `(${leftSideText})`;\n    }\n\n    return fixer.replaceText(reportedNode, `${leftSideText} ? ${rightSideText} : null`);\n  }\n\n  throw new TypeError('Invalid value for \"validStrategies\" option');\n}\n/**\n * @type {import('eslint').Rule.RuleModule}\n */\n\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow problematic leaked values from being rendered',\n      category: 'Possible Errors',\n      recommended: false,\n      url: docsUrl('jsx-no-leaked-render')\n    },\n    messages,\n    fixable: 'code',\n    schema: [{\n      type: 'object',\n      properties: {\n        validStrategies: {\n          type: 'array',\n          items: {\n            enum: [TERNARY_STRATEGY, COERCE_STRATEGY]\n          },\n          uniqueItems: true,\n          default: DEFAULT_VALID_STRATEGIES\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const config = context.options[0] || {};\n    const validStrategies = new Set(config.validStrategies || DEFAULT_VALID_STRATEGIES);\n    const fixStrategy = Array.from(validStrategies)[0];\n    return {\n      'JSXExpressionContainer > LogicalExpression[operator=\"&&\"]'(node) {\n        const leftSide = node.left;\n        const isCoerceValidLeftSide = COERCE_VALID_LEFT_SIDE_EXPRESSIONS.some(validExpression => validExpression === leftSide.type);\n\n        if (validStrategies.has(COERCE_STRATEGY)) {\n          if (isCoerceValidLeftSide || getIsCoerceValidNestedLogicalExpression(leftSide)) {\n            return;\n          }\n        }\n\n        report(context, messages.noPotentialLeakedRender, 'noPotentialLeakedRender', {\n          node,\n\n          fix(fixer) {\n            return ruleFixer(context, fixStrategy, fixer, node, leftSide, node.right);\n          }\n\n        });\n      },\n\n      'JSXExpressionContainer > ConditionalExpression'(node) {\n        if (validStrategies.has(TERNARY_STRATEGY)) {\n          return;\n        }\n\n        const isValidTernaryAlternate = TERNARY_INVALID_ALTERNATE_VALUES.indexOf(node.alternate.value) === -1;\n        const isJSXElementAlternate = node.alternate.type === 'JSXElement';\n\n        if (isValidTernaryAlternate || isJSXElementAlternate) {\n          return;\n        }\n\n        report(context, messages.noPotentialLeakedRender, 'noPotentialLeakedRender', {\n          node,\n\n          fix(fixer) {\n            return ruleFixer(context, fixStrategy, fixer, node, node.test, node.consequent);\n          }\n\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["docsUrl","require","report","isParenthesized","messages","noPotentialLeakedRender","COERCE_STRATEGY","TERNARY_STRATEGY","DEFAULT_VALID_STRATEGIES","COERCE_VALID_LEFT_SIDE_EXPRESSIONS","TERNARY_INVALID_ALTERNATE_VALUES","undefined","trimLeftNode","node","type","argument","getIsCoerceValidNestedLogicalExpression","left","right","some","validExpression","extractExpressionBetweenLogicalAnds","operator","concat","ruleFixer","context","fixStrategy","fixer","reportedNode","leftNode","rightNode","sourceCode","getSourceCode","rightSideText","getText","expressions","newText","map","nodeText","join","replaceText","leftSideText","TypeError","module","exports","meta","docs","description","category","recommended","url","fixable","schema","properties","validStrategies","items","enum","uniqueItems","default","additionalProperties","create","config","options","Set","Array","from","leftSide","isCoerceValidLeftSide","has","fix","isValidTernaryAlternate","indexOf","alternate","value","isJSXElementAlternate","test","consequent"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-no-leaked-render.js"],"sourcesContent":["/**\n * @fileoverview Prevent problematic leaked values from being rendered\n * @author Mario Beltrán\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\nconst isParenthesized = require('../util/ast').isParenthesized;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst messages = {\n  noPotentialLeakedRender: 'Potential leaked value that might cause unintentionally rendered values or rendering crashes',\n};\n\nconst COERCE_STRATEGY = 'coerce';\nconst TERNARY_STRATEGY = 'ternary';\nconst DEFAULT_VALID_STRATEGIES = [TERNARY_STRATEGY, COERCE_STRATEGY];\nconst COERCE_VALID_LEFT_SIDE_EXPRESSIONS = ['UnaryExpression', 'BinaryExpression', 'CallExpression'];\nconst TERNARY_INVALID_ALTERNATE_VALUES = [undefined, null, false];\n\nfunction trimLeftNode(node) {\n  // Remove double unary expression (boolean coercion), so we avoid trimming valid negations\n  if (node.type === 'UnaryExpression' && node.argument.type === 'UnaryExpression') {\n    return trimLeftNode(node.argument.argument);\n  }\n\n  return node;\n}\n\nfunction getIsCoerceValidNestedLogicalExpression(node) {\n  if (node.type === 'LogicalExpression') {\n    return getIsCoerceValidNestedLogicalExpression(node.left) && getIsCoerceValidNestedLogicalExpression(node.right);\n  }\n\n  return COERCE_VALID_LEFT_SIDE_EXPRESSIONS.some((validExpression) => validExpression === node.type);\n}\n\nfunction extractExpressionBetweenLogicalAnds(node) {\n  if (node.type !== 'LogicalExpression') return [node];\n  if (node.operator !== '&&') return [node];\n  return [].concat(\n    extractExpressionBetweenLogicalAnds(node.left),\n    extractExpressionBetweenLogicalAnds(node.right)\n  );\n}\n\nfunction ruleFixer(context, fixStrategy, fixer, reportedNode, leftNode, rightNode) {\n  const sourceCode = context.getSourceCode();\n  const rightSideText = sourceCode.getText(rightNode);\n\n  if (fixStrategy === COERCE_STRATEGY) {\n    const expressions = extractExpressionBetweenLogicalAnds(leftNode);\n    const newText = expressions.map((node) => {\n      let nodeText = sourceCode.getText(node);\n      if (isParenthesized(context, node)) {\n        nodeText = `(${nodeText})`;\n      }\n      return `${getIsCoerceValidNestedLogicalExpression(node) ? '' : '!!'}${nodeText}`;\n    }).join(' && ');\n\n    return fixer.replaceText(reportedNode, `${newText} && ${rightSideText}`);\n  }\n\n  if (fixStrategy === TERNARY_STRATEGY) {\n    let leftSideText = sourceCode.getText(trimLeftNode(leftNode));\n    if (isParenthesized(context, leftNode)) {\n      leftSideText = `(${leftSideText})`;\n    }\n    return fixer.replaceText(reportedNode, `${leftSideText} ? ${rightSideText} : null`);\n  }\n\n  throw new TypeError('Invalid value for \"validStrategies\" option');\n}\n\n/**\n * @type {import('eslint').Rule.RuleModule}\n */\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow problematic leaked values from being rendered',\n      category: 'Possible Errors',\n      recommended: false,\n      url: docsUrl('jsx-no-leaked-render'),\n    },\n\n    messages,\n\n    fixable: 'code',\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          validStrategies: {\n            type: 'array',\n            items: {\n              enum: [\n                TERNARY_STRATEGY,\n                COERCE_STRATEGY,\n              ],\n            },\n            uniqueItems: true,\n            default: DEFAULT_VALID_STRATEGIES,\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n  },\n\n  create(context) {\n    const config = context.options[0] || {};\n    const validStrategies = new Set(config.validStrategies || DEFAULT_VALID_STRATEGIES);\n    const fixStrategy = Array.from(validStrategies)[0];\n\n    return {\n      'JSXExpressionContainer > LogicalExpression[operator=\"&&\"]'(node) {\n        const leftSide = node.left;\n\n        const isCoerceValidLeftSide = COERCE_VALID_LEFT_SIDE_EXPRESSIONS\n          .some((validExpression) => validExpression === leftSide.type);\n        if (validStrategies.has(COERCE_STRATEGY)) {\n          if (isCoerceValidLeftSide || getIsCoerceValidNestedLogicalExpression(leftSide)) {\n            return;\n          }\n        }\n\n        report(context, messages.noPotentialLeakedRender, 'noPotentialLeakedRender', {\n          node,\n          fix(fixer) {\n            return ruleFixer(context, fixStrategy, fixer, node, leftSide, node.right);\n          },\n        });\n      },\n\n      'JSXExpressionContainer > ConditionalExpression'(node) {\n        if (validStrategies.has(TERNARY_STRATEGY)) {\n          return;\n        }\n\n        const isValidTernaryAlternate = TERNARY_INVALID_ALTERNATE_VALUES.indexOf(node.alternate.value) === -1;\n        const isJSXElementAlternate = node.alternate.type === 'JSXElement';\n        if (isValidTernaryAlternate || isJSXElementAlternate) {\n          return;\n        }\n\n        report(context, messages.noPotentialLeakedRender, 'noPotentialLeakedRender', {\n          node,\n          fix(fixer) {\n            return ruleFixer(context, fixStrategy, fixer, node, node.test, node.consequent);\n          },\n        });\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}