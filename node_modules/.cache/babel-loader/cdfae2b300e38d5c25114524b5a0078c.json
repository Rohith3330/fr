{"ast":null,"code":"import { encode, decode } from '@jridgewell/sourcemap-codec';\nimport resolveUri from '@jridgewell/resolve-uri';\n\nfunction resolve(input, base) {\n  // The base is always treated as a directory, if it's not empty.\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n  if (base && !base.endsWith('/')) base += '/';\n  return resolveUri(input, base);\n}\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\n\n\nfunction stripFilename(path) {\n  if (!path) return '';\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst REV_GENERATED_LINE = 1;\nconst REV_GENERATED_COLUMN = 2;\n\nfunction maybeSort(mappings, owned) {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings; // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n  // not, we do not want to modify the consumer's input array.\n\n  if (!owned) mappings = mappings.slice();\n\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n\n  return mappings;\n}\n\nfunction nextUnsortedSegmentLine(mappings, start) {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n\n  return mappings.length;\n}\n\nfunction isSorted(line) {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction sortSegments(line, owned) {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\n\nfunction sortComparator(a, b) {\n  return a[COLUMN] - b[COLUMN];\n}\n\nlet found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\n\nfunction binarySearch(haystack, needle, low, high) {\n  while (low <= high) {\n    const mid = low + (high - low >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  found = false;\n  return low - 1;\n}\n\nfunction upperBound(haystack, needle, index) {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n\n  return index;\n}\n\nfunction lowerBound(haystack, needle, index) {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n\n  return index;\n}\n\nfunction memoizedState() {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1\n  };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\n\n\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n  const {\n    lastKey,\n    lastNeedle,\n    lastIndex\n  } = state;\n  let low = 0;\n  let high = haystack.length - 1;\n\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n\n    if (needle >= lastNeedle) {\n      // lastIndex may be -1 if the previous needle was not found.\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n\n  state.lastKey = key;\n  state.lastNeedle = needle;\n  return state.lastIndex = binarySearch(haystack, needle, low, high);\n} // Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\n\n\nfunction buildBySources(decoded, memos) {\n  const sources = memos.map(buildNullArray);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n      const sourceIndex = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const originalSource = sources[sourceIndex];\n      const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);\n      const memo = memos[sourceIndex]; // The binary search either found a match, or it found the left-index just before where the\n      // segment should go. Either way, we want to insert after that. And there may be multiple\n      // generated segments associated with an original location, so there may need to move several\n      // indexes before we find where we need to insert.\n\n      const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n      insert(originalLine, memo.lastIndex = index + 1, [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n\n  return sources;\n}\n\nfunction insert(array, index, value) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n\n  array[index] = value;\n} // Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\n\n\nfunction buildNullArray() {\n  return {\n    __proto__: null\n  };\n}\n\nconst AnyMap = function (map, mapUrl) {\n  const parsed = typeof map === 'string' ? JSON.parse(map) : map;\n  if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\n  const mappings = [];\n  const sources = [];\n  const sourcesContent = [];\n  const names = [];\n  recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n  const joined = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings\n  };\n  return presortedDecodedMap(joined);\n};\n\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n  const {\n    sections\n  } = input;\n\n  for (let i = 0; i < sections.length; i++) {\n    const {\n      map,\n      offset\n    } = sections[i];\n    let sl = stopLine;\n    let sc = stopColumn;\n\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n\n    addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n  }\n}\n\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n  if ('sections' in input) return recurse(...arguments);\n  const map = new TraceMap(input, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const {\n    resolvedSources,\n    sourcesContent: contents\n  } = map;\n  append(sources, resolvedSources);\n  append(names, map.names);\n  if (contents) append(sourcesContent, contents);else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i; // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\n    // still need to check that we don't overstep lines, too.\n\n    if (lineI > stopLine) return; // The out line may already exist in mappings (if we're continuing the line started by a\n    // previous section). Or, we may have jumped ahead several lines to start this section.\n\n    const out = getLine(mappings, lineI); // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n    // map can be multiple lines), it doesn't.\n\n    const cOffset = i === 0 ? columnOffset : 0;\n    const line = decoded[i];\n\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN]; // If this segment steps into the column range that the next section's map controls, we need\n      // to stop early.\n\n      if (lineI === stopLine && column >= stopColumn) return;\n\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n    }\n  }\n}\n\nfunction append(arr, other) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\n\nfunction getLine(arr, index) {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n\n  return arr[index];\n}\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\nconst LEAST_UPPER_BOUND = -1;\nconst GREATEST_LOWER_BOUND = 1;\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\n\nlet encodedMappings;\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\n\nlet decodedMappings;\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\n\nlet traceSegment;\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\n\nlet originalPositionFor;\n/**\n * Finds the source/line/column directly after the mapping returned by originalPositionFor, provided\n * the found mapping is from the same source and line as the originalPositionFor mapping.\n *\n * Eg, in the code `let id = 1`, `originalPositionAfter` could find the mapping associated with `1`\n * using the same needle that would return `id` when calling `originalPositionFor`.\n */\n\nlet generatedPositionFor;\n/**\n * Iterates each mapping in generated position order.\n */\n\nlet eachMapping;\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\n\nlet sourceContentFor;\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\n\nlet presortedDecodedMap;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\n\nlet decodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\n\nlet encodedMap;\n\nclass TraceMap {\n  constructor(map, mapUrl) {\n    const isString = typeof map === 'string';\n    if (!isString && map._decodedMemo) return map;\n    const parsed = isString ? JSON.parse(map) : map;\n    const {\n      version,\n      file,\n      names,\n      sourceRoot,\n      sources,\n      sourcesContent\n    } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names;\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n    this.resolvedSources = sources.map(s => resolve(s || '', from));\n    const {\n      mappings\n    } = parsed;\n\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    }\n\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n  }\n\n}\n\n(() => {\n  encodedMappings = map => {\n    var _a;\n\n    return (_a = map._encoded) !== null && _a !== void 0 ? _a : map._encoded = encode(map._decoded);\n  };\n\n  decodedMappings = map => {\n    return map._decoded || (map._decoded = decode(map._encoded));\n  };\n\n  traceSegment = (map, line, column) => {\n    const decoded = decodedMappings(map); // It's common for parent source maps to have pointers to lines that have no\n    // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n\n    if (line >= decoded.length) return null;\n    return traceSegmentInternal(decoded[line], map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n  };\n\n  originalPositionFor = (map, _ref) => {\n    let {\n      line,\n      column,\n      bias\n    } = _ref;\n    line--;\n    if (line < 0) throw new Error(LINE_GTR_ZERO);\n    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n    const decoded = decodedMappings(map); // It's common for parent source maps to have pointers to lines that have no\n    // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n\n    if (line >= decoded.length) return OMapping(null, null, null, null);\n    const segment = traceSegmentInternal(decoded[line], map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n    if (segment == null) return OMapping(null, null, null, null);\n    if (segment.length == 1) return OMapping(null, null, null, null);\n    const {\n      names,\n      resolvedSources\n    } = map;\n    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n  };\n\n  generatedPositionFor = (map, _ref2) => {\n    let {\n      source,\n      line,\n      column,\n      bias\n    } = _ref2;\n    line--;\n    if (line < 0) throw new Error(LINE_GTR_ZERO);\n    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n    const {\n      sources,\n      resolvedSources\n    } = map;\n    let sourceIndex = sources.indexOf(source);\n    if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n    if (sourceIndex === -1) return GMapping(null, null);\n    const generated = map._bySources || (map._bySources = buildBySources(decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));\n    const memos = map._bySourceMemos;\n    const segments = generated[sourceIndex][line];\n    if (segments == null) return GMapping(null, null);\n    const segment = traceSegmentInternal(segments, memos[sourceIndex], line, column, bias || GREATEST_LOWER_BOUND);\n    if (segment == null) return GMapping(null, null);\n    return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n  };\n\n  eachMapping = (map, cb) => {\n    const decoded = decodedMappings(map);\n    const {\n      names,\n      resolvedSources\n    } = map;\n\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        const generatedLine = i + 1;\n        const generatedColumn = seg[0];\n        let source = null;\n        let originalLine = null;\n        let originalColumn = null;\n        let name = null;\n\n        if (seg.length !== 1) {\n          source = resolvedSources[seg[1]];\n          originalLine = seg[2] + 1;\n          originalColumn = seg[3];\n        }\n\n        if (seg.length === 5) name = names[seg[4]];\n        cb({\n          generatedLine,\n          generatedColumn,\n          source,\n          originalLine,\n          originalColumn,\n          name\n        });\n      }\n    }\n  };\n\n  sourceContentFor = (map, source) => {\n    const {\n      sources,\n      resolvedSources,\n      sourcesContent\n    } = map;\n    if (sourcesContent == null) return null;\n    let index = sources.indexOf(source);\n    if (index === -1) index = resolvedSources.indexOf(source);\n    return index === -1 ? null : sourcesContent[index];\n  };\n\n  presortedDecodedMap = (map, mapUrl) => {\n    const tracer = new TraceMap(clone(map, []), mapUrl);\n    tracer._decoded = map.mappings;\n    return tracer;\n  };\n\n  decodedMap = map => {\n    return clone(map, decodedMappings(map));\n  };\n\n  encodedMap = map => {\n    return clone(map, encodedMappings(map));\n  };\n})();\n\nfunction clone(map, mappings) {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings\n  };\n}\n\nfunction OMapping(source, line, column, name) {\n  return {\n    source,\n    line,\n    column,\n    name\n  };\n}\n\nfunction GMapping(line, column) {\n  return {\n    line,\n    column\n  };\n}\n\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n\n  if (found) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n\n  if (index === -1 || index === segments.length) return null;\n  return segments[index];\n}\n\nexport { AnyMap, GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap, decodedMap, decodedMappings, eachMapping, encodedMap, encodedMappings, generatedPositionFor, originalPositionFor, presortedDecodedMap, sourceContentFor, traceSegment };","map":{"version":3,"mappings":"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","names":["resolve","input","base","endsWith","resolveUri","path","index","lastIndexOf","slice","COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","REV_GENERATED_LINE","REV_GENERATED_COLUMN","maybeSort","mappings","owned","unsortedIndex","nextUnsortedSegmentLine","length","i","sortSegments","start","isSorted","line","j","sort","sortComparator","a","b","found","binarySearch","haystack","needle","low","high","mid","cmp","upperBound","lowerBound","memoizedState","lastKey","lastNeedle","lastIndex","memoizedBinarySearch","state","key","buildBySources","decoded","memos","sources","map","buildNullArray","seg","sourceIndex","sourceLine","sourceColumn","originalSource","originalLine","memo","insert","array","value","__proto__","mapUrl","parsed","JSON","parse","TraceMap","sourcesContent","names","recurse","Infinity","joined","version","file","presortedDecodedMap","lineOffset","columnOffset","stopLine","stopColumn","sections","offset","sl","sc","nextOffset","Math","min","column","addSection","arguments","sourcesOffset","namesOffset","decodedMappings","resolvedSources","contents","append","push","lineI","out","getLine","cOffset","sourcesIndex","arr","other","LINE_GTR_ZERO","COL_GTR_EQ_ZERO","GREATEST_LOWER_BOUND","constructor","isString","_decodedMemo","sourceRoot","from","stripFilename","s","_encoded","_decoded","undefined","_bySources","_bySourceMemos","encodedMappings","_a","encode","decode","traceSegment","traceSegmentInternal","originalPositionFor","bias","Error","OMapping","segment","generatedPositionFor","source","indexOf","GMapping","generated","segments","eachMapping","cb","generatedLine","generatedColumn","originalColumn","name","sourceContentFor","tracer","clone","decodedMap","encodedMap","bsFound","LEAST_UPPER_BOUND"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\resolve.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\strip-filename.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\sourcemap-segment.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\sort.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\binary-search.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\by-source.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\any-map.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@jridgewell\\trace-mapping\\src\\trace-mapping.ts"],"sourcesContent":["import resolveUri from '@jridgewell/resolve-uri';\n\nexport default function resolve(input: string, base: string | undefined): string {\n  // The base is always treated as a directory, if it's not empty.\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n  if (base && !base.endsWith('/')) base += '/';\n\n  return resolveUri(input, base);\n}\n","/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nexport default function stripFilename(path: string | undefined | null): string {\n  if (!path) return '';\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n","type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\ntype GeneratedLine = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n\nexport const REV_GENERATED_LINE = 1;\nexport const REV_GENERATED_COLUMN = 2;\n","import { COLUMN } from './sourcemap-segment';\n\nimport type { SourceMapSegment } from './sourcemap-segment';\n\nexport default function maybeSort(\n  mappings: SourceMapSegment[][],\n  owned: boolean,\n): SourceMapSegment[][] {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n  // not, we do not want to modify the consumer's input array.\n  if (!owned) mappings = mappings.slice();\n\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\n\nfunction nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\n\nfunction isSorted(line: SourceMapSegment[]): boolean {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[COLUMN] - b[COLUMN];\n}\n","import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport { COLUMN } from './sourcemap-segment';\n\nexport type MemoState = {\n  lastKey: number;\n  lastNeedle: number;\n  lastIndex: number;\n};\n\nexport let found = false;\n\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nexport function binarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  low: number,\n  high: number,\n): number {\n  while (low <= high) {\n    const mid = low + ((high - low) >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  found = false;\n  return low - 1;\n}\n\nexport function upperBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function lowerBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function memoizedState(): MemoState {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1,\n  };\n}\n\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nexport function memoizedBinarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  state: MemoState,\n  key: number,\n): number {\n  const { lastKey, lastNeedle, lastIndex } = state;\n\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n\n    if (needle >= lastNeedle) {\n      // lastIndex may be -1 if the previous needle was not found.\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n\n  return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n","import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';\nimport { memoizedBinarySearch, upperBound } from './binary-search';\n\nimport type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\nimport type { MemoState } from './binary-search';\n\nexport type Source = {\n  __proto__: null;\n  [line: number]: Exclude<ReverseSegment, [number]>[];\n};\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nexport default function buildBySources(\n  decoded: readonly SourceMapSegment[][],\n  memos: MemoState[],\n): Source[] {\n  const sources: Source[] = memos.map(buildNullArray);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n\n      const sourceIndex = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const originalSource = sources[sourceIndex];\n      const originalLine = (originalSource[sourceLine] ||= []);\n      const memo = memos[sourceIndex];\n\n      // The binary search either found a match, or it found the left-index just before where the\n      // segment should go. Either way, we want to insert after that. And there may be multiple\n      // generated segments associated with an original location, so there may need to move several\n      // indexes before we find where we need to insert.\n      const index = upperBound(\n        originalLine,\n        sourceColumn,\n        memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine),\n      );\n\n      insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n\n  return sources;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray<T extends { __proto__: null }>(): T {\n  return { __proto__: null } as T;\n}\n","import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type {\n  Section,\n  SectionedSourceMap,\n  DecodedSourceMap,\n  SectionedSourceMapInput,\n} from './types';\nimport type { SourceMapSegment } from './sourcemap-segment';\n\ntype AnyMap = {\n  new (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n  (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n};\n\nexport const AnyMap: AnyMap = function (map, mapUrl) {\n  const parsed =\n    typeof map === 'string' ? (JSON.parse(map) as Exclude<SectionedSourceMapInput, string>) : map;\n\n  if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\n\n  const mappings: SourceMapSegment[][] = [];\n  const sources: string[] = [];\n  const sourcesContent: (string | null)[] = [];\n  const names: string[] = [];\n\n  recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n\n  const joined: DecodedSourceMap = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n  };\n\n  return presortedDecodedMap(joined);\n} as AnyMap;\n\nfunction recurse(\n  input: SectionedSourceMap,\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const { sections } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const { map, offset } = sections[i];\n\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n\n    addSection(\n      map,\n      mapUrl,\n      mappings,\n      sources,\n      sourcesContent,\n      names,\n      lineOffset + offset.line,\n      columnOffset + offset.column,\n      sl,\n      sc,\n    );\n  }\n}\n\nfunction addSection(\n  input: Section['map'],\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  if ('sections' in input) return recurse(...(arguments as unknown as Parameters<typeof recurse>));\n\n  const map = new TraceMap(input, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const { resolvedSources, sourcesContent: contents } = map;\n\n  append(sources, resolvedSources);\n  append(names, map.names);\n  if (contents) append(sourcesContent, contents);\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\n    // still need to check that we don't overstep lines, too.\n    if (lineI > stopLine) return;\n\n    // The out line may already exist in mappings (if we're continuing the line started by a\n    // previous section). Or, we may have jumped ahead several lines to start this section.\n    const out = getLine(mappings, lineI);\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n    // map can be multiple lines), it doesn't.\n    const cOffset = i === 0 ? columnOffset : 0;\n\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n\n      // If this segment steps into the column range that the next section's map controls, we need\n      // to stop early.\n      if (lineI === stopLine && column >= stopColumn) return;\n\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(\n        seg.length === 4\n          ? [column, sourcesIndex, sourceLine, sourceColumn]\n          : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],\n      );\n    }\n  }\n}\n\nfunction append<T>(arr: T[], other: T[]) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\n\nfunction getLine<T>(arr: T[][], index: number): T[] {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n","import { encode, decode } from '@jridgewell/sourcemap-codec';\n\nimport resolve from './resolve';\nimport stripFilename from './strip-filename';\nimport maybeSort from './sort';\nimport buildBySources from './by-source';\nimport {\n  memoizedState,\n  memoizedBinarySearch,\n  upperBound,\n  lowerBound,\n  found as bsFound,\n} from './binary-search';\nimport {\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n  REV_GENERATED_LINE,\n  REV_GENERATED_COLUMN,\n} from './sourcemap-segment';\n\nimport type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport type {\n  SourceMapV3,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  InvalidOriginalMapping,\n  OriginalMapping,\n  InvalidGeneratedMapping,\n  GeneratedMapping,\n  SourceMapInput,\n  Needle,\n  SourceNeedle,\n  SourceMap,\n  EachMapping,\n} from './types';\nimport type { Source } from './by-source';\nimport type { MemoState } from './binary-search';\n\nexport type { SourceMapSegment } from './sourcemap-segment';\nexport type {\n  SourceMapInput,\n  SectionedSourceMapInput,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  SectionedSourceMap,\n  InvalidOriginalMapping,\n  OriginalMapping as Mapping,\n  OriginalMapping,\n  InvalidGeneratedMapping,\n  GeneratedMapping,\n  EachMapping,\n} from './types';\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n\nexport const LEAST_UPPER_BOUND = -1;\nexport const GREATEST_LOWER_BOUND = 1;\n\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nexport let encodedMappings: (map: TraceMap) => EncodedSourceMap['mappings'];\n\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nexport let decodedMappings: (map: TraceMap) => Readonly<DecodedSourceMap['mappings']>;\n\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nexport let traceSegment: (\n  map: TraceMap,\n  line: number,\n  column: number,\n) => Readonly<SourceMapSegment> | null;\n\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nexport let originalPositionFor: (\n  map: TraceMap,\n  needle: Needle,\n) => OriginalMapping | InvalidOriginalMapping;\n\n/**\n * Finds the source/line/column directly after the mapping returned by originalPositionFor, provided\n * the found mapping is from the same source and line as the originalPositionFor mapping.\n *\n * Eg, in the code `let id = 1`, `originalPositionAfter` could find the mapping associated with `1`\n * using the same needle that would return `id` when calling `originalPositionFor`.\n */\nexport let generatedPositionFor: (\n  map: TraceMap,\n  needle: SourceNeedle,\n) => GeneratedMapping | InvalidGeneratedMapping;\n\n/**\n * Iterates each mapping in generated position order.\n */\nexport let eachMapping: (map: TraceMap, cb: (mapping: EachMapping) => void) => void;\n\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nexport let sourceContentFor: (map: TraceMap, source: string) => string | null;\n\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nexport let presortedDecodedMap: (map: DecodedSourceMap, mapUrl?: string) => TraceMap;\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let decodedMap: (\n  map: TraceMap,\n) => Omit<DecodedSourceMap, 'mappings'> & { mappings: readonly SourceMapSegment[][] };\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let encodedMap: (map: TraceMap) => EncodedSourceMap;\n\nexport { AnyMap } from './any-map';\n\nexport class TraceMap implements SourceMap {\n  declare version: SourceMapV3['version'];\n  declare file: SourceMapV3['file'];\n  declare names: SourceMapV3['names'];\n  declare sourceRoot: SourceMapV3['sourceRoot'];\n  declare sources: SourceMapV3['sources'];\n  declare sourcesContent: SourceMapV3['sourcesContent'];\n\n  declare resolvedSources: string[];\n  private declare _encoded: string | undefined;\n\n  private declare _decoded: SourceMapSegment[][] | undefined;\n  private declare _decodedMemo: MemoState;\n\n  private declare _bySources: Source[] | undefined;\n  private declare _bySourceMemos: MemoState[] | undefined;\n\n  constructor(map: SourceMapInput, mapUrl?: string | null) {\n    const isString = typeof map === 'string';\n\n    if (!isString && (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;\n\n    const parsed = (isString ? JSON.parse(map) : map) as Exclude<SourceMapInput, string | TraceMap>;\n\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names;\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n\n    const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n    this.resolvedSources = sources.map((s) => resolve(s || '', from));\n\n    const { mappings } = parsed;\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    }\n\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n  }\n\n  static {\n    encodedMappings = (map) => {\n      return (map._encoded ??= encode(map._decoded!));\n    };\n\n    decodedMappings = (map) => {\n      return (map._decoded ||= decode(map._encoded!));\n    };\n\n    traceSegment = (map, line, column) => {\n      const decoded = decodedMappings(map);\n\n      // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n      if (line >= decoded.length) return null;\n\n      return traceSegmentInternal(\n        decoded[line],\n        map._decodedMemo,\n        line,\n        column,\n        GREATEST_LOWER_BOUND,\n      );\n    };\n\n    originalPositionFor = (map, { line, column, bias }) => {\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n      const decoded = decodedMappings(map);\n\n      // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n      if (line >= decoded.length) return OMapping(null, null, null, null);\n\n      const segment = traceSegmentInternal(\n        decoded[line],\n        map._decodedMemo,\n        line,\n        column,\n        bias || GREATEST_LOWER_BOUND,\n      );\n\n      if (segment == null) return OMapping(null, null, null, null);\n      if (segment.length == 1) return OMapping(null, null, null, null);\n\n      const { names, resolvedSources } = map;\n      return OMapping(\n        resolvedSources[segment[SOURCES_INDEX]],\n        segment[SOURCE_LINE] + 1,\n        segment[SOURCE_COLUMN],\n        segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\n      );\n    };\n\n    generatedPositionFor = (map, { source, line, column, bias }) => {\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n      const { sources, resolvedSources } = map;\n      let sourceIndex = sources.indexOf(source);\n      if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n      if (sourceIndex === -1) return GMapping(null, null);\n\n      const generated = (map._bySources ||= buildBySources(\n        decodedMappings(map),\n        (map._bySourceMemos = sources.map(memoizedState)),\n      ));\n      const memos = map._bySourceMemos!;\n\n      const segments = generated[sourceIndex][line];\n\n      if (segments == null) return GMapping(null, null);\n\n      const segment = traceSegmentInternal(\n        segments,\n        memos[sourceIndex],\n        line,\n        column,\n        bias || GREATEST_LOWER_BOUND,\n      );\n\n      if (segment == null) return GMapping(null, null);\n      return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n    };\n\n    eachMapping = (map, cb) => {\n      const decoded = decodedMappings(map);\n      const { names, resolvedSources } = map;\n\n      for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n\n          const generatedLine = i + 1;\n          const generatedColumn = seg[0];\n          let source = null;\n          let originalLine = null;\n          let originalColumn = null;\n          let name = null;\n          if (seg.length !== 1) {\n            source = resolvedSources[seg[1]];\n            originalLine = seg[2] + 1;\n            originalColumn = seg[3];\n          }\n          if (seg.length === 5) name = names[seg[4]];\n\n          cb({\n            generatedLine,\n            generatedColumn,\n            source,\n            originalLine,\n            originalColumn,\n            name,\n          } as EachMapping);\n        }\n      }\n    };\n\n    sourceContentFor = (map, source) => {\n      const { sources, resolvedSources, sourcesContent } = map;\n      if (sourcesContent == null) return null;\n\n      let index = sources.indexOf(source);\n      if (index === -1) index = resolvedSources.indexOf(source);\n\n      return index === -1 ? null : sourcesContent[index];\n    };\n\n    presortedDecodedMap = (map, mapUrl) => {\n      const tracer = new TraceMap(clone(map, []), mapUrl);\n      tracer._decoded = map.mappings;\n      return tracer;\n    };\n\n    decodedMap = (map) => {\n      return clone(map, decodedMappings(map));\n    };\n\n    encodedMap = (map) => {\n      return clone(map, encodedMappings(map));\n    };\n  }\n}\n\nfunction clone<T extends string | readonly SourceMapSegment[][]>(\n  map: TraceMap | DecodedSourceMap | EncodedSourceMap,\n  mappings: T,\n): T extends string ? EncodedSourceMap : DecodedSourceMap {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n  } as any;\n}\n\nfunction OMapping(\n  source: null,\n  line: null,\n  column: null,\n  name: null,\n): OriginalMapping | InvalidOriginalMapping;\nfunction OMapping(\n  source: string,\n  line: number,\n  column: number,\n  name: string | null,\n): OriginalMapping | InvalidOriginalMapping;\nfunction OMapping(\n  source: string | null,\n  line: number | null,\n  column: number | null,\n  name: string | null,\n): OriginalMapping | InvalidOriginalMapping {\n  return { source, line, column, name } as any;\n}\n\nfunction GMapping(line: null, column: null): GeneratedMapping | InvalidGeneratedMapping;\nfunction GMapping(line: number, column: number): GeneratedMapping | InvalidGeneratedMapping;\nfunction GMapping(\n  line: number | null,\n  column: number | null,\n): GeneratedMapping | InvalidGeneratedMapping {\n  return { line, column } as any;\n}\n\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: typeof LEAST_UPPER_BOUND | typeof GREATEST_LOWER_BOUND,\n): Readonly<SourceMapSegment> | null;\nfunction traceSegmentInternal(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: typeof LEAST_UPPER_BOUND | typeof GREATEST_LOWER_BOUND,\n): Readonly<ReverseSegment> | null;\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[] | ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: typeof LEAST_UPPER_BOUND | typeof GREATEST_LOWER_BOUND,\n): Readonly<SourceMapSegment | ReverseSegment> | null {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (bsFound) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n\n  if (index === -1 || index === segments.length) return null;\n  return segments[index];\n}\n"]},"metadata":{},"sourceType":"module"}