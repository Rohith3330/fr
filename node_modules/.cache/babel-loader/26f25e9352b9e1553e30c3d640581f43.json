{"ast":null,"code":"/**\n * @fileoverview Main class using flat config\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n// Note: Node.js 12 does not support fs/promises.\n\nconst fs = require(\"fs\").promises;\n\nconst path = require(\"path\");\n\nconst findUp = require(\"find-up\");\n\nconst {\n  version\n} = require(\"../../package.json\");\n\nconst {\n  Linter\n} = require(\"../linter\");\n\nconst {\n  getRuleFromConfig\n} = require(\"../config/flat-config-helpers\");\n\nconst {\n  gitignoreToMinimatch\n} = require(\"@humanwhocodes/gitignore-to-minimatch\");\n\nconst {\n  Legacy: {\n    ConfigOps: {\n      getRuleSeverity\n    },\n    ModuleResolver,\n    naming\n  }\n} = require(\"@eslint/eslintrc\");\n\nconst {\n  fileExists,\n  findFiles,\n  getCacheFile,\n  isNonEmptyString,\n  isArrayOfNonEmptyString,\n  createIgnoreResult,\n  isErrorMessage,\n  processOptions\n} = require(\"./eslint-helpers\");\n\nconst {\n  pathToFileURL\n} = require(\"url\");\n\nconst {\n  FlatConfigArray\n} = require(\"../config/flat-config-array\");\n\nconst LintResultCache = require(\"../cli-engine/lint-result-cache\");\n/*\n * This is necessary to allow overwriting writeFile for testing purposes.\n * We can just use fs/promises once we drop Node.js 12 support.\n */\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n// For VSCode IntelliSense\n\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n\n/** @typedef {import(\"../shared/types\").RuleConf} RuleConf */\n\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n/** @typedef {ReturnType<ConfigArray.extractConfig>} ExtractedConfig */\n\n/**\n * The options with which to configure the ESLint instance.\n * @typedef {Object} FlatESLintOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {\"metadata\" | \"content\"} [cacheStrategy] The strategy used to detect changed files.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn't throw even if no target files found. Defaults to `true`.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] False disables use of .eslintignore.\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\n * @property {string[]} [ignorePatterns] Ignore file patterns to use in addition to .eslintignore.\n * @property {ConfigData} [overrideConfig] Override config object, overrides all configs used with this instance\n * @property {boolean|string} [overrideConfigFile] Searches for default config file when falsy;\n *      doesn't do any config file lookup when `true`; considered to be a config filename\n *      when a string.\n * @property {Record<string,Plugin>} [plugins] An array of plugin implementations.\n * @property {\"error\" | \"warn\" | \"off\"} [reportUnusedDisableDirectives] the severity to report unused eslint-disable directives.\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst FLAT_CONFIG_FILENAME = \"eslint.config.js\";\n\nconst debug = require(\"debug\")(\"eslint:flat-eslint\");\n\nconst removedFormatters = new Set([\"table\", \"codeframe\"]);\nconst privateMembers = new WeakMap();\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {LintMessage[]} messages Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\n\nfunction calculateStatsPerFile(messages) {\n  return messages.reduce((stat, message) => {\n    if (message.fatal || message.severity === 2) {\n      stat.errorCount++;\n\n      if (message.fatal) {\n        stat.fatalErrorCount++;\n      }\n\n      if (message.fix) {\n        stat.fixableErrorCount++;\n      }\n    } else {\n      stat.warningCount++;\n\n      if (message.fix) {\n        stat.fixableWarningCount++;\n      }\n    }\n\n    return stat;\n  }, {\n    errorCount: 0,\n    fatalErrorCount: 0,\n    warningCount: 0,\n    fixableErrorCount: 0,\n    fixableWarningCount: 0\n  });\n}\n/**\n * It will calculate the error and warning count for collection of results from all files\n * @param {LintResult[]} results Collection of messages from all the files\n * @returns {Object} Contains the stats\n * @private\n */\n\n\nfunction calculateStatsPerRun(results) {\n  return results.reduce((stat, result) => {\n    stat.errorCount += result.errorCount;\n    stat.fatalErrorCount += result.fatalErrorCount;\n    stat.warningCount += result.warningCount;\n    stat.fixableErrorCount += result.fixableErrorCount;\n    stat.fixableWarningCount += result.fixableWarningCount;\n    return stat;\n  }, {\n    errorCount: 0,\n    fatalErrorCount: 0,\n    warningCount: 0,\n    fixableErrorCount: 0,\n    fixableWarningCount: 0\n  });\n}\n/**\n * Loads global ignore patterns from an ignore file (usually .eslintignore).\n * @param {string} filePath The filename to load.\n * @returns {ignore} A function encapsulating the ignore patterns.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nasync function loadIgnoreFilePatterns(filePath) {\n  debug(`Loading ignore file: ${filePath}`);\n\n  try {\n    const ignoreFileText = await fs.readFile(filePath, {\n      encoding: \"utf8\"\n    });\n    return ignoreFileText.split(/\\r?\\n/gu).filter(line => line.trim() !== \"\" && !line.startsWith(\"#\"));\n  } catch (e) {\n    debug(`Error reading ignore file: ${filePath}`);\n    e.message = `Cannot read ignore file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Create rulesMeta object.\n * @param {Map<string,Rule>} rules a map of rules from which to generate the object.\n * @returns {Object} metadata for all enabled rules.\n */\n\n\nfunction createRulesMeta(rules) {\n  return Array.from(rules).reduce((retVal, _ref) => {\n    let [id, rule] = _ref;\n    retVal[id] = rule.meta;\n    return retVal;\n  }, {});\n}\n/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>} */\n\n\nconst usedDeprecatedRulesCache = new WeakMap();\n/**\n * Create used deprecated rule list.\n * @param {CLIEngine} eslint The CLIEngine instance.\n * @param {string} maybeFilePath The absolute path to a lint target file or `\"<text>\"`.\n * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.\n */\n\nfunction getOrFindUsedDeprecatedRules(eslint, maybeFilePath) {\n  const {\n    configs,\n    options: {\n      cwd\n    }\n  } = privateMembers.get(eslint);\n  const filePath = path.isAbsolute(maybeFilePath) ? maybeFilePath : path.join(cwd, \"__placeholder__.js\");\n  const config = configs.getConfig(filePath); // Most files use the same config, so cache it.\n\n  if (config && !usedDeprecatedRulesCache.has(config)) {\n    const retv = [];\n\n    if (config.rules) {\n      for (const [ruleId, ruleConf] of Object.entries(config.rules)) {\n        if (getRuleSeverity(ruleConf) === 0) {\n          continue;\n        }\n\n        const rule = getRuleFromConfig(ruleId, config);\n        const meta = rule && rule.meta;\n\n        if (meta && meta.deprecated) {\n          retv.push({\n            ruleId,\n            replacedBy: meta.replacedBy || []\n          });\n        }\n      }\n    }\n\n    usedDeprecatedRulesCache.set(config, Object.freeze(retv));\n  }\n\n  return config ? usedDeprecatedRulesCache.get(config) : Object.freeze([]);\n}\n/**\n * Processes the linting results generated by a CLIEngine linting report to\n * match the ESLint class's API.\n * @param {CLIEngine} eslint The CLIEngine instance.\n * @param {CLIEngineLintReport} report The CLIEngine linting report to process.\n * @returns {LintResult[]} The processed linting results.\n */\n\n\nfunction processLintReport(eslint, _ref2) {\n  let {\n    results\n  } = _ref2;\n  const descriptor = {\n    configurable: true,\n    enumerable: true,\n\n    get() {\n      return getOrFindUsedDeprecatedRules(eslint, this.filePath);\n    }\n\n  };\n\n  for (const result of results) {\n    Object.defineProperty(result, \"usedDeprecatedRules\", descriptor);\n  }\n\n  return results;\n}\n/**\n * An Array.prototype.sort() compatible compare function to order results by their file path.\n * @param {LintResult} a The first lint result.\n * @param {LintResult} b The second lint result.\n * @returns {number} An integer representing the order in which the two results should occur.\n */\n\n\nfunction compareResultsByFilePath(a, b) {\n  if (a.filePath < b.filePath) {\n    return -1;\n  }\n\n  if (a.filePath > b.filePath) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\n * Searches from the current working directory up until finding the\n * given flat config filename.\n * @param {string} cwd The current working directory to search from.\n * @returns {Promise<string|null>} The filename if found or `null` if not.\n */\n\n\nfunction findFlatConfigFile(cwd) {\n  return findUp(FLAT_CONFIG_FILENAME, {\n    cwd\n  });\n}\n/**\n * Load the config array from the given filename.\n * @param {string} filePath The filename to load from.\n * @param {Object} options Options to help load the config file.\n * @param {string} options.basePath The base path for the config array.\n * @param {boolean} options.shouldIgnore Whether to honor ignore patterns.\n * @returns {Promise<FlatConfigArray>} The config array loaded from the config file.\n */\n\n\nasync function loadFlatConfigFile(filePath, _ref3) {\n  let {\n    basePath,\n    shouldIgnore\n  } = _ref3;\n  debug(`Loading config from ${filePath}`);\n  const fileURL = pathToFileURL(filePath);\n  debug(`Config file URL is ${fileURL}`);\n  const module = await import(fileURL);\n  return new FlatConfigArray(module.default, {\n    basePath,\n    shouldIgnore\n  });\n}\n/**\n * Calculates the config array for this run based on inputs.\n * @param {FlatESLint} eslint The instance to create the config array for.\n * @param {import(\"./eslint\").ESLintOptions} options The ESLint instance options.\n * @returns {FlatConfigArray} The config array for `eslint``.\n */\n\n\nasync function calculateConfigArray(eslint, _ref4) {\n  let {\n    cwd,\n    overrideConfig,\n    configFile,\n    ignore: shouldIgnore,\n    ignorePath,\n    ignorePatterns\n  } = _ref4;\n  // check for cached instance\n  const slots = privateMembers.get(eslint);\n\n  if (slots.configs) {\n    return slots.configs;\n  } // determine where to load config file from\n\n\n  let configFilePath;\n  let basePath = cwd;\n\n  if (typeof configFile === \"string\") {\n    debug(`Override config file path is ${configFile}`);\n    configFilePath = path.resolve(cwd, configFile);\n  } else if (configFile !== false) {\n    debug(\"Searching for eslint.config.js\");\n    configFilePath = await findFlatConfigFile(cwd);\n\n    if (!configFilePath) {\n      throw new Error(\"Could not find config file.\");\n    }\n\n    basePath = path.resolve(path.dirname(configFilePath));\n  } // load config array\n\n\n  let configs;\n\n  if (configFilePath) {\n    configs = await loadFlatConfigFile(configFilePath, {\n      basePath,\n      shouldIgnore\n    });\n  } else {\n    configs = new FlatConfigArray([], {\n      basePath,\n      shouldIgnore\n    });\n  } // add in any configured defaults\n\n\n  configs.push(...slots.defaultConfigs);\n  let allIgnorePatterns = [];\n  let ignoreFilePath; // load ignore file if necessary\n\n  if (shouldIgnore) {\n    if (ignorePath) {\n      ignoreFilePath = path.resolve(cwd, ignorePath);\n      allIgnorePatterns = await loadIgnoreFilePatterns(ignoreFilePath);\n    } else {\n      ignoreFilePath = path.resolve(cwd, \".eslintignore\"); // no error if .eslintignore doesn't exist`\n\n      if (fileExists(ignoreFilePath)) {\n        allIgnorePatterns = await loadIgnoreFilePatterns(ignoreFilePath);\n      }\n    }\n  } // append command line ignore patterns\n\n\n  if (ignorePatterns) {\n    if (typeof ignorePatterns === \"string\") {\n      allIgnorePatterns.push(ignorePatterns);\n    } else {\n      allIgnorePatterns.push(...ignorePatterns);\n    }\n  }\n  /*\n   * If the config file basePath is different than the cwd, then\n   * the ignore patterns won't work correctly. Here, we adjust the\n   * ignore pattern to include the correct relative path. Patterns\n   * loaded from ignore files are always relative to the cwd, whereas\n   * the config file basePath can be an ancestor of the cwd.\n   */\n\n\n  if (basePath !== cwd && allIgnorePatterns.length) {\n    const relativeIgnorePath = path.relative(basePath, cwd);\n    allIgnorePatterns = allIgnorePatterns.map(pattern => {\n      const negated = pattern.startsWith(\"!\");\n      const basePattern = negated ? pattern.slice(1) : pattern;\n      /*\n       * Ignore patterns are considered relative to a directory\n       * when the pattern contains a slash in a position other\n       * than the last character. If that's the case, we need to\n       * add the relative ignore path to the current pattern to\n       * get the correct behavior. Otherwise, no change is needed.\n       */\n\n      if (!basePattern.includes(\"/\") || basePattern.endsWith(\"/\")) {\n        return pattern;\n      }\n\n      return (negated ? \"!\" : \"\") + path.posix.join(relativeIgnorePath, basePattern);\n    });\n  }\n\n  if (allIgnorePatterns.length) {\n    /*\n     * Ignore patterns are added to the end of the config array\n     * so they can override default ignores.\n     */\n    configs.push({\n      ignores: allIgnorePatterns.map(gitignoreToMinimatch)\n    });\n  }\n\n  if (overrideConfig) {\n    if (Array.isArray(overrideConfig)) {\n      configs.push(...overrideConfig);\n    } else {\n      configs.push(overrideConfig);\n    }\n  }\n\n  await configs.normalize(); // cache the config array for this instance\n\n  slots.configs = configs;\n  return configs;\n}\n/**\n * Processes an source code using ESLint.\n * @param {Object} config The config object.\n * @param {string} config.text The source code to verify.\n * @param {string} config.cwd The path to the current working directory.\n * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.\n * @param {FlatConfigArray} config.configs The config.\n * @param {boolean} config.fix If `true` then it does fix.\n * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.\n * @param {boolean} config.reportUnusedDisableDirectives If `true` then it reports unused `eslint-disable` comments.\n * @param {Linter} config.linter The linter instance to verify.\n * @returns {LintResult} The result of linting.\n * @private\n */\n\n\nfunction verifyText(_ref5) {\n  let {\n    text,\n    cwd,\n    filePath: providedFilePath,\n    configs,\n    fix,\n    allowInlineConfig,\n    reportUnusedDisableDirectives,\n    linter\n  } = _ref5;\n  const filePath = providedFilePath || \"<text>\";\n  debug(`Lint ${filePath}`);\n  /*\n   * Verify.\n   * `config.extractConfig(filePath)` requires an absolute path, but `linter`\n   * doesn't know CWD, so it gives `linter` an absolute path always.\n   */\n\n  const filePathToVerify = filePath === \"<text>\" ? path.join(cwd, \"__placeholder__.js\") : filePath;\n  const {\n    fixed,\n    messages,\n    output\n  } = linter.verifyAndFix(text, configs, {\n    allowInlineConfig,\n    filename: filePathToVerify,\n    fix,\n    reportUnusedDisableDirectives,\n\n    /**\n     * Check if the linter should adopt a given code block or not.\n     * @param {string} blockFilename The virtual filename of a code block.\n     * @returns {boolean} `true` if the linter should adopt the code block.\n     */\n    filterCodeBlock(blockFilename) {\n      return configs.isExplicitMatch(blockFilename);\n    }\n\n  }); // Tweak and return.\n\n  const result = {\n    filePath: filePath === \"<text>\" ? filePath : path.resolve(filePath),\n    messages,\n    suppressedMessages: linter.getSuppressedMessages(),\n    ...calculateStatsPerFile(messages)\n  };\n\n  if (fixed) {\n    result.output = output;\n  }\n\n  if (result.errorCount + result.warningCount > 0 && typeof result.output === \"undefined\") {\n    result.source = text;\n  }\n\n  return result;\n}\n/**\n * Checks whether a message's rule type should be fixed.\n * @param {LintMessage} message The message to check.\n * @param {FlatConfig} config The config for the file that generated the message.\n * @param {string[]} fixTypes An array of fix types to check.\n * @returns {boolean} Whether the message should be fixed.\n */\n\n\nfunction shouldMessageBeFixed(message, config, fixTypes) {\n  if (!message.ruleId) {\n    return fixTypes.has(\"directive\");\n  }\n\n  const rule = message.ruleId && getRuleFromConfig(message.ruleId, config);\n  return Boolean(rule && rule.meta && fixTypes.has(rule.meta.type));\n}\n/**\n * Collect used deprecated rules.\n * @param {Array<FlatConfig>} configs The configs to evaluate.\n * @returns {IterableIterator<DeprecatedRuleInfo>} Used deprecated rules.\n */\n\n\nfunction* iterateRuleDeprecationWarnings(configs) {\n  const processedRuleIds = new Set();\n\n  for (const config of configs) {\n    for (const [ruleId, ruleConfig] of Object.entries(config.rules)) {\n      // Skip if it was processed.\n      if (processedRuleIds.has(ruleId)) {\n        continue;\n      }\n\n      processedRuleIds.add(ruleId); // Skip if it's not used.\n\n      if (!getRuleSeverity(ruleConfig)) {\n        continue;\n      }\n\n      const rule = getRuleFromConfig(ruleId, config); // Skip if it's not deprecated.\n\n      if (!(rule && rule.meta && rule.meta.deprecated)) {\n        continue;\n      } // This rule was used and deprecated.\n\n\n      yield {\n        ruleId,\n        replacedBy: rule.meta.replacedBy || []\n      };\n    }\n  }\n} //-----------------------------------------------------------------------------\n// Main API\n//-----------------------------------------------------------------------------\n\n/**\n * Primary Node.js API for ESLint.\n */\n\n\nclass FlatESLint {\n  /**\n   * Creates a new instance of the main ESLint API.\n   * @param {FlatESLintOptions} options The options for this instance.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const defaultConfigs = [];\n    const processedOptions = processOptions(options);\n    const linter = new Linter({\n      cwd: processedOptions.cwd,\n      configType: \"flat\"\n    });\n    const cacheFilePath = getCacheFile(processedOptions.cacheLocation, processedOptions.cwd);\n    const lintResultCache = processedOptions.cache ? new LintResultCache(cacheFilePath, processedOptions.cacheStrategy) : null;\n    privateMembers.set(this, {\n      options: processedOptions,\n      linter,\n      cacheFilePath,\n      lintResultCache,\n      defaultConfigs,\n      defaultIgnores: () => false,\n      configs: null\n    });\n    /**\n     * If additional plugins are passed in, add that to the default\n     * configs for this instance.\n     */\n\n    if (options.plugins) {\n      const plugins = {};\n\n      for (const [pluginName, plugin] of Object.entries(options.plugins)) {\n        plugins[naming.getShorthandName(pluginName, \"eslint-plugin\")] = plugin;\n      }\n\n      defaultConfigs.push({\n        plugins\n      });\n    }\n  }\n  /**\n   * The version text.\n   * @type {string}\n   */\n\n\n  static get version() {\n    return version;\n  }\n  /**\n   * Outputs fixes from the given results to files.\n   * @param {LintResult[]} results The lint results.\n   * @returns {Promise<void>} Returns a promise that is used to track side effects.\n   */\n\n\n  static async outputFixes(results) {\n    if (!Array.isArray(results)) {\n      throw new Error(\"'results' must be an array\");\n    }\n\n    await Promise.all(results.filter(result => {\n      if (typeof result !== \"object\" || result === null) {\n        throw new Error(\"'results' must include only objects\");\n      }\n\n      return typeof result.output === \"string\" && path.isAbsolute(result.filePath);\n    }).map(r => fs.writeFile(r.filePath, r.output)));\n  }\n  /**\n   * Returns results that only contains errors.\n   * @param {LintResult[]} results The results to filter.\n   * @returns {LintResult[]} The filtered results.\n   */\n\n\n  static getErrorResults(results) {\n    const filtered = [];\n    results.forEach(result => {\n      const filteredMessages = result.messages.filter(isErrorMessage);\n      const filteredSuppressedMessages = result.suppressedMessages.filter(isErrorMessage);\n\n      if (filteredMessages.length > 0) {\n        filtered.push({ ...result,\n          messages: filteredMessages,\n          suppressedMessages: filteredSuppressedMessages,\n          errorCount: filteredMessages.length,\n          warningCount: 0,\n          fixableErrorCount: result.fixableErrorCount,\n          fixableWarningCount: 0\n        });\n      }\n    });\n    return filtered;\n  }\n  /**\n   * Returns meta objects for each rule represented in the lint results.\n   * @param {LintResult[]} results The results to fetch rules meta for.\n   * @returns {Object} A mapping of ruleIds to rule meta objects.\n   * @throws {TypeError} When the results object wasn't created from this ESLint instance.\n   * @throws {TypeError} When a plugin or rule is missing.\n   */\n\n\n  getRulesMetaForResults(results) {\n    const resultRules = new Map(); // short-circuit simple case\n\n    if (results.length === 0) {\n      return resultRules;\n    }\n\n    const {\n      configs\n    } = privateMembers.get(this);\n    /*\n     * We can only accurately return rules meta information for linting results if the\n     * results were created by this instance. Otherwise, the necessary rules data is\n     * not available. So if the config array doesn't already exist, just throw an error\n     * to let the user know we can't do anything here.\n     */\n\n    if (!configs) {\n      throw new TypeError(\"Results object was not created from this ESLint instance.\");\n    }\n\n    for (const result of results) {\n      /*\n       * Normalize filename for <text>.\n       */\n      const filePath = result.filePath === \"<text>\" ? \"__placeholder__.js\" : result.filePath;\n      /*\n       * All of the plugin and rule information is contained within the\n       * calculated config for the given file.\n       */\n\n      const config = configs.getConfig(filePath);\n      const allMessages = result.messages.concat(result.suppressedMessages);\n\n      for (const {\n        ruleId\n      } of allMessages) {\n        const rule = getRuleFromConfig(ruleId, config); // ensure the rule exists\n\n        if (!rule) {\n          throw new TypeError(`Could not find the rule \"${ruleId}\".`);\n        }\n\n        resultRules.set(ruleId, rule);\n      }\n    }\n\n    return createRulesMeta(resultRules);\n  }\n  /**\n   * Executes the current configuration on an array of file and directory names.\n   * @param {string|string[]} patterns An array of file and directory names.\n   * @returns {Promise<LintResult[]>} The results of linting the file patterns given.\n   */\n\n\n  async lintFiles(patterns) {\n    if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {\n      throw new Error(\"'patterns' must be a non-empty string or an array of non-empty strings\");\n    }\n\n    const {\n      cacheFilePath,\n      lintResultCache,\n      linter,\n      options: eslintOptions\n    } = privateMembers.get(this);\n    const configs = await calculateConfigArray(this, eslintOptions);\n    const {\n      allowInlineConfig,\n      cache,\n      cwd,\n      fix,\n      fixTypes,\n      reportUnusedDisableDirectives,\n      globInputPaths,\n      errorOnUnmatchedPattern\n    } = eslintOptions;\n    const startTime = Date.now();\n    const usedConfigs = [];\n    const fixTypesSet = fixTypes ? new Set(fixTypes) : null; // Delete cache file; should this be done here?\n\n    if (!cache && cacheFilePath) {\n      debug(`Deleting cache file at ${cacheFilePath}`);\n\n      try {\n        await fs.unlink(cacheFilePath);\n      } catch (error) {\n        const errorCode = error && error.code; // Ignore errors when no such file exists or file system is read only (and cache file does not exist)\n\n        if (errorCode !== \"ENOENT\" && !(errorCode === \"EROFS\" && !(await fs.exists(cacheFilePath)))) {\n          throw error;\n        }\n      }\n    }\n\n    const filePaths = await findFiles({\n      patterns: typeof patterns === \"string\" ? [patterns] : patterns,\n      cwd,\n      globInputPaths,\n      configs,\n      errorOnUnmatchedPattern\n    });\n    debug(`${filePaths.length} files found in: ${Date.now() - startTime}ms`);\n    /*\n     * Because we need to process multiple files, including reading from disk,\n     * it is most efficient to start by reading each file via promises so that\n     * they can be done in parallel. Then, we can lint the returned text. This\n     * ensures we are waiting the minimum amount of time in between lints.\n     */\n\n    const results = await Promise.all(filePaths.map(_ref6 => {\n      let {\n        filePath,\n        ignored\n      } = _ref6;\n\n      /*\n       * If a filename was entered that matches an ignore\n       * pattern, then notify the user.\n       */\n      if (ignored) {\n        return createIgnoreResult(filePath, cwd);\n      }\n\n      const config = configs.getConfig(filePath);\n      /*\n       * Sometimes a file found through a glob pattern will\n       * be ignored. In this case, `config` will be undefined\n       * and we just silently ignore the file.\n       */\n\n      if (!config) {\n        return void 0;\n      }\n      /*\n       * Store used configs for:\n       * - this method uses to collect used deprecated rules.\n       * - `--fix-type` option uses to get the loaded rule's meta data.\n       */\n\n\n      if (!usedConfigs.includes(config)) {\n        usedConfigs.push(config);\n      } // Skip if there is cached result.\n\n\n      if (lintResultCache) {\n        const cachedResult = lintResultCache.getCachedLintResults(filePath, config);\n\n        if (cachedResult) {\n          const hadMessages = cachedResult.messages && cachedResult.messages.length > 0;\n\n          if (hadMessages && fix) {\n            debug(`Reprocessing cached file to allow autofix: ${filePath}`);\n          } else {\n            debug(`Skipping file since it hasn't changed: ${filePath}`);\n            return cachedResult;\n          }\n        }\n      } // set up fixer for fixtypes if necessary\n\n\n      let fixer = fix;\n\n      if (fix && fixTypesSet) {\n        // save original value of options.fix in case it's a function\n        const originalFix = typeof fix === \"function\" ? fix : () => true;\n\n        fixer = message => shouldMessageBeFixed(message, config, fixTypesSet) && originalFix(message);\n      }\n\n      return fs.readFile(filePath, \"utf8\").then(text => {\n        // do the linting\n        const result = verifyText({\n          text,\n          filePath,\n          configs,\n          cwd,\n          fix: fixer,\n          allowInlineConfig,\n          reportUnusedDisableDirectives,\n          linter\n        });\n        /*\n         * Store the lint result in the LintResultCache.\n         * NOTE: The LintResultCache will remove the file source and any\n         * other properties that are difficult to serialize, and will\n         * hydrate those properties back in on future lint runs.\n         */\n\n        if (lintResultCache) {\n          lintResultCache.setCachedLintResults(filePath, config, result);\n        }\n\n        return result;\n      });\n    })); // Persist the cache to disk.\n\n    if (lintResultCache) {\n      lintResultCache.reconcile();\n    }\n\n    let usedDeprecatedRules;\n    const finalResults = results.filter(result => !!result);\n    return processLintReport(this, {\n      results: finalResults,\n      ...calculateStatsPerRun(finalResults),\n\n      // Initialize it lazily because CLI and `ESLint` API don't use it.\n      get usedDeprecatedRules() {\n        if (!usedDeprecatedRules) {\n          usedDeprecatedRules = Array.from(iterateRuleDeprecationWarnings(usedConfigs));\n        }\n\n        return usedDeprecatedRules;\n      }\n\n    });\n  }\n  /**\n   * Executes the current configuration on text.\n   * @param {string} code A string of JavaScript code to lint.\n   * @param {Object} [options] The options.\n   * @param {string} [options.filePath] The path to the file of the source code.\n   * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.\n   * @returns {Promise<LintResult[]>} The results of linting the string of code given.\n   */\n\n\n  async lintText(code) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // Parameter validation\n    if (typeof code !== \"string\") {\n      throw new Error(\"'code' must be a string\");\n    }\n\n    if (typeof options !== \"object\") {\n      throw new Error(\"'options' must be an object, null, or undefined\");\n    } // Options validation\n\n\n    const {\n      filePath,\n      warnIgnored = false,\n      ...unknownOptions\n    } = options || {};\n    const unknownOptionKeys = Object.keys(unknownOptions);\n\n    if (unknownOptionKeys.length > 0) {\n      throw new Error(`'options' must not include the unknown option(s): ${unknownOptionKeys.join(\", \")}`);\n    }\n\n    if (filePath !== void 0 && !isNonEmptyString(filePath)) {\n      throw new Error(\"'options.filePath' must be a non-empty string or undefined\");\n    }\n\n    if (typeof warnIgnored !== \"boolean\") {\n      throw new Error(\"'options.warnIgnored' must be a boolean or undefined\");\n    } // Now we can get down to linting\n\n\n    const {\n      linter,\n      options: eslintOptions\n    } = privateMembers.get(this);\n    const configs = await calculateConfigArray(this, eslintOptions);\n    const {\n      allowInlineConfig,\n      cwd,\n      fix,\n      reportUnusedDisableDirectives\n    } = eslintOptions;\n    const results = [];\n    const startTime = Date.now();\n    const resolvedFilename = path.resolve(cwd, filePath || \"__placeholder__.js\");\n    let config; // Clear the last used config arrays.\n\n    if (resolvedFilename && (await this.isPathIgnored(resolvedFilename))) {\n      if (warnIgnored) {\n        results.push(createIgnoreResult(resolvedFilename, cwd));\n      }\n    } else {\n      // TODO: Needed?\n      config = configs.getConfig(resolvedFilename); // Do lint.\n\n      results.push(verifyText({\n        text: code,\n        filePath: resolvedFilename.endsWith(\"__placeholder__.js\") ? \"<text>\" : resolvedFilename,\n        configs,\n        cwd,\n        fix,\n        allowInlineConfig,\n        reportUnusedDisableDirectives,\n        linter\n      }));\n    }\n\n    debug(`Linting complete in: ${Date.now() - startTime}ms`);\n    let usedDeprecatedRules;\n    return processLintReport(this, {\n      results,\n      ...calculateStatsPerRun(results),\n\n      // Initialize it lazily because CLI and `ESLint` API don't use it.\n      get usedDeprecatedRules() {\n        if (!usedDeprecatedRules) {\n          usedDeprecatedRules = Array.from(iterateRuleDeprecationWarnings(config));\n        }\n\n        return usedDeprecatedRules;\n      }\n\n    });\n  }\n  /**\n   * Returns the formatter representing the given formatter name.\n   * @param {string} [name] The name of the formatter to load.\n   * The following values are allowed:\n   * - `undefined` ... Load `stylish` builtin formatter.\n   * - A builtin formatter name ... Load the builtin formatter.\n   * - A thirdparty formatter name:\n   *   - `foo` → `eslint-formatter-foo`\n   *   - `@foo` → `@foo/eslint-formatter`\n   *   - `@foo/bar` → `@foo/eslint-formatter-bar`\n   * - A file path ... Load the file.\n   * @returns {Promise<Formatter>} A promise resolving to the formatter object.\n   * This promise will be rejected if the given formatter was not found or not\n   * a function.\n   */\n\n\n  async loadFormatter() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"stylish\";\n\n    if (typeof name !== \"string\") {\n      throw new Error(\"'name' must be a string\");\n    } // replace \\ with / for Windows compatibility\n\n\n    const normalizedFormatName = name.replace(/\\\\/gu, \"/\");\n    const namespace = naming.getNamespaceFromTerm(normalizedFormatName); // grab our options\n\n    const {\n      cwd\n    } = privateMembers.get(this).options;\n    let formatterPath; // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)\n\n    if (!namespace && normalizedFormatName.includes(\"/\")) {\n      formatterPath = path.resolve(cwd, normalizedFormatName);\n    } else {\n      try {\n        const npmFormat = naming.normalizePackageName(normalizedFormatName, \"eslint-formatter\"); // TODO: This is pretty dirty...would be nice to clean up at some point.\n\n        formatterPath = ModuleResolver.resolve(npmFormat, path.join(cwd, \"__placeholder__.js\"));\n      } catch {\n        formatterPath = path.resolve(__dirname, \"../\", \"cli-engine\", \"formatters\", `${normalizedFormatName}.js`);\n      }\n    }\n\n    let formatter;\n\n    try {\n      formatter = (await import(pathToFileURL(formatterPath))).default;\n    } catch (ex) {\n      // check for formatters that have been removed\n      if (removedFormatters.has(name)) {\n        ex.message = `The ${name} formatter is no longer part of core ESLint. Install it manually with \\`npm install -D eslint-formatter-${name}\\``;\n      } else {\n        ex.message = `There was a problem loading formatter: ${formatterPath}\\nError: ${ex.message}`;\n      }\n\n      throw ex;\n    }\n\n    if (typeof formatter !== \"function\") {\n      throw new TypeError(`Formatter must be a function, but got a ${typeof formatter}.`);\n    }\n\n    const eslint = this;\n    return {\n      /**\n       * The main formatter method.\n       * @param {LintResults[]} results The lint results to format.\n       * @returns {string} The formatted lint results.\n       */\n      format(results) {\n        let rulesMeta = null;\n        results.sort(compareResultsByFilePath);\n        return formatter(results, {\n          cwd,\n\n          get rulesMeta() {\n            if (!rulesMeta) {\n              rulesMeta = eslint.getRulesMetaForResults(results);\n            }\n\n            return rulesMeta;\n          }\n\n        });\n      }\n\n    };\n  }\n  /**\n   * Returns a configuration object for the given file based on the CLI options.\n   * This is the same logic used by the ESLint CLI executable to determine\n   * configuration for each file it processes.\n   * @param {string} filePath The path of the file to retrieve a config object for.\n   * @returns {Promise<ConfigData|undefined>} A configuration object for the file\n   *      or `undefined` if there is no configuration data for the object.\n   */\n\n\n  async calculateConfigForFile(filePath) {\n    if (!isNonEmptyString(filePath)) {\n      throw new Error(\"'filePath' must be a non-empty string\");\n    }\n\n    const options = privateMembers.get(this).options;\n    const absolutePath = path.resolve(options.cwd, filePath);\n    const configs = await calculateConfigArray(this, options);\n    return configs.getConfig(absolutePath);\n  }\n  /**\n   * Checks if a given path is ignored by ESLint.\n   * @param {string} filePath The path of the file to check.\n   * @returns {Promise<boolean>} Whether or not the given path is ignored.\n   */\n\n\n  async isPathIgnored(filePath) {\n    const config = await this.calculateConfigForFile(filePath);\n    return config === void 0;\n  }\n\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  FlatESLint,\n  findFlatConfigFile\n};","map":{"version":3,"names":["fs","require","promises","path","findUp","version","Linter","getRuleFromConfig","gitignoreToMinimatch","Legacy","ConfigOps","getRuleSeverity","ModuleResolver","naming","fileExists","findFiles","getCacheFile","isNonEmptyString","isArrayOfNonEmptyString","createIgnoreResult","isErrorMessage","processOptions","pathToFileURL","FlatConfigArray","LintResultCache","FLAT_CONFIG_FILENAME","debug","removedFormatters","Set","privateMembers","WeakMap","calculateStatsPerFile","messages","reduce","stat","message","fatal","severity","errorCount","fatalErrorCount","fix","fixableErrorCount","warningCount","fixableWarningCount","calculateStatsPerRun","results","result","loadIgnoreFilePatterns","filePath","ignoreFileText","readFile","encoding","split","filter","line","trim","startsWith","e","createRulesMeta","rules","Array","from","retVal","id","rule","meta","usedDeprecatedRulesCache","getOrFindUsedDeprecatedRules","eslint","maybeFilePath","configs","options","cwd","get","isAbsolute","join","config","getConfig","has","retv","ruleId","ruleConf","Object","entries","deprecated","push","replacedBy","set","freeze","processLintReport","descriptor","configurable","enumerable","defineProperty","compareResultsByFilePath","a","b","findFlatConfigFile","loadFlatConfigFile","basePath","shouldIgnore","fileURL","module","default","calculateConfigArray","overrideConfig","configFile","ignore","ignorePath","ignorePatterns","slots","configFilePath","resolve","Error","dirname","defaultConfigs","allIgnorePatterns","ignoreFilePath","length","relativeIgnorePath","relative","map","pattern","negated","basePattern","slice","includes","endsWith","posix","ignores","isArray","normalize","verifyText","text","providedFilePath","allowInlineConfig","reportUnusedDisableDirectives","linter","filePathToVerify","fixed","output","verifyAndFix","filename","filterCodeBlock","blockFilename","isExplicitMatch","suppressedMessages","getSuppressedMessages","source","shouldMessageBeFixed","fixTypes","Boolean","type","iterateRuleDeprecationWarnings","processedRuleIds","ruleConfig","add","FlatESLint","constructor","processedOptions","configType","cacheFilePath","cacheLocation","lintResultCache","cache","cacheStrategy","defaultIgnores","plugins","pluginName","plugin","getShorthandName","outputFixes","Promise","all","r","writeFile","getErrorResults","filtered","forEach","filteredMessages","filteredSuppressedMessages","getRulesMetaForResults","resultRules","Map","TypeError","allMessages","concat","lintFiles","patterns","eslintOptions","globInputPaths","errorOnUnmatchedPattern","startTime","Date","now","usedConfigs","fixTypesSet","unlink","error","errorCode","code","exists","filePaths","ignored","cachedResult","getCachedLintResults","hadMessages","fixer","originalFix","then","setCachedLintResults","reconcile","usedDeprecatedRules","finalResults","lintText","warnIgnored","unknownOptions","unknownOptionKeys","keys","resolvedFilename","isPathIgnored","loadFormatter","name","normalizedFormatName","replace","namespace","getNamespaceFromTerm","formatterPath","npmFormat","normalizePackageName","__dirname","formatter","ex","format","rulesMeta","sort","calculateConfigForFile","absolutePath","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/eslint/flat-eslint.js"],"sourcesContent":["/**\n * @fileoverview Main class using flat config\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// Note: Node.js 12 does not support fs/promises.\nconst fs = require(\"fs\").promises;\nconst path = require(\"path\");\nconst findUp = require(\"find-up\");\nconst { version } = require(\"../../package.json\");\nconst { Linter } = require(\"../linter\");\nconst { getRuleFromConfig } = require(\"../config/flat-config-helpers\");\nconst { gitignoreToMinimatch } = require(\"@humanwhocodes/gitignore-to-minimatch\");\nconst {\n    Legacy: {\n        ConfigOps: {\n            getRuleSeverity\n        },\n        ModuleResolver,\n        naming\n    }\n} = require(\"@eslint/eslintrc\");\n\nconst {\n    fileExists,\n    findFiles,\n    getCacheFile,\n\n    isNonEmptyString,\n    isArrayOfNonEmptyString,\n\n    createIgnoreResult,\n    isErrorMessage,\n\n    processOptions\n} = require(\"./eslint-helpers\");\nconst { pathToFileURL } = require(\"url\");\nconst { FlatConfigArray } = require(\"../config/flat-config-array\");\nconst LintResultCache = require(\"../cli-engine/lint-result-cache\");\n\n/*\n * This is necessary to allow overwriting writeFile for testing purposes.\n * We can just use fs/promises once we drop Node.js 12 support.\n */\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n// For VSCode IntelliSense\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n/** @typedef {import(\"../shared/types\").RuleConf} RuleConf */\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n/** @typedef {ReturnType<ConfigArray.extractConfig>} ExtractedConfig */\n\n/**\n * The options with which to configure the ESLint instance.\n * @typedef {Object} FlatESLintOptions\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this instance\n * @property {boolean} [cache] Enable result caching.\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\n * @property {\"metadata\" | \"content\"} [cacheStrategy] The strategy used to detect changed files.\n * @property {string} [cwd] The value to use for the current working directory.\n * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn't throw even if no target files found. Defaults to `true`.\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\n * @property {boolean} [ignore] False disables use of .eslintignore.\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\n * @property {string[]} [ignorePatterns] Ignore file patterns to use in addition to .eslintignore.\n * @property {ConfigData} [overrideConfig] Override config object, overrides all configs used with this instance\n * @property {boolean|string} [overrideConfigFile] Searches for default config file when falsy;\n *      doesn't do any config file lookup when `true`; considered to be a config filename\n *      when a string.\n * @property {Record<string,Plugin>} [plugins] An array of plugin implementations.\n * @property {\"error\" | \"warn\" | \"off\"} [reportUnusedDisableDirectives] the severity to report unused eslint-disable directives.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst FLAT_CONFIG_FILENAME = \"eslint.config.js\";\nconst debug = require(\"debug\")(\"eslint:flat-eslint\");\nconst removedFormatters = new Set([\"table\", \"codeframe\"]);\nconst privateMembers = new WeakMap();\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {LintMessage[]} messages Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerFile(messages) {\n    return messages.reduce((stat, message) => {\n        if (message.fatal || message.severity === 2) {\n            stat.errorCount++;\n            if (message.fatal) {\n                stat.fatalErrorCount++;\n            }\n            if (message.fix) {\n                stat.fixableErrorCount++;\n            }\n        } else {\n            stat.warningCount++;\n            if (message.fix) {\n                stat.fixableWarningCount++;\n            }\n        }\n        return stat;\n    }, {\n        errorCount: 0,\n        fatalErrorCount: 0,\n        warningCount: 0,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    });\n}\n\n/**\n * It will calculate the error and warning count for collection of results from all files\n * @param {LintResult[]} results Collection of messages from all the files\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerRun(results) {\n    return results.reduce((stat, result) => {\n        stat.errorCount += result.errorCount;\n        stat.fatalErrorCount += result.fatalErrorCount;\n        stat.warningCount += result.warningCount;\n        stat.fixableErrorCount += result.fixableErrorCount;\n        stat.fixableWarningCount += result.fixableWarningCount;\n        return stat;\n    }, {\n        errorCount: 0,\n        fatalErrorCount: 0,\n        warningCount: 0,\n        fixableErrorCount: 0,\n        fixableWarningCount: 0\n    });\n}\n\n/**\n * Loads global ignore patterns from an ignore file (usually .eslintignore).\n * @param {string} filePath The filename to load.\n * @returns {ignore} A function encapsulating the ignore patterns.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nasync function loadIgnoreFilePatterns(filePath) {\n    debug(`Loading ignore file: ${filePath}`);\n\n    try {\n        const ignoreFileText = await fs.readFile(filePath, { encoding: \"utf8\" });\n\n        return ignoreFileText\n            .split(/\\r?\\n/gu)\n            .filter(line => line.trim() !== \"\" && !line.startsWith(\"#\"));\n\n    } catch (e) {\n        debug(`Error reading ignore file: ${filePath}`);\n        e.message = `Cannot read ignore file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Create rulesMeta object.\n * @param {Map<string,Rule>} rules a map of rules from which to generate the object.\n * @returns {Object} metadata for all enabled rules.\n */\nfunction createRulesMeta(rules) {\n    return Array.from(rules).reduce((retVal, [id, rule]) => {\n        retVal[id] = rule.meta;\n        return retVal;\n    }, {});\n}\n\n/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>} */\nconst usedDeprecatedRulesCache = new WeakMap();\n\n/**\n * Create used deprecated rule list.\n * @param {CLIEngine} eslint The CLIEngine instance.\n * @param {string} maybeFilePath The absolute path to a lint target file or `\"<text>\"`.\n * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.\n */\nfunction getOrFindUsedDeprecatedRules(eslint, maybeFilePath) {\n    const {\n        configs,\n        options: { cwd }\n    } = privateMembers.get(eslint);\n    const filePath = path.isAbsolute(maybeFilePath)\n        ? maybeFilePath\n        : path.join(cwd, \"__placeholder__.js\");\n    const config = configs.getConfig(filePath);\n\n    // Most files use the same config, so cache it.\n    if (config && !usedDeprecatedRulesCache.has(config)) {\n        const retv = [];\n\n        if (config.rules) {\n            for (const [ruleId, ruleConf] of Object.entries(config.rules)) {\n                if (getRuleSeverity(ruleConf) === 0) {\n                    continue;\n                }\n                const rule = getRuleFromConfig(ruleId, config);\n                const meta = rule && rule.meta;\n\n                if (meta && meta.deprecated) {\n                    retv.push({ ruleId, replacedBy: meta.replacedBy || [] });\n                }\n            }\n        }\n\n\n        usedDeprecatedRulesCache.set(config, Object.freeze(retv));\n    }\n\n    return config ? usedDeprecatedRulesCache.get(config) : Object.freeze([]);\n}\n\n/**\n * Processes the linting results generated by a CLIEngine linting report to\n * match the ESLint class's API.\n * @param {CLIEngine} eslint The CLIEngine instance.\n * @param {CLIEngineLintReport} report The CLIEngine linting report to process.\n * @returns {LintResult[]} The processed linting results.\n */\nfunction processLintReport(eslint, { results }) {\n    const descriptor = {\n        configurable: true,\n        enumerable: true,\n        get() {\n            return getOrFindUsedDeprecatedRules(eslint, this.filePath);\n        }\n    };\n\n    for (const result of results) {\n        Object.defineProperty(result, \"usedDeprecatedRules\", descriptor);\n    }\n\n    return results;\n}\n\n/**\n * An Array.prototype.sort() compatible compare function to order results by their file path.\n * @param {LintResult} a The first lint result.\n * @param {LintResult} b The second lint result.\n * @returns {number} An integer representing the order in which the two results should occur.\n */\nfunction compareResultsByFilePath(a, b) {\n    if (a.filePath < b.filePath) {\n        return -1;\n    }\n\n    if (a.filePath > b.filePath) {\n        return 1;\n    }\n\n    return 0;\n}\n\n/**\n * Searches from the current working directory up until finding the\n * given flat config filename.\n * @param {string} cwd The current working directory to search from.\n * @returns {Promise<string|null>} The filename if found or `null` if not.\n */\nfunction findFlatConfigFile(cwd) {\n    return findUp(\n        FLAT_CONFIG_FILENAME,\n        { cwd }\n    );\n}\n\n/**\n * Load the config array from the given filename.\n * @param {string} filePath The filename to load from.\n * @param {Object} options Options to help load the config file.\n * @param {string} options.basePath The base path for the config array.\n * @param {boolean} options.shouldIgnore Whether to honor ignore patterns.\n * @returns {Promise<FlatConfigArray>} The config array loaded from the config file.\n */\nasync function loadFlatConfigFile(filePath, { basePath, shouldIgnore }) {\n    debug(`Loading config from ${filePath}`);\n\n    const fileURL = pathToFileURL(filePath);\n\n    debug(`Config file URL is ${fileURL}`);\n\n    const module = await import(fileURL);\n\n    return new FlatConfigArray(module.default, {\n        basePath,\n        shouldIgnore\n    });\n}\n\n/**\n * Calculates the config array for this run based on inputs.\n * @param {FlatESLint} eslint The instance to create the config array for.\n * @param {import(\"./eslint\").ESLintOptions} options The ESLint instance options.\n * @returns {FlatConfigArray} The config array for `eslint``.\n */\nasync function calculateConfigArray(eslint, {\n    cwd,\n    overrideConfig,\n    configFile,\n    ignore: shouldIgnore,\n    ignorePath,\n    ignorePatterns\n}) {\n\n    // check for cached instance\n    const slots = privateMembers.get(eslint);\n\n    if (slots.configs) {\n        return slots.configs;\n    }\n\n    // determine where to load config file from\n    let configFilePath;\n    let basePath = cwd;\n\n    if (typeof configFile === \"string\") {\n        debug(`Override config file path is ${configFile}`);\n        configFilePath = path.resolve(cwd, configFile);\n    } else if (configFile !== false) {\n        debug(\"Searching for eslint.config.js\");\n        configFilePath = await findFlatConfigFile(cwd);\n\n        if (!configFilePath) {\n            throw new Error(\"Could not find config file.\");\n        }\n\n        basePath = path.resolve(path.dirname(configFilePath));\n    }\n\n    // load config array\n    let configs;\n\n    if (configFilePath) {\n        configs = await loadFlatConfigFile(configFilePath, {\n            basePath,\n            shouldIgnore\n        });\n    } else {\n        configs = new FlatConfigArray([], { basePath, shouldIgnore });\n    }\n\n    // add in any configured defaults\n    configs.push(...slots.defaultConfigs);\n\n    let allIgnorePatterns = [];\n    let ignoreFilePath;\n\n    // load ignore file if necessary\n    if (shouldIgnore) {\n        if (ignorePath) {\n            ignoreFilePath = path.resolve(cwd, ignorePath);\n            allIgnorePatterns = await loadIgnoreFilePatterns(ignoreFilePath);\n        } else {\n            ignoreFilePath = path.resolve(cwd, \".eslintignore\");\n\n            // no error if .eslintignore doesn't exist`\n            if (fileExists(ignoreFilePath)) {\n                allIgnorePatterns = await loadIgnoreFilePatterns(ignoreFilePath);\n            }\n        }\n    }\n\n    // append command line ignore patterns\n    if (ignorePatterns) {\n        if (typeof ignorePatterns === \"string\") {\n            allIgnorePatterns.push(ignorePatterns);\n        } else {\n            allIgnorePatterns.push(...ignorePatterns);\n        }\n    }\n\n    /*\n     * If the config file basePath is different than the cwd, then\n     * the ignore patterns won't work correctly. Here, we adjust the\n     * ignore pattern to include the correct relative path. Patterns\n     * loaded from ignore files are always relative to the cwd, whereas\n     * the config file basePath can be an ancestor of the cwd.\n     */\n    if (basePath !== cwd && allIgnorePatterns.length) {\n\n        const relativeIgnorePath = path.relative(basePath, cwd);\n\n        allIgnorePatterns = allIgnorePatterns.map(pattern => {\n            const negated = pattern.startsWith(\"!\");\n            const basePattern = negated ? pattern.slice(1) : pattern;\n\n            /*\n             * Ignore patterns are considered relative to a directory\n             * when the pattern contains a slash in a position other\n             * than the last character. If that's the case, we need to\n             * add the relative ignore path to the current pattern to\n             * get the correct behavior. Otherwise, no change is needed.\n             */\n            if (!basePattern.includes(\"/\") || basePattern.endsWith(\"/\")) {\n                return pattern;\n            }\n\n            return (negated ? \"!\" : \"\") +\n                path.posix.join(relativeIgnorePath, basePattern);\n        });\n    }\n\n    if (allIgnorePatterns.length) {\n\n        /*\n         * Ignore patterns are added to the end of the config array\n         * so they can override default ignores.\n         */\n        configs.push({\n            ignores: allIgnorePatterns.map(gitignoreToMinimatch)\n        });\n    }\n\n    if (overrideConfig) {\n        if (Array.isArray(overrideConfig)) {\n            configs.push(...overrideConfig);\n        } else {\n            configs.push(overrideConfig);\n        }\n    }\n\n    await configs.normalize();\n\n    // cache the config array for this instance\n    slots.configs = configs;\n\n    return configs;\n}\n\n/**\n * Processes an source code using ESLint.\n * @param {Object} config The config object.\n * @param {string} config.text The source code to verify.\n * @param {string} config.cwd The path to the current working directory.\n * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.\n * @param {FlatConfigArray} config.configs The config.\n * @param {boolean} config.fix If `true` then it does fix.\n * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.\n * @param {boolean} config.reportUnusedDisableDirectives If `true` then it reports unused `eslint-disable` comments.\n * @param {Linter} config.linter The linter instance to verify.\n * @returns {LintResult} The result of linting.\n * @private\n */\nfunction verifyText({\n    text,\n    cwd,\n    filePath: providedFilePath,\n    configs,\n    fix,\n    allowInlineConfig,\n    reportUnusedDisableDirectives,\n    linter\n}) {\n    const filePath = providedFilePath || \"<text>\";\n\n    debug(`Lint ${filePath}`);\n\n    /*\n     * Verify.\n     * `config.extractConfig(filePath)` requires an absolute path, but `linter`\n     * doesn't know CWD, so it gives `linter` an absolute path always.\n     */\n    const filePathToVerify = filePath === \"<text>\" ? path.join(cwd, \"__placeholder__.js\") : filePath;\n    const { fixed, messages, output } = linter.verifyAndFix(\n        text,\n        configs,\n        {\n            allowInlineConfig,\n            filename: filePathToVerify,\n            fix,\n            reportUnusedDisableDirectives,\n\n            /**\n             * Check if the linter should adopt a given code block or not.\n             * @param {string} blockFilename The virtual filename of a code block.\n             * @returns {boolean} `true` if the linter should adopt the code block.\n             */\n            filterCodeBlock(blockFilename) {\n                return configs.isExplicitMatch(blockFilename);\n            }\n        }\n    );\n\n    // Tweak and return.\n    const result = {\n        filePath: filePath === \"<text>\" ? filePath : path.resolve(filePath),\n        messages,\n        suppressedMessages: linter.getSuppressedMessages(),\n        ...calculateStatsPerFile(messages)\n    };\n\n    if (fixed) {\n        result.output = output;\n    }\n\n    if (\n        result.errorCount + result.warningCount > 0 &&\n        typeof result.output === \"undefined\"\n    ) {\n        result.source = text;\n    }\n\n    return result;\n}\n\n/**\n * Checks whether a message's rule type should be fixed.\n * @param {LintMessage} message The message to check.\n * @param {FlatConfig} config The config for the file that generated the message.\n * @param {string[]} fixTypes An array of fix types to check.\n * @returns {boolean} Whether the message should be fixed.\n */\nfunction shouldMessageBeFixed(message, config, fixTypes) {\n    if (!message.ruleId) {\n        return fixTypes.has(\"directive\");\n    }\n\n    const rule = message.ruleId && getRuleFromConfig(message.ruleId, config);\n\n    return Boolean(rule && rule.meta && fixTypes.has(rule.meta.type));\n}\n\n/**\n * Collect used deprecated rules.\n * @param {Array<FlatConfig>} configs The configs to evaluate.\n * @returns {IterableIterator<DeprecatedRuleInfo>} Used deprecated rules.\n */\nfunction *iterateRuleDeprecationWarnings(configs) {\n    const processedRuleIds = new Set();\n\n    for (const config of configs) {\n        for (const [ruleId, ruleConfig] of Object.entries(config.rules)) {\n\n            // Skip if it was processed.\n            if (processedRuleIds.has(ruleId)) {\n                continue;\n            }\n            processedRuleIds.add(ruleId);\n\n            // Skip if it's not used.\n            if (!getRuleSeverity(ruleConfig)) {\n                continue;\n            }\n            const rule = getRuleFromConfig(ruleId, config);\n\n            // Skip if it's not deprecated.\n            if (!(rule && rule.meta && rule.meta.deprecated)) {\n                continue;\n            }\n\n            // This rule was used and deprecated.\n            yield {\n                ruleId,\n                replacedBy: rule.meta.replacedBy || []\n            };\n        }\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Main API\n//-----------------------------------------------------------------------------\n\n/**\n * Primary Node.js API for ESLint.\n */\nclass FlatESLint {\n\n    /**\n     * Creates a new instance of the main ESLint API.\n     * @param {FlatESLintOptions} options The options for this instance.\n     */\n    constructor(options = {}) {\n\n        const defaultConfigs = [];\n        const processedOptions = processOptions(options);\n        const linter = new Linter({\n            cwd: processedOptions.cwd,\n            configType: \"flat\"\n        });\n\n        const cacheFilePath = getCacheFile(\n            processedOptions.cacheLocation,\n            processedOptions.cwd\n        );\n\n        const lintResultCache = processedOptions.cache\n            ? new LintResultCache(cacheFilePath, processedOptions.cacheStrategy)\n            : null;\n\n        privateMembers.set(this, {\n            options: processedOptions,\n            linter,\n            cacheFilePath,\n            lintResultCache,\n            defaultConfigs,\n            defaultIgnores: () => false,\n            configs: null\n        });\n\n        /**\n         * If additional plugins are passed in, add that to the default\n         * configs for this instance.\n         */\n        if (options.plugins) {\n\n            const plugins = {};\n\n            for (const [pluginName, plugin] of Object.entries(options.plugins)) {\n                plugins[naming.getShorthandName(pluginName, \"eslint-plugin\")] = plugin;\n            }\n\n            defaultConfigs.push({\n                plugins\n            });\n        }\n\n    }\n\n    /**\n     * The version text.\n     * @type {string}\n     */\n    static get version() {\n        return version;\n    }\n\n    /**\n     * Outputs fixes from the given results to files.\n     * @param {LintResult[]} results The lint results.\n     * @returns {Promise<void>} Returns a promise that is used to track side effects.\n     */\n    static async outputFixes(results) {\n        if (!Array.isArray(results)) {\n            throw new Error(\"'results' must be an array\");\n        }\n\n        await Promise.all(\n            results\n                .filter(result => {\n                    if (typeof result !== \"object\" || result === null) {\n                        throw new Error(\"'results' must include only objects\");\n                    }\n                    return (\n                        typeof result.output === \"string\" &&\n                        path.isAbsolute(result.filePath)\n                    );\n                })\n                .map(r => fs.writeFile(r.filePath, r.output))\n        );\n    }\n\n    /**\n     * Returns results that only contains errors.\n     * @param {LintResult[]} results The results to filter.\n     * @returns {LintResult[]} The filtered results.\n     */\n    static getErrorResults(results) {\n        const filtered = [];\n\n        results.forEach(result => {\n            const filteredMessages = result.messages.filter(isErrorMessage);\n            const filteredSuppressedMessages = result.suppressedMessages.filter(isErrorMessage);\n\n            if (filteredMessages.length > 0) {\n                filtered.push({\n                    ...result,\n                    messages: filteredMessages,\n                    suppressedMessages: filteredSuppressedMessages,\n                    errorCount: filteredMessages.length,\n                    warningCount: 0,\n                    fixableErrorCount: result.fixableErrorCount,\n                    fixableWarningCount: 0\n                });\n            }\n        });\n\n        return filtered;\n    }\n\n    /**\n     * Returns meta objects for each rule represented in the lint results.\n     * @param {LintResult[]} results The results to fetch rules meta for.\n     * @returns {Object} A mapping of ruleIds to rule meta objects.\n     * @throws {TypeError} When the results object wasn't created from this ESLint instance.\n     * @throws {TypeError} When a plugin or rule is missing.\n     */\n    getRulesMetaForResults(results) {\n\n        const resultRules = new Map();\n\n        // short-circuit simple case\n        if (results.length === 0) {\n            return resultRules;\n        }\n\n        const { configs } = privateMembers.get(this);\n\n        /*\n         * We can only accurately return rules meta information for linting results if the\n         * results were created by this instance. Otherwise, the necessary rules data is\n         * not available. So if the config array doesn't already exist, just throw an error\n         * to let the user know we can't do anything here.\n         */\n        if (!configs) {\n            throw new TypeError(\"Results object was not created from this ESLint instance.\");\n        }\n\n        for (const result of results) {\n\n            /*\n             * Normalize filename for <text>.\n             */\n            const filePath = result.filePath === \"<text>\"\n                ? \"__placeholder__.js\" : result.filePath;\n\n            /*\n             * All of the plugin and rule information is contained within the\n             * calculated config for the given file.\n             */\n            const config = configs.getConfig(filePath);\n            const allMessages = result.messages.concat(result.suppressedMessages);\n\n            for (const { ruleId } of allMessages) {\n                const rule = getRuleFromConfig(ruleId, config);\n\n                // ensure the rule exists\n                if (!rule) {\n                    throw new TypeError(`Could not find the rule \"${ruleId}\".`);\n                }\n\n                resultRules.set(ruleId, rule);\n            }\n        }\n\n        return createRulesMeta(resultRules);\n    }\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string|string[]} patterns An array of file and directory names.\n     * @returns {Promise<LintResult[]>} The results of linting the file patterns given.\n     */\n    async lintFiles(patterns) {\n        if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {\n            throw new Error(\"'patterns' must be a non-empty string or an array of non-empty strings\");\n        }\n\n        const {\n            cacheFilePath,\n            lintResultCache,\n            linter,\n            options: eslintOptions\n        } = privateMembers.get(this);\n        const configs = await calculateConfigArray(this, eslintOptions);\n        const {\n            allowInlineConfig,\n            cache,\n            cwd,\n            fix,\n            fixTypes,\n            reportUnusedDisableDirectives,\n            globInputPaths,\n            errorOnUnmatchedPattern\n        } = eslintOptions;\n        const startTime = Date.now();\n        const usedConfigs = [];\n        const fixTypesSet = fixTypes ? new Set(fixTypes) : null;\n\n        // Delete cache file; should this be done here?\n        if (!cache && cacheFilePath) {\n            debug(`Deleting cache file at ${cacheFilePath}`);\n\n            try {\n                await fs.unlink(cacheFilePath);\n            } catch (error) {\n                const errorCode = error && error.code;\n\n                // Ignore errors when no such file exists or file system is read only (and cache file does not exist)\n                if (errorCode !== \"ENOENT\" && !(errorCode === \"EROFS\" && !(await fs.exists(cacheFilePath)))) {\n                    throw error;\n                }\n            }\n        }\n\n        const filePaths = await findFiles({\n            patterns: typeof patterns === \"string\" ? [patterns] : patterns,\n            cwd,\n            globInputPaths,\n            configs,\n            errorOnUnmatchedPattern\n        });\n\n        debug(`${filePaths.length} files found in: ${Date.now() - startTime}ms`);\n\n        /*\n         * Because we need to process multiple files, including reading from disk,\n         * it is most efficient to start by reading each file via promises so that\n         * they can be done in parallel. Then, we can lint the returned text. This\n         * ensures we are waiting the minimum amount of time in between lints.\n         */\n        const results = await Promise.all(\n\n            filePaths.map(({ filePath, ignored }) => {\n\n                /*\n                 * If a filename was entered that matches an ignore\n                 * pattern, then notify the user.\n                 */\n                if (ignored) {\n                    return createIgnoreResult(filePath, cwd);\n                }\n\n                const config = configs.getConfig(filePath);\n\n                /*\n                 * Sometimes a file found through a glob pattern will\n                 * be ignored. In this case, `config` will be undefined\n                 * and we just silently ignore the file.\n                 */\n                if (!config) {\n                    return void 0;\n                }\n\n                /*\n                 * Store used configs for:\n                 * - this method uses to collect used deprecated rules.\n                 * - `--fix-type` option uses to get the loaded rule's meta data.\n                 */\n                if (!usedConfigs.includes(config)) {\n                    usedConfigs.push(config);\n                }\n\n                // Skip if there is cached result.\n                if (lintResultCache) {\n                    const cachedResult =\n                        lintResultCache.getCachedLintResults(filePath, config);\n\n                    if (cachedResult) {\n                        const hadMessages =\n                            cachedResult.messages &&\n                            cachedResult.messages.length > 0;\n\n                        if (hadMessages && fix) {\n                            debug(`Reprocessing cached file to allow autofix: ${filePath}`);\n                        } else {\n                            debug(`Skipping file since it hasn't changed: ${filePath}`);\n                            return cachedResult;\n                        }\n                    }\n                }\n\n\n                // set up fixer for fixtypes if necessary\n                let fixer = fix;\n\n                if (fix && fixTypesSet) {\n\n                    // save original value of options.fix in case it's a function\n                    const originalFix = (typeof fix === \"function\")\n                        ? fix : () => true;\n\n                    fixer = message => shouldMessageBeFixed(message, config, fixTypesSet) && originalFix(message);\n                }\n\n                return fs.readFile(filePath, \"utf8\")\n                    .then(text => {\n\n                        // do the linting\n                        const result = verifyText({\n                            text,\n                            filePath,\n                            configs,\n                            cwd,\n                            fix: fixer,\n                            allowInlineConfig,\n                            reportUnusedDisableDirectives,\n                            linter\n                        });\n\n                        /*\n                         * Store the lint result in the LintResultCache.\n                         * NOTE: The LintResultCache will remove the file source and any\n                         * other properties that are difficult to serialize, and will\n                         * hydrate those properties back in on future lint runs.\n                         */\n                        if (lintResultCache) {\n                            lintResultCache.setCachedLintResults(filePath, config, result);\n                        }\n\n                        return result;\n                    });\n\n            })\n        );\n\n        // Persist the cache to disk.\n        if (lintResultCache) {\n            lintResultCache.reconcile();\n        }\n\n        let usedDeprecatedRules;\n        const finalResults = results.filter(result => !!result);\n\n        return processLintReport(this, {\n            results: finalResults,\n            ...calculateStatsPerRun(finalResults),\n\n            // Initialize it lazily because CLI and `ESLint` API don't use it.\n            get usedDeprecatedRules() {\n                if (!usedDeprecatedRules) {\n                    usedDeprecatedRules = Array.from(\n                        iterateRuleDeprecationWarnings(usedConfigs)\n                    );\n                }\n                return usedDeprecatedRules;\n            }\n        });\n    }\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} code A string of JavaScript code to lint.\n     * @param {Object} [options] The options.\n     * @param {string} [options.filePath] The path to the file of the source code.\n     * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.\n     * @returns {Promise<LintResult[]>} The results of linting the string of code given.\n     */\n    async lintText(code, options = {}) {\n\n        // Parameter validation\n\n        if (typeof code !== \"string\") {\n            throw new Error(\"'code' must be a string\");\n        }\n\n        if (typeof options !== \"object\") {\n            throw new Error(\"'options' must be an object, null, or undefined\");\n        }\n\n        // Options validation\n\n        const {\n            filePath,\n            warnIgnored = false,\n            ...unknownOptions\n        } = options || {};\n\n        const unknownOptionKeys = Object.keys(unknownOptions);\n\n        if (unknownOptionKeys.length > 0) {\n            throw new Error(`'options' must not include the unknown option(s): ${unknownOptionKeys.join(\", \")}`);\n        }\n\n        if (filePath !== void 0 && !isNonEmptyString(filePath)) {\n            throw new Error(\"'options.filePath' must be a non-empty string or undefined\");\n        }\n\n        if (typeof warnIgnored !== \"boolean\") {\n            throw new Error(\"'options.warnIgnored' must be a boolean or undefined\");\n        }\n\n        // Now we can get down to linting\n\n        const {\n            linter,\n            options: eslintOptions\n        } = privateMembers.get(this);\n        const configs = await calculateConfigArray(this, eslintOptions);\n        const {\n            allowInlineConfig,\n            cwd,\n            fix,\n            reportUnusedDisableDirectives\n        } = eslintOptions;\n        const results = [];\n        const startTime = Date.now();\n        const resolvedFilename = path.resolve(cwd, filePath || \"__placeholder__.js\");\n        let config;\n\n        // Clear the last used config arrays.\n        if (resolvedFilename && await this.isPathIgnored(resolvedFilename)) {\n            if (warnIgnored) {\n                results.push(createIgnoreResult(resolvedFilename, cwd));\n            }\n        } else {\n\n            // TODO: Needed?\n            config = configs.getConfig(resolvedFilename);\n\n            // Do lint.\n            results.push(verifyText({\n                text: code,\n                filePath: resolvedFilename.endsWith(\"__placeholder__.js\") ? \"<text>\" : resolvedFilename,\n                configs,\n                cwd,\n                fix,\n                allowInlineConfig,\n                reportUnusedDisableDirectives,\n                linter\n            }));\n        }\n\n        debug(`Linting complete in: ${Date.now() - startTime}ms`);\n        let usedDeprecatedRules;\n\n        return processLintReport(this, {\n            results,\n            ...calculateStatsPerRun(results),\n\n            // Initialize it lazily because CLI and `ESLint` API don't use it.\n            get usedDeprecatedRules() {\n                if (!usedDeprecatedRules) {\n                    usedDeprecatedRules = Array.from(\n                        iterateRuleDeprecationWarnings(config)\n                    );\n                }\n                return usedDeprecatedRules;\n            }\n        });\n\n    }\n\n    /**\n     * Returns the formatter representing the given formatter name.\n     * @param {string} [name] The name of the formatter to load.\n     * The following values are allowed:\n     * - `undefined` ... Load `stylish` builtin formatter.\n     * - A builtin formatter name ... Load the builtin formatter.\n     * - A thirdparty formatter name:\n     *   - `foo` → `eslint-formatter-foo`\n     *   - `@foo` → `@foo/eslint-formatter`\n     *   - `@foo/bar` → `@foo/eslint-formatter-bar`\n     * - A file path ... Load the file.\n     * @returns {Promise<Formatter>} A promise resolving to the formatter object.\n     * This promise will be rejected if the given formatter was not found or not\n     * a function.\n     */\n    async loadFormatter(name = \"stylish\") {\n        if (typeof name !== \"string\") {\n            throw new Error(\"'name' must be a string\");\n        }\n\n        // replace \\ with / for Windows compatibility\n        const normalizedFormatName = name.replace(/\\\\/gu, \"/\");\n        const namespace = naming.getNamespaceFromTerm(normalizedFormatName);\n\n        // grab our options\n        const { cwd } = privateMembers.get(this).options;\n\n\n        let formatterPath;\n\n        // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)\n        if (!namespace && normalizedFormatName.includes(\"/\")) {\n            formatterPath = path.resolve(cwd, normalizedFormatName);\n        } else {\n            try {\n                const npmFormat = naming.normalizePackageName(normalizedFormatName, \"eslint-formatter\");\n\n                // TODO: This is pretty dirty...would be nice to clean up at some point.\n                formatterPath = ModuleResolver.resolve(npmFormat, path.join(cwd, \"__placeholder__.js\"));\n            } catch {\n                formatterPath = path.resolve(__dirname, \"../\", \"cli-engine\", \"formatters\", `${normalizedFormatName}.js`);\n            }\n        }\n\n        let formatter;\n\n        try {\n            formatter = (await import(pathToFileURL(formatterPath))).default;\n        } catch (ex) {\n\n            // check for formatters that have been removed\n            if (removedFormatters.has(name)) {\n                ex.message = `The ${name} formatter is no longer part of core ESLint. Install it manually with \\`npm install -D eslint-formatter-${name}\\``;\n            } else {\n                ex.message = `There was a problem loading formatter: ${formatterPath}\\nError: ${ex.message}`;\n            }\n\n            throw ex;\n        }\n\n\n        if (typeof formatter !== \"function\") {\n            throw new TypeError(`Formatter must be a function, but got a ${typeof formatter}.`);\n        }\n\n        const eslint = this;\n\n        return {\n\n            /**\n             * The main formatter method.\n             * @param {LintResults[]} results The lint results to format.\n             * @returns {string} The formatted lint results.\n             */\n            format(results) {\n                let rulesMeta = null;\n\n                results.sort(compareResultsByFilePath);\n\n                return formatter(results, {\n                    cwd,\n                    get rulesMeta() {\n                        if (!rulesMeta) {\n                            rulesMeta = eslint.getRulesMetaForResults(results);\n                        }\n\n                        return rulesMeta;\n                    }\n                });\n            }\n        };\n    }\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {Promise<ConfigData|undefined>} A configuration object for the file\n     *      or `undefined` if there is no configuration data for the object.\n     */\n    async calculateConfigForFile(filePath) {\n        if (!isNonEmptyString(filePath)) {\n            throw new Error(\"'filePath' must be a non-empty string\");\n        }\n        const options = privateMembers.get(this).options;\n        const absolutePath = path.resolve(options.cwd, filePath);\n        const configs = await calculateConfigArray(this, options);\n\n        return configs.getConfig(absolutePath);\n    }\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {Promise<boolean>} Whether or not the given path is ignored.\n     */\n    async isPathIgnored(filePath) {\n        const config = await this.calculateConfigForFile(filePath);\n\n        return config === void 0;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    FlatESLint,\n    findFlatConfigFile\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}