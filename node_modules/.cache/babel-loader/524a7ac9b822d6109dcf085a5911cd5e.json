{"ast":null,"code":"import path from 'path';\nimport chalk from 'chalk';\nimport slash from 'slash';\nimport stripAnsi from 'strip-ansi';\nconst TRIMMING_DOTS = '...';\nconst ENTER = '⏎';\n\nconst relativePath = (config, testPath) => {\n  const relativeTestPath = path.relative(config.cwd || config.rootDir, testPath);\n  const dirname = path.dirname(relativeTestPath);\n  const basename = path.basename(relativeTestPath);\n  return {\n    basename,\n    dirname\n  };\n};\n\nconst colorize = (str, start, end) => chalk.dim(str.slice(0, start)) + chalk.reset(str.slice(start, end)) + chalk.dim(str.slice(end));\n\nexport const trimAndFormatPath = (pad, config, testPath, columns) => {\n  const maxLength = columns - pad;\n  const relative = relativePath(config, testPath);\n  const {\n    basename\n  } = relative;\n  let {\n    dirname\n  } = relative; // length is ok\n\n  if ((dirname + path.sep + basename).length <= maxLength) {\n    return slash(chalk.dim(dirname + path.sep) + chalk.bold(basename));\n  } // we can fit trimmed dirname and full basename\n\n\n  const basenameLength = basename.length;\n\n  if (basenameLength + 4 < maxLength) {\n    const dirnameLength = maxLength - 4 - basenameLength;\n    dirname = `${TRIMMING_DOTS}${dirname.slice(dirname.length - dirnameLength, dirname.length)}`;\n    return slash(chalk.dim(dirname + path.sep) + chalk.bold(basename));\n  }\n\n  if (basenameLength + 4 === maxLength) {\n    return slash(chalk.dim(`${TRIMMING_DOTS}${path.sep}`) + chalk.bold(basename));\n  } // can't fit dirname, but can fit trimmed basename\n\n\n  return slash(chalk.bold(`${TRIMMING_DOTS}${basename.slice(-maxLength + 3)}`));\n};\nexport const getTerminalWidth = function () {\n  let pipe = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.stdout;\n  return pipe.columns;\n};\nexport const highlight = (rawPath, filePath, pattern) => {\n  const relativePathHead = './';\n  let regexp;\n\n  try {\n    regexp = new RegExp(pattern, 'i');\n  } catch (e) {\n    return chalk.dim(filePath);\n  }\n\n  const strippedRawPath = stripAnsi(rawPath);\n  const strippedFilePath = stripAnsi(filePath);\n  const match = strippedRawPath.match(regexp);\n\n  if (!match || match.index == null) {\n    return chalk.dim(strippedFilePath);\n  }\n\n  const offset = strippedRawPath.length - strippedFilePath.length;\n  let trimLength;\n\n  if (strippedFilePath.startsWith(TRIMMING_DOTS)) {\n    trimLength = TRIMMING_DOTS.length;\n  } else if (strippedFilePath.startsWith(relativePathHead)) {\n    trimLength = relativePathHead.length;\n  } else {\n    trimLength = 0;\n  }\n\n  const start = match.index - offset;\n  const end = start + match[0].length;\n  return colorize(strippedFilePath, Math.max(start, 0), Math.max(end, trimLength));\n};\nexport const formatTestNameByPattern = (testName, pattern, width) => {\n  const inlineTestName = testName.replace(/(\\r\\n|\\n|\\r)/gm, ENTER);\n  let regexp;\n\n  try {\n    regexp = new RegExp(pattern, 'i');\n  } catch (e) {\n    return chalk.dim(inlineTestName);\n  }\n\n  const match = inlineTestName.match(regexp);\n\n  if (!match || match.index == null) {\n    return chalk.dim(inlineTestName);\n  }\n\n  const startPatternIndex = Math.max(match.index, 0);\n  const endPatternIndex = startPatternIndex + match[0].length;\n  const testNameFitsInTerminal = inlineTestName.length <= width;\n\n  if (testNameFitsInTerminal) {\n    return colorize(inlineTestName, startPatternIndex, endPatternIndex);\n  }\n\n  const numberOfTruncatedChars = TRIMMING_DOTS.length + inlineTestName.length - width;\n  const end = Math.max(endPatternIndex - numberOfTruncatedChars, 0);\n  const truncatedTestName = inlineTestName.slice(numberOfTruncatedChars);\n  const shouldHighlightDots = startPatternIndex <= numberOfTruncatedChars;\n\n  if (shouldHighlightDots) {\n    return colorize(TRIMMING_DOTS + truncatedTestName, 0, end + TRIMMING_DOTS.length);\n  }\n\n  const start = startPatternIndex - numberOfTruncatedChars;\n  return colorize(TRIMMING_DOTS + truncatedTestName, start + TRIMMING_DOTS.length, end + TRIMMING_DOTS.length);\n};\nexport const removeTrimmingDots = value => {\n  if (value.startsWith(TRIMMING_DOTS)) {\n    return value.slice(TRIMMING_DOTS.length);\n  }\n\n  return value;\n};","map":{"version":3,"names":["path","chalk","slash","stripAnsi","TRIMMING_DOTS","ENTER","relativePath","config","testPath","relativeTestPath","relative","cwd","rootDir","dirname","basename","colorize","str","start","end","dim","slice","reset","trimAndFormatPath","pad","columns","maxLength","sep","length","bold","basenameLength","dirnameLength","getTerminalWidth","pipe","process","stdout","highlight","rawPath","filePath","pattern","relativePathHead","regexp","RegExp","e","strippedRawPath","strippedFilePath","match","index","offset","trimLength","startsWith","Math","max","formatTestNameByPattern","testName","width","inlineTestName","replace","startPatternIndex","endPatternIndex","testNameFitsInTerminal","numberOfTruncatedChars","truncatedTestName","shouldHighlightDots","removeTrimmingDots","value"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jest-watch-typeahead/build/lib/utils.js"],"sourcesContent":["import path from 'path';\nimport chalk from 'chalk';\nimport slash from 'slash';\nimport stripAnsi from 'strip-ansi';\nconst TRIMMING_DOTS = '...';\nconst ENTER = '⏎';\n\nconst relativePath = (config, testPath) => {\n  const relativeTestPath = path.relative(config.cwd || config.rootDir, testPath);\n  const dirname = path.dirname(relativeTestPath);\n  const basename = path.basename(relativeTestPath);\n  return {\n    basename,\n    dirname\n  };\n};\n\nconst colorize = (str, start, end) => chalk.dim(str.slice(0, start)) + chalk.reset(str.slice(start, end)) + chalk.dim(str.slice(end));\n\nexport const trimAndFormatPath = (pad, config, testPath, columns) => {\n  const maxLength = columns - pad;\n  const relative = relativePath(config, testPath);\n  const {\n    basename\n  } = relative;\n  let {\n    dirname\n  } = relative; // length is ok\n\n  if ((dirname + path.sep + basename).length <= maxLength) {\n    return slash(chalk.dim(dirname + path.sep) + chalk.bold(basename));\n  } // we can fit trimmed dirname and full basename\n\n\n  const basenameLength = basename.length;\n\n  if (basenameLength + 4 < maxLength) {\n    const dirnameLength = maxLength - 4 - basenameLength;\n    dirname = `${TRIMMING_DOTS}${dirname.slice(dirname.length - dirnameLength, dirname.length)}`;\n    return slash(chalk.dim(dirname + path.sep) + chalk.bold(basename));\n  }\n\n  if (basenameLength + 4 === maxLength) {\n    return slash(chalk.dim(`${TRIMMING_DOTS}${path.sep}`) + chalk.bold(basename));\n  } // can't fit dirname, but can fit trimmed basename\n\n\n  return slash(chalk.bold(`${TRIMMING_DOTS}${basename.slice(-maxLength + 3)}`));\n};\nexport const getTerminalWidth = (pipe = process.stdout) => pipe.columns;\nexport const highlight = (rawPath, filePath, pattern) => {\n  const relativePathHead = './';\n  let regexp;\n\n  try {\n    regexp = new RegExp(pattern, 'i');\n  } catch (e) {\n    return chalk.dim(filePath);\n  }\n\n  const strippedRawPath = stripAnsi(rawPath);\n  const strippedFilePath = stripAnsi(filePath);\n  const match = strippedRawPath.match(regexp);\n\n  if (!match || match.index == null) {\n    return chalk.dim(strippedFilePath);\n  }\n\n  const offset = strippedRawPath.length - strippedFilePath.length;\n  let trimLength;\n\n  if (strippedFilePath.startsWith(TRIMMING_DOTS)) {\n    trimLength = TRIMMING_DOTS.length;\n  } else if (strippedFilePath.startsWith(relativePathHead)) {\n    trimLength = relativePathHead.length;\n  } else {\n    trimLength = 0;\n  }\n\n  const start = match.index - offset;\n  const end = start + match[0].length;\n  return colorize(strippedFilePath, Math.max(start, 0), Math.max(end, trimLength));\n};\nexport const formatTestNameByPattern = (testName, pattern, width) => {\n  const inlineTestName = testName.replace(/(\\r\\n|\\n|\\r)/gm, ENTER);\n  let regexp;\n\n  try {\n    regexp = new RegExp(pattern, 'i');\n  } catch (e) {\n    return chalk.dim(inlineTestName);\n  }\n\n  const match = inlineTestName.match(regexp);\n\n  if (!match || match.index == null) {\n    return chalk.dim(inlineTestName);\n  }\n\n  const startPatternIndex = Math.max(match.index, 0);\n  const endPatternIndex = startPatternIndex + match[0].length;\n  const testNameFitsInTerminal = inlineTestName.length <= width;\n\n  if (testNameFitsInTerminal) {\n    return colorize(inlineTestName, startPatternIndex, endPatternIndex);\n  }\n\n  const numberOfTruncatedChars = TRIMMING_DOTS.length + inlineTestName.length - width;\n  const end = Math.max(endPatternIndex - numberOfTruncatedChars, 0);\n  const truncatedTestName = inlineTestName.slice(numberOfTruncatedChars);\n  const shouldHighlightDots = startPatternIndex <= numberOfTruncatedChars;\n\n  if (shouldHighlightDots) {\n    return colorize(TRIMMING_DOTS + truncatedTestName, 0, end + TRIMMING_DOTS.length);\n  }\n\n  const start = startPatternIndex - numberOfTruncatedChars;\n  return colorize(TRIMMING_DOTS + truncatedTestName, start + TRIMMING_DOTS.length, end + TRIMMING_DOTS.length);\n};\nexport const removeTrimmingDots = value => {\n  if (value.startsWith(TRIMMING_DOTS)) {\n    return value.slice(TRIMMING_DOTS.length);\n  }\n\n  return value;\n};"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,MAAjB;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,MAAMC,aAAa,GAAG,KAAtB;AACA,MAAMC,KAAK,GAAG,GAAd;;AAEA,MAAMC,YAAY,GAAG,CAACC,MAAD,EAASC,QAAT,KAAsB;EACzC,MAAMC,gBAAgB,GAAGT,IAAI,CAACU,QAAL,CAAcH,MAAM,CAACI,GAAP,IAAcJ,MAAM,CAACK,OAAnC,EAA4CJ,QAA5C,CAAzB;EACA,MAAMK,OAAO,GAAGb,IAAI,CAACa,OAAL,CAAaJ,gBAAb,CAAhB;EACA,MAAMK,QAAQ,GAAGd,IAAI,CAACc,QAAL,CAAcL,gBAAd,CAAjB;EACA,OAAO;IACLK,QADK;IAELD;EAFK,CAAP;AAID,CARD;;AAUA,MAAME,QAAQ,GAAG,CAACC,GAAD,EAAMC,KAAN,EAAaC,GAAb,KAAqBjB,KAAK,CAACkB,GAAN,CAAUH,GAAG,CAACI,KAAJ,CAAU,CAAV,EAAaH,KAAb,CAAV,IAAiChB,KAAK,CAACoB,KAAN,CAAYL,GAAG,CAACI,KAAJ,CAAUH,KAAV,EAAiBC,GAAjB,CAAZ,CAAjC,GAAsEjB,KAAK,CAACkB,GAAN,CAAUH,GAAG,CAACI,KAAJ,CAAUF,GAAV,CAAV,CAA5G;;AAEA,OAAO,MAAMI,iBAAiB,GAAG,CAACC,GAAD,EAAMhB,MAAN,EAAcC,QAAd,EAAwBgB,OAAxB,KAAoC;EACnE,MAAMC,SAAS,GAAGD,OAAO,GAAGD,GAA5B;EACA,MAAMb,QAAQ,GAAGJ,YAAY,CAACC,MAAD,EAASC,QAAT,CAA7B;EACA,MAAM;IACJM;EADI,IAEFJ,QAFJ;EAGA,IAAI;IACFG;EADE,IAEAH,QAFJ,CANmE,CAQrD;;EAEd,IAAI,CAACG,OAAO,GAAGb,IAAI,CAAC0B,GAAf,GAAqBZ,QAAtB,EAAgCa,MAAhC,IAA0CF,SAA9C,EAAyD;IACvD,OAAOvB,KAAK,CAACD,KAAK,CAACkB,GAAN,CAAUN,OAAO,GAAGb,IAAI,CAAC0B,GAAzB,IAAgCzB,KAAK,CAAC2B,IAAN,CAAWd,QAAX,CAAjC,CAAZ;EACD,CAZkE,CAYjE;;;EAGF,MAAMe,cAAc,GAAGf,QAAQ,CAACa,MAAhC;;EAEA,IAAIE,cAAc,GAAG,CAAjB,GAAqBJ,SAAzB,EAAoC;IAClC,MAAMK,aAAa,GAAGL,SAAS,GAAG,CAAZ,GAAgBI,cAAtC;IACAhB,OAAO,GAAI,GAAET,aAAc,GAAES,OAAO,CAACO,KAAR,CAAcP,OAAO,CAACc,MAAR,GAAiBG,aAA/B,EAA8CjB,OAAO,CAACc,MAAtD,CAA8D,EAA3F;IACA,OAAOzB,KAAK,CAACD,KAAK,CAACkB,GAAN,CAAUN,OAAO,GAAGb,IAAI,CAAC0B,GAAzB,IAAgCzB,KAAK,CAAC2B,IAAN,CAAWd,QAAX,CAAjC,CAAZ;EACD;;EAED,IAAIe,cAAc,GAAG,CAAjB,KAAuBJ,SAA3B,EAAsC;IACpC,OAAOvB,KAAK,CAACD,KAAK,CAACkB,GAAN,CAAW,GAAEf,aAAc,GAAEJ,IAAI,CAAC0B,GAAI,EAAtC,IAA2CzB,KAAK,CAAC2B,IAAN,CAAWd,QAAX,CAA5C,CAAZ;EACD,CAzBkE,CAyBjE;;;EAGF,OAAOZ,KAAK,CAACD,KAAK,CAAC2B,IAAN,CAAY,GAAExB,aAAc,GAAEU,QAAQ,CAACM,KAAT,CAAe,CAACK,SAAD,GAAa,CAA5B,CAA+B,EAA7D,CAAD,CAAZ;AACD,CA7BM;AA8BP,OAAO,MAAMM,gBAAgB,GAAG;EAAA,IAACC,IAAD,uEAAQC,OAAO,CAACC,MAAhB;EAAA,OAA2BF,IAAI,CAACR,OAAhC;AAAA,CAAzB;AACP,OAAO,MAAMW,SAAS,GAAG,CAACC,OAAD,EAAUC,QAAV,EAAoBC,OAApB,KAAgC;EACvD,MAAMC,gBAAgB,GAAG,IAAzB;EACA,IAAIC,MAAJ;;EAEA,IAAI;IACFA,MAAM,GAAG,IAAIC,MAAJ,CAAWH,OAAX,EAAoB,GAApB,CAAT;EACD,CAFD,CAEE,OAAOI,CAAP,EAAU;IACV,OAAOzC,KAAK,CAACkB,GAAN,CAAUkB,QAAV,CAAP;EACD;;EAED,MAAMM,eAAe,GAAGxC,SAAS,CAACiC,OAAD,CAAjC;EACA,MAAMQ,gBAAgB,GAAGzC,SAAS,CAACkC,QAAD,CAAlC;EACA,MAAMQ,KAAK,GAAGF,eAAe,CAACE,KAAhB,CAAsBL,MAAtB,CAAd;;EAEA,IAAI,CAACK,KAAD,IAAUA,KAAK,CAACC,KAAN,IAAe,IAA7B,EAAmC;IACjC,OAAO7C,KAAK,CAACkB,GAAN,CAAUyB,gBAAV,CAAP;EACD;;EAED,MAAMG,MAAM,GAAGJ,eAAe,CAAChB,MAAhB,GAAyBiB,gBAAgB,CAACjB,MAAzD;EACA,IAAIqB,UAAJ;;EAEA,IAAIJ,gBAAgB,CAACK,UAAjB,CAA4B7C,aAA5B,CAAJ,EAAgD;IAC9C4C,UAAU,GAAG5C,aAAa,CAACuB,MAA3B;EACD,CAFD,MAEO,IAAIiB,gBAAgB,CAACK,UAAjB,CAA4BV,gBAA5B,CAAJ,EAAmD;IACxDS,UAAU,GAAGT,gBAAgB,CAACZ,MAA9B;EACD,CAFM,MAEA;IACLqB,UAAU,GAAG,CAAb;EACD;;EAED,MAAM/B,KAAK,GAAG4B,KAAK,CAACC,KAAN,GAAcC,MAA5B;EACA,MAAM7B,GAAG,GAAGD,KAAK,GAAG4B,KAAK,CAAC,CAAD,CAAL,CAASlB,MAA7B;EACA,OAAOZ,QAAQ,CAAC6B,gBAAD,EAAmBM,IAAI,CAACC,GAAL,CAASlC,KAAT,EAAgB,CAAhB,CAAnB,EAAuCiC,IAAI,CAACC,GAAL,CAASjC,GAAT,EAAc8B,UAAd,CAAvC,CAAf;AACD,CAhCM;AAiCP,OAAO,MAAMI,uBAAuB,GAAG,CAACC,QAAD,EAAWf,OAAX,EAAoBgB,KAApB,KAA8B;EACnE,MAAMC,cAAc,GAAGF,QAAQ,CAACG,OAAT,CAAiB,gBAAjB,EAAmCnD,KAAnC,CAAvB;EACA,IAAImC,MAAJ;;EAEA,IAAI;IACFA,MAAM,GAAG,IAAIC,MAAJ,CAAWH,OAAX,EAAoB,GAApB,CAAT;EACD,CAFD,CAEE,OAAOI,CAAP,EAAU;IACV,OAAOzC,KAAK,CAACkB,GAAN,CAAUoC,cAAV,CAAP;EACD;;EAED,MAAMV,KAAK,GAAGU,cAAc,CAACV,KAAf,CAAqBL,MAArB,CAAd;;EAEA,IAAI,CAACK,KAAD,IAAUA,KAAK,CAACC,KAAN,IAAe,IAA7B,EAAmC;IACjC,OAAO7C,KAAK,CAACkB,GAAN,CAAUoC,cAAV,CAAP;EACD;;EAED,MAAME,iBAAiB,GAAGP,IAAI,CAACC,GAAL,CAASN,KAAK,CAACC,KAAf,EAAsB,CAAtB,CAA1B;EACA,MAAMY,eAAe,GAAGD,iBAAiB,GAAGZ,KAAK,CAAC,CAAD,CAAL,CAASlB,MAArD;EACA,MAAMgC,sBAAsB,GAAGJ,cAAc,CAAC5B,MAAf,IAAyB2B,KAAxD;;EAEA,IAAIK,sBAAJ,EAA4B;IAC1B,OAAO5C,QAAQ,CAACwC,cAAD,EAAiBE,iBAAjB,EAAoCC,eAApC,CAAf;EACD;;EAED,MAAME,sBAAsB,GAAGxD,aAAa,CAACuB,MAAd,GAAuB4B,cAAc,CAAC5B,MAAtC,GAA+C2B,KAA9E;EACA,MAAMpC,GAAG,GAAGgC,IAAI,CAACC,GAAL,CAASO,eAAe,GAAGE,sBAA3B,EAAmD,CAAnD,CAAZ;EACA,MAAMC,iBAAiB,GAAGN,cAAc,CAACnC,KAAf,CAAqBwC,sBAArB,CAA1B;EACA,MAAME,mBAAmB,GAAGL,iBAAiB,IAAIG,sBAAjD;;EAEA,IAAIE,mBAAJ,EAAyB;IACvB,OAAO/C,QAAQ,CAACX,aAAa,GAAGyD,iBAAjB,EAAoC,CAApC,EAAuC3C,GAAG,GAAGd,aAAa,CAACuB,MAA3D,CAAf;EACD;;EAED,MAAMV,KAAK,GAAGwC,iBAAiB,GAAGG,sBAAlC;EACA,OAAO7C,QAAQ,CAACX,aAAa,GAAGyD,iBAAjB,EAAoC5C,KAAK,GAAGb,aAAa,CAACuB,MAA1D,EAAkET,GAAG,GAAGd,aAAa,CAACuB,MAAtF,CAAf;AACD,CAnCM;AAoCP,OAAO,MAAMoC,kBAAkB,GAAGC,KAAK,IAAI;EACzC,IAAIA,KAAK,CAACf,UAAN,CAAiB7C,aAAjB,CAAJ,EAAqC;IACnC,OAAO4D,KAAK,CAAC5C,KAAN,CAAYhB,aAAa,CAACuB,MAA1B,CAAP;EACD;;EAED,OAAOqC,KAAP;AACD,CANM"},"metadata":{},"sourceType":"module"}