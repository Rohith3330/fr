{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\n\nconst codegen_1 = require(\"../codegen\");\n\nconst names_1 = require(\"../names\");\n\nconst code_1 = require(\"../../vocabularies/code\");\n\nconst errors_1 = require(\"../errors\");\n\nfunction macroKeywordCode(cxt, def) {\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    it\n  } = cxt;\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n  const schemaRef = useKeyword(gen, keyword, macroSchema);\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);\n  const valid = gen.name(\"valid\");\n  cxt.subschema({\n    schema: macroSchema,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n    topSchemaRef: schemaRef,\n    compositeRule: true\n  }, valid);\n  cxt.pass(valid, () => cxt.error(true));\n}\n\nexports.macroKeywordCode = macroKeywordCode;\n\nfunction funcKeywordCode(cxt, def) {\n  var _a;\n\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    $data,\n    it\n  } = cxt;\n  checkAsyncKeyword(it, def);\n  const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n  const validateRef = useKeyword(gen, keyword, validate);\n  const valid = gen.let(\"valid\");\n  cxt.block$data(valid, validateKeyword);\n  cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n\n  function validateKeyword() {\n    if (def.errors === false) {\n      assignValid();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => cxt.error());\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => addErrs(cxt, ruleErrs));\n    }\n  }\n\n  function validateAsync() {\n    const ruleErrs = gen.let(\"ruleErrs\", null);\n    gen.try(() => assignValid((0, codegen_1._)`await `), e => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));\n    return ruleErrs;\n  }\n\n  function validateSync() {\n    const validateErrs = (0, codegen_1._)`${validateRef}.errors`;\n    gen.assign(validateErrs, null);\n    assignValid(codegen_1.nil);\n    return validateErrs;\n  }\n\n  function assignValid() {\n    let _await = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : def.async ? (0, codegen_1._)`await ` : codegen_1.nil;\n\n    const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n    const passSchema = !(\"compile\" in def && !$data || def.schema === false);\n    gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n  }\n\n  function reportErrs(errors) {\n    var _a;\n\n    gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n  }\n}\n\nexports.funcKeywordCode = funcKeywordCode;\n\nfunction modifyData(cxt) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));\n}\n\nfunction addErrs(cxt, errs) {\n  const {\n    gen\n  } = cxt;\n  gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {\n    gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);\n    (0, errors_1.extendErrors)(cxt);\n  }, () => cxt.error());\n}\n\nfunction checkAsyncKeyword(_ref, def) {\n  let {\n    schemaEnv\n  } = _ref;\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\");\n}\n\nfunction useKeyword(gen, keyword, result) {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`);\n  return gen.scopeValue(\"keyword\", typeof result == \"function\" ? {\n    ref: result\n  } : {\n    ref: result,\n    code: (0, codegen_1.stringify)(result)\n  });\n}\n\nfunction validSchemaType(schema, schemaType) {\n  let allowUndefined = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // TODO add tests\n  return !schemaType.length || schemaType.some(st => st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\");\n}\n\nexports.validSchemaType = validSchemaType;\n\nfunction validateKeywordUsage(_ref2, def, keyword) {\n  let {\n    schema,\n    opts,\n    self,\n    errSchemaPath\n  } = _ref2;\n\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\");\n  }\n\n  const deps = def.dependencies;\n\n  if (deps === null || deps === void 0 ? void 0 : deps.some(kwd => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword]);\n\n    if (!valid) {\n      const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` + self.errorsText(def.validateSchema.errors);\n      if (opts.validateSchema === \"log\") self.logger.error(msg);else throw new Error(msg);\n    }\n  }\n}\n\nexports.validateKeywordUsage = validateKeywordUsage;","map":{"version":3,"mappings":"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","names":["macroKeywordCode","cxt","def","gen","keyword","schema","parentSchema","it","macroSchema","macro","call","self","schemaRef","useKeyword","opts","validateSchema","valid","name","subschema","schemaPath","codegen_1","errSchemaPath","topSchemaRef","compositeRule","pass","error","exports","funcKeywordCode","$data","checkAsyncKeyword","validate","compile","validateRef","let","block$data","validateKeyword","ok","_a","errors","assignValid","modifying","modifyData","reportErrs","ruleErrs","async","validateAsync","validateSync","addErrs","try","e","assign","if","ValidationError","throw","validateErrs","_await","passCxt","passContext","names_1","this","passSchema","data","parentData","parentDataProperty","errs","vErrors","schemaEnv","$async","Error","result","undefined","scopeValue","ref","code","validSchemaType","schemaType","allowUndefined","length","some","st","Array","isArray","validateKeywordUsage","includes","deps","dependencies","kwd","Object","prototype","hasOwnProperty","join","msg","errorsText","logger"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-webpack-plugin\\node_modules\\ajv\\lib\\compile\\validate\\keyword.ts"],"sourcesContent":["import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}