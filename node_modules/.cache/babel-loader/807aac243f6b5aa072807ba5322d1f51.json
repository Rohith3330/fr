{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'prefer-nullish-coalescing',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce using the nullish coalescing operator instead of logical chaining',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    hasSuggestions: true,\n    messages: {\n      preferNullishOverOr: 'Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.',\n      preferNullishOverTernary: 'Prefer using nullish coalescing operator (`??`) instead of a ternary expression, as it is simpler to read.',\n      suggestNullish: 'Fix to nullish coalescing operator (`??`).'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreConditionalTests: {\n          type: 'boolean'\n        },\n        ignoreTernaryTests: {\n          type: 'boolean'\n        },\n        ignoreMixedLogicalExpressions: {\n          type: 'boolean'\n        },\n        forceSuggestionFixer: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    ignoreConditionalTests: true,\n    ignoreTernaryTests: true,\n    ignoreMixedLogicalExpressions: true\n  }],\n\n  create(context, _ref) {\n    let [{\n      ignoreConditionalTests,\n      ignoreTernaryTests,\n      ignoreMixedLogicalExpressions\n    }] = _ref;\n    const parserServices = util.getParserServices(context);\n    const sourceCode = context.getSourceCode();\n    const checker = parserServices.program.getTypeChecker();\n    return {\n      ConditionalExpression(node) {\n        if (ignoreTernaryTests) {\n          return;\n        }\n\n        let operator;\n        let nodesInsideTestExpression = [];\n\n        if (node.test.type === utils_1.AST_NODE_TYPES.BinaryExpression) {\n          nodesInsideTestExpression = [node.test.left, node.test.right];\n\n          if (node.test.operator === '==' || node.test.operator === '!=' || node.test.operator === '===' || node.test.operator === '!==') {\n            operator = node.test.operator;\n          }\n        } else if (node.test.type === utils_1.AST_NODE_TYPES.LogicalExpression && node.test.left.type === utils_1.AST_NODE_TYPES.BinaryExpression && node.test.right.type === utils_1.AST_NODE_TYPES.BinaryExpression) {\n          nodesInsideTestExpression = [node.test.left.left, node.test.left.right, node.test.right.left, node.test.right.right];\n\n          if (node.test.operator === '||') {\n            if (node.test.left.operator === '===' && node.test.right.operator === '===') {\n              operator = '===';\n            } else if ((node.test.left.operator === '===' || node.test.right.operator === '===') && (node.test.left.operator === '==' || node.test.right.operator === '==') || node.test.left.operator === '==' && node.test.right.operator === '==') {\n              operator = '==';\n            }\n          } else if (node.test.operator === '&&') {\n            if (node.test.left.operator === '!==' && node.test.right.operator === '!==') {\n              operator = '!==';\n            } else if ((node.test.left.operator === '!==' || node.test.right.operator === '!==') && (node.test.left.operator === '!=' || node.test.right.operator === '!=') || node.test.left.operator === '!=' && node.test.right.operator === '!=') {\n              operator = '!=';\n            }\n          }\n        }\n\n        if (!operator) {\n          return;\n        }\n\n        let identifier;\n        let hasUndefinedCheck = false;\n        let hasNullCheck = false; // we check that the test only contains null, undefined and the identifier\n\n        for (const testNode of nodesInsideTestExpression) {\n          if (util.isNullLiteral(testNode)) {\n            hasNullCheck = true;\n          } else if (util.isUndefinedIdentifier(testNode)) {\n            hasUndefinedCheck = true;\n          } else if ((operator === '!==' || operator === '!=') && util.isNodeEqual(testNode, node.consequent)) {\n            identifier = testNode;\n          } else if ((operator === '===' || operator === '==') && util.isNodeEqual(testNode, node.alternate)) {\n            identifier = testNode;\n          } else {\n            return;\n          }\n        }\n\n        if (!identifier) {\n          return;\n        }\n\n        const isFixable = (() => {\n          // it is fixable if we check for both null and undefined, or not if neither\n          if (hasUndefinedCheck === hasNullCheck) {\n            return hasUndefinedCheck;\n          } // it is fixable if we loosely check for either null or undefined\n\n\n          if (operator === '==' || operator === '!=') {\n            return true;\n          }\n\n          const tsNode = parserServices.esTreeNodeToTSNodeMap.get(identifier);\n          const type = checker.getTypeAtLocation(tsNode);\n          const flags = util.getTypeFlags(type);\n\n          if (flags & (ts.TypeFlags.Any | ts.TypeFlags.Unknown)) {\n            return false;\n          }\n\n          const hasNullType = (flags & ts.TypeFlags.Null) !== 0; // it is fixable if we check for undefined and the type is not nullable\n\n          if (hasUndefinedCheck && !hasNullType) {\n            return true;\n          }\n\n          const hasUndefinedType = (flags & ts.TypeFlags.Undefined) !== 0; // it is fixable if we check for null and the type can't be undefined\n\n          return hasNullCheck && !hasUndefinedType;\n        })();\n\n        if (isFixable) {\n          context.report({\n            node,\n            messageId: 'preferNullishOverTernary',\n            suggest: [{\n              messageId: 'suggestNullish',\n\n              fix(fixer) {\n                const [left, right] = operator === '===' || operator === '==' ? [node.alternate, node.consequent] : [node.consequent, node.alternate];\n                return fixer.replaceText(node, `${sourceCode.text.slice(left.range[0], left.range[1])} ?? ${sourceCode.text.slice(right.range[0], right.range[1])}`);\n              }\n\n            }]\n          });\n        }\n      },\n\n      'LogicalExpression[operator = \"||\"]'(node) {\n        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n        const type = checker.getTypeAtLocation(tsNode.left);\n        const isNullish = util.isNullableType(type, {\n          allowUndefined: true\n        });\n\n        if (!isNullish) {\n          return;\n        }\n\n        if (ignoreConditionalTests === true && isConditionalTest(node)) {\n          return;\n        }\n\n        const isMixedLogical = isMixedLogicalExpression(node);\n\n        if (ignoreMixedLogicalExpressions === true && isMixedLogical) {\n          return;\n        }\n\n        const barBarOperator = util.nullThrows(sourceCode.getTokenAfter(node.left, token => token.type === utils_1.AST_TOKEN_TYPES.Punctuator && token.value === node.operator), util.NullThrowsReasons.MissingToken('operator', node.type));\n\n        function* fix(fixer) {\n          if (node.parent && util.isLogicalOrOperator(node.parent)) {\n            // '&&' and '??' operations cannot be mixed without parentheses (e.g. a && b ?? c)\n            if (node.left.type === utils_1.AST_NODE_TYPES.LogicalExpression && !util.isLogicalOrOperator(node.left.left)) {\n              yield fixer.insertTextBefore(node.left.right, '(');\n            } else {\n              yield fixer.insertTextBefore(node.left, '(');\n            }\n\n            yield fixer.insertTextAfter(node.right, ')');\n          }\n\n          yield fixer.replaceText(barBarOperator, '??');\n        }\n\n        context.report({\n          node: barBarOperator,\n          messageId: 'preferNullishOverOr',\n          suggest: [{\n            messageId: 'suggestNullish',\n            fix\n          }]\n        });\n      }\n\n    };\n  }\n\n});\n\nfunction isConditionalTest(node) {\n  const parents = new Set([node]);\n  let current = node.parent;\n\n  while (current) {\n    parents.add(current);\n\n    if ((current.type === utils_1.AST_NODE_TYPES.ConditionalExpression || current.type === utils_1.AST_NODE_TYPES.DoWhileStatement || current.type === utils_1.AST_NODE_TYPES.IfStatement || current.type === utils_1.AST_NODE_TYPES.ForStatement || current.type === utils_1.AST_NODE_TYPES.WhileStatement) && parents.has(current.test)) {\n      return true;\n    }\n\n    if ([utils_1.AST_NODE_TYPES.ArrowFunctionExpression, utils_1.AST_NODE_TYPES.FunctionExpression].includes(current.type)) {\n      /**\n       * This is a weird situation like:\n       * `if (() => a || b) {}`\n       * `if (function () { return a || b }) {}`\n       */\n      return false;\n    }\n\n    current = current.parent;\n  }\n\n  return false;\n}\n\nfunction isMixedLogicalExpression(node) {\n  const seen = new Set();\n  const queue = [node.parent, node.left, node.right];\n\n  for (const current of queue) {\n    if (seen.has(current)) {\n      continue;\n    }\n\n    seen.add(current);\n\n    if (current && current.type === utils_1.AST_NODE_TYPES.LogicalExpression) {\n      if (current.operator === '&&') {\n        return true;\n      } else if (current.operator === '||') {\n        // check the pieces of the node to catch cases like `a || b || c && d`\n        queue.push(current.parent, current.left, current.right);\n      }\n    }\n  }\n\n  return false;\n}","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","hasSuggestions","messages","preferNullishOverOr","preferNullishOverTernary","suggestNullish","schema","properties","ignoreConditionalTests","ignoreTernaryTests","ignoreMixedLogicalExpressions","forceSuggestionFixer","additionalProperties","defaultOptions","create","context","parserServices","getParserServices","sourceCode","getSourceCode","checker","program","getTypeChecker","ConditionalExpression","node","operator","nodesInsideTestExpression","test","utils_1","BinaryExpression","left","right","LogicalExpression","identifier","hasUndefinedCheck","hasNullCheck","testNode","isNullLiteral","isUndefinedIdentifier","isNodeEqual","consequent","alternate","isFixable","tsNode","esTreeNodeToTSNodeMap","get","getTypeAtLocation","flags","getTypeFlags","ts","TypeFlags","Any","Unknown","hasNullType","Null","hasUndefinedType","Undefined","report","messageId","suggest","fix","fixer","replaceText","text","slice","range","isNullish","isNullableType","allowUndefined","isConditionalTest","isMixedLogical","isMixedLogicalExpression","barBarOperator","nullThrows","getTokenAfter","token","Punctuator","value","NullThrowsReasons","MissingToken","parent","isLogicalOrOperator","insertTextBefore","insertTextAfter","parents","Set","current","add","DoWhileStatement","IfStatement","ForStatement","WhileStatement","has","ArrowFunctionExpression","FunctionExpression","includes","seen","queue","push"],"sources":["../../src/rules/prefer-nullish-coalescing.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}