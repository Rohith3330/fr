{"ast":null,"code":"import LRU from 'quick-lru';\nimport * as sharedState from './sharedState';\nimport { generateRules } from './generateRules';\nimport bigSign from '../util/bigSign';\nimport log from '../util/log';\nimport cloneNodes from '../util/cloneNodes';\nimport { defaultExtractor } from './defaultExtractor';\nlet env = sharedState.env;\nconst builtInExtractors = {\n  DEFAULT: defaultExtractor\n};\nconst builtInTransformers = {\n  DEFAULT: content => content,\n  svelte: content => content.replace(/(?:^|\\s)class:/g, ' ')\n};\n\nfunction getExtractor(context, fileExtension) {\n  let extractors = context.tailwindConfig.content.extract;\n  return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);\n}\n\nfunction getTransformer(tailwindConfig, fileExtension) {\n  let transformers = tailwindConfig.content.transform;\n  return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;\n}\n\nlet extractorCache = new WeakMap(); // Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though — if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\n\nfunction getClassCandidates(content, extractor, candidates, seen) {\n  if (!extractorCache.has(extractor)) {\n    extractorCache.set(extractor, new LRU({\n      maxSize: 25000\n    }));\n  }\n\n  for (let line of content.split('\\n')) {\n    line = line.trim();\n\n    if (seen.has(line)) {\n      continue;\n    }\n\n    seen.add(line);\n\n    if (extractorCache.get(extractor).has(line)) {\n      for (let match of extractorCache.get(extractor).get(line)) {\n        candidates.add(match);\n      }\n    } else {\n      let extractorMatches = extractor(line).filter(s => s !== '!*');\n      let lineMatchesSet = new Set(extractorMatches);\n\n      for (let match of lineMatchesSet) {\n        candidates.add(match);\n      }\n\n      extractorCache.get(extractor).set(line, lineMatchesSet);\n    }\n  }\n}\n\nfunction buildStylesheet(rules, context) {\n  let sortedRules = rules.sort((_ref, _ref2) => {\n    let [a] = _ref;\n    let [z] = _ref2;\n    return bigSign(a - z);\n  });\n  let returnValue = {\n    base: new Set(),\n    defaults: new Set(),\n    components: new Set(),\n    utilities: new Set(),\n    variants: new Set(),\n    // All the CSS that is not Tailwind related can be put in this bucket. This\n    // will make it easier to later use this information when we want to\n    // `@apply` for example. The main reason we do this here is because we\n    // still need to make sure the order is correct. Last but not least, we\n    // will make sure to always re-inject this section into the css, even if\n    // certain rules were not used. This means that it will look like a no-op\n    // from the user's perspective, but we gathered all the useful information\n    // we need.\n    user: new Set()\n  };\n\n  for (let [sort, rule] of sortedRules) {\n    if (sort >= context.minimumScreen) {\n      returnValue.variants.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.base) {\n      returnValue.base.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.defaults) {\n      returnValue.defaults.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.components) {\n      returnValue.components.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.utilities) {\n      returnValue.utilities.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.user) {\n      returnValue.user.add(rule);\n      continue;\n    }\n  }\n\n  return returnValue;\n}\n\nexport default function expandTailwindAtRules(context) {\n  return root => {\n    let layerNodes = {\n      base: null,\n      components: null,\n      utilities: null,\n      variants: null\n    };\n    root.walkAtRules(rule => {\n      // Make sure this file contains Tailwind directives. If not, we can save\n      // a lot of work and bail early. Also we don't have to register our touch\n      // file as a dependency since the output of this CSS does not depend on\n      // the source of any templates. Think Vue <style> blocks for example.\n      if (rule.name === 'tailwind') {\n        if (Object.keys(layerNodes).includes(rule.params)) {\n          layerNodes[rule.params] = rule;\n        }\n      }\n    });\n\n    if (Object.values(layerNodes).every(n => n === null)) {\n      return root;\n    } // ---\n    // Find potential rules in changed files\n\n\n    let candidates = new Set([sharedState.NOT_ON_DEMAND]);\n    let seen = new Set();\n    env.DEBUG && console.time('Reading changed files');\n\n    for (let {\n      content,\n      extension\n    } of context.changedContent) {\n      let transformer = getTransformer(context.tailwindConfig, extension);\n      let extractor = getExtractor(context, extension);\n      getClassCandidates(transformer(content), extractor, candidates, seen);\n    }\n\n    env.DEBUG && console.timeEnd('Reading changed files'); // ---\n    // Generate the actual CSS\n\n    let classCacheCount = context.classCache.size;\n    env.DEBUG && console.time('Generate rules');\n    let rules = generateRules(candidates, context);\n    env.DEBUG && console.timeEnd('Generate rules'); // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n\n    env.DEBUG && console.time('Build stylesheet');\n\n    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n      for (let rule of rules) {\n        context.ruleCache.add(rule);\n      }\n\n      context.stylesheetCache = buildStylesheet([...context.ruleCache], context);\n    }\n\n    env.DEBUG && console.timeEnd('Build stylesheet');\n    let {\n      defaults: defaultNodes,\n      base: baseNodes,\n      components: componentNodes,\n      utilities: utilityNodes,\n      variants: screenNodes\n    } = context.stylesheetCache; // ---\n    // Replace any Tailwind directives with generated CSS\n\n    if (layerNodes.base) {\n      layerNodes.base.before(cloneNodes([...baseNodes, ...defaultNodes], layerNodes.base.source, {\n        layer: 'base'\n      }));\n      layerNodes.base.remove();\n    }\n\n    if (layerNodes.components) {\n      layerNodes.components.before(cloneNodes([...componentNodes], layerNodes.components.source, {\n        layer: 'components'\n      }));\n      layerNodes.components.remove();\n    }\n\n    if (layerNodes.utilities) {\n      layerNodes.utilities.before(cloneNodes([...utilityNodes], layerNodes.utilities.source, {\n        layer: 'utilities'\n      }));\n      layerNodes.utilities.remove();\n    } // We do post-filtering to not alter the emitted order of the variants\n\n\n    const variantNodes = Array.from(screenNodes).filter(node => {\n      const parentLayer = node.raws.tailwind?.parentLayer;\n\n      if (parentLayer === 'components') {\n        return layerNodes.components !== null;\n      }\n\n      if (parentLayer === 'utilities') {\n        return layerNodes.utilities !== null;\n      }\n\n      return true;\n    });\n\n    if (layerNodes.variants) {\n      layerNodes.variants.before(cloneNodes(variantNodes, layerNodes.variants.source, {\n        layer: 'variants'\n      }));\n      layerNodes.variants.remove();\n    } else if (variantNodes.length > 0) {\n      root.append(cloneNodes(variantNodes, root.source, {\n        layer: 'variants'\n      }));\n    } // If we've got a utility layer and no utilities are generated there's likely something wrong\n\n\n    const hasUtilityVariants = variantNodes.some(node => node.raws.tailwind?.parentLayer === 'utilities');\n\n    if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {\n      log.warn('content-problems', ['No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.', 'https://tailwindcss.com/docs/content-configuration']);\n    } // ---\n\n\n    if (env.DEBUG) {\n      console.log('Potential classes: ', candidates.size);\n      console.log('Active contexts: ', sharedState.contextSourcesMap.size);\n    } // Clear the cache for the changed files\n\n\n    context.changedContent = []; // Cleanup any leftover @layer atrules\n\n    root.walkAtRules('layer', rule => {\n      if (Object.keys(layerNodes).includes(rule.params)) {\n        rule.remove();\n      }\n    });\n  };\n}","map":{"version":3,"names":["LRU","sharedState","generateRules","bigSign","log","cloneNodes","defaultExtractor","env","builtInExtractors","DEFAULT","builtInTransformers","content","svelte","replace","getExtractor","context","fileExtension","extractors","tailwindConfig","extract","getTransformer","transformers","transform","extractorCache","WeakMap","getClassCandidates","extractor","candidates","seen","has","set","maxSize","line","split","trim","add","get","match","extractorMatches","filter","s","lineMatchesSet","Set","buildStylesheet","rules","sortedRules","sort","a","z","returnValue","base","defaults","components","utilities","variants","user","rule","minimumScreen","layerOrder","expandTailwindAtRules","root","layerNodes","walkAtRules","name","Object","keys","includes","params","values","every","n","NOT_ON_DEMAND","DEBUG","console","time","extension","changedContent","transformer","timeEnd","classCacheCount","classCache","size","stylesheetCache","ruleCache","defaultNodes","baseNodes","componentNodes","utilityNodes","screenNodes","before","source","layer","remove","variantNodes","Array","from","node","parentLayer","raws","tailwind","length","append","hasUtilityVariants","some","warn","contextSourcesMap"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/src/lib/expandTailwindAtRules.js"],"sourcesContent":["import LRU from 'quick-lru'\nimport * as sharedState from './sharedState'\nimport { generateRules } from './generateRules'\nimport bigSign from '../util/bigSign'\nimport log from '../util/log'\nimport cloneNodes from '../util/cloneNodes'\nimport { defaultExtractor } from './defaultExtractor'\n\nlet env = sharedState.env\n\nconst builtInExtractors = {\n  DEFAULT: defaultExtractor,\n}\n\nconst builtInTransformers = {\n  DEFAULT: (content) => content,\n  svelte: (content) => content.replace(/(?:^|\\s)class:/g, ' '),\n}\n\nfunction getExtractor(context, fileExtension) {\n  let extractors = context.tailwindConfig.content.extract\n\n  return (\n    extractors[fileExtension] ||\n    extractors.DEFAULT ||\n    builtInExtractors[fileExtension] ||\n    builtInExtractors.DEFAULT(context)\n  )\n}\n\nfunction getTransformer(tailwindConfig, fileExtension) {\n  let transformers = tailwindConfig.content.transform\n\n  return (\n    transformers[fileExtension] ||\n    transformers.DEFAULT ||\n    builtInTransformers[fileExtension] ||\n    builtInTransformers.DEFAULT\n  )\n}\n\nlet extractorCache = new WeakMap()\n\n// Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though — if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\nfunction getClassCandidates(content, extractor, candidates, seen) {\n  if (!extractorCache.has(extractor)) {\n    extractorCache.set(extractor, new LRU({ maxSize: 25000 }))\n  }\n\n  for (let line of content.split('\\n')) {\n    line = line.trim()\n\n    if (seen.has(line)) {\n      continue\n    }\n    seen.add(line)\n\n    if (extractorCache.get(extractor).has(line)) {\n      for (let match of extractorCache.get(extractor).get(line)) {\n        candidates.add(match)\n      }\n    } else {\n      let extractorMatches = extractor(line).filter((s) => s !== '!*')\n      let lineMatchesSet = new Set(extractorMatches)\n\n      for (let match of lineMatchesSet) {\n        candidates.add(match)\n      }\n\n      extractorCache.get(extractor).set(line, lineMatchesSet)\n    }\n  }\n}\n\nfunction buildStylesheet(rules, context) {\n  let sortedRules = rules.sort(([a], [z]) => bigSign(a - z))\n\n  let returnValue = {\n    base: new Set(),\n    defaults: new Set(),\n    components: new Set(),\n    utilities: new Set(),\n    variants: new Set(),\n\n    // All the CSS that is not Tailwind related can be put in this bucket. This\n    // will make it easier to later use this information when we want to\n    // `@apply` for example. The main reason we do this here is because we\n    // still need to make sure the order is correct. Last but not least, we\n    // will make sure to always re-inject this section into the css, even if\n    // certain rules were not used. This means that it will look like a no-op\n    // from the user's perspective, but we gathered all the useful information\n    // we need.\n    user: new Set(),\n  }\n\n  for (let [sort, rule] of sortedRules) {\n    if (sort >= context.minimumScreen) {\n      returnValue.variants.add(rule)\n      continue\n    }\n\n    if (sort & context.layerOrder.base) {\n      returnValue.base.add(rule)\n      continue\n    }\n\n    if (sort & context.layerOrder.defaults) {\n      returnValue.defaults.add(rule)\n      continue\n    }\n\n    if (sort & context.layerOrder.components) {\n      returnValue.components.add(rule)\n      continue\n    }\n\n    if (sort & context.layerOrder.utilities) {\n      returnValue.utilities.add(rule)\n      continue\n    }\n\n    if (sort & context.layerOrder.user) {\n      returnValue.user.add(rule)\n      continue\n    }\n  }\n\n  return returnValue\n}\n\nexport default function expandTailwindAtRules(context) {\n  return (root) => {\n    let layerNodes = {\n      base: null,\n      components: null,\n      utilities: null,\n      variants: null,\n    }\n\n    root.walkAtRules((rule) => {\n      // Make sure this file contains Tailwind directives. If not, we can save\n      // a lot of work and bail early. Also we don't have to register our touch\n      // file as a dependency since the output of this CSS does not depend on\n      // the source of any templates. Think Vue <style> blocks for example.\n      if (rule.name === 'tailwind') {\n        if (Object.keys(layerNodes).includes(rule.params)) {\n          layerNodes[rule.params] = rule\n        }\n      }\n    })\n\n    if (Object.values(layerNodes).every((n) => n === null)) {\n      return root\n    }\n\n    // ---\n\n    // Find potential rules in changed files\n    let candidates = new Set([sharedState.NOT_ON_DEMAND])\n    let seen = new Set()\n\n    env.DEBUG && console.time('Reading changed files')\n\n    for (let { content, extension } of context.changedContent) {\n      let transformer = getTransformer(context.tailwindConfig, extension)\n      let extractor = getExtractor(context, extension)\n      getClassCandidates(transformer(content), extractor, candidates, seen)\n    }\n\n    env.DEBUG && console.timeEnd('Reading changed files')\n\n    // ---\n\n    // Generate the actual CSS\n    let classCacheCount = context.classCache.size\n\n    env.DEBUG && console.time('Generate rules')\n    let rules = generateRules(candidates, context)\n    env.DEBUG && console.timeEnd('Generate rules')\n\n    // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n    env.DEBUG && console.time('Build stylesheet')\n    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n      for (let rule of rules) {\n        context.ruleCache.add(rule)\n      }\n\n      context.stylesheetCache = buildStylesheet([...context.ruleCache], context)\n    }\n    env.DEBUG && console.timeEnd('Build stylesheet')\n\n    let {\n      defaults: defaultNodes,\n      base: baseNodes,\n      components: componentNodes,\n      utilities: utilityNodes,\n      variants: screenNodes,\n    } = context.stylesheetCache\n\n    // ---\n\n    // Replace any Tailwind directives with generated CSS\n\n    if (layerNodes.base) {\n      layerNodes.base.before(\n        cloneNodes([...baseNodes, ...defaultNodes], layerNodes.base.source, {\n          layer: 'base',\n        })\n      )\n      layerNodes.base.remove()\n    }\n\n    if (layerNodes.components) {\n      layerNodes.components.before(\n        cloneNodes([...componentNodes], layerNodes.components.source, {\n          layer: 'components',\n        })\n      )\n      layerNodes.components.remove()\n    }\n\n    if (layerNodes.utilities) {\n      layerNodes.utilities.before(\n        cloneNodes([...utilityNodes], layerNodes.utilities.source, {\n          layer: 'utilities',\n        })\n      )\n      layerNodes.utilities.remove()\n    }\n\n    // We do post-filtering to not alter the emitted order of the variants\n    const variantNodes = Array.from(screenNodes).filter((node) => {\n      const parentLayer = node.raws.tailwind?.parentLayer\n\n      if (parentLayer === 'components') {\n        return layerNodes.components !== null\n      }\n\n      if (parentLayer === 'utilities') {\n        return layerNodes.utilities !== null\n      }\n\n      return true\n    })\n\n    if (layerNodes.variants) {\n      layerNodes.variants.before(\n        cloneNodes(variantNodes, layerNodes.variants.source, {\n          layer: 'variants',\n        })\n      )\n      layerNodes.variants.remove()\n    } else if (variantNodes.length > 0) {\n      root.append(\n        cloneNodes(variantNodes, root.source, {\n          layer: 'variants',\n        })\n      )\n    }\n\n    // If we've got a utility layer and no utilities are generated there's likely something wrong\n    const hasUtilityVariants = variantNodes.some(\n      (node) => node.raws.tailwind?.parentLayer === 'utilities'\n    )\n\n    if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {\n      log.warn('content-problems', [\n        'No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.',\n        'https://tailwindcss.com/docs/content-configuration',\n      ])\n    }\n\n    // ---\n\n    if (env.DEBUG) {\n      console.log('Potential classes: ', candidates.size)\n      console.log('Active contexts: ', sharedState.contextSourcesMap.size)\n    }\n\n    // Clear the cache for the changed files\n    context.changedContent = []\n\n    // Cleanup any leftover @layer atrules\n    root.walkAtRules('layer', (rule) => {\n      if (Object.keys(layerNodes).includes(rule.params)) {\n        rule.remove()\n      }\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}