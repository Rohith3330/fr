{"ast":null,"code":"/**\n * @fileoverview Validate JSX maximum depth\n * @author Chris<wfsr@foxmail.com>\n */\n'use strict';\n\nconst has = require('object.hasown/polyfill')();\n\nconst includes = require('array-includes');\n\nconst variableUtil = require('../util/variable');\n\nconst jsxUtil = require('../util/jsx');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst reportC = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst messages = {\n  wrongDepth: 'Expected the depth of nested jsx elements to be <= {{needed}}, but found {{found}}.'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce JSX maximum depth',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-max-depth')\n    },\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        max: {\n          type: 'integer',\n          minimum: 0\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const DEFAULT_DEPTH = 2;\n    const option = context.options[0] || {};\n    const maxDepth = has(option, 'max') ? option.max : DEFAULT_DEPTH;\n\n    function isExpression(node) {\n      return node.type === 'JSXExpressionContainer';\n    }\n\n    function hasJSX(node) {\n      return jsxUtil.isJSX(node) || isExpression(node) && jsxUtil.isJSX(node.expression);\n    }\n\n    function isLeaf(node) {\n      const children = node.children;\n      return !children || children.length === 0 || !children.some(hasJSX);\n    }\n\n    function getDepth(node) {\n      let count = 0;\n\n      while (jsxUtil.isJSX(node.parent) || isExpression(node.parent)) {\n        node = node.parent;\n\n        if (jsxUtil.isJSX(node)) {\n          count += 1;\n        }\n      }\n\n      return count;\n    }\n\n    function report(node, depth) {\n      reportC(context, messages.wrongDepth, 'wrongDepth', {\n        node,\n        data: {\n          found: depth,\n          needed: maxDepth\n        }\n      });\n    }\n\n    function findJSXElementOrFragment(variables, name, previousReferences) {\n      function find(refs, prevRefs) {\n        for (let i = refs.length - 1; i >= 0; i--) {\n          if (has(refs[i], 'writeExpr')) {\n            const writeExpr = refs[i].writeExpr;\n            return jsxUtil.isJSX(writeExpr) && writeExpr || writeExpr && writeExpr.type === 'Identifier' && findJSXElementOrFragment(variables, writeExpr.name, prevRefs);\n          }\n        }\n\n        return null;\n      }\n\n      const variable = variableUtil.getVariable(variables, name);\n\n      if (variable && variable.references) {\n        const containDuplicates = previousReferences.some(ref => includes(variable.references, ref)); // Prevent getting stuck in circular references\n\n        if (containDuplicates) {\n          return false;\n        }\n\n        return find(variable.references, previousReferences.concat(variable.references));\n      }\n\n      return false;\n    }\n\n    function checkDescendant(baseDepth, children) {\n      baseDepth += 1;\n      (children || []).forEach(node => {\n        if (!hasJSX(node)) {\n          return;\n        }\n\n        if (baseDepth > maxDepth) {\n          report(node, baseDepth);\n        } else if (!isLeaf(node)) {\n          checkDescendant(baseDepth, node.children);\n        }\n      });\n    }\n\n    function handleJSX(node) {\n      if (!isLeaf(node)) {\n        return;\n      }\n\n      const depth = getDepth(node);\n\n      if (depth > maxDepth) {\n        report(node, depth);\n      }\n    }\n\n    return {\n      JSXElement: handleJSX,\n      JSXFragment: handleJSX,\n\n      JSXExpressionContainer(node) {\n        if (node.expression.type !== 'Identifier') {\n          return;\n        }\n\n        const variables = variableUtil.variablesInScope(context);\n        const element = findJSXElementOrFragment(variables, node.expression.name, []);\n\n        if (element) {\n          const baseDepth = getDepth(node);\n          checkDescendant(baseDepth, element.children);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["has","require","includes","variableUtil","jsxUtil","docsUrl","reportC","messages","wrongDepth","module","exports","meta","docs","description","category","recommended","url","schema","type","properties","max","minimum","additionalProperties","create","context","DEFAULT_DEPTH","option","options","maxDepth","isExpression","node","hasJSX","isJSX","expression","isLeaf","children","length","some","getDepth","count","parent","report","depth","data","found","needed","findJSXElementOrFragment","variables","name","previousReferences","find","refs","prevRefs","i","writeExpr","variable","getVariable","references","containDuplicates","ref","concat","checkDescendant","baseDepth","forEach","handleJSX","JSXElement","JSXFragment","JSXExpressionContainer","variablesInScope","element"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-max-depth.js"],"sourcesContent":["/**\n * @fileoverview Validate JSX maximum depth\n * @author Chris<wfsr@foxmail.com>\n */\n\n'use strict';\n\nconst has = require('object.hasown/polyfill')();\nconst includes = require('array-includes');\nconst variableUtil = require('../util/variable');\nconst jsxUtil = require('../util/jsx');\nconst docsUrl = require('../util/docsUrl');\nconst reportC = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  wrongDepth: 'Expected the depth of nested jsx elements to be <= {{needed}}, but found {{found}}.',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce JSX maximum depth',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-max-depth'),\n    },\n\n    messages,\n\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          max: {\n            type: 'integer',\n            minimum: 0,\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n  },\n  create(context) {\n    const DEFAULT_DEPTH = 2;\n\n    const option = context.options[0] || {};\n    const maxDepth = has(option, 'max') ? option.max : DEFAULT_DEPTH;\n\n    function isExpression(node) {\n      return node.type === 'JSXExpressionContainer';\n    }\n\n    function hasJSX(node) {\n      return jsxUtil.isJSX(node) || (isExpression(node) && jsxUtil.isJSX(node.expression));\n    }\n\n    function isLeaf(node) {\n      const children = node.children;\n\n      return !children || children.length === 0 || !children.some(hasJSX);\n    }\n\n    function getDepth(node) {\n      let count = 0;\n\n      while (jsxUtil.isJSX(node.parent) || isExpression(node.parent)) {\n        node = node.parent;\n        if (jsxUtil.isJSX(node)) {\n          count += 1;\n        }\n      }\n\n      return count;\n    }\n\n    function report(node, depth) {\n      reportC(context, messages.wrongDepth, 'wrongDepth', {\n        node,\n        data: {\n          found: depth,\n          needed: maxDepth,\n        },\n      });\n    }\n\n    function findJSXElementOrFragment(variables, name, previousReferences) {\n      function find(refs, prevRefs) {\n        for (let i = refs.length - 1; i >= 0; i--) {\n          if (has(refs[i], 'writeExpr')) {\n            const writeExpr = refs[i].writeExpr;\n\n            return (jsxUtil.isJSX(writeExpr)\n              && writeExpr)\n              || ((writeExpr && writeExpr.type === 'Identifier')\n              && findJSXElementOrFragment(variables, writeExpr.name, prevRefs));\n          }\n        }\n\n        return null;\n      }\n\n      const variable = variableUtil.getVariable(variables, name);\n      if (variable && variable.references) {\n        const containDuplicates = previousReferences.some((ref) => includes(variable.references, ref));\n\n        // Prevent getting stuck in circular references\n        if (containDuplicates) {\n          return false;\n        }\n\n        return find(variable.references, previousReferences.concat(variable.references));\n      }\n\n      return false;\n    }\n\n    function checkDescendant(baseDepth, children) {\n      baseDepth += 1;\n      (children || []).forEach((node) => {\n        if (!hasJSX(node)) {\n          return;\n        }\n\n        if (baseDepth > maxDepth) {\n          report(node, baseDepth);\n        } else if (!isLeaf(node)) {\n          checkDescendant(baseDepth, node.children);\n        }\n      });\n    }\n\n    function handleJSX(node) {\n      if (!isLeaf(node)) {\n        return;\n      }\n\n      const depth = getDepth(node);\n      if (depth > maxDepth) {\n        report(node, depth);\n      }\n    }\n\n    return {\n      JSXElement: handleJSX,\n      JSXFragment: handleJSX,\n\n      JSXExpressionContainer(node) {\n        if (node.expression.type !== 'Identifier') {\n          return;\n        }\n\n        const variables = variableUtil.variablesInScope(context);\n        const element = findJSXElementOrFragment(variables, node.expression.name, []);\n\n        if (element) {\n          const baseDepth = getDepth(node);\n          checkDescendant(baseDepth, element.children);\n        }\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}