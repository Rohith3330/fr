{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractComputedKeys = extractComputedKeys;\nexports.injectInitialization = injectInitialization;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nconst findBareSupers = _core.traverse.visitors.merge([{\n  Super(path) {\n    const {\n      node,\n      parentPath\n    } = path;\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      this.push(parentPath);\n    }\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nconst referenceVisitor = {\n  \"TSTypeAnnotation|TypeAnnotation\"(path) {\n    path.skip();\n  },\n\n  ReferencedIdentifier(path, _ref) {\n    let {\n      scope\n    } = _ref;\n\n    if (scope.hasOwnBinding(path.node.name)) {\n      scope.rename(path.node.name);\n      path.skip();\n    }\n  }\n\n};\n\nfunction handleClassTDZ(path, state) {\n  if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {\n    const classNameTDZError = state.file.addHelper(\"classNameTDZError\");\n\n    const throwNode = _core.types.callExpression(classNameTDZError, [_core.types.stringLiteral(path.node.name)]);\n\n    path.replaceWith(_core.types.sequenceExpression([throwNode, path.node]));\n    path.skip();\n  }\n}\n\nconst classFieldDefinitionEvaluationTDZVisitor = {\n  ReferencedIdentifier: handleClassTDZ\n};\n\nfunction injectInitialization(path, constructor, nodes, renamer) {\n  if (!nodes.length) return;\n  const isDerived = !!path.node.superClass;\n\n  if (!constructor) {\n    const newConstructor = _core.types.classMethod(\"constructor\", _core.types.identifier(\"constructor\"), [], _core.types.blockStatement([]));\n\n    if (isDerived) {\n      newConstructor.params = [_core.types.restElement(_core.types.identifier(\"args\"))];\n      newConstructor.body.body.push(_core.template.statement.ast`super(...args)`);\n    }\n\n    [constructor] = path.get(\"body\").unshiftContainer(\"body\", newConstructor);\n  }\n\n  if (renamer) {\n    renamer(referenceVisitor, {\n      scope: constructor.scope\n    });\n  }\n\n  if (isDerived) {\n    const bareSupers = [];\n    constructor.traverse(findBareSupers, bareSupers);\n    let isFirst = true;\n\n    for (const bareSuper of bareSupers) {\n      if (isFirst) {\n        bareSuper.insertAfter(nodes);\n        isFirst = false;\n      } else {\n        bareSuper.insertAfter(nodes.map(n => _core.types.cloneNode(n)));\n      }\n    }\n  } else {\n    constructor.get(\"body\").unshiftContainer(\"body\", nodes);\n  }\n}\n\nfunction extractComputedKeys(path, computedPaths, file) {\n  const declarations = [];\n  const state = {\n    classBinding: path.node.id && path.scope.getBinding(path.node.id.name),\n    file\n  };\n\n  for (const computedPath of computedPaths) {\n    const computedKey = computedPath.get(\"key\");\n\n    if (computedKey.isReferencedIdentifier()) {\n      handleClassTDZ(computedKey, state);\n    } else {\n      computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);\n    }\n\n    const computedNode = computedPath.node;\n\n    if (!computedKey.isConstantExpression()) {\n      const ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);\n      path.scope.push({\n        id: ident,\n        kind: \"let\"\n      });\n      declarations.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ident), computedNode.key)));\n      computedNode.key = _core.types.cloneNode(ident);\n    }\n  }\n\n  return declarations;\n}","map":{"version":3,"mappings":"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","names":["findBareSupers","traverse","visitors","merge","Super","path","node","parentPath","isCallExpression","callee","push","environmentVisitor","referenceVisitor","skip","ReferencedIdentifier","scope","hasOwnBinding","name","rename","handleClassTDZ","state","classBinding","getBinding","classNameTDZError","file","addHelper","throwNode","t","callExpression","stringLiteral","replaceWith","sequenceExpression","classFieldDefinitionEvaluationTDZVisitor","injectInitialization","constructor","nodes","renamer","length","isDerived","superClass","newConstructor","classMethod","identifier","blockStatement","params","restElement","body","template","statement","ast","get","unshiftContainer","bareSupers","isFirst","bareSuper","insertAfter","map","n","cloneNode","extractComputedKeys","computedPaths","declarations","id","computedPath","computedKey","isReferencedIdentifier","computedNode","isConstantExpression","ident","generateUidIdentifierBasedOnNode","key","kind","expressionStatement","assignmentExpression"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-create-class-features-plugin\\src\\misc.ts"],"sourcesContent":["import { template, traverse, types as t } from \"@babel/core\";\nimport type { File } from \"@babel/core\";\nimport type { NodePath, Scope, Visitor, Binding } from \"@babel/traverse\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\n\nconst findBareSupers = traverse.visitors.merge<NodePath<t.CallExpression>[]>([\n  {\n    Super(path) {\n      const { node, parentPath } = path;\n      if (parentPath.isCallExpression({ callee: node })) {\n        this.push(parentPath);\n      }\n    },\n  },\n  environmentVisitor,\n]);\n\nconst referenceVisitor: Visitor<{ scope: Scope }> = {\n  \"TSTypeAnnotation|TypeAnnotation\"(\n    path: NodePath<t.TSTypeAnnotation | t.TypeAnnotation>,\n  ) {\n    path.skip();\n  },\n\n  ReferencedIdentifier(path: NodePath<t.Identifier>, { scope }) {\n    if (scope.hasOwnBinding(path.node.name)) {\n      scope.rename(path.node.name);\n      path.skip();\n    }\n  },\n};\n\ntype HandleClassTDZState = {\n  classBinding: Binding;\n  file: File;\n};\n\nfunction handleClassTDZ(\n  path: NodePath<t.Identifier>,\n  state: HandleClassTDZState,\n) {\n  if (\n    state.classBinding &&\n    state.classBinding === path.scope.getBinding(path.node.name)\n  ) {\n    const classNameTDZError = state.file.addHelper(\"classNameTDZError\");\n    const throwNode = t.callExpression(classNameTDZError, [\n      t.stringLiteral(path.node.name),\n    ]);\n\n    path.replaceWith(t.sequenceExpression([throwNode, path.node]));\n    path.skip();\n  }\n}\n\nconst classFieldDefinitionEvaluationTDZVisitor: Visitor<HandleClassTDZState> = {\n  ReferencedIdentifier: handleClassTDZ,\n};\n\ninterface RenamerState {\n  scope: Scope;\n}\n\nexport function injectInitialization(\n  path: NodePath<t.Class>,\n  constructor: NodePath<t.ClassMethod> | undefined,\n  nodes: t.Statement[],\n  renamer?: (visitor: Visitor<RenamerState>, state: RenamerState) => void,\n) {\n  if (!nodes.length) return;\n\n  const isDerived = !!path.node.superClass;\n\n  if (!constructor) {\n    const newConstructor = t.classMethod(\n      \"constructor\",\n      t.identifier(\"constructor\"),\n      [],\n      t.blockStatement([]),\n    );\n\n    if (isDerived) {\n      newConstructor.params = [t.restElement(t.identifier(\"args\"))];\n      newConstructor.body.body.push(template.statement.ast`super(...args)`);\n    }\n\n    [constructor] = path\n      .get(\"body\")\n      .unshiftContainer(\"body\", newConstructor) as NodePath<t.ClassMethod>[];\n  }\n\n  if (renamer) {\n    renamer(referenceVisitor, { scope: constructor.scope });\n  }\n\n  if (isDerived) {\n    const bareSupers: NodePath<t.CallExpression>[] = [];\n    constructor.traverse(findBareSupers, bareSupers);\n    let isFirst = true;\n    for (const bareSuper of bareSupers) {\n      if (isFirst) {\n        bareSuper.insertAfter(nodes);\n        isFirst = false;\n      } else {\n        bareSuper.insertAfter(nodes.map(n => t.cloneNode(n)));\n      }\n    }\n  } else {\n    constructor.get(\"body\").unshiftContainer(\"body\", nodes);\n  }\n}\n\nexport function extractComputedKeys(\n  path: NodePath<t.Class>,\n  computedPaths: NodePath<t.ClassProperty | t.ClassMethod>[],\n  file: File,\n) {\n  const declarations: t.ExpressionStatement[] = [];\n  const state = {\n    classBinding: path.node.id && path.scope.getBinding(path.node.id.name),\n    file,\n  };\n  for (const computedPath of computedPaths) {\n    const computedKey = computedPath.get(\"key\");\n    if (computedKey.isReferencedIdentifier()) {\n      handleClassTDZ(computedKey, state);\n    } else {\n      computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);\n    }\n\n    const computedNode = computedPath.node;\n    // Make sure computed property names are only evaluated once (upon class definition)\n    // and in the right order in combination with static properties\n    if (!computedKey.isConstantExpression()) {\n      const ident = path.scope.generateUidIdentifierBasedOnNode(\n        computedNode.key,\n      );\n      // Declaring in the same block scope\n      // Ref: https://github.com/babel/babel/pull/10029/files#diff-fbbdd83e7a9c998721c1484529c2ce92\n      path.scope.push({\n        id: ident,\n        kind: \"let\",\n      });\n      declarations.push(\n        t.expressionStatement(\n          t.assignmentExpression(\"=\", t.cloneNode(ident), computedNode.key),\n        ),\n      );\n      computedNode.key = t.cloneNode(ident);\n    }\n  }\n\n  return declarations;\n}\n"]},"metadata":{},"sourceType":"script"}