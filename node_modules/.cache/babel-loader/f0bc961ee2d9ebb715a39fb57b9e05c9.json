{"ast":null,"code":"/**\n * @fileoverview Rule to check empty newline between class members\n * @author 薛定谔的猫<hh_2013@foxmail.com>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"Require or disallow an empty line between class members\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-between-class-members\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptAfterSingleLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      never: \"Unexpected blank line between class members.\",\n      always: \"Expected blank line between class members.\"\n    }\n  },\n\n  create(context) {\n    const options = [];\n    options[0] = context.options[0] || \"always\";\n    options[1] = context.options[1] || {\n      exceptAfterSingleLine: false\n    };\n    const sourceCode = context.getSourceCode();\n    /**\n     * Gets a pair of tokens that should be used to check lines between two class member nodes.\n     *\n     * In most cases, this returns the very last token of the current node and\n     * the very first token of the next node.\n     * For example:\n     *\n     *     class C {\n     *         x = 1;   // curLast: `;` nextFirst: `in`\n     *         in = 2\n     *     }\n     *\n     * There is only one exception. If the given node ends with a semicolon, and it looks like\n     * a semicolon-less style's semicolon - one that is not on the same line as the preceding\n     * token, but is on the line where the next class member starts - this returns the preceding\n     * token and the semicolon as boundary tokens.\n     * For example:\n     *\n     *     class C {\n     *         x = 1    // curLast: `1` nextFirst: `;`\n     *         ;in = 2\n     *     }\n     * When determining the desired layout of the code, we should treat this semicolon as\n     * a part of the next class member node instead of the one it technically belongs to.\n     * @param {ASTNode} curNode Current class member node.\n     * @param {ASTNode} nextNode Next class member node.\n     * @returns {Token} The actual last token of `node`.\n     * @private\n     */\n\n    function getBoundaryTokens(curNode, nextNode) {\n      const lastToken = sourceCode.getLastToken(curNode);\n      const prevToken = sourceCode.getTokenBefore(lastToken);\n      const nextToken = sourceCode.getFirstToken(nextNode); // skip possible lone `;` between nodes\n\n      const isSemicolonLessStyle = astUtils.isSemicolonToken(lastToken) && !astUtils.isTokenOnSameLine(prevToken, lastToken) && astUtils.isTokenOnSameLine(lastToken, nextToken);\n      return isSemicolonLessStyle ? {\n        curLast: prevToken,\n        nextFirst: lastToken\n      } : {\n        curLast: lastToken,\n        nextFirst: nextToken\n      };\n    }\n    /**\n     * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\n     * @param {Token} prevLastToken The last token in the previous member node.\n     * @param {Token} nextFirstToken The first token in the next member node.\n     * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n     * @returns {Token} The last token among the consecutive tokens.\n     */\n\n\n    function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n      const after = sourceCode.getTokenAfter(prevLastToken, {\n        includeComments: true\n      });\n\n      if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n        return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n      }\n\n      return prevLastToken;\n    }\n    /**\n     * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\n     * @param {Token} nextFirstToken The first token in the next member node.\n     * @param {Token} prevLastToken The last token in the previous member node.\n     * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n     * @returns {Token} The first token among the consecutive tokens.\n     */\n\n\n    function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n      const before = sourceCode.getTokenBefore(nextFirstToken, {\n        includeComments: true\n      });\n\n      if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n        return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n      }\n\n      return nextFirstToken;\n    }\n    /**\n     * Checks if there is a token or comment between two tokens.\n     * @param {Token} before The token before.\n     * @param {Token} after The token after.\n     * @returns {boolean} True if there is a token or comment between two tokens.\n     */\n\n\n    function hasTokenOrCommentBetween(before, after) {\n      return sourceCode.getTokensBetween(before, after, {\n        includeComments: true\n      }).length !== 0;\n    }\n\n    return {\n      ClassBody(node) {\n        const body = node.body;\n\n        for (let i = 0; i < body.length - 1; i++) {\n          const curFirst = sourceCode.getFirstToken(body[i]);\n          const {\n            curLast,\n            nextFirst\n          } = getBoundaryTokens(body[i], body[i + 1]);\n          const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n          const skip = !isMulti && options[1].exceptAfterSingleLine;\n          const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n          const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n          const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n          const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n          const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n\n          if (options[0] === \"always\" && !skip && !isPadded || options[0] === \"never\" && isPadded) {\n            context.report({\n              node: body[i + 1],\n              messageId: isPadded ? \"never\" : \"always\",\n\n              fix(fixer) {\n                if (hasTokenInPadding) {\n                  return null;\n                }\n\n                return isPadded ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\") : fixer.insertTextAfter(curLineLastToken, \"\\n\");\n              }\n\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","enum","properties","exceptAfterSingleLine","default","additionalProperties","messages","never","always","create","context","options","sourceCode","getSourceCode","getBoundaryTokens","curNode","nextNode","lastToken","getLastToken","prevToken","getTokenBefore","nextToken","getFirstToken","isSemicolonLessStyle","isSemicolonToken","isTokenOnSameLine","curLast","nextFirst","findLastConsecutiveTokenAfter","prevLastToken","nextFirstToken","maxLine","after","getTokenAfter","includeComments","loc","start","line","end","findFirstConsecutiveTokenBefore","before","hasTokenOrCommentBetween","getTokensBetween","length","ClassBody","node","body","i","curFirst","isMulti","skip","beforePadding","afterPadding","isPadded","hasTokenInPadding","curLineLastToken","report","messageId","fix","fixer","replaceTextRange","range","insertTextAfter"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/lines-between-class-members.js"],"sourcesContent":["/**\n * @fileoverview Rule to check empty newline between class members\n * @author 薛定谔的猫<hh_2013@foxmail.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"Require or disallow an empty line between class members\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/lines-between-class-members\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptAfterSingleLine: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n        messages: {\n            never: \"Unexpected blank line between class members.\",\n            always: \"Expected blank line between class members.\"\n        }\n    },\n\n    create(context) {\n\n        const options = [];\n\n        options[0] = context.options[0] || \"always\";\n        options[1] = context.options[1] || { exceptAfterSingleLine: false };\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Gets a pair of tokens that should be used to check lines between two class member nodes.\n         *\n         * In most cases, this returns the very last token of the current node and\n         * the very first token of the next node.\n         * For example:\n         *\n         *     class C {\n         *         x = 1;   // curLast: `;` nextFirst: `in`\n         *         in = 2\n         *     }\n         *\n         * There is only one exception. If the given node ends with a semicolon, and it looks like\n         * a semicolon-less style's semicolon - one that is not on the same line as the preceding\n         * token, but is on the line where the next class member starts - this returns the preceding\n         * token and the semicolon as boundary tokens.\n         * For example:\n         *\n         *     class C {\n         *         x = 1    // curLast: `1` nextFirst: `;`\n         *         ;in = 2\n         *     }\n         * When determining the desired layout of the code, we should treat this semicolon as\n         * a part of the next class member node instead of the one it technically belongs to.\n         * @param {ASTNode} curNode Current class member node.\n         * @param {ASTNode} nextNode Next class member node.\n         * @returns {Token} The actual last token of `node`.\n         * @private\n         */\n        function getBoundaryTokens(curNode, nextNode) {\n            const lastToken = sourceCode.getLastToken(curNode);\n            const prevToken = sourceCode.getTokenBefore(lastToken);\n            const nextToken = sourceCode.getFirstToken(nextNode); // skip possible lone `;` between nodes\n\n            const isSemicolonLessStyle = (\n                astUtils.isSemicolonToken(lastToken) &&\n                !astUtils.isTokenOnSameLine(prevToken, lastToken) &&\n                astUtils.isTokenOnSameLine(lastToken, nextToken)\n            );\n\n            return isSemicolonLessStyle\n                ? { curLast: prevToken, nextFirst: lastToken }\n                : { curLast: lastToken, nextFirst: nextToken };\n        }\n\n        /**\n         * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The last token among the consecutive tokens.\n         */\n        function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n            const after = sourceCode.getTokenAfter(prevLastToken, { includeComments: true });\n\n            if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n                return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n            }\n            return prevLastToken;\n        }\n\n        /**\n         * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\n         * @param {Token} nextFirstToken The first token in the next member node.\n         * @param {Token} prevLastToken The last token in the previous member node.\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\n         * @returns {Token} The first token among the consecutive tokens.\n         */\n        function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n            const before = sourceCode.getTokenBefore(nextFirstToken, { includeComments: true });\n\n            if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n                return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n            }\n            return nextFirstToken;\n        }\n\n        /**\n         * Checks if there is a token or comment between two tokens.\n         * @param {Token} before The token before.\n         * @param {Token} after The token after.\n         * @returns {boolean} True if there is a token or comment between two tokens.\n         */\n        function hasTokenOrCommentBetween(before, after) {\n            return sourceCode.getTokensBetween(before, after, { includeComments: true }).length !== 0;\n        }\n\n        return {\n            ClassBody(node) {\n                const body = node.body;\n\n                for (let i = 0; i < body.length - 1; i++) {\n                    const curFirst = sourceCode.getFirstToken(body[i]);\n                    const { curLast, nextFirst } = getBoundaryTokens(body[i], body[i + 1]);\n                    const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n                    const skip = !isMulti && options[1].exceptAfterSingleLine;\n                    const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n                    const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n                    const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n                    const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n                    const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n\n                    if ((options[0] === \"always\" && !skip && !isPadded) ||\n                        (options[0] === \"never\" && isPadded)) {\n                        context.report({\n                            node: body[i + 1],\n                            messageId: isPadded ? \"never\" : \"always\",\n                            fix(fixer) {\n                                if (hasTokenInPadding) {\n                                    return null;\n                                }\n                                return isPadded\n                                    ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\")\n                                    : fixer.insertTextAfter(curLineLastToken, \"\\n\");\n                            }\n                        });\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}