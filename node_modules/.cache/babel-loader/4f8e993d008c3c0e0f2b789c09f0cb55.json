{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst path_1 = require(\"path\");\n/**\n * It handles most of the logic required to process embedded TypeScript code (like in Vue components or MDX)\n *\n * @param embeddedExtensions List of file extensions that should be treated as an embedded TypeScript source\n *                           (for example ['.vue'])\n * @param getEmbeddedSource  Function that returns embedded TypeScript source text and extension that this file\n *                           would have if it would be a regular TypeScript file\n */\n\n\nfunction createTypeScriptEmbeddedExtension(_ref) {\n  let {\n    embeddedExtensions,\n    getEmbeddedSource\n  } = _ref;\n  const embeddedSourceCache = new Map();\n\n  function getCachedEmbeddedSource(fileName) {\n    if (!embeddedSourceCache.has(fileName)) {\n      embeddedSourceCache.set(fileName, getEmbeddedSource(fileName));\n    }\n\n    return embeddedSourceCache.get(fileName);\n  }\n\n  function parsePotentiallyEmbeddedFileName(fileName) {\n    const extension = path_1.extname(fileName);\n    const embeddedFileName = fileName.slice(0, fileName.length - extension.length);\n    const embeddedExtension = path_1.extname(embeddedFileName);\n    return {\n      extension,\n      embeddedFileName,\n      embeddedExtension\n    };\n  }\n\n  function createEmbeddedFileExists(fileExists) {\n    return function embeddedFileExists(fileName) {\n      const {\n        embeddedExtension,\n        embeddedFileName,\n        extension\n      } = parsePotentiallyEmbeddedFileName(fileName);\n\n      if (embeddedExtensions.includes(embeddedExtension) && fileExists(embeddedFileName)) {\n        const embeddedSource = getCachedEmbeddedSource(embeddedFileName);\n        return !!(embeddedSource && embeddedSource.extension === extension);\n      }\n\n      return fileExists(fileName);\n    };\n  }\n\n  function createEmbeddedReadFile(readFile) {\n    return function embeddedReadFile(fileName, encoding) {\n      const {\n        embeddedExtension,\n        embeddedFileName,\n        extension\n      } = parsePotentiallyEmbeddedFileName(fileName);\n\n      if (embeddedExtensions.includes(embeddedExtension)) {\n        const embeddedSource = getCachedEmbeddedSource(embeddedFileName);\n\n        if (embeddedSource && embeddedSource.extension === extension) {\n          return embeddedSource.sourceText;\n        }\n      }\n\n      return readFile(fileName, encoding);\n    };\n  }\n\n  return {\n    extendIssues(issues) {\n      return issues.map(issue => {\n        if (issue.file) {\n          const {\n            embeddedExtension,\n            embeddedFileName\n          } = parsePotentiallyEmbeddedFileName(issue.file);\n\n          if (embeddedExtensions.includes(embeddedExtension)) {\n            return Object.assign(Object.assign({}, issue), {\n              file: embeddedFileName\n            });\n          }\n        }\n\n        return issue;\n      });\n    },\n\n    extendWatchCompilerHost(host) {\n      return Object.assign(Object.assign({}, host), {\n        watchFile(fileName, callback, poolingInterval) {\n          const {\n            embeddedExtension,\n            embeddedFileName\n          } = parsePotentiallyEmbeddedFileName(fileName);\n\n          if (embeddedExtensions.includes(embeddedExtension)) {\n            return host.watchFile(embeddedFileName, (innerFileName, eventKind) => {\n              embeddedSourceCache.delete(embeddedFileName);\n              return callback(fileName, eventKind);\n            }, poolingInterval);\n          } else {\n            return host.watchFile(fileName, callback, poolingInterval);\n          }\n        },\n\n        readFile: createEmbeddedReadFile(host.readFile),\n        fileExists: createEmbeddedFileExists(host.fileExists)\n      });\n    },\n\n    extendCompilerHost(host) {\n      return Object.assign(Object.assign({}, host), {\n        readFile: createEmbeddedReadFile(host.readFile),\n        fileExists: createEmbeddedFileExists(host.fileExists)\n      });\n    },\n\n    extendParseConfigFileHost(host) {\n      return Object.assign(Object.assign({}, host), {\n        readDirectory(rootDir, extensions, excludes, includes, depth) {\n          return host.readDirectory(rootDir, [...extensions, ...embeddedExtensions], excludes, includes, depth).map(fileName => {\n            const isEmbeddedFile = embeddedExtensions.some(embeddedExtension => fileName.endsWith(embeddedExtension));\n\n            if (isEmbeddedFile) {\n              const embeddedSource = getCachedEmbeddedSource(fileName);\n              return embeddedSource ? `${fileName}${embeddedSource.extension}` : fileName;\n            } else {\n              return fileName;\n            }\n          });\n        }\n\n      });\n    },\n\n    extendDependencies(dependencies) {\n      return Object.assign(Object.assign({}, dependencies), {\n        files: dependencies.files.map(fileName => {\n          const {\n            embeddedExtension,\n            embeddedFileName,\n            extension\n          } = parsePotentiallyEmbeddedFileName(fileName);\n\n          if (embeddedExtensions.includes(embeddedExtension)) {\n            const embeddedSource = getCachedEmbeddedSource(embeddedFileName);\n\n            if (embeddedSource && embeddedSource.extension === extension) {\n              return embeddedFileName;\n            }\n          }\n\n          return fileName;\n        }),\n        extensions: [...dependencies.extensions, ...embeddedExtensions]\n      });\n    }\n\n  };\n}\n\nexports.createTypeScriptEmbeddedExtension = createTypeScriptEmbeddedExtension;","map":{"version":3,"names":["Object","defineProperty","exports","value","path_1","require","createTypeScriptEmbeddedExtension","embeddedExtensions","getEmbeddedSource","embeddedSourceCache","Map","getCachedEmbeddedSource","fileName","has","set","get","parsePotentiallyEmbeddedFileName","extension","extname","embeddedFileName","slice","length","embeddedExtension","createEmbeddedFileExists","fileExists","embeddedFileExists","includes","embeddedSource","createEmbeddedReadFile","readFile","embeddedReadFile","encoding","sourceText","extendIssues","issues","map","issue","file","assign","extendWatchCompilerHost","host","watchFile","callback","poolingInterval","innerFileName","eventKind","delete","extendCompilerHost","extendParseConfigFileHost","readDirectory","rootDir","extensions","excludes","depth","isEmbeddedFile","some","endsWith","extendDependencies","dependencies","files"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/fork-ts-checker-webpack-plugin/lib/typescript-reporter/extension/TypeScriptEmbeddedExtension.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path_1 = require(\"path\");\n/**\n * It handles most of the logic required to process embedded TypeScript code (like in Vue components or MDX)\n *\n * @param embeddedExtensions List of file extensions that should be treated as an embedded TypeScript source\n *                           (for example ['.vue'])\n * @param getEmbeddedSource  Function that returns embedded TypeScript source text and extension that this file\n *                           would have if it would be a regular TypeScript file\n */\nfunction createTypeScriptEmbeddedExtension({ embeddedExtensions, getEmbeddedSource, }) {\n    const embeddedSourceCache = new Map();\n    function getCachedEmbeddedSource(fileName) {\n        if (!embeddedSourceCache.has(fileName)) {\n            embeddedSourceCache.set(fileName, getEmbeddedSource(fileName));\n        }\n        return embeddedSourceCache.get(fileName);\n    }\n    function parsePotentiallyEmbeddedFileName(fileName) {\n        const extension = path_1.extname(fileName);\n        const embeddedFileName = fileName.slice(0, fileName.length - extension.length);\n        const embeddedExtension = path_1.extname(embeddedFileName);\n        return {\n            extension,\n            embeddedFileName,\n            embeddedExtension,\n        };\n    }\n    function createEmbeddedFileExists(fileExists) {\n        return function embeddedFileExists(fileName) {\n            const { embeddedExtension, embeddedFileName, extension } = parsePotentiallyEmbeddedFileName(fileName);\n            if (embeddedExtensions.includes(embeddedExtension) && fileExists(embeddedFileName)) {\n                const embeddedSource = getCachedEmbeddedSource(embeddedFileName);\n                return !!(embeddedSource && embeddedSource.extension === extension);\n            }\n            return fileExists(fileName);\n        };\n    }\n    function createEmbeddedReadFile(readFile) {\n        return function embeddedReadFile(fileName, encoding) {\n            const { embeddedExtension, embeddedFileName, extension } = parsePotentiallyEmbeddedFileName(fileName);\n            if (embeddedExtensions.includes(embeddedExtension)) {\n                const embeddedSource = getCachedEmbeddedSource(embeddedFileName);\n                if (embeddedSource && embeddedSource.extension === extension) {\n                    return embeddedSource.sourceText;\n                }\n            }\n            return readFile(fileName, encoding);\n        };\n    }\n    return {\n        extendIssues(issues) {\n            return issues.map((issue) => {\n                if (issue.file) {\n                    const { embeddedExtension, embeddedFileName } = parsePotentiallyEmbeddedFileName(issue.file);\n                    if (embeddedExtensions.includes(embeddedExtension)) {\n                        return Object.assign(Object.assign({}, issue), { file: embeddedFileName });\n                    }\n                }\n                return issue;\n            });\n        },\n        extendWatchCompilerHost(host) {\n            return Object.assign(Object.assign({}, host), { watchFile(fileName, callback, poolingInterval) {\n                    const { embeddedExtension, embeddedFileName } = parsePotentiallyEmbeddedFileName(fileName);\n                    if (embeddedExtensions.includes(embeddedExtension)) {\n                        return host.watchFile(embeddedFileName, (innerFileName, eventKind) => {\n                            embeddedSourceCache.delete(embeddedFileName);\n                            return callback(fileName, eventKind);\n                        }, poolingInterval);\n                    }\n                    else {\n                        return host.watchFile(fileName, callback, poolingInterval);\n                    }\n                }, readFile: createEmbeddedReadFile(host.readFile), fileExists: createEmbeddedFileExists(host.fileExists) });\n        },\n        extendCompilerHost(host) {\n            return Object.assign(Object.assign({}, host), { readFile: createEmbeddedReadFile(host.readFile), fileExists: createEmbeddedFileExists(host.fileExists) });\n        },\n        extendParseConfigFileHost(host) {\n            return Object.assign(Object.assign({}, host), { readDirectory(rootDir, extensions, excludes, includes, depth) {\n                    return host\n                        .readDirectory(rootDir, [...extensions, ...embeddedExtensions], excludes, includes, depth)\n                        .map((fileName) => {\n                        const isEmbeddedFile = embeddedExtensions.some((embeddedExtension) => fileName.endsWith(embeddedExtension));\n                        if (isEmbeddedFile) {\n                            const embeddedSource = getCachedEmbeddedSource(fileName);\n                            return embeddedSource ? `${fileName}${embeddedSource.extension}` : fileName;\n                        }\n                        else {\n                            return fileName;\n                        }\n                    });\n                } });\n        },\n        extendDependencies(dependencies) {\n            return Object.assign(Object.assign({}, dependencies), { files: dependencies.files.map((fileName) => {\n                    const { embeddedExtension, embeddedFileName, extension, } = parsePotentiallyEmbeddedFileName(fileName);\n                    if (embeddedExtensions.includes(embeddedExtension)) {\n                        const embeddedSource = getCachedEmbeddedSource(embeddedFileName);\n                        if (embeddedSource && embeddedSource.extension === extension) {\n                            return embeddedFileName;\n                        }\n                    }\n                    return fileName;\n                }), extensions: [...dependencies.extensions, ...embeddedExtensions] });\n        },\n    };\n}\nexports.createTypeScriptEmbeddedExtension = createTypeScriptEmbeddedExtension;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}