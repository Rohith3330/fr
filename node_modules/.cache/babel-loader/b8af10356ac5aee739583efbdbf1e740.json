{"ast":null,"code":"/**\n * @fileoverview Shared functions to work with configs.\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //-----------------------------------------------------------------------------\n// Functions\n//-----------------------------------------------------------------------------\n\n/**\n * Parses a ruleId into its plugin and rule parts.\n * @param {string} ruleId The rule ID to parse.\n * @returns {{pluginName:string,ruleName:string}} The plugin and rule\n *      parts of the ruleId;\n */\n\nfunction parseRuleId(ruleId) {\n  let pluginName, ruleName; // distinguish between core rules and plugin rules\n\n  if (ruleId.includes(\"/\")) {\n    // mimic scoped npm packages\n    if (ruleId.startsWith(\"@\")) {\n      pluginName = ruleId.slice(0, ruleId.lastIndexOf(\"/\"));\n    } else {\n      pluginName = ruleId.slice(0, ruleId.indexOf(\"/\"));\n    }\n\n    ruleName = ruleId.slice(pluginName.length + 1);\n  } else {\n    pluginName = \"@\";\n    ruleName = ruleId;\n  }\n\n  return {\n    pluginName,\n    ruleName\n  };\n}\n/**\n * Retrieves a rule instance from a given config based on the ruleId.\n * @param {string} ruleId The rule ID to look for.\n * @param {FlatConfig} config The config to search.\n * @returns {import(\"../shared/types\").Rule|undefined} The rule if found\n *      or undefined if not.\n */\n\n\nfunction getRuleFromConfig(ruleId, config) {\n  const {\n    pluginName,\n    ruleName\n  } = parseRuleId(ruleId);\n  const plugin = config.plugins && config.plugins[pluginName];\n  let rule = plugin && plugin.rules && plugin.rules[ruleName]; // normalize function rules into objects\n\n  if (rule && typeof rule === \"function\") {\n    rule = {\n      create: rule\n    };\n  }\n\n  return rule;\n}\n/**\n * Gets a complete options schema for a rule.\n * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\n * @returns {Object} JSON Schema for the rule's options.\n */\n\n\nfunction getRuleOptionsSchema(rule) {\n  if (!rule) {\n    return null;\n  }\n\n  const schema = rule.schema || rule.meta && rule.meta.schema;\n\n  if (Array.isArray(schema)) {\n    if (schema.length) {\n      return {\n        type: \"array\",\n        items: schema,\n        minItems: 0,\n        maxItems: schema.length\n      };\n    }\n\n    return {\n      type: \"array\",\n      minItems: 0,\n      maxItems: 0\n    };\n  } // Given a full schema, leave it alone\n\n\n  return schema || null;\n} //-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n\nmodule.exports = {\n  parseRuleId,\n  getRuleFromConfig,\n  getRuleOptionsSchema\n};","map":{"version":3,"names":["parseRuleId","ruleId","pluginName","ruleName","includes","startsWith","slice","lastIndexOf","indexOf","length","getRuleFromConfig","config","plugin","plugins","rule","rules","create","getRuleOptionsSchema","schema","meta","Array","isArray","type","items","minItems","maxItems","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/config/flat-config-helpers.js"],"sourcesContent":["/**\n * @fileoverview Shared functions to work with configs.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Functions\n//-----------------------------------------------------------------------------\n\n/**\n * Parses a ruleId into its plugin and rule parts.\n * @param {string} ruleId The rule ID to parse.\n * @returns {{pluginName:string,ruleName:string}} The plugin and rule\n *      parts of the ruleId;\n */\nfunction parseRuleId(ruleId) {\n    let pluginName, ruleName;\n\n    // distinguish between core rules and plugin rules\n    if (ruleId.includes(\"/\")) {\n\n        // mimic scoped npm packages\n        if (ruleId.startsWith(\"@\")) {\n            pluginName = ruleId.slice(0, ruleId.lastIndexOf(\"/\"));\n        } else {\n            pluginName = ruleId.slice(0, ruleId.indexOf(\"/\"));\n        }\n\n        ruleName = ruleId.slice(pluginName.length + 1);\n    } else {\n        pluginName = \"@\";\n        ruleName = ruleId;\n    }\n\n    return {\n        pluginName,\n        ruleName\n    };\n}\n\n/**\n * Retrieves a rule instance from a given config based on the ruleId.\n * @param {string} ruleId The rule ID to look for.\n * @param {FlatConfig} config The config to search.\n * @returns {import(\"../shared/types\").Rule|undefined} The rule if found\n *      or undefined if not.\n */\nfunction getRuleFromConfig(ruleId, config) {\n\n    const { pluginName, ruleName } = parseRuleId(ruleId);\n\n    const plugin = config.plugins && config.plugins[pluginName];\n    let rule = plugin && plugin.rules && plugin.rules[ruleName];\n\n\n    // normalize function rules into objects\n    if (rule && typeof rule === \"function\") {\n        rule = {\n            create: rule\n        };\n    }\n\n    return rule;\n}\n\n/**\n * Gets a complete options schema for a rule.\n * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\n * @returns {Object} JSON Schema for the rule's options.\n */\nfunction getRuleOptionsSchema(rule) {\n\n    if (!rule) {\n        return null;\n    }\n\n    const schema = rule.schema || rule.meta && rule.meta.schema;\n\n    if (Array.isArray(schema)) {\n        if (schema.length) {\n            return {\n                type: \"array\",\n                items: schema,\n                minItems: 0,\n                maxItems: schema.length\n            };\n        }\n        return {\n            type: \"array\",\n            minItems: 0,\n            maxItems: 0\n        };\n\n    }\n\n    // Given a full schema, leave it alone\n    return schema || null;\n}\n\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\nmodule.exports = {\n    parseRuleId,\n    getRuleFromConfig,\n    getRuleOptionsSchema\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,WAAT,CAAqBC,MAArB,EAA6B;EACzB,IAAIC,UAAJ,EAAgBC,QAAhB,CADyB,CAGzB;;EACA,IAAIF,MAAM,CAACG,QAAP,CAAgB,GAAhB,CAAJ,EAA0B;IAEtB;IACA,IAAIH,MAAM,CAACI,UAAP,CAAkB,GAAlB,CAAJ,EAA4B;MACxBH,UAAU,GAAGD,MAAM,CAACK,KAAP,CAAa,CAAb,EAAgBL,MAAM,CAACM,WAAP,CAAmB,GAAnB,CAAhB,CAAb;IACH,CAFD,MAEO;MACHL,UAAU,GAAGD,MAAM,CAACK,KAAP,CAAa,CAAb,EAAgBL,MAAM,CAACO,OAAP,CAAe,GAAf,CAAhB,CAAb;IACH;;IAEDL,QAAQ,GAAGF,MAAM,CAACK,KAAP,CAAaJ,UAAU,CAACO,MAAX,GAAoB,CAAjC,CAAX;EACH,CAVD,MAUO;IACHP,UAAU,GAAG,GAAb;IACAC,QAAQ,GAAGF,MAAX;EACH;;EAED,OAAO;IACHC,UADG;IAEHC;EAFG,CAAP;AAIH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASO,iBAAT,CAA2BT,MAA3B,EAAmCU,MAAnC,EAA2C;EAEvC,MAAM;IAAET,UAAF;IAAcC;EAAd,IAA2BH,WAAW,CAACC,MAAD,CAA5C;EAEA,MAAMW,MAAM,GAAGD,MAAM,CAACE,OAAP,IAAkBF,MAAM,CAACE,OAAP,CAAeX,UAAf,CAAjC;EACA,IAAIY,IAAI,GAAGF,MAAM,IAAIA,MAAM,CAACG,KAAjB,IAA0BH,MAAM,CAACG,KAAP,CAAaZ,QAAb,CAArC,CALuC,CAQvC;;EACA,IAAIW,IAAI,IAAI,OAAOA,IAAP,KAAgB,UAA5B,EAAwC;IACpCA,IAAI,GAAG;MACHE,MAAM,EAAEF;IADL,CAAP;EAGH;;EAED,OAAOA,IAAP;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASG,oBAAT,CAA8BH,IAA9B,EAAoC;EAEhC,IAAI,CAACA,IAAL,EAAW;IACP,OAAO,IAAP;EACH;;EAED,MAAMI,MAAM,GAAGJ,IAAI,CAACI,MAAL,IAAeJ,IAAI,CAACK,IAAL,IAAaL,IAAI,CAACK,IAAL,CAAUD,MAArD;;EAEA,IAAIE,KAAK,CAACC,OAAN,CAAcH,MAAd,CAAJ,EAA2B;IACvB,IAAIA,MAAM,CAACT,MAAX,EAAmB;MACf,OAAO;QACHa,IAAI,EAAE,OADH;QAEHC,KAAK,EAAEL,MAFJ;QAGHM,QAAQ,EAAE,CAHP;QAIHC,QAAQ,EAAEP,MAAM,CAACT;MAJd,CAAP;IAMH;;IACD,OAAO;MACHa,IAAI,EAAE,OADH;MAEHE,QAAQ,EAAE,CAFP;MAGHC,QAAQ,EAAE;IAHP,CAAP;EAMH,CAvB+B,CAyBhC;;;EACA,OAAOP,MAAM,IAAI,IAAjB;AACH,C,CAGD;AACA;AACA;;;AAEAQ,MAAM,CAACC,OAAP,GAAiB;EACb3B,WADa;EAEbU,iBAFa;EAGbO;AAHa,CAAjB"},"metadata":{},"sourceType":"script"}