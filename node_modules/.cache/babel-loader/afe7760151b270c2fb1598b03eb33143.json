{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _path = require('path');\n\nvar path = _interopRequireWildcard(_path);\n\nvar _ExportMap = require('../ExportMap');\n\nvar _ExportMap2 = _interopRequireDefault(_ExportMap);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj['default'] = obj;\n    return newObj;\n  }\n}\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      url: (0, _docsUrl2['default'])('named')\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        commonjs: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  create: function () {\n    function create(context) {\n      var options = context.options[0] || {};\n\n      function checkSpecifiers(key, type, node) {\n        // ignore local exports and type imports/exports\n        if (node.source == null || node.importKind === 'type' || node.importKind === 'typeof' || node.exportKind === 'type') {\n          return;\n        }\n\n        if (!node.specifiers.some(function (im) {\n          return im.type === type;\n        })) {\n          return; // no named imports/exports\n        }\n\n        var imports = _ExportMap2['default'].get(node.source.value, context);\n\n        if (imports == null || imports.parseGoal === 'ambiguous') {\n          return;\n        }\n\n        if (imports.errors.length) {\n          imports.reportErrors(context, node);\n          return;\n        }\n\n        node.specifiers.forEach(function (im) {\n          if (im.type !== type // ignore type imports\n          || im.importKind === 'type' || im.importKind === 'typeof') {\n            return;\n          }\n\n          var name = im[key].name || im[key].value;\n          var deepLookup = imports.hasDeep(name);\n\n          if (!deepLookup.found) {\n            if (deepLookup.path.length > 1) {\n              var deepPath = deepLookup.path.map(function (i) {\n                return path.relative(path.dirname(context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename()), i.path);\n              }).join(' -> ');\n              context.report(im[key], String(name) + ' not found via ' + String(deepPath));\n            } else {\n              context.report(im[key], name + ' not found in \\'' + node.source.value + '\\'');\n            }\n          }\n        });\n      }\n\n      function checkRequire(node) {\n        if (!options.commonjs || node.type !== 'VariableDeclarator' // return if it's not an object destructure or it's an empty object destructure\n        || !node.id || node.id.type !== 'ObjectPattern' || node.id.properties.length === 0 // return if there is no call expression on the right side\n        || !node.init || node.init.type !== 'CallExpression') {\n          return;\n        }\n\n        var call = node.init;\n\n        var _call$arguments = _slicedToArray(call.arguments, 1),\n            source = _call$arguments[0];\n\n        var variableImports = node.id.properties;\n\n        var variableExports = _ExportMap2['default'].get(source.value, context);\n\n        if ( // return if it's not a commonjs require statement\n        call.callee.type !== 'Identifier' || call.callee.name !== 'require' || call.arguments.length !== 1 // return if it's not a string source\n        || source.type !== 'Literal' || variableExports == null || variableExports.parseGoal === 'ambiguous') {\n          return;\n        }\n\n        if (variableExports.errors.length) {\n          variableExports.reportErrors(context, node);\n          return;\n        }\n\n        variableImports.forEach(function (im) {\n          if (im.type !== 'Property' || !im.key || im.key.type !== 'Identifier') {\n            return;\n          }\n\n          var deepLookup = variableExports.hasDeep(im.key.name);\n\n          if (!deepLookup.found) {\n            if (deepLookup.path.length > 1) {\n              var deepPath = deepLookup.path.map(function (i) {\n                return path.relative(path.dirname(context.getFilename()), i.path);\n              }).join(' -> ');\n              context.report(im.key, String(im.key.name) + ' not found via ' + String(deepPath));\n            } else {\n              context.report(im.key, im.key.name + ' not found in \\'' + source.value + '\\'');\n            }\n          }\n        });\n      }\n\n      return {\n        ImportDeclaration: checkSpecifiers.bind(null, 'imported', 'ImportSpecifier'),\n        ExportNamedDeclaration: checkSpecifiers.bind(null, 'local', 'ExportSpecifier'),\n        VariableDeclarator: checkRequire\n      };\n    }\n\n    return create;\n  }()\n};","map":{"version":3,"mappings":"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","names":["path","module","exports","meta","type","docs","url","schema","properties","commonjs","additionalProperties","create","context","options","checkSpecifiers","key","node","source","importKind","exportKind","specifiers","some","im","imports","Exports","get","value","parseGoal","errors","length","reportErrors","forEach","name","deepLookup","hasDeep","found","deepPath","map","relative","dirname","getPhysicalFilename","getFilename","i","join","report","checkRequire","id","init","call","arguments","variableImports","variableExports","callee","ImportDeclaration","bind","ExportNamedDeclaration","VariableDeclarator"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\named.js"],"sourcesContent":["import * as path from 'path';\nimport Exports from '../ExportMap';\nimport docsUrl from '../docsUrl';\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      url: docsUrl('named'),\n    },\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          commonjs: {\n            type: 'boolean',\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n\n    function checkSpecifiers(key, type, node) {\n      // ignore local exports and type imports/exports\n      if (\n        node.source == null\n        || node.importKind === 'type'\n        || node.importKind === 'typeof'\n        || node.exportKind === 'type'\n      ) {\n        return;\n      }\n\n      if (!node.specifiers.some((im) => im.type === type)) {\n        return; // no named imports/exports\n      }\n\n      const imports = Exports.get(node.source.value, context);\n      if (imports == null || imports.parseGoal === 'ambiguous') {\n        return;\n      }\n\n      if (imports.errors.length) {\n        imports.reportErrors(context, node);\n        return;\n      }\n\n      node.specifiers.forEach(function (im) {\n        if (\n          im.type !== type\n          // ignore type imports\n          || im.importKind === 'type' || im.importKind === 'typeof'\n        ) {\n          return;\n        }\n\n        const name = im[key].name || im[key].value;\n\n        const deepLookup = imports.hasDeep(name);\n\n        if (!deepLookup.found) {\n          if (deepLookup.path.length > 1) {\n            const deepPath = deepLookup.path\n              .map(i => path.relative(path.dirname(context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename()), i.path))\n              .join(' -> ');\n\n            context.report(im[key], `${name} not found via ${deepPath}`);\n          } else {\n            context.report(im[key], name + ' not found in \\'' + node.source.value + '\\'');\n          }\n        }\n      });\n    }\n\n    function checkRequire(node) {\n      if (\n        !options.commonjs\n        || node.type !== 'VariableDeclarator'\n        // return if it's not an object destructure or it's an empty object destructure\n        || !node.id || node.id.type !== 'ObjectPattern' || node.id.properties.length === 0\n        // return if there is no call expression on the right side\n        || !node.init || node.init.type !== 'CallExpression'\n      ) {\n        return;\n      }\n\n      const call = node.init;\n      const [source] = call.arguments;\n      const variableImports = node.id.properties;\n      const variableExports = Exports.get(source.value, context);\n\n      if (\n        // return if it's not a commonjs require statement\n        call.callee.type !== 'Identifier' || call.callee.name !== 'require' || call.arguments.length !== 1\n        // return if it's not a string source\n        || source.type !== 'Literal'\n        || variableExports == null\n        || variableExports.parseGoal === 'ambiguous'\n      ) {\n        return;\n      }\n\n      if (variableExports.errors.length) {\n        variableExports.reportErrors(context, node);\n        return;\n      }\n\n      variableImports.forEach(function (im) {\n        if (im.type !== 'Property' || !im.key || im.key.type !== 'Identifier') {\n          return;\n        }\n\n        const deepLookup = variableExports.hasDeep(im.key.name);\n\n        if (!deepLookup.found) {\n          if (deepLookup.path.length > 1) {\n            const deepPath = deepLookup.path\n              .map(i => path.relative(path.dirname(context.getFilename()), i.path))\n              .join(' -> ');\n\n            context.report(im.key, `${im.key.name} not found via ${deepPath}`);\n          } else {\n            context.report(im.key, im.key.name + ' not found in \\'' + source.value + '\\'');\n          }\n        }\n      });\n    }\n\n    return {\n      ImportDeclaration: checkSpecifiers.bind(null, 'imported', 'ImportSpecifier'),\n\n      ExportNamedDeclaration: checkSpecifiers.bind(null, 'local', 'ExportSpecifier'),\n\n      VariableDeclarator: checkRequire,\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"script"}