{"ast":null,"code":"/**\n * @fileoverview A rule to ensure whitespace before blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given node represents the body of a function.\n * @param {ASTNode} node the node to check.\n * @returns {boolean} `true` if the node is function body.\n */\n\n\nfunction isFunctionBody(node) {\n  const parent = node.parent;\n  return node.type === \"BlockStatement\" && astUtils.isFunction(parent) && parent.body === node;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"Enforce consistent spacing before blocks\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-before-blocks\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          keywords: {\n            enum: [\"always\", \"never\", \"off\"]\n          },\n          functions: {\n            enum: [\"always\", \"never\", \"off\"]\n          },\n          classes: {\n            enum: [\"always\", \"never\", \"off\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedSpace: \"Unexpected space before opening brace.\",\n      missingSpace: \"Missing space before opening brace.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0],\n          sourceCode = context.getSourceCode();\n    let alwaysFunctions = true,\n        alwaysKeywords = true,\n        alwaysClasses = true,\n        neverFunctions = false,\n        neverKeywords = false,\n        neverClasses = false;\n\n    if (typeof config === \"object\") {\n      alwaysFunctions = config.functions === \"always\";\n      alwaysKeywords = config.keywords === \"always\";\n      alwaysClasses = config.classes === \"always\";\n      neverFunctions = config.functions === \"never\";\n      neverKeywords = config.keywords === \"never\";\n      neverClasses = config.classes === \"never\";\n    } else if (config === \"never\") {\n      alwaysFunctions = false;\n      alwaysKeywords = false;\n      alwaysClasses = false;\n      neverFunctions = true;\n      neverKeywords = true;\n      neverClasses = true;\n    }\n    /**\n     * Checks whether the spacing before the given block is already controlled by another rule:\n     * - `arrow-spacing` checks spaces after `=>`.\n     * - `keyword-spacing` checks spaces after keywords in certain contexts.\n     * - `switch-colon-spacing` checks spaces after `:` of switch cases.\n     * @param {Token} precedingToken first token before the block.\n     * @param {ASTNode|Token} node `BlockStatement` node or `{` token of a `SwitchStatement` node.\n     * @returns {boolean} `true` if requiring or disallowing spaces before the given block could produce conflicts with other rules.\n     */\n\n\n    function isConflicted(precedingToken, node) {\n      return astUtils.isArrowToken(precedingToken) || astUtils.isKeywordToken(precedingToken) && !isFunctionBody(node) || astUtils.isColonToken(precedingToken) && node.parent && node.parent.type === \"SwitchCase\" && precedingToken === astUtils.getSwitchCaseColonToken(node.parent, sourceCode);\n    }\n    /**\n     * Checks the given BlockStatement node has a preceding space if it doesnâ€™t start on a new line.\n     * @param {ASTNode|Token} node The AST node of a BlockStatement.\n     * @returns {void} undefined.\n     */\n\n\n    function checkPrecedingSpace(node) {\n      const precedingToken = sourceCode.getTokenBefore(node);\n\n      if (precedingToken && !isConflicted(precedingToken, node) && astUtils.isTokenOnSameLine(precedingToken, node)) {\n        const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);\n        let requireSpace;\n        let requireNoSpace;\n\n        if (isFunctionBody(node)) {\n          requireSpace = alwaysFunctions;\n          requireNoSpace = neverFunctions;\n        } else if (node.type === \"ClassBody\") {\n          requireSpace = alwaysClasses;\n          requireNoSpace = neverClasses;\n        } else {\n          requireSpace = alwaysKeywords;\n          requireNoSpace = neverKeywords;\n        }\n\n        if (requireSpace && !hasSpace) {\n          context.report({\n            node,\n            messageId: \"missingSpace\",\n\n            fix(fixer) {\n              return fixer.insertTextBefore(node, \" \");\n            }\n\n          });\n        } else if (requireNoSpace && hasSpace) {\n          context.report({\n            node,\n            messageId: \"unexpectedSpace\",\n\n            fix(fixer) {\n              return fixer.removeRange([precedingToken.range[1], node.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n    /**\n     * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.\n     * @param {ASTNode} node The node of a SwitchStatement.\n     * @returns {void} undefined.\n     */\n\n\n    function checkSpaceBeforeCaseBlock(node) {\n      const cases = node.cases;\n      let openingBrace;\n\n      if (cases.length > 0) {\n        openingBrace = sourceCode.getTokenBefore(cases[0]);\n      } else {\n        openingBrace = sourceCode.getLastToken(node, 1);\n      }\n\n      checkPrecedingSpace(openingBrace);\n    }\n\n    return {\n      BlockStatement: checkPrecedingSpace,\n      ClassBody: checkPrecedingSpace,\n      SwitchStatement: checkSpaceBeforeCaseBlock\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","isFunctionBody","node","parent","type","isFunction","body","module","exports","meta","docs","description","recommended","url","fixable","schema","oneOf","enum","properties","keywords","functions","classes","additionalProperties","messages","unexpectedSpace","missingSpace","create","context","config","options","sourceCode","getSourceCode","alwaysFunctions","alwaysKeywords","alwaysClasses","neverFunctions","neverKeywords","neverClasses","isConflicted","precedingToken","isArrowToken","isKeywordToken","isColonToken","getSwitchCaseColonToken","checkPrecedingSpace","getTokenBefore","isTokenOnSameLine","hasSpace","isSpaceBetweenTokens","requireSpace","requireNoSpace","report","messageId","fix","fixer","insertTextBefore","removeRange","range","checkSpaceBeforeCaseBlock","cases","openingBrace","length","getLastToken","BlockStatement","ClassBody","SwitchStatement"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/space-before-blocks.js"],"sourcesContent":["/**\n * @fileoverview A rule to ensure whitespace before blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether the given node represents the body of a function.\n * @param {ASTNode} node the node to check.\n * @returns {boolean} `true` if the node is function body.\n */\nfunction isFunctionBody(node) {\n    const parent = node.parent;\n\n    return (\n        node.type === \"BlockStatement\" &&\n        astUtils.isFunction(parent) &&\n        parent.body === node\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent spacing before blocks\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/space-before-blocks\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            keywords: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            },\n                            functions: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\", \"off\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedSpace: \"Unexpected space before opening brace.\",\n            missingSpace: \"Missing space before opening brace.\"\n        }\n    },\n\n    create(context) {\n        const config = context.options[0],\n            sourceCode = context.getSourceCode();\n        let alwaysFunctions = true,\n            alwaysKeywords = true,\n            alwaysClasses = true,\n            neverFunctions = false,\n            neverKeywords = false,\n            neverClasses = false;\n\n        if (typeof config === \"object\") {\n            alwaysFunctions = config.functions === \"always\";\n            alwaysKeywords = config.keywords === \"always\";\n            alwaysClasses = config.classes === \"always\";\n            neverFunctions = config.functions === \"never\";\n            neverKeywords = config.keywords === \"never\";\n            neverClasses = config.classes === \"never\";\n        } else if (config === \"never\") {\n            alwaysFunctions = false;\n            alwaysKeywords = false;\n            alwaysClasses = false;\n            neverFunctions = true;\n            neverKeywords = true;\n            neverClasses = true;\n        }\n\n        /**\n         * Checks whether the spacing before the given block is already controlled by another rule:\n         * - `arrow-spacing` checks spaces after `=>`.\n         * - `keyword-spacing` checks spaces after keywords in certain contexts.\n         * - `switch-colon-spacing` checks spaces after `:` of switch cases.\n         * @param {Token} precedingToken first token before the block.\n         * @param {ASTNode|Token} node `BlockStatement` node or `{` token of a `SwitchStatement` node.\n         * @returns {boolean} `true` if requiring or disallowing spaces before the given block could produce conflicts with other rules.\n         */\n        function isConflicted(precedingToken, node) {\n            return (\n                astUtils.isArrowToken(precedingToken) ||\n                (\n                    astUtils.isKeywordToken(precedingToken) &&\n                    !isFunctionBody(node)\n                ) ||\n                (\n                    astUtils.isColonToken(precedingToken) &&\n                    node.parent &&\n                    node.parent.type === \"SwitchCase\" &&\n                    precedingToken === astUtils.getSwitchCaseColonToken(node.parent, sourceCode)\n                )\n            );\n        }\n\n        /**\n         * Checks the given BlockStatement node has a preceding space if it doesnâ€™t start on a new line.\n         * @param {ASTNode|Token} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPrecedingSpace(node) {\n            const precedingToken = sourceCode.getTokenBefore(node);\n\n            if (precedingToken && !isConflicted(precedingToken, node) && astUtils.isTokenOnSameLine(precedingToken, node)) {\n                const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);\n                let requireSpace;\n                let requireNoSpace;\n\n                if (isFunctionBody(node)) {\n                    requireSpace = alwaysFunctions;\n                    requireNoSpace = neverFunctions;\n                } else if (node.type === \"ClassBody\") {\n                    requireSpace = alwaysClasses;\n                    requireNoSpace = neverClasses;\n                } else {\n                    requireSpace = alwaysKeywords;\n                    requireNoSpace = neverKeywords;\n                }\n\n                if (requireSpace && !hasSpace) {\n                    context.report({\n                        node,\n                        messageId: \"missingSpace\",\n                        fix(fixer) {\n                            return fixer.insertTextBefore(node, \" \");\n                        }\n                    });\n                } else if (requireNoSpace && hasSpace) {\n                    context.report({\n                        node,\n                        messageId: \"unexpectedSpace\",\n                        fix(fixer) {\n                            return fixer.removeRange([precedingToken.range[1], node.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n         * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.\n         * @param {ASTNode} node The node of a SwitchStatement.\n         * @returns {void} undefined.\n         */\n        function checkSpaceBeforeCaseBlock(node) {\n            const cases = node.cases;\n            let openingBrace;\n\n            if (cases.length > 0) {\n                openingBrace = sourceCode.getTokenBefore(cases[0]);\n            } else {\n                openingBrace = sourceCode.getLastToken(node, 1);\n            }\n\n            checkPrecedingSpace(openingBrace);\n        }\n\n        return {\n            BlockStatement: checkPrecedingSpace,\n            ClassBody: checkPrecedingSpace,\n            SwitchStatement: checkSpaceBeforeCaseBlock\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}