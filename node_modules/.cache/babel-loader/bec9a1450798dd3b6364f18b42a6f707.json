{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils_1 = require(\"tsutils\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'no-unnecessary-type-assertion',\n  meta: {\n    docs: {\n      description: 'Disallow type assertions that do not change the type of an expression',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    fixable: 'code',\n    messages: {\n      unnecessaryAssertion: 'This assertion is unnecessary since it does not change the type of the expression.',\n      contextuallyUnnecessary: 'This assertion is unnecessary since the receiver accepts the original type of the expression.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        typesToIgnore: {\n          description: 'A list of type names to ignore.',\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        }\n      }\n    }],\n    type: 'suggestion'\n  },\n  defaultOptions: [{}],\n\n  create(context, _ref) {\n    let [options] = _ref;\n    const sourceCode = context.getSourceCode();\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const compilerOptions = parserServices.program.getCompilerOptions();\n    /**\n     * Sometimes tuple types don't have ObjectFlags.Tuple set, like when they're being matched against an inferred type.\n     * So, in addition, check if there are integer properties 0..n and no other numeric keys\n     */\n\n    function couldBeTupleType(type) {\n      const properties = type.getProperties();\n\n      if (properties.length === 0) {\n        return false;\n      }\n\n      let i = 0;\n\n      for (; i < properties.length; ++i) {\n        const name = properties[i].name;\n\n        if (String(i) !== name) {\n          if (i === 0) {\n            // if there are no integer properties, this is not a tuple\n            return false;\n          }\n\n          break;\n        }\n      }\n\n      for (; i < properties.length; ++i) {\n        if (String(+properties[i].name) === properties[i].name) {\n          return false; // if there are any other numeric properties, this is not a tuple\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Returns true if there's a chance the variable has been used before a value has been assigned to it\n     */\n\n\n    function isPossiblyUsedBeforeAssigned(node) {\n      const declaration = util.getDeclaration(checker, node);\n\n      if (!declaration) {\n        // don't know what the declaration is for some reason, so just assume the worst\n        return true;\n      }\n\n      if ( // non-strict mode doesn't care about used before assigned errors\n      (0, tsutils_1.isStrictCompilerOptionEnabled)(compilerOptions, 'strictNullChecks') && // ignore class properties as they are compile time guarded\n      // also ignore function arguments as they can't be used before defined\n      (0, tsutils_1.isVariableDeclaration)(declaration) && // is it `const x!: number`\n      declaration.initializer === undefined && declaration.exclamationToken === undefined && declaration.type !== undefined) {\n        // check if the defined variable type has changed since assignment\n        const declarationType = checker.getTypeFromTypeNode(declaration.type);\n        const type = util.getConstrainedTypeAtLocation(checker, node);\n\n        if (declarationType === type) {\n          // possibly used before assigned, so just skip it\n          // better to false negative and skip it, than false positive and fix to compile erroring code\n          //\n          // no better way to figure this out right now\n          // https://github.com/Microsoft/TypeScript/issues/31124\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function isConstAssertion(node) {\n      return node.type === utils_1.AST_NODE_TYPES.TSTypeReference && node.typeName.type === utils_1.AST_NODE_TYPES.Identifier && node.typeName.name === 'const';\n    }\n\n    return {\n      TSNonNullExpression(node) {\n        var _a;\n\n        if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.AssignmentExpression && node.parent.operator === '=') {\n          if (node.parent.left === node) {\n            context.report({\n              node,\n              messageId: 'contextuallyUnnecessary',\n\n              fix(fixer) {\n                return fixer.removeRange([node.expression.range[1], node.range[1]]);\n              }\n\n            });\n          } // for all other = assignments we ignore non-null checks\n          // this is because non-null assertions can change the type-flow of the code\n          // so whilst they might be unnecessary for the assignment - they are necessary\n          // for following code\n\n\n          return;\n        }\n\n        const originalNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n        const type = util.getConstrainedTypeAtLocation(checker, originalNode.expression);\n\n        if (!util.isNullableType(type)) {\n          if (isPossiblyUsedBeforeAssigned(originalNode.expression)) {\n            return;\n          }\n\n          context.report({\n            node,\n            messageId: 'unnecessaryAssertion',\n\n            fix(fixer) {\n              return fixer.removeRange([node.expression.range[1], node.range[1]]);\n            }\n\n          });\n        } else {\n          // we know it's a nullable type\n          // so figure out if the variable is used in a place that accepts nullable types\n          const contextualType = util.getContextualType(checker, originalNode);\n\n          if (contextualType) {\n            // in strict mode you can't assign null to undefined, so we have to make sure that\n            // the two types share a nullable type\n            const typeIncludesUndefined = util.isTypeFlagSet(type, ts.TypeFlags.Undefined);\n            const typeIncludesNull = util.isTypeFlagSet(type, ts.TypeFlags.Null);\n            const contextualTypeIncludesUndefined = util.isTypeFlagSet(contextualType, ts.TypeFlags.Undefined);\n            const contextualTypeIncludesNull = util.isTypeFlagSet(contextualType, ts.TypeFlags.Null); // make sure that the parent accepts the same types\n            // i.e. assigning `string | null | undefined` to `string | undefined` is invalid\n\n            const isValidUndefined = typeIncludesUndefined ? contextualTypeIncludesUndefined : true;\n            const isValidNull = typeIncludesNull ? contextualTypeIncludesNull : true;\n\n            if (isValidUndefined && isValidNull) {\n              context.report({\n                node,\n                messageId: 'contextuallyUnnecessary',\n\n                fix(fixer) {\n                  return fixer.removeRange([node.expression.range[1], node.range[1]]);\n                }\n\n              });\n            }\n          }\n        }\n      },\n\n      'TSAsExpression, TSTypeAssertion'(node) {\n        var _a;\n\n        if (((_a = options.typesToIgnore) === null || _a === void 0 ? void 0 : _a.includes(sourceCode.getText(node.typeAnnotation))) || isConstAssertion(node.typeAnnotation)) {\n          return;\n        }\n\n        const originalNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n        const castType = checker.getTypeAtLocation(originalNode);\n\n        if ((0, tsutils_1.isTypeFlagSet)(castType, ts.TypeFlags.Literal) || (0, tsutils_1.isObjectType)(castType) && ((0, tsutils_1.isObjectFlagSet)(castType, ts.ObjectFlags.Tuple) || couldBeTupleType(castType))) {\n          // It's not always safe to remove a cast to a literal type or tuple\n          // type, as those types are sometimes widened without the cast.\n          return;\n        }\n\n        const uncastType = checker.getTypeAtLocation(originalNode.expression);\n\n        if (uncastType === castType) {\n          context.report({\n            node,\n            messageId: 'unnecessaryAssertion',\n\n            fix(fixer) {\n              if (originalNode.kind === ts.SyntaxKind.TypeAssertionExpression) {\n                const closingAngleBracket = sourceCode.getTokenAfter(node.typeAnnotation);\n                return (closingAngleBracket === null || closingAngleBracket === void 0 ? void 0 : closingAngleBracket.value) === '>' ? fixer.removeRange([node.range[0], closingAngleBracket.range[1]]) : null;\n              }\n\n              return fixer.removeRange([node.expression.range[1] + 1, node.range[1]]);\n            }\n\n          });\n        } // TODO - add contextually unnecessary check for this\n\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AACA;;AAOA;;AAEA;;AASAA,kBAAeC,IAAI,CAACC,UAAL,CAAqC;EAClDC,IAAI,EAAE,+BAD4C;EAElDC,IAAI,EAAE;IACJC,IAAI,EAAE;MACJC,WAAW,EACT,uEAFE;MAGJC,WAAW,EAAE,OAHT;MAIJC,oBAAoB,EAAE;IAJlB,CADF;IAOJC,OAAO,EAAE,MAPL;IAQJC,QAAQ,EAAE;MACRC,oBAAoB,EAClB,oFAFM;MAGRC,uBAAuB,EACrB;IAJM,CARN;IAcJC,MAAM,EAAE,CACN;MACEC,IAAI,EAAE,QADR;MAEEC,UAAU,EAAE;QACVC,aAAa,EAAE;UACbV,WAAW,EAAE,iCADA;UAEbQ,IAAI,EAAE,OAFO;UAGbG,KAAK,EAAE;YACLH,IAAI,EAAE;UADD;QAHM;MADL;IAFd,CADM,CAdJ;IA4BJA,IAAI,EAAE;EA5BF,CAF4C;EAgClDI,cAAc,EAAE,CAAC,EAAD,CAhCkC;;EAiClDC,MAAM,CAACC,OAAD,QAAmB;IAAA,IAAT,CAACC,OAAD,CAAS;IACvB,MAAMC,UAAU,GAAGF,OAAO,CAACG,aAAR,EAAnB;IACA,MAAMC,cAAc,GAAGvB,IAAI,CAACwB,iBAAL,CAAuBL,OAAvB,CAAvB;IACA,MAAMM,OAAO,GAAGF,cAAc,CAACG,OAAf,CAAuBC,cAAvB,EAAhB;IACA,MAAMC,eAAe,GAAGL,cAAc,CAACG,OAAf,CAAuBG,kBAAvB,EAAxB;IAEA;;;;;IAIA,SAASC,gBAAT,CAA0BjB,IAA1B,EAA6C;MAC3C,MAAMC,UAAU,GAAGD,IAAI,CAACkB,aAAL,EAAnB;;MAEA,IAAIjB,UAAU,CAACkB,MAAX,KAAsB,CAA1B,EAA6B;QAC3B,OAAO,KAAP;MACD;;MACD,IAAIC,CAAC,GAAG,CAAR;;MAEA,OAAOA,CAAC,GAAGnB,UAAU,CAACkB,MAAtB,EAA8B,EAAEC,CAAhC,EAAmC;QACjC,MAAM/B,IAAI,GAAGY,UAAU,CAACmB,CAAD,CAAV,CAAc/B,IAA3B;;QAEA,IAAIgC,MAAM,CAACD,CAAD,CAAN,KAAc/B,IAAlB,EAAwB;UACtB,IAAI+B,CAAC,KAAK,CAAV,EAAa;YACX;YACA,OAAO,KAAP;UACD;;UACD;QACD;MACF;;MACD,OAAOA,CAAC,GAAGnB,UAAU,CAACkB,MAAtB,EAA8B,EAAEC,CAAhC,EAAmC;QACjC,IAAIC,MAAM,CAAC,CAACpB,UAAU,CAACmB,CAAD,CAAV,CAAc/B,IAAhB,CAAN,KAAgCY,UAAU,CAACmB,CAAD,CAAV,CAAc/B,IAAlD,EAAwD;UACtD,OAAO,KAAP,CADsD,CACxC;QACf;MACF;;MACD,OAAO,IAAP;IACD;IAED;;;;;IAGA,SAASiC,4BAAT,CAAsCC,IAAtC,EAAyD;MACvD,MAAMC,WAAW,GAAGrC,IAAI,CAACsC,cAAL,CAAoBb,OAApB,EAA6BW,IAA7B,CAApB;;MACA,IAAI,CAACC,WAAL,EAAkB;QAChB;QACA,OAAO,IAAP;MACD;;MAED,KACE;MACA,6CAA8BT,eAA9B,EAA+C,kBAA/C,KACA;MACA;MACA,qCAAsBS,WAAtB,CAHA,IAIA;MACAA,WAAW,CAACE,WAAZ,KAA4BC,SAL5B,IAMAH,WAAW,CAACI,gBAAZ,KAAiCD,SANjC,IAOAH,WAAW,CAACxB,IAAZ,KAAqB2B,SATvB,EAUE;QACA;QACA,MAAME,eAAe,GAAGjB,OAAO,CAACkB,mBAAR,CAA4BN,WAAW,CAACxB,IAAxC,CAAxB;QACA,MAAMA,IAAI,GAAGb,IAAI,CAAC4C,4BAAL,CAAkCnB,OAAlC,EAA2CW,IAA3C,CAAb;;QACA,IAAIM,eAAe,KAAK7B,IAAxB,EAA8B;UAC5B;UACA;UACA;UACA;UACA;UACA,OAAO,IAAP;QACD;MACF;;MACD,OAAO,KAAP;IACD;;IAED,SAASgC,gBAAT,CAA0BT,IAA1B,EAAiD;MAC/C,OACEA,IAAI,CAACvB,IAAL,KAAciC,uBAAeC,eAA7B,IACAX,IAAI,CAACY,QAAL,CAAcnC,IAAd,KAAuBiC,uBAAeG,UADtC,IAEAb,IAAI,CAACY,QAAL,CAAc9C,IAAd,KAAuB,OAHzB;IAKD;;IAED,OAAO;MACLgD,mBAAmB,CAACd,IAAD,EAAK;;;QACtB,IACE,WAAI,CAACe,MAAL,MAAW,IAAX,IAAWC,aAAX,GAAW,MAAX,GAAWA,GAAEvC,IAAb,MAAsBiC,uBAAeO,oBAArC,IACAjB,IAAI,CAACe,MAAL,CAAYG,QAAZ,KAAyB,GAF3B,EAGE;UACA,IAAIlB,IAAI,CAACe,MAAL,CAAYI,IAAZ,KAAqBnB,IAAzB,EAA+B;YAC7BjB,OAAO,CAACqC,MAAR,CAAe;cACbpB,IADa;cAEbqB,SAAS,EAAE,yBAFE;;cAGbC,GAAG,CAACC,KAAD,EAAM;gBACP,OAAOA,KAAK,CAACC,WAAN,CAAkB,CACvBxB,IAAI,CAACyB,UAAL,CAAgBC,KAAhB,CAAsB,CAAtB,CADuB,EAEvB1B,IAAI,CAAC0B,KAAL,CAAW,CAAX,CAFuB,CAAlB,CAAP;cAID;;YARY,CAAf;UAUD,CAZD,CAaA;UACA;UACA;UACA;;;UACA;QACD;;QAED,MAAMC,YAAY,GAAGxC,cAAc,CAACyC,qBAAf,CAAqCC,GAArC,CAAyC7B,IAAzC,CAArB;QAEA,MAAMvB,IAAI,GAAGb,IAAI,CAAC4C,4BAAL,CACXnB,OADW,EAEXsC,YAAY,CAACF,UAFF,CAAb;;QAKA,IAAI,CAAC7D,IAAI,CAACkE,cAAL,CAAoBrD,IAApB,CAAL,EAAgC;UAC9B,IAAIsB,4BAA4B,CAAC4B,YAAY,CAACF,UAAd,CAAhC,EAA2D;YACzD;UACD;;UAED1C,OAAO,CAACqC,MAAR,CAAe;YACbpB,IADa;YAEbqB,SAAS,EAAE,sBAFE;;YAGbC,GAAG,CAACC,KAAD,EAAM;cACP,OAAOA,KAAK,CAACC,WAAN,CAAkB,CACvBxB,IAAI,CAACyB,UAAL,CAAgBC,KAAhB,CAAsB,CAAtB,CADuB,EAEvB1B,IAAI,CAAC0B,KAAL,CAAW,CAAX,CAFuB,CAAlB,CAAP;YAID;;UARY,CAAf;QAUD,CAfD,MAeO;UACL;UACA;UAEA,MAAMK,cAAc,GAAGnE,IAAI,CAACoE,iBAAL,CAAuB3C,OAAvB,EAAgCsC,YAAhC,CAAvB;;UACA,IAAII,cAAJ,EAAoB;YAClB;YACA;YACA,MAAME,qBAAqB,GAAGrE,IAAI,CAACsE,aAAL,CAC5BzD,IAD4B,EAE5B0D,EAAE,CAACC,SAAH,CAAaC,SAFe,CAA9B;YAIA,MAAMC,gBAAgB,GAAG1E,IAAI,CAACsE,aAAL,CACvBzD,IADuB,EAEvB0D,EAAE,CAACC,SAAH,CAAaG,IAFU,CAAzB;YAKA,MAAMC,+BAA+B,GAAG5E,IAAI,CAACsE,aAAL,CACtCH,cADsC,EAEtCI,EAAE,CAACC,SAAH,CAAaC,SAFyB,CAAxC;YAIA,MAAMI,0BAA0B,GAAG7E,IAAI,CAACsE,aAAL,CACjCH,cADiC,EAEjCI,EAAE,CAACC,SAAH,CAAaG,IAFoB,CAAnC,CAhBkB,CAqBlB;YACA;;YACA,MAAMG,gBAAgB,GAAGT,qBAAqB,GAC1CO,+BAD0C,GAE1C,IAFJ;YAGA,MAAMG,WAAW,GAAGL,gBAAgB,GAChCG,0BADgC,GAEhC,IAFJ;;YAIA,IAAIC,gBAAgB,IAAIC,WAAxB,EAAqC;cACnC5D,OAAO,CAACqC,MAAR,CAAe;gBACbpB,IADa;gBAEbqB,SAAS,EAAE,yBAFE;;gBAGbC,GAAG,CAACC,KAAD,EAAM;kBACP,OAAOA,KAAK,CAACC,WAAN,CAAkB,CACvBxB,IAAI,CAACyB,UAAL,CAAgBC,KAAhB,CAAsB,CAAtB,CADuB,EAEvB1B,IAAI,CAAC0B,KAAL,CAAW,CAAX,CAFuB,CAAlB,CAAP;gBAID;;cARY,CAAf;YAUD;UACF;QACF;MACF,CAhGI;;MAiGL,kCACE1B,IADF,EAC0D;;;QAExD,IACE,cAAO,CAACrB,aAAR,MAAqB,IAArB,IAAqBqC,aAArB,GAAqB,MAArB,GAAqBA,GAAE4B,QAAF,CACnB3D,UAAU,CAAC4D,OAAX,CAAmB7C,IAAI,CAAC8C,cAAxB,CADmB,CAArB,KAGArC,gBAAgB,CAACT,IAAI,CAAC8C,cAAN,CAJlB,EAKE;UACA;QACD;;QAED,MAAMnB,YAAY,GAAGxC,cAAc,CAACyC,qBAAf,CAAqCC,GAArC,CAAyC7B,IAAzC,CAArB;QACA,MAAM+C,QAAQ,GAAG1D,OAAO,CAAC2D,iBAAR,CAA0BrB,YAA1B,CAAjB;;QAEA,IACE,6BAAcoB,QAAd,EAAwBZ,EAAE,CAACC,SAAH,CAAaa,OAArC,KACC,4BAAaF,QAAb,MACE,+BAAgBA,QAAhB,EAA0BZ,EAAE,CAACe,WAAH,CAAeC,KAAzC,KACCzD,gBAAgB,CAACqD,QAAD,CAFnB,CAFH,EAKE;UACA;UACA;UACA;QACD;;QAED,MAAMK,UAAU,GAAG/D,OAAO,CAAC2D,iBAAR,CAA0BrB,YAAY,CAACF,UAAvC,CAAnB;;QAEA,IAAI2B,UAAU,KAAKL,QAAnB,EAA6B;UAC3BhE,OAAO,CAACqC,MAAR,CAAe;YACbpB,IADa;YAEbqB,SAAS,EAAE,sBAFE;;YAGbC,GAAG,CAACC,KAAD,EAAM;cACP,IAAII,YAAY,CAAC0B,IAAb,KAAsBlB,EAAE,CAACmB,UAAH,CAAcC,uBAAxC,EAAiE;gBAC/D,MAAMC,mBAAmB,GAAGvE,UAAU,CAACwE,aAAX,CAC1BzD,IAAI,CAAC8C,cADqB,CAA5B;gBAGA,OAAO,oBAAmB,SAAnB,uBAAmB,WAAnB,GAAmB,MAAnB,sBAAmB,CAAEY,KAArB,MAA+B,GAA/B,GACHnC,KAAK,CAACC,WAAN,CAAkB,CAChBxB,IAAI,CAAC0B,KAAL,CAAW,CAAX,CADgB,EAEhB8B,mBAAmB,CAAC9B,KAApB,CAA0B,CAA1B,CAFgB,CAAlB,CADG,GAKH,IALJ;cAMD;;cACD,OAAOH,KAAK,CAACC,WAAN,CAAkB,CACvBxB,IAAI,CAACyB,UAAL,CAAgBC,KAAhB,CAAsB,CAAtB,IAA2B,CADJ,EAEvB1B,IAAI,CAAC0B,KAAL,CAAW,CAAX,CAFuB,CAAlB,CAAP;YAID;;UAnBY,CAAf;QAqBD,CAjDuD,CAmDxD;;MACD;;IAtJI,CAAP;EAwJD;;AA1QiD,CAArC,CAAf","names":["exports","util","createRule","name","meta","docs","description","recommended","requiresTypeChecking","fixable","messages","unnecessaryAssertion","contextuallyUnnecessary","schema","type","properties","typesToIgnore","items","defaultOptions","create","context","options","sourceCode","getSourceCode","parserServices","getParserServices","checker","program","getTypeChecker","compilerOptions","getCompilerOptions","couldBeTupleType","getProperties","length","i","String","isPossiblyUsedBeforeAssigned","node","declaration","getDeclaration","initializer","undefined","exclamationToken","declarationType","getTypeFromTypeNode","getConstrainedTypeAtLocation","isConstAssertion","utils_1","TSTypeReference","typeName","Identifier","TSNonNullExpression","parent","_a","AssignmentExpression","operator","left","report","messageId","fix","fixer","removeRange","expression","range","originalNode","esTreeNodeToTSNodeMap","get","isNullableType","contextualType","getContextualType","typeIncludesUndefined","isTypeFlagSet","ts","TypeFlags","Undefined","typeIncludesNull","Null","contextualTypeIncludesUndefined","contextualTypeIncludesNull","isValidUndefined","isValidNull","includes","getText","typeAnnotation","castType","getTypeAtLocation","Literal","ObjectFlags","Tuple","uncastType","kind","SyntaxKind","TypeAssertionExpression","closingAngleBracket","getTokenAfter","value"],"sources":["../../src/rules/no-unnecessary-type-assertion.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}