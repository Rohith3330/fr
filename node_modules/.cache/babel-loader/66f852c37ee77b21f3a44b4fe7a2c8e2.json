{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nconst enumValues = ['always', 'never', 'in-unions', 'in-intersections', 'in-unions-and-intersections'];\nexports.default = util.createRule({\n  name: 'no-type-alias',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow type aliases',\n      // too opinionated to be recommended\n      recommended: false\n    },\n    messages: {\n      noTypeAlias: 'Type {{alias}} are not allowed.',\n      noCompositionAlias: '{{typeName}} in {{compositionType}} types are not allowed.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowAliases: {\n          description: 'Whether to allow direct one-to-one type aliases.',\n          enum: enumValues\n        },\n        allowCallbacks: {\n          description: 'Whether to allow type aliases for callbacks.',\n          enum: ['always', 'never']\n        },\n        allowConditionalTypes: {\n          description: 'Whether to allow type aliases for conditional types.',\n          enum: ['always', 'never']\n        },\n        allowConstructors: {\n          description: 'Whether to allow type aliases with constructors.',\n          enum: ['always', 'never']\n        },\n        allowLiterals: {\n          description: 'Whether to allow type aliases with object literal types.',\n          enum: enumValues\n        },\n        allowMappedTypes: {\n          description: 'Whether to allow type aliases with mapped types.',\n          enum: enumValues\n        },\n        allowTupleTypes: {\n          description: 'Whether to allow type aliases with tuple types.',\n          enum: enumValues\n        },\n        allowGenerics: {\n          description: 'Whether to allow type aliases with generic types.',\n          enum: ['always', 'never']\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    allowAliases: 'never',\n    allowCallbacks: 'never',\n    allowConditionalTypes: 'never',\n    allowConstructors: 'never',\n    allowLiterals: 'never',\n    allowMappedTypes: 'never',\n    allowTupleTypes: 'never',\n    allowGenerics: 'never'\n  }],\n\n  create(context, _ref) {\n    let [{\n      allowAliases,\n      allowCallbacks,\n      allowConditionalTypes,\n      allowConstructors,\n      allowLiterals,\n      allowMappedTypes,\n      allowTupleTypes,\n      allowGenerics\n    }] = _ref;\n    const unions = ['always', 'in-unions', 'in-unions-and-intersections'];\n    const intersections = ['always', 'in-intersections', 'in-unions-and-intersections'];\n    const compositions = ['in-unions', 'in-intersections', 'in-unions-and-intersections'];\n    const aliasTypes = new Set([utils_1.AST_NODE_TYPES.TSArrayType, utils_1.AST_NODE_TYPES.TSImportType, utils_1.AST_NODE_TYPES.TSTypeReference, utils_1.AST_NODE_TYPES.TSLiteralType, utils_1.AST_NODE_TYPES.TSTypeQuery, utils_1.AST_NODE_TYPES.TSIndexedAccessType, utils_1.AST_NODE_TYPES.TSTemplateLiteralType]);\n    /**\n     * Determines if the composition type is supported by the allowed flags.\n     * @param isTopLevel a flag indicating this is the top level node.\n     * @param compositionType the composition type (either TSUnionType or TSIntersectionType)\n     * @param allowed the currently allowed flags.\n     */\n\n    function isSupportedComposition(isTopLevel, compositionType, allowed) {\n      return !compositions.includes(allowed) || !isTopLevel && (compositionType === utils_1.AST_NODE_TYPES.TSUnionType && unions.includes(allowed) || compositionType === utils_1.AST_NODE_TYPES.TSIntersectionType && intersections.includes(allowed));\n    }\n    /**\n     * Gets the message to be displayed based on the node type and whether the node is a top level declaration.\n     * @param node the location\n     * @param compositionType the type of composition this alias is part of (undefined if not\n     *                                  part of a composition)\n     * @param isRoot a flag indicating we are dealing with the top level declaration.\n     * @param type the kind of type alias being validated.\n     */\n\n\n    function reportError(node, compositionType, isRoot, type) {\n      if (isRoot) {\n        return context.report({\n          node,\n          messageId: 'noTypeAlias',\n          data: {\n            alias: type.toLowerCase()\n          }\n        });\n      }\n\n      return context.report({\n        node,\n        messageId: 'noCompositionAlias',\n        data: {\n          compositionType: compositionType === utils_1.AST_NODE_TYPES.TSUnionType ? 'union' : 'intersection',\n          typeName: type\n        }\n      });\n    }\n\n    const isValidTupleType = type => {\n      if (type.node.type === utils_1.AST_NODE_TYPES.TSTupleType) {\n        return true;\n      }\n\n      if (type.node.type === utils_1.AST_NODE_TYPES.TSTypeOperator) {\n        if (['keyof', 'readonly'].includes(type.node.operator) && type.node.typeAnnotation && type.node.typeAnnotation.type === utils_1.AST_NODE_TYPES.TSTupleType) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    const isValidGeneric = type => {\n      return type.node.type === utils_1.AST_NODE_TYPES.TSTypeReference && type.node.typeParameters !== undefined;\n    };\n\n    const checkAndReport = (optionValue, isTopLevel, type, label) => {\n      if (optionValue === 'never' || !isSupportedComposition(isTopLevel, type.compositionType, optionValue)) {\n        reportError(type.node, type.compositionType, isTopLevel, label);\n      }\n    };\n    /**\n     * Validates the node looking for aliases, callbacks and literals.\n     * @param type the type of composition this alias is part of (null if not\n     *                                  part of a composition)\n     * @param isTopLevel a flag indicating this is the top level node.\n     */\n\n\n    function validateTypeAliases(type) {\n      let isTopLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (type.node.type === utils_1.AST_NODE_TYPES.TSFunctionType) {\n        // callback\n        if (allowCallbacks === 'never') {\n          reportError(type.node, type.compositionType, isTopLevel, 'Callbacks');\n        }\n      } else if (type.node.type === utils_1.AST_NODE_TYPES.TSConditionalType) {\n        // conditional type\n        if (allowConditionalTypes === 'never') {\n          reportError(type.node, type.compositionType, isTopLevel, 'Conditional types');\n        }\n      } else if (type.node.type === utils_1.AST_NODE_TYPES.TSConstructorType) {\n        if (allowConstructors === 'never') {\n          reportError(type.node, type.compositionType, isTopLevel, 'Constructors');\n        }\n      } else if (type.node.type === utils_1.AST_NODE_TYPES.TSTypeLiteral) {\n        // literal object type\n        checkAndReport(allowLiterals, isTopLevel, type, 'Literals');\n      } else if (type.node.type === utils_1.AST_NODE_TYPES.TSMappedType) {\n        // mapped type\n        checkAndReport(allowMappedTypes, isTopLevel, type, 'Mapped types');\n      } else if (isValidTupleType(type)) {\n        // tuple types\n        checkAndReport(allowTupleTypes, isTopLevel, type, 'Tuple Types');\n      } else if (isValidGeneric(type)) {\n        if (allowGenerics === 'never') {\n          reportError(type.node, type.compositionType, isTopLevel, 'Generics');\n        }\n      } else if (type.node.type.endsWith(utils_1.AST_TOKEN_TYPES.Keyword) || aliasTypes.has(type.node.type) || type.node.type === utils_1.AST_NODE_TYPES.TSTypeOperator && (type.node.operator === 'keyof' || type.node.operator === 'readonly' && type.node.typeAnnotation && aliasTypes.has(type.node.typeAnnotation.type))) {\n        // alias / keyword\n        checkAndReport(allowAliases, isTopLevel, type, 'Aliases');\n      } else {\n        // unhandled type - shouldn't happen\n        reportError(type.node, type.compositionType, isTopLevel, 'Unhandled');\n      }\n    }\n    /**\n     * Flatten the given type into an array of its dependencies\n     */\n\n\n    function getTypes(node) {\n      let compositionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (node.type === utils_1.AST_NODE_TYPES.TSUnionType || node.type === utils_1.AST_NODE_TYPES.TSIntersectionType) {\n        return node.types.reduce((acc, type) => {\n          acc.push(...getTypes(type, node.type));\n          return acc;\n        }, []);\n      }\n\n      return [{\n        node,\n        compositionType\n      }];\n    }\n\n    return {\n      TSTypeAliasDeclaration(node) {\n        const types = getTypes(node.typeAnnotation);\n\n        if (types.length === 1) {\n          // is a top level type annotation\n          validateTypeAliases(types[0], true);\n        } else {\n          // is a composition type\n          types.forEach(type => {\n            validateTypeAliases(type);\n          });\n        }\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["enumValues","exports","util","createRule","name","meta","type","docs","description","recommended","messages","noTypeAlias","noCompositionAlias","schema","properties","allowAliases","enum","allowCallbacks","allowConditionalTypes","allowConstructors","allowLiterals","allowMappedTypes","allowTupleTypes","allowGenerics","additionalProperties","defaultOptions","create","context","unions","intersections","compositions","aliasTypes","Set","utils_1","TSArrayType","TSImportType","TSTypeReference","TSLiteralType","TSTypeQuery","TSIndexedAccessType","TSTemplateLiteralType","isSupportedComposition","isTopLevel","compositionType","allowed","includes","TSUnionType","TSIntersectionType","reportError","node","isRoot","report","messageId","data","alias","toLowerCase","typeName","isValidTupleType","TSTupleType","TSTypeOperator","operator","typeAnnotation","isValidGeneric","typeParameters","undefined","checkAndReport","optionValue","label","validateTypeAliases","TSFunctionType","TSConditionalType","TSConstructorType","TSTypeLiteral","TSMappedType","endsWith","Keyword","has","getTypes","types","reduce","acc","push","TSTypeAliasDeclaration","length","forEach"],"sources":["../../src/rules/no-type-alias.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}