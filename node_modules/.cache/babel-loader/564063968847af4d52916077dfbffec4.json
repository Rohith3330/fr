{"ast":null,"code":"import path, { dirname, resolve, extname, normalize, sep } from 'path';\nimport builtinList from 'builtin-modules';\nimport deepMerge from 'deepmerge';\nimport isModule from 'is-module';\nimport fs, { realpathSync } from 'fs';\nimport { promisify } from 'util';\nimport { pathToFileURL, fileURLToPath } from 'url';\nimport resolve$1 from 'resolve';\nimport { createFilter } from '@rollup/pluginutils';\nconst access = promisify(fs.access);\nconst readFile = promisify(fs.readFile);\nconst realpath = promisify(fs.realpath);\nconst stat = promisify(fs.stat);\n\nasync function exists(filePath) {\n  try {\n    await access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nconst onError = error => {\n  if (error.code === 'ENOENT') {\n    return false;\n  }\n\n  throw error;\n};\n\nconst makeCache = fn => {\n  const cache = new Map();\n\n  const wrapped = async (param, done) => {\n    if (cache.has(param) === false) {\n      cache.set(param, fn(param).catch(err => {\n        cache.delete(param);\n        throw err;\n      }));\n    }\n\n    try {\n      const result = cache.get(param);\n      const value = await result;\n      return done(null, value);\n    } catch (error) {\n      return done(error);\n    }\n  };\n\n  wrapped.clear = () => cache.clear();\n\n  return wrapped;\n};\n\nconst isDirCached = makeCache(async file => {\n  try {\n    const stats = await stat(file);\n    return stats.isDirectory();\n  } catch (error) {\n    return onError(error);\n  }\n});\nconst isFileCached = makeCache(async file => {\n  try {\n    const stats = await stat(file);\n    return stats.isFile();\n  } catch (error) {\n    return onError(error);\n  }\n});\nconst readCachedFile = makeCache(readFile); // returns the imported package name for bare module imports\n\nfunction getPackageName(id) {\n  if (id.startsWith('.') || id.startsWith('/')) {\n    return null;\n  }\n\n  const split = id.split('/'); // @my-scope/my-package/foo.js -> @my-scope/my-package\n  // @my-scope/my-package -> @my-scope/my-package\n\n  if (split[0][0] === '@') {\n    return `${split[0]}/${split[1]}`;\n  } // my-package/foo.js -> my-package\n  // my-package -> my-package\n\n\n  return split[0];\n}\n\nfunction getMainFields(options) {\n  let mainFields;\n\n  if (options.mainFields) {\n    ({\n      mainFields\n    } = options);\n  } else {\n    mainFields = ['module', 'main'];\n  }\n\n  if (options.browser && mainFields.indexOf('browser') === -1) {\n    return ['browser'].concat(mainFields);\n  }\n\n  if (!mainFields.length) {\n    throw new Error('Please ensure at least one `mainFields` value is specified');\n  }\n\n  return mainFields;\n}\n\nfunction getPackageInfo(options) {\n  const {\n    cache,\n    extensions,\n    pkg,\n    mainFields,\n    preserveSymlinks,\n    useBrowserOverrides,\n    rootDir,\n    ignoreSideEffectsForRoot\n  } = options;\n  let {\n    pkgPath\n  } = options;\n\n  if (cache.has(pkgPath)) {\n    return cache.get(pkgPath);\n  } // browserify/resolve doesn't realpath paths returned in its packageFilter callback\n\n\n  if (!preserveSymlinks) {\n    pkgPath = realpathSync(pkgPath);\n  }\n\n  const pkgRoot = dirname(pkgPath);\n  const packageInfo = {\n    // copy as we are about to munge the `main` field of `pkg`.\n    packageJson: { ...pkg\n    },\n    // path to package.json file\n    packageJsonPath: pkgPath,\n    // directory containing the package.json\n    root: pkgRoot,\n    // which main field was used during resolution of this module (main, module, or browser)\n    resolvedMainField: 'main',\n    // whether the browser map was used to resolve the entry point to this module\n    browserMappedMain: false,\n    // the entry point of the module with respect to the selected main field and any\n    // relevant browser mappings.\n    resolvedEntryPoint: ''\n  };\n  let overriddenMain = false;\n\n  for (let i = 0; i < mainFields.length; i++) {\n    const field = mainFields[i];\n\n    if (typeof pkg[field] === 'string') {\n      pkg.main = pkg[field];\n      packageInfo.resolvedMainField = field;\n      overriddenMain = true;\n      break;\n    }\n  }\n\n  const internalPackageInfo = {\n    cachedPkg: pkg,\n    hasModuleSideEffects: () => null,\n    hasPackageEntry: overriddenMain !== false || mainFields.indexOf('main') !== -1,\n    packageBrowserField: useBrowserOverrides && typeof pkg.browser === 'object' && Object.keys(pkg.browser).reduce((browser, key) => {\n      let resolved = pkg.browser[key];\n\n      if (resolved && resolved[0] === '.') {\n        resolved = resolve(pkgRoot, resolved);\n      }\n      /* eslint-disable no-param-reassign */\n\n\n      browser[key] = resolved;\n\n      if (key[0] === '.') {\n        const absoluteKey = resolve(pkgRoot, key);\n        browser[absoluteKey] = resolved;\n\n        if (!extname(key)) {\n          extensions.reduce((subBrowser, ext) => {\n            subBrowser[absoluteKey + ext] = subBrowser[key];\n            return subBrowser;\n          }, browser);\n        }\n      }\n\n      return browser;\n    }, {}),\n    packageInfo\n  };\n  const browserMap = internalPackageInfo.packageBrowserField;\n\n  if (useBrowserOverrides && typeof pkg.browser === 'object' && // eslint-disable-next-line no-prototype-builtins\n  browserMap.hasOwnProperty(pkg.main)) {\n    packageInfo.resolvedEntryPoint = browserMap[pkg.main];\n    packageInfo.browserMappedMain = true;\n  } else {\n    // index.node is technically a valid default entrypoint as well...\n    packageInfo.resolvedEntryPoint = resolve(pkgRoot, pkg.main || 'index.js');\n    packageInfo.browserMappedMain = false;\n  }\n\n  if (!ignoreSideEffectsForRoot || rootDir !== pkgRoot) {\n    const packageSideEffects = pkg.sideEffects;\n\n    if (typeof packageSideEffects === 'boolean') {\n      internalPackageInfo.hasModuleSideEffects = () => packageSideEffects;\n    } else if (Array.isArray(packageSideEffects)) {\n      internalPackageInfo.hasModuleSideEffects = createFilter(packageSideEffects, null, {\n        resolve: pkgRoot\n      });\n    }\n  }\n\n  cache.set(pkgPath, internalPackageInfo);\n  return internalPackageInfo;\n}\n\nfunction normalizeInput(input) {\n  if (Array.isArray(input)) {\n    return input;\n  } else if (typeof input === 'object') {\n    return Object.values(input);\n  } // otherwise it's a string\n\n\n  return [input];\n}\n/* eslint-disable no-await-in-loop */\n\n\nconst fileExists = promisify(fs.exists);\n\nfunction isModuleDir(current, moduleDirs) {\n  return moduleDirs.some(dir => current.endsWith(dir));\n}\n\nasync function findPackageJson(base, moduleDirs) {\n  const {\n    root\n  } = path.parse(base);\n  let current = base;\n\n  while (current !== root && !isModuleDir(current, moduleDirs)) {\n    const pkgJsonPath = path.join(current, 'package.json');\n\n    if (await fileExists(pkgJsonPath)) {\n      const pkgJsonString = fs.readFileSync(pkgJsonPath, 'utf-8');\n      return {\n        pkgJson: JSON.parse(pkgJsonString),\n        pkgPath: current,\n        pkgJsonPath\n      };\n    }\n\n    current = path.resolve(current, '..');\n  }\n\n  return null;\n}\n\nfunction isUrl(str) {\n  try {\n    return !!new URL(str);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction isConditions(exports) {\n  return typeof exports === 'object' && Object.keys(exports).every(k => !k.startsWith('.'));\n}\n\nfunction isMappings(exports) {\n  return typeof exports === 'object' && !isConditions(exports);\n}\n\nfunction isMixedExports(exports) {\n  const keys = Object.keys(exports);\n  return keys.some(k => k.startsWith('.')) && keys.some(k => !k.startsWith('.'));\n}\n\nfunction createBaseErrorMsg(importSpecifier, importer) {\n  return `Could not resolve import \"${importSpecifier}\" in ${importer}`;\n}\n\nfunction createErrorMsg(context, reason, internal) {\n  const {\n    importSpecifier,\n    importer,\n    pkgJsonPath\n  } = context;\n  const base = createBaseErrorMsg(importSpecifier, importer);\n  const field = internal ? 'imports' : 'exports';\n  return `${base} using ${field} defined in ${pkgJsonPath}.${reason ? ` ${reason}` : ''}`;\n}\n\nclass ResolveError extends Error {}\n\nclass InvalidConfigurationError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, `Invalid \"exports\" field. ${reason}`));\n  }\n\n}\n\nclass InvalidModuleSpecifierError extends ResolveError {\n  constructor(context, internal) {\n    super(createErrorMsg(context, internal));\n  }\n\n}\n\nclass InvalidPackageTargetError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, reason));\n  }\n\n}\n/* eslint-disable no-await-in-loop, no-undefined */\n\n\nfunction includesInvalidSegments(pathSegments, moduleDirs) {\n  return pathSegments.split('/').slice(1).some(t => ['.', '..', ...moduleDirs].includes(t));\n}\n\nasync function resolvePackageTarget(context, _ref) {\n  let {\n    target,\n    subpath,\n    pattern,\n    internal\n  } = _ref;\n\n  if (typeof target === 'string') {\n    if (!pattern && subpath.length > 0 && !target.endsWith('/')) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n\n    if (!target.startsWith('./')) {\n      if (internal && !['/', '../'].some(p => target.startsWith(p)) && !isUrl(target)) {\n        // this is a bare package import, remap it and resolve it using regular node resolve\n        if (pattern) {\n          const result = await context.resolveId(target.replace(/\\*/g, subpath), context.pkgURL.href);\n          return result ? pathToFileURL(result.location) : null;\n        }\n\n        const result = await context.resolveId(`${target}${subpath}`, context.pkgURL.href);\n        return result ? pathToFileURL(result.location) : null;\n      }\n\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n\n    if (includesInvalidSegments(target, context.moduleDirs)) {\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n\n    const resolvedTarget = new URL(target, context.pkgURL);\n\n    if (!resolvedTarget.href.startsWith(context.pkgURL.href)) {\n      throw new InvalidPackageTargetError(context, `Resolved to ${resolvedTarget.href} which is outside package ${context.pkgURL.href}`);\n    }\n\n    if (includesInvalidSegments(subpath, context.moduleDirs)) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n\n    if (pattern) {\n      return resolvedTarget.href.replace(/\\*/g, subpath);\n    }\n\n    return new URL(subpath, resolvedTarget).href;\n  }\n\n  if (Array.isArray(target)) {\n    let lastError;\n\n    for (const item of target) {\n      try {\n        const resolved = await resolvePackageTarget(context, {\n          target: item,\n          subpath,\n          pattern,\n          internal\n        }); // return if defined or null, but not undefined\n\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      } catch (error) {\n        if (!(error instanceof InvalidPackageTargetError)) {\n          throw error;\n        } else {\n          lastError = error;\n        }\n      }\n    }\n\n    if (lastError) {\n      throw lastError;\n    }\n\n    return null;\n  }\n\n  if (target && typeof target === 'object') {\n    for (const [key, value] of Object.entries(target)) {\n      if (key === 'default' || context.conditions.includes(key)) {\n        const resolved = await resolvePackageTarget(context, {\n          target: value,\n          subpath,\n          pattern,\n          internal\n        }); // return if defined or null, but not undefined\n\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  if (target === null) {\n    return null;\n  }\n\n  throw new InvalidPackageTargetError(context, `Invalid exports field.`);\n}\n/* eslint-disable no-await-in-loop */\n\n\nasync function resolvePackageImportsExports(context, _ref2) {\n  let {\n    matchKey,\n    matchObj,\n    internal\n  } = _ref2;\n\n  if (!matchKey.endsWith('*') && matchKey in matchObj) {\n    const target = matchObj[matchKey];\n    const resolved = await resolvePackageTarget(context, {\n      target,\n      subpath: '',\n      internal\n    });\n    return resolved;\n  }\n\n  const expansionKeys = Object.keys(matchObj).filter(k => k.endsWith('/') || k.endsWith('*')).sort((a, b) => b.length - a.length);\n\n  for (const expansionKey of expansionKeys) {\n    const prefix = expansionKey.substring(0, expansionKey.length - 1);\n\n    if (expansionKey.endsWith('*') && matchKey.startsWith(prefix)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length - 1);\n      const resolved = await resolvePackageTarget(context, {\n        target,\n        subpath,\n        pattern: true,\n        internal\n      });\n      return resolved;\n    }\n\n    if (matchKey.startsWith(expansionKey)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length);\n      const resolved = await resolvePackageTarget(context, {\n        target,\n        subpath,\n        internal\n      });\n      return resolved;\n    }\n  }\n\n  throw new InvalidModuleSpecifierError(context, internal);\n}\n\nasync function resolvePackageExports(context, subpath, exports) {\n  if (isMixedExports(exports)) {\n    throw new InvalidConfigurationError(context, 'All keys must either start with ./, or without one.');\n  }\n\n  if (subpath === '.') {\n    let mainExport; // If exports is a String or Array, or an Object containing no keys starting with \".\", then\n\n    if (typeof exports === 'string' || Array.isArray(exports) || isConditions(exports)) {\n      mainExport = exports;\n    } else if (isMappings(exports)) {\n      mainExport = exports['.'];\n    }\n\n    if (mainExport) {\n      const resolved = await resolvePackageTarget(context, {\n        target: mainExport,\n        subpath: ''\n      });\n\n      if (resolved) {\n        return resolved;\n      }\n    }\n  } else if (isMappings(exports)) {\n    const resolvedMatch = await resolvePackageImportsExports(context, {\n      matchKey: subpath,\n      matchObj: exports\n    });\n\n    if (resolvedMatch) {\n      return resolvedMatch;\n    }\n  }\n\n  throw new InvalidModuleSpecifierError(context);\n}\n\nasync function resolvePackageImports(_ref3) {\n  let {\n    importSpecifier,\n    importer,\n    moduleDirs,\n    conditions,\n    resolveId\n  } = _ref3;\n  const result = await findPackageJson(importer, moduleDirs);\n\n  if (!result) {\n    throw new Error(createBaseErrorMsg('. Could not find a parent package.json.'));\n  }\n\n  const {\n    pkgPath,\n    pkgJsonPath,\n    pkgJson\n  } = result;\n  const pkgURL = pathToFileURL(`${pkgPath}/`);\n  const context = {\n    importer,\n    importSpecifier,\n    moduleDirs,\n    pkgURL,\n    pkgJsonPath,\n    conditions,\n    resolveId\n  };\n  const {\n    imports\n  } = pkgJson;\n\n  if (!imports) {\n    throw new InvalidModuleSpecifierError(context, true);\n  }\n\n  if (importSpecifier === '#' || importSpecifier.startsWith('#/')) {\n    throw new InvalidModuleSpecifierError(context, 'Invalid import specifier.');\n  }\n\n  return resolvePackageImportsExports(context, {\n    matchKey: importSpecifier,\n    matchObj: imports,\n    internal: true\n  });\n}\n\nconst resolveImportPath = promisify(resolve$1);\nconst readFile$1 = promisify(fs.readFile);\n\nasync function getPackageJson(importer, pkgName, resolveOptions, moduleDirectories) {\n  if (importer) {\n    const selfPackageJsonResult = await findPackageJson(importer, moduleDirectories);\n\n    if (selfPackageJsonResult && selfPackageJsonResult.pkgJson.name === pkgName) {\n      // the referenced package name is the current package\n      return selfPackageJsonResult;\n    }\n  }\n\n  try {\n    const pkgJsonPath = await resolveImportPath(`${pkgName}/package.json`, resolveOptions);\n    const pkgJson = JSON.parse(await readFile$1(pkgJsonPath, 'utf-8'));\n    return {\n      pkgJsonPath,\n      pkgJson\n    };\n  } catch (_) {\n    return null;\n  }\n}\n\nasync function resolveId(_ref4) {\n  let {\n    importer,\n    importSpecifier,\n    exportConditions,\n    warn,\n    packageInfoCache,\n    extensions,\n    mainFields,\n    preserveSymlinks,\n    useBrowserOverrides,\n    baseDir,\n    moduleDirectories,\n    rootDir,\n    ignoreSideEffectsForRoot\n  } = _ref4;\n\n  let hasModuleSideEffects = () => null;\n\n  let hasPackageEntry = true;\n  let packageBrowserField = false;\n  let packageInfo;\n\n  const filter = (pkg, pkgPath) => {\n    const info = getPackageInfo({\n      cache: packageInfoCache,\n      extensions,\n      pkg,\n      pkgPath,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n    ({\n      packageInfo,\n      hasModuleSideEffects,\n      hasPackageEntry,\n      packageBrowserField\n    } = info);\n    return info.cachedPkg;\n  };\n\n  const resolveOptions = {\n    basedir: baseDir,\n    readFile: readCachedFile,\n    isFile: isFileCached,\n    isDirectory: isDirCached,\n    extensions,\n    includeCoreModules: false,\n    moduleDirectory: moduleDirectories,\n    preserveSymlinks,\n    packageFilter: filter\n  };\n  let location;\n  const pkgName = getPackageName(importSpecifier);\n\n  if (importSpecifier.startsWith('#')) {\n    // this is a package internal import, resolve using package imports field\n    const resolveResult = await resolvePackageImports({\n      importSpecifier,\n      importer,\n      moduleDirs: moduleDirectories,\n      conditions: exportConditions,\n\n      resolveId(id, parent) {\n        return resolveId({\n          importSpecifier: id,\n          importer: parent,\n          exportConditions,\n          warn,\n          packageInfoCache,\n          extensions,\n          mainFields,\n          preserveSymlinks,\n          useBrowserOverrides,\n          baseDir,\n          moduleDirectories\n        });\n      }\n\n    });\n    location = fileURLToPath(resolveResult);\n  } else if (pkgName) {\n    // it's a bare import, find the package.json and resolve using package exports if available\n    const result = await getPackageJson(importer, pkgName, resolveOptions, moduleDirectories);\n\n    if (result && result.pkgJson.exports) {\n      const {\n        pkgJson,\n        pkgJsonPath\n      } = result;\n\n      try {\n        const subpath = pkgName === importSpecifier ? '.' : `.${importSpecifier.substring(pkgName.length)}`;\n        const pkgDr = pkgJsonPath.replace('package.json', '');\n        const pkgURL = pathToFileURL(pkgDr);\n        const context = {\n          importer,\n          importSpecifier,\n          moduleDirs: moduleDirectories,\n          pkgURL,\n          pkgJsonPath,\n          conditions: exportConditions\n        };\n        const resolvedPackageExport = await resolvePackageExports(context, subpath, pkgJson.exports);\n        location = fileURLToPath(resolvedPackageExport);\n      } catch (error) {\n        if (error instanceof ResolveError) {\n          return error;\n        }\n\n        throw error;\n      }\n    }\n  }\n\n  if (!location) {\n    // package has no imports or exports, use classic node resolve\n    try {\n      location = await resolveImportPath(importSpecifier, resolveOptions);\n    } catch (error) {\n      if (error.code !== 'MODULE_NOT_FOUND') {\n        throw error;\n      }\n\n      return null;\n    }\n  }\n\n  if (!preserveSymlinks) {\n    if (await exists(location)) {\n      location = await realpath(location);\n    }\n  }\n\n  return {\n    location,\n    hasModuleSideEffects,\n    hasPackageEntry,\n    packageBrowserField,\n    packageInfo\n  };\n} // Resolve module specifiers in order. Promise resolves to the first module that resolves\n// successfully, or the error that resulted from the last attempted module resolution.\n\n\nasync function resolveImportSpecifiers(_ref5) {\n  let {\n    importer,\n    importSpecifierList,\n    exportConditions,\n    warn,\n    packageInfoCache,\n    extensions,\n    mainFields,\n    preserveSymlinks,\n    useBrowserOverrides,\n    baseDir,\n    moduleDirectories,\n    rootDir,\n    ignoreSideEffectsForRoot\n  } = _ref5;\n  let lastResolveError;\n\n  for (let i = 0; i < importSpecifierList.length; i++) {\n    // eslint-disable-next-line no-await-in-loop\n    const result = await resolveId({\n      importer,\n      importSpecifier: importSpecifierList[i],\n      exportConditions,\n      warn,\n      packageInfoCache,\n      extensions,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      baseDir,\n      moduleDirectories,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n\n    if (result instanceof ResolveError) {\n      lastResolveError = result;\n    } else if (result) {\n      return result;\n    }\n  }\n\n  if (lastResolveError) {\n    // only log the last failed resolve error\n    warn(lastResolveError);\n  }\n\n  return null;\n}\n\nfunction handleDeprecatedOptions(opts) {\n  const warnings = [];\n\n  if (opts.customResolveOptions) {\n    const {\n      customResolveOptions\n    } = opts;\n\n    if (customResolveOptions.moduleDirectory) {\n      // eslint-disable-next-line no-param-reassign\n      opts.moduleDirectories = Array.isArray(customResolveOptions.moduleDirectory) ? customResolveOptions.moduleDirectory : [customResolveOptions.moduleDirectory];\n      warnings.push('node-resolve: The `customResolveOptions.moduleDirectory` option has been deprecated. Use `moduleDirectories`, which must be an array.');\n    }\n\n    if (customResolveOptions.preserveSymlinks) {\n      throw new Error('node-resolve: `customResolveOptions.preserveSymlinks` is no longer an option. We now always use the rollup `preserveSymlinks` option.');\n    }\n\n    ['basedir', 'package', 'extensions', 'includeCoreModules', 'readFile', 'isFile', 'isDirectory', 'realpath', 'packageFilter', 'pathFilter', 'paths', 'packageIterator'].forEach(resolveOption => {\n      if (customResolveOptions[resolveOption]) {\n        throw new Error(`node-resolve: \\`customResolveOptions.${resolveOption}\\` is no longer an option. If you need this, please open an issue.`);\n      }\n    });\n  }\n\n  return {\n    warnings\n  };\n}\n/* eslint-disable no-param-reassign, no-shadow, no-undefined */\n\n\nconst builtins = new Set(builtinList);\nconst ES6_BROWSER_EMPTY = '\\0node-resolve:empty.js';\n\nconst deepFreeze = object => {\n  Object.freeze(object);\n\n  for (const value of Object.values(object)) {\n    if (typeof value === 'object' && !Object.isFrozen(value)) {\n      deepFreeze(value);\n    }\n  }\n\n  return object;\n};\n\nconst baseConditions = ['default', 'module'];\nconst baseConditionsEsm = [...baseConditions, 'import'];\nconst baseConditionsCjs = [...baseConditions, 'require'];\nconst defaults = {\n  dedupe: [],\n  // It's important that .mjs is listed before .js so that Rollup will interpret npm modules\n  // which deploy both ESM .mjs and CommonJS .js files as ESM.\n  extensions: ['.mjs', '.js', '.json', '.node'],\n  resolveOnly: [],\n  moduleDirectories: ['node_modules'],\n  ignoreSideEffectsForRoot: false\n};\nconst DEFAULTS = deepFreeze(deepMerge({}, defaults));\n\nfunction nodeResolve() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    warnings\n  } = handleDeprecatedOptions(opts);\n  const options = { ...defaults,\n    ...opts\n  };\n  const {\n    extensions,\n    jail,\n    moduleDirectories,\n    ignoreSideEffectsForRoot\n  } = options;\n  const conditionsEsm = [...baseConditionsEsm, ...(options.exportConditions || [])];\n  const conditionsCjs = [...baseConditionsCjs, ...(options.exportConditions || [])];\n  const packageInfoCache = new Map();\n  const idToPackageInfo = new Map();\n  const mainFields = getMainFields(options);\n  const useBrowserOverrides = mainFields.indexOf('browser') !== -1;\n  const isPreferBuiltinsSet = options.preferBuiltins === true || options.preferBuiltins === false;\n  const preferBuiltins = isPreferBuiltinsSet ? options.preferBuiltins : true;\n  const rootDir = resolve(options.rootDir || process.cwd());\n  let {\n    dedupe\n  } = options;\n  let rollupOptions;\n\n  if (typeof dedupe !== 'function') {\n    dedupe = importee => options.dedupe.includes(importee) || options.dedupe.includes(getPackageName(importee));\n  }\n\n  const resolveOnly = options.resolveOnly.map(pattern => {\n    if (pattern instanceof RegExp) {\n      return pattern;\n    }\n\n    const normalized = pattern.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    return new RegExp(`^${normalized}$`);\n  });\n  const browserMapCache = new Map();\n  let preserveSymlinks;\n  return {\n    name: 'node-resolve',\n\n    buildStart(options) {\n      rollupOptions = options;\n\n      for (const warning of warnings) {\n        this.warn(warning);\n      }\n\n      ({\n        preserveSymlinks\n      } = options);\n    },\n\n    generateBundle() {\n      readCachedFile.clear();\n      isFileCached.clear();\n      isDirCached.clear();\n    },\n\n    async resolveId(importee, importer, opts) {\n      var _this = this;\n\n      if (importee === ES6_BROWSER_EMPTY) {\n        return importee;\n      } // ignore IDs with null character, these belong to other plugins\n\n\n      if (/\\0/.test(importee)) return null;\n\n      if (/\\0/.test(importer)) {\n        importer = undefined;\n      } // strip query params from import\n\n\n      const [importPath, params] = importee.split('?');\n      const importSuffix = `${params ? `?${params}` : ''}`;\n      importee = importPath;\n      const baseDir = !importer || dedupe(importee) ? rootDir : dirname(importer); // https://github.com/defunctzombie/package-browser-field-spec\n\n      const browser = browserMapCache.get(importer);\n\n      if (useBrowserOverrides && browser) {\n        const resolvedImportee = resolve(baseDir, importee);\n\n        if (browser[importee] === false || browser[resolvedImportee] === false) {\n          return ES6_BROWSER_EMPTY;\n        }\n\n        const browserImportee = browser[importee] || browser[resolvedImportee] || browser[`${resolvedImportee}.js`] || browser[`${resolvedImportee}.json`];\n\n        if (browserImportee) {\n          importee = browserImportee;\n        }\n      }\n\n      const parts = importee.split(/[/\\\\]/);\n      let id = parts.shift();\n      let isRelativeImport = false;\n\n      if (id[0] === '@' && parts.length > 0) {\n        // scoped packages\n        id += `/${parts.shift()}`;\n      } else if (id[0] === '.') {\n        // an import relative to the parent dir of the importer\n        id = resolve(baseDir, importee);\n        isRelativeImport = true;\n      }\n\n      if (!isRelativeImport && resolveOnly.length && !resolveOnly.some(pattern => pattern.test(id))) {\n        if (normalizeInput(rollupOptions.input).includes(importee)) {\n          return null;\n        }\n\n        return false;\n      }\n\n      const importSpecifierList = [];\n\n      if (importer === undefined && !importee[0].match(/^\\.?\\.?\\//)) {\n        // For module graph roots (i.e. when importer is undefined), we\n        // need to handle 'path fragments` like `foo/bar` that are commonly\n        // found in rollup config files. If importee doesn't look like a\n        // relative or absolute path, we make it relative and attempt to\n        // resolve it. If we don't find anything, we try resolving it as we\n        // got it.\n        importSpecifierList.push(`./${importee}`);\n      }\n\n      const importeeIsBuiltin = builtins.has(importee);\n\n      if (importeeIsBuiltin) {\n        // The `resolve` library will not resolve packages with the same\n        // name as a node built-in module. If we're resolving something\n        // that's a builtin, and we don't prefer to find built-ins, we\n        // first try to look up a local module with that name. If we don't\n        // find anything, we resolve the builtin which just returns back\n        // the built-in's name.\n        importSpecifierList.push(`${importee}/`);\n      } // TypeScript files may import '.js' to refer to either '.ts' or '.tsx'\n\n\n      if (importer && importee.endsWith('.js')) {\n        for (const ext of ['.ts', '.tsx']) {\n          if (importer.endsWith(ext) && extensions.includes(ext)) {\n            importSpecifierList.push(importee.replace(/.js$/, ext));\n          }\n        }\n      }\n\n      importSpecifierList.push(importee);\n\n      const warn = function () {\n        return _this.warn(...arguments);\n      };\n\n      const isRequire = opts && opts.custom && opts.custom['node-resolve'] && opts.custom['node-resolve'].isRequire;\n      const exportConditions = isRequire ? conditionsCjs : conditionsEsm;\n      const resolvedWithoutBuiltins = await resolveImportSpecifiers({\n        importer,\n        importSpecifierList,\n        exportConditions,\n        warn,\n        packageInfoCache,\n        extensions,\n        mainFields,\n        preserveSymlinks,\n        useBrowserOverrides,\n        baseDir,\n        moduleDirectories,\n        rootDir,\n        ignoreSideEffectsForRoot\n      });\n      const resolved = importeeIsBuiltin && preferBuiltins ? {\n        packageInfo: undefined,\n        hasModuleSideEffects: () => null,\n        hasPackageEntry: true,\n        packageBrowserField: false\n      } : resolvedWithoutBuiltins;\n\n      if (!resolved) {\n        return null;\n      }\n\n      const {\n        packageInfo,\n        hasModuleSideEffects,\n        hasPackageEntry,\n        packageBrowserField\n      } = resolved;\n      let {\n        location\n      } = resolved;\n\n      if (packageBrowserField) {\n        if (Object.prototype.hasOwnProperty.call(packageBrowserField, location)) {\n          if (!packageBrowserField[location]) {\n            browserMapCache.set(location, packageBrowserField);\n            return ES6_BROWSER_EMPTY;\n          }\n\n          location = packageBrowserField[location];\n        }\n\n        browserMapCache.set(location, packageBrowserField);\n      }\n\n      if (hasPackageEntry && !preserveSymlinks) {\n        const fileExists = await exists(location);\n\n        if (fileExists) {\n          location = await realpath(location);\n        }\n      }\n\n      idToPackageInfo.set(location, packageInfo);\n\n      if (hasPackageEntry) {\n        if (importeeIsBuiltin && preferBuiltins) {\n          if (!isPreferBuiltinsSet && resolvedWithoutBuiltins && resolved !== importee) {\n            this.warn(`preferring built-in module '${importee}' over local alternative at '${resolvedWithoutBuiltins.location}', pass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning`);\n          }\n\n          return false;\n        } else if (jail && location.indexOf(normalize(jail.trim(sep))) !== 0) {\n          return null;\n        }\n      }\n\n      if (options.modulesOnly && (await exists(location))) {\n        const code = await readFile(location, 'utf-8');\n\n        if (isModule(code)) {\n          return {\n            id: `${location}${importSuffix}`,\n            moduleSideEffects: hasModuleSideEffects(location)\n          };\n        }\n\n        return null;\n      }\n\n      const result = {\n        id: `${location}${importSuffix}`,\n        moduleSideEffects: hasModuleSideEffects(location)\n      };\n      return result;\n    },\n\n    load(importee) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return 'export default {};';\n      }\n\n      return null;\n    },\n\n    getPackageInfoForId(id) {\n      return idToPackageInfo.get(id);\n    }\n\n  };\n}\n\nexport default nodeResolve;\nexport { DEFAULTS, nodeResolve };","map":{"version":3,"names":["path","dirname","resolve","extname","normalize","sep","builtinList","deepMerge","isModule","fs","realpathSync","promisify","pathToFileURL","fileURLToPath","resolve$1","createFilter","access","readFile","realpath","stat","exists","filePath","onError","error","code","makeCache","fn","cache","Map","wrapped","param","done","has","set","catch","err","delete","result","get","value","clear","isDirCached","file","stats","isDirectory","isFileCached","isFile","readCachedFile","getPackageName","id","startsWith","split","getMainFields","options","mainFields","browser","indexOf","concat","length","Error","getPackageInfo","extensions","pkg","preserveSymlinks","useBrowserOverrides","rootDir","ignoreSideEffectsForRoot","pkgPath","pkgRoot","packageInfo","packageJson","packageJsonPath","root","resolvedMainField","browserMappedMain","resolvedEntryPoint","overriddenMain","i","field","main","internalPackageInfo","cachedPkg","hasModuleSideEffects","hasPackageEntry","packageBrowserField","Object","keys","reduce","key","resolved","absoluteKey","subBrowser","ext","browserMap","hasOwnProperty","packageSideEffects","sideEffects","Array","isArray","normalizeInput","input","values","fileExists","isModuleDir","current","moduleDirs","some","dir","endsWith","findPackageJson","base","parse","pkgJsonPath","join","pkgJsonString","readFileSync","pkgJson","JSON","isUrl","str","URL","_","isConditions","exports","every","k","isMappings","isMixedExports","createBaseErrorMsg","importSpecifier","importer","createErrorMsg","context","reason","internal","ResolveError","InvalidConfigurationError","constructor","InvalidModuleSpecifierError","InvalidPackageTargetError","includesInvalidSegments","pathSegments","slice","t","includes","resolvePackageTarget","target","subpath","pattern","p","resolveId","replace","pkgURL","href","location","resolvedTarget","lastError","item","undefined","entries","conditions","resolvePackageImportsExports","matchKey","matchObj","expansionKeys","filter","sort","a","b","expansionKey","prefix","substring","resolvePackageExports","mainExport","resolvedMatch","resolvePackageImports","imports","resolveImportPath","readFile$1","getPackageJson","pkgName","resolveOptions","moduleDirectories","selfPackageJsonResult","name","exportConditions","warn","packageInfoCache","baseDir","info","basedir","includeCoreModules","moduleDirectory","packageFilter","resolveResult","parent","pkgDr","resolvedPackageExport","resolveImportSpecifiers","importSpecifierList","lastResolveError","handleDeprecatedOptions","opts","warnings","customResolveOptions","push","forEach","resolveOption","builtins","Set","ES6_BROWSER_EMPTY","deepFreeze","object","freeze","isFrozen","baseConditions","baseConditionsEsm","baseConditionsCjs","defaults","dedupe","resolveOnly","DEFAULTS","nodeResolve","jail","conditionsEsm","conditionsCjs","idToPackageInfo","isPreferBuiltinsSet","preferBuiltins","process","cwd","rollupOptions","importee","map","RegExp","normalized","browserMapCache","buildStart","warning","generateBundle","test","importPath","params","importSuffix","resolvedImportee","browserImportee","parts","shift","isRelativeImport","match","importeeIsBuiltin","isRequire","custom","resolvedWithoutBuiltins","prototype","call","trim","modulesOnly","moduleSideEffects","load","getPackageInfoForId"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@rollup/plugin-node-resolve/dist/es/index.js"],"sourcesContent":["import path, { dirname, resolve, extname, normalize, sep } from 'path';\nimport builtinList from 'builtin-modules';\nimport deepMerge from 'deepmerge';\nimport isModule from 'is-module';\nimport fs, { realpathSync } from 'fs';\nimport { promisify } from 'util';\nimport { pathToFileURL, fileURLToPath } from 'url';\nimport resolve$1 from 'resolve';\nimport { createFilter } from '@rollup/pluginutils';\n\nconst access = promisify(fs.access);\nconst readFile = promisify(fs.readFile);\nconst realpath = promisify(fs.realpath);\nconst stat = promisify(fs.stat);\nasync function exists(filePath) {\n  try {\n    await access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nconst onError = (error) => {\n  if (error.code === 'ENOENT') {\n    return false;\n  }\n  throw error;\n};\n\nconst makeCache = (fn) => {\n  const cache = new Map();\n  const wrapped = async (param, done) => {\n    if (cache.has(param) === false) {\n      cache.set(\n        param,\n        fn(param).catch((err) => {\n          cache.delete(param);\n          throw err;\n        })\n      );\n    }\n\n    try {\n      const result = cache.get(param);\n      const value = await result;\n      return done(null, value);\n    } catch (error) {\n      return done(error);\n    }\n  };\n\n  wrapped.clear = () => cache.clear();\n\n  return wrapped;\n};\n\nconst isDirCached = makeCache(async (file) => {\n  try {\n    const stats = await stat(file);\n    return stats.isDirectory();\n  } catch (error) {\n    return onError(error);\n  }\n});\n\nconst isFileCached = makeCache(async (file) => {\n  try {\n    const stats = await stat(file);\n    return stats.isFile();\n  } catch (error) {\n    return onError(error);\n  }\n});\n\nconst readCachedFile = makeCache(readFile);\n\n// returns the imported package name for bare module imports\nfunction getPackageName(id) {\n  if (id.startsWith('.') || id.startsWith('/')) {\n    return null;\n  }\n\n  const split = id.split('/');\n\n  // @my-scope/my-package/foo.js -> @my-scope/my-package\n  // @my-scope/my-package -> @my-scope/my-package\n  if (split[0][0] === '@') {\n    return `${split[0]}/${split[1]}`;\n  }\n\n  // my-package/foo.js -> my-package\n  // my-package -> my-package\n  return split[0];\n}\n\nfunction getMainFields(options) {\n  let mainFields;\n  if (options.mainFields) {\n    ({ mainFields } = options);\n  } else {\n    mainFields = ['module', 'main'];\n  }\n  if (options.browser && mainFields.indexOf('browser') === -1) {\n    return ['browser'].concat(mainFields);\n  }\n  if (!mainFields.length) {\n    throw new Error('Please ensure at least one `mainFields` value is specified');\n  }\n  return mainFields;\n}\n\nfunction getPackageInfo(options) {\n  const {\n    cache,\n    extensions,\n    pkg,\n    mainFields,\n    preserveSymlinks,\n    useBrowserOverrides,\n    rootDir,\n    ignoreSideEffectsForRoot\n  } = options;\n  let { pkgPath } = options;\n\n  if (cache.has(pkgPath)) {\n    return cache.get(pkgPath);\n  }\n\n  // browserify/resolve doesn't realpath paths returned in its packageFilter callback\n  if (!preserveSymlinks) {\n    pkgPath = realpathSync(pkgPath);\n  }\n\n  const pkgRoot = dirname(pkgPath);\n\n  const packageInfo = {\n    // copy as we are about to munge the `main` field of `pkg`.\n    packageJson: { ...pkg },\n\n    // path to package.json file\n    packageJsonPath: pkgPath,\n\n    // directory containing the package.json\n    root: pkgRoot,\n\n    // which main field was used during resolution of this module (main, module, or browser)\n    resolvedMainField: 'main',\n\n    // whether the browser map was used to resolve the entry point to this module\n    browserMappedMain: false,\n\n    // the entry point of the module with respect to the selected main field and any\n    // relevant browser mappings.\n    resolvedEntryPoint: ''\n  };\n\n  let overriddenMain = false;\n  for (let i = 0; i < mainFields.length; i++) {\n    const field = mainFields[i];\n    if (typeof pkg[field] === 'string') {\n      pkg.main = pkg[field];\n      packageInfo.resolvedMainField = field;\n      overriddenMain = true;\n      break;\n    }\n  }\n\n  const internalPackageInfo = {\n    cachedPkg: pkg,\n    hasModuleSideEffects: () => null,\n    hasPackageEntry: overriddenMain !== false || mainFields.indexOf('main') !== -1,\n    packageBrowserField:\n      useBrowserOverrides &&\n      typeof pkg.browser === 'object' &&\n      Object.keys(pkg.browser).reduce((browser, key) => {\n        let resolved = pkg.browser[key];\n        if (resolved && resolved[0] === '.') {\n          resolved = resolve(pkgRoot, resolved);\n        }\n        /* eslint-disable no-param-reassign */\n        browser[key] = resolved;\n        if (key[0] === '.') {\n          const absoluteKey = resolve(pkgRoot, key);\n          browser[absoluteKey] = resolved;\n          if (!extname(key)) {\n            extensions.reduce((subBrowser, ext) => {\n              subBrowser[absoluteKey + ext] = subBrowser[key];\n              return subBrowser;\n            }, browser);\n          }\n        }\n        return browser;\n      }, {}),\n    packageInfo\n  };\n\n  const browserMap = internalPackageInfo.packageBrowserField;\n  if (\n    useBrowserOverrides &&\n    typeof pkg.browser === 'object' &&\n    // eslint-disable-next-line no-prototype-builtins\n    browserMap.hasOwnProperty(pkg.main)\n  ) {\n    packageInfo.resolvedEntryPoint = browserMap[pkg.main];\n    packageInfo.browserMappedMain = true;\n  } else {\n    // index.node is technically a valid default entrypoint as well...\n    packageInfo.resolvedEntryPoint = resolve(pkgRoot, pkg.main || 'index.js');\n    packageInfo.browserMappedMain = false;\n  }\n\n  if (!ignoreSideEffectsForRoot || rootDir !== pkgRoot) {\n    const packageSideEffects = pkg.sideEffects;\n    if (typeof packageSideEffects === 'boolean') {\n      internalPackageInfo.hasModuleSideEffects = () => packageSideEffects;\n    } else if (Array.isArray(packageSideEffects)) {\n      internalPackageInfo.hasModuleSideEffects = createFilter(packageSideEffects, null, {\n        resolve: pkgRoot\n      });\n    }\n  }\n\n  cache.set(pkgPath, internalPackageInfo);\n  return internalPackageInfo;\n}\n\nfunction normalizeInput(input) {\n  if (Array.isArray(input)) {\n    return input;\n  } else if (typeof input === 'object') {\n    return Object.values(input);\n  }\n\n  // otherwise it's a string\n  return [input];\n}\n\n/* eslint-disable no-await-in-loop */\n\nconst fileExists = promisify(fs.exists);\n\nfunction isModuleDir(current, moduleDirs) {\n  return moduleDirs.some((dir) => current.endsWith(dir));\n}\n\nasync function findPackageJson(base, moduleDirs) {\n  const { root } = path.parse(base);\n  let current = base;\n\n  while (current !== root && !isModuleDir(current, moduleDirs)) {\n    const pkgJsonPath = path.join(current, 'package.json');\n    if (await fileExists(pkgJsonPath)) {\n      const pkgJsonString = fs.readFileSync(pkgJsonPath, 'utf-8');\n      return { pkgJson: JSON.parse(pkgJsonString), pkgPath: current, pkgJsonPath };\n    }\n    current = path.resolve(current, '..');\n  }\n  return null;\n}\n\nfunction isUrl(str) {\n  try {\n    return !!new URL(str);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction isConditions(exports) {\n  return typeof exports === 'object' && Object.keys(exports).every((k) => !k.startsWith('.'));\n}\n\nfunction isMappings(exports) {\n  return typeof exports === 'object' && !isConditions(exports);\n}\n\nfunction isMixedExports(exports) {\n  const keys = Object.keys(exports);\n  return keys.some((k) => k.startsWith('.')) && keys.some((k) => !k.startsWith('.'));\n}\n\nfunction createBaseErrorMsg(importSpecifier, importer) {\n  return `Could not resolve import \"${importSpecifier}\" in ${importer}`;\n}\n\nfunction createErrorMsg(context, reason, internal) {\n  const { importSpecifier, importer, pkgJsonPath } = context;\n  const base = createBaseErrorMsg(importSpecifier, importer);\n  const field = internal ? 'imports' : 'exports';\n  return `${base} using ${field} defined in ${pkgJsonPath}.${reason ? ` ${reason}` : ''}`;\n}\n\nclass ResolveError extends Error {}\n\nclass InvalidConfigurationError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, `Invalid \"exports\" field. ${reason}`));\n  }\n}\n\nclass InvalidModuleSpecifierError extends ResolveError {\n  constructor(context, internal) {\n    super(createErrorMsg(context, internal));\n  }\n}\n\nclass InvalidPackageTargetError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, reason));\n  }\n}\n\n/* eslint-disable no-await-in-loop, no-undefined */\n\nfunction includesInvalidSegments(pathSegments, moduleDirs) {\n  return pathSegments\n    .split('/')\n    .slice(1)\n    .some((t) => ['.', '..', ...moduleDirs].includes(t));\n}\n\nasync function resolvePackageTarget(context, { target, subpath, pattern, internal }) {\n  if (typeof target === 'string') {\n    if (!pattern && subpath.length > 0 && !target.endsWith('/')) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n\n    if (!target.startsWith('./')) {\n      if (internal && !['/', '../'].some((p) => target.startsWith(p)) && !isUrl(target)) {\n        // this is a bare package import, remap it and resolve it using regular node resolve\n        if (pattern) {\n          const result = await context.resolveId(\n            target.replace(/\\*/g, subpath),\n            context.pkgURL.href\n          );\n          return result ? pathToFileURL(result.location) : null;\n        }\n\n        const result = await context.resolveId(`${target}${subpath}`, context.pkgURL.href);\n        return result ? pathToFileURL(result.location) : null;\n      }\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n\n    if (includesInvalidSegments(target, context.moduleDirs)) {\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n\n    const resolvedTarget = new URL(target, context.pkgURL);\n    if (!resolvedTarget.href.startsWith(context.pkgURL.href)) {\n      throw new InvalidPackageTargetError(\n        context,\n        `Resolved to ${resolvedTarget.href} which is outside package ${context.pkgURL.href}`\n      );\n    }\n\n    if (includesInvalidSegments(subpath, context.moduleDirs)) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n\n    if (pattern) {\n      return resolvedTarget.href.replace(/\\*/g, subpath);\n    }\n    return new URL(subpath, resolvedTarget).href;\n  }\n\n  if (Array.isArray(target)) {\n    let lastError;\n    for (const item of target) {\n      try {\n        const resolved = await resolvePackageTarget(context, {\n          target: item,\n          subpath,\n          pattern,\n          internal\n        });\n\n        // return if defined or null, but not undefined\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      } catch (error) {\n        if (!(error instanceof InvalidPackageTargetError)) {\n          throw error;\n        } else {\n          lastError = error;\n        }\n      }\n    }\n\n    if (lastError) {\n      throw lastError;\n    }\n    return null;\n  }\n\n  if (target && typeof target === 'object') {\n    for (const [key, value] of Object.entries(target)) {\n      if (key === 'default' || context.conditions.includes(key)) {\n        const resolved = await resolvePackageTarget(context, {\n          target: value,\n          subpath,\n          pattern,\n          internal\n        });\n\n        // return if defined or null, but not undefined\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  if (target === null) {\n    return null;\n  }\n\n  throw new InvalidPackageTargetError(context, `Invalid exports field.`);\n}\n\n/* eslint-disable no-await-in-loop */\n\nasync function resolvePackageImportsExports(context, { matchKey, matchObj, internal }) {\n  if (!matchKey.endsWith('*') && matchKey in matchObj) {\n    const target = matchObj[matchKey];\n    const resolved = await resolvePackageTarget(context, { target, subpath: '', internal });\n    return resolved;\n  }\n\n  const expansionKeys = Object.keys(matchObj)\n    .filter((k) => k.endsWith('/') || k.endsWith('*'))\n    .sort((a, b) => b.length - a.length);\n\n  for (const expansionKey of expansionKeys) {\n    const prefix = expansionKey.substring(0, expansionKey.length - 1);\n\n    if (expansionKey.endsWith('*') && matchKey.startsWith(prefix)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length - 1);\n      const resolved = await resolvePackageTarget(context, {\n        target,\n        subpath,\n        pattern: true,\n        internal\n      });\n      return resolved;\n    }\n\n    if (matchKey.startsWith(expansionKey)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length);\n\n      const resolved = await resolvePackageTarget(context, { target, subpath, internal });\n      return resolved;\n    }\n  }\n\n  throw new InvalidModuleSpecifierError(context, internal);\n}\n\nasync function resolvePackageExports(context, subpath, exports) {\n  if (isMixedExports(exports)) {\n    throw new InvalidConfigurationError(\n      context,\n      'All keys must either start with ./, or without one.'\n    );\n  }\n\n  if (subpath === '.') {\n    let mainExport;\n    // If exports is a String or Array, or an Object containing no keys starting with \".\", then\n    if (typeof exports === 'string' || Array.isArray(exports) || isConditions(exports)) {\n      mainExport = exports;\n    } else if (isMappings(exports)) {\n      mainExport = exports['.'];\n    }\n\n    if (mainExport) {\n      const resolved = await resolvePackageTarget(context, { target: mainExport, subpath: '' });\n      if (resolved) {\n        return resolved;\n      }\n    }\n  } else if (isMappings(exports)) {\n    const resolvedMatch = await resolvePackageImportsExports(context, {\n      matchKey: subpath,\n      matchObj: exports\n    });\n\n    if (resolvedMatch) {\n      return resolvedMatch;\n    }\n  }\n\n  throw new InvalidModuleSpecifierError(context);\n}\n\nasync function resolvePackageImports({\n  importSpecifier,\n  importer,\n  moduleDirs,\n  conditions,\n  resolveId\n}) {\n  const result = await findPackageJson(importer, moduleDirs);\n  if (!result) {\n    throw new Error(createBaseErrorMsg('. Could not find a parent package.json.'));\n  }\n\n  const { pkgPath, pkgJsonPath, pkgJson } = result;\n  const pkgURL = pathToFileURL(`${pkgPath}/`);\n  const context = {\n    importer,\n    importSpecifier,\n    moduleDirs,\n    pkgURL,\n    pkgJsonPath,\n    conditions,\n    resolveId\n  };\n\n  const { imports } = pkgJson;\n  if (!imports) {\n    throw new InvalidModuleSpecifierError(context, true);\n  }\n\n  if (importSpecifier === '#' || importSpecifier.startsWith('#/')) {\n    throw new InvalidModuleSpecifierError(context, 'Invalid import specifier.');\n  }\n\n  return resolvePackageImportsExports(context, {\n    matchKey: importSpecifier,\n    matchObj: imports,\n    internal: true\n  });\n}\n\nconst resolveImportPath = promisify(resolve$1);\nconst readFile$1 = promisify(fs.readFile);\n\nasync function getPackageJson(importer, pkgName, resolveOptions, moduleDirectories) {\n  if (importer) {\n    const selfPackageJsonResult = await findPackageJson(importer, moduleDirectories);\n    if (selfPackageJsonResult && selfPackageJsonResult.pkgJson.name === pkgName) {\n      // the referenced package name is the current package\n      return selfPackageJsonResult;\n    }\n  }\n\n  try {\n    const pkgJsonPath = await resolveImportPath(`${pkgName}/package.json`, resolveOptions);\n    const pkgJson = JSON.parse(await readFile$1(pkgJsonPath, 'utf-8'));\n    return { pkgJsonPath, pkgJson };\n  } catch (_) {\n    return null;\n  }\n}\n\nasync function resolveId({\n  importer,\n  importSpecifier,\n  exportConditions,\n  warn,\n  packageInfoCache,\n  extensions,\n  mainFields,\n  preserveSymlinks,\n  useBrowserOverrides,\n  baseDir,\n  moduleDirectories,\n  rootDir,\n  ignoreSideEffectsForRoot\n}) {\n  let hasModuleSideEffects = () => null;\n  let hasPackageEntry = true;\n  let packageBrowserField = false;\n  let packageInfo;\n\n  const filter = (pkg, pkgPath) => {\n    const info = getPackageInfo({\n      cache: packageInfoCache,\n      extensions,\n      pkg,\n      pkgPath,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n\n    ({ packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = info);\n\n    return info.cachedPkg;\n  };\n\n  const resolveOptions = {\n    basedir: baseDir,\n    readFile: readCachedFile,\n    isFile: isFileCached,\n    isDirectory: isDirCached,\n    extensions,\n    includeCoreModules: false,\n    moduleDirectory: moduleDirectories,\n    preserveSymlinks,\n    packageFilter: filter\n  };\n\n  let location;\n\n  const pkgName = getPackageName(importSpecifier);\n  if (importSpecifier.startsWith('#')) {\n    // this is a package internal import, resolve using package imports field\n    const resolveResult = await resolvePackageImports({\n      importSpecifier,\n      importer,\n      moduleDirs: moduleDirectories,\n      conditions: exportConditions,\n      resolveId(id, parent) {\n        return resolveId({\n          importSpecifier: id,\n          importer: parent,\n          exportConditions,\n          warn,\n          packageInfoCache,\n          extensions,\n          mainFields,\n          preserveSymlinks,\n          useBrowserOverrides,\n          baseDir,\n          moduleDirectories\n        });\n      }\n    });\n    location = fileURLToPath(resolveResult);\n  } else if (pkgName) {\n    // it's a bare import, find the package.json and resolve using package exports if available\n    const result = await getPackageJson(importer, pkgName, resolveOptions, moduleDirectories);\n\n    if (result && result.pkgJson.exports) {\n      const { pkgJson, pkgJsonPath } = result;\n      try {\n        const subpath =\n          pkgName === importSpecifier ? '.' : `.${importSpecifier.substring(pkgName.length)}`;\n        const pkgDr = pkgJsonPath.replace('package.json', '');\n        const pkgURL = pathToFileURL(pkgDr);\n\n        const context = {\n          importer,\n          importSpecifier,\n          moduleDirs: moduleDirectories,\n          pkgURL,\n          pkgJsonPath,\n          conditions: exportConditions\n        };\n        const resolvedPackageExport = await resolvePackageExports(\n          context,\n          subpath,\n          pkgJson.exports\n        );\n        location = fileURLToPath(resolvedPackageExport);\n      } catch (error) {\n        if (error instanceof ResolveError) {\n          return error;\n        }\n        throw error;\n      }\n    }\n  }\n\n  if (!location) {\n    // package has no imports or exports, use classic node resolve\n    try {\n      location = await resolveImportPath(importSpecifier, resolveOptions);\n    } catch (error) {\n      if (error.code !== 'MODULE_NOT_FOUND') {\n        throw error;\n      }\n      return null;\n    }\n  }\n\n  if (!preserveSymlinks) {\n    if (await exists(location)) {\n      location = await realpath(location);\n    }\n  }\n\n  return {\n    location,\n    hasModuleSideEffects,\n    hasPackageEntry,\n    packageBrowserField,\n    packageInfo\n  };\n}\n\n// Resolve module specifiers in order. Promise resolves to the first module that resolves\n// successfully, or the error that resulted from the last attempted module resolution.\nasync function resolveImportSpecifiers({\n  importer,\n  importSpecifierList,\n  exportConditions,\n  warn,\n  packageInfoCache,\n  extensions,\n  mainFields,\n  preserveSymlinks,\n  useBrowserOverrides,\n  baseDir,\n  moduleDirectories,\n  rootDir,\n  ignoreSideEffectsForRoot\n}) {\n  let lastResolveError;\n\n  for (let i = 0; i < importSpecifierList.length; i++) {\n    // eslint-disable-next-line no-await-in-loop\n    const result = await resolveId({\n      importer,\n      importSpecifier: importSpecifierList[i],\n      exportConditions,\n      warn,\n      packageInfoCache,\n      extensions,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      baseDir,\n      moduleDirectories,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n\n    if (result instanceof ResolveError) {\n      lastResolveError = result;\n    } else if (result) {\n      return result;\n    }\n  }\n\n  if (lastResolveError) {\n    // only log the last failed resolve error\n    warn(lastResolveError);\n  }\n  return null;\n}\n\nfunction handleDeprecatedOptions(opts) {\n  const warnings = [];\n\n  if (opts.customResolveOptions) {\n    const { customResolveOptions } = opts;\n    if (customResolveOptions.moduleDirectory) {\n      // eslint-disable-next-line no-param-reassign\n      opts.moduleDirectories = Array.isArray(customResolveOptions.moduleDirectory)\n        ? customResolveOptions.moduleDirectory\n        : [customResolveOptions.moduleDirectory];\n\n      warnings.push(\n        'node-resolve: The `customResolveOptions.moduleDirectory` option has been deprecated. Use `moduleDirectories`, which must be an array.'\n      );\n    }\n\n    if (customResolveOptions.preserveSymlinks) {\n      throw new Error(\n        'node-resolve: `customResolveOptions.preserveSymlinks` is no longer an option. We now always use the rollup `preserveSymlinks` option.'\n      );\n    }\n\n    [\n      'basedir',\n      'package',\n      'extensions',\n      'includeCoreModules',\n      'readFile',\n      'isFile',\n      'isDirectory',\n      'realpath',\n      'packageFilter',\n      'pathFilter',\n      'paths',\n      'packageIterator'\n    ].forEach((resolveOption) => {\n      if (customResolveOptions[resolveOption]) {\n        throw new Error(\n          `node-resolve: \\`customResolveOptions.${resolveOption}\\` is no longer an option. If you need this, please open an issue.`\n        );\n      }\n    });\n  }\n\n  return { warnings };\n}\n\n/* eslint-disable no-param-reassign, no-shadow, no-undefined */\n\nconst builtins = new Set(builtinList);\nconst ES6_BROWSER_EMPTY = '\\0node-resolve:empty.js';\nconst deepFreeze = (object) => {\n  Object.freeze(object);\n\n  for (const value of Object.values(object)) {\n    if (typeof value === 'object' && !Object.isFrozen(value)) {\n      deepFreeze(value);\n    }\n  }\n\n  return object;\n};\n\nconst baseConditions = ['default', 'module'];\nconst baseConditionsEsm = [...baseConditions, 'import'];\nconst baseConditionsCjs = [...baseConditions, 'require'];\nconst defaults = {\n  dedupe: [],\n  // It's important that .mjs is listed before .js so that Rollup will interpret npm modules\n  // which deploy both ESM .mjs and CommonJS .js files as ESM.\n  extensions: ['.mjs', '.js', '.json', '.node'],\n  resolveOnly: [],\n  moduleDirectories: ['node_modules'],\n  ignoreSideEffectsForRoot: false\n};\nconst DEFAULTS = deepFreeze(deepMerge({}, defaults));\n\nfunction nodeResolve(opts = {}) {\n  const { warnings } = handleDeprecatedOptions(opts);\n\n  const options = { ...defaults, ...opts };\n  const { extensions, jail, moduleDirectories, ignoreSideEffectsForRoot } = options;\n  const conditionsEsm = [...baseConditionsEsm, ...(options.exportConditions || [])];\n  const conditionsCjs = [...baseConditionsCjs, ...(options.exportConditions || [])];\n  const packageInfoCache = new Map();\n  const idToPackageInfo = new Map();\n  const mainFields = getMainFields(options);\n  const useBrowserOverrides = mainFields.indexOf('browser') !== -1;\n  const isPreferBuiltinsSet = options.preferBuiltins === true || options.preferBuiltins === false;\n  const preferBuiltins = isPreferBuiltinsSet ? options.preferBuiltins : true;\n  const rootDir = resolve(options.rootDir || process.cwd());\n  let { dedupe } = options;\n  let rollupOptions;\n\n  if (typeof dedupe !== 'function') {\n    dedupe = (importee) =>\n      options.dedupe.includes(importee) || options.dedupe.includes(getPackageName(importee));\n  }\n\n  const resolveOnly = options.resolveOnly.map((pattern) => {\n    if (pattern instanceof RegExp) {\n      return pattern;\n    }\n    const normalized = pattern.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    return new RegExp(`^${normalized}$`);\n  });\n\n  const browserMapCache = new Map();\n  let preserveSymlinks;\n\n  return {\n    name: 'node-resolve',\n\n    buildStart(options) {\n      rollupOptions = options;\n\n      for (const warning of warnings) {\n        this.warn(warning);\n      }\n\n      ({ preserveSymlinks } = options);\n    },\n\n    generateBundle() {\n      readCachedFile.clear();\n      isFileCached.clear();\n      isDirCached.clear();\n    },\n\n    async resolveId(importee, importer, opts) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return importee;\n      }\n      // ignore IDs with null character, these belong to other plugins\n      if (/\\0/.test(importee)) return null;\n\n      if (/\\0/.test(importer)) {\n        importer = undefined;\n      }\n\n      // strip query params from import\n      const [importPath, params] = importee.split('?');\n      const importSuffix = `${params ? `?${params}` : ''}`;\n      importee = importPath;\n\n      const baseDir = !importer || dedupe(importee) ? rootDir : dirname(importer);\n\n      // https://github.com/defunctzombie/package-browser-field-spec\n      const browser = browserMapCache.get(importer);\n      if (useBrowserOverrides && browser) {\n        const resolvedImportee = resolve(baseDir, importee);\n        if (browser[importee] === false || browser[resolvedImportee] === false) {\n          return ES6_BROWSER_EMPTY;\n        }\n        const browserImportee =\n          browser[importee] ||\n          browser[resolvedImportee] ||\n          browser[`${resolvedImportee}.js`] ||\n          browser[`${resolvedImportee}.json`];\n        if (browserImportee) {\n          importee = browserImportee;\n        }\n      }\n\n      const parts = importee.split(/[/\\\\]/);\n      let id = parts.shift();\n      let isRelativeImport = false;\n\n      if (id[0] === '@' && parts.length > 0) {\n        // scoped packages\n        id += `/${parts.shift()}`;\n      } else if (id[0] === '.') {\n        // an import relative to the parent dir of the importer\n        id = resolve(baseDir, importee);\n        isRelativeImport = true;\n      }\n\n      if (\n        !isRelativeImport &&\n        resolveOnly.length &&\n        !resolveOnly.some((pattern) => pattern.test(id))\n      ) {\n        if (normalizeInput(rollupOptions.input).includes(importee)) {\n          return null;\n        }\n        return false;\n      }\n\n      const importSpecifierList = [];\n\n      if (importer === undefined && !importee[0].match(/^\\.?\\.?\\//)) {\n        // For module graph roots (i.e. when importer is undefined), we\n        // need to handle 'path fragments` like `foo/bar` that are commonly\n        // found in rollup config files. If importee doesn't look like a\n        // relative or absolute path, we make it relative and attempt to\n        // resolve it. If we don't find anything, we try resolving it as we\n        // got it.\n        importSpecifierList.push(`./${importee}`);\n      }\n\n      const importeeIsBuiltin = builtins.has(importee);\n\n      if (importeeIsBuiltin) {\n        // The `resolve` library will not resolve packages with the same\n        // name as a node built-in module. If we're resolving something\n        // that's a builtin, and we don't prefer to find built-ins, we\n        // first try to look up a local module with that name. If we don't\n        // find anything, we resolve the builtin which just returns back\n        // the built-in's name.\n        importSpecifierList.push(`${importee}/`);\n      }\n\n      // TypeScript files may import '.js' to refer to either '.ts' or '.tsx'\n      if (importer && importee.endsWith('.js')) {\n        for (const ext of ['.ts', '.tsx']) {\n          if (importer.endsWith(ext) && extensions.includes(ext)) {\n            importSpecifierList.push(importee.replace(/.js$/, ext));\n          }\n        }\n      }\n\n      importSpecifierList.push(importee);\n\n      const warn = (...args) => this.warn(...args);\n      const isRequire =\n        opts && opts.custom && opts.custom['node-resolve'] && opts.custom['node-resolve'].isRequire;\n      const exportConditions = isRequire ? conditionsCjs : conditionsEsm;\n\n      const resolvedWithoutBuiltins = await resolveImportSpecifiers({\n        importer,\n        importSpecifierList,\n        exportConditions,\n        warn,\n        packageInfoCache,\n        extensions,\n        mainFields,\n        preserveSymlinks,\n        useBrowserOverrides,\n        baseDir,\n        moduleDirectories,\n        rootDir,\n        ignoreSideEffectsForRoot\n      });\n\n      const resolved =\n        importeeIsBuiltin && preferBuiltins\n          ? {\n              packageInfo: undefined,\n              hasModuleSideEffects: () => null,\n              hasPackageEntry: true,\n              packageBrowserField: false\n            }\n          : resolvedWithoutBuiltins;\n      if (!resolved) {\n        return null;\n      }\n\n      const { packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = resolved;\n      let { location } = resolved;\n      if (packageBrowserField) {\n        if (Object.prototype.hasOwnProperty.call(packageBrowserField, location)) {\n          if (!packageBrowserField[location]) {\n            browserMapCache.set(location, packageBrowserField);\n            return ES6_BROWSER_EMPTY;\n          }\n          location = packageBrowserField[location];\n        }\n        browserMapCache.set(location, packageBrowserField);\n      }\n\n      if (hasPackageEntry && !preserveSymlinks) {\n        const fileExists = await exists(location);\n        if (fileExists) {\n          location = await realpath(location);\n        }\n      }\n\n      idToPackageInfo.set(location, packageInfo);\n\n      if (hasPackageEntry) {\n        if (importeeIsBuiltin && preferBuiltins) {\n          if (!isPreferBuiltinsSet && resolvedWithoutBuiltins && resolved !== importee) {\n            this.warn(\n              `preferring built-in module '${importee}' over local alternative at '${resolvedWithoutBuiltins.location}', pass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning`\n            );\n          }\n          return false;\n        } else if (jail && location.indexOf(normalize(jail.trim(sep))) !== 0) {\n          return null;\n        }\n      }\n\n      if (options.modulesOnly && (await exists(location))) {\n        const code = await readFile(location, 'utf-8');\n        if (isModule(code)) {\n          return {\n            id: `${location}${importSuffix}`,\n            moduleSideEffects: hasModuleSideEffects(location)\n          };\n        }\n        return null;\n      }\n      const result = {\n        id: `${location}${importSuffix}`,\n        moduleSideEffects: hasModuleSideEffects(location)\n      };\n      return result;\n    },\n\n    load(importee) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return 'export default {};';\n      }\n      return null;\n    },\n\n    getPackageInfoForId(id) {\n      return idToPackageInfo.get(id);\n    }\n  };\n}\n\nexport default nodeResolve;\nexport { DEFAULTS, nodeResolve };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}