{"ast":null,"code":"/**\n * @fileoverview Prevents jsx context provider values from taking values that\n *               will cause needless rerenders.\n * @author Dylan Oshima\n */\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Helpers\n// ------------------------------------------------------------------------------\n// Recursively checks if an element is a construction.\n// A construction is a variable that changes identity every render.\n\n\nfunction isConstruction(node, callScope) {\n  switch (node.type) {\n    case 'Literal':\n      if (node.regex != null) {\n        return {\n          type: 'regular expression',\n          node\n        };\n      }\n\n      return null;\n\n    case 'Identifier':\n      {\n        const variableScoping = callScope.set.get(node.name);\n\n        if (variableScoping == null || variableScoping.defs == null) {\n          // If it's not in scope, we don't care.\n          return null; // Handled\n        } // Gets the last variable identity\n\n\n        const variableDefs = variableScoping.defs;\n        const def = variableDefs[variableDefs.length - 1];\n\n        if (def != null && def.type !== 'Variable' && def.type !== 'FunctionName') {\n          // Parameter or an unusual pattern. Bail out.\n          return null; // Unhandled\n        }\n\n        if (def.node.type === 'FunctionDeclaration') {\n          return {\n            type: 'function declaration',\n            node: def.node,\n            usage: node\n          };\n        }\n\n        const init = def.node.init;\n\n        if (init == null) {\n          return null;\n        }\n\n        const initConstruction = isConstruction(init, callScope);\n\n        if (initConstruction == null) {\n          return null;\n        }\n\n        return {\n          type: initConstruction.type,\n          node: initConstruction.node,\n          usage: node\n        };\n      }\n\n    case 'ObjectExpression':\n      // Any object initialized inline will create a new identity\n      return {\n        type: 'object',\n        node\n      };\n\n    case 'ArrayExpression':\n      return {\n        type: 'array',\n        node\n      };\n\n    case 'ArrowFunctionExpression':\n    case 'FunctionExpression':\n      // Functions that are initialized inline will have a new identity\n      return {\n        type: 'function expression',\n        node\n      };\n\n    case 'ClassExpression':\n      return {\n        type: 'class expression',\n        node\n      };\n\n    case 'NewExpression':\n      // `const a = new SomeClass();` is a construction\n      return {\n        type: 'new expression',\n        node\n      };\n\n    case 'ConditionalExpression':\n      return isConstruction(node.consequent, callScope) || isConstruction(node.alternate, callScope);\n\n    case 'LogicalExpression':\n      return isConstruction(node.left, callScope) || isConstruction(node.right, callScope);\n\n    case 'MemberExpression':\n      {\n        const objConstruction = isConstruction(node.object, callScope);\n\n        if (objConstruction == null) {\n          return null;\n        }\n\n        return {\n          type: objConstruction.type,\n          node: objConstruction.node,\n          usage: node.object\n        };\n      }\n\n    case 'JSXFragment':\n      return {\n        type: 'JSX fragment',\n        node\n      };\n\n    case 'JSXElement':\n      return {\n        type: 'JSX element',\n        node\n      };\n\n    case 'AssignmentExpression':\n      {\n        const construct = isConstruction(node.right, callScope);\n\n        if (construct != null) {\n          return {\n            type: 'assignment expression',\n            node: construct.node,\n            usage: node\n          };\n        }\n\n        return null;\n      }\n\n    case 'TypeCastExpression':\n    case 'TSAsExpression':\n      return isConstruction(node.expression, callScope);\n\n    default:\n      return null;\n  }\n} // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst messages = {\n  withIdentifierMsg: \"The '{{variableName}}' {{type}} (at line {{nodeLine}}) passed as the value prop to the Context provider (at line {{usageLine}}) changes every render. To fix this consider wrapping it in a useMemo hook.\",\n  withIdentifierMsgFunc: \"The '{{variableName}}' {{type}} (at line {{nodeLine}}) passed as the value prop to the Context provider (at line {{usageLine}}) changes every render. To fix this consider wrapping it in a useCallback hook.\",\n  defaultMsg: 'The {{type}} passed as the value prop to the Context provider (at line {{nodeLine}}) changes every render. To fix this consider wrapping it in a useMemo hook.',\n  defaultMsgFunc: 'The {{type}} passed as the value prop to the Context provider (at line {{nodeLine}}) changes every render. To fix this consider wrapping it in a useCallback hook.'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallows JSX context provider values from taking values that will cause needless rerenders',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('jsx-no-constructed-context-values')\n    },\n    messages\n  },\n\n  create(context) {\n    return {\n      JSXOpeningElement(node) {\n        const openingElementName = node.name;\n\n        if (openingElementName.type !== 'JSXMemberExpression') {\n          // Has no member\n          return;\n        }\n\n        const isJsxContext = openingElementName.property.name === 'Provider';\n\n        if (!isJsxContext) {\n          // Member is not Provider\n          return;\n        } // Contexts can take in more than just a value prop\n        // so we need to iterate through all of them\n\n\n        const jsxValueAttribute = node.attributes.find(attribute => attribute.type === 'JSXAttribute' && attribute.name.name === 'value');\n\n        if (jsxValueAttribute == null) {\n          // No value prop was passed\n          return;\n        }\n\n        const valueNode = jsxValueAttribute.value;\n\n        if (!valueNode) {\n          // attribute is a boolean shorthand\n          return;\n        }\n\n        if (valueNode.type !== 'JSXExpressionContainer') {\n          // value could be a literal\n          return;\n        }\n\n        const valueExpression = valueNode.expression;\n        const invocationScope = context.getScope(); // Check if the value prop is a construction\n\n        const constructInfo = isConstruction(valueExpression, invocationScope);\n\n        if (constructInfo == null) {\n          return;\n        } // Report found error\n\n\n        const constructType = constructInfo.type;\n        const constructNode = constructInfo.node;\n        const constructUsage = constructInfo.usage;\n        const data = {\n          type: constructType,\n          nodeLine: constructNode.loc.start.line\n        };\n        let messageId = 'defaultMsg'; // Variable passed to value prop\n\n        if (constructUsage != null) {\n          messageId = 'withIdentifierMsg';\n          data.usageLine = constructUsage.loc.start.line;\n          data.variableName = constructUsage.name;\n        } // Type of expression\n\n\n        if (constructType === 'function expression' || constructType === 'function declaration') {\n          messageId += 'Func';\n        }\n\n        report(context, messages[messageId], messageId, {\n          node: constructNode,\n          data\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["docsUrl","require","report","isConstruction","node","callScope","type","regex","variableScoping","set","get","name","defs","variableDefs","def","length","usage","init","initConstruction","consequent","alternate","left","right","objConstruction","object","construct","expression","messages","withIdentifierMsg","withIdentifierMsgFunc","defaultMsg","defaultMsgFunc","module","exports","meta","docs","description","category","recommended","url","create","context","JSXOpeningElement","openingElementName","isJsxContext","property","jsxValueAttribute","attributes","find","attribute","valueNode","value","valueExpression","invocationScope","getScope","constructInfo","constructType","constructNode","constructUsage","data","nodeLine","loc","start","line","messageId","usageLine","variableName"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-no-constructed-context-values.js"],"sourcesContent":["/**\n * @fileoverview Prevents jsx context provider values from taking values that\n *               will cause needless rerenders.\n * @author Dylan Oshima\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Helpers\n// ------------------------------------------------------------------------------\n\n// Recursively checks if an element is a construction.\n// A construction is a variable that changes identity every render.\nfunction isConstruction(node, callScope) {\n  switch (node.type) {\n    case 'Literal':\n      if (node.regex != null) {\n        return { type: 'regular expression', node };\n      }\n      return null;\n    case 'Identifier': {\n      const variableScoping = callScope.set.get(node.name);\n\n      if (variableScoping == null || variableScoping.defs == null) {\n        // If it's not in scope, we don't care.\n        return null; // Handled\n      }\n\n      // Gets the last variable identity\n      const variableDefs = variableScoping.defs;\n      const def = variableDefs[variableDefs.length - 1];\n      if (def != null\n        && def.type !== 'Variable'\n        && def.type !== 'FunctionName'\n      ) {\n        // Parameter or an unusual pattern. Bail out.\n        return null; // Unhandled\n      }\n\n      if (def.node.type === 'FunctionDeclaration') {\n        return { type: 'function declaration', node: def.node, usage: node };\n      }\n\n      const init = def.node.init;\n      if (init == null) {\n        return null;\n      }\n\n      const initConstruction = isConstruction(init, callScope);\n      if (initConstruction == null) {\n        return null;\n      }\n\n      return {\n        type: initConstruction.type,\n        node: initConstruction.node,\n        usage: node,\n      };\n    }\n    case 'ObjectExpression':\n      // Any object initialized inline will create a new identity\n      return { type: 'object', node };\n    case 'ArrayExpression':\n      return { type: 'array', node };\n    case 'ArrowFunctionExpression':\n    case 'FunctionExpression':\n      // Functions that are initialized inline will have a new identity\n      return { type: 'function expression', node };\n    case 'ClassExpression':\n      return { type: 'class expression', node };\n    case 'NewExpression':\n      // `const a = new SomeClass();` is a construction\n      return { type: 'new expression', node };\n    case 'ConditionalExpression':\n      return (isConstruction(node.consequent, callScope)\n        || isConstruction(node.alternate, callScope)\n      );\n    case 'LogicalExpression':\n      return (isConstruction(node.left, callScope)\n        || isConstruction(node.right, callScope)\n      );\n    case 'MemberExpression': {\n      const objConstruction = isConstruction(node.object, callScope);\n      if (objConstruction == null) {\n        return null;\n      }\n      return {\n        type: objConstruction.type,\n        node: objConstruction.node,\n        usage: node.object,\n      };\n    }\n    case 'JSXFragment':\n      return { type: 'JSX fragment', node };\n    case 'JSXElement':\n      return { type: 'JSX element', node };\n    case 'AssignmentExpression': {\n      const construct = isConstruction(node.right, callScope);\n      if (construct != null) {\n        return {\n          type: 'assignment expression',\n          node: construct.node,\n          usage: node,\n        };\n      }\n      return null;\n    }\n    case 'TypeCastExpression':\n    case 'TSAsExpression':\n      return isConstruction(node.expression, callScope);\n    default:\n      return null;\n  }\n}\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  withIdentifierMsg: \"The '{{variableName}}' {{type}} (at line {{nodeLine}}) passed as the value prop to the Context provider (at line {{usageLine}}) changes every render. To fix this consider wrapping it in a useMemo hook.\",\n  withIdentifierMsgFunc: \"The '{{variableName}}' {{type}} (at line {{nodeLine}}) passed as the value prop to the Context provider (at line {{usageLine}}) changes every render. To fix this consider wrapping it in a useCallback hook.\",\n  defaultMsg: 'The {{type}} passed as the value prop to the Context provider (at line {{nodeLine}}) changes every render. To fix this consider wrapping it in a useMemo hook.',\n  defaultMsgFunc: 'The {{type}} passed as the value prop to the Context provider (at line {{nodeLine}}) changes every render. To fix this consider wrapping it in a useCallback hook.',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallows JSX context provider values from taking values that will cause needless rerenders',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('jsx-no-constructed-context-values'),\n    },\n    messages,\n  },\n\n  create(context) {\n    return {\n      JSXOpeningElement(node) {\n        const openingElementName = node.name;\n        if (openingElementName.type !== 'JSXMemberExpression') {\n          // Has no member\n          return;\n        }\n\n        const isJsxContext = openingElementName.property.name === 'Provider';\n        if (!isJsxContext) {\n          // Member is not Provider\n          return;\n        }\n\n        // Contexts can take in more than just a value prop\n        // so we need to iterate through all of them\n        const jsxValueAttribute = node.attributes.find(\n          (attribute) => attribute.type === 'JSXAttribute' && attribute.name.name === 'value'\n        );\n\n        if (jsxValueAttribute == null) {\n          // No value prop was passed\n          return;\n        }\n\n        const valueNode = jsxValueAttribute.value;\n        if (!valueNode) {\n          // attribute is a boolean shorthand\n          return;\n        }\n        if (valueNode.type !== 'JSXExpressionContainer') {\n          // value could be a literal\n          return;\n        }\n\n        const valueExpression = valueNode.expression;\n        const invocationScope = context.getScope();\n\n        // Check if the value prop is a construction\n        const constructInfo = isConstruction(valueExpression, invocationScope);\n        if (constructInfo == null) {\n          return;\n        }\n\n        // Report found error\n        const constructType = constructInfo.type;\n        const constructNode = constructInfo.node;\n        const constructUsage = constructInfo.usage;\n        const data = {\n          type: constructType, nodeLine: constructNode.loc.start.line,\n        };\n        let messageId = 'defaultMsg';\n\n        // Variable passed to value prop\n        if (constructUsage != null) {\n          messageId = 'withIdentifierMsg';\n          data.usageLine = constructUsage.loc.start.line;\n          data.variableName = constructUsage.name;\n        }\n\n        // Type of expression\n        if (\n          constructType === 'function expression'\n          || constructType === 'function declaration'\n        ) {\n          messageId += 'Func';\n        }\n\n        report(context, messages[messageId], messageId, {\n          node: constructNode,\n          data,\n        });\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}