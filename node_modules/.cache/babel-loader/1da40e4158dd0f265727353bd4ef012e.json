{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _helperExplodeAssignableExpression = require(\"@babel/helper-explode-assignable-expression\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  assignmentExpression,\n  sequenceExpression\n} = _t;\n\nfunction _default(opts) {\n  const {\n    build,\n    operator\n  } = opts;\n  const visitor = {\n    AssignmentExpression(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (node.operator !== operator + \"=\") return;\n      const nodes = [];\n      const exploded = (0, _helperExplodeAssignableExpression.default)(node.left, nodes, this, scope);\n      nodes.push(assignmentExpression(\"=\", exploded.ref, build(exploded.uid, node.right)));\n      path.replaceWith(sequenceExpression(nodes));\n    },\n\n    BinaryExpression(path) {\n      const {\n        node\n      } = path;\n\n      if (node.operator === operator) {\n        path.replaceWith(build(node.left, node.right));\n      }\n    }\n\n  };\n  return visitor;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_default","_helperExplodeAssignableExpression","require","_t","assignmentExpression","sequenceExpression","opts","build","operator","visitor","AssignmentExpression","path","node","scope","nodes","exploded","left","push","ref","uid","right","replaceWith","BinaryExpression"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/helper-builder-binary-assignment-operator-visitor/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _helperExplodeAssignableExpression = require(\"@babel/helper-explode-assignable-expression\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  assignmentExpression,\n  sequenceExpression\n} = _t;\n\nfunction _default(opts) {\n  const {\n    build,\n    operator\n  } = opts;\n  const visitor = {\n    AssignmentExpression(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (node.operator !== operator + \"=\") return;\n      const nodes = [];\n      const exploded = (0, _helperExplodeAssignableExpression.default)(node.left, nodes, this, scope);\n      nodes.push(assignmentExpression(\"=\", exploded.ref, build(exploded.uid, node.right)));\n      path.replaceWith(sequenceExpression(nodes));\n    },\n\n    BinaryExpression(path) {\n      const {\n        node\n      } = path;\n\n      if (node.operator === operator) {\n        path.replaceWith(build(node.left, node.right));\n      }\n    }\n\n  };\n  return visitor;\n}"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,QAAlB;;AAEA,IAAIC,kCAAkC,GAAGC,OAAO,CAAC,6CAAD,CAAhD;;AAEA,IAAIC,EAAE,GAAGD,OAAO,CAAC,cAAD,CAAhB;;AAEA,MAAM;EACJE,oBADI;EAEJC;AAFI,IAGFF,EAHJ;;AAKA,SAASH,QAAT,CAAkBM,IAAlB,EAAwB;EACtB,MAAM;IACJC,KADI;IAEJC;EAFI,IAGFF,IAHJ;EAIA,MAAMG,OAAO,GAAG;IACdC,oBAAoB,CAACC,IAAD,EAAO;MACzB,MAAM;QACJC,IADI;QAEJC;MAFI,IAGFF,IAHJ;MAIA,IAAIC,IAAI,CAACJ,QAAL,KAAkBA,QAAQ,GAAG,GAAjC,EAAsC;MACtC,MAAMM,KAAK,GAAG,EAAd;MACA,MAAMC,QAAQ,GAAG,CAAC,GAAGd,kCAAkC,CAACF,OAAvC,EAAgDa,IAAI,CAACI,IAArD,EAA2DF,KAA3D,EAAkE,IAAlE,EAAwED,KAAxE,CAAjB;MACAC,KAAK,CAACG,IAAN,CAAWb,oBAAoB,CAAC,GAAD,EAAMW,QAAQ,CAACG,GAAf,EAAoBX,KAAK,CAACQ,QAAQ,CAACI,GAAV,EAAeP,IAAI,CAACQ,KAApB,CAAzB,CAA/B;MACAT,IAAI,CAACU,WAAL,CAAiBhB,kBAAkB,CAACS,KAAD,CAAnC;IACD,CAXa;;IAadQ,gBAAgB,CAACX,IAAD,EAAO;MACrB,MAAM;QACJC;MADI,IAEFD,IAFJ;;MAIA,IAAIC,IAAI,CAACJ,QAAL,KAAkBA,QAAtB,EAAgC;QAC9BG,IAAI,CAACU,WAAL,CAAiBd,KAAK,CAACK,IAAI,CAACI,IAAN,EAAYJ,IAAI,CAACQ,KAAjB,CAAtB;MACD;IACF;;EArBa,CAAhB;EAwBA,OAAOX,OAAP;AACD"},"metadata":{},"sourceType":"script"}