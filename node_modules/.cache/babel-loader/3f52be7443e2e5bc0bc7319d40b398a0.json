{"ast":null,"code":"// Partial port of python's argparse module, version 3.9.0 (only wrap and fill functions):\n// https://github.com/python/cpython/blob/v3.9.0b4/Lib/textwrap.py\n'use strict';\n/*\n * Text wrapping and filling.\n */\n// Copyright (C) 1999-2001 Gregory P. Ward.\n// Copyright (C) 2002, 2003 Python Software Foundation.\n// Copyright (C) 2020 argparse.js authors\n// Originally written by Greg Ward <gward@python.net>\n// Hardcode the recognized whitespace characters to the US-ASCII\n// whitespace characters.  The main reason for doing this is that\n// some Unicode spaces (like \\u00a0) are non-breaking whitespaces.\n//\n// This less funky little regex just split on recognized spaces. E.g.\n//   \"Hello there -- you goof-ball, use the -b option!\"\n// splits into\n//   Hello/ /there/ /--/ /you/ /goof-ball,/ /use/ /the/ /-b/ /option!/\n\nconst wordsep_simple_re = /([\\t\\n\\x0b\\x0c\\r ]+)/;\n\nclass TextWrapper {\n  /*\n   *  Object for wrapping/filling text.  The public interface consists of\n   *  the wrap() and fill() methods; the other methods are just there for\n   *  subclasses to override in order to tweak the default behaviour.\n   *  If you want to completely replace the main wrapping algorithm,\n   *  you'll probably have to override _wrap_chunks().\n   *\n   *  Several instance attributes control various aspects of wrapping:\n   *    width (default: 70)\n   *      the maximum width of wrapped lines (unless break_long_words\n   *      is false)\n   *    initial_indent (default: \"\")\n   *      string that will be prepended to the first line of wrapped\n   *      output.  Counts towards the line's width.\n   *    subsequent_indent (default: \"\")\n   *      string that will be prepended to all lines save the first\n   *      of wrapped output; also counts towards each line's width.\n   *    expand_tabs (default: true)\n   *      Expand tabs in input text to spaces before further processing.\n   *      Each tab will become 0 .. 'tabsize' spaces, depending on its position\n   *      in its line.  If false, each tab is treated as a single character.\n   *    tabsize (default: 8)\n   *      Expand tabs in input text to 0 .. 'tabsize' spaces, unless\n   *      'expand_tabs' is false.\n   *    replace_whitespace (default: true)\n   *      Replace all whitespace characters in the input text by spaces\n   *      after tab expansion.  Note that if expand_tabs is false and\n   *      replace_whitespace is true, every tab will be converted to a\n   *      single space!\n   *    fix_sentence_endings (default: false)\n   *      Ensure that sentence-ending punctuation is always followed\n   *      by two spaces.  Off by default because the algorithm is\n   *      (unavoidably) imperfect.\n   *    break_long_words (default: true)\n   *      Break words longer than 'width'.  If false, those words will not\n   *      be broken, and some lines might be longer than 'width'.\n   *    break_on_hyphens (default: true)\n   *      Allow breaking hyphenated words. If true, wrapping will occur\n   *      preferably on whitespaces and right after hyphens part of\n   *      compound words.\n   *    drop_whitespace (default: true)\n   *      Drop leading and trailing whitespace from lines.\n   *    max_lines (default: None)\n   *      Truncate wrapped lines.\n   *    placeholder (default: ' [...]')\n   *      Append to the last line of truncated text.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let {\n      width = 70,\n      initial_indent = '',\n      subsequent_indent = '',\n      expand_tabs = true,\n      replace_whitespace = true,\n      fix_sentence_endings = false,\n      break_long_words = true,\n      drop_whitespace = true,\n      break_on_hyphens = true,\n      tabsize = 8,\n      max_lines = undefined,\n      placeholder = ' [...]'\n    } = options;\n    this.width = width;\n    this.initial_indent = initial_indent;\n    this.subsequent_indent = subsequent_indent;\n    this.expand_tabs = expand_tabs;\n    this.replace_whitespace = replace_whitespace;\n    this.fix_sentence_endings = fix_sentence_endings;\n    this.break_long_words = break_long_words;\n    this.drop_whitespace = drop_whitespace;\n    this.break_on_hyphens = break_on_hyphens;\n    this.tabsize = tabsize;\n    this.max_lines = max_lines;\n    this.placeholder = placeholder;\n  } // -- Private methods -----------------------------------------------\n  // (possibly useful for subclasses to override)\n\n\n  _munge_whitespace(text) {\n    /*\n     *  _munge_whitespace(text : string) -> string\n     *\n     *  Munge whitespace in text: expand tabs and convert all other\n     *  whitespace characters to spaces.  Eg. \" foo\\\\tbar\\\\n\\\\nbaz\"\n     *  becomes \" foo    bar  baz\".\n     */\n    if (this.expand_tabs) {\n      text = text.replace(/\\t/g, ' '.repeat(this.tabsize)); // not strictly correct in js\n    }\n\n    if (this.replace_whitespace) {\n      text = text.replace(/[\\t\\n\\x0b\\x0c\\r]/g, ' ');\n    }\n\n    return text;\n  }\n\n  _split(text) {\n    /*\n     *  _split(text : string) -> [string]\n     *\n     *  Split the text to wrap into indivisible chunks.  Chunks are\n     *  not quite the same as words; see _wrap_chunks() for full\n     *  details.  As an example, the text\n     *    Look, goof-ball -- use the -b option!\n     *  breaks into the following chunks:\n     *    'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ',\n     *    'use', ' ', 'the', ' ', '-b', ' ', 'option!'\n     *  if break_on_hyphens is True, or in:\n     *    'Look,', ' ', 'goof-ball', ' ', '--', ' ',\n     *    'use', ' ', 'the', ' ', '-b', ' ', option!'\n     *  otherwise.\n     */\n    let chunks = text.split(wordsep_simple_re);\n    chunks = chunks.filter(Boolean);\n    return chunks;\n  }\n\n  _handle_long_word(reversed_chunks, cur_line, cur_len, width) {\n    /*\n     *  _handle_long_word(chunks : [string],\n     *                    cur_line : [string],\n     *                    cur_len : int, width : int)\n     *\n     *  Handle a chunk of text (most likely a word, not whitespace) that\n     *  is too long to fit in any line.\n     */\n    // Figure out when indent is larger than the specified width, and make\n    // sure at least one character is stripped off on every pass\n    let space_left;\n\n    if (width < 1) {\n      space_left = 1;\n    } else {\n      space_left = width - cur_len;\n    } // If we're allowed to break long words, then do so: put as much\n    // of the next chunk onto the current line as will fit.\n\n\n    if (this.break_long_words) {\n      cur_line.push(reversed_chunks[reversed_chunks.length - 1].slice(0, space_left));\n      reversed_chunks[reversed_chunks.length - 1] = reversed_chunks[reversed_chunks.length - 1].slice(space_left); // Otherwise, we have to preserve the long word intact.  Only add\n      // it to the current line if there's nothing already there --\n      // that minimizes how much we violate the width constraint.\n    } else if (!cur_line) {\n      cur_line.push(...reversed_chunks.pop());\n    } // If we're not allowed to break long words, and there's already\n    // text on the current line, do nothing.  Next time through the\n    // main loop of _wrap_chunks(), we'll wind up here again, but\n    // cur_len will be zero, so the next line will be entirely\n    // devoted to the long word that we can't handle right now.\n\n  }\n\n  _wrap_chunks(chunks) {\n    /*\n     *  _wrap_chunks(chunks : [string]) -> [string]\n     *\n     *  Wrap a sequence of text chunks and return a list of lines of\n     *  length 'self.width' or less.  (If 'break_long_words' is false,\n     *  some lines may be longer than this.)  Chunks correspond roughly\n     *  to words and the whitespace between them: each chunk is\n     *  indivisible (modulo 'break_long_words'), but a line break can\n     *  come between any two chunks.  Chunks should not have internal\n     *  whitespace; ie. a chunk is either all whitespace or a \"word\".\n     *  Whitespace chunks will be removed from the beginning and end of\n     *  lines, but apart from that whitespace is preserved.\n     */\n    let lines = [];\n    let indent;\n\n    if (this.width <= 0) {\n      throw Error(`invalid width ${this.width} (must be > 0)`);\n    }\n\n    if (this.max_lines !== undefined) {\n      if (this.max_lines > 1) {\n        indent = this.subsequent_indent;\n      } else {\n        indent = this.initial_indent;\n      }\n\n      if (indent.length + this.placeholder.trimStart().length > this.width) {\n        throw Error('placeholder too large for max width');\n      }\n    } // Arrange in reverse order so items can be efficiently popped\n    // from a stack of chucks.\n\n\n    chunks = chunks.reverse();\n\n    while (chunks.length > 0) {\n      // Start the list of chunks that will make up the current line.\n      // cur_len is just the length of all the chunks in cur_line.\n      let cur_line = [];\n      let cur_len = 0; // Figure out which static string will prefix this line.\n\n      let indent;\n\n      if (lines) {\n        indent = this.subsequent_indent;\n      } else {\n        indent = this.initial_indent;\n      } // Maximum width for this line.\n\n\n      let width = this.width - indent.length; // First chunk on line is whitespace -- drop it, unless this\n      // is the very beginning of the text (ie. no lines started yet).\n\n      if (this.drop_whitespace && chunks[chunks.length - 1].trim() === '' && lines.length > 0) {\n        chunks.pop();\n      }\n\n      while (chunks.length > 0) {\n        let l = chunks[chunks.length - 1].length; // Can at least squeeze this chunk onto the current line.\n\n        if (cur_len + l <= width) {\n          cur_line.push(chunks.pop());\n          cur_len += l; // Nope, this line is full.\n        } else {\n          break;\n        }\n      } // The current line is full, and the next chunk is too big to\n      // fit on *any* line (not just this one).\n\n\n      if (chunks.length && chunks[chunks.length - 1].length > width) {\n        this._handle_long_word(chunks, cur_line, cur_len, width);\n\n        cur_len = cur_line.map(l => l.length).reduce((a, b) => a + b, 0);\n      } // If the last chunk on this line is all whitespace, drop it.\n\n\n      if (this.drop_whitespace && cur_line.length > 0 && cur_line[cur_line.length - 1].trim() === '') {\n        cur_len -= cur_line[cur_line.length - 1].length;\n        cur_line.pop();\n      }\n\n      if (cur_line) {\n        if (this.max_lines === undefined || lines.length + 1 < this.max_lines || (chunks.length === 0 || this.drop_whitespace && chunks.length === 1 && !chunks[0].trim()) && cur_len <= width) {\n          // Convert current line back to a string and store it in\n          // list of all lines (return value).\n          lines.push(indent + cur_line.join(''));\n        } else {\n          let had_break = false;\n\n          while (cur_line) {\n            if (cur_line[cur_line.length - 1].trim() && cur_len + this.placeholder.length <= width) {\n              cur_line.push(this.placeholder);\n              lines.push(indent + cur_line.join(''));\n              had_break = true;\n              break;\n            }\n\n            cur_len -= cur_line[-1].length;\n            cur_line.pop();\n          }\n\n          if (!had_break) {\n            if (lines) {\n              let prev_line = lines[lines.length - 1].trimEnd();\n\n              if (prev_line.length + this.placeholder.length <= this.width) {\n                lines[lines.length - 1] = prev_line + this.placeholder;\n                break;\n              }\n            }\n\n            lines.push(indent + this.placeholder.lstrip());\n          }\n\n          break;\n        }\n      }\n    }\n\n    return lines;\n  }\n\n  _split_chunks(text) {\n    text = this._munge_whitespace(text);\n    return this._split(text);\n  } // -- Public interface ----------------------------------------------\n\n\n  wrap(text) {\n    /*\n     *  wrap(text : string) -> [string]\n     *\n     *  Reformat the single paragraph in 'text' so it fits in lines of\n     *  no more than 'self.width' columns, and return a list of wrapped\n     *  lines.  Tabs in 'text' are expanded with string.expandtabs(),\n     *  and all other whitespace characters (including newline) are\n     *  converted to space.\n     */\n    let chunks = this._split_chunks(text); // not implemented in js\n    //if (this.fix_sentence_endings) {\n    //    this._fix_sentence_endings(chunks)\n    //}\n\n\n    return this._wrap_chunks(chunks);\n  }\n\n  fill(text) {\n    /*\n     *  fill(text : string) -> string\n     *\n     *  Reformat the single paragraph in 'text' to fit in lines of no\n     *  more than 'self.width' columns, and return a new string\n     *  containing the entire wrapped paragraph.\n     */\n    return this.wrap(text).join('\\n');\n  }\n\n} // -- Convenience interface ---------------------------------------------\n\n\nfunction wrap(text) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /*\n   *  Wrap a single paragraph of text, returning a list of wrapped lines.\n   *\n   *  Reformat the single paragraph in 'text' so it fits in lines of no\n   *  more than 'width' columns, and return a list of wrapped lines.  By\n   *  default, tabs in 'text' are expanded with string.expandtabs(), and\n   *  all other whitespace characters (including newline) are converted to\n   *  space.  See TextWrapper class for available keyword args to customize\n   *  wrapping behaviour.\n   */\n  let {\n    width = 70,\n    ...kwargs\n  } = options;\n  let w = new TextWrapper(Object.assign({\n    width\n  }, kwargs));\n  return w.wrap(text);\n}\n\nfunction fill(text) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /*\n   *  Fill a single paragraph of text, returning a new string.\n   *\n   *  Reformat the single paragraph in 'text' to fit in lines of no more\n   *  than 'width' columns, and return a new string containing the entire\n   *  wrapped paragraph.  As with wrap(), tabs are expanded and other\n   *  whitespace characters converted to space.  See TextWrapper class for\n   *  available keyword args to customize wrapping behaviour.\n   */\n  let {\n    width = 70,\n    ...kwargs\n  } = options;\n  let w = new TextWrapper(Object.assign({\n    width\n  }, kwargs));\n  return w.fill(text);\n} // -- Loosely related functionality -------------------------------------\n\n\nlet _whitespace_only_re = /^[ \\t]+$/mg;\nlet _leading_whitespace_re = /(^[ \\t]*)(?:[^ \\t\\n])/mg;\n\nfunction dedent(text) {\n  /*\n   *  Remove any common leading whitespace from every line in `text`.\n   *\n   *  This can be used to make triple-quoted strings line up with the left\n   *  edge of the display, while still presenting them in the source code\n   *  in indented form.\n   *\n   *  Note that tabs and spaces are both treated as whitespace, but they\n   *  are not equal: the lines \"  hello\" and \"\\\\thello\" are\n   *  considered to have no common leading whitespace.\n   *\n   *  Entirely blank lines are normalized to a newline character.\n   */\n  // Look for the longest leading string of spaces and tabs common to\n  // all lines.\n  let margin = undefined;\n  text = text.replace(_whitespace_only_re, '');\n  let indents = text.match(_leading_whitespace_re) || [];\n\n  for (let indent of indents) {\n    indent = indent.slice(0, -1);\n\n    if (margin === undefined) {\n      margin = indent; // Current line more deeply indented than previous winner:\n      // no change (previous winner is still on top).\n    } else if (indent.startsWith(margin)) {// pass\n      // Current line consistent with and no deeper than previous winner:\n      // it's the new winner.\n    } else if (margin.startsWith(indent)) {\n      margin = indent; // Find the largest common whitespace between current line and previous\n      // winner.\n    } else {\n      for (let i = 0; i < margin.length && i < indent.length; i++) {\n        if (margin[i] !== indent[i]) {\n          margin = margin.slice(0, i);\n          break;\n        }\n      }\n    }\n  }\n\n  if (margin) {\n    text = text.replace(new RegExp('^' + margin, 'mg'), '');\n  }\n\n  return text;\n}\n\nmodule.exports = {\n  wrap,\n  fill,\n  dedent\n};","map":{"version":3,"names":["wordsep_simple_re","TextWrapper","constructor","options","width","initial_indent","subsequent_indent","expand_tabs","replace_whitespace","fix_sentence_endings","break_long_words","drop_whitespace","break_on_hyphens","tabsize","max_lines","undefined","placeholder","_munge_whitespace","text","replace","repeat","_split","chunks","split","filter","Boolean","_handle_long_word","reversed_chunks","cur_line","cur_len","space_left","push","length","slice","pop","_wrap_chunks","lines","indent","Error","trimStart","reverse","trim","l","map","reduce","a","b","join","had_break","prev_line","trimEnd","lstrip","_split_chunks","wrap","fill","kwargs","w","Object","assign","_whitespace_only_re","_leading_whitespace_re","dedent","margin","indents","match","startsWith","i","RegExp","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@eslint/eslintrc/node_modules/argparse/lib/textwrap.js"],"sourcesContent":["// Partial port of python's argparse module, version 3.9.0 (only wrap and fill functions):\n// https://github.com/python/cpython/blob/v3.9.0b4/Lib/textwrap.py\n\n'use strict'\n\n/*\n * Text wrapping and filling.\n */\n\n// Copyright (C) 1999-2001 Gregory P. Ward.\n// Copyright (C) 2002, 2003 Python Software Foundation.\n// Copyright (C) 2020 argparse.js authors\n// Originally written by Greg Ward <gward@python.net>\n\n// Hardcode the recognized whitespace characters to the US-ASCII\n// whitespace characters.  The main reason for doing this is that\n// some Unicode spaces (like \\u00a0) are non-breaking whitespaces.\n//\n// This less funky little regex just split on recognized spaces. E.g.\n//   \"Hello there -- you goof-ball, use the -b option!\"\n// splits into\n//   Hello/ /there/ /--/ /you/ /goof-ball,/ /use/ /the/ /-b/ /option!/\nconst wordsep_simple_re = /([\\t\\n\\x0b\\x0c\\r ]+)/\n\nclass TextWrapper {\n    /*\n     *  Object for wrapping/filling text.  The public interface consists of\n     *  the wrap() and fill() methods; the other methods are just there for\n     *  subclasses to override in order to tweak the default behaviour.\n     *  If you want to completely replace the main wrapping algorithm,\n     *  you'll probably have to override _wrap_chunks().\n     *\n     *  Several instance attributes control various aspects of wrapping:\n     *    width (default: 70)\n     *      the maximum width of wrapped lines (unless break_long_words\n     *      is false)\n     *    initial_indent (default: \"\")\n     *      string that will be prepended to the first line of wrapped\n     *      output.  Counts towards the line's width.\n     *    subsequent_indent (default: \"\")\n     *      string that will be prepended to all lines save the first\n     *      of wrapped output; also counts towards each line's width.\n     *    expand_tabs (default: true)\n     *      Expand tabs in input text to spaces before further processing.\n     *      Each tab will become 0 .. 'tabsize' spaces, depending on its position\n     *      in its line.  If false, each tab is treated as a single character.\n     *    tabsize (default: 8)\n     *      Expand tabs in input text to 0 .. 'tabsize' spaces, unless\n     *      'expand_tabs' is false.\n     *    replace_whitespace (default: true)\n     *      Replace all whitespace characters in the input text by spaces\n     *      after tab expansion.  Note that if expand_tabs is false and\n     *      replace_whitespace is true, every tab will be converted to a\n     *      single space!\n     *    fix_sentence_endings (default: false)\n     *      Ensure that sentence-ending punctuation is always followed\n     *      by two spaces.  Off by default because the algorithm is\n     *      (unavoidably) imperfect.\n     *    break_long_words (default: true)\n     *      Break words longer than 'width'.  If false, those words will not\n     *      be broken, and some lines might be longer than 'width'.\n     *    break_on_hyphens (default: true)\n     *      Allow breaking hyphenated words. If true, wrapping will occur\n     *      preferably on whitespaces and right after hyphens part of\n     *      compound words.\n     *    drop_whitespace (default: true)\n     *      Drop leading and trailing whitespace from lines.\n     *    max_lines (default: None)\n     *      Truncate wrapped lines.\n     *    placeholder (default: ' [...]')\n     *      Append to the last line of truncated text.\n     */\n\n    constructor(options = {}) {\n        let {\n            width = 70,\n            initial_indent = '',\n            subsequent_indent = '',\n            expand_tabs = true,\n            replace_whitespace = true,\n            fix_sentence_endings = false,\n            break_long_words = true,\n            drop_whitespace = true,\n            break_on_hyphens = true,\n            tabsize = 8,\n            max_lines = undefined,\n            placeholder=' [...]'\n        } = options\n\n        this.width = width\n        this.initial_indent = initial_indent\n        this.subsequent_indent = subsequent_indent\n        this.expand_tabs = expand_tabs\n        this.replace_whitespace = replace_whitespace\n        this.fix_sentence_endings = fix_sentence_endings\n        this.break_long_words = break_long_words\n        this.drop_whitespace = drop_whitespace\n        this.break_on_hyphens = break_on_hyphens\n        this.tabsize = tabsize\n        this.max_lines = max_lines\n        this.placeholder = placeholder\n    }\n\n\n    // -- Private methods -----------------------------------------------\n    // (possibly useful for subclasses to override)\n\n    _munge_whitespace(text) {\n        /*\n         *  _munge_whitespace(text : string) -> string\n         *\n         *  Munge whitespace in text: expand tabs and convert all other\n         *  whitespace characters to spaces.  Eg. \" foo\\\\tbar\\\\n\\\\nbaz\"\n         *  becomes \" foo    bar  baz\".\n         */\n        if (this.expand_tabs) {\n            text = text.replace(/\\t/g, ' '.repeat(this.tabsize)) // not strictly correct in js\n        }\n        if (this.replace_whitespace) {\n            text = text.replace(/[\\t\\n\\x0b\\x0c\\r]/g, ' ')\n        }\n        return text\n    }\n\n    _split(text) {\n        /*\n         *  _split(text : string) -> [string]\n         *\n         *  Split the text to wrap into indivisible chunks.  Chunks are\n         *  not quite the same as words; see _wrap_chunks() for full\n         *  details.  As an example, the text\n         *    Look, goof-ball -- use the -b option!\n         *  breaks into the following chunks:\n         *    'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ',\n         *    'use', ' ', 'the', ' ', '-b', ' ', 'option!'\n         *  if break_on_hyphens is True, or in:\n         *    'Look,', ' ', 'goof-ball', ' ', '--', ' ',\n         *    'use', ' ', 'the', ' ', '-b', ' ', option!'\n         *  otherwise.\n         */\n        let chunks = text.split(wordsep_simple_re)\n        chunks = chunks.filter(Boolean)\n        return chunks\n    }\n\n    _handle_long_word(reversed_chunks, cur_line, cur_len, width) {\n        /*\n         *  _handle_long_word(chunks : [string],\n         *                    cur_line : [string],\n         *                    cur_len : int, width : int)\n         *\n         *  Handle a chunk of text (most likely a word, not whitespace) that\n         *  is too long to fit in any line.\n         */\n        // Figure out when indent is larger than the specified width, and make\n        // sure at least one character is stripped off on every pass\n        let space_left\n        if (width < 1) {\n            space_left = 1\n        } else {\n            space_left = width - cur_len\n        }\n\n        // If we're allowed to break long words, then do so: put as much\n        // of the next chunk onto the current line as will fit.\n        if (this.break_long_words) {\n            cur_line.push(reversed_chunks[reversed_chunks.length - 1].slice(0, space_left))\n            reversed_chunks[reversed_chunks.length - 1] = reversed_chunks[reversed_chunks.length - 1].slice(space_left)\n\n        // Otherwise, we have to preserve the long word intact.  Only add\n        // it to the current line if there's nothing already there --\n        // that minimizes how much we violate the width constraint.\n        } else if (!cur_line) {\n            cur_line.push(...reversed_chunks.pop())\n        }\n\n        // If we're not allowed to break long words, and there's already\n        // text on the current line, do nothing.  Next time through the\n        // main loop of _wrap_chunks(), we'll wind up here again, but\n        // cur_len will be zero, so the next line will be entirely\n        // devoted to the long word that we can't handle right now.\n    }\n\n    _wrap_chunks(chunks) {\n        /*\n         *  _wrap_chunks(chunks : [string]) -> [string]\n         *\n         *  Wrap a sequence of text chunks and return a list of lines of\n         *  length 'self.width' or less.  (If 'break_long_words' is false,\n         *  some lines may be longer than this.)  Chunks correspond roughly\n         *  to words and the whitespace between them: each chunk is\n         *  indivisible (modulo 'break_long_words'), but a line break can\n         *  come between any two chunks.  Chunks should not have internal\n         *  whitespace; ie. a chunk is either all whitespace or a \"word\".\n         *  Whitespace chunks will be removed from the beginning and end of\n         *  lines, but apart from that whitespace is preserved.\n         */\n        let lines = []\n        let indent\n        if (this.width <= 0) {\n            throw Error(`invalid width ${this.width} (must be > 0)`)\n        }\n        if (this.max_lines !== undefined) {\n            if (this.max_lines > 1) {\n                indent = this.subsequent_indent\n            } else {\n                indent = this.initial_indent\n            }\n            if (indent.length + this.placeholder.trimStart().length > this.width) {\n                throw Error('placeholder too large for max width')\n            }\n        }\n\n        // Arrange in reverse order so items can be efficiently popped\n        // from a stack of chucks.\n        chunks = chunks.reverse()\n\n        while (chunks.length > 0) {\n\n            // Start the list of chunks that will make up the current line.\n            // cur_len is just the length of all the chunks in cur_line.\n            let cur_line = []\n            let cur_len = 0\n\n            // Figure out which static string will prefix this line.\n            let indent\n            if (lines) {\n                indent = this.subsequent_indent\n            } else {\n                indent = this.initial_indent\n            }\n\n            // Maximum width for this line.\n            let width = this.width - indent.length\n\n            // First chunk on line is whitespace -- drop it, unless this\n            // is the very beginning of the text (ie. no lines started yet).\n            if (this.drop_whitespace && chunks[chunks.length - 1].trim() === '' && lines.length > 0) {\n                chunks.pop()\n            }\n\n            while (chunks.length > 0) {\n                let l = chunks[chunks.length - 1].length\n\n                // Can at least squeeze this chunk onto the current line.\n                if (cur_len + l <= width) {\n                    cur_line.push(chunks.pop())\n                    cur_len += l\n\n                // Nope, this line is full.\n                } else {\n                    break\n                }\n            }\n\n            // The current line is full, and the next chunk is too big to\n            // fit on *any* line (not just this one).\n            if (chunks.length && chunks[chunks.length - 1].length > width) {\n                this._handle_long_word(chunks, cur_line, cur_len, width)\n                cur_len = cur_line.map(l => l.length).reduce((a, b) => a + b, 0)\n            }\n\n            // If the last chunk on this line is all whitespace, drop it.\n            if (this.drop_whitespace && cur_line.length > 0 && cur_line[cur_line.length - 1].trim() === '') {\n                cur_len -= cur_line[cur_line.length - 1].length\n                cur_line.pop()\n            }\n\n            if (cur_line) {\n                if (this.max_lines === undefined ||\n                    lines.length + 1 < this.max_lines ||\n                    (chunks.length === 0 ||\n                     this.drop_whitespace &&\n                     chunks.length === 1 &&\n                     !chunks[0].trim()) && cur_len <= width) {\n                    // Convert current line back to a string and store it in\n                    // list of all lines (return value).\n                    lines.push(indent + cur_line.join(''))\n                } else {\n                    let had_break = false\n                    while (cur_line) {\n                        if (cur_line[cur_line.length - 1].trim() &&\n                            cur_len + this.placeholder.length <= width) {\n                            cur_line.push(this.placeholder)\n                            lines.push(indent + cur_line.join(''))\n                            had_break = true\n                            break\n                        }\n                        cur_len -= cur_line[-1].length\n                        cur_line.pop()\n                    }\n                    if (!had_break) {\n                        if (lines) {\n                            let prev_line = lines[lines.length - 1].trimEnd()\n                            if (prev_line.length + this.placeholder.length <=\n                                    this.width) {\n                                lines[lines.length - 1] = prev_line + this.placeholder\n                                break\n                            }\n                        }\n                        lines.push(indent + this.placeholder.lstrip())\n                    }\n                    break\n                }\n            }\n        }\n\n        return lines\n    }\n\n    _split_chunks(text) {\n        text = this._munge_whitespace(text)\n        return this._split(text)\n    }\n\n    // -- Public interface ----------------------------------------------\n\n    wrap(text) {\n        /*\n         *  wrap(text : string) -> [string]\n         *\n         *  Reformat the single paragraph in 'text' so it fits in lines of\n         *  no more than 'self.width' columns, and return a list of wrapped\n         *  lines.  Tabs in 'text' are expanded with string.expandtabs(),\n         *  and all other whitespace characters (including newline) are\n         *  converted to space.\n         */\n        let chunks = this._split_chunks(text)\n        // not implemented in js\n        //if (this.fix_sentence_endings) {\n        //    this._fix_sentence_endings(chunks)\n        //}\n        return this._wrap_chunks(chunks)\n    }\n\n    fill(text) {\n        /*\n         *  fill(text : string) -> string\n         *\n         *  Reformat the single paragraph in 'text' to fit in lines of no\n         *  more than 'self.width' columns, and return a new string\n         *  containing the entire wrapped paragraph.\n         */\n        return this.wrap(text).join('\\n')\n    }\n}\n\n\n// -- Convenience interface ---------------------------------------------\n\nfunction wrap(text, options = {}) {\n    /*\n     *  Wrap a single paragraph of text, returning a list of wrapped lines.\n     *\n     *  Reformat the single paragraph in 'text' so it fits in lines of no\n     *  more than 'width' columns, and return a list of wrapped lines.  By\n     *  default, tabs in 'text' are expanded with string.expandtabs(), and\n     *  all other whitespace characters (including newline) are converted to\n     *  space.  See TextWrapper class for available keyword args to customize\n     *  wrapping behaviour.\n     */\n    let { width = 70, ...kwargs } = options\n    let w = new TextWrapper(Object.assign({ width }, kwargs))\n    return w.wrap(text)\n}\n\nfunction fill(text, options = {}) {\n    /*\n     *  Fill a single paragraph of text, returning a new string.\n     *\n     *  Reformat the single paragraph in 'text' to fit in lines of no more\n     *  than 'width' columns, and return a new string containing the entire\n     *  wrapped paragraph.  As with wrap(), tabs are expanded and other\n     *  whitespace characters converted to space.  See TextWrapper class for\n     *  available keyword args to customize wrapping behaviour.\n     */\n    let { width = 70, ...kwargs } = options\n    let w = new TextWrapper(Object.assign({ width }, kwargs))\n    return w.fill(text)\n}\n\n// -- Loosely related functionality -------------------------------------\n\nlet _whitespace_only_re = /^[ \\t]+$/mg\nlet _leading_whitespace_re = /(^[ \\t]*)(?:[^ \\t\\n])/mg\n\nfunction dedent(text) {\n    /*\n     *  Remove any common leading whitespace from every line in `text`.\n     *\n     *  This can be used to make triple-quoted strings line up with the left\n     *  edge of the display, while still presenting them in the source code\n     *  in indented form.\n     *\n     *  Note that tabs and spaces are both treated as whitespace, but they\n     *  are not equal: the lines \"  hello\" and \"\\\\thello\" are\n     *  considered to have no common leading whitespace.\n     *\n     *  Entirely blank lines are normalized to a newline character.\n     */\n    // Look for the longest leading string of spaces and tabs common to\n    // all lines.\n    let margin = undefined\n    text = text.replace(_whitespace_only_re, '')\n    let indents = text.match(_leading_whitespace_re) || []\n    for (let indent of indents) {\n        indent = indent.slice(0, -1)\n\n        if (margin === undefined) {\n            margin = indent\n\n        // Current line more deeply indented than previous winner:\n        // no change (previous winner is still on top).\n        } else if (indent.startsWith(margin)) {\n            // pass\n\n        // Current line consistent with and no deeper than previous winner:\n        // it's the new winner.\n        } else if (margin.startsWith(indent)) {\n            margin = indent\n\n        // Find the largest common whitespace between current line and previous\n        // winner.\n        } else {\n            for (let i = 0; i < margin.length && i < indent.length; i++) {\n                if (margin[i] !== indent[i]) {\n                    margin = margin.slice(0, i)\n                    break\n                }\n            }\n        }\n    }\n\n    if (margin) {\n        text = text.replace(new RegExp('^' + margin, 'mg'), '')\n    }\n    return text\n}\n\nmodule.exports = { wrap, fill, dedent }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}