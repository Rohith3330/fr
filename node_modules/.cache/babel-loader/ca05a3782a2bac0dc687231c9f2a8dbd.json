{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultOrder = void 0;\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nconst neverConfig = {\n  type: 'string',\n  enum: ['never']\n};\n\nconst arrayConfig = memberTypes => ({\n  type: 'array',\n  items: {\n    oneOf: [{\n      enum: memberTypes\n    }, {\n      type: 'array',\n      items: {\n        enum: memberTypes\n      }\n    }]\n  }\n});\n\nconst objectConfig = memberTypes => ({\n  type: 'object',\n  properties: {\n    memberTypes: {\n      oneOf: [arrayConfig(memberTypes), neverConfig]\n    },\n    order: {\n      type: 'string',\n      enum: ['alphabetically', 'alphabetically-case-insensitive', 'as-written']\n    }\n  },\n  additionalProperties: false\n});\n\nexports.defaultOrder = [// Index signature\n'signature', 'call-signature', // Fields\n'public-static-field', 'protected-static-field', 'private-static-field', 'public-decorated-field', 'protected-decorated-field', 'private-decorated-field', 'public-instance-field', 'protected-instance-field', 'private-instance-field', 'public-abstract-field', 'protected-abstract-field', 'private-abstract-field', 'public-field', 'protected-field', 'private-field', 'static-field', 'instance-field', 'abstract-field', 'decorated-field', 'field', // Static initialization\n'static-initialization', // Constructors\n'public-constructor', 'protected-constructor', 'private-constructor', 'constructor', // Getters\n'public-static-get', 'protected-static-get', 'private-static-get', 'public-decorated-get', 'protected-decorated-get', 'private-decorated-get', 'public-instance-get', 'protected-instance-get', 'private-instance-get', 'public-abstract-get', 'protected-abstract-get', 'private-abstract-get', 'public-get', 'protected-get', 'private-get', 'static-get', 'instance-get', 'abstract-get', 'decorated-get', 'get', // Setters\n'public-static-set', 'protected-static-set', 'private-static-set', 'public-decorated-set', 'protected-decorated-set', 'private-decorated-set', 'public-instance-set', 'protected-instance-set', 'private-instance-set', 'public-abstract-set', 'protected-abstract-set', 'private-abstract-set', 'public-set', 'protected-set', 'private-set', 'static-set', 'instance-set', 'abstract-set', 'decorated-set', 'set', // Methods\n'public-static-method', 'protected-static-method', 'private-static-method', 'public-decorated-method', 'protected-decorated-method', 'private-decorated-method', 'public-instance-method', 'protected-instance-method', 'private-instance-method', 'public-abstract-method', 'protected-abstract-method', 'private-abstract-method', 'public-method', 'protected-method', 'private-method', 'static-method', 'instance-method', 'abstract-method', 'decorated-method', 'method'];\nconst allMemberTypes = Array.from(['signature', 'field', 'method', 'call-signature', 'constructor', 'get', 'set', 'static-initialization'].reduce((all, type) => {\n  all.add(type);\n  ['public', 'protected', 'private'].forEach(accessibility => {\n    if (type !== 'signature' && type !== 'static-initialization') {\n      all.add(`${accessibility}-${type}`); // e.g. `public-field`\n    } // Only class instance fields, methods, get and set can have decorators attached to them\n\n\n    if (type === 'field' || type === 'method' || type === 'get' || type === 'set') {\n      all.add(`${accessibility}-decorated-${type}`);\n      all.add(`decorated-${type}`);\n    }\n\n    if (type !== 'constructor' && type !== 'signature') {\n      // There is no `static-constructor` or `instance-constructor` or `abstract-constructor`\n      ['static', 'instance', 'abstract'].forEach(scope => {\n        all.add(`${scope}-${type}`);\n        all.add(`${accessibility}-${scope}-${type}`);\n      });\n    }\n  });\n  return all;\n}, new Set()));\nconst functionExpressions = [utils_1.AST_NODE_TYPES.FunctionExpression, utils_1.AST_NODE_TYPES.ArrowFunctionExpression];\n/**\n * Gets the node type.\n *\n * @param node the node to be evaluated.\n */\n\nfunction getNodeType(node) {\n  switch (node.type) {\n    case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:\n    case utils_1.AST_NODE_TYPES.MethodDefinition:\n      return node.kind;\n\n    case utils_1.AST_NODE_TYPES.TSMethodSignature:\n      return 'method';\n\n    case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:\n      return 'call-signature';\n\n    case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:\n      return 'constructor';\n\n    case utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:\n      return 'field';\n\n    case utils_1.AST_NODE_TYPES.PropertyDefinition:\n      return node.value && functionExpressions.includes(node.value.type) ? 'method' : 'field';\n\n    case utils_1.AST_NODE_TYPES.TSPropertySignature:\n      return 'field';\n\n    case utils_1.AST_NODE_TYPES.TSIndexSignature:\n      return 'signature';\n\n    case utils_1.AST_NODE_TYPES.StaticBlock:\n      return 'static-initialization';\n\n    default:\n      return null;\n  }\n}\n/**\n * Gets the raw string value of a member's name\n */\n\n\nfunction getMemberRawName(member, sourceCode) {\n  const {\n    name,\n    type\n  } = util.getNameFromMember(member, sourceCode);\n\n  if (type === util.MemberNameType.Quoted) {\n    return name.slice(1, -1);\n  }\n\n  if (type === util.MemberNameType.Private) {\n    return name.slice(1);\n  }\n\n  return name;\n}\n/**\n * Gets the member name based on the member type.\n *\n * @param node the node to be evaluated.\n * @param sourceCode\n */\n\n\nfunction getMemberName(node, sourceCode) {\n  switch (node.type) {\n    case utils_1.AST_NODE_TYPES.TSPropertySignature:\n    case utils_1.AST_NODE_TYPES.TSMethodSignature:\n    case utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition:\n    case utils_1.AST_NODE_TYPES.PropertyDefinition:\n      return getMemberRawName(node, sourceCode);\n\n    case utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition:\n    case utils_1.AST_NODE_TYPES.MethodDefinition:\n      return node.kind === 'constructor' ? 'constructor' : getMemberRawName(node, sourceCode);\n\n    case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:\n      return 'new';\n\n    case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:\n      return 'call';\n\n    case utils_1.AST_NODE_TYPES.TSIndexSignature:\n      return util.getNameFromIndexSignature(node);\n\n    case utils_1.AST_NODE_TYPES.StaticBlock:\n      return 'static block';\n\n    default:\n      return null;\n  }\n}\n/**\n * Gets the calculated rank using the provided method definition.\n * The algorithm is as follows:\n * - Get the rank based on the accessibility-scope-type name, e.g. public-instance-field\n * - If there is no order for accessibility-scope-type, then strip out the accessibility.\n * - If there is no order for scope-type, then strip out the scope.\n * - If there is no order for type, then return -1\n * @param memberGroups the valid names to be validated.\n * @param orderConfig the current order to be validated.\n *\n * @return Index of the matching member type in the order configuration.\n */\n\n\nfunction getRankOrder(memberGroups, orderConfig) {\n  let rank = -1;\n  const stack = memberGroups.slice(); // Get a copy of the member groups\n\n  while (stack.length > 0 && rank === -1) {\n    const memberGroup = stack.shift();\n    rank = orderConfig.findIndex(memberType => Array.isArray(memberType) ? memberType.includes(memberGroup) : memberType === memberGroup);\n  }\n\n  return rank;\n}\n/**\n * Gets the rank of the node given the order.\n * @param node the node to be evaluated.\n * @param orderConfig the current order to be validated.\n * @param supportsModifiers a flag indicating whether the type supports modifiers (scope or accessibility) or not.\n */\n\n\nfunction getRank(node, orderConfig, supportsModifiers) {\n  const type = getNodeType(node);\n\n  if (type === null) {\n    // shouldn't happen but just in case, put it on the end\n    return orderConfig.length - 1;\n  }\n\n  const abstract = node.type === utils_1.AST_NODE_TYPES.TSAbstractPropertyDefinition || node.type === utils_1.AST_NODE_TYPES.TSAbstractMethodDefinition;\n  const scope = 'static' in node && node.static ? 'static' : abstract ? 'abstract' : 'instance';\n  const accessibility = 'accessibility' in node && node.accessibility ? node.accessibility : 'public'; // Collect all existing member groups that apply to this node...\n  // (e.g. 'public-instance-field', 'instance-field', 'public-field', 'constructor' etc.)\n\n  const memberGroups = [];\n\n  if (supportsModifiers) {\n    const decorated = 'decorators' in node && node.decorators.length > 0;\n\n    if (decorated && (type === 'field' || type === 'method' || type === 'get' || type === 'set')) {\n      memberGroups.push(`${accessibility}-decorated-${type}`);\n      memberGroups.push(`decorated-${type}`);\n    }\n\n    if (type !== 'signature' && type !== 'static-initialization') {\n      if (type !== 'constructor') {\n        // Constructors have no scope\n        memberGroups.push(`${accessibility}-${scope}-${type}`);\n        memberGroups.push(`${scope}-${type}`);\n      }\n\n      memberGroups.push(`${accessibility}-${type}`);\n    }\n  }\n\n  memberGroups.push(type); // ...then get the rank order for those member groups based on the node\n\n  return getRankOrder(memberGroups, orderConfig);\n}\n/**\n * Gets the lowest possible rank(s) higher than target.\n * e.g. given the following order:\n *   ...\n *   public-static-method\n *   protected-static-method\n *   private-static-method\n *   public-instance-method\n *   protected-instance-method\n *   private-instance-method\n *   ...\n * and considering that a public-instance-method has already been declared, so ranks contains\n * public-instance-method, then the lowest possible rank for public-static-method is\n * public-instance-method.\n * If a lowest possible rank is a member group, a comma separated list of ranks is returned.\n * @param ranks the existing ranks in the object.\n * @param target the target rank.\n * @param order the current order to be validated.\n * @returns the name(s) of the lowest possible rank without dashes (-).\n */\n\n\nfunction getLowestRank(ranks, target, order) {\n  let lowest = ranks[ranks.length - 1];\n  ranks.forEach(rank => {\n    if (rank > target) {\n      lowest = Math.min(lowest, rank);\n    }\n  });\n  const lowestRank = order[lowest];\n  const lowestRanks = Array.isArray(lowestRank) ? lowestRank : [lowestRank];\n  return lowestRanks.map(rank => rank.replace(/-/g, ' ')).join(', ');\n}\n\nexports.default = util.createRule({\n  name: 'member-ordering',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Require a consistent member declaration order',\n      recommended: false\n    },\n    messages: {\n      incorrectOrder: 'Member {{member}} should be declared before member {{beforeMember}}.',\n      incorrectGroupOrder: 'Member {{name}} should be declared before all {{rank}} definitions.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        default: {\n          oneOf: [neverConfig, arrayConfig(allMemberTypes), objectConfig(allMemberTypes)]\n        },\n        classes: {\n          oneOf: [neverConfig, arrayConfig(allMemberTypes), objectConfig(allMemberTypes)]\n        },\n        classExpressions: {\n          oneOf: [neverConfig, arrayConfig(allMemberTypes), objectConfig(allMemberTypes)]\n        },\n        interfaces: {\n          oneOf: [neverConfig, arrayConfig(['signature', 'field', 'method', 'constructor']), objectConfig(['signature', 'field', 'method', 'constructor'])]\n        },\n        typeLiterals: {\n          oneOf: [neverConfig, arrayConfig(['signature', 'field', 'method', 'constructor']), objectConfig(['signature', 'field', 'method', 'constructor'])]\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    default: exports.defaultOrder\n  }],\n\n  create(context, _ref) {\n    let [options] = _ref;\n\n    /**\n     * Checks if the member groups are correctly sorted.\n     *\n     * @param members Members to be validated.\n     * @param groupOrder Group order to be validated.\n     * @param supportsModifiers A flag indicating whether the type supports modifiers (scope or accessibility) or not.\n     *\n     * @return Array of member groups or null if one of the groups is not correctly sorted.\n     */\n    function checkGroupSort(members, groupOrder, supportsModifiers) {\n      const previousRanks = [];\n      const memberGroups = [];\n      let isCorrectlySorted = true; // Find first member which isn't correctly sorted\n\n      members.forEach(member => {\n        const rank = getRank(member, groupOrder, supportsModifiers);\n        const name = getMemberName(member, context.getSourceCode());\n        const rankLastMember = previousRanks[previousRanks.length - 1];\n\n        if (rank === -1) {\n          return;\n        } // Works for 1st item because x < undefined === false for any x (typeof string)\n\n\n        if (rank < rankLastMember) {\n          context.report({\n            node: member,\n            messageId: 'incorrectGroupOrder',\n            data: {\n              name,\n              rank: getLowestRank(previousRanks, rank, groupOrder)\n            }\n          });\n          isCorrectlySorted = false;\n        } else if (rank === rankLastMember) {\n          // Same member group --> Push to existing member group array\n          memberGroups[memberGroups.length - 1].push(member);\n        } else {\n          // New member group --> Create new member group array\n          previousRanks.push(rank);\n          memberGroups.push([member]);\n        }\n      });\n      return isCorrectlySorted ? memberGroups : null;\n    }\n    /**\n     * Checks if the members are alphabetically sorted.\n     *\n     * @param members Members to be validated.\n     * @param caseSensitive indicates if the alpha ordering is case sensitive or not.\n     *\n     * @return True if all members are correctly sorted.\n     */\n\n\n    function checkAlphaSort(members, caseSensitive) {\n      let previousName = '';\n      let isCorrectlySorted = true; // Find first member which isn't correctly sorted\n\n      members.forEach(member => {\n        const name = getMemberName(member, context.getSourceCode()); // Note: Not all members have names\n\n        if (name) {\n          if (caseSensitive ? name < previousName : name.toLowerCase() < previousName.toLowerCase()) {\n            context.report({\n              node: member,\n              messageId: 'incorrectOrder',\n              data: {\n                member: name,\n                beforeMember: previousName\n              }\n            });\n            isCorrectlySorted = false;\n          }\n\n          previousName = name;\n        }\n      });\n      return isCorrectlySorted;\n    }\n    /**\n     * Validates if all members are correctly sorted.\n     *\n     * @param members Members to be validated.\n     * @param orderConfig Order config to be validated.\n     * @param supportsModifiers A flag indicating whether the type supports modifiers (scope or accessibility) or not.\n     */\n\n\n    function validateMembersOrder(members, orderConfig, supportsModifiers) {\n      if (orderConfig === 'never') {\n        return;\n      } // Standardize config\n\n\n      let order = null;\n      let memberTypes;\n\n      if (Array.isArray(orderConfig)) {\n        memberTypes = orderConfig;\n      } else {\n        order = orderConfig.order;\n        memberTypes = orderConfig.memberTypes;\n      }\n\n      const hasAlphaSort = order === null || order === void 0 ? void 0 : order.startsWith('alphabetically');\n      const alphaSortIsCaseSensitive = order !== 'alphabetically-case-insensitive'; // Check order\n\n      if (Array.isArray(memberTypes)) {\n        const grouped = checkGroupSort(members, memberTypes, supportsModifiers);\n\n        if (grouped === null) {\n          return;\n        }\n\n        if (hasAlphaSort) {\n          grouped.some(groupMember => !checkAlphaSort(groupMember, alphaSortIsCaseSensitive));\n        }\n      } else if (hasAlphaSort) {\n        checkAlphaSort(members, alphaSortIsCaseSensitive);\n      }\n    }\n\n    return {\n      ClassDeclaration(node) {\n        var _a;\n\n        validateMembersOrder(node.body.body, (_a = options.classes) !== null && _a !== void 0 ? _a : options.default, true);\n      },\n\n      ClassExpression(node) {\n        var _a;\n\n        validateMembersOrder(node.body.body, (_a = options.classExpressions) !== null && _a !== void 0 ? _a : options.default, true);\n      },\n\n      TSInterfaceDeclaration(node) {\n        var _a;\n\n        validateMembersOrder(node.body.body, (_a = options.interfaces) !== null && _a !== void 0 ? _a : options.default, false);\n      },\n\n      TSTypeLiteral(node) {\n        var _a;\n\n        validateMembersOrder(node.members, (_a = options.typeLiterals) !== null && _a !== void 0 ? _a : options.default, false);\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["neverConfig","type","enum","arrayConfig","memberTypes","items","oneOf","objectConfig","properties","order","additionalProperties","exports","allMemberTypes","Array","from","reduce","all","add","forEach","accessibility","scope","Set","functionExpressions","utils_1","FunctionExpression","ArrowFunctionExpression","getNodeType","node","TSAbstractMethodDefinition","MethodDefinition","kind","TSMethodSignature","TSCallSignatureDeclaration","TSConstructSignatureDeclaration","TSAbstractPropertyDefinition","PropertyDefinition","value","includes","TSPropertySignature","TSIndexSignature","StaticBlock","getMemberRawName","member","sourceCode","name","util","getNameFromMember","MemberNameType","Quoted","slice","Private","getMemberName","getNameFromIndexSignature","getRankOrder","memberGroups","orderConfig","rank","stack","length","memberGroup","shift","findIndex","memberType","isArray","getRank","supportsModifiers","abstract","static","decorated","decorators","push","getLowestRank","ranks","target","lowest","Math","min","lowestRank","lowestRanks","map","replace","join","createRule","meta","docs","description","recommended","messages","incorrectOrder","incorrectGroupOrder","schema","default","classes","classExpressions","interfaces","typeLiterals","defaultOptions","create","context","options","checkGroupSort","members","groupOrder","previousRanks","isCorrectlySorted","getSourceCode","rankLastMember","report","messageId","data","checkAlphaSort","caseSensitive","previousName","toLowerCase","beforeMember","validateMembersOrder","hasAlphaSort","startsWith","alphaSortIsCaseSensitive","grouped","some","groupMember","ClassDeclaration","body","_a","ClassExpression","TSInterfaceDeclaration","TSTypeLiteral"],"sources":["../../src/rules/member-ordering.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}