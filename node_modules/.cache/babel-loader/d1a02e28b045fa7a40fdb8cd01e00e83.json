{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createRegExpFeaturePlugin = createRegExpFeaturePlugin;\n\nvar _regexpuCore = require(\"regexpu-core\");\n\nvar _features = require(\"./features\");\n\nvar _util = require(\"./util\");\n\nvar _core = require(\"@babel/core\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nconst version = \"7.19.0\".split(\".\").reduce((v, x) => v * 1e5 + +x, 0);\nconst versionKey = \"@babel/plugin-regexp-features/version\";\n\nfunction createRegExpFeaturePlugin(_ref) {\n  let {\n    name,\n    feature,\n    options = {},\n    manipulateOptions = () => {}\n  } = _ref;\n  return {\n    name,\n    manipulateOptions,\n\n    pre() {\n      var _file$get;\n\n      const {\n        file\n      } = this;\n      const features = (_file$get = file.get(_features.featuresKey)) != null ? _file$get : 0;\n      let newFeatures = (0, _features.enableFeature)(features, _features.FEATURES[feature]);\n      const {\n        useUnicodeFlag,\n        runtime\n      } = options;\n\n      if (useUnicodeFlag === false) {\n        newFeatures = (0, _features.enableFeature)(newFeatures, _features.FEATURES.unicodeFlag);\n      }\n\n      if (newFeatures !== features) {\n        file.set(_features.featuresKey, newFeatures);\n      }\n\n      if (runtime !== undefined) {\n        if (file.has(_features.runtimeKey) && file.get(_features.runtimeKey) !== runtime && (0, _features.hasFeature)(newFeatures, _features.FEATURES.duplicateNamedCaptureGroups)) {\n          throw new Error(`The 'runtime' option must be the same for ` + `'@babel/plugin-transform-named-capturing-groups-regex' and ` + `'@babel/plugin-proposal-duplicate-named-capturing-groups-regex'.`);\n        }\n\n        if (feature === \"namedCaptureGroups\") {\n          if (!runtime || !file.has(_features.runtimeKey)) file.set(_features.runtimeKey, runtime);\n        } else {\n          file.set(_features.runtimeKey, runtime);\n        }\n      }\n\n      if (!file.has(versionKey) || file.get(versionKey) < version) {\n        file.set(versionKey, version);\n      }\n    },\n\n    visitor: {\n      RegExpLiteral(path) {\n        var _file$get2;\n\n        const {\n          node\n        } = path;\n        const {\n          file\n        } = this;\n        const features = file.get(_features.featuresKey);\n        const runtime = (_file$get2 = file.get(_features.runtimeKey)) != null ? _file$get2 : true;\n        const regexpuOptions = (0, _util.generateRegexpuOptions)(node.pattern, features);\n\n        if ((0, _util.canSkipRegexpu)(node, regexpuOptions)) {\n          return;\n        }\n\n        const namedCaptureGroups = {\n          __proto__: null\n        };\n\n        if (regexpuOptions.namedGroups === \"transform\") {\n          regexpuOptions.onNamedGroup = (name, index) => {\n            const prev = namedCaptureGroups[name];\n\n            if (typeof prev === \"number\") {\n              namedCaptureGroups[name] = [prev, index];\n            } else if (Array.isArray(prev)) {\n              prev.push(index);\n            } else {\n              namedCaptureGroups[name] = index;\n            }\n          };\n        }\n\n        node.pattern = _regexpuCore(node.pattern, node.flags, regexpuOptions);\n\n        if (regexpuOptions.namedGroups === \"transform\" && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {\n          const call = _core.types.callExpression(this.addHelper(\"wrapRegExp\"), [node, _core.types.valueToNode(namedCaptureGroups)]);\n\n          (0, _helperAnnotateAsPure.default)(call);\n          path.replaceWith(call);\n        }\n\n        node.flags = (0, _util.transformFlags)(regexpuOptions, node.flags);\n      }\n\n    }\n  };\n}\n\nfunction isRegExpTest(path) {\n  return path.parentPath.isMemberExpression({\n    object: path.node,\n    computed: false\n  }) && path.parentPath.get(\"property\").isIdentifier({\n    name: \"test\"\n  });\n}","map":{"version":3,"mappings":"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","names":["version","split","reduce","v","x","versionKey","createRegExpFeaturePlugin","name","feature","options","manipulateOptions","pre","file","features","get","featuresKey","newFeatures","FEATURES","useUnicodeFlag","runtime","unicodeFlag","set","undefined","has","runtimeKey","duplicateNamedCaptureGroups","Error","visitor","RegExpLiteral","path","node","regexpuOptions","pattern","namedCaptureGroups","__proto__","namedGroups","onNamedGroup","index","prev","Array","isArray","push","rewritePattern","flags","Object","keys","length","isRegExpTest","call","t","callExpression","addHelper","valueToNode","replaceWith","parentPath","isMemberExpression","object","computed","isIdentifier"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-create-regexp-features-plugin\\src\\index.ts"],"sourcesContent":["import rewritePattern from \"regexpu-core\";\nimport {\n  featuresKey,\n  FEATURES,\n  enableFeature,\n  runtimeKey,\n  hasFeature,\n} from \"./features\";\nimport { generateRegexpuOptions, canSkipRegexpu, transformFlags } from \"./util\";\nimport type { NodePath } from \"@babel/traverse\";\n\nimport { types as t } from \"@babel/core\";\nimport type { PluginObject } from \"@babel/core\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\n\ndeclare const PACKAGE_JSON: { name: string; version: string };\n\n// Note: Versions are represented as an integer. e.g. 7.1.5 is represented\n//       as 70000100005. This method is easier than using a semver-parsing\n//       package, but it breaks if we release x.y.z where x, y or z are\n//       greater than 99_999.\nconst version = PACKAGE_JSON.version\n  .split(\".\")\n  .reduce((v, x) => v * 1e5 + +x, 0);\nconst versionKey = \"@babel/plugin-regexp-features/version\";\n\nexport interface Options {\n  name: string;\n  feature: keyof typeof FEATURES;\n  options?: {\n    useUnicodeFlag?: boolean;\n    runtime?: boolean;\n  };\n  manipulateOptions?: PluginObject[\"manipulateOptions\"];\n}\n\nexport function createRegExpFeaturePlugin({\n  name,\n  feature,\n  options = {},\n  manipulateOptions = () => {},\n}: Options): PluginObject {\n  return {\n    name,\n\n    manipulateOptions,\n\n    pre() {\n      const { file } = this;\n      const features = file.get(featuresKey) ?? 0;\n      let newFeatures = enableFeature(features, FEATURES[feature]);\n\n      const { useUnicodeFlag, runtime } = options;\n      if (useUnicodeFlag === false) {\n        newFeatures = enableFeature(newFeatures, FEATURES.unicodeFlag);\n      }\n      if (newFeatures !== features) {\n        file.set(featuresKey, newFeatures);\n      }\n\n      if (runtime !== undefined) {\n        if (\n          file.has(runtimeKey) &&\n          file.get(runtimeKey) !== runtime &&\n          // TODO(Babel 8): Remove this check. It's necessary because in Babel 7\n          // we allow multiple copies of transform-named-capturing-groups-regex\n          // with conflicting 'runtime' options.\n          hasFeature(newFeatures, FEATURES.duplicateNamedCaptureGroups)\n        ) {\n          throw new Error(\n            `The 'runtime' option must be the same for ` +\n              `'@babel/plugin-transform-named-capturing-groups-regex' and ` +\n              `'@babel/plugin-proposal-duplicate-named-capturing-groups-regex'.`,\n          );\n        }\n        // TODO(Babel 8): Remove this check and always set it.\n        // It's necessary because in Babel 7 we allow multiple copies of\n        // transform-named-capturing-groups-regex with conflicting 'runtime' options.\n        if (feature === \"namedCaptureGroups\") {\n          if (!runtime || !file.has(runtimeKey)) file.set(runtimeKey, runtime);\n        } else {\n          file.set(runtimeKey, runtime);\n        }\n      }\n\n      if (!file.has(versionKey) || file.get(versionKey) < version) {\n        file.set(versionKey, version);\n      }\n    },\n\n    visitor: {\n      RegExpLiteral(path) {\n        const { node } = path;\n        const { file } = this;\n        const features = file.get(featuresKey);\n        const runtime = file.get(runtimeKey) ?? true;\n\n        const regexpuOptions = generateRegexpuOptions(node.pattern, features);\n        if (canSkipRegexpu(node, regexpuOptions)) {\n          return;\n        }\n\n        const namedCaptureGroups: Record<string, number | number[]> = {\n          __proto__: null,\n        };\n        if (regexpuOptions.namedGroups === \"transform\") {\n          regexpuOptions.onNamedGroup = (name, index) => {\n            const prev = namedCaptureGroups[name];\n            if (typeof prev === \"number\") {\n              namedCaptureGroups[name] = [prev, index];\n            } else if (Array.isArray(prev)) {\n              prev.push(index);\n            } else {\n              namedCaptureGroups[name] = index;\n            }\n          };\n        }\n\n        node.pattern = rewritePattern(node.pattern, node.flags, regexpuOptions);\n\n        if (\n          regexpuOptions.namedGroups === \"transform\" &&\n          Object.keys(namedCaptureGroups).length > 0 &&\n          runtime &&\n          !isRegExpTest(path)\n        ) {\n          const call = t.callExpression(this.addHelper(\"wrapRegExp\"), [\n            node,\n            t.valueToNode(namedCaptureGroups),\n          ]);\n          annotateAsPure(call);\n\n          path.replaceWith(call);\n        }\n\n        node.flags = transformFlags(regexpuOptions, node.flags);\n      },\n    },\n  };\n}\n\nfunction isRegExpTest(path: NodePath<t.RegExpLiteral>) {\n  return (\n    path.parentPath.isMemberExpression({\n      object: path.node,\n      computed: false,\n    }) && path.parentPath.get(\"property\").isIdentifier({ name: \"test\" })\n  );\n}\n"]},"metadata":{},"sourceType":"script"}