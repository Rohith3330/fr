{"ast":null,"code":"/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\"use strict\";\n\nconst {\n  readFileSync\n} = require(\"fs\");\n\nconst {\n  join\n} = require(\"path\");\n\nconst ejs = require(\"ejs\");\n\nconst MagicString = require(\"magic-string\");\n\nconst json5 = require(\"json5\"); // See https://github.com/surma/rollup-plugin-off-main-thread/issues/49\n\n\nconst matchAll = require(\"string.prototype.matchall\");\n\nconst defaultOpts = {\n  // A string containing the EJS template for the amd loader. If `undefined`,\n  // OMT will use `loader.ejs`.\n  loader: readFileSync(join(__dirname, \"/loader.ejs\"), \"utf8\"),\n  // Use `fetch()` + `eval()` to load dependencies instead of `<script>` tags\n  // and `importScripts()`. _This is not CSP compliant, but is required if you\n  // want to use dynamic imports in ServiceWorker_.\n  useEval: false,\n  // Function name to use instead of AMD’s `define`.\n  amdFunctionName: \"define\",\n  // A function that determines whether the loader code should be prepended to a\n  // certain chunk. Should return true if the load is supposed to be prepended.\n  prependLoader: (chunk, workerFiles) => chunk.isEntry || workerFiles.includes(chunk.facadeModuleId),\n  // The scheme used when importing workers as a URL.\n  urlLoaderScheme: \"omt\",\n  // Silence the warning about ESM being badly supported in workers.\n  silenceESMWorkerWarning: false\n}; // A regexp to find static `new Worker` invocations.\n// Matches `new Worker(...file part...`\n// File part matches one of:\n// - '...'\n// - \"...\"\n// - `import.meta.url`\n// - new URL('...', import.meta.url)\n// - new URL(\"...\", import.meta.url)\n\nconst workerRegexpForTransform = /(new\\s+Worker\\()\\s*(('.*?'|\".*?\")|import\\.meta\\.url|new\\s+URL\\(('.*?'|\".*?\"),\\s*import\\.meta\\.url\\))/gs; // A regexp to find static `new Worker` invocations we've rewritten during the transform phase.\n// Matches `new Worker(...file part..., ...options...`.\n// File part matches one of:\n// - new URL('...', module.uri)\n// - new URL(\"...\", module.uri)\n\nconst workerRegexpForOutput = /new\\s+Worker\\(new\\s+URL\\((?:'.*?'|\".*?\"),\\s*module\\.uri\\)\\s*(,([^)]+))/gs;\nlet longWarningAlreadyShown = false;\n\nmodule.exports = function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  opts = Object.assign({}, defaultOpts, opts);\n  opts.loader = ejs.render(opts.loader, opts);\n  const urlLoaderPrefix = opts.urlLoaderScheme + \":\";\n  let workerFiles;\n\n  let isEsmOutput = () => {\n    throw new Error(\"outputOptions hasn't been called yet\");\n  };\n\n  return {\n    name: \"off-main-thread\",\n\n    async buildStart(options) {\n      workerFiles = [];\n    },\n\n    async resolveId(id, importer) {\n      if (!id.startsWith(urlLoaderPrefix)) return;\n      const path = id.slice(urlLoaderPrefix.length);\n      const resolved = await this.resolve(path, importer);\n      if (!resolved) throw Error(`Cannot find module '${path}' from '${importer}'`);\n      const newId = resolved.id;\n      return urlLoaderPrefix + newId;\n    },\n\n    load(id) {\n      if (!id.startsWith(urlLoaderPrefix)) return;\n      const realId = id.slice(urlLoaderPrefix.length);\n      const chunkRef = this.emitFile({\n        id: realId,\n        type: \"chunk\"\n      });\n      return `export default import.meta.ROLLUP_FILE_URL_${chunkRef};`;\n    },\n\n    async transform(code, id) {\n      const ms = new MagicString(code);\n      const replacementPromises = [];\n\n      for (const match of matchAll(code, workerRegexpForTransform)) {\n        let [fullMatch, partBeforeArgs, workerSource, directWorkerFile, workerFile] = match;\n        const workerParametersEndIndex = match.index + fullMatch.length;\n        const matchIndex = match.index;\n        const workerParametersStartIndex = matchIndex + partBeforeArgs.length;\n        let workerIdPromise;\n\n        if (workerSource === \"import.meta.url\") {\n          // Turn the current file into a chunk\n          workerIdPromise = Promise.resolve(id);\n        } else {\n          // Otherwise it's a string literal either directly or in the `new URL(...)`.\n          if (directWorkerFile) {\n            const fullMatchWithOpts = `${fullMatch}, …)`;\n            const fullReplacement = `new Worker(new URL(${directWorkerFile}, import.meta.url), …)`;\n\n            if (!longWarningAlreadyShown) {\n              this.warn(`rollup-plugin-off-main-thread:\n\\`${fullMatchWithOpts}\\` suggests that the Worker should be relative to the document, not the script.\nIn the bundler, we don't know what the final document's URL will be, and instead assume it's a URL relative to the current module.\nThis might lead to incorrect behaviour during runtime.\nIf you did mean to use a URL relative to the current module, please change your code to the following form:\n\\`${fullReplacement}\\`\nThis will become a hard error in the future.`, matchIndex);\n              longWarningAlreadyShown = true;\n            } else {\n              this.warn(`rollup-plugin-off-main-thread: Treating \\`${fullMatchWithOpts}\\` as \\`${fullReplacement}\\``, matchIndex);\n            }\n\n            workerFile = directWorkerFile;\n          } // Cut off surrounding quotes.\n\n\n          workerFile = workerFile.slice(1, -1);\n\n          if (!/^\\.{1,2}\\//.test(workerFile)) {\n            let isError = false;\n\n            if (directWorkerFile) {\n              // If direct worker file, it must be in `./something` form.\n              isError = true;\n            } else {\n              // If `new URL(...)` it can be in `new URL('something', import.meta.url)` form too,\n              // so just check it's not absolute.\n              if (/^(\\/|https?:)/.test(workerFile)) {\n                isError = true;\n              } else {\n                // If it does turn out to be `new URL('something', import.meta.url)` form,\n                // prepend `./` so that it becomes valid module specifier.\n                workerFile = `./${workerFile}`;\n              }\n            }\n\n            if (isError) {\n              this.warn(`Paths passed to the Worker constructor must be relative to the current file, i.e. start with ./ or ../ (just like dynamic import!). Ignoring \"${workerFile}\".`, matchIndex);\n              continue;\n            }\n          }\n\n          workerIdPromise = this.resolve(workerFile, id).then(res => res.id);\n        }\n\n        replacementPromises.push((async () => {\n          const resolvedWorkerFile = await workerIdPromise;\n          workerFiles.push(resolvedWorkerFile);\n          const chunkRefId = this.emitFile({\n            id: resolvedWorkerFile,\n            type: \"chunk\"\n          });\n          ms.overwrite(workerParametersStartIndex, workerParametersEndIndex, `new URL(import.meta.ROLLUP_FILE_URL_${chunkRefId}, import.meta.url)`);\n        })());\n      } // No matches found.\n\n\n      if (!replacementPromises.length) {\n        return;\n      } // Wait for all the scheduled replacements to finish.\n\n\n      await Promise.all(replacementPromises);\n      return {\n        code: ms.toString(),\n        map: ms.generateMap({\n          hires: true\n        })\n      };\n    },\n\n    resolveFileUrl(chunk) {\n      return JSON.stringify(chunk.relativePath);\n    },\n\n    outputOptions(_ref) {\n      let {\n        format\n      } = _ref;\n\n      if (format === \"esm\" || format === \"es\") {\n        if (!opts.silenceESMWorkerWarning) {\n          this.warn('Very few browsers support ES modules in Workers. If you want to your code to run in all browsers, set `output.format = \"amd\";`');\n        } // In ESM, we never prepend a loader.\n\n\n        isEsmOutput = () => true;\n      } else if (format !== \"amd\") {\n        this.error(`\\`output.format\\` must either be \"amd\" or \"esm\", got \"${format}\"`);\n      } else {\n        isEsmOutput = () => false;\n      }\n    },\n\n    renderDynamicImport() {\n      if (isEsmOutput()) return; // In our loader, `require` simply return a promise directly.\n      // This is tinier and simpler output than the Rollup's default.\n\n      return {\n        left: 'require(',\n        right: ')'\n      };\n    },\n\n    resolveImportMeta(property) {\n      if (isEsmOutput()) return;\n\n      if (property === 'url') {\n        // In our loader, `module.uri` is already fully resolved\n        // so we can emit something shorter than the Rollup's default.\n        return `module.uri`;\n      }\n    },\n\n    renderChunk(code, chunk, outputOptions) {\n      // We don’t need to do any loader processing when targeting ESM format.\n      if (isEsmOutput()) return;\n\n      if (outputOptions.banner && outputOptions.banner.length > 0) {\n        this.error(\"OMT currently doesn’t work with `banner`. Feel free to submit a PR at https://github.com/surma/rollup-plugin-off-main-thread\");\n        return;\n      }\n\n      const ms = new MagicString(code);\n\n      for (const match of matchAll(code, workerRegexpForOutput)) {\n        let [fullMatch, optionsWithCommaStr, optionsStr] = match;\n        let options;\n\n        try {\n          options = json5.parse(optionsStr);\n        } catch (e) {\n          // If we couldn't parse the options object, maybe it's something dynamic or has nested\n          // parentheses or something like that. In that case, treat it as a warning\n          // and not a hard error, just like we wouldn't break on unmatched regex.\n          console.warn(\"Couldn't match options object\", fullMatch, \": \", e);\n          continue;\n        }\n\n        if (!(\"type\" in options)) {\n          // Nothing to do.\n          continue;\n        }\n\n        delete options.type;\n        const replacementEnd = match.index + fullMatch.length;\n        const replacementStart = replacementEnd - optionsWithCommaStr.length;\n        optionsStr = json5.stringify(options);\n        optionsWithCommaStr = optionsStr === \"{}\" ? \"\" : `, ${optionsStr}`;\n        ms.overwrite(replacementStart, replacementEnd, optionsWithCommaStr);\n      } // Mangle define() call\n\n\n      ms.remove(0, \"define(\".length); // If the module does not have any dependencies, it’s technically okay\n      // to skip the dependency array. But our minimal loader expects it, so\n      // we add it back in.\n\n      if (!code.startsWith(\"define([\")) {\n        ms.prepend(\"[],\");\n      }\n\n      ms.prepend(`${opts.amdFunctionName}(`); // Prepend loader if it’s an entry point or a worker file\n\n      if (opts.prependLoader(chunk, workerFiles)) {\n        ms.prepend(opts.loader);\n      }\n\n      const newCode = ms.toString();\n      const hasCodeChanged = code !== newCode;\n      return {\n        code: newCode,\n        // Avoid generating sourcemaps if possible as it can be a very expensive operation\n        map: hasCodeChanged ? ms.generateMap({\n          hires: true\n        }) : null\n      };\n    }\n\n  };\n};","map":{"version":3,"names":["readFileSync","require","join","ejs","MagicString","json5","matchAll","defaultOpts","loader","__dirname","useEval","amdFunctionName","prependLoader","chunk","workerFiles","isEntry","includes","facadeModuleId","urlLoaderScheme","silenceESMWorkerWarning","workerRegexpForTransform","workerRegexpForOutput","longWarningAlreadyShown","module","exports","opts","Object","assign","render","urlLoaderPrefix","isEsmOutput","Error","name","buildStart","options","resolveId","id","importer","startsWith","path","slice","length","resolved","resolve","newId","load","realId","chunkRef","emitFile","type","transform","code","ms","replacementPromises","match","fullMatch","partBeforeArgs","workerSource","directWorkerFile","workerFile","workerParametersEndIndex","index","matchIndex","workerParametersStartIndex","workerIdPromise","Promise","fullMatchWithOpts","fullReplacement","warn","test","isError","then","res","push","resolvedWorkerFile","chunkRefId","overwrite","all","toString","map","generateMap","hires","resolveFileUrl","JSON","stringify","relativePath","outputOptions","format","error","renderDynamicImport","left","right","resolveImportMeta","property","renderChunk","banner","optionsWithCommaStr","optionsStr","parse","e","console","replacementEnd","replacementStart","remove","prepend","newCode","hasCodeChanged"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@surma/rollup-plugin-off-main-thread/index.js"],"sourcesContent":["/**\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\"use strict\";\n\nconst { readFileSync } = require(\"fs\");\nconst { join } = require(\"path\");\nconst ejs = require(\"ejs\");\nconst MagicString = require(\"magic-string\");\nconst json5 = require(\"json5\");\n// See https://github.com/surma/rollup-plugin-off-main-thread/issues/49\nconst matchAll = require(\"string.prototype.matchall\");\n\nconst defaultOpts = {\n  // A string containing the EJS template for the amd loader. If `undefined`,\n  // OMT will use `loader.ejs`.\n  loader: readFileSync(join(__dirname, \"/loader.ejs\"), \"utf8\"),\n  // Use `fetch()` + `eval()` to load dependencies instead of `<script>` tags\n  // and `importScripts()`. _This is not CSP compliant, but is required if you\n  // want to use dynamic imports in ServiceWorker_.\n  useEval: false,\n  // Function name to use instead of AMD’s `define`.\n  amdFunctionName: \"define\",\n  // A function that determines whether the loader code should be prepended to a\n  // certain chunk. Should return true if the load is supposed to be prepended.\n  prependLoader: (chunk, workerFiles) =>\n    chunk.isEntry || workerFiles.includes(chunk.facadeModuleId),\n  // The scheme used when importing workers as a URL.\n  urlLoaderScheme: \"omt\",\n  // Silence the warning about ESM being badly supported in workers.\n  silenceESMWorkerWarning: false\n};\n\n// A regexp to find static `new Worker` invocations.\n// Matches `new Worker(...file part...`\n// File part matches one of:\n// - '...'\n// - \"...\"\n// - `import.meta.url`\n// - new URL('...', import.meta.url)\n// - new URL(\"...\", import.meta.url)\nconst workerRegexpForTransform = /(new\\s+Worker\\()\\s*(('.*?'|\".*?\")|import\\.meta\\.url|new\\s+URL\\(('.*?'|\".*?\"),\\s*import\\.meta\\.url\\))/gs;\n\n// A regexp to find static `new Worker` invocations we've rewritten during the transform phase.\n// Matches `new Worker(...file part..., ...options...`.\n// File part matches one of:\n// - new URL('...', module.uri)\n// - new URL(\"...\", module.uri)\nconst workerRegexpForOutput = /new\\s+Worker\\(new\\s+URL\\((?:'.*?'|\".*?\"),\\s*module\\.uri\\)\\s*(,([^)]+))/gs;\n\nlet longWarningAlreadyShown = false;\n\nmodule.exports = function(opts = {}) {\n  opts = Object.assign({}, defaultOpts, opts);\n\n  opts.loader = ejs.render(opts.loader, opts);\n\n  const urlLoaderPrefix = opts.urlLoaderScheme + \":\";\n\n  let workerFiles;\n  let isEsmOutput = () => { throw new Error(\"outputOptions hasn't been called yet\") };\n  return {\n    name: \"off-main-thread\",\n\n    async buildStart(options) {\n      workerFiles = [];\n    },\n\n    async resolveId(id, importer) {\n      if (!id.startsWith(urlLoaderPrefix)) return;\n\n      const path = id.slice(urlLoaderPrefix.length);\n      const resolved = await this.resolve(path, importer);\n      if (!resolved)\n        throw Error(`Cannot find module '${path}' from '${importer}'`);\n      const newId = resolved.id;\n\n      return urlLoaderPrefix + newId;\n    },\n\n    load(id) {\n      if (!id.startsWith(urlLoaderPrefix)) return;\n\n      const realId = id.slice(urlLoaderPrefix.length);\n      const chunkRef = this.emitFile({ id: realId, type: \"chunk\" });\n      return `export default import.meta.ROLLUP_FILE_URL_${chunkRef};`;\n    },\n\n    async transform(code, id) {\n      const ms = new MagicString(code);\n\n      const replacementPromises = [];\n\n      for (const match of matchAll(code, workerRegexpForTransform)) {\n        let [\n          fullMatch,\n          partBeforeArgs,\n          workerSource,\n          directWorkerFile,\n          workerFile,\n        ] = match;\n\n        const workerParametersEndIndex = match.index + fullMatch.length;\n        const matchIndex = match.index;\n        const workerParametersStartIndex = matchIndex + partBeforeArgs.length;\n\n        let workerIdPromise;\n        if (workerSource === \"import.meta.url\") {\n          // Turn the current file into a chunk\n          workerIdPromise = Promise.resolve(id);\n        } else {\n          // Otherwise it's a string literal either directly or in the `new URL(...)`.\n          if (directWorkerFile) {\n            const fullMatchWithOpts = `${fullMatch}, …)`;\n            const fullReplacement = `new Worker(new URL(${directWorkerFile}, import.meta.url), …)`;\n\n            if (!longWarningAlreadyShown) {\n              this.warn(\n                `rollup-plugin-off-main-thread:\n\\`${fullMatchWithOpts}\\` suggests that the Worker should be relative to the document, not the script.\nIn the bundler, we don't know what the final document's URL will be, and instead assume it's a URL relative to the current module.\nThis might lead to incorrect behaviour during runtime.\nIf you did mean to use a URL relative to the current module, please change your code to the following form:\n\\`${fullReplacement}\\`\nThis will become a hard error in the future.`,\n                matchIndex\n              );\n              longWarningAlreadyShown = true;\n            } else {\n              this.warn(\n                `rollup-plugin-off-main-thread: Treating \\`${fullMatchWithOpts}\\` as \\`${fullReplacement}\\``,\n                matchIndex\n              );\n            }\n            workerFile = directWorkerFile;\n          }\n\n          // Cut off surrounding quotes.\n          workerFile = workerFile.slice(1, -1);\n\n          if (!/^\\.{1,2}\\//.test(workerFile)) {\n            let isError = false;\n            if (directWorkerFile) {\n              // If direct worker file, it must be in `./something` form.\n              isError = true;\n            } else {\n              // If `new URL(...)` it can be in `new URL('something', import.meta.url)` form too,\n              // so just check it's not absolute.\n              if (/^(\\/|https?:)/.test(workerFile)) {\n                isError = true;\n              } else {\n                // If it does turn out to be `new URL('something', import.meta.url)` form,\n                // prepend `./` so that it becomes valid module specifier.\n                workerFile = `./${workerFile}`;\n              }\n            }\n            if (isError) {\n              this.warn(\n                `Paths passed to the Worker constructor must be relative to the current file, i.e. start with ./ or ../ (just like dynamic import!). Ignoring \"${workerFile}\".`,\n                matchIndex\n              );\n              continue;\n            }\n          }\n\n          workerIdPromise = this.resolve(workerFile, id).then(res => res.id);\n        }\n\n        replacementPromises.push(\n          (async () => {\n            const resolvedWorkerFile = await workerIdPromise;\n            workerFiles.push(resolvedWorkerFile);\n            const chunkRefId = this.emitFile({\n              id: resolvedWorkerFile,\n              type: \"chunk\"\n            });\n\n            ms.overwrite(\n              workerParametersStartIndex,\n              workerParametersEndIndex,\n              `new URL(import.meta.ROLLUP_FILE_URL_${chunkRefId}, import.meta.url)`\n            );\n          })()\n        );\n      }\n\n      // No matches found.\n      if (!replacementPromises.length) {\n        return;\n      }\n\n      // Wait for all the scheduled replacements to finish.\n      await Promise.all(replacementPromises);\n\n      return {\n        code: ms.toString(),\n        map: ms.generateMap({ hires: true })\n      };\n    },\n\n    resolveFileUrl(chunk) {\n      return JSON.stringify(chunk.relativePath);\n    },\n\n    outputOptions({ format }) {\n      if (format === \"esm\" || format === \"es\") {\n        if (!opts.silenceESMWorkerWarning) {\n          this.warn(\n            'Very few browsers support ES modules in Workers. If you want to your code to run in all browsers, set `output.format = \"amd\";`'\n          );\n        }\n        // In ESM, we never prepend a loader.\n        isEsmOutput = () => true;\n      } else if (format !== \"amd\") {\n        this.error(\n          `\\`output.format\\` must either be \"amd\" or \"esm\", got \"${format}\"`\n        );\n      } else {\n        isEsmOutput = () => false;\n      }\n    },\n\n    renderDynamicImport() {\n      if (isEsmOutput()) return;\n\n      // In our loader, `require` simply return a promise directly.\n      // This is tinier and simpler output than the Rollup's default.\n      return {\n        left: 'require(',\n        right: ')'\n      };\n    },\n\n    resolveImportMeta(property) {\n      if (isEsmOutput()) return;\n\n      if (property === 'url') {\n        // In our loader, `module.uri` is already fully resolved\n        // so we can emit something shorter than the Rollup's default.\n        return `module.uri`;\n      }\n    },\n\n    renderChunk(code, chunk, outputOptions) {\n      // We don’t need to do any loader processing when targeting ESM format.\n      if (isEsmOutput()) return;\n\n      if (outputOptions.banner && outputOptions.banner.length > 0) {\n        this.error(\n          \"OMT currently doesn’t work with `banner`. Feel free to submit a PR at https://github.com/surma/rollup-plugin-off-main-thread\"\n        );\n        return;\n      }\n      const ms = new MagicString(code);\n\n      for (const match of matchAll(code, workerRegexpForOutput)) {\n        let [fullMatch, optionsWithCommaStr, optionsStr] = match;\n        let options;\n        try {\n          options = json5.parse(optionsStr);\n        } catch (e) {\n          // If we couldn't parse the options object, maybe it's something dynamic or has nested\n          // parentheses or something like that. In that case, treat it as a warning\n          // and not a hard error, just like we wouldn't break on unmatched regex.\n          console.warn(\"Couldn't match options object\", fullMatch, \": \", e);\n          continue;\n        }\n        if (!(\"type\" in options)) {\n          // Nothing to do.\n          continue;\n        }\n        delete options.type;\n        const replacementEnd = match.index + fullMatch.length;\n        const replacementStart = replacementEnd - optionsWithCommaStr.length;\n        optionsStr = json5.stringify(options);\n        optionsWithCommaStr = optionsStr === \"{}\" ? \"\" : `, ${optionsStr}`;\n        ms.overwrite(\n          replacementStart,\n          replacementEnd,\n          optionsWithCommaStr\n        );\n      }\n\n      // Mangle define() call\n      ms.remove(0, \"define(\".length);\n      // If the module does not have any dependencies, it’s technically okay\n      // to skip the dependency array. But our minimal loader expects it, so\n      // we add it back in.\n      if (!code.startsWith(\"define([\")) {\n        ms.prepend(\"[],\");\n      }\n      ms.prepend(`${opts.amdFunctionName}(`);\n\n      // Prepend loader if it’s an entry point or a worker file\n      if (opts.prependLoader(chunk, workerFiles)) {\n        ms.prepend(opts.loader);\n      }\n\n      const newCode = ms.toString();\n      const hasCodeChanged = code !== newCode;\n      return {\n        code: newCode,\n        // Avoid generating sourcemaps if possible as it can be a very expensive operation\n        map: hasCodeChanged ? ms.generateMap({ hires: true }) : null\n      };\n    }\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}