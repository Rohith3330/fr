{"ast":null,"code":"/**\n * @fileoverview Prevent missing parentheses around multilines JSX\n * @author Yannick Croissant\n */\n'use strict';\n\nconst has = require('object.hasown/polyfill')();\n\nconst docsUrl = require('../util/docsUrl');\n\nconst jsxUtil = require('../util/jsx');\n\nconst reportC = require('../util/report');\n\nconst isParenthesized = require('../util/ast').isParenthesized; // ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\n\nconst DEFAULTS = {\n  declaration: 'parens',\n  assignment: 'parens',\n  return: 'parens',\n  arrow: 'parens',\n  condition: 'ignore',\n  logical: 'ignore',\n  prop: 'ignore'\n}; // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  missingParens: 'Missing parentheses around multilines JSX',\n  parensOnNewLines: 'Parentheses around JSX should be on separate lines'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow missing parentheses around multiline JSX',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-wrap-multilines')\n    },\n    fixable: 'code',\n    messages,\n    schema: [{\n      type: 'object',\n      // true/false are for backwards compatibility\n      properties: {\n        declaration: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line']\n        },\n        assignment: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line']\n        },\n        return: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line']\n        },\n        arrow: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line']\n        },\n        condition: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line']\n        },\n        logical: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line']\n        },\n        prop: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line']\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    function getOption(type) {\n      const userOptions = context.options[0] || {};\n\n      if (has(userOptions, type)) {\n        return userOptions[type];\n      }\n\n      return DEFAULTS[type];\n    }\n\n    function isEnabled(type) {\n      const option = getOption(type);\n      return option && option !== 'ignore';\n    }\n\n    function needsOpeningNewLine(node) {\n      const previousToken = context.getSourceCode().getTokenBefore(node);\n\n      if (!isParenthesized(context, node)) {\n        return false;\n      }\n\n      if (previousToken.loc.end.line === node.loc.start.line) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function needsClosingNewLine(node) {\n      const nextToken = context.getSourceCode().getTokenAfter(node);\n\n      if (!isParenthesized(context, node)) {\n        return false;\n      }\n\n      if (node.loc.end.line === nextToken.loc.end.line) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function isMultilines(node) {\n      return node.loc.start.line !== node.loc.end.line;\n    }\n\n    function report(node, messageId, fix) {\n      reportC(context, messages[messageId], messageId, {\n        node,\n        fix\n      });\n    }\n\n    function trimTokenBeforeNewline(node, tokenBefore) {\n      // if the token before the jsx is a bracket or curly brace\n      // we don't want a space between the opening parentheses and the multiline jsx\n      const isBracket = tokenBefore.value === '{' || tokenBefore.value === '[';\n      return `${tokenBefore.value.trim()}${isBracket ? '' : ' '}`;\n    }\n\n    function check(node, type) {\n      if (!node || !jsxUtil.isJSX(node)) {\n        return;\n      }\n\n      const sourceCode = context.getSourceCode();\n      const option = getOption(type);\n\n      if ((option === true || option === 'parens') && !isParenthesized(context, node) && isMultilines(node)) {\n        report(node, 'missingParens', fixer => fixer.replaceText(node, `(${sourceCode.getText(node)})`));\n      }\n\n      if (option === 'parens-new-line' && isMultilines(node)) {\n        if (!isParenthesized(context, node)) {\n          const tokenBefore = sourceCode.getTokenBefore(node, {\n            includeComments: true\n          });\n          const tokenAfter = sourceCode.getTokenAfter(node, {\n            includeComments: true\n          });\n          const start = node.loc.start;\n\n          if (tokenBefore.loc.end.line < start.line) {\n            // Strip newline after operator if parens newline is specified\n            report(node, 'missingParens', fixer => fixer.replaceTextRange([tokenBefore.range[0], tokenAfter && (tokenAfter.value === ';' || tokenAfter.value === '}') ? tokenAfter.range[0] : node.range[1]], `${trimTokenBeforeNewline(node, tokenBefore)}(\\n${start.column > 0 ? ' '.repeat(start.column) : ''}${sourceCode.getText(node)}\\n${start.column > 0 ? ' '.repeat(start.column - 2) : ''})`));\n          } else {\n            report(node, 'missingParens', fixer => fixer.replaceText(node, `(\\n${sourceCode.getText(node)}\\n)`));\n          }\n        } else {\n          const needsOpening = needsOpeningNewLine(node);\n          const needsClosing = needsClosingNewLine(node);\n\n          if (needsOpening || needsClosing) {\n            report(node, 'parensOnNewLines', fixer => {\n              const text = sourceCode.getText(node);\n              let fixed = text;\n\n              if (needsOpening) {\n                fixed = `\\n${fixed}`;\n              }\n\n              if (needsClosing) {\n                fixed = `${fixed}\\n`;\n              }\n\n              return fixer.replaceText(node, fixed);\n            });\n          }\n        }\n      }\n    } // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n\n    return {\n      VariableDeclarator(node) {\n        const type = 'declaration';\n\n        if (!isEnabled(type)) {\n          return;\n        }\n\n        if (!isEnabled('condition') && node.init && node.init.type === 'ConditionalExpression') {\n          check(node.init.consequent, type);\n          check(node.init.alternate, type);\n          return;\n        }\n\n        check(node.init, type);\n      },\n\n      AssignmentExpression(node) {\n        const type = 'assignment';\n\n        if (!isEnabled(type)) {\n          return;\n        }\n\n        if (!isEnabled('condition') && node.right.type === 'ConditionalExpression') {\n          check(node.right.consequent, type);\n          check(node.right.alternate, type);\n          return;\n        }\n\n        check(node.right, type);\n      },\n\n      ReturnStatement(node) {\n        const type = 'return';\n\n        if (isEnabled(type)) {\n          check(node.argument, type);\n        }\n      },\n\n      'ArrowFunctionExpression:exit': node => {\n        const arrowBody = node.body;\n        const type = 'arrow';\n\n        if (isEnabled(type) && arrowBody.type !== 'BlockStatement') {\n          check(arrowBody, type);\n        }\n      },\n\n      ConditionalExpression(node) {\n        const type = 'condition';\n\n        if (isEnabled(type)) {\n          check(node.consequent, type);\n          check(node.alternate, type);\n        }\n      },\n\n      LogicalExpression(node) {\n        const type = 'logical';\n\n        if (isEnabled(type)) {\n          check(node.right, type);\n        }\n      },\n\n      JSXAttribute(node) {\n        const type = 'prop';\n\n        if (isEnabled(type) && node.value && node.value.type === 'JSXExpressionContainer') {\n          check(node.value.expression, type);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["has","require","docsUrl","jsxUtil","reportC","isParenthesized","DEFAULTS","declaration","assignment","return","arrow","condition","logical","prop","messages","missingParens","parensOnNewLines","module","exports","meta","docs","description","category","recommended","url","fixable","schema","type","properties","enum","additionalProperties","create","context","getOption","userOptions","options","isEnabled","option","needsOpeningNewLine","node","previousToken","getSourceCode","getTokenBefore","loc","end","line","start","needsClosingNewLine","nextToken","getTokenAfter","isMultilines","report","messageId","fix","trimTokenBeforeNewline","tokenBefore","isBracket","value","trim","check","isJSX","sourceCode","fixer","replaceText","getText","includeComments","tokenAfter","replaceTextRange","range","column","repeat","needsOpening","needsClosing","text","fixed","VariableDeclarator","init","consequent","alternate","AssignmentExpression","right","ReturnStatement","argument","arrowBody","body","ConditionalExpression","LogicalExpression","JSXAttribute","expression"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-wrap-multilines.js"],"sourcesContent":["/**\n * @fileoverview Prevent missing parentheses around multilines JSX\n * @author Yannick Croissant\n */\n\n'use strict';\n\nconst has = require('object.hasown/polyfill')();\nconst docsUrl = require('../util/docsUrl');\nconst jsxUtil = require('../util/jsx');\nconst reportC = require('../util/report');\nconst isParenthesized = require('../util/ast').isParenthesized;\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nconst DEFAULTS = {\n  declaration: 'parens',\n  assignment: 'parens',\n  return: 'parens',\n  arrow: 'parens',\n  condition: 'ignore',\n  logical: 'ignore',\n  prop: 'ignore',\n};\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  missingParens: 'Missing parentheses around multilines JSX',\n  parensOnNewLines: 'Parentheses around JSX should be on separate lines',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow missing parentheses around multiline JSX',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-wrap-multilines'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      // true/false are for backwards compatibility\n      properties: {\n        declaration: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line'],\n        },\n        assignment: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line'],\n        },\n        return: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line'],\n        },\n        arrow: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line'],\n        },\n        condition: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line'],\n        },\n        logical: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line'],\n        },\n        prop: {\n          enum: [true, false, 'ignore', 'parens', 'parens-new-line'],\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create(context) {\n    function getOption(type) {\n      const userOptions = context.options[0] || {};\n      if (has(userOptions, type)) {\n        return userOptions[type];\n      }\n      return DEFAULTS[type];\n    }\n\n    function isEnabled(type) {\n      const option = getOption(type);\n      return option && option !== 'ignore';\n    }\n\n    function needsOpeningNewLine(node) {\n      const previousToken = context.getSourceCode().getTokenBefore(node);\n\n      if (!isParenthesized(context, node)) {\n        return false;\n      }\n\n      if (previousToken.loc.end.line === node.loc.start.line) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function needsClosingNewLine(node) {\n      const nextToken = context.getSourceCode().getTokenAfter(node);\n\n      if (!isParenthesized(context, node)) {\n        return false;\n      }\n\n      if (node.loc.end.line === nextToken.loc.end.line) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function isMultilines(node) {\n      return node.loc.start.line !== node.loc.end.line;\n    }\n\n    function report(node, messageId, fix) {\n      reportC(context, messages[messageId], messageId, {\n        node,\n        fix,\n      });\n    }\n\n    function trimTokenBeforeNewline(node, tokenBefore) {\n      // if the token before the jsx is a bracket or curly brace\n      // we don't want a space between the opening parentheses and the multiline jsx\n      const isBracket = tokenBefore.value === '{' || tokenBefore.value === '[';\n      return `${tokenBefore.value.trim()}${isBracket ? '' : ' '}`;\n    }\n\n    function check(node, type) {\n      if (!node || !jsxUtil.isJSX(node)) {\n        return;\n      }\n\n      const sourceCode = context.getSourceCode();\n      const option = getOption(type);\n\n      if ((option === true || option === 'parens') && !isParenthesized(context, node) && isMultilines(node)) {\n        report(node, 'missingParens', (fixer) => fixer.replaceText(node, `(${sourceCode.getText(node)})`));\n      }\n\n      if (option === 'parens-new-line' && isMultilines(node)) {\n        if (!isParenthesized(context, node)) {\n          const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });\n          const tokenAfter = sourceCode.getTokenAfter(node, { includeComments: true });\n          const start = node.loc.start;\n          if (tokenBefore.loc.end.line < start.line) {\n            // Strip newline after operator if parens newline is specified\n            report(\n              node,\n              'missingParens',\n              (fixer) => fixer.replaceTextRange(\n                [tokenBefore.range[0], tokenAfter && (tokenAfter.value === ';' || tokenAfter.value === '}') ? tokenAfter.range[0] : node.range[1]],\n                `${trimTokenBeforeNewline(node, tokenBefore)}(\\n${start.column > 0 ? ' '.repeat(start.column) : ''}${sourceCode.getText(node)}\\n${start.column > 0 ? ' '.repeat(start.column - 2) : ''})`\n              )\n            );\n          } else {\n            report(node, 'missingParens', (fixer) => fixer.replaceText(node, `(\\n${sourceCode.getText(node)}\\n)`));\n          }\n        } else {\n          const needsOpening = needsOpeningNewLine(node);\n          const needsClosing = needsClosingNewLine(node);\n          if (needsOpening || needsClosing) {\n            report(node, 'parensOnNewLines', (fixer) => {\n              const text = sourceCode.getText(node);\n              let fixed = text;\n              if (needsOpening) {\n                fixed = `\\n${fixed}`;\n              }\n              if (needsClosing) {\n                fixed = `${fixed}\\n`;\n              }\n              return fixer.replaceText(node, fixed);\n            });\n          }\n        }\n      }\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n\n      VariableDeclarator(node) {\n        const type = 'declaration';\n        if (!isEnabled(type)) {\n          return;\n        }\n        if (!isEnabled('condition') && node.init && node.init.type === 'ConditionalExpression') {\n          check(node.init.consequent, type);\n          check(node.init.alternate, type);\n          return;\n        }\n        check(node.init, type);\n      },\n\n      AssignmentExpression(node) {\n        const type = 'assignment';\n        if (!isEnabled(type)) {\n          return;\n        }\n        if (!isEnabled('condition') && node.right.type === 'ConditionalExpression') {\n          check(node.right.consequent, type);\n          check(node.right.alternate, type);\n          return;\n        }\n        check(node.right, type);\n      },\n\n      ReturnStatement(node) {\n        const type = 'return';\n        if (isEnabled(type)) {\n          check(node.argument, type);\n        }\n      },\n\n      'ArrowFunctionExpression:exit': (node) => {\n        const arrowBody = node.body;\n        const type = 'arrow';\n\n        if (isEnabled(type) && arrowBody.type !== 'BlockStatement') {\n          check(arrowBody, type);\n        }\n      },\n\n      ConditionalExpression(node) {\n        const type = 'condition';\n        if (isEnabled(type)) {\n          check(node.consequent, type);\n          check(node.alternate, type);\n        }\n      },\n\n      LogicalExpression(node) {\n        const type = 'logical';\n        if (isEnabled(type)) {\n          check(node.right, type);\n        }\n      },\n\n      JSXAttribute(node) {\n        const type = 'prop';\n        if (isEnabled(type) && node.value && node.value.type === 'JSXExpressionContainer') {\n          check(node.value.expression, type);\n        }\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}