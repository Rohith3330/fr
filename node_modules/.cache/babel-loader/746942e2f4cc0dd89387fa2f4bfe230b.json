{"ast":null,"code":"export class RangeTree {\n  constructor(start, end, delta, children) {\n    this.start = start;\n    this.end = end;\n    this.delta = delta;\n    this.children = children;\n  }\n  /**\n   * @precodition `ranges` are well-formed and pre-order sorted\n   */\n\n\n  static fromSortedRanges(ranges) {\n    let root; // Stack of parent trees and parent counts.\n\n    const stack = [];\n\n    for (const range of ranges) {\n      const node = new RangeTree(range.startOffset, range.endOffset, range.count, []);\n\n      if (root === undefined) {\n        root = node;\n        stack.push([node, range.count]);\n        continue;\n      }\n\n      let parent;\n      let parentCount;\n\n      while (true) {\n        [parent, parentCount] = stack[stack.length - 1]; // assert: `top !== undefined` (the ranges are sorted)\n\n        if (range.startOffset < parent.end) {\n          break;\n        } else {\n          stack.pop();\n        }\n      }\n\n      node.delta -= parentCount;\n      parent.children.push(node);\n      stack.push([node, range.count]);\n    }\n\n    return root;\n  }\n\n  normalize() {\n    const children = [];\n    let curEnd;\n    let head;\n    const tail = [];\n\n    for (const child of this.children) {\n      if (head === undefined) {\n        head = child;\n      } else if (child.delta === head.delta && child.start === curEnd) {\n        tail.push(child);\n      } else {\n        endChain();\n        head = child;\n      }\n\n      curEnd = child.end;\n    }\n\n    if (head !== undefined) {\n      endChain();\n    }\n\n    if (children.length === 1) {\n      const child = children[0];\n\n      if (child.start === this.start && child.end === this.end) {\n        this.delta += child.delta;\n        this.children = child.children; // `.lazyCount` is zero for both (both are after normalization)\n\n        return;\n      }\n    }\n\n    this.children = children;\n\n    function endChain() {\n      if (tail.length !== 0) {\n        head.end = tail[tail.length - 1].end;\n\n        for (const tailTree of tail) {\n          for (const subChild of tailTree.children) {\n            subChild.delta += tailTree.delta - head.delta;\n            head.children.push(subChild);\n          }\n        }\n\n        tail.length = 0;\n      }\n\n      head.normalize();\n      children.push(head);\n    }\n  }\n  /**\n   * @precondition `tree.start < value && value < tree.end`\n   * @return RangeTree Right part\n   */\n\n\n  split(value) {\n    let leftChildLen = this.children.length;\n    let mid; // TODO(perf): Binary search (check overhead)\n\n    for (let i = 0; i < this.children.length; i++) {\n      const child = this.children[i];\n\n      if (child.start < value && value < child.end) {\n        mid = child.split(value);\n        leftChildLen = i + 1;\n        break;\n      } else if (child.start >= value) {\n        leftChildLen = i;\n        break;\n      }\n    }\n\n    const rightLen = this.children.length - leftChildLen;\n    const rightChildren = this.children.splice(leftChildLen, rightLen);\n\n    if (mid !== undefined) {\n      rightChildren.unshift(mid);\n    }\n\n    const result = new RangeTree(value, this.end, this.delta, rightChildren);\n    this.end = value;\n    return result;\n  }\n  /**\n   * Get the range coverages corresponding to the tree.\n   *\n   * The ranges are pre-order sorted.\n   */\n\n\n  toRanges() {\n    const ranges = []; // Stack of parent trees and counts.\n\n    const stack = [[this, 0]];\n\n    while (stack.length > 0) {\n      const [cur, parentCount] = stack.pop();\n      const count = parentCount + cur.delta;\n      ranges.push({\n        startOffset: cur.start,\n        endOffset: cur.end,\n        count\n      });\n\n      for (let i = cur.children.length - 1; i >= 0; i--) {\n        stack.push([cur.children[i], count]);\n      }\n    }\n\n    return ranges;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["RangeTree","constructor","start","end","delta","children","fromSortedRanges","ranges","root","stack","range","node","startOffset","endOffset","count","undefined","push","parent","parentCount","length","pop","normalize","curEnd","head","tail","child","endChain","tailTree","subChild","split","value","leftChildLen","mid","i","rightLen","rightChildren","splice","unshift","result","toRanges","cur"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@bcoe\\v8-coverage\\dist\\lib\\_src\\range-tree.ts"],"sourcesContent":["import { RangeCov } from \"./types\";\n\nexport class RangeTree {\n  start: number;\n  end: number;\n  delta: number;\n  children: RangeTree[];\n\n  constructor(\n    start: number,\n    end: number,\n    delta: number,\n    children: RangeTree[],\n  ) {\n    this.start = start;\n    this.end = end;\n    this.delta = delta;\n    this.children = children;\n  }\n\n  /**\n   * @precodition `ranges` are well-formed and pre-order sorted\n   */\n  static fromSortedRanges(ranges: ReadonlyArray<RangeCov>): RangeTree | undefined {\n    let root: RangeTree | undefined;\n    // Stack of parent trees and parent counts.\n    const stack: [RangeTree, number][] = [];\n    for (const range of ranges) {\n      const node: RangeTree = new RangeTree(range.startOffset, range.endOffset, range.count, []);\n      if (root === undefined) {\n        root = node;\n        stack.push([node, range.count]);\n        continue;\n      }\n      let parent: RangeTree;\n      let parentCount: number;\n      while (true) {\n        [parent, parentCount] = stack[stack.length - 1];\n        // assert: `top !== undefined` (the ranges are sorted)\n        if (range.startOffset < parent.end) {\n          break;\n        } else {\n          stack.pop();\n        }\n      }\n      node.delta -= parentCount;\n      parent.children.push(node);\n      stack.push([node, range.count]);\n    }\n    return root;\n  }\n\n  normalize(): void {\n    const children: RangeTree[] = [];\n    let curEnd: number;\n    let head: RangeTree | undefined;\n    const tail: RangeTree[] = [];\n    for (const child of this.children) {\n      if (head === undefined) {\n        head = child;\n      } else if (child.delta === head.delta && child.start === curEnd!) {\n        tail.push(child);\n      } else {\n        endChain();\n        head = child;\n      }\n      curEnd = child.end;\n    }\n    if (head !== undefined) {\n      endChain();\n    }\n\n    if (children.length === 1) {\n      const child: RangeTree = children[0];\n      if (child.start === this.start && child.end === this.end) {\n        this.delta += child.delta;\n        this.children = child.children;\n        // `.lazyCount` is zero for both (both are after normalization)\n        return;\n      }\n    }\n\n    this.children = children;\n\n    function endChain(): void {\n      if (tail.length !== 0) {\n        head!.end = tail[tail.length - 1].end;\n        for (const tailTree of tail) {\n          for (const subChild of tailTree.children) {\n            subChild.delta += tailTree.delta - head!.delta;\n            head!.children.push(subChild);\n          }\n        }\n        tail.length = 0;\n      }\n      head!.normalize();\n      children.push(head!);\n    }\n  }\n\n  /**\n   * @precondition `tree.start < value && value < tree.end`\n   * @return RangeTree Right part\n   */\n  split(value: number): RangeTree {\n    let leftChildLen: number = this.children.length;\n    let mid: RangeTree | undefined;\n\n    // TODO(perf): Binary search (check overhead)\n    for (let i: number = 0; i < this.children.length; i++) {\n      const child: RangeTree = this.children[i];\n      if (child.start < value && value < child.end) {\n        mid = child.split(value);\n        leftChildLen = i + 1;\n        break;\n      } else if (child.start >= value) {\n        leftChildLen = i;\n        break;\n      }\n    }\n\n    const rightLen: number = this.children.length - leftChildLen;\n    const rightChildren: RangeTree[] = this.children.splice(leftChildLen, rightLen);\n    if (mid !== undefined) {\n      rightChildren.unshift(mid);\n    }\n    const result: RangeTree = new RangeTree(\n      value,\n      this.end,\n      this.delta,\n      rightChildren,\n    );\n    this.end = value;\n    return result;\n  }\n\n  /**\n   * Get the range coverages corresponding to the tree.\n   *\n   * The ranges are pre-order sorted.\n   */\n  toRanges(): RangeCov[] {\n    const ranges: RangeCov[] = [];\n    // Stack of parent trees and counts.\n    const stack: [RangeTree, number][] = [[this, 0]];\n    while (stack.length > 0) {\n      const [cur, parentCount]: [RangeTree, number] = stack.pop()!;\n      const count: number = parentCount + cur.delta;\n      ranges.push({startOffset: cur.start, endOffset: cur.end, count});\n      for (let i: number = cur.children.length - 1; i >= 0; i--) {\n        stack.push([cur.children[i], count]);\n      }\n    }\n    return ranges;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}