{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileNamespace;\n\nvar _core = require(\"@babel/core\");\n\nfunction transpileNamespace(path, allowNamespaces) {\n  if (path.node.declare || path.node.id.type === \"StringLiteral\") {\n    path.remove();\n    return;\n  }\n\n  if (!allowNamespaces) {\n    throw path.get(\"id\").buildCodeFrameError(\"Namespace not marked type-only declare.\" + \" Non-declarative namespaces are only supported experimentally in Babel.\" + \" To enable and review caveats see:\" + \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\");\n  }\n\n  const name = path.node.id.name;\n  const value = handleNested(path, _core.types.cloneNode(path.node, true));\n  const bound = path.scope.hasOwnBinding(name);\n\n  if (path.parent.type === \"ExportNamedDeclaration\") {\n    if (!bound) {\n      path.parentPath.insertAfter(value);\n      path.replaceWith(getDeclaration(name));\n      path.scope.registerDeclaration(path.parentPath);\n    } else {\n      path.parentPath.replaceWith(value);\n    }\n  } else if (bound) {\n    path.replaceWith(value);\n  } else {\n    path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(name), value])[0]);\n  }\n}\n\nfunction getDeclaration(name) {\n  return _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(_core.types.identifier(name))]);\n}\n\nfunction getMemberExpression(name, itemName) {\n  return _core.types.memberExpression(_core.types.identifier(name), _core.types.identifier(itemName));\n}\n\nfunction handleVariableDeclaration(node, name, hub) {\n  if (node.kind !== \"const\") {\n    throw hub.file.buildCodeFrameError(node, \"Namespaces exporting non-const are not supported by Babel.\" + \" Change to const or see:\" + \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\");\n  }\n\n  const {\n    declarations\n  } = node;\n\n  if (declarations.every(declarator => _core.types.isIdentifier(declarator.id))) {\n    for (const declarator of declarations) {\n      if (declarator.init) {\n        declarator.init = _core.types.assignmentExpression(\"=\", getMemberExpression(name, declarator.id.name), declarator.init);\n      }\n    }\n\n    return [node];\n  }\n\n  const bindingIdentifiers = _core.types.getBindingIdentifiers(node);\n\n  const assignments = [];\n\n  for (const idName in bindingIdentifiers) {\n    assignments.push(_core.types.assignmentExpression(\"=\", getMemberExpression(name, idName), _core.types.cloneNode(bindingIdentifiers[idName])));\n  }\n\n  return [node, _core.types.expressionStatement(_core.types.sequenceExpression(assignments))];\n}\n\nfunction buildNestedAmbiendModuleError(path, node) {\n  throw path.hub.buildError(node, \"Ambient modules cannot be nested in other modules or namespaces.\", Error);\n}\n\nfunction handleNested(path, node, parentExport) {\n  const names = new Set();\n  const realName = node.id;\n\n  _core.types.assertIdentifier(realName);\n\n  const name = path.scope.generateUid(realName.name);\n  const namespaceTopLevel = _core.types.isTSModuleBlock(node.body) ? node.body.body : [_core.types.exportNamedDeclaration(node.body)];\n\n  for (let i = 0; i < namespaceTopLevel.length; i++) {\n    const subNode = namespaceTopLevel[i];\n\n    switch (subNode.type) {\n      case \"TSModuleDeclaration\":\n        {\n          if (!_core.types.isIdentifier(subNode.id)) {\n            throw buildNestedAmbiendModuleError(path, subNode);\n          }\n\n          const transformed = handleNested(path, subNode);\n          const moduleName = subNode.id.name;\n\n          if (names.has(moduleName)) {\n            namespaceTopLevel[i] = transformed;\n          } else {\n            names.add(moduleName);\n            namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed);\n          }\n\n          continue;\n        }\n\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\":\n        names.add(subNode.id.name);\n        continue;\n\n      case \"VariableDeclaration\":\n        {\n          for (const name in _core.types.getBindingIdentifiers(subNode)) {\n            names.add(name);\n          }\n\n          continue;\n        }\n\n      default:\n        continue;\n\n      case \"ExportNamedDeclaration\":\n    }\n\n    switch (subNode.declaration.type) {\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\":\n        {\n          if (subNode.declaration.declare) {\n            continue;\n          }\n\n          const itemName = subNode.declaration.id.name;\n          names.add(itemName);\n          namespaceTopLevel.splice(i++, 1, subNode.declaration, _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", getMemberExpression(name, itemName), _core.types.identifier(itemName))));\n          break;\n        }\n\n      case \"VariableDeclaration\":\n        {\n          const nodes = handleVariableDeclaration(subNode.declaration, name, path.hub);\n          namespaceTopLevel.splice(i, nodes.length, ...nodes);\n          i += nodes.length - 1;\n          break;\n        }\n\n      case \"TSModuleDeclaration\":\n        {\n          if (!_core.types.isIdentifier(subNode.declaration.id)) {\n            throw buildNestedAmbiendModuleError(path, subNode.declaration);\n          }\n\n          const transformed = handleNested(path, subNode.declaration, _core.types.identifier(name));\n          const moduleName = subNode.declaration.id.name;\n\n          if (names.has(moduleName)) {\n            namespaceTopLevel[i] = transformed;\n          } else {\n            names.add(moduleName);\n            namespaceTopLevel.splice(i++, 1, getDeclaration(moduleName), transformed);\n          }\n        }\n    }\n  }\n\n  let fallthroughValue = _core.types.objectExpression([]);\n\n  if (parentExport) {\n    const memberExpr = _core.types.memberExpression(parentExport, realName);\n\n    fallthroughValue = _core.template.expression.ast`\n      ${_core.types.cloneNode(memberExpr)} ||\n        (${_core.types.cloneNode(memberExpr)} = ${fallthroughValue})\n    `;\n  }\n\n  return _core.template.statement.ast`\n    (function (${_core.types.identifier(name)}) {\n      ${namespaceTopLevel}\n    })(${realName} || (${_core.types.cloneNode(realName)} = ${fallthroughValue}));\n  `;\n}","map":{"version":3,"mappings":"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","names":["transpileNamespace","path","allowNamespaces","node","declare","id","type","remove","get","buildCodeFrameError","name","value","handleNested","t","cloneNode","bound","scope","hasOwnBinding","parent","parentPath","insertAfter","replaceWith","getDeclaration","registerDeclaration","replaceWithMultiple","variableDeclaration","variableDeclarator","identifier","getMemberExpression","itemName","memberExpression","handleVariableDeclaration","hub","kind","file","declarations","every","declarator","isIdentifier","init","assignmentExpression","bindingIdentifiers","getBindingIdentifiers","assignments","idName","push","expressionStatement","sequenceExpression","buildNestedAmbiendModuleError","buildError","Error","parentExport","names","Set","realName","assertIdentifier","generateUid","namespaceTopLevel","isTSModuleBlock","body","exportNamedDeclaration","i","length","subNode","transformed","moduleName","has","add","splice","declaration","nodes","fallthroughValue","objectExpression","memberExpr","template","expression","ast","statement"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-transform-typescript\\src\\namespace.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport default function transpileNamespace(\n  path: NodePath<t.TSModuleDeclaration>,\n  allowNamespaces: boolean,\n) {\n  if (path.node.declare || path.node.id.type === \"StringLiteral\") {\n    path.remove();\n    return;\n  }\n\n  if (!allowNamespaces) {\n    throw path\n      .get(\"id\")\n      .buildCodeFrameError(\n        \"Namespace not marked type-only declare.\" +\n          \" Non-declarative namespaces are only supported experimentally in Babel.\" +\n          \" To enable and review caveats see:\" +\n          \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\",\n      );\n  }\n\n  const name = path.node.id.name;\n  const value = handleNested(path, t.cloneNode(path.node, true));\n  const bound = path.scope.hasOwnBinding(name);\n  if (path.parent.type === \"ExportNamedDeclaration\") {\n    if (!bound) {\n      path.parentPath.insertAfter(value);\n      path.replaceWith(getDeclaration(name));\n      path.scope.registerDeclaration(path.parentPath);\n    } else {\n      path.parentPath.replaceWith(value);\n    }\n  } else if (bound) {\n    path.replaceWith(value);\n  } else {\n    path.scope.registerDeclaration(\n      path.replaceWithMultiple([getDeclaration(name), value])[0],\n    );\n  }\n}\n\nfunction getDeclaration(name: string) {\n  return t.variableDeclaration(\"let\", [\n    t.variableDeclarator(t.identifier(name)),\n  ]);\n}\n\nfunction getMemberExpression(name: string, itemName: string) {\n  return t.memberExpression(t.identifier(name), t.identifier(itemName));\n}\n\n/**\n * Convert export const foo = 1 to Namepsace.foo = 1;\n *\n * @param {t.VariableDeclaration} node given variable declaration, e.g. `const foo = 1`\n * @param {string} name the generated unique namespace member name\n * @param {*} hub An instance implements HubInterface defined in `@babel/traverse` that can throw a code frame error\n */\nfunction handleVariableDeclaration(\n  node: t.VariableDeclaration,\n  name: string,\n  hub: any,\n): t.Statement[] {\n  if (node.kind !== \"const\") {\n    throw hub.file.buildCodeFrameError(\n      node,\n      \"Namespaces exporting non-const are not supported by Babel.\" +\n        \" Change to const or see:\" +\n        \" https://babeljs.io/docs/en/babel-plugin-transform-typescript\",\n    );\n  }\n  const { declarations } = node;\n  if (\n    declarations.every(\n      (declarator): declarator is t.VariableDeclarator & { id: t.Identifier } =>\n        t.isIdentifier(declarator.id),\n    )\n  ) {\n    // `export const a = 1` transforms to `const a = N.a = 1`, the output\n    // is smaller than `const a = 1; N.a = a`;\n    for (const declarator of declarations) {\n      // `export declare const a`,the declarator.init would be null,\n      if (declarator.init) {\n        declarator.init = t.assignmentExpression(\n          \"=\",\n          getMemberExpression(name, declarator.id.name),\n          declarator.init,\n        );\n      }\n    }\n    return [node];\n  }\n  // Now we have pattern in declarators\n  // `export const [a] = 1` transforms to `const [a] = 1; N.a = a`\n  const bindingIdentifiers = t.getBindingIdentifiers(node);\n  const assignments = [];\n  // getBindingIdentifiers returns an object without prototype.\n  // eslint-disable-next-line guard-for-in\n  for (const idName in bindingIdentifiers) {\n    assignments.push(\n      t.assignmentExpression(\n        \"=\",\n        getMemberExpression(name, idName),\n        t.cloneNode(bindingIdentifiers[idName]),\n      ),\n    );\n  }\n  return [node, t.expressionStatement(t.sequenceExpression(assignments))];\n}\n\nfunction buildNestedAmbiendModuleError(path: NodePath, node: t.Node) {\n  throw path.hub.buildError(\n    node,\n    \"Ambient modules cannot be nested in other modules or namespaces.\",\n    Error,\n  );\n}\n\nfunction handleNested(\n  path: NodePath,\n  node: t.TSModuleDeclaration,\n  parentExport?: t.Expression,\n) {\n  const names = new Set();\n  const realName = node.id;\n  t.assertIdentifier(realName);\n\n  const name = path.scope.generateUid(realName.name);\n\n  const namespaceTopLevel: t.Statement[] = t.isTSModuleBlock(node.body)\n    ? node.body.body\n    : // We handle `namespace X.Y {}` as if it was\n      //   namespace X {\n      //     export namespace Y {}\n      //   }\n      [t.exportNamedDeclaration(node.body)];\n\n  for (let i = 0; i < namespaceTopLevel.length; i++) {\n    const subNode = namespaceTopLevel[i];\n\n    // The first switch is mainly to detect name usage. Only export\n    // declarations require further transformation.\n    switch (subNode.type) {\n      case \"TSModuleDeclaration\": {\n        if (!t.isIdentifier(subNode.id)) {\n          throw buildNestedAmbiendModuleError(path, subNode);\n        }\n\n        const transformed = handleNested(path, subNode);\n        const moduleName = subNode.id.name;\n        if (names.has(moduleName)) {\n          namespaceTopLevel[i] = transformed;\n        } else {\n          names.add(moduleName);\n          namespaceTopLevel.splice(\n            i++,\n            1,\n            getDeclaration(moduleName),\n            transformed,\n          );\n        }\n        continue;\n      }\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\":\n        names.add(subNode.id.name);\n        continue;\n      case \"VariableDeclaration\": {\n        // getBindingIdentifiers returns an object without prototype.\n        // eslint-disable-next-line guard-for-in\n        for (const name in t.getBindingIdentifiers(subNode)) {\n          names.add(name);\n        }\n        continue;\n      }\n      default:\n        // Neither named declaration nor export, continue to next item.\n        continue;\n      case \"ExportNamedDeclaration\":\n      // Export declarations get parsed using the next switch.\n    }\n\n    // Transform the export declarations that occur inside of a namespace.\n    switch (subNode.declaration.type) {\n      case \"TSEnumDeclaration\":\n      case \"FunctionDeclaration\":\n      case \"ClassDeclaration\": {\n        if (subNode.declaration.declare) {\n          continue;\n        }\n\n        const itemName = subNode.declaration.id.name;\n        names.add(itemName);\n        namespaceTopLevel.splice(\n          i++,\n          1,\n          subNode.declaration,\n          t.expressionStatement(\n            t.assignmentExpression(\n              \"=\",\n              getMemberExpression(name, itemName),\n              t.identifier(itemName),\n            ),\n          ),\n        );\n        break;\n      }\n      case \"VariableDeclaration\": {\n        const nodes = handleVariableDeclaration(\n          subNode.declaration,\n          name,\n          path.hub,\n        );\n        namespaceTopLevel.splice(i, nodes.length, ...nodes);\n        i += nodes.length - 1;\n        break;\n      }\n      case \"TSModuleDeclaration\": {\n        if (!t.isIdentifier(subNode.declaration.id)) {\n          throw buildNestedAmbiendModuleError(path, subNode.declaration);\n        }\n\n        const transformed = handleNested(\n          path,\n          subNode.declaration,\n          t.identifier(name),\n        );\n        const moduleName = subNode.declaration.id.name;\n        if (names.has(moduleName)) {\n          namespaceTopLevel[i] = transformed;\n        } else {\n          names.add(moduleName);\n          namespaceTopLevel.splice(\n            i++,\n            1,\n            getDeclaration(moduleName),\n            transformed,\n          );\n        }\n      }\n    }\n  }\n\n  // {}\n  let fallthroughValue: t.Expression = t.objectExpression([]);\n\n  if (parentExport) {\n    const memberExpr = t.memberExpression(parentExport, realName);\n    fallthroughValue = template.expression.ast`\n      ${t.cloneNode(memberExpr)} ||\n        (${t.cloneNode(memberExpr)} = ${fallthroughValue})\n    `;\n  }\n\n  return template.statement.ast`\n    (function (${t.identifier(name)}) {\n      ${namespaceTopLevel}\n    })(${realName} || (${t.cloneNode(realName)} = ${fallthroughValue}));\n  `;\n}\n"]},"metadata":{},"sourceType":"script"}