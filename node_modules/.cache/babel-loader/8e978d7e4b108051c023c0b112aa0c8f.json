{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeConfigAPI = makeConfigAPI;\nexports.makePluginAPI = makePluginAPI;\nexports.makePresetAPI = makePresetAPI;\n\nfunction _semver() {\n  var data = require(\"semver\");\n\n  _semver = function _semver() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ = require(\"../../\");\n\nvar _caching = require(\"../caching\");\n\nfunction makeConfigAPI(cache) {\n  var env = function env(value) {\n    return cache.using(function (data) {\n      if (typeof value === \"undefined\") return data.envName;\n\n      if (typeof value === \"function\") {\n        return (0, _caching.assertSimpleType)(value(data.envName));\n      }\n\n      return (Array.isArray(value) ? value : [value]).some(function (entry) {\n        if (typeof entry !== \"string\") {\n          throw new Error(\"Unexpected non-string value\");\n        }\n\n        return entry === data.envName;\n      });\n    });\n  };\n\n  var caller = function caller(cb) {\n    return cache.using(function (data) {\n      return (0, _caching.assertSimpleType)(cb(data.caller));\n    });\n  };\n\n  return {\n    version: _.version,\n    cache: cache.simple(),\n    env: env,\n    async: function async() {\n      return false;\n    },\n    caller: caller,\n    assertVersion: assertVersion\n  };\n}\n\nfunction makePresetAPI(cache, externalDependencies) {\n  var targets = function targets() {\n    return JSON.parse(cache.using(function (data) {\n      return JSON.stringify(data.targets);\n    }));\n  };\n\n  var addExternalDependency = function addExternalDependency(ref) {\n    externalDependencies.push(ref);\n  };\n\n  return Object.assign({}, makeConfigAPI(cache), {\n    targets: targets,\n    addExternalDependency: addExternalDependency\n  });\n}\n\nfunction makePluginAPI(cache, externalDependencies) {\n  var assumption = function assumption(name) {\n    return cache.using(function (data) {\n      return data.assumptions[name];\n    });\n  };\n\n  return Object.assign({}, makePresetAPI(cache, externalDependencies), {\n    assumption: assumption\n  });\n}\n\nfunction assertVersion(range) {\n  if (typeof range === \"number\") {\n    if (!Number.isInteger(range)) {\n      throw new Error(\"Expected string or integer value.\");\n    }\n\n    range = \"^\".concat(range, \".0.0-0\");\n  }\n\n  if (typeof range !== \"string\") {\n    throw new Error(\"Expected string or integer value.\");\n  }\n\n  if (_semver().satisfies(_.version, range)) return;\n  var limit = Error.stackTraceLimit;\n\n  if (typeof limit === \"number\" && limit < 25) {\n    Error.stackTraceLimit = 25;\n  }\n\n  var err = new Error(\"Requires Babel \\\"\".concat(range, \"\\\", but was loaded with \\\"\").concat(_.version, \"\\\". \") + \"If you are sure you have a compatible version of @babel/core, \" + \"it is likely that something in your build process is loading the \" + \"wrong version. Inspect the stack trace of this error to look for \" + \"the first entry that doesn't mention \\\"@babel/core\\\" or \\\"babel-core\\\" \" + \"to see what is calling Babel.\");\n\n  if (typeof limit === \"number\") {\n    Error.stackTraceLimit = limit;\n  }\n\n  throw Object.assign(err, {\n    code: \"BABEL_VERSION_UNSUPPORTED\",\n    version: _.version,\n    range: range\n  });\n}\n\n0 && 0;","map":{"version":3,"mappings":"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","names":["_semver","makeConfigAPI","cache","env","value","using","data","envName","Array","isArray","some","entry","Error","caller","cb","version","coreVersion","simple","async","assertVersion","makePresetAPI","externalDependencies","targets","JSON","parse","stringify","addExternalDependency","ref","push","makePluginAPI","assumption","name","assumptions","range","Number","isInteger","semver","satisfies","limit","stackTraceLimit","err","Object","assign","code"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\helpers\\config-api.ts"],"sourcesContent":["import semver from \"semver\";\nimport type { Targets } from \"@babel/helper-compilation-targets\";\n\nimport { version as coreVersion } from \"../../\";\nimport { assertSimpleType } from \"../caching\";\nimport type {\n  CacheConfigurator,\n  SimpleCacheConfigurator,\n  SimpleType,\n} from \"../caching\";\n\nimport type { AssumptionName, CallerMetadata } from \"../validation/options\";\n\nimport type * as Context from \"../cache-contexts\";\n\ntype EnvFunction = {\n  (): string;\n  <T>(extractor: (babelEnv: string) => T): T;\n  (envVar: string): boolean;\n  (envVars: Array<string>): boolean;\n};\n\ntype CallerFactory = (\n  extractor: (callerMetadata: CallerMetadata | undefined) => unknown,\n) => SimpleType;\ntype TargetsFunction = () => Targets;\ntype AssumptionFunction = (name: AssumptionName) => boolean | undefined;\n\nexport type ConfigAPI = {\n  version: string;\n  cache: SimpleCacheConfigurator;\n  env: EnvFunction;\n  async: () => boolean;\n  assertVersion: typeof assertVersion;\n  caller?: CallerFactory;\n};\n\nexport type PresetAPI = {\n  targets: TargetsFunction;\n  addExternalDependency: (ref: string) => void;\n} & ConfigAPI;\n\nexport type PluginAPI = {\n  assumption: AssumptionFunction;\n} & PresetAPI;\n\nexport function makeConfigAPI<SideChannel extends Context.SimpleConfig>(\n  cache: CacheConfigurator<SideChannel>,\n): ConfigAPI {\n  // TODO(@nicolo-ribaudo): If we remove the explicit type from `value`\n  // and the `as any` type cast, TypeScript crashes in an infinite\n  // recursion. After upgrading to TS4.7 and finishing the noImplicitAny\n  // PR, we should check if it still crashes and report it to the TS team.\n  const env: EnvFunction = ((\n    value: string | string[] | (<T>(babelEnv: string) => T),\n  ) =>\n    cache.using(data => {\n      if (typeof value === \"undefined\") return data.envName;\n      if (typeof value === \"function\") {\n        return assertSimpleType(value(data.envName));\n      }\n      return (Array.isArray(value) ? value : [value]).some(entry => {\n        if (typeof entry !== \"string\") {\n          throw new Error(\"Unexpected non-string value\");\n        }\n        return entry === data.envName;\n      });\n    })) as any;\n\n  const caller = (cb: {\n    (CallerMetadata: CallerMetadata | undefined): SimpleType;\n  }) => cache.using(data => assertSimpleType(cb(data.caller)));\n\n  return {\n    version: coreVersion,\n    cache: cache.simple(),\n    // Expose \".env()\" so people can easily get the same env that we expose using the \"env\" key.\n    env,\n    async: () => false,\n    caller,\n    assertVersion,\n  };\n}\n\nexport function makePresetAPI<SideChannel extends Context.SimplePreset>(\n  cache: CacheConfigurator<SideChannel>,\n  externalDependencies: Array<string>,\n): PresetAPI {\n  const targets = () =>\n    // We are using JSON.parse/JSON.stringify because it's only possible to cache\n    // primitive values. We can safely stringify the targets object because it\n    // only contains strings as its properties.\n    // Please make the Record and Tuple proposal happen!\n    JSON.parse(cache.using(data => JSON.stringify(data.targets)));\n\n  const addExternalDependency = (ref: string) => {\n    externalDependencies.push(ref);\n  };\n\n  return { ...makeConfigAPI(cache), targets, addExternalDependency };\n}\n\nexport function makePluginAPI<SideChannel extends Context.SimplePlugin>(\n  cache: CacheConfigurator<SideChannel>,\n  externalDependencies: Array<string>,\n): PluginAPI {\n  const assumption = (name: string) =>\n    cache.using(data => data.assumptions[name]);\n\n  return { ...makePresetAPI(cache, externalDependencies), assumption };\n}\n\nfunction assertVersion(range: string | number): void {\n  if (typeof range === \"number\") {\n    if (!Number.isInteger(range)) {\n      throw new Error(\"Expected string or integer value.\");\n    }\n    range = `^${range}.0.0-0`;\n  }\n  if (typeof range !== \"string\") {\n    throw new Error(\"Expected string or integer value.\");\n  }\n\n  if (semver.satisfies(coreVersion, range)) return;\n\n  const limit = Error.stackTraceLimit;\n\n  if (typeof limit === \"number\" && limit < 25) {\n    // Bump up the limit if needed so that users are more likely\n    // to be able to see what is calling Babel.\n    Error.stackTraceLimit = 25;\n  }\n\n  const err = new Error(\n    `Requires Babel \"${range}\", but was loaded with \"${coreVersion}\". ` +\n      `If you are sure you have a compatible version of @babel/core, ` +\n      `it is likely that something in your build process is loading the ` +\n      `wrong version. Inspect the stack trace of this error to look for ` +\n      `the first entry that doesn't mention \"@babel/core\" or \"babel-core\" ` +\n      `to see what is calling Babel.`,\n  );\n\n  if (typeof limit === \"number\") {\n    Error.stackTraceLimit = limit;\n  }\n\n  throw Object.assign(err, {\n    code: \"BABEL_VERSION_UNSUPPORTED\",\n    version: coreVersion,\n    range,\n  });\n}\n"]},"metadata":{},"sourceType":"script"}