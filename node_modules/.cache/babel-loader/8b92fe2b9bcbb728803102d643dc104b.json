{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.waitForElementToBeRemoved = waitForElementToBeRemoved;\n\nvar _waitFor = require(\"./wait-for\");\n\nconst isRemoved = result => !result || Array.isArray(result) && !result.length; // Check if the element is not present.\n// As the name implies, waitForElementToBeRemoved should check `present` --> `removed`\n\n\nfunction initialCheck(elements) {\n  if (isRemoved(elements)) {\n    throw new Error('The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.');\n  }\n}\n\nasync function waitForElementToBeRemoved(callback, options) {\n  // created here so we get a nice stacktrace\n  const timeoutError = new Error('Timed out in waitForElementToBeRemoved.');\n\n  if (typeof callback !== 'function') {\n    initialCheck(callback);\n    const elements = Array.isArray(callback) ? callback : [callback];\n    const getRemainingElements = elements.map(element => {\n      let parent = element.parentElement;\n      if (parent === null) return () => null;\n\n      while (parent.parentElement) parent = parent.parentElement;\n\n      return () => parent.contains(element) ? element : null;\n    });\n\n    callback = () => getRemainingElements.map(c => c()).filter(Boolean);\n  }\n\n  initialCheck(callback());\n  return (0, _waitFor.waitFor)(() => {\n    let result;\n\n    try {\n      result = callback();\n    } catch (error) {\n      if (error.name === 'TestingLibraryElementError') {\n        return undefined;\n      }\n\n      throw error;\n    }\n\n    if (!isRemoved(result)) {\n      throw timeoutError;\n    }\n\n    return undefined;\n  }, options);\n}\n/*\neslint\n  require-await: \"off\"\n*/","map":{"version":3,"names":["Object","defineProperty","exports","value","waitForElementToBeRemoved","_waitFor","require","isRemoved","result","Array","isArray","length","initialCheck","elements","Error","callback","options","timeoutError","getRemainingElements","map","element","parent","parentElement","contains","c","filter","Boolean","waitFor","error","name","undefined"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@testing-library/dom/dist/wait-for-element-to-be-removed.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.waitForElementToBeRemoved = waitForElementToBeRemoved;\n\nvar _waitFor = require(\"./wait-for\");\n\nconst isRemoved = result => !result || Array.isArray(result) && !result.length; // Check if the element is not present.\n// As the name implies, waitForElementToBeRemoved should check `present` --> `removed`\n\n\nfunction initialCheck(elements) {\n  if (isRemoved(elements)) {\n    throw new Error('The element(s) given to waitForElementToBeRemoved are already removed. waitForElementToBeRemoved requires that the element(s) exist(s) before waiting for removal.');\n  }\n}\n\nasync function waitForElementToBeRemoved(callback, options) {\n  // created here so we get a nice stacktrace\n  const timeoutError = new Error('Timed out in waitForElementToBeRemoved.');\n\n  if (typeof callback !== 'function') {\n    initialCheck(callback);\n    const elements = Array.isArray(callback) ? callback : [callback];\n    const getRemainingElements = elements.map(element => {\n      let parent = element.parentElement;\n      if (parent === null) return () => null;\n\n      while (parent.parentElement) parent = parent.parentElement;\n\n      return () => parent.contains(element) ? element : null;\n    });\n\n    callback = () => getRemainingElements.map(c => c()).filter(Boolean);\n  }\n\n  initialCheck(callback());\n  return (0, _waitFor.waitFor)(() => {\n    let result;\n\n    try {\n      result = callback();\n    } catch (error) {\n      if (error.name === 'TestingLibraryElementError') {\n        return undefined;\n      }\n\n      throw error;\n    }\n\n    if (!isRemoved(result)) {\n      throw timeoutError;\n    }\n\n    return undefined;\n  }, options);\n}\n/*\neslint\n  require-await: \"off\"\n*/"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,yBAAR,GAAoCA,yBAApC;;AAEA,IAAIC,QAAQ,GAAGC,OAAO,CAAC,YAAD,CAAtB;;AAEA,MAAMC,SAAS,GAAGC,MAAM,IAAI,CAACA,MAAD,IAAWC,KAAK,CAACC,OAAN,CAAcF,MAAd,KAAyB,CAACA,MAAM,CAACG,MAAxE,C,CAAgF;AAChF;;;AAGA,SAASC,YAAT,CAAsBC,QAAtB,EAAgC;EAC9B,IAAIN,SAAS,CAACM,QAAD,CAAb,EAAyB;IACvB,MAAM,IAAIC,KAAJ,CAAU,oKAAV,CAAN;EACD;AACF;;AAED,eAAeV,yBAAf,CAAyCW,QAAzC,EAAmDC,OAAnD,EAA4D;EAC1D;EACA,MAAMC,YAAY,GAAG,IAAIH,KAAJ,CAAU,yCAAV,CAArB;;EAEA,IAAI,OAAOC,QAAP,KAAoB,UAAxB,EAAoC;IAClCH,YAAY,CAACG,QAAD,CAAZ;IACA,MAAMF,QAAQ,GAAGJ,KAAK,CAACC,OAAN,CAAcK,QAAd,IAA0BA,QAA1B,GAAqC,CAACA,QAAD,CAAtD;IACA,MAAMG,oBAAoB,GAAGL,QAAQ,CAACM,GAAT,CAAaC,OAAO,IAAI;MACnD,IAAIC,MAAM,GAAGD,OAAO,CAACE,aAArB;MACA,IAAID,MAAM,KAAK,IAAf,EAAqB,OAAO,MAAM,IAAb;;MAErB,OAAOA,MAAM,CAACC,aAAd,EAA6BD,MAAM,GAAGA,MAAM,CAACC,aAAhB;;MAE7B,OAAO,MAAMD,MAAM,CAACE,QAAP,CAAgBH,OAAhB,IAA2BA,OAA3B,GAAqC,IAAlD;IACD,CAP4B,CAA7B;;IASAL,QAAQ,GAAG,MAAMG,oBAAoB,CAACC,GAArB,CAAyBK,CAAC,IAAIA,CAAC,EAA/B,EAAmCC,MAAnC,CAA0CC,OAA1C,CAAjB;EACD;;EAEDd,YAAY,CAACG,QAAQ,EAAT,CAAZ;EACA,OAAO,CAAC,GAAGV,QAAQ,CAACsB,OAAb,EAAsB,MAAM;IACjC,IAAInB,MAAJ;;IAEA,IAAI;MACFA,MAAM,GAAGO,QAAQ,EAAjB;IACD,CAFD,CAEE,OAAOa,KAAP,EAAc;MACd,IAAIA,KAAK,CAACC,IAAN,KAAe,4BAAnB,EAAiD;QAC/C,OAAOC,SAAP;MACD;;MAED,MAAMF,KAAN;IACD;;IAED,IAAI,CAACrB,SAAS,CAACC,MAAD,CAAd,EAAwB;MACtB,MAAMS,YAAN;IACD;;IAED,OAAOa,SAAP;EACD,CAlBM,EAkBJd,OAlBI,CAAP;AAmBD;AACD;AACA;AACA;AACA"},"metadata":{},"sourceType":"script"}