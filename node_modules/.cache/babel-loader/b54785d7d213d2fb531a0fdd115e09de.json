{"ast":null,"code":"/**\n * @fileoverview Enforce React components to have a shouldComponentUpdate method\n * @author Evgueni Naverniouk\n */\n'use strict';\n\nconst Components = require('../util/Components');\n\nconst componentUtil = require('../util/componentUtil');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report');\n\nconst messages = {\n  noShouldComponentUpdate: 'Component is not optimized. Please add a shouldComponentUpdate method.'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce React components to have a shouldComponentUpdate method',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('require-optimization')\n    },\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        allowDecorators: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  create: Components.detect((context, components) => {\n    const configuration = context.options[0] || {};\n    const allowDecorators = configuration.allowDecorators || [];\n    /**\n     * Checks to see if our component is decorated by PureRenderMixin via reactMixin\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if node is decorated with a PureRenderMixin, false if not.\n     */\n\n    function hasPureRenderDecorator(node) {\n      if (node.decorators && node.decorators.length) {\n        for (let i = 0, l = node.decorators.length; i < l; i++) {\n          if (node.decorators[i].expression && node.decorators[i].expression.callee && node.decorators[i].expression.callee.object && node.decorators[i].expression.callee.object.name === 'reactMixin' && node.decorators[i].expression.callee.property && node.decorators[i].expression.callee.property.name === 'decorate' && node.decorators[i].expression.arguments && node.decorators[i].expression.arguments.length && node.decorators[i].expression.arguments[0].name === 'PureRenderMixin') {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Checks to see if our component is custom decorated\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if node is decorated name with a custom decorated, false if not.\n     */\n\n\n    function hasCustomDecorator(node) {\n      const allowLength = allowDecorators.length;\n\n      if (allowLength && node.decorators && node.decorators.length) {\n        for (let i = 0; i < allowLength; i++) {\n          for (let j = 0, l = node.decorators.length; j < l; j++) {\n            if (node.decorators[j].expression && node.decorators[j].expression.name === allowDecorators[i]) {\n              return true;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Checks if we are declaring a shouldComponentUpdate method\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if we are declaring a shouldComponentUpdate method, false if not.\n     */\n\n\n    function isSCUDeclared(node) {\n      return Boolean(node && node.name === 'shouldComponentUpdate');\n    }\n    /**\n     * Checks if we are declaring a PureRenderMixin mixin\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if we are declaring a PureRenderMixin method, false if not.\n     */\n\n\n    function isPureRenderDeclared(node) {\n      let hasPR = false;\n\n      if (node.value && node.value.elements) {\n        for (let i = 0, l = node.value.elements.length; i < l; i++) {\n          if (node.value.elements[i] && node.value.elements[i].name === 'PureRenderMixin') {\n            hasPR = true;\n            break;\n          }\n        }\n      }\n\n      return Boolean(node && node.key.name === 'mixins' && hasPR);\n    }\n    /**\n     * Mark shouldComponentUpdate as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n\n\n    function markSCUAsDeclared(node) {\n      components.set(node, {\n        hasSCU: true\n      });\n    }\n    /**\n     * Reports missing optimization for a given component\n     * @param {Object} component The component to process\n     */\n\n\n    function reportMissingOptimization(component) {\n      report(context, messages.noShouldComponentUpdate, 'noShouldComponentUpdate', {\n        node: component.node\n      });\n    }\n    /**\n     * Checks if we are declaring function in class\n     * @returns {Boolean} True if we are declaring function in class, false if not.\n     */\n\n\n    function isFunctionInClass() {\n      let blockNode;\n      let scope = context.getScope();\n\n      while (scope) {\n        blockNode = scope.block;\n\n        if (blockNode && blockNode.type === 'ClassDeclaration') {\n          return true;\n        }\n\n        scope = scope.upper;\n      }\n\n      return false;\n    }\n\n    return {\n      ArrowFunctionExpression(node) {\n        // Skip if the function is declared in the class\n        if (isFunctionInClass()) {\n          return;\n        } // Stateless Functional Components cannot be optimized (yet)\n\n\n        markSCUAsDeclared(node);\n      },\n\n      ClassDeclaration(node) {\n        if (!(hasPureRenderDecorator(node) || hasCustomDecorator(node) || componentUtil.isPureComponent(node, context))) {\n          return;\n        }\n\n        markSCUAsDeclared(node);\n      },\n\n      FunctionDeclaration(node) {\n        // Skip if the function is declared in the class\n        if (isFunctionInClass()) {\n          return;\n        } // Stateless Functional Components cannot be optimized (yet)\n\n\n        markSCUAsDeclared(node);\n      },\n\n      FunctionExpression(node) {\n        // Skip if the function is declared in the class\n        if (isFunctionInClass()) {\n          return;\n        } // Stateless Functional Components cannot be optimized (yet)\n\n\n        markSCUAsDeclared(node);\n      },\n\n      MethodDefinition(node) {\n        if (!isSCUDeclared(node.key)) {\n          return;\n        }\n\n        markSCUAsDeclared(node);\n      },\n\n      ObjectExpression(node) {\n        // Search for the shouldComponentUpdate declaration\n        const found = node.properties.some(property => property.key && (isSCUDeclared(property.key) || isPureRenderDeclared(property)));\n\n        if (found) {\n          markSCUAsDeclared(node);\n        }\n      },\n\n      'Program:exit'() {\n        const list = components.list(); // Report missing shouldComponentUpdate for all components\n\n        Object.keys(list).filter(component => !list[component].hasSCU).forEach(component => {\n          reportMissingOptimization(list[component]);\n        });\n      }\n\n    };\n  })\n};","map":{"version":3,"names":["Components","require","componentUtil","docsUrl","report","messages","noShouldComponentUpdate","module","exports","meta","docs","description","category","recommended","url","schema","type","properties","allowDecorators","items","additionalProperties","create","detect","context","components","configuration","options","hasPureRenderDecorator","node","decorators","length","i","l","expression","callee","object","name","property","arguments","hasCustomDecorator","allowLength","j","isSCUDeclared","Boolean","isPureRenderDeclared","hasPR","value","elements","key","markSCUAsDeclared","set","hasSCU","reportMissingOptimization","component","isFunctionInClass","blockNode","scope","getScope","block","upper","ArrowFunctionExpression","ClassDeclaration","isPureComponent","FunctionDeclaration","FunctionExpression","MethodDefinition","ObjectExpression","found","some","list","Object","keys","filter","forEach"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/require-optimization.js"],"sourcesContent":["/**\n * @fileoverview Enforce React components to have a shouldComponentUpdate method\n * @author Evgueni Naverniouk\n */\n\n'use strict';\n\nconst Components = require('../util/Components');\nconst componentUtil = require('../util/componentUtil');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\nconst messages = {\n  noShouldComponentUpdate: 'Component is not optimized. Please add a shouldComponentUpdate method.',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce React components to have a shouldComponentUpdate method',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('require-optimization'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        allowDecorators: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components) => {\n    const configuration = context.options[0] || {};\n    const allowDecorators = configuration.allowDecorators || [];\n\n    /**\n     * Checks to see if our component is decorated by PureRenderMixin via reactMixin\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if node is decorated with a PureRenderMixin, false if not.\n     */\n    function hasPureRenderDecorator(node) {\n      if (node.decorators && node.decorators.length) {\n        for (let i = 0, l = node.decorators.length; i < l; i++) {\n          if (\n            node.decorators[i].expression\n            && node.decorators[i].expression.callee\n            && node.decorators[i].expression.callee.object\n            && node.decorators[i].expression.callee.object.name === 'reactMixin'\n            && node.decorators[i].expression.callee.property\n            && node.decorators[i].expression.callee.property.name === 'decorate'\n            && node.decorators[i].expression.arguments\n            && node.decorators[i].expression.arguments.length\n            && node.decorators[i].expression.arguments[0].name === 'PureRenderMixin'\n          ) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Checks to see if our component is custom decorated\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if node is decorated name with a custom decorated, false if not.\n     */\n    function hasCustomDecorator(node) {\n      const allowLength = allowDecorators.length;\n\n      if (allowLength && node.decorators && node.decorators.length) {\n        for (let i = 0; i < allowLength; i++) {\n          for (let j = 0, l = node.decorators.length; j < l; j++) {\n            if (\n              node.decorators[j].expression\n              && node.decorators[j].expression.name === allowDecorators[i]\n            ) {\n              return true;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Checks if we are declaring a shouldComponentUpdate method\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if we are declaring a shouldComponentUpdate method, false if not.\n     */\n    function isSCUDeclared(node) {\n      return Boolean(\n        node\n        && node.name === 'shouldComponentUpdate'\n      );\n    }\n\n    /**\n     * Checks if we are declaring a PureRenderMixin mixin\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if we are declaring a PureRenderMixin method, false if not.\n     */\n    function isPureRenderDeclared(node) {\n      let hasPR = false;\n      if (node.value && node.value.elements) {\n        for (let i = 0, l = node.value.elements.length; i < l; i++) {\n          if (node.value.elements[i] && node.value.elements[i].name === 'PureRenderMixin') {\n            hasPR = true;\n            break;\n          }\n        }\n      }\n\n      return Boolean(\n        node\n        && node.key.name === 'mixins'\n        && hasPR\n      );\n    }\n\n    /**\n     * Mark shouldComponentUpdate as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markSCUAsDeclared(node) {\n      components.set(node, {\n        hasSCU: true,\n      });\n    }\n\n    /**\n     * Reports missing optimization for a given component\n     * @param {Object} component The component to process\n     */\n    function reportMissingOptimization(component) {\n      report(context, messages.noShouldComponentUpdate, 'noShouldComponentUpdate', {\n        node: component.node,\n      });\n    }\n\n    /**\n     * Checks if we are declaring function in class\n     * @returns {Boolean} True if we are declaring function in class, false if not.\n     */\n    function isFunctionInClass() {\n      let blockNode;\n      let scope = context.getScope();\n      while (scope) {\n        blockNode = scope.block;\n        if (blockNode && blockNode.type === 'ClassDeclaration') {\n          return true;\n        }\n        scope = scope.upper;\n      }\n\n      return false;\n    }\n\n    return {\n      ArrowFunctionExpression(node) {\n        // Skip if the function is declared in the class\n        if (isFunctionInClass()) {\n          return;\n        }\n        // Stateless Functional Components cannot be optimized (yet)\n        markSCUAsDeclared(node);\n      },\n\n      ClassDeclaration(node) {\n        if (!(\n          hasPureRenderDecorator(node)\n          || hasCustomDecorator(node)\n          || componentUtil.isPureComponent(node, context)\n        )) {\n          return;\n        }\n        markSCUAsDeclared(node);\n      },\n\n      FunctionDeclaration(node) {\n        // Skip if the function is declared in the class\n        if (isFunctionInClass()) {\n          return;\n        }\n        // Stateless Functional Components cannot be optimized (yet)\n        markSCUAsDeclared(node);\n      },\n\n      FunctionExpression(node) {\n        // Skip if the function is declared in the class\n        if (isFunctionInClass()) {\n          return;\n        }\n        // Stateless Functional Components cannot be optimized (yet)\n        markSCUAsDeclared(node);\n      },\n\n      MethodDefinition(node) {\n        if (!isSCUDeclared(node.key)) {\n          return;\n        }\n        markSCUAsDeclared(node);\n      },\n\n      ObjectExpression(node) {\n        // Search for the shouldComponentUpdate declaration\n        const found = node.properties.some((property) => (\n          property.key\n          && (isSCUDeclared(property.key) || isPureRenderDeclared(property))\n        ));\n        if (found) {\n          markSCUAsDeclared(node);\n        }\n      },\n\n      'Program:exit'() {\n        const list = components.list();\n\n        // Report missing shouldComponentUpdate for all components\n        Object.keys(list).filter((component) => !list[component].hasSCU).forEach((component) => {\n          reportMissingOptimization(list[component]);\n        });\n      },\n    };\n  }),\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}