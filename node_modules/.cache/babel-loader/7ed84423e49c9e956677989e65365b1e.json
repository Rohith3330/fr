{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _ExportMap = require('../ExportMap');\n\nvar _ExportMap2 = _interopRequireDefault(_ExportMap);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nvar _arrayIncludes = require('array-includes');\n\nvar _arrayIncludes2 = _interopRequireDefault(_arrayIncludes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n/*\n                                                                                                                                                                                                            Notes on TypeScript namespaces aka TSModuleDeclaration:\n                                                                                                                                                                                                            \n                                                                                                                                                                                                            There are two forms:\n                                                                                                                                                                                                            - active namespaces: namespace Foo {} / module Foo {}\n                                                                                                                                                                                                            - ambient modules; declare module \"eslint-plugin-import\" {}\n                                                                                                                                                                                                            \n                                                                                                                                                                                                            active namespaces:\n                                                                                                                                                                                                            - cannot contain a default export\n                                                                                                                                                                                                            - cannot contain an export all\n                                                                                                                                                                                                            - cannot contain a multi name export (export { a, b })\n                                                                                                                                                                                                            - can have active namespaces nested within them\n                                                                                                                                                                                                            \n                                                                                                                                                                                                            ambient namespaces:\n                                                                                                                                                                                                            - can only be defined in .d.ts files\n                                                                                                                                                                                                            - cannot be nested within active namespaces\n                                                                                                                                                                                                            - have no other restrictions\n                                                                                                                                                                                                            */\n\n\nvar rootProgram = 'root';\nvar tsTypePrefix = 'type:';\n/**\n                             * Detect function overloads like:\n                             * ```ts\n                             * export function foo(a: number);\n                             * export function foo(a: string);\n                             * export function foo(a: number|string) { return a; }\n                             * ```\n                             * @param {Set<Object>} nodes\n                             * @returns {boolean}\n                             */\n\nfunction isTypescriptFunctionOverloads(nodes) {\n  var types = new Set(Array.from(nodes, function (node) {\n    return node.parent.type;\n  }));\n  return types.has('TSDeclareFunction') && (types.size === 1 || types.size === 2 && types.has('FunctionDeclaration'));\n}\n/**\n   * Detect merging Namespaces with Classes, Functions, or Enums like:\n   * ```ts\n   * export class Foo { }\n   * export namespace Foo { }\n   * ```\n   * @param {Set<Object>} nodes\n   * @returns {boolean}\n   */\n\n\nfunction isTypescriptNamespaceMerging(nodes) {\n  var types = new Set(Array.from(nodes, function (node) {\n    return node.parent.type;\n  }));\n  var noNamespaceNodes = Array.from(nodes).filter(function (node) {\n    return node.parent.type !== 'TSModuleDeclaration';\n  });\n  return types.has('TSModuleDeclaration') && (types.size === 1 // Merging with functions\n  || types.size === 2 && (types.has('FunctionDeclaration') || types.has('TSDeclareFunction')) || types.size === 3 && types.has('FunctionDeclaration') && types.has('TSDeclareFunction') // Merging with classes or enums\n  || types.size === 2 && (types.has('ClassDeclaration') || types.has('TSEnumDeclaration')) && noNamespaceNodes.length === 1);\n}\n/**\n   * Detect if a typescript namespace node should be reported as multiple export:\n   * ```ts\n   * export class Foo { }\n   * export function Foo();\n   * export namespace Foo { }\n   * ```\n   * @param {Object} node\n   * @param {Set<Object>} nodes\n   * @returns {boolean}\n   */\n\n\nfunction shouldSkipTypescriptNamespace(node, nodes) {\n  var types = new Set(Array.from(nodes, function (node) {\n    return node.parent.type;\n  }));\n  return !isTypescriptNamespaceMerging(nodes) && node.parent.type === 'TSModuleDeclaration' && (types.has('TSEnumDeclaration') || types.has('ClassDeclaration') || types.has('FunctionDeclaration') || types.has('TSDeclareFunction'));\n}\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      url: (0, _docsUrl2['default'])('export')\n    },\n    schema: []\n  },\n  create: function () {\n    function create(context) {\n      var namespace = new Map([[rootProgram, new Map()]]);\n\n      function addNamed(name, node, parent, isType) {\n        if (!namespace.has(parent)) {\n          namespace.set(parent, new Map());\n        }\n\n        var named = namespace.get(parent);\n        var key = isType ? '' + tsTypePrefix + String(name) : name;\n        var nodes = named.get(key);\n\n        if (nodes == null) {\n          nodes = new Set();\n          named.set(key, nodes);\n        }\n\n        nodes.add(node);\n      }\n\n      function getParent(node) {\n        if (node.parent && node.parent.type === 'TSModuleBlock') {\n          return node.parent.parent;\n        } // just in case somehow a non-ts namespace export declaration isn't directly\n        // parented to the root Program node\n\n\n        return rootProgram;\n      }\n\n      return {\n        ExportDefaultDeclaration: function () {\n          function ExportDefaultDeclaration(node) {\n            addNamed('default', node, getParent(node));\n          }\n\n          return ExportDefaultDeclaration;\n        }(),\n        ExportSpecifier: function () {\n          function ExportSpecifier(node) {\n            addNamed(node.exported.name || node.exported.value, node.exported, getParent(node.parent));\n          }\n\n          return ExportSpecifier;\n        }(),\n        ExportNamedDeclaration: function () {\n          function ExportNamedDeclaration(node) {\n            if (node.declaration == null) return;\n            var parent = getParent(node); // support for old TypeScript versions\n\n            var isTypeVariableDecl = node.declaration.kind === 'type';\n\n            if (node.declaration.id != null) {\n              if ((0, _arrayIncludes2['default'])(['TSTypeAliasDeclaration', 'TSInterfaceDeclaration'], node.declaration.type)) {\n                addNamed(node.declaration.id.name, node.declaration.id, parent, true);\n              } else {\n                addNamed(node.declaration.id.name, node.declaration.id, parent, isTypeVariableDecl);\n              }\n            }\n\n            if (node.declaration.declarations != null) {\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = node.declaration.declarations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var declaration = _step.value;\n                  (0, _ExportMap.recursivePatternCapture)(declaration.id, function (v) {\n                    return addNamed(v.name, v, parent, isTypeVariableDecl);\n                  });\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator['return']) {\n                    _iterator['return']();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n            }\n          }\n\n          return ExportNamedDeclaration;\n        }(),\n        ExportAllDeclaration: function () {\n          function ExportAllDeclaration(node) {\n            if (node.source == null) return; // not sure if this is ever true\n            // `export * as X from 'path'` does not conflict\n\n            if (node.exported && node.exported.name) return;\n\n            var remoteExports = _ExportMap2['default'].get(node.source.value, context);\n\n            if (remoteExports == null) return;\n\n            if (remoteExports.errors.length) {\n              remoteExports.reportErrors(context, node);\n              return;\n            }\n\n            var parent = getParent(node);\n            var any = false;\n            remoteExports.forEach(function (v, name) {\n              if (name !== 'default') {\n                any = true; // poor man's filter\n\n                addNamed(name, node, parent);\n              }\n            });\n\n            if (!any) {\n              context.report(node.source, 'No named exports found in module \\'' + String(node.source.value) + '\\'.');\n            }\n          }\n\n          return ExportAllDeclaration;\n        }(),\n        'Program:exit': function () {\n          function ProgramExit() {\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = namespace[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var _ref = _step2.value;\n\n                var _ref2 = _slicedToArray(_ref, 2);\n\n                var named = _ref2[1];\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n\n                try {\n                  for (var _iterator3 = named[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var _ref3 = _step3.value;\n\n                    var _ref4 = _slicedToArray(_ref3, 2);\n\n                    var name = _ref4[0];\n                    var nodes = _ref4[1];\n                    if (nodes.size <= 1) continue;\n                    if (isTypescriptFunctionOverloads(nodes) || isTypescriptNamespaceMerging(nodes)) continue;\n                    var _iteratorNormalCompletion4 = true;\n                    var _didIteratorError4 = false;\n                    var _iteratorError4 = undefined;\n\n                    try {\n                      for (var _iterator4 = nodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                        var node = _step4.value;\n                        if (shouldSkipTypescriptNamespace(node, nodes)) continue;\n\n                        if (name === 'default') {\n                          context.report(node, 'Multiple default exports.');\n                        } else {\n                          context.report(node, 'Multiple exports of name \\'' + String(name.replace(tsTypePrefix, '')) + '\\'.');\n                        }\n                      }\n                    } catch (err) {\n                      _didIteratorError4 = true;\n                      _iteratorError4 = err;\n                    } finally {\n                      try {\n                        if (!_iteratorNormalCompletion4 && _iterator4['return']) {\n                          _iterator4['return']();\n                        }\n                      } finally {\n                        if (_didIteratorError4) {\n                          throw _iteratorError4;\n                        }\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _didIteratorError3 = true;\n                  _iteratorError3 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion3 && _iterator3['return']) {\n                      _iterator3['return']();\n                    }\n                  } finally {\n                    if (_didIteratorError3) {\n                      throw _iteratorError3;\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n                  _iterator2['return']();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n          }\n\n          return ProgramExit;\n        }()\n      };\n    }\n\n    return create;\n  }()\n};","map":{"version":3,"mappings":"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","names":["rootProgram","tsTypePrefix","isTypescriptFunctionOverloads","nodes","types","Set","Array","from","node","parent","type","has","size","isTypescriptNamespaceMerging","noNamespaceNodes","filter","length","shouldSkipTypescriptNamespace","module","exports","meta","docs","url","schema","create","context","namespace","Map","addNamed","name","isType","set","named","get","key","add","getParent","ExportDefaultDeclaration","ExportSpecifier","exported","value","ExportNamedDeclaration","declaration","isTypeVariableDecl","kind","id","declarations","Symbol","v","_didIteratorError","_iteratorError","_iterator","ExportAllDeclaration","source","remoteExports","ExportMap","errors","reportErrors","any","forEach","report","replace","_didIteratorError4","_iteratorError4","_iterator4","_didIteratorError3","_iteratorError3","_iterator3","_didIteratorError2","_iteratorError2","_iterator2"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\export.js"],"sourcesContent":["import ExportMap, { recursivePatternCapture } from '../ExportMap';\nimport docsUrl from '../docsUrl';\nimport includes from 'array-includes';\n\n/*\nNotes on TypeScript namespaces aka TSModuleDeclaration:\n\nThere are two forms:\n- active namespaces: namespace Foo {} / module Foo {}\n- ambient modules; declare module \"eslint-plugin-import\" {}\n\nactive namespaces:\n- cannot contain a default export\n- cannot contain an export all\n- cannot contain a multi name export (export { a, b })\n- can have active namespaces nested within them\n\nambient namespaces:\n- can only be defined in .d.ts files\n- cannot be nested within active namespaces\n- have no other restrictions\n*/\n\nconst rootProgram = 'root';\nconst tsTypePrefix = 'type:';\n\n/**\n * Detect function overloads like:\n * ```ts\n * export function foo(a: number);\n * export function foo(a: string);\n * export function foo(a: number|string) { return a; }\n * ```\n * @param {Set<Object>} nodes\n * @returns {boolean}\n */\nfunction isTypescriptFunctionOverloads(nodes) {\n  const types = new Set(Array.from(nodes, node => node.parent.type));\n  return types.has('TSDeclareFunction')\n    && (\n      types.size === 1\n      || (types.size === 2 && types.has('FunctionDeclaration'))\n    );\n}\n\n/**\n * Detect merging Namespaces with Classes, Functions, or Enums like:\n * ```ts\n * export class Foo { }\n * export namespace Foo { }\n * ```\n * @param {Set<Object>} nodes\n * @returns {boolean}\n */\nfunction isTypescriptNamespaceMerging(nodes) {\n  const types = new Set(Array.from(nodes, node => node.parent.type));\n  const noNamespaceNodes = Array.from(nodes).filter((node) => node.parent.type !== 'TSModuleDeclaration');\n\n  return types.has('TSModuleDeclaration')\n    && (\n      types.size === 1\n      // Merging with functions\n      || (types.size === 2 && (types.has('FunctionDeclaration') || types.has('TSDeclareFunction')))\n      || (types.size === 3 && types.has('FunctionDeclaration') && types.has('TSDeclareFunction'))\n      // Merging with classes or enums\n      || (types.size === 2 && (types.has('ClassDeclaration') || types.has('TSEnumDeclaration')) && noNamespaceNodes.length === 1)\n    );\n}\n\n/**\n * Detect if a typescript namespace node should be reported as multiple export:\n * ```ts\n * export class Foo { }\n * export function Foo();\n * export namespace Foo { }\n * ```\n * @param {Object} node\n * @param {Set<Object>} nodes\n * @returns {boolean}\n */\nfunction shouldSkipTypescriptNamespace(node, nodes) {\n  const types = new Set(Array.from(nodes, node => node.parent.type));\n\n  return !isTypescriptNamespaceMerging(nodes)\n    && node.parent.type === 'TSModuleDeclaration'\n    && (\n      types.has('TSEnumDeclaration')\n      || types.has('ClassDeclaration')\n      || types.has('FunctionDeclaration')\n      || types.has('TSDeclareFunction')\n    );\n}\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      url: docsUrl('export'),\n    },\n    schema: [],\n  },\n\n  create(context) {\n    const namespace = new Map([[rootProgram, new Map()]]);\n\n    function addNamed(name, node, parent, isType) {\n      if (!namespace.has(parent)) {\n        namespace.set(parent, new Map());\n      }\n      const named = namespace.get(parent);\n\n      const key = isType ? `${tsTypePrefix}${name}` : name;\n      let nodes = named.get(key);\n\n      if (nodes == null) {\n        nodes = new Set();\n        named.set(key, nodes);\n      }\n\n      nodes.add(node);\n    }\n\n    function getParent(node) {\n      if (node.parent && node.parent.type === 'TSModuleBlock') {\n        return node.parent.parent;\n      }\n\n      // just in case somehow a non-ts namespace export declaration isn't directly\n      // parented to the root Program node\n      return rootProgram;\n    }\n\n    return {\n      ExportDefaultDeclaration(node) {\n        addNamed('default', node, getParent(node));\n      },\n\n      ExportSpecifier(node) {\n        addNamed(\n          node.exported.name || node.exported.value,\n          node.exported,\n          getParent(node.parent),\n        );\n      },\n\n      ExportNamedDeclaration(node) {\n        if (node.declaration == null) return;\n\n        const parent = getParent(node);\n        // support for old TypeScript versions\n        const isTypeVariableDecl = node.declaration.kind === 'type';\n\n        if (node.declaration.id != null) {\n          if (includes([\n            'TSTypeAliasDeclaration',\n            'TSInterfaceDeclaration',\n          ], node.declaration.type)) {\n            addNamed(node.declaration.id.name, node.declaration.id, parent, true);\n          } else {\n            addNamed(node.declaration.id.name, node.declaration.id, parent, isTypeVariableDecl);\n          }\n        }\n\n        if (node.declaration.declarations != null) {\n          for (const declaration of node.declaration.declarations) {\n            recursivePatternCapture(declaration.id, v =>\n              addNamed(v.name, v, parent, isTypeVariableDecl));\n          }\n        }\n      },\n\n      ExportAllDeclaration(node) {\n        if (node.source == null) return; // not sure if this is ever true\n\n        // `export * as X from 'path'` does not conflict\n        if (node.exported && node.exported.name) return;\n\n        const remoteExports = ExportMap.get(node.source.value, context);\n        if (remoteExports == null) return;\n\n        if (remoteExports.errors.length) {\n          remoteExports.reportErrors(context, node);\n          return;\n        }\n\n        const parent = getParent(node);\n\n        let any = false;\n        remoteExports.forEach((v, name) => {\n          if (name !== 'default') {\n            any = true; // poor man's filter\n            addNamed(name, node, parent);\n          }\n        });\n\n        if (!any) {\n          context.report(\n            node.source,\n            `No named exports found in module '${node.source.value}'.`,\n          );\n        }\n      },\n\n      'Program:exit': function () {\n        for (const [, named] of namespace) {\n          for (const [name, nodes] of named) {\n            if (nodes.size <= 1) continue;\n\n            if (isTypescriptFunctionOverloads(nodes) || isTypescriptNamespaceMerging(nodes)) continue;\n\n            for (const node of nodes) {\n              if (shouldSkipTypescriptNamespace(node, nodes)) continue;\n\n              if (name === 'default') {\n                context.report(node, 'Multiple default exports.');\n              } else {\n                context.report(\n                  node,\n                  `Multiple exports of name '${name.replace(tsTypePrefix, '')}'.`,\n                );\n              }\n            }\n          }\n        }\n      },\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"script"}