{"ast":null,"code":"/**\n * @fileoverview Require or prevent a new line after jsx elements and expressions.\n * @author Johnny Zabala\n * @author Joseph Stiles\n */\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst messages = {\n  require: 'JSX element should start in a new line',\n  prevent: 'JSX element should not start in a new line',\n  allowMultilines: 'Multiline JSX elements should start in a new line'\n};\n\nfunction isMultilined(node) {\n  return node.loc.start.line !== node.loc.end.line;\n}\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Require or prevent a new line after jsx elements and expressions.',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-newline')\n    },\n    fixable: 'code',\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        prevent: {\n          default: false,\n          type: 'boolean'\n        },\n        allowMultilines: {\n          default: false,\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false,\n      if: {\n        properties: {\n          allowMultilines: {\n            const: true\n          }\n        }\n      },\n      then: {\n        properties: {\n          prevent: {\n            const: true\n          }\n        },\n        required: ['prevent']\n      }\n    }]\n  },\n\n  create(context) {\n    const jsxElementParents = new Set();\n    const sourceCode = context.getSourceCode();\n    return {\n      'Program:exit'() {\n        jsxElementParents.forEach(parent => {\n          parent.children.forEach((element, index, elements) => {\n            if (element.type === 'JSXElement' || element.type === 'JSXExpressionContainer') {\n              const configuration = context.options[0] || {};\n              const prevent = configuration.prevent || false;\n              const allowMultilines = configuration.allowMultilines || false;\n              const firstAdjacentSibling = elements[index + 1];\n              const secondAdjacentSibling = elements[index + 2];\n              const hasSibling = firstAdjacentSibling && secondAdjacentSibling && (firstAdjacentSibling.type === 'Literal' || firstAdjacentSibling.type === 'JSXText');\n              if (!hasSibling) return; // Check adjacent sibling has the proper amount of newlines\n\n              const isWithoutNewLine = !/\\n\\s*\\n/.test(firstAdjacentSibling.value);\n\n              if (allowMultilines && (isMultilined(element) || isMultilined(secondAdjacentSibling))) {\n                if (!isWithoutNewLine) return;\n                const regex = /(\\n)(?!.*\\1)/g;\n                const replacement = '\\n\\n';\n                const messageId = 'allowMultilines';\n                report(context, messages[messageId], messageId, {\n                  node: secondAdjacentSibling,\n\n                  fix(fixer) {\n                    return fixer.replaceText(firstAdjacentSibling, sourceCode.getText(firstAdjacentSibling).replace(regex, replacement));\n                  }\n\n                });\n                return;\n              }\n\n              if (isWithoutNewLine === prevent) return;\n              const messageId = prevent ? 'prevent' : 'require';\n              const regex = prevent ? /(\\n\\n)(?!.*\\1)/g : /(\\n)(?!.*\\1)/g;\n              const replacement = prevent ? '\\n' : '\\n\\n';\n              report(context, messages[messageId], messageId, {\n                node: secondAdjacentSibling,\n\n                fix(fixer) {\n                  return fixer.replaceText(firstAdjacentSibling, // double or remove the last newline\n                  sourceCode.getText(firstAdjacentSibling).replace(regex, replacement));\n                }\n\n              });\n            }\n          });\n        });\n      },\n\n      ':matches(JSXElement, JSXFragment) > :matches(JSXElement, JSXExpressionContainer)': node => {\n        jsxElementParents.add(node.parent);\n      }\n    };\n  }\n\n};","map":{"version":3,"names":["docsUrl","require","report","messages","prevent","allowMultilines","isMultilined","node","loc","start","line","end","module","exports","meta","docs","description","category","recommended","url","fixable","schema","type","properties","default","additionalProperties","if","const","then","required","create","context","jsxElementParents","Set","sourceCode","getSourceCode","forEach","parent","children","element","index","elements","configuration","options","firstAdjacentSibling","secondAdjacentSibling","hasSibling","isWithoutNewLine","test","value","regex","replacement","messageId","fix","fixer","replaceText","getText","replace","add"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-newline.js"],"sourcesContent":["/**\n * @fileoverview Require or prevent a new line after jsx elements and expressions.\n * @author Johnny Zabala\n * @author Joseph Stiles\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  require: 'JSX element should start in a new line',\n  prevent: 'JSX element should not start in a new line',\n  allowMultilines: 'Multiline JSX elements should start in a new line',\n};\n\nfunction isMultilined(node) {\n  return node.loc.start.line !== node.loc.end.line;\n}\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Require or prevent a new line after jsx elements and expressions.',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-newline'),\n    },\n    fixable: 'code',\n\n    messages,\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          prevent: {\n            default: false,\n            type: 'boolean',\n          },\n          allowMultilines: {\n            default: false,\n            type: 'boolean',\n          },\n        },\n        additionalProperties: false,\n        if: {\n          properties: {\n            allowMultilines: {\n              const: true,\n            },\n          },\n        },\n        then: {\n          properties: {\n            prevent: {\n              const: true,\n            },\n          },\n          required: [\n            'prevent',\n          ],\n        },\n      },\n    ],\n  },\n  create(context) {\n    const jsxElementParents = new Set();\n    const sourceCode = context.getSourceCode();\n\n    return {\n      'Program:exit'() {\n        jsxElementParents.forEach((parent) => {\n          parent.children.forEach((element, index, elements) => {\n            if (element.type === 'JSXElement' || element.type === 'JSXExpressionContainer') {\n              const configuration = context.options[0] || {};\n              const prevent = configuration.prevent || false;\n              const allowMultilines = configuration.allowMultilines || false;\n\n              const firstAdjacentSibling = elements[index + 1];\n              const secondAdjacentSibling = elements[index + 2];\n\n              const hasSibling = firstAdjacentSibling\n              && secondAdjacentSibling\n              && (firstAdjacentSibling.type === 'Literal' || firstAdjacentSibling.type === 'JSXText');\n\n              if (!hasSibling) return;\n\n              // Check adjacent sibling has the proper amount of newlines\n              const isWithoutNewLine = !/\\n\\s*\\n/.test(firstAdjacentSibling.value);\n\n              if (allowMultilines && (isMultilined(element) || isMultilined(secondAdjacentSibling))) {\n                if (!isWithoutNewLine) return;\n\n                const regex = /(\\n)(?!.*\\1)/g;\n                const replacement = '\\n\\n';\n                const messageId = 'allowMultilines';\n\n                report(context, messages[messageId], messageId, {\n                  node: secondAdjacentSibling,\n                  fix(fixer) {\n                    return fixer.replaceText(\n                      firstAdjacentSibling,\n                      sourceCode.getText(firstAdjacentSibling)\n                        .replace(regex, replacement)\n                    );\n                  },\n                });\n\n                return;\n              }\n\n              if (isWithoutNewLine === prevent) return;\n              const messageId = prevent\n                ? 'prevent'\n                : 'require';\n\n              const regex = prevent\n                ? /(\\n\\n)(?!.*\\1)/g\n                : /(\\n)(?!.*\\1)/g;\n\n              const replacement = prevent\n                ? '\\n'\n                : '\\n\\n';\n\n              report(context, messages[messageId], messageId, {\n                node: secondAdjacentSibling,\n                fix(fixer) {\n                  return fixer.replaceText(\n                    firstAdjacentSibling,\n                    // double or remove the last newline\n                    sourceCode.getText(firstAdjacentSibling)\n                      .replace(regex, replacement)\n                  );\n                },\n              });\n            }\n          });\n        });\n      },\n      ':matches(JSXElement, JSXFragment) > :matches(JSXElement, JSXExpressionContainer)': (node) => {\n        jsxElementParents.add(node.parent);\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}