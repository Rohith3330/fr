{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(normalizeFile);\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeFile;\n\nfunction _fs() {\n  var data = require(\"fs\");\n\n  _fs = function _fs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  var data = require(\"path\");\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  var data = require(\"debug\");\n\n  _debug = function _debug() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _t() {\n  var data = require(\"@babel/types\");\n\n  _t = function _t() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  var data = require(\"convert-source-map\");\n\n  _convertSourceMap = function _convertSourceMap() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _file = require(\"./file/file\");\n\nvar _parser = require(\"../parser\");\n\nvar _cloneDeep = require(\"./util/clone-deep\");\n\nvar _t2 = _t(),\n    file = _t2.file,\n    traverseFast = _t2.traverseFast;\n\nvar debug = _debug()(\"babel:transform:file\");\n\nvar LARGE_INPUT_SOURCEMAP_THRESHOLD = 3000000;\n\nfunction normalizeFile(pluginPasses, options, code, ast) {\n  var inputMap, lastComment, _lastComment, match, inputMapContent;\n\n  return _regeneratorRuntime().wrap(function normalizeFile$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          code = \"\".concat(code || \"\");\n\n          if (!ast) {\n            _context.next = 11;\n            break;\n          }\n\n          if (!(ast.type === \"Program\")) {\n            _context.next = 6;\n            break;\n          }\n\n          ast = file(ast, [], []);\n          _context.next = 8;\n          break;\n\n        case 6:\n          if (!(ast.type !== \"File\")) {\n            _context.next = 8;\n            break;\n          }\n\n          throw new Error(\"AST root must be a Program or File node\");\n\n        case 8:\n          if (options.cloneInputAst) {\n            ast = (0, _cloneDeep.default)(ast);\n          }\n\n          _context.next = 13;\n          break;\n\n        case 11:\n          return _context.delegateYield((0, _parser.default)(pluginPasses, options, code), \"t0\", 12);\n\n        case 12:\n          ast = _context.t0;\n\n        case 13:\n          inputMap = null;\n\n          if (options.inputSourceMap !== false) {\n            if (typeof options.inputSourceMap === \"object\") {\n              inputMap = _convertSourceMap().fromObject(options.inputSourceMap);\n            }\n\n            if (!inputMap) {\n              lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);\n\n              if (lastComment) {\n                try {\n                  inputMap = _convertSourceMap().fromComment(lastComment);\n                } catch (err) {\n                  debug(\"discarding unknown inline input sourcemap\", err);\n                }\n              }\n            }\n\n            if (!inputMap) {\n              _lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);\n\n              if (typeof options.filename === \"string\" && _lastComment) {\n                try {\n                  match = EXTERNAL_SOURCEMAP_REGEX.exec(_lastComment);\n                  inputMapContent = _fs().readFileSync(_path().resolve(_path().dirname(options.filename), match[1]));\n\n                  if (inputMapContent.length > LARGE_INPUT_SOURCEMAP_THRESHOLD) {\n                    debug(\"skip merging input map > 1 MB\");\n                  } else {\n                    inputMap = _convertSourceMap().fromJSON(inputMapContent);\n                  }\n                } catch (err) {\n                  debug(\"discarding unknown file input sourcemap\", err);\n                }\n              } else if (_lastComment) {\n                debug(\"discarding un-loadable file input sourcemap\");\n              }\n            }\n          }\n\n          return _context.abrupt(\"return\", new _file.default(options, {\n            code: code,\n            ast: ast,\n            inputMap: inputMap\n          }));\n\n        case 16:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nvar INLINE_SOURCEMAP_REGEX = /^[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+?;)?base64,(?:.*)$/;\nvar EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \\t]+sourceMappingURL=([^\\s'\"`]+)[ \\t]*$/;\n\nfunction extractCommentsFromList(regex, comments, lastComment) {\n  if (comments) {\n    comments = comments.filter(function (_ref) {\n      var value = _ref.value;\n\n      if (regex.test(value)) {\n        lastComment = value;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  return [comments, lastComment];\n}\n\nfunction extractComments(regex, ast) {\n  var lastComment = null;\n  traverseFast(ast, function (node) {\n    var _extractCommentsFromL = extractCommentsFromList(regex, node.leadingComments, lastComment);\n\n    var _extractCommentsFromL2 = _slicedToArray(_extractCommentsFromL, 2);\n\n    node.leadingComments = _extractCommentsFromL2[0];\n    lastComment = _extractCommentsFromL2[1];\n\n    var _extractCommentsFromL3 = extractCommentsFromList(regex, node.innerComments, lastComment);\n\n    var _extractCommentsFromL4 = _slicedToArray(_extractCommentsFromL3, 2);\n\n    node.innerComments = _extractCommentsFromL4[0];\n    lastComment = _extractCommentsFromL4[1];\n\n    var _extractCommentsFromL5 = extractCommentsFromList(regex, node.trailingComments, lastComment);\n\n    var _extractCommentsFromL6 = _slicedToArray(_extractCommentsFromL5, 2);\n\n    node.trailingComments = _extractCommentsFromL6[0];\n    lastComment = _extractCommentsFromL6[1];\n  });\n  return lastComment;\n}\n\n0 && 0;","map":{"version":3,"mappings":"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","names":["normalizeFile","_fs","_path","_debug","_t","_convertSourceMap","file","traverseFast","debug","buildDebug","LARGE_INPUT_SOURCEMAP_THRESHOLD","pluginPasses","options","code","ast","type","Error","cloneInputAst","inputMap","inputSourceMap","convertSourceMap","fromObject","lastComment","extractComments","INLINE_SOURCEMAP_REGEX","fromComment","err","EXTERNAL_SOURCEMAP_REGEX","filename","match","exec","inputMapContent","fs","readFileSync","path","resolve","dirname","length","fromJSON","File","extractCommentsFromList","regex","comments","filter","value","test","node","leadingComments","innerComments","trailingComments"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\transformation\\normalize-file.ts"],"sourcesContent":["import fs from \"fs\";\nimport path from \"path\";\nimport buildDebug from \"debug\";\nimport type { Handler } from \"gensync\";\nimport { file, traverseFast } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { PluginPasses } from \"../config\";\nimport convertSourceMap from \"convert-source-map\";\nimport type { SourceMapConverter as Converter } from \"convert-source-map\";\nimport File from \"./file/file\";\nimport parser from \"../parser\";\nimport cloneDeep from \"./util/clone-deep\";\n\nconst debug = buildDebug(\"babel:transform:file\");\nconst LARGE_INPUT_SOURCEMAP_THRESHOLD = 3_000_000;\n\nexport type NormalizedFile = {\n  code: string;\n  ast: t.File;\n  inputMap: Converter | null;\n};\n\nexport default function* normalizeFile(\n  pluginPasses: PluginPasses,\n  options: { [key: string]: any },\n  code: string,\n  ast?: t.File | t.Program | null,\n): Handler<File> {\n  code = `${code || \"\"}`;\n\n  if (ast) {\n    if (ast.type === \"Program\") {\n      ast = file(ast, [], []);\n    } else if (ast.type !== \"File\") {\n      throw new Error(\"AST root must be a Program or File node\");\n    }\n\n    if (options.cloneInputAst) {\n      ast = cloneDeep(ast) as t.File;\n    }\n  } else {\n    // @ts-expect-error todo: use babel-types ast typings in Babel parser\n    ast = yield* parser(pluginPasses, options, code);\n  }\n\n  let inputMap = null;\n  if (options.inputSourceMap !== false) {\n    // If an explicit object is passed in, it overrides the processing of\n    // source maps that may be in the file itself.\n    if (typeof options.inputSourceMap === \"object\") {\n      inputMap = convertSourceMap.fromObject(options.inputSourceMap);\n    }\n\n    if (!inputMap) {\n      const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);\n      if (lastComment) {\n        try {\n          inputMap = convertSourceMap.fromComment(lastComment);\n        } catch (err) {\n          debug(\"discarding unknown inline input sourcemap\", err);\n        }\n      }\n    }\n\n    if (!inputMap) {\n      const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);\n      if (typeof options.filename === \"string\" && lastComment) {\n        try {\n          // when `lastComment` is non-null, EXTERNAL_SOURCEMAP_REGEX must have matches\n          const match: [string, string] = EXTERNAL_SOURCEMAP_REGEX.exec(\n            lastComment,\n          ) as any;\n          const inputMapContent = fs.readFileSync(\n            path.resolve(path.dirname(options.filename), match[1]),\n          );\n          if (inputMapContent.length > LARGE_INPUT_SOURCEMAP_THRESHOLD) {\n            debug(\"skip merging input map > 1 MB\");\n          } else {\n            inputMap = convertSourceMap.fromJSON(\n              // todo:\n              inputMapContent as unknown as string,\n            );\n          }\n        } catch (err) {\n          debug(\"discarding unknown file input sourcemap\", err);\n        }\n      } else if (lastComment) {\n        debug(\"discarding un-loadable file input sourcemap\");\n      }\n    }\n  }\n\n  return new File(options, {\n    code,\n    ast: ast as t.File,\n    inputMap,\n  });\n}\n\n// These regexps are copied from the convert-source-map package,\n// but without // or /* at the beginning of the comment.\n\n// eslint-disable-next-line max-len\nconst INLINE_SOURCEMAP_REGEX =\n  /^[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+?;)?base64,(?:.*)$/;\nconst EXTERNAL_SOURCEMAP_REGEX =\n  /^[@#][ \\t]+sourceMappingURL=([^\\s'\"`]+)[ \\t]*$/;\n\nfunction extractCommentsFromList(\n  regex: RegExp,\n  comments: t.Comment[],\n  lastComment: string | null,\n): [t.Comment[], string | null] {\n  if (comments) {\n    comments = comments.filter(({ value }) => {\n      if (regex.test(value)) {\n        lastComment = value;\n        return false;\n      }\n      return true;\n    });\n  }\n  return [comments, lastComment];\n}\n\nfunction extractComments(regex: RegExp, ast: t.Node) {\n  let lastComment: string = null;\n  traverseFast(ast, node => {\n    [node.leadingComments, lastComment] = extractCommentsFromList(\n      regex,\n      node.leadingComments,\n      lastComment,\n    );\n    [node.innerComments, lastComment] = extractCommentsFromList(\n      regex,\n      node.innerComments,\n      lastComment,\n    );\n    [node.trailingComments, lastComment] = extractCommentsFromList(\n      regex,\n      node.trailingComments,\n      lastComment,\n    );\n  });\n  return lastComment;\n}\n"]},"metadata":{},"sourceType":"script"}