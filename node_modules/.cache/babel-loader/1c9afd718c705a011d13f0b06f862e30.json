{"ast":null,"code":"/* eslint-env jest */\nimport getProp from '../src/getProp';\nconst nodeVersion = parseInt(process.version.match(/^v(\\d+)\\./)[1], 10);\nexport const fallbackToBabylon = nodeVersion < 6;\nlet parserName;\nconst babelParser = fallbackToBabylon ? require('babylon') : require('@babel/parser');\n\nconst flowParser = require('flow-parser');\n\nconst defaultPlugins = ['jsx', 'functionBind', 'estree', 'objectRestSpread', 'optionalChaining' // 'nullishCoalescing', // TODO: update to babel 7\n];\nlet plugins = [...defaultPlugins];\nexport function setParserName(name) {\n  parserName = name;\n}\nexport function changePlugins(pluginOrFn) {\n  if (Array.isArray(pluginOrFn)) {\n    plugins = pluginOrFn;\n  } else if (typeof pluginOrFn === 'function') {\n    plugins = pluginOrFn(plugins);\n  } else {\n    throw new Error('changePlugins argument should be either an array or a function');\n  }\n}\nbeforeEach(() => {\n  plugins = [...defaultPlugins];\n});\n\nfunction parse(code) {\n  if (parserName === undefined) {\n    throw new Error('No parser specified');\n  }\n\n  if (parserName === 'babel') {\n    try {\n      return babelParser.parse(code, {\n        plugins,\n        sourceFilename: 'test.js'\n      });\n    } catch (_) {\n      // eslint-disable-next-line no-console\n      console.warn(`Failed to parse with ${fallbackToBabylon ? 'babylon' : 'Babel'} parser.`);\n    }\n  }\n\n  if (parserName === 'flow') {\n    try {\n      return flowParser.parse(code, {\n        plugins\n      });\n    } catch (_) {\n      // eslint-disable-next-line no-console\n      console.warn('Failed to parse with the Flow parser');\n    }\n  }\n\n  throw new Error(`The parser ${parserName} is not yet supported for testing.`);\n}\n\nexport function getOpeningElement(code) {\n  const parsedCode = parse(code);\n  let body;\n\n  if (parsedCode.program) {\n    // eslint-disable-next-line prefer-destructuring\n    body = parsedCode.program.body;\n  } else {\n    // eslint-disable-next-line prefer-destructuring\n    body = parsedCode.body;\n  }\n\n  if (Array.isArray(body) && body[0] != null) {\n    const [{\n      expression\n    }] = body;\n    return expression.type === 'JSXFragment' ? expression.openingFragment : expression.openingElement;\n  }\n\n  return null;\n}\nexport function extractProp(code) {\n  let prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'foo';\n  const node = getOpeningElement(code);\n  const {\n    attributes: props\n  } = node;\n  return getProp(props, prop);\n}\nexport const describeIfNotBabylon = fallbackToBabylon ? describe.skip : describe;","map":{"version":3,"names":["getProp","nodeVersion","parseInt","process","version","match","fallbackToBabylon","parserName","babelParser","require","flowParser","defaultPlugins","plugins","setParserName","name","changePlugins","pluginOrFn","Array","isArray","Error","beforeEach","parse","code","undefined","sourceFilename","_","console","warn","getOpeningElement","parsedCode","body","program","expression","type","openingFragment","openingElement","extractProp","prop","node","attributes","props","describeIfNotBabylon","describe","skip"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jsx-ast-utils/__tests__/helper.js"],"sourcesContent":["/* eslint-env jest */\nimport getProp from '../src/getProp';\n\nconst nodeVersion = parseInt(process.version.match(/^v(\\d+)\\./)[1], 10);\n\nexport const fallbackToBabylon = nodeVersion < 6;\n\nlet parserName;\nconst babelParser = fallbackToBabylon ? require('babylon') : require('@babel/parser');\nconst flowParser = require('flow-parser');\n\nconst defaultPlugins = [\n  'jsx',\n  'functionBind',\n  'estree',\n  'objectRestSpread',\n  'optionalChaining',\n  // 'nullishCoalescing', // TODO: update to babel 7\n];\nlet plugins = [...defaultPlugins];\n\nexport function setParserName(name) {\n  parserName = name;\n}\n\nexport function changePlugins(pluginOrFn) {\n  if (Array.isArray(pluginOrFn)) {\n    plugins = pluginOrFn;\n  } else if (typeof pluginOrFn === 'function') {\n    plugins = pluginOrFn(plugins);\n  } else {\n    throw new Error('changePlugins argument should be either an array or a function');\n  }\n}\n\nbeforeEach(() => {\n  plugins = [...defaultPlugins];\n});\n\nfunction parse(code) {\n  if (parserName === undefined) {\n    throw new Error('No parser specified');\n  }\n  if (parserName === 'babel') {\n    try {\n      return babelParser.parse(code, { plugins, sourceFilename: 'test.js' });\n    } catch (_) {\n      // eslint-disable-next-line no-console\n      console.warn(`Failed to parse with ${fallbackToBabylon ? 'babylon' : 'Babel'} parser.`);\n    }\n  }\n  if (parserName === 'flow') {\n    try {\n      return flowParser.parse(code, { plugins });\n    } catch (_) {\n      // eslint-disable-next-line no-console\n      console.warn('Failed to parse with the Flow parser');\n    }\n  }\n  throw new Error(`The parser ${parserName} is not yet supported for testing.`);\n}\n\nexport function getOpeningElement(code) {\n  const parsedCode = parse(code);\n  let body;\n  if (parsedCode.program) {\n    // eslint-disable-next-line prefer-destructuring\n    body = parsedCode.program.body;\n  } else {\n    // eslint-disable-next-line prefer-destructuring\n    body = parsedCode.body;\n  }\n  if (Array.isArray(body) && body[0] != null) {\n    const [{ expression }] = body;\n    return expression.type === 'JSXFragment' ? expression.openingFragment : expression.openingElement;\n  }\n\n  return null;\n}\n\nexport function extractProp(code, prop = 'foo') {\n  const node = getOpeningElement(code);\n  const { attributes: props } = node;\n  return getProp(props, prop);\n}\n\nexport const describeIfNotBabylon = fallbackToBabylon ? describe.skip : describe;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}