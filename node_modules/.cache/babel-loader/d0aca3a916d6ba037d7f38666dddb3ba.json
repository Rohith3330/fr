{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst schema = [{\n  enum: ['always', 'never'],\n  type: 'string'\n}, {\n  additionalProperties: false,\n  properties: {\n    annotateUndefined: {\n      enum: ['always', 'never', 'ignore', 'always-enforce'],\n      type: 'string'\n    },\n    excludeArrowFunctions: {\n      enum: [false, true, 'expressionsOnly']\n    },\n    excludeMatching: {\n      items: {\n        type: 'string'\n      },\n      type: 'array'\n    },\n    includeOnlyMatching: {\n      items: {\n        type: 'string'\n      },\n      type: 'array'\n    }\n  },\n  type: 'object'\n}];\n\nconst makeRegExp = str => {\n  return new RegExp(str, 'u');\n};\n\nconst isUndefinedReturnType = returnNode => {\n  return returnNode.argument === null || returnNode.argument.name === 'undefined' || returnNode.argument.operator === 'void';\n};\n\nconst create = context => {\n  const annotateReturn = (_lodash.default.get(context, 'options[0]') || 'always') === 'always';\n  const annotateUndefined = _lodash.default.get(context, 'options[1].annotateUndefined') || 'never';\n  const skipArrows = _lodash.default.get(context, 'options[1].excludeArrowFunctions') || false; // eslint-disable-next-line unicorn/no-array-callback-reference\n\n  const excludeMatching = _lodash.default.get(context, 'options[1].excludeMatching', []).map(makeRegExp); // eslint-disable-next-line unicorn/no-array-callback-reference\n\n\n  const includeOnlyMatching = _lodash.default.get(context, 'options[1].includeOnlyMatching', []).map(makeRegExp);\n\n  const targetNodes = [];\n\n  const registerFunction = functionNode => {\n    targetNodes.push({\n      functionNode\n    });\n  };\n\n  const getIsReturnTypeAnnotationUndefined = targetNode => {\n    const isReturnTypeAnnotationLiteralUndefined = _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.id.name') === 'undefined' && _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.type') === 'GenericTypeAnnotation';\n    const isReturnTypeAnnotationVoid = _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.type') === 'VoidTypeAnnotation';\n    const isAsyncReturnTypeAnnotationVoid = _lodash.default.get(targetNode, 'functionNode.async') && _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.id.name') === 'Promise' && (_lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.typeParameters.params[0].type') === 'VoidTypeAnnotation' || _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.typeParameters.params[0].id.name') === 'undefined' && _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.typeParameters.params[0].type') === 'GenericTypeAnnotation');\n    return isReturnTypeAnnotationLiteralUndefined || isReturnTypeAnnotationVoid || isAsyncReturnTypeAnnotationVoid;\n  };\n\n  const shouldFilterNode = functionNode => {\n    const isArrow = functionNode.type === 'ArrowFunctionExpression';\n    const isMethod = functionNode.parent && functionNode.parent.type === 'MethodDefinition';\n    const propertyNodes = ['Property', 'ClassProperty'];\n    const isProperty = functionNode.parent && propertyNodes.includes(functionNode.parent.type);\n    let selector;\n\n    if (isMethod || isProperty) {\n      selector = 'parent.key.name';\n    } else if (isArrow) {\n      selector = 'parent.id.name';\n    } else {\n      selector = 'id.name';\n    }\n\n    const identifierName = _lodash.default.get(functionNode, selector);\n\n    const checkRegExp = regex => {\n      return regex.test(identifierName);\n    };\n\n    if (excludeMatching.length && _lodash.default.some(excludeMatching, checkRegExp)) {\n      return true;\n    }\n\n    if (includeOnlyMatching.length && !_lodash.default.some(includeOnlyMatching, checkRegExp)) {\n      return true;\n    }\n\n    return false;\n  }; // eslint-disable-next-line complexity\n\n\n  const evaluateFunction = functionNode => {\n    const targetNode = targetNodes.pop();\n\n    if (functionNode !== targetNode.functionNode) {\n      throw new Error('Mismatch.');\n    }\n\n    const isArrow = functionNode.type === 'ArrowFunctionExpression';\n    const isArrowFunctionExpression = functionNode.expression;\n    const isFunctionReturnUndefined = !isArrowFunctionExpression && !functionNode.generator && (!targetNode.returnStatementNode || isUndefinedReturnType(targetNode.returnStatementNode));\n    const isReturnTypeAnnotationUndefined = getIsReturnTypeAnnotationUndefined(targetNode);\n\n    if (skipArrows === 'expressionsOnly' && isArrowFunctionExpression || skipArrows === true && isArrow || shouldFilterNode(functionNode)) {\n      return;\n    }\n\n    const returnType = functionNode.returnType || isArrow && _lodash.default.get(functionNode, 'parent.id.typeAnnotation');\n\n    if (isFunctionReturnUndefined && isReturnTypeAnnotationUndefined && annotateUndefined === 'never') {\n      context.report({\n        message: 'Must not annotate undefined return type.',\n        node: functionNode\n      });\n    } else if (isFunctionReturnUndefined && !isReturnTypeAnnotationUndefined && annotateUndefined === 'always') {\n      context.report({\n        message: 'Must annotate undefined return type.',\n        node: functionNode\n      });\n    } else if ((annotateUndefined === 'always-enforce' || !isFunctionReturnUndefined && !isReturnTypeAnnotationUndefined) && annotateReturn && !returnType && !shouldFilterNode(functionNode)) {\n      context.report({\n        message: 'Missing return type annotation.',\n        node: functionNode\n      });\n    }\n  };\n\n  const evaluateNoise = () => {\n    targetNodes.pop();\n  };\n\n  return {\n    ArrowFunctionExpression: registerFunction,\n    'ArrowFunctionExpression:exit': evaluateFunction,\n    ClassDeclaration: registerFunction,\n    'ClassDeclaration:exit': evaluateNoise,\n    ClassExpression: registerFunction,\n    'ClassExpression:exit': evaluateNoise,\n    FunctionDeclaration: registerFunction,\n    'FunctionDeclaration:exit': evaluateFunction,\n    FunctionExpression: registerFunction,\n    'FunctionExpression:exit': evaluateFunction,\n    ReturnStatement: node => {\n      if (targetNodes.length) {\n        targetNodes[targetNodes.length - 1].returnStatementNode = node;\n      }\n    }\n  };\n};\n\nvar _default = {\n  create,\n  schema\n};\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_lodash","_interopRequireDefault","require","obj","__esModule","schema","enum","type","additionalProperties","properties","annotateUndefined","excludeArrowFunctions","excludeMatching","items","includeOnlyMatching","makeRegExp","str","RegExp","isUndefinedReturnType","returnNode","argument","name","operator","create","context","annotateReturn","get","skipArrows","map","targetNodes","registerFunction","functionNode","push","getIsReturnTypeAnnotationUndefined","targetNode","isReturnTypeAnnotationLiteralUndefined","isReturnTypeAnnotationVoid","isAsyncReturnTypeAnnotationVoid","shouldFilterNode","isArrow","isMethod","parent","propertyNodes","isProperty","includes","selector","identifierName","checkRegExp","regex","test","length","some","evaluateFunction","pop","Error","isArrowFunctionExpression","expression","isFunctionReturnUndefined","generator","returnStatementNode","isReturnTypeAnnotationUndefined","returnType","report","message","node","evaluateNoise","ArrowFunctionExpression","ClassDeclaration","ClassExpression","FunctionDeclaration","FunctionExpression","ReturnStatement","_default","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-flowtype/dist/rules/requireReturnType.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst schema = [{\n  enum: ['always', 'never'],\n  type: 'string'\n}, {\n  additionalProperties: false,\n  properties: {\n    annotateUndefined: {\n      enum: ['always', 'never', 'ignore', 'always-enforce'],\n      type: 'string'\n    },\n    excludeArrowFunctions: {\n      enum: [false, true, 'expressionsOnly']\n    },\n    excludeMatching: {\n      items: {\n        type: 'string'\n      },\n      type: 'array'\n    },\n    includeOnlyMatching: {\n      items: {\n        type: 'string'\n      },\n      type: 'array'\n    }\n  },\n  type: 'object'\n}];\n\nconst makeRegExp = str => {\n  return new RegExp(str, 'u');\n};\n\nconst isUndefinedReturnType = returnNode => {\n  return returnNode.argument === null || returnNode.argument.name === 'undefined' || returnNode.argument.operator === 'void';\n};\n\nconst create = context => {\n  const annotateReturn = (_lodash.default.get(context, 'options[0]') || 'always') === 'always';\n  const annotateUndefined = _lodash.default.get(context, 'options[1].annotateUndefined') || 'never';\n  const skipArrows = _lodash.default.get(context, 'options[1].excludeArrowFunctions') || false; // eslint-disable-next-line unicorn/no-array-callback-reference\n\n  const excludeMatching = _lodash.default.get(context, 'options[1].excludeMatching', []).map(makeRegExp); // eslint-disable-next-line unicorn/no-array-callback-reference\n\n\n  const includeOnlyMatching = _lodash.default.get(context, 'options[1].includeOnlyMatching', []).map(makeRegExp);\n\n  const targetNodes = [];\n\n  const registerFunction = functionNode => {\n    targetNodes.push({\n      functionNode\n    });\n  };\n\n  const getIsReturnTypeAnnotationUndefined = targetNode => {\n    const isReturnTypeAnnotationLiteralUndefined = _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.id.name') === 'undefined' && _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.type') === 'GenericTypeAnnotation';\n    const isReturnTypeAnnotationVoid = _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.type') === 'VoidTypeAnnotation';\n    const isAsyncReturnTypeAnnotationVoid = _lodash.default.get(targetNode, 'functionNode.async') && _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.id.name') === 'Promise' && (_lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.typeParameters.params[0].type') === 'VoidTypeAnnotation' || _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.typeParameters.params[0].id.name') === 'undefined' && _lodash.default.get(targetNode, 'functionNode.returnType.typeAnnotation.typeParameters.params[0].type') === 'GenericTypeAnnotation');\n    return isReturnTypeAnnotationLiteralUndefined || isReturnTypeAnnotationVoid || isAsyncReturnTypeAnnotationVoid;\n  };\n\n  const shouldFilterNode = functionNode => {\n    const isArrow = functionNode.type === 'ArrowFunctionExpression';\n    const isMethod = functionNode.parent && functionNode.parent.type === 'MethodDefinition';\n    const propertyNodes = ['Property', 'ClassProperty'];\n    const isProperty = functionNode.parent && propertyNodes.includes(functionNode.parent.type);\n    let selector;\n\n    if (isMethod || isProperty) {\n      selector = 'parent.key.name';\n    } else if (isArrow) {\n      selector = 'parent.id.name';\n    } else {\n      selector = 'id.name';\n    }\n\n    const identifierName = _lodash.default.get(functionNode, selector);\n\n    const checkRegExp = regex => {\n      return regex.test(identifierName);\n    };\n\n    if (excludeMatching.length && _lodash.default.some(excludeMatching, checkRegExp)) {\n      return true;\n    }\n\n    if (includeOnlyMatching.length && !_lodash.default.some(includeOnlyMatching, checkRegExp)) {\n      return true;\n    }\n\n    return false;\n  }; // eslint-disable-next-line complexity\n\n\n  const evaluateFunction = functionNode => {\n    const targetNode = targetNodes.pop();\n\n    if (functionNode !== targetNode.functionNode) {\n      throw new Error('Mismatch.');\n    }\n\n    const isArrow = functionNode.type === 'ArrowFunctionExpression';\n    const isArrowFunctionExpression = functionNode.expression;\n    const isFunctionReturnUndefined = !isArrowFunctionExpression && !functionNode.generator && (!targetNode.returnStatementNode || isUndefinedReturnType(targetNode.returnStatementNode));\n    const isReturnTypeAnnotationUndefined = getIsReturnTypeAnnotationUndefined(targetNode);\n\n    if (skipArrows === 'expressionsOnly' && isArrowFunctionExpression || skipArrows === true && isArrow || shouldFilterNode(functionNode)) {\n      return;\n    }\n\n    const returnType = functionNode.returnType || isArrow && _lodash.default.get(functionNode, 'parent.id.typeAnnotation');\n\n    if (isFunctionReturnUndefined && isReturnTypeAnnotationUndefined && annotateUndefined === 'never') {\n      context.report({\n        message: 'Must not annotate undefined return type.',\n        node: functionNode\n      });\n    } else if (isFunctionReturnUndefined && !isReturnTypeAnnotationUndefined && annotateUndefined === 'always') {\n      context.report({\n        message: 'Must annotate undefined return type.',\n        node: functionNode\n      });\n    } else if ((annotateUndefined === 'always-enforce' || !isFunctionReturnUndefined && !isReturnTypeAnnotationUndefined) && annotateReturn && !returnType && !shouldFilterNode(functionNode)) {\n      context.report({\n        message: 'Missing return type annotation.',\n        node: functionNode\n      });\n    }\n  };\n\n  const evaluateNoise = () => {\n    targetNodes.pop();\n  };\n\n  return {\n    ArrowFunctionExpression: registerFunction,\n    'ArrowFunctionExpression:exit': evaluateFunction,\n    ClassDeclaration: registerFunction,\n    'ClassDeclaration:exit': evaluateNoise,\n    ClassExpression: registerFunction,\n    'ClassExpression:exit': evaluateNoise,\n    FunctionDeclaration: registerFunction,\n    'FunctionDeclaration:exit': evaluateFunction,\n    FunctionExpression: registerFunction,\n    'FunctionExpression:exit': evaluateFunction,\n    ReturnStatement: node => {\n      if (targetNodes.length) {\n        targetNodes[targetNodes.length - 1].returnStatementNode = node;\n      }\n    }\n  };\n};\n\nvar _default = {\n  create,\n  schema\n};\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,OAAO,GAAGC,sBAAsB,CAACC,OAAO,CAAC,QAAD,CAAR,CAApC;;AAEA,SAASD,sBAAT,CAAgCE,GAAhC,EAAqC;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;IAAEJ,OAAO,EAAEI;EAAX,CAArC;AAAwD;;AAE/F,MAAME,MAAM,GAAG,CAAC;EACdC,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX,CADQ;EAEdC,IAAI,EAAE;AAFQ,CAAD,EAGZ;EACDC,oBAAoB,EAAE,KADrB;EAEDC,UAAU,EAAE;IACVC,iBAAiB,EAAE;MACjBJ,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX,EAAoB,QAApB,EAA8B,gBAA9B,CADW;MAEjBC,IAAI,EAAE;IAFW,CADT;IAKVI,qBAAqB,EAAE;MACrBL,IAAI,EAAE,CAAC,KAAD,EAAQ,IAAR,EAAc,iBAAd;IADe,CALb;IAQVM,eAAe,EAAE;MACfC,KAAK,EAAE;QACLN,IAAI,EAAE;MADD,CADQ;MAIfA,IAAI,EAAE;IAJS,CARP;IAcVO,mBAAmB,EAAE;MACnBD,KAAK,EAAE;QACLN,IAAI,EAAE;MADD,CADY;MAInBA,IAAI,EAAE;IAJa;EAdX,CAFX;EAuBDA,IAAI,EAAE;AAvBL,CAHY,CAAf;;AA6BA,MAAMQ,UAAU,GAAGC,GAAG,IAAI;EACxB,OAAO,IAAIC,MAAJ,CAAWD,GAAX,EAAgB,GAAhB,CAAP;AACD,CAFD;;AAIA,MAAME,qBAAqB,GAAGC,UAAU,IAAI;EAC1C,OAAOA,UAAU,CAACC,QAAX,KAAwB,IAAxB,IAAgCD,UAAU,CAACC,QAAX,CAAoBC,IAApB,KAA6B,WAA7D,IAA4EF,UAAU,CAACC,QAAX,CAAoBE,QAApB,KAAiC,MAApH;AACD,CAFD;;AAIA,MAAMC,MAAM,GAAGC,OAAO,IAAI;EACxB,MAAMC,cAAc,GAAG,CAACzB,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBF,OAApB,EAA6B,YAA7B,KAA8C,QAA/C,MAA6D,QAApF;EACA,MAAMd,iBAAiB,GAAGV,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBF,OAApB,EAA6B,8BAA7B,KAAgE,OAA1F;EACA,MAAMG,UAAU,GAAG3B,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBF,OAApB,EAA6B,kCAA7B,KAAoE,KAAvF,CAHwB,CAGsE;;EAE9F,MAAMZ,eAAe,GAAGZ,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBF,OAApB,EAA6B,4BAA7B,EAA2D,EAA3D,EAA+DI,GAA/D,CAAmEb,UAAnE,CAAxB,CALwB,CAKgF;;;EAGxG,MAAMD,mBAAmB,GAAGd,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBF,OAApB,EAA6B,gCAA7B,EAA+D,EAA/D,EAAmEI,GAAnE,CAAuEb,UAAvE,CAA5B;;EAEA,MAAMc,WAAW,GAAG,EAApB;;EAEA,MAAMC,gBAAgB,GAAGC,YAAY,IAAI;IACvCF,WAAW,CAACG,IAAZ,CAAiB;MACfD;IADe,CAAjB;EAGD,CAJD;;EAMA,MAAME,kCAAkC,GAAGC,UAAU,IAAI;IACvD,MAAMC,sCAAsC,GAAGnC,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBQ,UAApB,EAAgC,gDAAhC,MAAsF,WAAtF,IAAqGlC,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBQ,UAApB,EAAgC,6CAAhC,MAAmF,uBAAvO;IACA,MAAME,0BAA0B,GAAGpC,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBQ,UAApB,EAAgC,6CAAhC,MAAmF,oBAAtH;IACA,MAAMG,+BAA+B,GAAGrC,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBQ,UAApB,EAAgC,oBAAhC,KAAyDlC,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBQ,UAApB,EAAgC,gDAAhC,MAAsF,SAA/I,KAA6JlC,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBQ,UAApB,EAAgC,sEAAhC,MAA4G,oBAA5G,IAAoIlC,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBQ,UAApB,EAAgC,yEAAhC,MAA+G,WAA/G,IAA8HlC,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBQ,UAApB,EAAgC,sEAAhC,MAA4G,uBAA3gB,CAAxC;IACA,OAAOC,sCAAsC,IAAIC,0BAA1C,IAAwEC,+BAA/E;EACD,CALD;;EAOA,MAAMC,gBAAgB,GAAGP,YAAY,IAAI;IACvC,MAAMQ,OAAO,GAAGR,YAAY,CAACxB,IAAb,KAAsB,yBAAtC;IACA,MAAMiC,QAAQ,GAAGT,YAAY,CAACU,MAAb,IAAuBV,YAAY,CAACU,MAAb,CAAoBlC,IAApB,KAA6B,kBAArE;IACA,MAAMmC,aAAa,GAAG,CAAC,UAAD,EAAa,eAAb,CAAtB;IACA,MAAMC,UAAU,GAAGZ,YAAY,CAACU,MAAb,IAAuBC,aAAa,CAACE,QAAd,CAAuBb,YAAY,CAACU,MAAb,CAAoBlC,IAA3C,CAA1C;IACA,IAAIsC,QAAJ;;IAEA,IAAIL,QAAQ,IAAIG,UAAhB,EAA4B;MAC1BE,QAAQ,GAAG,iBAAX;IACD,CAFD,MAEO,IAAIN,OAAJ,EAAa;MAClBM,QAAQ,GAAG,gBAAX;IACD,CAFM,MAEA;MACLA,QAAQ,GAAG,SAAX;IACD;;IAED,MAAMC,cAAc,GAAG9C,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBK,YAApB,EAAkCc,QAAlC,CAAvB;;IAEA,MAAME,WAAW,GAAGC,KAAK,IAAI;MAC3B,OAAOA,KAAK,CAACC,IAAN,CAAWH,cAAX,CAAP;IACD,CAFD;;IAIA,IAAIlC,eAAe,CAACsC,MAAhB,IAA0BlD,OAAO,CAACD,OAAR,CAAgBoD,IAAhB,CAAqBvC,eAArB,EAAsCmC,WAAtC,CAA9B,EAAkF;MAChF,OAAO,IAAP;IACD;;IAED,IAAIjC,mBAAmB,CAACoC,MAApB,IAA8B,CAAClD,OAAO,CAACD,OAAR,CAAgBoD,IAAhB,CAAqBrC,mBAArB,EAA0CiC,WAA1C,CAAnC,EAA2F;MACzF,OAAO,IAAP;IACD;;IAED,OAAO,KAAP;EACD,CA9BD,CAzBwB,CAuDrB;;;EAGH,MAAMK,gBAAgB,GAAGrB,YAAY,IAAI;IACvC,MAAMG,UAAU,GAAGL,WAAW,CAACwB,GAAZ,EAAnB;;IAEA,IAAItB,YAAY,KAAKG,UAAU,CAACH,YAAhC,EAA8C;MAC5C,MAAM,IAAIuB,KAAJ,CAAU,WAAV,CAAN;IACD;;IAED,MAAMf,OAAO,GAAGR,YAAY,CAACxB,IAAb,KAAsB,yBAAtC;IACA,MAAMgD,yBAAyB,GAAGxB,YAAY,CAACyB,UAA/C;IACA,MAAMC,yBAAyB,GAAG,CAACF,yBAAD,IAA8B,CAACxB,YAAY,CAAC2B,SAA5C,KAA0D,CAACxB,UAAU,CAACyB,mBAAZ,IAAmCzC,qBAAqB,CAACgB,UAAU,CAACyB,mBAAZ,CAAlH,CAAlC;IACA,MAAMC,+BAA+B,GAAG3B,kCAAkC,CAACC,UAAD,CAA1E;;IAEA,IAAIP,UAAU,KAAK,iBAAf,IAAoC4B,yBAApC,IAAiE5B,UAAU,KAAK,IAAf,IAAuBY,OAAxF,IAAmGD,gBAAgB,CAACP,YAAD,CAAvH,EAAuI;MACrI;IACD;;IAED,MAAM8B,UAAU,GAAG9B,YAAY,CAAC8B,UAAb,IAA2BtB,OAAO,IAAIvC,OAAO,CAACD,OAAR,CAAgB2B,GAAhB,CAAoBK,YAApB,EAAkC,0BAAlC,CAAzD;;IAEA,IAAI0B,yBAAyB,IAAIG,+BAA7B,IAAgElD,iBAAiB,KAAK,OAA1F,EAAmG;MACjGc,OAAO,CAACsC,MAAR,CAAe;QACbC,OAAO,EAAE,0CADI;QAEbC,IAAI,EAAEjC;MAFO,CAAf;IAID,CALD,MAKO,IAAI0B,yBAAyB,IAAI,CAACG,+BAA9B,IAAiElD,iBAAiB,KAAK,QAA3F,EAAqG;MAC1Gc,OAAO,CAACsC,MAAR,CAAe;QACbC,OAAO,EAAE,sCADI;QAEbC,IAAI,EAAEjC;MAFO,CAAf;IAID,CALM,MAKA,IAAI,CAACrB,iBAAiB,KAAK,gBAAtB,IAA0C,CAAC+C,yBAAD,IAA8B,CAACG,+BAA1E,KAA8GnC,cAA9G,IAAgI,CAACoC,UAAjI,IAA+I,CAACvB,gBAAgB,CAACP,YAAD,CAApK,EAAoL;MACzLP,OAAO,CAACsC,MAAR,CAAe;QACbC,OAAO,EAAE,iCADI;QAEbC,IAAI,EAAEjC;MAFO,CAAf;IAID;EACF,CAlCD;;EAoCA,MAAMkC,aAAa,GAAG,MAAM;IAC1BpC,WAAW,CAACwB,GAAZ;EACD,CAFD;;EAIA,OAAO;IACLa,uBAAuB,EAAEpC,gBADpB;IAEL,gCAAgCsB,gBAF3B;IAGLe,gBAAgB,EAAErC,gBAHb;IAIL,yBAAyBmC,aAJpB;IAKLG,eAAe,EAAEtC,gBALZ;IAML,wBAAwBmC,aANnB;IAOLI,mBAAmB,EAAEvC,gBAPhB;IAQL,4BAA4BsB,gBARvB;IASLkB,kBAAkB,EAAExC,gBATf;IAUL,2BAA2BsB,gBAVtB;IAWLmB,eAAe,EAAEP,IAAI,IAAI;MACvB,IAAInC,WAAW,CAACqB,MAAhB,EAAwB;QACtBrB,WAAW,CAACA,WAAW,CAACqB,MAAZ,GAAqB,CAAtB,CAAX,CAAoCS,mBAApC,GAA0DK,IAA1D;MACD;IACF;EAfI,CAAP;AAiBD,CAnHD;;AAqHA,IAAIQ,QAAQ,GAAG;EACbjD,MADa;EAEblB;AAFa,CAAf;AAIAR,OAAO,CAACE,OAAR,GAAkByE,QAAlB;AACAC,MAAM,CAAC5E,OAAP,GAAiBA,OAAO,CAACE,OAAzB"},"metadata":{},"sourceType":"script"}