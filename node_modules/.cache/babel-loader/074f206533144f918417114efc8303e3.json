{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _cssSyntaxError = _interopRequireDefault(require(\"./css-syntax-error\"));\n\nvar _previousMap = _interopRequireDefault(require(\"./previous-map\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar sequence = 0;\n/**\n * Represents the source CSS.\n *\n * @example\n * const root  = postcss.parse(css, { from: file })\n * const input = root.source.input\n */\n\nvar Input = /*#__PURE__*/function () {\n  /**\n   * @param {string} css    Input CSS source.\n   * @param {object} [opts] {@link Processor#process} options.\n   */\n  function Input(css, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (css === null || typeof css === 'undefined' || typeof css === 'object' && !css.toString) {\n      throw new Error(\"PostCSS received \" + css + \" instead of CSS string\");\n    }\n    /**\n     * Input CSS source\n     *\n     * @type {string}\n     *\n     * @example\n     * const input = postcss.parse('a{}', { from: file }).input\n     * input.css //=> \"a{}\"\n     */\n\n\n    this.css = css.toString();\n\n    if (this.css[0] === \"\\uFEFF\" || this.css[0] === \"\\uFFFE\") {\n      this.hasBOM = true;\n      this.css = this.css.slice(1);\n    } else {\n      this.hasBOM = false;\n    }\n\n    if (opts.from) {\n      if (/^\\w+:\\/\\//.test(opts.from) || _path.default.isAbsolute(opts.from)) {\n        /**\n         * The absolute path to the CSS source file defined\n         * with the `from` option.\n         *\n         * @type {string}\n         *\n         * @example\n         * const root = postcss.parse(css, { from: 'a.css' })\n         * root.source.input.file //=> '/home/ai/a.css'\n         */\n        this.file = opts.from;\n      } else {\n        this.file = _path.default.resolve(opts.from);\n      }\n    }\n\n    var map = new _previousMap.default(this.css, opts);\n\n    if (map.text) {\n      /**\n       * The input source map passed from a compilation step before PostCSS\n       * (for example, from Sass compiler).\n       *\n       * @type {PreviousMap}\n       *\n       * @example\n       * root.source.input.map.consumer().sources //=> ['a.sass']\n       */\n      this.map = map;\n      var file = map.consumer().file;\n      if (!this.file && file) this.file = this.mapResolve(file);\n    }\n\n    if (!this.file) {\n      sequence += 1;\n      /**\n       * The unique ID of the CSS source. It will be created if `from` option\n       * is not provided (because PostCSS does not know the file path).\n       *\n       * @type {string}\n       *\n       * @example\n       * const root = postcss.parse(css)\n       * root.source.input.file //=> undefined\n       * root.source.input.id   //=> \"<input css 1>\"\n       */\n\n      this.id = '<input css ' + sequence + '>';\n    }\n\n    if (this.map) this.map.file = this.from;\n  }\n\n  var _proto = Input.prototype;\n\n  _proto.error = function error(message, line, column, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    var result;\n    var origin = this.origin(line, column);\n\n    if (origin) {\n      result = new _cssSyntaxError.default(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);\n    } else {\n      result = new _cssSyntaxError.default(message, line, column, this.css, this.file, opts.plugin);\n    }\n\n    result.input = {\n      line: line,\n      column: column,\n      source: this.css\n    };\n    if (this.file) result.input.file = this.file;\n    return result;\n  }\n  /**\n   * Reads the input source map and returns a symbol position\n   * in the input source (e.g., in a Sass file that was compiled\n   * to CSS before being passed to PostCSS).\n   *\n   * @param {number} line   Line in input CSS.\n   * @param {number} column Column in input CSS.\n   *\n   * @return {filePosition} Position in input source.\n   *\n   * @example\n   * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }\n   */\n  ;\n\n  _proto.origin = function origin(line, column) {\n    if (!this.map) return false;\n    var consumer = this.map.consumer();\n    var from = consumer.originalPositionFor({\n      line: line,\n      column: column\n    });\n    if (!from.source) return false;\n    var result = {\n      file: this.mapResolve(from.source),\n      line: from.line,\n      column: from.column\n    };\n    var source = consumer.sourceContentFor(from.source);\n    if (source) result.source = source;\n    return result;\n  };\n\n  _proto.mapResolve = function mapResolve(file) {\n    if (/^\\w+:\\/\\//.test(file)) {\n      return file;\n    }\n\n    return _path.default.resolve(this.map.consumer().sourceRoot || '.', file);\n  }\n  /**\n   * The CSS source identifier. Contains {@link Input#file} if the user\n   * set the `from` option, or {@link Input#id} if they did not.\n   *\n   * @type {string}\n   *\n   * @example\n   * const root = postcss.parse(css, { from: 'a.css' })\n   * root.source.input.from //=> \"/home/ai/a.css\"\n   *\n   * const root = postcss.parse(css)\n   * root.source.input.from //=> \"<input css 1>\"\n   */\n  ;\n\n  _createClass(Input, [{\n    key: \"from\",\n    get: function get() {\n      return this.file || this.id;\n    }\n  }]);\n\n  return Input;\n}();\n\nvar _default = Input;\n/**\n * @typedef  {object} filePosition\n * @property {string} file   Path to file.\n * @property {number} line   Source line in file.\n * @property {number} column Source column in file.\n */\n\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"mappings":"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","names":["sequence","Input","css","opts","toString","Error","hasBOM","slice","from","test","path","isAbsolute","file","resolve","map","PreviousMap","text","consumer","mapResolve","id","error","message","line","column","result","origin","CssSyntaxError","source","plugin","input","originalPositionFor","sourceContentFor","sourceRoot"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\resolve-url-loader\\node_modules\\postcss\\lib\\input.es6"],"sourcesContent":["import path from 'path'\n\nimport CssSyntaxError from './css-syntax-error'\nimport PreviousMap from './previous-map'\n\nlet sequence = 0\n\n/**\n * Represents the source CSS.\n *\n * @example\n * const root  = postcss.parse(css, { from: file })\n * const input = root.source.input\n */\nclass Input {\n  /**\n   * @param {string} css    Input CSS source.\n   * @param {object} [opts] {@link Processor#process} options.\n   */\n  constructor (css, opts = { }) {\n    if (\n      css === null ||\n      typeof css === 'undefined' ||\n      (typeof css === 'object' && !css.toString)\n    ) {\n      throw new Error(`PostCSS received ${ css } instead of CSS string`)\n    }\n\n    /**\n     * Input CSS source\n     *\n     * @type {string}\n     *\n     * @example\n     * const input = postcss.parse('a{}', { from: file }).input\n     * input.css //=> \"a{}\"\n     */\n    this.css = css.toString()\n\n    if (this.css[0] === '\\uFEFF' || this.css[0] === '\\uFFFE') {\n      this.hasBOM = true\n      this.css = this.css.slice(1)\n    } else {\n      this.hasBOM = false\n    }\n\n    if (opts.from) {\n      if (/^\\w+:\\/\\//.test(opts.from) || path.isAbsolute(opts.from)) {\n        /**\n         * The absolute path to the CSS source file defined\n         * with the `from` option.\n         *\n         * @type {string}\n         *\n         * @example\n         * const root = postcss.parse(css, { from: 'a.css' })\n         * root.source.input.file //=> '/home/ai/a.css'\n         */\n        this.file = opts.from\n      } else {\n        this.file = path.resolve(opts.from)\n      }\n    }\n\n    let map = new PreviousMap(this.css, opts)\n    if (map.text) {\n      /**\n       * The input source map passed from a compilation step before PostCSS\n       * (for example, from Sass compiler).\n       *\n       * @type {PreviousMap}\n       *\n       * @example\n       * root.source.input.map.consumer().sources //=> ['a.sass']\n       */\n      this.map = map\n      let file = map.consumer().file\n      if (!this.file && file) this.file = this.mapResolve(file)\n    }\n\n    if (!this.file) {\n      sequence += 1\n      /**\n       * The unique ID of the CSS source. It will be created if `from` option\n       * is not provided (because PostCSS does not know the file path).\n       *\n       * @type {string}\n       *\n       * @example\n       * const root = postcss.parse(css)\n       * root.source.input.file //=> undefined\n       * root.source.input.id   //=> \"<input css 1>\"\n       */\n      this.id = '<input css ' + sequence + '>'\n    }\n    if (this.map) this.map.file = this.from\n  }\n\n  error (message, line, column, opts = { }) {\n    let result\n    let origin = this.origin(line, column)\n    if (origin) {\n      result = new CssSyntaxError(\n        message, origin.line, origin.column,\n        origin.source, origin.file, opts.plugin\n      )\n    } else {\n      result = new CssSyntaxError(\n        message, line, column, this.css, this.file, opts.plugin)\n    }\n\n    result.input = { line, column, source: this.css }\n    if (this.file) result.input.file = this.file\n\n    return result\n  }\n\n  /**\n   * Reads the input source map and returns a symbol position\n   * in the input source (e.g., in a Sass file that was compiled\n   * to CSS before being passed to PostCSS).\n   *\n   * @param {number} line   Line in input CSS.\n   * @param {number} column Column in input CSS.\n   *\n   * @return {filePosition} Position in input source.\n   *\n   * @example\n   * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }\n   */\n  origin (line, column) {\n    if (!this.map) return false\n    let consumer = this.map.consumer()\n\n    let from = consumer.originalPositionFor({ line, column })\n    if (!from.source) return false\n\n    let result = {\n      file: this.mapResolve(from.source),\n      line: from.line,\n      column: from.column\n    }\n\n    let source = consumer.sourceContentFor(from.source)\n    if (source) result.source = source\n\n    return result\n  }\n\n  mapResolve (file) {\n    if (/^\\w+:\\/\\//.test(file)) {\n      return file\n    }\n    return path.resolve(this.map.consumer().sourceRoot || '.', file)\n  }\n\n  /**\n   * The CSS source identifier. Contains {@link Input#file} if the user\n   * set the `from` option, or {@link Input#id} if they did not.\n   *\n   * @type {string}\n   *\n   * @example\n   * const root = postcss.parse(css, { from: 'a.css' })\n   * root.source.input.from //=> \"/home/ai/a.css\"\n   *\n   * const root = postcss.parse(css)\n   * root.source.input.from //=> \"<input css 1>\"\n   */\n  get from () {\n    return this.file || this.id\n  }\n}\n\nexport default Input\n\n/**\n * @typedef  {object} filePosition\n * @property {string} file   Path to file.\n * @property {number} line   Source line in file.\n * @property {number} column Source column in file.\n */\n"]},"metadata":{},"sourceType":"script"}