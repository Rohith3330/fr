{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\"use strict\";\n\nimport assert from \"assert\";\nimport { hoist } from \"./hoist\";\nimport { Emitter } from \"./emit\";\nimport replaceShorthandObjectMethod from \"./replaceShorthandObjectMethod\";\nimport * as util from \"./util\";\n\nexports.getVisitor = _ref => {\n  let {\n    types: t\n  } = _ref;\n  return {\n    Method(path, state) {\n      let node = path.node;\n      if (!shouldRegenerate(node, state)) return;\n      const container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);\n      path.get(\"body\").set(\"body\", [t.returnStatement(t.callExpression(container, []))]); // Regardless of whether or not the wrapped function is a an async method\n      // or generator the outer function should not be\n\n      node.async = false;\n      node.generator = false; // Unwrap the wrapper IIFE's environment so super and this and such still work.\n\n      path.get(\"body.body.0.argument.callee\").unwrapFunctionEnvironment();\n    },\n\n    Function: {\n      exit: util.wrapWithTypes(t, function (path, state) {\n        let node = path.node;\n        if (!shouldRegenerate(node, state)) return; // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n\n        path = replaceShorthandObjectMethod(path);\n        node = path.node;\n        let contextId = path.scope.generateUidIdentifier(\"context\");\n        let argsId = path.scope.generateUidIdentifier(\"args\");\n        path.ensureBlock();\n        let bodyBlockPath = path.get(\"body\");\n\n        if (node.async) {\n          bodyBlockPath.traverse(awaitVisitor);\n        }\n\n        bodyBlockPath.traverse(functionSentVisitor, {\n          context: contextId\n        });\n        let outerBody = [];\n        let innerBody = [];\n        bodyBlockPath.get(\"body\").forEach(function (childPath) {\n          let node = childPath.node;\n\n          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {\n            // Babylon represents directives like \"use strict\" as elements\n            // of a bodyBlockPath.node.directives array, but they could just\n            // as easily be represented (by other parsers) as traditional\n            // string-literal-valued expression statements, so we need to\n            // handle that here. (#248)\n            outerBody.push(node);\n          } else if (node && node._blockHoist != null) {\n            outerBody.push(node);\n          } else {\n            innerBody.push(node);\n          }\n        });\n\n        if (outerBody.length > 0) {\n          // Only replace the inner body if we actually hoisted any statements\n          // to the outer body.\n          bodyBlockPath.node.body = innerBody;\n        }\n\n        let outerFnExpr = getOuterFnExpr(path); // Note that getOuterFnExpr has the side-effect of ensuring that the\n        // function has a name (so node.id will always be an Identifier), even\n        // if a temporary name has to be synthesized.\n\n        t.assertIdentifier(node.id);\n        let innerFnId = t.identifier(node.id.name + \"$\"); // Turn all declarations into vars, and replace the original\n        // declarations with equivalent assignment expressions.\n\n        let vars = hoist(path);\n        let context = {\n          usesThis: false,\n          usesArguments: false,\n          getArgsId: () => t.clone(argsId)\n        };\n        path.traverse(argumentsThisVisitor, context);\n\n        if (context.usesArguments) {\n          vars = vars || t.variableDeclaration(\"var\", []);\n          vars.declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier(\"arguments\")));\n        }\n\n        let emitter = new Emitter(contextId);\n        emitter.explode(path.get(\"body\"));\n\n        if (vars && vars.declarations.length > 0) {\n          outerBody.push(vars);\n        }\n\n        let wrapArgs = [emitter.getContextFunction(innerFnId)];\n        let tryLocsList = emitter.getTryLocsList();\n\n        if (node.generator) {\n          wrapArgs.push(outerFnExpr);\n        } else if (context.usesThis || tryLocsList || node.async) {\n          // Async functions that are not generators don't care about the\n          // outer function because they don't need it to be marked and don't\n          // inherit from its .prototype.\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (context.usesThis) {\n          wrapArgs.push(t.thisExpression());\n        } else if (tryLocsList || node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (tryLocsList) {\n          wrapArgs.push(tryLocsList);\n        } else if (node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (node.async) {\n          // Rename any locally declared \"Promise\" variable,\n          // to use the global one.\n          let currentScope = path.scope;\n\n          do {\n            if (currentScope.hasOwnBinding(\"Promise\")) currentScope.rename(\"Promise\");\n          } while (currentScope = currentScope.parent);\n\n          wrapArgs.push(t.identifier(\"Promise\"));\n        }\n\n        let wrapCall = t.callExpression(util.runtimeProperty(node.async ? \"async\" : \"wrap\"), wrapArgs);\n        outerBody.push(t.returnStatement(wrapCall));\n        node.body = t.blockStatement(outerBody); // We injected a few new variable declarations (for every hoisted var),\n        // so we need to add them to the scope.\n\n        path.get(\"body.body\").forEach(p => p.scope.registerDeclaration(p));\n        const oldDirectives = bodyBlockPath.node.directives;\n\n        if (oldDirectives) {\n          // Babylon represents directives like \"use strict\" as elements of\n          // a bodyBlockPath.node.directives array. (#248)\n          node.body.directives = oldDirectives;\n        }\n\n        let wasGeneratorFunction = node.generator;\n\n        if (wasGeneratorFunction) {\n          node.generator = false;\n        }\n\n        if (node.async) {\n          node.async = false;\n        }\n\n        if (wasGeneratorFunction && t.isExpression(node)) {\n          util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n          path.addComment(\"leading\", \"#__PURE__\");\n        }\n\n        const insertedLocs = emitter.getInsertedLocs();\n        path.traverse({\n          NumericLiteral(path) {\n            if (!insertedLocs.has(path.node)) {\n              return;\n            }\n\n            path.replaceWith(t.numericLiteral(path.node.value));\n          }\n\n        }); // Generators are processed in 'exit' handlers so that regenerator only has to run on\n        // an ES5 AST, but that means traversal will not pick up newly inserted references\n        // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n\n        path.requeue();\n      })\n    }\n  };\n}; // Check if a node should be transformed by regenerator\n\n\nfunction shouldRegenerate(node, state) {\n  if (node.generator) {\n    if (node.async) {\n      // Async generator\n      return state.opts.asyncGenerators !== false;\n    } else {\n      // Plain generator\n      return state.opts.generators !== false;\n    }\n  } else if (node.async) {\n    // Async function\n    return state.opts.async !== false;\n  } else {\n    // Not a generator or async function.\n    return false;\n  }\n} // Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\n\n\nfunction getOuterFnExpr(funPath) {\n  const t = util.getTypes();\n  let node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n  t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return t.clone(node.id);\n}\n\nconst markInfo = new WeakMap();\n\nfunction getMarkInfo(node) {\n  if (!markInfo.has(node)) {\n    markInfo.set(node, {});\n  }\n\n  return markInfo.get(node);\n}\n\nfunction getMarkedFunctionId(funPath) {\n  const t = util.getTypes();\n  const node = funPath.node;\n  t.assertIdentifier(node.id);\n  const blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  const block = blockPath.node;\n  assert.ok(Array.isArray(block.body));\n  const info = getMarkInfo(block);\n\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  assert.strictEqual(info.declPath.node, info.decl); // Get a new unique identifier for our marked variable.\n\n  const markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  const markCallExp = t.callExpression(util.runtimeProperty(\"mark\"), [t.clone(node.id)]);\n  const index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;\n  const markCallExpPath = info.declPath.get(\"declarations.\" + index + \".init\");\n  assert.strictEqual(markCallExpPath.node, markCallExp);\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n  return t.clone(markedId);\n}\n\nlet argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration|Method\": function (path) {\n    path.skip();\n  },\n  Identifier: function (path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression: function (path, state) {\n    state.usesThis = true;\n  }\n};\nlet functionSentVisitor = {\n  MetaProperty(path) {\n    let {\n      node\n    } = path;\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      const t = util.getTypes();\n      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier(\"_sent\")));\n    }\n  }\n\n};\nlet awaitVisitor = {\n  Function: function (path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n  AwaitExpression: function (path) {\n    const t = util.getTypes(); // Convert await expressions to yield expressions.\n\n    let argument = path.node.argument; // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n\n    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty(\"awrap\"), [argument]), false));\n  }\n};","map":{"version":3,"names":["assert","hoist","Emitter","replaceShorthandObjectMethod","util","exports","getVisitor","types","t","Method","path","state","node","shouldRegenerate","container","functionExpression","cloneNode","body","generator","async","get","set","returnStatement","callExpression","unwrapFunctionEnvironment","Function","exit","wrapWithTypes","contextId","scope","generateUidIdentifier","argsId","ensureBlock","bodyBlockPath","traverse","awaitVisitor","functionSentVisitor","context","outerBody","innerBody","forEach","childPath","isExpressionStatement","isStringLiteral","expression","push","_blockHoist","length","outerFnExpr","getOuterFnExpr","assertIdentifier","id","innerFnId","identifier","name","vars","usesThis","usesArguments","getArgsId","clone","argumentsThisVisitor","variableDeclaration","declarations","variableDeclarator","emitter","explode","wrapArgs","getContextFunction","tryLocsList","getTryLocsList","nullLiteral","thisExpression","currentScope","hasOwnBinding","rename","parent","wrapCall","runtimeProperty","blockStatement","p","registerDeclaration","oldDirectives","directives","wasGeneratorFunction","isExpression","replaceWithOrRemove","addComment","insertedLocs","getInsertedLocs","NumericLiteral","has","replaceWith","numericLiteral","value","requeue","opts","asyncGenerators","generators","funPath","getTypes","assertFunction","isFunctionDeclaration","getMarkedFunctionId","markInfo","WeakMap","getMarkInfo","blockPath","findParent","isProgram","isBlockStatement","block","ok","Array","isArray","info","decl","unshiftContainer","declPath","strictEqual","markedId","markCallExp","index","markCallExpPath","skip","Identifier","isReference","ThisExpression","MetaProperty","meta","property","memberExpression","AwaitExpression","argument","yieldExpression"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/regenerator-transform/src/visit.js"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\nimport assert from \"assert\";\nimport { hoist } from \"./hoist\";\nimport { Emitter } from \"./emit\";\nimport replaceShorthandObjectMethod from \"./replaceShorthandObjectMethod\";\nimport * as util from \"./util\";\n\nexports.getVisitor = ({ types: t }) => ({\n  Method(path, state) {\n    let node = path.node;\n\n    if (!shouldRegenerate(node, state)) return;\n\n    const container = t.functionExpression(\n      null,\n      [],\n      t.cloneNode(node.body, false),\n      node.generator,\n      node.async,\n    );\n\n    path.get(\"body\").set(\"body\", [\n      t.returnStatement(\n        t.callExpression(container, []),\n      ),\n    ]);\n\n    // Regardless of whether or not the wrapped function is a an async method\n    // or generator the outer function should not be\n    node.async = false;\n    node.generator = false;\n\n    // Unwrap the wrapper IIFE's environment so super and this and such still work.\n    path\n      .get(\"body.body.0.argument.callee\")\n      .unwrapFunctionEnvironment();\n  },\n  Function: {\n    exit: util.wrapWithTypes(t, function(path, state) {\n      let node = path.node;\n\n      if (!shouldRegenerate(node, state)) return;\n\n      // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n      path = replaceShorthandObjectMethod(path);\n      node = path.node;\n\n      let contextId = path.scope.generateUidIdentifier(\"context\");\n      let argsId = path.scope.generateUidIdentifier(\"args\");\n\n      path.ensureBlock();\n      let bodyBlockPath = path.get(\"body\");\n\n      if (node.async) {\n        bodyBlockPath.traverse(awaitVisitor);\n      }\n\n      bodyBlockPath.traverse(functionSentVisitor, {\n        context: contextId\n      });\n\n      let outerBody = [];\n      let innerBody = [];\n\n      bodyBlockPath.get(\"body\").forEach(function(childPath) {\n        let node = childPath.node;\n        if (t.isExpressionStatement(node) &&\n            t.isStringLiteral(node.expression)) {\n          // Babylon represents directives like \"use strict\" as elements\n          // of a bodyBlockPath.node.directives array, but they could just\n          // as easily be represented (by other parsers) as traditional\n          // string-literal-valued expression statements, so we need to\n          // handle that here. (#248)\n          outerBody.push(node);\n        } else if (node && node._blockHoist != null) {\n          outerBody.push(node);\n        } else {\n          innerBody.push(node);\n        }\n      });\n\n      if (outerBody.length > 0) {\n        // Only replace the inner body if we actually hoisted any statements\n        // to the outer body.\n        bodyBlockPath.node.body = innerBody;\n      }\n\n      let outerFnExpr = getOuterFnExpr(path);\n      // Note that getOuterFnExpr has the side-effect of ensuring that the\n      // function has a name (so node.id will always be an Identifier), even\n      // if a temporary name has to be synthesized.\n      t.assertIdentifier(node.id);\n      let innerFnId = t.identifier(node.id.name + \"$\");\n\n      // Turn all declarations into vars, and replace the original\n      // declarations with equivalent assignment expressions.\n      let vars = hoist(path);\n\n      let context = {\n        usesThis: false,\n        usesArguments: false,\n        getArgsId: () => t.clone(argsId),\n      };\n      path.traverse(argumentsThisVisitor, context);\n\n      if (context.usesArguments) {\n        vars = vars || t.variableDeclaration(\"var\", []);\n        vars.declarations.push(t.variableDeclarator(\n          t.clone(argsId),\n          t.identifier(\"arguments\"),\n        ));\n      }\n\n      let emitter = new Emitter(contextId);\n      emitter.explode(path.get(\"body\"));\n\n      if (vars && vars.declarations.length > 0) {\n        outerBody.push(vars);\n      }\n\n      let wrapArgs = [emitter.getContextFunction(innerFnId)];\n      let tryLocsList = emitter.getTryLocsList();\n\n      if (node.generator) {\n        wrapArgs.push(outerFnExpr);\n      } else if (context.usesThis || tryLocsList || node.async) {\n        // Async functions that are not generators don't care about the\n        // outer function because they don't need it to be marked and don't\n        // inherit from its .prototype.\n        wrapArgs.push(t.nullLiteral());\n      }\n      if (context.usesThis) {\n        wrapArgs.push(t.thisExpression());\n      } else if (tryLocsList || node.async) {\n        wrapArgs.push(t.nullLiteral());\n      }\n      if (tryLocsList) {\n        wrapArgs.push(tryLocsList);\n      } else if (node.async) {\n        wrapArgs.push(t.nullLiteral());\n      }\n\n      if (node.async) {\n        // Rename any locally declared \"Promise\" variable,\n        // to use the global one.\n        let currentScope = path.scope;\n        do {\n          if (currentScope.hasOwnBinding(\"Promise\")) currentScope.rename(\"Promise\");\n        } while (currentScope = currentScope.parent);\n\n        wrapArgs.push(t.identifier(\"Promise\"));\n      }\n\n      let wrapCall = t.callExpression(\n        util.runtimeProperty(node.async ? \"async\" : \"wrap\"),\n        wrapArgs\n      );\n\n      outerBody.push(t.returnStatement(wrapCall));\n      node.body = t.blockStatement(outerBody);\n      // We injected a few new variable declarations (for every hoisted var),\n      // so we need to add them to the scope.\n      path.get(\"body.body\").forEach(p => p.scope.registerDeclaration(p));\n\n      const oldDirectives = bodyBlockPath.node.directives;\n      if (oldDirectives) {\n        // Babylon represents directives like \"use strict\" as elements of\n        // a bodyBlockPath.node.directives array. (#248)\n        node.body.directives = oldDirectives;\n      }\n\n      let wasGeneratorFunction = node.generator;\n      if (wasGeneratorFunction) {\n        node.generator = false;\n      }\n\n      if (node.async) {\n        node.async = false;\n      }\n\n      if (wasGeneratorFunction && t.isExpression(node)) {\n        util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]))\n        path.addComment(\"leading\", \"#__PURE__\");\n      }\n\n      const insertedLocs = emitter.getInsertedLocs();\n\n      path.traverse({\n        NumericLiteral(path) {\n          if (!insertedLocs.has(path.node)) {\n            return;\n          }\n\n          path.replaceWith(t.numericLiteral(path.node.value));\n        },\n      })\n\n      // Generators are processed in 'exit' handlers so that regenerator only has to run on\n      // an ES5 AST, but that means traversal will not pick up newly inserted references\n      // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n      path.requeue();\n    })\n  }\n});\n\n// Check if a node should be transformed by regenerator\nfunction shouldRegenerate(node, state) {\n  if (node.generator) {\n    if (node.async) {\n      // Async generator\n      return state.opts.asyncGenerators !== false;\n    } else {\n      // Plain generator\n      return state.opts.generators !== false;\n    }\n  } else if (node.async) {\n    // Async function\n    return state.opts.async !== false;\n  } else {\n    // Not a generator or async function.\n    return false;\n  }\n}\n\n// Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\nfunction getOuterFnExpr(funPath) {\n  const t = util.getTypes();\n  let node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n      t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return t.clone(node.id);\n}\n\nconst markInfo = new WeakMap();\n\nfunction getMarkInfo(node) {\n  if (!markInfo.has(node)) {\n    markInfo.set(node, {});\n  }\n  return markInfo.get(node);\n}\n\nfunction getMarkedFunctionId(funPath) {\n  const t = util.getTypes();\n  const node = funPath.node;\n  t.assertIdentifier(node.id);\n\n  const blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  const block = blockPath.node;\n  assert.ok(Array.isArray(block.body));\n\n  const info = getMarkInfo(block);\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  assert.strictEqual(info.declPath.node, info.decl);\n\n  // Get a new unique identifier for our marked variable.\n  const markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  const markCallExp = t.callExpression(\n    util.runtimeProperty(\"mark\"),\n    [t.clone(node.id)]\n  );\n\n  const index = info.decl.declarations.push(\n    t.variableDeclarator(markedId, markCallExp)\n  ) - 1;\n\n  const markCallExpPath =\n    info.declPath.get(\"declarations.\" + index + \".init\");\n\n  assert.strictEqual(markCallExpPath.node, markCallExp);\n\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n\n  return t.clone(markedId);\n}\n\nlet argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration|Method\": function(path) {\n    path.skip();\n  },\n\n  Identifier: function(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n\n  ThisExpression: function(path, state) {\n    state.usesThis = true;\n  }\n};\n\nlet functionSentVisitor = {\n  MetaProperty(path) {\n    let { node } = path;\n\n    if (node.meta.name === \"function\" &&\n        node.property.name === \"sent\") {\n      const t = util.getTypes();\n      util.replaceWithOrRemove(\n        path,\n        t.memberExpression(\n          t.clone(this.context),\n          t.identifier(\"_sent\")\n        )\n      );\n    }\n  }\n};\n\nlet awaitVisitor = {\n  Function: function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n\n  AwaitExpression: function(path) {\n    const t = util.getTypes();\n\n    // Convert await expressions to yield expressions.\n    let argument = path.node.argument;\n\n    // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n    util.replaceWithOrRemove(path, t.yieldExpression(\n      t.callExpression(\n        util.runtimeProperty(\"awrap\"),\n        [argument]\n      ),\n      false\n    ));\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}