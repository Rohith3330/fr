{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _Referencer_jsxPragma, _Referencer_jsxFragmentName, _Referencer_hasReferencedJsxFactory, _Referencer_hasReferencedJsxFragmentFactory, _Referencer_lib, _Referencer_emitDecoratorMetadata;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Referencer = void 0;\n\nconst types_1 = require(\"@typescript-eslint/types\");\n\nconst assert_1 = require(\"../assert\");\n\nconst definition_1 = require(\"../definition\");\n\nconst lib_1 = require(\"../lib\");\n\nconst ClassVisitor_1 = require(\"./ClassVisitor\");\n\nconst ExportVisitor_1 = require(\"./ExportVisitor\");\n\nconst ImportVisitor_1 = require(\"./ImportVisitor\");\n\nconst PatternVisitor_1 = require(\"./PatternVisitor\");\n\nconst Reference_1 = require(\"./Reference\");\n\nconst TypeVisitor_1 = require(\"./TypeVisitor\");\n\nconst Visitor_1 = require(\"./Visitor\"); // Referencing variables and creating bindings.\n\n\nclass Referencer extends Visitor_1.Visitor {\n  constructor(options, scopeManager) {\n    super(options);\n\n    _Referencer_jsxPragma.set(this, void 0);\n\n    _Referencer_jsxFragmentName.set(this, void 0);\n\n    _Referencer_hasReferencedJsxFactory.set(this, false);\n\n    _Referencer_hasReferencedJsxFragmentFactory.set(this, false);\n\n    _Referencer_lib.set(this, void 0);\n\n    _Referencer_emitDecoratorMetadata.set(this, void 0);\n\n    this.scopeManager = scopeManager;\n\n    __classPrivateFieldSet(this, _Referencer_jsxPragma, options.jsxPragma, \"f\");\n\n    __classPrivateFieldSet(this, _Referencer_jsxFragmentName, options.jsxFragmentName, \"f\");\n\n    __classPrivateFieldSet(this, _Referencer_lib, options.lib, \"f\");\n\n    __classPrivateFieldSet(this, _Referencer_emitDecoratorMetadata, options.emitDecoratorMetadata, \"f\");\n  }\n\n  currentScope(dontThrowOnNull) {\n    if (!dontThrowOnNull) {\n      (0, assert_1.assert)(this.scopeManager.currentScope, 'aaa');\n    }\n\n    return this.scopeManager.currentScope;\n  }\n\n  close(node) {\n    while (this.currentScope(true) && node === this.currentScope().block) {\n      this.scopeManager.currentScope = this.currentScope().close(this.scopeManager);\n    }\n  }\n\n  referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {\n    assignments.forEach(assignment => {\n      this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, assignment.right, maybeImplicitGlobal, init);\n    });\n  }\n\n  populateGlobalsFromLib(globalScope) {\n    for (const lib of __classPrivateFieldGet(this, _Referencer_lib, \"f\")) {\n      const variables = lib_1.lib[lib];\n      /* istanbul ignore if */\n\n      if (!variables) {\n        throw new Error(`Invalid value for lib provided: ${lib}`);\n      }\n\n      for (const [name, variable] of Object.entries(variables)) {\n        globalScope.defineImplicitVariable(name, variable);\n      }\n    } // for const assertions (`{} as const` / `<const>{}`)\n\n\n    globalScope.defineImplicitVariable('const', {\n      eslintImplicitGlobalSetting: 'readonly',\n      isTypeVariable: true,\n      isValueVariable: false\n    });\n  }\n  /**\n   * Searches for a variable named \"name\" in the upper scopes and adds a pseudo-reference from itself to itself\n   */\n\n\n  referenceInSomeUpperScope(name) {\n    let scope = this.scopeManager.currentScope;\n\n    while (scope) {\n      const variable = scope.set.get(name);\n\n      if (!variable) {\n        scope = scope.upper;\n        continue;\n      }\n\n      scope.referenceValue(variable.identifiers[0]);\n      return true;\n    }\n\n    return false;\n  }\n\n  referenceJsxPragma() {\n    if (__classPrivateFieldGet(this, _Referencer_jsxPragma, \"f\") === null || __classPrivateFieldGet(this, _Referencer_hasReferencedJsxFactory, \"f\")) {\n      return;\n    }\n\n    __classPrivateFieldSet(this, _Referencer_hasReferencedJsxFactory, this.referenceInSomeUpperScope(__classPrivateFieldGet(this, _Referencer_jsxPragma, \"f\")), \"f\");\n  }\n\n  referenceJsxFragment() {\n    if (__classPrivateFieldGet(this, _Referencer_jsxFragmentName, \"f\") === null || __classPrivateFieldGet(this, _Referencer_hasReferencedJsxFragmentFactory, \"f\")) {\n      return;\n    }\n\n    __classPrivateFieldSet(this, _Referencer_hasReferencedJsxFragmentFactory, this.referenceInSomeUpperScope(__classPrivateFieldGet(this, _Referencer_jsxFragmentName, \"f\")), \"f\");\n  } ///////////////////\n  // Visit helpers //\n  ///////////////////\n\n\n  visitClass(node) {\n    ClassVisitor_1.ClassVisitor.visit(this, node, __classPrivateFieldGet(this, _Referencer_emitDecoratorMetadata, \"f\"));\n  }\n\n  visitForIn(node) {\n    if (node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration && node.left.kind !== 'var') {\n      this.scopeManager.nestForScope(node);\n    }\n\n    if (node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration) {\n      this.visit(node.left);\n      this.visitPattern(node.left.declarations[0].id, pattern => {\n        this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, null, true);\n      });\n    } else {\n      this.visitPattern(node.left, (pattern, info) => {\n        const maybeImplicitGlobal = !this.currentScope().isStrict ? {\n          pattern,\n          node\n        } : null;\n        this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);\n        this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, false);\n      }, {\n        processRightHandNodes: true\n      });\n    }\n\n    this.visit(node.right);\n    this.visit(node.body);\n    this.close(node);\n  }\n\n  visitFunctionParameterTypeAnnotation(node) {\n    if ('typeAnnotation' in node) {\n      this.visitType(node.typeAnnotation);\n    } else if (node.type === types_1.AST_NODE_TYPES.AssignmentPattern) {\n      this.visitType(node.left.typeAnnotation);\n    } else if (node.type === types_1.AST_NODE_TYPES.TSParameterProperty) {\n      this.visitFunctionParameterTypeAnnotation(node.parameter);\n    }\n  }\n\n  visitFunction(node) {\n    // FunctionDeclaration name is defined in upper scope\n    // NOTE: Not referring variableScope. It is intended.\n    // Since\n    //  in ES5, FunctionDeclaration should be in FunctionBody.\n    //  in ES6, FunctionDeclaration should be block scoped.\n    var _a;\n\n    if (node.type === types_1.AST_NODE_TYPES.FunctionExpression) {\n      if (node.id) {\n        // FunctionExpression with name creates its special scope;\n        // FunctionExpressionNameScope.\n        this.scopeManager.nestFunctionExpressionNameScope(node);\n      }\n    } else if (node.id) {\n      // id is defined in upper scope\n      this.currentScope().defineIdentifier(node.id, new definition_1.FunctionNameDefinition(node.id, node));\n    } // Consider this function is in the MethodDefinition.\n\n\n    this.scopeManager.nestFunctionScope(node, false); // Process parameter declarations.\n\n    for (const param of node.params) {\n      this.visitPattern(param, (pattern, info) => {\n        this.currentScope().defineIdentifier(pattern, new definition_1.ParameterDefinition(pattern, node, info.rest));\n        this.referencingDefaultValue(pattern, info.assignments, null, true);\n      }, {\n        processRightHandNodes: true\n      });\n      this.visitFunctionParameterTypeAnnotation(param);\n      (_a = param.decorators) === null || _a === void 0 ? void 0 : _a.forEach(d => this.visit(d));\n    }\n\n    this.visitType(node.returnType);\n    this.visitType(node.typeParameters); // In TypeScript there are a number of function-like constructs which have no body,\n    // so check it exists before traversing\n\n    if (node.body) {\n      // Skip BlockStatement to prevent creating BlockStatement scope.\n      if (node.body.type === types_1.AST_NODE_TYPES.BlockStatement) {\n        this.visitChildren(node.body);\n      } else {\n        this.visit(node.body);\n      }\n    }\n\n    this.close(node);\n  }\n\n  visitProperty(node) {\n    if (node.computed) {\n      this.visit(node.key);\n    }\n\n    this.visit(node.value);\n  }\n\n  visitType(node) {\n    if (!node) {\n      return;\n    }\n\n    TypeVisitor_1.TypeVisitor.visit(this, node);\n  }\n\n  visitTypeAssertion(node) {\n    this.visit(node.expression);\n    this.visitType(node.typeAnnotation);\n  } /////////////////////\n  // Visit selectors //\n  /////////////////////\n\n\n  ArrowFunctionExpression(node) {\n    this.visitFunction(node);\n  }\n\n  AssignmentExpression(node) {\n    let left = node.left;\n\n    switch (left.type) {\n      case types_1.AST_NODE_TYPES.TSAsExpression:\n      case types_1.AST_NODE_TYPES.TSTypeAssertion:\n        // explicitly visit the type annotation\n        this.visitType(left.typeAnnotation);\n      // intentional fallthrough\n\n      case types_1.AST_NODE_TYPES.TSNonNullExpression:\n        // unwrap the expression\n        left = left.expression;\n    }\n\n    if (PatternVisitor_1.PatternVisitor.isPattern(left)) {\n      if (node.operator === '=') {\n        this.visitPattern(left, (pattern, info) => {\n          const maybeImplicitGlobal = !this.currentScope().isStrict ? {\n            pattern,\n            node\n          } : null;\n          this.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);\n          this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, false);\n        }, {\n          processRightHandNodes: true\n        });\n      } else if (left.type === types_1.AST_NODE_TYPES.Identifier) {\n        this.currentScope().referenceValue(left, Reference_1.ReferenceFlag.ReadWrite, node.right);\n      }\n    } else {\n      this.visit(left);\n    }\n\n    this.visit(node.right);\n  }\n\n  BlockStatement(node) {\n    if (this.scopeManager.isES6()) {\n      this.scopeManager.nestBlockScope(node);\n    }\n\n    this.visitChildren(node);\n    this.close(node);\n  }\n\n  BreakStatement() {// don't reference the break statement's label\n  }\n\n  CallExpression(node) {\n    this.visitChildren(node, ['typeParameters']);\n    this.visitType(node.typeParameters);\n  }\n\n  CatchClause(node) {\n    this.scopeManager.nestCatchScope(node);\n\n    if (node.param) {\n      const param = node.param;\n      this.visitPattern(param, (pattern, info) => {\n        this.currentScope().defineIdentifier(pattern, new definition_1.CatchClauseDefinition(param, node));\n        this.referencingDefaultValue(pattern, info.assignments, null, true);\n      }, {\n        processRightHandNodes: true\n      });\n    }\n\n    this.visit(node.body);\n    this.close(node);\n  }\n\n  ClassExpression(node) {\n    this.visitClass(node);\n  }\n\n  ClassDeclaration(node) {\n    this.visitClass(node);\n  }\n\n  ContinueStatement() {// don't reference the continue statement's label\n  }\n\n  ExportAllDeclaration() {// this defines no local variables\n  }\n\n  ExportDefaultDeclaration(node) {\n    if (node.declaration.type === types_1.AST_NODE_TYPES.Identifier) {\n      ExportVisitor_1.ExportVisitor.visit(this, node);\n    } else {\n      this.visit(node.declaration);\n    }\n  }\n\n  ExportNamedDeclaration(node) {\n    if (node.declaration) {\n      this.visit(node.declaration);\n    } else {\n      ExportVisitor_1.ExportVisitor.visit(this, node);\n    }\n  }\n\n  ForInStatement(node) {\n    this.visitForIn(node);\n  }\n\n  ForOfStatement(node) {\n    this.visitForIn(node);\n  }\n\n  ForStatement(node) {\n    // Create ForStatement declaration.\n    // NOTE: In ES6, ForStatement dynamically generates per iteration environment. However, this is\n    // a static analyzer, we only generate one scope for ForStatement.\n    if (node.init && node.init.type === types_1.AST_NODE_TYPES.VariableDeclaration && node.init.kind !== 'var') {\n      this.scopeManager.nestForScope(node);\n    }\n\n    this.visitChildren(node);\n    this.close(node);\n  }\n\n  FunctionDeclaration(node) {\n    this.visitFunction(node);\n  }\n\n  FunctionExpression(node) {\n    this.visitFunction(node);\n  }\n\n  Identifier(node) {\n    this.currentScope().referenceValue(node);\n    this.visitType(node.typeAnnotation);\n  }\n\n  ImportDeclaration(node) {\n    (0, assert_1.assert)(this.scopeManager.isES6() && this.scopeManager.isModule(), 'ImportDeclaration should appear when the mode is ES6 and in the module context.');\n    ImportVisitor_1.ImportVisitor.visit(this, node);\n  }\n\n  JSXAttribute(node) {\n    this.visit(node.value);\n  }\n\n  JSXClosingElement() {// should not be counted as a reference\n  }\n\n  JSXFragment(node) {\n    this.referenceJsxPragma();\n    this.referenceJsxFragment();\n    this.visitChildren(node);\n  }\n\n  JSXIdentifier(node) {\n    this.currentScope().referenceValue(node);\n  }\n\n  JSXMemberExpression(node) {\n    if (node.object.type !== types_1.AST_NODE_TYPES.JSXIdentifier) {\n      this.visit(node.object);\n    } else {\n      if (node.object.name !== 'this') {\n        this.visit(node.object);\n      }\n    } // we don't ever reference the property as it's always going to be a property on the thing\n\n  }\n\n  JSXOpeningElement(node) {\n    this.referenceJsxPragma();\n\n    if (node.name.type === types_1.AST_NODE_TYPES.JSXIdentifier) {\n      if (node.name.name[0].toUpperCase() === node.name.name[0] || node.name.name === 'this') {\n        // lower cased component names are always treated as \"intrinsic\" names, and are converted to a string,\n        // not a variable by JSX transforms:\n        // <div /> => React.createElement(\"div\", null)\n        // the only case we want to visit a lower-cased component has its name as \"this\",\n        this.visit(node.name);\n      }\n    } else {\n      this.visit(node.name);\n    }\n\n    this.visitType(node.typeParameters);\n\n    for (const attr of node.attributes) {\n      this.visit(attr);\n    }\n  }\n\n  LabeledStatement(node) {\n    this.visit(node.body);\n  }\n\n  MemberExpression(node) {\n    this.visit(node.object);\n\n    if (node.computed) {\n      this.visit(node.property);\n    }\n  }\n\n  MetaProperty() {// meta properties all builtin globals\n  }\n\n  NewExpression(node) {\n    this.visitChildren(node, ['typeParameters']);\n    this.visitType(node.typeParameters);\n  }\n\n  PrivateIdentifier() {// private identifiers are members on classes and thus have no variables to to reference\n  }\n\n  Program(node) {\n    const globalScope = this.scopeManager.nestGlobalScope(node);\n    this.populateGlobalsFromLib(globalScope);\n\n    if (this.scopeManager.isGlobalReturn()) {\n      // Force strictness of GlobalScope to false when using node.js scope.\n      this.currentScope().isStrict = false;\n      this.scopeManager.nestFunctionScope(node, false);\n    }\n\n    if (this.scopeManager.isES6() && this.scopeManager.isModule()) {\n      this.scopeManager.nestModuleScope(node);\n    }\n\n    if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {\n      this.currentScope().isStrict = true;\n    }\n\n    this.visitChildren(node);\n    this.close(node);\n  }\n\n  Property(node) {\n    this.visitProperty(node);\n  }\n\n  SwitchStatement(node) {\n    this.visit(node.discriminant);\n\n    if (this.scopeManager.isES6()) {\n      this.scopeManager.nestSwitchScope(node);\n    }\n\n    for (const switchCase of node.cases) {\n      this.visit(switchCase);\n    }\n\n    this.close(node);\n  }\n\n  TaggedTemplateExpression(node) {\n    this.visit(node.tag);\n    this.visit(node.quasi);\n    this.visitType(node.typeParameters);\n  }\n\n  TSAsExpression(node) {\n    this.visitTypeAssertion(node);\n  }\n\n  TSDeclareFunction(node) {\n    this.visitFunction(node);\n  }\n\n  TSImportEqualsDeclaration(node) {\n    this.currentScope().defineIdentifier(node.id, new definition_1.ImportBindingDefinition(node.id, node, node));\n\n    if (node.moduleReference.type === types_1.AST_NODE_TYPES.TSQualifiedName) {\n      this.visit(node.moduleReference.left);\n    } else {\n      this.visit(node.moduleReference);\n    }\n  }\n\n  TSEmptyBodyFunctionExpression(node) {\n    this.visitFunction(node);\n  }\n\n  TSEnumDeclaration(node) {\n    this.currentScope().defineIdentifier(node.id, new definition_1.TSEnumNameDefinition(node.id, node)); // enum members can be referenced within the enum body\n\n    this.scopeManager.nestTSEnumScope(node); // define the enum name again inside the new enum scope\n    // references to the enum should not resolve directly to the enum\n\n    this.currentScope().defineIdentifier(node.id, new definition_1.TSEnumNameDefinition(node.id, node));\n\n    for (const member of node.members) {\n      // TS resolves literal named members to be actual names\n      // enum Foo {\n      //   'a' = 1,\n      //   b = a, // this references the 'a' member\n      // }\n      if (member.id.type === types_1.AST_NODE_TYPES.Literal && typeof member.id.value === 'string') {\n        const name = member.id;\n        this.currentScope().defineLiteralIdentifier(name, new definition_1.TSEnumMemberDefinition(name, member));\n      } else if (!member.computed && member.id.type === types_1.AST_NODE_TYPES.Identifier) {\n        this.currentScope().defineIdentifier(member.id, new definition_1.TSEnumMemberDefinition(member.id, member));\n      }\n\n      this.visit(member.initializer);\n    }\n\n    this.close(node);\n  }\n\n  TSInstantiationExpression(node) {\n    this.visitChildren(node, ['typeParameters']);\n    this.visitType(node.typeParameters);\n  }\n\n  TSInterfaceDeclaration(node) {\n    this.visitType(node);\n  }\n\n  TSModuleDeclaration(node) {\n    if (node.id.type === types_1.AST_NODE_TYPES.Identifier && !node.global) {\n      this.currentScope().defineIdentifier(node.id, new definition_1.TSModuleNameDefinition(node.id, node));\n    }\n\n    this.scopeManager.nestTSModuleScope(node);\n    this.visit(node.body);\n    this.close(node);\n  }\n\n  TSTypeAliasDeclaration(node) {\n    this.visitType(node);\n  }\n\n  TSTypeAssertion(node) {\n    this.visitTypeAssertion(node);\n  }\n\n  UpdateExpression(node) {\n    if (PatternVisitor_1.PatternVisitor.isPattern(node.argument)) {\n      this.visitPattern(node.argument, pattern => {\n        this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.ReadWrite, null);\n      });\n    } else {\n      this.visitChildren(node);\n    }\n  }\n\n  VariableDeclaration(node) {\n    const variableTargetScope = node.kind === 'var' ? this.currentScope().variableScope : this.currentScope();\n\n    for (const decl of node.declarations) {\n      const init = decl.init;\n      this.visitPattern(decl.id, (pattern, info) => {\n        variableTargetScope.defineIdentifier(pattern, new definition_1.VariableDefinition(pattern, decl, node));\n        this.referencingDefaultValue(pattern, info.assignments, null, true);\n\n        if (init) {\n          this.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, init, null, true);\n        }\n      }, {\n        processRightHandNodes: true\n      });\n\n      if (decl.init) {\n        this.visit(decl.init);\n      }\n\n      if ('typeAnnotation' in decl.id) {\n        this.visitType(decl.id.typeAnnotation);\n      }\n    }\n  }\n\n  WithStatement(node) {\n    this.visit(node.object); // Then nest scope for WithStatement.\n\n    this.scopeManager.nestWithScope(node);\n    this.visit(node.body);\n    this.close(node);\n  }\n\n  ImportAttribute() {// import assertions are module metadata and thus have no variables to reference\n  }\n\n}\n\nexports.Referencer = Referencer;\n_Referencer_jsxPragma = new WeakMap(), _Referencer_jsxFragmentName = new WeakMap(), _Referencer_hasReferencedJsxFactory = new WeakMap(), _Referencer_hasReferencedJsxFragmentFactory = new WeakMap(), _Referencer_lib = new WeakMap(), _Referencer_emitDecoratorMetadata = new WeakMap();","map":{"version":3,"mappings":"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","names":["Referencer","Visitor_1","constructor","options","scopeManager","_Referencer_jsxPragma","_Referencer_jsxFragmentName","_Referencer_hasReferencedJsxFactory","_Referencer_hasReferencedJsxFragmentFactory","_Referencer_lib","_Referencer_emitDecoratorMetadata","__classPrivateFieldSet","jsxPragma","jsxFragmentName","lib","emitDecoratorMetadata","currentScope","dontThrowOnNull","close","node","block","referencingDefaultValue","pattern","assignments","maybeImplicitGlobal","init","forEach","assignment","referenceValue","Reference_1","Write","right","populateGlobalsFromLib","globalScope","__classPrivateFieldGet","variables","lib_1","Error","name","variable","Object","entries","defineImplicitVariable","eslintImplicitGlobalSetting","isTypeVariable","isValueVariable","referenceInSomeUpperScope","scope","set","get","upper","identifiers","referenceJsxPragma","referenceJsxFragment","visitClass","ClassVisitor_1","visit","visitForIn","left","type","types_1","VariableDeclaration","kind","nestForScope","visitPattern","declarations","id","info","isStrict","processRightHandNodes","body","visitFunctionParameterTypeAnnotation","visitType","typeAnnotation","AssignmentPattern","TSParameterProperty","parameter","visitFunction","FunctionExpression","nestFunctionExpressionNameScope","defineIdentifier","definition_1","nestFunctionScope","param","params","rest","decorators","_a","d","returnType","typeParameters","BlockStatement","visitChildren","visitProperty","computed","key","value","TypeVisitor_1","visitTypeAssertion","expression","ArrowFunctionExpression","AssignmentExpression","TSAsExpression","TSTypeAssertion","TSNonNullExpression","PatternVisitor_1","isPattern","operator","Identifier","ReadWrite","isES6","nestBlockScope","BreakStatement","CallExpression","CatchClause","nestCatchScope","ClassExpression","ClassDeclaration","ContinueStatement","ExportAllDeclaration","ExportDefaultDeclaration","declaration","ExportVisitor_1","ExportNamedDeclaration","ForInStatement","ForOfStatement","ForStatement","FunctionDeclaration","ImportDeclaration","isModule","ImportVisitor_1","JSXAttribute","JSXClosingElement","JSXFragment","JSXIdentifier","JSXMemberExpression","object","JSXOpeningElement","toUpperCase","attr","attributes","LabeledStatement","MemberExpression","property","MetaProperty","NewExpression","PrivateIdentifier","Program","nestGlobalScope","isGlobalReturn","nestModuleScope","isStrictModeSupported","isImpliedStrict","Property","SwitchStatement","discriminant","nestSwitchScope","switchCase","cases","TaggedTemplateExpression","tag","quasi","TSDeclareFunction","TSImportEqualsDeclaration","moduleReference","TSQualifiedName","TSEmptyBodyFunctionExpression","TSEnumDeclaration","nestTSEnumScope","member","members","Literal","defineLiteralIdentifier","initializer","TSInstantiationExpression","TSInterfaceDeclaration","TSModuleDeclaration","global","nestTSModuleScope","TSTypeAliasDeclaration","UpdateExpression","argument","variableTargetScope","variableScope","decl","WithStatement","nestWithScope","ImportAttribute","exports"],"sources":["../../src/referencer/Referencer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}