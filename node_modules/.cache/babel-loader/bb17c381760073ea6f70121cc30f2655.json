{"ast":null,"code":"import { useState } from 'react';\nimport useStableMemo from './useStableMemo';\nimport useEffect from './useIsomorphicEffect';\nimport useEventCallback from './useEventCallback';\n/**\n * Setup an [`IntersectionObserver`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver) on\n * a DOM Element that returns it's entries as they arrive.\n *\n * @param element The DOM element to observe\n * @param init IntersectionObserver options with a notable change,\n * unlike a plain IntersectionObserver `root: null` means \"not provided YET\",\n * and the hook will wait until it receives a non-null value to set up the observer.\n * This change allows for easier syncing of element and root values in a React\n * context.\n */\n\nfunction useIntersectionObserver(element, callbackOrOptions, maybeOptions) {\n  var callback;\n  var options;\n\n  if (typeof callbackOrOptions === 'function') {\n    callback = callbackOrOptions;\n    options = maybeOptions || {};\n  } else {\n    options = callbackOrOptions || {};\n  }\n\n  var _options = options,\n      threshold = _options.threshold,\n      root = _options.root,\n      rootMargin = _options.rootMargin;\n\n  var _useState = useState(null),\n      entries = _useState[0],\n      setEntry = _useState[1];\n\n  var handler = useEventCallback(callback || setEntry); // We wait for element to exist before constructing\n\n  var observer = useStableMemo(function () {\n    return root !== null && typeof IntersectionObserver !== 'undefined' && new IntersectionObserver(handler, {\n      threshold: threshold,\n      root: root,\n      rootMargin: rootMargin\n    });\n  }, [handler, root, rootMargin, threshold && JSON.stringify(threshold)]);\n  useEffect(function () {\n    if (!element || !observer) return;\n    observer.observe(element);\n    return function () {\n      observer.unobserve(element);\n    };\n  }, [observer, element]);\n  return callback ? undefined : entries || [];\n}\n\nexport default useIntersectionObserver;","map":{"version":3,"names":["useState","useStableMemo","useEffect","useEventCallback","useIntersectionObserver","element","callbackOrOptions","maybeOptions","callback","options","_options","threshold","root","rootMargin","_useState","entries","setEntry","handler","observer","IntersectionObserver","JSON","stringify","observe","unobserve","undefined"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@restart/hooks/esm/useIntersectionObserver.js"],"sourcesContent":["import { useState } from 'react';\nimport useStableMemo from './useStableMemo';\nimport useEffect from './useIsomorphicEffect';\nimport useEventCallback from './useEventCallback';\n/**\n * Setup an [`IntersectionObserver`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver) on\n * a DOM Element that returns it's entries as they arrive.\n *\n * @param element The DOM element to observe\n * @param init IntersectionObserver options with a notable change,\n * unlike a plain IntersectionObserver `root: null` means \"not provided YET\",\n * and the hook will wait until it receives a non-null value to set up the observer.\n * This change allows for easier syncing of element and root values in a React\n * context.\n */\n\nfunction useIntersectionObserver(element, callbackOrOptions, maybeOptions) {\n  var callback;\n  var options;\n\n  if (typeof callbackOrOptions === 'function') {\n    callback = callbackOrOptions;\n    options = maybeOptions || {};\n  } else {\n    options = callbackOrOptions || {};\n  }\n\n  var _options = options,\n      threshold = _options.threshold,\n      root = _options.root,\n      rootMargin = _options.rootMargin;\n\n  var _useState = useState(null),\n      entries = _useState[0],\n      setEntry = _useState[1];\n\n  var handler = useEventCallback(callback || setEntry); // We wait for element to exist before constructing\n\n  var observer = useStableMemo(function () {\n    return root !== null && typeof IntersectionObserver !== 'undefined' && new IntersectionObserver(handler, {\n      threshold: threshold,\n      root: root,\n      rootMargin: rootMargin\n    });\n  }, [handler, root, rootMargin, threshold && JSON.stringify(threshold)]);\n  useEffect(function () {\n    if (!element || !observer) return;\n    observer.observe(element);\n    return function () {\n      observer.unobserve(element);\n    };\n  }, [observer, element]);\n  return callback ? undefined : entries || [];\n}\n\nexport default useIntersectionObserver;"],"mappings":"AAAA,SAASA,QAAT,QAAyB,OAAzB;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,SAAP,MAAsB,uBAAtB;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,uBAAT,CAAiCC,OAAjC,EAA0CC,iBAA1C,EAA6DC,YAA7D,EAA2E;EACzE,IAAIC,QAAJ;EACA,IAAIC,OAAJ;;EAEA,IAAI,OAAOH,iBAAP,KAA6B,UAAjC,EAA6C;IAC3CE,QAAQ,GAAGF,iBAAX;IACAG,OAAO,GAAGF,YAAY,IAAI,EAA1B;EACD,CAHD,MAGO;IACLE,OAAO,GAAGH,iBAAiB,IAAI,EAA/B;EACD;;EAED,IAAII,QAAQ,GAAGD,OAAf;EAAA,IACIE,SAAS,GAAGD,QAAQ,CAACC,SADzB;EAAA,IAEIC,IAAI,GAAGF,QAAQ,CAACE,IAFpB;EAAA,IAGIC,UAAU,GAAGH,QAAQ,CAACG,UAH1B;;EAKA,IAAIC,SAAS,GAAGd,QAAQ,CAAC,IAAD,CAAxB;EAAA,IACIe,OAAO,GAAGD,SAAS,CAAC,CAAD,CADvB;EAAA,IAEIE,QAAQ,GAAGF,SAAS,CAAC,CAAD,CAFxB;;EAIA,IAAIG,OAAO,GAAGd,gBAAgB,CAACK,QAAQ,IAAIQ,QAAb,CAA9B,CApByE,CAoBnB;;EAEtD,IAAIE,QAAQ,GAAGjB,aAAa,CAAC,YAAY;IACvC,OAAOW,IAAI,KAAK,IAAT,IAAiB,OAAOO,oBAAP,KAAgC,WAAjD,IAAgE,IAAIA,oBAAJ,CAAyBF,OAAzB,EAAkC;MACvGN,SAAS,EAAEA,SAD4F;MAEvGC,IAAI,EAAEA,IAFiG;MAGvGC,UAAU,EAAEA;IAH2F,CAAlC,CAAvE;EAKD,CAN2B,EAMzB,CAACI,OAAD,EAAUL,IAAV,EAAgBC,UAAhB,EAA4BF,SAAS,IAAIS,IAAI,CAACC,SAAL,CAAeV,SAAf,CAAzC,CANyB,CAA5B;EAOAT,SAAS,CAAC,YAAY;IACpB,IAAI,CAACG,OAAD,IAAY,CAACa,QAAjB,EAA2B;IAC3BA,QAAQ,CAACI,OAAT,CAAiBjB,OAAjB;IACA,OAAO,YAAY;MACjBa,QAAQ,CAACK,SAAT,CAAmBlB,OAAnB;IACD,CAFD;EAGD,CANQ,EAMN,CAACa,QAAD,EAAWb,OAAX,CANM,CAAT;EAOA,OAAOG,QAAQ,GAAGgB,SAAH,GAAeT,OAAO,IAAI,EAAzC;AACD;;AAED,eAAeX,uBAAf"},"metadata":{},"sourceType":"module"}