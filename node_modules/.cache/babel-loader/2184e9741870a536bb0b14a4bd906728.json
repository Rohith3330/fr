{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;\n\nconst codegen_1 = require(\"../codegen\");\n\nconst util_1 = require(\"../util\");\n\nfunction getSubschema(it, _ref) {\n  let {\n    keyword,\n    schemaProp,\n    schema,\n    schemaPath,\n    errSchemaPath,\n    topSchemaRef\n  } = _ref;\n\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed');\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword];\n    return schemaProp === undefined ? {\n      schema: sch,\n      schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`\n    } : {\n      schema: sch[schemaProp],\n      schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`\n    };\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"');\n    }\n\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath\n    };\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed');\n}\n\nexports.getSubschema = getSubschema;\n\nfunction extendSubschemaData(subschema, it, _ref2) {\n  let {\n    dataProp,\n    dataPropType: dpType,\n    data,\n    dataTypes,\n    propertyName\n  } = _ref2;\n\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed');\n  }\n\n  const {\n    gen\n  } = it;\n\n  if (dataProp !== undefined) {\n    const {\n      errorPath,\n      dataPathArr,\n      opts\n    } = it;\n    const nextData = gen.let(\"data\", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);\n    dataContextProps(nextData);\n    subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;\n    subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof codegen_1.Name ? data : gen.let(\"data\", data, true); // replaceable if used once?\n\n    dataContextProps(nextData);\n    if (propertyName !== undefined) subschema.propertyName = propertyName; // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes;\n\n  function dataContextProps(_nextData) {\n    subschema.data = _nextData;\n    subschema.dataLevel = it.dataLevel + 1;\n    subschema.dataTypes = [];\n    it.definedProperties = new Set();\n    subschema.parentData = it.data;\n    subschema.dataNames = [...it.dataNames, _nextData];\n  }\n}\n\nexports.extendSubschemaData = extendSubschemaData;\n\nfunction extendSubschemaMode(subschema, _ref3) {\n  let {\n    jtdDiscriminator,\n    jtdMetadata,\n    compositeRule,\n    createErrors,\n    allErrors\n  } = _ref3;\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule;\n  if (createErrors !== undefined) subschema.createErrors = createErrors;\n  if (allErrors !== undefined) subschema.allErrors = allErrors;\n  subschema.jtdDiscriminator = jtdDiscriminator; // not inherited\n\n  subschema.jtdMetadata = jtdMetadata; // not inherited\n}\n\nexports.extendSubschemaMode = extendSubschemaMode;","map":{"version":3,"mappings":"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","names":["getSubschema","it","keyword","schemaProp","schema","schemaPath","errSchemaPath","topSchemaRef","undefined","Error","sch","exports","extendSubschemaData","subschema","dataProp","dataPropType","dpType","data","dataTypes","propertyName","gen","errorPath","dataPathArr","opts","nextData","let","dataContextProps","jsPropertySyntax","parentDataProperty","codegen_1","_nextData","dataLevel","definedProperties","Set","parentData","dataNames","extendSubschemaMode","jtdDiscriminator","jtdMetadata","compositeRule","createErrors","allErrors"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\compile\\validate\\subschema.ts"],"sourcesContent":["import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n"]},"metadata":{},"sourceType":"script"}