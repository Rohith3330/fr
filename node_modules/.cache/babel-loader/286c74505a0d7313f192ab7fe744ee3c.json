{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst {\n  parsePathData,\n  stringifyPathData\n} = require('../lib/path.js');\n/**\n * @type {[number, number]}\n */\n\n\nvar prevCtrlPoint;\n/**\n * Convert path string to JS representation.\n *\n * @type {(path: XastElement) => Array<PathDataItem>}\n */\n\nconst path2js = path => {\n  // @ts-ignore legacy\n  if (path.pathJS) return path.pathJS;\n  /**\n   * @type {Array<PathDataItem>}\n   */\n\n  const pathData = []; // JS representation of the path data\n\n  const newPathData = parsePathData(path.attributes.d);\n\n  for (const {\n    command,\n    args\n  } of newPathData) {\n    pathData.push({\n      command,\n      args\n    });\n  } // First moveto is actually absolute. Subsequent coordinates were separated above.\n\n\n  if (pathData.length && pathData[0].command == 'm') {\n    pathData[0].command = 'M';\n  } // @ts-ignore legacy\n\n\n  path.pathJS = pathData;\n  return pathData;\n};\n\nexports.path2js = path2js;\n/**\n * Convert relative Path data to absolute.\n *\n * @type {(data: Array<PathDataItem>) => Array<PathDataItem>}\n *\n */\n\nconst convertRelativeToAbsolute = data => {\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const newData = [];\n  let start = [0, 0];\n  let cursor = [0, 0];\n\n  for (let {\n    command,\n    args\n  } of data) {\n    args = args.slice(); // moveto (x y)\n\n    if (command === 'm') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'M';\n    }\n\n    if (command === 'M') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    } // horizontal lineto (x)\n\n\n    if (command === 'h') {\n      args[0] += cursor[0];\n      command = 'H';\n    }\n\n    if (command === 'H') {\n      cursor[0] = args[0];\n    } // vertical lineto (y)\n\n\n    if (command === 'v') {\n      args[0] += cursor[1];\n      command = 'V';\n    }\n\n    if (command === 'V') {\n      cursor[1] = args[0];\n    } // lineto (x y)\n\n\n    if (command === 'l') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'L';\n    }\n\n    if (command === 'L') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    } // curveto (x1 y1 x2 y2 x y)\n\n\n    if (command === 'c') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      args[4] += cursor[0];\n      args[5] += cursor[1];\n      command = 'C';\n    }\n\n    if (command === 'C') {\n      cursor[0] = args[4];\n      cursor[1] = args[5];\n    } // smooth curveto (x2 y2 x y)\n\n\n    if (command === 's') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'S';\n    }\n\n    if (command === 'S') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    } // quadratic Bézier curveto (x1 y1 x y)\n\n\n    if (command === 'q') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'Q';\n    }\n\n    if (command === 'Q') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    } // smooth quadratic Bézier curveto (x y)\n\n\n    if (command === 't') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'T';\n    }\n\n    if (command === 'T') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    } // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n\n\n    if (command === 'a') {\n      args[5] += cursor[0];\n      args[6] += cursor[1];\n      command = 'A';\n    }\n\n    if (command === 'A') {\n      cursor[0] = args[5];\n      cursor[1] = args[6];\n    } // closepath\n\n\n    if (command === 'z' || command === 'Z') {\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n      command = 'z';\n    }\n\n    newData.push({\n      command,\n      args\n    });\n  }\n\n  return newData;\n};\n/**\n * @typedef {{ floatPrecision?: number, noSpaceAfterFlags?: boolean }} Js2PathParams\n */\n\n/**\n * Convert path array to string.\n *\n * @type {(path: XastElement, data: Array<PathDataItem>, params: Js2PathParams) => void}\n */\n\n\nexports.js2path = function (path, data, params) {\n  // @ts-ignore legacy\n  path.pathJS = data;\n  const pathData = [];\n\n  for (const item of data) {\n    // remove moveto commands which are followed by moveto commands\n    if (pathData.length !== 0 && (item.command === 'M' || item.command === 'm')) {\n      const last = pathData[pathData.length - 1];\n\n      if (last.command === 'M' || last.command === 'm') {\n        pathData.pop();\n      }\n    }\n\n    pathData.push({\n      command: item.command,\n      args: item.args\n    });\n  }\n\n  path.attributes.d = stringifyPathData({\n    pathData,\n    precision: params.floatPrecision,\n    disableSpaceAfterFlags: params.noSpaceAfterFlags\n  });\n};\n/**\n * @type {(dest: Array<number>, source: Array<number>) => Array<number>}\n */\n\n\nfunction set(dest, source) {\n  dest[0] = source[source.length - 2];\n  dest[1] = source[source.length - 1];\n  return dest;\n}\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * https://web.archive.org/web/20180822200027/http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @type {(path1: Array<PathDataItem>, path2: Array<PathDataItem>) => boolean}\n */\n\n\nexports.intersects = function (path1, path2) {\n  // Collect points of every subpath.\n  const points1 = gatherPoints(convertRelativeToAbsolute(path1));\n  const points2 = gatherPoints(convertRelativeToAbsolute(path2)); // Axis-aligned bounding box check.\n\n  if (points1.maxX <= points2.minX || points2.maxX <= points1.minX || points1.maxY <= points2.minY || points2.maxY <= points1.minY || points1.list.every(set1 => {\n    return points2.list.every(set2 => {\n      return set1.list[set1.maxX][0] <= set2.list[set2.minX][0] || set2.list[set2.maxX][0] <= set1.list[set1.minX][0] || set1.list[set1.maxY][1] <= set2.list[set2.minY][1] || set2.list[set2.maxY][1] <= set1.list[set1.minY][1];\n    });\n  })) return false; // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).\n\n  const hullNest1 = points1.list.map(convexHull);\n  const hullNest2 = points2.list.map(convexHull); // Check intersection of every subpath of the first path with every subpath of the second.\n\n  return hullNest1.some(function (hull1) {\n    if (hull1.list.length < 3) return false;\n    return hullNest2.some(function (hull2) {\n      if (hull2.list.length < 3) return false;\n      var simplex = [getSupport(hull1, hull2, [1, 0])],\n          // create the initial simplex\n      direction = minus(simplex[0]); // set the direction to point towards the origin\n\n      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n      // eslint-disable-next-line no-constant-condition\n\n      while (true) {\n        // eslint-disable-next-line no-constant-condition\n        if (iterations-- == 0) {\n          console.error('Error: infinite loop while processing mergePaths plugin.');\n          return true; // true is the safe value that means “do nothing with paths”\n        } // add a new point\n\n\n        simplex.push(getSupport(hull1, hull2, direction)); // see if the new point was on the correct side of the origin\n\n        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false; // process the simplex\n\n        if (processSimplex(simplex, direction)) return true;\n      }\n    });\n  });\n  /**\n   * @type {(a: Point, b: Point, direction: Array<number>) => Array<number>}\n   */\n\n  function getSupport(a, b, direction) {\n    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n  } // Computes farthest polygon point in particular direction.\n  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n\n  /**\n   * @type {(polygon: Point, direction: Array<number>) => Array<number>}\n   */\n\n\n  function supportPoint(polygon, direction) {\n    var index = direction[1] >= 0 ? direction[0] < 0 ? polygon.maxY : polygon.maxX : direction[0] < 0 ? polygon.minX : polygon.minY,\n        max = -Infinity,\n        value;\n\n    while ((value = dot(polygon.list[index], direction)) > max) {\n      max = value;\n      index = ++index % polygon.list.length;\n    }\n\n    return polygon.list[(index || polygon.list.length) - 1];\n  }\n};\n/**\n * @type {(simplex: Array<Array<number>>, direction: Array<number>) => boolean}\n */\n\n\nfunction processSimplex(simplex, direction) {\n  // we only need to handle to 1-simplex and 2-simplex\n  if (simplex.length == 2) {\n    // 1-simplex\n    let a = simplex[1],\n        b = simplex[0],\n        AO = minus(simplex[1]),\n        AB = sub(b, a); // AO is in the same direction as AB\n\n    if (dot(AO, AB) > 0) {\n      // get the vector perpendicular to AB facing O\n      set(direction, orth(AB, a));\n    } else {\n      set(direction, AO); // only A remains in the simplex\n\n      simplex.shift();\n    }\n  } else {\n    // 2-simplex\n    let a = simplex[2],\n        // [a, b, c] = simplex\n    b = simplex[1],\n        c = simplex[0],\n        AB = sub(b, a),\n        AC = sub(c, a),\n        AO = minus(a),\n        ACB = orth(AB, AC),\n        // the vector perpendicular to AB facing away from C\n    ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n    if (dot(ACB, AO) > 0) {\n      if (dot(AB, AO) > 0) {\n        // region 4\n        set(direction, ACB);\n        simplex.shift(); // simplex = [b, a]\n      } else {\n        // region 5\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else if (dot(ABC, AO) > 0) {\n      if (dot(AC, AO) > 0) {\n        // region 6\n        set(direction, ABC);\n        simplex.splice(1, 1); // simplex = [c, a]\n      } else {\n        // region 5 (again)\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } // region 7\n    else return true;\n  }\n\n  return false;\n}\n/**\n * @type {(v: Array<number>) => Array<number>}\n */\n\n\nfunction minus(v) {\n  return [-v[0], -v[1]];\n}\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\n\n\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => number}\n */\n\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\n\n\nfunction orth(v, from) {\n  var o = [-v[1], v[0]];\n  return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\n/**\n * @typedef {{\n *   list: Array<Array<number>>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Point\n */\n\n/**\n * @typedef {{\n *   list: Array<Point>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Points\n */\n\n/**\n * @type {(pathData: Array<PathDataItem>) => Points}\n */\n\n\nfunction gatherPoints(pathData) {\n  /**\n   * @type {Points}\n   */\n  const points = {\n    list: [],\n    minX: 0,\n    minY: 0,\n    maxX: 0,\n    maxY: 0\n  }; // Writes data about the extreme points on each axle\n\n  /**\n   * @type {(path: Point, point: Array<number>) => void}\n   */\n\n  const addPoint = (path, point) => {\n    if (!path.list.length || point[1] > path.list[path.maxY][1]) {\n      path.maxY = path.list.length;\n      points.maxY = points.list.length ? Math.max(point[1], points.maxY) : point[1];\n    }\n\n    if (!path.list.length || point[0] > path.list[path.maxX][0]) {\n      path.maxX = path.list.length;\n      points.maxX = points.list.length ? Math.max(point[0], points.maxX) : point[0];\n    }\n\n    if (!path.list.length || point[1] < path.list[path.minY][1]) {\n      path.minY = path.list.length;\n      points.minY = points.list.length ? Math.min(point[1], points.minY) : point[1];\n    }\n\n    if (!path.list.length || point[0] < path.list[path.minX][0]) {\n      path.minX = path.list.length;\n      points.minX = points.list.length ? Math.min(point[0], points.minX) : point[0];\n    }\n\n    path.list.push(point);\n  };\n\n  for (let i = 0; i < pathData.length; i += 1) {\n    const pathDataItem = pathData[i];\n    let subPath = points.list.length === 0 ? {\n      list: [],\n      minX: 0,\n      minY: 0,\n      maxX: 0,\n      maxY: 0\n    } : points.list[points.list.length - 1];\n    let prev = i === 0 ? null : pathData[i - 1];\n    let basePoint = subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];\n    let data = pathDataItem.args;\n    let ctrlPoint = basePoint;\n    /**\n     * @type {(n: number, i: number) => number}\n     * TODO fix null hack\n     */\n\n    const toAbsolute = (n, i) => n + (basePoint == null ? 0 : basePoint[i % 2]);\n\n    switch (pathDataItem.command) {\n      case 'M':\n        subPath = {\n          list: [],\n          minX: 0,\n          minY: 0,\n          maxX: 0,\n          maxY: 0\n        };\n        points.list.push(subPath);\n        break;\n\n      case 'H':\n        if (basePoint != null) {\n          addPoint(subPath, [data[0], basePoint[1]]);\n        }\n\n        break;\n\n      case 'V':\n        if (basePoint != null) {\n          addPoint(subPath, [basePoint[0], data[0]]);\n        }\n\n        break;\n\n      case 'Q':\n        addPoint(subPath, data.slice(0, 2));\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n\n        break;\n\n      case 'T':\n        if (basePoint != null && prev != null && (prev.command == 'Q' || prev.command == 'T')) {\n          ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n          addPoint(subPath, ctrlPoint);\n          prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n        }\n\n        break;\n\n      case 'C':\n        if (basePoint != null) {\n          // Approximate quibic Bezier curve with middle points between control points\n          addPoint(subPath, [0.5 * (basePoint[0] + data[0]), 0.5 * (basePoint[1] + data[1])]);\n        }\n\n        addPoint(subPath, [0.5 * (data[0] + data[2]), 0.5 * (data[1] + data[3])]);\n        addPoint(subPath, [0.5 * (data[2] + data[4]), 0.5 * (data[3] + data[5])]);\n        prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n\n        break;\n\n      case 'S':\n        if (basePoint != null && prev != null && (prev.command == 'C' || prev.command == 'S')) {\n          addPoint(subPath, [basePoint[0] + 0.5 * prevCtrlPoint[0], basePoint[1] + 0.5 * prevCtrlPoint[1]]);\n          ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n        }\n\n        if (ctrlPoint != null) {\n          addPoint(subPath, [0.5 * (ctrlPoint[0] + data[0]), 0.5 * (ctrlPoint[1] + data[1])]);\n        }\n\n        addPoint(subPath, [0.5 * (data[0] + data[2]), 0.5 * (data[1] + data[3])]);\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n        break;\n\n      case 'A':\n        if (basePoint != null) {\n          // Convert the arc to bezier curves and use the same approximation\n          // @ts-ignore no idea what's going on here\n          var curves = a2c.apply(0, basePoint.concat(data));\n\n          for (var cData; (cData = curves.splice(0, 6).map(toAbsolute)).length;) {\n            if (basePoint != null) {\n              addPoint(subPath, [0.5 * (basePoint[0] + cData[0]), 0.5 * (basePoint[1] + cData[1])]);\n            }\n\n            addPoint(subPath, [0.5 * (cData[0] + cData[2]), 0.5 * (cData[1] + cData[3])]);\n            addPoint(subPath, [0.5 * (cData[2] + cData[4]), 0.5 * (cData[3] + cData[5])]);\n            if (curves.length) addPoint(subPath, basePoint = cData.slice(-2));\n          }\n        }\n\n        break;\n    } // Save final command coordinates\n\n\n    if (data.length >= 2) addPoint(subPath, data.slice(-2));\n  }\n\n  return points;\n}\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @type {(points: Point) => Point}\n */\n\n\nfunction convexHull(points) {\n  points.list.sort(function (a, b) {\n    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n  });\n  var lower = [],\n      minY = 0,\n      bottom = 0;\n\n  for (let i = 0; i < points.list.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <= 0) {\n      lower.pop();\n    }\n\n    if (points.list[i][1] < points.list[minY][1]) {\n      minY = i;\n      bottom = lower.length;\n    }\n\n    lower.push(points.list[i]);\n  }\n\n  var upper = [],\n      maxY = points.list.length - 1,\n      top = 0;\n\n  for (let i = points.list.length; i--;) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <= 0) {\n      upper.pop();\n    }\n\n    if (points.list[i][1] > points.list[maxY][1]) {\n      maxY = i;\n      top = upper.length;\n    }\n\n    upper.push(points.list[i]);\n  } // last points are equal to starting points of the other part\n\n\n  upper.pop();\n  lower.pop();\n  const hullList = lower.concat(upper);\n  /**\n   * @type {Point}\n   */\n\n  const hull = {\n    list: hullList,\n    minX: 0,\n    // by sorting\n    maxX: lower.length,\n    minY: bottom,\n    maxY: (lower.length + top) % hullList.length\n  };\n  return hull;\n}\n/**\n * @type {(o: Array<number>, a: Array<number>, b: Array<number>) => number}\n */\n\n\nfunction cross(o, a, b) {\n  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n/**\n * Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n *\n * @type {(\n *  x1: number,\n *  y1: number,\n *  rx: number,\n *  ry: number,\n *  angle: number,\n *  large_arc_flag: number,\n *  sweep_flag: number,\n *  x2: number,\n *  y2: number,\n *  recursive: Array<number>\n * ) => Array<number>}\n */\n\n\nconst a2c = (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) => {\n  // for more information of where this Math came from visit:\n  // https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const _120 = Math.PI * 120 / 180;\n\n  const rad = Math.PI / 180 * (+angle || 0);\n  /**\n   * @type {Array<number>}\n   */\n\n  let res = [];\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n\n  const rotateX = (x, y, rad) => {\n    return x * Math.cos(rad) - y * Math.sin(rad);\n  };\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n\n\n  const rotateY = (x, y, rad) => {\n    return x * Math.sin(rad) + y * Math.cos(rad);\n  };\n\n  if (!recursive) {\n    x1 = rotateX(x1, y1, -rad);\n    y1 = rotateY(x1, y1, -rad);\n    x2 = rotateX(x2, y2, -rad);\n    y2 = rotateY(x2, y2, -rad);\n    var x = (x1 - x2) / 2,\n        y = (y1 - y2) / 2;\n    var h = x * x / (rx * rx) + y * y / (ry * ry);\n\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n\n    var rx2 = rx * rx;\n    var ry2 = ry * ry;\n    var k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));\n    var cx = k * rx * y / ry + (x1 + x2) / 2;\n    var cy = k * -ry * x / rx + (y1 + y2) / 2;\n    var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));\n    var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n\n  var df = f2 - f1;\n\n  if (Math.abs(df) > _120) {\n    var f2old = f2,\n        x2old = x2,\n        y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n\n  df = f2 - f1;\n  var c1 = Math.cos(f1),\n      s1 = Math.sin(f1),\n      c2 = Math.cos(f2),\n      s2 = Math.sin(f2),\n      t = Math.tan(df / 4),\n      hx = 4 / 3 * rx * t,\n      hy = 4 / 3 * ry * t,\n      m = [-hx * s1, hy * c1, x2 + hx * s2 - x1, y2 - hy * c2 - y1, x2 - x1, y2 - y1];\n\n  if (recursive) {\n    return m.concat(res);\n  } else {\n    res = m.concat(res);\n    var newres = [];\n\n    for (var i = 0, n = res.length; i < n; i++) {\n      newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);\n    }\n\n    return newres;\n  }\n};","map":{"version":3,"names":["parsePathData","stringifyPathData","require","prevCtrlPoint","path2js","path","pathJS","pathData","newPathData","attributes","d","command","args","push","length","exports","convertRelativeToAbsolute","data","newData","start","cursor","slice","js2path","params","item","last","pop","precision","floatPrecision","disableSpaceAfterFlags","noSpaceAfterFlags","set","dest","source","intersects","path1","path2","points1","gatherPoints","points2","maxX","minX","maxY","minY","list","every","set1","set2","hullNest1","map","convexHull","hullNest2","some","hull1","hull2","simplex","getSupport","direction","minus","iterations","console","error","dot","processSimplex","a","b","sub","supportPoint","polygon","index","max","Infinity","value","AO","AB","orth","shift","c","AC","ACB","ABC","splice","v","v1","v2","from","o","points","addPoint","point","Math","min","i","pathDataItem","subPath","prev","basePoint","ctrlPoint","toAbsolute","n","curves","a2c","apply","concat","cData","sort","lower","bottom","cross","upper","top","hullList","hull","x1","y1","rx","ry","angle","large_arc_flag","sweep_flag","x2","y2","recursive","_120","PI","rad","res","rotateX","x","y","cos","sin","rotateY","h","sqrt","rx2","ry2","k","abs","cx","cy","f1","asin","Number","toFixed","f2","df","f2old","x2old","y2old","c1","s1","c2","s2","t","tan","hx","hy","m","newres"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/svgo/plugins/_path.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst { parsePathData, stringifyPathData } = require('../lib/path.js');\n\n/**\n * @type {[number, number]}\n */\nvar prevCtrlPoint;\n\n/**\n * Convert path string to JS representation.\n *\n * @type {(path: XastElement) => Array<PathDataItem>}\n */\nconst path2js = (path) => {\n  // @ts-ignore legacy\n  if (path.pathJS) return path.pathJS;\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const pathData = []; // JS representation of the path data\n  const newPathData = parsePathData(path.attributes.d);\n  for (const { command, args } of newPathData) {\n    pathData.push({ command, args });\n  }\n  // First moveto is actually absolute. Subsequent coordinates were separated above.\n  if (pathData.length && pathData[0].command == 'm') {\n    pathData[0].command = 'M';\n  }\n  // @ts-ignore legacy\n  path.pathJS = pathData;\n  return pathData;\n};\nexports.path2js = path2js;\n\n/**\n * Convert relative Path data to absolute.\n *\n * @type {(data: Array<PathDataItem>) => Array<PathDataItem>}\n *\n */\nconst convertRelativeToAbsolute = (data) => {\n  /**\n   * @type {Array<PathDataItem>}\n   */\n  const newData = [];\n  let start = [0, 0];\n  let cursor = [0, 0];\n\n  for (let { command, args } of data) {\n    args = args.slice();\n\n    // moveto (x y)\n    if (command === 'm') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'M';\n    }\n    if (command === 'M') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n\n    // horizontal lineto (x)\n    if (command === 'h') {\n      args[0] += cursor[0];\n      command = 'H';\n    }\n    if (command === 'H') {\n      cursor[0] = args[0];\n    }\n\n    // vertical lineto (y)\n    if (command === 'v') {\n      args[0] += cursor[1];\n      command = 'V';\n    }\n    if (command === 'V') {\n      cursor[1] = args[0];\n    }\n\n    // lineto (x y)\n    if (command === 'l') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'L';\n    }\n    if (command === 'L') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    }\n\n    // curveto (x1 y1 x2 y2 x y)\n    if (command === 'c') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      args[4] += cursor[0];\n      args[5] += cursor[1];\n      command = 'C';\n    }\n    if (command === 'C') {\n      cursor[0] = args[4];\n      cursor[1] = args[5];\n    }\n\n    // smooth curveto (x2 y2 x y)\n    if (command === 's') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'S';\n    }\n    if (command === 'S') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    }\n\n    // quadratic Bézier curveto (x1 y1 x y)\n    if (command === 'q') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      args[2] += cursor[0];\n      args[3] += cursor[1];\n      command = 'Q';\n    }\n    if (command === 'Q') {\n      cursor[0] = args[2];\n      cursor[1] = args[3];\n    }\n\n    // smooth quadratic Bézier curveto (x y)\n    if (command === 't') {\n      args[0] += cursor[0];\n      args[1] += cursor[1];\n      command = 'T';\n    }\n    if (command === 'T') {\n      cursor[0] = args[0];\n      cursor[1] = args[1];\n    }\n\n    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n    if (command === 'a') {\n      args[5] += cursor[0];\n      args[6] += cursor[1];\n      command = 'A';\n    }\n    if (command === 'A') {\n      cursor[0] = args[5];\n      cursor[1] = args[6];\n    }\n\n    // closepath\n    if (command === 'z' || command === 'Z') {\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n      command = 'z';\n    }\n\n    newData.push({ command, args });\n  }\n  return newData;\n};\n\n/**\n * @typedef {{ floatPrecision?: number, noSpaceAfterFlags?: boolean }} Js2PathParams\n */\n\n/**\n * Convert path array to string.\n *\n * @type {(path: XastElement, data: Array<PathDataItem>, params: Js2PathParams) => void}\n */\nexports.js2path = function (path, data, params) {\n  // @ts-ignore legacy\n  path.pathJS = data;\n\n  const pathData = [];\n  for (const item of data) {\n    // remove moveto commands which are followed by moveto commands\n    if (\n      pathData.length !== 0 &&\n      (item.command === 'M' || item.command === 'm')\n    ) {\n      const last = pathData[pathData.length - 1];\n      if (last.command === 'M' || last.command === 'm') {\n        pathData.pop();\n      }\n    }\n    pathData.push({\n      command: item.command,\n      args: item.args,\n    });\n  }\n\n  path.attributes.d = stringifyPathData({\n    pathData,\n    precision: params.floatPrecision,\n    disableSpaceAfterFlags: params.noSpaceAfterFlags,\n  });\n};\n\n/**\n * @type {(dest: Array<number>, source: Array<number>) => Array<number>}\n */\nfunction set(dest, source) {\n  dest[0] = source[source.length - 2];\n  dest[1] = source[source.length - 1];\n  return dest;\n}\n\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * https://web.archive.org/web/20180822200027/http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @type {(path1: Array<PathDataItem>, path2: Array<PathDataItem>) => boolean}\n */\nexports.intersects = function (path1, path2) {\n  // Collect points of every subpath.\n  const points1 = gatherPoints(convertRelativeToAbsolute(path1));\n  const points2 = gatherPoints(convertRelativeToAbsolute(path2));\n\n  // Axis-aligned bounding box check.\n  if (\n    points1.maxX <= points2.minX ||\n    points2.maxX <= points1.minX ||\n    points1.maxY <= points2.minY ||\n    points2.maxY <= points1.minY ||\n    points1.list.every((set1) => {\n      return points2.list.every((set2) => {\n        return (\n          set1.list[set1.maxX][0] <= set2.list[set2.minX][0] ||\n          set2.list[set2.maxX][0] <= set1.list[set1.minX][0] ||\n          set1.list[set1.maxY][1] <= set2.list[set2.minY][1] ||\n          set2.list[set2.maxY][1] <= set1.list[set1.minY][1]\n        );\n      });\n    })\n  )\n    return false;\n\n  // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).\n  const hullNest1 = points1.list.map(convexHull);\n  const hullNest2 = points2.list.map(convexHull);\n\n  // Check intersection of every subpath of the first path with every subpath of the second.\n  return hullNest1.some(function (hull1) {\n    if (hull1.list.length < 3) return false;\n\n    return hullNest2.some(function (hull2) {\n      if (hull2.list.length < 3) return false;\n\n      var simplex = [getSupport(hull1, hull2, [1, 0])], // create the initial simplex\n        direction = minus(simplex[0]); // set the direction to point towards the origin\n\n      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        // eslint-disable-next-line no-constant-condition\n        if (iterations-- == 0) {\n          console.error(\n            'Error: infinite loop while processing mergePaths plugin.'\n          );\n          return true; // true is the safe value that means “do nothing with paths”\n        }\n        // add a new point\n        simplex.push(getSupport(hull1, hull2, direction));\n        // see if the new point was on the correct side of the origin\n        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;\n        // process the simplex\n        if (processSimplex(simplex, direction)) return true;\n      }\n    });\n  });\n\n  /**\n   * @type {(a: Point, b: Point, direction: Array<number>) => Array<number>}\n   */\n  function getSupport(a, b, direction) {\n    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n  }\n\n  // Computes farthest polygon point in particular direction.\n  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n  /**\n   * @type {(polygon: Point, direction: Array<number>) => Array<number>}\n   */\n  function supportPoint(polygon, direction) {\n    var index =\n        direction[1] >= 0\n          ? direction[0] < 0\n            ? polygon.maxY\n            : polygon.maxX\n          : direction[0] < 0\n          ? polygon.minX\n          : polygon.minY,\n      max = -Infinity,\n      value;\n    while ((value = dot(polygon.list[index], direction)) > max) {\n      max = value;\n      index = ++index % polygon.list.length;\n    }\n    return polygon.list[(index || polygon.list.length) - 1];\n  }\n};\n\n/**\n * @type {(simplex: Array<Array<number>>, direction: Array<number>) => boolean}\n */\nfunction processSimplex(simplex, direction) {\n  // we only need to handle to 1-simplex and 2-simplex\n  if (simplex.length == 2) {\n    // 1-simplex\n    let a = simplex[1],\n      b = simplex[0],\n      AO = minus(simplex[1]),\n      AB = sub(b, a);\n    // AO is in the same direction as AB\n    if (dot(AO, AB) > 0) {\n      // get the vector perpendicular to AB facing O\n      set(direction, orth(AB, a));\n    } else {\n      set(direction, AO);\n      // only A remains in the simplex\n      simplex.shift();\n    }\n  } else {\n    // 2-simplex\n    let a = simplex[2], // [a, b, c] = simplex\n      b = simplex[1],\n      c = simplex[0],\n      AB = sub(b, a),\n      AC = sub(c, a),\n      AO = minus(a),\n      ACB = orth(AB, AC), // the vector perpendicular to AB facing away from C\n      ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n    if (dot(ACB, AO) > 0) {\n      if (dot(AB, AO) > 0) {\n        // region 4\n        set(direction, ACB);\n        simplex.shift(); // simplex = [b, a]\n      } else {\n        // region 5\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else if (dot(ABC, AO) > 0) {\n      if (dot(AC, AO) > 0) {\n        // region 6\n        set(direction, ABC);\n        simplex.splice(1, 1); // simplex = [c, a]\n      } else {\n        // region 5 (again)\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } // region 7\n    else return true;\n  }\n  return false;\n}\n\n/**\n * @type {(v: Array<number>) => Array<number>}\n */\nfunction minus(v) {\n  return [-v[0], -v[1]];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => number}\n */\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n\n/**\n * @type {(v1: Array<number>, v2: Array<number>) => Array<number>}\n */\nfunction orth(v, from) {\n  var o = [-v[1], v[0]];\n  return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\n\n/**\n * @typedef {{\n *   list: Array<Array<number>>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Point\n */\n\n/**\n * @typedef {{\n *   list: Array<Point>,\n *   minX: number,\n *   minY: number,\n *   maxX: number,\n *   maxY: number\n * }} Points\n */\n\n/**\n * @type {(pathData: Array<PathDataItem>) => Points}\n */\nfunction gatherPoints(pathData) {\n  /**\n   * @type {Points}\n   */\n  const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };\n\n  // Writes data about the extreme points on each axle\n  /**\n   * @type {(path: Point, point: Array<number>) => void}\n   */\n  const addPoint = (path, point) => {\n    if (!path.list.length || point[1] > path.list[path.maxY][1]) {\n      path.maxY = path.list.length;\n      points.maxY = points.list.length\n        ? Math.max(point[1], points.maxY)\n        : point[1];\n    }\n    if (!path.list.length || point[0] > path.list[path.maxX][0]) {\n      path.maxX = path.list.length;\n      points.maxX = points.list.length\n        ? Math.max(point[0], points.maxX)\n        : point[0];\n    }\n    if (!path.list.length || point[1] < path.list[path.minY][1]) {\n      path.minY = path.list.length;\n      points.minY = points.list.length\n        ? Math.min(point[1], points.minY)\n        : point[1];\n    }\n    if (!path.list.length || point[0] < path.list[path.minX][0]) {\n      path.minX = path.list.length;\n      points.minX = points.list.length\n        ? Math.min(point[0], points.minX)\n        : point[0];\n    }\n    path.list.push(point);\n  };\n\n  for (let i = 0; i < pathData.length; i += 1) {\n    const pathDataItem = pathData[i];\n    let subPath =\n      points.list.length === 0\n        ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 }\n        : points.list[points.list.length - 1];\n    let prev = i === 0 ? null : pathData[i - 1];\n    let basePoint =\n      subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];\n    let data = pathDataItem.args;\n    let ctrlPoint = basePoint;\n\n    /**\n     * @type {(n: number, i: number) => number}\n     * TODO fix null hack\n     */\n    const toAbsolute = (n, i) => n + (basePoint == null ? 0 : basePoint[i % 2]);\n\n    switch (pathDataItem.command) {\n      case 'M':\n        subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };\n        points.list.push(subPath);\n        break;\n\n      case 'H':\n        if (basePoint != null) {\n          addPoint(subPath, [data[0], basePoint[1]]);\n        }\n        break;\n\n      case 'V':\n        if (basePoint != null) {\n          addPoint(subPath, [basePoint[0], data[0]]);\n        }\n        break;\n\n      case 'Q':\n        addPoint(subPath, data.slice(0, 2));\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n        break;\n\n      case 'T':\n        if (\n          basePoint != null &&\n          prev != null &&\n          (prev.command == 'Q' || prev.command == 'T')\n        ) {\n          ctrlPoint = [\n            basePoint[0] + prevCtrlPoint[0],\n            basePoint[1] + prevCtrlPoint[1],\n          ];\n          addPoint(subPath, ctrlPoint);\n          prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n        }\n        break;\n\n      case 'C':\n        if (basePoint != null) {\n          // Approximate quibic Bezier curve with middle points between control points\n          addPoint(subPath, [\n            0.5 * (basePoint[0] + data[0]),\n            0.5 * (basePoint[1] + data[1]),\n          ]);\n        }\n        addPoint(subPath, [\n          0.5 * (data[0] + data[2]),\n          0.5 * (data[1] + data[3]),\n        ]);\n        addPoint(subPath, [\n          0.5 * (data[2] + data[4]),\n          0.5 * (data[3] + data[5]),\n        ]);\n        prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n        break;\n\n      case 'S':\n        if (\n          basePoint != null &&\n          prev != null &&\n          (prev.command == 'C' || prev.command == 'S')\n        ) {\n          addPoint(subPath, [\n            basePoint[0] + 0.5 * prevCtrlPoint[0],\n            basePoint[1] + 0.5 * prevCtrlPoint[1],\n          ]);\n          ctrlPoint = [\n            basePoint[0] + prevCtrlPoint[0],\n            basePoint[1] + prevCtrlPoint[1],\n          ];\n        }\n        if (ctrlPoint != null) {\n          addPoint(subPath, [\n            0.5 * (ctrlPoint[0] + data[0]),\n            0.5 * (ctrlPoint[1] + data[1]),\n          ]);\n        }\n        addPoint(subPath, [\n          0.5 * (data[0] + data[2]),\n          0.5 * (data[1] + data[3]),\n        ]);\n        prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n        break;\n\n      case 'A':\n        if (basePoint != null) {\n          // Convert the arc to bezier curves and use the same approximation\n          // @ts-ignore no idea what's going on here\n          var curves = a2c.apply(0, basePoint.concat(data));\n          for (\n            var cData;\n            (cData = curves.splice(0, 6).map(toAbsolute)).length;\n\n          ) {\n            if (basePoint != null) {\n              addPoint(subPath, [\n                0.5 * (basePoint[0] + cData[0]),\n                0.5 * (basePoint[1] + cData[1]),\n              ]);\n            }\n            addPoint(subPath, [\n              0.5 * (cData[0] + cData[2]),\n              0.5 * (cData[1] + cData[3]),\n            ]);\n            addPoint(subPath, [\n              0.5 * (cData[2] + cData[4]),\n              0.5 * (cData[3] + cData[5]),\n            ]);\n            if (curves.length) addPoint(subPath, (basePoint = cData.slice(-2)));\n          }\n        }\n        break;\n    }\n\n    // Save final command coordinates\n    if (data.length >= 2) addPoint(subPath, data.slice(-2));\n  }\n\n  return points;\n}\n\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @type {(points: Point) => Point}\n */\nfunction convexHull(points) {\n  points.list.sort(function (a, b) {\n    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n  });\n\n  var lower = [],\n    minY = 0,\n    bottom = 0;\n  for (let i = 0; i < points.list.length; i++) {\n    while (\n      lower.length >= 2 &&\n      cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <=\n        0\n    ) {\n      lower.pop();\n    }\n    if (points.list[i][1] < points.list[minY][1]) {\n      minY = i;\n      bottom = lower.length;\n    }\n    lower.push(points.list[i]);\n  }\n\n  var upper = [],\n    maxY = points.list.length - 1,\n    top = 0;\n  for (let i = points.list.length; i--; ) {\n    while (\n      upper.length >= 2 &&\n      cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <=\n        0\n    ) {\n      upper.pop();\n    }\n    if (points.list[i][1] > points.list[maxY][1]) {\n      maxY = i;\n      top = upper.length;\n    }\n    upper.push(points.list[i]);\n  }\n\n  // last points are equal to starting points of the other part\n  upper.pop();\n  lower.pop();\n\n  const hullList = lower.concat(upper);\n\n  /**\n   * @type {Point}\n   */\n  const hull = {\n    list: hullList,\n    minX: 0, // by sorting\n    maxX: lower.length,\n    minY: bottom,\n    maxY: (lower.length + top) % hullList.length,\n  };\n\n  return hull;\n}\n\n/**\n * @type {(o: Array<number>, a: Array<number>, b: Array<number>) => number}\n */\nfunction cross(o, a, b) {\n  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\n/**\n * Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n *\n * @type {(\n *  x1: number,\n *  y1: number,\n *  rx: number,\n *  ry: number,\n *  angle: number,\n *  large_arc_flag: number,\n *  sweep_flag: number,\n *  x2: number,\n *  y2: number,\n *  recursive: Array<number>\n * ) => Array<number>}\n */\nconst a2c = (\n  x1,\n  y1,\n  rx,\n  ry,\n  angle,\n  large_arc_flag,\n  sweep_flag,\n  x2,\n  y2,\n  recursive\n) => {\n  // for more information of where this Math came from visit:\n  // https://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  const _120 = (Math.PI * 120) / 180;\n  const rad = (Math.PI / 180) * (+angle || 0);\n  /**\n   * @type {Array<number>}\n   */\n  let res = [];\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n  const rotateX = (x, y, rad) => {\n    return x * Math.cos(rad) - y * Math.sin(rad);\n  };\n  /**\n   * @type {(x: number, y: number, rad: number) => number}\n   */\n  const rotateY = (x, y, rad) => {\n    return x * Math.sin(rad) + y * Math.cos(rad);\n  };\n  if (!recursive) {\n    x1 = rotateX(x1, y1, -rad);\n    y1 = rotateY(x1, y1, -rad);\n    x2 = rotateX(x2, y2, -rad);\n    y2 = rotateY(x2, y2, -rad);\n    var x = (x1 - x2) / 2,\n      y = (y1 - y2) / 2;\n    var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n    var rx2 = rx * rx;\n    var ry2 = ry * ry;\n    var k =\n      (large_arc_flag == sweep_flag ? -1 : 1) *\n      Math.sqrt(\n        Math.abs(\n          (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)\n        )\n      );\n    var cx = (k * rx * y) / ry + (x1 + x2) / 2;\n    var cy = (k * -ry * x) / rx + (y1 + y2) / 2;\n    var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));\n    var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));\n\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n  var df = f2 - f1;\n  if (Math.abs(df) > _120) {\n    var f2old = f2,\n      x2old = x2,\n      y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [\n      f2,\n      f2old,\n      cx,\n      cy,\n    ]);\n  }\n  df = f2 - f1;\n  var c1 = Math.cos(f1),\n    s1 = Math.sin(f1),\n    c2 = Math.cos(f2),\n    s2 = Math.sin(f2),\n    t = Math.tan(df / 4),\n    hx = (4 / 3) * rx * t,\n    hy = (4 / 3) * ry * t,\n    m = [\n      -hx * s1,\n      hy * c1,\n      x2 + hx * s2 - x1,\n      y2 - hy * c2 - y1,\n      x2 - x1,\n      y2 - y1,\n    ];\n  if (recursive) {\n    return m.concat(res);\n  } else {\n    res = m.concat(res);\n    var newres = [];\n    for (var i = 0, n = res.length; i < n; i++) {\n      newres[i] =\n        i % 2\n          ? rotateY(res[i - 1], res[i], rad)\n          : rotateX(res[i], res[i + 1], rad);\n    }\n    return newres;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}