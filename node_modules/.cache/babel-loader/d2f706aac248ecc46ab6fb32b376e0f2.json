{"ast":null,"code":"/**\n * @fileoverview Enforce consistent usage of destructuring assignment of props, state, and context.\n */\n'use strict';\n\nconst Components = require('../util/Components');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst isAssignmentLHS = require('../util/ast').isAssignmentLHS;\n\nconst report = require('../util/report');\n\nconst DEFAULT_OPTION = 'always';\n\nfunction createSFCParams() {\n  const queue = [];\n  return {\n    push(params) {\n      queue.unshift(params);\n    },\n\n    pop() {\n      queue.shift();\n    },\n\n    propsName() {\n      const found = queue.find(params => {\n        const props = params[0];\n        return props && !props.destructuring && props.name;\n      });\n      return found && found[0] && found[0].name;\n    },\n\n    contextName() {\n      const found = queue.find(params => {\n        const context = params[1];\n        return context && !context.destructuring && context.name;\n      });\n      return found && found[1] && found[1].name;\n    }\n\n  };\n}\n\nfunction evalParams(params) {\n  return params.map(param => ({\n    destructuring: param.type === 'ObjectPattern',\n    name: param.type === 'Identifier' && param.name\n  }));\n}\n\nconst messages = {\n  noDestructPropsInSFCArg: 'Must never use destructuring props assignment in SFC argument',\n  noDestructContextInSFCArg: 'Must never use destructuring context assignment in SFC argument',\n  noDestructAssignment: 'Must never use destructuring {{type}} assignment',\n  useDestructAssignment: 'Must use destructuring {{type}} assignment',\n  destructureInSignature: 'Must destructure props in the function signature.'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce consistent usage of destructuring assignment of props, state, and context',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('destructuring-assignment')\n    },\n    fixable: 'code',\n    messages,\n    schema: [{\n      type: 'string',\n      enum: ['always', 'never']\n    }, {\n      type: 'object',\n      properties: {\n        ignoreClassFields: {\n          type: 'boolean'\n        },\n        destructureInSignature: {\n          type: 'string',\n          enum: ['always', 'ignore']\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  create: Components.detect((context, components, utils) => {\n    const configuration = context.options[0] || DEFAULT_OPTION;\n    const ignoreClassFields = context.options[1] && context.options[1].ignoreClassFields === true || false;\n    const destructureInSignature = context.options[1] && context.options[1].destructureInSignature || 'ignore';\n    const sfcParams = createSFCParams();\n    /**\n     * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n     *   FunctionDeclaration, or FunctionExpression\n     */\n\n    function handleStatelessComponent(node) {\n      const params = evalParams(node.params);\n      const SFCComponent = components.get(context.getScope(node).block);\n\n      if (!SFCComponent) {\n        return;\n      }\n\n      sfcParams.push(params);\n\n      if (params[0] && params[0].destructuring && components.get(node) && configuration === 'never') {\n        report(context, messages.noDestructPropsInSFCArg, 'noDestructPropsInSFCArg', {\n          node\n        });\n      } else if (params[1] && params[1].destructuring && components.get(node) && configuration === 'never') {\n        report(context, messages.noDestructContextInSFCArg, 'noDestructContextInSFCArg', {\n          node\n        });\n      }\n    }\n\n    function handleStatelessComponentExit(node) {\n      const SFCComponent = components.get(context.getScope(node).block);\n\n      if (SFCComponent) {\n        sfcParams.pop();\n      }\n    }\n\n    function handleSFCUsage(node) {\n      const propsName = sfcParams.propsName();\n      const contextName = sfcParams.contextName(); // props.aProp || context.aProp\n\n      const isPropUsed = (propsName && node.object.name === propsName || contextName && node.object.name === contextName) && !isAssignmentLHS(node);\n\n      if (isPropUsed && configuration === 'always') {\n        report(context, messages.useDestructAssignment, 'useDestructAssignment', {\n          node,\n          data: {\n            type: node.object.name\n          }\n        });\n      }\n    }\n\n    function isInClassProperty(node) {\n      let curNode = node.parent;\n\n      while (curNode) {\n        if (curNode.type === 'ClassProperty' || curNode.type === 'PropertyDefinition') {\n          return true;\n        }\n\n        curNode = curNode.parent;\n      }\n\n      return false;\n    }\n\n    function handleClassUsage(node) {\n      // this.props.Aprop || this.context.aProp || this.state.aState\n      const isPropUsed = node.object.type === 'MemberExpression' && node.object.object.type === 'ThisExpression' && (node.object.property.name === 'props' || node.object.property.name === 'context' || node.object.property.name === 'state') && !isAssignmentLHS(node);\n\n      if (isPropUsed && configuration === 'always' && !(ignoreClassFields && isInClassProperty(node))) {\n        report(context, messages.useDestructAssignment, 'useDestructAssignment', {\n          node,\n          data: {\n            type: node.object.property.name\n          }\n        });\n      }\n    }\n\n    return {\n      FunctionDeclaration: handleStatelessComponent,\n      ArrowFunctionExpression: handleStatelessComponent,\n      FunctionExpression: handleStatelessComponent,\n      'FunctionDeclaration:exit': handleStatelessComponentExit,\n      'ArrowFunctionExpression:exit': handleStatelessComponentExit,\n      'FunctionExpression:exit': handleStatelessComponentExit,\n\n      MemberExpression(node) {\n        let scope = context.getScope(node);\n        let SFCComponent = components.get(scope.block);\n\n        while (!SFCComponent && scope.upper && scope.upper !== scope) {\n          SFCComponent = components.get(scope.upper.block);\n          scope = scope.upper;\n        }\n\n        if (SFCComponent) {\n          handleSFCUsage(node);\n        }\n\n        const classComponent = utils.getParentComponent(node);\n\n        if (classComponent) {\n          handleClassUsage(node);\n        }\n      },\n\n      VariableDeclarator(node) {\n        const classComponent = utils.getParentComponent(node);\n        const SFCComponent = components.get(context.getScope(node).block);\n        const destructuring = node.init && node.id && node.id.type === 'ObjectPattern'; // let {foo} = props;\n\n        const destructuringSFC = destructuring && (node.init.name === 'props' || node.init.name === 'context'); // let {foo} = this.props;\n\n        const destructuringClass = destructuring && node.init.object && node.init.object.type === 'ThisExpression' && (node.init.property.name === 'props' || node.init.property.name === 'context' || node.init.property.name === 'state');\n\n        if (SFCComponent && destructuringSFC && configuration === 'never') {\n          report(context, messages.noDestructAssignment, 'noDestructAssignment', {\n            node,\n            data: {\n              type: node.init.name\n            }\n          });\n        }\n\n        if (classComponent && destructuringClass && configuration === 'never' && !(ignoreClassFields && (node.parent.type === 'ClassProperty' || node.parent.type === 'PropertyDefinition'))) {\n          report(context, messages.noDestructAssignment, 'noDestructAssignment', {\n            node,\n            data: {\n              type: node.init.property.name\n            }\n          });\n        }\n\n        if (SFCComponent && destructuringSFC && configuration === 'always' && destructureInSignature === 'always' && node.init.name === 'props') {\n          const scopeSetProps = context.getScope().set.get('props');\n          const propsRefs = scopeSetProps && scopeSetProps.references;\n\n          if (!propsRefs) {\n            return;\n          } // Skip if props is used elsewhere\n\n\n          if (propsRefs.length > 1) {\n            return;\n          }\n\n          report(context, messages.destructureInSignature, 'destructureInSignature', {\n            node,\n\n            fix(fixer) {\n              const param = SFCComponent.node.params[0];\n\n              if (!param) {\n                return;\n              }\n\n              const replaceRange = [param.range[0], param.typeAnnotation ? param.typeAnnotation.range[0] : param.range[1]];\n              return [fixer.replaceTextRange(replaceRange, context.getSourceCode().getText(node.id)), fixer.remove(node.parent)];\n            }\n\n          });\n        }\n      }\n\n    };\n  })\n};","map":{"version":3,"names":["Components","require","docsUrl","isAssignmentLHS","report","DEFAULT_OPTION","createSFCParams","queue","push","params","unshift","pop","shift","propsName","found","find","props","destructuring","name","contextName","context","evalParams","map","param","type","messages","noDestructPropsInSFCArg","noDestructContextInSFCArg","noDestructAssignment","useDestructAssignment","destructureInSignature","module","exports","meta","docs","description","category","recommended","url","fixable","schema","enum","properties","ignoreClassFields","additionalProperties","create","detect","components","utils","configuration","options","sfcParams","handleStatelessComponent","node","SFCComponent","get","getScope","block","handleStatelessComponentExit","handleSFCUsage","isPropUsed","object","data","isInClassProperty","curNode","parent","handleClassUsage","property","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","MemberExpression","scope","upper","classComponent","getParentComponent","VariableDeclarator","init","id","destructuringSFC","destructuringClass","scopeSetProps","set","propsRefs","references","length","fix","fixer","replaceRange","range","typeAnnotation","replaceTextRange","getSourceCode","getText","remove"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/destructuring-assignment.js"],"sourcesContent":["/**\n * @fileoverview Enforce consistent usage of destructuring assignment of props, state, and context.\n */\n\n'use strict';\n\nconst Components = require('../util/Components');\nconst docsUrl = require('../util/docsUrl');\nconst isAssignmentLHS = require('../util/ast').isAssignmentLHS;\nconst report = require('../util/report');\n\nconst DEFAULT_OPTION = 'always';\n\nfunction createSFCParams() {\n  const queue = [];\n\n  return {\n    push(params) {\n      queue.unshift(params);\n    },\n    pop() {\n      queue.shift();\n    },\n    propsName() {\n      const found = queue.find((params) => {\n        const props = params[0];\n        return props && !props.destructuring && props.name;\n      });\n      return found && found[0] && found[0].name;\n    },\n    contextName() {\n      const found = queue.find((params) => {\n        const context = params[1];\n        return context && !context.destructuring && context.name;\n      });\n      return found && found[1] && found[1].name;\n    },\n  };\n}\n\nfunction evalParams(params) {\n  return params.map((param) => ({\n    destructuring: param.type === 'ObjectPattern',\n    name: param.type === 'Identifier' && param.name,\n  }));\n}\n\nconst messages = {\n  noDestructPropsInSFCArg: 'Must never use destructuring props assignment in SFC argument',\n  noDestructContextInSFCArg: 'Must never use destructuring context assignment in SFC argument',\n  noDestructAssignment: 'Must never use destructuring {{type}} assignment',\n  useDestructAssignment: 'Must use destructuring {{type}} assignment',\n  destructureInSignature: 'Must destructure props in the function signature.',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce consistent usage of destructuring assignment of props, state, and context',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('destructuring-assignment'),\n    },\n    fixable: 'code',\n    messages,\n\n    schema: [{\n      type: 'string',\n      enum: [\n        'always',\n        'never',\n      ],\n    }, {\n      type: 'object',\n      properties: {\n        ignoreClassFields: {\n          type: 'boolean',\n        },\n        destructureInSignature: {\n          type: 'string',\n          enum: [\n            'always',\n            'ignore',\n          ],\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components, utils) => {\n    const configuration = context.options[0] || DEFAULT_OPTION;\n    const ignoreClassFields = (context.options[1] && (context.options[1].ignoreClassFields === true)) || false;\n    const destructureInSignature = (context.options[1] && context.options[1].destructureInSignature) || 'ignore';\n    const sfcParams = createSFCParams();\n\n    /**\n     * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n     *   FunctionDeclaration, or FunctionExpression\n     */\n    function handleStatelessComponent(node) {\n      const params = evalParams(node.params);\n\n      const SFCComponent = components.get(context.getScope(node).block);\n      if (!SFCComponent) {\n        return;\n      }\n      sfcParams.push(params);\n\n      if (params[0] && params[0].destructuring && components.get(node) && configuration === 'never') {\n        report(context, messages.noDestructPropsInSFCArg, 'noDestructPropsInSFCArg', {\n          node,\n        });\n      } else if (params[1] && params[1].destructuring && components.get(node) && configuration === 'never') {\n        report(context, messages.noDestructContextInSFCArg, 'noDestructContextInSFCArg', {\n          node,\n        });\n      }\n    }\n\n    function handleStatelessComponentExit(node) {\n      const SFCComponent = components.get(context.getScope(node).block);\n      if (SFCComponent) {\n        sfcParams.pop();\n      }\n    }\n\n    function handleSFCUsage(node) {\n      const propsName = sfcParams.propsName();\n      const contextName = sfcParams.contextName();\n      // props.aProp || context.aProp\n      const isPropUsed = (\n        (propsName && node.object.name === propsName)\n          || (contextName && node.object.name === contextName)\n      )\n        && !isAssignmentLHS(node);\n      if (isPropUsed && configuration === 'always') {\n        report(context, messages.useDestructAssignment, 'useDestructAssignment', {\n          node,\n          data: {\n            type: node.object.name,\n          },\n        });\n      }\n    }\n\n    function isInClassProperty(node) {\n      let curNode = node.parent;\n      while (curNode) {\n        if (curNode.type === 'ClassProperty' || curNode.type === 'PropertyDefinition') {\n          return true;\n        }\n        curNode = curNode.parent;\n      }\n      return false;\n    }\n\n    function handleClassUsage(node) {\n      // this.props.Aprop || this.context.aProp || this.state.aState\n      const isPropUsed = (\n        node.object.type === 'MemberExpression' && node.object.object.type === 'ThisExpression'\n        && (node.object.property.name === 'props' || node.object.property.name === 'context' || node.object.property.name === 'state')\n        && !isAssignmentLHS(node)\n      );\n\n      if (\n        isPropUsed && configuration === 'always'\n        && !(ignoreClassFields && isInClassProperty(node))\n      ) {\n        report(context, messages.useDestructAssignment, 'useDestructAssignment', {\n          node,\n          data: {\n            type: node.object.property.name,\n          },\n        });\n      }\n    }\n\n    return {\n\n      FunctionDeclaration: handleStatelessComponent,\n\n      ArrowFunctionExpression: handleStatelessComponent,\n\n      FunctionExpression: handleStatelessComponent,\n\n      'FunctionDeclaration:exit': handleStatelessComponentExit,\n\n      'ArrowFunctionExpression:exit': handleStatelessComponentExit,\n\n      'FunctionExpression:exit': handleStatelessComponentExit,\n\n      MemberExpression(node) {\n        let scope = context.getScope(node);\n        let SFCComponent = components.get(scope.block);\n        while (!SFCComponent && scope.upper && scope.upper !== scope) {\n          SFCComponent = components.get(scope.upper.block);\n          scope = scope.upper;\n        }\n        if (SFCComponent) {\n          handleSFCUsage(node);\n        }\n\n        const classComponent = utils.getParentComponent(node);\n        if (classComponent) {\n          handleClassUsage(node);\n        }\n      },\n\n      VariableDeclarator(node) {\n        const classComponent = utils.getParentComponent(node);\n        const SFCComponent = components.get(context.getScope(node).block);\n\n        const destructuring = (node.init && node.id && node.id.type === 'ObjectPattern');\n        // let {foo} = props;\n        const destructuringSFC = destructuring && (node.init.name === 'props' || node.init.name === 'context');\n        // let {foo} = this.props;\n        const destructuringClass = destructuring && node.init.object && node.init.object.type === 'ThisExpression' && (\n          node.init.property.name === 'props' || node.init.property.name === 'context' || node.init.property.name === 'state'\n        );\n\n        if (SFCComponent && destructuringSFC && configuration === 'never') {\n          report(context, messages.noDestructAssignment, 'noDestructAssignment', {\n            node,\n            data: {\n              type: node.init.name,\n            },\n          });\n        }\n\n        if (\n          classComponent && destructuringClass && configuration === 'never'\n          && !(ignoreClassFields && (node.parent.type === 'ClassProperty' || node.parent.type === 'PropertyDefinition'))\n        ) {\n          report(context, messages.noDestructAssignment, 'noDestructAssignment', {\n            node,\n            data: {\n              type: node.init.property.name,\n            },\n          });\n        }\n\n        if (\n          SFCComponent\n          && destructuringSFC\n          && configuration === 'always'\n          && destructureInSignature === 'always'\n          && node.init.name === 'props'\n        ) {\n          const scopeSetProps = context.getScope().set.get('props');\n          const propsRefs = scopeSetProps && scopeSetProps.references;\n          if (!propsRefs) {\n            return;\n          }\n          // Skip if props is used elsewhere\n          if (propsRefs.length > 1) {\n            return;\n          }\n          report(context, messages.destructureInSignature, 'destructureInSignature', {\n            node,\n            fix(fixer) {\n              const param = SFCComponent.node.params[0];\n              if (!param) {\n                return;\n              }\n              const replaceRange = [\n                param.range[0],\n                param.typeAnnotation ? param.typeAnnotation.range[0] : param.range[1],\n              ];\n              return [\n                fixer.replaceTextRange(replaceRange, context.getSourceCode().getText(node.id)),\n                fixer.remove(node.parent),\n              ];\n            },\n          });\n        }\n      },\n    };\n  }),\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}