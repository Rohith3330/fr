{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'consistent-type-definitions',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce type definitions to consistently use either `interface` or `type`',\n      recommended: 'strict'\n    },\n    messages: {\n      interfaceOverType: 'Use an `interface` instead of a `type`.',\n      typeOverInterface: 'Use a `type` instead of an `interface`.'\n    },\n    schema: [{\n      enum: ['interface', 'type']\n    }],\n    fixable: 'code'\n  },\n  defaultOptions: ['interface'],\n\n  create(context, _ref) {\n    let [option] = _ref;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Iterates from the highest parent to the currently traversed node\n     * to determine whether any node in tree is globally declared module declaration\n     */\n\n    function isCurrentlyTraversedNodeWithinModuleDeclaration() {\n      return context.getAncestors().some(node => node.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration && node.declare && node.global);\n    }\n\n    return Object.assign(Object.assign({}, option === 'interface' && {\n      \"TSTypeAliasDeclaration[typeAnnotation.type='TSTypeLiteral']\"(node) {\n        context.report({\n          node: node.id,\n          messageId: 'interfaceOverType',\n\n          fix(fixer) {\n            var _a;\n\n            const typeNode = (_a = node.typeParameters) !== null && _a !== void 0 ? _a : node.id;\n            const fixes = [];\n            const firstToken = sourceCode.getTokenBefore(node.id);\n\n            if (firstToken) {\n              fixes.push(fixer.replaceText(firstToken, 'interface'));\n              fixes.push(fixer.replaceTextRange([typeNode.range[1], node.typeAnnotation.range[0]], ' '));\n            }\n\n            const afterToken = sourceCode.getTokenAfter(node.typeAnnotation);\n\n            if (afterToken && afterToken.type === utils_1.AST_TOKEN_TYPES.Punctuator && afterToken.value === ';') {\n              fixes.push(fixer.remove(afterToken));\n            }\n\n            return fixes;\n          }\n\n        });\n      }\n\n    }), option === 'type' && {\n      TSInterfaceDeclaration(node) {\n        const fix = isCurrentlyTraversedNodeWithinModuleDeclaration() ? null : fixer => {\n          var _a, _b;\n\n          const typeNode = (_a = node.typeParameters) !== null && _a !== void 0 ? _a : node.id;\n          const fixes = [];\n          const firstToken = sourceCode.getTokenBefore(node.id);\n\n          if (firstToken) {\n            fixes.push(fixer.replaceText(firstToken, 'type'));\n            fixes.push(fixer.replaceTextRange([typeNode.range[1], node.body.range[0]], ' = '));\n          }\n\n          if (node.extends) {\n            node.extends.forEach(heritage => {\n              const typeIdentifier = sourceCode.getText(heritage);\n              fixes.push(fixer.insertTextAfter(node.body, ` & ${typeIdentifier}`));\n            });\n          }\n\n          if (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) {\n            fixes.push(fixer.removeRange([node.parent.range[0], node.range[0]]), fixer.insertTextAfter(node.body, `\\nexport default ${node.id.name}`));\n          }\n\n          return fixes;\n        };\n        context.report({\n          node: node.id,\n          messageId: 'typeOverInterface',\n\n          /**\n           * remove automatically fix when the interface is within a declare global\n           * @see {@link https://github.com/typescript-eslint/typescript-eslint/issues/2707}\n           */\n          fix\n        });\n      }\n\n    });\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","messages","interfaceOverType","typeOverInterface","schema","enum","fixable","defaultOptions","create","context","option","sourceCode","getSourceCode","isCurrentlyTraversedNodeWithinModuleDeclaration","getAncestors","some","node","utils_1","TSModuleDeclaration","declare","global","report","id","messageId","fix","fixer","typeNode","typeParameters","_a","fixes","firstToken","getTokenBefore","push","replaceText","replaceTextRange","range","typeAnnotation","afterToken","getTokenAfter","Punctuator","value","remove","TSInterfaceDeclaration","body","extends","forEach","heritage","typeIdentifier","getText","insertTextAfter","parent","_b","ExportDefaultDeclaration","removeRange"],"sources":["../../src/rules/consistent-type-definitions.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}