{"ast":null,"code":"export default function collapseDuplicateDeclarations() {\n  return root => {\n    root.walkRules(node => {\n      let seen = new Map();\n      let droppable = new Set([]);\n      let byProperty = new Map();\n      node.walkDecls(decl => {\n        // This could happen if we have nested selectors. In that case the\n        // parent will loop over all its declarations but also the declarations\n        // of nested rules. With this we ensure that we are shallowly checking\n        // declarations.\n        if (decl.parent !== node) {\n          return;\n        }\n\n        if (seen.has(decl.prop)) {\n          // Exact same value as what we have seen so far\n          if (seen.get(decl.prop).value === decl.value) {\n            // Keep the last one, drop the one we've seen so far\n            droppable.add(seen.get(decl.prop)); // Override the existing one with the new value. This is necessary\n            // so that if we happen to have more than one declaration with the\n            // same value, that we keep removing the previous one. Otherwise we\n            // will only remove the *first* one.\n\n            seen.set(decl.prop, decl);\n            return;\n          } // Not the same value, so we need to check if we can merge it so\n          // let's collect it first.\n\n\n          if (!byProperty.has(decl.prop)) {\n            byProperty.set(decl.prop, new Set());\n          }\n\n          byProperty.get(decl.prop).add(seen.get(decl.prop));\n          byProperty.get(decl.prop).add(decl);\n        }\n\n        seen.set(decl.prop, decl);\n      }); // Drop all the duplicate declarations with the exact same value we've\n      // already seen so far.\n\n      for (let decl of droppable) {\n        decl.remove();\n      } // Analyze the declarations based on its unit, drop all the declarations\n      // with the same unit but the last one in the list.\n\n\n      for (let declarations of byProperty.values()) {\n        let byUnit = new Map();\n\n        for (let decl of declarations) {\n          let unit = resolveUnit(decl.value);\n\n          if (unit === null) {\n            // We don't have a unit, so should never try and collapse this\n            // value. This is because we can't know how to do it in a correct\n            // way (e.g.: overrides for older browsers)\n            continue;\n          }\n\n          if (!byUnit.has(unit)) {\n            byUnit.set(unit, new Set());\n          }\n\n          byUnit.get(unit).add(decl);\n        }\n\n        for (let declarations of byUnit.values()) {\n          // Get all but the last one\n          let removableDeclarations = Array.from(declarations).slice(0, -1);\n\n          for (let decl of removableDeclarations) {\n            decl.remove();\n          }\n        }\n      }\n    });\n  };\n}\nlet UNITLESS_NUMBER = Symbol('unitless-number');\n\nfunction resolveUnit(input) {\n  let result = /^-?\\d*.?\\d+([\\w%]+)?$/g.exec(input);\n\n  if (result) {\n    return result[1] ?? UNITLESS_NUMBER;\n  }\n\n  return null;\n}","map":{"version":3,"names":["collapseDuplicateDeclarations","root","walkRules","node","seen","Map","droppable","Set","byProperty","walkDecls","decl","parent","has","prop","get","value","add","set","remove","declarations","values","byUnit","unit","resolveUnit","removableDeclarations","Array","from","slice","UNITLESS_NUMBER","Symbol","input","result","exec"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/src/lib/collapseDuplicateDeclarations.js"],"sourcesContent":["export default function collapseDuplicateDeclarations() {\n  return (root) => {\n    root.walkRules((node) => {\n      let seen = new Map()\n      let droppable = new Set([])\n      let byProperty = new Map()\n\n      node.walkDecls((decl) => {\n        // This could happen if we have nested selectors. In that case the\n        // parent will loop over all its declarations but also the declarations\n        // of nested rules. With this we ensure that we are shallowly checking\n        // declarations.\n        if (decl.parent !== node) {\n          return\n        }\n\n        if (seen.has(decl.prop)) {\n          // Exact same value as what we have seen so far\n          if (seen.get(decl.prop).value === decl.value) {\n            // Keep the last one, drop the one we've seen so far\n            droppable.add(seen.get(decl.prop))\n            // Override the existing one with the new value. This is necessary\n            // so that if we happen to have more than one declaration with the\n            // same value, that we keep removing the previous one. Otherwise we\n            // will only remove the *first* one.\n            seen.set(decl.prop, decl)\n            return\n          }\n\n          // Not the same value, so we need to check if we can merge it so\n          // let's collect it first.\n          if (!byProperty.has(decl.prop)) {\n            byProperty.set(decl.prop, new Set())\n          }\n\n          byProperty.get(decl.prop).add(seen.get(decl.prop))\n          byProperty.get(decl.prop).add(decl)\n        }\n\n        seen.set(decl.prop, decl)\n      })\n\n      // Drop all the duplicate declarations with the exact same value we've\n      // already seen so far.\n      for (let decl of droppable) {\n        decl.remove()\n      }\n\n      // Analyze the declarations based on its unit, drop all the declarations\n      // with the same unit but the last one in the list.\n      for (let declarations of byProperty.values()) {\n        let byUnit = new Map()\n\n        for (let decl of declarations) {\n          let unit = resolveUnit(decl.value)\n          if (unit === null) {\n            // We don't have a unit, so should never try and collapse this\n            // value. This is because we can't know how to do it in a correct\n            // way (e.g.: overrides for older browsers)\n            continue\n          }\n\n          if (!byUnit.has(unit)) {\n            byUnit.set(unit, new Set())\n          }\n\n          byUnit.get(unit).add(decl)\n        }\n\n        for (let declarations of byUnit.values()) {\n          // Get all but the last one\n          let removableDeclarations = Array.from(declarations).slice(0, -1)\n\n          for (let decl of removableDeclarations) {\n            decl.remove()\n          }\n        }\n      }\n    })\n  }\n}\n\nlet UNITLESS_NUMBER = Symbol('unitless-number')\n\nfunction resolveUnit(input) {\n  let result = /^-?\\d*.?\\d+([\\w%]+)?$/g.exec(input)\n\n  if (result) {\n    return result[1] ?? UNITLESS_NUMBER\n  }\n\n  return null\n}\n"],"mappings":"AAAA,eAAe,SAASA,6BAAT,GAAyC;EACtD,OAAQC,IAAD,IAAU;IACfA,IAAI,CAACC,SAAL,CAAgBC,IAAD,IAAU;MACvB,IAAIC,IAAI,GAAG,IAAIC,GAAJ,EAAX;MACA,IAAIC,SAAS,GAAG,IAAIC,GAAJ,CAAQ,EAAR,CAAhB;MACA,IAAIC,UAAU,GAAG,IAAIH,GAAJ,EAAjB;MAEAF,IAAI,CAACM,SAAL,CAAgBC,IAAD,IAAU;QACvB;QACA;QACA;QACA;QACA,IAAIA,IAAI,CAACC,MAAL,KAAgBR,IAApB,EAA0B;UACxB;QACD;;QAED,IAAIC,IAAI,CAACQ,GAAL,CAASF,IAAI,CAACG,IAAd,CAAJ,EAAyB;UACvB;UACA,IAAIT,IAAI,CAACU,GAAL,CAASJ,IAAI,CAACG,IAAd,EAAoBE,KAApB,KAA8BL,IAAI,CAACK,KAAvC,EAA8C;YAC5C;YACAT,SAAS,CAACU,GAAV,CAAcZ,IAAI,CAACU,GAAL,CAASJ,IAAI,CAACG,IAAd,CAAd,EAF4C,CAG5C;YACA;YACA;YACA;;YACAT,IAAI,CAACa,GAAL,CAASP,IAAI,CAACG,IAAd,EAAoBH,IAApB;YACA;UACD,CAXsB,CAavB;UACA;;;UACA,IAAI,CAACF,UAAU,CAACI,GAAX,CAAeF,IAAI,CAACG,IAApB,CAAL,EAAgC;YAC9BL,UAAU,CAACS,GAAX,CAAeP,IAAI,CAACG,IAApB,EAA0B,IAAIN,GAAJ,EAA1B;UACD;;UAEDC,UAAU,CAACM,GAAX,CAAeJ,IAAI,CAACG,IAApB,EAA0BG,GAA1B,CAA8BZ,IAAI,CAACU,GAAL,CAASJ,IAAI,CAACG,IAAd,CAA9B;UACAL,UAAU,CAACM,GAAX,CAAeJ,IAAI,CAACG,IAApB,EAA0BG,GAA1B,CAA8BN,IAA9B;QACD;;QAEDN,IAAI,CAACa,GAAL,CAASP,IAAI,CAACG,IAAd,EAAoBH,IAApB;MACD,CAjCD,EALuB,CAwCvB;MACA;;MACA,KAAK,IAAIA,IAAT,IAAiBJ,SAAjB,EAA4B;QAC1BI,IAAI,CAACQ,MAAL;MACD,CA5CsB,CA8CvB;MACA;;;MACA,KAAK,IAAIC,YAAT,IAAyBX,UAAU,CAACY,MAAX,EAAzB,EAA8C;QAC5C,IAAIC,MAAM,GAAG,IAAIhB,GAAJ,EAAb;;QAEA,KAAK,IAAIK,IAAT,IAAiBS,YAAjB,EAA+B;UAC7B,IAAIG,IAAI,GAAGC,WAAW,CAACb,IAAI,CAACK,KAAN,CAAtB;;UACA,IAAIO,IAAI,KAAK,IAAb,EAAmB;YACjB;YACA;YACA;YACA;UACD;;UAED,IAAI,CAACD,MAAM,CAACT,GAAP,CAAWU,IAAX,CAAL,EAAuB;YACrBD,MAAM,CAACJ,GAAP,CAAWK,IAAX,EAAiB,IAAIf,GAAJ,EAAjB;UACD;;UAEDc,MAAM,CAACP,GAAP,CAAWQ,IAAX,EAAiBN,GAAjB,CAAqBN,IAArB;QACD;;QAED,KAAK,IAAIS,YAAT,IAAyBE,MAAM,CAACD,MAAP,EAAzB,EAA0C;UACxC;UACA,IAAII,qBAAqB,GAAGC,KAAK,CAACC,IAAN,CAAWP,YAAX,EAAyBQ,KAAzB,CAA+B,CAA/B,EAAkC,CAAC,CAAnC,CAA5B;;UAEA,KAAK,IAAIjB,IAAT,IAAiBc,qBAAjB,EAAwC;YACtCd,IAAI,CAACQ,MAAL;UACD;QACF;MACF;IACF,CA5ED;EA6ED,CA9ED;AA+ED;AAED,IAAIU,eAAe,GAAGC,MAAM,CAAC,iBAAD,CAA5B;;AAEA,SAASN,WAAT,CAAqBO,KAArB,EAA4B;EAC1B,IAAIC,MAAM,GAAG,yBAAyBC,IAAzB,CAA8BF,KAA9B,CAAb;;EAEA,IAAIC,MAAJ,EAAY;IACV,OAAOA,MAAM,CAAC,CAAD,CAAN,IAAaH,eAApB;EACD;;EAED,OAAO,IAAP;AACD"},"metadata":{},"sourceType":"module"}