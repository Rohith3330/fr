{"ast":null,"code":"\"use strict\"; // external tooling\n\nconst valueParser = require(\"postcss-value-parser\"); // extended tooling\n\n\nconst {\n  stringify\n} = valueParser;\n\nfunction split(params, start) {\n  const list = [];\n  const last = params.reduce((item, node, index) => {\n    if (index < start) return \"\";\n\n    if (node.type === \"div\" && node.value === \",\") {\n      list.push(item);\n      return \"\";\n    }\n\n    return item + stringify(node);\n  }, \"\");\n  list.push(last);\n  return list;\n}\n\nmodule.exports = function (result, styles) {\n  const statements = [];\n  let nodes = [];\n  styles.each(node => {\n    let stmt;\n\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\") stmt = parseImport(result, node);else if (node.name === \"media\") stmt = parseMedia(result, node);else if (node.name === \"charset\") stmt = parseCharset(result, node);\n    }\n\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes,\n          media: [],\n          layer: []\n        });\n        nodes = [];\n      }\n\n      statements.push(stmt);\n    } else nodes.push(node);\n  });\n\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes,\n      media: [],\n      layer: []\n    });\n  }\n\n  return statements;\n};\n\nfunction parseMedia(result, atRule) {\n  const params = valueParser(atRule.params).nodes;\n  return {\n    type: \"media\",\n    node: atRule,\n    media: split(params, 0),\n    layer: []\n  };\n}\n\nfunction parseCharset(result, atRule) {\n  if (atRule.prev()) {\n    return result.warn(\"@charset must precede all other statements\", {\n      node: atRule\n    });\n  }\n\n  return {\n    type: \"charset\",\n    node: atRule,\n    media: [],\n    layer: []\n  };\n}\n\nfunction parseImport(result, atRule) {\n  let prev = atRule.prev();\n\n  if (prev) {\n    do {\n      if (prev.type !== \"comment\" && (prev.type !== \"atrule\" || prev.name !== \"import\" && prev.name !== \"charset\" && !(prev.name === \"layer\" && !prev.nodes))) {\n        return result.warn(\"@import must precede all other statements (besides @charset or empty @layer)\", {\n          node: atRule\n        });\n      }\n\n      prev = prev.prev();\n    } while (prev);\n  }\n\n  if (atRule.nodes) {\n    return result.warn(\"It looks like you didn't end your @import statement correctly. \" + \"Child nodes are attached to it.\", {\n      node: atRule\n    });\n  }\n\n  const params = valueParser(atRule.params).nodes;\n  const stmt = {\n    type: \"import\",\n    node: atRule,\n    media: [],\n    layer: []\n  }; // prettier-ignore\n\n  if (!params.length || (params[0].type !== \"string\" || !params[0].value) && (params[0].type !== \"function\" || params[0].value !== \"url\" || !params[0].nodes.length || !params[0].nodes[0].value)) {\n    return result.warn(`Unable to find uri in '${atRule.toString()}'`, {\n      node: atRule\n    });\n  }\n\n  if (params[0].type === \"string\") stmt.uri = params[0].value;else stmt.uri = params[0].nodes[0].value;\n  stmt.fullUri = stringify(params[0]);\n  let remainder = params;\n\n  if (remainder.length > 2) {\n    if ((remainder[2].type === \"word\" || remainder[2].type === \"function\") && remainder[2].value === \"layer\") {\n      if (remainder[1].type !== \"space\") {\n        return result.warn(\"Invalid import layer statement\", {\n          node: atRule\n        });\n      }\n\n      if (remainder[2].nodes) {\n        stmt.layer = [stringify(remainder[2].nodes)];\n      } else {\n        stmt.layer = [\"\"];\n      }\n\n      remainder = remainder.slice(2);\n    }\n  }\n\n  if (remainder.length > 2) {\n    if (remainder[1].type !== \"space\") {\n      return result.warn(\"Invalid import media statement\", {\n        node: atRule\n      });\n    }\n\n    stmt.media = split(remainder, 2);\n  }\n\n  return stmt;\n}","map":{"version":3,"names":["valueParser","require","stringify","split","params","start","list","last","reduce","item","node","index","type","value","push","module","exports","result","styles","statements","nodes","each","stmt","name","parseImport","parseMedia","parseCharset","length","media","layer","atRule","prev","warn","toString","uri","fullUri","remainder","slice"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-import/lib/parse-statements.js"],"sourcesContent":["\"use strict\"\n\n// external tooling\nconst valueParser = require(\"postcss-value-parser\")\n\n// extended tooling\nconst { stringify } = valueParser\n\nfunction split(params, start) {\n  const list = []\n  const last = params.reduce((item, node, index) => {\n    if (index < start) return \"\"\n    if (node.type === \"div\" && node.value === \",\") {\n      list.push(item)\n      return \"\"\n    }\n    return item + stringify(node)\n  }, \"\")\n  list.push(last)\n  return list\n}\n\nmodule.exports = function (result, styles) {\n  const statements = []\n  let nodes = []\n\n  styles.each(node => {\n    let stmt\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\") stmt = parseImport(result, node)\n      else if (node.name === \"media\") stmt = parseMedia(result, node)\n      else if (node.name === \"charset\") stmt = parseCharset(result, node)\n    }\n\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes,\n          media: [],\n          layer: [],\n        })\n        nodes = []\n      }\n      statements.push(stmt)\n    } else nodes.push(node)\n  })\n\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes,\n      media: [],\n      layer: [],\n    })\n  }\n\n  return statements\n}\n\nfunction parseMedia(result, atRule) {\n  const params = valueParser(atRule.params).nodes\n  return {\n    type: \"media\",\n    node: atRule,\n    media: split(params, 0),\n    layer: [],\n  }\n}\n\nfunction parseCharset(result, atRule) {\n  if (atRule.prev()) {\n    return result.warn(\"@charset must precede all other statements\", {\n      node: atRule,\n    })\n  }\n  return {\n    type: \"charset\",\n    node: atRule,\n    media: [],\n    layer: [],\n  }\n}\n\nfunction parseImport(result, atRule) {\n  let prev = atRule.prev()\n  if (prev) {\n    do {\n      if (\n        prev.type !== \"comment\" &&\n        (prev.type !== \"atrule\" ||\n          (prev.name !== \"import\" &&\n            prev.name !== \"charset\" &&\n            !(prev.name === \"layer\" && !prev.nodes)))\n      ) {\n        return result.warn(\n          \"@import must precede all other statements (besides @charset or empty @layer)\",\n          { node: atRule }\n        )\n      }\n      prev = prev.prev()\n    } while (prev)\n  }\n\n  if (atRule.nodes) {\n    return result.warn(\n      \"It looks like you didn't end your @import statement correctly. \" +\n        \"Child nodes are attached to it.\",\n      { node: atRule }\n    )\n  }\n\n  const params = valueParser(atRule.params).nodes\n  const stmt = {\n    type: \"import\",\n    node: atRule,\n    media: [],\n    layer: [],\n  }\n\n  // prettier-ignore\n  if (\n    !params.length ||\n    (\n      params[0].type !== \"string\" ||\n      !params[0].value\n    ) &&\n    (\n      params[0].type !== \"function\" ||\n      params[0].value !== \"url\" ||\n      !params[0].nodes.length ||\n      !params[0].nodes[0].value\n    )\n  ) {\n    return result.warn(`Unable to find uri in '${  atRule.toString()  }'`, {\n      node: atRule,\n    })\n  }\n\n  if (params[0].type === \"string\") stmt.uri = params[0].value\n  else stmt.uri = params[0].nodes[0].value\n  stmt.fullUri = stringify(params[0])\n\n  let remainder = params\n  if (remainder.length > 2) {\n    if (\n      (remainder[2].type === \"word\" || remainder[2].type === \"function\") &&\n      remainder[2].value === \"layer\"\n    ) {\n      if (remainder[1].type !== \"space\") {\n        return result.warn(\"Invalid import layer statement\", { node: atRule })\n      }\n\n      if (remainder[2].nodes) {\n        stmt.layer = [stringify(remainder[2].nodes)]\n      } else {\n        stmt.layer = [\"\"]\n      }\n      remainder = remainder.slice(2)\n    }\n  }\n\n  if (remainder.length > 2) {\n    if (remainder[1].type !== \"space\") {\n      return result.warn(\"Invalid import media statement\", { node: atRule })\n    }\n\n    stmt.media = split(remainder, 2)\n  }\n\n  return stmt\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}