{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst normalize_1 = require(\"./normalize\");\n\nconst range_tree_1 = require(\"./range-tree\");\n/**\n * Merges a list of process coverages.\n *\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param processCovs Process coverages to merge.\n * @return Merged process coverage.\n */\n\n\nfunction mergeProcessCovs(processCovs) {\n  if (processCovs.length === 0) {\n    return {\n      result: []\n    };\n  }\n\n  const urlToScripts = new Map();\n\n  for (const processCov of processCovs) {\n    for (const scriptCov of processCov.result) {\n      let scriptCovs = urlToScripts.get(scriptCov.url);\n\n      if (scriptCovs === undefined) {\n        scriptCovs = [];\n        urlToScripts.set(scriptCov.url, scriptCovs);\n      }\n\n      scriptCovs.push(scriptCov);\n    }\n  }\n\n  const result = [];\n\n  for (const scripts of urlToScripts.values()) {\n    // assert: `scripts.length > 0`\n    result.push(mergeScriptCovs(scripts));\n  }\n\n  const merged = {\n    result\n  };\n  normalize_1.normalizeProcessCov(merged);\n  return merged;\n}\n\nexports.mergeProcessCovs = mergeProcessCovs;\n/**\n * Merges a list of matching script coverages.\n *\n * Scripts are matching if they have the same `url`.\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param scriptCovs Process coverages to merge.\n * @return Merged script coverage, or `undefined` if the input list was empty.\n */\n\nfunction mergeScriptCovs(scriptCovs) {\n  if (scriptCovs.length === 0) {\n    return undefined;\n  } else if (scriptCovs.length === 1) {\n    const merged = scriptCovs[0];\n    normalize_1.deepNormalizeScriptCov(merged);\n    return merged;\n  }\n\n  const first = scriptCovs[0];\n  const scriptId = first.scriptId;\n  const url = first.url;\n  const rangeToFuncs = new Map();\n\n  for (const scriptCov of scriptCovs) {\n    for (const funcCov of scriptCov.functions) {\n      const rootRange = stringifyFunctionRootRange(funcCov);\n      let funcCovs = rangeToFuncs.get(rootRange);\n\n      if (funcCovs === undefined || // if the entry in rangeToFuncs is function-level granularity and\n      // the new coverage is block-level, prefer block-level.\n      !funcCovs[0].isBlockCoverage && funcCov.isBlockCoverage) {\n        funcCovs = [];\n        rangeToFuncs.set(rootRange, funcCovs);\n      } else if (funcCovs[0].isBlockCoverage && !funcCov.isBlockCoverage) {\n        // if the entry in rangeToFuncs is block-level granularity, we should\n        // not append function level granularity.\n        continue;\n      }\n\n      funcCovs.push(funcCov);\n    }\n  }\n\n  const functions = [];\n\n  for (const funcCovs of rangeToFuncs.values()) {\n    // assert: `funcCovs.length > 0`\n    functions.push(mergeFunctionCovs(funcCovs));\n  }\n\n  const merged = {\n    scriptId,\n    url,\n    functions\n  };\n  normalize_1.normalizeScriptCov(merged);\n  return merged;\n}\n\nexports.mergeScriptCovs = mergeScriptCovs;\n/**\n * Returns a string representation of the root range of the function.\n *\n * This string can be used to match function with same root range.\n * The string is derived from the start and end offsets of the root range of\n * the function.\n * This assumes that `ranges` is non-empty (true for valid function coverages).\n *\n * @param funcCov Function coverage with the range to stringify\n * @internal\n */\n\nfunction stringifyFunctionRootRange(funcCov) {\n  const rootRange = funcCov.ranges[0];\n  return `${rootRange.startOffset.toString(10)};${rootRange.endOffset.toString(10)}`;\n}\n/**\n * Merges a list of matching function coverages.\n *\n * Functions are matching if their root ranges have the same span.\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param funcCovs Function coverages to merge.\n * @return Merged function coverage, or `undefined` if the input list was empty.\n */\n\n\nfunction mergeFunctionCovs(funcCovs) {\n  if (funcCovs.length === 0) {\n    return undefined;\n  } else if (funcCovs.length === 1) {\n    const merged = funcCovs[0];\n    normalize_1.normalizeFunctionCov(merged);\n    return merged;\n  }\n\n  const functionName = funcCovs[0].functionName;\n  const trees = [];\n\n  for (const funcCov of funcCovs) {\n    // assert: `fn.ranges.length > 0`\n    // assert: `fn.ranges` is sorted\n    trees.push(range_tree_1.RangeTree.fromSortedRanges(funcCov.ranges));\n  } // assert: `trees.length > 0`\n\n\n  const mergedTree = mergeRangeTrees(trees);\n  normalize_1.normalizeRangeTree(mergedTree);\n  const ranges = mergedTree.toRanges();\n  const isBlockCoverage = !(ranges.length === 1 && ranges[0].count === 0);\n  const merged = {\n    functionName,\n    ranges,\n    isBlockCoverage\n  }; // assert: `merged` is normalized\n\n  return merged;\n}\n\nexports.mergeFunctionCovs = mergeFunctionCovs;\n/**\n * @precondition Same `start` and `end` for all the trees\n */\n\nfunction mergeRangeTrees(trees) {\n  if (trees.length <= 1) {\n    return trees[0];\n  }\n\n  const first = trees[0];\n  let delta = 0;\n\n  for (const tree of trees) {\n    delta += tree.delta;\n  }\n\n  const children = mergeRangeTreeChildren(trees);\n  return new range_tree_1.RangeTree(first.start, first.end, delta, children);\n}\n\nclass RangeTreeWithParent {\n  constructor(parentIndex, tree) {\n    this.parentIndex = parentIndex;\n    this.tree = tree;\n  }\n\n}\n\nclass StartEvent {\n  constructor(offset, trees) {\n    this.offset = offset;\n    this.trees = trees;\n  }\n\n  static compare(a, b) {\n    return a.offset - b.offset;\n  }\n\n}\n\nclass StartEventQueue {\n  constructor(queue) {\n    this.queue = queue;\n    this.nextIndex = 0;\n    this.pendingOffset = 0;\n    this.pendingTrees = undefined;\n  }\n\n  static fromParentTrees(parentTrees) {\n    const startToTrees = new Map();\n\n    for (const [parentIndex, parentTree] of parentTrees.entries()) {\n      for (const child of parentTree.children) {\n        let trees = startToTrees.get(child.start);\n\n        if (trees === undefined) {\n          trees = [];\n          startToTrees.set(child.start, trees);\n        }\n\n        trees.push(new RangeTreeWithParent(parentIndex, child));\n      }\n    }\n\n    const queue = [];\n\n    for (const [startOffset, trees] of startToTrees) {\n      queue.push(new StartEvent(startOffset, trees));\n    }\n\n    queue.sort(StartEvent.compare);\n    return new StartEventQueue(queue);\n  }\n\n  setPendingOffset(offset) {\n    this.pendingOffset = offset;\n  }\n\n  pushPendingTree(tree) {\n    if (this.pendingTrees === undefined) {\n      this.pendingTrees = [];\n    }\n\n    this.pendingTrees.push(tree);\n  }\n\n  next() {\n    const pendingTrees = this.pendingTrees;\n    const nextEvent = this.queue[this.nextIndex];\n\n    if (pendingTrees === undefined) {\n      this.nextIndex++;\n      return nextEvent;\n    } else if (nextEvent === undefined) {\n      this.pendingTrees = undefined;\n      return new StartEvent(this.pendingOffset, pendingTrees);\n    } else {\n      if (this.pendingOffset < nextEvent.offset) {\n        this.pendingTrees = undefined;\n        return new StartEvent(this.pendingOffset, pendingTrees);\n      } else {\n        if (this.pendingOffset === nextEvent.offset) {\n          this.pendingTrees = undefined;\n\n          for (const tree of pendingTrees) {\n            nextEvent.trees.push(tree);\n          }\n        }\n\n        this.nextIndex++;\n        return nextEvent;\n      }\n    }\n  }\n\n}\n\nfunction mergeRangeTreeChildren(parentTrees) {\n  const result = [];\n  const startEventQueue = StartEventQueue.fromParentTrees(parentTrees);\n  const parentToNested = new Map();\n  let openRange;\n\n  while (true) {\n    const event = startEventQueue.next();\n\n    if (event === undefined) {\n      break;\n    }\n\n    if (openRange !== undefined && openRange.end <= event.offset) {\n      result.push(nextChild(openRange, parentToNested));\n      openRange = undefined;\n    }\n\n    if (openRange === undefined) {\n      let openRangeEnd = event.offset + 1;\n\n      for (const {\n        parentIndex,\n        tree\n      } of event.trees) {\n        openRangeEnd = Math.max(openRangeEnd, tree.end);\n        insertChild(parentToNested, parentIndex, tree);\n      }\n\n      startEventQueue.setPendingOffset(openRangeEnd);\n      openRange = {\n        start: event.offset,\n        end: openRangeEnd\n      };\n    } else {\n      for (const {\n        parentIndex,\n        tree\n      } of event.trees) {\n        if (tree.end > openRange.end) {\n          const right = tree.split(openRange.end);\n          startEventQueue.pushPendingTree(new RangeTreeWithParent(parentIndex, right));\n        }\n\n        insertChild(parentToNested, parentIndex, tree);\n      }\n    }\n  }\n\n  if (openRange !== undefined) {\n    result.push(nextChild(openRange, parentToNested));\n  }\n\n  return result;\n}\n\nfunction insertChild(parentToNested, parentIndex, tree) {\n  let nested = parentToNested.get(parentIndex);\n\n  if (nested === undefined) {\n    nested = [];\n    parentToNested.set(parentIndex, nested);\n  }\n\n  nested.push(tree);\n}\n\nfunction nextChild(openRange, parentToNested) {\n  const matchingTrees = [];\n\n  for (const nested of parentToNested.values()) {\n    if (nested.length === 1 && nested[0].start === openRange.start && nested[0].end === openRange.end) {\n      matchingTrees.push(nested[0]);\n    } else {\n      matchingTrees.push(new range_tree_1.RangeTree(openRange.start, openRange.end, 0, nested));\n    }\n  }\n\n  parentToNested.clear();\n  return mergeRangeTrees(matchingTrees);\n}","map":{"version":3,"mappings":"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","names":["mergeProcessCovs","processCovs","length","result","urlToScripts","Map","processCov","scriptCov","scriptCovs","get","url","undefined","set","push","scripts","values","mergeScriptCovs","merged","normalize_1","exports","first","scriptId","rangeToFuncs","funcCov","functions","rootRange","stringifyFunctionRootRange","funcCovs","isBlockCoverage","mergeFunctionCovs","ranges","startOffset","toString","endOffset","functionName","trees","range_tree_1","fromSortedRanges","mergedTree","mergeRangeTrees","toRanges","count","delta","tree","children","mergeRangeTreeChildren","start","end","RangeTreeWithParent","constructor","parentIndex","StartEvent","offset","compare","a","b","StartEventQueue","queue","nextIndex","pendingOffset","pendingTrees","fromParentTrees","parentTrees","startToTrees","parentTree","entries","child","sort","setPendingOffset","pushPendingTree","next","nextEvent","startEventQueue","parentToNested","openRange","event","nextChild","openRangeEnd","Math","max","insertChild","right","split","nested","matchingTrees","clear"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@bcoe\\v8-coverage\\dist\\lib\\_src\\merge.ts"],"sourcesContent":["import {\n  deepNormalizeScriptCov,\n  normalizeFunctionCov,\n  normalizeProcessCov,\n  normalizeRangeTree,\n  normalizeScriptCov,\n} from \"./normalize\";\nimport { RangeTree } from \"./range-tree\";\nimport { FunctionCov, ProcessCov, Range, RangeCov, ScriptCov } from \"./types\";\n\n/**\n * Merges a list of process coverages.\n *\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param processCovs Process coverages to merge.\n * @return Merged process coverage.\n */\nexport function mergeProcessCovs(processCovs: ReadonlyArray<ProcessCov>): ProcessCov {\n  if (processCovs.length === 0) {\n    return {result: []};\n  }\n\n  const urlToScripts: Map<string, ScriptCov[]> = new Map();\n  for (const processCov of processCovs) {\n    for (const scriptCov of processCov.result) {\n      let scriptCovs: ScriptCov[] | undefined = urlToScripts.get(scriptCov.url);\n      if (scriptCovs === undefined) {\n        scriptCovs = [];\n        urlToScripts.set(scriptCov.url, scriptCovs);\n      }\n      scriptCovs.push(scriptCov);\n    }\n  }\n\n  const result: ScriptCov[] = [];\n  for (const scripts of urlToScripts.values()) {\n    // assert: `scripts.length > 0`\n    result.push(mergeScriptCovs(scripts)!);\n  }\n  const merged: ProcessCov = {result};\n\n  normalizeProcessCov(merged);\n  return merged;\n}\n\n/**\n * Merges a list of matching script coverages.\n *\n * Scripts are matching if they have the same `url`.\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param scriptCovs Process coverages to merge.\n * @return Merged script coverage, or `undefined` if the input list was empty.\n */\nexport function mergeScriptCovs(scriptCovs: ReadonlyArray<ScriptCov>): ScriptCov | undefined {\n  if (scriptCovs.length === 0) {\n    return undefined;\n  } else if (scriptCovs.length === 1) {\n    const merged: ScriptCov = scriptCovs[0];\n    deepNormalizeScriptCov(merged);\n    return merged;\n  }\n\n  const first: ScriptCov = scriptCovs[0];\n  const scriptId: string = first.scriptId;\n  const url: string = first.url;\n\n  const rangeToFuncs: Map<string, FunctionCov[]> = new Map();\n  for (const scriptCov of scriptCovs) {\n    for (const funcCov of scriptCov.functions) {\n      const rootRange: string = stringifyFunctionRootRange(funcCov);\n      let funcCovs: FunctionCov[] | undefined = rangeToFuncs.get(rootRange);\n\n      if (funcCovs === undefined ||\n        // if the entry in rangeToFuncs is function-level granularity and\n        // the new coverage is block-level, prefer block-level.\n        (!funcCovs[0].isBlockCoverage && funcCov.isBlockCoverage)) {\n        funcCovs = [];\n        rangeToFuncs.set(rootRange, funcCovs);\n      } else if (funcCovs[0].isBlockCoverage && !funcCov.isBlockCoverage) {\n        // if the entry in rangeToFuncs is block-level granularity, we should\n        // not append function level granularity.\n        continue;\n      }\n      funcCovs.push(funcCov);\n    }\n  }\n\n  const functions: FunctionCov[] = [];\n  for (const funcCovs of rangeToFuncs.values()) {\n    // assert: `funcCovs.length > 0`\n    functions.push(mergeFunctionCovs(funcCovs)!);\n  }\n\n  const merged: ScriptCov = {scriptId, url, functions};\n  normalizeScriptCov(merged);\n  return merged;\n}\n\n/**\n * Returns a string representation of the root range of the function.\n *\n * This string can be used to match function with same root range.\n * The string is derived from the start and end offsets of the root range of\n * the function.\n * This assumes that `ranges` is non-empty (true for valid function coverages).\n *\n * @param funcCov Function coverage with the range to stringify\n * @internal\n */\nfunction stringifyFunctionRootRange(funcCov: Readonly<FunctionCov>): string {\n  const rootRange: RangeCov = funcCov.ranges[0];\n  return `${rootRange.startOffset.toString(10)};${rootRange.endOffset.toString(10)}`;\n}\n\n/**\n * Merges a list of matching function coverages.\n *\n * Functions are matching if their root ranges have the same span.\n * The result is normalized.\n * The input values may be mutated, it is not safe to use them after passing\n * them to this function.\n * The computation is synchronous.\n *\n * @param funcCovs Function coverages to merge.\n * @return Merged function coverage, or `undefined` if the input list was empty.\n */\nexport function mergeFunctionCovs(funcCovs: ReadonlyArray<FunctionCov>): FunctionCov | undefined {\n  if (funcCovs.length === 0) {\n    return undefined;\n  } else if (funcCovs.length === 1) {\n    const merged: FunctionCov = funcCovs[0];\n    normalizeFunctionCov(merged);\n    return merged;\n  }\n\n  const functionName: string = funcCovs[0].functionName;\n\n  const trees: RangeTree[] = [];\n  for (const funcCov of funcCovs) {\n    // assert: `fn.ranges.length > 0`\n    // assert: `fn.ranges` is sorted\n    trees.push(RangeTree.fromSortedRanges(funcCov.ranges)!);\n  }\n\n  // assert: `trees.length > 0`\n  const mergedTree: RangeTree = mergeRangeTrees(trees)!;\n  normalizeRangeTree(mergedTree);\n  const ranges: RangeCov[] = mergedTree.toRanges();\n  const isBlockCoverage: boolean = !(ranges.length === 1 && ranges[0].count === 0);\n\n  const merged: FunctionCov = {functionName, ranges, isBlockCoverage};\n  // assert: `merged` is normalized\n  return merged;\n}\n\n/**\n * @precondition Same `start` and `end` for all the trees\n */\nfunction mergeRangeTrees(trees: ReadonlyArray<RangeTree>): RangeTree | undefined {\n  if (trees.length <= 1) {\n    return trees[0];\n  }\n  const first: RangeTree = trees[0];\n  let delta: number = 0;\n  for (const tree of trees) {\n    delta += tree.delta;\n  }\n  const children: RangeTree[] = mergeRangeTreeChildren(trees);\n  return new RangeTree(first.start, first.end, delta, children);\n}\n\nclass RangeTreeWithParent {\n  readonly parentIndex: number;\n  readonly tree: RangeTree;\n\n  constructor(parentIndex: number, tree: RangeTree) {\n    this.parentIndex = parentIndex;\n    this.tree = tree;\n  }\n}\n\nclass StartEvent {\n  readonly offset: number;\n  readonly trees: RangeTreeWithParent[];\n\n  constructor(offset: number, trees: RangeTreeWithParent[]) {\n    this.offset = offset;\n    this.trees = trees;\n  }\n\n  static compare(a: StartEvent, b: StartEvent): number {\n    return a.offset - b.offset;\n  }\n}\n\nclass StartEventQueue {\n  private readonly queue: StartEvent[];\n  private nextIndex: number;\n  private pendingOffset: number;\n  private pendingTrees: RangeTreeWithParent[] | undefined;\n\n  private constructor(queue: StartEvent[]) {\n    this.queue = queue;\n    this.nextIndex = 0;\n    this.pendingOffset = 0;\n    this.pendingTrees = undefined;\n  }\n\n  static fromParentTrees(parentTrees: ReadonlyArray<RangeTree>): StartEventQueue {\n    const startToTrees: Map<number, RangeTreeWithParent[]> = new Map();\n    for (const [parentIndex, parentTree] of parentTrees.entries()) {\n      for (const child of parentTree.children) {\n        let trees: RangeTreeWithParent[] | undefined = startToTrees.get(child.start);\n        if (trees === undefined) {\n          trees = [];\n          startToTrees.set(child.start, trees);\n        }\n        trees.push(new RangeTreeWithParent(parentIndex, child));\n      }\n    }\n    const queue: StartEvent[] = [];\n    for (const [startOffset, trees] of startToTrees) {\n      queue.push(new StartEvent(startOffset, trees));\n    }\n    queue.sort(StartEvent.compare);\n    return new StartEventQueue(queue);\n  }\n\n  setPendingOffset(offset: number): void {\n    this.pendingOffset = offset;\n  }\n\n  pushPendingTree(tree: RangeTreeWithParent): void {\n    if (this.pendingTrees === undefined) {\n      this.pendingTrees = [];\n    }\n    this.pendingTrees.push(tree);\n  }\n\n  next(): StartEvent | undefined {\n    const pendingTrees: RangeTreeWithParent[] | undefined = this.pendingTrees;\n    const nextEvent: StartEvent | undefined = this.queue[this.nextIndex];\n    if (pendingTrees === undefined) {\n      this.nextIndex++;\n      return nextEvent;\n    } else if (nextEvent === undefined) {\n      this.pendingTrees = undefined;\n      return new StartEvent(this.pendingOffset, pendingTrees);\n    } else {\n      if (this.pendingOffset < nextEvent.offset) {\n        this.pendingTrees = undefined;\n        return new StartEvent(this.pendingOffset, pendingTrees);\n      } else {\n        if (this.pendingOffset === nextEvent.offset) {\n          this.pendingTrees = undefined;\n          for (const tree of pendingTrees) {\n            nextEvent.trees.push(tree);\n          }\n        }\n        this.nextIndex++;\n        return nextEvent;\n      }\n    }\n  }\n}\n\nfunction mergeRangeTreeChildren(parentTrees: ReadonlyArray<RangeTree>): RangeTree[] {\n  const result: RangeTree[] = [];\n  const startEventQueue: StartEventQueue = StartEventQueue.fromParentTrees(parentTrees);\n  const parentToNested: Map<number, RangeTree[]> = new Map();\n  let openRange: Range | undefined;\n\n  while (true) {\n    const event: StartEvent | undefined = startEventQueue.next();\n    if (event === undefined) {\n      break;\n    }\n\n    if (openRange !== undefined && openRange.end <= event.offset) {\n      result.push(nextChild(openRange, parentToNested));\n      openRange = undefined;\n    }\n\n    if (openRange === undefined) {\n      let openRangeEnd: number = event.offset + 1;\n      for (const {parentIndex, tree} of event.trees) {\n        openRangeEnd = Math.max(openRangeEnd, tree.end);\n        insertChild(parentToNested, parentIndex, tree);\n      }\n      startEventQueue.setPendingOffset(openRangeEnd);\n      openRange = {start: event.offset, end: openRangeEnd};\n    } else {\n      for (const {parentIndex, tree} of event.trees) {\n        if (tree.end > openRange.end) {\n          const right: RangeTree = tree.split(openRange.end);\n          startEventQueue.pushPendingTree(new RangeTreeWithParent(parentIndex, right));\n        }\n        insertChild(parentToNested, parentIndex, tree);\n      }\n    }\n  }\n  if (openRange !== undefined) {\n    result.push(nextChild(openRange, parentToNested));\n  }\n\n  return result;\n}\n\nfunction insertChild(parentToNested: Map<number, RangeTree[]>, parentIndex: number, tree: RangeTree): void {\n  let nested: RangeTree[] | undefined = parentToNested.get(parentIndex);\n  if (nested === undefined) {\n    nested = [];\n    parentToNested.set(parentIndex, nested);\n  }\n  nested.push(tree);\n}\n\nfunction nextChild(openRange: Range, parentToNested: Map<number, RangeTree[]>): RangeTree {\n  const matchingTrees: RangeTree[] = [];\n\n  for (const nested of parentToNested.values()) {\n    if (nested.length === 1 && nested[0].start === openRange.start && nested[0].end === openRange.end) {\n      matchingTrees.push(nested[0]);\n    } else {\n      matchingTrees.push(new RangeTree(\n        openRange.start,\n        openRange.end,\n        0,\n        nested,\n      ));\n    }\n  }\n  parentToNested.clear();\n  return mergeRangeTrees(matchingTrees)!;\n}\n"]},"metadata":{},"sourceType":"script"}