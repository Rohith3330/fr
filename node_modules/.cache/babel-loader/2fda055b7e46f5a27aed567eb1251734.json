{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar _t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isNullLiteral,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isRegExpLiteral,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator,\n  isRecordExpression,\n  isTupleExpression,\n  isObjectProperty,\n  isTopicReference,\n  isMetaProperty,\n  isPrivateName\n} = _t;\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      gatherNodeParts(node.name, parts);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n\n    if (declar.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        binding == null ? void 0 : binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding == null ? void 0 : binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const shouldSkip = path.key === \"key\" || path.listKey === \"decorators\";\n      path = path.parentPath;\n      if (shouldSkip && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return identifier(this.generateUid(name));\n  }\n\n  generateUid() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"temp\";\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && kind === \"const\";\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path) {\n    let bindingPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path;\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {\n      return true;\n    } else if (isClass(node)) {\n      var _node$decorators;\n\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (isArrayExpression(node) || isTupleExpression(node)) {\n      for (const elem of node.elements) {\n        if (elem !== null && !this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isObjectExpression(node) || isRecordExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isMethod(node)) {\n      var _node$decorators2;\n\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n\n      if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {\n        return false;\n      }\n\n      return true;\n    } else if (isProperty(node)) {\n      var _node$decorators3;\n\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n\n      if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {\n        return false;\n      }\n\n      if (isObjectProperty(node) || node.static) {\n        if (node.value !== null && !this.isPure(node.value, constantsOnly)) {\n          return false;\n        }\n      }\n\n      return true;\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (path.isPattern()) {\n      path = this.getPatternParent().path;\n    } else if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    const len = declarPath.node.declarations.push(declarator);\n    path.scope.registerBinding(kind, declarPath.get(\"declarations\")[len - 1]);\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getPatternParent() {\n    let scope = this;\n\n    do {\n      if (!scope.path.isPattern()) {\n        return scope.getBlockParent();\n      }\n    } while (scope = scope.parent.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind() {\n    const ids = Object.create(null);\n\n    for (var _len = arguments.length, kinds = new Array(_len), _key = 0; _key < _len; _key++) {\n      kinds[_key] = arguments[_key];\n    }\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\n          return binding;\n        }\n      } else if (!binding && name === \"arguments\" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n        break;\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","map":{"version":3,"mappings":"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","names":["NOT_LOCAL_BINDING","callExpression","cloneNode","getBindingIdentifiers","identifier","isArrayExpression","isBinary","isClass","isClassBody","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isFunctionDeclaration","isIdentifier","isImportDeclaration","isLiteral","isMethod","isModuleDeclaration","isModuleSpecifier","isNullLiteral","isObjectExpression","isProperty","isPureish","isRegExpLiteral","isSuper","isTaggedTemplateExpression","isTemplateLiteral","isThisExpression","isUnaryExpression","isVariableDeclaration","matchesPattern","memberExpression","numericLiteral","toIdentifier","unaryExpression","variableDeclaration","variableDeclarator","isRecordExpression","isTupleExpression","isObjectProperty","isTopicReference","isMetaProperty","isPrivateName","gatherNodeParts","node","parts","type","source","specifiers","length","e","declaration","local","push","value","object","property","name","callee","properties","argument","key","left","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","ForStatement","path","declar","get","isVar","scope","parentScope","getFunctionParent","getProgramParent","registerBinding","Declaration","isBlockScoped","isExportDeclaration","parent","registerDeclaration","ImportDeclaration","getBlockParent","ReferencedIdentifier","state","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","binding","getBinding","reference","decl","declarations","Object","keys","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","BlockScoped","bindings","CatchClause","Function","params","param","isFunctionExpression","has","ClassExpression","uid","Scope","constructor","block","labels","inited","globals","uids","data","crawling","cached","scopeCache","set","Map","shouldSkip","listKey","parentPath","isScope","_parent","parentBlock","hub","traverse","opts","generateDeclaredUidIdentifier","generateUidIdentifier","generateUid","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","generateUidBasedOnNode","defaultName","join","slice","generateUidIdentifierBasedOnNode","isStatic","constant","maybeGenerateMemoised","dontPush","checkBlockScopedCollisions","kind","duplicate","buildError","TypeError","rename","oldName","newName","Renamer","_renameFromMap","map","dump","sep","repeat","console","log","violations","toArray","arrayLikeIsIterable","isGenericType","helperName","args","unshift","addHelper","getLabel","registerLabel","label","isLabeledStatement","declare","specifier","buildUndefinedNode","registerConstantViolation","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","Binding","addGlobal","hasUid","isPure","constantsOnly","superClass","decorators","body","method","right","elem","elements","prop","computed","static","tag","quasi","expressions","setData","val","getData","removeData","init","crawl","create","programParent","_exploded","visit","enter","typeVisitors","ref","getPatternParent","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","unshiftContainer","declarator","len","Error","isFunctionParent","isBlockParent","getAllBindings","getAllBindingsOfKind","kinds","bindingIdentifierEquals","getBindingIdentifier","previousPath","isArrowFunctionExpression","_this$getBinding","getOwnBindingIdentifier","hasOwnBinding","noGlobals","parentHasBinding","includes","contextVariables","_this$parent","moveBindingTo","info","removeOwnBinding","removeBinding","builtin"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\scope\\index.ts"],"sourcesContent":["import Renamer from \"./lib/renamer\";\nimport type NodePath from \"../path\";\nimport traverse from \"../index\";\nimport type { TraverseOptions } from \"../index\";\nimport Binding from \"./binding\";\nimport type { BindingKind } from \"./binding\";\nimport globals from \"globals\";\nimport {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isNullLiteral,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isRegExpLiteral,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator,\n  isRecordExpression,\n  isTupleExpression,\n  isObjectProperty,\n  isTopicReference,\n  isMetaProperty,\n  isPrivateName,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { scope as scopeCache } from \"../cache\";\nimport type { Visitor } from \"../types\";\n\ntype NodePart = string | number | boolean;\n// Recursively gathers the identifying names of a node.\nfunction gatherNodeParts(node: t.Node, parts: NodePart[]) {\n  switch (node?.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if (\n          (isExportAllDeclaration(node) ||\n            isExportNamedDeclaration(node) ||\n            isImportDeclaration(node)) &&\n          node.source\n        ) {\n          gatherNodeParts(node.source, parts);\n        } else if (\n          (isExportNamedDeclaration(node) || isImportDeclaration(node)) &&\n          node.specifiers &&\n          node.specifiers.length\n        ) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if (\n          (isExportDefaultDeclaration(node) ||\n            isExportNamedDeclaration(node)) &&\n          node.declaration\n        ) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        // todo(flow->ts): should condition instead be:\n        //    ```\n        //    t.isExportSpecifier(node) ||\n        //    t.isImportDefaultSpecifier(node) ||\n        //    t.isImportNamespaceSpecifier(node) ||\n        //    t.isImportSpecifier(node)\n        //    ```\n        //    allowing only nodes with `.local`?\n        // @ts-expect-error todo(flow->ts)\n        gatherNodeParts(node.local, parts);\n      } else if (\n        isLiteral(node) &&\n        !isNullLiteral(node) &&\n        !isRegExpLiteral(node) &&\n        !isTemplateLiteral(node)\n      ) {\n        parts.push(node.value);\n      }\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      gatherNodeParts(node.name, parts);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\n//\ninterface CollectVisitorState {\n  assignments: NodePath<t.AssignmentExpression>[];\n  references: NodePath<t.Identifier | t.JSXIdentifier>[];\n  constantViolations: NodePath[];\n}\n\nconst collectorVisitor: Visitor<CollectVisitorState> = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n    // delegate block scope handling to the `BlockScoped` method\n    if (declar.isVar()) {\n      const { scope } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    // delegate block scope handling to the `BlockScoped` method\n    if (path.isBlockScoped()) return;\n\n    // delegate import handing to the `ImportDeclaration` method\n    if (path.isImportDeclaration()) return;\n\n    // this will be hit again once we traverse into it after this iteration\n    if (path.isExportDeclaration()) return;\n\n    // we've ran into a declaration!\n    const parent =\n      path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    // import may only appear in the top level or inside a module/namespace (for TS/flow)\n    const parent = path.scope.getBlockParent();\n\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n    // delegate block scope handling to the `BlockScoped` method\n    else if (left.isVar()) {\n      const { scope } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const { node, scope } = path;\n      // ExportAllDeclaration does not have `declaration`\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n\n        const binding = scope.getBinding(id.name);\n        binding?.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding?.reference(path);\n          }\n        }\n      }\n    },\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    // Register class identifier in class' scope if this is a class declaration.\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params: Array<NodePath> = path.get(\"params\");\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    // Register function expression id after params. When the id\n    // collides with a function param, the id effectively can't be\n    // referenced: here we registered it as a constantViolation\n    if (\n      path.isFunctionExpression() &&\n      path.has(\"id\") &&\n      // @ts-expect-error Fixme: document symbol ast properties\n      !path.get(\"id\").node[NOT_LOCAL_BINDING]\n    ) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (\n      path.has(\"id\") &&\n      // @ts-expect-error Fixme: document symbol ast properties\n      !path.get(\"id\").node[NOT_LOCAL_BINDING]\n    ) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  },\n};\n\nlet uid = 0;\n\nexport type { Binding };\n\nexport default class Scope {\n  uid;\n\n  path: NodePath;\n  block: t.Pattern | t.Scopable;\n\n  labels;\n  inited;\n\n  bindings: { [name: string]: Binding };\n  references: { [name: string]: true };\n  globals: { [name: string]: t.Identifier | t.JSXIdentifier };\n  uids: { [name: string]: boolean };\n  data: { [key: string | symbol]: unknown };\n  crawling: boolean;\n\n  /**\n   * This searches the current \"scope\" and collects all references/bindings\n   * within.\n   */\n  constructor(path: NodePath<t.Pattern | t.Scopable>) {\n    const { node } = path;\n    const cached = scopeCache.get(node);\n    // Sometimes, a scopable path is placed higher in the AST tree.\n    // In these cases, have to create a new Scope.\n    if (cached?.path === path) {\n      return cached;\n    }\n    scopeCache.set(node, this);\n\n    this.uid = uid++;\n\n    this.block = node;\n    this.path = path;\n\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  /**\n   * Globals.\n   */\n\n  static globals = Object.keys(globals.builtin);\n\n  /**\n   * Variables available in current context.\n   */\n\n  static contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];\n\n  get parent() {\n    let parent,\n      path = this.path;\n    do {\n      // Skip method scope if coming from inside computed key or decorator expression\n      const shouldSkip = path.key === \"key\" || path.listKey === \"decorators\";\n      path = path.parentPath;\n      if (shouldSkip && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return parent?.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse<S>(\n    node: t.Node | t.Node[],\n    opts: TraverseOptions<S>,\n    state: S,\n  ): void;\n  traverse(node: t.Node | t.Node[], opts?: TraverseOptions, state?: any): void;\n  /**\n   * Traverse node with current scope and path.\n   */\n  traverse<S>(node: any, opts: any, state?: S) {\n    traverse(node, opts, this, state, this.path);\n  }\n\n  /**\n   * Generate a unique identifier and add it to the current scope.\n   */\n\n  generateDeclaredUidIdentifier(name?: string) {\n    const id = this.generateUidIdentifier(name);\n    this.push({ id });\n    return cloneNode(id);\n  }\n\n  /**\n   * Generate a unique identifier.\n   */\n\n  generateUidIdentifier(name?: string) {\n    return identifier(this.generateUid(name));\n  }\n\n  /**\n   * Generate a unique `_id1` binding.\n   */\n\n  generateUid(name: string = \"temp\"): string {\n    name = toIdentifier(name)\n      .replace(/^_+/, \"\")\n      .replace(/[0-9]+$/g, \"\");\n\n    let uid;\n    let i = 1;\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (\n      this.hasLabel(uid) ||\n      this.hasBinding(uid) ||\n      this.hasGlobal(uid) ||\n      this.hasReference(uid)\n    );\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n\n    return uid;\n  }\n\n  /**\n   * Generate an `_id1`.\n   */\n\n  _generateUid(name: string, i: number) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node: t.Node, defaultName?: string) {\n    const parts: NodePart[] = [];\n    gatherNodeParts(node, parts);\n\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  /**\n   * Generate a unique identifier based on a node.\n   */\n\n  generateUidIdentifierBasedOnNode(node: t.Node, defaultName?: string) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  /**\n   * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.\n   * evaluating it wont result in potentially arbitrary code from being ran. The following are\n   * allowed and determined not to cause side effects:\n   *\n   *  - `this` expressions\n   *  - `super` expressions\n   *  - Bound identifiers\n   */\n\n  isStatic(node: t.Node): boolean {\n    if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Possibly generate a memoised identifier if it is not static and has consequences.\n   */\n\n  maybeGenerateMemoised(node: t.Node, dontPush?: boolean) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n      if (!dontPush) {\n        this.push({ id });\n        return cloneNode(id);\n      }\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(\n    local: Binding,\n    kind: BindingKind,\n    name: string,\n    id: any,\n  ) {\n    // ignore parameters\n    if (kind === \"param\") return;\n\n    // Ignore existing binding if it's the name of the current function or\n    // class expression\n    if (local.kind === \"local\") return;\n\n    const duplicate =\n      // don't allow duplicate bindings to exist alongside\n      kind === \"let\" ||\n      local.kind === \"let\" ||\n      local.kind === \"const\" ||\n      local.kind === \"module\" ||\n      // don't allow a local of param with a kind of let\n      (local.kind === \"param\" && kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(\n        id,\n        `Duplicate declaration \"${name}\"`,\n        TypeError,\n      );\n    }\n  }\n\n  rename(oldName: string, newName?: string, block?: t.Pattern | t.Scopable) {\n    const binding = this.getBinding(oldName);\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new Renamer(binding, oldName, newName).rename(block);\n    }\n  }\n\n  /** @deprecated Not used in our codebase */\n  _renameFromMap(\n    map: Record<string | symbol, unknown>,\n    oldName: string | symbol,\n    newName: string | symbol,\n    value: unknown,\n  ) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope: Scope = this;\n    do {\n      console.log(\"#\", scope.block.type);\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind,\n        });\n      }\n    } while ((scope = scope.parent));\n    console.log(sep);\n  }\n\n  // TODO: (Babel 8) Split i in two parameters, and use an object of flags\n  toArray(\n    node: t.Node,\n    i?: number | boolean,\n    arrayLikeIsIterable?: boolean | void,\n  ) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (binding?.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, { name: \"arguments\" })) {\n      return callExpression(\n        memberExpression(\n          memberExpression(\n            memberExpression(identifier(\"Array\"), identifier(\"prototype\")),\n            identifier(\"slice\"),\n          ),\n          identifier(\"call\"),\n        ),\n        [node],\n      );\n    }\n\n    let helperName;\n    const args = [node];\n    if (i === true) {\n      // Used in array-spread to create an array.\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n\n      // Used in array-rest to create an array from a subset of an iterable.\n      helperName = \"slicedToArray\";\n      // TODO if (this.hub.isLoose(\"es6.forOf\")) helperName += \"-loose\";\n    } else {\n      // Used in array-rest to create an array\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    // @ts-expect-error todo(flow->ts): t.Node is not valid to use in args, function argument typeneeds to be clarified\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name: string) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name: string) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path: NodePath<t.LabeledStatement>) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path: NodePath) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      // todo: improve babel-types\n      const declar = path.get(\"declaration\") as NodePath;\n      if (\n        declar.isClassDeclaration() ||\n        declar.isFunctionDeclaration() ||\n        declar.isVariableDeclaration()\n      ) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path: NodePath) {\n    const ids = path.getBindingIdentifiers();\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(\n    kind: Binding[\"kind\"],\n    path: NodePath,\n    bindingPath: NodePath = path,\n  ) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators: Array<NodePath> = path.get(\"declarations\");\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          // same identifier so continue safely as we're likely trying to register it\n          // multiple times\n          if (local.identifier === id) continue;\n\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        // A redeclaration of an existing variable is a modification\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new Binding({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind,\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node: t.Identifier | t.JSXIdentifier) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name: string): boolean {\n    let scope: Scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while ((scope = scope.parent));\n\n    return false;\n  }\n\n  hasGlobal(name: string): boolean {\n    let scope: Scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while ((scope = scope.parent));\n\n    return false;\n  }\n\n  hasReference(name: string): boolean {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node: t.Node, constantsOnly?: boolean): boolean {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (\n      isThisExpression(node) ||\n      isMetaProperty(node) ||\n      isTopicReference(node) ||\n      isPrivateName(node)\n    ) {\n      return true;\n    } else if (isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isBinary(node)) {\n      return (\n        this.isPure(node.left, constantsOnly) &&\n        this.isPure(node.right, constantsOnly)\n      );\n    } else if (isArrayExpression(node) || isTupleExpression(node)) {\n      for (const elem of node.elements) {\n        if (elem !== null && !this.isPure(elem, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isObjectExpression(node) || isRecordExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      return true;\n    } else if (isProperty(node)) {\n      // @ts-expect-error todo(flow->ts): computed in not present on private properties\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.decorators?.length > 0) {\n        return false;\n      }\n      if (isObjectProperty(node) || node.static) {\n        if (node.value !== null && !this.isPure(node.value, constantsOnly)) {\n          return false;\n        }\n      }\n      return true;\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return (\n        matchesPattern(node.tag, \"String.raw\") &&\n        !this.hasBinding(\"String\", true) &&\n        this.isPure(node.quasi, constantsOnly)\n      );\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  /**\n   * Set some arbitrary data on the current scope.\n   */\n\n  setData(key: string | symbol, val: any) {\n    return (this.data[key] = val);\n  }\n\n  /**\n   * Recursively walk up scope tree looking for the data `key`.\n   */\n\n  getData(key: string | symbol): any {\n    let scope: Scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while ((scope = scope.parent));\n  }\n\n  /**\n   * Recursively walk up scope tree looking for the data `key` and if it exists,\n   * remove it.\n   */\n\n  removeData(key: string) {\n    let scope: Scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while ((scope = scope.parent));\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n\n    const state: CollectVisitorState = {\n      references: [],\n      constantViolations: [],\n      assignments: [],\n    };\n\n    this.crawling = true;\n    // traverse does not visit the root node, here we explicitly collect\n    // root node binding info when the root is not a Program.\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      // @ts-expect-error when collectorVisitor is exploded, `enter` always exists\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n      const typeVisitors = collectorVisitor[path.type];\n      if (typeVisitors) {\n        // @ts-expect-error when collectorVisitor is exploded, `enter` always exists\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    // register assignments\n    for (const path of state.assignments) {\n      // register undeclared bindings as globals\n      const ids = path.getBindingIdentifiers();\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      // register as constant violation\n      path.scope.registerConstantViolation(path);\n    }\n\n    // register references\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    // register constant violations\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts: {\n    id: t.LVal;\n    init?: t.Expression;\n    unique?: boolean;\n    _blockHoist?: number | undefined;\n    kind?: \"var\" | \"let\" | \"const\";\n  }) {\n    let path = this.path;\n\n    if (path.isPattern()) {\n      path = this.getPatternParent().path;\n    } else if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      // @ts-expect-error TS can not infer NodePath<Loop> | NodePath<CatchClause> as NodePath<Loop | CatchClause>\n      path.ensureBlock();\n      // @ts-expect-error todo(flow->ts): improve types\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      // @ts-expect-error todo(flow->ts): avoid modifying nodes\n      declar._blockHoist = blockHoist;\n\n      [declarPath] = (path as NodePath<t.BlockStatement>).unshiftContainer(\n        \"body\",\n        [declar],\n      );\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    const len = declarPath.node.declarations.push(declarator);\n    path.scope.registerBinding(kind, declarPath.get(\"declarations\")[len - 1]);\n  }\n\n  /**\n   * Walk up to the top of the scope tree and get the `Program`.\n   */\n\n  getProgramParent() {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  /**\n   * Walk up the scope tree until we hit either a Function or return null.\n   */\n\n  getFunctionParent(): Scope | null {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    return null;\n  }\n\n  /**\n   * Walk up the scope tree until we hit either a BlockStatement/Loop/Program/Function/Switch or reach the\n   * very top and hit Program.\n   */\n\n  getBlockParent() {\n    let scope: Scope = this;\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while ((scope = scope.parent));\n    throw new Error(\n      \"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\",\n    );\n  }\n\n  /**\n   * Walk up from a pattern scope (function param initializer) until we hit a non-pattern scope,\n   * then returns its block parent\n   * @returns An ancestry scope whose path is a block parent\n   */\n  getPatternParent() {\n    let scope: Scope = this;\n    do {\n      if (!scope.path.isPattern()) {\n        return scope.getBlockParent();\n      }\n    } while ((scope = scope.parent.parent));\n    throw new Error(\n      \"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\",\n    );\n  }\n\n  /**\n   * Walks the scope tree and gathers **all** bindings.\n   */\n\n  getAllBindings(): Record<string, Binding> {\n    const ids = Object.create(null);\n\n    let scope: Scope = this;\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  /**\n   * Walks the scope tree and gathers all declarations of `kind`.\n   */\n\n  getAllBindingsOfKind(...kinds: string[]): Record<string, Binding> {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope: Scope = this;\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name: string, node: t.Node): boolean {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name: string): Binding | undefined {\n    let scope: Scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n      if (binding) {\n        // Check if a pattern is a part of parameter expressions.\n        // Note: for performance reason we skip checking previousPath.parentPath.isFunction()\n        // because `scope.path` is validated as scope in packages/babel-types/src/validators/isScope.js\n        // That is, if a scope path is pattern, its parent must be Function/CatchClause\n\n        // Spec 9.2.10.28: The closure created by this expression should not have visibility of\n        // declarations in the function body. If the binding is not a `param`-kind (as function parameters)\n        // or `local`-kind (as id in function expression),\n        // then it must be defined inside the function body, thus it should be skipped\n        if (\n          previousPath?.isPattern() &&\n          binding.kind !== \"param\" &&\n          binding.kind !== \"local\"\n        ) {\n          // do nothing\n        } else {\n          return binding;\n        }\n      } else if (\n        !binding &&\n        name === \"arguments\" &&\n        scope.path.isFunction() &&\n        !scope.path.isArrowFunctionExpression()\n      ) {\n        break;\n      }\n      previousPath = scope.path;\n    } while ((scope = scope.parent));\n  }\n\n  getOwnBinding(name: string): Binding | undefined {\n    return this.bindings[name];\n  }\n\n  // todo: return probably can be undefined…\n  getBindingIdentifier(name: string): t.Identifier {\n    return this.getBinding(name)?.identifier;\n  }\n\n  // todo: flow->ts return probably can be undefined\n  getOwnBindingIdentifier(name: string): t.Identifier {\n    const binding = this.bindings[name];\n    return binding?.identifier;\n  }\n\n  hasOwnBinding(name: string) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name: string, noGlobals?: boolean) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name: string, noGlobals?: boolean) {\n    return this.parent?.hasBinding(name, noGlobals);\n  }\n\n  /**\n   * Move a binding of `name` to another `scope`.\n   */\n\n  moveBindingTo(name: string, scope: Scope) {\n    const info = this.getBinding(name);\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name: string) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name: string) {\n    // clear literal binding\n    this.getBinding(name)?.scope.removeOwnBinding(name);\n\n    // clear uids with this name - https://github.com/babel/babel/issues/2101\n    let scope: Scope = this;\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while ((scope = scope.parent));\n  }\n}\n"]},"metadata":{},"sourceType":"script"}