{"ast":null,"code":"var _classCallCheck = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@jridgewell/trace-mapping'), require('@jridgewell/gen-mapping')) : typeof define === 'function' && define.amd ? define(['@jridgewell/trace-mapping', '@jridgewell/gen-mapping'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.remapping = factory(global.traceMapping, global.genMapping));\n})(this, function (traceMapping, genMapping) {\n  'use strict';\n\n  var SOURCELESS_MAPPING = {\n    source: null,\n    column: null,\n    line: null,\n    name: null,\n    content: null\n  };\n  var EMPTY_SOURCES = [];\n\n  function Source(map, sources, source, content) {\n    return {\n      map: map,\n      sources: sources,\n      source: source,\n      content: content\n    };\n  }\n  /**\n   * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes\n   * (which may themselves be SourceMapTrees).\n   */\n\n\n  function MapSource(map, sources) {\n    return Source(map, sources, '', null);\n  }\n  /**\n   * A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive\n   * segment tracing ends at the `OriginalSource`.\n   */\n\n\n  function OriginalSource(source, content) {\n    return Source(null, EMPTY_SOURCES, source, content);\n  }\n  /**\n   * traceMappings is only called on the root level SourceMapTree, and begins the process of\n   * resolving each mapping in terms of the original source files.\n   */\n\n\n  function traceMappings(tree) {\n    var gen = new genMapping.GenMapping({\n      file: tree.map.file\n    });\n    var rootSources = tree.sources,\n        map = tree.map;\n    var rootNames = map.names;\n    var rootMappings = traceMapping.decodedMappings(map);\n\n    for (var i = 0; i < rootMappings.length; i++) {\n      var segments = rootMappings[i];\n      var lastSource = null;\n      var lastSourceLine = null;\n      var lastSourceColumn = null;\n\n      for (var j = 0; j < segments.length; j++) {\n        var segment = segments[j];\n        var genCol = segment[0];\n        var traced = SOURCELESS_MAPPING; // 1-length segments only move the current generated column, there's no source information\n        // to gather from it.\n\n        if (segment.length !== 1) {\n          var _source = rootSources[segment[1]];\n          traced = originalPositionFor(_source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : ''); // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n          // respective segment into an original source.\n\n          if (traced == null) continue;\n        } // So we traced a segment down into its original source file. Now push a\n        // new segment pointing to this location.\n\n\n        var _traced = traced,\n            column = _traced.column,\n            line = _traced.line,\n            name = _traced.name,\n            content = _traced.content,\n            source = _traced.source;\n\n        if (line === lastSourceLine && column === lastSourceColumn && source === lastSource) {\n          continue;\n        }\n\n        lastSourceLine = line;\n        lastSourceColumn = column;\n        lastSource = source; // Sigh, TypeScript can't figure out source/line/column are either all null, or all non-null...\n\n        genMapping.addSegment(gen, i, genCol, source, line, column, name);\n        if (content != null) genMapping.setSourceContent(gen, source, content);\n      }\n    }\n\n    return gen;\n  }\n  /**\n   * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own\n   * child SourceMapTrees, until we find the original source map.\n   */\n\n\n  function originalPositionFor(source, line, column, name) {\n    if (!source.map) {\n      return {\n        column: column,\n        line: line,\n        name: name,\n        source: source.source,\n        content: source.content\n      };\n    }\n\n    var segment = traceMapping.traceSegment(source.map, line, column); // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n\n    if (segment == null) return null; // 1-length segments only move the current generated column, there's no source information\n    // to gather from it.\n\n    if (segment.length === 1) return SOURCELESS_MAPPING;\n    return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);\n  }\n\n  function asArray(value) {\n    if (Array.isArray(value)) return value;\n    return [value];\n  }\n  /**\n   * Recursively builds a tree structure out of sourcemap files, with each node\n   * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n   * `OriginalSource`s and `SourceMapTree`s.\n   *\n   * Every sourcemap is composed of a collection of source files and mappings\n   * into locations of those source files. When we generate a `SourceMapTree` for\n   * the sourcemap, we attempt to load each source file's own sourcemap. If it\n   * does not have an associated sourcemap, it is considered an original,\n   * unmodified source file.\n   */\n\n\n  function buildSourceMapTree(input, loader) {\n    var maps = asArray(input).map(function (m) {\n      return new traceMapping.TraceMap(m, '');\n    });\n    var map = maps.pop();\n\n    for (var i = 0; i < maps.length; i++) {\n      if (maps[i].sources.length > 1) {\n        throw new Error(\"Transformation map \".concat(i, \" must have exactly one source file.\\n\") + 'Did you specify these with the most recent transformation maps first?');\n      }\n    }\n\n    var tree = build(map, loader, '', 0);\n\n    for (var _i = maps.length - 1; _i >= 0; _i--) {\n      tree = MapSource(maps[_i], [tree]);\n    }\n\n    return tree;\n  }\n\n  function build(map, loader, importer, importerDepth) {\n    var resolvedSources = map.resolvedSources,\n        sourcesContent = map.sourcesContent;\n    var depth = importerDepth + 1;\n    var children = resolvedSources.map(function (sourceFile, i) {\n      // The loading context gives the loader more information about why this file is being loaded\n      // (eg, from which importer). It also allows the loader to override the location of the loaded\n      // sourcemap/original source, or to override the content in the sourcesContent field if it's\n      // an unmodified source file.\n      var ctx = {\n        importer: importer,\n        depth: depth,\n        source: sourceFile || '',\n        content: undefined\n      }; // Use the provided loader callback to retrieve the file's sourcemap.\n      // TODO: We should eventually support async loading of sourcemap files.\n\n      var sourceMap = loader(ctx.source, ctx);\n      var source = ctx.source,\n          content = ctx.content; // If there is a sourcemap, then we need to recurse into it to load its source files.\n\n      if (sourceMap) return build(new traceMapping.TraceMap(sourceMap, source), loader, source, depth); // Else, it's an an unmodified source file.\n      // The contents of this unmodified source file can be overridden via the loader context,\n      // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n      // the importing sourcemap's `sourcesContent` field.\n\n      var sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n      return OriginalSource(source, sourceContent);\n    });\n    return MapSource(map, children);\n  }\n  /**\n   * A SourceMap v3 compatible sourcemap, which only includes fields that were\n   * provided to it.\n   */\n\n\n  var SourceMap = /*#__PURE__*/function () {\n    function SourceMap(map, options) {\n      _classCallCheck(this, SourceMap);\n\n      var out = options.decodedMappings ? genMapping.decodedMap(map) : genMapping.encodedMap(map);\n      this.version = out.version; // SourceMap spec says this should be first.\n\n      this.file = out.file;\n      this.mappings = out.mappings;\n      this.names = out.names;\n      this.sourceRoot = out.sourceRoot;\n      this.sources = out.sources;\n\n      if (!options.excludeContent) {\n        this.sourcesContent = out.sourcesContent;\n      }\n    }\n\n    _createClass(SourceMap, [{\n      key: \"toString\",\n      value: function toString() {\n        return JSON.stringify(this);\n      }\n    }]);\n\n    return SourceMap;\n  }();\n  /**\n   * Traces through all the mappings in the root sourcemap, through the sources\n   * (and their sourcemaps), all the way back to the original source location.\n   *\n   * `loader` will be called every time we encounter a source file. If it returns\n   * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n   * it returns a falsey value, that source file is treated as an original,\n   * unmodified source file.\n   *\n   * Pass `excludeContent` to exclude any self-containing source file content\n   * from the output sourcemap.\n   *\n   * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n   * VLQ encoded) mappings.\n   */\n\n\n  function remapping(input, loader, options) {\n    var opts = typeof options === 'object' ? options : {\n      excludeContent: !!options,\n      decodedMappings: false\n    };\n    var tree = buildSourceMapTree(input, loader);\n    return new SourceMap(traceMappings(tree), opts);\n  }\n\n  return remapping;\n});","map":{"version":3,"mappings":"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","names":["SOURCELESS_MAPPING","source","column","line","name","content","EMPTY_SOURCES","Source","map","sources","traceMappings","tree","gen","GenMapping","file","rootSources","rootNames","names","rootMappings","decodedMappings","i","length","segments","lastSource","lastSourceLine","lastSourceColumn","j","segment","genCol","traced","originalPositionFor","addSegment","setSourceContent","traceSegment","asArray","value","Array","isArray","buildSourceMapTree","input","loader","maps","m","TraceMap","pop","Error","build","MapSource","importer","importerDepth","resolvedSources","sourcesContent","depth","children","sourceFile","ctx","undefined","sourceMap","sourceContent","OriginalSource","SourceMap","options","out","decodedMap","encodedMap","version","mappings","sourceRoot","excludeContent","JSON","stringify","opts"],"sources":["../../src/source-map-tree.ts","../../src/build-source-map-tree.ts","../../src/source-map.ts","../../src/remapping.ts"],"sourcesContent":[null,null,null,null]},"metadata":{},"sourceType":"script"}