{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst TypeScriptIssueFactory_1 = require(\"../issue/TypeScriptIssueFactory\");\n\nconst ControlledWatchCompilerHost_1 = require(\"./ControlledWatchCompilerHost\");\n\nconst TypeScriptVueExtension_1 = require(\"../extension/vue/TypeScriptVueExtension\");\n\nconst ControlledWatchSolutionBuilderHost_1 = require(\"./ControlledWatchSolutionBuilderHost\");\n\nconst ControlledTypeScriptSystem_1 = require(\"./ControlledTypeScriptSystem\");\n\nconst TypeScriptConfigurationParser_1 = require(\"./TypeScriptConfigurationParser\");\n\nconst Performance_1 = require(\"../../profile/Performance\");\n\nconst TypeScriptPerformance_1 = require(\"../profile/TypeScriptPerformance\");\n\nfunction createTypeScriptReporter(configuration) {\n  let parsedConfiguration;\n  let parseConfigurationDiagnostics = [];\n  let dependencies;\n  let artifacts;\n  let configurationChanged = false;\n  let watchCompilerHost;\n  let watchSolutionBuilderHost;\n  let watchProgram;\n  let solutionBuilder;\n  let shouldUpdateRootFiles = false; // eslint-disable-next-line @typescript-eslint/no-var-requires\n\n  const typescript = require(configuration.typescriptPath);\n\n  const extensions = [];\n  const system = ControlledTypeScriptSystem_1.createControlledTypeScriptSystem(typescript, configuration.mode);\n  const diagnosticsPerProject = new Map();\n  const performance = TypeScriptPerformance_1.connectTypeScriptPerformance(typescript, Performance_1.createPerformance());\n\n  if (configuration.extensions.vue.enabled) {\n    extensions.push(TypeScriptVueExtension_1.createTypeScriptVueExtension(configuration.extensions.vue));\n  }\n\n  function getConfigFilePathFromCompilerOptions(compilerOptions) {\n    return compilerOptions.configFilePath;\n  }\n\n  function getProjectNameOfBuilderProgram(builderProgram) {\n    return getConfigFilePathFromCompilerOptions(builderProgram.getProgram().getCompilerOptions());\n  }\n\n  function getTracing() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return typescript.tracing;\n  }\n\n  function getDiagnosticsOfBuilderProgram(builderProgram) {\n    const diagnostics = [];\n\n    if (configuration.diagnosticOptions.syntactic) {\n      performance.markStart('Syntactic Diagnostics');\n      diagnostics.push(...builderProgram.getSyntacticDiagnostics());\n      performance.markEnd('Syntactic Diagnostics');\n    }\n\n    if (configuration.diagnosticOptions.global) {\n      performance.markStart('Global Diagnostics');\n      diagnostics.push(...builderProgram.getGlobalDiagnostics());\n      performance.markEnd('Global Diagnostics');\n    }\n\n    if (configuration.diagnosticOptions.semantic) {\n      performance.markStart('Semantic Diagnostics');\n      diagnostics.push(...builderProgram.getSemanticDiagnostics());\n      performance.markEnd('Semantic Diagnostics');\n    }\n\n    if (configuration.diagnosticOptions.declaration) {\n      performance.markStart('Declaration Diagnostics');\n      diagnostics.push(...builderProgram.getDeclarationDiagnostics());\n      performance.markEnd('Declaration Diagnostics');\n    }\n\n    return diagnostics;\n  }\n\n  function emitTsBuildInfoFileForBuilderProgram(builderProgram) {\n    if (configuration.mode !== 'readonly' && parsedConfiguration && TypeScriptConfigurationParser_1.isIncrementalCompilation(parsedConfiguration.options)) {\n      const program = builderProgram.getProgram(); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      if (typeof program.emitBuildInfo === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        program.emitBuildInfo();\n      }\n    }\n  }\n\n  function getParseConfigFileHost() {\n    const parseConfigDiagnostics = [];\n    let parseConfigFileHost = Object.assign(Object.assign({}, system), {\n      onUnRecoverableConfigFileDiagnostic: diagnostic => {\n        parseConfigDiagnostics.push(diagnostic);\n      }\n    });\n\n    for (const extension of extensions) {\n      if (extension.extendParseConfigFileHost) {\n        parseConfigFileHost = extension.extendParseConfigFileHost(parseConfigFileHost);\n      }\n    }\n\n    return [parseConfigFileHost, parseConfigDiagnostics];\n  }\n\n  function parseConfiguration() {\n    const [parseConfigFileHost, parseConfigDiagnostics] = getParseConfigFileHost();\n    const parsedConfiguration = TypeScriptConfigurationParser_1.parseTypeScriptConfiguration(typescript, configuration.configFile, configuration.context, configuration.configOverwrite, parseConfigFileHost);\n\n    if (parsedConfiguration.errors) {\n      parseConfigDiagnostics.push(...parsedConfiguration.errors);\n    }\n\n    return [parsedConfiguration, parseConfigDiagnostics];\n  }\n\n  function parseConfigurationIfNeeded() {\n    if (!parsedConfiguration) {\n      [parsedConfiguration, parseConfigurationDiagnostics] = parseConfiguration();\n    }\n\n    return parsedConfiguration;\n  }\n\n  function getDependencies() {\n    parsedConfiguration = parseConfigurationIfNeeded();\n    const [parseConfigFileHost] = getParseConfigFileHost();\n    let dependencies = TypeScriptConfigurationParser_1.getDependenciesFromTypeScriptConfiguration(typescript, parsedConfiguration, configuration.context, parseConfigFileHost);\n\n    for (const extension of extensions) {\n      if (extension.extendDependencies) {\n        dependencies = extension.extendDependencies(dependencies);\n      }\n    }\n\n    return dependencies;\n  }\n\n  function getArtifacts() {\n    parsedConfiguration = parseConfigurationIfNeeded();\n    const [parseConfigFileHost] = getParseConfigFileHost();\n    return TypeScriptConfigurationParser_1.getArtifactsFromTypeScriptConfiguration(typescript, parsedConfiguration, configuration.context, parseConfigFileHost);\n  }\n\n  function getArtifactsIfNeeded() {\n    if (!artifacts) {\n      artifacts = getArtifacts();\n    }\n\n    return artifacts;\n  }\n\n  function startProfilingIfNeeded() {\n    if (configuration.profile) {\n      performance.enable();\n    }\n  }\n\n  function stopProfilingIfNeeded() {\n    if (configuration.profile) {\n      performance.print();\n      performance.disable();\n    }\n  }\n\n  function startTracingIfNeeded(compilerOptions) {\n    const tracing = getTracing();\n\n    if (compilerOptions.generateTrace && tracing) {\n      tracing.startTracing(getConfigFilePathFromCompilerOptions(compilerOptions), compilerOptions.generateTrace, configuration.build);\n    }\n  }\n\n  function stopTracingIfNeeded(program) {\n    const tracing = getTracing();\n    const compilerOptions = program.getCompilerOptions();\n\n    if (compilerOptions.generateTrace && tracing) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      tracing.stopTracing(program.getProgram().getTypeCatalog());\n    }\n  }\n\n  function dumpTracingLegendIfNeeded() {\n    const tracing = getTracing();\n\n    if (tracing) {\n      tracing.dumpLegend();\n    }\n  }\n\n  return {\n    getReport: _ref => {\n      let {\n        changedFiles = [],\n        deletedFiles = []\n      } = _ref;\n      return __awaiter(this, void 0, void 0, function* () {\n        // clear cache to be ready for next iteration and to free memory\n        system.clearCache();\n\n        if ([...changedFiles, ...deletedFiles].map(affectedFile => path_1.default.normalize(affectedFile)).includes(path_1.default.normalize(configuration.configFile))) {\n          // we need to re-create programs\n          parsedConfiguration = undefined;\n          dependencies = undefined;\n          artifacts = undefined;\n          watchCompilerHost = undefined;\n          watchSolutionBuilderHost = undefined;\n          watchProgram = undefined;\n          solutionBuilder = undefined;\n          diagnosticsPerProject.clear();\n          configurationChanged = true;\n        } else {\n          const previousDependencies = dependencies;\n          [parsedConfiguration, parseConfigurationDiagnostics] = parseConfiguration();\n          dependencies = getDependencies();\n\n          if (previousDependencies && JSON.stringify(previousDependencies) !== JSON.stringify(dependencies)) {\n            // dependencies changed - we need to recompute artifacts\n            artifacts = getArtifacts();\n            shouldUpdateRootFiles = true;\n          }\n        }\n\n        parsedConfiguration = parseConfigurationIfNeeded();\n        system.setArtifacts(getArtifactsIfNeeded());\n\n        if (configurationChanged) {\n          configurationChanged = false; // try to remove outdated .tsbuildinfo file for incremental mode\n\n          if (typeof typescript.getTsBuildInfoEmitOutputFilePath === 'function' && configuration.mode !== 'readonly' && parsedConfiguration.options.incremental) {\n            const tsBuildInfoPath = typescript.getTsBuildInfoEmitOutputFilePath(parsedConfiguration.options);\n\n            if (tsBuildInfoPath) {\n              try {\n                system.deleteFile(tsBuildInfoPath);\n              } catch (error) {// silent\n              }\n            }\n          }\n        }\n\n        return {\n          getDependencies() {\n            return __awaiter(this, void 0, void 0, function* () {\n              if (!dependencies) {\n                dependencies = getDependencies();\n              }\n\n              return dependencies;\n            });\n          },\n\n          getIssues() {\n            return __awaiter(this, void 0, void 0, function* () {\n              startProfilingIfNeeded();\n              parsedConfiguration = parseConfigurationIfNeeded(); // report configuration diagnostics and exit\n\n              if (parseConfigurationDiagnostics.length) {\n                let issues = TypeScriptIssueFactory_1.createIssuesFromTsDiagnostics(typescript, parseConfigurationDiagnostics);\n                issues.forEach(issue => {\n                  if (!issue.file) {\n                    issue.file = configuration.configFile;\n                  }\n                });\n                extensions.forEach(extension => {\n                  if (extension.extendIssues) {\n                    issues = extension.extendIssues(issues);\n                  }\n                });\n                return issues;\n              }\n\n              if (configuration.build) {\n                // solution builder case\n                // ensure watch solution builder host exists\n                if (!watchSolutionBuilderHost) {\n                  performance.markStart('Create Solution Builder Host');\n                  watchSolutionBuilderHost = ControlledWatchSolutionBuilderHost_1.createControlledWatchSolutionBuilderHost(typescript, parsedConfiguration, system, (rootNames, compilerOptions, host, oldProgram, configFileParsingDiagnostics, projectReferences) => {\n                    if (compilerOptions) {\n                      startTracingIfNeeded(compilerOptions);\n                    }\n\n                    return typescript.createSemanticDiagnosticsBuilderProgram(rootNames, compilerOptions, host, oldProgram, configFileParsingDiagnostics, projectReferences);\n                  }, undefined, undefined, undefined, undefined, builderProgram => {\n                    const projectName = getProjectNameOfBuilderProgram(builderProgram);\n                    const diagnostics = getDiagnosticsOfBuilderProgram(builderProgram); // update diagnostics\n\n                    diagnosticsPerProject.set(projectName, diagnostics); // emit .tsbuildinfo file if needed\n\n                    emitTsBuildInfoFileForBuilderProgram(builderProgram);\n                    stopTracingIfNeeded(builderProgram);\n                  }, extensions);\n                  performance.markEnd('Create Solution Builder Host');\n                  solutionBuilder = undefined;\n                } // ensure solution builder exists and is up-to-date\n\n\n                if (!solutionBuilder || shouldUpdateRootFiles) {\n                  // not sure if it's the best option - maybe there is a smarter way to do this\n                  shouldUpdateRootFiles = false;\n                  performance.markStart('Create Solution Builder');\n                  solutionBuilder = typescript.createSolutionBuilderWithWatch(watchSolutionBuilderHost, [configuration.configFile], {});\n                  performance.markEnd('Create Solution Builder');\n                  performance.markStart('Build Solutions');\n                  solutionBuilder.build();\n                  performance.markEnd('Build Solutions');\n                }\n              } else {\n                // watch compiler case\n                // ensure watch compiler host exists\n                if (!watchCompilerHost) {\n                  performance.markStart('Create Watch Compiler Host');\n                  watchCompilerHost = ControlledWatchCompilerHost_1.createControlledWatchCompilerHost(typescript, parsedConfiguration, system, (rootNames, compilerOptions, host, oldProgram, configFileParsingDiagnostics, projectReferences) => {\n                    if (compilerOptions) {\n                      startTracingIfNeeded(compilerOptions);\n                    }\n\n                    return typescript.createSemanticDiagnosticsBuilderProgram(rootNames, compilerOptions, host, oldProgram, configFileParsingDiagnostics, projectReferences);\n                  }, undefined, undefined, builderProgram => {\n                    const projectName = getProjectNameOfBuilderProgram(builderProgram);\n                    const diagnostics = getDiagnosticsOfBuilderProgram(builderProgram); // update diagnostics\n\n                    diagnosticsPerProject.set(projectName, diagnostics); // emit .tsbuildinfo file if needed\n\n                    emitTsBuildInfoFileForBuilderProgram(builderProgram);\n                    stopTracingIfNeeded(builderProgram);\n                  }, extensions);\n                  performance.markEnd('Create Watch Compiler Host');\n                  watchProgram = undefined;\n                } // ensure watch program exists\n\n\n                if (!watchProgram) {\n                  performance.markStart('Create Watch Program');\n                  watchProgram = typescript.createWatchProgram(watchCompilerHost);\n                  performance.markEnd('Create Watch Program');\n                }\n\n                if (shouldUpdateRootFiles && (dependencies === null || dependencies === void 0 ? void 0 : dependencies.files)) {\n                  // we have to update root files manually as don't use config file as a program input\n                  watchProgram.updateRootFileNames(dependencies.files);\n                  shouldUpdateRootFiles = false;\n                }\n              }\n\n              changedFiles.forEach(changedFile => {\n                if (system) {\n                  system.invokeFileChanged(changedFile);\n                }\n              });\n              deletedFiles.forEach(removedFile => {\n                if (system) {\n                  system.invokeFileDeleted(removedFile);\n                }\n              }); // wait for all queued events to be processed\n\n              performance.markStart('Queued Tasks');\n              yield system.waitForQueued();\n              performance.markEnd('Queued Tasks'); // aggregate all diagnostics and map them to issues\n\n              const diagnostics = [];\n              diagnosticsPerProject.forEach(projectDiagnostics => {\n                diagnostics.push(...projectDiagnostics);\n              });\n              let issues = TypeScriptIssueFactory_1.createIssuesFromTsDiagnostics(typescript, diagnostics);\n              extensions.forEach(extension => {\n                if (extension.extendIssues) {\n                  issues = extension.extendIssues(issues);\n                }\n              });\n              dumpTracingLegendIfNeeded();\n              stopProfilingIfNeeded();\n              return issues;\n            });\n          },\n\n          close() {\n            return __awaiter(this, void 0, void 0, function* () {// do nothing\n            });\n          }\n\n        };\n      });\n    }\n  };\n}\n\nexports.createTypeScriptReporter = createTypeScriptReporter;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","path_1","require","TypeScriptIssueFactory_1","ControlledWatchCompilerHost_1","TypeScriptVueExtension_1","ControlledWatchSolutionBuilderHost_1","ControlledTypeScriptSystem_1","TypeScriptConfigurationParser_1","Performance_1","TypeScriptPerformance_1","createTypeScriptReporter","configuration","parsedConfiguration","parseConfigurationDiagnostics","dependencies","artifacts","configurationChanged","watchCompilerHost","watchSolutionBuilderHost","watchProgram","solutionBuilder","shouldUpdateRootFiles","typescript","typescriptPath","extensions","system","createControlledTypeScriptSystem","mode","diagnosticsPerProject","Map","performance","connectTypeScriptPerformance","createPerformance","vue","enabled","push","createTypeScriptVueExtension","getConfigFilePathFromCompilerOptions","compilerOptions","configFilePath","getProjectNameOfBuilderProgram","builderProgram","getProgram","getCompilerOptions","getTracing","tracing","getDiagnosticsOfBuilderProgram","diagnostics","diagnosticOptions","syntactic","markStart","getSyntacticDiagnostics","markEnd","global","getGlobalDiagnostics","semantic","getSemanticDiagnostics","declaration","getDeclarationDiagnostics","emitTsBuildInfoFileForBuilderProgram","isIncrementalCompilation","options","program","emitBuildInfo","getParseConfigFileHost","parseConfigDiagnostics","parseConfigFileHost","assign","onUnRecoverableConfigFileDiagnostic","diagnostic","extension","extendParseConfigFileHost","parseConfiguration","parseTypeScriptConfiguration","configFile","context","configOverwrite","errors","parseConfigurationIfNeeded","getDependencies","getDependenciesFromTypeScriptConfiguration","extendDependencies","getArtifacts","getArtifactsFromTypeScriptConfiguration","getArtifactsIfNeeded","startProfilingIfNeeded","profile","enable","stopProfilingIfNeeded","print","disable","startTracingIfNeeded","generateTrace","startTracing","build","stopTracingIfNeeded","stopTracing","getTypeCatalog","dumpTracingLegendIfNeeded","dumpLegend","getReport","changedFiles","deletedFiles","clearCache","map","affectedFile","default","normalize","includes","undefined","clear","previousDependencies","JSON","stringify","setArtifacts","getTsBuildInfoEmitOutputFilePath","incremental","tsBuildInfoPath","deleteFile","error","getIssues","length","issues","createIssuesFromTsDiagnostics","forEach","issue","file","extendIssues","createControlledWatchSolutionBuilderHost","rootNames","host","oldProgram","configFileParsingDiagnostics","projectReferences","createSemanticDiagnosticsBuilderProgram","projectName","set","createSolutionBuilderWithWatch","createControlledWatchCompilerHost","createWatchProgram","files","updateRootFileNames","changedFile","invokeFileChanged","removedFile","invokeFileDeleted","waitForQueued","projectDiagnostics","close"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/fork-ts-checker-webpack-plugin/lib/typescript-reporter/reporter/TypeScriptReporter.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path_1 = __importDefault(require(\"path\"));\nconst TypeScriptIssueFactory_1 = require(\"../issue/TypeScriptIssueFactory\");\nconst ControlledWatchCompilerHost_1 = require(\"./ControlledWatchCompilerHost\");\nconst TypeScriptVueExtension_1 = require(\"../extension/vue/TypeScriptVueExtension\");\nconst ControlledWatchSolutionBuilderHost_1 = require(\"./ControlledWatchSolutionBuilderHost\");\nconst ControlledTypeScriptSystem_1 = require(\"./ControlledTypeScriptSystem\");\nconst TypeScriptConfigurationParser_1 = require(\"./TypeScriptConfigurationParser\");\nconst Performance_1 = require(\"../../profile/Performance\");\nconst TypeScriptPerformance_1 = require(\"../profile/TypeScriptPerformance\");\nfunction createTypeScriptReporter(configuration) {\n    let parsedConfiguration;\n    let parseConfigurationDiagnostics = [];\n    let dependencies;\n    let artifacts;\n    let configurationChanged = false;\n    let watchCompilerHost;\n    let watchSolutionBuilderHost;\n    let watchProgram;\n    let solutionBuilder;\n    let shouldUpdateRootFiles = false;\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const typescript = require(configuration.typescriptPath);\n    const extensions = [];\n    const system = ControlledTypeScriptSystem_1.createControlledTypeScriptSystem(typescript, configuration.mode);\n    const diagnosticsPerProject = new Map();\n    const performance = TypeScriptPerformance_1.connectTypeScriptPerformance(typescript, Performance_1.createPerformance());\n    if (configuration.extensions.vue.enabled) {\n        extensions.push(TypeScriptVueExtension_1.createTypeScriptVueExtension(configuration.extensions.vue));\n    }\n    function getConfigFilePathFromCompilerOptions(compilerOptions) {\n        return compilerOptions.configFilePath;\n    }\n    function getProjectNameOfBuilderProgram(builderProgram) {\n        return getConfigFilePathFromCompilerOptions(builderProgram.getProgram().getCompilerOptions());\n    }\n    function getTracing() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return typescript.tracing;\n    }\n    function getDiagnosticsOfBuilderProgram(builderProgram) {\n        const diagnostics = [];\n        if (configuration.diagnosticOptions.syntactic) {\n            performance.markStart('Syntactic Diagnostics');\n            diagnostics.push(...builderProgram.getSyntacticDiagnostics());\n            performance.markEnd('Syntactic Diagnostics');\n        }\n        if (configuration.diagnosticOptions.global) {\n            performance.markStart('Global Diagnostics');\n            diagnostics.push(...builderProgram.getGlobalDiagnostics());\n            performance.markEnd('Global Diagnostics');\n        }\n        if (configuration.diagnosticOptions.semantic) {\n            performance.markStart('Semantic Diagnostics');\n            diagnostics.push(...builderProgram.getSemanticDiagnostics());\n            performance.markEnd('Semantic Diagnostics');\n        }\n        if (configuration.diagnosticOptions.declaration) {\n            performance.markStart('Declaration Diagnostics');\n            diagnostics.push(...builderProgram.getDeclarationDiagnostics());\n            performance.markEnd('Declaration Diagnostics');\n        }\n        return diagnostics;\n    }\n    function emitTsBuildInfoFileForBuilderProgram(builderProgram) {\n        if (configuration.mode !== 'readonly' &&\n            parsedConfiguration &&\n            TypeScriptConfigurationParser_1.isIncrementalCompilation(parsedConfiguration.options)) {\n            const program = builderProgram.getProgram();\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            if (typeof program.emitBuildInfo === 'function') {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                program.emitBuildInfo();\n            }\n        }\n    }\n    function getParseConfigFileHost() {\n        const parseConfigDiagnostics = [];\n        let parseConfigFileHost = Object.assign(Object.assign({}, system), { onUnRecoverableConfigFileDiagnostic: (diagnostic) => {\n                parseConfigDiagnostics.push(diagnostic);\n            } });\n        for (const extension of extensions) {\n            if (extension.extendParseConfigFileHost) {\n                parseConfigFileHost = extension.extendParseConfigFileHost(parseConfigFileHost);\n            }\n        }\n        return [parseConfigFileHost, parseConfigDiagnostics];\n    }\n    function parseConfiguration() {\n        const [parseConfigFileHost, parseConfigDiagnostics] = getParseConfigFileHost();\n        const parsedConfiguration = TypeScriptConfigurationParser_1.parseTypeScriptConfiguration(typescript, configuration.configFile, configuration.context, configuration.configOverwrite, parseConfigFileHost);\n        if (parsedConfiguration.errors) {\n            parseConfigDiagnostics.push(...parsedConfiguration.errors);\n        }\n        return [parsedConfiguration, parseConfigDiagnostics];\n    }\n    function parseConfigurationIfNeeded() {\n        if (!parsedConfiguration) {\n            [parsedConfiguration, parseConfigurationDiagnostics] = parseConfiguration();\n        }\n        return parsedConfiguration;\n    }\n    function getDependencies() {\n        parsedConfiguration = parseConfigurationIfNeeded();\n        const [parseConfigFileHost] = getParseConfigFileHost();\n        let dependencies = TypeScriptConfigurationParser_1.getDependenciesFromTypeScriptConfiguration(typescript, parsedConfiguration, configuration.context, parseConfigFileHost);\n        for (const extension of extensions) {\n            if (extension.extendDependencies) {\n                dependencies = extension.extendDependencies(dependencies);\n            }\n        }\n        return dependencies;\n    }\n    function getArtifacts() {\n        parsedConfiguration = parseConfigurationIfNeeded();\n        const [parseConfigFileHost] = getParseConfigFileHost();\n        return TypeScriptConfigurationParser_1.getArtifactsFromTypeScriptConfiguration(typescript, parsedConfiguration, configuration.context, parseConfigFileHost);\n    }\n    function getArtifactsIfNeeded() {\n        if (!artifacts) {\n            artifacts = getArtifacts();\n        }\n        return artifacts;\n    }\n    function startProfilingIfNeeded() {\n        if (configuration.profile) {\n            performance.enable();\n        }\n    }\n    function stopProfilingIfNeeded() {\n        if (configuration.profile) {\n            performance.print();\n            performance.disable();\n        }\n    }\n    function startTracingIfNeeded(compilerOptions) {\n        const tracing = getTracing();\n        if (compilerOptions.generateTrace && tracing) {\n            tracing.startTracing(getConfigFilePathFromCompilerOptions(compilerOptions), compilerOptions.generateTrace, configuration.build);\n        }\n    }\n    function stopTracingIfNeeded(program) {\n        const tracing = getTracing();\n        const compilerOptions = program.getCompilerOptions();\n        if (compilerOptions.generateTrace && tracing) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            tracing.stopTracing(program.getProgram().getTypeCatalog());\n        }\n    }\n    function dumpTracingLegendIfNeeded() {\n        const tracing = getTracing();\n        if (tracing) {\n            tracing.dumpLegend();\n        }\n    }\n    return {\n        getReport: ({ changedFiles = [], deletedFiles = [] }) => __awaiter(this, void 0, void 0, function* () {\n            // clear cache to be ready for next iteration and to free memory\n            system.clearCache();\n            if ([...changedFiles, ...deletedFiles]\n                .map((affectedFile) => path_1.default.normalize(affectedFile))\n                .includes(path_1.default.normalize(configuration.configFile))) {\n                // we need to re-create programs\n                parsedConfiguration = undefined;\n                dependencies = undefined;\n                artifacts = undefined;\n                watchCompilerHost = undefined;\n                watchSolutionBuilderHost = undefined;\n                watchProgram = undefined;\n                solutionBuilder = undefined;\n                diagnosticsPerProject.clear();\n                configurationChanged = true;\n            }\n            else {\n                const previousDependencies = dependencies;\n                [parsedConfiguration, parseConfigurationDiagnostics] = parseConfiguration();\n                dependencies = getDependencies();\n                if (previousDependencies &&\n                    JSON.stringify(previousDependencies) !== JSON.stringify(dependencies)) {\n                    // dependencies changed - we need to recompute artifacts\n                    artifacts = getArtifacts();\n                    shouldUpdateRootFiles = true;\n                }\n            }\n            parsedConfiguration = parseConfigurationIfNeeded();\n            system.setArtifacts(getArtifactsIfNeeded());\n            if (configurationChanged) {\n                configurationChanged = false;\n                // try to remove outdated .tsbuildinfo file for incremental mode\n                if (typeof typescript.getTsBuildInfoEmitOutputFilePath === 'function' &&\n                    configuration.mode !== 'readonly' &&\n                    parsedConfiguration.options.incremental) {\n                    const tsBuildInfoPath = typescript.getTsBuildInfoEmitOutputFilePath(parsedConfiguration.options);\n                    if (tsBuildInfoPath) {\n                        try {\n                            system.deleteFile(tsBuildInfoPath);\n                        }\n                        catch (error) {\n                            // silent\n                        }\n                    }\n                }\n            }\n            return {\n                getDependencies() {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        if (!dependencies) {\n                            dependencies = getDependencies();\n                        }\n                        return dependencies;\n                    });\n                },\n                getIssues() {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        startProfilingIfNeeded();\n                        parsedConfiguration = parseConfigurationIfNeeded();\n                        // report configuration diagnostics and exit\n                        if (parseConfigurationDiagnostics.length) {\n                            let issues = TypeScriptIssueFactory_1.createIssuesFromTsDiagnostics(typescript, parseConfigurationDiagnostics);\n                            issues.forEach((issue) => {\n                                if (!issue.file) {\n                                    issue.file = configuration.configFile;\n                                }\n                            });\n                            extensions.forEach((extension) => {\n                                if (extension.extendIssues) {\n                                    issues = extension.extendIssues(issues);\n                                }\n                            });\n                            return issues;\n                        }\n                        if (configuration.build) {\n                            // solution builder case\n                            // ensure watch solution builder host exists\n                            if (!watchSolutionBuilderHost) {\n                                performance.markStart('Create Solution Builder Host');\n                                watchSolutionBuilderHost = ControlledWatchSolutionBuilderHost_1.createControlledWatchSolutionBuilderHost(typescript, parsedConfiguration, system, (rootNames, compilerOptions, host, oldProgram, configFileParsingDiagnostics, projectReferences) => {\n                                    if (compilerOptions) {\n                                        startTracingIfNeeded(compilerOptions);\n                                    }\n                                    return typescript.createSemanticDiagnosticsBuilderProgram(rootNames, compilerOptions, host, oldProgram, configFileParsingDiagnostics, projectReferences);\n                                }, undefined, undefined, undefined, undefined, (builderProgram) => {\n                                    const projectName = getProjectNameOfBuilderProgram(builderProgram);\n                                    const diagnostics = getDiagnosticsOfBuilderProgram(builderProgram);\n                                    // update diagnostics\n                                    diagnosticsPerProject.set(projectName, diagnostics);\n                                    // emit .tsbuildinfo file if needed\n                                    emitTsBuildInfoFileForBuilderProgram(builderProgram);\n                                    stopTracingIfNeeded(builderProgram);\n                                }, extensions);\n                                performance.markEnd('Create Solution Builder Host');\n                                solutionBuilder = undefined;\n                            }\n                            // ensure solution builder exists and is up-to-date\n                            if (!solutionBuilder || shouldUpdateRootFiles) {\n                                // not sure if it's the best option - maybe there is a smarter way to do this\n                                shouldUpdateRootFiles = false;\n                                performance.markStart('Create Solution Builder');\n                                solutionBuilder = typescript.createSolutionBuilderWithWatch(watchSolutionBuilderHost, [configuration.configFile], {});\n                                performance.markEnd('Create Solution Builder');\n                                performance.markStart('Build Solutions');\n                                solutionBuilder.build();\n                                performance.markEnd('Build Solutions');\n                            }\n                        }\n                        else {\n                            // watch compiler case\n                            // ensure watch compiler host exists\n                            if (!watchCompilerHost) {\n                                performance.markStart('Create Watch Compiler Host');\n                                watchCompilerHost = ControlledWatchCompilerHost_1.createControlledWatchCompilerHost(typescript, parsedConfiguration, system, (rootNames, compilerOptions, host, oldProgram, configFileParsingDiagnostics, projectReferences) => {\n                                    if (compilerOptions) {\n                                        startTracingIfNeeded(compilerOptions);\n                                    }\n                                    return typescript.createSemanticDiagnosticsBuilderProgram(rootNames, compilerOptions, host, oldProgram, configFileParsingDiagnostics, projectReferences);\n                                }, undefined, undefined, (builderProgram) => {\n                                    const projectName = getProjectNameOfBuilderProgram(builderProgram);\n                                    const diagnostics = getDiagnosticsOfBuilderProgram(builderProgram);\n                                    // update diagnostics\n                                    diagnosticsPerProject.set(projectName, diagnostics);\n                                    // emit .tsbuildinfo file if needed\n                                    emitTsBuildInfoFileForBuilderProgram(builderProgram);\n                                    stopTracingIfNeeded(builderProgram);\n                                }, extensions);\n                                performance.markEnd('Create Watch Compiler Host');\n                                watchProgram = undefined;\n                            }\n                            // ensure watch program exists\n                            if (!watchProgram) {\n                                performance.markStart('Create Watch Program');\n                                watchProgram = typescript.createWatchProgram(watchCompilerHost);\n                                performance.markEnd('Create Watch Program');\n                            }\n                            if (shouldUpdateRootFiles && (dependencies === null || dependencies === void 0 ? void 0 : dependencies.files)) {\n                                // we have to update root files manually as don't use config file as a program input\n                                watchProgram.updateRootFileNames(dependencies.files);\n                                shouldUpdateRootFiles = false;\n                            }\n                        }\n                        changedFiles.forEach((changedFile) => {\n                            if (system) {\n                                system.invokeFileChanged(changedFile);\n                            }\n                        });\n                        deletedFiles.forEach((removedFile) => {\n                            if (system) {\n                                system.invokeFileDeleted(removedFile);\n                            }\n                        });\n                        // wait for all queued events to be processed\n                        performance.markStart('Queued Tasks');\n                        yield system.waitForQueued();\n                        performance.markEnd('Queued Tasks');\n                        // aggregate all diagnostics and map them to issues\n                        const diagnostics = [];\n                        diagnosticsPerProject.forEach((projectDiagnostics) => {\n                            diagnostics.push(...projectDiagnostics);\n                        });\n                        let issues = TypeScriptIssueFactory_1.createIssuesFromTsDiagnostics(typescript, diagnostics);\n                        extensions.forEach((extension) => {\n                            if (extension.extendIssues) {\n                                issues = extension.extendIssues(issues);\n                            }\n                        });\n                        dumpTracingLegendIfNeeded();\n                        stopProfilingIfNeeded();\n                        return issues;\n                    });\n                },\n                close() {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        // do nothing\n                    });\n                },\n            };\n        }),\n    };\n}\nexports.createTypeScriptReporter = createTypeScriptReporter;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}