{"ast":null,"code":"import fs from 'fs';\nimport path from 'path';\nimport fastGlob from 'fast-glob';\nimport LRU from 'quick-lru';\nimport normalizePath from 'normalize-path';\nimport hash from '../util/hashConfig';\nimport getModuleDependencies from '../lib/getModuleDependencies';\nimport resolveConfig from '../public/resolve-config';\nimport resolveConfigPath from '../util/resolveConfigPath';\nimport { env } from './sharedState';\nimport { getContext, getFileModifiedMap } from './setupContextUtils';\nimport parseDependency from '../util/parseDependency';\nimport { validateConfig } from '../util/validateConfig.js';\nlet configPathCache = new LRU({\n  maxSize: 100\n});\nlet candidateFilesCache = new WeakMap();\n\nfunction getCandidateFiles(context, tailwindConfig) {\n  if (candidateFilesCache.has(context)) {\n    return candidateFilesCache.get(context);\n  }\n\n  let candidateFiles = tailwindConfig.content.files.filter(item => typeof item === 'string').map(contentPath => normalizePath(contentPath));\n  return candidateFilesCache.set(context, candidateFiles).get(context);\n} // Get the config object based on a path\n\n\nfunction getTailwindConfig(configOrPath) {\n  let userConfigPath = resolveConfigPath(configOrPath);\n\n  if (userConfigPath !== null) {\n    let [prevConfig, prevConfigHash, prevDeps, prevModified] = configPathCache.get(userConfigPath) || [];\n    let newDeps = getModuleDependencies(userConfigPath).map(dep => dep.file);\n    let modified = false;\n    let newModified = new Map();\n\n    for (let file of newDeps) {\n      let time = fs.statSync(file).mtimeMs;\n      newModified.set(file, time);\n\n      if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n        modified = true;\n      }\n    } // It hasn't changed (based on timestamps)\n\n\n    if (!modified) {\n      return [prevConfig, userConfigPath, prevConfigHash, prevDeps];\n    } // It has changed (based on timestamps), or first run\n\n\n    for (let file of newDeps) {\n      delete require.cache[file];\n    }\n\n    let newConfig = resolveConfig(require(userConfigPath));\n    newConfig = validateConfig(newConfig);\n    let newHash = hash(newConfig);\n    configPathCache.set(userConfigPath, [newConfig, newHash, newDeps, newModified]);\n    return [newConfig, userConfigPath, newHash, newDeps];\n  } // It's a plain object, not a path\n\n\n  let newConfig = resolveConfig(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n  newConfig = validateConfig(newConfig);\n  return [newConfig, null, hash(newConfig), []];\n}\n\nfunction resolvedChangedContent(context, candidateFiles, fileModifiedMap) {\n  let changedContent = context.tailwindConfig.content.files.filter(item => typeof item.raw === 'string').map(_ref => {\n    let {\n      raw,\n      extension = 'html'\n    } = _ref;\n    return {\n      content: raw,\n      extension\n    };\n  });\n\n  for (let changedFile of resolveChangedFiles(candidateFiles, fileModifiedMap)) {\n    let content = fs.readFileSync(changedFile, 'utf8');\n    let extension = path.extname(changedFile).slice(1);\n    changedContent.push({\n      content,\n      extension\n    });\n  }\n\n  return changedContent;\n}\n\nfunction resolveChangedFiles(candidateFiles, fileModifiedMap) {\n  let changedFiles = new Set();\n  env.DEBUG && console.time('Finding changed files');\n  let files = fastGlob.sync(candidateFiles);\n\n  for (let file of files) {\n    let prevModified = fileModifiedMap.has(file) ? fileModifiedMap.get(file) : -Infinity;\n    let modified = fs.statSync(file).mtimeMs;\n\n    if (modified > prevModified) {\n      changedFiles.add(file);\n      fileModifiedMap.set(file, modified);\n    }\n  }\n\n  env.DEBUG && console.timeEnd('Finding changed files');\n  return changedFiles;\n} // DISABLE_TOUCH = TRUE\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\n\nexport default function setupTrackingContext(configOrPath) {\n  return _ref2 => {\n    let {\n      tailwindDirectives,\n      registerDependency\n    } = _ref2;\n    return (root, result) => {\n      let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n      let contextDependencies = new Set(configDependencies); // If there are no @tailwind or @apply rules, we don't consider this CSS\n      // file or its dependencies to be dependencies of the context. Can reuse\n      // the context even if they change. We may want to think about `@layer`\n      // being part of this trigger too, but it's tough because it's impossible\n      // for a layer in one file to end up in the actual @tailwind rule in\n      // another file since independent sources are effectively isolated.\n\n      if (tailwindDirectives.size > 0) {\n        // Add current css file as a context dependencies.\n        contextDependencies.add(result.opts.from); // Add all css @import dependencies as context dependencies.\n\n        for (let message of result.messages) {\n          if (message.type === 'dependency') {\n            contextDependencies.add(message.file);\n          }\n        }\n      }\n\n      let [context] = getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n      let candidateFiles = getCandidateFiles(context, tailwindConfig); // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's\n      // dependencies to be dependencies of the context. Can reuse the context even if they change.\n      // We may want to think about `@layer` being part of this trigger too, but it's tough\n      // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n      // in another file since independent sources are effectively isolated.\n\n      if (tailwindDirectives.size > 0) {\n        let fileModifiedMap = getFileModifiedMap(context); // Add template paths as postcss dependencies.\n\n        for (let fileOrGlob of candidateFiles) {\n          let dependency = parseDependency(fileOrGlob);\n\n          if (dependency) {\n            registerDependency(dependency);\n          }\n        }\n\n        for (let changedContent of resolvedChangedContent(context, candidateFiles, fileModifiedMap)) {\n          context.changedContent.push(changedContent);\n        }\n      }\n\n      for (let file of configDependencies) {\n        registerDependency({\n          type: 'dependency',\n          file\n        });\n      }\n\n      return context;\n    };\n  };\n}","map":{"version":3,"names":["fs","path","fastGlob","LRU","normalizePath","hash","getModuleDependencies","resolveConfig","resolveConfigPath","env","getContext","getFileModifiedMap","parseDependency","validateConfig","configPathCache","maxSize","candidateFilesCache","WeakMap","getCandidateFiles","context","tailwindConfig","has","get","candidateFiles","content","files","filter","item","map","contentPath","set","getTailwindConfig","configOrPath","userConfigPath","prevConfig","prevConfigHash","prevDeps","prevModified","newDeps","dep","file","modified","newModified","Map","time","statSync","mtimeMs","require","cache","newConfig","newHash","config","undefined","resolvedChangedContent","fileModifiedMap","changedContent","raw","extension","changedFile","resolveChangedFiles","readFileSync","extname","slice","push","changedFiles","Set","DEBUG","console","sync","Infinity","add","timeEnd","setupTrackingContext","tailwindDirectives","registerDependency","root","result","tailwindConfigHash","configDependencies","contextDependencies","size","opts","from","message","messages","type","fileOrGlob","dependency"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/src/lib/setupTrackingContext.js"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\n\nimport fastGlob from 'fast-glob'\nimport LRU from 'quick-lru'\nimport normalizePath from 'normalize-path'\n\nimport hash from '../util/hashConfig'\nimport getModuleDependencies from '../lib/getModuleDependencies'\n\nimport resolveConfig from '../public/resolve-config'\n\nimport resolveConfigPath from '../util/resolveConfigPath'\n\nimport { env } from './sharedState'\n\nimport { getContext, getFileModifiedMap } from './setupContextUtils'\nimport parseDependency from '../util/parseDependency'\nimport { validateConfig } from '../util/validateConfig.js'\n\nlet configPathCache = new LRU({ maxSize: 100 })\n\nlet candidateFilesCache = new WeakMap()\n\nfunction getCandidateFiles(context, tailwindConfig) {\n  if (candidateFilesCache.has(context)) {\n    return candidateFilesCache.get(context)\n  }\n\n  let candidateFiles = tailwindConfig.content.files\n    .filter((item) => typeof item === 'string')\n    .map((contentPath) => normalizePath(contentPath))\n\n  return candidateFilesCache.set(context, candidateFiles).get(context)\n}\n\n// Get the config object based on a path\nfunction getTailwindConfig(configOrPath) {\n  let userConfigPath = resolveConfigPath(configOrPath)\n\n  if (userConfigPath !== null) {\n    let [prevConfig, prevConfigHash, prevDeps, prevModified] =\n      configPathCache.get(userConfigPath) || []\n\n    let newDeps = getModuleDependencies(userConfigPath).map((dep) => dep.file)\n\n    let modified = false\n    let newModified = new Map()\n    for (let file of newDeps) {\n      let time = fs.statSync(file).mtimeMs\n      newModified.set(file, time)\n      if (!prevModified || !prevModified.has(file) || time > prevModified.get(file)) {\n        modified = true\n      }\n    }\n\n    // It hasn't changed (based on timestamps)\n    if (!modified) {\n      return [prevConfig, userConfigPath, prevConfigHash, prevDeps]\n    }\n\n    // It has changed (based on timestamps), or first run\n    for (let file of newDeps) {\n      delete require.cache[file]\n    }\n    let newConfig = resolveConfig(require(userConfigPath))\n    newConfig = validateConfig(newConfig)\n    let newHash = hash(newConfig)\n    configPathCache.set(userConfigPath, [newConfig, newHash, newDeps, newModified])\n    return [newConfig, userConfigPath, newHash, newDeps]\n  }\n\n  // It's a plain object, not a path\n  let newConfig = resolveConfig(\n    configOrPath.config === undefined ? configOrPath : configOrPath.config\n  )\n\n  newConfig = validateConfig(newConfig)\n\n  return [newConfig, null, hash(newConfig), []]\n}\n\nfunction resolvedChangedContent(context, candidateFiles, fileModifiedMap) {\n  let changedContent = context.tailwindConfig.content.files\n    .filter((item) => typeof item.raw === 'string')\n    .map(({ raw, extension = 'html' }) => ({ content: raw, extension }))\n\n  for (let changedFile of resolveChangedFiles(candidateFiles, fileModifiedMap)) {\n    let content = fs.readFileSync(changedFile, 'utf8')\n    let extension = path.extname(changedFile).slice(1)\n    changedContent.push({ content, extension })\n  }\n  return changedContent\n}\n\nfunction resolveChangedFiles(candidateFiles, fileModifiedMap) {\n  let changedFiles = new Set()\n  env.DEBUG && console.time('Finding changed files')\n  let files = fastGlob.sync(candidateFiles)\n  for (let file of files) {\n    let prevModified = fileModifiedMap.has(file) ? fileModifiedMap.get(file) : -Infinity\n    let modified = fs.statSync(file).mtimeMs\n\n    if (modified > prevModified) {\n      changedFiles.add(file)\n      fileModifiedMap.set(file, modified)\n    }\n  }\n  env.DEBUG && console.timeEnd('Finding changed files')\n  return changedFiles\n}\n\n// DISABLE_TOUCH = TRUE\n\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\nexport default function setupTrackingContext(configOrPath) {\n  return ({ tailwindDirectives, registerDependency }) => {\n    return (root, result) => {\n      let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] =\n        getTailwindConfig(configOrPath)\n\n      let contextDependencies = new Set(configDependencies)\n\n      // If there are no @tailwind or @apply rules, we don't consider this CSS\n      // file or its dependencies to be dependencies of the context. Can reuse\n      // the context even if they change. We may want to think about `@layer`\n      // being part of this trigger too, but it's tough because it's impossible\n      // for a layer in one file to end up in the actual @tailwind rule in\n      // another file since independent sources are effectively isolated.\n      if (tailwindDirectives.size > 0) {\n        // Add current css file as a context dependencies.\n        contextDependencies.add(result.opts.from)\n\n        // Add all css @import dependencies as context dependencies.\n        for (let message of result.messages) {\n          if (message.type === 'dependency') {\n            contextDependencies.add(message.file)\n          }\n        }\n      }\n\n      let [context] = getContext(\n        root,\n        result,\n        tailwindConfig,\n        userConfigPath,\n        tailwindConfigHash,\n        contextDependencies\n      )\n\n      let candidateFiles = getCandidateFiles(context, tailwindConfig)\n\n      // If there are no @tailwind or @apply rules, we don't consider this CSS file or it's\n      // dependencies to be dependencies of the context. Can reuse the context even if they change.\n      // We may want to think about `@layer` being part of this trigger too, but it's tough\n      // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n      // in another file since independent sources are effectively isolated.\n      if (tailwindDirectives.size > 0) {\n        let fileModifiedMap = getFileModifiedMap(context)\n\n        // Add template paths as postcss dependencies.\n        for (let fileOrGlob of candidateFiles) {\n          let dependency = parseDependency(fileOrGlob)\n          if (dependency) {\n            registerDependency(dependency)\n          }\n        }\n\n        for (let changedContent of resolvedChangedContent(\n          context,\n          candidateFiles,\n          fileModifiedMap\n        )) {\n          context.changedContent.push(changedContent)\n        }\n      }\n\n      for (let file of configDependencies) {\n        registerDependency({ type: 'dependency', file })\n      }\n\n      return context\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}