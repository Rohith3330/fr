{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _utilities = require(\"../utilities\");\n\nconst schema = [{\n  enum: ['always', 'never'],\n  type: 'string'\n}];\n\nconst create = context => {\n  const sourceCode = context.getSourceCode();\n  const always = (context.options[0] || 'always') === 'always';\n\n  const check = node => {\n    for (const [index, type] of node.types.entries()) {\n      if (index + 1 === node.types.length) {\n        continue;\n      }\n\n      const separator = (0, _utilities.getTokenAfterParens)(sourceCode, type);\n      const endOfType = sourceCode.getTokenBefore(separator);\n      const nextType = sourceCode.getTokenAfter(separator);\n      const spaceBefore = separator.range[0] - endOfType.range[1];\n      const spaceAfter = nextType.range[0] - separator.range[1];\n      const data = {\n        type: node.type === 'UnionTypeAnnotation' ? 'union' : 'intersection'\n      };\n\n      if (always) {\n        if (!spaceBefore) {\n          context.report({\n            data,\n            fix: _utilities.spacingFixers.addSpaceAfter(endOfType),\n            message: 'There must be a space before {{type}} type annotation separator',\n            node\n          });\n        }\n\n        if (!spaceAfter) {\n          context.report({\n            data,\n            fix: _utilities.spacingFixers.addSpaceAfter(separator),\n            message: 'There must be a space after {{type}} type annotation separator',\n            node\n          });\n        }\n      } else {\n        if (spaceBefore) {\n          context.report({\n            data,\n            fix: _utilities.spacingFixers.stripSpacesAfter(endOfType, spaceBefore),\n            message: 'There must be no space before {{type}} type annotation separator',\n            node\n          });\n        }\n\n        if (spaceAfter) {\n          context.report({\n            data,\n            fix: _utilities.spacingFixers.stripSpacesAfter(separator, spaceAfter),\n            message: 'There must be no space after {{type}} type annotation separator',\n            node\n          });\n        }\n      }\n    }\n  };\n\n  return {\n    IntersectionTypeAnnotation: check,\n    UnionTypeAnnotation: check\n  };\n};\n\nvar _default = {\n  create,\n  meta: {\n    fixable: 'code'\n  },\n  schema\n};\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_utilities","require","schema","enum","type","create","context","sourceCode","getSourceCode","always","options","check","node","index","types","entries","length","separator","getTokenAfterParens","endOfType","getTokenBefore","nextType","getTokenAfter","spaceBefore","range","spaceAfter","data","report","fix","spacingFixers","addSpaceAfter","message","stripSpacesAfter","IntersectionTypeAnnotation","UnionTypeAnnotation","_default","meta","fixable","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-flowtype/dist/rules/unionIntersectionSpacing.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _utilities = require(\"../utilities\");\n\nconst schema = [{\n  enum: ['always', 'never'],\n  type: 'string'\n}];\n\nconst create = context => {\n  const sourceCode = context.getSourceCode();\n  const always = (context.options[0] || 'always') === 'always';\n\n  const check = node => {\n    for (const [index, type] of node.types.entries()) {\n      if (index + 1 === node.types.length) {\n        continue;\n      }\n\n      const separator = (0, _utilities.getTokenAfterParens)(sourceCode, type);\n      const endOfType = sourceCode.getTokenBefore(separator);\n      const nextType = sourceCode.getTokenAfter(separator);\n      const spaceBefore = separator.range[0] - endOfType.range[1];\n      const spaceAfter = nextType.range[0] - separator.range[1];\n      const data = {\n        type: node.type === 'UnionTypeAnnotation' ? 'union' : 'intersection'\n      };\n\n      if (always) {\n        if (!spaceBefore) {\n          context.report({\n            data,\n            fix: _utilities.spacingFixers.addSpaceAfter(endOfType),\n            message: 'There must be a space before {{type}} type annotation separator',\n            node\n          });\n        }\n\n        if (!spaceAfter) {\n          context.report({\n            data,\n            fix: _utilities.spacingFixers.addSpaceAfter(separator),\n            message: 'There must be a space after {{type}} type annotation separator',\n            node\n          });\n        }\n      } else {\n        if (spaceBefore) {\n          context.report({\n            data,\n            fix: _utilities.spacingFixers.stripSpacesAfter(endOfType, spaceBefore),\n            message: 'There must be no space before {{type}} type annotation separator',\n            node\n          });\n        }\n\n        if (spaceAfter) {\n          context.report({\n            data,\n            fix: _utilities.spacingFixers.stripSpacesAfter(separator, spaceAfter),\n            message: 'There must be no space after {{type}} type annotation separator',\n            node\n          });\n        }\n      }\n    }\n  };\n\n  return {\n    IntersectionTypeAnnotation: check,\n    UnionTypeAnnotation: check\n  };\n};\n\nvar _default = {\n  create,\n  meta: {\n    fixable: 'code'\n  },\n  schema\n};\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}