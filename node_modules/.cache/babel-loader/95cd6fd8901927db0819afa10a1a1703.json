{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst child_process_1 = require(\"child_process\");\n\nconst RpcIpcMessagePortClosedError_1 = require(\"./error/RpcIpcMessagePortClosedError\");\n\nfunction createRpcIpcMessagePort(process) {\n  const messageListeners = new Set();\n  const errorListeners = new Set();\n  let closedError;\n\n  const handleExit = (code, signal) => __awaiter(this, void 0, void 0, function* () {\n    closedError = new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(code ? `Process ${process.pid} exited with code \"${code}\" [${signal}]` : `Process ${process.pid} exited [${signal}].`, code, signal);\n    errorListeners.forEach(listener => {\n      if (closedError) {\n        listener(closedError);\n      }\n    });\n    yield port.close();\n  });\n\n  const handleMessage = message => {\n    messageListeners.forEach(listener => {\n      listener(message);\n    });\n  };\n\n  process.on('message', handleMessage);\n  process.on('exit', handleExit);\n  const port = {\n    dispatchMessage: message => __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => {\n        if (!process.connected) {\n          reject(closedError || new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(`Process ${process.pid} doesn't have open IPC channels`));\n        }\n\n        if (process.send) {\n          process.send(Object.assign(Object.assign({}, message), {\n            source: process.pid\n          }), undefined, undefined, sendError => {\n            if (sendError) {\n              if (!closedError) {\n                closedError = new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(`Cannot send the message - the message port has been closed for the process ${process.pid}.`);\n              }\n\n              reject(closedError);\n            } else {\n              resolve();\n            }\n          });\n        } else {\n          reject(new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(`Process ${process.pid} doesn't have IPC channels`));\n        }\n      });\n    }),\n    addMessageListener: listener => {\n      messageListeners.add(listener);\n    },\n    removeMessageListener: listener => {\n      messageListeners.delete(listener);\n    },\n    addErrorListener: listener => {\n      errorListeners.add(listener);\n    },\n    removeErrorListener: listener => {\n      errorListeners.delete(listener);\n    },\n    isOpen: () => !!process.connected,\n    open: () => __awaiter(this, void 0, void 0, function* () {\n      if (!process.connected || closedError) {\n        throw closedError || new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(`Cannot open closed IPC channel for process ${process.pid}.`);\n      }\n    }),\n    close: () => __awaiter(this, void 0, void 0, function* () {\n      process.off('message', handleMessage);\n      process.off('exit', handleExit);\n      messageListeners.clear();\n      errorListeners.clear();\n\n      if (process.disconnect && process.connected) {\n        process.disconnect();\n      }\n    })\n  };\n  return port;\n}\n\nexports.createRpcIpcMessagePort = createRpcIpcMessagePort;\n\nfunction createRpcIpcForkedProcessMessagePort(filePath) {\n  let memoryLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2048;\n  let autoRecreate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  function createChildProcess() {\n    return child_process_1.fork(filePath, [], {\n      execArgv: [`--max-old-space-size=${memoryLimit}`],\n      stdio: ['inherit', 'inherit', 'inherit', 'ipc']\n    });\n  }\n\n  const messageListeners = new Set();\n  const errorListeners = new Set();\n  let childProcess = createChildProcess();\n  let port = createRpcIpcMessagePort(childProcess);\n  return {\n    dispatchMessage: message => port.dispatchMessage(message),\n    addMessageListener: listener => {\n      messageListeners.add(listener);\n      return port.addMessageListener(listener);\n    },\n    removeMessageListener: listener => {\n      messageListeners.delete(listener);\n      return port.removeMessageListener(listener);\n    },\n    addErrorListener: listener => {\n      errorListeners.add(listener);\n      return port.addErrorListener(listener);\n    },\n    removeErrorListener: listener => {\n      errorListeners.delete(listener);\n      return port.removeErrorListener(listener);\n    },\n    isOpen: () => port.isOpen(),\n    open: () => __awaiter(this, void 0, void 0, function* () {\n      if (!port.isOpen() && autoRecreate) {\n        // recreate the process and add existing message listeners\n        childProcess = createChildProcess();\n        port = createRpcIpcMessagePort(childProcess);\n        messageListeners.forEach(listener => {\n          port.addMessageListener(listener);\n        });\n        errorListeners.forEach(listener => {\n          port.addErrorListener(listener);\n        });\n      } else {\n        return port.open();\n      }\n    }),\n    close: () => __awaiter(this, void 0, void 0, function* () {\n      yield port.close();\n      messageListeners.clear();\n      errorListeners.clear();\n\n      if (childProcess) {\n        childProcess.kill('SIGTERM');\n        childProcess = undefined;\n      }\n    })\n  };\n}\n\nexports.createRpcIpcForkedProcessMessagePort = createRpcIpcForkedProcessMessagePort;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","child_process_1","require","RpcIpcMessagePortClosedError_1","createRpcIpcMessagePort","process","messageListeners","Set","errorListeners","closedError","handleExit","code","signal","RpcIpcMessagePortClosedError","pid","forEach","listener","port","close","handleMessage","message","on","dispatchMessage","connected","send","assign","source","undefined","sendError","addMessageListener","add","removeMessageListener","delete","addErrorListener","removeErrorListener","isOpen","open","off","clear","disconnect","createRpcIpcForkedProcessMessagePort","filePath","memoryLimit","autoRecreate","createChildProcess","fork","execArgv","stdio","childProcess","kill"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/fork-ts-checker-webpack-plugin/lib/rpc/rpc-ipc/RpcIpcMessagePort.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst child_process_1 = require(\"child_process\");\nconst RpcIpcMessagePortClosedError_1 = require(\"./error/RpcIpcMessagePortClosedError\");\nfunction createRpcIpcMessagePort(process) {\n    const messageListeners = new Set();\n    const errorListeners = new Set();\n    let closedError;\n    const handleExit = (code, signal) => __awaiter(this, void 0, void 0, function* () {\n        closedError = new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(code\n            ? `Process ${process.pid} exited with code \"${code}\" [${signal}]`\n            : `Process ${process.pid} exited [${signal}].`, code, signal);\n        errorListeners.forEach((listener) => {\n            if (closedError) {\n                listener(closedError);\n            }\n        });\n        yield port.close();\n    });\n    const handleMessage = (message) => {\n        messageListeners.forEach((listener) => {\n            listener(message);\n        });\n    };\n    process.on('message', handleMessage);\n    process.on('exit', handleExit);\n    const port = {\n        dispatchMessage: (message) => __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                if (!process.connected) {\n                    reject(closedError ||\n                        new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(`Process ${process.pid} doesn't have open IPC channels`));\n                }\n                if (process.send) {\n                    process.send(Object.assign(Object.assign({}, message), { source: process.pid }), undefined, undefined, (sendError) => {\n                        if (sendError) {\n                            if (!closedError) {\n                                closedError = new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(`Cannot send the message - the message port has been closed for the process ${process.pid}.`);\n                            }\n                            reject(closedError);\n                        }\n                        else {\n                            resolve();\n                        }\n                    });\n                }\n                else {\n                    reject(new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(`Process ${process.pid} doesn't have IPC channels`));\n                }\n            });\n        }),\n        addMessageListener: (listener) => {\n            messageListeners.add(listener);\n        },\n        removeMessageListener: (listener) => {\n            messageListeners.delete(listener);\n        },\n        addErrorListener: (listener) => {\n            errorListeners.add(listener);\n        },\n        removeErrorListener: (listener) => {\n            errorListeners.delete(listener);\n        },\n        isOpen: () => !!process.connected,\n        open: () => __awaiter(this, void 0, void 0, function* () {\n            if (!process.connected || closedError) {\n                throw (closedError ||\n                    new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(`Cannot open closed IPC channel for process ${process.pid}.`));\n            }\n        }),\n        close: () => __awaiter(this, void 0, void 0, function* () {\n            process.off('message', handleMessage);\n            process.off('exit', handleExit);\n            messageListeners.clear();\n            errorListeners.clear();\n            if (process.disconnect && process.connected) {\n                process.disconnect();\n            }\n        }),\n    };\n    return port;\n}\nexports.createRpcIpcMessagePort = createRpcIpcMessagePort;\nfunction createRpcIpcForkedProcessMessagePort(filePath, memoryLimit = 2048, autoRecreate = true) {\n    function createChildProcess() {\n        return child_process_1.fork(filePath, [], {\n            execArgv: [`--max-old-space-size=${memoryLimit}`],\n            stdio: ['inherit', 'inherit', 'inherit', 'ipc'],\n        });\n    }\n    const messageListeners = new Set();\n    const errorListeners = new Set();\n    let childProcess = createChildProcess();\n    let port = createRpcIpcMessagePort(childProcess);\n    return {\n        dispatchMessage: (message) => port.dispatchMessage(message),\n        addMessageListener: (listener) => {\n            messageListeners.add(listener);\n            return port.addMessageListener(listener);\n        },\n        removeMessageListener: (listener) => {\n            messageListeners.delete(listener);\n            return port.removeMessageListener(listener);\n        },\n        addErrorListener: (listener) => {\n            errorListeners.add(listener);\n            return port.addErrorListener(listener);\n        },\n        removeErrorListener: (listener) => {\n            errorListeners.delete(listener);\n            return port.removeErrorListener(listener);\n        },\n        isOpen: () => port.isOpen(),\n        open: () => __awaiter(this, void 0, void 0, function* () {\n            if (!port.isOpen() && autoRecreate) {\n                // recreate the process and add existing message listeners\n                childProcess = createChildProcess();\n                port = createRpcIpcMessagePort(childProcess);\n                messageListeners.forEach((listener) => {\n                    port.addMessageListener(listener);\n                });\n                errorListeners.forEach((listener) => {\n                    port.addErrorListener(listener);\n                });\n            }\n            else {\n                return port.open();\n            }\n        }),\n        close: () => __awaiter(this, void 0, void 0, function* () {\n            yield port.close();\n            messageListeners.clear();\n            errorListeners.clear();\n            if (childProcess) {\n                childProcess.kill('SIGTERM');\n                childProcess = undefined;\n            }\n        }),\n    };\n}\nexports.createRpcIpcForkedProcessMessagePort = createRpcIpcForkedProcessMessagePort;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}