{"ast":null,"code":"/**\n * Gets the source (i.e. host) of the script currently running.\n * @returns {string}\n */\nfunction getCurrentScriptSource() {\n  // `document.currentScript` is the most accurate way to get the current running script,\n  // but is not supported in all browsers (most notably, IE).\n  if ('currentScript' in document) {\n    // In some cases, `document.currentScript` would be `null` even if the browser supports it:\n    // e.g. asynchronous chunks on Firefox.\n    // We should not fallback to the list-approach as it would not be safe.\n    if (document.currentScript == null) return;\n    return document.currentScript.getAttribute('src');\n  } // Fallback to getting all scripts running in the document,\n  // and finding the last one injected.\n  else {\n    const scriptElementsWithSrc = Array.prototype.filter.call(document.scripts || [], function (elem) {\n      return elem.getAttribute('src');\n    });\n    if (!scriptElementsWithSrc.length) return;\n    const currentScript = scriptElementsWithSrc[scriptElementsWithSrc.length - 1];\n    return currentScript.getAttribute('src');\n  }\n}\n\nmodule.exports = getCurrentScriptSource;","map":{"version":3,"names":["getCurrentScriptSource","document","currentScript","getAttribute","scriptElementsWithSrc","Array","prototype","filter","call","scripts","elem","length","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@pmmmwh/react-refresh-webpack-plugin/sockets/utils/getCurrentScriptSource.js"],"sourcesContent":["/**\n * Gets the source (i.e. host) of the script currently running.\n * @returns {string}\n */\nfunction getCurrentScriptSource() {\n  // `document.currentScript` is the most accurate way to get the current running script,\n  // but is not supported in all browsers (most notably, IE).\n  if ('currentScript' in document) {\n    // In some cases, `document.currentScript` would be `null` even if the browser supports it:\n    // e.g. asynchronous chunks on Firefox.\n    // We should not fallback to the list-approach as it would not be safe.\n    if (document.currentScript == null) return;\n    return document.currentScript.getAttribute('src');\n  }\n  // Fallback to getting all scripts running in the document,\n  // and finding the last one injected.\n  else {\n    const scriptElementsWithSrc = Array.prototype.filter.call(\n      document.scripts || [],\n      function (elem) {\n        return elem.getAttribute('src');\n      }\n    );\n    if (!scriptElementsWithSrc.length) return;\n    const currentScript = scriptElementsWithSrc[scriptElementsWithSrc.length - 1];\n    return currentScript.getAttribute('src');\n  }\n}\n\nmodule.exports = getCurrentScriptSource;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,sBAAT,GAAkC;EAChC;EACA;EACA,IAAI,mBAAmBC,QAAvB,EAAiC;IAC/B;IACA;IACA;IACA,IAAIA,QAAQ,CAACC,aAAT,IAA0B,IAA9B,EAAoC;IACpC,OAAOD,QAAQ,CAACC,aAAT,CAAuBC,YAAvB,CAAoC,KAApC,CAAP;EACD,CAND,CAOA;EACA;EARA,KASK;IACH,MAAMC,qBAAqB,GAAGC,KAAK,CAACC,SAAN,CAAgBC,MAAhB,CAAuBC,IAAvB,CAC5BP,QAAQ,CAACQ,OAAT,IAAoB,EADQ,EAE5B,UAAUC,IAAV,EAAgB;MACd,OAAOA,IAAI,CAACP,YAAL,CAAkB,KAAlB,CAAP;IACD,CAJ2B,CAA9B;IAMA,IAAI,CAACC,qBAAqB,CAACO,MAA3B,EAAmC;IACnC,MAAMT,aAAa,GAAGE,qBAAqB,CAACA,qBAAqB,CAACO,MAAtB,GAA+B,CAAhC,CAA3C;IACA,OAAOT,aAAa,CAACC,YAAd,CAA2B,KAA3B,CAAP;EACD;AACF;;AAEDS,MAAM,CAACC,OAAP,GAAiBb,sBAAjB"},"metadata":{},"sourceType":"script"}