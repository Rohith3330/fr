{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        min,\n        max\n      }\n    } = _ref;\n    return max === undefined ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        min,\n        max\n      }\n    } = _ref2;\n    return max === undefined ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`;\n  }\n};\nconst def = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      parentSchema,\n      data,\n      it\n    } = cxt;\n    let min;\n    let max;\n    const {\n      minContains,\n      maxContains\n    } = parentSchema;\n\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains;\n      max = maxContains;\n    } else {\n      min = 1;\n    }\n\n    const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n    cxt.setParams({\n      min,\n      max\n    });\n\n    if (max === undefined && min === 0) {\n      (0, util_1.checkStrictMode)(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`);\n      return;\n    }\n\n    if (max !== undefined && min > max) {\n      (0, util_1.checkStrictMode)(it, `\"minContains\" > \"maxContains\" is always invalid`);\n      cxt.fail();\n      return;\n    }\n\n    if ((0, util_1.alwaysValidSchema)(it, schema)) {\n      let cond = (0, codegen_1._)`${len} >= ${min}`;\n      if (max !== undefined) cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;\n      cxt.pass(cond);\n      return;\n    }\n\n    it.items = true;\n    const valid = gen.name(\"valid\");\n\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()));\n    } else if (min === 0) {\n      gen.let(valid, true);\n      if (max !== undefined) gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);\n    } else {\n      gen.let(valid, false);\n      validateItemsWithCount();\n    }\n\n    cxt.result(valid, () => cxt.reset());\n\n    function validateItemsWithCount() {\n      const schValid = gen.name(\"_valid\");\n      const count = gen.let(\"count\", 0);\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));\n    }\n\n    function validateItems(_valid, block) {\n      gen.forRange(\"i\", 0, len, i => {\n        cxt.subschema({\n          keyword: \"contains\",\n          dataProp: i,\n          dataPropType: util_1.Type.Num,\n          compositeRule: true\n        }, _valid);\n        block();\n      });\n    }\n\n    function checkLimits(count) {\n      gen.code((0, codegen_1._)`${count}++`);\n\n      if (max === undefined) {\n        gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());\n      } else {\n        gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());\n        if (min === 1) gen.assign(valid, true);else gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));\n      }\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","min","max","undefined","def","keyword","type","schemaType","before","trackErrors","code","cxt","gen","schema","parentSchema","data","it","minContains","maxContains","opts","next","len","const","setParams","fail","cond","pass","items","valid","name","validateItems","if","break","let","validateItemsWithCount","result","reset","schValid","count","checkLimits","_valid","block","forRange","i","subschema","dataProp","dataPropType","util_1","Num","compositeRule","assign","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\mini-css-extract-plugin\\node_modules\\ajv\\lib\\vocabularies\\applicator\\contains.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}