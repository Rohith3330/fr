{"ast":null,"code":"\"use strict\";\n\nconst selectorParser = require(\"postcss-selector-parser\");\n\nconst valueParser = require(\"postcss-value-parser\");\n\nconst {\n  extractICSS\n} = require(\"icss-utils\");\n\nconst isSpacing = node => node.type === \"combinator\" && node.value === \" \";\n\nfunction normalizeNodeArray(nodes) {\n  const array = [];\n  nodes.forEach(x => {\n    if (Array.isArray(x)) {\n      normalizeNodeArray(x).forEach(item => {\n        array.push(item);\n      });\n    } else if (x) {\n      array.push(x);\n    }\n  });\n\n  if (array.length > 0 && isSpacing(array[array.length - 1])) {\n    array.pop();\n  }\n\n  return array;\n}\n\nfunction localizeNode(rule, mode, localAliasMap) {\n  const transform = (node, context) => {\n    if (context.ignoreNextSpacing && !isSpacing(node)) {\n      throw new Error(\"Missing whitespace after \" + context.ignoreNextSpacing);\n    }\n\n    if (context.enforceNoSpacing && isSpacing(node)) {\n      throw new Error(\"Missing whitespace before \" + context.enforceNoSpacing);\n    }\n\n    let newNodes;\n\n    switch (node.type) {\n      case \"root\":\n        {\n          let resultingGlobal;\n          context.hasPureGlobals = false;\n          newNodes = node.nodes.map(n => {\n            const nContext = {\n              global: context.global,\n              lastWasSpacing: true,\n              hasLocals: false,\n              explicit: false\n            };\n            n = transform(n, nContext);\n\n            if (typeof resultingGlobal === \"undefined\") {\n              resultingGlobal = nContext.global;\n            } else if (resultingGlobal !== nContext.global) {\n              throw new Error('Inconsistent rule global/local result in rule \"' + node + '\" (multiple selectors must result in the same mode for the rule)');\n            }\n\n            if (!nContext.hasLocals) {\n              context.hasPureGlobals = true;\n            }\n\n            return n;\n          });\n          context.global = resultingGlobal;\n          node.nodes = normalizeNodeArray(newNodes);\n          break;\n        }\n\n      case \"selector\":\n        {\n          newNodes = node.map(childNode => transform(childNode, context));\n          node = node.clone();\n          node.nodes = normalizeNodeArray(newNodes);\n          break;\n        }\n\n      case \"combinator\":\n        {\n          if (isSpacing(node)) {\n            if (context.ignoreNextSpacing) {\n              context.ignoreNextSpacing = false;\n              context.lastWasSpacing = false;\n              context.enforceNoSpacing = false;\n              return null;\n            }\n\n            context.lastWasSpacing = true;\n            return node;\n          }\n\n          break;\n        }\n\n      case \"pseudo\":\n        {\n          let childContext;\n          const isNested = !!node.length;\n          const isScoped = node.value === \":local\" || node.value === \":global\";\n          const isImportExport = node.value === \":import\" || node.value === \":export\";\n\n          if (isImportExport) {\n            context.hasLocals = true; // :local(.foo)\n          } else if (isNested) {\n            if (isScoped) {\n              if (node.nodes.length === 0) {\n                throw new Error(`${node.value}() can't be empty`);\n              }\n\n              if (context.inside) {\n                throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);\n              }\n\n              childContext = {\n                global: node.value === \":global\",\n                inside: node.value,\n                hasLocals: false,\n                explicit: true\n              };\n              newNodes = node.map(childNode => transform(childNode, childContext)).reduce((acc, next) => acc.concat(next.nodes), []);\n\n              if (newNodes.length) {\n                const {\n                  before,\n                  after\n                } = node.spaces;\n                const first = newNodes[0];\n                const last = newNodes[newNodes.length - 1];\n                first.spaces = {\n                  before,\n                  after: first.spaces.after\n                };\n                last.spaces = {\n                  before: last.spaces.before,\n                  after\n                };\n              }\n\n              node = newNodes;\n              break;\n            } else {\n              childContext = {\n                global: context.global,\n                inside: context.inside,\n                lastWasSpacing: true,\n                hasLocals: false,\n                explicit: context.explicit\n              };\n              newNodes = node.map(childNode => transform(childNode, childContext));\n              node = node.clone();\n              node.nodes = normalizeNodeArray(newNodes);\n\n              if (childContext.hasLocals) {\n                context.hasLocals = true;\n              }\n            }\n\n            break; //:local .foo .bar\n          } else if (isScoped) {\n            if (context.inside) {\n              throw new Error(`A ${node.value} is not allowed inside of a ${context.inside}(...)`);\n            }\n\n            const addBackSpacing = !!node.spaces.before;\n            context.ignoreNextSpacing = context.lastWasSpacing ? node.value : false;\n            context.enforceNoSpacing = context.lastWasSpacing ? false : node.value;\n            context.global = node.value === \":global\";\n            context.explicit = true; // because this node has spacing that is lost when we remove it\n            // we make up for it by adding an extra combinator in since adding\n            // spacing on the parent selector doesn't work\n\n            return addBackSpacing ? selectorParser.combinator({\n              value: \" \"\n            }) : null;\n          }\n\n          break;\n        }\n\n      case \"id\":\n      case \"class\":\n        {\n          if (!node.value) {\n            throw new Error(\"Invalid class or id selector syntax\");\n          }\n\n          if (context.global) {\n            break;\n          }\n\n          const isImportedValue = localAliasMap.has(node.value);\n          const isImportedWithExplicitScope = isImportedValue && context.explicit;\n\n          if (!isImportedValue || isImportedWithExplicitScope) {\n            const innerNode = node.clone();\n            innerNode.spaces = {\n              before: \"\",\n              after: \"\"\n            };\n            node = selectorParser.pseudo({\n              value: \":local\",\n              nodes: [innerNode],\n              spaces: node.spaces\n            });\n            context.hasLocals = true;\n          }\n\n          break;\n        }\n    }\n\n    context.lastWasSpacing = false;\n    context.ignoreNextSpacing = false;\n    context.enforceNoSpacing = false;\n    return node;\n  };\n\n  const rootContext = {\n    global: mode === \"global\",\n    hasPureGlobals: false\n  };\n  rootContext.selector = selectorParser(root => {\n    transform(root, rootContext);\n  }).processSync(rule, {\n    updateSelector: false,\n    lossless: true\n  });\n  return rootContext;\n}\n\nfunction localizeDeclNode(node, context) {\n  switch (node.type) {\n    case \"word\":\n      if (context.localizeNextItem) {\n        if (!context.localAliasMap.has(node.value)) {\n          node.value = \":local(\" + node.value + \")\";\n          context.localizeNextItem = false;\n        }\n      }\n\n      break;\n\n    case \"function\":\n      if (context.options && context.options.rewriteUrl && node.value.toLowerCase() === \"url\") {\n        node.nodes.map(nestedNode => {\n          if (nestedNode.type !== \"string\" && nestedNode.type !== \"word\") {\n            return;\n          }\n\n          let newUrl = context.options.rewriteUrl(context.global, nestedNode.value);\n\n          switch (nestedNode.type) {\n            case \"string\":\n              if (nestedNode.quote === \"'\") {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/'/g, \"\\\\'\");\n              }\n\n              if (nestedNode.quote === '\"') {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/\"/g, '\\\\\"');\n              }\n\n              break;\n\n            case \"word\":\n              newUrl = newUrl.replace(/(\"|'|\\)|\\\\)/g, \"\\\\$1\");\n              break;\n          }\n\n          nestedNode.value = newUrl;\n        });\n      }\n\n      break;\n  }\n\n  return node;\n}\n\nfunction isWordAFunctionArgument(wordNode, functionNode) {\n  return functionNode ? functionNode.nodes.some(functionNodeChild => functionNodeChild.sourceIndex === wordNode.sourceIndex) : false;\n}\n\nfunction localizeDeclarationValues(localize, declaration, context) {\n  const valueNodes = valueParser(declaration.value);\n  valueNodes.walk((node, index, nodes) => {\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: localize && !context.global,\n      localAliasMap: context.localAliasMap\n    };\n    nodes[index] = localizeDeclNode(node, subContext);\n  });\n  declaration.value = valueNodes.toString();\n}\n\nfunction localizeDeclaration(declaration, context) {\n  const isAnimation = /animation$/i.test(declaration.prop);\n\n  if (isAnimation) {\n    const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;\n    /*\n    The spec defines some keywords that you can use to describe properties such as the timing\n    function. These are still valid animation names, so as long as there is a property that accepts\n    a keyword, it is given priority. Only when all the properties that can take a keyword are\n    exhausted can the animation name be set to the keyword. I.e.\n       animation: infinite infinite;\n       The animation will repeat an infinite number of times from the first argument, and will have an\n    animation name of infinite from the second.\n    */\n\n    const animationKeywords = {\n      $alternate: 1,\n      \"$alternate-reverse\": 1,\n      $backwards: 1,\n      $both: 1,\n      $ease: 1,\n      \"$ease-in\": 1,\n      \"$ease-in-out\": 1,\n      \"$ease-out\": 1,\n      $forwards: 1,\n      $infinite: 1,\n      $linear: 1,\n      $none: Infinity,\n      // No matter how many times you write none, it will never be an animation name\n      $normal: 1,\n      $paused: 1,\n      $reverse: 1,\n      $running: 1,\n      \"$step-end\": 1,\n      \"$step-start\": 1,\n      $initial: Infinity,\n      $inherit: Infinity,\n      $unset: Infinity\n    };\n    const didParseAnimationName = false;\n    let parsedAnimationKeywords = {};\n    let stepsFunctionNode = null;\n    const valueNodes = valueParser(declaration.value).walk(node => {\n      /* If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh. */\n      if (node.type === \"div\") {\n        parsedAnimationKeywords = {};\n      }\n\n      if (node.type === \"function\" && node.value.toLowerCase() === \"steps\") {\n        stepsFunctionNode = node;\n      }\n\n      const value = node.type === \"word\" && !isWordAFunctionArgument(node, stepsFunctionNode) ? node.value.toLowerCase() : null;\n      let shouldParseAnimationName = false;\n\n      if (!didParseAnimationName && value && validIdent.test(value)) {\n        if (\"$\" + value in animationKeywords) {\n          parsedAnimationKeywords[\"$\" + value] = \"$\" + value in parsedAnimationKeywords ? parsedAnimationKeywords[\"$\" + value] + 1 : 0;\n          shouldParseAnimationName = parsedAnimationKeywords[\"$\" + value] >= animationKeywords[\"$\" + value];\n        } else {\n          shouldParseAnimationName = true;\n        }\n      }\n\n      const subContext = {\n        options: context.options,\n        global: context.global,\n        localizeNextItem: shouldParseAnimationName && !context.global,\n        localAliasMap: context.localAliasMap\n      };\n      return localizeDeclNode(node, subContext);\n    });\n    declaration.value = valueNodes.toString();\n    return;\n  }\n\n  const isAnimationName = /animation(-name)?$/i.test(declaration.prop);\n\n  if (isAnimationName) {\n    return localizeDeclarationValues(true, declaration, context);\n  }\n\n  const hasUrl = /url\\(/i.test(declaration.value);\n\n  if (hasUrl) {\n    return localizeDeclarationValues(false, declaration, context);\n  }\n}\n\nmodule.exports = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (options && options.mode && options.mode !== \"global\" && options.mode !== \"local\" && options.mode !== \"pure\") {\n    throw new Error('options.mode must be either \"global\", \"local\" or \"pure\" (default \"local\")');\n  }\n\n  const pureMode = options && options.mode === \"pure\";\n  const globalMode = options && options.mode === \"global\";\n  return {\n    postcssPlugin: \"postcss-modules-local-by-default\",\n\n    prepare() {\n      const localAliasMap = new Map();\n      return {\n        Once(root) {\n          const {\n            icssImports\n          } = extractICSS(root, false);\n          Object.keys(icssImports).forEach(key => {\n            Object.keys(icssImports[key]).forEach(prop => {\n              localAliasMap.set(prop, icssImports[key][prop]);\n            });\n          });\n          root.walkAtRules(atRule => {\n            if (/keyframes$/i.test(atRule.name)) {\n              const globalMatch = /^\\s*:global\\s*\\((.+)\\)\\s*$/.exec(atRule.params);\n              const localMatch = /^\\s*:local\\s*\\((.+)\\)\\s*$/.exec(atRule.params);\n              let globalKeyframes = globalMode;\n\n              if (globalMatch) {\n                if (pureMode) {\n                  throw atRule.error(\"@keyframes :global(...) is not allowed in pure mode\");\n                }\n\n                atRule.params = globalMatch[1];\n                globalKeyframes = true;\n              } else if (localMatch) {\n                atRule.params = localMatch[0];\n                globalKeyframes = false;\n              } else if (!globalMode) {\n                if (atRule.params && !localAliasMap.has(atRule.params)) {\n                  atRule.params = \":local(\" + atRule.params + \")\";\n                }\n              }\n\n              atRule.walkDecls(declaration => {\n                localizeDeclaration(declaration, {\n                  localAliasMap,\n                  options: options,\n                  global: globalKeyframes\n                });\n              });\n            } else if (atRule.nodes) {\n              atRule.nodes.forEach(declaration => {\n                if (declaration.type === \"decl\") {\n                  localizeDeclaration(declaration, {\n                    localAliasMap,\n                    options: options,\n                    global: globalMode\n                  });\n                }\n              });\n            }\n          });\n          root.walkRules(rule => {\n            if (rule.parent && rule.parent.type === \"atrule\" && /keyframes$/i.test(rule.parent.name)) {\n              // ignore keyframe rules\n              return;\n            }\n\n            const context = localizeNode(rule, options.mode, localAliasMap);\n            context.options = options;\n            context.localAliasMap = localAliasMap;\n\n            if (pureMode && context.hasPureGlobals) {\n              throw rule.error('Selector \"' + rule.selector + '\" is not pure ' + \"(pure selectors must contain at least one local class or id)\");\n            }\n\n            rule.selector = context.selector; // Less-syntax mixins parse as rules with no nodes\n\n            if (rule.nodes) {\n              rule.nodes.forEach(declaration => localizeDeclaration(declaration, context));\n            }\n          });\n        }\n\n      };\n    }\n\n  };\n};\n\nmodule.exports.postcss = true;","map":{"version":3,"names":["selectorParser","require","valueParser","extractICSS","isSpacing","node","type","value","normalizeNodeArray","nodes","array","forEach","x","Array","isArray","item","push","length","pop","localizeNode","rule","mode","localAliasMap","transform","context","ignoreNextSpacing","Error","enforceNoSpacing","newNodes","resultingGlobal","hasPureGlobals","map","n","nContext","global","lastWasSpacing","hasLocals","explicit","childNode","clone","childContext","isNested","isScoped","isImportExport","inside","reduce","acc","next","concat","before","after","spaces","first","last","addBackSpacing","combinator","isImportedValue","has","isImportedWithExplicitScope","innerNode","pseudo","rootContext","selector","root","processSync","updateSelector","lossless","localizeDeclNode","localizeNextItem","options","rewriteUrl","toLowerCase","nestedNode","newUrl","quote","replace","isWordAFunctionArgument","wordNode","functionNode","some","functionNodeChild","sourceIndex","localizeDeclarationValues","localize","declaration","valueNodes","walk","index","subContext","toString","localizeDeclaration","isAnimation","test","prop","validIdent","animationKeywords","$alternate","$backwards","$both","$ease","$forwards","$infinite","$linear","$none","Infinity","$normal","$paused","$reverse","$running","$initial","$inherit","$unset","didParseAnimationName","parsedAnimationKeywords","stepsFunctionNode","shouldParseAnimationName","isAnimationName","hasUrl","module","exports","pureMode","globalMode","postcssPlugin","prepare","Map","Once","icssImports","Object","keys","key","set","walkAtRules","atRule","name","globalMatch","exec","params","localMatch","globalKeyframes","error","walkDecls","walkRules","parent","postcss"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-modules-local-by-default/src/index.js"],"sourcesContent":["\"use strict\";\n\nconst selectorParser = require(\"postcss-selector-parser\");\nconst valueParser = require(\"postcss-value-parser\");\nconst { extractICSS } = require(\"icss-utils\");\n\nconst isSpacing = (node) => node.type === \"combinator\" && node.value === \" \";\n\nfunction normalizeNodeArray(nodes) {\n  const array = [];\n\n  nodes.forEach((x) => {\n    if (Array.isArray(x)) {\n      normalizeNodeArray(x).forEach((item) => {\n        array.push(item);\n      });\n    } else if (x) {\n      array.push(x);\n    }\n  });\n\n  if (array.length > 0 && isSpacing(array[array.length - 1])) {\n    array.pop();\n  }\n  return array;\n}\n\nfunction localizeNode(rule, mode, localAliasMap) {\n  const transform = (node, context) => {\n    if (context.ignoreNextSpacing && !isSpacing(node)) {\n      throw new Error(\"Missing whitespace after \" + context.ignoreNextSpacing);\n    }\n\n    if (context.enforceNoSpacing && isSpacing(node)) {\n      throw new Error(\"Missing whitespace before \" + context.enforceNoSpacing);\n    }\n\n    let newNodes;\n\n    switch (node.type) {\n      case \"root\": {\n        let resultingGlobal;\n\n        context.hasPureGlobals = false;\n\n        newNodes = node.nodes.map((n) => {\n          const nContext = {\n            global: context.global,\n            lastWasSpacing: true,\n            hasLocals: false,\n            explicit: false,\n          };\n\n          n = transform(n, nContext);\n\n          if (typeof resultingGlobal === \"undefined\") {\n            resultingGlobal = nContext.global;\n          } else if (resultingGlobal !== nContext.global) {\n            throw new Error(\n              'Inconsistent rule global/local result in rule \"' +\n                node +\n                '\" (multiple selectors must result in the same mode for the rule)'\n            );\n          }\n\n          if (!nContext.hasLocals) {\n            context.hasPureGlobals = true;\n          }\n\n          return n;\n        });\n\n        context.global = resultingGlobal;\n\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case \"selector\": {\n        newNodes = node.map((childNode) => transform(childNode, context));\n\n        node = node.clone();\n        node.nodes = normalizeNodeArray(newNodes);\n        break;\n      }\n      case \"combinator\": {\n        if (isSpacing(node)) {\n          if (context.ignoreNextSpacing) {\n            context.ignoreNextSpacing = false;\n            context.lastWasSpacing = false;\n            context.enforceNoSpacing = false;\n            return null;\n          }\n          context.lastWasSpacing = true;\n          return node;\n        }\n        break;\n      }\n      case \"pseudo\": {\n        let childContext;\n        const isNested = !!node.length;\n        const isScoped = node.value === \":local\" || node.value === \":global\";\n        const isImportExport =\n          node.value === \":import\" || node.value === \":export\";\n\n        if (isImportExport) {\n          context.hasLocals = true;\n          // :local(.foo)\n        } else if (isNested) {\n          if (isScoped) {\n            if (node.nodes.length === 0) {\n              throw new Error(`${node.value}() can't be empty`);\n            }\n\n            if (context.inside) {\n              throw new Error(\n                `A ${node.value} is not allowed inside of a ${context.inside}(...)`\n              );\n            }\n\n            childContext = {\n              global: node.value === \":global\",\n              inside: node.value,\n              hasLocals: false,\n              explicit: true,\n            };\n\n            newNodes = node\n              .map((childNode) => transform(childNode, childContext))\n              .reduce((acc, next) => acc.concat(next.nodes), []);\n\n            if (newNodes.length) {\n              const { before, after } = node.spaces;\n\n              const first = newNodes[0];\n              const last = newNodes[newNodes.length - 1];\n\n              first.spaces = { before, after: first.spaces.after };\n              last.spaces = { before: last.spaces.before, after };\n            }\n\n            node = newNodes;\n\n            break;\n          } else {\n            childContext = {\n              global: context.global,\n              inside: context.inside,\n              lastWasSpacing: true,\n              hasLocals: false,\n              explicit: context.explicit,\n            };\n            newNodes = node.map((childNode) =>\n              transform(childNode, childContext)\n            );\n\n            node = node.clone();\n            node.nodes = normalizeNodeArray(newNodes);\n\n            if (childContext.hasLocals) {\n              context.hasLocals = true;\n            }\n          }\n          break;\n\n          //:local .foo .bar\n        } else if (isScoped) {\n          if (context.inside) {\n            throw new Error(\n              `A ${node.value} is not allowed inside of a ${context.inside}(...)`\n            );\n          }\n\n          const addBackSpacing = !!node.spaces.before;\n\n          context.ignoreNextSpacing = context.lastWasSpacing\n            ? node.value\n            : false;\n\n          context.enforceNoSpacing = context.lastWasSpacing\n            ? false\n            : node.value;\n\n          context.global = node.value === \":global\";\n          context.explicit = true;\n\n          // because this node has spacing that is lost when we remove it\n          // we make up for it by adding an extra combinator in since adding\n          // spacing on the parent selector doesn't work\n          return addBackSpacing\n            ? selectorParser.combinator({ value: \" \" })\n            : null;\n        }\n        break;\n      }\n      case \"id\":\n      case \"class\": {\n        if (!node.value) {\n          throw new Error(\"Invalid class or id selector syntax\");\n        }\n\n        if (context.global) {\n          break;\n        }\n\n        const isImportedValue = localAliasMap.has(node.value);\n        const isImportedWithExplicitScope = isImportedValue && context.explicit;\n\n        if (!isImportedValue || isImportedWithExplicitScope) {\n          const innerNode = node.clone();\n          innerNode.spaces = { before: \"\", after: \"\" };\n\n          node = selectorParser.pseudo({\n            value: \":local\",\n            nodes: [innerNode],\n            spaces: node.spaces,\n          });\n\n          context.hasLocals = true;\n        }\n\n        break;\n      }\n    }\n\n    context.lastWasSpacing = false;\n    context.ignoreNextSpacing = false;\n    context.enforceNoSpacing = false;\n\n    return node;\n  };\n\n  const rootContext = {\n    global: mode === \"global\",\n    hasPureGlobals: false,\n  };\n\n  rootContext.selector = selectorParser((root) => {\n    transform(root, rootContext);\n  }).processSync(rule, { updateSelector: false, lossless: true });\n\n  return rootContext;\n}\n\nfunction localizeDeclNode(node, context) {\n  switch (node.type) {\n    case \"word\":\n      if (context.localizeNextItem) {\n        if (!context.localAliasMap.has(node.value)) {\n          node.value = \":local(\" + node.value + \")\";\n          context.localizeNextItem = false;\n        }\n      }\n      break;\n\n    case \"function\":\n      if (\n        context.options &&\n        context.options.rewriteUrl &&\n        node.value.toLowerCase() === \"url\"\n      ) {\n        node.nodes.map((nestedNode) => {\n          if (nestedNode.type !== \"string\" && nestedNode.type !== \"word\") {\n            return;\n          }\n\n          let newUrl = context.options.rewriteUrl(\n            context.global,\n            nestedNode.value\n          );\n\n          switch (nestedNode.type) {\n            case \"string\":\n              if (nestedNode.quote === \"'\") {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/'/g, \"\\\\'\");\n              }\n\n              if (nestedNode.quote === '\"') {\n                newUrl = newUrl.replace(/(\\\\)/g, \"\\\\$1\").replace(/\"/g, '\\\\\"');\n              }\n\n              break;\n            case \"word\":\n              newUrl = newUrl.replace(/(\"|'|\\)|\\\\)/g, \"\\\\$1\");\n              break;\n          }\n\n          nestedNode.value = newUrl;\n        });\n      }\n      break;\n  }\n  return node;\n}\n\nfunction isWordAFunctionArgument(wordNode, functionNode) {\n  return functionNode\n    ? functionNode.nodes.some(\n        (functionNodeChild) =>\n          functionNodeChild.sourceIndex === wordNode.sourceIndex\n      )\n    : false;\n}\n\nfunction localizeDeclarationValues(localize, declaration, context) {\n  const valueNodes = valueParser(declaration.value);\n\n  valueNodes.walk((node, index, nodes) => {\n    const subContext = {\n      options: context.options,\n      global: context.global,\n      localizeNextItem: localize && !context.global,\n      localAliasMap: context.localAliasMap,\n    };\n    nodes[index] = localizeDeclNode(node, subContext);\n  });\n\n  declaration.value = valueNodes.toString();\n}\n\nfunction localizeDeclaration(declaration, context) {\n  const isAnimation = /animation$/i.test(declaration.prop);\n\n  if (isAnimation) {\n    const validIdent = /^-?[_a-z][_a-z0-9-]*$/i;\n\n    /*\n    The spec defines some keywords that you can use to describe properties such as the timing\n    function. These are still valid animation names, so as long as there is a property that accepts\n    a keyword, it is given priority. Only when all the properties that can take a keyword are\n    exhausted can the animation name be set to the keyword. I.e.\n  \n    animation: infinite infinite;\n  \n    The animation will repeat an infinite number of times from the first argument, and will have an\n    animation name of infinite from the second.\n    */\n    const animationKeywords = {\n      $alternate: 1,\n      \"$alternate-reverse\": 1,\n      $backwards: 1,\n      $both: 1,\n      $ease: 1,\n      \"$ease-in\": 1,\n      \"$ease-in-out\": 1,\n      \"$ease-out\": 1,\n      $forwards: 1,\n      $infinite: 1,\n      $linear: 1,\n      $none: Infinity, // No matter how many times you write none, it will never be an animation name\n      $normal: 1,\n      $paused: 1,\n      $reverse: 1,\n      $running: 1,\n      \"$step-end\": 1,\n      \"$step-start\": 1,\n      $initial: Infinity,\n      $inherit: Infinity,\n      $unset: Infinity,\n    };\n\n    const didParseAnimationName = false;\n    let parsedAnimationKeywords = {};\n    let stepsFunctionNode = null;\n    const valueNodes = valueParser(declaration.value).walk((node) => {\n      /* If div-token appeared (represents as comma ','), a possibility of an animation-keywords should be reflesh. */\n      if (node.type === \"div\") {\n        parsedAnimationKeywords = {};\n      }\n      if (node.type === \"function\" && node.value.toLowerCase() === \"steps\") {\n        stepsFunctionNode = node;\n      }\n      const value =\n        node.type === \"word\" &&\n        !isWordAFunctionArgument(node, stepsFunctionNode)\n          ? node.value.toLowerCase()\n          : null;\n\n      let shouldParseAnimationName = false;\n\n      if (!didParseAnimationName && value && validIdent.test(value)) {\n        if (\"$\" + value in animationKeywords) {\n          parsedAnimationKeywords[\"$\" + value] =\n            \"$\" + value in parsedAnimationKeywords\n              ? parsedAnimationKeywords[\"$\" + value] + 1\n              : 0;\n\n          shouldParseAnimationName =\n            parsedAnimationKeywords[\"$\" + value] >=\n            animationKeywords[\"$\" + value];\n        } else {\n          shouldParseAnimationName = true;\n        }\n      }\n\n      const subContext = {\n        options: context.options,\n        global: context.global,\n        localizeNextItem: shouldParseAnimationName && !context.global,\n        localAliasMap: context.localAliasMap,\n      };\n      return localizeDeclNode(node, subContext);\n    });\n\n    declaration.value = valueNodes.toString();\n\n    return;\n  }\n\n  const isAnimationName = /animation(-name)?$/i.test(declaration.prop);\n\n  if (isAnimationName) {\n    return localizeDeclarationValues(true, declaration, context);\n  }\n\n  const hasUrl = /url\\(/i.test(declaration.value);\n\n  if (hasUrl) {\n    return localizeDeclarationValues(false, declaration, context);\n  }\n}\n\nmodule.exports = (options = {}) => {\n  if (\n    options &&\n    options.mode &&\n    options.mode !== \"global\" &&\n    options.mode !== \"local\" &&\n    options.mode !== \"pure\"\n  ) {\n    throw new Error(\n      'options.mode must be either \"global\", \"local\" or \"pure\" (default \"local\")'\n    );\n  }\n\n  const pureMode = options && options.mode === \"pure\";\n  const globalMode = options && options.mode === \"global\";\n\n  return {\n    postcssPlugin: \"postcss-modules-local-by-default\",\n    prepare() {\n      const localAliasMap = new Map();\n\n      return {\n        Once(root) {\n          const { icssImports } = extractICSS(root, false);\n\n          Object.keys(icssImports).forEach((key) => {\n            Object.keys(icssImports[key]).forEach((prop) => {\n              localAliasMap.set(prop, icssImports[key][prop]);\n            });\n          });\n\n          root.walkAtRules((atRule) => {\n            if (/keyframes$/i.test(atRule.name)) {\n              const globalMatch = /^\\s*:global\\s*\\((.+)\\)\\s*$/.exec(\n                atRule.params\n              );\n              const localMatch = /^\\s*:local\\s*\\((.+)\\)\\s*$/.exec(\n                atRule.params\n              );\n\n              let globalKeyframes = globalMode;\n\n              if (globalMatch) {\n                if (pureMode) {\n                  throw atRule.error(\n                    \"@keyframes :global(...) is not allowed in pure mode\"\n                  );\n                }\n                atRule.params = globalMatch[1];\n                globalKeyframes = true;\n              } else if (localMatch) {\n                atRule.params = localMatch[0];\n                globalKeyframes = false;\n              } else if (!globalMode) {\n                if (atRule.params && !localAliasMap.has(atRule.params)) {\n                  atRule.params = \":local(\" + atRule.params + \")\";\n                }\n              }\n\n              atRule.walkDecls((declaration) => {\n                localizeDeclaration(declaration, {\n                  localAliasMap,\n                  options: options,\n                  global: globalKeyframes,\n                });\n              });\n            } else if (atRule.nodes) {\n              atRule.nodes.forEach((declaration) => {\n                if (declaration.type === \"decl\") {\n                  localizeDeclaration(declaration, {\n                    localAliasMap,\n                    options: options,\n                    global: globalMode,\n                  });\n                }\n              });\n            }\n          });\n\n          root.walkRules((rule) => {\n            if (\n              rule.parent &&\n              rule.parent.type === \"atrule\" &&\n              /keyframes$/i.test(rule.parent.name)\n            ) {\n              // ignore keyframe rules\n              return;\n            }\n\n            const context = localizeNode(rule, options.mode, localAliasMap);\n\n            context.options = options;\n            context.localAliasMap = localAliasMap;\n\n            if (pureMode && context.hasPureGlobals) {\n              throw rule.error(\n                'Selector \"' +\n                  rule.selector +\n                  '\" is not pure ' +\n                  \"(pure selectors must contain at least one local class or id)\"\n              );\n            }\n\n            rule.selector = context.selector;\n\n            // Less-syntax mixins parse as rules with no nodes\n            if (rule.nodes) {\n              rule.nodes.forEach((declaration) =>\n                localizeDeclaration(declaration, context)\n              );\n            }\n          });\n        },\n      };\n    },\n  };\n};\nmodule.exports.postcss = true;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}