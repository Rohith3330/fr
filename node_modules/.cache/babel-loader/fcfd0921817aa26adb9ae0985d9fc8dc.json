{"ast":null,"code":"import * as _acorn from \"acorn\";\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n      FUNC_HANGING_STATEMENT = 2,\n      FUNC_NULLABLE_ID = 4;\nexport function importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  return class extends Parser {\n    constructor() {\n      super(...arguments);\n      this.assertToken = new TokenType(keyword);\n    }\n\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n\n      this.next();\n    }\n\n    readToken(code) {\n      let i = 0;\n\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      } // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n\n\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      } // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n\n\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n      // Parse node.source.\n\n      node.source = this.parseMaybeAssign();\n\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n\n      this._eat(tt.parenR);\n\n      return this.finishNode(node, \"ImportExpression\");\n    } // ported from acorn/src/statement.js pp.parseExport\n\n\n    parseExport(node, exports) {\n      this.next(); // export * from '...'\n\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n\n        this.expectContextual(\"from\");\n\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n\n        node.source = this.parseExprAtom();\n\n        if (this.type === this.assertToken) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n\n          if (isAsync) {\n            this.next();\n          }\n\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      } // export var|const|let|function|class ...\n\n\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n\n          node.source = this.parseExprAtom();\n\n          if (this.type === this.assertToken) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local); // check if export is defined\n\n            this.checkLocalExport(spec.local);\n          }\n\n          node.source = null;\n        }\n\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    parseImport(node) {\n      this.next(); // import '...'\n\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n\n      if (this.type === this.assertToken) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n\n      const attrs = this.parseAssertEntries();\n\n      this._eat(tt.braceR);\n\n      return attrs;\n    }\n\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n\n        const node = this.startNode(); // parse AssertionKey : IdentifierName, StringLiteral\n\n        let assertionKeyNode;\n\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n\n        this.next();\n        node.key = assertionKeyNode; // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n\n        attrNames.add(node.key.name);\n\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an assertion value\");\n        }\n\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n\n      return attrs;\n    }\n\n  };\n}","map":{"version":3,"names":["_acorn","leftCurlyBrace","charCodeAt","space","keyword","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","FUNC_NULLABLE_ID","importAssertions","Parser","acorn","tokTypes","tt","TokenType","constructor","assertToken","_codeAt","i","input","_eat","t","type","unexpected","next","readToken","code","length","pos","label","finishToken","parseDynamicImport","node","source","parseMaybeAssign","eat","comma","obj","parseObj","arguments","parenR","finishNode","parseExport","exports","star","options","ecmaVersion","eatContextual","exported","parseIdent","checkExport","name","lastTokStart","expectContextual","string","parseExprAtom","assertions","parseImportAssertions","semicolon","_default","isAsync","_function","isAsyncFunction","fNode","startNode","declaration","parseFunction","_class","cNode","parseClass","shouldParseExportStatement","parseStatement","checkVariableExport","declarations","id","start","specifiers","parseExportSpecifiers","list","spec","checkUnreserved","local","checkLocalExport","parseImport","parseImportSpecifiers","braceL","attrs","parseAssertEntries","braceR","attrNames","Set","assertionKeyNode","parseLiteral","value","key","has","raise","add","push"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/acorn-import-assertions/src/index.js"],"sourcesContent":["import * as _acorn from \"acorn\";\n\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\n\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4\n\nexport function importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const { tokTypes: tt, TokenType } = acorn;\n\n  return class extends Parser {\n    constructor(...args) {\n      super(...args);\n      this.assertToken = new TokenType(keyword);\n    }\n\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n      this.next();\n    }\n\n    readToken(code) {\n      let i = 0;\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      }\n\n      // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      }\n\n      // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n\n      // Parse node.source.\n      node.source = this.parseMaybeAssign();\n\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n      this._eat(tt.parenR);\n      return this.finishNode(node, \"ImportExpression\");\n    }\n\n    // ported from acorn/src/statement.js pp.parseExport\n    parseExport(node, exports) {\n      this.next();\n      // export * from '...'\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n        this.expectContextual(\"from\");\n        if (this.type !== tt.string) { this.unexpected(); }\n        node.source = this.parseExprAtom();\n\n        if (this.type === this.assertToken) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\")\n      }\n      if (this.eat(tt._default)) { // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n          if (isAsync) { this.next(); }\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n        return this.finishNode(node, \"ExportDefaultDeclaration\")\n      }\n      // export var|const|let|function|class ...\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n        if (node.declaration.type === \"VariableDeclaration\")\n          { this.checkVariableExport(exports, node.declaration.declarations); }\n        else\n          { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n        node.specifiers = [];\n        node.source = null;\n      } else { // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) { this.unexpected(); }\n          node.source = this.parseExprAtom();\n\n          if (this.type === this.assertToken) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n\n            this.checkUnreserved(spec.local);\n            // check if export is defined\n            this.checkLocalExport(spec.local);\n          }\n\n          node.source = null;\n        }\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportNamedDeclaration\")\n    }\n\n    parseImport(node) {\n      this.next();\n      // import '...'\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source =\n          this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n\n      if (this.type === this.assertToken) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n      const attrs = this.parseAssertEntries();\n      this._eat(tt.braceR);\n      return attrs;\n    }\n\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n\n        const node = this.startNode();\n\n        // parse AssertionKey : IdentifierName, StringLiteral\n        let assertionKeyNode;\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n        this.next();\n        node.key = assertionKeyNode;\n\n        // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n        attrNames.add(node.key.name);\n\n        if (this.type !== tt.string) {\n          this.raise(\n            this.pos,\n            \"Only string is supported as an assertion value\"\n          );\n        }\n\n        node.value = this.parseLiteral(this.value);\n\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n\n      return attrs;\n    }\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}