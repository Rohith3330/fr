{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertSimpleType = assertSimpleType;\nexports.makeStrongCache = makeStrongCache;\nexports.makeStrongCacheSync = makeStrongCacheSync;\nexports.makeWeakCache = makeWeakCache;\nexports.makeWeakCacheSync = makeWeakCacheSync;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nconst synchronize = gen => {\n  return _gensync()(gen).sync;\n};\n\nfunction* genTrue() {\n  return true;\n}\n\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(WeakMap, handler);\n}\n\nfunction makeWeakCacheSync(handler) {\n  return synchronize(makeWeakCache(handler));\n}\n\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(Map, handler);\n}\n\nfunction makeStrongCacheSync(handler) {\n  return synchronize(makeStrongCache(handler));\n}\n\nfunction makeCachedFunction(CallCache, handler) {\n  const callCacheSync = new CallCache();\n  const callCacheAsync = new CallCache();\n  const futureCache = new CallCache();\n  return function* cachedFunction(arg, data) {\n    const asyncContext = yield* (0, _async.isAsync)();\n    const callCache = asyncContext ? callCacheAsync : callCacheSync;\n    const cached = yield* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);\n    if (cached.valid) return cached.value;\n    const cache = new CacheConfigurator(data);\n    const handlerResult = handler(arg, cache);\n    let finishLock;\n    let value;\n\n    if ((0, _util.isIterableIterator)(handlerResult)) {\n      value = yield* (0, _async.onFirstPause)(handlerResult, () => {\n        finishLock = setupAsyncLocks(cache, futureCache, arg);\n      });\n    } else {\n      value = handlerResult;\n    }\n\n    updateFunctionCache(callCache, cache, arg, value);\n\n    if (finishLock) {\n      futureCache.delete(arg);\n      finishLock.release(value);\n    }\n\n    return value;\n  };\n}\n\nfunction* getCachedValue(cache, arg, data) {\n  const cachedValue = cache.get(arg);\n\n  if (cachedValue) {\n    for (const {\n      value,\n      valid\n    } of cachedValue) {\n      if (yield* valid(data)) return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {\n  const cached = yield* getCachedValue(callCache, arg, data);\n\n  if (cached.valid) {\n    return cached;\n  }\n\n  if (asyncContext) {\n    const cached = yield* getCachedValue(futureCache, arg, data);\n\n    if (cached.valid) {\n      const value = yield* (0, _async.waitFor)(cached.value.promise);\n      return {\n        valid: true,\n        value\n      };\n    }\n  }\n\n  return {\n    valid: false,\n    value: null\n  };\n}\n\nfunction setupAsyncLocks(config, futureCache, arg) {\n  const finishLock = new Lock();\n  updateFunctionCache(futureCache, config, arg, finishLock);\n  return finishLock;\n}\n\nfunction updateFunctionCache(cache, config, arg, value) {\n  if (!config.configured()) config.forever();\n  let cachedValue = cache.get(arg);\n  config.deactivate();\n\n  switch (config.mode()) {\n    case \"forever\":\n      cachedValue = [{\n        value,\n        valid: genTrue\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"invalidate\":\n      cachedValue = [{\n        value,\n        valid: config.validator()\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"valid\":\n      if (cachedValue) {\n        cachedValue.push({\n          value,\n          valid: config.validator()\n        });\n      } else {\n        cachedValue = [{\n          value,\n          valid: config.validator()\n        }];\n        cache.set(arg, cachedValue);\n      }\n\n  }\n}\n\nclass CacheConfigurator {\n  constructor(data) {\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = void 0;\n    this._data = data;\n  }\n\n  simple() {\n    return makeSimpleConfigurator(this);\n  }\n\n  mode() {\n    if (this._never) return \"never\";\n    if (this._forever) return \"forever\";\n    if (this._invalidate) return \"invalidate\";\n    return \"valid\";\n  }\n\n  forever() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never) {\n      throw new Error(\"Caching has already been configured with .never()\");\n    }\n\n    this._forever = true;\n    this._configured = true;\n  }\n\n  never() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._forever) {\n      throw new Error(\"Caching has already been configured with .forever()\");\n    }\n\n    this._never = true;\n    this._configured = true;\n  }\n\n  using(handler) {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n\n    if (this._never || this._forever) {\n      throw new Error(\"Caching has already been configured with .never or .forever()\");\n    }\n\n    this._configured = true;\n    const key = handler(this._data);\n    const fn = (0, _async.maybeAsync)(handler, `You appear to be using an async cache handler, but Babel has been called synchronously`);\n\n    if ((0, _async.isThenable)(key)) {\n      return key.then(key => {\n        this._pairs.push([key, fn]);\n\n        return key;\n      });\n    }\n\n    this._pairs.push([key, fn]);\n\n    return key;\n  }\n\n  invalidate(handler) {\n    this._invalidate = true;\n    return this.using(handler);\n  }\n\n  validator() {\n    const pairs = this._pairs;\n    return function* (data) {\n      for (const [key, fn] of pairs) {\n        if (key !== (yield* fn(data))) return false;\n      }\n\n      return true;\n    };\n  }\n\n  deactivate() {\n    this._active = false;\n  }\n\n  configured() {\n    return this._configured;\n  }\n\n}\n\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n\n    return cache.using(() => assertSimpleType(val()));\n  }\n\n  cacheFn.forever = () => cache.forever();\n\n  cacheFn.never = () => cache.never();\n\n  cacheFn.using = cb => cache.using(() => assertSimpleType(cb()));\n\n  cacheFn.invalidate = cb => cache.invalidate(() => assertSimpleType(cb()));\n\n  return cacheFn;\n}\n\nfunction assertSimpleType(value) {\n  if ((0, _async.isThenable)(value)) {\n    throw new Error(`You appear to be using an async cache handler, ` + `which your current version of Babel does not support. ` + `We may add support for this in the future, ` + `but if you're on the most recent version of @babel/core and still ` + `seeing this error, then you'll need to synchronously handle your caching logic.`);\n  }\n\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n\n  return value;\n}\n\nclass Lock {\n  constructor() {\n    this.released = false;\n    this.promise = void 0;\n    this._resolve = void 0;\n    this.promise = new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n  release(value) {\n    this.released = true;\n\n    this._resolve(value);\n  }\n\n}\n\n0 && 0;","map":{"version":3,"mappings":";;;;;;;;;;;AAAA;EAAA;;EAAAA;IAAA;EAAA;;EAAA;AAAA;;AAEA;;AAOA;;AAmBA,MAAMC,WAAW,GACfC,GADkB,IAEgB;EAClC,OAAOC,WAAQD,GAARC,EAAaC,IAApB;AAHF;;AAOA,UAAUC,OAAV,GAAoB;EAClB,OAAO,IAAP;AACD;;AAEM,SAASC,aAAT,CACLC,OADK,EAK+C;EACpD,OAAOC,kBAAkB,CAA6BC,OAA7B,EAAsCF,OAAtC,CAAzB;AACD;;AAEM,SAASG,iBAAT,CACLH,OADK,EAEuC;EAC5C,OAAON,WAAW,CAChBK,aAAa,CAA6BC,OAA7B,CADG,CAAlB;AAGD;;AAEM,SAASI,eAAT,CACLJ,OADK,EAK+C;EACpD,OAAOC,kBAAkB,CAA6BI,GAA7B,EAAkCL,OAAlC,CAAzB;AACD;;AAEM,SAASM,mBAAT,CACLN,OADK,EAEuC;EAC5C,OAAON,WAAW,CAChBU,eAAe,CAA6BJ,OAA7B,CADC,CAAlB;AAGD;;AA2BD,SAASC,kBAAT,CACEM,SADF,EAEEP,OAFF,EAMsD;EACpD,MAAMQ,aAAa,GAAG,IAAID,SAAJ,EAAtB;EACA,MAAME,cAAc,GAAG,IAAIF,SAAJ,EAAvB;EACA,MAAMG,WAAW,GAAG,IAAIH,SAAJ,EAApB;EAEA,OAAO,UAAUI,cAAV,CAAyBC,GAAzB,EAAoCC,IAApC,EAAuD;IAC5D,MAAMC,YAAY,GAAG,OAAO,qBAA5B;IACA,MAAMC,SAAS,GAAGD,YAAY,GAAGL,cAAH,GAAoBD,aAAlD;IAEA,MAAMQ,MAAM,GAAG,OAAOC,oBAAoB,CACxCH,YADwC,EAExCC,SAFwC,EAGxCL,WAHwC,EAIxCE,GAJwC,EAKxCC,IALwC,CAA1C;IAOA,IAAIG,MAAM,CAACE,KAAX,EAAkB,OAAOF,MAAM,CAACG,KAAd;IAElB,MAAMC,KAAK,GAAG,IAAIC,iBAAJ,CAAsBR,IAAtB,CAAd;IAEA,MAAMS,aAAyC,GAAGtB,OAAO,CAACY,GAAD,EAAMQ,KAAN,CAAzD;IAEA,IAAIG,UAAJ;IACA,IAAIJ,KAAJ;;IAEA,IAAI,8BAAmBG,aAAnB,CAAJ,EAAuC;MACrCH,KAAK,GAAG,OAAO,yBAAaG,aAAb,EAA4B,MAAM;QAC/CC,UAAU,GAAGC,eAAe,CAACJ,KAAD,EAAQV,WAAR,EAAqBE,GAArB,CAA5BW;MADa,EAAfJ;IADF,OAIO;MACLA,KAAK,GAAGG,aAARH;IACD;;IAEDM,mBAAmB,CAACV,SAAD,EAAYK,KAAZ,EAAmBR,GAAnB,EAAwBO,KAAxB,CAAnBM;;IAEA,IAAIF,UAAJ,EAAgB;MACdb,WAAW,CAACgB,MAAZhB,CAAmBE,GAAnBF;MACAa,UAAU,CAACI,OAAXJ,CAAmBJ,KAAnBI;IACD;;IAED,OAAOJ,KAAP;EAnCF;AAqCD;;AAOD,UAAUS,cAAV,CACER,KADF,EAEER,GAFF,EAGEC,IAHF,EAI4E;EAC1E,MAAMgB,WAAoD,GAAGT,KAAK,CAACU,GAANV,CAAUR,GAAVQ,CAA7D;;EAEA,IAAIS,WAAJ,EAAiB;IACf,KAAK,MAAM;MAAEV,KAAF;MAASD;IAAT,CAAX,IAA+BW,WAA/B,EAA4C;MAC1C,IAAI,OAAOX,KAAK,CAACL,IAAD,CAAhB,EAAwB,OAAO;QAAEK,KAAK,EAAE,IAAT;QAAeC;MAAf,CAAP;IACzB;EACF;;EAED,OAAO;IAAED,KAAK,EAAE,KAAT;IAAgBC,KAAK,EAAE;EAAvB,CAAP;AACD;;AAED,UAAUF,oBAAV,CACEH,YADF,EAEEC,SAFF,EAGEL,WAHF,EAIEE,GAJF,EAKEC,IALF,EAM4E;EAC1E,MAAMG,MAAM,GAAG,OAAOY,cAAc,CAACb,SAAD,EAAYH,GAAZ,EAAiBC,IAAjB,CAApC;;EACA,IAAIG,MAAM,CAACE,KAAX,EAAkB;IAChB,OAAOF,MAAP;EACD;;EAED,IAAIF,YAAJ,EAAkB;IAChB,MAAME,MAAM,GAAG,OAAOY,cAAc,CAAClB,WAAD,EAAcE,GAAd,EAAmBC,IAAnB,CAApC;;IACA,IAAIG,MAAM,CAACE,KAAX,EAAkB;MAChB,MAAMC,KAAK,GAAG,OAAO,oBAAiBH,MAAM,CAACG,KAAPH,CAAae,OAA9B,CAArB;MACA,OAAO;QAAEb,KAAK,EAAE,IAAT;QAAeC;MAAf,CAAP;IACD;EACF;;EAED,OAAO;IAAED,KAAK,EAAE,KAAT;IAAgBC,KAAK,EAAE;EAAvB,CAAP;AACD;;AAED,SAASK,eAAT,CACEQ,MADF,EAEEtB,WAFF,EAGEE,GAHF,EAIiB;EACf,MAAMW,UAAU,GAAG,IAAIU,IAAJ,EAAnB;EAEAR,mBAAmB,CAACf,WAAD,EAAcsB,MAAd,EAAsBpB,GAAtB,EAA2BW,UAA3B,CAAnBE;EAEA,OAAOF,UAAP;AACD;;AAED,SAASE,mBAAT,CAMEL,KANF,EAOEY,MAPF,EAQEpB,GARF,EASEO,KATF,EAUE;EACA,IAAI,CAACa,MAAM,CAACE,UAAPF,EAAL,EAA0BA,MAAM,CAACG,OAAPH;EAE1B,IAAIH,WAAoD,GAAGT,KAAK,CAACU,GAANV,CAAUR,GAAVQ,CAA3D;EAEAY,MAAM,CAACI,UAAPJ;;EAEA,QAAQA,MAAM,CAACK,IAAPL,EAAR;IACE,KAAK,SAAL;MACEH,WAAW,GAAG,CAAC;QAAEV,KAAF;QAASD,KAAK,EAAEpB;MAAhB,CAAD,CAAd+B;MACAT,KAAK,CAACkB,GAANlB,CAAUR,GAAVQ,EAAeS,WAAfT;MACA;;IACF,KAAK,YAAL;MACES,WAAW,GAAG,CAAC;QAAEV,KAAF;QAASD,KAAK,EAAEc,MAAM,CAACO,SAAPP;MAAhB,CAAD,CAAdH;MACAT,KAAK,CAACkB,GAANlB,CAAUR,GAAVQ,EAAeS,WAAfT;MACA;;IACF,KAAK,OAAL;MACE,IAAIS,WAAJ,EAAiB;QACfA,WAAW,CAACW,IAAZX,CAAiB;UAAEV,KAAF;UAASD,KAAK,EAAEc,MAAM,CAACO,SAAPP;QAAhB,CAAjBH;MADF,OAEO;QACLA,WAAW,GAAG,CAAC;UAAEV,KAAF;UAASD,KAAK,EAAEc,MAAM,CAACO,SAAPP;QAAhB,CAAD,CAAdH;QACAT,KAAK,CAACkB,GAANlB,CAAUR,GAAVQ,EAAeS,WAAfT;MACD;;EAfL;AAiBD;;AAED,MAAMC,iBAAN,CAA4C;EAc1CoB,WAAW,CAAC5B,IAAD,EAAoB;IAAA,KAb/B6B,OAa+B,GAbZ,IAaY;IAAA,KAZ/BC,MAY+B,GAZb,KAYa;IAAA,KAX/BC,QAW+B,GAXX,KAWW;IAAA,KAV/BC,WAU+B,GAVR,KAUQ;IAAA,KAR/BC,WAQ+B,GARR,KAQQ;IAAA,KAN/BC,MAM+B,GAJ3B,EAI2B;IAAA,KAF/BC,KAE+B;IAC7B,KAAKA,KAAL,GAAanC,IAAb;EACD;;EAEDoC,MAAM,GAAG;IACP,OAAOC,sBAAsB,CAAC,IAAD,CAA7B;EACD;;EAEDb,IAAI,GAAG;IACL,IAAI,KAAKM,MAAT,EAAiB,OAAO,OAAP;IACjB,IAAI,KAAKC,QAAT,EAAmB,OAAO,SAAP;IACnB,IAAI,KAAKC,WAAT,EAAsB,OAAO,YAAP;IACtB,OAAO,OAAP;EACD;;EAEDV,OAAO,GAAG;IACR,IAAI,CAAC,KAAKO,OAAV,EAAmB;MACjB,MAAM,IAAIS,KAAJ,CAAU,uDAAV,CAAN;IACD;;IACD,IAAI,KAAKR,MAAT,EAAiB;MACf,MAAM,IAAIQ,KAAJ,CAAU,mDAAV,CAAN;IACD;;IACD,KAAKP,QAAL,GAAgB,IAAhB;IACA,KAAKE,WAAL,GAAmB,IAAnB;EACD;;EAEDM,KAAK,GAAG;IACN,IAAI,CAAC,KAAKV,OAAV,EAAmB;MACjB,MAAM,IAAIS,KAAJ,CAAU,uDAAV,CAAN;IACD;;IACD,IAAI,KAAKP,QAAT,EAAmB;MACjB,MAAM,IAAIO,KAAJ,CAAU,qDAAV,CAAN;IACD;;IACD,KAAKR,MAAL,GAAc,IAAd;IACA,KAAKG,WAAL,GAAmB,IAAnB;EACD;;EAEDO,KAAK,CAAIrD,OAAJ,EAA0C;IAC7C,IAAI,CAAC,KAAK0C,OAAV,EAAmB;MACjB,MAAM,IAAIS,KAAJ,CAAU,uDAAV,CAAN;IACD;;IACD,IAAI,KAAKR,MAAL,IAAe,KAAKC,QAAxB,EAAkC;MAChC,MAAM,IAAIO,KAAJ,CACJ,+DADI,CAAN;IAGD;;IACD,KAAKL,WAAL,GAAmB,IAAnB;IAEA,MAAMQ,GAAG,GAAGtD,OAAO,CAAC,KAAKgD,KAAN,CAAnB;IAEA,MAAMO,EAAE,GAAG,uBACTvD,OADS,EAER,wFAFQ,CAAX;;IAKA,IAAI,uBAAWsD,GAAX,CAAJ,EAAqB;MAEnB,OAAOA,GAAG,CAACE,IAAJF,CAAUA,GAAD,IAAkB;QAChC,KAAKP,MAAL,CAAYP,IAAZ,CAAiB,CAACc,GAAD,EAAMC,EAAN,CAAjB;;QACA,OAAOD,GAAP;MAFK,EAAP;IAID;;IAED,KAAKP,MAAL,CAAYP,IAAZ,CAAiB,CAACc,GAAD,EAAMC,EAAN,CAAjB;;IACA,OAAOD,GAAP;EACD;;EAEDG,UAAU,CAAIzD,OAAJ,EAA0C;IAClD,KAAK6C,WAAL,GAAmB,IAAnB;IACA,OAAO,KAAKQ,KAAL,CAAWrD,OAAX,CAAP;EACD;;EAEDuC,SAAS,GAA4C;IACnD,MAAMmB,KAAK,GAAG,KAAKX,MAAnB;IACA,OAAO,WAAWlC,IAAX,EAA8B;MACnC,KAAK,MAAM,CAACyC,GAAD,EAAMC,EAAN,CAAX,IAAwBG,KAAxB,EAA+B;QAC7B,IAAIJ,GAAG,MAAM,OAAOC,EAAE,CAAC1C,IAAD,CAAf,CAAP,EAA+B,OAAO,KAAP;MAChC;;MACD,OAAO,IAAP;IAJF;EAMD;;EAEDuB,UAAU,GAAG;IACX,KAAKM,OAAL,GAAe,KAAf;EACD;;EAEDR,UAAU,GAAG;IACX,OAAO,KAAKY,WAAZ;EACD;;AAtGyC;;AAyG5C,SAASI,sBAAT,CACE9B,KADF,EAE2B;EACzB,SAASuC,OAAT,CAAiBC,GAAjB,EAA2B;IACzB,IAAI,OAAOA,GAAP,KAAe,SAAnB,EAA8B;MAC5B,IAAIA,GAAJ,EAASxC,KAAK,CAACe,OAANf,GAAT,KACKA,KAAK,CAACgC,KAANhC;MACL;IACD;;IAED,OAAOA,KAAK,CAACiC,KAANjC,CAAY,MAAMyC,gBAAgB,CAACD,GAAG,EAAJ,CAAlCxC,CAAP;EACD;;EACDuC,OAAO,CAACxB,OAARwB,GAAkB,MAAMvC,KAAK,CAACe,OAANf,EAAxBuC;;EACAA,OAAO,CAACP,KAARO,GAAgB,MAAMvC,KAAK,CAACgC,KAANhC,EAAtBuC;;EACAA,OAAO,CAACN,KAARM,GAAiBG,EAAD,IACd1C,KAAK,CAACiC,KAANjC,CAAY,MAAMyC,gBAAgB,CAACC,EAAE,EAAH,CAAlC1C,CADFuC;;EAEAA,OAAO,CAACF,UAARE,GAAsBG,EAAD,IACnB1C,KAAK,CAACqC,UAANrC,CAAiB,MAAMyC,gBAAgB,CAACC,EAAE,EAAH,CAAvC1C,CADFuC;;EAGA,OAAOA,OAAP;AACD;;AAWM,SAASE,gBAAT,CAA0B1C,KAA1B,EAAsD;EAC3D,IAAI,uBAAWA,KAAX,CAAJ,EAAuB;IACrB,MAAM,IAAIgC,KAAJ,CACH,oDACE,wDADF,GAEE,6CAFF,GAGE,oEAHF,GAIE,iFALC,CAAN;EAOD;;EAED,IACEhC,KAAK,IAAI,IAATA,IACA,OAAOA,KAAP,KAAiB,QADjBA,IAEA,OAAOA,KAAP,KAAiB,SAFjBA,IAGA,OAAOA,KAAP,KAAiB,QAJnB,EAKE;IACA,MAAM,IAAIgC,KAAJ,CACJ,wEADI,CAAN;EAGD;;EAGD,OAAOhC,KAAP;AACD;;AAED,MAAMc,IAAN,CAAc;EAKZQ,WAAW,GAAG;IAAA,KAJdsB,QAIc,GAJM,KAIN;IAAA,KAHdhC,OAGc;IAAA,KAFdiC,QAEc;IACZ,KAAKjC,OAAL,GAAe,IAAIkC,OAAJ,CAAYC,OAAO,IAAI;MACpC,KAAKF,QAAL,GAAgBE,OAAhB;IADa,EAAf;EAGD;;EAEDvC,OAAO,CAACR,KAAD,EAAW;IAChB,KAAK4C,QAAL,GAAgB,IAAhB;;IACA,KAAKC,QAAL,CAAc7C,KAAd;EACD;;AAdW","names":["_gensync","synchronize","gen","gensync","sync","genTrue","makeWeakCache","handler","makeCachedFunction","WeakMap","makeWeakCacheSync","makeStrongCache","Map","makeStrongCacheSync","CallCache","callCacheSync","callCacheAsync","futureCache","cachedFunction","arg","data","asyncContext","callCache","cached","getCachedValueOrWait","valid","value","cache","CacheConfigurator","handlerResult","finishLock","setupAsyncLocks","updateFunctionCache","delete","release","getCachedValue","cachedValue","get","promise","config","Lock","configured","forever","deactivate","mode","set","validator","push","constructor","_active","_never","_forever","_invalidate","_configured","_pairs","_data","simple","makeSimpleConfigurator","Error","never","using","key","fn","then","invalidate","pairs","cacheFn","val","assertSimpleType","cb","released","_resolve","Promise","resolve"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\caching.ts"],"sourcesContent":["import gensync from \"gensync\";\nimport type { Handler } from \"gensync\";\nimport {\n  maybeAsync,\n  isAsync,\n  onFirstPause,\n  waitFor,\n  isThenable,\n} from \"../gensync-utils/async\";\nimport { isIterableIterator } from \"./util\";\n\nexport type { CacheConfigurator };\n\nexport type SimpleCacheConfigurator = {\n  (forever: boolean): void;\n  <T>(handler: () => T): T;\n\n  forever: () => void;\n  never: () => void;\n  using: <T>(handler: () => T) => T;\n  invalidate: <T>(handler: () => T) => T;\n};\n\nexport type CacheEntry<ResultT, SideChannel> = Array<{\n  value: ResultT;\n  valid: (channel: SideChannel) => Handler<boolean>;\n}>;\n\nconst synchronize = <ArgsT extends unknown[], ResultT>(\n  gen: (...args: ArgsT) => Handler<ResultT>,\n): ((...args: ArgsT) => ResultT) => {\n  return gensync(gen).sync;\n};\n\n// eslint-disable-next-line require-yield\nfunction* genTrue() {\n  return true;\n}\n\nexport function makeWeakCache<ArgT extends object, ResultT, SideChannel>(\n  handler: (\n    arg: ArgT,\n    cache: CacheConfigurator<SideChannel>,\n  ) => Handler<ResultT> | ResultT,\n): (arg: ArgT, data: SideChannel) => Handler<ResultT> {\n  return makeCachedFunction<ArgT, ResultT, SideChannel>(WeakMap, handler);\n}\n\nexport function makeWeakCacheSync<ArgT extends object, ResultT, SideChannel>(\n  handler: (arg: ArgT, cache?: CacheConfigurator<SideChannel>) => ResultT,\n): (arg: ArgT, data?: SideChannel) => ResultT {\n  return synchronize<[ArgT, SideChannel], ResultT>(\n    makeWeakCache<ArgT, ResultT, SideChannel>(handler),\n  );\n}\n\nexport function makeStrongCache<ArgT, ResultT, SideChannel>(\n  handler: (\n    arg: ArgT,\n    cache: CacheConfigurator<SideChannel>,\n  ) => Handler<ResultT> | ResultT,\n): (arg: ArgT, data: SideChannel) => Handler<ResultT> {\n  return makeCachedFunction<ArgT, ResultT, SideChannel>(Map, handler);\n}\n\nexport function makeStrongCacheSync<ArgT, ResultT, SideChannel>(\n  handler: (arg: ArgT, cache?: CacheConfigurator<SideChannel>) => ResultT,\n): (arg: ArgT, data?: SideChannel) => ResultT {\n  return synchronize<[ArgT, SideChannel], ResultT>(\n    makeStrongCache<ArgT, ResultT, SideChannel>(handler),\n  );\n}\n\n/* NOTE: Part of the logic explained in this comment is explained in the\n *       getCachedValueOrWait and setupAsyncLocks functions.\n *\n * > There are only two hard things in Computer Science: cache invalidation and naming things.\n * > -- Phil Karlton\n *\n * I don't know if Phil was also thinking about handling a cache whose invalidation function is\n * defined asynchronously is considered, but it is REALLY hard to do correctly.\n *\n * The implemented logic (only when gensync is run asynchronously) is the following:\n *   1. If there is a valid cache associated to the current \"arg\" parameter,\n *       a. RETURN the cached value\n *   3. If there is a FinishLock associated to the current \"arg\" parameter representing a valid cache,\n *       a. Wait for that lock to be released\n *       b. RETURN the value associated with that lock\n *   5. Start executing the function to be cached\n *       a. If it pauses on a promise, then\n *           i. Let FinishLock be a new lock\n *          ii. Store FinishLock as associated to the current \"arg\" parameter\n *         iii. Wait for the function to finish executing\n *          iv. Release FinishLock\n *           v. Send the function result to anyone waiting on FinishLock\n *   6. Store the result in the cache\n *   7. RETURN the result\n */\nfunction makeCachedFunction<ArgT, ResultT, SideChannel>(\n  CallCache: new <Cached>() => CacheMap<ArgT, Cached, SideChannel>,\n  handler: (\n    arg: ArgT,\n    cache: CacheConfigurator<SideChannel>,\n  ) => Handler<ResultT> | ResultT,\n): (arg: ArgT, data: SideChannel) => Handler<ResultT> {\n  const callCacheSync = new CallCache<ResultT>();\n  const callCacheAsync = new CallCache<ResultT>();\n  const futureCache = new CallCache<Lock<ResultT>>();\n\n  return function* cachedFunction(arg: ArgT, data: SideChannel) {\n    const asyncContext = yield* isAsync();\n    const callCache = asyncContext ? callCacheAsync : callCacheSync;\n\n    const cached = yield* getCachedValueOrWait<ArgT, ResultT, SideChannel>(\n      asyncContext,\n      callCache,\n      futureCache,\n      arg,\n      data,\n    );\n    if (cached.valid) return cached.value;\n\n    const cache = new CacheConfigurator(data);\n\n    const handlerResult: Handler<ResultT> | ResultT = handler(arg, cache);\n\n    let finishLock: Lock<ResultT>;\n    let value: ResultT;\n\n    if (isIterableIterator(handlerResult)) {\n      value = yield* onFirstPause(handlerResult, () => {\n        finishLock = setupAsyncLocks(cache, futureCache, arg);\n      });\n    } else {\n      value = handlerResult;\n    }\n\n    updateFunctionCache(callCache, cache, arg, value);\n\n    if (finishLock) {\n      futureCache.delete(arg);\n      finishLock.release(value);\n    }\n\n    return value;\n  };\n}\n\ntype CacheMap<ArgT, ResultT, SideChannel> =\n  | Map<ArgT, CacheEntry<ResultT, SideChannel>>\n  // @ts-expect-error todo(flow->ts): add `extends object` constraint to ArgT\n  | WeakMap<ArgT, CacheEntry<ResultT, SideChannel>>;\n\nfunction* getCachedValue<ArgT, ResultT, SideChannel>(\n  cache: CacheMap<ArgT, ResultT, SideChannel>,\n  arg: ArgT,\n  data: SideChannel,\n): Handler<{ valid: true; value: ResultT } | { valid: false; value: null }> {\n  const cachedValue: CacheEntry<ResultT, SideChannel> | void = cache.get(arg);\n\n  if (cachedValue) {\n    for (const { value, valid } of cachedValue) {\n      if (yield* valid(data)) return { valid: true, value };\n    }\n  }\n\n  return { valid: false, value: null };\n}\n\nfunction* getCachedValueOrWait<ArgT, ResultT, SideChannel>(\n  asyncContext: boolean,\n  callCache: CacheMap<ArgT, ResultT, SideChannel>,\n  futureCache: CacheMap<ArgT, Lock<ResultT>, SideChannel>,\n  arg: ArgT,\n  data: SideChannel,\n): Handler<{ valid: true; value: ResultT } | { valid: false; value: null }> {\n  const cached = yield* getCachedValue(callCache, arg, data);\n  if (cached.valid) {\n    return cached;\n  }\n\n  if (asyncContext) {\n    const cached = yield* getCachedValue(futureCache, arg, data);\n    if (cached.valid) {\n      const value = yield* waitFor<ResultT>(cached.value.promise);\n      return { valid: true, value };\n    }\n  }\n\n  return { valid: false, value: null };\n}\n\nfunction setupAsyncLocks<ArgT, ResultT, SideChannel>(\n  config: CacheConfigurator<SideChannel>,\n  futureCache: CacheMap<ArgT, Lock<ResultT>, SideChannel>,\n  arg: ArgT,\n): Lock<ResultT> {\n  const finishLock = new Lock<ResultT>();\n\n  updateFunctionCache(futureCache, config, arg, finishLock);\n\n  return finishLock;\n}\n\nfunction updateFunctionCache<\n  ArgT,\n  ResultT,\n  SideChannel,\n  Cache extends CacheMap<ArgT, ResultT, SideChannel>,\n>(\n  cache: Cache,\n  config: CacheConfigurator<SideChannel>,\n  arg: ArgT,\n  value: ResultT,\n) {\n  if (!config.configured()) config.forever();\n\n  let cachedValue: CacheEntry<ResultT, SideChannel> | void = cache.get(arg);\n\n  config.deactivate();\n\n  switch (config.mode()) {\n    case \"forever\":\n      cachedValue = [{ value, valid: genTrue }];\n      cache.set(arg, cachedValue);\n      break;\n    case \"invalidate\":\n      cachedValue = [{ value, valid: config.validator() }];\n      cache.set(arg, cachedValue);\n      break;\n    case \"valid\":\n      if (cachedValue) {\n        cachedValue.push({ value, valid: config.validator() });\n      } else {\n        cachedValue = [{ value, valid: config.validator() }];\n        cache.set(arg, cachedValue);\n      }\n  }\n}\n\nclass CacheConfigurator<SideChannel = void> {\n  _active: boolean = true;\n  _never: boolean = false;\n  _forever: boolean = false;\n  _invalidate: boolean = false;\n\n  _configured: boolean = false;\n\n  _pairs: Array<\n    [cachedValue: unknown, handler: (data: SideChannel) => Handler<unknown>]\n  > = [];\n\n  _data: SideChannel;\n\n  constructor(data: SideChannel) {\n    this._data = data;\n  }\n\n  simple() {\n    return makeSimpleConfigurator(this);\n  }\n\n  mode() {\n    if (this._never) return \"never\";\n    if (this._forever) return \"forever\";\n    if (this._invalidate) return \"invalidate\";\n    return \"valid\";\n  }\n\n  forever() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n    if (this._never) {\n      throw new Error(\"Caching has already been configured with .never()\");\n    }\n    this._forever = true;\n    this._configured = true;\n  }\n\n  never() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n    if (this._forever) {\n      throw new Error(\"Caching has already been configured with .forever()\");\n    }\n    this._never = true;\n    this._configured = true;\n  }\n\n  using<T>(handler: (data: SideChannel) => T): T {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n    if (this._never || this._forever) {\n      throw new Error(\n        \"Caching has already been configured with .never or .forever()\",\n      );\n    }\n    this._configured = true;\n\n    const key = handler(this._data);\n\n    const fn = maybeAsync(\n      handler,\n      `You appear to be using an async cache handler, but Babel has been called synchronously`,\n    );\n\n    if (isThenable(key)) {\n      // @ts-expect-error todo(flow->ts): improve function return type annotation\n      return key.then((key: unknown) => {\n        this._pairs.push([key, fn]);\n        return key;\n      });\n    }\n\n    this._pairs.push([key, fn]);\n    return key;\n  }\n\n  invalidate<T>(handler: (data: SideChannel) => T): T {\n    this._invalidate = true;\n    return this.using(handler);\n  }\n\n  validator(): (data: SideChannel) => Handler<boolean> {\n    const pairs = this._pairs;\n    return function* (data: SideChannel) {\n      for (const [key, fn] of pairs) {\n        if (key !== (yield* fn(data))) return false;\n      }\n      return true;\n    };\n  }\n\n  deactivate() {\n    this._active = false;\n  }\n\n  configured() {\n    return this._configured;\n  }\n}\n\nfunction makeSimpleConfigurator(\n  cache: CacheConfigurator<any>,\n): SimpleCacheConfigurator {\n  function cacheFn(val: any) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();\n      else cache.never();\n      return;\n    }\n\n    return cache.using(() => assertSimpleType(val()));\n  }\n  cacheFn.forever = () => cache.forever();\n  cacheFn.never = () => cache.never();\n  cacheFn.using = (cb: { (): SimpleType }) =>\n    cache.using(() => assertSimpleType(cb()));\n  cacheFn.invalidate = (cb: { (): SimpleType }) =>\n    cache.invalidate(() => assertSimpleType(cb()));\n\n  return cacheFn as any;\n}\n\n// Types are limited here so that in the future these values can be used\n// as part of Babel's caching logic.\nexport type SimpleType =\n  | string\n  | boolean\n  | number\n  | null\n  | void\n  | Promise<SimpleType>;\nexport function assertSimpleType(value: unknown): SimpleType {\n  if (isThenable(value)) {\n    throw new Error(\n      `You appear to be using an async cache handler, ` +\n        `which your current version of Babel does not support. ` +\n        `We may add support for this in the future, ` +\n        `but if you're on the most recent version of @babel/core and still ` +\n        `seeing this error, then you'll need to synchronously handle your caching logic.`,\n    );\n  }\n\n  if (\n    value != null &&\n    typeof value !== \"string\" &&\n    typeof value !== \"boolean\" &&\n    typeof value !== \"number\"\n  ) {\n    throw new Error(\n      \"Cache keys must be either string, boolean, number, null, or undefined.\",\n    );\n  }\n  // @ts-expect-error Type 'unknown' is not assignable to type 'SimpleType'. This can be removed\n  // when strictNullCheck is enabled\n  return value;\n}\n\nclass Lock<T> {\n  released: boolean = false;\n  promise: Promise<T>;\n  _resolve: (value: T) => void;\n\n  constructor() {\n    this.promise = new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n  release(value: T) {\n    this.released = true;\n    this._resolve(value);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}