{"ast":null,"code":"import dlv from 'dlv';\nimport didYouMean from 'didyoumean';\nimport transformThemeValue from '../util/transformThemeValue';\nimport parseValue from 'postcss-value-parser';\nimport { normalizeScreens } from '../util/normalizeScreens';\nimport buildMediaQuery from '../util/buildMediaQuery';\nimport { toPath } from '../util/toPath';\nimport { withAlphaValue } from '../util/withAlphaVariable';\nimport { parseColorFormat } from '../util/pluginUtils';\n\nfunction isObject(input) {\n  return typeof input === 'object' && input !== null;\n}\n\nfunction findClosestExistingPath(theme, path) {\n  let parts = toPath(path);\n\n  do {\n    parts.pop();\n    if (dlv(theme, parts) !== undefined) break;\n  } while (parts.length);\n\n  return parts.length ? parts : undefined;\n}\n\nfunction pathToString(path) {\n  if (typeof path === 'string') return path;\n  return path.reduce((acc, cur, i) => {\n    if (cur.includes('.')) return `${acc}[${cur}]`;\n    return i === 0 ? cur : `${acc}.${cur}`;\n  }, '');\n}\n\nfunction list(items) {\n  return items.map(key => `'${key}'`).join(', ');\n}\n\nfunction listKeys(obj) {\n  return list(Object.keys(obj));\n}\n\nfunction validatePath(config, path, defaultValue) {\n  let themeOpts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const pathString = Array.isArray(path) ? pathToString(path) : path.replace(/^['\"]+|['\"]+$/g, '');\n  const pathSegments = Array.isArray(path) ? path : toPath(pathString);\n  const value = dlv(config.theme, pathSegments, defaultValue);\n\n  if (value === undefined) {\n    let error = `'${pathString}' does not exist in your theme config.`;\n    const parentSegments = pathSegments.slice(0, -1);\n    const parentValue = dlv(config.theme, parentSegments);\n\n    if (isObject(parentValue)) {\n      const validKeys = Object.keys(parentValue).filter(key => validatePath(config, [...parentSegments, key]).isValid);\n      const suggestion = didYouMean(pathSegments[pathSegments.length - 1], validKeys);\n\n      if (suggestion) {\n        error += ` Did you mean '${pathToString([...parentSegments, suggestion])}'?`;\n      } else if (validKeys.length > 0) {\n        error += ` '${pathToString(parentSegments)}' has the following valid keys: ${list(validKeys)}`;\n      }\n    } else {\n      const closestPath = findClosestExistingPath(config.theme, pathString);\n\n      if (closestPath) {\n        const closestValue = dlv(config.theme, closestPath);\n\n        if (isObject(closestValue)) {\n          error += ` '${pathToString(closestPath)}' has the following keys: ${listKeys(closestValue)}`;\n        } else {\n          error += ` '${pathToString(closestPath)}' is not an object.`;\n        }\n      } else {\n        error += ` Your theme has the following top-level keys: ${listKeys(config.theme)}`;\n      }\n    }\n\n    return {\n      isValid: false,\n      error\n    };\n  }\n\n  if (!(typeof value === 'string' || typeof value === 'number' || typeof value === 'function' || value instanceof String || value instanceof Number || Array.isArray(value))) {\n    let error = `'${pathString}' was found but does not resolve to a string.`;\n\n    if (isObject(value)) {\n      let validKeys = Object.keys(value).filter(key => validatePath(config, [...pathSegments, key]).isValid);\n\n      if (validKeys.length) {\n        error += ` Did you mean something like '${pathToString([...pathSegments, validKeys[0]])}'?`;\n      }\n    }\n\n    return {\n      isValid: false,\n      error\n    };\n  }\n\n  const [themeSection] = pathSegments;\n  return {\n    isValid: true,\n    value: transformThemeValue(themeSection)(value, themeOpts)\n  };\n}\n\nfunction extractArgs(node, vNodes, functions) {\n  vNodes = vNodes.map(vNode => resolveVNode(node, vNode, functions));\n  let args = [''];\n\n  for (let vNode of vNodes) {\n    if (vNode.type === 'div' && vNode.value === ',') {\n      args.push('');\n    } else {\n      args[args.length - 1] += parseValue.stringify(vNode);\n    }\n  }\n\n  return args;\n}\n\nfunction resolveVNode(node, vNode, functions) {\n  if (vNode.type === 'function' && functions[vNode.value] !== undefined) {\n    let args = extractArgs(node, vNode.nodes, functions);\n    vNode.type = 'word';\n    vNode.value = functions[vNode.value](node, ...args);\n  }\n\n  return vNode;\n}\n\nfunction resolveFunctions(node, input, functions) {\n  return parseValue(input).walk(vNode => {\n    resolveVNode(node, vNode, functions);\n  }).toString();\n}\n\nlet nodeTypePropertyMap = {\n  atrule: 'params',\n  decl: 'value'\n};\n/**\n * @param {string} path\n * @returns {Iterable<[path: string, alpha: string|undefined]>}\n */\n\nfunction* toPaths(path) {\n  // Strip quotes from beginning and end of string\n  // This allows the alpha value to be present inside of quotes\n  path = path.replace(/^['\"]+|['\"]+$/g, '');\n  let matches = path.match(/^([^\\s]+)(?![^\\[]*\\])(?:\\s*\\/\\s*([^\\/\\s]+))$/);\n  let alpha = undefined;\n  yield [path, undefined];\n\n  if (matches) {\n    path = matches[1];\n    alpha = matches[2];\n    yield [path, alpha];\n  }\n}\n/**\n *\n * @param {any} config\n * @param {string} path\n * @param {any} defaultValue\n */\n\n\nfunction resolvePath(config, path, defaultValue) {\n  const results = Array.from(toPaths(path)).map(_ref => {\n    let [path, alpha] = _ref;\n    return Object.assign(validatePath(config, path, defaultValue, {\n      opacityValue: alpha\n    }), {\n      resolvedPath: path,\n      alpha\n    });\n  });\n  return results.find(result => result.isValid) ?? results[0];\n}\n\nexport default function (_ref2) {\n  let {\n    tailwindConfig: config\n  } = _ref2;\n  let functions = {\n    theme: function (node, path) {\n      for (var _len = arguments.length, defaultValue = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        defaultValue[_key - 2] = arguments[_key];\n      }\n\n      let {\n        isValid,\n        value,\n        error,\n        alpha\n      } = resolvePath(config, path, defaultValue.length ? defaultValue : undefined);\n\n      if (!isValid) {\n        throw node.error(error);\n      }\n\n      let maybeColor = parseColorFormat(value);\n      let isColorFunction = maybeColor !== undefined && typeof maybeColor === 'function';\n\n      if (alpha !== undefined || isColorFunction) {\n        if (alpha === undefined) {\n          alpha = 1.0;\n        }\n\n        value = withAlphaValue(maybeColor, alpha, maybeColor);\n      }\n\n      return value;\n    },\n    screen: (node, screen) => {\n      screen = screen.replace(/^['\"]+/g, '').replace(/['\"]+$/g, '');\n      let screens = normalizeScreens(config.theme.screens);\n      let screenDefinition = screens.find(_ref3 => {\n        let {\n          name\n        } = _ref3;\n        return name === screen;\n      });\n\n      if (!screenDefinition) {\n        throw node.error(`The '${screen}' screen does not exist in your theme.`);\n      }\n\n      return buildMediaQuery(screenDefinition);\n    }\n  };\n  return root => {\n    root.walk(node => {\n      let property = nodeTypePropertyMap[node.type];\n\n      if (property === undefined) {\n        return;\n      }\n\n      node[property] = resolveFunctions(node, node[property], functions);\n    });\n  };\n}","map":{"version":3,"names":["dlv","didYouMean","transformThemeValue","parseValue","normalizeScreens","buildMediaQuery","toPath","withAlphaValue","parseColorFormat","isObject","input","findClosestExistingPath","theme","path","parts","pop","undefined","length","pathToString","reduce","acc","cur","i","includes","list","items","map","key","join","listKeys","obj","Object","keys","validatePath","config","defaultValue","themeOpts","pathString","Array","isArray","replace","pathSegments","value","error","parentSegments","slice","parentValue","validKeys","filter","isValid","suggestion","closestPath","closestValue","String","Number","themeSection","extractArgs","node","vNodes","functions","vNode","resolveVNode","args","type","push","stringify","nodes","resolveFunctions","walk","toString","nodeTypePropertyMap","atrule","decl","toPaths","matches","match","alpha","resolvePath","results","from","assign","opacityValue","resolvedPath","find","result","tailwindConfig","maybeColor","isColorFunction","screen","screens","screenDefinition","name","root","property"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/src/lib/evaluateTailwindFunctions.js"],"sourcesContent":["import dlv from 'dlv'\nimport didYouMean from 'didyoumean'\nimport transformThemeValue from '../util/transformThemeValue'\nimport parseValue from 'postcss-value-parser'\nimport { normalizeScreens } from '../util/normalizeScreens'\nimport buildMediaQuery from '../util/buildMediaQuery'\nimport { toPath } from '../util/toPath'\nimport { withAlphaValue } from '../util/withAlphaVariable'\nimport { parseColorFormat } from '../util/pluginUtils'\n\nfunction isObject(input) {\n  return typeof input === 'object' && input !== null\n}\n\nfunction findClosestExistingPath(theme, path) {\n  let parts = toPath(path)\n  do {\n    parts.pop()\n\n    if (dlv(theme, parts) !== undefined) break\n  } while (parts.length)\n\n  return parts.length ? parts : undefined\n}\n\nfunction pathToString(path) {\n  if (typeof path === 'string') return path\n  return path.reduce((acc, cur, i) => {\n    if (cur.includes('.')) return `${acc}[${cur}]`\n    return i === 0 ? cur : `${acc}.${cur}`\n  }, '')\n}\n\nfunction list(items) {\n  return items.map((key) => `'${key}'`).join(', ')\n}\n\nfunction listKeys(obj) {\n  return list(Object.keys(obj))\n}\n\nfunction validatePath(config, path, defaultValue, themeOpts = {}) {\n  const pathString = Array.isArray(path) ? pathToString(path) : path.replace(/^['\"]+|['\"]+$/g, '')\n  const pathSegments = Array.isArray(path) ? path : toPath(pathString)\n  const value = dlv(config.theme, pathSegments, defaultValue)\n\n  if (value === undefined) {\n    let error = `'${pathString}' does not exist in your theme config.`\n    const parentSegments = pathSegments.slice(0, -1)\n    const parentValue = dlv(config.theme, parentSegments)\n\n    if (isObject(parentValue)) {\n      const validKeys = Object.keys(parentValue).filter(\n        (key) => validatePath(config, [...parentSegments, key]).isValid\n      )\n      const suggestion = didYouMean(pathSegments[pathSegments.length - 1], validKeys)\n      if (suggestion) {\n        error += ` Did you mean '${pathToString([...parentSegments, suggestion])}'?`\n      } else if (validKeys.length > 0) {\n        error += ` '${pathToString(parentSegments)}' has the following valid keys: ${list(\n          validKeys\n        )}`\n      }\n    } else {\n      const closestPath = findClosestExistingPath(config.theme, pathString)\n      if (closestPath) {\n        const closestValue = dlv(config.theme, closestPath)\n        if (isObject(closestValue)) {\n          error += ` '${pathToString(closestPath)}' has the following keys: ${listKeys(\n            closestValue\n          )}`\n        } else {\n          error += ` '${pathToString(closestPath)}' is not an object.`\n        }\n      } else {\n        error += ` Your theme has the following top-level keys: ${listKeys(config.theme)}`\n      }\n    }\n\n    return {\n      isValid: false,\n      error,\n    }\n  }\n\n  if (\n    !(\n      typeof value === 'string' ||\n      typeof value === 'number' ||\n      typeof value === 'function' ||\n      value instanceof String ||\n      value instanceof Number ||\n      Array.isArray(value)\n    )\n  ) {\n    let error = `'${pathString}' was found but does not resolve to a string.`\n\n    if (isObject(value)) {\n      let validKeys = Object.keys(value).filter(\n        (key) => validatePath(config, [...pathSegments, key]).isValid\n      )\n      if (validKeys.length) {\n        error += ` Did you mean something like '${pathToString([...pathSegments, validKeys[0]])}'?`\n      }\n    }\n\n    return {\n      isValid: false,\n      error,\n    }\n  }\n\n  const [themeSection] = pathSegments\n\n  return {\n    isValid: true,\n    value: transformThemeValue(themeSection)(value, themeOpts),\n  }\n}\n\nfunction extractArgs(node, vNodes, functions) {\n  vNodes = vNodes.map((vNode) => resolveVNode(node, vNode, functions))\n\n  let args = ['']\n\n  for (let vNode of vNodes) {\n    if (vNode.type === 'div' && vNode.value === ',') {\n      args.push('')\n    } else {\n      args[args.length - 1] += parseValue.stringify(vNode)\n    }\n  }\n\n  return args\n}\n\nfunction resolveVNode(node, vNode, functions) {\n  if (vNode.type === 'function' && functions[vNode.value] !== undefined) {\n    let args = extractArgs(node, vNode.nodes, functions)\n    vNode.type = 'word'\n    vNode.value = functions[vNode.value](node, ...args)\n  }\n\n  return vNode\n}\n\nfunction resolveFunctions(node, input, functions) {\n  return parseValue(input)\n    .walk((vNode) => {\n      resolveVNode(node, vNode, functions)\n    })\n    .toString()\n}\n\nlet nodeTypePropertyMap = {\n  atrule: 'params',\n  decl: 'value',\n}\n\n/**\n * @param {string} path\n * @returns {Iterable<[path: string, alpha: string|undefined]>}\n */\nfunction* toPaths(path) {\n  // Strip quotes from beginning and end of string\n  // This allows the alpha value to be present inside of quotes\n  path = path.replace(/^['\"]+|['\"]+$/g, '')\n\n  let matches = path.match(/^([^\\s]+)(?![^\\[]*\\])(?:\\s*\\/\\s*([^\\/\\s]+))$/)\n  let alpha = undefined\n\n  yield [path, undefined]\n\n  if (matches) {\n    path = matches[1]\n    alpha = matches[2]\n\n    yield [path, alpha]\n  }\n}\n\n/**\n *\n * @param {any} config\n * @param {string} path\n * @param {any} defaultValue\n */\nfunction resolvePath(config, path, defaultValue) {\n  const results = Array.from(toPaths(path)).map(([path, alpha]) => {\n    return Object.assign(validatePath(config, path, defaultValue, { opacityValue: alpha }), {\n      resolvedPath: path,\n      alpha,\n    })\n  })\n\n  return results.find((result) => result.isValid) ?? results[0]\n}\n\nexport default function ({ tailwindConfig: config }) {\n  let functions = {\n    theme: (node, path, ...defaultValue) => {\n      let { isValid, value, error, alpha } = resolvePath(\n        config,\n        path,\n        defaultValue.length ? defaultValue : undefined\n      )\n\n      if (!isValid) {\n        throw node.error(error)\n      }\n\n      let maybeColor = parseColorFormat(value)\n      let isColorFunction = maybeColor !== undefined && typeof maybeColor === 'function'\n\n      if (alpha !== undefined || isColorFunction) {\n        if (alpha === undefined) {\n          alpha = 1.0\n        }\n\n        value = withAlphaValue(maybeColor, alpha, maybeColor)\n      }\n\n      return value\n    },\n    screen: (node, screen) => {\n      screen = screen.replace(/^['\"]+/g, '').replace(/['\"]+$/g, '')\n      let screens = normalizeScreens(config.theme.screens)\n      let screenDefinition = screens.find(({ name }) => name === screen)\n\n      if (!screenDefinition) {\n        throw node.error(`The '${screen}' screen does not exist in your theme.`)\n      }\n\n      return buildMediaQuery(screenDefinition)\n    },\n  }\n  return (root) => {\n    root.walk((node) => {\n      let property = nodeTypePropertyMap[node.type]\n\n      if (property === undefined) {\n        return\n      }\n\n      node[property] = resolveFunctions(node, node[property], functions)\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}