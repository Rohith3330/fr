{"ast":null,"code":"const path = require('path');\n/**\n * @callback MatchObject\n * @param {string} [str]\n * @returns {boolean}\n */\n\n/**\n * @typedef {Object} InjectLoaderOptions\n * @property {MatchObject} match A function to include/exclude files to be processed.\n * @property {import('../../loader/types').ReactRefreshLoaderOptions} [options] Options passed to the loader.\n */\n\n\nconst resolvedLoader = require.resolve('../../loader');\n/**\n * Injects refresh loader to all JavaScript-like and user-specified files.\n * @param {*} moduleData Module factory creation data.\n * @param {InjectLoaderOptions} injectOptions Options to alter how the loader is injected.\n * @returns {*} The injected module factory creation data.\n */\n\n\nfunction injectRefreshLoader(moduleData, injectOptions) {\n  const {\n    match,\n    options\n  } = injectOptions;\n\n  if ( // Include and exclude user-specified files\n  match(moduleData.matchResource || moduleData.resource) && // Exclude files referenced as assets\n  !moduleData.type.includes('asset') && // Skip react-refresh and the plugin's runtime utils to prevent self-referencing -\n  // this is useful when using the plugin as a direct dependency,\n  // or when node_modules are specified to be processed.\n  !moduleData.resource.includes(path.dirname(require.resolve('react-refresh'))) && !moduleData.resource.includes(path.join(__dirname, '../runtime/RefreshUtils')) && // Check to prevent double injection\n  !moduleData.loaders.find(_ref => {\n    let {\n      loader\n    } = _ref;\n    return loader === resolvedLoader;\n  })) {\n    // As we inject runtime code for each module,\n    // it is important to run the injected loader after everything.\n    // This way we can ensure that all code-processing have been done,\n    // and we won't risk breaking tools like Flow or ESLint.\n    moduleData.loaders.unshift({\n      loader: resolvedLoader,\n      options\n    });\n  }\n\n  return moduleData;\n}\n\nmodule.exports = injectRefreshLoader;","map":{"version":3,"names":["path","require","resolvedLoader","resolve","injectRefreshLoader","moduleData","injectOptions","match","options","matchResource","resource","type","includes","dirname","join","__dirname","loaders","find","loader","unshift","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/utils/injectRefreshLoader.js"],"sourcesContent":["const path = require('path');\n\n/**\n * @callback MatchObject\n * @param {string} [str]\n * @returns {boolean}\n */\n\n/**\n * @typedef {Object} InjectLoaderOptions\n * @property {MatchObject} match A function to include/exclude files to be processed.\n * @property {import('../../loader/types').ReactRefreshLoaderOptions} [options] Options passed to the loader.\n */\n\nconst resolvedLoader = require.resolve('../../loader');\n\n/**\n * Injects refresh loader to all JavaScript-like and user-specified files.\n * @param {*} moduleData Module factory creation data.\n * @param {InjectLoaderOptions} injectOptions Options to alter how the loader is injected.\n * @returns {*} The injected module factory creation data.\n */\nfunction injectRefreshLoader(moduleData, injectOptions) {\n  const { match, options } = injectOptions;\n\n  if (\n    // Include and exclude user-specified files\n    match(moduleData.matchResource || moduleData.resource) &&\n    // Exclude files referenced as assets\n    !moduleData.type.includes('asset') &&\n    // Skip react-refresh and the plugin's runtime utils to prevent self-referencing -\n    // this is useful when using the plugin as a direct dependency,\n    // or when node_modules are specified to be processed.\n    !moduleData.resource.includes(path.dirname(require.resolve('react-refresh'))) &&\n    !moduleData.resource.includes(path.join(__dirname, '../runtime/RefreshUtils')) &&\n    // Check to prevent double injection\n    !moduleData.loaders.find(({ loader }) => loader === resolvedLoader)\n  ) {\n    // As we inject runtime code for each module,\n    // it is important to run the injected loader after everything.\n    // This way we can ensure that all code-processing have been done,\n    // and we won't risk breaking tools like Flow or ESLint.\n    moduleData.loaders.unshift({\n      loader: resolvedLoader,\n      options,\n    });\n  }\n\n  return moduleData;\n}\n\nmodule.exports = injectRefreshLoader;\n"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAEA,MAAMC,cAAc,GAAGD,OAAO,CAACE,OAAR,CAAgB,cAAhB,CAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,mBAAT,CAA6BC,UAA7B,EAAyCC,aAAzC,EAAwD;EACtD,MAAM;IAAEC,KAAF;IAASC;EAAT,IAAqBF,aAA3B;;EAEA,KACE;EACAC,KAAK,CAACF,UAAU,CAACI,aAAX,IAA4BJ,UAAU,CAACK,QAAxC,CAAL,IACA;EACA,CAACL,UAAU,CAACM,IAAX,CAAgBC,QAAhB,CAAyB,OAAzB,CAFD,IAGA;EACA;EACA;EACA,CAACP,UAAU,CAACK,QAAX,CAAoBE,QAApB,CAA6BZ,IAAI,CAACa,OAAL,CAAaZ,OAAO,CAACE,OAAR,CAAgB,eAAhB,CAAb,CAA7B,CAND,IAOA,CAACE,UAAU,CAACK,QAAX,CAAoBE,QAApB,CAA6BZ,IAAI,CAACc,IAAL,CAAUC,SAAV,EAAqB,yBAArB,CAA7B,CAPD,IAQA;EACA,CAACV,UAAU,CAACW,OAAX,CAAmBC,IAAnB,CAAwB;IAAA,IAAC;MAAEC;IAAF,CAAD;IAAA,OAAgBA,MAAM,KAAKhB,cAA3B;EAAA,CAAxB,CAXH,EAYE;IACA;IACA;IACA;IACA;IACAG,UAAU,CAACW,OAAX,CAAmBG,OAAnB,CAA2B;MACzBD,MAAM,EAAEhB,cADiB;MAEzBM;IAFyB,CAA3B;EAID;;EAED,OAAOH,UAAP;AACD;;AAEDe,MAAM,CAACC,OAAP,GAAiBjB,mBAAjB"},"metadata":{},"sourceType":"script"}