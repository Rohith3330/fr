{"ast":null,"code":"// Port of python's argparse module, version 3.9.0:\n// https://github.com/python/cpython/blob/v3.9.0rc1/Lib/argparse.py\n'use strict'; // Copyright (C) 2010-2020 Python Software Foundation.\n// Copyright (C) 2020 argparse.js authors\n\n/*\n * Command-line parsing library\n *\n * This module is an optparse-inspired command-line parsing library that:\n *\n *     - handles both optional and positional arguments\n *     - produces highly informative usage messages\n *     - supports parsers that dispatch to sub-parsers\n *\n * The following is a simple usage example that sums integers from the\n * command-line and writes the result to a file::\n *\n *     parser = argparse.ArgumentParser(\n *         description='sum the integers at the command line')\n *     parser.add_argument(\n *         'integers', metavar='int', nargs='+', type=int,\n *         help='an integer to be summed')\n *     parser.add_argument(\n *         '--log', default=sys.stdout, type=argparse.FileType('w'),\n *         help='the file where the sum should be written')\n *     args = parser.parse_args()\n *     args.log.write('%s' % sum(args.integers))\n *     args.log.close()\n *\n * The module contains the following public classes:\n *\n *     - ArgumentParser -- The main entry point for command-line parsing. As the\n *         example above shows, the add_argument() method is used to populate\n *         the parser with actions for optional and positional arguments. Then\n *         the parse_args() method is invoked to convert the args at the\n *         command-line into an object with attributes.\n *\n *     - ArgumentError -- The exception raised by ArgumentParser objects when\n *         there are errors with the parser's actions. Errors raised while\n *         parsing the command-line are caught by ArgumentParser and emitted\n *         as command-line messages.\n *\n *     - FileType -- A factory for defining types of files to be created. As the\n *         example above shows, instances of FileType are typically passed as\n *         the type= argument of add_argument() calls.\n *\n *     - Action -- The base class for parser actions. Typically actions are\n *         selected by passing strings like 'store_true' or 'append_const' to\n *         the action= argument of add_argument(). However, for greater\n *         customization of ArgumentParser actions, subclasses of Action may\n *         be defined and passed as the action= argument.\n *\n *     - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,\n *         ArgumentDefaultsHelpFormatter -- Formatter classes which\n *         may be passed as the formatter_class= argument to the\n *         ArgumentParser constructor. HelpFormatter is the default,\n *         RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser\n *         not to change the formatting for help text, and\n *         ArgumentDefaultsHelpFormatter adds information about argument defaults\n *         to the help.\n *\n * All other classes in this module are considered implementation details.\n * (Also note that HelpFormatter and RawDescriptionHelpFormatter are only\n * considered public as object names -- the API of the formatter objects is\n * still considered an implementation detail.)\n */\n\nconst SUPPRESS = '==SUPPRESS==';\nconst OPTIONAL = '?';\nconst ZERO_OR_MORE = '*';\nconst ONE_OR_MORE = '+';\nconst PARSER = 'A...';\nconst REMAINDER = '...';\nconst _UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'; // ==================================\n// Utility functions used for porting\n// ==================================\n\nconst assert = require('assert');\n\nconst util = require('util');\n\nconst fs = require('fs');\n\nconst sub = require('./lib/sub');\n\nconst path = require('path');\n\nconst repr = util.inspect;\n\nfunction get_argv() {\n  // omit first argument (which is assumed to be interpreter - `node`, `coffee`, `ts-node`, etc.)\n  return process.argv.slice(1);\n}\n\nfunction get_terminal_size() {\n  return {\n    columns: +process.env.COLUMNS || process.stdout.columns || 80\n  };\n}\n\nfunction hasattr(object, name) {\n  return Object.prototype.hasOwnProperty.call(object, name);\n}\n\nfunction getattr(object, name, value) {\n  return hasattr(object, name) ? object[name] : value;\n}\n\nfunction setattr(object, name, value) {\n  object[name] = value;\n}\n\nfunction setdefault(object, name, value) {\n  if (!hasattr(object, name)) object[name] = value;\n  return object[name];\n}\n\nfunction delattr(object, name) {\n  delete object[name];\n}\n\nfunction range(from, to) {\n  let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  // range(10) is equivalent to range(0, 10)\n  if (arguments.length === 1) [to, from] = [from, 0];\n\n  if (typeof from !== 'number' || typeof to !== 'number' || typeof step !== 'number') {\n    throw new TypeError('argument cannot be interpreted as an integer');\n  }\n\n  if (step === 0) throw new TypeError('range() arg 3 must not be zero');\n  let result = [];\n\n  if (step > 0) {\n    for (let i = from; i < to; i += step) result.push(i);\n  } else {\n    for (let i = from; i > to; i += step) result.push(i);\n  }\n\n  return result;\n}\n\nfunction splitlines(str) {\n  let keepends = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let result;\n\n  if (!keepends) {\n    result = str.split(/\\r\\n|[\\n\\r\\v\\f\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/);\n  } else {\n    result = [];\n    let parts = str.split(/(\\r\\n|[\\n\\r\\v\\f\\x1c\\x1d\\x1e\\x85\\u2028\\u2029])/);\n\n    for (let i = 0; i < parts.length; i += 2) {\n      result.push(parts[i] + (i + 1 < parts.length ? parts[i + 1] : ''));\n    }\n  }\n\n  if (!result[result.length - 1]) result.pop();\n  return result;\n}\n\nfunction _string_lstrip(string, prefix_chars) {\n  let idx = 0;\n\n  while (idx < string.length && prefix_chars.includes(string[idx])) idx++;\n\n  return idx ? string.slice(idx) : string;\n}\n\nfunction _string_split(string, sep, maxsplit) {\n  let result = string.split(sep);\n\n  if (result.length > maxsplit) {\n    result = result.slice(0, maxsplit).concat([result.slice(maxsplit).join(sep)]);\n  }\n\n  return result;\n}\n\nfunction _array_equal(array1, array2) {\n  if (array1.length !== array2.length) return false;\n\n  for (let i = 0; i < array1.length; i++) {\n    if (array1[i] !== array2[i]) return false;\n  }\n\n  return true;\n}\n\nfunction _array_remove(array, item) {\n  let idx = array.indexOf(item);\n  if (idx === -1) throw new TypeError(sub('%r not in list', item));\n  array.splice(idx, 1);\n} // normalize choices to array;\n// this isn't required in python because `in` and `map` operators work with anything,\n// but in js dealing with multiple types here is too clunky\n\n\nfunction _choices_to_array(choices) {\n  if (choices === undefined) {\n    return [];\n  } else if (Array.isArray(choices)) {\n    return choices;\n  } else if (choices !== null && typeof choices[Symbol.iterator] === 'function') {\n    return Array.from(choices);\n  } else if (typeof choices === 'object' && choices !== null) {\n    return Object.keys(choices);\n  } else {\n    throw new Error(sub('invalid choices value: %r', choices));\n  }\n} // decorator that allows a class to be called without new\n\n\nfunction _callable(cls) {\n  let result = {\n    // object is needed for inferred class name\n    [cls.name]: function () {\n      let this_class = new.target === result || !new.target;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return Reflect.construct(cls, args, this_class ? cls : new.target);\n    }\n  };\n  result[cls.name].prototype = cls.prototype; // fix default tag for toString, e.g. [object Action] instead of [object Object]\n\n  cls.prototype[Symbol.toStringTag] = cls.name;\n  return result[cls.name];\n}\n\nfunction _alias(object, from, to) {\n  try {\n    let name = object.constructor.name;\n    Object.defineProperty(object, from, {\n      value: util.deprecate(object[to], sub('%s.%s() is renamed to %s.%s()', name, from, name, to)),\n      enumerable: false\n    });\n  } catch {}\n} // decorator that allows snake_case class methods to be called with camelCase and vice versa\n\n\nfunction _camelcase_alias(_class) {\n  for (let name of Object.getOwnPropertyNames(_class.prototype)) {\n    let camelcase = name.replace(/\\w_[a-z]/g, s => s[0] + s[2].toUpperCase());\n    if (camelcase !== name) _alias(_class.prototype, camelcase, name);\n  }\n\n  return _class;\n}\n\nfunction _to_legacy_name(key) {\n  key = key.replace(/\\w_[a-z]/g, s => s[0] + s[2].toUpperCase());\n  if (key === 'default') key = 'defaultValue';\n  if (key === 'const') key = 'constant';\n  return key;\n}\n\nfunction _to_new_name(key) {\n  if (key === 'defaultValue') key = 'default';\n  if (key === 'constant') key = 'const';\n  key = key.replace(/[A-Z]/g, c => '_' + c.toLowerCase());\n  return key;\n} // parse options\n\n\nlet no_default = Symbol('no_default_value');\n\nfunction _parse_opts(args, descriptor) {\n  function get_name() {\n    let stack = new Error().stack.split('\\n').map(x => x.match(/^    at (.*) \\(.*\\)$/)).filter(Boolean).map(m => m[1]).map(fn => fn.match(/[^ .]*$/)[0]);\n    if (stack.length && stack[0] === get_name.name) stack.shift();\n    if (stack.length && stack[0] === _parse_opts.name) stack.shift();\n    return stack.length ? stack[0] : '';\n  }\n\n  args = Array.from(args);\n  let kwargs = {};\n  let result = [];\n  let last_opt = args.length && args[args.length - 1];\n\n  if (typeof last_opt === 'object' && last_opt !== null && !Array.isArray(last_opt) && (!last_opt.constructor || last_opt.constructor.name === 'Object')) {\n    kwargs = Object.assign({}, args.pop());\n  } // LEGACY (v1 compatibility): camelcase\n\n\n  let renames = [];\n\n  for (let key of Object.keys(descriptor)) {\n    let old_name = _to_legacy_name(key);\n\n    if (old_name !== key && old_name in kwargs) {\n      if (key in kwargs) {// default and defaultValue specified at the same time, happens often in old tests\n        //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))\n      } else {\n        kwargs[key] = kwargs[old_name];\n      }\n\n      renames.push([old_name, key]);\n      delete kwargs[old_name];\n    }\n  }\n\n  if (renames.length) {\n    let name = get_name();\n    deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s', name, renames.map(_ref => {\n      let [a, b] = _ref;\n      return sub('%r -> %r', a, b);\n    })));\n  } // end\n\n\n  let missing_positionals = [];\n  let positional_count = args.length;\n\n  for (let [key, def] of Object.entries(descriptor)) {\n    if (key[0] === '*') {\n      if (key.length > 0 && key[1] === '*') {\n        // LEGACY (v1 compatibility): camelcase\n        let renames = [];\n\n        for (let key of Object.keys(kwargs)) {\n          let new_name = _to_new_name(key);\n\n          if (new_name !== key && key in kwargs) {\n            if (new_name in kwargs) {// default and defaultValue specified at the same time, happens often in old tests\n              //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), new_name))\n            } else {\n              kwargs[new_name] = kwargs[key];\n            }\n\n            renames.push([key, new_name]);\n            delete kwargs[key];\n          }\n        }\n\n        if (renames.length) {\n          let name = get_name();\n          deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s', name, renames.map(_ref2 => {\n            let [a, b] = _ref2;\n            return sub('%r -> %r', a, b);\n          })));\n        } // end\n\n\n        result.push(kwargs);\n        kwargs = {};\n      } else {\n        result.push(args);\n        args = [];\n      }\n    } else if (key in kwargs && args.length > 0) {\n      throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key));\n    } else if (key in kwargs) {\n      result.push(kwargs[key]);\n      delete kwargs[key];\n    } else if (args.length > 0) {\n      result.push(args.shift());\n    } else if (def !== no_default) {\n      result.push(def);\n    } else {\n      missing_positionals.push(key);\n    }\n  }\n\n  if (Object.keys(kwargs).length) {\n    throw new TypeError(sub('%s() got an unexpected keyword argument %r', get_name(), Object.keys(kwargs)[0]));\n  }\n\n  if (args.length) {\n    let from = Object.entries(descriptor).filter(_ref3 => {\n      let [k, v] = _ref3;\n      return k[0] !== '*' && v !== no_default;\n    }).length;\n    let to = Object.entries(descriptor).filter(_ref4 => {\n      let [k] = _ref4;\n      return k[0] !== '*';\n    }).length;\n    throw new TypeError(sub('%s() takes %s positional argument%s but %s %s given', get_name(), from === to ? sub('from %s to %s', from, to) : to, from === to && to === 1 ? '' : 's', positional_count, positional_count === 1 ? 'was' : 'were'));\n  }\n\n  if (missing_positionals.length) {\n    let strs = missing_positionals.map(repr);\n    if (strs.length > 1) strs[strs.length - 1] = 'and ' + strs[strs.length - 1];\n    let str_joined = strs.join(strs.length === 2 ? '' : ', ');\n    throw new TypeError(sub('%s() missing %i required positional argument%s: %s', get_name(), strs.length, strs.length === 1 ? '' : 's', str_joined));\n  }\n\n  return result;\n}\n\nlet _deprecations = {};\n\nfunction deprecate(id, string) {\n  _deprecations[id] = _deprecations[id] || util.deprecate(() => {}, string);\n\n  _deprecations[id]();\n} // =============================\n// Utility functions and classes\n// =============================\n\n\nfunction _AttributeHolder() {\n  let cls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object;\n\n  /*\n   *  Abstract base class that provides __repr__.\n   *\n   *  The __repr__ method returns a string in the format::\n   *      ClassName(attr=name, attr=name, ...)\n   *  The attributes are determined either by a class-level attribute,\n   *  '_kwarg_names', or by inspecting the instance __dict__.\n   */\n  return class _AttributeHolder extends cls {\n    [util.inspect.custom]() {\n      let type_name = this.constructor.name;\n      let arg_strings = [];\n      let star_args = {};\n\n      for (let arg of this._get_args()) {\n        arg_strings.push(repr(arg));\n      }\n\n      for (let [name, value] of this._get_kwargs()) {\n        if (/^[a-z_][a-z0-9_$]*$/i.test(name)) {\n          arg_strings.push(sub('%s=%r', name, value));\n        } else {\n          star_args[name] = value;\n        }\n      }\n\n      if (Object.keys(star_args).length) {\n        arg_strings.push(sub('**%s', repr(star_args)));\n      }\n\n      return sub('%s(%s)', type_name, arg_strings.join(', '));\n    }\n\n    toString() {\n      return this[util.inspect.custom]();\n    }\n\n    _get_kwargs() {\n      return Object.entries(this);\n    }\n\n    _get_args() {\n      return [];\n    }\n\n  };\n}\n\nfunction _copy_items(items) {\n  if (items === undefined) {\n    return [];\n  }\n\n  return items.slice(0);\n} // ===============\n// Formatting Help\n// ===============\n\n\nconst HelpFormatter = _camelcase_alias(_callable(class HelpFormatter {\n  /*\n   *  Formatter for generating usage messages and argument help strings.\n   *\n   *  Only the name of this class is considered a public API. All the methods\n   *  provided by the class are considered an implementation detail.\n   */\n  constructor() {\n    let [prog, indent_increment, max_help_position, width] = _parse_opts(arguments, {\n      prog: no_default,\n      indent_increment: 2,\n      max_help_position: 24,\n      width: undefined\n    }); // default setting for width\n\n\n    if (width === undefined) {\n      width = get_terminal_size().columns;\n      width -= 2;\n    }\n\n    this._prog = prog;\n    this._indent_increment = indent_increment;\n    this._max_help_position = Math.min(max_help_position, Math.max(width - 20, indent_increment * 2));\n    this._width = width;\n    this._current_indent = 0;\n    this._level = 0;\n    this._action_max_length = 0;\n    this._root_section = this._Section(this, undefined);\n    this._current_section = this._root_section;\n    this._whitespace_matcher = /[ \\t\\n\\r\\f\\v]+/g; // equivalent to python /\\s+/ with ASCII flag\n\n    this._long_break_matcher = /\\n\\n\\n+/g;\n  } // ===============================\n  // Section and indentation methods\n  // ===============================\n\n\n  _indent() {\n    this._current_indent += this._indent_increment;\n    this._level += 1;\n  }\n\n  _dedent() {\n    this._current_indent -= this._indent_increment;\n    assert(this._current_indent >= 0, 'Indent decreased below 0.');\n    this._level -= 1;\n  }\n\n  _add_item(func, args) {\n    this._current_section.items.push([func, args]);\n  } // ========================\n  // Message building methods\n  // ========================\n\n\n  start_section(heading) {\n    this._indent();\n\n    let section = this._Section(this, this._current_section, heading);\n\n    this._add_item(section.format_help.bind(section), []);\n\n    this._current_section = section;\n  }\n\n  end_section() {\n    this._current_section = this._current_section.parent;\n\n    this._dedent();\n  }\n\n  add_text(text) {\n    if (text !== SUPPRESS && text !== undefined) {\n      this._add_item(this._format_text.bind(this), [text]);\n    }\n  }\n\n  add_usage(usage, actions, groups) {\n    let prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n    if (usage !== SUPPRESS) {\n      let args = [usage, actions, groups, prefix];\n\n      this._add_item(this._format_usage.bind(this), args);\n    }\n  }\n\n  add_argument(action) {\n    if (action.help !== SUPPRESS) {\n      // find all invocations\n      let invocations = [this._format_action_invocation(action)];\n\n      for (let subaction of this._iter_indented_subactions(action)) {\n        invocations.push(this._format_action_invocation(subaction));\n      } // update the maximum item length\n\n\n      let invocation_length = Math.max(...invocations.map(invocation => invocation.length));\n      let action_length = invocation_length + this._current_indent;\n      this._action_max_length = Math.max(this._action_max_length, action_length); // add the item to the list\n\n      this._add_item(this._format_action.bind(this), [action]);\n    }\n  }\n\n  add_arguments(actions) {\n    for (let action of actions) {\n      this.add_argument(action);\n    }\n  } // =======================\n  // Help-formatting methods\n  // =======================\n\n\n  format_help() {\n    let help = this._root_section.format_help();\n\n    if (help) {\n      help = help.replace(this._long_break_matcher, '\\n\\n');\n      help = help.replace(/^\\n+|\\n+$/g, '') + '\\n';\n    }\n\n    return help;\n  }\n\n  _join_parts(part_strings) {\n    return part_strings.filter(part => part && part !== SUPPRESS).join('');\n  }\n\n  _format_usage(usage, actions, groups, prefix) {\n    if (prefix === undefined) {\n      prefix = 'usage: ';\n    } // if usage is specified, use that\n\n\n    if (usage !== undefined) {\n      usage = sub(usage, {\n        prog: this._prog\n      }); // if no optionals or positionals are available, usage is just prog\n    } else if (usage === undefined && !actions.length) {\n      usage = sub('%(prog)s', {\n        prog: this._prog\n      }); // if optionals and positionals are available, calculate usage\n    } else if (usage === undefined) {\n      let prog = sub('%(prog)s', {\n        prog: this._prog\n      }); // split optionals from positionals\n\n      let optionals = [];\n      let positionals = [];\n\n      for (let action of actions) {\n        if (action.option_strings.length) {\n          optionals.push(action);\n        } else {\n          positionals.push(action);\n        }\n      } // build full usage string\n\n\n      let action_usage = this._format_actions_usage([].concat(optionals).concat(positionals), groups);\n\n      usage = [prog, action_usage].map(String).join(' '); // wrap the usage parts if it's too long\n\n      let text_width = this._width - this._current_indent;\n\n      if (prefix.length + usage.length > text_width) {\n        // break usage into wrappable parts\n        let part_regexp = /\\(.*?\\)+(?=\\s|$)|\\[.*?\\]+(?=\\s|$)|\\S+/g;\n\n        let opt_usage = this._format_actions_usage(optionals, groups);\n\n        let pos_usage = this._format_actions_usage(positionals, groups);\n\n        let opt_parts = opt_usage.match(part_regexp) || [];\n        let pos_parts = pos_usage.match(part_regexp) || [];\n        assert(opt_parts.join(' ') === opt_usage);\n        assert(pos_parts.join(' ') === pos_usage); // helper for wrapping lines\n\n        let get_lines = function (parts, indent) {\n          let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n          let lines = [];\n          let line = [];\n          let line_len;\n\n          if (prefix !== undefined) {\n            line_len = prefix.length - 1;\n          } else {\n            line_len = indent.length - 1;\n          }\n\n          for (let part of parts) {\n            if (line_len + 1 + part.length > text_width && line) {\n              lines.push(indent + line.join(' '));\n              line = [];\n              line_len = indent.length - 1;\n            }\n\n            line.push(part);\n            line_len += part.length + 1;\n          }\n\n          if (line.length) {\n            lines.push(indent + line.join(' '));\n          }\n\n          if (prefix !== undefined) {\n            lines[0] = lines[0].slice(indent.length);\n          }\n\n          return lines;\n        };\n\n        let lines; // if prog is short, follow it with optionals or positionals\n\n        if (prefix.length + prog.length <= 0.75 * text_width) {\n          let indent = ' '.repeat(prefix.length + prog.length + 1);\n\n          if (opt_parts.length) {\n            lines = get_lines([prog].concat(opt_parts), indent, prefix);\n            lines = lines.concat(get_lines(pos_parts, indent));\n          } else if (pos_parts.length) {\n            lines = get_lines([prog].concat(pos_parts), indent, prefix);\n          } else {\n            lines = [prog];\n          } // if prog is long, put it on its own line\n\n        } else {\n          let indent = ' '.repeat(prefix.length);\n          let parts = [].concat(opt_parts).concat(pos_parts);\n          lines = get_lines(parts, indent);\n\n          if (lines.length > 1) {\n            lines = [];\n            lines = lines.concat(get_lines(opt_parts, indent));\n            lines = lines.concat(get_lines(pos_parts, indent));\n          }\n\n          lines = [prog].concat(lines);\n        } // join lines into usage\n\n\n        usage = lines.join('\\n');\n      }\n    } // prefix with 'usage:'\n\n\n    return sub('%s%s\\n\\n', prefix, usage);\n  }\n\n  _format_actions_usage(actions, groups) {\n    // find group indices and identify actions in groups\n    let group_actions = new Set();\n    let inserts = {};\n\n    for (let group of groups) {\n      let start = actions.indexOf(group._group_actions[0]);\n\n      if (start === -1) {\n        continue;\n      } else {\n        let end = start + group._group_actions.length;\n\n        if (_array_equal(actions.slice(start, end), group._group_actions)) {\n          for (let action of group._group_actions) {\n            group_actions.add(action);\n          }\n\n          if (!group.required) {\n            if (start in inserts) {\n              inserts[start] += ' [';\n            } else {\n              inserts[start] = '[';\n            }\n\n            if (end in inserts) {\n              inserts[end] += ']';\n            } else {\n              inserts[end] = ']';\n            }\n          } else {\n            if (start in inserts) {\n              inserts[start] += ' (';\n            } else {\n              inserts[start] = '(';\n            }\n\n            if (end in inserts) {\n              inserts[end] += ')';\n            } else {\n              inserts[end] = ')';\n            }\n          }\n\n          for (let i of range(start + 1, end)) {\n            inserts[i] = '|';\n          }\n        }\n      }\n    } // collect all actions format strings\n\n\n    let parts = [];\n\n    for (let [i, action] of Object.entries(actions)) {\n      // suppressed arguments are marked with None\n      // remove | separators for suppressed arguments\n      if (action.help === SUPPRESS) {\n        parts.push(undefined);\n\n        if (inserts[+i] === '|') {\n          delete inserts[+i];\n        } else if (inserts[+i + 1] === '|') {\n          delete inserts[+i + 1];\n        } // produce all arg strings\n\n      } else if (!action.option_strings.length) {\n        let default_value = this._get_default_metavar_for_positional(action);\n\n        let part = this._format_args(action, default_value); // if it's in a group, strip the outer []\n\n\n        if (group_actions.has(action)) {\n          if (part[0] === '[' && part[part.length - 1] === ']') {\n            part = part.slice(1, -1);\n          }\n        } // add the action string to the list\n\n\n        parts.push(part); // produce the first way to invoke the option in brackets\n      } else {\n        let option_string = action.option_strings[0];\n        let part; // if the Optional doesn't take a value, format is:\n        //    -s or --long\n\n        if (action.nargs === 0) {\n          part = action.format_usage(); // if the Optional takes a value, format is:\n          //    -s ARGS or --long ARGS\n        } else {\n          let default_value = this._get_default_metavar_for_optional(action);\n\n          let args_string = this._format_args(action, default_value);\n\n          part = sub('%s %s', option_string, args_string);\n        } // make it look optional if it's not required or in a group\n\n\n        if (!action.required && !group_actions.has(action)) {\n          part = sub('[%s]', part);\n        } // add the action string to the list\n\n\n        parts.push(part);\n      }\n    } // insert things at the necessary indices\n\n\n    for (let i of Object.keys(inserts).map(Number).sort((a, b) => b - a)) {\n      parts.splice(+i, 0, inserts[+i]);\n    } // join all the action items with spaces\n\n\n    let text = parts.filter(Boolean).join(' '); // clean up separators for mutually exclusive groups\n\n    text = text.replace(/([\\[(]) /g, '$1');\n    text = text.replace(/ ([\\])])/g, '$1');\n    text = text.replace(/[\\[(] *[\\])]/g, '');\n    text = text.replace(/\\(([^|]*)\\)/g, '$1', text);\n    text = text.trim(); // return the text\n\n    return text;\n  }\n\n  _format_text(text) {\n    if (text.includes('%(prog)')) {\n      text = sub(text, {\n        prog: this._prog\n      });\n    }\n\n    let text_width = Math.max(this._width - this._current_indent, 11);\n    let indent = ' '.repeat(this._current_indent);\n    return this._fill_text(text, text_width, indent) + '\\n\\n';\n  }\n\n  _format_action(action) {\n    // determine the required width and the entry label\n    let help_position = Math.min(this._action_max_length + 2, this._max_help_position);\n    let help_width = Math.max(this._width - help_position, 11);\n    let action_width = help_position - this._current_indent - 2;\n\n    let action_header = this._format_action_invocation(action);\n\n    let indent_first; // no help; start on same line and add a final newline\n\n    if (!action.help) {\n      let tup = [this._current_indent, '', action_header];\n      action_header = sub('%*s%s\\n', ...tup); // short action name; start on the same line and pad two spaces\n    } else if (action_header.length <= action_width) {\n      let tup = [this._current_indent, '', action_width, action_header];\n      action_header = sub('%*s%-*s  ', ...tup);\n      indent_first = 0; // long action name; start on the next line\n    } else {\n      let tup = [this._current_indent, '', action_header];\n      action_header = sub('%*s%s\\n', ...tup);\n      indent_first = help_position;\n    } // collect the pieces of the action help\n\n\n    let parts = [action_header]; // if there was help for the action, add lines of help text\n\n    if (action.help) {\n      let help_text = this._expand_help(action);\n\n      let help_lines = this._split_lines(help_text, help_width);\n\n      parts.push(sub('%*s%s\\n', indent_first, '', help_lines[0]));\n\n      for (let line of help_lines.slice(1)) {\n        parts.push(sub('%*s%s\\n', help_position, '', line));\n      } // or add a newline if the description doesn't end with one\n\n    } else if (!action_header.endsWith('\\n')) {\n      parts.push('\\n');\n    } // if there are any sub-actions, add their help as well\n\n\n    for (let subaction of this._iter_indented_subactions(action)) {\n      parts.push(this._format_action(subaction));\n    } // return a single string\n\n\n    return this._join_parts(parts);\n  }\n\n  _format_action_invocation(action) {\n    if (!action.option_strings.length) {\n      let default_value = this._get_default_metavar_for_positional(action);\n\n      let metavar = this._metavar_formatter(action, default_value)(1)[0];\n\n      return metavar;\n    } else {\n      let parts = []; // if the Optional doesn't take a value, format is:\n      //    -s, --long\n\n      if (action.nargs === 0) {\n        parts = parts.concat(action.option_strings); // if the Optional takes a value, format is:\n        //    -s ARGS, --long ARGS\n      } else {\n        let default_value = this._get_default_metavar_for_optional(action);\n\n        let args_string = this._format_args(action, default_value);\n\n        for (let option_string of action.option_strings) {\n          parts.push(sub('%s %s', option_string, args_string));\n        }\n      }\n\n      return parts.join(', ');\n    }\n  }\n\n  _metavar_formatter(action, default_metavar) {\n    let result;\n\n    if (action.metavar !== undefined) {\n      result = action.metavar;\n    } else if (action.choices !== undefined) {\n      let choice_strs = _choices_to_array(action.choices).map(String);\n\n      result = sub('{%s}', choice_strs.join(','));\n    } else {\n      result = default_metavar;\n    }\n\n    function format(tuple_size) {\n      if (Array.isArray(result)) {\n        return result;\n      } else {\n        return Array(tuple_size).fill(result);\n      }\n    }\n\n    return format;\n  }\n\n  _format_args(action, default_metavar) {\n    let get_metavar = this._metavar_formatter(action, default_metavar);\n\n    let result;\n\n    if (action.nargs === undefined) {\n      result = sub('%s', ...get_metavar(1));\n    } else if (action.nargs === OPTIONAL) {\n      result = sub('[%s]', ...get_metavar(1));\n    } else if (action.nargs === ZERO_OR_MORE) {\n      let metavar = get_metavar(1);\n\n      if (metavar.length === 2) {\n        result = sub('[%s [%s ...]]', ...metavar);\n      } else {\n        result = sub('[%s ...]', ...metavar);\n      }\n    } else if (action.nargs === ONE_OR_MORE) {\n      result = sub('%s [%s ...]', ...get_metavar(2));\n    } else if (action.nargs === REMAINDER) {\n      result = '...';\n    } else if (action.nargs === PARSER) {\n      result = sub('%s ...', ...get_metavar(1));\n    } else if (action.nargs === SUPPRESS) {\n      result = '';\n    } else {\n      let formats;\n\n      try {\n        formats = range(action.nargs).map(() => '%s');\n      } catch (err) {\n        throw new TypeError('invalid nargs value');\n      }\n\n      result = sub(formats.join(' '), ...get_metavar(action.nargs));\n    }\n\n    return result;\n  }\n\n  _expand_help(action) {\n    let params = Object.assign({\n      prog: this._prog\n    }, action);\n\n    for (let name of Object.keys(params)) {\n      if (params[name] === SUPPRESS) {\n        delete params[name];\n      }\n    }\n\n    for (let name of Object.keys(params)) {\n      if (params[name] && params[name].name) {\n        params[name] = params[name].name;\n      }\n    }\n\n    if (params.choices !== undefined) {\n      let choices_str = _choices_to_array(params.choices).map(String).join(', ');\n\n      params.choices = choices_str;\n    } // LEGACY (v1 compatibility): camelcase\n\n\n    for (let key of Object.keys(params)) {\n      let old_name = _to_legacy_name(key);\n\n      if (old_name !== key) {\n        params[old_name] = params[key];\n      }\n    } // end\n\n\n    return sub(this._get_help_string(action), params);\n  }\n\n  *_iter_indented_subactions(action) {\n    if (typeof action._get_subactions === 'function') {\n      this._indent();\n\n      yield* action._get_subactions();\n\n      this._dedent();\n    }\n  }\n\n  _split_lines(text, width) {\n    text = text.replace(this._whitespace_matcher, ' ').trim(); // The textwrap module is used only for formatting help.\n    // Delay its import for speeding up the common usage of argparse.\n\n    let textwrap = require('./lib/textwrap');\n\n    return textwrap.wrap(text, {\n      width\n    });\n  }\n\n  _fill_text(text, width, indent) {\n    text = text.replace(this._whitespace_matcher, ' ').trim();\n\n    let textwrap = require('./lib/textwrap');\n\n    return textwrap.fill(text, {\n      width,\n      initial_indent: indent,\n      subsequent_indent: indent\n    });\n  }\n\n  _get_help_string(action) {\n    return action.help;\n  }\n\n  _get_default_metavar_for_optional(action) {\n    return action.dest.toUpperCase();\n  }\n\n  _get_default_metavar_for_positional(action) {\n    return action.dest;\n  }\n\n}));\n\nHelpFormatter.prototype._Section = _callable(class _Section {\n  constructor(formatter, parent) {\n    let heading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    this.formatter = formatter;\n    this.parent = parent;\n    this.heading = heading;\n    this.items = [];\n  }\n\n  format_help() {\n    // format the indented section\n    if (this.parent !== undefined) {\n      this.formatter._indent();\n    }\n\n    let item_help = this.formatter._join_parts(this.items.map(_ref5 => {\n      let [func, args] = _ref5;\n      return func.apply(null, args);\n    }));\n\n    if (this.parent !== undefined) {\n      this.formatter._dedent();\n    } // return nothing if the section was empty\n\n\n    if (!item_help) {\n      return '';\n    } // add the heading if the section was non-empty\n\n\n    let heading;\n\n    if (this.heading !== SUPPRESS && this.heading !== undefined) {\n      let current_indent = this.formatter._current_indent;\n      heading = sub('%*s%s:\\n', current_indent, '', this.heading);\n    } else {\n      heading = '';\n    } // join the section-initial newline, the heading and the help\n\n\n    return this.formatter._join_parts(['\\n', heading, item_help, '\\n']);\n  }\n\n});\n\nconst RawDescriptionHelpFormatter = _camelcase_alias(_callable(class RawDescriptionHelpFormatter extends HelpFormatter {\n  /*\n   *  Help message formatter which retains any formatting in descriptions.\n   *\n   *  Only the name of this class is considered a public API. All the methods\n   *  provided by the class are considered an implementation detail.\n   */\n  _fill_text(text, width, indent) {\n    return splitlines(text, true).map(line => indent + line).join('');\n  }\n\n}));\n\nconst RawTextHelpFormatter = _camelcase_alias(_callable(class RawTextHelpFormatter extends RawDescriptionHelpFormatter {\n  /*\n   *  Help message formatter which retains formatting of all help text.\n   *\n   *  Only the name of this class is considered a public API. All the methods\n   *  provided by the class are considered an implementation detail.\n   */\n  _split_lines(text\n  /*, width*/\n  ) {\n    return splitlines(text);\n  }\n\n}));\n\nconst ArgumentDefaultsHelpFormatter = _camelcase_alias(_callable(class ArgumentDefaultsHelpFormatter extends HelpFormatter {\n  /*\n   *  Help message formatter which adds default values to argument help.\n   *\n   *  Only the name of this class is considered a public API. All the methods\n   *  provided by the class are considered an implementation detail.\n   */\n  _get_help_string(action) {\n    let help = action.help; // LEGACY (v1 compatibility): additional check for defaultValue needed\n\n    if (!action.help.includes('%(default)') && !action.help.includes('%(defaultValue)')) {\n      if (action.default !== SUPPRESS) {\n        let defaulting_nargs = [OPTIONAL, ZERO_OR_MORE];\n\n        if (action.option_strings.length || defaulting_nargs.includes(action.nargs)) {\n          help += ' (default: %(default)s)';\n        }\n      }\n    }\n\n    return help;\n  }\n\n}));\n\nconst MetavarTypeHelpFormatter = _camelcase_alias(_callable(class MetavarTypeHelpFormatter extends HelpFormatter {\n  /*\n   *  Help message formatter which uses the argument 'type' as the default\n   *  metavar value (instead of the argument 'dest')\n   *\n   *  Only the name of this class is considered a public API. All the methods\n   *  provided by the class are considered an implementation detail.\n   */\n  _get_default_metavar_for_optional(action) {\n    return typeof action.type === 'function' ? action.type.name : action.type;\n  }\n\n  _get_default_metavar_for_positional(action) {\n    return typeof action.type === 'function' ? action.type.name : action.type;\n  }\n\n})); // =====================\n// Options and Arguments\n// =====================\n\n\nfunction _get_action_name(argument) {\n  if (argument === undefined) {\n    return undefined;\n  } else if (argument.option_strings.length) {\n    return argument.option_strings.join('/');\n  } else if (![undefined, SUPPRESS].includes(argument.metavar)) {\n    return argument.metavar;\n  } else if (![undefined, SUPPRESS].includes(argument.dest)) {\n    return argument.dest;\n  } else {\n    return undefined;\n  }\n}\n\nconst ArgumentError = _callable(class ArgumentError extends Error {\n  /*\n   *  An error from creating or using an argument (optional or positional).\n   *\n   *  The string value of this exception is the message, augmented with\n   *  information about the argument that caused it.\n   */\n  constructor(argument, message) {\n    super();\n    this.name = 'ArgumentError';\n    this._argument_name = _get_action_name(argument);\n    this._message = message;\n    this.message = this.str();\n  }\n\n  str() {\n    let format;\n\n    if (this._argument_name === undefined) {\n      format = '%(message)s';\n    } else {\n      format = 'argument %(argument_name)s: %(message)s';\n    }\n\n    return sub(format, {\n      message: this._message,\n      argument_name: this._argument_name\n    });\n  }\n\n});\n\nconst ArgumentTypeError = _callable(class ArgumentTypeError extends Error {\n  /*\n   * An error from trying to convert a command line string to a type.\n   */\n  constructor(message) {\n    super(message);\n    this.name = 'ArgumentTypeError';\n  }\n\n}); // ==============\n// Action classes\n// ==============\n\n\nconst Action = _camelcase_alias(_callable(class Action extends _AttributeHolder(Function) {\n  /*\n   *  Information about how to convert command line strings to Python objects.\n   *\n   *  Action objects are used by an ArgumentParser to represent the information\n   *  needed to parse a single argument from one or more strings from the\n   *  command line. The keyword arguments to the Action constructor are also\n   *  all attributes of Action instances.\n   *\n   *  Keyword Arguments:\n   *\n   *      - option_strings -- A list of command-line option strings which\n   *          should be associated with this action.\n   *\n   *      - dest -- The name of the attribute to hold the created object(s)\n   *\n   *      - nargs -- The number of command-line arguments that should be\n   *          consumed. By default, one argument will be consumed and a single\n   *          value will be produced.  Other values include:\n   *              - N (an integer) consumes N arguments (and produces a list)\n   *              - '?' consumes zero or one arguments\n   *              - '*' consumes zero or more arguments (and produces a list)\n   *              - '+' consumes one or more arguments (and produces a list)\n   *          Note that the difference between the default and nargs=1 is that\n   *          with the default, a single value will be produced, while with\n   *          nargs=1, a list containing a single value will be produced.\n   *\n   *      - const -- The value to be produced if the option is specified and the\n   *          option uses an action that takes no values.\n   *\n   *      - default -- The value to be produced if the option is not specified.\n   *\n   *      - type -- A callable that accepts a single string argument, and\n   *          returns the converted value.  The standard Python types str, int,\n   *          float, and complex are useful examples of such callables.  If None,\n   *          str is used.\n   *\n   *      - choices -- A container of values that should be allowed. If not None,\n   *          after a command-line argument has been converted to the appropriate\n   *          type, an exception will be raised if it is not a member of this\n   *          collection.\n   *\n   *      - required -- True if the action must always be specified at the\n   *          command line. This is only meaningful for optional command-line\n   *          arguments.\n   *\n   *      - help -- The help string describing the argument.\n   *\n   *      - metavar -- The name to be used for the option's argument with the\n   *          help string. If None, the 'dest' value will be used as the name.\n   */\n  constructor() {\n    let [option_strings, dest, nargs, const_value, default_value, type, choices, required, help, metavar] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      nargs: undefined,\n      const: undefined,\n      default: undefined,\n      type: undefined,\n      choices: undefined,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    }); // when this class is called as a function, redirect it to .call() method of itself\n\n\n    super('return arguments.callee.call.apply(arguments.callee, arguments)');\n    this.option_strings = option_strings;\n    this.dest = dest;\n    this.nargs = nargs;\n    this.const = const_value;\n    this.default = default_value;\n    this.type = type;\n    this.choices = choices;\n    this.required = required;\n    this.help = help;\n    this.metavar = metavar;\n  }\n\n  _get_kwargs() {\n    let names = ['option_strings', 'dest', 'nargs', 'const', 'default', 'type', 'choices', 'help', 'metavar'];\n    return names.map(name => [name, getattr(this, name)]);\n  }\n\n  format_usage() {\n    return this.option_strings[0];\n  }\n\n  call() {\n    throw new Error('.call() not defined');\n  }\n\n}));\n\nconst BooleanOptionalAction = _camelcase_alias(_callable(class BooleanOptionalAction extends Action {\n  constructor() {\n    let [option_strings, dest, default_value, type, choices, required, help, metavar] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      default: undefined,\n      type: undefined,\n      choices: undefined,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    });\n\n    let _option_strings = [];\n\n    for (let option_string of option_strings) {\n      _option_strings.push(option_string);\n\n      if (option_string.startsWith('--')) {\n        option_string = '--no-' + option_string.slice(2);\n\n        _option_strings.push(option_string);\n      }\n    }\n\n    if (help !== undefined && default_value !== undefined) {\n      help += ` (default: ${default_value})`;\n    }\n\n    super({\n      option_strings: _option_strings,\n      dest,\n      nargs: 0,\n      default: default_value,\n      type,\n      choices,\n      required,\n      help,\n      metavar\n    });\n  }\n\n  call(parser, namespace, values) {\n    let option_string = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n    if (this.option_strings.includes(option_string)) {\n      setattr(namespace, this.dest, !option_string.startsWith('--no-'));\n    }\n  }\n\n  format_usage() {\n    return this.option_strings.join(' | ');\n  }\n\n}));\n\nconst _StoreAction = _callable(class _StoreAction extends Action {\n  constructor() {\n    let [option_strings, dest, nargs, const_value, default_value, type, choices, required, help, metavar] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      nargs: undefined,\n      const: undefined,\n      default: undefined,\n      type: undefined,\n      choices: undefined,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    });\n\n    if (nargs === 0) {\n      throw new TypeError('nargs for store actions must be != 0; if you ' + 'have nothing to store, actions such as store ' + 'true or store const may be more appropriate');\n    }\n\n    if (const_value !== undefined && nargs !== OPTIONAL) {\n      throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL));\n    }\n\n    super({\n      option_strings,\n      dest,\n      nargs,\n      const: const_value,\n      default: default_value,\n      type,\n      choices,\n      required,\n      help,\n      metavar\n    });\n  }\n\n  call(parser, namespace, values\n  /*, option_string = undefined*/\n  ) {\n    setattr(namespace, this.dest, values);\n  }\n\n});\n\nconst _StoreConstAction = _callable(class _StoreConstAction extends Action {\n  constructor() {\n    let [option_strings, dest, const_value, default_value, required, help //, metavar\n    ] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      const: no_default,\n      default: undefined,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    });\n\n    super({\n      option_strings,\n      dest,\n      nargs: 0,\n      const: const_value,\n      default: default_value,\n      required,\n      help\n    });\n  }\n\n  call(parser, namespace\n  /*, values, option_string = undefined*/\n  ) {\n    setattr(namespace, this.dest, this.const);\n  }\n\n});\n\nconst _StoreTrueAction = _callable(class _StoreTrueAction extends _StoreConstAction {\n  constructor() {\n    let [option_strings, dest, default_value, required, help] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      default: false,\n      required: false,\n      help: undefined\n    });\n\n    super({\n      option_strings,\n      dest,\n      const: true,\n      default: default_value,\n      required,\n      help\n    });\n  }\n\n});\n\nconst _StoreFalseAction = _callable(class _StoreFalseAction extends _StoreConstAction {\n  constructor() {\n    let [option_strings, dest, default_value, required, help] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      default: true,\n      required: false,\n      help: undefined\n    });\n\n    super({\n      option_strings,\n      dest,\n      const: false,\n      default: default_value,\n      required,\n      help\n    });\n  }\n\n});\n\nconst _AppendAction = _callable(class _AppendAction extends Action {\n  constructor() {\n    let [option_strings, dest, nargs, const_value, default_value, type, choices, required, help, metavar] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      nargs: undefined,\n      const: undefined,\n      default: undefined,\n      type: undefined,\n      choices: undefined,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    });\n\n    if (nargs === 0) {\n      throw new TypeError('nargs for append actions must be != 0; if arg ' + 'strings are not supplying the value to append, ' + 'the append const action may be more appropriate');\n    }\n\n    if (const_value !== undefined && nargs !== OPTIONAL) {\n      throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL));\n    }\n\n    super({\n      option_strings,\n      dest,\n      nargs,\n      const: const_value,\n      default: default_value,\n      type,\n      choices,\n      required,\n      help,\n      metavar\n    });\n  }\n\n  call(parser, namespace, values\n  /*, option_string = undefined*/\n  ) {\n    let items = getattr(namespace, this.dest, undefined);\n    items = _copy_items(items);\n    items.push(values);\n    setattr(namespace, this.dest, items);\n  }\n\n});\n\nconst _AppendConstAction = _callable(class _AppendConstAction extends Action {\n  constructor() {\n    let [option_strings, dest, const_value, default_value, required, help, metavar] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      const: no_default,\n      default: undefined,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    });\n\n    super({\n      option_strings,\n      dest,\n      nargs: 0,\n      const: const_value,\n      default: default_value,\n      required,\n      help,\n      metavar\n    });\n  }\n\n  call(parser, namespace\n  /*, values, option_string = undefined*/\n  ) {\n    let items = getattr(namespace, this.dest, undefined);\n    items = _copy_items(items);\n    items.push(this.const);\n    setattr(namespace, this.dest, items);\n  }\n\n});\n\nconst _CountAction = _callable(class _CountAction extends Action {\n  constructor() {\n    let [option_strings, dest, default_value, required, help] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: no_default,\n      default: undefined,\n      required: false,\n      help: undefined\n    });\n\n    super({\n      option_strings,\n      dest,\n      nargs: 0,\n      default: default_value,\n      required,\n      help\n    });\n  }\n\n  call(parser, namespace\n  /*, values, option_string = undefined*/\n  ) {\n    let count = getattr(namespace, this.dest, undefined);\n\n    if (count === undefined) {\n      count = 0;\n    }\n\n    setattr(namespace, this.dest, count + 1);\n  }\n\n});\n\nconst _HelpAction = _callable(class _HelpAction extends Action {\n  constructor() {\n    let [option_strings, dest, default_value, help] = _parse_opts(arguments, {\n      option_strings: no_default,\n      dest: SUPPRESS,\n      default: SUPPRESS,\n      help: undefined\n    });\n\n    super({\n      option_strings,\n      dest,\n      default: default_value,\n      nargs: 0,\n      help\n    });\n  }\n\n  call(parser\n  /*, namespace, values, option_string = undefined*/\n  ) {\n    parser.print_help();\n    parser.exit();\n  }\n\n});\n\nconst _VersionAction = _callable(class _VersionAction extends Action {\n  constructor() {\n    let [option_strings, version, dest, default_value, help] = _parse_opts(arguments, {\n      option_strings: no_default,\n      version: undefined,\n      dest: SUPPRESS,\n      default: SUPPRESS,\n      help: \"show program's version number and exit\"\n    });\n\n    super({\n      option_strings,\n      dest,\n      default: default_value,\n      nargs: 0,\n      help\n    });\n    this.version = version;\n  }\n\n  call(parser\n  /*, namespace, values, option_string = undefined*/\n  ) {\n    let version = this.version;\n\n    if (version === undefined) {\n      version = parser.version;\n    }\n\n    let formatter = parser._get_formatter();\n\n    formatter.add_text(version);\n\n    parser._print_message(formatter.format_help(), process.stdout);\n\n    parser.exit();\n  }\n\n});\n\nconst _SubParsersAction = _camelcase_alias(_callable(class _SubParsersAction extends Action {\n  constructor() {\n    let [option_strings, prog, parser_class, dest, required, help, metavar] = _parse_opts(arguments, {\n      option_strings: no_default,\n      prog: no_default,\n      parser_class: no_default,\n      dest: SUPPRESS,\n      required: false,\n      help: undefined,\n      metavar: undefined\n    });\n\n    let name_parser_map = {};\n    super({\n      option_strings,\n      dest,\n      nargs: PARSER,\n      choices: name_parser_map,\n      required,\n      help,\n      metavar\n    });\n    this._prog_prefix = prog;\n    this._parser_class = parser_class;\n    this._name_parser_map = name_parser_map;\n    this._choices_actions = [];\n  }\n\n  add_parser() {\n    let [name, kwargs] = _parse_opts(arguments, {\n      name: no_default,\n      '**kwargs': no_default\n    }); // set prog from the existing prefix\n\n\n    if (kwargs.prog === undefined) {\n      kwargs.prog = sub('%s %s', this._prog_prefix, name);\n    }\n\n    let aliases = getattr(kwargs, 'aliases', []);\n    delete kwargs.aliases; // create a pseudo-action to hold the choice help\n\n    if ('help' in kwargs) {\n      let help = kwargs.help;\n      delete kwargs.help;\n\n      let choice_action = this._ChoicesPseudoAction(name, aliases, help);\n\n      this._choices_actions.push(choice_action);\n    } // create the parser and add it to the map\n\n\n    let parser = new this._parser_class(kwargs);\n    this._name_parser_map[name] = parser; // make parser available under aliases also\n\n    for (let alias of aliases) {\n      this._name_parser_map[alias] = parser;\n    }\n\n    return parser;\n  }\n\n  _get_subactions() {\n    return this._choices_actions;\n  }\n\n  call(parser, namespace, values\n  /*, option_string = undefined*/\n  ) {\n    let parser_name = values[0];\n    let arg_strings = values.slice(1); // set the parser name if requested\n\n    if (this.dest !== SUPPRESS) {\n      setattr(namespace, this.dest, parser_name);\n    } // select the parser\n\n\n    if (hasattr(this._name_parser_map, parser_name)) {\n      parser = this._name_parser_map[parser_name];\n    } else {\n      let args = {\n        parser_name,\n        choices: this._name_parser_map.join(', ')\n      };\n      let msg = sub('unknown parser %(parser_name)r (choices: %(choices)s)', args);\n      throw new ArgumentError(this, msg);\n    } // parse all the remaining options into the namespace\n    // store any unrecognized options on the object, so that the top\n    // level parser can decide what to do with them\n    // In case this subparser defines new defaults, we parse them\n    // in a new namespace object and then update the original\n    // namespace for the relevant parts.\n\n\n    let subnamespace;\n    [subnamespace, arg_strings] = parser.parse_known_args(arg_strings, undefined);\n\n    for (let [key, value] of Object.entries(subnamespace)) {\n      setattr(namespace, key, value);\n    }\n\n    if (arg_strings.length) {\n      setdefault(namespace, _UNRECOGNIZED_ARGS_ATTR, []);\n      getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).push(...arg_strings);\n    }\n  }\n\n}));\n\n_SubParsersAction.prototype._ChoicesPseudoAction = _callable(class _ChoicesPseudoAction extends Action {\n  constructor(name, aliases, help) {\n    let metavar = name,\n        dest = name;\n\n    if (aliases.length) {\n      metavar += sub(' (%s)', aliases.join(', '));\n    }\n\n    super({\n      option_strings: [],\n      dest,\n      help,\n      metavar\n    });\n  }\n\n});\n\nconst _ExtendAction = _callable(class _ExtendAction extends _AppendAction {\n  call(parser, namespace, values\n  /*, option_string = undefined*/\n  ) {\n    let items = getattr(namespace, this.dest, undefined);\n    items = _copy_items(items);\n    items = items.concat(values);\n    setattr(namespace, this.dest, items);\n  }\n\n}); // ==============\n// Type classes\n// ==============\n\n\nconst FileType = _callable(class FileType extends Function {\n  /*\n   *  Factory for creating file object types\n   *\n   *  Instances of FileType are typically passed as type= arguments to the\n   *  ArgumentParser add_argument() method.\n   *\n   *  Keyword Arguments:\n   *      - mode -- A string indicating how the file is to be opened. Accepts the\n   *          same values as the builtin open() function.\n   *      - bufsize -- The file's desired buffer size. Accepts the same values as\n   *          the builtin open() function.\n   *      - encoding -- The file's encoding. Accepts the same values as the\n   *          builtin open() function.\n   *      - errors -- A string indicating how encoding and decoding errors are to\n   *          be handled. Accepts the same value as the builtin open() function.\n   */\n  constructor() {\n    let [flags, encoding, mode, autoClose, emitClose, start, end, highWaterMark, fs] = _parse_opts(arguments, {\n      flags: 'r',\n      encoding: undefined,\n      mode: undefined,\n      // 0o666\n      autoClose: undefined,\n      // true\n      emitClose: undefined,\n      // false\n      start: undefined,\n      // 0\n      end: undefined,\n      // Infinity\n      highWaterMark: undefined,\n      // 64 * 1024\n      fs: undefined\n    }); // when this class is called as a function, redirect it to .call() method of itself\n\n\n    super('return arguments.callee.call.apply(arguments.callee, arguments)');\n    Object.defineProperty(this, 'name', {\n      get() {\n        return sub('FileType(%r)', flags);\n      }\n\n    });\n    this._flags = flags;\n    this._options = {};\n    if (encoding !== undefined) this._options.encoding = encoding;\n    if (mode !== undefined) this._options.mode = mode;\n    if (autoClose !== undefined) this._options.autoClose = autoClose;\n    if (emitClose !== undefined) this._options.emitClose = emitClose;\n    if (start !== undefined) this._options.start = start;\n    if (end !== undefined) this._options.end = end;\n    if (highWaterMark !== undefined) this._options.highWaterMark = highWaterMark;\n    if (fs !== undefined) this._options.fs = fs;\n  }\n\n  call(string) {\n    // the special argument \"-\" means sys.std{in,out}\n    if (string === '-') {\n      if (this._flags.includes('r')) {\n        return process.stdin;\n      } else if (this._flags.includes('w')) {\n        return process.stdout;\n      } else {\n        let msg = sub('argument \"-\" with mode %r', this._flags);\n        throw new TypeError(msg);\n      }\n    } // all other arguments are used as file names\n\n\n    let fd;\n\n    try {\n      fd = fs.openSync(string, this._flags, this._options.mode);\n    } catch (e) {\n      let args = {\n        filename: string,\n        error: e.message\n      };\n      let message = \"can't open '%(filename)s': %(error)s\";\n      throw new ArgumentTypeError(sub(message, args));\n    }\n\n    let options = Object.assign({\n      fd,\n      flags: this._flags\n    }, this._options);\n\n    if (this._flags.includes('r')) {\n      return fs.createReadStream(undefined, options);\n    } else if (this._flags.includes('w')) {\n      return fs.createWriteStream(undefined, options);\n    } else {\n      let msg = sub('argument \"%s\" with mode %r', string, this._flags);\n      throw new TypeError(msg);\n    }\n  }\n\n  [util.inspect.custom]() {\n    let args = [this._flags];\n    let kwargs = Object.entries(this._options).map(_ref6 => {\n      let [k, v] = _ref6;\n      if (k === 'mode') v = {\n        value: v,\n\n        [util.inspect.custom]() {\n          return '0o' + this.value.toString(8);\n        }\n\n      };\n      return [k, v];\n    });\n    let args_str = [].concat(args.filter(arg => arg !== -1).map(repr)).concat(kwargs.filter(_ref7 => {\n      let [, arg] = _ref7;\n      return arg !== undefined;\n    }).map(_ref8 => {\n      let [kw, arg] = _ref8;\n      return sub('%s=%r', kw, arg);\n    })).join(', ');\n    return sub('%s(%s)', this.constructor.name, args_str);\n  }\n\n  toString() {\n    return this[util.inspect.custom]();\n  }\n\n}); // ===========================\n// Optional and Positional Parsing\n// ===========================\n\n\nconst Namespace = _callable(class Namespace extends _AttributeHolder() {\n  /*\n   *  Simple object for storing attributes.\n   *\n   *  Implements equality by attribute names and values, and provides a simple\n   *  string representation.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    Object.assign(this, options);\n  }\n\n}); // unset string tag to mimic plain object\n\n\nNamespace.prototype[Symbol.toStringTag] = undefined;\n\nconst _ActionsContainer = _camelcase_alias(_callable(class _ActionsContainer {\n  constructor() {\n    let [description, prefix_chars, argument_default, conflict_handler] = _parse_opts(arguments, {\n      description: no_default,\n      prefix_chars: no_default,\n      argument_default: no_default,\n      conflict_handler: no_default\n    });\n\n    this.description = description;\n    this.argument_default = argument_default;\n    this.prefix_chars = prefix_chars;\n    this.conflict_handler = conflict_handler; // set up registries\n\n    this._registries = {}; // register actions\n\n    this.register('action', undefined, _StoreAction);\n    this.register('action', 'store', _StoreAction);\n    this.register('action', 'store_const', _StoreConstAction);\n    this.register('action', 'store_true', _StoreTrueAction);\n    this.register('action', 'store_false', _StoreFalseAction);\n    this.register('action', 'append', _AppendAction);\n    this.register('action', 'append_const', _AppendConstAction);\n    this.register('action', 'count', _CountAction);\n    this.register('action', 'help', _HelpAction);\n    this.register('action', 'version', _VersionAction);\n    this.register('action', 'parsers', _SubParsersAction);\n    this.register('action', 'extend', _ExtendAction) // LEGACY (v1 compatibility): camelcase variants\n    ;\n    ['storeConst', 'storeTrue', 'storeFalse', 'appendConst'].forEach(old_name => {\n      let new_name = _to_new_name(old_name);\n\n      this.register('action', old_name, util.deprecate(this._registry_get('action', new_name), sub('{action: \"%s\"} is renamed to {action: \"%s\"}', old_name, new_name)));\n    }); // end\n    // raise an exception if the conflict handler is invalid\n\n    this._get_handler(); // action storage\n\n\n    this._actions = [];\n    this._option_string_actions = {}; // groups\n\n    this._action_groups = [];\n    this._mutually_exclusive_groups = []; // defaults storage\n\n    this._defaults = {}; // determines whether an \"option\" looks like a negative number\n\n    this._negative_number_matcher = /^-\\d+$|^-\\d*\\.\\d+$/; // whether or not there are any optionals that look like negative\n    // numbers -- uses a list so it can be shared and edited\n\n    this._has_negative_number_optionals = [];\n  } // ====================\n  // Registration methods\n  // ====================\n\n\n  register(registry_name, value, object) {\n    let registry = setdefault(this._registries, registry_name, {});\n    registry[value] = object;\n  }\n\n  _registry_get(registry_name, value) {\n    let default_value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    return getattr(this._registries[registry_name], value, default_value);\n  } // ==================================\n  // Namespace default accessor methods\n  // ==================================\n\n\n  set_defaults(kwargs) {\n    Object.assign(this._defaults, kwargs); // if these defaults match any existing arguments, replace\n    // the previous default on the object with the new one\n\n    for (let action of this._actions) {\n      if (action.dest in kwargs) {\n        action.default = kwargs[action.dest];\n      }\n    }\n  }\n\n  get_default(dest) {\n    for (let action of this._actions) {\n      if (action.dest === dest && action.default !== undefined) {\n        return action.default;\n      }\n    }\n\n    return this._defaults[dest];\n  } // =======================\n  // Adding argument actions\n  // =======================\n\n\n  add_argument() {\n    /*\n     *  add_argument(dest, ..., name=value, ...)\n     *  add_argument(option_string, option_string, ..., name=value, ...)\n     */\n    let [args, kwargs] = _parse_opts(arguments, {\n      '*args': no_default,\n      '**kwargs': no_default\n    }); // LEGACY (v1 compatibility), old-style add_argument([ args ], { options })\n\n\n    if (args.length === 1 && Array.isArray(args[0])) {\n      args = args[0];\n      deprecate('argument-array', sub('use add_argument(%(args)s, {...}) instead of add_argument([ %(args)s ], { ... })', {\n        args: args.map(repr).join(', ')\n      }));\n    } // end\n    // if no positional args are supplied or only one is supplied and\n    // it doesn't look like an option string, parse a positional\n    // argument\n\n\n    let chars = this.prefix_chars;\n\n    if (!args.length || args.length === 1 && !chars.includes(args[0][0])) {\n      if (args.length && 'dest' in kwargs) {\n        throw new TypeError('dest supplied twice for positional argument');\n      }\n\n      kwargs = this._get_positional_kwargs(...args, kwargs); // otherwise, we're adding an optional argument\n    } else {\n      kwargs = this._get_optional_kwargs(...args, kwargs);\n    } // if no default was supplied, use the parser-level default\n\n\n    if (!('default' in kwargs)) {\n      let dest = kwargs.dest;\n\n      if (dest in this._defaults) {\n        kwargs.default = this._defaults[dest];\n      } else if (this.argument_default !== undefined) {\n        kwargs.default = this.argument_default;\n      }\n    } // create the action object, and add it to the parser\n\n\n    let action_class = this._pop_action_class(kwargs);\n\n    if (typeof action_class !== 'function') {\n      throw new TypeError(sub('unknown action \"%s\"', action_class));\n    } // eslint-disable-next-line new-cap\n\n\n    let action = new action_class(kwargs); // raise an error if the action type is not callable\n\n    let type_func = this._registry_get('type', action.type, action.type);\n\n    if (typeof type_func !== 'function') {\n      throw new TypeError(sub('%r is not callable', type_func));\n    }\n\n    if (type_func === FileType) {\n      throw new TypeError(sub('%r is a FileType class object, instance of it' + ' must be passed', type_func));\n    } // raise an error if the metavar does not match the type\n\n\n    if ('_get_formatter' in this) {\n      try {\n        this._get_formatter()._format_args(action, undefined);\n      } catch (err) {\n        // check for 'invalid nargs value' is an artifact of TypeError and ValueError in js being the same\n        if (err instanceof TypeError && err.message !== 'invalid nargs value') {\n          throw new TypeError('length of metavar tuple does not match nargs');\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    return this._add_action(action);\n  }\n\n  add_argument_group() {\n    let group = _ArgumentGroup(this, ...arguments);\n\n    this._action_groups.push(group);\n\n    return group;\n  }\n\n  add_mutually_exclusive_group() {\n    // eslint-disable-next-line no-use-before-define\n    let group = _MutuallyExclusiveGroup(this, ...arguments);\n\n    this._mutually_exclusive_groups.push(group);\n\n    return group;\n  }\n\n  _add_action(action) {\n    // resolve any conflicts\n    this._check_conflict(action); // add to actions list\n\n\n    this._actions.push(action);\n\n    action.container = this; // index the action by any option strings it has\n\n    for (let option_string of action.option_strings) {\n      this._option_string_actions[option_string] = action;\n    } // set the flag if any option strings look like negative numbers\n\n\n    for (let option_string of action.option_strings) {\n      if (this._negative_number_matcher.test(option_string)) {\n        if (!this._has_negative_number_optionals.length) {\n          this._has_negative_number_optionals.push(true);\n        }\n      }\n    } // return the created action\n\n\n    return action;\n  }\n\n  _remove_action(action) {\n    _array_remove(this._actions, action);\n  }\n\n  _add_container_actions(container) {\n    // collect groups by titles\n    let title_group_map = {};\n\n    for (let group of this._action_groups) {\n      if (group.title in title_group_map) {\n        let msg = 'cannot merge actions - two groups are named %r';\n        throw new TypeError(sub(msg, group.title));\n      }\n\n      title_group_map[group.title] = group;\n    } // map each action to its group\n\n\n    let group_map = new Map();\n\n    for (let group of container._action_groups) {\n      // if a group with the title exists, use that, otherwise\n      // create a new group matching the container's group\n      if (!(group.title in title_group_map)) {\n        title_group_map[group.title] = this.add_argument_group({\n          title: group.title,\n          description: group.description,\n          conflict_handler: group.conflict_handler\n        });\n      } // map the actions to their new group\n\n\n      for (let action of group._group_actions) {\n        group_map.set(action, title_group_map[group.title]);\n      }\n    } // add container's mutually exclusive groups\n    // NOTE: if add_mutually_exclusive_group ever gains title= and\n    // description= then this code will need to be expanded as above\n\n\n    for (let group of container._mutually_exclusive_groups) {\n      let mutex_group = this.add_mutually_exclusive_group({\n        required: group.required\n      }); // map the actions to their new mutex group\n\n      for (let action of group._group_actions) {\n        group_map.set(action, mutex_group);\n      }\n    } // add all actions to this container or their group\n\n\n    for (let action of container._actions) {\n      group_map.get(action)._add_action(action);\n    }\n  }\n\n  _get_positional_kwargs() {\n    let [dest, kwargs] = _parse_opts(arguments, {\n      dest: no_default,\n      '**kwargs': no_default\n    }); // make sure required is not specified\n\n\n    if ('required' in kwargs) {\n      let msg = \"'required' is an invalid argument for positionals\";\n      throw new TypeError(msg);\n    } // mark positional arguments as required if at least one is\n    // always required\n\n\n    if (![OPTIONAL, ZERO_OR_MORE].includes(kwargs.nargs)) {\n      kwargs.required = true;\n    }\n\n    if (kwargs.nargs === ZERO_OR_MORE && !('default' in kwargs)) {\n      kwargs.required = true;\n    } // return the keyword arguments with no option strings\n\n\n    return Object.assign(kwargs, {\n      dest,\n      option_strings: []\n    });\n  }\n\n  _get_optional_kwargs() {\n    let [args, kwargs] = _parse_opts(arguments, {\n      '*args': no_default,\n      '**kwargs': no_default\n    }); // determine short and long option strings\n\n\n    let option_strings = [];\n    let long_option_strings = [];\n    let option_string;\n\n    for (option_string of args) {\n      // error on strings that don't start with an appropriate prefix\n      if (!this.prefix_chars.includes(option_string[0])) {\n        let args = {\n          option: option_string,\n          prefix_chars: this.prefix_chars\n        };\n        let msg = 'invalid option string %(option)r: ' + 'must start with a character %(prefix_chars)r';\n        throw new TypeError(sub(msg, args));\n      } // strings starting with two prefix characters are long options\n\n\n      option_strings.push(option_string);\n\n      if (option_string.length > 1 && this.prefix_chars.includes(option_string[1])) {\n        long_option_strings.push(option_string);\n      }\n    } // infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'\n\n\n    let dest = kwargs.dest;\n    delete kwargs.dest;\n\n    if (dest === undefined) {\n      let dest_option_string;\n\n      if (long_option_strings.length) {\n        dest_option_string = long_option_strings[0];\n      } else {\n        dest_option_string = option_strings[0];\n      }\n\n      dest = _string_lstrip(dest_option_string, this.prefix_chars);\n\n      if (!dest) {\n        let msg = 'dest= is required for options like %r';\n        throw new TypeError(sub(msg, option_string));\n      }\n\n      dest = dest.replace(/-/g, '_');\n    } // return the updated keyword arguments\n\n\n    return Object.assign(kwargs, {\n      dest,\n      option_strings\n    });\n  }\n\n  _pop_action_class(kwargs) {\n    let default_value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let action = getattr(kwargs, 'action', default_value);\n    delete kwargs.action;\n    return this._registry_get('action', action, action);\n  }\n\n  _get_handler() {\n    // determine function from conflict handler string\n    let handler_func_name = sub('_handle_conflict_%s', this.conflict_handler);\n\n    if (typeof this[handler_func_name] === 'function') {\n      return this[handler_func_name];\n    } else {\n      let msg = 'invalid conflict_resolution value: %r';\n      throw new TypeError(sub(msg, this.conflict_handler));\n    }\n  }\n\n  _check_conflict(action) {\n    // find all options that conflict with this option\n    let confl_optionals = [];\n\n    for (let option_string of action.option_strings) {\n      if (hasattr(this._option_string_actions, option_string)) {\n        let confl_optional = this._option_string_actions[option_string];\n        confl_optionals.push([option_string, confl_optional]);\n      }\n    } // resolve any conflicts\n\n\n    if (confl_optionals.length) {\n      let conflict_handler = this._get_handler();\n\n      conflict_handler.call(this, action, confl_optionals);\n    }\n  }\n\n  _handle_conflict_error(action, conflicting_actions) {\n    let message = conflicting_actions.length === 1 ? 'conflicting option string: %s' : 'conflicting option strings: %s';\n    let conflict_string = conflicting_actions.map(_ref9 => {\n      let [option_string\n      /*, action*/\n      ] = _ref9;\n      return option_string;\n    }).join(', ');\n    throw new ArgumentError(action, sub(message, conflict_string));\n  }\n\n  _handle_conflict_resolve(action, conflicting_actions) {\n    // remove all conflicting options\n    for (let [option_string, action] of conflicting_actions) {\n      // remove the conflicting option\n      _array_remove(action.option_strings, option_string);\n\n      delete this._option_string_actions[option_string]; // if the option now has no option string, remove it from the\n      // container holding it\n\n      if (!action.option_strings.length) {\n        action.container._remove_action(action);\n      }\n    }\n  }\n\n}));\n\nconst _ArgumentGroup = _callable(class _ArgumentGroup extends _ActionsContainer {\n  constructor() {\n    let [container, title, description, kwargs] = _parse_opts(arguments, {\n      container: no_default,\n      title: undefined,\n      description: undefined,\n      '**kwargs': no_default\n    }); // add any missing keyword arguments by checking the container\n\n\n    setdefault(kwargs, 'conflict_handler', container.conflict_handler);\n    setdefault(kwargs, 'prefix_chars', container.prefix_chars);\n    setdefault(kwargs, 'argument_default', container.argument_default);\n    super(Object.assign({\n      description\n    }, kwargs)); // group attributes\n\n    this.title = title;\n    this._group_actions = []; // share most attributes with the container\n\n    this._registries = container._registries;\n    this._actions = container._actions;\n    this._option_string_actions = container._option_string_actions;\n    this._defaults = container._defaults;\n    this._has_negative_number_optionals = container._has_negative_number_optionals;\n    this._mutually_exclusive_groups = container._mutually_exclusive_groups;\n  }\n\n  _add_action(action) {\n    action = super._add_action(action);\n\n    this._group_actions.push(action);\n\n    return action;\n  }\n\n  _remove_action(action) {\n    super._remove_action(action);\n\n    _array_remove(this._group_actions, action);\n  }\n\n});\n\nconst _MutuallyExclusiveGroup = _callable(class _MutuallyExclusiveGroup extends _ArgumentGroup {\n  constructor() {\n    let [container, required] = _parse_opts(arguments, {\n      container: no_default,\n      required: false\n    });\n\n    super(container);\n    this.required = required;\n    this._container = container;\n  }\n\n  _add_action(action) {\n    if (action.required) {\n      let msg = 'mutually exclusive arguments must be optional';\n      throw new TypeError(msg);\n    }\n\n    action = this._container._add_action(action);\n\n    this._group_actions.push(action);\n\n    return action;\n  }\n\n  _remove_action(action) {\n    this._container._remove_action(action);\n\n    _array_remove(this._group_actions, action);\n  }\n\n});\n\nconst ArgumentParser = _camelcase_alias(_callable(class ArgumentParser extends _AttributeHolder(_ActionsContainer) {\n  /*\n   *  Object for parsing command line strings into Python objects.\n   *\n   *  Keyword Arguments:\n   *      - prog -- The name of the program (default: sys.argv[0])\n   *      - usage -- A usage message (default: auto-generated from arguments)\n   *      - description -- A description of what the program does\n   *      - epilog -- Text following the argument descriptions\n   *      - parents -- Parsers whose arguments should be copied into this one\n   *      - formatter_class -- HelpFormatter class for printing help messages\n   *      - prefix_chars -- Characters that prefix optional arguments\n   *      - fromfile_prefix_chars -- Characters that prefix files containing\n   *          additional arguments\n   *      - argument_default -- The default value for all arguments\n   *      - conflict_handler -- String indicating how to handle conflicts\n   *      - add_help -- Add a -h/-help option\n   *      - allow_abbrev -- Allow long options to be abbreviated unambiguously\n   *      - exit_on_error -- Determines whether or not ArgumentParser exits with\n   *          error info when an error occurs\n   */\n  constructor() {\n    let [prog, usage, description, epilog, parents, formatter_class, prefix_chars, fromfile_prefix_chars, argument_default, conflict_handler, add_help, allow_abbrev, exit_on_error, debug, // LEGACY (v1 compatibility), debug mode\n    version // LEGACY (v1 compatibility), version\n    ] = _parse_opts(arguments, {\n      prog: undefined,\n      usage: undefined,\n      description: undefined,\n      epilog: undefined,\n      parents: [],\n      formatter_class: HelpFormatter,\n      prefix_chars: '-',\n      fromfile_prefix_chars: undefined,\n      argument_default: undefined,\n      conflict_handler: 'error',\n      add_help: true,\n      allow_abbrev: true,\n      exit_on_error: true,\n      debug: undefined,\n      // LEGACY (v1 compatibility), debug mode\n      version: undefined // LEGACY (v1 compatibility), version\n\n    }); // LEGACY (v1 compatibility)\n\n\n    if (debug !== undefined) {\n      deprecate('debug', 'The \"debug\" argument to ArgumentParser is deprecated. Please ' + 'override ArgumentParser.exit function instead.');\n    }\n\n    if (version !== undefined) {\n      deprecate('version', 'The \"version\" argument to ArgumentParser is deprecated. Please use ' + \"add_argument(..., { action: 'version', version: 'N', ... }) instead.\");\n    } // end\n\n\n    super({\n      description,\n      prefix_chars,\n      argument_default,\n      conflict_handler\n    }); // default setting for prog\n\n    if (prog === undefined) {\n      prog = path.basename(get_argv()[0] || '');\n    }\n\n    this.prog = prog;\n    this.usage = usage;\n    this.epilog = epilog;\n    this.formatter_class = formatter_class;\n    this.fromfile_prefix_chars = fromfile_prefix_chars;\n    this.add_help = add_help;\n    this.allow_abbrev = allow_abbrev;\n    this.exit_on_error = exit_on_error; // LEGACY (v1 compatibility), debug mode\n\n    this.debug = debug; // end\n\n    this._positionals = this.add_argument_group('positional arguments');\n    this._optionals = this.add_argument_group('optional arguments');\n    this._subparsers = undefined; // register types\n\n    function identity(string) {\n      return string;\n    }\n\n    this.register('type', undefined, identity);\n    this.register('type', null, identity);\n    this.register('type', 'auto', identity);\n    this.register('type', 'int', function (x) {\n      let result = Number(x);\n\n      if (!Number.isInteger(result)) {\n        throw new TypeError(sub('could not convert string to int: %r', x));\n      }\n\n      return result;\n    });\n    this.register('type', 'float', function (x) {\n      let result = Number(x);\n\n      if (isNaN(result)) {\n        throw new TypeError(sub('could not convert string to float: %r', x));\n      }\n\n      return result;\n    });\n    this.register('type', 'str', String); // LEGACY (v1 compatibility): custom types\n\n    this.register('type', 'string', util.deprecate(String, 'use {type:\"str\"} or {type:String} instead of {type:\"string\"}')); // end\n    // add help argument if necessary\n    // (using explicit default to override global argument_default)\n\n    let default_prefix = prefix_chars.includes('-') ? '-' : prefix_chars[0];\n\n    if (this.add_help) {\n      this.add_argument(default_prefix + 'h', default_prefix.repeat(2) + 'help', {\n        action: 'help',\n        default: SUPPRESS,\n        help: 'show this help message and exit'\n      });\n    } // LEGACY (v1 compatibility), version\n\n\n    if (version) {\n      this.add_argument(default_prefix + 'v', default_prefix.repeat(2) + 'version', {\n        action: 'version',\n        default: SUPPRESS,\n        version: this.version,\n        help: \"show program's version number and exit\"\n      });\n    } // end\n    // add parent arguments and defaults\n\n\n    for (let parent of parents) {\n      this._add_container_actions(parent);\n\n      Object.assign(this._defaults, parent._defaults);\n    }\n  } // =======================\n  // Pretty __repr__ methods\n  // =======================\n\n\n  _get_kwargs() {\n    let names = ['prog', 'usage', 'description', 'formatter_class', 'conflict_handler', 'add_help'];\n    return names.map(name => [name, getattr(this, name)]);\n  } // ==================================\n  // Optional/Positional adding methods\n  // ==================================\n\n\n  add_subparsers() {\n    let [kwargs] = _parse_opts(arguments, {\n      '**kwargs': no_default\n    });\n\n    if (this._subparsers !== undefined) {\n      this.error('cannot have multiple subparser arguments');\n    } // add the parser class to the arguments if it's not present\n\n\n    setdefault(kwargs, 'parser_class', this.constructor);\n\n    if ('title' in kwargs || 'description' in kwargs) {\n      let title = getattr(kwargs, 'title', 'subcommands');\n      let description = getattr(kwargs, 'description', undefined);\n      delete kwargs.title;\n      delete kwargs.description;\n      this._subparsers = this.add_argument_group(title, description);\n    } else {\n      this._subparsers = this._positionals;\n    } // prog defaults to the usage message of this parser, skipping\n    // optional arguments and with no \"usage:\" prefix\n\n\n    if (kwargs.prog === undefined) {\n      let formatter = this._get_formatter();\n\n      let positionals = this._get_positional_actions();\n\n      let groups = this._mutually_exclusive_groups;\n      formatter.add_usage(this.usage, positionals, groups, '');\n      kwargs.prog = formatter.format_help().trim();\n    } // create the parsers action and add it to the positionals list\n\n\n    let parsers_class = this._pop_action_class(kwargs, 'parsers'); // eslint-disable-next-line new-cap\n\n\n    let action = new parsers_class(Object.assign({\n      option_strings: []\n    }, kwargs));\n\n    this._subparsers._add_action(action); // return the created parsers action\n\n\n    return action;\n  }\n\n  _add_action(action) {\n    if (action.option_strings.length) {\n      this._optionals._add_action(action);\n    } else {\n      this._positionals._add_action(action);\n    }\n\n    return action;\n  }\n\n  _get_optional_actions() {\n    return this._actions.filter(action => action.option_strings.length);\n  }\n\n  _get_positional_actions() {\n    return this._actions.filter(action => !action.option_strings.length);\n  } // =====================================\n  // Command line argument parsing methods\n  // =====================================\n\n\n  parse_args() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let argv;\n    [args, argv] = this.parse_known_args(args, namespace);\n\n    if (argv && argv.length > 0) {\n      let msg = 'unrecognized arguments: %s';\n      this.error(sub(msg, argv.join(' ')));\n    }\n\n    return args;\n  }\n\n  parse_known_args() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n    if (args === undefined) {\n      args = get_argv().slice(1);\n    } // default Namespace built from parser defaults\n\n\n    if (namespace === undefined) {\n      namespace = new Namespace();\n    } // add any action defaults that aren't present\n\n\n    for (let action of this._actions) {\n      if (action.dest !== SUPPRESS) {\n        if (!hasattr(namespace, action.dest)) {\n          if (action.default !== SUPPRESS) {\n            setattr(namespace, action.dest, action.default);\n          }\n        }\n      }\n    } // add any parser defaults that aren't present\n\n\n    for (let dest of Object.keys(this._defaults)) {\n      if (!hasattr(namespace, dest)) {\n        setattr(namespace, dest, this._defaults[dest]);\n      }\n    } // parse the arguments and exit if there are any errors\n\n\n    if (this.exit_on_error) {\n      try {\n        [namespace, args] = this._parse_known_args(args, namespace);\n      } catch (err) {\n        if (err instanceof ArgumentError) {\n          this.error(err.message);\n        } else {\n          throw err;\n        }\n      }\n    } else {\n      [namespace, args] = this._parse_known_args(args, namespace);\n    }\n\n    if (hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR)) {\n      args = args.concat(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR));\n      delattr(namespace, _UNRECOGNIZED_ARGS_ATTR);\n    }\n\n    return [namespace, args];\n  }\n\n  _parse_known_args(arg_strings, namespace) {\n    var _this = this;\n\n    // replace arg strings that are file references\n    if (this.fromfile_prefix_chars !== undefined) {\n      arg_strings = this._read_args_from_files(arg_strings);\n    } // map all mutually exclusive arguments to the other arguments\n    // they can't occur with\n\n\n    let action_conflicts = new Map();\n\n    for (let mutex_group of this._mutually_exclusive_groups) {\n      let group_actions = mutex_group._group_actions;\n\n      for (let [i, mutex_action] of Object.entries(mutex_group._group_actions)) {\n        let conflicts = action_conflicts.get(mutex_action) || [];\n        conflicts = conflicts.concat(group_actions.slice(0, +i));\n        conflicts = conflicts.concat(group_actions.slice(+i + 1));\n        action_conflicts.set(mutex_action, conflicts);\n      }\n    } // find all option indices, and determine the arg_string_pattern\n    // which has an 'O' if there is an option at an index,\n    // an 'A' if there is an argument, or a '-' if there is a '--'\n\n\n    let option_string_indices = {};\n    let arg_string_pattern_parts = [];\n    let arg_strings_iter = Object.entries(arg_strings)[Symbol.iterator]();\n\n    for (let [i, arg_string] of arg_strings_iter) {\n      // all args after -- are non-options\n      if (arg_string === '--') {\n        arg_string_pattern_parts.push('-');\n\n        for ([i, arg_string] of arg_strings_iter) {\n          arg_string_pattern_parts.push('A');\n        } // otherwise, add the arg to the arg strings\n        // and note the index if it was an option\n\n      } else {\n        let option_tuple = this._parse_optional(arg_string);\n\n        let pattern;\n\n        if (option_tuple === undefined) {\n          pattern = 'A';\n        } else {\n          option_string_indices[i] = option_tuple;\n          pattern = 'O';\n        }\n\n        arg_string_pattern_parts.push(pattern);\n      }\n    } // join the pieces together to form the pattern\n\n\n    let arg_strings_pattern = arg_string_pattern_parts.join(''); // converts arg strings to the appropriate and then takes the action\n\n    let seen_actions = new Set();\n    let seen_non_default_actions = new Set();\n    let extras;\n\n    let take_action = function (action, argument_strings) {\n      let option_string = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      seen_actions.add(action);\n\n      let argument_values = _this._get_values(action, argument_strings); // error if this argument is not allowed with other previously\n      // seen arguments, assuming that actions that use the default\n      // value don't really count as \"present\"\n\n\n      if (argument_values !== action.default) {\n        seen_non_default_actions.add(action);\n\n        for (let conflict_action of action_conflicts.get(action) || []) {\n          if (seen_non_default_actions.has(conflict_action)) {\n            let msg = 'not allowed with argument %s';\n\n            let action_name = _get_action_name(conflict_action);\n\n            throw new ArgumentError(action, sub(msg, action_name));\n          }\n        }\n      } // take the action if we didn't receive a SUPPRESS value\n      // (e.g. from a default)\n\n\n      if (argument_values !== SUPPRESS) {\n        action(_this, namespace, argument_values, option_string);\n      }\n    }; // function to convert arg_strings into an optional action\n\n\n    let consume_optional = start_index => {\n      // get the optional identified at this index\n      let option_tuple = option_string_indices[start_index];\n      let [action, option_string, explicit_arg] = option_tuple; // identify additional optionals in the same arg string\n      // (e.g. -xyz is the same as -x -y -z if no args are required)\n\n      let action_tuples = [];\n      let stop;\n\n      for (;;) {\n        // if we found no optional action, skip it\n        if (action === undefined) {\n          extras.push(arg_strings[start_index]);\n          return start_index + 1;\n        } // if there is an explicit argument, try to match the\n        // optional's string arguments to only this\n\n\n        if (explicit_arg !== undefined) {\n          let arg_count = this._match_argument(action, 'A'); // if the action is a single-dash option and takes no\n          // arguments, try to parse more single-dash options out\n          // of the tail of the option string\n\n\n          let chars = this.prefix_chars;\n\n          if (arg_count === 0 && !chars.includes(option_string[1])) {\n            action_tuples.push([action, [], option_string]);\n            let char = option_string[0];\n            option_string = char + explicit_arg[0];\n            let new_explicit_arg = explicit_arg.slice(1) || undefined;\n            let optionals_map = this._option_string_actions;\n\n            if (hasattr(optionals_map, option_string)) {\n              action = optionals_map[option_string];\n              explicit_arg = new_explicit_arg;\n            } else {\n              let msg = 'ignored explicit argument %r';\n              throw new ArgumentError(action, sub(msg, explicit_arg));\n            } // if the action expect exactly one argument, we've\n            // successfully matched the option; exit the loop\n\n          } else if (arg_count === 1) {\n            stop = start_index + 1;\n            let args = [explicit_arg];\n            action_tuples.push([action, args, option_string]);\n            break; // error if a double-dash option did not use the\n            // explicit argument\n          } else {\n            let msg = 'ignored explicit argument %r';\n            throw new ArgumentError(action, sub(msg, explicit_arg));\n          } // if there is no explicit argument, try to match the\n          // optional's string arguments with the following strings\n          // if successful, exit the loop\n\n        } else {\n          let start = start_index + 1;\n          let selected_patterns = arg_strings_pattern.slice(start);\n\n          let arg_count = this._match_argument(action, selected_patterns);\n\n          stop = start + arg_count;\n          let args = arg_strings.slice(start, stop);\n          action_tuples.push([action, args, option_string]);\n          break;\n        }\n      } // add the Optional to the list and return the index at which\n      // the Optional's string args stopped\n\n\n      assert(action_tuples.length);\n\n      for (let [action, args, option_string] of action_tuples) {\n        take_action(action, args, option_string);\n      }\n\n      return stop;\n    }; // the list of Positionals left to be parsed; this is modified\n    // by consume_positionals()\n\n\n    let positionals = this._get_positional_actions(); // function to convert arg_strings into positional actions\n\n\n    let consume_positionals = start_index => {\n      // match as many Positionals as possible\n      let selected_pattern = arg_strings_pattern.slice(start_index);\n\n      let arg_counts = this._match_arguments_partial(positionals, selected_pattern); // slice off the appropriate arg strings for each Positional\n      // and add the Positional and its args to the list\n\n\n      for (let i = 0; i < positionals.length && i < arg_counts.length; i++) {\n        let action = positionals[i];\n        let arg_count = arg_counts[i];\n        let args = arg_strings.slice(start_index, start_index + arg_count);\n        start_index += arg_count;\n        take_action(action, args);\n      } // slice off the Positionals that we just parsed and return the\n      // index at which the Positionals' string args stopped\n\n\n      positionals = positionals.slice(arg_counts.length);\n      return start_index;\n    }; // consume Positionals and Optionals alternately, until we have\n    // passed the last option string\n\n\n    extras = [];\n    let start_index = 0;\n    let max_option_string_index = Math.max(-1, ...Object.keys(option_string_indices).map(Number));\n\n    while (start_index <= max_option_string_index) {\n      // consume any Positionals preceding the next option\n      let next_option_string_index = Math.min( // eslint-disable-next-line no-loop-func\n      ...Object.keys(option_string_indices).map(Number).filter(index => index >= start_index));\n\n      if (start_index !== next_option_string_index) {\n        let positionals_end_index = consume_positionals(start_index); // only try to parse the next optional if we didn't consume\n        // the option string during the positionals parsing\n\n        if (positionals_end_index > start_index) {\n          start_index = positionals_end_index;\n          continue;\n        } else {\n          start_index = positionals_end_index;\n        }\n      } // if we consumed all the positionals we could and we're not\n      // at the index of an option string, there were extra arguments\n\n\n      if (!(start_index in option_string_indices)) {\n        let strings = arg_strings.slice(start_index, next_option_string_index);\n        extras = extras.concat(strings);\n        start_index = next_option_string_index;\n      } // consume the next optional and any arguments for it\n\n\n      start_index = consume_optional(start_index);\n    } // consume any positionals following the last Optional\n\n\n    let stop_index = consume_positionals(start_index); // if we didn't consume all the argument strings, there were extras\n\n    extras = extras.concat(arg_strings.slice(stop_index)); // make sure all required actions were present and also convert\n    // action defaults which were not given as arguments\n\n    let required_actions = [];\n\n    for (let action of this._actions) {\n      if (!seen_actions.has(action)) {\n        if (action.required) {\n          required_actions.push(_get_action_name(action));\n        } else {\n          // Convert action default now instead of doing it before\n          // parsing arguments to avoid calling convert functions\n          // twice (which may fail) if the argument was given, but\n          // only if it was defined already in the namespace\n          if (action.default !== undefined && typeof action.default === 'string' && hasattr(namespace, action.dest) && action.default === getattr(namespace, action.dest)) {\n            setattr(namespace, action.dest, this._get_value(action, action.default));\n          }\n        }\n      }\n    }\n\n    if (required_actions.length) {\n      this.error(sub('the following arguments are required: %s', required_actions.join(', ')));\n    } // make sure all required groups had one option present\n\n\n    for (let group of this._mutually_exclusive_groups) {\n      if (group.required) {\n        let no_actions_used = true;\n\n        for (let action of group._group_actions) {\n          if (seen_non_default_actions.has(action)) {\n            no_actions_used = false;\n            break;\n          }\n        } // if no actions were used, report the error\n\n\n        if (no_actions_used) {\n          let names = group._group_actions.filter(action => action.help !== SUPPRESS).map(action => _get_action_name(action));\n\n          let msg = 'one of the arguments %s is required';\n          this.error(sub(msg, names.join(' ')));\n        }\n      }\n    } // return the updated namespace and the extra arguments\n\n\n    return [namespace, extras];\n  }\n\n  _read_args_from_files(arg_strings) {\n    // expand arguments referencing files\n    let new_arg_strings = [];\n\n    for (let arg_string of arg_strings) {\n      // for regular arguments, just add them back into the list\n      if (!arg_string || !this.fromfile_prefix_chars.includes(arg_string[0])) {\n        new_arg_strings.push(arg_string); // replace arguments referencing files with the file content\n      } else {\n        try {\n          let args_file = fs.readFileSync(arg_string.slice(1), 'utf8');\n          let arg_strings = [];\n\n          for (let arg_line of splitlines(args_file)) {\n            for (let arg of this.convert_arg_line_to_args(arg_line)) {\n              arg_strings.push(arg);\n            }\n          }\n\n          arg_strings = this._read_args_from_files(arg_strings);\n          new_arg_strings = new_arg_strings.concat(arg_strings);\n        } catch (err) {\n          this.error(err.message);\n        }\n      }\n    } // return the modified argument list\n\n\n    return new_arg_strings;\n  }\n\n  convert_arg_line_to_args(arg_line) {\n    return [arg_line];\n  }\n\n  _match_argument(action, arg_strings_pattern) {\n    // match the pattern for this action to the arg strings\n    let nargs_pattern = this._get_nargs_pattern(action);\n\n    let match = arg_strings_pattern.match(new RegExp('^' + nargs_pattern)); // raise an exception if we weren't able to find a match\n\n    if (match === null) {\n      let nargs_errors = {\n        undefined: 'expected one argument',\n        [OPTIONAL]: 'expected at most one argument',\n        [ONE_OR_MORE]: 'expected at least one argument'\n      };\n      let msg = nargs_errors[action.nargs];\n\n      if (msg === undefined) {\n        msg = sub(action.nargs === 1 ? 'expected %s argument' : 'expected %s arguments', action.nargs);\n      }\n\n      throw new ArgumentError(action, msg);\n    } // return the number of arguments matched\n\n\n    return match[1].length;\n  }\n\n  _match_arguments_partial(actions, arg_strings_pattern) {\n    // progressively shorten the actions list by slicing off the\n    // final actions until we find a match\n    let result = [];\n\n    for (let i of range(actions.length, 0, -1)) {\n      let actions_slice = actions.slice(0, i);\n      let pattern = actions_slice.map(action => this._get_nargs_pattern(action)).join('');\n      let match = arg_strings_pattern.match(new RegExp('^' + pattern));\n\n      if (match !== null) {\n        result = result.concat(match.slice(1).map(string => string.length));\n        break;\n      }\n    } // return the list of arg string counts\n\n\n    return result;\n  }\n\n  _parse_optional(arg_string) {\n    // if it's an empty string, it was meant to be a positional\n    if (!arg_string) {\n      return undefined;\n    } // if it doesn't start with a prefix, it was meant to be positional\n\n\n    if (!this.prefix_chars.includes(arg_string[0])) {\n      return undefined;\n    } // if the option string is present in the parser, return the action\n\n\n    if (arg_string in this._option_string_actions) {\n      let action = this._option_string_actions[arg_string];\n      return [action, arg_string, undefined];\n    } // if it's just a single character, it was meant to be positional\n\n\n    if (arg_string.length === 1) {\n      return undefined;\n    } // if the option string before the \"=\" is present, return the action\n\n\n    if (arg_string.includes('=')) {\n      let [option_string, explicit_arg] = _string_split(arg_string, '=', 1);\n\n      if (option_string in this._option_string_actions) {\n        let action = this._option_string_actions[option_string];\n        return [action, option_string, explicit_arg];\n      }\n    } // search through all possible prefixes of the option string\n    // and all actions in the parser for possible interpretations\n\n\n    let option_tuples = this._get_option_tuples(arg_string); // if multiple actions match, the option string was ambiguous\n\n\n    if (option_tuples.length > 1) {\n      let options = option_tuples.map(_ref10 => {\n        let [, option_string\n        /*, explicit_arg*/\n        ] = _ref10;\n        return option_string;\n      }).join(', ');\n      let args = {\n        option: arg_string,\n        matches: options\n      };\n      let msg = 'ambiguous option: %(option)s could match %(matches)s';\n      this.error(sub(msg, args)); // if exactly one action matched, this segmentation is good,\n      // so return the parsed action\n    } else if (option_tuples.length === 1) {\n      let [option_tuple] = option_tuples;\n      return option_tuple;\n    } // if it was not found as an option, but it looks like a negative\n    // number, it was meant to be positional\n    // unless there are negative-number-like options\n\n\n    if (this._negative_number_matcher.test(arg_string)) {\n      if (!this._has_negative_number_optionals.length) {\n        return undefined;\n      }\n    } // if it contains a space, it was meant to be a positional\n\n\n    if (arg_string.includes(' ')) {\n      return undefined;\n    } // it was meant to be an optional but there is no such option\n    // in this parser (though it might be a valid option in a subparser)\n\n\n    return [undefined, arg_string, undefined];\n  }\n\n  _get_option_tuples(option_string) {\n    let result = []; // option strings starting with two prefix characters are only\n    // split at the '='\n\n    let chars = this.prefix_chars;\n\n    if (chars.includes(option_string[0]) && chars.includes(option_string[1])) {\n      if (this.allow_abbrev) {\n        let option_prefix, explicit_arg;\n\n        if (option_string.includes('=')) {\n          [option_prefix, explicit_arg] = _string_split(option_string, '=', 1);\n        } else {\n          option_prefix = option_string;\n          explicit_arg = undefined;\n        }\n\n        for (let option_string of Object.keys(this._option_string_actions)) {\n          if (option_string.startsWith(option_prefix)) {\n            let action = this._option_string_actions[option_string];\n            let tup = [action, option_string, explicit_arg];\n            result.push(tup);\n          }\n        }\n      } // single character options can be concatenated with their arguments\n      // but multiple character options always have to have their argument\n      // separate\n\n    } else if (chars.includes(option_string[0]) && !chars.includes(option_string[1])) {\n      let option_prefix = option_string;\n      let explicit_arg = undefined;\n      let short_option_prefix = option_string.slice(0, 2);\n      let short_explicit_arg = option_string.slice(2);\n\n      for (let option_string of Object.keys(this._option_string_actions)) {\n        if (option_string === short_option_prefix) {\n          let action = this._option_string_actions[option_string];\n          let tup = [action, option_string, short_explicit_arg];\n          result.push(tup);\n        } else if (option_string.startsWith(option_prefix)) {\n          let action = this._option_string_actions[option_string];\n          let tup = [action, option_string, explicit_arg];\n          result.push(tup);\n        }\n      } // shouldn't ever get here\n\n    } else {\n      this.error(sub('unexpected option string: %s', option_string));\n    } // return the collected option tuples\n\n\n    return result;\n  }\n\n  _get_nargs_pattern(action) {\n    // in all examples below, we have to allow for '--' args\n    // which are represented as '-' in the pattern\n    let nargs = action.nargs;\n    let nargs_pattern; // the default (None) is assumed to be a single argument\n\n    if (nargs === undefined) {\n      nargs_pattern = '(-*A-*)'; // allow zero or one arguments\n    } else if (nargs === OPTIONAL) {\n      nargs_pattern = '(-*A?-*)'; // allow zero or more arguments\n    } else if (nargs === ZERO_OR_MORE) {\n      nargs_pattern = '(-*[A-]*)'; // allow one or more arguments\n    } else if (nargs === ONE_OR_MORE) {\n      nargs_pattern = '(-*A[A-]*)'; // allow any number of options or arguments\n    } else if (nargs === REMAINDER) {\n      nargs_pattern = '([-AO]*)'; // allow one argument followed by any number of options or arguments\n    } else if (nargs === PARSER) {\n      nargs_pattern = '(-*A[-AO]*)'; // suppress action, like nargs=0\n    } else if (nargs === SUPPRESS) {\n      nargs_pattern = '(-*-*)'; // all others should be integers\n    } else {\n      nargs_pattern = sub('(-*%s-*)', 'A'.repeat(nargs).split('').join('-*'));\n    } // if this is an optional action, -- is not allowed\n\n\n    if (action.option_strings.length) {\n      nargs_pattern = nargs_pattern.replace(/-\\*/g, '');\n      nargs_pattern = nargs_pattern.replace(/-/g, '');\n    } // return the pattern\n\n\n    return nargs_pattern;\n  } // ========================\n  // Alt command line argument parsing, allowing free intermix\n  // ========================\n\n\n  parse_intermixed_args() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let argv;\n    [args, argv] = this.parse_known_intermixed_args(args, namespace);\n\n    if (argv.length) {\n      let msg = 'unrecognized arguments: %s';\n      this.error(sub(msg, argv.join(' ')));\n    }\n\n    return args;\n  }\n\n  parse_known_intermixed_args() {\n    let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    // returns a namespace and list of extras\n    //\n    // positional can be freely intermixed with optionals.  optionals are\n    // first parsed with all positional arguments deactivated.  The 'extras'\n    // are then parsed.  If the parser definition is incompatible with the\n    // intermixed assumptions (e.g. use of REMAINDER, subparsers) a\n    // TypeError is raised.\n    //\n    // positionals are 'deactivated' by setting nargs and default to\n    // SUPPRESS.  This blocks the addition of that positional to the\n    // namespace\n    let extras;\n\n    let positionals = this._get_positional_actions();\n\n    let a = positionals.filter(action => [PARSER, REMAINDER].includes(action.nargs));\n\n    if (a.length) {\n      throw new TypeError(sub('parse_intermixed_args: positional arg' + ' with nargs=%s', a[0].nargs));\n    }\n\n    for (let group of this._mutually_exclusive_groups) {\n      for (let action of group._group_actions) {\n        if (positionals.includes(action)) {\n          throw new TypeError('parse_intermixed_args: positional in' + ' mutuallyExclusiveGroup');\n        }\n      }\n    }\n\n    let save_usage;\n\n    try {\n      save_usage = this.usage;\n      let remaining_args;\n\n      try {\n        if (this.usage === undefined) {\n          // capture the full usage for use in error messages\n          this.usage = this.format_usage().slice(7);\n        }\n\n        for (let action of positionals) {\n          // deactivate positionals\n          action.save_nargs = action.nargs; // action.nargs = 0\n\n          action.nargs = SUPPRESS;\n          action.save_default = action.default;\n          action.default = SUPPRESS;\n        }\n\n        [namespace, remaining_args] = this.parse_known_args(args, namespace);\n\n        for (let action of positionals) {\n          // remove the empty positional values from namespace\n          let attr = getattr(namespace, action.dest);\n\n          if (Array.isArray(attr) && attr.length === 0) {\n            // eslint-disable-next-line no-console\n            console.warn(sub('Do not expect %s in %s', action.dest, namespace));\n            delattr(namespace, action.dest);\n          }\n        }\n      } finally {\n        // restore nargs and usage before exiting\n        for (let action of positionals) {\n          action.nargs = action.save_nargs;\n          action.default = action.save_default;\n        }\n      }\n\n      let optionals = this._get_optional_actions();\n\n      try {\n        // parse positionals.  optionals aren't normally required, but\n        // they could be, so make sure they aren't.\n        for (let action of optionals) {\n          action.save_required = action.required;\n          action.required = false;\n        }\n\n        for (let group of this._mutually_exclusive_groups) {\n          group.save_required = group.required;\n          group.required = false;\n        }\n\n        [namespace, extras] = this.parse_known_args(remaining_args, namespace);\n      } finally {\n        // restore parser values before exiting\n        for (let action of optionals) {\n          action.required = action.save_required;\n        }\n\n        for (let group of this._mutually_exclusive_groups) {\n          group.required = group.save_required;\n        }\n      }\n    } finally {\n      this.usage = save_usage;\n    }\n\n    return [namespace, extras];\n  } // ========================\n  // Value conversion methods\n  // ========================\n\n\n  _get_values(action, arg_strings) {\n    // for everything but PARSER, REMAINDER args, strip out first '--'\n    if (![PARSER, REMAINDER].includes(action.nargs)) {\n      try {\n        _array_remove(arg_strings, '--');\n      } catch (err) {}\n    }\n\n    let value; // optional argument produces a default when not present\n\n    if (!arg_strings.length && action.nargs === OPTIONAL) {\n      if (action.option_strings.length) {\n        value = action.const;\n      } else {\n        value = action.default;\n      }\n\n      if (typeof value === 'string') {\n        value = this._get_value(action, value);\n\n        this._check_value(action, value);\n      } // when nargs='*' on a positional, if there were no command-line\n      // args, use the default if it is anything other than None\n\n    } else if (!arg_strings.length && action.nargs === ZERO_OR_MORE && !action.option_strings.length) {\n      if (action.default !== undefined) {\n        value = action.default;\n      } else {\n        value = arg_strings;\n      }\n\n      this._check_value(action, value); // single argument or optional argument produces a single value\n\n    } else if (arg_strings.length === 1 && [undefined, OPTIONAL].includes(action.nargs)) {\n      let arg_string = arg_strings[0];\n      value = this._get_value(action, arg_string);\n\n      this._check_value(action, value); // REMAINDER arguments convert all values, checking none\n\n    } else if (action.nargs === REMAINDER) {\n      value = arg_strings.map(v => this._get_value(action, v)); // PARSER arguments convert all values, but check only the first\n    } else if (action.nargs === PARSER) {\n      value = arg_strings.map(v => this._get_value(action, v));\n\n      this._check_value(action, value[0]); // SUPPRESS argument does not put anything in the namespace\n\n    } else if (action.nargs === SUPPRESS) {\n      value = SUPPRESS; // all other types of nargs produce a list\n    } else {\n      value = arg_strings.map(v => this._get_value(action, v));\n\n      for (let v of value) {\n        this._check_value(action, v);\n      }\n    } // return the converted value\n\n\n    return value;\n  }\n\n  _get_value(action, arg_string) {\n    let type_func = this._registry_get('type', action.type, action.type);\n\n    if (typeof type_func !== 'function') {\n      let msg = '%r is not callable';\n      throw new ArgumentError(action, sub(msg, type_func));\n    } // convert the value to the appropriate type\n\n\n    let result;\n\n    try {\n      try {\n        result = type_func(arg_string);\n      } catch (err) {\n        // Dear TC39, why would you ever consider making es6 classes not callable?\n        // We had one universal interface, [[Call]], which worked for anything\n        // (with familiar this-instanceof guard for classes). Now we have two.\n        if (err instanceof TypeError && /Class constructor .* cannot be invoked without 'new'/.test(err.message)) {\n          // eslint-disable-next-line new-cap\n          result = new type_func(arg_string);\n        } else {\n          throw err;\n        }\n      }\n    } catch (err) {\n      // ArgumentTypeErrors indicate errors\n      if (err instanceof ArgumentTypeError) {\n        //let name = getattr(action.type, 'name', repr(action.type))\n        let msg = err.message;\n        throw new ArgumentError(action, msg); // TypeErrors or ValueErrors also indicate errors\n      } else if (err instanceof TypeError) {\n        let name = getattr(action.type, 'name', repr(action.type));\n        let args = {\n          type: name,\n          value: arg_string\n        };\n        let msg = 'invalid %(type)s value: %(value)r';\n        throw new ArgumentError(action, sub(msg, args));\n      } else {\n        throw err;\n      }\n    } // return the converted value\n\n\n    return result;\n  }\n\n  _check_value(action, value) {\n    // converted value must be one of the choices (if specified)\n    if (action.choices !== undefined && !_choices_to_array(action.choices).includes(value)) {\n      let args = {\n        value,\n        choices: _choices_to_array(action.choices).map(repr).join(', ')\n      };\n      let msg = 'invalid choice: %(value)r (choose from %(choices)s)';\n      throw new ArgumentError(action, sub(msg, args));\n    }\n  } // =======================\n  // Help-formatting methods\n  // =======================\n\n\n  format_usage() {\n    let formatter = this._get_formatter();\n\n    formatter.add_usage(this.usage, this._actions, this._mutually_exclusive_groups);\n    return formatter.format_help();\n  }\n\n  format_help() {\n    let formatter = this._get_formatter(); // usage\n\n\n    formatter.add_usage(this.usage, this._actions, this._mutually_exclusive_groups); // description\n\n    formatter.add_text(this.description); // positionals, optionals and user-defined groups\n\n    for (let action_group of this._action_groups) {\n      formatter.start_section(action_group.title);\n      formatter.add_text(action_group.description);\n      formatter.add_arguments(action_group._group_actions);\n      formatter.end_section();\n    } // epilog\n\n\n    formatter.add_text(this.epilog); // determine help from format above\n\n    return formatter.format_help();\n  }\n\n  _get_formatter() {\n    // eslint-disable-next-line new-cap\n    return new this.formatter_class({\n      prog: this.prog\n    });\n  } // =====================\n  // Help-printing methods\n  // =====================\n\n\n  print_usage() {\n    let file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    if (file === undefined) file = process.stdout;\n\n    this._print_message(this.format_usage(), file);\n  }\n\n  print_help() {\n    let file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    if (file === undefined) file = process.stdout;\n\n    this._print_message(this.format_help(), file);\n  }\n\n  _print_message(message) {\n    let file = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n    if (message) {\n      if (file === undefined) file = process.stderr;\n      file.write(message);\n    }\n  } // ===============\n  // Exiting methods\n  // ===============\n\n\n  exit() {\n    let status = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n    if (message) {\n      this._print_message(message, process.stderr);\n    }\n\n    process.exit(status);\n  }\n\n  error(message) {\n    /*\n     *  error(message: string)\n     *\n     *  Prints a usage message incorporating the message to stderr and\n     *  exits.\n     *\n     *  If you override this in a subclass, it should not return -- it\n     *  should either exit or raise an exception.\n     */\n    // LEGACY (v1 compatibility), debug mode\n    if (this.debug === true) throw new Error(message); // end\n\n    this.print_usage(process.stderr);\n    let args = {\n      prog: this.prog,\n      message: message\n    };\n    this.exit(2, sub('%(prog)s: error: %(message)s\\n', args));\n  }\n\n}));\n\nmodule.exports = {\n  ArgumentParser,\n  ArgumentError,\n  ArgumentTypeError,\n  BooleanOptionalAction,\n  FileType,\n  HelpFormatter,\n  ArgumentDefaultsHelpFormatter,\n  RawDescriptionHelpFormatter,\n  RawTextHelpFormatter,\n  MetavarTypeHelpFormatter,\n  Namespace,\n  Action,\n  ONE_OR_MORE,\n  OPTIONAL,\n  PARSER,\n  REMAINDER,\n  SUPPRESS,\n  ZERO_OR_MORE\n}; // LEGACY (v1 compatibility), Const alias\n\nObject.defineProperty(module.exports, 'Const', {\n  get() {\n    let result = {};\n    Object.entries({\n      ONE_OR_MORE,\n      OPTIONAL,\n      PARSER,\n      REMAINDER,\n      SUPPRESS,\n      ZERO_OR_MORE\n    }).forEach(_ref11 => {\n      let [n, v] = _ref11;\n      Object.defineProperty(result, n, {\n        get() {\n          deprecate(n, sub('use argparse.%s instead of argparse.Const.%s', n, n));\n          return v;\n        }\n\n      });\n    });\n    Object.entries({\n      _UNRECOGNIZED_ARGS_ATTR\n    }).forEach(_ref12 => {\n      let [n, v] = _ref12;\n      Object.defineProperty(result, n, {\n        get() {\n          deprecate(n, sub('argparse.Const.%s is an internal symbol and will no longer be available', n));\n          return v;\n        }\n\n      });\n    });\n    return result;\n  },\n\n  enumerable: false\n}); // end","map":{"version":3,"names":["SUPPRESS","OPTIONAL","ZERO_OR_MORE","ONE_OR_MORE","PARSER","REMAINDER","_UNRECOGNIZED_ARGS_ATTR","assert","require","util","fs","sub","path","repr","inspect","get_argv","process","argv","slice","get_terminal_size","columns","env","COLUMNS","stdout","hasattr","object","name","Object","prototype","hasOwnProperty","call","getattr","value","setattr","setdefault","delattr","range","from","to","step","arguments","length","TypeError","result","i","push","splitlines","str","keepends","split","parts","pop","_string_lstrip","string","prefix_chars","idx","includes","_string_split","sep","maxsplit","concat","join","_array_equal","array1","array2","_array_remove","array","item","indexOf","splice","_choices_to_array","choices","undefined","Array","isArray","Symbol","iterator","keys","Error","_callable","cls","this_class","new","target","args","Reflect","construct","toStringTag","_alias","constructor","defineProperty","deprecate","enumerable","_camelcase_alias","_class","getOwnPropertyNames","camelcase","replace","s","toUpperCase","_to_legacy_name","key","_to_new_name","c","toLowerCase","no_default","_parse_opts","descriptor","get_name","stack","map","x","match","filter","Boolean","m","fn","shift","kwargs","last_opt","assign","renames","old_name","a","b","missing_positionals","positional_count","def","entries","new_name","k","v","strs","str_joined","_deprecations","id","_AttributeHolder","custom","type_name","arg_strings","star_args","arg","_get_args","_get_kwargs","test","toString","_copy_items","items","HelpFormatter","prog","indent_increment","max_help_position","width","_prog","_indent_increment","_max_help_position","Math","min","max","_width","_current_indent","_level","_action_max_length","_root_section","_Section","_current_section","_whitespace_matcher","_long_break_matcher","_indent","_dedent","_add_item","func","start_section","heading","section","format_help","bind","end_section","parent","add_text","text","_format_text","add_usage","usage","actions","groups","prefix","_format_usage","add_argument","action","help","invocations","_format_action_invocation","subaction","_iter_indented_subactions","invocation_length","invocation","action_length","_format_action","add_arguments","_join_parts","part_strings","part","optionals","positionals","option_strings","action_usage","_format_actions_usage","String","text_width","part_regexp","opt_usage","pos_usage","opt_parts","pos_parts","get_lines","indent","lines","line","line_len","repeat","group_actions","Set","inserts","group","start","_group_actions","end","add","required","default_value","_get_default_metavar_for_positional","_format_args","has","option_string","nargs","format_usage","_get_default_metavar_for_optional","args_string","Number","sort","trim","_fill_text","help_position","help_width","action_width","action_header","indent_first","tup","help_text","_expand_help","help_lines","_split_lines","endsWith","metavar","_metavar_formatter","default_metavar","choice_strs","format","tuple_size","fill","get_metavar","formats","err","params","choices_str","_get_help_string","_get_subactions","textwrap","wrap","initial_indent","subsequent_indent","dest","formatter","item_help","apply","current_indent","RawDescriptionHelpFormatter","RawTextHelpFormatter","ArgumentDefaultsHelpFormatter","default","defaulting_nargs","MetavarTypeHelpFormatter","type","_get_action_name","argument","ArgumentError","message","_argument_name","_message","argument_name","ArgumentTypeError","Action","Function","const_value","const","names","BooleanOptionalAction","_option_strings","startsWith","parser","namespace","values","_StoreAction","_StoreConstAction","_StoreTrueAction","_StoreFalseAction","_AppendAction","_AppendConstAction","_CountAction","count","_HelpAction","print_help","exit","_VersionAction","version","_get_formatter","_print_message","_SubParsersAction","parser_class","name_parser_map","_prog_prefix","_parser_class","_name_parser_map","_choices_actions","add_parser","aliases","choice_action","_ChoicesPseudoAction","alias","parser_name","msg","subnamespace","parse_known_args","_ExtendAction","FileType","flags","encoding","mode","autoClose","emitClose","highWaterMark","get","_flags","_options","stdin","fd","openSync","e","filename","error","options","createReadStream","createWriteStream","args_str","kw","Namespace","_ActionsContainer","description","argument_default","conflict_handler","_registries","register","forEach","_registry_get","_get_handler","_actions","_option_string_actions","_action_groups","_mutually_exclusive_groups","_defaults","_negative_number_matcher","_has_negative_number_optionals","registry_name","registry","set_defaults","get_default","chars","_get_positional_kwargs","_get_optional_kwargs","action_class","_pop_action_class","type_func","_add_action","add_argument_group","_ArgumentGroup","add_mutually_exclusive_group","_MutuallyExclusiveGroup","_check_conflict","container","_remove_action","_add_container_actions","title_group_map","title","group_map","Map","set","mutex_group","long_option_strings","option","dest_option_string","handler_func_name","confl_optionals","confl_optional","_handle_conflict_error","conflicting_actions","conflict_string","_handle_conflict_resolve","_container","ArgumentParser","epilog","parents","formatter_class","fromfile_prefix_chars","add_help","allow_abbrev","exit_on_error","debug","basename","_positionals","_optionals","_subparsers","identity","isInteger","isNaN","default_prefix","add_subparsers","_get_positional_actions","parsers_class","_get_optional_actions","parse_args","_parse_known_args","_read_args_from_files","action_conflicts","mutex_action","conflicts","option_string_indices","arg_string_pattern_parts","arg_strings_iter","arg_string","option_tuple","_parse_optional","pattern","arg_strings_pattern","seen_actions","seen_non_default_actions","extras","take_action","argument_strings","argument_values","_get_values","conflict_action","action_name","consume_optional","start_index","explicit_arg","action_tuples","stop","arg_count","_match_argument","char","new_explicit_arg","optionals_map","selected_patterns","consume_positionals","selected_pattern","arg_counts","_match_arguments_partial","max_option_string_index","next_option_string_index","index","positionals_end_index","strings","stop_index","required_actions","_get_value","no_actions_used","new_arg_strings","args_file","readFileSync","arg_line","convert_arg_line_to_args","nargs_pattern","_get_nargs_pattern","RegExp","nargs_errors","actions_slice","option_tuples","_get_option_tuples","matches","option_prefix","short_option_prefix","short_explicit_arg","parse_intermixed_args","parse_known_intermixed_args","save_usage","remaining_args","save_nargs","save_default","attr","console","warn","save_required","_check_value","action_group","print_usage","file","stderr","write","status","module","exports","n"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/node_modules/argparse/argparse.js"],"sourcesContent":["// Port of python's argparse module, version 3.9.0:\n// https://github.com/python/cpython/blob/v3.9.0rc1/Lib/argparse.py\n\n'use strict'\n\n// Copyright (C) 2010-2020 Python Software Foundation.\n// Copyright (C) 2020 argparse.js authors\n\n/*\n * Command-line parsing library\n *\n * This module is an optparse-inspired command-line parsing library that:\n *\n *     - handles both optional and positional arguments\n *     - produces highly informative usage messages\n *     - supports parsers that dispatch to sub-parsers\n *\n * The following is a simple usage example that sums integers from the\n * command-line and writes the result to a file::\n *\n *     parser = argparse.ArgumentParser(\n *         description='sum the integers at the command line')\n *     parser.add_argument(\n *         'integers', metavar='int', nargs='+', type=int,\n *         help='an integer to be summed')\n *     parser.add_argument(\n *         '--log', default=sys.stdout, type=argparse.FileType('w'),\n *         help='the file where the sum should be written')\n *     args = parser.parse_args()\n *     args.log.write('%s' % sum(args.integers))\n *     args.log.close()\n *\n * The module contains the following public classes:\n *\n *     - ArgumentParser -- The main entry point for command-line parsing. As the\n *         example above shows, the add_argument() method is used to populate\n *         the parser with actions for optional and positional arguments. Then\n *         the parse_args() method is invoked to convert the args at the\n *         command-line into an object with attributes.\n *\n *     - ArgumentError -- The exception raised by ArgumentParser objects when\n *         there are errors with the parser's actions. Errors raised while\n *         parsing the command-line are caught by ArgumentParser and emitted\n *         as command-line messages.\n *\n *     - FileType -- A factory for defining types of files to be created. As the\n *         example above shows, instances of FileType are typically passed as\n *         the type= argument of add_argument() calls.\n *\n *     - Action -- The base class for parser actions. Typically actions are\n *         selected by passing strings like 'store_true' or 'append_const' to\n *         the action= argument of add_argument(). However, for greater\n *         customization of ArgumentParser actions, subclasses of Action may\n *         be defined and passed as the action= argument.\n *\n *     - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,\n *         ArgumentDefaultsHelpFormatter -- Formatter classes which\n *         may be passed as the formatter_class= argument to the\n *         ArgumentParser constructor. HelpFormatter is the default,\n *         RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser\n *         not to change the formatting for help text, and\n *         ArgumentDefaultsHelpFormatter adds information about argument defaults\n *         to the help.\n *\n * All other classes in this module are considered implementation details.\n * (Also note that HelpFormatter and RawDescriptionHelpFormatter are only\n * considered public as object names -- the API of the formatter objects is\n * still considered an implementation detail.)\n */\n\nconst SUPPRESS = '==SUPPRESS=='\n\nconst OPTIONAL = '?'\nconst ZERO_OR_MORE = '*'\nconst ONE_OR_MORE = '+'\nconst PARSER = 'A...'\nconst REMAINDER = '...'\nconst _UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'\n\n\n// ==================================\n// Utility functions used for porting\n// ==================================\nconst assert = require('assert')\nconst util = require('util')\nconst fs = require('fs')\nconst sub = require('./lib/sub')\nconst path = require('path')\nconst repr = util.inspect\n\nfunction get_argv() {\n    // omit first argument (which is assumed to be interpreter - `node`, `coffee`, `ts-node`, etc.)\n    return process.argv.slice(1)\n}\n\nfunction get_terminal_size() {\n    return {\n        columns: +process.env.COLUMNS || process.stdout.columns || 80\n    }\n}\n\nfunction hasattr(object, name) {\n    return Object.prototype.hasOwnProperty.call(object, name)\n}\n\nfunction getattr(object, name, value) {\n    return hasattr(object, name) ? object[name] : value\n}\n\nfunction setattr(object, name, value) {\n    object[name] = value\n}\n\nfunction setdefault(object, name, value) {\n    if (!hasattr(object, name)) object[name] = value\n    return object[name]\n}\n\nfunction delattr(object, name) {\n    delete object[name]\n}\n\nfunction range(from, to, step=1) {\n    // range(10) is equivalent to range(0, 10)\n    if (arguments.length === 1) [ to, from ] = [ from, 0 ]\n    if (typeof from !== 'number' || typeof to !== 'number' || typeof step !== 'number') {\n        throw new TypeError('argument cannot be interpreted as an integer')\n    }\n    if (step === 0) throw new TypeError('range() arg 3 must not be zero')\n\n    let result = []\n    if (step > 0) {\n        for (let i = from; i < to; i += step) result.push(i)\n    } else {\n        for (let i = from; i > to; i += step) result.push(i)\n    }\n    return result\n}\n\nfunction splitlines(str, keepends = false) {\n    let result\n    if (!keepends) {\n        result = str.split(/\\r\\n|[\\n\\r\\v\\f\\x1c\\x1d\\x1e\\x85\\u2028\\u2029]/)\n    } else {\n        result = []\n        let parts = str.split(/(\\r\\n|[\\n\\r\\v\\f\\x1c\\x1d\\x1e\\x85\\u2028\\u2029])/)\n        for (let i = 0; i < parts.length; i += 2) {\n            result.push(parts[i] + (i + 1 < parts.length ? parts[i + 1] : ''))\n        }\n    }\n    if (!result[result.length - 1]) result.pop()\n    return result\n}\n\nfunction _string_lstrip(string, prefix_chars) {\n    let idx = 0\n    while (idx < string.length && prefix_chars.includes(string[idx])) idx++\n    return idx ? string.slice(idx) : string\n}\n\nfunction _string_split(string, sep, maxsplit) {\n    let result = string.split(sep)\n    if (result.length > maxsplit) {\n        result = result.slice(0, maxsplit).concat([ result.slice(maxsplit).join(sep) ])\n    }\n    return result\n}\n\nfunction _array_equal(array1, array2) {\n    if (array1.length !== array2.length) return false\n    for (let i = 0; i < array1.length; i++) {\n        if (array1[i] !== array2[i]) return false\n    }\n    return true\n}\n\nfunction _array_remove(array, item) {\n    let idx = array.indexOf(item)\n    if (idx === -1) throw new TypeError(sub('%r not in list', item))\n    array.splice(idx, 1)\n}\n\n// normalize choices to array;\n// this isn't required in python because `in` and `map` operators work with anything,\n// but in js dealing with multiple types here is too clunky\nfunction _choices_to_array(choices) {\n    if (choices === undefined) {\n        return []\n    } else if (Array.isArray(choices)) {\n        return choices\n    } else if (choices !== null && typeof choices[Symbol.iterator] === 'function') {\n        return Array.from(choices)\n    } else if (typeof choices === 'object' && choices !== null) {\n        return Object.keys(choices)\n    } else {\n        throw new Error(sub('invalid choices value: %r', choices))\n    }\n}\n\n// decorator that allows a class to be called without new\nfunction _callable(cls) {\n    let result = { // object is needed for inferred class name\n        [cls.name]: function (...args) {\n            let this_class = new.target === result || !new.target\n            return Reflect.construct(cls, args, this_class ? cls : new.target)\n        }\n    }\n    result[cls.name].prototype = cls.prototype\n    // fix default tag for toString, e.g. [object Action] instead of [object Object]\n    cls.prototype[Symbol.toStringTag] = cls.name\n    return result[cls.name]\n}\n\nfunction _alias(object, from, to) {\n    try {\n        let name = object.constructor.name\n        Object.defineProperty(object, from, {\n            value: util.deprecate(object[to], sub('%s.%s() is renamed to %s.%s()',\n                name, from, name, to)),\n            enumerable: false\n        })\n    } catch {}\n}\n\n// decorator that allows snake_case class methods to be called with camelCase and vice versa\nfunction _camelcase_alias(_class) {\n    for (let name of Object.getOwnPropertyNames(_class.prototype)) {\n        let camelcase = name.replace(/\\w_[a-z]/g, s => s[0] + s[2].toUpperCase())\n        if (camelcase !== name) _alias(_class.prototype, camelcase, name)\n    }\n    return _class\n}\n\nfunction _to_legacy_name(key) {\n    key = key.replace(/\\w_[a-z]/g, s => s[0] + s[2].toUpperCase())\n    if (key === 'default') key = 'defaultValue'\n    if (key === 'const') key = 'constant'\n    return key\n}\n\nfunction _to_new_name(key) {\n    if (key === 'defaultValue') key = 'default'\n    if (key === 'constant') key = 'const'\n    key = key.replace(/[A-Z]/g, c => '_' + c.toLowerCase())\n    return key\n}\n\n// parse options\nlet no_default = Symbol('no_default_value')\nfunction _parse_opts(args, descriptor) {\n    function get_name() {\n        let stack = new Error().stack.split('\\n')\n            .map(x => x.match(/^    at (.*) \\(.*\\)$/))\n            .filter(Boolean)\n            .map(m => m[1])\n            .map(fn => fn.match(/[^ .]*$/)[0])\n\n        if (stack.length && stack[0] === get_name.name) stack.shift()\n        if (stack.length && stack[0] === _parse_opts.name) stack.shift()\n        return stack.length ? stack[0] : ''\n    }\n\n    args = Array.from(args)\n    let kwargs = {}\n    let result = []\n    let last_opt = args.length && args[args.length - 1]\n\n    if (typeof last_opt === 'object' && last_opt !== null && !Array.isArray(last_opt) &&\n        (!last_opt.constructor || last_opt.constructor.name === 'Object')) {\n        kwargs = Object.assign({}, args.pop())\n    }\n\n    // LEGACY (v1 compatibility): camelcase\n    let renames = []\n    for (let key of Object.keys(descriptor)) {\n        let old_name = _to_legacy_name(key)\n        if (old_name !== key && (old_name in kwargs)) {\n            if (key in kwargs) {\n                // default and defaultValue specified at the same time, happens often in old tests\n                //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))\n            } else {\n                kwargs[key] = kwargs[old_name]\n            }\n            renames.push([ old_name, key ])\n            delete kwargs[old_name]\n        }\n    }\n    if (renames.length) {\n        let name = get_name()\n        deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s',\n            name, renames.map(([ a, b ]) => sub('%r -> %r', a, b))))\n    }\n    // end\n\n    let missing_positionals = []\n    let positional_count = args.length\n\n    for (let [ key, def ] of Object.entries(descriptor)) {\n        if (key[0] === '*') {\n            if (key.length > 0 && key[1] === '*') {\n                // LEGACY (v1 compatibility): camelcase\n                let renames = []\n                for (let key of Object.keys(kwargs)) {\n                    let new_name = _to_new_name(key)\n                    if (new_name !== key && (key in kwargs)) {\n                        if (new_name in kwargs) {\n                            // default and defaultValue specified at the same time, happens often in old tests\n                            //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), new_name))\n                        } else {\n                            kwargs[new_name] = kwargs[key]\n                        }\n                        renames.push([ key, new_name ])\n                        delete kwargs[key]\n                    }\n                }\n                if (renames.length) {\n                    let name = get_name()\n                    deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s',\n                        name, renames.map(([ a, b ]) => sub('%r -> %r', a, b))))\n                }\n                // end\n                result.push(kwargs)\n                kwargs = {}\n            } else {\n                result.push(args)\n                args = []\n            }\n        } else if (key in kwargs && args.length > 0) {\n            throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))\n        } else if (key in kwargs) {\n            result.push(kwargs[key])\n            delete kwargs[key]\n        } else if (args.length > 0) {\n            result.push(args.shift())\n        } else if (def !== no_default) {\n            result.push(def)\n        } else {\n            missing_positionals.push(key)\n        }\n    }\n\n    if (Object.keys(kwargs).length) {\n        throw new TypeError(sub('%s() got an unexpected keyword argument %r',\n            get_name(), Object.keys(kwargs)[0]))\n    }\n\n    if (args.length) {\n        let from = Object.entries(descriptor).filter(([ k, v ]) => k[0] !== '*' && v !== no_default).length\n        let to = Object.entries(descriptor).filter(([ k ]) => k[0] !== '*').length\n        throw new TypeError(sub('%s() takes %s positional argument%s but %s %s given',\n            get_name(),\n            from === to ? sub('from %s to %s', from, to) : to,\n            from === to && to === 1 ? '' : 's',\n            positional_count,\n            positional_count === 1 ? 'was' : 'were'))\n    }\n\n    if (missing_positionals.length) {\n        let strs = missing_positionals.map(repr)\n        if (strs.length > 1) strs[strs.length - 1] = 'and ' + strs[strs.length - 1]\n        let str_joined = strs.join(strs.length === 2 ? '' : ', ')\n        throw new TypeError(sub('%s() missing %i required positional argument%s: %s',\n            get_name(), strs.length, strs.length === 1 ? '' : 's', str_joined))\n    }\n\n    return result\n}\n\nlet _deprecations = {}\nfunction deprecate(id, string) {\n    _deprecations[id] = _deprecations[id] || util.deprecate(() => {}, string)\n    _deprecations[id]()\n}\n\n\n// =============================\n// Utility functions and classes\n// =============================\nfunction _AttributeHolder(cls = Object) {\n    /*\n     *  Abstract base class that provides __repr__.\n     *\n     *  The __repr__ method returns a string in the format::\n     *      ClassName(attr=name, attr=name, ...)\n     *  The attributes are determined either by a class-level attribute,\n     *  '_kwarg_names', or by inspecting the instance __dict__.\n     */\n\n    return class _AttributeHolder extends cls {\n        [util.inspect.custom]() {\n            let type_name = this.constructor.name\n            let arg_strings = []\n            let star_args = {}\n            for (let arg of this._get_args()) {\n                arg_strings.push(repr(arg))\n            }\n            for (let [ name, value ] of this._get_kwargs()) {\n                if (/^[a-z_][a-z0-9_$]*$/i.test(name)) {\n                    arg_strings.push(sub('%s=%r', name, value))\n                } else {\n                    star_args[name] = value\n                }\n            }\n            if (Object.keys(star_args).length) {\n                arg_strings.push(sub('**%s', repr(star_args)))\n            }\n            return sub('%s(%s)', type_name, arg_strings.join(', '))\n        }\n\n        toString() {\n            return this[util.inspect.custom]()\n        }\n\n        _get_kwargs() {\n            return Object.entries(this)\n        }\n\n        _get_args() {\n            return []\n        }\n    }\n}\n\n\nfunction _copy_items(items) {\n    if (items === undefined) {\n        return []\n    }\n    return items.slice(0)\n}\n\n\n// ===============\n// Formatting Help\n// ===============\nconst HelpFormatter = _camelcase_alias(_callable(class HelpFormatter {\n    /*\n     *  Formatter for generating usage messages and argument help strings.\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    constructor() {\n        let [\n            prog,\n            indent_increment,\n            max_help_position,\n            width\n        ] = _parse_opts(arguments, {\n            prog: no_default,\n            indent_increment: 2,\n            max_help_position: 24,\n            width: undefined\n        })\n\n        // default setting for width\n        if (width === undefined) {\n            width = get_terminal_size().columns\n            width -= 2\n        }\n\n        this._prog = prog\n        this._indent_increment = indent_increment\n        this._max_help_position = Math.min(max_help_position,\n                                      Math.max(width - 20, indent_increment * 2))\n        this._width = width\n\n        this._current_indent = 0\n        this._level = 0\n        this._action_max_length = 0\n\n        this._root_section = this._Section(this, undefined)\n        this._current_section = this._root_section\n\n        this._whitespace_matcher = /[ \\t\\n\\r\\f\\v]+/g // equivalent to python /\\s+/ with ASCII flag\n        this._long_break_matcher = /\\n\\n\\n+/g\n    }\n\n    // ===============================\n    // Section and indentation methods\n    // ===============================\n    _indent() {\n        this._current_indent += this._indent_increment\n        this._level += 1\n    }\n\n    _dedent() {\n        this._current_indent -= this._indent_increment\n        assert(this._current_indent >= 0, 'Indent decreased below 0.')\n        this._level -= 1\n    }\n\n    _add_item(func, args) {\n        this._current_section.items.push([ func, args ])\n    }\n\n    // ========================\n    // Message building methods\n    // ========================\n    start_section(heading) {\n        this._indent()\n        let section = this._Section(this, this._current_section, heading)\n        this._add_item(section.format_help.bind(section), [])\n        this._current_section = section\n    }\n\n    end_section() {\n        this._current_section = this._current_section.parent\n        this._dedent()\n    }\n\n    add_text(text) {\n        if (text !== SUPPRESS && text !== undefined) {\n            this._add_item(this._format_text.bind(this), [text])\n        }\n    }\n\n    add_usage(usage, actions, groups, prefix = undefined) {\n        if (usage !== SUPPRESS) {\n            let args = [ usage, actions, groups, prefix ]\n            this._add_item(this._format_usage.bind(this), args)\n        }\n    }\n\n    add_argument(action) {\n        if (action.help !== SUPPRESS) {\n\n            // find all invocations\n            let invocations = [this._format_action_invocation(action)]\n            for (let subaction of this._iter_indented_subactions(action)) {\n                invocations.push(this._format_action_invocation(subaction))\n            }\n\n            // update the maximum item length\n            let invocation_length = Math.max(...invocations.map(invocation => invocation.length))\n            let action_length = invocation_length + this._current_indent\n            this._action_max_length = Math.max(this._action_max_length,\n                                               action_length)\n\n            // add the item to the list\n            this._add_item(this._format_action.bind(this), [action])\n        }\n    }\n\n    add_arguments(actions) {\n        for (let action of actions) {\n            this.add_argument(action)\n        }\n    }\n\n    // =======================\n    // Help-formatting methods\n    // =======================\n    format_help() {\n        let help = this._root_section.format_help()\n        if (help) {\n            help = help.replace(this._long_break_matcher, '\\n\\n')\n            help = help.replace(/^\\n+|\\n+$/g, '') + '\\n'\n        }\n        return help\n    }\n\n    _join_parts(part_strings) {\n        return part_strings.filter(part => part && part !== SUPPRESS).join('')\n    }\n\n    _format_usage(usage, actions, groups, prefix) {\n        if (prefix === undefined) {\n            prefix = 'usage: '\n        }\n\n        // if usage is specified, use that\n        if (usage !== undefined) {\n            usage = sub(usage, { prog: this._prog })\n\n        // if no optionals or positionals are available, usage is just prog\n        } else if (usage === undefined && !actions.length) {\n            usage = sub('%(prog)s', { prog: this._prog })\n\n        // if optionals and positionals are available, calculate usage\n        } else if (usage === undefined) {\n            let prog = sub('%(prog)s', { prog: this._prog })\n\n            // split optionals from positionals\n            let optionals = []\n            let positionals = []\n            for (let action of actions) {\n                if (action.option_strings.length) {\n                    optionals.push(action)\n                } else {\n                    positionals.push(action)\n                }\n            }\n\n            // build full usage string\n            let action_usage = this._format_actions_usage([].concat(optionals).concat(positionals), groups)\n            usage = [ prog, action_usage ].map(String).join(' ')\n\n            // wrap the usage parts if it's too long\n            let text_width = this._width - this._current_indent\n            if (prefix.length + usage.length > text_width) {\n\n                // break usage into wrappable parts\n                let part_regexp = /\\(.*?\\)+(?=\\s|$)|\\[.*?\\]+(?=\\s|$)|\\S+/g\n                let opt_usage = this._format_actions_usage(optionals, groups)\n                let pos_usage = this._format_actions_usage(positionals, groups)\n                let opt_parts = opt_usage.match(part_regexp) || []\n                let pos_parts = pos_usage.match(part_regexp) || []\n                assert(opt_parts.join(' ') === opt_usage)\n                assert(pos_parts.join(' ') === pos_usage)\n\n                // helper for wrapping lines\n                let get_lines = (parts, indent, prefix = undefined) => {\n                    let lines = []\n                    let line = []\n                    let line_len\n                    if (prefix !== undefined) {\n                        line_len = prefix.length - 1\n                    } else {\n                        line_len = indent.length - 1\n                    }\n                    for (let part of parts) {\n                        if (line_len + 1 + part.length > text_width && line) {\n                            lines.push(indent + line.join(' '))\n                            line = []\n                            line_len = indent.length - 1\n                        }\n                        line.push(part)\n                        line_len += part.length + 1\n                    }\n                    if (line.length) {\n                        lines.push(indent + line.join(' '))\n                    }\n                    if (prefix !== undefined) {\n                        lines[0] = lines[0].slice(indent.length)\n                    }\n                    return lines\n                }\n\n                let lines\n\n                // if prog is short, follow it with optionals or positionals\n                if (prefix.length + prog.length <= 0.75 * text_width) {\n                    let indent = ' '.repeat(prefix.length + prog.length + 1)\n                    if (opt_parts.length) {\n                        lines = get_lines([prog].concat(opt_parts), indent, prefix)\n                        lines = lines.concat(get_lines(pos_parts, indent))\n                    } else if (pos_parts.length) {\n                        lines = get_lines([prog].concat(pos_parts), indent, prefix)\n                    } else {\n                        lines = [prog]\n                    }\n\n                // if prog is long, put it on its own line\n                } else {\n                    let indent = ' '.repeat(prefix.length)\n                    let parts = [].concat(opt_parts).concat(pos_parts)\n                    lines = get_lines(parts, indent)\n                    if (lines.length > 1) {\n                        lines = []\n                        lines = lines.concat(get_lines(opt_parts, indent))\n                        lines = lines.concat(get_lines(pos_parts, indent))\n                    }\n                    lines = [prog].concat(lines)\n                }\n\n                // join lines into usage\n                usage = lines.join('\\n')\n            }\n        }\n\n        // prefix with 'usage:'\n        return sub('%s%s\\n\\n', prefix, usage)\n    }\n\n    _format_actions_usage(actions, groups) {\n        // find group indices and identify actions in groups\n        let group_actions = new Set()\n        let inserts = {}\n        for (let group of groups) {\n            let start = actions.indexOf(group._group_actions[0])\n            if (start === -1) {\n                continue\n            } else {\n                let end = start + group._group_actions.length\n                if (_array_equal(actions.slice(start, end), group._group_actions)) {\n                    for (let action of group._group_actions) {\n                        group_actions.add(action)\n                    }\n                    if (!group.required) {\n                        if (start in inserts) {\n                            inserts[start] += ' ['\n                        } else {\n                            inserts[start] = '['\n                        }\n                        if (end in inserts) {\n                            inserts[end] += ']'\n                        } else {\n                            inserts[end] = ']'\n                        }\n                    } else {\n                        if (start in inserts) {\n                            inserts[start] += ' ('\n                        } else {\n                            inserts[start] = '('\n                        }\n                        if (end in inserts) {\n                            inserts[end] += ')'\n                        } else {\n                            inserts[end] = ')'\n                        }\n                    }\n                    for (let i of range(start + 1, end)) {\n                        inserts[i] = '|'\n                    }\n                }\n            }\n        }\n\n        // collect all actions format strings\n        let parts = []\n        for (let [ i, action ] of Object.entries(actions)) {\n\n            // suppressed arguments are marked with None\n            // remove | separators for suppressed arguments\n            if (action.help === SUPPRESS) {\n                parts.push(undefined)\n                if (inserts[+i] === '|') {\n                    delete inserts[+i]\n                } else if (inserts[+i + 1] === '|') {\n                    delete inserts[+i + 1]\n                }\n\n            // produce all arg strings\n            } else if (!action.option_strings.length) {\n                let default_value = this._get_default_metavar_for_positional(action)\n                let part = this._format_args(action, default_value)\n\n                // if it's in a group, strip the outer []\n                if (group_actions.has(action)) {\n                    if (part[0] === '[' && part[part.length - 1] === ']') {\n                        part = part.slice(1, -1)\n                    }\n                }\n\n                // add the action string to the list\n                parts.push(part)\n\n            // produce the first way to invoke the option in brackets\n            } else {\n                let option_string = action.option_strings[0]\n                let part\n\n                // if the Optional doesn't take a value, format is:\n                //    -s or --long\n                if (action.nargs === 0) {\n                    part = action.format_usage()\n\n                // if the Optional takes a value, format is:\n                //    -s ARGS or --long ARGS\n                } else {\n                    let default_value = this._get_default_metavar_for_optional(action)\n                    let args_string = this._format_args(action, default_value)\n                    part = sub('%s %s', option_string, args_string)\n                }\n\n                // make it look optional if it's not required or in a group\n                if (!action.required && !group_actions.has(action)) {\n                    part = sub('[%s]', part)\n                }\n\n                // add the action string to the list\n                parts.push(part)\n            }\n        }\n\n        // insert things at the necessary indices\n        for (let i of Object.keys(inserts).map(Number).sort((a, b) => b - a)) {\n            parts.splice(+i, 0, inserts[+i])\n        }\n\n        // join all the action items with spaces\n        let text = parts.filter(Boolean).join(' ')\n\n        // clean up separators for mutually exclusive groups\n        text = text.replace(/([\\[(]) /g, '$1')\n        text = text.replace(/ ([\\])])/g, '$1')\n        text = text.replace(/[\\[(] *[\\])]/g, '')\n        text = text.replace(/\\(([^|]*)\\)/g, '$1', text)\n        text = text.trim()\n\n        // return the text\n        return text\n    }\n\n    _format_text(text) {\n        if (text.includes('%(prog)')) {\n            text = sub(text, { prog: this._prog })\n        }\n        let text_width = Math.max(this._width - this._current_indent, 11)\n        let indent = ' '.repeat(this._current_indent)\n        return this._fill_text(text, text_width, indent) + '\\n\\n'\n    }\n\n    _format_action(action) {\n        // determine the required width and the entry label\n        let help_position = Math.min(this._action_max_length + 2,\n                                     this._max_help_position)\n        let help_width = Math.max(this._width - help_position, 11)\n        let action_width = help_position - this._current_indent - 2\n        let action_header = this._format_action_invocation(action)\n        let indent_first\n\n        // no help; start on same line and add a final newline\n        if (!action.help) {\n            let tup = [ this._current_indent, '', action_header ]\n            action_header = sub('%*s%s\\n', ...tup)\n\n        // short action name; start on the same line and pad two spaces\n        } else if (action_header.length <= action_width) {\n            let tup = [ this._current_indent, '', action_width, action_header ]\n            action_header = sub('%*s%-*s  ', ...tup)\n            indent_first = 0\n\n        // long action name; start on the next line\n        } else {\n            let tup = [ this._current_indent, '', action_header ]\n            action_header = sub('%*s%s\\n', ...tup)\n            indent_first = help_position\n        }\n\n        // collect the pieces of the action help\n        let parts = [action_header]\n\n        // if there was help for the action, add lines of help text\n        if (action.help) {\n            let help_text = this._expand_help(action)\n            let help_lines = this._split_lines(help_text, help_width)\n            parts.push(sub('%*s%s\\n', indent_first, '', help_lines[0]))\n            for (let line of help_lines.slice(1)) {\n                parts.push(sub('%*s%s\\n', help_position, '', line))\n            }\n\n        // or add a newline if the description doesn't end with one\n        } else if (!action_header.endsWith('\\n')) {\n            parts.push('\\n')\n        }\n\n        // if there are any sub-actions, add their help as well\n        for (let subaction of this._iter_indented_subactions(action)) {\n            parts.push(this._format_action(subaction))\n        }\n\n        // return a single string\n        return this._join_parts(parts)\n    }\n\n    _format_action_invocation(action) {\n        if (!action.option_strings.length) {\n            let default_value = this._get_default_metavar_for_positional(action)\n            let metavar = this._metavar_formatter(action, default_value)(1)[0]\n            return metavar\n\n        } else {\n            let parts = []\n\n            // if the Optional doesn't take a value, format is:\n            //    -s, --long\n            if (action.nargs === 0) {\n                parts = parts.concat(action.option_strings)\n\n            // if the Optional takes a value, format is:\n            //    -s ARGS, --long ARGS\n            } else {\n                let default_value = this._get_default_metavar_for_optional(action)\n                let args_string = this._format_args(action, default_value)\n                for (let option_string of action.option_strings) {\n                    parts.push(sub('%s %s', option_string, args_string))\n                }\n            }\n\n            return parts.join(', ')\n        }\n    }\n\n    _metavar_formatter(action, default_metavar) {\n        let result\n        if (action.metavar !== undefined) {\n            result = action.metavar\n        } else if (action.choices !== undefined) {\n            let choice_strs = _choices_to_array(action.choices).map(String)\n            result = sub('{%s}', choice_strs.join(','))\n        } else {\n            result = default_metavar\n        }\n\n        function format(tuple_size) {\n            if (Array.isArray(result)) {\n                return result\n            } else {\n                return Array(tuple_size).fill(result)\n            }\n        }\n        return format\n    }\n\n    _format_args(action, default_metavar) {\n        let get_metavar = this._metavar_formatter(action, default_metavar)\n        let result\n        if (action.nargs === undefined) {\n            result = sub('%s', ...get_metavar(1))\n        } else if (action.nargs === OPTIONAL) {\n            result = sub('[%s]', ...get_metavar(1))\n        } else if (action.nargs === ZERO_OR_MORE) {\n            let metavar = get_metavar(1)\n            if (metavar.length === 2) {\n                result = sub('[%s [%s ...]]', ...metavar)\n            } else {\n                result = sub('[%s ...]', ...metavar)\n            }\n        } else if (action.nargs === ONE_OR_MORE) {\n            result = sub('%s [%s ...]', ...get_metavar(2))\n        } else if (action.nargs === REMAINDER) {\n            result = '...'\n        } else if (action.nargs === PARSER) {\n            result = sub('%s ...', ...get_metavar(1))\n        } else if (action.nargs === SUPPRESS) {\n            result = ''\n        } else {\n            let formats\n            try {\n                formats = range(action.nargs).map(() => '%s')\n            } catch (err) {\n                throw new TypeError('invalid nargs value')\n            }\n            result = sub(formats.join(' '), ...get_metavar(action.nargs))\n        }\n        return result\n    }\n\n    _expand_help(action) {\n        let params = Object.assign({ prog: this._prog }, action)\n        for (let name of Object.keys(params)) {\n            if (params[name] === SUPPRESS) {\n                delete params[name]\n            }\n        }\n        for (let name of Object.keys(params)) {\n            if (params[name] && params[name].name) {\n                params[name] = params[name].name\n            }\n        }\n        if (params.choices !== undefined) {\n            let choices_str = _choices_to_array(params.choices).map(String).join(', ')\n            params.choices = choices_str\n        }\n        // LEGACY (v1 compatibility): camelcase\n        for (let key of Object.keys(params)) {\n            let old_name = _to_legacy_name(key)\n            if (old_name !== key) {\n                params[old_name] = params[key]\n            }\n        }\n        // end\n        return sub(this._get_help_string(action), params)\n    }\n\n    * _iter_indented_subactions(action) {\n        if (typeof action._get_subactions === 'function') {\n            this._indent()\n            yield* action._get_subactions()\n            this._dedent()\n        }\n    }\n\n    _split_lines(text, width) {\n        text = text.replace(this._whitespace_matcher, ' ').trim()\n        // The textwrap module is used only for formatting help.\n        // Delay its import for speeding up the common usage of argparse.\n        let textwrap = require('./lib/textwrap')\n        return textwrap.wrap(text, { width })\n    }\n\n    _fill_text(text, width, indent) {\n        text = text.replace(this._whitespace_matcher, ' ').trim()\n        let textwrap = require('./lib/textwrap')\n        return textwrap.fill(text, { width,\n                                     initial_indent: indent,\n                                     subsequent_indent: indent })\n    }\n\n    _get_help_string(action) {\n        return action.help\n    }\n\n    _get_default_metavar_for_optional(action) {\n        return action.dest.toUpperCase()\n    }\n\n    _get_default_metavar_for_positional(action) {\n        return action.dest\n    }\n}))\n\nHelpFormatter.prototype._Section = _callable(class _Section {\n\n    constructor(formatter, parent, heading = undefined) {\n        this.formatter = formatter\n        this.parent = parent\n        this.heading = heading\n        this.items = []\n    }\n\n    format_help() {\n        // format the indented section\n        if (this.parent !== undefined) {\n            this.formatter._indent()\n        }\n        let item_help = this.formatter._join_parts(this.items.map(([ func, args ]) => func.apply(null, args)))\n        if (this.parent !== undefined) {\n            this.formatter._dedent()\n        }\n\n        // return nothing if the section was empty\n        if (!item_help) {\n            return ''\n        }\n\n        // add the heading if the section was non-empty\n        let heading\n        if (this.heading !== SUPPRESS && this.heading !== undefined) {\n            let current_indent = this.formatter._current_indent\n            heading = sub('%*s%s:\\n', current_indent, '', this.heading)\n        } else {\n            heading = ''\n        }\n\n        // join the section-initial newline, the heading and the help\n        return this.formatter._join_parts(['\\n', heading, item_help, '\\n'])\n    }\n})\n\n\nconst RawDescriptionHelpFormatter = _camelcase_alias(_callable(class RawDescriptionHelpFormatter extends HelpFormatter {\n    /*\n     *  Help message formatter which retains any formatting in descriptions.\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    _fill_text(text, width, indent) {\n        return splitlines(text, true).map(line => indent + line).join('')\n    }\n}))\n\n\nconst RawTextHelpFormatter = _camelcase_alias(_callable(class RawTextHelpFormatter extends RawDescriptionHelpFormatter {\n    /*\n     *  Help message formatter which retains formatting of all help text.\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    _split_lines(text/*, width*/) {\n        return splitlines(text)\n    }\n}))\n\n\nconst ArgumentDefaultsHelpFormatter = _camelcase_alias(_callable(class ArgumentDefaultsHelpFormatter extends HelpFormatter {\n    /*\n     *  Help message formatter which adds default values to argument help.\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    _get_help_string(action) {\n        let help = action.help\n        // LEGACY (v1 compatibility): additional check for defaultValue needed\n        if (!action.help.includes('%(default)') && !action.help.includes('%(defaultValue)')) {\n            if (action.default !== SUPPRESS) {\n                let defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]\n                if (action.option_strings.length || defaulting_nargs.includes(action.nargs)) {\n                    help += ' (default: %(default)s)'\n                }\n            }\n        }\n        return help\n    }\n}))\n\n\nconst MetavarTypeHelpFormatter = _camelcase_alias(_callable(class MetavarTypeHelpFormatter extends HelpFormatter {\n    /*\n     *  Help message formatter which uses the argument 'type' as the default\n     *  metavar value (instead of the argument 'dest')\n     *\n     *  Only the name of this class is considered a public API. All the methods\n     *  provided by the class are considered an implementation detail.\n     */\n\n    _get_default_metavar_for_optional(action) {\n        return typeof action.type === 'function' ? action.type.name : action.type\n    }\n\n    _get_default_metavar_for_positional(action) {\n        return typeof action.type === 'function' ? action.type.name : action.type\n    }\n}))\n\n\n// =====================\n// Options and Arguments\n// =====================\nfunction _get_action_name(argument) {\n    if (argument === undefined) {\n        return undefined\n    } else if (argument.option_strings.length) {\n        return argument.option_strings.join('/')\n    } else if (![ undefined, SUPPRESS ].includes(argument.metavar)) {\n        return argument.metavar\n    } else if (![ undefined, SUPPRESS ].includes(argument.dest)) {\n        return argument.dest\n    } else {\n        return undefined\n    }\n}\n\n\nconst ArgumentError = _callable(class ArgumentError extends Error {\n    /*\n     *  An error from creating or using an argument (optional or positional).\n     *\n     *  The string value of this exception is the message, augmented with\n     *  information about the argument that caused it.\n     */\n\n    constructor(argument, message) {\n        super()\n        this.name = 'ArgumentError'\n        this._argument_name = _get_action_name(argument)\n        this._message = message\n        this.message = this.str()\n    }\n\n    str() {\n        let format\n        if (this._argument_name === undefined) {\n            format = '%(message)s'\n        } else {\n            format = 'argument %(argument_name)s: %(message)s'\n        }\n        return sub(format, { message: this._message,\n                             argument_name: this._argument_name })\n    }\n})\n\n\nconst ArgumentTypeError = _callable(class ArgumentTypeError extends Error {\n    /*\n     * An error from trying to convert a command line string to a type.\n     */\n\n    constructor(message) {\n        super(message)\n        this.name = 'ArgumentTypeError'\n    }\n})\n\n\n// ==============\n// Action classes\n// ==============\nconst Action = _camelcase_alias(_callable(class Action extends _AttributeHolder(Function) {\n    /*\n     *  Information about how to convert command line strings to Python objects.\n     *\n     *  Action objects are used by an ArgumentParser to represent the information\n     *  needed to parse a single argument from one or more strings from the\n     *  command line. The keyword arguments to the Action constructor are also\n     *  all attributes of Action instances.\n     *\n     *  Keyword Arguments:\n     *\n     *      - option_strings -- A list of command-line option strings which\n     *          should be associated with this action.\n     *\n     *      - dest -- The name of the attribute to hold the created object(s)\n     *\n     *      - nargs -- The number of command-line arguments that should be\n     *          consumed. By default, one argument will be consumed and a single\n     *          value will be produced.  Other values include:\n     *              - N (an integer) consumes N arguments (and produces a list)\n     *              - '?' consumes zero or one arguments\n     *              - '*' consumes zero or more arguments (and produces a list)\n     *              - '+' consumes one or more arguments (and produces a list)\n     *          Note that the difference between the default and nargs=1 is that\n     *          with the default, a single value will be produced, while with\n     *          nargs=1, a list containing a single value will be produced.\n     *\n     *      - const -- The value to be produced if the option is specified and the\n     *          option uses an action that takes no values.\n     *\n     *      - default -- The value to be produced if the option is not specified.\n     *\n     *      - type -- A callable that accepts a single string argument, and\n     *          returns the converted value.  The standard Python types str, int,\n     *          float, and complex are useful examples of such callables.  If None,\n     *          str is used.\n     *\n     *      - choices -- A container of values that should be allowed. If not None,\n     *          after a command-line argument has been converted to the appropriate\n     *          type, an exception will be raised if it is not a member of this\n     *          collection.\n     *\n     *      - required -- True if the action must always be specified at the\n     *          command line. This is only meaningful for optional command-line\n     *          arguments.\n     *\n     *      - help -- The help string describing the argument.\n     *\n     *      - metavar -- The name to be used for the option's argument with the\n     *          help string. If None, the 'dest' value will be used as the name.\n     */\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            nargs,\n            const_value,\n            default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            nargs: undefined,\n            const: undefined,\n            default: undefined,\n            type: undefined,\n            choices: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        // when this class is called as a function, redirect it to .call() method of itself\n        super('return arguments.callee.call.apply(arguments.callee, arguments)')\n\n        this.option_strings = option_strings\n        this.dest = dest\n        this.nargs = nargs\n        this.const = const_value\n        this.default = default_value\n        this.type = type\n        this.choices = choices\n        this.required = required\n        this.help = help\n        this.metavar = metavar\n    }\n\n    _get_kwargs() {\n        let names = [\n            'option_strings',\n            'dest',\n            'nargs',\n            'const',\n            'default',\n            'type',\n            'choices',\n            'help',\n            'metavar'\n        ]\n        return names.map(name => [ name, getattr(this, name) ])\n    }\n\n    format_usage() {\n        return this.option_strings[0]\n    }\n\n    call(/*parser, namespace, values, option_string = undefined*/) {\n        throw new Error('.call() not defined')\n    }\n}))\n\n\nconst BooleanOptionalAction = _camelcase_alias(_callable(class BooleanOptionalAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            default: undefined,\n            type: undefined,\n            choices: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        let _option_strings = []\n        for (let option_string of option_strings) {\n            _option_strings.push(option_string)\n\n            if (option_string.startsWith('--')) {\n                option_string = '--no-' + option_string.slice(2)\n                _option_strings.push(option_string)\n            }\n        }\n\n        if (help !== undefined && default_value !== undefined) {\n            help += ` (default: ${default_value})`\n        }\n\n        super({\n            option_strings: _option_strings,\n            dest,\n            nargs: 0,\n            default: default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        })\n    }\n\n    call(parser, namespace, values, option_string = undefined) {\n        if (this.option_strings.includes(option_string)) {\n            setattr(namespace, this.dest, !option_string.startsWith('--no-'))\n        }\n    }\n\n    format_usage() {\n        return this.option_strings.join(' | ')\n    }\n}))\n\n\nconst _StoreAction = _callable(class _StoreAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            nargs,\n            const_value,\n            default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            nargs: undefined,\n            const: undefined,\n            default: undefined,\n            type: undefined,\n            choices: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        if (nargs === 0) {\n            throw new TypeError('nargs for store actions must be != 0; if you ' +\n                        'have nothing to store, actions such as store ' +\n                        'true or store const may be more appropriate')\n        }\n        if (const_value !== undefined && nargs !== OPTIONAL) {\n            throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL))\n        }\n        super({\n            option_strings,\n            dest,\n            nargs,\n            const: const_value,\n            default: default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        })\n    }\n\n    call(parser, namespace, values/*, option_string = undefined*/) {\n        setattr(namespace, this.dest, values)\n    }\n})\n\n\nconst _StoreConstAction = _callable(class _StoreConstAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            const_value,\n            default_value,\n            required,\n            help\n            //, metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            const: no_default,\n            default: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            nargs: 0,\n            const: const_value,\n            default: default_value,\n            required,\n            help\n        })\n    }\n\n    call(parser, namespace/*, values, option_string = undefined*/) {\n        setattr(namespace, this.dest, this.const)\n    }\n})\n\n\nconst _StoreTrueAction = _callable(class _StoreTrueAction extends _StoreConstAction {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            required,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            default: false,\n            required: false,\n            help: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            const: true,\n            default: default_value,\n            required,\n            help\n        })\n    }\n})\n\n\nconst _StoreFalseAction = _callable(class _StoreFalseAction extends _StoreConstAction {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            required,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            default: true,\n            required: false,\n            help: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            const: false,\n            default: default_value,\n            required,\n            help\n        })\n    }\n})\n\n\nconst _AppendAction = _callable(class _AppendAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            nargs,\n            const_value,\n            default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            nargs: undefined,\n            const: undefined,\n            default: undefined,\n            type: undefined,\n            choices: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        if (nargs === 0) {\n            throw new TypeError('nargs for append actions must be != 0; if arg ' +\n                        'strings are not supplying the value to append, ' +\n                        'the append const action may be more appropriate')\n        }\n        if (const_value !== undefined && nargs !== OPTIONAL) {\n            throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL))\n        }\n        super({\n            option_strings,\n            dest,\n            nargs,\n            const: const_value,\n            default: default_value,\n            type,\n            choices,\n            required,\n            help,\n            metavar\n        })\n    }\n\n    call(parser, namespace, values/*, option_string = undefined*/) {\n        let items = getattr(namespace, this.dest, undefined)\n        items = _copy_items(items)\n        items.push(values)\n        setattr(namespace, this.dest, items)\n    }\n})\n\n\nconst _AppendConstAction = _callable(class _AppendConstAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            const_value,\n            default_value,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            const: no_default,\n            default: undefined,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            nargs: 0,\n            const: const_value,\n            default: default_value,\n            required,\n            help,\n            metavar\n        })\n    }\n\n    call(parser, namespace/*, values, option_string = undefined*/) {\n        let items = getattr(namespace, this.dest, undefined)\n        items = _copy_items(items)\n        items.push(this.const)\n        setattr(namespace, this.dest, items)\n    }\n})\n\n\nconst _CountAction = _callable(class _CountAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            required,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: no_default,\n            default: undefined,\n            required: false,\n            help: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            nargs: 0,\n            default: default_value,\n            required,\n            help\n        })\n    }\n\n    call(parser, namespace/*, values, option_string = undefined*/) {\n        let count = getattr(namespace, this.dest, undefined)\n        if (count === undefined) {\n            count = 0\n        }\n        setattr(namespace, this.dest, count + 1)\n    }\n})\n\n\nconst _HelpAction = _callable(class _HelpAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            dest,\n            default_value,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            dest: SUPPRESS,\n            default: SUPPRESS,\n            help: undefined\n        })\n\n        super({\n            option_strings,\n            dest,\n            default: default_value,\n            nargs: 0,\n            help\n        })\n    }\n\n    call(parser/*, namespace, values, option_string = undefined*/) {\n        parser.print_help()\n        parser.exit()\n    }\n})\n\n\nconst _VersionAction = _callable(class _VersionAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            version,\n            dest,\n            default_value,\n            help\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            version: undefined,\n            dest: SUPPRESS,\n            default: SUPPRESS,\n            help: \"show program's version number and exit\"\n        })\n\n        super({\n            option_strings,\n            dest,\n            default: default_value,\n            nargs: 0,\n            help\n        })\n        this.version = version\n    }\n\n    call(parser/*, namespace, values, option_string = undefined*/) {\n        let version = this.version\n        if (version === undefined) {\n            version = parser.version\n        }\n        let formatter = parser._get_formatter()\n        formatter.add_text(version)\n        parser._print_message(formatter.format_help(), process.stdout)\n        parser.exit()\n    }\n})\n\n\nconst _SubParsersAction = _camelcase_alias(_callable(class _SubParsersAction extends Action {\n\n    constructor() {\n        let [\n            option_strings,\n            prog,\n            parser_class,\n            dest,\n            required,\n            help,\n            metavar\n        ] = _parse_opts(arguments, {\n            option_strings: no_default,\n            prog: no_default,\n            parser_class: no_default,\n            dest: SUPPRESS,\n            required: false,\n            help: undefined,\n            metavar: undefined\n        })\n\n        let name_parser_map = {}\n\n        super({\n            option_strings,\n            dest,\n            nargs: PARSER,\n            choices: name_parser_map,\n            required,\n            help,\n            metavar\n        })\n\n        this._prog_prefix = prog\n        this._parser_class = parser_class\n        this._name_parser_map = name_parser_map\n        this._choices_actions = []\n    }\n\n    add_parser() {\n        let [\n            name,\n            kwargs\n        ] = _parse_opts(arguments, {\n            name: no_default,\n            '**kwargs': no_default\n        })\n\n        // set prog from the existing prefix\n        if (kwargs.prog === undefined) {\n            kwargs.prog = sub('%s %s', this._prog_prefix, name)\n        }\n\n        let aliases = getattr(kwargs, 'aliases', [])\n        delete kwargs.aliases\n\n        // create a pseudo-action to hold the choice help\n        if ('help' in kwargs) {\n            let help = kwargs.help\n            delete kwargs.help\n            let choice_action = this._ChoicesPseudoAction(name, aliases, help)\n            this._choices_actions.push(choice_action)\n        }\n\n        // create the parser and add it to the map\n        let parser = new this._parser_class(kwargs)\n        this._name_parser_map[name] = parser\n\n        // make parser available under aliases also\n        for (let alias of aliases) {\n            this._name_parser_map[alias] = parser\n        }\n\n        return parser\n    }\n\n    _get_subactions() {\n        return this._choices_actions\n    }\n\n    call(parser, namespace, values/*, option_string = undefined*/) {\n        let parser_name = values[0]\n        let arg_strings = values.slice(1)\n\n        // set the parser name if requested\n        if (this.dest !== SUPPRESS) {\n            setattr(namespace, this.dest, parser_name)\n        }\n\n        // select the parser\n        if (hasattr(this._name_parser_map, parser_name)) {\n            parser = this._name_parser_map[parser_name]\n        } else {\n            let args = {parser_name,\n                        choices: this._name_parser_map.join(', ')}\n            let msg = sub('unknown parser %(parser_name)r (choices: %(choices)s)', args)\n            throw new ArgumentError(this, msg)\n        }\n\n        // parse all the remaining options into the namespace\n        // store any unrecognized options on the object, so that the top\n        // level parser can decide what to do with them\n\n        // In case this subparser defines new defaults, we parse them\n        // in a new namespace object and then update the original\n        // namespace for the relevant parts.\n        let subnamespace\n        [ subnamespace, arg_strings ] = parser.parse_known_args(arg_strings, undefined)\n        for (let [ key, value ] of Object.entries(subnamespace)) {\n            setattr(namespace, key, value)\n        }\n\n        if (arg_strings.length) {\n            setdefault(namespace, _UNRECOGNIZED_ARGS_ATTR, [])\n            getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).push(...arg_strings)\n        }\n    }\n}))\n\n\n_SubParsersAction.prototype._ChoicesPseudoAction = _callable(class _ChoicesPseudoAction extends Action {\n    constructor(name, aliases, help) {\n        let metavar = name, dest = name\n        if (aliases.length) {\n            metavar += sub(' (%s)', aliases.join(', '))\n        }\n        super({ option_strings: [], dest, help, metavar })\n    }\n})\n\n\nconst _ExtendAction = _callable(class _ExtendAction extends _AppendAction {\n    call(parser, namespace, values/*, option_string = undefined*/) {\n        let items = getattr(namespace, this.dest, undefined)\n        items = _copy_items(items)\n        items = items.concat(values)\n        setattr(namespace, this.dest, items)\n    }\n})\n\n\n// ==============\n// Type classes\n// ==============\nconst FileType = _callable(class FileType extends Function {\n    /*\n     *  Factory for creating file object types\n     *\n     *  Instances of FileType are typically passed as type= arguments to the\n     *  ArgumentParser add_argument() method.\n     *\n     *  Keyword Arguments:\n     *      - mode -- A string indicating how the file is to be opened. Accepts the\n     *          same values as the builtin open() function.\n     *      - bufsize -- The file's desired buffer size. Accepts the same values as\n     *          the builtin open() function.\n     *      - encoding -- The file's encoding. Accepts the same values as the\n     *          builtin open() function.\n     *      - errors -- A string indicating how encoding and decoding errors are to\n     *          be handled. Accepts the same value as the builtin open() function.\n     */\n\n    constructor() {\n        let [\n            flags,\n            encoding,\n            mode,\n            autoClose,\n            emitClose,\n            start,\n            end,\n            highWaterMark,\n            fs\n        ] = _parse_opts(arguments, {\n            flags: 'r',\n            encoding: undefined,\n            mode: undefined, // 0o666\n            autoClose: undefined, // true\n            emitClose: undefined, // false\n            start: undefined, // 0\n            end: undefined, // Infinity\n            highWaterMark: undefined, // 64 * 1024\n            fs: undefined\n        })\n\n        // when this class is called as a function, redirect it to .call() method of itself\n        super('return arguments.callee.call.apply(arguments.callee, arguments)')\n\n        Object.defineProperty(this, 'name', {\n            get() {\n                return sub('FileType(%r)', flags)\n            }\n        })\n        this._flags = flags\n        this._options = {}\n        if (encoding !== undefined) this._options.encoding = encoding\n        if (mode !== undefined) this._options.mode = mode\n        if (autoClose !== undefined) this._options.autoClose = autoClose\n        if (emitClose !== undefined) this._options.emitClose = emitClose\n        if (start !== undefined) this._options.start = start\n        if (end !== undefined) this._options.end = end\n        if (highWaterMark !== undefined) this._options.highWaterMark = highWaterMark\n        if (fs !== undefined) this._options.fs = fs\n    }\n\n    call(string) {\n        // the special argument \"-\" means sys.std{in,out}\n        if (string === '-') {\n            if (this._flags.includes('r')) {\n                return process.stdin\n            } else if (this._flags.includes('w')) {\n                return process.stdout\n            } else {\n                let msg = sub('argument \"-\" with mode %r', this._flags)\n                throw new TypeError(msg)\n            }\n        }\n\n        // all other arguments are used as file names\n        let fd\n        try {\n            fd = fs.openSync(string, this._flags, this._options.mode)\n        } catch (e) {\n            let args = { filename: string, error: e.message }\n            let message = \"can't open '%(filename)s': %(error)s\"\n            throw new ArgumentTypeError(sub(message, args))\n        }\n\n        let options = Object.assign({ fd, flags: this._flags }, this._options)\n        if (this._flags.includes('r')) {\n            return fs.createReadStream(undefined, options)\n        } else if (this._flags.includes('w')) {\n            return fs.createWriteStream(undefined, options)\n        } else {\n            let msg = sub('argument \"%s\" with mode %r', string, this._flags)\n            throw new TypeError(msg)\n        }\n    }\n\n    [util.inspect.custom]() {\n        let args = [ this._flags ]\n        let kwargs = Object.entries(this._options).map(([ k, v ]) => {\n            if (k === 'mode') v = { value: v, [util.inspect.custom]() { return '0o' + this.value.toString(8) } }\n            return [ k, v ]\n        })\n        let args_str = []\n                .concat(args.filter(arg => arg !== -1).map(repr))\n                .concat(kwargs.filter(([/*kw*/, arg]) => arg !== undefined)\n                    .map(([kw, arg]) => sub('%s=%r', kw, arg)))\n                .join(', ')\n        return sub('%s(%s)', this.constructor.name, args_str)\n    }\n\n    toString() {\n        return this[util.inspect.custom]()\n    }\n})\n\n// ===========================\n// Optional and Positional Parsing\n// ===========================\nconst Namespace = _callable(class Namespace extends _AttributeHolder() {\n    /*\n     *  Simple object for storing attributes.\n     *\n     *  Implements equality by attribute names and values, and provides a simple\n     *  string representation.\n     */\n\n    constructor(options = {}) {\n        super()\n        Object.assign(this, options)\n    }\n})\n\n// unset string tag to mimic plain object\nNamespace.prototype[Symbol.toStringTag] = undefined\n\n\nconst _ActionsContainer = _camelcase_alias(_callable(class _ActionsContainer {\n\n    constructor() {\n        let [\n            description,\n            prefix_chars,\n            argument_default,\n            conflict_handler\n        ] = _parse_opts(arguments, {\n            description: no_default,\n            prefix_chars: no_default,\n            argument_default: no_default,\n            conflict_handler: no_default\n        })\n\n        this.description = description\n        this.argument_default = argument_default\n        this.prefix_chars = prefix_chars\n        this.conflict_handler = conflict_handler\n\n        // set up registries\n        this._registries = {}\n\n        // register actions\n        this.register('action', undefined, _StoreAction)\n        this.register('action', 'store', _StoreAction)\n        this.register('action', 'store_const', _StoreConstAction)\n        this.register('action', 'store_true', _StoreTrueAction)\n        this.register('action', 'store_false', _StoreFalseAction)\n        this.register('action', 'append', _AppendAction)\n        this.register('action', 'append_const', _AppendConstAction)\n        this.register('action', 'count', _CountAction)\n        this.register('action', 'help', _HelpAction)\n        this.register('action', 'version', _VersionAction)\n        this.register('action', 'parsers', _SubParsersAction)\n        this.register('action', 'extend', _ExtendAction)\n        // LEGACY (v1 compatibility): camelcase variants\n        ;[ 'storeConst', 'storeTrue', 'storeFalse', 'appendConst' ].forEach(old_name => {\n            let new_name = _to_new_name(old_name)\n            this.register('action', old_name, util.deprecate(this._registry_get('action', new_name),\n                sub('{action: \"%s\"} is renamed to {action: \"%s\"}', old_name, new_name)))\n        })\n        // end\n\n        // raise an exception if the conflict handler is invalid\n        this._get_handler()\n\n        // action storage\n        this._actions = []\n        this._option_string_actions = {}\n\n        // groups\n        this._action_groups = []\n        this._mutually_exclusive_groups = []\n\n        // defaults storage\n        this._defaults = {}\n\n        // determines whether an \"option\" looks like a negative number\n        this._negative_number_matcher = /^-\\d+$|^-\\d*\\.\\d+$/\n\n        // whether or not there are any optionals that look like negative\n        // numbers -- uses a list so it can be shared and edited\n        this._has_negative_number_optionals = []\n    }\n\n    // ====================\n    // Registration methods\n    // ====================\n    register(registry_name, value, object) {\n        let registry = setdefault(this._registries, registry_name, {})\n        registry[value] = object\n    }\n\n    _registry_get(registry_name, value, default_value = undefined) {\n        return getattr(this._registries[registry_name], value, default_value)\n    }\n\n    // ==================================\n    // Namespace default accessor methods\n    // ==================================\n    set_defaults(kwargs) {\n        Object.assign(this._defaults, kwargs)\n\n        // if these defaults match any existing arguments, replace\n        // the previous default on the object with the new one\n        for (let action of this._actions) {\n            if (action.dest in kwargs) {\n                action.default = kwargs[action.dest]\n            }\n        }\n    }\n\n    get_default(dest) {\n        for (let action of this._actions) {\n            if (action.dest === dest && action.default !== undefined) {\n                return action.default\n            }\n        }\n        return this._defaults[dest]\n    }\n\n\n    // =======================\n    // Adding argument actions\n    // =======================\n    add_argument() {\n        /*\n         *  add_argument(dest, ..., name=value, ...)\n         *  add_argument(option_string, option_string, ..., name=value, ...)\n         */\n        let [\n            args,\n            kwargs\n        ] = _parse_opts(arguments, {\n            '*args': no_default,\n            '**kwargs': no_default\n        })\n        // LEGACY (v1 compatibility), old-style add_argument([ args ], { options })\n        if (args.length === 1 && Array.isArray(args[0])) {\n            args = args[0]\n            deprecate('argument-array',\n                sub('use add_argument(%(args)s, {...}) instead of add_argument([ %(args)s ], { ... })', {\n                    args: args.map(repr).join(', ')\n                }))\n        }\n        // end\n\n        // if no positional args are supplied or only one is supplied and\n        // it doesn't look like an option string, parse a positional\n        // argument\n        let chars = this.prefix_chars\n        if (!args.length || args.length === 1 && !chars.includes(args[0][0])) {\n            if (args.length && 'dest' in kwargs) {\n                throw new TypeError('dest supplied twice for positional argument')\n            }\n            kwargs = this._get_positional_kwargs(...args, kwargs)\n\n        // otherwise, we're adding an optional argument\n        } else {\n            kwargs = this._get_optional_kwargs(...args, kwargs)\n        }\n\n        // if no default was supplied, use the parser-level default\n        if (!('default' in kwargs)) {\n            let dest = kwargs.dest\n            if (dest in this._defaults) {\n                kwargs.default = this._defaults[dest]\n            } else if (this.argument_default !== undefined) {\n                kwargs.default = this.argument_default\n            }\n        }\n\n        // create the action object, and add it to the parser\n        let action_class = this._pop_action_class(kwargs)\n        if (typeof action_class !== 'function') {\n            throw new TypeError(sub('unknown action \"%s\"', action_class))\n        }\n        // eslint-disable-next-line new-cap\n        let action = new action_class(kwargs)\n\n        // raise an error if the action type is not callable\n        let type_func = this._registry_get('type', action.type, action.type)\n        if (typeof type_func !== 'function') {\n            throw new TypeError(sub('%r is not callable', type_func))\n        }\n\n        if (type_func === FileType) {\n            throw new TypeError(sub('%r is a FileType class object, instance of it' +\n                                    ' must be passed', type_func))\n        }\n\n        // raise an error if the metavar does not match the type\n        if ('_get_formatter' in this) {\n            try {\n                this._get_formatter()._format_args(action, undefined)\n            } catch (err) {\n                // check for 'invalid nargs value' is an artifact of TypeError and ValueError in js being the same\n                if (err instanceof TypeError && err.message !== 'invalid nargs value') {\n                    throw new TypeError('length of metavar tuple does not match nargs')\n                } else {\n                    throw err\n                }\n            }\n        }\n\n        return this._add_action(action)\n    }\n\n    add_argument_group() {\n        let group = _ArgumentGroup(this, ...arguments)\n        this._action_groups.push(group)\n        return group\n    }\n\n    add_mutually_exclusive_group() {\n        // eslint-disable-next-line no-use-before-define\n        let group = _MutuallyExclusiveGroup(this, ...arguments)\n        this._mutually_exclusive_groups.push(group)\n        return group\n    }\n\n    _add_action(action) {\n        // resolve any conflicts\n        this._check_conflict(action)\n\n        // add to actions list\n        this._actions.push(action)\n        action.container = this\n\n        // index the action by any option strings it has\n        for (let option_string of action.option_strings) {\n            this._option_string_actions[option_string] = action\n        }\n\n        // set the flag if any option strings look like negative numbers\n        for (let option_string of action.option_strings) {\n            if (this._negative_number_matcher.test(option_string)) {\n                if (!this._has_negative_number_optionals.length) {\n                    this._has_negative_number_optionals.push(true)\n                }\n            }\n        }\n\n        // return the created action\n        return action\n    }\n\n    _remove_action(action) {\n        _array_remove(this._actions, action)\n    }\n\n    _add_container_actions(container) {\n        // collect groups by titles\n        let title_group_map = {}\n        for (let group of this._action_groups) {\n            if (group.title in title_group_map) {\n                let msg = 'cannot merge actions - two groups are named %r'\n                throw new TypeError(sub(msg, group.title))\n            }\n            title_group_map[group.title] = group\n        }\n\n        // map each action to its group\n        let group_map = new Map()\n        for (let group of container._action_groups) {\n\n            // if a group with the title exists, use that, otherwise\n            // create a new group matching the container's group\n            if (!(group.title in title_group_map)) {\n                title_group_map[group.title] = this.add_argument_group({\n                    title: group.title,\n                    description: group.description,\n                    conflict_handler: group.conflict_handler\n                })\n            }\n\n            // map the actions to their new group\n            for (let action of group._group_actions) {\n                group_map.set(action, title_group_map[group.title])\n            }\n        }\n\n        // add container's mutually exclusive groups\n        // NOTE: if add_mutually_exclusive_group ever gains title= and\n        // description= then this code will need to be expanded as above\n        for (let group of container._mutually_exclusive_groups) {\n            let mutex_group = this.add_mutually_exclusive_group({\n                required: group.required\n            })\n\n            // map the actions to their new mutex group\n            for (let action of group._group_actions) {\n                group_map.set(action, mutex_group)\n            }\n        }\n\n        // add all actions to this container or their group\n        for (let action of container._actions) {\n            group_map.get(action)._add_action(action)\n        }\n    }\n\n    _get_positional_kwargs() {\n        let [\n            dest,\n            kwargs\n        ] = _parse_opts(arguments, {\n            dest: no_default,\n            '**kwargs': no_default\n        })\n\n        // make sure required is not specified\n        if ('required' in kwargs) {\n            let msg = \"'required' is an invalid argument for positionals\"\n            throw new TypeError(msg)\n        }\n\n        // mark positional arguments as required if at least one is\n        // always required\n        if (![OPTIONAL, ZERO_OR_MORE].includes(kwargs.nargs)) {\n            kwargs.required = true\n        }\n        if (kwargs.nargs === ZERO_OR_MORE && !('default' in kwargs)) {\n            kwargs.required = true\n        }\n\n        // return the keyword arguments with no option strings\n        return Object.assign(kwargs, { dest, option_strings: [] })\n    }\n\n    _get_optional_kwargs() {\n        let [\n            args,\n            kwargs\n        ] = _parse_opts(arguments, {\n            '*args': no_default,\n            '**kwargs': no_default\n        })\n\n        // determine short and long option strings\n        let option_strings = []\n        let long_option_strings = []\n        let option_string\n        for (option_string of args) {\n            // error on strings that don't start with an appropriate prefix\n            if (!this.prefix_chars.includes(option_string[0])) {\n                let args = {option: option_string,\n                            prefix_chars: this.prefix_chars}\n                let msg = 'invalid option string %(option)r: ' +\n                          'must start with a character %(prefix_chars)r'\n                throw new TypeError(sub(msg, args))\n            }\n\n            // strings starting with two prefix characters are long options\n            option_strings.push(option_string)\n            if (option_string.length > 1 && this.prefix_chars.includes(option_string[1])) {\n                long_option_strings.push(option_string)\n            }\n        }\n\n        // infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'\n        let dest = kwargs.dest\n        delete kwargs.dest\n        if (dest === undefined) {\n            let dest_option_string\n            if (long_option_strings.length) {\n                dest_option_string = long_option_strings[0]\n            } else {\n                dest_option_string = option_strings[0]\n            }\n            dest = _string_lstrip(dest_option_string, this.prefix_chars)\n            if (!dest) {\n                let msg = 'dest= is required for options like %r'\n                throw new TypeError(sub(msg, option_string))\n            }\n            dest = dest.replace(/-/g, '_')\n        }\n\n        // return the updated keyword arguments\n        return Object.assign(kwargs, { dest, option_strings })\n    }\n\n    _pop_action_class(kwargs, default_value = undefined) {\n        let action = getattr(kwargs, 'action', default_value)\n        delete kwargs.action\n        return this._registry_get('action', action, action)\n    }\n\n    _get_handler() {\n        // determine function from conflict handler string\n        let handler_func_name = sub('_handle_conflict_%s', this.conflict_handler)\n        if (typeof this[handler_func_name] === 'function') {\n            return this[handler_func_name]\n        } else {\n            let msg = 'invalid conflict_resolution value: %r'\n            throw new TypeError(sub(msg, this.conflict_handler))\n        }\n    }\n\n    _check_conflict(action) {\n\n        // find all options that conflict with this option\n        let confl_optionals = []\n        for (let option_string of action.option_strings) {\n            if (hasattr(this._option_string_actions, option_string)) {\n                let confl_optional = this._option_string_actions[option_string]\n                confl_optionals.push([ option_string, confl_optional ])\n            }\n        }\n\n        // resolve any conflicts\n        if (confl_optionals.length) {\n            let conflict_handler = this._get_handler()\n            conflict_handler.call(this, action, confl_optionals)\n        }\n    }\n\n    _handle_conflict_error(action, conflicting_actions) {\n        let message = conflicting_actions.length === 1 ?\n            'conflicting option string: %s' :\n            'conflicting option strings: %s'\n        let conflict_string = conflicting_actions.map(([ option_string/*, action*/ ]) => option_string).join(', ')\n        throw new ArgumentError(action, sub(message, conflict_string))\n    }\n\n    _handle_conflict_resolve(action, conflicting_actions) {\n\n        // remove all conflicting options\n        for (let [ option_string, action ] of conflicting_actions) {\n\n            // remove the conflicting option\n            _array_remove(action.option_strings, option_string)\n            delete this._option_string_actions[option_string]\n\n            // if the option now has no option string, remove it from the\n            // container holding it\n            if (!action.option_strings.length) {\n                action.container._remove_action(action)\n            }\n        }\n    }\n}))\n\n\nconst _ArgumentGroup = _callable(class _ArgumentGroup extends _ActionsContainer {\n\n    constructor() {\n        let [\n            container,\n            title,\n            description,\n            kwargs\n        ] = _parse_opts(arguments, {\n            container: no_default,\n            title: undefined,\n            description: undefined,\n            '**kwargs': no_default\n        })\n\n        // add any missing keyword arguments by checking the container\n        setdefault(kwargs, 'conflict_handler', container.conflict_handler)\n        setdefault(kwargs, 'prefix_chars', container.prefix_chars)\n        setdefault(kwargs, 'argument_default', container.argument_default)\n        super(Object.assign({ description }, kwargs))\n\n        // group attributes\n        this.title = title\n        this._group_actions = []\n\n        // share most attributes with the container\n        this._registries = container._registries\n        this._actions = container._actions\n        this._option_string_actions = container._option_string_actions\n        this._defaults = container._defaults\n        this._has_negative_number_optionals =\n            container._has_negative_number_optionals\n        this._mutually_exclusive_groups = container._mutually_exclusive_groups\n    }\n\n    _add_action(action) {\n        action = super._add_action(action)\n        this._group_actions.push(action)\n        return action\n    }\n\n    _remove_action(action) {\n        super._remove_action(action)\n        _array_remove(this._group_actions, action)\n    }\n})\n\n\nconst _MutuallyExclusiveGroup = _callable(class _MutuallyExclusiveGroup extends _ArgumentGroup {\n\n    constructor() {\n        let [\n            container,\n            required\n        ] = _parse_opts(arguments, {\n            container: no_default,\n            required: false\n        })\n\n        super(container)\n        this.required = required\n        this._container = container\n    }\n\n    _add_action(action) {\n        if (action.required) {\n            let msg = 'mutually exclusive arguments must be optional'\n            throw new TypeError(msg)\n        }\n        action = this._container._add_action(action)\n        this._group_actions.push(action)\n        return action\n    }\n\n    _remove_action(action) {\n        this._container._remove_action(action)\n        _array_remove(this._group_actions, action)\n    }\n})\n\n\nconst ArgumentParser = _camelcase_alias(_callable(class ArgumentParser extends _AttributeHolder(_ActionsContainer) {\n    /*\n     *  Object for parsing command line strings into Python objects.\n     *\n     *  Keyword Arguments:\n     *      - prog -- The name of the program (default: sys.argv[0])\n     *      - usage -- A usage message (default: auto-generated from arguments)\n     *      - description -- A description of what the program does\n     *      - epilog -- Text following the argument descriptions\n     *      - parents -- Parsers whose arguments should be copied into this one\n     *      - formatter_class -- HelpFormatter class for printing help messages\n     *      - prefix_chars -- Characters that prefix optional arguments\n     *      - fromfile_prefix_chars -- Characters that prefix files containing\n     *          additional arguments\n     *      - argument_default -- The default value for all arguments\n     *      - conflict_handler -- String indicating how to handle conflicts\n     *      - add_help -- Add a -h/-help option\n     *      - allow_abbrev -- Allow long options to be abbreviated unambiguously\n     *      - exit_on_error -- Determines whether or not ArgumentParser exits with\n     *          error info when an error occurs\n     */\n\n    constructor() {\n        let [\n            prog,\n            usage,\n            description,\n            epilog,\n            parents,\n            formatter_class,\n            prefix_chars,\n            fromfile_prefix_chars,\n            argument_default,\n            conflict_handler,\n            add_help,\n            allow_abbrev,\n            exit_on_error,\n            debug, // LEGACY (v1 compatibility), debug mode\n            version // LEGACY (v1 compatibility), version\n        ] = _parse_opts(arguments, {\n            prog: undefined,\n            usage: undefined,\n            description: undefined,\n            epilog: undefined,\n            parents: [],\n            formatter_class: HelpFormatter,\n            prefix_chars: '-',\n            fromfile_prefix_chars: undefined,\n            argument_default: undefined,\n            conflict_handler: 'error',\n            add_help: true,\n            allow_abbrev: true,\n            exit_on_error: true,\n            debug: undefined, // LEGACY (v1 compatibility), debug mode\n            version: undefined // LEGACY (v1 compatibility), version\n        })\n\n        // LEGACY (v1 compatibility)\n        if (debug !== undefined) {\n            deprecate('debug',\n                'The \"debug\" argument to ArgumentParser is deprecated. Please ' +\n                'override ArgumentParser.exit function instead.'\n            )\n        }\n\n        if (version !== undefined) {\n            deprecate('version',\n                'The \"version\" argument to ArgumentParser is deprecated. Please use ' +\n                \"add_argument(..., { action: 'version', version: 'N', ... }) instead.\"\n            )\n        }\n        // end\n\n        super({\n            description,\n            prefix_chars,\n            argument_default,\n            conflict_handler\n        })\n\n        // default setting for prog\n        if (prog === undefined) {\n            prog = path.basename(get_argv()[0] || '')\n        }\n\n        this.prog = prog\n        this.usage = usage\n        this.epilog = epilog\n        this.formatter_class = formatter_class\n        this.fromfile_prefix_chars = fromfile_prefix_chars\n        this.add_help = add_help\n        this.allow_abbrev = allow_abbrev\n        this.exit_on_error = exit_on_error\n        // LEGACY (v1 compatibility), debug mode\n        this.debug = debug\n        // end\n\n        this._positionals = this.add_argument_group('positional arguments')\n        this._optionals = this.add_argument_group('optional arguments')\n        this._subparsers = undefined\n\n        // register types\n        function identity(string) {\n            return string\n        }\n        this.register('type', undefined, identity)\n        this.register('type', null, identity)\n        this.register('type', 'auto', identity)\n        this.register('type', 'int', function (x) {\n            let result = Number(x)\n            if (!Number.isInteger(result)) {\n                throw new TypeError(sub('could not convert string to int: %r', x))\n            }\n            return result\n        })\n        this.register('type', 'float', function (x) {\n            let result = Number(x)\n            if (isNaN(result)) {\n                throw new TypeError(sub('could not convert string to float: %r', x))\n            }\n            return result\n        })\n        this.register('type', 'str', String)\n        // LEGACY (v1 compatibility): custom types\n        this.register('type', 'string',\n            util.deprecate(String, 'use {type:\"str\"} or {type:String} instead of {type:\"string\"}'))\n        // end\n\n        // add help argument if necessary\n        // (using explicit default to override global argument_default)\n        let default_prefix = prefix_chars.includes('-') ? '-' : prefix_chars[0]\n        if (this.add_help) {\n            this.add_argument(\n                default_prefix + 'h',\n                default_prefix.repeat(2) + 'help',\n                {\n                    action: 'help',\n                    default: SUPPRESS,\n                    help: 'show this help message and exit'\n                }\n            )\n        }\n        // LEGACY (v1 compatibility), version\n        if (version) {\n            this.add_argument(\n                default_prefix + 'v',\n                default_prefix.repeat(2) + 'version',\n                {\n                    action: 'version',\n                    default: SUPPRESS,\n                    version: this.version,\n                    help: \"show program's version number and exit\"\n                }\n            )\n        }\n        // end\n\n        // add parent arguments and defaults\n        for (let parent of parents) {\n            this._add_container_actions(parent)\n            Object.assign(this._defaults, parent._defaults)\n        }\n    }\n\n    // =======================\n    // Pretty __repr__ methods\n    // =======================\n    _get_kwargs() {\n        let names = [\n            'prog',\n            'usage',\n            'description',\n            'formatter_class',\n            'conflict_handler',\n            'add_help'\n        ]\n        return names.map(name => [ name, getattr(this, name) ])\n    }\n\n    // ==================================\n    // Optional/Positional adding methods\n    // ==================================\n    add_subparsers() {\n        let [\n            kwargs\n        ] = _parse_opts(arguments, {\n            '**kwargs': no_default\n        })\n\n        if (this._subparsers !== undefined) {\n            this.error('cannot have multiple subparser arguments')\n        }\n\n        // add the parser class to the arguments if it's not present\n        setdefault(kwargs, 'parser_class', this.constructor)\n\n        if ('title' in kwargs || 'description' in kwargs) {\n            let title = getattr(kwargs, 'title', 'subcommands')\n            let description = getattr(kwargs, 'description', undefined)\n            delete kwargs.title\n            delete kwargs.description\n            this._subparsers = this.add_argument_group(title, description)\n        } else {\n            this._subparsers = this._positionals\n        }\n\n        // prog defaults to the usage message of this parser, skipping\n        // optional arguments and with no \"usage:\" prefix\n        if (kwargs.prog === undefined) {\n            let formatter = this._get_formatter()\n            let positionals = this._get_positional_actions()\n            let groups = this._mutually_exclusive_groups\n            formatter.add_usage(this.usage, positionals, groups, '')\n            kwargs.prog = formatter.format_help().trim()\n        }\n\n        // create the parsers action and add it to the positionals list\n        let parsers_class = this._pop_action_class(kwargs, 'parsers')\n        // eslint-disable-next-line new-cap\n        let action = new parsers_class(Object.assign({ option_strings: [] }, kwargs))\n        this._subparsers._add_action(action)\n\n        // return the created parsers action\n        return action\n    }\n\n    _add_action(action) {\n        if (action.option_strings.length) {\n            this._optionals._add_action(action)\n        } else {\n            this._positionals._add_action(action)\n        }\n        return action\n    }\n\n    _get_optional_actions() {\n        return this._actions.filter(action => action.option_strings.length)\n    }\n\n    _get_positional_actions() {\n        return this._actions.filter(action => !action.option_strings.length)\n    }\n\n    // =====================================\n    // Command line argument parsing methods\n    // =====================================\n    parse_args(args = undefined, namespace = undefined) {\n        let argv\n        [ args, argv ] = this.parse_known_args(args, namespace)\n        if (argv && argv.length > 0) {\n            let msg = 'unrecognized arguments: %s'\n            this.error(sub(msg, argv.join(' ')))\n        }\n        return args\n    }\n\n    parse_known_args(args = undefined, namespace = undefined) {\n        if (args === undefined) {\n            args = get_argv().slice(1)\n        }\n\n        // default Namespace built from parser defaults\n        if (namespace === undefined) {\n            namespace = new Namespace()\n        }\n\n        // add any action defaults that aren't present\n        for (let action of this._actions) {\n            if (action.dest !== SUPPRESS) {\n                if (!hasattr(namespace, action.dest)) {\n                    if (action.default !== SUPPRESS) {\n                        setattr(namespace, action.dest, action.default)\n                    }\n                }\n            }\n        }\n\n        // add any parser defaults that aren't present\n        for (let dest of Object.keys(this._defaults)) {\n            if (!hasattr(namespace, dest)) {\n                setattr(namespace, dest, this._defaults[dest])\n            }\n        }\n\n        // parse the arguments and exit if there are any errors\n        if (this.exit_on_error) {\n            try {\n                [ namespace, args ] = this._parse_known_args(args, namespace)\n            } catch (err) {\n                if (err instanceof ArgumentError) {\n                    this.error(err.message)\n                } else {\n                    throw err\n                }\n            }\n        } else {\n            [ namespace, args ] = this._parse_known_args(args, namespace)\n        }\n\n        if (hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR)) {\n            args = args.concat(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR))\n            delattr(namespace, _UNRECOGNIZED_ARGS_ATTR)\n        }\n\n        return [ namespace, args ]\n    }\n\n    _parse_known_args(arg_strings, namespace) {\n        // replace arg strings that are file references\n        if (this.fromfile_prefix_chars !== undefined) {\n            arg_strings = this._read_args_from_files(arg_strings)\n        }\n\n        // map all mutually exclusive arguments to the other arguments\n        // they can't occur with\n        let action_conflicts = new Map()\n        for (let mutex_group of this._mutually_exclusive_groups) {\n            let group_actions = mutex_group._group_actions\n            for (let [ i, mutex_action ] of Object.entries(mutex_group._group_actions)) {\n                let conflicts = action_conflicts.get(mutex_action) || []\n                conflicts = conflicts.concat(group_actions.slice(0, +i))\n                conflicts = conflicts.concat(group_actions.slice(+i + 1))\n                action_conflicts.set(mutex_action, conflicts)\n            }\n        }\n\n        // find all option indices, and determine the arg_string_pattern\n        // which has an 'O' if there is an option at an index,\n        // an 'A' if there is an argument, or a '-' if there is a '--'\n        let option_string_indices = {}\n        let arg_string_pattern_parts = []\n        let arg_strings_iter = Object.entries(arg_strings)[Symbol.iterator]()\n        for (let [ i, arg_string ] of arg_strings_iter) {\n\n            // all args after -- are non-options\n            if (arg_string === '--') {\n                arg_string_pattern_parts.push('-')\n                for ([ i, arg_string ] of arg_strings_iter) {\n                    arg_string_pattern_parts.push('A')\n                }\n\n            // otherwise, add the arg to the arg strings\n            // and note the index if it was an option\n            } else {\n                let option_tuple = this._parse_optional(arg_string)\n                let pattern\n                if (option_tuple === undefined) {\n                    pattern = 'A'\n                } else {\n                    option_string_indices[i] = option_tuple\n                    pattern = 'O'\n                }\n                arg_string_pattern_parts.push(pattern)\n            }\n        }\n\n        // join the pieces together to form the pattern\n        let arg_strings_pattern = arg_string_pattern_parts.join('')\n\n        // converts arg strings to the appropriate and then takes the action\n        let seen_actions = new Set()\n        let seen_non_default_actions = new Set()\n        let extras\n\n        let take_action = (action, argument_strings, option_string = undefined) => {\n            seen_actions.add(action)\n            let argument_values = this._get_values(action, argument_strings)\n\n            // error if this argument is not allowed with other previously\n            // seen arguments, assuming that actions that use the default\n            // value don't really count as \"present\"\n            if (argument_values !== action.default) {\n                seen_non_default_actions.add(action)\n                for (let conflict_action of action_conflicts.get(action) || []) {\n                    if (seen_non_default_actions.has(conflict_action)) {\n                        let msg = 'not allowed with argument %s'\n                        let action_name = _get_action_name(conflict_action)\n                        throw new ArgumentError(action, sub(msg, action_name))\n                    }\n                }\n            }\n\n            // take the action if we didn't receive a SUPPRESS value\n            // (e.g. from a default)\n            if (argument_values !== SUPPRESS) {\n                action(this, namespace, argument_values, option_string)\n            }\n        }\n\n        // function to convert arg_strings into an optional action\n        let consume_optional = start_index => {\n\n            // get the optional identified at this index\n            let option_tuple = option_string_indices[start_index]\n            let [ action, option_string, explicit_arg ] = option_tuple\n\n            // identify additional optionals in the same arg string\n            // (e.g. -xyz is the same as -x -y -z if no args are required)\n            let action_tuples = []\n            let stop\n            for (;;) {\n\n                // if we found no optional action, skip it\n                if (action === undefined) {\n                    extras.push(arg_strings[start_index])\n                    return start_index + 1\n                }\n\n                // if there is an explicit argument, try to match the\n                // optional's string arguments to only this\n                if (explicit_arg !== undefined) {\n                    let arg_count = this._match_argument(action, 'A')\n\n                    // if the action is a single-dash option and takes no\n                    // arguments, try to parse more single-dash options out\n                    // of the tail of the option string\n                    let chars = this.prefix_chars\n                    if (arg_count === 0 && !chars.includes(option_string[1])) {\n                        action_tuples.push([ action, [], option_string ])\n                        let char = option_string[0]\n                        option_string = char + explicit_arg[0]\n                        let new_explicit_arg = explicit_arg.slice(1) || undefined\n                        let optionals_map = this._option_string_actions\n                        if (hasattr(optionals_map, option_string)) {\n                            action = optionals_map[option_string]\n                            explicit_arg = new_explicit_arg\n                        } else {\n                            let msg = 'ignored explicit argument %r'\n                            throw new ArgumentError(action, sub(msg, explicit_arg))\n                        }\n\n                    // if the action expect exactly one argument, we've\n                    // successfully matched the option; exit the loop\n                    } else if (arg_count === 1) {\n                        stop = start_index + 1\n                        let args = [ explicit_arg ]\n                        action_tuples.push([ action, args, option_string ])\n                        break\n\n                    // error if a double-dash option did not use the\n                    // explicit argument\n                    } else {\n                        let msg = 'ignored explicit argument %r'\n                        throw new ArgumentError(action, sub(msg, explicit_arg))\n                    }\n\n                // if there is no explicit argument, try to match the\n                // optional's string arguments with the following strings\n                // if successful, exit the loop\n                } else {\n                    let start = start_index + 1\n                    let selected_patterns = arg_strings_pattern.slice(start)\n                    let arg_count = this._match_argument(action, selected_patterns)\n                    stop = start + arg_count\n                    let args = arg_strings.slice(start, stop)\n                    action_tuples.push([ action, args, option_string ])\n                    break\n                }\n            }\n\n            // add the Optional to the list and return the index at which\n            // the Optional's string args stopped\n            assert(action_tuples.length)\n            for (let [ action, args, option_string ] of action_tuples) {\n                take_action(action, args, option_string)\n            }\n            return stop\n        }\n\n        // the list of Positionals left to be parsed; this is modified\n        // by consume_positionals()\n        let positionals = this._get_positional_actions()\n\n        // function to convert arg_strings into positional actions\n        let consume_positionals = start_index => {\n            // match as many Positionals as possible\n            let selected_pattern = arg_strings_pattern.slice(start_index)\n            let arg_counts = this._match_arguments_partial(positionals, selected_pattern)\n\n            // slice off the appropriate arg strings for each Positional\n            // and add the Positional and its args to the list\n            for (let i = 0; i < positionals.length && i < arg_counts.length; i++) {\n                let action = positionals[i]\n                let arg_count = arg_counts[i]\n                let args = arg_strings.slice(start_index, start_index + arg_count)\n                start_index += arg_count\n                take_action(action, args)\n            }\n\n            // slice off the Positionals that we just parsed and return the\n            // index at which the Positionals' string args stopped\n            positionals = positionals.slice(arg_counts.length)\n            return start_index\n        }\n\n        // consume Positionals and Optionals alternately, until we have\n        // passed the last option string\n        extras = []\n        let start_index = 0\n        let max_option_string_index = Math.max(-1, ...Object.keys(option_string_indices).map(Number))\n        while (start_index <= max_option_string_index) {\n\n            // consume any Positionals preceding the next option\n            let next_option_string_index = Math.min(\n                // eslint-disable-next-line no-loop-func\n                ...Object.keys(option_string_indices).map(Number).filter(index => index >= start_index)\n            )\n            if (start_index !== next_option_string_index) {\n                let positionals_end_index = consume_positionals(start_index)\n\n                // only try to parse the next optional if we didn't consume\n                // the option string during the positionals parsing\n                if (positionals_end_index > start_index) {\n                    start_index = positionals_end_index\n                    continue\n                } else {\n                    start_index = positionals_end_index\n                }\n            }\n\n            // if we consumed all the positionals we could and we're not\n            // at the index of an option string, there were extra arguments\n            if (!(start_index in option_string_indices)) {\n                let strings = arg_strings.slice(start_index, next_option_string_index)\n                extras = extras.concat(strings)\n                start_index = next_option_string_index\n            }\n\n            // consume the next optional and any arguments for it\n            start_index = consume_optional(start_index)\n        }\n\n        // consume any positionals following the last Optional\n        let stop_index = consume_positionals(start_index)\n\n        // if we didn't consume all the argument strings, there were extras\n        extras = extras.concat(arg_strings.slice(stop_index))\n\n        // make sure all required actions were present and also convert\n        // action defaults which were not given as arguments\n        let required_actions = []\n        for (let action of this._actions) {\n            if (!seen_actions.has(action)) {\n                if (action.required) {\n                    required_actions.push(_get_action_name(action))\n                } else {\n                    // Convert action default now instead of doing it before\n                    // parsing arguments to avoid calling convert functions\n                    // twice (which may fail) if the argument was given, but\n                    // only if it was defined already in the namespace\n                    if (action.default !== undefined &&\n                        typeof action.default === 'string' &&\n                        hasattr(namespace, action.dest) &&\n                        action.default === getattr(namespace, action.dest)) {\n                        setattr(namespace, action.dest,\n                                this._get_value(action, action.default))\n                    }\n                }\n            }\n        }\n\n        if (required_actions.length) {\n            this.error(sub('the following arguments are required: %s',\n                       required_actions.join(', ')))\n        }\n\n        // make sure all required groups had one option present\n        for (let group of this._mutually_exclusive_groups) {\n            if (group.required) {\n                let no_actions_used = true\n                for (let action of group._group_actions) {\n                    if (seen_non_default_actions.has(action)) {\n                        no_actions_used = false\n                        break\n                    }\n                }\n\n                // if no actions were used, report the error\n                if (no_actions_used) {\n                    let names = group._group_actions\n                        .filter(action => action.help !== SUPPRESS)\n                        .map(action => _get_action_name(action))\n                    let msg = 'one of the arguments %s is required'\n                    this.error(sub(msg, names.join(' ')))\n                }\n            }\n        }\n\n        // return the updated namespace and the extra arguments\n        return [ namespace, extras ]\n    }\n\n    _read_args_from_files(arg_strings) {\n        // expand arguments referencing files\n        let new_arg_strings = []\n        for (let arg_string of arg_strings) {\n\n            // for regular arguments, just add them back into the list\n            if (!arg_string || !this.fromfile_prefix_chars.includes(arg_string[0])) {\n                new_arg_strings.push(arg_string)\n\n            // replace arguments referencing files with the file content\n            } else {\n                try {\n                    let args_file = fs.readFileSync(arg_string.slice(1), 'utf8')\n                    let arg_strings = []\n                    for (let arg_line of splitlines(args_file)) {\n                        for (let arg of this.convert_arg_line_to_args(arg_line)) {\n                            arg_strings.push(arg)\n                        }\n                    }\n                    arg_strings = this._read_args_from_files(arg_strings)\n                    new_arg_strings = new_arg_strings.concat(arg_strings)\n                } catch (err) {\n                    this.error(err.message)\n                }\n            }\n        }\n\n        // return the modified argument list\n        return new_arg_strings\n    }\n\n    convert_arg_line_to_args(arg_line) {\n        return [arg_line]\n    }\n\n    _match_argument(action, arg_strings_pattern) {\n        // match the pattern for this action to the arg strings\n        let nargs_pattern = this._get_nargs_pattern(action)\n        let match = arg_strings_pattern.match(new RegExp('^' + nargs_pattern))\n\n        // raise an exception if we weren't able to find a match\n        if (match === null) {\n            let nargs_errors = {\n                undefined: 'expected one argument',\n                [OPTIONAL]: 'expected at most one argument',\n                [ONE_OR_MORE]: 'expected at least one argument'\n            }\n            let msg = nargs_errors[action.nargs]\n            if (msg === undefined) {\n                msg = sub(action.nargs === 1 ? 'expected %s argument' : 'expected %s arguments', action.nargs)\n            }\n            throw new ArgumentError(action, msg)\n        }\n\n        // return the number of arguments matched\n        return match[1].length\n    }\n\n    _match_arguments_partial(actions, arg_strings_pattern) {\n        // progressively shorten the actions list by slicing off the\n        // final actions until we find a match\n        let result = []\n        for (let i of range(actions.length, 0, -1)) {\n            let actions_slice = actions.slice(0, i)\n            let pattern = actions_slice.map(action => this._get_nargs_pattern(action)).join('')\n            let match = arg_strings_pattern.match(new RegExp('^' + pattern))\n            if (match !== null) {\n                result = result.concat(match.slice(1).map(string => string.length))\n                break\n            }\n        }\n\n        // return the list of arg string counts\n        return result\n    }\n\n    _parse_optional(arg_string) {\n        // if it's an empty string, it was meant to be a positional\n        if (!arg_string) {\n            return undefined\n        }\n\n        // if it doesn't start with a prefix, it was meant to be positional\n        if (!this.prefix_chars.includes(arg_string[0])) {\n            return undefined\n        }\n\n        // if the option string is present in the parser, return the action\n        if (arg_string in this._option_string_actions) {\n            let action = this._option_string_actions[arg_string]\n            return [ action, arg_string, undefined ]\n        }\n\n        // if it's just a single character, it was meant to be positional\n        if (arg_string.length === 1) {\n            return undefined\n        }\n\n        // if the option string before the \"=\" is present, return the action\n        if (arg_string.includes('=')) {\n            let [ option_string, explicit_arg ] = _string_split(arg_string, '=', 1)\n            if (option_string in this._option_string_actions) {\n                let action = this._option_string_actions[option_string]\n                return [ action, option_string, explicit_arg ]\n            }\n        }\n\n        // search through all possible prefixes of the option string\n        // and all actions in the parser for possible interpretations\n        let option_tuples = this._get_option_tuples(arg_string)\n\n        // if multiple actions match, the option string was ambiguous\n        if (option_tuples.length > 1) {\n            let options = option_tuples.map(([ /*action*/, option_string/*, explicit_arg*/ ]) => option_string).join(', ')\n            let args = {option: arg_string, matches: options}\n            let msg = 'ambiguous option: %(option)s could match %(matches)s'\n            this.error(sub(msg, args))\n\n        // if exactly one action matched, this segmentation is good,\n        // so return the parsed action\n        } else if (option_tuples.length === 1) {\n            let [ option_tuple ] = option_tuples\n            return option_tuple\n        }\n\n        // if it was not found as an option, but it looks like a negative\n        // number, it was meant to be positional\n        // unless there are negative-number-like options\n        if (this._negative_number_matcher.test(arg_string)) {\n            if (!this._has_negative_number_optionals.length) {\n                return undefined\n            }\n        }\n\n        // if it contains a space, it was meant to be a positional\n        if (arg_string.includes(' ')) {\n            return undefined\n        }\n\n        // it was meant to be an optional but there is no such option\n        // in this parser (though it might be a valid option in a subparser)\n        return [ undefined, arg_string, undefined ]\n    }\n\n    _get_option_tuples(option_string) {\n        let result = []\n\n        // option strings starting with two prefix characters are only\n        // split at the '='\n        let chars = this.prefix_chars\n        if (chars.includes(option_string[0]) && chars.includes(option_string[1])) {\n            if (this.allow_abbrev) {\n                let option_prefix, explicit_arg\n                if (option_string.includes('=')) {\n                    [ option_prefix, explicit_arg ] = _string_split(option_string, '=', 1)\n                } else {\n                    option_prefix = option_string\n                    explicit_arg = undefined\n                }\n                for (let option_string of Object.keys(this._option_string_actions)) {\n                    if (option_string.startsWith(option_prefix)) {\n                        let action = this._option_string_actions[option_string]\n                        let tup = [ action, option_string, explicit_arg ]\n                        result.push(tup)\n                    }\n                }\n            }\n\n        // single character options can be concatenated with their arguments\n        // but multiple character options always have to have their argument\n        // separate\n        } else if (chars.includes(option_string[0]) && !chars.includes(option_string[1])) {\n            let option_prefix = option_string\n            let explicit_arg = undefined\n            let short_option_prefix = option_string.slice(0, 2)\n            let short_explicit_arg = option_string.slice(2)\n\n            for (let option_string of Object.keys(this._option_string_actions)) {\n                if (option_string === short_option_prefix) {\n                    let action = this._option_string_actions[option_string]\n                    let tup = [ action, option_string, short_explicit_arg ]\n                    result.push(tup)\n                } else if (option_string.startsWith(option_prefix)) {\n                    let action = this._option_string_actions[option_string]\n                    let tup = [ action, option_string, explicit_arg ]\n                    result.push(tup)\n                }\n            }\n\n        // shouldn't ever get here\n        } else {\n            this.error(sub('unexpected option string: %s', option_string))\n        }\n\n        // return the collected option tuples\n        return result\n    }\n\n    _get_nargs_pattern(action) {\n        // in all examples below, we have to allow for '--' args\n        // which are represented as '-' in the pattern\n        let nargs = action.nargs\n        let nargs_pattern\n\n        // the default (None) is assumed to be a single argument\n        if (nargs === undefined) {\n            nargs_pattern = '(-*A-*)'\n\n        // allow zero or one arguments\n        } else if (nargs === OPTIONAL) {\n            nargs_pattern = '(-*A?-*)'\n\n        // allow zero or more arguments\n        } else if (nargs === ZERO_OR_MORE) {\n            nargs_pattern = '(-*[A-]*)'\n\n        // allow one or more arguments\n        } else if (nargs === ONE_OR_MORE) {\n            nargs_pattern = '(-*A[A-]*)'\n\n        // allow any number of options or arguments\n        } else if (nargs === REMAINDER) {\n            nargs_pattern = '([-AO]*)'\n\n        // allow one argument followed by any number of options or arguments\n        } else if (nargs === PARSER) {\n            nargs_pattern = '(-*A[-AO]*)'\n\n        // suppress action, like nargs=0\n        } else if (nargs === SUPPRESS) {\n            nargs_pattern = '(-*-*)'\n\n        // all others should be integers\n        } else {\n            nargs_pattern = sub('(-*%s-*)', 'A'.repeat(nargs).split('').join('-*'))\n        }\n\n        // if this is an optional action, -- is not allowed\n        if (action.option_strings.length) {\n            nargs_pattern = nargs_pattern.replace(/-\\*/g, '')\n            nargs_pattern = nargs_pattern.replace(/-/g, '')\n        }\n\n        // return the pattern\n        return nargs_pattern\n    }\n\n    // ========================\n    // Alt command line argument parsing, allowing free intermix\n    // ========================\n\n    parse_intermixed_args(args = undefined, namespace = undefined) {\n        let argv\n        [ args, argv ] = this.parse_known_intermixed_args(args, namespace)\n        if (argv.length) {\n            let msg = 'unrecognized arguments: %s'\n            this.error(sub(msg, argv.join(' ')))\n        }\n        return args\n    }\n\n    parse_known_intermixed_args(args = undefined, namespace = undefined) {\n        // returns a namespace and list of extras\n        //\n        // positional can be freely intermixed with optionals.  optionals are\n        // first parsed with all positional arguments deactivated.  The 'extras'\n        // are then parsed.  If the parser definition is incompatible with the\n        // intermixed assumptions (e.g. use of REMAINDER, subparsers) a\n        // TypeError is raised.\n        //\n        // positionals are 'deactivated' by setting nargs and default to\n        // SUPPRESS.  This blocks the addition of that positional to the\n        // namespace\n\n        let extras\n        let positionals = this._get_positional_actions()\n        let a = positionals.filter(action => [ PARSER, REMAINDER ].includes(action.nargs))\n        if (a.length) {\n            throw new TypeError(sub('parse_intermixed_args: positional arg' +\n                                    ' with nargs=%s', a[0].nargs))\n        }\n\n        for (let group of this._mutually_exclusive_groups) {\n            for (let action of group._group_actions) {\n                if (positionals.includes(action)) {\n                    throw new TypeError('parse_intermixed_args: positional in' +\n                                        ' mutuallyExclusiveGroup')\n                }\n            }\n        }\n\n        let save_usage\n        try {\n            save_usage = this.usage\n            let remaining_args\n            try {\n                if (this.usage === undefined) {\n                    // capture the full usage for use in error messages\n                    this.usage = this.format_usage().slice(7)\n                }\n                for (let action of positionals) {\n                    // deactivate positionals\n                    action.save_nargs = action.nargs\n                    // action.nargs = 0\n                    action.nargs = SUPPRESS\n                    action.save_default = action.default\n                    action.default = SUPPRESS\n                }\n                [ namespace, remaining_args ] = this.parse_known_args(args,\n                                                                      namespace)\n                for (let action of positionals) {\n                    // remove the empty positional values from namespace\n                    let attr = getattr(namespace, action.dest)\n                    if (Array.isArray(attr) && attr.length === 0) {\n                        // eslint-disable-next-line no-console\n                        console.warn(sub('Do not expect %s in %s', action.dest, namespace))\n                        delattr(namespace, action.dest)\n                    }\n                }\n            } finally {\n                // restore nargs and usage before exiting\n                for (let action of positionals) {\n                    action.nargs = action.save_nargs\n                    action.default = action.save_default\n                }\n            }\n            let optionals = this._get_optional_actions()\n            try {\n                // parse positionals.  optionals aren't normally required, but\n                // they could be, so make sure they aren't.\n                for (let action of optionals) {\n                    action.save_required = action.required\n                    action.required = false\n                }\n                for (let group of this._mutually_exclusive_groups) {\n                    group.save_required = group.required\n                    group.required = false\n                }\n                [ namespace, extras ] = this.parse_known_args(remaining_args,\n                                                              namespace)\n            } finally {\n                // restore parser values before exiting\n                for (let action of optionals) {\n                    action.required = action.save_required\n                }\n                for (let group of this._mutually_exclusive_groups) {\n                    group.required = group.save_required\n                }\n            }\n        } finally {\n            this.usage = save_usage\n        }\n        return [ namespace, extras ]\n    }\n\n    // ========================\n    // Value conversion methods\n    // ========================\n    _get_values(action, arg_strings) {\n        // for everything but PARSER, REMAINDER args, strip out first '--'\n        if (![PARSER, REMAINDER].includes(action.nargs)) {\n            try {\n                _array_remove(arg_strings, '--')\n            } catch (err) {}\n        }\n\n        let value\n        // optional argument produces a default when not present\n        if (!arg_strings.length && action.nargs === OPTIONAL) {\n            if (action.option_strings.length) {\n                value = action.const\n            } else {\n                value = action.default\n            }\n            if (typeof value === 'string') {\n                value = this._get_value(action, value)\n                this._check_value(action, value)\n            }\n\n        // when nargs='*' on a positional, if there were no command-line\n        // args, use the default if it is anything other than None\n        } else if (!arg_strings.length && action.nargs === ZERO_OR_MORE &&\n              !action.option_strings.length) {\n            if (action.default !== undefined) {\n                value = action.default\n            } else {\n                value = arg_strings\n            }\n            this._check_value(action, value)\n\n        // single argument or optional argument produces a single value\n        } else if (arg_strings.length === 1 && [undefined, OPTIONAL].includes(action.nargs)) {\n            let arg_string = arg_strings[0]\n            value = this._get_value(action, arg_string)\n            this._check_value(action, value)\n\n        // REMAINDER arguments convert all values, checking none\n        } else if (action.nargs === REMAINDER) {\n            value = arg_strings.map(v => this._get_value(action, v))\n\n        // PARSER arguments convert all values, but check only the first\n        } else if (action.nargs === PARSER) {\n            value = arg_strings.map(v => this._get_value(action, v))\n            this._check_value(action, value[0])\n\n        // SUPPRESS argument does not put anything in the namespace\n        } else if (action.nargs === SUPPRESS) {\n            value = SUPPRESS\n\n        // all other types of nargs produce a list\n        } else {\n            value = arg_strings.map(v => this._get_value(action, v))\n            for (let v of value) {\n                this._check_value(action, v)\n            }\n        }\n\n        // return the converted value\n        return value\n    }\n\n    _get_value(action, arg_string) {\n        let type_func = this._registry_get('type', action.type, action.type)\n        if (typeof type_func !== 'function') {\n            let msg = '%r is not callable'\n            throw new ArgumentError(action, sub(msg, type_func))\n        }\n\n        // convert the value to the appropriate type\n        let result\n        try {\n            try {\n                result = type_func(arg_string)\n            } catch (err) {\n                // Dear TC39, why would you ever consider making es6 classes not callable?\n                // We had one universal interface, [[Call]], which worked for anything\n                // (with familiar this-instanceof guard for classes). Now we have two.\n                if (err instanceof TypeError &&\n                    /Class constructor .* cannot be invoked without 'new'/.test(err.message)) {\n                    // eslint-disable-next-line new-cap\n                    result = new type_func(arg_string)\n                } else {\n                    throw err\n                }\n            }\n\n        } catch (err) {\n            // ArgumentTypeErrors indicate errors\n            if (err instanceof ArgumentTypeError) {\n                //let name = getattr(action.type, 'name', repr(action.type))\n                let msg = err.message\n                throw new ArgumentError(action, msg)\n\n            // TypeErrors or ValueErrors also indicate errors\n            } else if (err instanceof TypeError) {\n                let name = getattr(action.type, 'name', repr(action.type))\n                let args = {type: name, value: arg_string}\n                let msg = 'invalid %(type)s value: %(value)r'\n                throw new ArgumentError(action, sub(msg, args))\n            } else {\n                throw err\n            }\n        }\n\n        // return the converted value\n        return result\n    }\n\n    _check_value(action, value) {\n        // converted value must be one of the choices (if specified)\n        if (action.choices !== undefined && !_choices_to_array(action.choices).includes(value)) {\n            let args = {value,\n                        choices: _choices_to_array(action.choices).map(repr).join(', ')}\n            let msg = 'invalid choice: %(value)r (choose from %(choices)s)'\n            throw new ArgumentError(action, sub(msg, args))\n        }\n    }\n\n    // =======================\n    // Help-formatting methods\n    // =======================\n    format_usage() {\n        let formatter = this._get_formatter()\n        formatter.add_usage(this.usage, this._actions,\n                            this._mutually_exclusive_groups)\n        return formatter.format_help()\n    }\n\n    format_help() {\n        let formatter = this._get_formatter()\n\n        // usage\n        formatter.add_usage(this.usage, this._actions,\n                            this._mutually_exclusive_groups)\n\n        // description\n        formatter.add_text(this.description)\n\n        // positionals, optionals and user-defined groups\n        for (let action_group of this._action_groups) {\n            formatter.start_section(action_group.title)\n            formatter.add_text(action_group.description)\n            formatter.add_arguments(action_group._group_actions)\n            formatter.end_section()\n        }\n\n        // epilog\n        formatter.add_text(this.epilog)\n\n        // determine help from format above\n        return formatter.format_help()\n    }\n\n    _get_formatter() {\n        // eslint-disable-next-line new-cap\n        return new this.formatter_class({ prog: this.prog })\n    }\n\n    // =====================\n    // Help-printing methods\n    // =====================\n    print_usage(file = undefined) {\n        if (file === undefined) file = process.stdout\n        this._print_message(this.format_usage(), file)\n    }\n\n    print_help(file = undefined) {\n        if (file === undefined) file = process.stdout\n        this._print_message(this.format_help(), file)\n    }\n\n    _print_message(message, file = undefined) {\n        if (message) {\n            if (file === undefined) file = process.stderr\n            file.write(message)\n        }\n    }\n\n    // ===============\n    // Exiting methods\n    // ===============\n    exit(status = 0, message = undefined) {\n        if (message) {\n            this._print_message(message, process.stderr)\n        }\n        process.exit(status)\n    }\n\n    error(message) {\n        /*\n         *  error(message: string)\n         *\n         *  Prints a usage message incorporating the message to stderr and\n         *  exits.\n         *\n         *  If you override this in a subclass, it should not return -- it\n         *  should either exit or raise an exception.\n         */\n\n        // LEGACY (v1 compatibility), debug mode\n        if (this.debug === true) throw new Error(message)\n        // end\n        this.print_usage(process.stderr)\n        let args = {prog: this.prog, message: message}\n        this.exit(2, sub('%(prog)s: error: %(message)s\\n', args))\n    }\n}))\n\n\nmodule.exports = {\n    ArgumentParser,\n    ArgumentError,\n    ArgumentTypeError,\n    BooleanOptionalAction,\n    FileType,\n    HelpFormatter,\n    ArgumentDefaultsHelpFormatter,\n    RawDescriptionHelpFormatter,\n    RawTextHelpFormatter,\n    MetavarTypeHelpFormatter,\n    Namespace,\n    Action,\n    ONE_OR_MORE,\n    OPTIONAL,\n    PARSER,\n    REMAINDER,\n    SUPPRESS,\n    ZERO_OR_MORE\n}\n\n// LEGACY (v1 compatibility), Const alias\nObject.defineProperty(module.exports, 'Const', {\n    get() {\n        let result = {}\n        Object.entries({ ONE_OR_MORE, OPTIONAL, PARSER, REMAINDER, SUPPRESS, ZERO_OR_MORE }).forEach(([ n, v ]) => {\n            Object.defineProperty(result, n, {\n                get() {\n                    deprecate(n, sub('use argparse.%s instead of argparse.Const.%s', n, n))\n                    return v\n                }\n            })\n        })\n        Object.entries({ _UNRECOGNIZED_ARGS_ATTR }).forEach(([ n, v ]) => {\n            Object.defineProperty(result, n, {\n                get() {\n                    deprecate(n, sub('argparse.Const.%s is an internal symbol and will no longer be available', n))\n                    return v\n                }\n            })\n        })\n        return result\n    },\n    enumerable: false\n})\n// end\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}