{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nconst definition = {\n  type: 'object',\n  properties: {\n    multiline: {\n      type: 'object',\n      properties: {\n        delimiter: {\n          enum: ['none', 'semi', 'comma']\n        },\n        requireLast: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    },\n    singleline: {\n      type: 'object',\n      properties: {\n        // note can't have \"none\" for single line delimiter as it's invalid syntax\n        delimiter: {\n          enum: ['semi', 'comma']\n        },\n        requireLast: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }\n  },\n  additionalProperties: false\n};\n\nconst isLastTokenEndOfLine = (token, line) => {\n  const positionInLine = token.loc.start.column;\n  return positionInLine === line.length - 1;\n};\n\nconst isCommentsEndOfLine = (token, comments, line) => {\n  if (!comments) {\n    return false;\n  }\n\n  if (comments.loc.end.line > token.loc.end.line) {\n    return true;\n  }\n\n  const positionInLine = comments.loc.end.column;\n  return positionInLine === line.length;\n};\n\nconst makeFixFunction = _ref => {\n  let {\n    optsNone,\n    optsSemi,\n    lastToken,\n    commentsAfterLastToken,\n    missingDelimiter,\n    lastTokenLine,\n    isSingleLine\n  } = _ref;\n\n  // if removing is the action but last token is not the end of the line\n  if (optsNone && !isLastTokenEndOfLine(lastToken, lastTokenLine) && !isCommentsEndOfLine(lastToken, commentsAfterLastToken, lastTokenLine) && !isSingleLine) {\n    return null;\n  }\n\n  return fixer => {\n    if (optsNone) {\n      // remove the unneeded token\n      return fixer.remove(lastToken);\n    }\n\n    const token = optsSemi ? ';' : ',';\n\n    if (missingDelimiter) {\n      // add the missing delimiter\n      return fixer.insertTextAfter(lastToken, token);\n    } // correct the current delimiter\n\n\n    return fixer.replaceText(lastToken, token);\n  };\n};\n\nexports.default = util.createRule({\n  name: 'member-delimiter-style',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Require a specific member delimiter style for interfaces and type literals',\n      recommended: false\n    },\n    fixable: 'code',\n    messages: {\n      unexpectedComma: 'Unexpected separator (,).',\n      unexpectedSemi: 'Unexpected separator (;).',\n      expectedComma: 'Expected a comma.',\n      expectedSemi: 'Expected a semicolon.'\n    },\n    schema: [{\n      type: 'object',\n      properties: Object.assign({}, definition.properties, {\n        overrides: {\n          type: 'object',\n          properties: {\n            interface: definition,\n            typeLiteral: definition\n          },\n          additionalProperties: false\n        },\n        multilineDetection: {\n          enum: ['brackets', 'last-member']\n        }\n      }),\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    multiline: {\n      delimiter: 'semi',\n      requireLast: true\n    },\n    singleline: {\n      delimiter: 'semi',\n      requireLast: false\n    },\n    multilineDetection: 'brackets'\n  }],\n\n  create(context, _ref2) {\n    let [options] = _ref2;\n\n    var _a;\n\n    const sourceCode = context.getSourceCode(); // use the base options as the defaults for the cases\n\n    const baseOptions = options;\n    const overrides = (_a = baseOptions.overrides) !== null && _a !== void 0 ? _a : {};\n    const interfaceOptions = util.deepMerge(baseOptions, overrides.interface);\n    const typeLiteralOptions = util.deepMerge(baseOptions, overrides.typeLiteral);\n    /**\n     * Check the last token in the given member.\n     * @param member the member to be evaluated.\n     * @param opts the options to be validated.\n     * @param isLast a flag indicating `member` is the last in the interface or type literal.\n     */\n\n    function checkLastToken(member, opts, isLast) {\n      /**\n       * Resolves the boolean value for the given setting enum value\n       * @param type the option name\n       */\n      function getOption(type) {\n        if (isLast && !opts.requireLast) {\n          // only turn the option on if its expecting no delimiter for the last member\n          return type === 'none';\n        }\n\n        return opts.delimiter === type;\n      }\n\n      let messageId = null;\n      let missingDelimiter = false;\n      const lastToken = sourceCode.getLastToken(member, {\n        includeComments: false\n      });\n\n      if (!lastToken) {\n        return;\n      }\n\n      const commentsAfterLastToken = sourceCode.getCommentsAfter(lastToken).pop();\n      const sourceCodeLines = sourceCode.getLines();\n      const lastTokenLine = sourceCodeLines[(lastToken === null || lastToken === void 0 ? void 0 : lastToken.loc.start.line) - 1];\n      const optsSemi = getOption('semi');\n      const optsComma = getOption('comma');\n      const optsNone = getOption('none');\n\n      if (lastToken.value === ';') {\n        if (optsComma) {\n          messageId = 'expectedComma';\n        } else if (optsNone) {\n          missingDelimiter = true;\n          messageId = 'unexpectedSemi';\n        }\n      } else if (lastToken.value === ',') {\n        if (optsSemi) {\n          messageId = 'expectedSemi';\n        } else if (optsNone) {\n          missingDelimiter = true;\n          messageId = 'unexpectedComma';\n        }\n      } else {\n        if (optsSemi) {\n          missingDelimiter = true;\n          messageId = 'expectedSemi';\n        } else if (optsComma) {\n          missingDelimiter = true;\n          messageId = 'expectedComma';\n        }\n      }\n\n      if (messageId) {\n        context.report({\n          node: lastToken,\n          loc: {\n            start: {\n              line: lastToken.loc.end.line,\n              column: lastToken.loc.end.column\n            },\n            end: {\n              line: lastToken.loc.end.line,\n              column: lastToken.loc.end.column\n            }\n          },\n          messageId,\n          fix: makeFixFunction({\n            optsNone,\n            optsSemi,\n            lastToken,\n            commentsAfterLastToken,\n            missingDelimiter,\n            lastTokenLine,\n            isSingleLine: opts.type === 'single-line'\n          })\n        });\n      }\n    }\n    /**\n     * Check the member separator being used matches the delimiter.\n     * @param {ASTNode} node the node to be evaluated.\n     */\n\n\n    function checkMemberSeparatorStyle(node) {\n      const members = node.type === utils_1.AST_NODE_TYPES.TSInterfaceBody ? node.body : node.members;\n      let isSingleLine = node.loc.start.line === node.loc.end.line;\n\n      if (options.multilineDetection === 'last-member' && !isSingleLine && members.length > 0) {\n        const lastMember = members[members.length - 1];\n\n        if (lastMember.loc.end.line === node.loc.end.line) {\n          isSingleLine = true;\n        }\n      }\n\n      const typeOpts = node.type === utils_1.AST_NODE_TYPES.TSInterfaceBody ? interfaceOptions : typeLiteralOptions;\n      const opts = isSingleLine ? Object.assign(Object.assign({}, typeOpts.singleline), {\n        type: 'single-line'\n      }) : Object.assign(Object.assign({}, typeOpts.multiline), {\n        type: 'multi-line'\n      });\n      members.forEach((member, index) => {\n        checkLastToken(member, opts !== null && opts !== void 0 ? opts : {}, index === members.length - 1);\n      });\n    }\n\n    return {\n      TSInterfaceBody: checkMemberSeparatorStyle,\n      TSTypeLiteral: checkMemberSeparatorStyle\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["definition","type","properties","multiline","delimiter","enum","requireLast","additionalProperties","singleline","isLastTokenEndOfLine","token","line","positionInLine","loc","start","column","length","isCommentsEndOfLine","comments","end","makeFixFunction","optsNone","optsSemi","lastToken","commentsAfterLastToken","missingDelimiter","lastTokenLine","isSingleLine","fixer","remove","insertTextAfter","replaceText","exports","util","createRule","name","meta","docs","description","recommended","fixable","messages","unexpectedComma","unexpectedSemi","expectedComma","expectedSemi","schema","Object","assign","overrides","interface","typeLiteral","multilineDetection","defaultOptions","create","context","options","sourceCode","getSourceCode","baseOptions","_a","interfaceOptions","deepMerge","typeLiteralOptions","checkLastToken","member","opts","isLast","getOption","messageId","getLastToken","includeComments","getCommentsAfter","pop","sourceCodeLines","getLines","optsComma","value","report","node","fix","checkMemberSeparatorStyle","members","utils_1","TSInterfaceBody","body","lastMember","typeOpts","forEach","index","TSTypeLiteral"],"sources":["../../src/rules/member-delimiter-style.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}