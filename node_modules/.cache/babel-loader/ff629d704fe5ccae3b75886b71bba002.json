{"ast":null,"code":"/**\n * Module dependencies.\n */\nconst EventEmitter = require('events').EventEmitter;\n\nconst childProcess = require('child_process');\n\nconst path = require('path');\n\nconst fs = require('fs'); // @ts-check\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\n\n\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n  }\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const args = cmd._helpCommandnameAndArgs.split(/ +/);\n\n      const helpCommand = cmd.createCommand(args.shift()).helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n\n      helpCommand._parseExpectedArgs(args);\n\n      visibleCommands.push(helpCommand);\n    }\n\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        return a.name().localeCompare(b.name());\n      });\n    }\n\n    return visibleCommands;\n  }\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter(option => !option.hidden); // Implicit help\n\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n\n      visibleOptions.push(helpOption);\n    }\n\n    if (this.sortOptions) {\n      const getSortKey = option => {\n        // WYSIWYG for order displayed in help with short before long, no special handling for negated.\n        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n      };\n\n      visibleOptions.sort((a, b) => {\n        return getSortKey(a).localeCompare(getSortKey(b));\n      });\n    }\n\n    return visibleOptions;\n  }\n  /**\n   * Get an array of the arguments which have descriptions.\n   *\n   * @param {Command} cmd\n   * @returns {{ term: string, description:string }[]}\n   */\n\n\n  visibleArguments(cmd) {\n    if (cmd._argsDescription && cmd._args.length) {\n      return cmd._args.map(argument => {\n        return {\n          term: argument.name,\n          description: cmd._argsDescription[argument.name] || ''\n        };\n      }, 0);\n    }\n\n    return [];\n  }\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');\n\n    return cmd._name + (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') + (cmd.options.length ? ' [options]' : '') + ( // simplistic check for non-help option\n    args ? ' ' + args : '');\n  }\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n\n  optionTerm(option) {\n    return option.flags;\n  }\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, argument.term.length);\n    }, 0);\n  }\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n\n    let parentCmdNames = '';\n\n    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {\n      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n    }\n\n    return parentCmdNames + cmdName + ' ' + cmd.usage();\n  }\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n  /**\n   * Get the command description to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n\n  optionDescription(option) {\n    if (option.negate) {\n      return option.description;\n    }\n\n    const extraInfo = [];\n\n    if (option.argChoices) {\n      extraInfo.push( // use stringify to match the display of the default value\n      `choices: ${option.argChoices.map(choice => JSON.stringify(choice)).join(', ')}`);\n    }\n\n    if (option.defaultValue !== undefined) {\n      extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n    }\n\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n\n    return option.description;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n\n      return term;\n    }\n\n    ;\n\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    } // Usage\n\n\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, '']; // Description\n\n    const commandDescription = helper.commandDescription(cmd);\n\n    if (commandDescription.length > 0) {\n      output = output.concat([commandDescription, '']);\n    } // Arguments\n\n\n    const argumentList = helper.visibleArguments(cmd).map(argument => {\n      return formatItem(argument.term, argument.description);\n    });\n\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    } // Options\n\n\n    const optionList = helper.visibleOptions(cmd).map(option => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    } // Commands\n\n\n    const commandList = helper.visibleCommands(cmd).map(cmd => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n\n  padWidth(cmd, helper) {\n    return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));\n  }\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n  wrap(str, width, indent) {\n    let minColumnWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 40;\n    // Detect manually wrapped and indented strings by searching for line breaks\n    // followed by multiple spaces/tabs.\n    if (str.match(/[\\n]\\s+/)) return str; // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n    const leadingStr = str.substr(0, indent);\n    const columnText = str.substr(indent);\n    const indentString = ' '.repeat(indent);\n    const regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\\\s\\u200B]|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]|$)', 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line.slice(-1) === '\\n') {\n        line = line.slice(0, line.length - 1);\n      }\n\n      return (i > 0 ? indentString : '') + line.trimRight();\n    }).join('\\n');\n  }\n\n}\n\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   */\n  constructor(flags, description) {\n    this.flags = flags;\n    this.description = description || '';\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n\n    const optionFlags = _parseOptionFlags(flags);\n\n    this.short = optionFlags.shortFlag;\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.parseArg = undefined;\n    this.hidden = false;\n    this.argChoices = undefined;\n  }\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {any} value\n   * @param {string} [description]\n   * @return {Option}\n   */\n\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   *\n   * @param {Function} [fn]\n   * @return {Option}\n   */\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   *\n   * @param {boolean} [mandatory=true]\n   * @return {Option}\n   */\n  makeOptionMandatory() {\n    let mandatory = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.mandatory = !!mandatory;\n    return this;\n  }\n\n  /**\n   * Hide option in help.\n   *\n   * @param {boolean} [hide=true]\n   * @return {Option}\n   */\n  hideHelp() {\n    let hide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.hidden = !!hide;\n    return this;\n  }\n\n  /**\n   * @api private\n   */\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Option}\n   */\n\n\n  choices(values) {\n    this.argChoices = values;\n\n    this.parseArg = (arg, previous) => {\n      if (!values.includes(arg)) {\n        throw new InvalidOptionArgumentError(`Allowed choices are ${values.join(', ')}.`);\n      }\n\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n\n      return arg;\n    };\n\n    return this;\n  }\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   */\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n\n    return this.short.replace(/^-/, '');\n  }\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   *\n   * @return {string}\n   * @api private\n   */\n  attributeName() {\n    return camelcase(this.name().replace(/^no-/, ''));\n  }\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @api private\n   */\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  }\n\n}\n/**\n * CommanderError class\n * @class\n */\n\n\nclass CommanderError extends Error {\n  /**\n   * Constructs the CommanderError class\n   * @param {number} exitCode suggested exit code which could be used with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @constructor\n   */\n  constructor(exitCode, code, message) {\n    super(message); // properly capture stack trace in Node.js\n\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.exitCode = exitCode;\n    this.nestedError = undefined;\n  }\n\n}\n/**\n * InvalidOptionArgumentError class\n * @class\n */\n\n\nclass InvalidOptionArgumentError extends CommanderError {\n  /**\n   * Constructs the InvalidOptionArgumentError class\n   * @param {string} [message] explanation of why argument is invalid\n   * @constructor\n   */\n  constructor(message) {\n    super(1, 'commander.invalidOptionArgument', message); // properly capture stack trace in Node.js\n\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n  }\n\n}\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n  constructor(name) {\n    super();\n    this.commands = [];\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    this._args = [];\n    this.rawArgs = null;\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._storeOptionsAsProperties = false;\n    this._actionResults = [];\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._argsDescription = undefined;\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false; // see .configureOutput() for docs\n\n    this._outputConfiguration = {\n      writeOut: str => process.stdout.write(str),\n      writeErr: str => process.stderr.write(str),\n      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str)\n    };\n    this._hidden = false;\n    this._hasHelpOption = true;\n    this._helpFlags = '-h, --help';\n    this._helpDescription = 'display help for command';\n    this._helpShortFlag = '-h';\n    this._helpLongFlag = '--help';\n    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false\n\n    this._helpCommandName = 'help';\n    this._helpCommandnameAndArgs = 'help [command]';\n    this._helpCommandDescription = 'display help for command';\n    this._helpConfiguration = {};\n  }\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * Examples:\n   *\n   *      // Command implemented using action handler (description is supplied separately to `.command`)\n   *      program\n   *        .command('clone <source> [destination]')\n   *        .description('clone a repository into a newly created directory')\n   *        .action((source, destination) => {\n   *          console.log('clone command called');\n   *        });\n   *\n   *      // Command implemented using separate executable file (description is second parameter to `.command`)\n   *      program\n   *        .command('start <service>', 'start named service')\n   *        .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n\n    opts = opts || {};\n    const args = nameAndArgs.split(/ +/);\n    const cmd = this.createCommand(args.shift());\n\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    cmd._outputConfiguration = this._outputConfiguration;\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n\n    cmd._hasHelpOption = this._hasHelpOption;\n    cmd._helpFlags = this._helpFlags;\n    cmd._helpDescription = this._helpDescription;\n    cmd._helpShortFlag = this._helpShortFlag;\n    cmd._helpLongFlag = this._helpLongFlag;\n    cmd._helpCommandName = this._helpCommandName;\n    cmd._helpCommandnameAndArgs = this._helpCommandnameAndArgs;\n    cmd._helpCommandDescription = this._helpCommandDescription;\n    cmd._helpConfiguration = this._helpConfiguration;\n    cmd._exitCallback = this._exitCallback;\n    cmd._storeOptionsAsProperties = this._storeOptionsAsProperties;\n    cmd._combineFlagAndOptionalValue = this._combineFlagAndOptionalValue;\n    cmd._allowExcessArguments = this._allowExcessArguments;\n    cmd._enablePositionalOptions = this._enablePositionalOptions;\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n\n    this.commands.push(cmd);\n\n    cmd._parseExpectedArgs(args);\n\n    cmd.parent = this;\n    if (desc) return this;\n    return cmd;\n  }\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n  createCommand(name) {\n    return new Command(name);\n  }\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  }\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n    this._helpConfiguration = configuration;\n    return this;\n  }\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *    // functions to change where being written, stdout and stderr\n   *    writeOut(str)\n   *    writeErr(str)\n   *    // matching functions to specify width for wrapping help\n   *    getOutHelpWidth()\n   *    getErrHelpWidth()\n   *    // functions based on what is being written out\n   *    outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) throw new Error('Command passed to .addCommand() must have a name'); // To keep things simple, block automatic name generation for deeply nested executables.\n    // Fail fast and detect when adding rather than later when parsing.\n\n    function checkExplicitNames(commandArray) {\n      commandArray.forEach(cmd => {\n        if (cmd._executableHandler && !cmd._executableFile) {\n          throw new Error(`Must specify executableFile for deeply nested executable: ${cmd.name()}`);\n        }\n\n        checkExplicitNames(cmd.commands);\n      });\n    }\n\n    checkExplicitNames(cmd.commands);\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this.commands.push(cmd);\n    cmd.parent = this;\n    return this;\n  }\n\n  /**\n   * Define argument syntax for the command.\n   */\n  arguments(desc) {\n    return this._parseExpectedArgs(desc.split(/ +/));\n  }\n\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   *    addHelpCommand() // force on\n   *    addHelpCommand(false); // force off\n   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   *\n   * @return {Command} `this` command for chaining\n   */\n  addHelpCommand(enableOrNameAndArgs, description) {\n    if (enableOrNameAndArgs === false) {\n      this._addImplicitHelpCommand = false;\n    } else {\n      this._addImplicitHelpCommand = true;\n\n      if (typeof enableOrNameAndArgs === 'string') {\n        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];\n        this._helpCommandnameAndArgs = enableOrNameAndArgs;\n      }\n\n      this._helpCommandDescription = description || this._helpCommandDescription;\n    }\n\n    return this;\n  }\n\n  /**\n   * @return {boolean}\n   * @api private\n   */\n  _hasImplicitHelpCommand() {\n    if (this._addImplicitHelpCommand === undefined) {\n      return this.commands.length && !this._actionHandler && !this._findCommand('help');\n    }\n\n    return this._addImplicitHelpCommand;\n  }\n\n  /**\n   * Parse expected `args`.\n   *\n   * For example `[\"[type]\"]` becomes `[{ required: false, name: 'type' }]`.\n   *\n   * @param {Array} args\n   * @return {Command} `this` command for chaining\n   * @api private\n   */\n  _parseExpectedArgs(args) {\n    if (!args.length) return;\n    args.forEach(arg => {\n      const argDetails = {\n        required: false,\n        name: '',\n        variadic: false\n      };\n\n      switch (arg[0]) {\n        case '<':\n          argDetails.required = true;\n          argDetails.name = arg.slice(1, -1);\n          break;\n\n        case '[':\n          argDetails.name = arg.slice(1, -1);\n          break;\n      }\n\n      if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {\n        argDetails.variadic = true;\n        argDetails.name = argDetails.name.slice(0, -3);\n      }\n\n      if (argDetails.name) {\n        this._args.push(argDetails);\n      }\n    });\n\n    this._args.forEach((arg, i) => {\n      if (arg.variadic && i < this._args.length - 1) {\n        throw new Error(`only the last argument can be variadic '${arg.name}'`);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = err => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {// Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n\n    return this;\n  }\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @api private\n   */\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message)); // Expecting this line is not reached.\n\n    }\n\n    process.exit(exitCode);\n  }\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * Examples:\n   *\n   *      program\n   *        .command('help')\n   *        .description('display verbose help')\n   *        .action(function() {\n   *           // output help here\n   *        });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n  action(fn) {\n    const listener = args => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this._args.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n\n      actionArgs.push(this);\n      const actionResult = fn.apply(this, actionArgs); // Remember result in case it is async. Assume parseAsync getting called on root.\n\n      let rootCommand = this;\n\n      while (rootCommand.parent) {\n        rootCommand = rootCommand.parent;\n      }\n\n      rootCommand._actionResults.push(actionResult);\n    };\n\n    this._actionHandler = listener;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n  createOption(flags, description) {\n    return new Option(flags, description);\n  }\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    const oname = option.name();\n    const name = option.attributeName();\n    let defaultValue = option.defaultValue; // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value\n\n    if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {\n      // when --no-foo we make sure default is true, unless a --foo option is already defined\n      if (option.negate) {\n        const positiveLongFlag = option.long.replace(/^--no-/, '--');\n        defaultValue = this._findOption(positiveLongFlag) ? this._getOptionValue(name) : true;\n      } // preassign only if we have a default\n\n\n      if (defaultValue !== undefined) {\n        this._setOptionValue(name, defaultValue);\n      }\n    } // register the option\n\n\n    this.options.push(option); // when it's passed assign the value\n    // and conditionally invoke the callback\n\n    this.on('option:' + oname, val => {\n      const oldValue = this._getOptionValue(name); // custom processing\n\n\n      if (val !== null && option.parseArg) {\n        try {\n          val = option.parseArg(val, oldValue === undefined ? defaultValue : oldValue);\n        } catch (err) {\n          if (err.code === 'commander.invalidOptionArgument') {\n            const message = `error: option '${option.flags}' argument '${val}' is invalid. ${err.message}`;\n\n            this._displayError(err.exitCode, err.code, message);\n          }\n\n          throw err;\n        }\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      } // unassigned or boolean value\n\n\n      if (typeof oldValue === 'boolean' || typeof oldValue === 'undefined') {\n        // if no value, negate false, and we have a default, then use it!\n        if (val == null) {\n          this._setOptionValue(name, option.negate ? false : defaultValue || true);\n        } else {\n          this._setOptionValue(name, val);\n        }\n      } else if (val !== null) {\n        // reassign\n        this._setOptionValue(name, option.negate ? false : val);\n      }\n    });\n    return this;\n  }\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @api private\n   */\n\n\n  _optionEx(config, flags, description, fn, defaultValue) {\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n  /**\n   * Define option with `flags`, `description` and optional\n   * coercion `fn`.\n   *\n   * The `flags` string contains the short and/or long flags,\n   * separated by comma, a pipe or space. The following are all valid\n   * all will output this way when `--help` is used.\n   *\n   *    \"-p, --pepper\"\n   *    \"-p|--pepper\"\n   *    \"-p --pepper\"\n   *\n   * Examples:\n   *\n   *     // simple boolean defaulting to undefined\n   *     program.option('-p, --pepper', 'add pepper');\n   *\n   *     program.pepper\n   *     // => undefined\n   *\n   *     --pepper\n   *     program.pepper\n   *     // => true\n   *\n   *     // simple boolean defaulting to true (unless non-negated option is also defined)\n   *     program.option('-C, --no-cheese', 'remove cheese');\n   *\n   *     program.cheese\n   *     // => true\n   *\n   *     --no-cheese\n   *     program.cheese\n   *     // => false\n   *\n   *     // required argument\n   *     program.option('-C, --chdir <path>', 'change the working directory');\n   *\n   *     --chdir /tmp\n   *     program.chdir\n   *     // => \"/tmp\"\n   *\n   *     // optional argument\n   *     program.option('-c, --cheese [type]', 'add cheese [marble]');\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n\n  option(flags, description, fn, defaultValue) {\n    return this._optionEx({}, flags, description, fn, defaultValue);\n  }\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} [description]\n  * @param {Function|*} [fn] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  */\n  requiredOption(flags, description, fn, defaultValue) {\n    return this._optionEx({\n      mandatory: true\n    }, flags, description, fn, defaultValue);\n  }\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * Examples:\n   *\n   *    // for `.option('-f,--flag [value]'):\n   *    .combineFlagAndOptionalValue(true)  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   *    .combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.\n   */\n  combineFlagAndOptionalValue() {\n    let combine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  }\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   */\n  allowUnknownOption() {\n    let allowUnknown = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  }\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown\n   * for excess arguments.\n   */\n  allowExcessArguments() {\n    let allowExcess = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  }\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {Boolean} [positional=true]\n   */\n  enablePositionalOptions() {\n    let positional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._enablePositionalOptions = !!positional;\n    return this;\n  }\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {Boolean} [passThrough=true]\n   * for unknown options.\n   */\n  passThroughOptions() {\n    let passThrough = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._passThroughOptions = !!passThrough;\n\n    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {\n      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');\n    }\n\n    return this;\n  }\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} [storeAsProperties=true]\n    * @return {Command} `this` command for chaining\n    */\n  storeOptionsAsProperties() {\n    let storeAsProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._storeOptionsAsProperties = !!storeAsProperties;\n\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n\n    return this;\n  }\n\n  /**\n   * Store option value\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @api private\n   */\n  _setOptionValue(key, value) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n  }\n\n  /**\n   * Retrieve option value\n   *\n   * @param {string} key\n   * @return {Object} value\n   * @api private\n   */\n  _getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n\n    return this._optionValues[key];\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * Examples:\n   *\n   *      program.parse(process.argv);\n   *      program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   *      program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n  parse(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n\n    parseOptions = parseOptions || {}; // Default to using process.argv\n\n    if (argv === undefined) {\n      argv = process.argv; // @ts-ignore: unknown property\n\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n\n    this.rawArgs = argv.slice(); // make it a little easier for callers by supporting various argv conventions\n\n    let userArgs;\n\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n\n      case 'electron':\n        // @ts-ignore: unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n\n        break;\n\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n\n    if (!this._scriptPath && require.main) {\n      this._scriptPath = require.main.filename;\n    } // Guess name, used in usage in help.\n\n\n    this._name = this._name || this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath)); // Let's go!\n\n    this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * Examples:\n   *\n   *      program.parseAsync(process.argv);\n   *      program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   *      program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n  parseAsync(argv, parseOptions) {\n    this.parse(argv, parseOptions);\n    return Promise.all(this._actionResults).then(() => this);\n  }\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @api private\n   */\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs']; // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n\n    this._checkForMissingMandatoryOptions(); // Want the entry script as the reference for command name and directory for searching for other files.\n\n\n    let scriptPath = this._scriptPath; // Fallback in case not set, due to how Command created or called.\n\n    if (!scriptPath && require.main) {\n      scriptPath = require.main.filename;\n    }\n\n    let baseDir;\n\n    try {\n      const resolvedLink = fs.realpathSync(scriptPath);\n      baseDir = path.dirname(resolvedLink);\n    } catch (e) {\n      baseDir = '.'; // dummy, probably not going to find executable!\n    } // name of the subcommand, like `pm-install`\n\n\n    let bin = path.basename(scriptPath, path.extname(scriptPath)) + '-' + subcommand._name;\n\n    if (subcommand._executableFile) {\n      bin = subcommand._executableFile;\n    }\n\n    const localBin = path.join(baseDir, bin);\n\n    if (fs.existsSync(localBin)) {\n      // prefer local `./<bin>` to bin in the $PATH\n      bin = localBin;\n    } else {\n      // Look for source files.\n      sourceExt.forEach(ext => {\n        if (fs.existsSync(`${localBin}${ext}`)) {\n          bin = `${localBin}${ext}`;\n        }\n      });\n    }\n\n    launchWithNode = sourceExt.includes(path.extname(bin));\n    let proc;\n\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(bin); // add executable arguments to spawn\n\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n        proc = childProcess.spawn(process.argv[0], args, {\n          stdio: 'inherit'\n        });\n      } else {\n        proc = childProcess.spawn(bin, args, {\n          stdio: 'inherit'\n        });\n      }\n    } else {\n      args.unshift(bin); // add executable arguments to spawn\n\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, {\n        stdio: 'inherit'\n      });\n    }\n\n    const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n    signals.forEach(signal => {\n      // @ts-ignore\n      process.on(signal, () => {\n        if (proc.killed === false && proc.exitCode === null) {\n          proc.kill(signal);\n        }\n      });\n    }); // By default terminate process when spawned process terminates.\n    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n\n    const exitCallback = this._exitCallback;\n\n    if (!exitCallback) {\n      proc.on('close', process.exit.bind(process));\n    } else {\n      proc.on('close', () => {\n        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n      });\n    }\n\n    proc.on('error', err => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableMissing = `'${bin}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name`;\n        throw new Error(executableMissing); // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${bin}' not executable`);\n      }\n\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    }); // Store the reference to the child process\n\n    this.runningCommand = proc;\n  }\n\n  /**\n   * @api private\n   */\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n\n    if (!subCommand) this.help({\n      error: true\n    });\n\n    if (subCommand._executableHandler) {\n      this._executeSubCommand(subCommand, operands.concat(unknown));\n    } else {\n      subCommand._parseCommand(operands, unknown);\n    }\n  }\n\n  /**\n   * Process arguments in context of this command.\n   *\n   * @api private\n   */\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    } else if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {\n      if (operands.length === 1) {\n        this.help();\n      } else {\n        this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);\n      }\n    } else if (this._defaultCommandName) {\n      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command\n\n      this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    } else {\n      if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n        // probably missing subcommand and no handler, user needs help\n        this.help({\n          error: true\n        });\n      }\n\n      outputHelpIfRequested(this, parsed.unknown);\n\n      this._checkForMissingMandatoryOptions(); // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n\n\n      const checkForUnknownOptions = () => {\n        if (parsed.unknown.length > 0) {\n          this.unknownOption(parsed.unknown[0]);\n        }\n      };\n\n      const commandEvent = `command:${this.name()}`;\n\n      if (this._actionHandler) {\n        checkForUnknownOptions(); // Check expected arguments and collect variadic together.\n\n        const args = this.args.slice();\n\n        this._args.forEach((arg, i) => {\n          if (arg.required && args[i] == null) {\n            this.missingArgument(arg.name);\n          } else if (arg.variadic) {\n            args[i] = args.splice(i);\n            args.length = Math.min(i + 1, args.length);\n          }\n        });\n\n        if (args.length > this._args.length) {\n          this._excessArguments(args);\n        }\n\n        this._actionHandler(args);\n\n        if (this.parent) this.parent.emit(commandEvent, operands, unknown); // legacy\n      } else if (this.parent && this.parent.listenerCount(commandEvent)) {\n        checkForUnknownOptions();\n        this.parent.emit(commandEvent, operands, unknown); // legacy\n      } else if (operands.length) {\n        if (this._findCommand('*')) {\n          // legacy default command\n          this._dispatchSubcommand('*', operands, unknown);\n        } else if (this.listenerCount('command:*')) {\n          // skip option check, emit event for possible misspelling suggestion\n          this.emit('command:*', operands, unknown);\n        } else if (this.commands.length) {\n          this.unknownCommand();\n        } else {\n          checkForUnknownOptions();\n        }\n      } else if (this.commands.length) {\n        // This command has subcommands and nothing hooked up at this level, so display help.\n        this.help({\n          error: true\n        });\n      } else {\n        checkForUnknownOptions(); // fall through for caller to handle after calling .parse()\n      }\n    }\n  }\n\n  /**\n   * Find matching command.\n   *\n   * @api private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  }\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @api private\n   */\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  }\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Lazy calling after checking for help flags from leaf subcommand.\n   *\n   * @api private\n   */\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    for (let cmd = this; cmd; cmd = cmd.parent) {\n      cmd.options.forEach(anOption => {\n        if (anOption.mandatory && cmd._getOptionValue(anOption.attributeName()) === undefined) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    }\n  }\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *    argv => operands, unknown\n   *    --known kkk op => [op], []\n   *    op --known kkk => [op], []\n   *    sub --unknown uuu op => [sub], [--unknown uuu op]\n   *    sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {String[]} argv\n   * @return {{operands: String[], unknown: String[]}}\n   */\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n\n    const unknown = []; // first unknown option and remaining unknown args\n\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    } // parse options\n\n\n    let activeVariadicOption = null;\n\n    while (args.length) {\n      const arg = args.shift(); // literal\n\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg); // recognised option, call listener to assign value with possible custom processing\n\n\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null; // historical behaviour is optional value is following arg unless an option\n\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n\n            this.emit(`option:${option.name()}`, value);\n          } else {\n            // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      } // Look for combo options following single dash, eat first one if known.\n\n\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n\n        if (option) {\n          if (option.required || option.optional && this._combineFlagAndOptionalValue) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n\n          continue;\n        }\n      } // Look for known long flag with value, like --foo=bar\n\n\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n\n        const option = this._findOption(arg.slice(0, index));\n\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      } // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n\n\n      if (maybeOption(arg)) {\n        dest = unknown;\n      } // If using positionalOptions, stop processing our options at subcommand.\n\n\n      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      } // If using passThroughOptions, stop processing options at first command-argument.\n\n\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      } // add arg\n\n\n      dest.push(arg);\n    }\n\n    return {\n      operands,\n      unknown\n    };\n  }\n\n  /**\n   * Return an object containing options as key-value pairs\n   *\n   * @return {Object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n\n      return result;\n    }\n\n    return this._optionValues;\n  }\n\n  /**\n   * Internal bottleneck for handling of parsing errors.\n   *\n   * @api private\n   */\n  _displayError(exitCode, code, message) {\n    this._outputConfiguration.outputError(`${message}\\n`, this._outputConfiguration.writeErr);\n\n    this._exit(exitCode, code, message);\n  }\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @api private\n   */\n\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n\n    this._displayError(1, 'commander.missingArgument', message);\n  }\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @api private\n   */\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n\n    this._displayError(1, 'commander.optionMissingArgument', message);\n  }\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @api private\n   */\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n\n    this._displayError(1, 'commander.missingMandatoryOptionValue', message);\n  }\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @api private\n   */\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    const message = `error: unknown option '${flag}'`;\n\n    this._displayError(1, 'commander.unknownOption', message);\n  }\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @api private\n   */\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n    const expected = this._args.length;\n    const s = expected === 1 ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n\n    this._displayError(1, 'commander.excessArguments', message);\n  }\n\n  /**\n   * Unknown command.\n   *\n   * @api private\n   */\n  unknownCommand() {\n    const partCommands = [this.name()];\n\n    for (let parentCmd = this.parent; parentCmd; parentCmd = parentCmd.parent) {\n      partCommands.unshift(parentCmd.name());\n    }\n\n    const fullCommand = partCommands.join(' ');\n    const message = `error: unknown command '${this.args[0]}'.` + (this._hasHelpOption ? ` See '${fullCommand} ${this._helpLongFlag}'.` : '');\n\n    this._displayError(1, 'commander.unknownCommand', message);\n  }\n\n  /**\n   * Set the program version to `str`.\n   *\n   * This method auto-registers the \"-V, --version\" flag\n   * which will print the version number when passed.\n   *\n   * You can optionally supply the  flags and description to override the defaults.\n   *\n   * @param {string} str\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {this | string} `this` command for chaining, or version string if no arguments\n   */\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this.options.push(versionOption);\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  }\n\n  /**\n   * Set the description to `str`.\n   *\n   * @param {string} [str]\n   * @param {Object} [argsDescription]\n   * @return {string|Command}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n    this._argsDescription = argsDescription;\n    return this;\n  }\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {string|Command}\n   */\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    let command = this;\n\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n    command._aliases.push(alias);\n\n    return this;\n  }\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {string[]|Command}\n   */\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n    aliases.forEach(alias => this.alias(alias));\n    return this;\n  }\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   */\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this._args.map(arg => {\n        return humanReadableArgName(arg);\n      });\n\n      return [].concat(this.options.length || this._hasHelpOption ? '[options]' : [], this.commands.length ? '[command]' : [], this._args.length ? args : []).join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  }\n\n  /**\n   * Get or set the name of the command\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  }\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();\n    }\n\n    return helper.formatHelp(this, helper);\n  }\n\n  /**\n   * @api private\n   */\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = {\n      error: !!contextOptions.error\n    };\n    let write;\n\n    if (context.error) {\n      write = arg => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = arg => this._outputConfiguration.writeOut(arg);\n    }\n\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n\n    const context = this._getHelpContext(contextOptions);\n\n    const groupListeners = [];\n    let command = this;\n\n    while (command) {\n      groupListeners.push(command); // ordered from current command to root\n\n      command = command.parent;\n    }\n\n    groupListeners.slice().reverse().forEach(command => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n    let helpInformation = this.helpInformation(context);\n\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n\n      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n\n    context.write(helpInformation);\n    this.emit(this._helpLongFlag); // deprecated\n\n    this.emit('afterHelp', context);\n    groupListeners.forEach(command => command.emit('afterAllHelp', context));\n  }\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false to\n   * disable the built-in help option.\n   *\n   * @param {string | boolean} [flags]\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n  helpOption(flags, description) {\n    if (typeof flags === 'boolean') {\n      this._hasHelpOption = flags;\n      return this;\n    }\n\n    this._helpFlags = flags || this._helpFlags;\n    this._helpDescription = description || this._helpDescription;\n\n    const helpFlags = _parseOptionFlags(this._helpFlags);\n\n    this._helpShortFlag = helpFlags.shortFlag;\n    this._helpLongFlag = helpFlags.longFlag;\n    return this;\n  }\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n\n    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {\n      exitCode = 1;\n    } // message: do not have all displayed text available so only passing placeholder.\n\n\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  }\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {string | Function} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, context => {\n      let helpStr;\n\n      if (typeof text === 'function') {\n        helpStr = text({\n          error: context.error,\n          command: context.command\n        });\n      } else {\n        helpStr = text;\n      } // Ignore falsy value when nothing to output.\n\n\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n\n}\n\n;\n/**\n * Expose the root command.\n */\n\nexports = module.exports = new Command();\nexports.program = exports; // More explicit access to global command.\n\n/**\n * Expose classes\n */\n\nexports.Command = Command;\nexports.Option = Option;\nexports.CommanderError = CommanderError;\nexports.InvalidOptionArgumentError = InvalidOptionArgumentError;\nexports.Help = Help;\n/**\n * Camel-case the given `flag`\n *\n * @param {string} flag\n * @return {string}\n * @api private\n */\n\nfunction camelcase(flag) {\n  return flag.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} args - array of options to search for help flags\n * @api private\n */\n\n\nfunction outputHelpIfRequested(cmd, args) {\n  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);\n\n  if (helpOption) {\n    cmd.outputHelp(); // (Do not have all displayed text available so only passing placeholder.)\n\n    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n  }\n}\n/**\n * Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Object} arg\n * @return {string}\n * @api private\n */\n\n\nfunction humanReadableArgName(arg) {\n  const nameOutput = arg.name + (arg.variadic === true ? '...' : '');\n  return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';\n}\n/**\n * Parse the short and long flag out of something like '-m,--mixed <value>'\n *\n * @api private\n */\n\n\nfunction _parseOptionFlags(flags) {\n  let shortFlag;\n  let longFlag; // Use original very loose parsing to maintain backwards compatibility for now,\n  // which allowed for example unintended `-sw, --short-word` [sic].\n\n  const flagParts = flags.split(/[ |,]+/);\n  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();\n  longFlag = flagParts.shift(); // Add support for lone short flag without significantly changing parsing!\n\n  if (!shortFlag && /^-[^-]$/.test(longFlag)) {\n    shortFlag = longFlag;\n    longFlag = undefined;\n  }\n\n  return {\n    shortFlag,\n    longFlag\n  };\n}\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map(arg => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n\n    return arg;\n  });\n}","map":{"version":3,"names":["EventEmitter","require","childProcess","path","fs","Help","constructor","helpWidth","undefined","sortSubcommands","sortOptions","visibleCommands","cmd","commands","filter","_hidden","_hasImplicitHelpCommand","args","_helpCommandnameAndArgs","split","helpCommand","createCommand","shift","helpOption","description","_helpCommandDescription","_parseExpectedArgs","push","sort","a","b","name","localeCompare","visibleOptions","options","option","hidden","showShortHelpFlag","_hasHelpOption","_helpShortFlag","_findOption","showLongHelpFlag","_helpLongFlag","createOption","_helpDescription","_helpFlags","getSortKey","short","replace","long","visibleArguments","_argsDescription","_args","length","map","argument","term","subcommandTerm","arg","humanReadableArgName","join","_name","_aliases","optionTerm","flags","longestSubcommandTermLength","helper","reduce","max","command","Math","longestOptionTermLength","longestArgumentTermLength","commandUsage","cmdName","parentCmdNames","parentCmd","parent","usage","commandDescription","subcommandDescription","optionDescription","negate","extraInfo","argChoices","choice","JSON","stringify","defaultValue","defaultValueDescription","formatHelp","termWidth","padWidth","itemIndentWidth","itemSeparatorWidth","formatItem","fullText","padEnd","wrap","formatList","textArray","repeat","output","concat","argumentList","optionList","commandList","str","width","indent","minColumnWidth","match","columnWidth","leadingStr","substr","columnText","indentString","regex","RegExp","lines","line","i","slice","trimRight","Option","required","includes","optional","variadic","test","mandatory","optionFlags","_parseOptionFlags","shortFlag","longFlag","startsWith","parseArg","default","value","argParser","fn","makeOptionMandatory","hideHelp","hide","_concatValue","previous","Array","isArray","choices","values","InvalidOptionArgumentError","attributeName","camelcase","is","CommanderError","Error","exitCode","code","message","captureStackTrace","nestedError","Command","_allowUnknownOption","_allowExcessArguments","rawArgs","_scriptPath","_optionValues","_storeOptionsAsProperties","_actionResults","_actionHandler","_executableHandler","_executableFile","_defaultCommandName","_exitCallback","_combineFlagAndOptionalValue","_description","_enablePositionalOptions","_passThroughOptions","_outputConfiguration","writeOut","process","stdout","write","writeErr","stderr","getOutHelpWidth","isTTY","columns","getErrHelpWidth","outputError","_addImplicitHelpCommand","_helpCommandName","_helpConfiguration","nameAndArgs","actionOptsOrExecDesc","execOpts","desc","opts","isDefault","noHelp","executableFile","createHelp","Object","assign","configureHelp","configuration","configureOutput","addCommand","checkExplicitNames","commandArray","forEach","arguments","addHelpCommand","enableOrNameAndArgs","_findCommand","argDetails","exitOverride","err","_exit","exit","action","listener","expectedArgsCount","actionArgs","actionResult","apply","rootCommand","addOption","oname","positiveLongFlag","_getOptionValue","_setOptionValue","on","val","oldValue","_displayError","_optionEx","config","def","m","exec","requiredOption","combineFlagAndOptionalValue","combine","allowUnknownOption","allowUnknown","allowExcessArguments","allowExcess","enablePositionalOptions","positional","passThroughOptions","passThrough","storeOptionsAsProperties","storeAsProperties","key","parse","argv","parseOptions","versions","electron","from","userArgs","defaultApp","main","filename","basename","extname","_parseCommand","parseAsync","Promise","all","then","_executeSubCommand","subcommand","launchWithNode","sourceExt","_checkForMissingMandatoryOptions","scriptPath","baseDir","resolvedLink","realpathSync","dirname","e","bin","localBin","existsSync","ext","proc","platform","unshift","incrementNodeInspectorPort","execArgv","spawn","stdio","execPath","signals","signal","killed","kill","exitCallback","bind","executableMissing","wrappedError","runningCommand","_dispatchSubcommand","commandName","operands","unknown","subCommand","help","error","parsed","outputHelpIfRequested","checkForUnknownOptions","unknownOption","commandEvent","missingArgument","splice","min","_excessArguments","emit","listenerCount","unknownCommand","find","anOption","missingMandatoryOptionValue","dest","maybeOption","activeVariadicOption","optionMissingArgument","index","indexOf","result","len","_versionOptionName","_version","flag","receivedArgs","expected","s","forSubcommand","partCommands","fullCommand","version","versionOption","argsDescription","alias","aliases","_usage","helpInformation","contextOptions","_getHelpContext","context","outputHelp","deprecatedCallback","groupListeners","reverse","Buffer","isBuffer","helpFlags","addHelpText","position","text","allowedValues","helpEvent","helpStr","exports","module","program","word","toUpperCase","nameOutput","flagParts","debugOption","debugHost","debugPort","parseInt"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/commander/index.js"],"sourcesContent":["/**\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst childProcess = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\n\n// @ts-check\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const args = cmd._helpCommandnameAndArgs.split(/ +/);\n      const helpCommand = cmd.createCommand(args.shift())\n        .helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n      helpCommand._parseExpectedArgs(args);\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter((option) => !option.hidden);\n    // Implicit help\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n      visibleOptions.push(helpOption);\n    }\n    if (this.sortOptions) {\n      const getSortKey = (option) => {\n        // WYSIWYG for order displayed in help with short before long, no special handling for negated.\n        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n      };\n      visibleOptions.sort((a, b) => {\n        return getSortKey(a).localeCompare(getSortKey(b));\n      });\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the arguments which have descriptions.\n   *\n   * @param {Command} cmd\n   * @returns {{ term: string, description:string }[]}\n   */\n\n  visibleArguments(cmd) {\n    if (cmd._argsDescription && cmd._args.length) {\n      return cmd._args.map((argument) => {\n        return { term: argument.name, description: cmd._argsDescription[argument.name] || '' };\n      }, 0);\n    }\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');\n    return cmd._name +\n      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option\n      (args ? ' ' + args : '');\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  };\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  };\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, argument.term.length);\n    }, 0);\n  };\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let parentCmdNames = '';\n    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {\n      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n    }\n    return parentCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the command description to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    if (option.negate) {\n      return option.description;\n    }\n    const extraInfo = [];\n    if (option.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (option.defaultValue !== undefined) {\n      extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n    return option.description;\n  };\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n      return term;\n    };\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([commandDescription, '']);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map((argument) => {\n      return formatItem(argument.term, argument.description);\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map((option) => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map((cmd) => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(\n      helper.longestOptionTermLength(cmd, helper),\n      helper.longestSubcommandTermLength(cmd, helper),\n      helper.longestArgumentTermLength(cmd, helper)\n    );\n  };\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Detect manually wrapped and indented strings by searching for line breaks\n    // followed by multiple spaces/tabs.\n    if (str.match(/[\\n]\\s+/)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n\n    const leadingStr = str.substr(0, indent);\n    const columnText = str.substr(indent);\n\n    const indentString = ' '.repeat(indent);\n    const regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\\\s\\u200B]|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]|$)', 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line.slice(-1) === '\\n') {\n        line = line.slice(0, line.length - 1);\n      }\n      return ((i > 0) ? indentString : '') + line.trimRight();\n    }).join('\\n');\n  }\n}\n\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   */\n\n  constructor(flags, description) {\n    this.flags = flags;\n    this.description = description || '';\n\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n    const optionFlags = _parseOptionFlags(flags);\n    this.short = optionFlags.shortFlag;\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.parseArg = undefined;\n    this.hidden = false;\n    this.argChoices = undefined;\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {any} value\n   * @param {string} [description]\n   * @return {Option}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  };\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   *\n   * @param {Function} [fn]\n   * @return {Option}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  };\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   *\n   * @param {boolean} [mandatory=true]\n   * @return {Option}\n   */\n\n  makeOptionMandatory(mandatory = true) {\n    this.mandatory = !!mandatory;\n    return this;\n  };\n\n  /**\n   * Hide option in help.\n   *\n   * @param {boolean} [hide=true]\n   * @return {Option}\n   */\n\n  hideHelp(hide = true) {\n    this.hidden = !!hide;\n    return this;\n  };\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Option}\n   */\n\n  choices(values) {\n    this.argChoices = values;\n    this.parseArg = (arg, previous) => {\n      if (!values.includes(arg)) {\n        throw new InvalidOptionArgumentError(`Allowed choices are ${values.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  };\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n    return this.short.replace(/^-/, '');\n  };\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   *\n   * @return {string}\n   * @api private\n   */\n\n  attributeName() {\n    return camelcase(this.name().replace(/^no-/, ''));\n  };\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @api private\n   */\n\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  };\n}\n\n/**\n * CommanderError class\n * @class\n */\nclass CommanderError extends Error {\n  /**\n   * Constructs the CommanderError class\n   * @param {number} exitCode suggested exit code which could be used with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @constructor\n   */\n  constructor(exitCode, code, message) {\n    super(message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.exitCode = exitCode;\n    this.nestedError = undefined;\n  }\n}\n\n/**\n * InvalidOptionArgumentError class\n * @class\n */\nclass InvalidOptionArgumentError extends CommanderError {\n  /**\n   * Constructs the InvalidOptionArgumentError class\n   * @param {string} [message] explanation of why argument is invalid\n   * @constructor\n   */\n  constructor(message) {\n    super(1, 'commander.invalidOptionArgument', message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n  }\n}\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n\n  constructor(name) {\n    super();\n    this.commands = [];\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    this._args = [];\n    this.rawArgs = null;\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._storeOptionsAsProperties = false;\n    this._actionResults = [];\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._argsDescription = undefined;\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n\n    // see .configureOutput() for docs\n    this._outputConfiguration = {\n      writeOut: (str) => process.stdout.write(str),\n      writeErr: (str) => process.stderr.write(str),\n      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str)\n    };\n\n    this._hidden = false;\n    this._hasHelpOption = true;\n    this._helpFlags = '-h, --help';\n    this._helpDescription = 'display help for command';\n    this._helpShortFlag = '-h';\n    this._helpLongFlag = '--help';\n    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false\n    this._helpCommandName = 'help';\n    this._helpCommandnameAndArgs = 'help [command]';\n    this._helpCommandDescription = 'display help for command';\n    this._helpConfiguration = {};\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * Examples:\n   *\n   *      // Command implemented using action handler (description is supplied separately to `.command`)\n   *      program\n   *        .command('clone <source> [destination]')\n   *        .description('clone a repository into a newly created directory')\n   *        .action((source, destination) => {\n   *          console.log('clone command called');\n   *        });\n   *\n   *      // Command implemented using separate executable file (description is second parameter to `.command`)\n   *      program\n   *        .command('start <service>', 'start named service')\n   *        .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const args = nameAndArgs.split(/ +/);\n    const cmd = this.createCommand(args.shift());\n\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n\n    cmd._outputConfiguration = this._outputConfiguration;\n\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n    cmd._hasHelpOption = this._hasHelpOption;\n    cmd._helpFlags = this._helpFlags;\n    cmd._helpDescription = this._helpDescription;\n    cmd._helpShortFlag = this._helpShortFlag;\n    cmd._helpLongFlag = this._helpLongFlag;\n    cmd._helpCommandName = this._helpCommandName;\n    cmd._helpCommandnameAndArgs = this._helpCommandnameAndArgs;\n    cmd._helpCommandDescription = this._helpCommandDescription;\n    cmd._helpConfiguration = this._helpConfiguration;\n    cmd._exitCallback = this._exitCallback;\n    cmd._storeOptionsAsProperties = this._storeOptionsAsProperties;\n    cmd._combineFlagAndOptionalValue = this._combineFlagAndOptionalValue;\n    cmd._allowExcessArguments = this._allowExcessArguments;\n    cmd._enablePositionalOptions = this._enablePositionalOptions;\n\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    this.commands.push(cmd);\n    cmd._parseExpectedArgs(args);\n    cmd.parent = this;\n\n    if (desc) return this;\n    return cmd;\n  };\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  };\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  };\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n\n    this._helpConfiguration = configuration;\n    return this;\n  }\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *    // functions to change where being written, stdout and stderr\n   *    writeOut(str)\n   *    writeErr(str)\n   *    // matching functions to specify width for wrapping help\n   *    getOutHelpWidth()\n   *    getErrHelpWidth()\n   *    // functions based on what is being written out\n   *    outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) throw new Error('Command passed to .addCommand() must have a name');\n\n    // To keep things simple, block automatic name generation for deeply nested executables.\n    // Fail fast and detect when adding rather than later when parsing.\n    function checkExplicitNames(commandArray) {\n      commandArray.forEach((cmd) => {\n        if (cmd._executableHandler && !cmd._executableFile) {\n          throw new Error(`Must specify executableFile for deeply nested executable: ${cmd.name()}`);\n        }\n        checkExplicitNames(cmd.commands);\n      });\n    }\n    checkExplicitNames(cmd.commands);\n\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this.commands.push(cmd);\n    cmd.parent = this;\n    return this;\n  };\n\n  /**\n   * Define argument syntax for the command.\n   */\n\n  arguments(desc) {\n    return this._parseExpectedArgs(desc.split(/ +/));\n  };\n\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   *    addHelpCommand() // force on\n   *    addHelpCommand(false); // force off\n   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   *\n   * @return {Command} `this` command for chaining\n   */\n\n  addHelpCommand(enableOrNameAndArgs, description) {\n    if (enableOrNameAndArgs === false) {\n      this._addImplicitHelpCommand = false;\n    } else {\n      this._addImplicitHelpCommand = true;\n      if (typeof enableOrNameAndArgs === 'string') {\n        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];\n        this._helpCommandnameAndArgs = enableOrNameAndArgs;\n      }\n      this._helpCommandDescription = description || this._helpCommandDescription;\n    }\n    return this;\n  };\n\n  /**\n   * @return {boolean}\n   * @api private\n   */\n\n  _hasImplicitHelpCommand() {\n    if (this._addImplicitHelpCommand === undefined) {\n      return this.commands.length && !this._actionHandler && !this._findCommand('help');\n    }\n    return this._addImplicitHelpCommand;\n  };\n\n  /**\n   * Parse expected `args`.\n   *\n   * For example `[\"[type]\"]` becomes `[{ required: false, name: 'type' }]`.\n   *\n   * @param {Array} args\n   * @return {Command} `this` command for chaining\n   * @api private\n   */\n\n  _parseExpectedArgs(args) {\n    if (!args.length) return;\n    args.forEach((arg) => {\n      const argDetails = {\n        required: false,\n        name: '',\n        variadic: false\n      };\n\n      switch (arg[0]) {\n        case '<':\n          argDetails.required = true;\n          argDetails.name = arg.slice(1, -1);\n          break;\n        case '[':\n          argDetails.name = arg.slice(1, -1);\n          break;\n      }\n\n      if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {\n        argDetails.variadic = true;\n        argDetails.name = argDetails.name.slice(0, -3);\n      }\n      if (argDetails.name) {\n        this._args.push(argDetails);\n      }\n    });\n    this._args.forEach((arg, i) => {\n      if (arg.variadic && i < this._args.length - 1) {\n        throw new Error(`only the last argument can be variadic '${arg.name}'`);\n      }\n    });\n    return this;\n  };\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = (err) => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  };\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @api private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  };\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * Examples:\n   *\n   *      program\n   *        .command('help')\n   *        .description('display verbose help')\n   *        .action(function() {\n   *           // output help here\n   *        });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n\n  action(fn) {\n    const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this._args.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      actionArgs.push(this);\n\n      const actionResult = fn.apply(this, actionArgs);\n      // Remember result in case it is async. Assume parseAsync getting called on root.\n      let rootCommand = this;\n      while (rootCommand.parent) {\n        rootCommand = rootCommand.parent;\n      }\n      rootCommand._actionResults.push(actionResult);\n    };\n    this._actionHandler = listener;\n    return this;\n  };\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n\n  createOption(flags, description) {\n    return new Option(flags, description);\n  };\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    const oname = option.name();\n    const name = option.attributeName();\n\n    let defaultValue = option.defaultValue;\n\n    // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value\n    if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {\n      // when --no-foo we make sure default is true, unless a --foo option is already defined\n      if (option.negate) {\n        const positiveLongFlag = option.long.replace(/^--no-/, '--');\n        defaultValue = this._findOption(positiveLongFlag) ? this._getOptionValue(name) : true;\n      }\n      // preassign only if we have a default\n      if (defaultValue !== undefined) {\n        this._setOptionValue(name, defaultValue);\n      }\n    }\n\n    // register the option\n    this.options.push(option);\n\n    // when it's passed assign the value\n    // and conditionally invoke the callback\n    this.on('option:' + oname, (val) => {\n      const oldValue = this._getOptionValue(name);\n\n      // custom processing\n      if (val !== null && option.parseArg) {\n        try {\n          val = option.parseArg(val, oldValue === undefined ? defaultValue : oldValue);\n        } catch (err) {\n          if (err.code === 'commander.invalidOptionArgument') {\n            const message = `error: option '${option.flags}' argument '${val}' is invalid. ${err.message}`;\n            this._displayError(err.exitCode, err.code, message);\n          }\n          throw err;\n        }\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      }\n\n      // unassigned or boolean value\n      if (typeof oldValue === 'boolean' || typeof oldValue === 'undefined') {\n        // if no value, negate false, and we have a default, then use it!\n        if (val == null) {\n          this._setOptionValue(name, option.negate\n            ? false\n            : defaultValue || true);\n        } else {\n          this._setOptionValue(name, val);\n        }\n      } else if (val !== null) {\n        // reassign\n        this._setOptionValue(name, option.negate ? false : val);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @api private\n   */\n  _optionEx(config, flags, description, fn, defaultValue) {\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n\n  /**\n   * Define option with `flags`, `description` and optional\n   * coercion `fn`.\n   *\n   * The `flags` string contains the short and/or long flags,\n   * separated by comma, a pipe or space. The following are all valid\n   * all will output this way when `--help` is used.\n   *\n   *    \"-p, --pepper\"\n   *    \"-p|--pepper\"\n   *    \"-p --pepper\"\n   *\n   * Examples:\n   *\n   *     // simple boolean defaulting to undefined\n   *     program.option('-p, --pepper', 'add pepper');\n   *\n   *     program.pepper\n   *     // => undefined\n   *\n   *     --pepper\n   *     program.pepper\n   *     // => true\n   *\n   *     // simple boolean defaulting to true (unless non-negated option is also defined)\n   *     program.option('-C, --no-cheese', 'remove cheese');\n   *\n   *     program.cheese\n   *     // => true\n   *\n   *     --no-cheese\n   *     program.cheese\n   *     // => false\n   *\n   *     // required argument\n   *     program.option('-C, --chdir <path>', 'change the working directory');\n   *\n   *     --chdir /tmp\n   *     program.chdir\n   *     // => \"/tmp\"\n   *\n   *     // optional argument\n   *     program.option('-c, --cheese [type]', 'add cheese [marble]');\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  option(flags, description, fn, defaultValue) {\n    return this._optionEx({}, flags, description, fn, defaultValue);\n  };\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} [description]\n  * @param {Function|*} [fn] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  */\n\n  requiredOption(flags, description, fn, defaultValue) {\n    return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);\n  };\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * Examples:\n   *\n   *    // for `.option('-f,--flag [value]'):\n   *    .combineFlagAndOptionalValue(true)  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   *    .combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.\n   */\n  combineFlagAndOptionalValue(combine = true) {\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  };\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   */\n  allowUnknownOption(allowUnknown = true) {\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  };\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown\n   * for excess arguments.\n   */\n  allowExcessArguments(allowExcess = true) {\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  };\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {Boolean} [positional=true]\n   */\n  enablePositionalOptions(positional = true) {\n    this._enablePositionalOptions = !!positional;\n    return this;\n  };\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {Boolean} [passThrough=true]\n   * for unknown options.\n   */\n  passThroughOptions(passThrough = true) {\n    this._passThroughOptions = !!passThrough;\n    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {\n      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');\n    }\n    return this;\n  };\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} [storeAsProperties=true]\n    * @return {Command} `this` command for chaining\n    */\n\n  storeOptionsAsProperties(storeAsProperties = true) {\n    this._storeOptionsAsProperties = !!storeAsProperties;\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    return this;\n  };\n\n  /**\n   * Store option value\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @api private\n   */\n\n  _setOptionValue(key, value) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n  };\n\n  /**\n   * Retrieve option value\n   *\n   * @param {string} key\n   * @return {Object} value\n   * @api private\n   */\n\n  _getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  };\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * Examples:\n   *\n   *      program.parse(process.argv);\n   *      program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   *      program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n  parse(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // Default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n      // @ts-ignore: unknown property\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n    this.rawArgs = argv.slice();\n\n    // make it a little easier for callers by supporting various argv conventions\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore: unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n    if (!this._scriptPath && require.main) {\n      this._scriptPath = require.main.filename;\n    }\n\n    // Guess name, used in usage in help.\n    this._name = this._name || (this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath)));\n\n    // Let's go!\n    this._parseCommand([], userArgs);\n\n    return this;\n  };\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * Examples:\n   *\n   *      program.parseAsync(process.argv);\n   *      program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   *      program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n\n  parseAsync(argv, parseOptions) {\n    this.parse(argv, parseOptions);\n    return Promise.all(this._actionResults).then(() => this);\n  };\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @api private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n\n    // Want the entry script as the reference for command name and directory for searching for other files.\n    let scriptPath = this._scriptPath;\n    // Fallback in case not set, due to how Command created or called.\n    if (!scriptPath && require.main) {\n      scriptPath = require.main.filename;\n    }\n\n    let baseDir;\n    try {\n      const resolvedLink = fs.realpathSync(scriptPath);\n      baseDir = path.dirname(resolvedLink);\n    } catch (e) {\n      baseDir = '.'; // dummy, probably not going to find executable!\n    }\n\n    // name of the subcommand, like `pm-install`\n    let bin = path.basename(scriptPath, path.extname(scriptPath)) + '-' + subcommand._name;\n    if (subcommand._executableFile) {\n      bin = subcommand._executableFile;\n    }\n\n    const localBin = path.join(baseDir, bin);\n    if (fs.existsSync(localBin)) {\n      // prefer local `./<bin>` to bin in the $PATH\n      bin = localBin;\n    } else {\n      // Look for source files.\n      sourceExt.forEach((ext) => {\n        if (fs.existsSync(`${localBin}${ext}`)) {\n          bin = `${localBin}${ext}`;\n        }\n      });\n    }\n    launchWithNode = sourceExt.includes(path.extname(bin));\n\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(bin);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });\n      } else {\n        proc = childProcess.spawn(bin, args, { stdio: 'inherit' });\n      }\n    } else {\n      args.unshift(bin);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });\n    }\n\n    const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n    signals.forEach((signal) => {\n      // @ts-ignore\n      process.on(signal, () => {\n        if (proc.killed === false && proc.exitCode === null) {\n          proc.kill(signal);\n        }\n      });\n    });\n\n    // By default terminate process when spawned process terminates.\n    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n    const exitCallback = this._exitCallback;\n    if (!exitCallback) {\n      proc.on('close', process.exit.bind(process));\n    } else {\n      proc.on('close', () => {\n        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n      });\n    }\n    proc.on('error', (err) => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableMissing = `'${bin}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name`;\n        throw new Error(executableMissing);\n      // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${bin}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  };\n\n  /**\n   * @api private\n   */\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this.help({ error: true });\n\n    if (subCommand._executableHandler) {\n      this._executeSubCommand(subCommand, operands.concat(unknown));\n    } else {\n      subCommand._parseCommand(operands, unknown);\n    }\n  };\n\n  /**\n   * Process arguments in context of this command.\n   *\n   * @api private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    } else if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {\n      if (operands.length === 1) {\n        this.help();\n      } else {\n        this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);\n      }\n    } else if (this._defaultCommandName) {\n      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command\n      this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    } else {\n      if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n        // probably missing subcommand and no handler, user needs help\n        this.help({ error: true });\n      }\n\n      outputHelpIfRequested(this, parsed.unknown);\n      this._checkForMissingMandatoryOptions();\n\n      // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n      const checkForUnknownOptions = () => {\n        if (parsed.unknown.length > 0) {\n          this.unknownOption(parsed.unknown[0]);\n        }\n      };\n\n      const commandEvent = `command:${this.name()}`;\n      if (this._actionHandler) {\n        checkForUnknownOptions();\n        // Check expected arguments and collect variadic together.\n        const args = this.args.slice();\n        this._args.forEach((arg, i) => {\n          if (arg.required && args[i] == null) {\n            this.missingArgument(arg.name);\n          } else if (arg.variadic) {\n            args[i] = args.splice(i);\n            args.length = Math.min(i + 1, args.length);\n          }\n        });\n        if (args.length > this._args.length) {\n          this._excessArguments(args);\n        }\n\n        this._actionHandler(args);\n        if (this.parent) this.parent.emit(commandEvent, operands, unknown); // legacy\n      } else if (this.parent && this.parent.listenerCount(commandEvent)) {\n        checkForUnknownOptions();\n        this.parent.emit(commandEvent, operands, unknown); // legacy\n      } else if (operands.length) {\n        if (this._findCommand('*')) { // legacy default command\n          this._dispatchSubcommand('*', operands, unknown);\n        } else if (this.listenerCount('command:*')) {\n          // skip option check, emit event for possible misspelling suggestion\n          this.emit('command:*', operands, unknown);\n        } else if (this.commands.length) {\n          this.unknownCommand();\n        } else {\n          checkForUnknownOptions();\n        }\n      } else if (this.commands.length) {\n        // This command has subcommands and nothing hooked up at this level, so display help.\n        this.help({ error: true });\n      } else {\n        checkForUnknownOptions();\n        // fall through for caller to handle after calling .parse()\n      }\n    }\n  };\n\n  /**\n   * Find matching command.\n   *\n   * @api private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  };\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @api private\n   */\n\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  };\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Lazy calling after checking for help flags from leaf subcommand.\n   *\n   * @api private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    for (let cmd = this; cmd; cmd = cmd.parent) {\n      cmd.options.forEach((anOption) => {\n        if (anOption.mandatory && (cmd._getOptionValue(anOption.attributeName()) === undefined)) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    }\n  };\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *    argv => operands, unknown\n   *    --known kkk op => [op], []\n   *    op --known kkk => [op], []\n   *    sub --unknown uuu op => [sub], [--unknown uuu op]\n   *    sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {String[]} argv\n   * @return {{operands: String[], unknown: String[]}}\n   */\n\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    // parse options\n    let activeVariadicOption = null;\n    while (args.length) {\n      const arg = args.shift();\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else { // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n      if (maybeOption(arg)) {\n        dest = unknown;\n      }\n\n      // If using positionalOptions, stop processing our options at subcommand.\n      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      }\n\n      // If using passThroughOptions, stop processing options at first command-argument.\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n\n    return { operands, unknown };\n  };\n\n  /**\n   * Return an object containing options as key-value pairs\n   *\n   * @return {Object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n\n    return this._optionValues;\n  };\n\n  /**\n   * Internal bottleneck for handling of parsing errors.\n   *\n   * @api private\n   */\n  _displayError(exitCode, code, message) {\n    this._outputConfiguration.outputError(`${message}\\n`, this._outputConfiguration.writeErr);\n    this._exit(exitCode, code, message);\n  }\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @api private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    this._displayError(1, 'commander.missingArgument', message);\n  };\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n    this._displayError(1, 'commander.optionMissingArgument', message);\n  };\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    this._displayError(1, 'commander.missingMandatoryOptionValue', message);\n  };\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @api private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    const message = `error: unknown option '${flag}'`;\n    this._displayError(1, 'commander.unknownOption', message);\n  };\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @api private\n   */\n\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n\n    const expected = this._args.length;\n    const s = (expected === 1) ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n    this._displayError(1, 'commander.excessArguments', message);\n  };\n\n  /**\n   * Unknown command.\n   *\n   * @api private\n   */\n\n  unknownCommand() {\n    const partCommands = [this.name()];\n    for (let parentCmd = this.parent; parentCmd; parentCmd = parentCmd.parent) {\n      partCommands.unshift(parentCmd.name());\n    }\n    const fullCommand = partCommands.join(' ');\n    const message = `error: unknown command '${this.args[0]}'.` +\n      (this._hasHelpOption ? ` See '${fullCommand} ${this._helpLongFlag}'.` : '');\n    this._displayError(1, 'commander.unknownCommand', message);\n  };\n\n  /**\n   * Set the program version to `str`.\n   *\n   * This method auto-registers the \"-V, --version\" flag\n   * which will print the version number when passed.\n   *\n   * You can optionally supply the  flags and description to override the defaults.\n   *\n   * @param {string} str\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {this | string} `this` command for chaining, or version string if no arguments\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this.options.push(versionOption);\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  };\n\n  /**\n   * Set the description to `str`.\n   *\n   * @param {string} [str]\n   * @param {Object} [argsDescription]\n   * @return {string|Command}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n    this._argsDescription = argsDescription;\n    return this;\n  };\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {string|Command}\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    let command = this;\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n    command._aliases.push(alias);\n    return this;\n  };\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {string[]|Command}\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n\n    aliases.forEach((alias) => this.alias(alias));\n    return this;\n  };\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this._args.map((arg) => {\n        return humanReadableArgName(arg);\n      });\n      return [].concat(\n        (this.options.length || this._hasHelpOption ? '[options]' : []),\n        (this.commands.length ? '[command]' : []),\n        (this._args.length ? args : [])\n      ).join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  };\n\n  /**\n   * Get or set the name of the command\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  };\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();\n    }\n    return helper.formatHelp(this, helper);\n  };\n\n  /**\n   * @api private\n   */\n\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = { error: !!contextOptions.error };\n    let write;\n    if (context.error) {\n      write = (arg) => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = (arg) => this._outputConfiguration.writeOut(arg);\n    }\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n    const context = this._getHelpContext(contextOptions);\n\n    const groupListeners = [];\n    let command = this;\n    while (command) {\n      groupListeners.push(command); // ordered from current command to root\n      command = command.parent;\n    }\n\n    groupListeners.slice().reverse().forEach(command => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n\n    let helpInformation = this.helpInformation(context);\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n    context.write(helpInformation);\n\n    this.emit(this._helpLongFlag); // deprecated\n    this.emit('afterHelp', context);\n    groupListeners.forEach(command => command.emit('afterAllHelp', context));\n  };\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false to\n   * disable the built-in help option.\n   *\n   * @param {string | boolean} [flags]\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n\n  helpOption(flags, description) {\n    if (typeof flags === 'boolean') {\n      this._hasHelpOption = flags;\n      return this;\n    }\n    this._helpFlags = flags || this._helpFlags;\n    this._helpDescription = description || this._helpDescription;\n\n    const helpFlags = _parseOptionFlags(this._helpFlags);\n    this._helpShortFlag = helpFlags.shortFlag;\n    this._helpLongFlag = helpFlags.longFlag;\n\n    return this;\n  };\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {\n      exitCode = 1;\n    }\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  };\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {string | Function} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, (context) => {\n      let helpStr;\n      if (typeof text === 'function') {\n        helpStr = text({ error: context.error, command: context.command });\n      } else {\n        helpStr = text;\n      }\n      // Ignore falsy value when nothing to output.\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n};\n\n/**\n * Expose the root command.\n */\n\nexports = module.exports = new Command();\nexports.program = exports; // More explicit access to global command.\n\n/**\n * Expose classes\n */\n\nexports.Command = Command;\nexports.Option = Option;\nexports.CommanderError = CommanderError;\nexports.InvalidOptionArgumentError = InvalidOptionArgumentError;\nexports.Help = Help;\n\n/**\n * Camel-case the given `flag`\n *\n * @param {string} flag\n * @return {string}\n * @api private\n */\n\nfunction camelcase(flag) {\n  return flag.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} args - array of options to search for help flags\n * @api private\n */\n\nfunction outputHelpIfRequested(cmd, args) {\n  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);\n  if (helpOption) {\n    cmd.outputHelp();\n    // (Do not have all displayed text available so only passing placeholder.)\n    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n  }\n}\n\n/**\n * Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Object} arg\n * @return {string}\n * @api private\n */\n\nfunction humanReadableArgName(arg) {\n  const nameOutput = arg.name + (arg.variadic === true ? '...' : '');\n\n  return arg.required\n    ? '<' + nameOutput + '>'\n    : '[' + nameOutput + ']';\n}\n\n/**\n * Parse the short and long flag out of something like '-m,--mixed <value>'\n *\n * @api private\n */\n\nfunction _parseOptionFlags(flags) {\n  let shortFlag;\n  let longFlag;\n  // Use original very loose parsing to maintain backwards compatibility for now,\n  // which allowed for example unintended `-sw, --short-word` [sic].\n  const flagParts = flags.split(/[ |,]+/);\n  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();\n  longFlag = flagParts.shift();\n  // Add support for lone short flag without significantly changing parsing!\n  if (!shortFlag && /^-[^-]$/.test(longFlag)) {\n    shortFlag = longFlag;\n    longFlag = undefined;\n  }\n  return { shortFlag, longFlag };\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\n"],"mappings":"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MACLzG,MAAM,CAACsG,OAAP,CAAeG,EAAf;IACD;;IAED,OAAO,KAAKuF,SAAL,CAAehM,MAAf,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAEEA,MAAM,CAAC6B,KAAD,EAAQxC,WAAR,EAAqBoH,EAArB,EAAyBpD,YAAzB,EAAuC;IAC3C,OAAO,KAAKoJ,SAAL,CAAe,EAAf,EAAmB5K,KAAnB,EAA0BxC,WAA1B,EAAuCoH,EAAvC,EAA2CpD,YAA3C,CAAP;EACD;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEEyJ,cAAc,CAACjL,KAAD,EAAQxC,WAAR,EAAqBoH,EAArB,EAAyBpD,YAAzB,EAAuC;IACnD,OAAO,KAAKoJ,SAAL,CAAe;MAAE1G,SAAS,EAAE;IAAb,CAAf,EAAoClE,KAApC,EAA2CxC,WAA3C,EAAwDoH,EAAxD,EAA4DpD,YAA5D,CAAP;EACD;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE0J,2BAA2B,GAAiB;IAAA,IAAhBC,OAAgB,uEAAN,IAAM;IAC1C,KAAKrE,4BAAL,GAAoC,CAAC,CAACqE,OAAtC;IACA,OAAO,IAAP;EACD;;EAED;AACF;AACA;AACA;AACA;AACA;EACEC,kBAAkB,GAAsB;IAAA,IAArBC,YAAqB,uEAAN,IAAM;IACtC,KAAKnF,mBAAL,GAA2B,CAAC,CAACmF,YAA7B;IACA,OAAO,IAAP;EACD;;EAED;AACF;AACA;AACA;AACA;AACA;EACEC,oBAAoB,GAAqB;IAAA,IAApBC,WAAoB,uEAAN,IAAM;IACvC,KAAKpF,qBAAL,GAA6B,CAAC,CAACoF,WAA/B;IACA,OAAO,I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"},"metadata":{},"sourceType":"script"}