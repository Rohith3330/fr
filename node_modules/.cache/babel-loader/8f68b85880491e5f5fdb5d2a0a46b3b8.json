{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nfunction isImportToken(token) {\n  return token.type === utils_1.AST_TOKEN_TYPES.Keyword && token.value === 'import';\n}\n\nfunction isTypeToken(token) {\n  return token.type === utils_1.AST_TOKEN_TYPES.Identifier && token.value === 'type';\n}\n\nexports.default = util.createRule({\n  name: 'consistent-type-imports',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce consistent usage of type imports',\n      recommended: false\n    },\n    messages: {\n      typeOverValue: 'All imports in the declaration are only used as types. Use `import type`.',\n      someImportsAreOnlyTypes: 'Imports {{typeImports}} are only used as types.',\n      aImportIsOnlyTypes: 'Import {{typeImports}} is only used as types.',\n      someImportsInDecoMeta: 'Type imports {{typeImports}} are used by decorator metadata.',\n      aImportInDecoMeta: 'Type import {{typeImports}} is used by decorator metadata.',\n      valueOverType: 'Use an `import` instead of an `import type`.',\n      noImportTypeAnnotations: '`import()` type annotations are forbidden.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        prefer: {\n          enum: ['type-imports', 'no-type-imports']\n        },\n        disallowTypeAnnotations: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: 'code'\n  },\n  defaultOptions: [{\n    prefer: 'type-imports',\n    disallowTypeAnnotations: true\n  }],\n\n  create(context, _ref) {\n    let [option] = _ref;\n\n    var _a;\n\n    const prefer = (_a = option.prefer) !== null && _a !== void 0 ? _a : 'type-imports';\n    const disallowTypeAnnotations = option.disallowTypeAnnotations !== false;\n    const sourceCode = context.getSourceCode();\n    const sourceImportsMap = {};\n    return Object.assign(Object.assign({}, prefer === 'type-imports' ? {\n      // prefer type imports\n      ImportDeclaration(node) {\n        var _a;\n\n        const source = node.source.value;\n        const sourceImports = (_a = sourceImportsMap[source]) !== null && _a !== void 0 ? _a : sourceImportsMap[source] = {\n          source,\n          reportValueImports: [],\n          typeOnlyNamedImport: null,\n          valueOnlyNamedImport: null\n        };\n\n        if (node.importKind === 'type') {\n          if (!sourceImports.typeOnlyNamedImport && node.specifiers.every(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {\n            sourceImports.typeOnlyNamedImport = node;\n          }\n        } else {\n          if (!sourceImports.valueOnlyNamedImport && node.specifiers.every(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier)) {\n            sourceImports.valueOnlyNamedImport = node;\n          }\n        }\n\n        const typeSpecifiers = [];\n        const inlineTypeSpecifiers = [];\n        const valueSpecifiers = [];\n        const unusedSpecifiers = [];\n\n        for (const specifier of node.specifiers) {\n          if (specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier && specifier.importKind === 'type') {\n            inlineTypeSpecifiers.push(specifier);\n            continue;\n          }\n\n          const [variable] = context.getDeclaredVariables(specifier);\n\n          if (variable.references.length === 0) {\n            unusedSpecifiers.push(specifier);\n          } else {\n            const onlyHasTypeReferences = variable.references.every(ref => {\n              var _a, _b;\n              /**\n               * keep origin import kind when export\n               * export { Type }\n               * export default Type;\n               */\n\n\n              if (((_a = ref.identifier.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ExportSpecifier || ((_b = ref.identifier.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) {\n                if (ref.isValueReference && ref.isTypeReference) {\n                  return node.importKind === 'type';\n                }\n              }\n\n              if (ref.isValueReference) {\n                let parent = ref.identifier.parent;\n                let child = ref.identifier;\n\n                while (parent) {\n                  switch (parent.type) {\n                    // CASE 1:\n                    // `type T = typeof foo` will create a value reference because \"foo\" must be a value type\n                    // however this value reference is safe to use with type-only imports\n                    case utils_1.AST_NODE_TYPES.TSTypeQuery:\n                      return true;\n\n                    case utils_1.AST_NODE_TYPES.TSQualifiedName:\n                      // TSTypeQuery must have a TSESTree.EntityName as its child, so we can filter here and break early\n                      if (parent.left !== child) {\n                        return false;\n                      }\n\n                      child = parent;\n                      parent = parent.parent;\n                      continue;\n                    // END CASE 1\n                    //////////////\n                    // CASE 2:\n                    // `type T = { [foo]: string }` will create a value reference because \"foo\" must be a value type\n                    // however this value reference is safe to use with type-only imports.\n                    // Also this is represented as a non-type AST - hence it uses MemberExpression\n\n                    case utils_1.AST_NODE_TYPES.TSPropertySignature:\n                      return parent.key === child;\n\n                    case utils_1.AST_NODE_TYPES.MemberExpression:\n                      if (parent.object !== child) {\n                        return false;\n                      }\n\n                      child = parent;\n                      parent = parent.parent;\n                      continue;\n                    // END CASE 2\n\n                    default:\n                      return false;\n                  }\n                }\n              }\n\n              return ref.isTypeReference;\n            });\n\n            if (onlyHasTypeReferences) {\n              typeSpecifiers.push(specifier);\n            } else {\n              valueSpecifiers.push(specifier);\n            }\n          }\n        }\n\n        if (node.importKind === 'value' && typeSpecifiers.length || node.importKind === 'type' && valueSpecifiers.length) {\n          sourceImports.reportValueImports.push({\n            node,\n            typeSpecifiers,\n            valueSpecifiers,\n            unusedSpecifiers,\n            inlineTypeSpecifiers\n          });\n        }\n      },\n\n      'Program:exit'() {\n        for (const sourceImports of Object.values(sourceImportsMap)) {\n          if (sourceImports.reportValueImports.length === 0) {\n            continue;\n          }\n\n          for (const report of sourceImports.reportValueImports) {\n            if (report.valueSpecifiers.length === 0 && report.unusedSpecifiers.length === 0) {\n              // import is all type-only, convert the entire import to `import type`\n              context.report({\n                node: report.node,\n                messageId: 'typeOverValue',\n\n                *fix(fixer) {\n                  yield* fixToTypeImportDeclaration(fixer, report, sourceImports);\n                }\n\n              });\n            } else {\n              const isTypeImport = report.node.importKind === 'type'; // we have a mixed type/value import, so we need to split them out into multiple exports\n\n              const importNames = (isTypeImport ? report.valueSpecifiers : report.typeSpecifiers).map(specifier => `\"${specifier.local.name}\"`);\n\n              const message = (() => {\n                const typeImports = util.formatWordList(importNames);\n\n                if (importNames.length === 1) {\n                  if (isTypeImport) {\n                    return {\n                      messageId: 'aImportInDecoMeta',\n                      data: {\n                        typeImports\n                      }\n                    };\n                  } else {\n                    return {\n                      messageId: 'aImportIsOnlyTypes',\n                      data: {\n                        typeImports\n                      }\n                    };\n                  }\n                } else {\n                  if (isTypeImport) {\n                    return {\n                      messageId: 'someImportsInDecoMeta',\n                      data: {\n                        typeImports\n                      }\n                    };\n                  } else {\n                    return {\n                      messageId: 'someImportsAreOnlyTypes',\n                      data: {\n                        typeImports\n                      }\n                    };\n                  }\n                }\n              })();\n\n              context.report(Object.assign(Object.assign({\n                node: report.node\n              }, message), {\n                *fix(fixer) {\n                  if (isTypeImport) {\n                    yield* fixToValueImportDeclaration(fixer, report, sourceImports);\n                  } else {\n                    yield* fixToTypeImportDeclaration(fixer, report, sourceImports);\n                  }\n                }\n\n              }));\n            }\n          }\n        }\n      }\n\n    } : {\n      // prefer no type imports\n      'ImportDeclaration[importKind = \"type\"]'(node) {\n        context.report({\n          node,\n          messageId: 'valueOverType',\n\n          fix(fixer) {\n            return fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);\n          }\n\n        });\n      },\n\n      'ImportSpecifier[importKind = \"type\"]'(node) {\n        context.report({\n          node,\n          messageId: 'valueOverType',\n\n          fix(fixer) {\n            return fixRemoveTypeSpecifierFromImportSpecifier(fixer, node);\n          }\n\n        });\n      }\n\n    }), disallowTypeAnnotations ? {\n      // disallow `import()` type\n      TSImportType(node) {\n        context.report({\n          node,\n          messageId: 'noImportTypeAnnotations'\n        });\n      }\n\n    } : {});\n\n    function classifySpecifier(node) {\n      var _a;\n\n      const defaultSpecifier = node.specifiers[0].type === utils_1.AST_NODE_TYPES.ImportDefaultSpecifier ? node.specifiers[0] : null;\n      const namespaceSpecifier = (_a = node.specifiers.find(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportNamespaceSpecifier)) !== null && _a !== void 0 ? _a : null;\n      const namedSpecifiers = node.specifiers.filter(specifier => specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier);\n      return {\n        defaultSpecifier,\n        namespaceSpecifier,\n        namedSpecifiers\n      };\n    }\n    /**\n     * Returns information for fixing named specifiers.\n     */\n\n\n    function getFixesNamedSpecifiers(fixer, node, typeNamedSpecifiers, allNamedSpecifiers) {\n      if (allNamedSpecifiers.length === 0) {\n        return {\n          typeNamedSpecifiersText: '',\n          removeTypeNamedSpecifiers: []\n        };\n      }\n\n      const typeNamedSpecifiersTexts = [];\n      const removeTypeNamedSpecifiers = [];\n\n      if (typeNamedSpecifiers.length === allNamedSpecifiers.length) {\n        // import Foo, {Type1, Type2} from 'foo'\n        // import DefType, {Type1, Type2} from 'foo'\n        const openingBraceToken = util.nullThrows(sourceCode.getTokenBefore(typeNamedSpecifiers[0], util.isOpeningBraceToken), util.NullThrowsReasons.MissingToken('{', node.type));\n        const commaToken = util.nullThrows(sourceCode.getTokenBefore(openingBraceToken, util.isCommaToken), util.NullThrowsReasons.MissingToken(',', node.type));\n        const closingBraceToken = util.nullThrows(sourceCode.getFirstTokenBetween(openingBraceToken, node.source, util.isClosingBraceToken), util.NullThrowsReasons.MissingToken('}', node.type)); // import DefType, {...} from 'foo'\n        //               ^^^^^^^ remove\n\n        removeTypeNamedSpecifiers.push(fixer.removeRange([commaToken.range[0], closingBraceToken.range[1]]));\n        typeNamedSpecifiersTexts.push(sourceCode.text.slice(openingBraceToken.range[1], closingBraceToken.range[0]));\n      } else {\n        const typeNamedSpecifierGroups = [];\n        let group = [];\n\n        for (const namedSpecifier of allNamedSpecifiers) {\n          if (typeNamedSpecifiers.includes(namedSpecifier)) {\n            group.push(namedSpecifier);\n          } else if (group.length) {\n            typeNamedSpecifierGroups.push(group);\n            group = [];\n          }\n        }\n\n        if (group.length) {\n          typeNamedSpecifierGroups.push(group);\n        }\n\n        for (const namedSpecifiers of typeNamedSpecifierGroups) {\n          const {\n            removeRange,\n            textRange\n          } = getNamedSpecifierRanges(namedSpecifiers, allNamedSpecifiers);\n          removeTypeNamedSpecifiers.push(fixer.removeRange(removeRange));\n          typeNamedSpecifiersTexts.push(sourceCode.text.slice(...textRange));\n        }\n      }\n\n      return {\n        typeNamedSpecifiersText: typeNamedSpecifiersTexts.join(','),\n        removeTypeNamedSpecifiers\n      };\n    }\n    /**\n     * Returns ranges for fixing named specifier.\n     */\n\n\n    function getNamedSpecifierRanges(namedSpecifierGroup, allNamedSpecifiers) {\n      const first = namedSpecifierGroup[0];\n      const last = namedSpecifierGroup[namedSpecifierGroup.length - 1];\n      const removeRange = [first.range[0], last.range[1]];\n      const textRange = [...removeRange];\n      const before = sourceCode.getTokenBefore(first);\n      textRange[0] = before.range[1];\n\n      if (util.isCommaToken(before)) {\n        removeRange[0] = before.range[0];\n      } else {\n        removeRange[0] = before.range[1];\n      }\n\n      const isFirst = allNamedSpecifiers[0] === first;\n      const isLast = allNamedSpecifiers[allNamedSpecifiers.length - 1] === last;\n      const after = sourceCode.getTokenAfter(last);\n      textRange[1] = after.range[0];\n\n      if (isFirst || isLast) {\n        if (util.isCommaToken(after)) {\n          removeRange[1] = after.range[1];\n        }\n      }\n\n      return {\n        textRange,\n        removeRange\n      };\n    }\n    /**\n     * insert specifiers to named import node.\n     * e.g.\n     * import type { Already, Type1, Type2 } from 'foo'\n     *                        ^^^^^^^^^^^^^ insert\n     */\n\n\n    function fixInsertNamedSpecifiersInNamedSpecifierList(fixer, target, insertText) {\n      const closingBraceToken = util.nullThrows(sourceCode.getFirstTokenBetween(sourceCode.getFirstToken(target), target.source, util.isClosingBraceToken), util.NullThrowsReasons.MissingToken('}', target.type));\n      const before = sourceCode.getTokenBefore(closingBraceToken);\n\n      if (!util.isCommaToken(before) && !util.isOpeningBraceToken(before)) {\n        insertText = `,${insertText}`;\n      }\n\n      return fixer.insertTextBefore(closingBraceToken, `${insertText}`);\n    }\n\n    function* fixToTypeImportDeclaration(fixer, report, sourceImports) {\n      const {\n        node\n      } = report;\n      const {\n        defaultSpecifier,\n        namespaceSpecifier,\n        namedSpecifiers\n      } = classifySpecifier(node);\n\n      if (namespaceSpecifier && !defaultSpecifier) {\n        // import * as types from 'foo'\n        yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, false);\n        return;\n      } else if (defaultSpecifier) {\n        if (report.typeSpecifiers.includes(defaultSpecifier) && namedSpecifiers.length === 0 && !namespaceSpecifier) {\n          // import Type from 'foo'\n          yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, true);\n          return;\n        }\n      } else {\n        if (namedSpecifiers.every(specifier => report.typeSpecifiers.includes(specifier)) && !namespaceSpecifier) {\n          // import {Type1, Type2} from 'foo'\n          yield* fixInsertTypeSpecifierForImportDeclaration(fixer, node, false);\n          return;\n        }\n      }\n\n      const typeNamedSpecifiers = namedSpecifiers.filter(specifier => report.typeSpecifiers.includes(specifier));\n      const fixesNamedSpecifiers = getFixesNamedSpecifiers(fixer, node, typeNamedSpecifiers, namedSpecifiers);\n      const afterFixes = [];\n\n      if (typeNamedSpecifiers.length) {\n        if (sourceImports.typeOnlyNamedImport) {\n          const insertTypeNamedSpecifiers = fixInsertNamedSpecifiersInNamedSpecifierList(fixer, sourceImports.typeOnlyNamedImport, fixesNamedSpecifiers.typeNamedSpecifiersText);\n\n          if (sourceImports.typeOnlyNamedImport.range[1] <= node.range[0]) {\n            yield insertTypeNamedSpecifiers;\n          } else {\n            afterFixes.push(insertTypeNamedSpecifiers);\n          }\n        } else {\n          yield fixer.insertTextBefore(node, `import type {${fixesNamedSpecifiers.typeNamedSpecifiersText}} from ${sourceCode.getText(node.source)};\\n`);\n        }\n      }\n\n      const fixesRemoveTypeNamespaceSpecifier = [];\n\n      if (namespaceSpecifier && report.typeSpecifiers.includes(namespaceSpecifier)) {\n        // import Foo, * as Type from 'foo'\n        // import DefType, * as Type from 'foo'\n        // import DefType, * as Type from 'foo'\n        const commaToken = util.nullThrows(sourceCode.getTokenBefore(namespaceSpecifier, util.isCommaToken), util.NullThrowsReasons.MissingToken(',', node.type)); // import Def, * as Ns from 'foo'\n        //           ^^^^^^^^^ remove\n\n        fixesRemoveTypeNamespaceSpecifier.push(fixer.removeRange([commaToken.range[0], namespaceSpecifier.range[1]])); // import type * as Ns from 'foo'\n        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ insert\n\n        yield fixer.insertTextBefore(node, `import type ${sourceCode.getText(namespaceSpecifier)} from ${sourceCode.getText(node.source)};\\n`);\n      }\n\n      if (defaultSpecifier && report.typeSpecifiers.includes(defaultSpecifier)) {\n        if (report.typeSpecifiers.length === node.specifiers.length) {\n          const importToken = util.nullThrows(sourceCode.getFirstToken(node, isImportToken), util.NullThrowsReasons.MissingToken('import', node.type)); // import type Type from 'foo'\n          //        ^^^^ insert\n\n          yield fixer.insertTextAfter(importToken, ' type');\n        } else {\n          const commaToken = util.nullThrows(sourceCode.getTokenAfter(defaultSpecifier, util.isCommaToken), util.NullThrowsReasons.MissingToken(',', defaultSpecifier.type)); // import Type , {...} from 'foo'\n          //        ^^^^^ pick\n\n          const defaultText = sourceCode.text.slice(defaultSpecifier.range[0], commaToken.range[0]).trim();\n          yield fixer.insertTextBefore(node, `import type ${defaultText} from ${sourceCode.getText(node.source)};\\n`);\n          const afterToken = util.nullThrows(sourceCode.getTokenAfter(commaToken, {\n            includeComments: true\n          }), util.NullThrowsReasons.MissingToken('any token', node.type)); // import Type , {...} from 'foo'\n          //        ^^^^^^^ remove\n\n          yield fixer.removeRange([defaultSpecifier.range[0], afterToken.range[0]]);\n        }\n      }\n\n      yield* fixesNamedSpecifiers.removeTypeNamedSpecifiers;\n      yield* fixesRemoveTypeNamespaceSpecifier;\n      yield* afterFixes;\n    }\n\n    function* fixInsertTypeSpecifierForImportDeclaration(fixer, node, isDefaultImport) {\n      // import type Foo from 'foo'\n      //       ^^^^^ insert\n      const importToken = util.nullThrows(sourceCode.getFirstToken(node, isImportToken), util.NullThrowsReasons.MissingToken('import', node.type));\n      yield fixer.insertTextAfter(importToken, ' type');\n\n      if (isDefaultImport) {\n        // Has default import\n        const openingBraceToken = sourceCode.getFirstTokenBetween(importToken, node.source, util.isOpeningBraceToken);\n\n        if (openingBraceToken) {\n          // Only braces. e.g. import Foo, {} from 'foo'\n          const commaToken = util.nullThrows(sourceCode.getTokenBefore(openingBraceToken, util.isCommaToken), util.NullThrowsReasons.MissingToken(',', node.type));\n          const closingBraceToken = util.nullThrows(sourceCode.getFirstTokenBetween(openingBraceToken, node.source, util.isClosingBraceToken), util.NullThrowsReasons.MissingToken('}', node.type)); // import type Foo, {} from 'foo'\n          //                  ^^ remove\n\n          yield fixer.removeRange([commaToken.range[0], closingBraceToken.range[1]]);\n          const specifiersText = sourceCode.text.slice(commaToken.range[1], closingBraceToken.range[1]);\n\n          if (node.specifiers.length > 1) {\n            // import type Foo from 'foo'\n            // import type {...} from 'foo' // <- insert\n            yield fixer.insertTextAfter(node, `\\nimport type${specifiersText} from ${sourceCode.getText(node.source)};`);\n          }\n        }\n      } // make sure we don't do anything like `import type {type T} from 'foo';`\n\n\n      for (const specifier of node.specifiers) {\n        if (specifier.type === utils_1.AST_NODE_TYPES.ImportSpecifier && specifier.importKind === 'type') {\n          yield* fixRemoveTypeSpecifierFromImportSpecifier(fixer, specifier);\n        }\n      }\n    }\n\n    function* fixToValueImportDeclaration(fixer, report, sourceImports) {\n      const {\n        node\n      } = report;\n      const {\n        defaultSpecifier,\n        namespaceSpecifier,\n        namedSpecifiers\n      } = classifySpecifier(node);\n\n      if (namespaceSpecifier) {\n        // import type * as types from 'foo'\n        yield* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);\n        return;\n      } else if (defaultSpecifier) {\n        if (report.valueSpecifiers.includes(defaultSpecifier) && namedSpecifiers.length === 0) {\n          // import type Type from 'foo'\n          yield* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);\n          return;\n        }\n      } else {\n        if (namedSpecifiers.every(specifier => report.valueSpecifiers.includes(specifier))) {\n          // import type {Type1, Type2} from 'foo'\n          yield* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node);\n          return;\n        }\n      }\n\n      const valueNamedSpecifiers = namedSpecifiers.filter(specifier => report.valueSpecifiers.includes(specifier));\n      const fixesNamedSpecifiers = getFixesNamedSpecifiers(fixer, node, valueNamedSpecifiers, namedSpecifiers);\n      const afterFixes = [];\n\n      if (valueNamedSpecifiers.length) {\n        if (sourceImports.valueOnlyNamedImport) {\n          const insertTypeNamedSpecifiers = fixInsertNamedSpecifiersInNamedSpecifierList(fixer, sourceImports.valueOnlyNamedImport, fixesNamedSpecifiers.typeNamedSpecifiersText);\n\n          if (sourceImports.valueOnlyNamedImport.range[1] <= node.range[0]) {\n            yield insertTypeNamedSpecifiers;\n          } else {\n            afterFixes.push(insertTypeNamedSpecifiers);\n          }\n        } else {\n          yield fixer.insertTextBefore(node, `import {${fixesNamedSpecifiers.typeNamedSpecifiersText}} from ${sourceCode.getText(node.source)};\\n`);\n        }\n      }\n\n      yield* fixesNamedSpecifiers.removeTypeNamedSpecifiers;\n      yield* afterFixes;\n    }\n\n    function* fixRemoveTypeSpecifierFromImportDeclaration(fixer, node) {\n      var _a, _b; // import type Foo from 'foo'\n      //        ^^^^ remove\n\n\n      const importToken = util.nullThrows(sourceCode.getFirstToken(node, isImportToken), util.NullThrowsReasons.MissingToken('import', node.type));\n      const typeToken = util.nullThrows(sourceCode.getFirstTokenBetween(importToken, (_b = (_a = node.specifiers[0]) === null || _a === void 0 ? void 0 : _a.local) !== null && _b !== void 0 ? _b : node.source, isTypeToken), util.NullThrowsReasons.MissingToken('type', node.type));\n      const afterToken = util.nullThrows(sourceCode.getTokenAfter(typeToken, {\n        includeComments: true\n      }), util.NullThrowsReasons.MissingToken('any token', node.type));\n      yield fixer.removeRange([typeToken.range[0], afterToken.range[0]]);\n    }\n\n    function* fixRemoveTypeSpecifierFromImportSpecifier(fixer, node) {\n      const typeToken = util.nullThrows(sourceCode.getFirstToken(node, isTypeToken), util.NullThrowsReasons.MissingToken('type', node.type));\n      const afterToken = util.nullThrows(sourceCode.getTokenAfter(typeToken, {\n        includeComments: true\n      }), util.NullThrowsReasons.MissingToken('any token', node.type));\n      yield fixer.removeRange([typeToken.range[0], afterToken.range[0]]);\n    }\n  }\n\n});","map":{"version":3,"mappings":"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","names":["isImportToken","token","type","utils_1","Keyword","value","isTypeToken","Identifier","exports","util","createRule","name","meta","docs","description","recommended","messages","typeOverValue","someImportsAreOnlyTypes","aImportIsOnlyTypes","someImportsInDecoMeta","aImportInDecoMeta","valueOverType","noImportTypeAnnotations","schema","properties","prefer","enum","disallowTypeAnnotations","additionalProperties","fixable","defaultOptions","create","context","option","_a","sourceCode","getSourceCode","sourceImportsMap","ImportDeclaration","node","source","sourceImports","reportValueImports","typeOnlyNamedImport","valueOnlyNamedImport","importKind","specifiers","every","specifier","ImportSpecifier","typeSpecifiers","inlineTypeSpecifiers","valueSpecifiers","unusedSpecifiers","push","variable","getDeclaredVariables","references","length","onlyHasTypeReferences","ref","identifier","parent","ExportSpecifier","_b","ExportDefaultDeclaration","isValueReference","isTypeReference","child","TSTypeQuery","TSQualifiedName","left","TSPropertySignature","key","MemberExpression","object","Object","values","report","messageId","fix","fixer","fixToTypeImportDeclaration","isTypeImport","importNames","map","local","message","typeImports","formatWordList","data","fixToValueImportDeclaration","fixRemoveTypeSpecifierFromImportDeclaration","fixRemoveTypeSpecifierFromImportSpecifier","TSImportType","classifySpecifier","defaultSpecifier","ImportDefaultSpecifier","namespaceSpecifier","find","ImportNamespaceSpecifier","namedSpecifiers","filter","getFixesNamedSpecifiers","typeNamedSpecifiers","allNamedSpecifiers","typeNamedSpecifiersText","removeTypeNamedSpecifiers","typeNamedSpecifiersTexts","openingBraceToken","nullThrows","getTokenBefore","isOpeningBraceToken","NullThrowsReasons","MissingToken","commaToken","isCommaToken","closingBraceToken","getFirstTokenBetween","isClosingBraceToken","removeRange","range","text","slice","typeNamedSpecifierGroups","group","namedSpecifier","includes","textRange","getNamedSpecifierRanges","join","namedSpecifierGroup","first","last","before","isFirst","isLast","after","getTokenAfter","fixInsertNamedSpecifiersInNamedSpecifierList","target","insertText","getFirstToken","insertTextBefore","fixInsertTypeSpecifierForImportDeclaration","fixesNamedSpecifiers","afterFixes","insertTypeNamedSpecifiers","getText","fixesRemoveTypeNamespaceSpecifier","importToken","insertTextAfter","defaultText","trim","afterToken","includeComments","isDefaultImport","specifiersText","valueNamedSpecifiers","typeToken"],"sources":["../../src/rules/consistent-type-imports.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}