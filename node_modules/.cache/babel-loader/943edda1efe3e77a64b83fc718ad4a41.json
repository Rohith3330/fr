{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('estraverse')) : typeof define === 'function' && define.amd ? define(['estraverse'], factory) : (global = global || self, global.esquery = factory(global.estraverse));\n})(this, function (estraverse) {\n  'use strict';\n\n  estraverse = estraverse && Object.prototype.hasOwnProperty.call(estraverse, 'default') ? estraverse['default'] : estraverse;\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n\n        var F = function () {};\n\n        return {\n          s: F,\n          n: function () {\n            if (i >= o.length) return {\n              done: true\n            };\n            return {\n              done: false,\n              value: o[i++]\n            };\n          },\n          e: function (e) {\n            throw e;\n          },\n          f: F\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true,\n        didErr = false,\n        err;\n    return {\n      s: function () {\n        it = o[Symbol.iterator]();\n      },\n      n: function () {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function (e) {\n        didErr = true;\n        err = e;\n      },\n      f: function () {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var parser = createCommonjsModule(function (module) {\n    /*\n     * Generated by PEG.js 0.10.0.\n     *\n     * http://pegjs.org/\n     */\n    (function (root, factory) {\n      if (module.exports) {\n        module.exports = factory();\n      }\n    })(commonjsGlobal, function () {\n      function peg$subclass(child, parent) {\n        function ctor() {\n          this.constructor = child;\n        }\n\n        ctor.prototype = parent.prototype;\n        child.prototype = new ctor();\n      }\n\n      function peg$SyntaxError(message, expected, found, location) {\n        this.message = message;\n        this.expected = expected;\n        this.found = found;\n        this.location = location;\n        this.name = \"SyntaxError\";\n\n        if (typeof Error.captureStackTrace === \"function\") {\n          Error.captureStackTrace(this, peg$SyntaxError);\n        }\n      }\n\n      peg$subclass(peg$SyntaxError, Error);\n\n      peg$SyntaxError.buildMessage = function (expected, found) {\n        var DESCRIBE_EXPECTATION_FNS = {\n          literal: function literal(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n          \"class\": function _class(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n          any: function any(expectation) {\n            return \"any character\";\n          },\n          end: function end(expectation) {\n            return \"end of input\";\n          },\n          other: function other(expectation) {\n            return expectation.description;\n          }\n        };\n\n        function hex(ch) {\n          return ch.charCodeAt(0).toString(16).toUpperCase();\n        }\n\n        function literalEscape(s) {\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          });\n        }\n\n        function classEscape(s) {\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\\]/g, '\\\\]').replace(/\\^/g, '\\\\^').replace(/-/g, '\\\\-').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          });\n        }\n\n        function describeExpectation(expectation) {\n          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n        }\n\n        function describeExpected(expected) {\n          var descriptions = new Array(expected.length),\n              i,\n              j;\n\n          for (i = 0; i < expected.length; i++) {\n            descriptions[i] = describeExpectation(expected[i]);\n          }\n\n          descriptions.sort();\n\n          if (descriptions.length > 0) {\n            for (i = 1, j = 1; i < descriptions.length; i++) {\n              if (descriptions[i - 1] !== descriptions[i]) {\n                descriptions[j] = descriptions[i];\n                j++;\n              }\n            }\n\n            descriptions.length = j;\n          }\n\n          switch (descriptions.length) {\n            case 1:\n              return descriptions[0];\n\n            case 2:\n              return descriptions[0] + \" or \" + descriptions[1];\n\n            default:\n              return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n          }\n        }\n\n        function describeFound(found) {\n          return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n        }\n\n        return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n      };\n\n      function peg$parse(input, options) {\n        options = options !== void 0 ? options : {};\n\n        var peg$FAILED = {},\n            peg$startRuleFunctions = {\n          start: peg$parsestart\n        },\n            peg$startRuleFunction = peg$parsestart,\n            peg$c0 = function peg$c0(ss) {\n          return ss.length === 1 ? ss[0] : {\n            type: 'matches',\n            selectors: ss\n          };\n        },\n            peg$c1 = function peg$c1() {\n          return void 0;\n        },\n            peg$c2 = \" \",\n            peg$c3 = peg$literalExpectation(\" \", false),\n            peg$c4 = /^[^ [\\],():#!=><~+.]/,\n            peg$c5 = peg$classExpectation([\" \", \"[\", \"]\", \",\", \"(\", \")\", \":\", \"#\", \"!\", \"=\", \">\", \"<\", \"~\", \"+\", \".\"], true, false),\n            peg$c6 = function peg$c6(i) {\n          return i.join('');\n        },\n            peg$c7 = \">\",\n            peg$c8 = peg$literalExpectation(\">\", false),\n            peg$c9 = function peg$c9() {\n          return 'child';\n        },\n            peg$c10 = \"~\",\n            peg$c11 = peg$literalExpectation(\"~\", false),\n            peg$c12 = function peg$c12() {\n          return 'sibling';\n        },\n            peg$c13 = \"+\",\n            peg$c14 = peg$literalExpectation(\"+\", false),\n            peg$c15 = function peg$c15() {\n          return 'adjacent';\n        },\n            peg$c16 = function peg$c16() {\n          return 'descendant';\n        },\n            peg$c17 = \",\",\n            peg$c18 = peg$literalExpectation(\",\", false),\n            peg$c19 = function peg$c19(s, ss) {\n          return [s].concat(ss.map(function (s) {\n            return s[3];\n          }));\n        },\n            peg$c20 = function peg$c20(a, ops) {\n          return ops.reduce(function (memo, rhs) {\n            return {\n              type: rhs[0],\n              left: memo,\n              right: rhs[1]\n            };\n          }, a);\n        },\n            peg$c21 = \"!\",\n            peg$c22 = peg$literalExpectation(\"!\", false),\n            peg$c23 = function peg$c23(subject, as) {\n          var b = as.length === 1 ? as[0] : {\n            type: 'compound',\n            selectors: as\n          };\n          if (subject) b.subject = true;\n          return b;\n        },\n            peg$c24 = \"*\",\n            peg$c25 = peg$literalExpectation(\"*\", false),\n            peg$c26 = function peg$c26(a) {\n          return {\n            type: 'wildcard',\n            value: a\n          };\n        },\n            peg$c27 = \"#\",\n            peg$c28 = peg$literalExpectation(\"#\", false),\n            peg$c29 = function peg$c29(i) {\n          return {\n            type: 'identifier',\n            value: i\n          };\n        },\n            peg$c30 = \"[\",\n            peg$c31 = peg$literalExpectation(\"[\", false),\n            peg$c32 = \"]\",\n            peg$c33 = peg$literalExpectation(\"]\", false),\n            peg$c34 = function peg$c34(v) {\n          return v;\n        },\n            peg$c35 = /^[><!]/,\n            peg$c36 = peg$classExpectation([\">\", \"<\", \"!\"], false, false),\n            peg$c37 = \"=\",\n            peg$c38 = peg$literalExpectation(\"=\", false),\n            peg$c39 = function peg$c39(a) {\n          return (a || '') + '=';\n        },\n            peg$c40 = /^[><]/,\n            peg$c41 = peg$classExpectation([\">\", \"<\"], false, false),\n            peg$c42 = \".\",\n            peg$c43 = peg$literalExpectation(\".\", false),\n            peg$c44 = function peg$c44(a, as) {\n          return [].concat.apply([a], as).join('');\n        },\n            peg$c45 = function peg$c45(name, op, value) {\n          return {\n            type: 'attribute',\n            name: name,\n            operator: op,\n            value: value\n          };\n        },\n            peg$c46 = function peg$c46(name) {\n          return {\n            type: 'attribute',\n            name: name\n          };\n        },\n            peg$c47 = \"\\\"\",\n            peg$c48 = peg$literalExpectation(\"\\\"\", false),\n            peg$c49 = /^[^\\\\\"]/,\n            peg$c50 = peg$classExpectation([\"\\\\\", \"\\\"\"], true, false),\n            peg$c51 = \"\\\\\",\n            peg$c52 = peg$literalExpectation(\"\\\\\", false),\n            peg$c53 = peg$anyExpectation(),\n            peg$c54 = function peg$c54(a, b) {\n          return a + b;\n        },\n            peg$c55 = function peg$c55(d) {\n          return {\n            type: 'literal',\n            value: strUnescape(d.join(''))\n          };\n        },\n            peg$c56 = \"'\",\n            peg$c57 = peg$literalExpectation(\"'\", false),\n            peg$c58 = /^[^\\\\']/,\n            peg$c59 = peg$classExpectation([\"\\\\\", \"'\"], true, false),\n            peg$c60 = /^[0-9]/,\n            peg$c61 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n            peg$c62 = function peg$c62(a, b) {\n          // Can use `a.flat().join('')` once supported\n          var leadingDecimals = a ? [].concat.apply([], a).join('') : '';\n          return {\n            type: 'literal',\n            value: parseFloat(leadingDecimals + b.join(''))\n          };\n        },\n            peg$c63 = function peg$c63(i) {\n          return {\n            type: 'literal',\n            value: i\n          };\n        },\n            peg$c64 = \"type(\",\n            peg$c65 = peg$literalExpectation(\"type(\", false),\n            peg$c66 = /^[^ )]/,\n            peg$c67 = peg$classExpectation([\" \", \")\"], true, false),\n            peg$c68 = \")\",\n            peg$c69 = peg$literalExpectation(\")\", false),\n            peg$c70 = function peg$c70(t) {\n          return {\n            type: 'type',\n            value: t.join('')\n          };\n        },\n            peg$c71 = /^[imsu]/,\n            peg$c72 = peg$classExpectation([\"i\", \"m\", \"s\", \"u\"], false, false),\n            peg$c73 = \"/\",\n            peg$c74 = peg$literalExpectation(\"/\", false),\n            peg$c75 = /^[^\\/]/,\n            peg$c76 = peg$classExpectation([\"/\"], true, false),\n            peg$c77 = function peg$c77(d, flgs) {\n          return {\n            type: 'regexp',\n            value: new RegExp(d.join(''), flgs ? flgs.join('') : '')\n          };\n        },\n            peg$c78 = function peg$c78(i, is) {\n          return {\n            type: 'field',\n            name: is.reduce(function (memo, p) {\n              return memo + p[0] + p[1];\n            }, i)\n          };\n        },\n            peg$c79 = \":not(\",\n            peg$c80 = peg$literalExpectation(\":not(\", false),\n            peg$c81 = function peg$c81(ss) {\n          return {\n            type: 'not',\n            selectors: ss\n          };\n        },\n            peg$c82 = \":matches(\",\n            peg$c83 = peg$literalExpectation(\":matches(\", false),\n            peg$c84 = function peg$c84(ss) {\n          return {\n            type: 'matches',\n            selectors: ss\n          };\n        },\n            peg$c85 = \":has(\",\n            peg$c86 = peg$literalExpectation(\":has(\", false),\n            peg$c87 = function peg$c87(ss) {\n          return {\n            type: 'has',\n            selectors: ss\n          };\n        },\n            peg$c88 = \":first-child\",\n            peg$c89 = peg$literalExpectation(\":first-child\", false),\n            peg$c90 = function peg$c90() {\n          return nth(1);\n        },\n            peg$c91 = \":last-child\",\n            peg$c92 = peg$literalExpectation(\":last-child\", false),\n            peg$c93 = function peg$c93() {\n          return nthLast(1);\n        },\n            peg$c94 = \":nth-child(\",\n            peg$c95 = peg$literalExpectation(\":nth-child(\", false),\n            peg$c96 = function peg$c96(n) {\n          return nth(parseInt(n.join(''), 10));\n        },\n            peg$c97 = \":nth-last-child(\",\n            peg$c98 = peg$literalExpectation(\":nth-last-child(\", false),\n            peg$c99 = function peg$c99(n) {\n          return nthLast(parseInt(n.join(''), 10));\n        },\n            peg$c100 = \":\",\n            peg$c101 = peg$literalExpectation(\":\", false),\n            peg$c102 = \"statement\",\n            peg$c103 = peg$literalExpectation(\"statement\", true),\n            peg$c104 = \"expression\",\n            peg$c105 = peg$literalExpectation(\"expression\", true),\n            peg$c106 = \"declaration\",\n            peg$c107 = peg$literalExpectation(\"declaration\", true),\n            peg$c108 = \"function\",\n            peg$c109 = peg$literalExpectation(\"function\", true),\n            peg$c110 = \"pattern\",\n            peg$c111 = peg$literalExpectation(\"pattern\", true),\n            peg$c112 = function peg$c112(c) {\n          return {\n            type: 'class',\n            name: c\n          };\n        },\n            peg$currPos = 0,\n            peg$posDetailsCache = [{\n          line: 1,\n          column: 1\n        }],\n            peg$maxFailPos = 0,\n            peg$maxFailExpected = [],\n            peg$resultsCache = {},\n            peg$result;\n\n        if (\"startRule\" in options) {\n          if (!(options.startRule in peg$startRuleFunctions)) {\n            throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n          }\n\n          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n        }\n\n        function peg$literalExpectation(text, ignoreCase) {\n          return {\n            type: \"literal\",\n            text: text,\n            ignoreCase: ignoreCase\n          };\n        }\n\n        function peg$classExpectation(parts, inverted, ignoreCase) {\n          return {\n            type: \"class\",\n            parts: parts,\n            inverted: inverted,\n            ignoreCase: ignoreCase\n          };\n        }\n\n        function peg$anyExpectation() {\n          return {\n            type: \"any\"\n          };\n        }\n\n        function peg$endExpectation() {\n          return {\n            type: \"end\"\n          };\n        }\n\n        function peg$computePosDetails(pos) {\n          var details = peg$posDetailsCache[pos],\n              p;\n\n          if (details) {\n            return details;\n          } else {\n            p = pos - 1;\n\n            while (!peg$posDetailsCache[p]) {\n              p--;\n            }\n\n            details = peg$posDetailsCache[p];\n            details = {\n              line: details.line,\n              column: details.column\n            };\n\n            while (p < pos) {\n              if (input.charCodeAt(p) === 10) {\n                details.line++;\n                details.column = 1;\n              } else {\n                details.column++;\n              }\n\n              p++;\n            }\n\n            peg$posDetailsCache[pos] = details;\n            return details;\n          }\n        }\n\n        function peg$computeLocation(startPos, endPos) {\n          var startPosDetails = peg$computePosDetails(startPos),\n              endPosDetails = peg$computePosDetails(endPos);\n          return {\n            start: {\n              offset: startPos,\n              line: startPosDetails.line,\n              column: startPosDetails.column\n            },\n            end: {\n              offset: endPos,\n              line: endPosDetails.line,\n              column: endPosDetails.column\n            }\n          };\n        }\n\n        function peg$fail(expected) {\n          if (peg$currPos < peg$maxFailPos) {\n            return;\n          }\n\n          if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n          }\n\n          peg$maxFailExpected.push(expected);\n        }\n\n        function peg$buildStructuredError(expected, found, location) {\n          return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n        }\n\n        function peg$parsestart() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 0,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseselectors();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c0(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n\n            if (s1 !== peg$FAILED) {\n              s1 = peg$c1();\n            }\n\n            s0 = s1;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parse_() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 1,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = [];\n\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s1 = peg$c2;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c3);\n            }\n          }\n\n          while (s1 !== peg$FAILED) {\n            s0.push(s1);\n\n            if (input.charCodeAt(peg$currPos) === 32) {\n              s1 = peg$c2;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              {\n                peg$fail(peg$c3);\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseidentifierName() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 2,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = [];\n\n          if (peg$c4.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            {\n              peg$fail(peg$c5);\n            }\n          }\n\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n\n              if (peg$c4.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                {\n                  peg$fail(peg$c5);\n                }\n              }\n            }\n          } else {\n            s1 = peg$FAILED;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c6(s1);\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsebinaryOp() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 3,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 62) {\n              s2 = peg$c7;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              {\n                peg$fail(peg$c8);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c9();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n\n            if (s1 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 126) {\n                s2 = peg$c10;\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                {\n                  peg$fail(peg$c11);\n                }\n              }\n\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parse_();\n\n                if (s3 !== peg$FAILED) {\n                  s1 = peg$c12();\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parse_();\n\n              if (s1 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 43) {\n                  s2 = peg$c13;\n                  peg$currPos++;\n                } else {\n                  s2 = peg$FAILED;\n                  {\n                    peg$fail(peg$c14);\n                  }\n                }\n\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parse_();\n\n                  if (s3 !== peg$FAILED) {\n                    s1 = peg$c15();\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 32) {\n                  s1 = peg$c2;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  {\n                    peg$fail(peg$c3);\n                  }\n                }\n\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parse_();\n\n                  if (s2 !== peg$FAILED) {\n                    s1 = peg$c16();\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseselectors() {\n          var s0, s1, s2, s3, s4, s5, s6, s7;\n          var key = peg$currPos * 30 + 4,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseselector();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$parse_();\n\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c17;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                {\n                  peg$fail(peg$c18);\n                }\n              }\n\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parseselector();\n\n                  if (s7 !== peg$FAILED) {\n                    s4 = [s4, s5, s6, s7];\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$parse_();\n\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s5 = peg$c17;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c18);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse_();\n\n                  if (s6 !== peg$FAILED) {\n                    s7 = peg$parseselector();\n\n                    if (s7 !== peg$FAILED) {\n                      s4 = [s4, s5, s6, s7];\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c19(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseselector() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 5,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parsesequence();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$parsebinaryOp();\n\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsesequence();\n\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$parsebinaryOp();\n\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsesequence();\n\n                if (s5 !== peg$FAILED) {\n                  s4 = [s4, s5];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c20(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsesequence() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 6,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 33) {\n            s1 = peg$c21;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c22);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parseatom();\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parseatom();\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c23(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseatom() {\n          var s0;\n          var key = peg$currPos * 30 + 7,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$parsewildcard();\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseidentifier();\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseattr();\n\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsefield();\n\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsenegation();\n\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsematches();\n\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsehas();\n\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsefirstChild();\n\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parselastChild();\n\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsenthChild();\n\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parsenthLastChild();\n\n                              if (s0 === peg$FAILED) {\n                                s0 = peg$parseclass();\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsewildcard() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 8,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s1 = peg$c24;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c25);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c26(s1);\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseidentifier() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 9,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 35) {\n            s1 = peg$c27;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c28);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseidentifierName();\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c29(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattr() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 10,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s1 = peg$c30;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c31);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseattrValue();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 93) {\n                    s5 = peg$c32;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c33);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c34(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrOps() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 11,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (peg$c35.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c36);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s2 = peg$c37;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              {\n                peg$fail(peg$c38);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c39(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            if (peg$c40.test(input.charAt(peg$currPos))) {\n              s0 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              {\n                peg$fail(peg$c41);\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrEqOps() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 12,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 33) {\n            s1 = peg$c21;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c22);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s2 = peg$c37;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              {\n                peg$fail(peg$c38);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c39(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrName() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 13,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseidentifierName();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s4 = peg$c42;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              {\n                peg$fail(peg$c43);\n              }\n            }\n\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseidentifierName();\n\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s4 = peg$c42;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c43);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parseidentifierName();\n\n                if (s5 !== peg$FAILED) {\n                  s4 = [s4, s5];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c44(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrValue() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 14,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseattrName();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseattrEqOps();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsetype();\n\n                  if (s5 === peg$FAILED) {\n                    s5 = peg$parseregex();\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c45(s1, s3, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseattrName();\n\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parseattrOps();\n\n                if (s3 !== peg$FAILED) {\n                  s4 = peg$parse_();\n\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsestring();\n\n                    if (s5 === peg$FAILED) {\n                      s5 = peg$parsenumber();\n\n                      if (s5 === peg$FAILED) {\n                        s5 = peg$parsepath();\n                      }\n                    }\n\n                    if (s5 !== peg$FAILED) {\n                      s1 = peg$c45(s1, s3, s5);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parseattrName();\n\n              if (s1 !== peg$FAILED) {\n                s1 = peg$c46(s1);\n              }\n\n              s0 = s1;\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsestring() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 15,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s1 = peg$c47;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c48);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n\n            if (peg$c49.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c50);\n              }\n            }\n\n            if (s3 === peg$FAILED) {\n              s3 = peg$currPos;\n\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s4 = peg$c51;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c52);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c53);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s4 = peg$c54(s4, s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n\n              if (peg$c49.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c50);\n                }\n              }\n\n              if (s3 === peg$FAILED) {\n                s3 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 92) {\n                  s4 = peg$c51;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  {\n                    peg$fail(peg$c52);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s5 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c53);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s4 = peg$c54(s4, s5);\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 34) {\n                s3 = peg$c47;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c48);\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c55(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n\n            if (input.charCodeAt(peg$currPos) === 39) {\n              s1 = peg$c56;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              {\n                peg$fail(peg$c57);\n              }\n            }\n\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n\n              if (peg$c58.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c59);\n                }\n              }\n\n              if (s3 === peg$FAILED) {\n                s3 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 92) {\n                  s4 = peg$c51;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  {\n                    peg$fail(peg$c52);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s5 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c53);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s4 = peg$c54(s4, s5);\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n\n                if (peg$c58.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  {\n                    peg$fail(peg$c59);\n                  }\n                }\n\n                if (s3 === peg$FAILED) {\n                  s3 = peg$currPos;\n\n                  if (input.charCodeAt(peg$currPos) === 92) {\n                    s4 = peg$c51;\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    {\n                      peg$fail(peg$c52);\n                    }\n                  }\n\n                  if (s4 !== peg$FAILED) {\n                    if (input.length > peg$currPos) {\n                      s5 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s5 = peg$FAILED;\n                      {\n                        peg$fail(peg$c53);\n                      }\n                    }\n\n                    if (s5 !== peg$FAILED) {\n                      s4 = peg$c54(s4, s5);\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                }\n              }\n\n              if (s2 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 39) {\n                  s3 = peg$c56;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  {\n                    peg$fail(peg$c57);\n                  }\n                }\n\n                if (s3 !== peg$FAILED) {\n                  s1 = peg$c55(s2);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenumber() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 16,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$currPos;\n          s2 = [];\n\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            {\n              peg$fail(peg$c61);\n            }\n          }\n\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n\n            if (peg$c60.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c61);\n              }\n            }\n          }\n\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s3 = peg$c42;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c43);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              s2 = [s2, s3];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n\n            if (peg$c60.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c61);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n\n                if (peg$c60.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  {\n                    peg$fail(peg$c61);\n                  }\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c62(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsepath() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 17,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseidentifierName();\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c63(s1);\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsetype() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 18,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 5) === peg$c64) {\n            s1 = peg$c64;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c65);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n\n              if (peg$c66.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c67);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n\n                  if (peg$c66.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    {\n                      peg$fail(peg$c67);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c70(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseflags() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 19,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = [];\n\n          if (peg$c71.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c72);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            while (s1 !== peg$FAILED) {\n              s0.push(s1);\n\n              if (peg$c71.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                {\n                  peg$fail(peg$c72);\n                }\n              }\n            }\n          } else {\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseregex() {\n          var s0, s1, s2, s3, s4;\n          var key = peg$currPos * 30 + 20,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s1 = peg$c73;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c74);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n\n            if (peg$c75.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c76);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n\n                if (peg$c75.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  {\n                    peg$fail(peg$c76);\n                  }\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 47) {\n                s3 = peg$c73;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c74);\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parseflags();\n\n                if (s4 === peg$FAILED) {\n                  s4 = null;\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s1 = peg$c77(s2, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsefield() {\n          var s0, s1, s2, s3, s4, s5, s6;\n          var key = peg$currPos * 30 + 21,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s1 = peg$c42;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c43);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseidentifierName();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$currPos;\n\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s5 = peg$c42;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                {\n                  peg$fail(peg$c43);\n                }\n              }\n\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseidentifierName();\n\n                if (s6 !== peg$FAILED) {\n                  s5 = [s5, s6];\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 46) {\n                  s5 = peg$c42;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c43);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parseidentifierName();\n\n                  if (s6 !== peg$FAILED) {\n                    s5 = [s5, s6];\n                    s4 = s5;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c78(s2, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenegation() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 22,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 5) === peg$c79) {\n            s1 = peg$c79;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c80);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c81(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsematches() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 23,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 9) === peg$c82) {\n            s1 = peg$c82;\n            peg$currPos += 9;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c83);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c84(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsehas() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 24,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 5) === peg$c85) {\n            s1 = peg$c85;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c86);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c87(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsefirstChild() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 25,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 12) === peg$c88) {\n            s1 = peg$c88;\n            peg$currPos += 12;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c89);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c90();\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parselastChild() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 26,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 11) === peg$c91) {\n            s1 = peg$c91;\n            peg$currPos += 11;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c92);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c93();\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenthChild() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 27,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 11) === peg$c94) {\n            s1 = peg$c94;\n            peg$currPos += 11;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c95);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c61);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n\n                  if (peg$c60.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    {\n                      peg$fail(peg$c61);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c96(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenthLastChild() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 28,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 16) === peg$c97) {\n            s1 = peg$c97;\n            peg$currPos += 16;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c98);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c61);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n\n                  if (peg$c60.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    {\n                      peg$fail(peg$c61);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c99(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseclass() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 29,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s1 = peg$c100;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c101);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c102) {\n              s2 = input.substr(peg$currPos, 9);\n              peg$currPos += 9;\n            } else {\n              s2 = peg$FAILED;\n              {\n                peg$fail(peg$c103);\n              }\n            }\n\n            if (s2 === peg$FAILED) {\n              if (input.substr(peg$currPos, 10).toLowerCase() === peg$c104) {\n                s2 = input.substr(peg$currPos, 10);\n                peg$currPos += 10;\n              } else {\n                s2 = peg$FAILED;\n                {\n                  peg$fail(peg$c105);\n                }\n              }\n\n              if (s2 === peg$FAILED) {\n                if (input.substr(peg$currPos, 11).toLowerCase() === peg$c106) {\n                  s2 = input.substr(peg$currPos, 11);\n                  peg$currPos += 11;\n                } else {\n                  s2 = peg$FAILED;\n                  {\n                    peg$fail(peg$c107);\n                  }\n                }\n\n                if (s2 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 8).toLowerCase() === peg$c108) {\n                    s2 = input.substr(peg$currPos, 8);\n                    peg$currPos += 8;\n                  } else {\n                    s2 = peg$FAILED;\n                    {\n                      peg$fail(peg$c109);\n                    }\n                  }\n\n                  if (s2 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c110) {\n                      s2 = input.substr(peg$currPos, 7);\n                      peg$currPos += 7;\n                    } else {\n                      s2 = peg$FAILED;\n                      {\n                        peg$fail(peg$c111);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c112(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function nth(n) {\n          return {\n            type: 'nth-child',\n            index: {\n              type: 'literal',\n              value: n\n            }\n          };\n        }\n\n        function nthLast(n) {\n          return {\n            type: 'nth-last-child',\n            index: {\n              type: 'literal',\n              value: n\n            }\n          };\n        }\n\n        function strUnescape(s) {\n          return s.replace(/\\\\(.)/g, function (match, ch) {\n            switch (ch) {\n              case 'b':\n                return '\\b';\n\n              case 'f':\n                return '\\f';\n\n              case 'n':\n                return '\\n';\n\n              case 'r':\n                return '\\r';\n\n              case 't':\n                return '\\t';\n\n              case 'v':\n                return '\\v';\n\n              default:\n                return ch;\n            }\n          });\n        }\n\n        peg$result = peg$startRuleFunction();\n\n        if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n          return peg$result;\n        } else {\n          if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n            peg$fail(peg$endExpectation());\n          }\n\n          throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n        }\n      }\n\n      return {\n        SyntaxError: peg$SyntaxError,\n        parse: peg$parse\n      };\n    });\n  });\n\n  function _objectEntries(obj) {\n    var entries = [];\n    var keys = Object.keys(obj);\n\n    for (var k = 0; k < keys.length; k++) entries.push([keys[k], obj[keys[k]]]);\n\n    return entries;\n  }\n  /**\n  * @typedef {\"LEFT_SIDE\"|\"RIGHT_SIDE\"} Side\n  */\n\n\n  var LEFT_SIDE = 'LEFT_SIDE';\n  var RIGHT_SIDE = 'RIGHT_SIDE';\n  /**\n   * @external AST\n   * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html\n   */\n\n  /**\n   * One of the rules of `grammar.pegjs`\n   * @typedef {PlainObject} SelectorAST\n   * @see grammar.pegjs\n  */\n\n  /**\n   * The `sequence` production of `grammar.pegjs`\n   * @typedef {PlainObject} SelectorSequenceAST\n  */\n\n  /**\n   * Get the value of a property which may be multiple levels down\n   * in the object.\n   * @param {?PlainObject} obj\n   * @param {string} key\n   * @returns {undefined|boolean|string|number|external:AST}\n   */\n\n  function getPath(obj, key) {\n    var keys = key.split('.');\n\n    var _iterator = _createForOfIteratorHelper(keys),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _key = _step.value;\n\n        if (obj == null) {\n          return obj;\n        }\n\n        obj = obj[_key];\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return obj;\n  }\n  /**\n   * Determine whether `node` can be reached by following `path`,\n   * starting at `ancestor`.\n   * @param {?external:AST} node\n   * @param {?external:AST} ancestor\n   * @param {string[]} path\n   * @returns {boolean}\n   */\n\n\n  function inPath(node, ancestor, path) {\n    if (path.length === 0) {\n      return node === ancestor;\n    }\n\n    if (ancestor == null) {\n      return false;\n    }\n\n    var field = ancestor[path[0]];\n    var remainingPath = path.slice(1);\n\n    if (Array.isArray(field)) {\n      var _iterator2 = _createForOfIteratorHelper(field),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var component = _step2.value;\n\n          if (inPath(node, component, remainingPath)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return false;\n    } else {\n      return inPath(node, field, remainingPath);\n    }\n  }\n  /**\n   * @callback TraverseOptionFallback\n   * @param {external:AST} node The given node.\n   * @returns {string[]} An array of visitor keys for the given node.\n   */\n\n  /**\n   * @typedef {object} ESQueryOptions\n   * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.\n   * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.\n   */\n\n  /**\n   * Given a `node` and its ancestors, determine if `node` is matched\n   * by `selector`.\n   * @param {?external:AST} node\n   * @param {?SelectorAST} selector\n   * @param {external:AST[]} [ancestry=[]]\n   * @param {ESQueryOptions} [options]\n   * @throws {Error} Unknowns (operator, class name, selector type, or\n   * selector value type)\n   * @returns {boolean}\n   */\n\n\n  function matches(node, selector, ancestry, options) {\n    if (!selector) {\n      return true;\n    }\n\n    if (!node) {\n      return false;\n    }\n\n    if (!ancestry) {\n      ancestry = [];\n    }\n\n    switch (selector.type) {\n      case 'wildcard':\n        return true;\n\n      case 'identifier':\n        return selector.value.toLowerCase() === node.type.toLowerCase();\n\n      case 'field':\n        {\n          var path = selector.name.split('.');\n          var ancestor = ancestry[path.length - 1];\n          return inPath(node, ancestor, path);\n        }\n\n      case 'matches':\n        var _iterator3 = _createForOfIteratorHelper(selector.selectors),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var sel = _step3.value;\n\n            if (matches(node, sel, ancestry, options)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        return false;\n\n      case 'compound':\n        var _iterator4 = _createForOfIteratorHelper(selector.selectors),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _sel = _step4.value;\n\n            if (!matches(node, _sel, ancestry, options)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        return true;\n\n      case 'not':\n        var _iterator5 = _createForOfIteratorHelper(selector.selectors),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _sel2 = _step5.value;\n\n            if (matches(node, _sel2, ancestry, options)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        return true;\n\n      case 'has':\n        {\n          var _ret = function () {\n            var collector = [];\n\n            var _iterator6 = _createForOfIteratorHelper(selector.selectors),\n                _step6;\n\n            try {\n              var _loop = function _loop() {\n                var sel = _step6.value;\n                var a = [];\n                estraverse.traverse(node, {\n                  enter: function enter(node, parent) {\n                    if (parent != null) {\n                      a.unshift(parent);\n                    }\n\n                    if (matches(node, sel, a, options)) {\n                      collector.push(node);\n                    }\n                  },\n                  leave: function leave() {\n                    a.shift();\n                  },\n                  keys: options && options.visitorKeys,\n                  fallback: options && options.fallback || 'iteration'\n                });\n              };\n\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                _loop();\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n\n            return {\n              v: collector.length !== 0\n            };\n          }();\n\n          if (_typeof(_ret) === \"object\") return _ret.v;\n        }\n\n      case 'child':\n        if (matches(node, selector.right, ancestry, options)) {\n          return matches(ancestry[0], selector.left, ancestry.slice(1), options);\n        }\n\n        return false;\n\n      case 'descendant':\n        if (matches(node, selector.right, ancestry, options)) {\n          for (var i = 0, l = ancestry.length; i < l; ++i) {\n            if (matches(ancestry[i], selector.left, ancestry.slice(i + 1), options)) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n\n      case 'attribute':\n        {\n          var p = getPath(node, selector.name);\n\n          switch (selector.operator) {\n            case void 0:\n              return p != null;\n\n            case '=':\n              switch (selector.value.type) {\n                case 'regexp':\n                  return typeof p === 'string' && selector.value.value.test(p);\n\n                case 'literal':\n                  return \"\".concat(selector.value.value) === \"\".concat(p);\n\n                case 'type':\n                  return selector.value.value === _typeof(p);\n              }\n\n              throw new Error(\"Unknown selector value type: \".concat(selector.value.type));\n\n            case '!=':\n              switch (selector.value.type) {\n                case 'regexp':\n                  return !selector.value.value.test(p);\n\n                case 'literal':\n                  return \"\".concat(selector.value.value) !== \"\".concat(p);\n\n                case 'type':\n                  return selector.value.value !== _typeof(p);\n              }\n\n              throw new Error(\"Unknown selector value type: \".concat(selector.value.type));\n\n            case '<=':\n              return p <= selector.value.value;\n\n            case '<':\n              return p < selector.value.value;\n\n            case '>':\n              return p > selector.value.value;\n\n            case '>=':\n              return p >= selector.value.value;\n          }\n\n          throw new Error(\"Unknown operator: \".concat(selector.operator));\n        }\n\n      case 'sibling':\n        return matches(node, selector.right, ancestry, options) && sibling(node, selector.left, ancestry, LEFT_SIDE, options) || selector.left.subject && matches(node, selector.left, ancestry, options) && sibling(node, selector.right, ancestry, RIGHT_SIDE, options);\n\n      case 'adjacent':\n        return matches(node, selector.right, ancestry, options) && adjacent(node, selector.left, ancestry, LEFT_SIDE, options) || selector.right.subject && matches(node, selector.left, ancestry, options) && adjacent(node, selector.right, ancestry, RIGHT_SIDE, options);\n\n      case 'nth-child':\n        return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function () {\n          return selector.index.value - 1;\n        }, options);\n\n      case 'nth-last-child':\n        return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function (length) {\n          return length - selector.index.value;\n        }, options);\n\n      case 'class':\n        switch (selector.name.toLowerCase()) {\n          case 'statement':\n            if (node.type.slice(-9) === 'Statement') return true;\n          // fallthrough: interface Declaration <: Statement { }\n\n          case 'declaration':\n            return node.type.slice(-11) === 'Declaration';\n\n          case 'pattern':\n            if (node.type.slice(-7) === 'Pattern') return true;\n          // fallthrough: interface Expression <: Node, Pattern { }\n\n          case 'expression':\n            return node.type.slice(-10) === 'Expression' || node.type.slice(-7) === 'Literal' || node.type === 'Identifier' && (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty') || node.type === 'MetaProperty';\n\n          case 'function':\n            return node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';\n        }\n\n        throw new Error(\"Unknown class name: \".concat(selector.name));\n    }\n\n    throw new Error(\"Unknown selector type: \".concat(selector.type));\n  }\n  /**\n   * Get visitor keys of a given node.\n   * @param {external:AST} node The AST node to get keys.\n   * @param {ESQueryOptions|undefined} options\n   * @returns {string[]} Visitor keys of the node.\n   */\n\n\n  function getVisitorKeys(node, options) {\n    var nodeType = node.type;\n\n    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {\n      return options.visitorKeys[nodeType];\n    }\n\n    if (estraverse.VisitorKeys[nodeType]) {\n      return estraverse.VisitorKeys[nodeType];\n    }\n\n    if (options && typeof options.fallback === 'function') {\n      return options.fallback(node);\n    } // 'iteration' fallback\n\n\n    return Object.keys(node).filter(function (key) {\n      return key !== 'type';\n    });\n  }\n  /**\n   * Check whether the given value is an ASTNode or not.\n   * @param {any} node The value to check.\n   * @returns {boolean} `true` if the value is an ASTNode.\n   */\n\n\n  function isNode(node) {\n    return node !== null && _typeof(node) === 'object' && typeof node.type === 'string';\n  }\n  /**\n   * Determines if the given node has a sibling that matches the\n   * given selector.\n   * @param {external:AST} node\n   * @param {SelectorSequenceAST} selector\n   * @param {external:AST[]} ancestry\n   * @param {Side} side\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n\n\n  function sibling(node, selector, ancestry, side, options) {\n    var _ancestry = _slicedToArray(ancestry, 1),\n        parent = _ancestry[0];\n\n    if (!parent) {\n      return false;\n    }\n\n    var keys = getVisitorKeys(parent, options);\n\n    var _iterator7 = _createForOfIteratorHelper(keys),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var key = _step7.value;\n        var listProp = parent[key];\n\n        if (Array.isArray(listProp)) {\n          var startIndex = listProp.indexOf(node);\n\n          if (startIndex < 0) {\n            continue;\n          }\n\n          var lowerBound = void 0,\n              upperBound = void 0;\n\n          if (side === LEFT_SIDE) {\n            lowerBound = 0;\n            upperBound = startIndex;\n          } else {\n            lowerBound = startIndex + 1;\n            upperBound = listProp.length;\n          }\n\n          for (var k = lowerBound; k < upperBound; ++k) {\n            if (isNode(listProp[k]) && matches(listProp[k], selector, ancestry, options)) {\n              return true;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    return false;\n  }\n  /**\n   * Determines if the given node has an adjacent sibling that matches\n   * the given selector.\n   * @param {external:AST} node\n   * @param {SelectorSequenceAST} selector\n   * @param {external:AST[]} ancestry\n   * @param {Side} side\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n\n\n  function adjacent(node, selector, ancestry, side, options) {\n    var _ancestry2 = _slicedToArray(ancestry, 1),\n        parent = _ancestry2[0];\n\n    if (!parent) {\n      return false;\n    }\n\n    var keys = getVisitorKeys(parent, options);\n\n    var _iterator8 = _createForOfIteratorHelper(keys),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var key = _step8.value;\n        var listProp = parent[key];\n\n        if (Array.isArray(listProp)) {\n          var idx = listProp.indexOf(node);\n\n          if (idx < 0) {\n            continue;\n          }\n\n          if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1]) && matches(listProp[idx - 1], selector, ancestry, options)) {\n            return true;\n          }\n\n          if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1]) && matches(listProp[idx + 1], selector, ancestry, options)) {\n            return true;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n\n    return false;\n  }\n  /**\n  * @callback IndexFunction\n  * @param {Integer} len Containing list's length\n  * @returns {Integer}\n  */\n\n  /**\n   * Determines if the given node is the nth child, determined by\n   * `idxFn`, which is given the containing list's length.\n   * @param {external:AST} node\n   * @param {external:AST[]} ancestry\n   * @param {IndexFunction} idxFn\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n\n\n  function nthChild(node, ancestry, idxFn, options) {\n    var _ancestry3 = _slicedToArray(ancestry, 1),\n        parent = _ancestry3[0];\n\n    if (!parent) {\n      return false;\n    }\n\n    var keys = getVisitorKeys(parent, options);\n\n    var _iterator9 = _createForOfIteratorHelper(keys),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var key = _step9.value;\n        var listProp = parent[key];\n\n        if (Array.isArray(listProp)) {\n          var idx = listProp.indexOf(node);\n\n          if (idx >= 0 && idx === idxFn(listProp.length)) {\n            return true;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    return false;\n  }\n  /**\n   * For each selector node marked as a subject, find the portion of the\n   * selector that the subject must match.\n   * @param {SelectorAST} selector\n   * @param {SelectorAST} [ancestor] Defaults to `selector`\n   * @returns {SelectorAST[]}\n   */\n\n\n  function subjects(selector, ancestor) {\n    if (selector == null || _typeof(selector) != 'object') {\n      return [];\n    }\n\n    if (ancestor == null) {\n      ancestor = selector;\n    }\n\n    var results = selector.subject ? [ancestor] : [];\n\n    for (var _i = 0, _Object$entries = _objectEntries(selector); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          p = _Object$entries$_i[0],\n          sel = _Object$entries$_i[1];\n\n      results.push.apply(results, _toConsumableArray(subjects(sel, p === 'left' ? sel : ancestor)));\n    }\n\n    return results;\n  }\n  /**\n  * @callback TraverseVisitor\n  * @param {?external:AST} node\n  * @param {?external:AST} parent\n  * @param {external:AST[]} ancestry\n  */\n\n  /**\n   * From a JS AST and a selector AST, collect all JS AST nodes that\n   * match the selector.\n   * @param {external:AST} ast\n   * @param {?SelectorAST} selector\n   * @param {TraverseVisitor} visitor\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n\n\n  function traverse(ast, selector, visitor, options) {\n    if (!selector) {\n      return;\n    }\n\n    var ancestry = [];\n    var altSubjects = subjects(selector);\n    estraverse.traverse(ast, {\n      enter: function enter(node, parent) {\n        if (parent != null) {\n          ancestry.unshift(parent);\n        }\n\n        if (matches(node, selector, ancestry, options)) {\n          if (altSubjects.length) {\n            for (var i = 0, l = altSubjects.length; i < l; ++i) {\n              if (matches(node, altSubjects[i], ancestry, options)) {\n                visitor(node, parent, ancestry);\n              }\n\n              for (var k = 0, m = ancestry.length; k < m; ++k) {\n                var succeedingAncestry = ancestry.slice(k + 1);\n\n                if (matches(ancestry[k], altSubjects[i], succeedingAncestry, options)) {\n                  visitor(ancestry[k], parent, succeedingAncestry);\n                }\n              }\n            }\n          } else {\n            visitor(node, parent, ancestry);\n          }\n        }\n      },\n      leave: function leave() {\n        ancestry.shift();\n      },\n      keys: options && options.visitorKeys,\n      fallback: options && options.fallback || 'iteration'\n    });\n  }\n  /**\n   * From a JS AST and a selector AST, collect all JS AST nodes that\n   * match the selector.\n   * @param {external:AST} ast\n   * @param {?SelectorAST} selector\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n\n\n  function match(ast, selector, options) {\n    var results = [];\n    traverse(ast, selector, function (node) {\n      results.push(node);\n    }, options);\n    return results;\n  }\n  /**\n   * Parse a selector string and return its AST.\n   * @param {string} selector\n   * @returns {SelectorAST}\n   */\n\n\n  function parse(selector) {\n    return parser.parse(selector);\n  }\n  /**\n   * Query the code AST using the selector string.\n   * @param {external:AST} ast\n   * @param {string} selector\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n\n\n  function query(ast, selector, options) {\n    return match(ast, parse(selector), options);\n  }\n\n  query.parse = parse;\n  query.match = match;\n  query.traverse = traverse;\n  query.matches = matches;\n  query.query = query;\n  return query;\n});","map":{"version":3,"names":["global","factory","exports","module","require","define","amd","self","esquery","estraverse","Object","prototype","hasOwnProperty","call","_typeof","obj","Symbol","iterator","constructor","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","from","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","o","minLen","n","toString","slice","name","test","len","arr2","TypeError","_createForOfIteratorHelper","allowArrayLike","it","F","s","e","f","normalCompletion","didErr","step","return","commonjsGlobal","globalThis","window","createCommonjsModule","fn","parser","root","peg$subclass","child","parent","ctor","peg$SyntaxError","message","expected","found","location","Error","captureStackTrace","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","_class","escapedParts","parts","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toUpperCase","replace","describeExpectation","type","describeExpected","descriptions","j","sort","join","describeFound","peg$parse","input","options","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c0","ss","selectors","peg$c1","peg$c2","peg$c3","peg$literalExpectation","peg$c4","peg$c5","peg$classExpectation","peg$c6","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","concat","map","peg$c20","a","ops","reduce","memo","rhs","left","right","peg$c21","peg$c22","peg$c23","subject","as","b","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","v","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","apply","peg$c45","op","operator","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$anyExpectation","peg$c54","peg$c55","d","strUnescape","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","leadingDecimals","parseFloat","peg$c63","peg$c64","peg$c65","peg$c66","peg$c67","peg$c68","peg$c69","peg$c70","t","peg$c71","peg$c72","peg$c73","peg$c74","peg$c75","peg$c76","peg$c77","flgs","RegExp","peg$c78","is","p","peg$c79","peg$c80","peg$c81","peg$c82","peg$c83","peg$c84","peg$c85","peg$c86","peg$c87","peg$c88","peg$c89","peg$c90","nth","peg$c91","peg$c92","peg$c93","nthLast","peg$c94","peg$c95","peg$c96","parseInt","peg$c97","peg$c98","peg$c99","peg$c100","peg$c101","peg$c102","peg$c103","peg$c104","peg$c105","peg$c106","peg$c107","peg$c108","peg$c109","peg$c110","peg$c111","peg$c112","c","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$resultsCache","peg$result","startRule","ignoreCase","peg$endExpectation","peg$computePosDetails","pos","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","offset","peg$fail","peg$buildStructuredError","s0","s1","s2","s3","key","cached","nextPos","result","peg$parse_","peg$parseselectors","peg$parseidentifierName","charAt","peg$parsebinaryOp","s4","s5","s6","s7","peg$parseselector","peg$parsesequence","peg$parseatom","peg$parsewildcard","peg$parseidentifier","peg$parseattr","peg$parsefield","peg$parsenegation","peg$parsematches","peg$parsehas","peg$parsefirstChild","peg$parselastChild","peg$parsenthChild","peg$parsenthLastChild","peg$parseclass","peg$parseattrValue","peg$parseattrOps","peg$parseattrEqOps","peg$parseattrName","peg$parsetype","peg$parseregex","peg$parsestring","peg$parsenumber","peg$parsepath","substr","peg$parseflags","toLowerCase","index","match","SyntaxError","parse","_objectEntries","entries","keys","k","LEFT_SIDE","RIGHT_SIDE","getPath","split","_iterator","_step","_key","inPath","node","ancestor","path","field","remainingPath","_iterator2","_step2","component","matches","selector","ancestry","_iterator3","_step3","sel","_iterator4","_step4","_sel","_iterator5","_step5","_sel2","_ret","collector","_iterator6","_step6","_loop","traverse","enter","unshift","leave","shift","visitorKeys","fallback","l","sibling","adjacent","nthChild","getVisitorKeys","nodeType","VisitorKeys","filter","isNode","side","_ancestry","_iterator7","_step7","listProp","startIndex","indexOf","lowerBound","upperBound","_ancestry2","_iterator8","_step8","idx","idxFn","_ancestry3","_iterator9","_step9","subjects","results","_Object$entries","_Object$entries$_i","ast","visitor","altSubjects","m","succeedingAncestry","query"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/esquery/dist/esquery.lite.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('estraverse')) :\n  typeof define === 'function' && define.amd ? define(['estraverse'], factory) :\n  (global = global || self, global.esquery = factory(global.estraverse));\n}(this, (function (estraverse) { 'use strict';\n\n  estraverse = estraverse && Object.prototype.hasOwnProperty.call(estraverse, 'default') ? estraverse['default'] : estraverse;\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n\n        var F = function () {};\n\n        return {\n          s: F,\n          n: function () {\n            if (i >= o.length) return {\n              done: true\n            };\n            return {\n              done: false,\n              value: o[i++]\n            };\n          },\n          e: function (e) {\n            throw e;\n          },\n          f: F\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true,\n        didErr = false,\n        err;\n    return {\n      s: function () {\n        it = o[Symbol.iterator]();\n      },\n      n: function () {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function (e) {\n        didErr = true;\n        err = e;\n      },\n      f: function () {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var parser = createCommonjsModule(function (module) {\n    /*\n     * Generated by PEG.js 0.10.0.\n     *\n     * http://pegjs.org/\n     */\n    (function (root, factory) {\n      if ( module.exports) {\n        module.exports = factory();\n      }\n    })(commonjsGlobal, function () {\n\n      function peg$subclass(child, parent) {\n        function ctor() {\n          this.constructor = child;\n        }\n\n        ctor.prototype = parent.prototype;\n        child.prototype = new ctor();\n      }\n\n      function peg$SyntaxError(message, expected, found, location) {\n        this.message = message;\n        this.expected = expected;\n        this.found = found;\n        this.location = location;\n        this.name = \"SyntaxError\";\n\n        if (typeof Error.captureStackTrace === \"function\") {\n          Error.captureStackTrace(this, peg$SyntaxError);\n        }\n      }\n\n      peg$subclass(peg$SyntaxError, Error);\n\n      peg$SyntaxError.buildMessage = function (expected, found) {\n        var DESCRIBE_EXPECTATION_FNS = {\n          literal: function literal(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n          \"class\": function _class(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n          any: function any(expectation) {\n            return \"any character\";\n          },\n          end: function end(expectation) {\n            return \"end of input\";\n          },\n          other: function other(expectation) {\n            return expectation.description;\n          }\n        };\n\n        function hex(ch) {\n          return ch.charCodeAt(0).toString(16).toUpperCase();\n        }\n\n        function literalEscape(s) {\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          });\n        }\n\n        function classEscape(s) {\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\\]/g, '\\\\]').replace(/\\^/g, '\\\\^').replace(/-/g, '\\\\-').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          });\n        }\n\n        function describeExpectation(expectation) {\n          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n        }\n\n        function describeExpected(expected) {\n          var descriptions = new Array(expected.length),\n              i,\n              j;\n\n          for (i = 0; i < expected.length; i++) {\n            descriptions[i] = describeExpectation(expected[i]);\n          }\n\n          descriptions.sort();\n\n          if (descriptions.length > 0) {\n            for (i = 1, j = 1; i < descriptions.length; i++) {\n              if (descriptions[i - 1] !== descriptions[i]) {\n                descriptions[j] = descriptions[i];\n                j++;\n              }\n            }\n\n            descriptions.length = j;\n          }\n\n          switch (descriptions.length) {\n            case 1:\n              return descriptions[0];\n\n            case 2:\n              return descriptions[0] + \" or \" + descriptions[1];\n\n            default:\n              return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n          }\n        }\n\n        function describeFound(found) {\n          return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n        }\n\n        return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n      };\n\n      function peg$parse(input, options) {\n        options = options !== void 0 ? options : {};\n\n        var peg$FAILED = {},\n            peg$startRuleFunctions = {\n          start: peg$parsestart\n        },\n            peg$startRuleFunction = peg$parsestart,\n            peg$c0 = function peg$c0(ss) {\n          return ss.length === 1 ? ss[0] : {\n            type: 'matches',\n            selectors: ss\n          };\n        },\n            peg$c1 = function peg$c1() {\n          return void 0;\n        },\n            peg$c2 = \" \",\n            peg$c3 = peg$literalExpectation(\" \", false),\n            peg$c4 = /^[^ [\\],():#!=><~+.]/,\n            peg$c5 = peg$classExpectation([\" \", \"[\", \"]\", \",\", \"(\", \")\", \":\", \"#\", \"!\", \"=\", \">\", \"<\", \"~\", \"+\", \".\"], true, false),\n            peg$c6 = function peg$c6(i) {\n          return i.join('');\n        },\n            peg$c7 = \">\",\n            peg$c8 = peg$literalExpectation(\">\", false),\n            peg$c9 = function peg$c9() {\n          return 'child';\n        },\n            peg$c10 = \"~\",\n            peg$c11 = peg$literalExpectation(\"~\", false),\n            peg$c12 = function peg$c12() {\n          return 'sibling';\n        },\n            peg$c13 = \"+\",\n            peg$c14 = peg$literalExpectation(\"+\", false),\n            peg$c15 = function peg$c15() {\n          return 'adjacent';\n        },\n            peg$c16 = function peg$c16() {\n          return 'descendant';\n        },\n            peg$c17 = \",\",\n            peg$c18 = peg$literalExpectation(\",\", false),\n            peg$c19 = function peg$c19(s, ss) {\n          return [s].concat(ss.map(function (s) {\n            return s[3];\n          }));\n        },\n            peg$c20 = function peg$c20(a, ops) {\n          return ops.reduce(function (memo, rhs) {\n            return {\n              type: rhs[0],\n              left: memo,\n              right: rhs[1]\n            };\n          }, a);\n        },\n            peg$c21 = \"!\",\n            peg$c22 = peg$literalExpectation(\"!\", false),\n            peg$c23 = function peg$c23(subject, as) {\n          var b = as.length === 1 ? as[0] : {\n            type: 'compound',\n            selectors: as\n          };\n          if (subject) b.subject = true;\n          return b;\n        },\n            peg$c24 = \"*\",\n            peg$c25 = peg$literalExpectation(\"*\", false),\n            peg$c26 = function peg$c26(a) {\n          return {\n            type: 'wildcard',\n            value: a\n          };\n        },\n            peg$c27 = \"#\",\n            peg$c28 = peg$literalExpectation(\"#\", false),\n            peg$c29 = function peg$c29(i) {\n          return {\n            type: 'identifier',\n            value: i\n          };\n        },\n            peg$c30 = \"[\",\n            peg$c31 = peg$literalExpectation(\"[\", false),\n            peg$c32 = \"]\",\n            peg$c33 = peg$literalExpectation(\"]\", false),\n            peg$c34 = function peg$c34(v) {\n          return v;\n        },\n            peg$c35 = /^[><!]/,\n            peg$c36 = peg$classExpectation([\">\", \"<\", \"!\"], false, false),\n            peg$c37 = \"=\",\n            peg$c38 = peg$literalExpectation(\"=\", false),\n            peg$c39 = function peg$c39(a) {\n          return (a || '') + '=';\n        },\n            peg$c40 = /^[><]/,\n            peg$c41 = peg$classExpectation([\">\", \"<\"], false, false),\n            peg$c42 = \".\",\n            peg$c43 = peg$literalExpectation(\".\", false),\n            peg$c44 = function peg$c44(a, as) {\n          return [].concat.apply([a], as).join('');\n        },\n            peg$c45 = function peg$c45(name, op, value) {\n          return {\n            type: 'attribute',\n            name: name,\n            operator: op,\n            value: value\n          };\n        },\n            peg$c46 = function peg$c46(name) {\n          return {\n            type: 'attribute',\n            name: name\n          };\n        },\n            peg$c47 = \"\\\"\",\n            peg$c48 = peg$literalExpectation(\"\\\"\", false),\n            peg$c49 = /^[^\\\\\"]/,\n            peg$c50 = peg$classExpectation([\"\\\\\", \"\\\"\"], true, false),\n            peg$c51 = \"\\\\\",\n            peg$c52 = peg$literalExpectation(\"\\\\\", false),\n            peg$c53 = peg$anyExpectation(),\n            peg$c54 = function peg$c54(a, b) {\n          return a + b;\n        },\n            peg$c55 = function peg$c55(d) {\n          return {\n            type: 'literal',\n            value: strUnescape(d.join(''))\n          };\n        },\n            peg$c56 = \"'\",\n            peg$c57 = peg$literalExpectation(\"'\", false),\n            peg$c58 = /^[^\\\\']/,\n            peg$c59 = peg$classExpectation([\"\\\\\", \"'\"], true, false),\n            peg$c60 = /^[0-9]/,\n            peg$c61 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n            peg$c62 = function peg$c62(a, b) {\n          // Can use `a.flat().join('')` once supported\n          var leadingDecimals = a ? [].concat.apply([], a).join('') : '';\n          return {\n            type: 'literal',\n            value: parseFloat(leadingDecimals + b.join(''))\n          };\n        },\n            peg$c63 = function peg$c63(i) {\n          return {\n            type: 'literal',\n            value: i\n          };\n        },\n            peg$c64 = \"type(\",\n            peg$c65 = peg$literalExpectation(\"type(\", false),\n            peg$c66 = /^[^ )]/,\n            peg$c67 = peg$classExpectation([\" \", \")\"], true, false),\n            peg$c68 = \")\",\n            peg$c69 = peg$literalExpectation(\")\", false),\n            peg$c70 = function peg$c70(t) {\n          return {\n            type: 'type',\n            value: t.join('')\n          };\n        },\n            peg$c71 = /^[imsu]/,\n            peg$c72 = peg$classExpectation([\"i\", \"m\", \"s\", \"u\"], false, false),\n            peg$c73 = \"/\",\n            peg$c74 = peg$literalExpectation(\"/\", false),\n            peg$c75 = /^[^\\/]/,\n            peg$c76 = peg$classExpectation([\"/\"], true, false),\n            peg$c77 = function peg$c77(d, flgs) {\n          return {\n            type: 'regexp',\n            value: new RegExp(d.join(''), flgs ? flgs.join('') : '')\n          };\n        },\n            peg$c78 = function peg$c78(i, is) {\n          return {\n            type: 'field',\n            name: is.reduce(function (memo, p) {\n              return memo + p[0] + p[1];\n            }, i)\n          };\n        },\n            peg$c79 = \":not(\",\n            peg$c80 = peg$literalExpectation(\":not(\", false),\n            peg$c81 = function peg$c81(ss) {\n          return {\n            type: 'not',\n            selectors: ss\n          };\n        },\n            peg$c82 = \":matches(\",\n            peg$c83 = peg$literalExpectation(\":matches(\", false),\n            peg$c84 = function peg$c84(ss) {\n          return {\n            type: 'matches',\n            selectors: ss\n          };\n        },\n            peg$c85 = \":has(\",\n            peg$c86 = peg$literalExpectation(\":has(\", false),\n            peg$c87 = function peg$c87(ss) {\n          return {\n            type: 'has',\n            selectors: ss\n          };\n        },\n            peg$c88 = \":first-child\",\n            peg$c89 = peg$literalExpectation(\":first-child\", false),\n            peg$c90 = function peg$c90() {\n          return nth(1);\n        },\n            peg$c91 = \":last-child\",\n            peg$c92 = peg$literalExpectation(\":last-child\", false),\n            peg$c93 = function peg$c93() {\n          return nthLast(1);\n        },\n            peg$c94 = \":nth-child(\",\n            peg$c95 = peg$literalExpectation(\":nth-child(\", false),\n            peg$c96 = function peg$c96(n) {\n          return nth(parseInt(n.join(''), 10));\n        },\n            peg$c97 = \":nth-last-child(\",\n            peg$c98 = peg$literalExpectation(\":nth-last-child(\", false),\n            peg$c99 = function peg$c99(n) {\n          return nthLast(parseInt(n.join(''), 10));\n        },\n            peg$c100 = \":\",\n            peg$c101 = peg$literalExpectation(\":\", false),\n            peg$c102 = \"statement\",\n            peg$c103 = peg$literalExpectation(\"statement\", true),\n            peg$c104 = \"expression\",\n            peg$c105 = peg$literalExpectation(\"expression\", true),\n            peg$c106 = \"declaration\",\n            peg$c107 = peg$literalExpectation(\"declaration\", true),\n            peg$c108 = \"function\",\n            peg$c109 = peg$literalExpectation(\"function\", true),\n            peg$c110 = \"pattern\",\n            peg$c111 = peg$literalExpectation(\"pattern\", true),\n            peg$c112 = function peg$c112(c) {\n          return {\n            type: 'class',\n            name: c\n          };\n        },\n            peg$currPos = 0,\n            peg$posDetailsCache = [{\n          line: 1,\n          column: 1\n        }],\n            peg$maxFailPos = 0,\n            peg$maxFailExpected = [],\n            peg$resultsCache = {},\n            peg$result;\n\n        if (\"startRule\" in options) {\n          if (!(options.startRule in peg$startRuleFunctions)) {\n            throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n          }\n\n          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n        }\n\n        function peg$literalExpectation(text, ignoreCase) {\n          return {\n            type: \"literal\",\n            text: text,\n            ignoreCase: ignoreCase\n          };\n        }\n\n        function peg$classExpectation(parts, inverted, ignoreCase) {\n          return {\n            type: \"class\",\n            parts: parts,\n            inverted: inverted,\n            ignoreCase: ignoreCase\n          };\n        }\n\n        function peg$anyExpectation() {\n          return {\n            type: \"any\"\n          };\n        }\n\n        function peg$endExpectation() {\n          return {\n            type: \"end\"\n          };\n        }\n\n        function peg$computePosDetails(pos) {\n          var details = peg$posDetailsCache[pos],\n              p;\n\n          if (details) {\n            return details;\n          } else {\n            p = pos - 1;\n\n            while (!peg$posDetailsCache[p]) {\n              p--;\n            }\n\n            details = peg$posDetailsCache[p];\n            details = {\n              line: details.line,\n              column: details.column\n            };\n\n            while (p < pos) {\n              if (input.charCodeAt(p) === 10) {\n                details.line++;\n                details.column = 1;\n              } else {\n                details.column++;\n              }\n\n              p++;\n            }\n\n            peg$posDetailsCache[pos] = details;\n            return details;\n          }\n        }\n\n        function peg$computeLocation(startPos, endPos) {\n          var startPosDetails = peg$computePosDetails(startPos),\n              endPosDetails = peg$computePosDetails(endPos);\n          return {\n            start: {\n              offset: startPos,\n              line: startPosDetails.line,\n              column: startPosDetails.column\n            },\n            end: {\n              offset: endPos,\n              line: endPosDetails.line,\n              column: endPosDetails.column\n            }\n          };\n        }\n\n        function peg$fail(expected) {\n          if (peg$currPos < peg$maxFailPos) {\n            return;\n          }\n\n          if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n          }\n\n          peg$maxFailExpected.push(expected);\n        }\n\n        function peg$buildStructuredError(expected, found, location) {\n          return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n        }\n\n        function peg$parsestart() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 0,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseselectors();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c0(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n\n            if (s1 !== peg$FAILED) {\n              s1 = peg$c1();\n            }\n\n            s0 = s1;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parse_() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 1,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = [];\n\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s1 = peg$c2;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c3);\n            }\n          }\n\n          while (s1 !== peg$FAILED) {\n            s0.push(s1);\n\n            if (input.charCodeAt(peg$currPos) === 32) {\n              s1 = peg$c2;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n\n              {\n                peg$fail(peg$c3);\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseidentifierName() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 2,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = [];\n\n          if (peg$c4.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n\n            {\n              peg$fail(peg$c5);\n            }\n          }\n\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n\n              if (peg$c4.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c5);\n                }\n              }\n            }\n          } else {\n            s1 = peg$FAILED;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c6(s1);\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsebinaryOp() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 3,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 62) {\n              s2 = peg$c7;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n\n              {\n                peg$fail(peg$c8);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c9();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n\n            if (s1 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 126) {\n                s2 = peg$c10;\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c11);\n                }\n              }\n\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parse_();\n\n                if (s3 !== peg$FAILED) {\n                  s1 = peg$c12();\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parse_();\n\n              if (s1 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 43) {\n                  s2 = peg$c13;\n                  peg$currPos++;\n                } else {\n                  s2 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c14);\n                  }\n                }\n\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parse_();\n\n                  if (s3 !== peg$FAILED) {\n                    s1 = peg$c15();\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 32) {\n                  s1 = peg$c2;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c3);\n                  }\n                }\n\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parse_();\n\n                  if (s2 !== peg$FAILED) {\n                    s1 = peg$c16();\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseselectors() {\n          var s0, s1, s2, s3, s4, s5, s6, s7;\n          var key = peg$currPos * 30 + 4,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseselector();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$parse_();\n\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c17;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c18);\n                }\n              }\n\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parseselector();\n\n                  if (s7 !== peg$FAILED) {\n                    s4 = [s4, s5, s6, s7];\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$parse_();\n\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s5 = peg$c17;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c18);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse_();\n\n                  if (s6 !== peg$FAILED) {\n                    s7 = peg$parseselector();\n\n                    if (s7 !== peg$FAILED) {\n                      s4 = [s4, s5, s6, s7];\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c19(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseselector() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 5,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parsesequence();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$parsebinaryOp();\n\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsesequence();\n\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$parsebinaryOp();\n\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsesequence();\n\n                if (s5 !== peg$FAILED) {\n                  s4 = [s4, s5];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c20(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsesequence() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 6,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 33) {\n            s1 = peg$c21;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c22);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parseatom();\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parseatom();\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c23(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseatom() {\n          var s0;\n          var key = peg$currPos * 30 + 7,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$parsewildcard();\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseidentifier();\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseattr();\n\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsefield();\n\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsenegation();\n\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsematches();\n\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsehas();\n\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsefirstChild();\n\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parselastChild();\n\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsenthChild();\n\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parsenthLastChild();\n\n                              if (s0 === peg$FAILED) {\n                                s0 = peg$parseclass();\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsewildcard() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 8,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s1 = peg$c24;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c25);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c26(s1);\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseidentifier() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 9,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 35) {\n            s1 = peg$c27;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c28);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseidentifierName();\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c29(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattr() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 10,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s1 = peg$c30;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c31);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseattrValue();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 93) {\n                    s5 = peg$c32;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c33);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c34(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrOps() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 11,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (peg$c35.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c36);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s2 = peg$c37;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n\n              {\n                peg$fail(peg$c38);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c39(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            if (peg$c40.test(input.charAt(peg$currPos))) {\n              s0 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n\n              {\n                peg$fail(peg$c41);\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrEqOps() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 12,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 33) {\n            s1 = peg$c21;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c22);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s2 = peg$c37;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n\n              {\n                peg$fail(peg$c38);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c39(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrName() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 13,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseidentifierName();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s4 = peg$c42;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n\n              {\n                peg$fail(peg$c43);\n              }\n            }\n\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseidentifierName();\n\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s4 = peg$c42;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c43);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parseidentifierName();\n\n                if (s5 !== peg$FAILED) {\n                  s4 = [s4, s5];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c44(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrValue() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 14,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseattrName();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseattrEqOps();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsetype();\n\n                  if (s5 === peg$FAILED) {\n                    s5 = peg$parseregex();\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c45(s1, s3, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseattrName();\n\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parseattrOps();\n\n                if (s3 !== peg$FAILED) {\n                  s4 = peg$parse_();\n\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsestring();\n\n                    if (s5 === peg$FAILED) {\n                      s5 = peg$parsenumber();\n\n                      if (s5 === peg$FAILED) {\n                        s5 = peg$parsepath();\n                      }\n                    }\n\n                    if (s5 !== peg$FAILED) {\n                      s1 = peg$c45(s1, s3, s5);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parseattrName();\n\n              if (s1 !== peg$FAILED) {\n                s1 = peg$c46(s1);\n              }\n\n              s0 = s1;\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsestring() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 15,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s1 = peg$c47;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c48);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n\n            if (peg$c49.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n\n              {\n                peg$fail(peg$c50);\n              }\n            }\n\n            if (s3 === peg$FAILED) {\n              s3 = peg$currPos;\n\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s4 = peg$c51;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c52);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c53);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s4 = peg$c54(s4, s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n\n              if (peg$c49.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c50);\n                }\n              }\n\n              if (s3 === peg$FAILED) {\n                s3 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 92) {\n                  s4 = peg$c51;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c52);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s5 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c53);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s4 = peg$c54(s4, s5);\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 34) {\n                s3 = peg$c47;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c48);\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c55(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n\n            if (input.charCodeAt(peg$currPos) === 39) {\n              s1 = peg$c56;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n\n              {\n                peg$fail(peg$c57);\n              }\n            }\n\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n\n              if (peg$c58.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c59);\n                }\n              }\n\n              if (s3 === peg$FAILED) {\n                s3 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 92) {\n                  s4 = peg$c51;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c52);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s5 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c53);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s4 = peg$c54(s4, s5);\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n\n                if (peg$c58.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c59);\n                  }\n                }\n\n                if (s3 === peg$FAILED) {\n                  s3 = peg$currPos;\n\n                  if (input.charCodeAt(peg$currPos) === 92) {\n                    s4 = peg$c51;\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c52);\n                    }\n                  }\n\n                  if (s4 !== peg$FAILED) {\n                    if (input.length > peg$currPos) {\n                      s5 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s5 = peg$FAILED;\n\n                      {\n                        peg$fail(peg$c53);\n                      }\n                    }\n\n                    if (s5 !== peg$FAILED) {\n                      s4 = peg$c54(s4, s5);\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                }\n              }\n\n              if (s2 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 39) {\n                  s3 = peg$c56;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c57);\n                  }\n                }\n\n                if (s3 !== peg$FAILED) {\n                  s1 = peg$c55(s2);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenumber() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 16,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$currPos;\n          s2 = [];\n\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n\n            {\n              peg$fail(peg$c61);\n            }\n          }\n\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n\n            if (peg$c60.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n\n              {\n                peg$fail(peg$c61);\n              }\n            }\n          }\n\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s3 = peg$c42;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n\n              {\n                peg$fail(peg$c43);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              s2 = [s2, s3];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n\n            if (peg$c60.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n\n              {\n                peg$fail(peg$c61);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n\n                if (peg$c60.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c61);\n                  }\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c62(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsepath() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 17,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseidentifierName();\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c63(s1);\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsetype() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 18,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 5) === peg$c64) {\n            s1 = peg$c64;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c65);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n\n              if (peg$c66.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c67);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n\n                  if (peg$c66.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c67);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c70(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseflags() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 19,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = [];\n\n          if (peg$c71.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c72);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            while (s1 !== peg$FAILED) {\n              s0.push(s1);\n\n              if (peg$c71.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c72);\n                }\n              }\n            }\n          } else {\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseregex() {\n          var s0, s1, s2, s3, s4;\n          var key = peg$currPos * 30 + 20,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s1 = peg$c73;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c74);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n\n            if (peg$c75.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n\n              {\n                peg$fail(peg$c76);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n\n                if (peg$c75.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c76);\n                  }\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 47) {\n                s3 = peg$c73;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c74);\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parseflags();\n\n                if (s4 === peg$FAILED) {\n                  s4 = null;\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s1 = peg$c77(s2, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsefield() {\n          var s0, s1, s2, s3, s4, s5, s6;\n          var key = peg$currPos * 30 + 21,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s1 = peg$c42;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c43);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseidentifierName();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$currPos;\n\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s5 = peg$c42;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c43);\n                }\n              }\n\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseidentifierName();\n\n                if (s6 !== peg$FAILED) {\n                  s5 = [s5, s6];\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 46) {\n                  s5 = peg$c42;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c43);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parseidentifierName();\n\n                  if (s6 !== peg$FAILED) {\n                    s5 = [s5, s6];\n                    s4 = s5;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c78(s2, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenegation() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 22,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 5) === peg$c79) {\n            s1 = peg$c79;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c80);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c81(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsematches() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 23,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 9) === peg$c82) {\n            s1 = peg$c82;\n            peg$currPos += 9;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c83);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c84(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsehas() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 24,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 5) === peg$c85) {\n            s1 = peg$c85;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c86);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c87(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsefirstChild() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 25,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 12) === peg$c88) {\n            s1 = peg$c88;\n            peg$currPos += 12;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c89);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c90();\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parselastChild() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 26,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 11) === peg$c91) {\n            s1 = peg$c91;\n            peg$currPos += 11;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c92);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c93();\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenthChild() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 27,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 11) === peg$c94) {\n            s1 = peg$c94;\n            peg$currPos += 11;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c95);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c61);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n\n                  if (peg$c60.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c61);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c96(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenthLastChild() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 28,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 16) === peg$c97) {\n            s1 = peg$c97;\n            peg$currPos += 16;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c98);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c61);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n\n                  if (peg$c60.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c61);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c99(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseclass() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 29,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s1 = peg$c100;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c101);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c102) {\n              s2 = input.substr(peg$currPos, 9);\n              peg$currPos += 9;\n            } else {\n              s2 = peg$FAILED;\n\n              {\n                peg$fail(peg$c103);\n              }\n            }\n\n            if (s2 === peg$FAILED) {\n              if (input.substr(peg$currPos, 10).toLowerCase() === peg$c104) {\n                s2 = input.substr(peg$currPos, 10);\n                peg$currPos += 10;\n              } else {\n                s2 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c105);\n                }\n              }\n\n              if (s2 === peg$FAILED) {\n                if (input.substr(peg$currPos, 11).toLowerCase() === peg$c106) {\n                  s2 = input.substr(peg$currPos, 11);\n                  peg$currPos += 11;\n                } else {\n                  s2 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c107);\n                  }\n                }\n\n                if (s2 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 8).toLowerCase() === peg$c108) {\n                    s2 = input.substr(peg$currPos, 8);\n                    peg$currPos += 8;\n                  } else {\n                    s2 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c109);\n                    }\n                  }\n\n                  if (s2 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c110) {\n                      s2 = input.substr(peg$currPos, 7);\n                      peg$currPos += 7;\n                    } else {\n                      s2 = peg$FAILED;\n\n                      {\n                        peg$fail(peg$c111);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c112(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function nth(n) {\n          return {\n            type: 'nth-child',\n            index: {\n              type: 'literal',\n              value: n\n            }\n          };\n        }\n\n        function nthLast(n) {\n          return {\n            type: 'nth-last-child',\n            index: {\n              type: 'literal',\n              value: n\n            }\n          };\n        }\n\n        function strUnescape(s) {\n          return s.replace(/\\\\(.)/g, function (match, ch) {\n            switch (ch) {\n              case 'b':\n                return '\\b';\n\n              case 'f':\n                return '\\f';\n\n              case 'n':\n                return '\\n';\n\n              case 'r':\n                return '\\r';\n\n              case 't':\n                return '\\t';\n\n              case 'v':\n                return '\\v';\n\n              default:\n                return ch;\n            }\n          });\n        }\n\n        peg$result = peg$startRuleFunction();\n\n        if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n          return peg$result;\n        } else {\n          if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n            peg$fail(peg$endExpectation());\n          }\n\n          throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n        }\n      }\n\n      return {\n        SyntaxError: peg$SyntaxError,\n        parse: peg$parse\n      };\n    });\n  });\n\n  function _objectEntries(obj) {\n    var entries = [];\n    var keys = Object.keys(obj);\n\n    for (var k = 0; k < keys.length; k++) entries.push([keys[k], obj[keys[k]]]);\n\n    return entries;\n  }\n  /**\n  * @typedef {\"LEFT_SIDE\"|\"RIGHT_SIDE\"} Side\n  */\n\n  var LEFT_SIDE = 'LEFT_SIDE';\n  var RIGHT_SIDE = 'RIGHT_SIDE';\n  /**\n   * @external AST\n   * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html\n   */\n\n  /**\n   * One of the rules of `grammar.pegjs`\n   * @typedef {PlainObject} SelectorAST\n   * @see grammar.pegjs\n  */\n\n  /**\n   * The `sequence` production of `grammar.pegjs`\n   * @typedef {PlainObject} SelectorSequenceAST\n  */\n\n  /**\n   * Get the value of a property which may be multiple levels down\n   * in the object.\n   * @param {?PlainObject} obj\n   * @param {string} key\n   * @returns {undefined|boolean|string|number|external:AST}\n   */\n\n  function getPath(obj, key) {\n    var keys = key.split('.');\n\n    var _iterator = _createForOfIteratorHelper(keys),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _key = _step.value;\n\n        if (obj == null) {\n          return obj;\n        }\n\n        obj = obj[_key];\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return obj;\n  }\n  /**\n   * Determine whether `node` can be reached by following `path`,\n   * starting at `ancestor`.\n   * @param {?external:AST} node\n   * @param {?external:AST} ancestor\n   * @param {string[]} path\n   * @returns {boolean}\n   */\n\n\n  function inPath(node, ancestor, path) {\n    if (path.length === 0) {\n      return node === ancestor;\n    }\n\n    if (ancestor == null) {\n      return false;\n    }\n\n    var field = ancestor[path[0]];\n    var remainingPath = path.slice(1);\n\n    if (Array.isArray(field)) {\n      var _iterator2 = _createForOfIteratorHelper(field),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var component = _step2.value;\n\n          if (inPath(node, component, remainingPath)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return false;\n    } else {\n      return inPath(node, field, remainingPath);\n    }\n  }\n  /**\n   * @callback TraverseOptionFallback\n   * @param {external:AST} node The given node.\n   * @returns {string[]} An array of visitor keys for the given node.\n   */\n\n  /**\n   * @typedef {object} ESQueryOptions\n   * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.\n   * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.\n   */\n\n  /**\n   * Given a `node` and its ancestors, determine if `node` is matched\n   * by `selector`.\n   * @param {?external:AST} node\n   * @param {?SelectorAST} selector\n   * @param {external:AST[]} [ancestry=[]]\n   * @param {ESQueryOptions} [options]\n   * @throws {Error} Unknowns (operator, class name, selector type, or\n   * selector value type)\n   * @returns {boolean}\n   */\n\n\n  function matches(node, selector, ancestry, options) {\n    if (!selector) {\n      return true;\n    }\n\n    if (!node) {\n      return false;\n    }\n\n    if (!ancestry) {\n      ancestry = [];\n    }\n\n    switch (selector.type) {\n      case 'wildcard':\n        return true;\n\n      case 'identifier':\n        return selector.value.toLowerCase() === node.type.toLowerCase();\n\n      case 'field':\n        {\n          var path = selector.name.split('.');\n          var ancestor = ancestry[path.length - 1];\n          return inPath(node, ancestor, path);\n        }\n\n      case 'matches':\n        var _iterator3 = _createForOfIteratorHelper(selector.selectors),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var sel = _step3.value;\n\n            if (matches(node, sel, ancestry, options)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        return false;\n\n      case 'compound':\n        var _iterator4 = _createForOfIteratorHelper(selector.selectors),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _sel = _step4.value;\n\n            if (!matches(node, _sel, ancestry, options)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        return true;\n\n      case 'not':\n        var _iterator5 = _createForOfIteratorHelper(selector.selectors),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _sel2 = _step5.value;\n\n            if (matches(node, _sel2, ancestry, options)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        return true;\n\n      case 'has':\n        {\n          var _ret = function () {\n            var collector = [];\n\n            var _iterator6 = _createForOfIteratorHelper(selector.selectors),\n                _step6;\n\n            try {\n              var _loop = function _loop() {\n                var sel = _step6.value;\n                var a = [];\n                estraverse.traverse(node, {\n                  enter: function enter(node, parent) {\n                    if (parent != null) {\n                      a.unshift(parent);\n                    }\n\n                    if (matches(node, sel, a, options)) {\n                      collector.push(node);\n                    }\n                  },\n                  leave: function leave() {\n                    a.shift();\n                  },\n                  keys: options && options.visitorKeys,\n                  fallback: options && options.fallback || 'iteration'\n                });\n              };\n\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                _loop();\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n\n            return {\n              v: collector.length !== 0\n            };\n          }();\n\n          if (_typeof(_ret) === \"object\") return _ret.v;\n        }\n\n      case 'child':\n        if (matches(node, selector.right, ancestry, options)) {\n          return matches(ancestry[0], selector.left, ancestry.slice(1), options);\n        }\n\n        return false;\n\n      case 'descendant':\n        if (matches(node, selector.right, ancestry, options)) {\n          for (var i = 0, l = ancestry.length; i < l; ++i) {\n            if (matches(ancestry[i], selector.left, ancestry.slice(i + 1), options)) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n\n      case 'attribute':\n        {\n          var p = getPath(node, selector.name);\n\n          switch (selector.operator) {\n            case void 0:\n              return p != null;\n\n            case '=':\n              switch (selector.value.type) {\n                case 'regexp':\n                  return typeof p === 'string' && selector.value.value.test(p);\n\n                case 'literal':\n                  return \"\".concat(selector.value.value) === \"\".concat(p);\n\n                case 'type':\n                  return selector.value.value === _typeof(p);\n              }\n\n              throw new Error(\"Unknown selector value type: \".concat(selector.value.type));\n\n            case '!=':\n              switch (selector.value.type) {\n                case 'regexp':\n                  return !selector.value.value.test(p);\n\n                case 'literal':\n                  return \"\".concat(selector.value.value) !== \"\".concat(p);\n\n                case 'type':\n                  return selector.value.value !== _typeof(p);\n              }\n\n              throw new Error(\"Unknown selector value type: \".concat(selector.value.type));\n\n            case '<=':\n              return p <= selector.value.value;\n\n            case '<':\n              return p < selector.value.value;\n\n            case '>':\n              return p > selector.value.value;\n\n            case '>=':\n              return p >= selector.value.value;\n          }\n\n          throw new Error(\"Unknown operator: \".concat(selector.operator));\n        }\n\n      case 'sibling':\n        return matches(node, selector.right, ancestry, options) && sibling(node, selector.left, ancestry, LEFT_SIDE, options) || selector.left.subject && matches(node, selector.left, ancestry, options) && sibling(node, selector.right, ancestry, RIGHT_SIDE, options);\n\n      case 'adjacent':\n        return matches(node, selector.right, ancestry, options) && adjacent(node, selector.left, ancestry, LEFT_SIDE, options) || selector.right.subject && matches(node, selector.left, ancestry, options) && adjacent(node, selector.right, ancestry, RIGHT_SIDE, options);\n\n      case 'nth-child':\n        return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function () {\n          return selector.index.value - 1;\n        }, options);\n\n      case 'nth-last-child':\n        return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function (length) {\n          return length - selector.index.value;\n        }, options);\n\n      case 'class':\n        switch (selector.name.toLowerCase()) {\n          case 'statement':\n            if (node.type.slice(-9) === 'Statement') return true;\n          // fallthrough: interface Declaration <: Statement { }\n\n          case 'declaration':\n            return node.type.slice(-11) === 'Declaration';\n\n          case 'pattern':\n            if (node.type.slice(-7) === 'Pattern') return true;\n          // fallthrough: interface Expression <: Node, Pattern { }\n\n          case 'expression':\n            return node.type.slice(-10) === 'Expression' || node.type.slice(-7) === 'Literal' || node.type === 'Identifier' && (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty') || node.type === 'MetaProperty';\n\n          case 'function':\n            return node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';\n        }\n\n        throw new Error(\"Unknown class name: \".concat(selector.name));\n    }\n\n    throw new Error(\"Unknown selector type: \".concat(selector.type));\n  }\n  /**\n   * Get visitor keys of a given node.\n   * @param {external:AST} node The AST node to get keys.\n   * @param {ESQueryOptions|undefined} options\n   * @returns {string[]} Visitor keys of the node.\n   */\n\n\n  function getVisitorKeys(node, options) {\n    var nodeType = node.type;\n\n    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {\n      return options.visitorKeys[nodeType];\n    }\n\n    if (estraverse.VisitorKeys[nodeType]) {\n      return estraverse.VisitorKeys[nodeType];\n    }\n\n    if (options && typeof options.fallback === 'function') {\n      return options.fallback(node);\n    } // 'iteration' fallback\n\n\n    return Object.keys(node).filter(function (key) {\n      return key !== 'type';\n    });\n  }\n  /**\n   * Check whether the given value is an ASTNode or not.\n   * @param {any} node The value to check.\n   * @returns {boolean} `true` if the value is an ASTNode.\n   */\n\n\n  function isNode(node) {\n    return node !== null && _typeof(node) === 'object' && typeof node.type === 'string';\n  }\n  /**\n   * Determines if the given node has a sibling that matches the\n   * given selector.\n   * @param {external:AST} node\n   * @param {SelectorSequenceAST} selector\n   * @param {external:AST[]} ancestry\n   * @param {Side} side\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n\n\n  function sibling(node, selector, ancestry, side, options) {\n    var _ancestry = _slicedToArray(ancestry, 1),\n        parent = _ancestry[0];\n\n    if (!parent) {\n      return false;\n    }\n\n    var keys = getVisitorKeys(parent, options);\n\n    var _iterator7 = _createForOfIteratorHelper(keys),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var key = _step7.value;\n        var listProp = parent[key];\n\n        if (Array.isArray(listProp)) {\n          var startIndex = listProp.indexOf(node);\n\n          if (startIndex < 0) {\n            continue;\n          }\n\n          var lowerBound = void 0,\n              upperBound = void 0;\n\n          if (side === LEFT_SIDE) {\n            lowerBound = 0;\n            upperBound = startIndex;\n          } else {\n            lowerBound = startIndex + 1;\n            upperBound = listProp.length;\n          }\n\n          for (var k = lowerBound; k < upperBound; ++k) {\n            if (isNode(listProp[k]) && matches(listProp[k], selector, ancestry, options)) {\n              return true;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    return false;\n  }\n  /**\n   * Determines if the given node has an adjacent sibling that matches\n   * the given selector.\n   * @param {external:AST} node\n   * @param {SelectorSequenceAST} selector\n   * @param {external:AST[]} ancestry\n   * @param {Side} side\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n\n\n  function adjacent(node, selector, ancestry, side, options) {\n    var _ancestry2 = _slicedToArray(ancestry, 1),\n        parent = _ancestry2[0];\n\n    if (!parent) {\n      return false;\n    }\n\n    var keys = getVisitorKeys(parent, options);\n\n    var _iterator8 = _createForOfIteratorHelper(keys),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var key = _step8.value;\n        var listProp = parent[key];\n\n        if (Array.isArray(listProp)) {\n          var idx = listProp.indexOf(node);\n\n          if (idx < 0) {\n            continue;\n          }\n\n          if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1]) && matches(listProp[idx - 1], selector, ancestry, options)) {\n            return true;\n          }\n\n          if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1]) && matches(listProp[idx + 1], selector, ancestry, options)) {\n            return true;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n\n    return false;\n  }\n  /**\n  * @callback IndexFunction\n  * @param {Integer} len Containing list's length\n  * @returns {Integer}\n  */\n\n  /**\n   * Determines if the given node is the nth child, determined by\n   * `idxFn`, which is given the containing list's length.\n   * @param {external:AST} node\n   * @param {external:AST[]} ancestry\n   * @param {IndexFunction} idxFn\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n\n\n  function nthChild(node, ancestry, idxFn, options) {\n    var _ancestry3 = _slicedToArray(ancestry, 1),\n        parent = _ancestry3[0];\n\n    if (!parent) {\n      return false;\n    }\n\n    var keys = getVisitorKeys(parent, options);\n\n    var _iterator9 = _createForOfIteratorHelper(keys),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var key = _step9.value;\n        var listProp = parent[key];\n\n        if (Array.isArray(listProp)) {\n          var idx = listProp.indexOf(node);\n\n          if (idx >= 0 && idx === idxFn(listProp.length)) {\n            return true;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    return false;\n  }\n  /**\n   * For each selector node marked as a subject, find the portion of the\n   * selector that the subject must match.\n   * @param {SelectorAST} selector\n   * @param {SelectorAST} [ancestor] Defaults to `selector`\n   * @returns {SelectorAST[]}\n   */\n\n\n  function subjects(selector, ancestor) {\n    if (selector == null || _typeof(selector) != 'object') {\n      return [];\n    }\n\n    if (ancestor == null) {\n      ancestor = selector;\n    }\n\n    var results = selector.subject ? [ancestor] : [];\n\n    for (var _i = 0, _Object$entries = _objectEntries(selector); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          p = _Object$entries$_i[0],\n          sel = _Object$entries$_i[1];\n\n      results.push.apply(results, _toConsumableArray(subjects(sel, p === 'left' ? sel : ancestor)));\n    }\n\n    return results;\n  }\n  /**\n  * @callback TraverseVisitor\n  * @param {?external:AST} node\n  * @param {?external:AST} parent\n  * @param {external:AST[]} ancestry\n  */\n\n  /**\n   * From a JS AST and a selector AST, collect all JS AST nodes that\n   * match the selector.\n   * @param {external:AST} ast\n   * @param {?SelectorAST} selector\n   * @param {TraverseVisitor} visitor\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n\n\n  function traverse(ast, selector, visitor, options) {\n    if (!selector) {\n      return;\n    }\n\n    var ancestry = [];\n    var altSubjects = subjects(selector);\n    estraverse.traverse(ast, {\n      enter: function enter(node, parent) {\n        if (parent != null) {\n          ancestry.unshift(parent);\n        }\n\n        if (matches(node, selector, ancestry, options)) {\n          if (altSubjects.length) {\n            for (var i = 0, l = altSubjects.length; i < l; ++i) {\n              if (matches(node, altSubjects[i], ancestry, options)) {\n                visitor(node, parent, ancestry);\n              }\n\n              for (var k = 0, m = ancestry.length; k < m; ++k) {\n                var succeedingAncestry = ancestry.slice(k + 1);\n\n                if (matches(ancestry[k], altSubjects[i], succeedingAncestry, options)) {\n                  visitor(ancestry[k], parent, succeedingAncestry);\n                }\n              }\n            }\n          } else {\n            visitor(node, parent, ancestry);\n          }\n        }\n      },\n      leave: function leave() {\n        ancestry.shift();\n      },\n      keys: options && options.visitorKeys,\n      fallback: options && options.fallback || 'iteration'\n    });\n  }\n  /**\n   * From a JS AST and a selector AST, collect all JS AST nodes that\n   * match the selector.\n   * @param {external:AST} ast\n   * @param {?SelectorAST} selector\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n\n\n  function match(ast, selector, options) {\n    var results = [];\n    traverse(ast, selector, function (node) {\n      results.push(node);\n    }, options);\n    return results;\n  }\n  /**\n   * Parse a selector string and return its AST.\n   * @param {string} selector\n   * @returns {SelectorAST}\n   */\n\n\n  function parse(selector) {\n    return parser.parse(selector);\n  }\n  /**\n   * Query the code AST using the selector string.\n   * @param {external:AST} ast\n   * @param {string} selector\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n\n\n  function query(ast, selector, options) {\n    return match(ast, parse(selector), options);\n  }\n\n  query.parse = parse;\n  query.match = match;\n  query.traverse = traverse;\n  query.matches = matches;\n  query.query = query;\n\n  return query;\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}