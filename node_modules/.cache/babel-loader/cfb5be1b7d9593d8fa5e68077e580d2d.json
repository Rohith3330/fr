{"ast":null,"code":"/**\n * @fileoverview Disallow useless fragments\n */\n'use strict';\n\nconst arrayIncludes = require('array-includes');\n\nconst pragmaUtil = require('../util/pragma');\n\nconst jsxUtil = require('../util/jsx');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report');\n\nfunction isJSXText(node) {\n  return !!node && (node.type === 'JSXText' || node.type === 'Literal');\n}\n/**\n * @param {string} text\n * @returns {boolean}\n */\n\n\nfunction isOnlyWhitespace(text) {\n  return text.trim().length === 0;\n}\n/**\n * @param {ASTNode} node\n * @returns {boolean}\n */\n\n\nfunction isNonspaceJSXTextOrJSXCurly(node) {\n  return isJSXText(node) && !isOnlyWhitespace(node.raw) || node.type === 'JSXExpressionContainer';\n}\n/**\n * Somehow fragment like this is useful: <Foo content={<>ee eeee eeee ...</>} />\n * @param {ASTNode} node\n * @returns {boolean}\n */\n\n\nfunction isFragmentWithOnlyTextAndIsNotChild(node) {\n  return node.children.length === 1 && isJSXText(node.children[0]) && !(node.parent.type === 'JSXElement' || node.parent.type === 'JSXFragment');\n}\n/**\n * @param {string} text\n * @returns {string}\n */\n\n\nfunction trimLikeReact(text) {\n  const leadingSpaces = /^\\s*/.exec(text)[0];\n  const trailingSpaces = /\\s*$/.exec(text)[0];\n  const start = arrayIncludes(leadingSpaces, '\\n') ? leadingSpaces.length : 0;\n  const end = arrayIncludes(trailingSpaces, '\\n') ? text.length - trailingSpaces.length : text.length;\n  return text.slice(start, end);\n}\n/**\n * Test if node is like `<Fragment key={_}>_</Fragment>`\n * @param {JSXElement} node\n * @returns {boolean}\n */\n\n\nfunction isKeyedElement(node) {\n  return node.type === 'JSXElement' && node.openingElement.attributes && node.openingElement.attributes.some(jsxUtil.isJSXAttributeKey);\n}\n/**\n * @param {ASTNode} node\n * @returns {boolean}\n */\n\n\nfunction containsCallExpression(node) {\n  return node && node.type === 'JSXExpressionContainer' && node.expression && node.expression.type === 'CallExpression';\n}\n\nconst messages = {\n  NeedsMoreChildren: 'Fragments should contain more than one child - otherwise, there’s no need for a Fragment at all.',\n  ChildOfHtmlElement: 'Passing a fragment to an HTML element is useless.'\n};\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    fixable: 'code',\n    docs: {\n      description: 'Disallow unnecessary fragments',\n      category: 'Possible Errors',\n      recommended: false,\n      url: docsUrl('jsx-no-useless-fragment')\n    },\n    messages\n  },\n\n  create(context) {\n    const config = context.options[0] || {};\n    const allowExpressions = config.allowExpressions || false;\n    const reactPragma = pragmaUtil.getFromContext(context);\n    const fragmentPragma = pragmaUtil.getFragmentFromContext(context);\n    /**\n     * Test whether a node is an padding spaces trimmed by react runtime.\n     * @param {ASTNode} node\n     * @returns {boolean}\n     */\n\n    function isPaddingSpaces(node) {\n      return isJSXText(node) && isOnlyWhitespace(node.raw) && arrayIncludes(node.raw, '\\n');\n    }\n\n    function isFragmentWithSingleExpression(node) {\n      const children = node && node.children.filter(child => !isPaddingSpaces(child));\n      return children && children.length === 1 && children[0].type === 'JSXExpressionContainer';\n    }\n    /**\n     * Test whether a JSXElement has less than two children, excluding paddings spaces.\n     * @param {JSXElement|JSXFragment} node\n     * @returns {boolean}\n     */\n\n\n    function hasLessThanTwoChildren(node) {\n      if (!node || !node.children) {\n        return true;\n      }\n      /** @type {ASTNode[]} */\n\n\n      const nonPaddingChildren = node.children.filter(child => !isPaddingSpaces(child));\n\n      if (nonPaddingChildren.length < 2) {\n        return !containsCallExpression(nonPaddingChildren[0]);\n      }\n    }\n    /**\n     * @param {JSXElement|JSXFragment} node\n     * @returns {boolean}\n     */\n\n\n    function isChildOfHtmlElement(node) {\n      return node.parent.type === 'JSXElement' && node.parent.openingElement.name.type === 'JSXIdentifier' && /^[a-z]+$/.test(node.parent.openingElement.name.name);\n    }\n    /**\n     * @param {JSXElement|JSXFragment} node\n     * @return {boolean}\n     */\n\n\n    function isChildOfComponentElement(node) {\n      return node.parent.type === 'JSXElement' && !isChildOfHtmlElement(node) && !jsxUtil.isFragment(node.parent, reactPragma, fragmentPragma);\n    }\n    /**\n     * @param {ASTNode} node\n     * @returns {boolean}\n     */\n\n\n    function canFix(node) {\n      // Not safe to fix fragments without a jsx parent.\n      if (!(node.parent.type === 'JSXElement' || node.parent.type === 'JSXFragment')) {\n        // const a = <></>\n        if (node.children.length === 0) {\n          return false;\n        } // const a = <>cat {meow}</>\n\n\n        if (node.children.some(isNonspaceJSXTextOrJSXCurly)) {\n          return false;\n        }\n      } // Not safe to fix `<Eeee><>foo</></Eeee>` because `Eeee` might require its children be a ReactElement.\n\n\n      if (isChildOfComponentElement(node)) {\n        return false;\n      } // old TS parser can't handle this one\n\n\n      if (node.type === 'JSXFragment' && (!node.openingFragment || !node.closingFragment)) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * @param {ASTNode} node\n     * @returns {Function | undefined}\n     */\n\n\n    function getFix(node) {\n      if (!canFix(node)) {\n        return undefined;\n      }\n\n      return function fix(fixer) {\n        const opener = node.type === 'JSXFragment' ? node.openingFragment : node.openingElement;\n        const closer = node.type === 'JSXFragment' ? node.closingFragment : node.closingElement;\n        const childrenText = opener.selfClosing ? '' : context.getSourceCode().getText().slice(opener.range[1], closer.range[0]);\n        return fixer.replaceText(node, trimLikeReact(childrenText));\n      };\n    }\n\n    function checkNode(node) {\n      if (isKeyedElement(node)) {\n        return;\n      }\n\n      if (hasLessThanTwoChildren(node) && !isFragmentWithOnlyTextAndIsNotChild(node) && !(allowExpressions && isFragmentWithSingleExpression(node))) {\n        report(context, messages.NeedsMoreChildren, 'NeedsMoreChildren', {\n          node,\n          fix: getFix(node)\n        });\n      }\n\n      if (isChildOfHtmlElement(node)) {\n        report(context, messages.ChildOfHtmlElement, 'ChildOfHtmlElement', {\n          node,\n          fix: getFix(node)\n        });\n      }\n    }\n\n    return {\n      JSXElement(node) {\n        if (jsxUtil.isFragment(node, reactPragma, fragmentPragma)) {\n          checkNode(node);\n        }\n      },\n\n      JSXFragment: checkNode\n    };\n  }\n\n};","map":{"version":3,"names":["arrayIncludes","require","pragmaUtil","jsxUtil","docsUrl","report","isJSXText","node","type","isOnlyWhitespace","text","trim","length","isNonspaceJSXTextOrJSXCurly","raw","isFragmentWithOnlyTextAndIsNotChild","children","parent","trimLikeReact","leadingSpaces","exec","trailingSpaces","start","end","slice","isKeyedElement","openingElement","attributes","some","isJSXAttributeKey","containsCallExpression","expression","messages","NeedsMoreChildren","ChildOfHtmlElement","module","exports","meta","fixable","docs","description","category","recommended","url","create","context","config","options","allowExpressions","reactPragma","getFromContext","fragmentPragma","getFragmentFromContext","isPaddingSpaces","isFragmentWithSingleExpression","filter","child","hasLessThanTwoChildren","nonPaddingChildren","isChildOfHtmlElement","name","test","isChildOfComponentElement","isFragment","canFix","openingFragment","closingFragment","getFix","undefined","fix","fixer","opener","closer","closingElement","childrenText","selfClosing","getSourceCode","getText","range","replaceText","checkNode","JSXElement","JSXFragment"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-no-useless-fragment.js"],"sourcesContent":["/**\n * @fileoverview Disallow useless fragments\n */\n\n'use strict';\n\nconst arrayIncludes = require('array-includes');\n\nconst pragmaUtil = require('../util/pragma');\nconst jsxUtil = require('../util/jsx');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\nfunction isJSXText(node) {\n  return !!node && (node.type === 'JSXText' || node.type === 'Literal');\n}\n\n/**\n * @param {string} text\n * @returns {boolean}\n */\nfunction isOnlyWhitespace(text) {\n  return text.trim().length === 0;\n}\n\n/**\n * @param {ASTNode} node\n * @returns {boolean}\n */\nfunction isNonspaceJSXTextOrJSXCurly(node) {\n  return (isJSXText(node) && !isOnlyWhitespace(node.raw)) || node.type === 'JSXExpressionContainer';\n}\n\n/**\n * Somehow fragment like this is useful: <Foo content={<>ee eeee eeee ...</>} />\n * @param {ASTNode} node\n * @returns {boolean}\n */\nfunction isFragmentWithOnlyTextAndIsNotChild(node) {\n  return node.children.length === 1\n    && isJSXText(node.children[0])\n    && !(node.parent.type === 'JSXElement' || node.parent.type === 'JSXFragment');\n}\n\n/**\n * @param {string} text\n * @returns {string}\n */\nfunction trimLikeReact(text) {\n  const leadingSpaces = /^\\s*/.exec(text)[0];\n  const trailingSpaces = /\\s*$/.exec(text)[0];\n\n  const start = arrayIncludes(leadingSpaces, '\\n') ? leadingSpaces.length : 0;\n  const end = arrayIncludes(trailingSpaces, '\\n') ? text.length - trailingSpaces.length : text.length;\n\n  return text.slice(start, end);\n}\n\n/**\n * Test if node is like `<Fragment key={_}>_</Fragment>`\n * @param {JSXElement} node\n * @returns {boolean}\n */\nfunction isKeyedElement(node) {\n  return node.type === 'JSXElement'\n    && node.openingElement.attributes\n    && node.openingElement.attributes.some(jsxUtil.isJSXAttributeKey);\n}\n\n/**\n * @param {ASTNode} node\n * @returns {boolean}\n */\nfunction containsCallExpression(node) {\n  return node\n    && node.type === 'JSXExpressionContainer'\n    && node.expression\n    && node.expression.type === 'CallExpression';\n}\n\nconst messages = {\n  NeedsMoreChildren: 'Fragments should contain more than one child - otherwise, there’s no need for a Fragment at all.',\n  ChildOfHtmlElement: 'Passing a fragment to an HTML element is useless.',\n};\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    fixable: 'code',\n    docs: {\n      description: 'Disallow unnecessary fragments',\n      category: 'Possible Errors',\n      recommended: false,\n      url: docsUrl('jsx-no-useless-fragment'),\n    },\n    messages,\n  },\n\n  create(context) {\n    const config = context.options[0] || {};\n    const allowExpressions = config.allowExpressions || false;\n\n    const reactPragma = pragmaUtil.getFromContext(context);\n    const fragmentPragma = pragmaUtil.getFragmentFromContext(context);\n\n    /**\n     * Test whether a node is an padding spaces trimmed by react runtime.\n     * @param {ASTNode} node\n     * @returns {boolean}\n     */\n    function isPaddingSpaces(node) {\n      return isJSXText(node)\n        && isOnlyWhitespace(node.raw)\n        && arrayIncludes(node.raw, '\\n');\n    }\n\n    function isFragmentWithSingleExpression(node) {\n      const children = node && node.children.filter((child) => !isPaddingSpaces(child));\n      return (\n        children\n        && children.length === 1\n        && children[0].type === 'JSXExpressionContainer'\n      );\n    }\n\n    /**\n     * Test whether a JSXElement has less than two children, excluding paddings spaces.\n     * @param {JSXElement|JSXFragment} node\n     * @returns {boolean}\n     */\n    function hasLessThanTwoChildren(node) {\n      if (!node || !node.children) {\n        return true;\n      }\n\n      /** @type {ASTNode[]} */\n      const nonPaddingChildren = node.children.filter(\n        (child) => !isPaddingSpaces(child)\n      );\n\n      if (nonPaddingChildren.length < 2) {\n        return !containsCallExpression(nonPaddingChildren[0]);\n      }\n    }\n\n    /**\n     * @param {JSXElement|JSXFragment} node\n     * @returns {boolean}\n     */\n    function isChildOfHtmlElement(node) {\n      return node.parent.type === 'JSXElement'\n        && node.parent.openingElement.name.type === 'JSXIdentifier'\n        && /^[a-z]+$/.test(node.parent.openingElement.name.name);\n    }\n\n    /**\n     * @param {JSXElement|JSXFragment} node\n     * @return {boolean}\n     */\n    function isChildOfComponentElement(node) {\n      return node.parent.type === 'JSXElement'\n        && !isChildOfHtmlElement(node)\n        && !jsxUtil.isFragment(node.parent, reactPragma, fragmentPragma);\n    }\n\n    /**\n     * @param {ASTNode} node\n     * @returns {boolean}\n     */\n    function canFix(node) {\n      // Not safe to fix fragments without a jsx parent.\n      if (!(node.parent.type === 'JSXElement' || node.parent.type === 'JSXFragment')) {\n        // const a = <></>\n        if (node.children.length === 0) {\n          return false;\n        }\n\n        // const a = <>cat {meow}</>\n        if (node.children.some(isNonspaceJSXTextOrJSXCurly)) {\n          return false;\n        }\n      }\n\n      // Not safe to fix `<Eeee><>foo</></Eeee>` because `Eeee` might require its children be a ReactElement.\n      if (isChildOfComponentElement(node)) {\n        return false;\n      }\n\n      // old TS parser can't handle this one\n      if (node.type === 'JSXFragment' && (!node.openingFragment || !node.closingFragment)) {\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n     * @param {ASTNode} node\n     * @returns {Function | undefined}\n     */\n    function getFix(node) {\n      if (!canFix(node)) {\n        return undefined;\n      }\n\n      return function fix(fixer) {\n        const opener = node.type === 'JSXFragment' ? node.openingFragment : node.openingElement;\n        const closer = node.type === 'JSXFragment' ? node.closingFragment : node.closingElement;\n\n        const childrenText = opener.selfClosing ? '' : context.getSourceCode().getText().slice(opener.range[1], closer.range[0]);\n\n        return fixer.replaceText(node, trimLikeReact(childrenText));\n      };\n    }\n\n    function checkNode(node) {\n      if (isKeyedElement(node)) {\n        return;\n      }\n\n      if (\n        hasLessThanTwoChildren(node)\n        && !isFragmentWithOnlyTextAndIsNotChild(node)\n        && !(allowExpressions && isFragmentWithSingleExpression(node))\n      ) {\n        report(context, messages.NeedsMoreChildren, 'NeedsMoreChildren', {\n          node,\n          fix: getFix(node),\n        });\n      }\n\n      if (isChildOfHtmlElement(node)) {\n        report(context, messages.ChildOfHtmlElement, 'ChildOfHtmlElement', {\n          node,\n          fix: getFix(node),\n        });\n      }\n    }\n\n    return {\n      JSXElement(node) {\n        if (jsxUtil.isFragment(node, reactPragma, fragmentPragma)) {\n          checkNode(node);\n        }\n      },\n      JSXFragment: checkNode,\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}