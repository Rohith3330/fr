{"ast":null,"code":"'use strict';\n\nconst check = require('check-types');\n\nconst DataStream = require('./datastream');\n\nconst events = require('./events');\n\nconst Hoopy = require('hoopy');\n\nconst walk = require('./walk');\n\nconst DEFAULT_BUFFER_LENGTH = 1024;\nmodule.exports = match;\n/**\n * Public function `match`.\n *\n * Asynchronously parses a stream of JSON data, returning a stream of items\n * that match the argument. Note that if a value is `null`, it won't be matched\n * because `null` is used to signify end-of-stream in node.\n *\n * @param stream:         Readable instance representing the incoming JSON.\n *\n * @param selector:       Regular expression, string or predicate function used to\n *                        identify matches. If a regular expression or string is\n *                        passed, only property keys are tested. If a predicate is\n *                        passed, both the key and the value are passed to it as\n *                        arguments.\n *\n * @option minDepth:      Number indicating the minimum depth to apply the selector\n *                        to. The default is `0`, but setting it to a higher value\n *                        can improve performance and reduce memory usage by\n *                        eliminating the need to actualise top-level items.\n *\n * @option numbers:       Boolean, indicating whether numerical keys (e.g. array\n *                        indices) should be coerced to strings before testing the\n *                        match. Only applies if the `selector` argument is a string\n *                        or regular expression.\n *\n * @option ndjson:        Set this to true to parse newline-delimited JSON,\n *                        default is `false`.\n *\n * @option yieldRate:     The number of data items to process per timeslice,\n *                        default is 16384.\n *\n * @option bufferLength:  The length of the match buffer, default is 1024.\n *\n * @option highWaterMark: If set, will be passed to the readable stream constructor\n *                        as the value for the highWaterMark option.\n *\n * @option Promise:       The promise constructor to use, defaults to bluebird.\n **/\n\nfunction match(stream, selector) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const scopes = [];\n  const properties = [];\n  const emitter = walk(stream, options);\n  const matches = new Hoopy(options.bufferLength || DEFAULT_BUFFER_LENGTH);\n  let streamOptions;\n  const {\n    highWaterMark\n  } = options;\n\n  if (highWaterMark) {\n    streamOptions = {\n      highWaterMark\n    };\n  }\n\n  const results = new DataStream(read, streamOptions);\n  let selectorFunction, selectorString, resume;\n  let coerceNumbers = false;\n  let awaitPush = true;\n  let isEnded = false;\n  let length = 0;\n  let index = 0;\n  const minDepth = options.minDepth || 0;\n  check.assert.greaterOrEqual(minDepth, 0);\n\n  if (check.function(selector)) {\n    selectorFunction = selector;\n    selector = null;\n  } else {\n    coerceNumbers = !!options.numbers;\n\n    if (check.string(selector)) {\n      check.assert.nonEmptyString(selector);\n      selectorString = selector;\n      selector = null;\n    } else {\n      check.assert.instanceStrict(selector, RegExp);\n    }\n  }\n\n  emitter.on(events.array, array);\n  emitter.on(events.object, object);\n  emitter.on(events.property, property);\n  emitter.on(events.endArray, endScope);\n  emitter.on(events.endObject, endScope);\n  emitter.on(events.string, value);\n  emitter.on(events.number, value);\n  emitter.on(events.literal, value);\n  emitter.on(events.end, end);\n  emitter.on(events.error, error);\n  emitter.on(events.dataError, dataError);\n  return results;\n\n  function read() {\n    if (awaitPush) {\n      awaitPush = false;\n\n      if (isEnded) {\n        if (length > 0) {\n          after();\n        }\n\n        return endResults();\n      }\n    }\n\n    if (resume) {\n      const resumeCopy = resume;\n      resume = null;\n      resumeCopy();\n      after();\n    }\n  }\n\n  function after() {\n    if (awaitPush || resume) {\n      return;\n    }\n\n    let i;\n\n    for (i = 0; i < length && !resume; ++i) {\n      if (!results.push(matches[i + index])) {\n        pause();\n      }\n    }\n\n    if (i === length) {\n      index = length = 0;\n    } else {\n      length -= i;\n      index += i;\n    }\n  }\n\n  function pause() {\n    resume = emitter.pause();\n  }\n\n  function endResults() {\n    if (!awaitPush) {\n      results.push(null);\n    }\n  }\n\n  function array() {\n    scopes.push([]);\n  }\n\n  function object() {\n    scopes.push({});\n  }\n\n  function property(name) {\n    if (scopes.length < minDepth) {\n      return;\n    }\n\n    properties.push(name);\n  }\n\n  function endScope() {\n    value(scopes.pop());\n  }\n\n  function value(v) {\n    let key;\n\n    if (scopes.length < minDepth) {\n      return;\n    }\n\n    if (scopes.length > 0) {\n      const scope = scopes[scopes.length - 1];\n\n      if (Array.isArray(scope)) {\n        key = scope.length;\n      } else {\n        key = properties.pop();\n      }\n\n      scope[key] = v;\n    }\n\n    if (v === null) {\n      return;\n    }\n\n    if (selectorFunction) {\n      if (selectorFunction(key, v, scopes.length)) {\n        push(v);\n      }\n    } else {\n      if (coerceNumbers && typeof key === 'number') {\n        key = key.toString();\n      }\n\n      if (selectorString && selectorString === key || selector && selector.test(key)) {\n        push(v);\n      }\n    }\n  }\n\n  function push(v) {\n    if (length + 1 === matches.length) {\n      pause();\n    }\n\n    matches[index + length++] = v;\n    after();\n  }\n\n  function end() {\n    isEnded = true;\n    endResults();\n  }\n\n  function error(e) {\n    results.emit('error', e);\n  }\n\n  function dataError(e) {\n    results.emit('dataError', e);\n  }\n}","map":{"version":3,"names":["check","require","DataStream","events","Hoopy","walk","DEFAULT_BUFFER_LENGTH","module","exports","match","stream","selector","options","scopes","properties","emitter","matches","bufferLength","streamOptions","highWaterMark","results","read","selectorFunction","selectorString","resume","coerceNumbers","awaitPush","isEnded","length","index","minDepth","assert","greaterOrEqual","function","numbers","string","nonEmptyString","instanceStrict","RegExp","on","array","object","property","endArray","endScope","endObject","value","number","literal","end","error","dataError","after","endResults","resumeCopy","i","push","pause","name","pop","v","key","scope","Array","isArray","toString","test","e","emit"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/bfj/src/match.js"],"sourcesContent":["'use strict'\n\nconst check = require('check-types')\nconst DataStream = require('./datastream')\nconst events = require('./events')\nconst Hoopy = require('hoopy')\nconst walk = require('./walk')\n\nconst DEFAULT_BUFFER_LENGTH = 1024\n\nmodule.exports = match\n\n/**\n * Public function `match`.\n *\n * Asynchronously parses a stream of JSON data, returning a stream of items\n * that match the argument. Note that if a value is `null`, it won't be matched\n * because `null` is used to signify end-of-stream in node.\n *\n * @param stream:         Readable instance representing the incoming JSON.\n *\n * @param selector:       Regular expression, string or predicate function used to\n *                        identify matches. If a regular expression or string is\n *                        passed, only property keys are tested. If a predicate is\n *                        passed, both the key and the value are passed to it as\n *                        arguments.\n *\n * @option minDepth:      Number indicating the minimum depth to apply the selector\n *                        to. The default is `0`, but setting it to a higher value\n *                        can improve performance and reduce memory usage by\n *                        eliminating the need to actualise top-level items.\n *\n * @option numbers:       Boolean, indicating whether numerical keys (e.g. array\n *                        indices) should be coerced to strings before testing the\n *                        match. Only applies if the `selector` argument is a string\n *                        or regular expression.\n *\n * @option ndjson:        Set this to true to parse newline-delimited JSON,\n *                        default is `false`.\n *\n * @option yieldRate:     The number of data items to process per timeslice,\n *                        default is 16384.\n *\n * @option bufferLength:  The length of the match buffer, default is 1024.\n *\n * @option highWaterMark: If set, will be passed to the readable stream constructor\n *                        as the value for the highWaterMark option.\n *\n * @option Promise:       The promise constructor to use, defaults to bluebird.\n **/\nfunction match (stream, selector, options = {}) {\n  const scopes = []\n  const properties = []\n  const emitter = walk(stream, options)\n  const matches = new Hoopy(options.bufferLength || DEFAULT_BUFFER_LENGTH)\n  let streamOptions\n  const { highWaterMark } = options\n  if (highWaterMark) {\n    streamOptions = { highWaterMark }\n  }\n  const results = new DataStream(read, streamOptions)\n\n  let selectorFunction, selectorString, resume\n  let coerceNumbers = false\n  let awaitPush = true\n  let isEnded = false\n  let length = 0\n  let index = 0\n\n  const minDepth = options.minDepth || 0\n  check.assert.greaterOrEqual(minDepth, 0)\n\n  if (check.function(selector)) {\n    selectorFunction = selector\n    selector = null\n  } else {\n    coerceNumbers = !! options.numbers\n\n    if (check.string(selector)) {\n      check.assert.nonEmptyString(selector)\n      selectorString = selector\n      selector = null\n    } else {\n      check.assert.instanceStrict(selector, RegExp)\n    }\n  }\n\n  emitter.on(events.array, array)\n  emitter.on(events.object, object)\n  emitter.on(events.property, property)\n  emitter.on(events.endArray, endScope)\n  emitter.on(events.endObject, endScope)\n  emitter.on(events.string, value)\n  emitter.on(events.number, value)\n  emitter.on(events.literal, value)\n  emitter.on(events.end, end)\n  emitter.on(events.error, error)\n  emitter.on(events.dataError, dataError)\n\n  return results\n\n  function read () {\n    if (awaitPush) {\n      awaitPush = false\n\n      if (isEnded) {\n        if (length > 0) {\n          after()\n        }\n\n        return endResults()\n      }\n    }\n\n    if (resume) {\n      const resumeCopy = resume\n      resume = null\n      resumeCopy()\n      after()\n    }\n  }\n\n  function after () {\n    if (awaitPush || resume) {\n      return\n    }\n\n    let i\n\n    for (i = 0; i < length && ! resume; ++i) {\n      if (! results.push(matches[i + index])) {\n        pause()\n      }\n    }\n\n    if (i === length) {\n      index = length = 0\n    } else {\n      length -= i\n      index += i\n    }\n  }\n\n  function pause () {\n    resume = emitter.pause()\n  }\n\n  function endResults () {\n    if (! awaitPush) {\n      results.push(null)\n    }\n  }\n\n  function array () {\n    scopes.push([])\n  }\n\n  function object () {\n    scopes.push({})\n  }\n\n  function property (name) {\n    if (scopes.length < minDepth) {\n      return\n    }\n\n    properties.push(name)\n  }\n\n  function endScope () {\n    value(scopes.pop())\n  }\n\n  function value (v) {\n    let key\n\n    if (scopes.length < minDepth) {\n      return\n    }\n\n    if (scopes.length > 0) {\n      const scope = scopes[scopes.length - 1]\n\n      if (Array.isArray(scope)) {\n        key = scope.length\n      } else {\n        key = properties.pop()\n      }\n\n      scope[key] = v\n    }\n\n    if (v === null) {\n      return\n    }\n\n    if (selectorFunction) {\n      if (selectorFunction(key, v, scopes.length)) {\n        push(v)\n      }\n    } else {\n      if (coerceNumbers && typeof key === 'number') {\n        key = key.toString()\n      }\n\n      if ((selectorString && selectorString === key) || (selector && selector.test(key))) {\n        push(v)\n      }\n    }\n  }\n\n  function push (v) {\n    if (length + 1 === matches.length) {\n      pause()\n    }\n\n    matches[index + length++] = v\n\n    after()\n  }\n\n  function end () {\n    isEnded = true\n    endResults()\n  }\n\n  function error (e) {\n    results.emit('error', e)\n  }\n\n  function dataError (e) {\n    results.emit('dataError', e)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}