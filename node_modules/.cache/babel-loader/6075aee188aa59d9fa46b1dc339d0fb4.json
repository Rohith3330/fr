{"ast":null,"code":"/**\n * @fileoverview Rule to require or disallow line breaks inside braces.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n// Schema objects.\n\n\nconst OPTION_VALUE = {\n  oneOf: [{\n    enum: [\"always\", \"never\"]\n  }, {\n    type: \"object\",\n    properties: {\n      multiline: {\n        type: \"boolean\"\n      },\n      minProperties: {\n        type: \"integer\",\n        minimum: 0\n      },\n      consistent: {\n        type: \"boolean\"\n      }\n    },\n    additionalProperties: false,\n    minProperties: 1\n  }]\n};\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} value An option value to parse.\n * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.\n */\n\nfunction normalizeOptionValue(value) {\n  let multiline = false;\n  let minProperties = Number.POSITIVE_INFINITY;\n  let consistent = false;\n\n  if (value) {\n    if (value === \"always\") {\n      minProperties = 0;\n    } else if (value === \"never\") {\n      minProperties = Number.POSITIVE_INFINITY;\n    } else {\n      multiline = Boolean(value.multiline);\n      minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n      consistent = Boolean(value.consistent);\n    }\n  } else {\n    consistent = true;\n  }\n\n  return {\n    multiline,\n    minProperties,\n    consistent\n  };\n}\n/**\n * Checks if a value is an object.\n * @param {any} value The value to check\n * @returns {boolean} `true` if the value is an object, otherwise `false`\n */\n\n\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\n/**\n * Checks if an option is a node-specific option\n * @param {any} option The option to check\n * @returns {boolean} `true` if the option is node-specific, otherwise `false`\n */\n\n\nfunction isNodeSpecificOption(option) {\n  return isObject(option) || typeof option === \"string\";\n}\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} options An option value to parse.\n * @returns {{\n *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean}\n * }} Normalized option object.\n */\n\n\nfunction normalizeOptions(options) {\n  if (isObject(options) && Object.values(options).some(isNodeSpecificOption)) {\n    return {\n      ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n      ObjectPattern: normalizeOptionValue(options.ObjectPattern),\n      ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),\n      ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)\n    };\n  }\n\n  const value = normalizeOptionValue(options);\n  return {\n    ObjectExpression: value,\n    ObjectPattern: value,\n    ImportDeclaration: value,\n    ExportNamedDeclaration: value\n  };\n}\n/**\n * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration\n * node needs to be checked for missing line breaks\n * @param {ASTNode} node Node under inspection\n * @param {Object} options option specific to node type\n * @param {Token} first First object property\n * @param {Token} last Last object property\n * @returns {boolean} `true` if node needs to be checked for missing line breaks\n */\n\n\nfunction areLineBreaksRequired(node, options, first, last) {\n  let objectProperties;\n\n  if (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\") {\n    objectProperties = node.properties;\n  } else {\n    // is ImportDeclaration or ExportNamedDeclaration\n    objectProperties = node.specifiers.filter(s => s.type === \"ImportSpecifier\" || s.type === \"ExportSpecifier\");\n  }\n\n  return objectProperties.length >= options.minProperties || options.multiline && objectProperties.length > 0 && first.loc.start.line !== last.loc.end.line;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"Enforce consistent line breaks after opening and before closing braces\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/object-curly-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [OPTION_VALUE, {\n        type: \"object\",\n        properties: {\n          ObjectExpression: OPTION_VALUE,\n          ObjectPattern: OPTION_VALUE,\n          ImportDeclaration: OPTION_VALUE,\n          ExportDeclaration: OPTION_VALUE\n        },\n        additionalProperties: false,\n        minProperties: 1\n      }]\n    }],\n    messages: {\n      unexpectedLinebreakBeforeClosingBrace: \"Unexpected line break before this closing brace.\",\n      unexpectedLinebreakAfterOpeningBrace: \"Unexpected line break after this opening brace.\",\n      expectedLinebreakBeforeClosingBrace: \"Expected a line break before this closing brace.\",\n      expectedLinebreakAfterOpeningBrace: \"Expected a line break after this opening brace.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const normalizedOptions = normalizeOptions(context.options[0]);\n    /**\n     * Reports a given node if it violated this rule.\n     * @param {ASTNode} node A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.\n     * @returns {void}\n     */\n\n    function check(node) {\n      const options = normalizedOptions[node.type];\n\n      if (node.type === \"ImportDeclaration\" && !node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\") || node.type === \"ExportNamedDeclaration\" && !node.specifiers.some(specifier => specifier.type === \"ExportSpecifier\")) {\n        return;\n      }\n\n      const openBrace = sourceCode.getFirstToken(node, token => token.value === \"{\");\n      let closeBrace;\n\n      if (node.typeAnnotation) {\n        closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);\n      } else {\n        closeBrace = sourceCode.getLastToken(node, token => token.value === \"}\");\n      }\n\n      let first = sourceCode.getTokenAfter(openBrace, {\n        includeComments: true\n      });\n      let last = sourceCode.getTokenBefore(closeBrace, {\n        includeComments: true\n      });\n      const needsLineBreaks = areLineBreaksRequired(node, options, first, last);\n      const hasCommentsFirstToken = astUtils.isCommentToken(first);\n      const hasCommentsLastToken = astUtils.isCommentToken(last);\n      /*\n       * Use tokens or comments to check multiline or not.\n       * But use only tokens to check whether line breaks are needed.\n       * This allows:\n       *     var obj = { // eslint-disable-line foo\n       *         a: 1\n       *     }\n       */\n\n      first = sourceCode.getTokenAfter(openBrace);\n      last = sourceCode.getTokenBefore(closeBrace);\n\n      if (needsLineBreaks) {\n        if (astUtils.isTokenOnSameLine(openBrace, first)) {\n          context.report({\n            messageId: \"expectedLinebreakAfterOpeningBrace\",\n            node,\n            loc: openBrace.loc,\n\n            fix(fixer) {\n              if (hasCommentsFirstToken) {\n                return null;\n              }\n\n              return fixer.insertTextAfter(openBrace, \"\\n\");\n            }\n\n          });\n        }\n\n        if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n          context.report({\n            messageId: \"expectedLinebreakBeforeClosingBrace\",\n            node,\n            loc: closeBrace.loc,\n\n            fix(fixer) {\n              if (hasCommentsLastToken) {\n                return null;\n              }\n\n              return fixer.insertTextBefore(closeBrace, \"\\n\");\n            }\n\n          });\n        }\n      } else {\n        const consistent = options.consistent;\n        const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\n        const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\n\n        if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) {\n          context.report({\n            messageId: \"unexpectedLinebreakAfterOpeningBrace\",\n            node,\n            loc: openBrace.loc,\n\n            fix(fixer) {\n              if (hasCommentsFirstToken) {\n                return null;\n              }\n\n              return fixer.removeRange([openBrace.range[1], first.range[0]]);\n            }\n\n          });\n        }\n\n        if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) {\n          context.report({\n            messageId: \"unexpectedLinebreakBeforeClosingBrace\",\n            node,\n            loc: closeBrace.loc,\n\n            fix(fixer) {\n              if (hasCommentsLastToken) {\n                return null;\n              }\n\n              return fixer.removeRange([last.range[1], closeBrace.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n\n    return {\n      ObjectExpression: check,\n      ObjectPattern: check,\n      ImportDeclaration: check,\n      ExportNamedDeclaration: check\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","OPTION_VALUE","oneOf","enum","type","properties","multiline","minProperties","minimum","consistent","additionalProperties","normalizeOptionValue","value","Number","POSITIVE_INFINITY","Boolean","isObject","isNodeSpecificOption","option","normalizeOptions","options","Object","values","some","ObjectExpression","ObjectPattern","ImportDeclaration","ExportNamedDeclaration","ExportDeclaration","areLineBreaksRequired","node","first","last","objectProperties","specifiers","filter","s","length","loc","start","line","end","module","exports","meta","docs","description","recommended","url","fixable","schema","messages","unexpectedLinebreakBeforeClosingBrace","unexpectedLinebreakAfterOpeningBrace","expectedLinebreakBeforeClosingBrace","expectedLinebreakAfterOpeningBrace","create","context","sourceCode","getSourceCode","normalizedOptions","check","specifier","openBrace","getFirstToken","token","closeBrace","typeAnnotation","getTokenBefore","getLastToken","getTokenAfter","includeComments","needsLineBreaks","hasCommentsFirstToken","isCommentToken","hasCommentsLastToken","isTokenOnSameLine","report","messageId","fix","fixer","insertTextAfter","insertTextBefore","hasLineBreakBetweenOpenBraceAndFirst","hasLineBreakBetweenCloseBraceAndLast","removeRange","range"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/object-curly-newline.js"],"sourcesContent":["/**\n * @fileoverview Rule to require or disallow line breaks inside braces.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n// Schema objects.\nconst OPTION_VALUE = {\n    oneOf: [\n        {\n            enum: [\"always\", \"never\"]\n        },\n        {\n            type: \"object\",\n            properties: {\n                multiline: {\n                    type: \"boolean\"\n                },\n                minProperties: {\n                    type: \"integer\",\n                    minimum: 0\n                },\n                consistent: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false,\n            minProperties: 1\n        }\n    ]\n};\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} value An option value to parse.\n * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.\n */\nfunction normalizeOptionValue(value) {\n    let multiline = false;\n    let minProperties = Number.POSITIVE_INFINITY;\n    let consistent = false;\n\n    if (value) {\n        if (value === \"always\") {\n            minProperties = 0;\n        } else if (value === \"never\") {\n            minProperties = Number.POSITIVE_INFINITY;\n        } else {\n            multiline = Boolean(value.multiline);\n            minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n            consistent = Boolean(value.consistent);\n        }\n    } else {\n        consistent = true;\n    }\n\n    return { multiline, minProperties, consistent };\n}\n\n/**\n * Checks if a value is an object.\n * @param {any} value The value to check\n * @returns {boolean} `true` if the value is an object, otherwise `false`\n */\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n\n/**\n * Checks if an option is a node-specific option\n * @param {any} option The option to check\n * @returns {boolean} `true` if the option is node-specific, otherwise `false`\n */\nfunction isNodeSpecificOption(option) {\n    return isObject(option) || typeof option === \"string\";\n}\n\n/**\n * Normalizes a given option value.\n * @param {string|Object|undefined} options An option value to parse.\n * @returns {{\n *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean},\n *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean}\n * }} Normalized option object.\n */\nfunction normalizeOptions(options) {\n    if (isObject(options) && Object.values(options).some(isNodeSpecificOption)) {\n        return {\n            ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n            ObjectPattern: normalizeOptionValue(options.ObjectPattern),\n            ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),\n            ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)\n        };\n    }\n\n    const value = normalizeOptionValue(options);\n\n    return { ObjectExpression: value, ObjectPattern: value, ImportDeclaration: value, ExportNamedDeclaration: value };\n}\n\n/**\n * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration\n * node needs to be checked for missing line breaks\n * @param {ASTNode} node Node under inspection\n * @param {Object} options option specific to node type\n * @param {Token} first First object property\n * @param {Token} last Last object property\n * @returns {boolean} `true` if node needs to be checked for missing line breaks\n */\nfunction areLineBreaksRequired(node, options, first, last) {\n    let objectProperties;\n\n    if (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\") {\n        objectProperties = node.properties;\n    } else {\n\n        // is ImportDeclaration or ExportNamedDeclaration\n        objectProperties = node.specifiers\n            .filter(s => s.type === \"ImportSpecifier\" || s.type === \"ExportSpecifier\");\n    }\n\n    return objectProperties.length >= options.minProperties ||\n        (\n            options.multiline &&\n            objectProperties.length > 0 &&\n            first.loc.start.line !== last.loc.end.line\n        );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent line breaks after opening and before closing braces\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/object-curly-newline\"\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    OPTION_VALUE,\n                    {\n                        type: \"object\",\n                        properties: {\n                            ObjectExpression: OPTION_VALUE,\n                            ObjectPattern: OPTION_VALUE,\n                            ImportDeclaration: OPTION_VALUE,\n                            ExportDeclaration: OPTION_VALUE\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unexpectedLinebreakBeforeClosingBrace: \"Unexpected line break before this closing brace.\",\n            unexpectedLinebreakAfterOpeningBrace: \"Unexpected line break after this opening brace.\",\n            expectedLinebreakBeforeClosingBrace: \"Expected a line break before this closing brace.\",\n            expectedLinebreakAfterOpeningBrace: \"Expected a line break after this opening brace.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const normalizedOptions = normalizeOptions(context.options[0]);\n\n        /**\n         * Reports a given node if it violated this rule.\n         * @param {ASTNode} node A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.\n         * @returns {void}\n         */\n        function check(node) {\n            const options = normalizedOptions[node.type];\n\n            if (\n                (node.type === \"ImportDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) ||\n                (node.type === \"ExportNamedDeclaration\" &&\n                    !node.specifiers.some(specifier => specifier.type === \"ExportSpecifier\"))\n            ) {\n                return;\n            }\n\n            const openBrace = sourceCode.getFirstToken(node, token => token.value === \"{\");\n\n            let closeBrace;\n\n            if (node.typeAnnotation) {\n                closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);\n            } else {\n                closeBrace = sourceCode.getLastToken(node, token => token.value === \"}\");\n            }\n\n            let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });\n            let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\n\n            const needsLineBreaks = areLineBreaksRequired(node, options, first, last);\n\n            const hasCommentsFirstToken = astUtils.isCommentToken(first);\n            const hasCommentsLastToken = astUtils.isCommentToken(last);\n\n            /*\n             * Use tokens or comments to check multiline or not.\n             * But use only tokens to check whether line breaks are needed.\n             * This allows:\n             *     var obj = { // eslint-disable-line foo\n             *         a: 1\n             *     }\n             */\n            first = sourceCode.getTokenAfter(openBrace);\n            last = sourceCode.getTokenBefore(closeBrace);\n\n            if (needsLineBreaks) {\n                if (astUtils.isTokenOnSameLine(openBrace, first)) {\n                    context.report({\n                        messageId: \"expectedLinebreakAfterOpeningBrace\",\n                        node,\n                        loc: openBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextAfter(openBrace, \"\\n\");\n                        }\n                    });\n                }\n                if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n                    context.report({\n                        messageId: \"expectedLinebreakBeforeClosingBrace\",\n                        node,\n                        loc: closeBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.insertTextBefore(closeBrace, \"\\n\");\n                        }\n                    });\n                }\n            } else {\n                const consistent = options.consistent;\n                const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\n                const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\n\n                if (\n                    (!consistent && hasLineBreakBetweenOpenBraceAndFirst) ||\n                    (consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        messageId: \"unexpectedLinebreakAfterOpeningBrace\",\n                        node,\n                        loc: openBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsFirstToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                openBrace.range[1],\n                                first.range[0]\n                            ]);\n                        }\n                    });\n                }\n                if (\n                    (!consistent && hasLineBreakBetweenCloseBraceAndLast) ||\n                    (consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast)\n                ) {\n                    context.report({\n                        messageId: \"unexpectedLinebreakBeforeClosingBrace\",\n                        node,\n                        loc: closeBrace.loc,\n                        fix(fixer) {\n                            if (hasCommentsLastToken) {\n                                return null;\n                            }\n\n                            return fixer.removeRange([\n                                last.range[1],\n                                closeBrace.range[0]\n                            ]);\n                        }\n                    });\n                }\n            }\n        }\n\n        return {\n            ObjectExpression: check,\n            ObjectPattern: check,\n            ImportDeclaration: check,\n            ExportNamedDeclaration: check\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}