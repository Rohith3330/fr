{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _classCallCheck = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(genTrue),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(getCachedValue),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime().mark(getCachedValueOrWait);\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertSimpleType = assertSimpleType;\nexports.makeStrongCache = makeStrongCache;\nexports.makeStrongCacheSync = makeStrongCacheSync;\nexports.makeWeakCache = makeWeakCache;\nexports.makeWeakCacheSync = makeWeakCacheSync;\n\nfunction _gensync() {\n  var data = require(\"gensync\");\n\n  _gensync = function _gensync() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nvar synchronize = function synchronize(gen) {\n  return _gensync()(gen).sync;\n};\n\nfunction genTrue() {\n  return _regeneratorRuntime().wrap(function genTrue$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", true);\n\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction makeWeakCache(handler) {\n  return makeCachedFunction(WeakMap, handler);\n}\n\nfunction makeWeakCacheSync(handler) {\n  return synchronize(makeWeakCache(handler));\n}\n\nfunction makeStrongCache(handler) {\n  return makeCachedFunction(Map, handler);\n}\n\nfunction makeStrongCacheSync(handler) {\n  return synchronize(makeStrongCache(handler));\n}\n\nfunction makeCachedFunction(CallCache, handler) {\n  var callCacheSync = new CallCache();\n  var callCacheAsync = new CallCache();\n  var futureCache = new CallCache();\n  return /*#__PURE__*/_regeneratorRuntime().mark(function cachedFunction(arg, data) {\n    var asyncContext, callCache, cached, cache, handlerResult, finishLock, value;\n    return _regeneratorRuntime().wrap(function cachedFunction$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.delegateYield((0, _async.isAsync)(), \"t0\", 1);\n\n          case 1:\n            asyncContext = _context2.t0;\n            callCache = asyncContext ? callCacheAsync : callCacheSync;\n            return _context2.delegateYield(getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data), \"t1\", 4);\n\n          case 4:\n            cached = _context2.t1;\n\n            if (!cached.valid) {\n              _context2.next = 7;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", cached.value);\n\n          case 7:\n            cache = new CacheConfigurator(data);\n            handlerResult = handler(arg, cache);\n\n            if (!(0, _util.isIterableIterator)(handlerResult)) {\n              _context2.next = 14;\n              break;\n            }\n\n            return _context2.delegateYield((0, _async.onFirstPause)(handlerResult, function () {\n              finishLock = setupAsyncLocks(cache, futureCache, arg);\n            }), \"t2\", 11);\n\n          case 11:\n            value = _context2.t2;\n            _context2.next = 15;\n            break;\n\n          case 14:\n            value = handlerResult;\n\n          case 15:\n            updateFunctionCache(callCache, cache, arg, value);\n\n            if (finishLock) {\n              futureCache.delete(arg);\n              finishLock.release(value);\n            }\n\n            return _context2.abrupt(\"return\", value);\n\n          case 18:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, cachedFunction);\n  });\n}\n\nfunction getCachedValue(cache, arg, data) {\n  var cachedValue, _iterator, _step, _step$value, value, valid;\n\n  return _regeneratorRuntime().wrap(function getCachedValue$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          cachedValue = cache.get(arg);\n\n          if (!cachedValue) {\n            _context3.next = 20;\n            break;\n          }\n\n          _iterator = _createForOfIteratorHelper(cachedValue);\n          _context3.prev = 3;\n\n          _iterator.s();\n\n        case 5:\n          if ((_step = _iterator.n()).done) {\n            _context3.next = 12;\n            break;\n          }\n\n          _step$value = _step.value, value = _step$value.value, valid = _step$value.valid;\n          return _context3.delegateYield(valid(data), \"t0\", 8);\n\n        case 8:\n          if (!_context3.t0) {\n            _context3.next = 10;\n            break;\n          }\n\n          return _context3.abrupt(\"return\", {\n            valid: true,\n            value: value\n          });\n\n        case 10:\n          _context3.next = 5;\n          break;\n\n        case 12:\n          _context3.next = 17;\n          break;\n\n        case 14:\n          _context3.prev = 14;\n          _context3.t1 = _context3[\"catch\"](3);\n\n          _iterator.e(_context3.t1);\n\n        case 17:\n          _context3.prev = 17;\n\n          _iterator.f();\n\n          return _context3.finish(17);\n\n        case 20:\n          return _context3.abrupt(\"return\", {\n            valid: false,\n            value: null\n          });\n\n        case 21:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked2, null, [[3, 14, 17, 20]]);\n}\n\nfunction getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {\n  var cached, _cached, value;\n\n  return _regeneratorRuntime().wrap(function getCachedValueOrWait$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          return _context4.delegateYield(getCachedValue(callCache, arg, data), \"t0\", 1);\n\n        case 1:\n          cached = _context4.t0;\n\n          if (!cached.valid) {\n            _context4.next = 4;\n            break;\n          }\n\n          return _context4.abrupt(\"return\", cached);\n\n        case 4:\n          if (!asyncContext) {\n            _context4.next = 11;\n            break;\n          }\n\n          return _context4.delegateYield(getCachedValue(futureCache, arg, data), \"t1\", 6);\n\n        case 6:\n          _cached = _context4.t1;\n\n          if (!_cached.valid) {\n            _context4.next = 11;\n            break;\n          }\n\n          return _context4.delegateYield((0, _async.waitFor)(_cached.value.promise), \"t2\", 9);\n\n        case 9:\n          value = _context4.t2;\n          return _context4.abrupt(\"return\", {\n            valid: true,\n            value: value\n          });\n\n        case 11:\n          return _context4.abrupt(\"return\", {\n            valid: false,\n            value: null\n          });\n\n        case 12:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked3);\n}\n\nfunction setupAsyncLocks(config, futureCache, arg) {\n  var finishLock = new Lock();\n  updateFunctionCache(futureCache, config, arg, finishLock);\n  return finishLock;\n}\n\nfunction updateFunctionCache(cache, config, arg, value) {\n  if (!config.configured()) config.forever();\n  var cachedValue = cache.get(arg);\n  config.deactivate();\n\n  switch (config.mode()) {\n    case \"forever\":\n      cachedValue = [{\n        value: value,\n        valid: genTrue\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"invalidate\":\n      cachedValue = [{\n        value: value,\n        valid: config.validator()\n      }];\n      cache.set(arg, cachedValue);\n      break;\n\n    case \"valid\":\n      if (cachedValue) {\n        cachedValue.push({\n          value: value,\n          valid: config.validator()\n        });\n      } else {\n        cachedValue = [{\n          value: value,\n          valid: config.validator()\n        }];\n        cache.set(arg, cachedValue);\n      }\n\n  }\n}\n\nvar CacheConfigurator = /*#__PURE__*/function () {\n  function CacheConfigurator(data) {\n    _classCallCheck(this, CacheConfigurator);\n\n    this._active = true;\n    this._never = false;\n    this._forever = false;\n    this._invalidate = false;\n    this._configured = false;\n    this._pairs = [];\n    this._data = void 0;\n    this._data = data;\n  }\n\n  _createClass(CacheConfigurator, [{\n    key: \"simple\",\n    value: function simple() {\n      return makeSimpleConfigurator(this);\n    }\n  }, {\n    key: \"mode\",\n    value: function mode() {\n      if (this._never) return \"never\";\n      if (this._forever) return \"forever\";\n      if (this._invalidate) return \"invalidate\";\n      return \"valid\";\n    }\n  }, {\n    key: \"forever\",\n    value: function forever() {\n      if (!this._active) {\n        throw new Error(\"Cannot change caching after evaluation has completed.\");\n      }\n\n      if (this._never) {\n        throw new Error(\"Caching has already been configured with .never()\");\n      }\n\n      this._forever = true;\n      this._configured = true;\n    }\n  }, {\n    key: \"never\",\n    value: function never() {\n      if (!this._active) {\n        throw new Error(\"Cannot change caching after evaluation has completed.\");\n      }\n\n      if (this._forever) {\n        throw new Error(\"Caching has already been configured with .forever()\");\n      }\n\n      this._never = true;\n      this._configured = true;\n    }\n  }, {\n    key: \"using\",\n    value: function using(handler) {\n      var _this = this;\n\n      if (!this._active) {\n        throw new Error(\"Cannot change caching after evaluation has completed.\");\n      }\n\n      if (this._never || this._forever) {\n        throw new Error(\"Caching has already been configured with .never or .forever()\");\n      }\n\n      this._configured = true;\n      var key = handler(this._data);\n      var fn = (0, _async.maybeAsync)(handler, \"You appear to be using an async cache handler, but Babel has been called synchronously\");\n\n      if ((0, _async.isThenable)(key)) {\n        return key.then(function (key) {\n          _this._pairs.push([key, fn]);\n\n          return key;\n        });\n      }\n\n      this._pairs.push([key, fn]);\n\n      return key;\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(handler) {\n      this._invalidate = true;\n      return this.using(handler);\n    }\n  }, {\n    key: \"validator\",\n    value: function validator() {\n      var pairs = this._pairs;\n      return /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data) {\n        var _iterator2, _step2, _step2$value, key, fn;\n\n        return _regeneratorRuntime().wrap(function _callee$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _iterator2 = _createForOfIteratorHelper(pairs);\n                _context5.prev = 1;\n\n                _iterator2.s();\n\n              case 3:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                _step2$value = _slicedToArray(_step2.value, 2), key = _step2$value[0], fn = _step2$value[1];\n                _context5.t0 = key;\n                return _context5.delegateYield(fn(data), \"t1\", 7);\n\n              case 7:\n                _context5.t2 = _context5.t1;\n\n                if (!(_context5.t0 !== _context5.t2)) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", false);\n\n              case 10:\n                _context5.next = 3;\n                break;\n\n              case 12:\n                _context5.next = 17;\n                break;\n\n              case 14:\n                _context5.prev = 14;\n                _context5.t3 = _context5[\"catch\"](1);\n\n                _iterator2.e(_context5.t3);\n\n              case 17:\n                _context5.prev = 17;\n\n                _iterator2.f();\n\n                return _context5.finish(17);\n\n              case 20:\n                return _context5.abrupt(\"return\", true);\n\n              case 21:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee, null, [[1, 14, 17, 20]]);\n      });\n    }\n  }, {\n    key: \"deactivate\",\n    value: function deactivate() {\n      this._active = false;\n    }\n  }, {\n    key: \"configured\",\n    value: function configured() {\n      return this._configured;\n    }\n  }]);\n\n  return CacheConfigurator;\n}();\n\nfunction makeSimpleConfigurator(cache) {\n  function cacheFn(val) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();else cache.never();\n      return;\n    }\n\n    return cache.using(function () {\n      return assertSimpleType(val());\n    });\n  }\n\n  cacheFn.forever = function () {\n    return cache.forever();\n  };\n\n  cacheFn.never = function () {\n    return cache.never();\n  };\n\n  cacheFn.using = function (cb) {\n    return cache.using(function () {\n      return assertSimpleType(cb());\n    });\n  };\n\n  cacheFn.invalidate = function (cb) {\n    return cache.invalidate(function () {\n      return assertSimpleType(cb());\n    });\n  };\n\n  return cacheFn;\n}\n\nfunction assertSimpleType(value) {\n  if ((0, _async.isThenable)(value)) {\n    throw new Error(\"You appear to be using an async cache handler, \" + \"which your current version of Babel does not support. \" + \"We may add support for this in the future, \" + \"but if you're on the most recent version of @babel/core and still \" + \"seeing this error, then you'll need to synchronously handle your caching logic.\");\n  }\n\n  if (value != null && typeof value !== \"string\" && typeof value !== \"boolean\" && typeof value !== \"number\") {\n    throw new Error(\"Cache keys must be either string, boolean, number, null, or undefined.\");\n  }\n\n  return value;\n}\n\nvar Lock = /*#__PURE__*/function () {\n  function Lock() {\n    var _this2 = this;\n\n    _classCallCheck(this, Lock);\n\n    this.released = false;\n    this.promise = void 0;\n    this._resolve = void 0;\n    this.promise = new Promise(function (resolve) {\n      _this2._resolve = resolve;\n    });\n  }\n\n  _createClass(Lock, [{\n    key: \"release\",\n    value: function release(value) {\n      this.released = true;\n\n      this._resolve(value);\n    }\n  }]);\n\n  return Lock;\n}();\n\n0 && 0;","map":{"version":3,"mappings":"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","names":["genTrue","getCachedValue","getCachedValueOrWait","_gensync","synchronize","gen","gensync","sync","makeWeakCache","handler","makeCachedFunction","WeakMap","makeWeakCacheSync","makeStrongCache","Map","makeStrongCacheSync","CallCache","callCacheSync","callCacheAsync","futureCache","cachedFunction","arg","data","asyncContext","callCache","cached","valid","value","cache","CacheConfigurator","handlerResult","finishLock","setupAsyncLocks","updateFunctionCache","delete","release","cachedValue","get","promise","config","Lock","configured","forever","deactivate","mode","set","validator","push","constructor","_active","_never","_forever","_invalidate","_configured","_pairs","_data","simple","makeSimpleConfigurator","Error","never","using","key","fn","then","invalidate","pairs","cacheFn","val","assertSimpleType","cb","released","_resolve","Promise","resolve"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\caching.ts"],"sourcesContent":["import gensync from \"gensync\";\nimport type { Handler } from \"gensync\";\nimport {\n  maybeAsync,\n  isAsync,\n  onFirstPause,\n  waitFor,\n  isThenable,\n} from \"../gensync-utils/async\";\nimport { isIterableIterator } from \"./util\";\n\nexport type { CacheConfigurator };\n\nexport type SimpleCacheConfigurator = {\n  (forever: boolean): void;\n  <T>(handler: () => T): T;\n\n  forever: () => void;\n  never: () => void;\n  using: <T>(handler: () => T) => T;\n  invalidate: <T>(handler: () => T) => T;\n};\n\nexport type CacheEntry<ResultT, SideChannel> = Array<{\n  value: ResultT;\n  valid: (channel: SideChannel) => Handler<boolean>;\n}>;\n\nconst synchronize = <ArgsT extends unknown[], ResultT>(\n  gen: (...args: ArgsT) => Handler<ResultT>,\n): ((...args: ArgsT) => ResultT) => {\n  return gensync(gen).sync;\n};\n\n// eslint-disable-next-line require-yield\nfunction* genTrue() {\n  return true;\n}\n\nexport function makeWeakCache<ArgT extends object, ResultT, SideChannel>(\n  handler: (\n    arg: ArgT,\n    cache: CacheConfigurator<SideChannel>,\n  ) => Handler<ResultT> | ResultT,\n): (arg: ArgT, data: SideChannel) => Handler<ResultT> {\n  return makeCachedFunction<ArgT, ResultT, SideChannel>(WeakMap, handler);\n}\n\nexport function makeWeakCacheSync<ArgT extends object, ResultT, SideChannel>(\n  handler: (arg: ArgT, cache?: CacheConfigurator<SideChannel>) => ResultT,\n): (arg: ArgT, data?: SideChannel) => ResultT {\n  return synchronize<[ArgT, SideChannel], ResultT>(\n    makeWeakCache<ArgT, ResultT, SideChannel>(handler),\n  );\n}\n\nexport function makeStrongCache<ArgT, ResultT, SideChannel>(\n  handler: (\n    arg: ArgT,\n    cache: CacheConfigurator<SideChannel>,\n  ) => Handler<ResultT> | ResultT,\n): (arg: ArgT, data: SideChannel) => Handler<ResultT> {\n  return makeCachedFunction<ArgT, ResultT, SideChannel>(Map, handler);\n}\n\nexport function makeStrongCacheSync<ArgT, ResultT, SideChannel>(\n  handler: (arg: ArgT, cache?: CacheConfigurator<SideChannel>) => ResultT,\n): (arg: ArgT, data?: SideChannel) => ResultT {\n  return synchronize<[ArgT, SideChannel], ResultT>(\n    makeStrongCache<ArgT, ResultT, SideChannel>(handler),\n  );\n}\n\n/* NOTE: Part of the logic explained in this comment is explained in the\n *       getCachedValueOrWait and setupAsyncLocks functions.\n *\n * > There are only two hard things in Computer Science: cache invalidation and naming things.\n * > -- Phil Karlton\n *\n * I don't know if Phil was also thinking about handling a cache whose invalidation function is\n * defined asynchronously is considered, but it is REALLY hard to do correctly.\n *\n * The implemented logic (only when gensync is run asynchronously) is the following:\n *   1. If there is a valid cache associated to the current \"arg\" parameter,\n *       a. RETURN the cached value\n *   3. If there is a FinishLock associated to the current \"arg\" parameter representing a valid cache,\n *       a. Wait for that lock to be released\n *       b. RETURN the value associated with that lock\n *   5. Start executing the function to be cached\n *       a. If it pauses on a promise, then\n *           i. Let FinishLock be a new lock\n *          ii. Store FinishLock as associated to the current \"arg\" parameter\n *         iii. Wait for the function to finish executing\n *          iv. Release FinishLock\n *           v. Send the function result to anyone waiting on FinishLock\n *   6. Store the result in the cache\n *   7. RETURN the result\n */\nfunction makeCachedFunction<ArgT, ResultT, SideChannel>(\n  CallCache: new <Cached>() => CacheMap<ArgT, Cached, SideChannel>,\n  handler: (\n    arg: ArgT,\n    cache: CacheConfigurator<SideChannel>,\n  ) => Handler<ResultT> | ResultT,\n): (arg: ArgT, data: SideChannel) => Handler<ResultT> {\n  const callCacheSync = new CallCache<ResultT>();\n  const callCacheAsync = new CallCache<ResultT>();\n  const futureCache = new CallCache<Lock<ResultT>>();\n\n  return function* cachedFunction(arg: ArgT, data: SideChannel) {\n    const asyncContext = yield* isAsync();\n    const callCache = asyncContext ? callCacheAsync : callCacheSync;\n\n    const cached = yield* getCachedValueOrWait<ArgT, ResultT, SideChannel>(\n      asyncContext,\n      callCache,\n      futureCache,\n      arg,\n      data,\n    );\n    if (cached.valid) return cached.value;\n\n    const cache = new CacheConfigurator(data);\n\n    const handlerResult: Handler<ResultT> | ResultT = handler(arg, cache);\n\n    let finishLock: Lock<ResultT>;\n    let value: ResultT;\n\n    if (isIterableIterator(handlerResult)) {\n      value = yield* onFirstPause(handlerResult, () => {\n        finishLock = setupAsyncLocks(cache, futureCache, arg);\n      });\n    } else {\n      value = handlerResult;\n    }\n\n    updateFunctionCache(callCache, cache, arg, value);\n\n    if (finishLock) {\n      futureCache.delete(arg);\n      finishLock.release(value);\n    }\n\n    return value;\n  };\n}\n\ntype CacheMap<ArgT, ResultT, SideChannel> =\n  | Map<ArgT, CacheEntry<ResultT, SideChannel>>\n  // @ts-expect-error todo(flow->ts): add `extends object` constraint to ArgT\n  | WeakMap<ArgT, CacheEntry<ResultT, SideChannel>>;\n\nfunction* getCachedValue<ArgT, ResultT, SideChannel>(\n  cache: CacheMap<ArgT, ResultT, SideChannel>,\n  arg: ArgT,\n  data: SideChannel,\n): Handler<{ valid: true; value: ResultT } | { valid: false; value: null }> {\n  const cachedValue: CacheEntry<ResultT, SideChannel> | void = cache.get(arg);\n\n  if (cachedValue) {\n    for (const { value, valid } of cachedValue) {\n      if (yield* valid(data)) return { valid: true, value };\n    }\n  }\n\n  return { valid: false, value: null };\n}\n\nfunction* getCachedValueOrWait<ArgT, ResultT, SideChannel>(\n  asyncContext: boolean,\n  callCache: CacheMap<ArgT, ResultT, SideChannel>,\n  futureCache: CacheMap<ArgT, Lock<ResultT>, SideChannel>,\n  arg: ArgT,\n  data: SideChannel,\n): Handler<{ valid: true; value: ResultT } | { valid: false; value: null }> {\n  const cached = yield* getCachedValue(callCache, arg, data);\n  if (cached.valid) {\n    return cached;\n  }\n\n  if (asyncContext) {\n    const cached = yield* getCachedValue(futureCache, arg, data);\n    if (cached.valid) {\n      const value = yield* waitFor<ResultT>(cached.value.promise);\n      return { valid: true, value };\n    }\n  }\n\n  return { valid: false, value: null };\n}\n\nfunction setupAsyncLocks<ArgT, ResultT, SideChannel>(\n  config: CacheConfigurator<SideChannel>,\n  futureCache: CacheMap<ArgT, Lock<ResultT>, SideChannel>,\n  arg: ArgT,\n): Lock<ResultT> {\n  const finishLock = new Lock<ResultT>();\n\n  updateFunctionCache(futureCache, config, arg, finishLock);\n\n  return finishLock;\n}\n\nfunction updateFunctionCache<\n  ArgT,\n  ResultT,\n  SideChannel,\n  Cache extends CacheMap<ArgT, ResultT, SideChannel>,\n>(\n  cache: Cache,\n  config: CacheConfigurator<SideChannel>,\n  arg: ArgT,\n  value: ResultT,\n) {\n  if (!config.configured()) config.forever();\n\n  let cachedValue: CacheEntry<ResultT, SideChannel> | void = cache.get(arg);\n\n  config.deactivate();\n\n  switch (config.mode()) {\n    case \"forever\":\n      cachedValue = [{ value, valid: genTrue }];\n      cache.set(arg, cachedValue);\n      break;\n    case \"invalidate\":\n      cachedValue = [{ value, valid: config.validator() }];\n      cache.set(arg, cachedValue);\n      break;\n    case \"valid\":\n      if (cachedValue) {\n        cachedValue.push({ value, valid: config.validator() });\n      } else {\n        cachedValue = [{ value, valid: config.validator() }];\n        cache.set(arg, cachedValue);\n      }\n  }\n}\n\nclass CacheConfigurator<SideChannel = void> {\n  _active: boolean = true;\n  _never: boolean = false;\n  _forever: boolean = false;\n  _invalidate: boolean = false;\n\n  _configured: boolean = false;\n\n  _pairs: Array<\n    [cachedValue: unknown, handler: (data: SideChannel) => Handler<unknown>]\n  > = [];\n\n  _data: SideChannel;\n\n  constructor(data: SideChannel) {\n    this._data = data;\n  }\n\n  simple() {\n    return makeSimpleConfigurator(this);\n  }\n\n  mode() {\n    if (this._never) return \"never\";\n    if (this._forever) return \"forever\";\n    if (this._invalidate) return \"invalidate\";\n    return \"valid\";\n  }\n\n  forever() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n    if (this._never) {\n      throw new Error(\"Caching has already been configured with .never()\");\n    }\n    this._forever = true;\n    this._configured = true;\n  }\n\n  never() {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n    if (this._forever) {\n      throw new Error(\"Caching has already been configured with .forever()\");\n    }\n    this._never = true;\n    this._configured = true;\n  }\n\n  using<T>(handler: (data: SideChannel) => T): T {\n    if (!this._active) {\n      throw new Error(\"Cannot change caching after evaluation has completed.\");\n    }\n    if (this._never || this._forever) {\n      throw new Error(\n        \"Caching has already been configured with .never or .forever()\",\n      );\n    }\n    this._configured = true;\n\n    const key = handler(this._data);\n\n    const fn = maybeAsync(\n      handler,\n      `You appear to be using an async cache handler, but Babel has been called synchronously`,\n    );\n\n    if (isThenable(key)) {\n      // @ts-expect-error todo(flow->ts): improve function return type annotation\n      return key.then((key: unknown) => {\n        this._pairs.push([key, fn]);\n        return key;\n      });\n    }\n\n    this._pairs.push([key, fn]);\n    return key;\n  }\n\n  invalidate<T>(handler: (data: SideChannel) => T): T {\n    this._invalidate = true;\n    return this.using(handler);\n  }\n\n  validator(): (data: SideChannel) => Handler<boolean> {\n    const pairs = this._pairs;\n    return function* (data: SideChannel) {\n      for (const [key, fn] of pairs) {\n        if (key !== (yield* fn(data))) return false;\n      }\n      return true;\n    };\n  }\n\n  deactivate() {\n    this._active = false;\n  }\n\n  configured() {\n    return this._configured;\n  }\n}\n\nfunction makeSimpleConfigurator(\n  cache: CacheConfigurator<any>,\n): SimpleCacheConfigurator {\n  function cacheFn(val: any) {\n    if (typeof val === \"boolean\") {\n      if (val) cache.forever();\n      else cache.never();\n      return;\n    }\n\n    return cache.using(() => assertSimpleType(val()));\n  }\n  cacheFn.forever = () => cache.forever();\n  cacheFn.never = () => cache.never();\n  cacheFn.using = (cb: { (): SimpleType }) =>\n    cache.using(() => assertSimpleType(cb()));\n  cacheFn.invalidate = (cb: { (): SimpleType }) =>\n    cache.invalidate(() => assertSimpleType(cb()));\n\n  return cacheFn as any;\n}\n\n// Types are limited here so that in the future these values can be used\n// as part of Babel's caching logic.\nexport type SimpleType =\n  | string\n  | boolean\n  | number\n  | null\n  | void\n  | Promise<SimpleType>;\nexport function assertSimpleType(value: unknown): SimpleType {\n  if (isThenable(value)) {\n    throw new Error(\n      `You appear to be using an async cache handler, ` +\n        `which your current version of Babel does not support. ` +\n        `We may add support for this in the future, ` +\n        `but if you're on the most recent version of @babel/core and still ` +\n        `seeing this error, then you'll need to synchronously handle your caching logic.`,\n    );\n  }\n\n  if (\n    value != null &&\n    typeof value !== \"string\" &&\n    typeof value !== \"boolean\" &&\n    typeof value !== \"number\"\n  ) {\n    throw new Error(\n      \"Cache keys must be either string, boolean, number, null, or undefined.\",\n    );\n  }\n  // @ts-expect-error Type 'unknown' is not assignable to type 'SimpleType'. This can be removed\n  // when strictNullCheck is enabled\n  return value;\n}\n\nclass Lock<T> {\n  released: boolean = false;\n  promise: Promise<T>;\n  _resolve: (value: T) => void;\n\n  constructor() {\n    this.promise = new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n  release(value: T) {\n    this.released = true;\n    this._resolve(value);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}