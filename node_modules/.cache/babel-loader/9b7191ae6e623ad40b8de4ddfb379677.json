{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;\n\nconst codegen_1 = require(\"../compile/codegen\");\n\nconst util_1 = require(\"../compile/util\");\n\nconst names_1 = require(\"../compile/names\");\n\nconst util_2 = require(\"../compile/util\");\n\nfunction checkReportMissingProp(cxt, prop) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({\n      missingProperty: (0, codegen_1._)`${prop}`\n    }, true);\n    cxt.error();\n  });\n}\n\nexports.checkReportMissingProp = checkReportMissingProp;\n\nfunction checkMissingProp(_ref, properties, missing) {\n  let {\n    gen,\n    data,\n    it: {\n      opts\n    }\n  } = _ref;\n  return (0, codegen_1.or)(...properties.map(prop => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));\n}\n\nexports.checkMissingProp = checkMissingProp;\n\nfunction reportMissingProp(cxt, missing) {\n  cxt.setParams({\n    missingProperty: missing\n  }, true);\n  cxt.error();\n}\n\nexports.reportMissingProp = reportMissingProp;\n\nfunction hasPropFunc(gen) {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: (0, codegen_1._)`Object.prototype.hasOwnProperty`\n  });\n}\n\nexports.hasPropFunc = hasPropFunc;\n\nfunction isOwnProperty(gen, data, property) {\n  return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;\n}\n\nexports.isOwnProperty = isOwnProperty;\n\nfunction propertyInData(gen, data, property, ownProperties) {\n  const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;\n  return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;\n}\n\nexports.propertyInData = propertyInData;\n\nfunction noPropertyInData(gen, data, property, ownProperties) {\n  const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;\n  return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;\n}\n\nexports.noPropertyInData = noPropertyInData;\n\nfunction allSchemaProperties(schemaMap) {\n  return schemaMap ? Object.keys(schemaMap).filter(p => p !== \"__proto__\") : [];\n}\n\nexports.allSchemaProperties = allSchemaProperties;\n\nfunction schemaProperties(it, schemaMap) {\n  return allSchemaProperties(schemaMap).filter(p => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));\n}\n\nexports.schemaProperties = schemaProperties;\n\nfunction callValidateCode(_ref2, func, context, passSchema) {\n  let {\n    schemaCode,\n    data,\n    it: {\n      gen,\n      topSchemaRef,\n      schemaPath,\n      errorPath\n    },\n    it\n  } = _ref2;\n  const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;\n  const valCxt = [[names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)], [names_1.default.parentData, it.parentData], [names_1.default.parentDataProperty, it.parentDataProperty], [names_1.default.rootData, names_1.default.rootData]];\n  if (it.opts.dynamicRef) valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);\n  const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;\n  return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;\n}\n\nexports.callValidateCode = callValidateCode;\nconst newRegExp = (0, codegen_1._)`new RegExp`;\n\nfunction usePattern(_ref3, pattern) {\n  let {\n    gen,\n    it: {\n      opts\n    }\n  } = _ref3;\n  const u = opts.unicodeRegExp ? \"u\" : \"\";\n  const {\n    regExp\n  } = opts.code;\n  const rx = regExp(pattern, u);\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: (0, codegen_1._)`${regExp.code === \"new RegExp\" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`\n  });\n}\n\nexports.usePattern = usePattern;\n\nfunction validateArray(cxt) {\n  const {\n    gen,\n    data,\n    keyword,\n    it\n  } = cxt;\n  const valid = gen.name(\"valid\");\n\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true);\n    validateItems(() => gen.assign(validArr, false));\n    return validArr;\n  }\n\n  gen.var(valid, true);\n  validateItems(() => gen.break());\n  return valid;\n\n  function validateItems(notValid) {\n    const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n    gen.forRange(\"i\", 0, len, i => {\n      cxt.subschema({\n        keyword,\n        dataProp: i,\n        dataPropType: util_1.Type.Num\n      }, valid);\n      gen.if((0, codegen_1.not)(valid), notValid);\n    });\n  }\n}\n\nexports.validateArray = validateArray;\n\nfunction validateUnion(cxt) {\n  const {\n    gen,\n    schema,\n    keyword,\n    it\n  } = cxt;\n  /* istanbul ignore if */\n\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\");\n  const alwaysValid = schema.some(sch => (0, util_1.alwaysValidSchema)(it, sch));\n  if (alwaysValid && !it.opts.unevaluated) return;\n  const valid = gen.let(\"valid\", false);\n  const schValid = gen.name(\"_valid\");\n  gen.block(() => schema.forEach((_sch, i) => {\n    const schCxt = cxt.subschema({\n      keyword,\n      schemaProp: i,\n      compositeRule: true\n    }, schValid);\n    gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);\n    const merged = cxt.mergeValidEvaluated(schCxt, schValid); // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n    // or if all properties and items were evaluated (it.props === true && it.items === true)\n\n    if (!merged) gen.if((0, codegen_1.not)(valid));\n  }));\n  cxt.result(valid, () => cxt.reset(), () => cxt.error(true));\n}\n\nexports.validateUnion = validateUnion;","map":{"version":3,"mappings":"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","names":["checkReportMissingProp","cxt","prop","gen","data","it","if","noPropertyInData","opts","ownProperties","setParams","missingProperty","error","exports","checkMissingProp","properties","missing","map","reportMissingProp","hasPropFunc","scopeValue","ref","Object","prototype","hasOwnProperty","code","isOwnProperty","property","propertyInData","cond","allSchemaProperties","schemaMap","keys","filter","p","schemaProperties","callValidateCode","func","context","passSchema","schemaCode","topSchemaRef","schemaPath","errorPath","dataAndSchema","valCxt","names_1","instancePath","parentData","parentDataProperty","rootData","dynamicRef","push","dynamicAnchors","args","object","codegen_1","newRegExp","usePattern","pattern","u","unicodeRegExp","regExp","rx","key","toString","validateArray","keyword","valid","name","allErrors","validArr","let","validateItems","assign","var","break","notValid","len","const","forRange","i","subschema","dataProp","dataPropType","util_1","Num","validateUnion","schema","Array","isArray","Error","alwaysValid","some","sch","unevaluated","schValid","block","forEach","_sch","schCxt","schemaProp","compositeRule","merged","mergeValidEvaluated","result","reset"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\mini-css-extract-plugin\\node_modules\\ajv\\lib\\vocabularies\\code.ts"],"sourcesContent":["import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n"]},"metadata":{},"sourceType":"script"}