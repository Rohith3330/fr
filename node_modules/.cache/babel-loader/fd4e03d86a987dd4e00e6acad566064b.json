{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _helperSkipTransparentExpressionWrappers = require(\"@babel/helper-skip-transparent-expression-wrappers\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption, _options$allowArrayLi;\n\n  api.assertVersion(7);\n  const iterableIsArray = (_api$assumption = api.assumption(\"iterableIsArray\")) != null ? _api$assumption : options.loose;\n  const arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption(\"arrayLikeIsIterable\");\n\n  function getSpreadLiteral(spread, scope) {\n    if (iterableIsArray && !_core.types.isIdentifier(spread.argument, {\n      name: \"arguments\"\n    })) {\n      return spread.argument;\n    } else {\n      return scope.toArray(spread.argument, true, arrayLikeIsIterable);\n    }\n  }\n\n  function hasHole(spread) {\n    return spread.elements.some(el => el === null);\n  }\n\n  function hasSpread(nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      if (_core.types.isSpreadElement(nodes[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function push(_props, nodes) {\n    if (!_props.length) return _props;\n    nodes.push(_core.types.arrayExpression(_props));\n    return [];\n  }\n\n  function build(props, scope, file) {\n    const nodes = [];\n    let _props = [];\n\n    for (const prop of props) {\n      if (_core.types.isSpreadElement(prop)) {\n        _props = push(_props, nodes);\n        let spreadLiteral = getSpreadLiteral(prop, scope);\n\n        if (_core.types.isArrayExpression(spreadLiteral) && hasHole(spreadLiteral)) {\n          spreadLiteral = _core.types.callExpression(file.addHelper(\"arrayWithoutHoles\"), [spreadLiteral]);\n        }\n\n        nodes.push(spreadLiteral);\n      } else {\n        _props.push(prop);\n      }\n    }\n\n    push(_props, nodes);\n    return nodes;\n  }\n\n  return {\n    name: \"transform-spread\",\n    visitor: {\n      ArrayExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const elements = node.elements;\n        if (!hasSpread(elements)) return;\n        const nodes = build(elements, scope, this.file);\n        let first = nodes[0];\n\n        if (nodes.length === 1 && first !== elements[0].argument) {\n          path.replaceWith(first);\n          return;\n        }\n\n        if (!_core.types.isArrayExpression(first)) {\n          first = _core.types.arrayExpression([]);\n        } else {\n          nodes.shift();\n        }\n\n        path.replaceWith(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes));\n      },\n\n      CallExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const args = node.arguments;\n        if (!hasSpread(args)) return;\n        const calleePath = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers)(path.get(\"callee\"));\n\n        if (calleePath.isSuper()) {\n          throw path.buildCodeFrameError(\"It's not possible to compile spread arguments in `super()` without compiling classes.\\n\" + \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\");\n        }\n\n        let contextLiteral = scope.buildUndefinedNode();\n        node.arguments = [];\n        let nodes;\n\n        if (args.length === 1 && _core.types.isIdentifier(args[0].argument, {\n          name: \"arguments\"\n        })) {\n          nodes = [args[0].argument];\n        } else {\n          nodes = build(args, scope, this.file);\n        }\n\n        const first = nodes.shift();\n\n        if (nodes.length) {\n          node.arguments.push(_core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes));\n        } else {\n          node.arguments.push(first);\n        }\n\n        const callee = calleePath.node;\n\n        if (_core.types.isMemberExpression(callee)) {\n          const temp = scope.maybeGenerateMemoised(callee.object);\n\n          if (temp) {\n            callee.object = _core.types.assignmentExpression(\"=\", temp, callee.object);\n            contextLiteral = temp;\n          } else {\n            contextLiteral = _core.types.cloneNode(callee.object);\n          }\n        }\n\n        node.callee = _core.types.memberExpression(node.callee, _core.types.identifier(\"apply\"));\n\n        if (_core.types.isSuper(contextLiteral)) {\n          contextLiteral = _core.types.thisExpression();\n        }\n\n        node.arguments.unshift(_core.types.cloneNode(contextLiteral));\n      },\n\n      NewExpression(path) {\n        const {\n          node,\n          scope\n        } = path;\n        if (!hasSpread(node.arguments)) return;\n        const nodes = build(node.arguments, scope, this.file);\n        const first = nodes.shift();\n        let args;\n\n        if (nodes.length) {\n          args = _core.types.callExpression(_core.types.memberExpression(first, _core.types.identifier(\"concat\")), nodes);\n        } else {\n          args = first;\n        }\n\n        path.replaceWith(_core.types.callExpression(path.hub.addHelper(\"construct\"), [node.callee, args]));\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AAEA;;eAUe,gCAAQ,CAACA,GAAD,EAAMC,OAAN,KAA2B;EAAA;;EAChDD,GAAG,CAACE,aAAJF,CAAkB,CAAlBA;EAEA,MAAMG,eAAe,sBAAGH,GAAG,CAACI,UAAJJ,CAAe,iBAAfA,CAAH,8BAAwCC,OAAO,CAACI,KAArE;EACA,MAAMC,mBAAmB,4BACvBL,OAAO,CAACM,cADe,oCACGP,GAAG,CAACI,UAAJJ,CAAe,qBAAfA,CAD5B;;EAGA,SAASQ,gBAAT,CACEC,MADF,EAEEC,KAFF,EAGgB;IACd,IACEP,eAAe,IACf,CAACQ,YAAEC,YAAFD,CAAeF,MAAM,CAACI,QAAtBF,EAAgC;MAAEG,IAAI,EAAE;IAAR,CAAhCH,CAFH,EAGE;MACA,OAAOF,MAAM,CAACI,QAAd;IAJF,OAKO;MACL,OAAOH,KAAK,CAACK,OAANL,CAAcD,MAAM,CAACI,QAArBH,EAA+B,IAA/BA,EAAqCJ,mBAArCI,CAAP;IACD;EACF;;EAED,SAASM,OAAT,CAAiBP,MAAjB,EAAqD;IACnD,OAAOA,MAAM,CAACQ,QAAPR,CAAgBS,IAAhBT,CAAqBU,EAAE,IAAIA,EAAE,KAAK,IAAlCV,CAAP;EACD;;EAED,SAASW,SAAT,CAAmBC,KAAnB,EAAkD;IAChD,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;MACrC,IAAIX,YAAEa,eAAFb,CAAkBU,KAAK,CAACC,CAAD,CAAvBX,CAAJ,EAAiC;QAC/B,OAAO,IAAP;MACD;IACF;;IACD,OAAO,KAAP;EACD;;EAED,SAASc,IAAT,CAAcC,MAAd,EAA0CL,KAA1C,EAAsE;IACpE,IAAI,CAACK,MAAM,CAACH,MAAZ,EAAoB,OAAOG,MAAP;IACpBL,KAAK,CAACI,IAANJ,CAAWV,YAAEgB,eAAFhB,CAAkBe,MAAlBf,CAAXU;IACA,OAAO,EAAP;EACD;;EAED,SAASO,KAAT,CACEC,KADF,EAEEnB,KAFF,EAGEoB,IAHF,EAIkB;IAChB,MAAMT,KAA0B,GAAG,EAAnC;IACA,IAAIK,MAA0B,GAAG,EAAjC;;IAEA,KAAK,MAAMK,IAAX,IAAmBF,KAAnB,EAA0B;MACxB,IAAIlB,YAAEa,eAAFb,CAAkBoB,IAAlBpB,CAAJ,EAA6B;QAC3Be,MAAM,GAAGD,IAAI,CAACC,MAAD,EAASL,KAAT,CAAbK;QACA,IAAIM,aAAa,GAAGxB,gBAAgB,CAACuB,IAAD,EAAOrB,KAAP,CAApC;;QAEA,IAAIC,YAAEsB,iBAAFtB,CAAoBqB,aAApBrB,KAAsCK,OAAO,CAACgB,aAAD,CAAjD,EAAkE;UAChEA,aAAa,GAAGrB,YAAEuB,cAAFvB,CACdmB,IAAI,CAACK,SAALL,CAGM,mBAHNA,CADcnB,EAMd,CAACqB,aAAD,CANcrB,CAAhBqB;QAQD;;QAEDX,KAAK,CAACI,IAANJ,CAAWW,aAAXX;MAfF,OAgBO;QACLK,MAAM,CAACD,IAAPC,CAAYK,IAAZL;MACD;IACF;;IAEDD,IAAI,CAACC,MAAD,EAASL,KAAT,CAAJI;IAEA,OAAOJ,KAAP;EACD;;EAED,OAAO;IACLP,IAAI,EAAE,kBADD;IAGLsB,OAAO,EAAE;MACPC,eAAe,CAACC,IAAD,EAAa;QAC1B,MAAM;UAAEC,IAAF;UAAQ7B;QAAR,IAAkB4B,IAAxB;QACA,MAAMrB,QAAQ,GAAGsB,IAAI,CAACtB,QAAtB;QACA,IAAI,CAACG,SAAS,CAACH,QAAD,CAAd,EAA0B;QAE1B,MAAMI,KAAK,GAAGO,KAAK,CAACX,QAAD,EAAWP,KAAX,EAAkB,KAAKoB,IAAvB,CAAnB;QACA,IAAIU,KAAK,GAAGnB,KAAK,CAAC,CAAD,CAAjB;;QAMA,IACEA,KAAK,CAACE,MAANF,KAAiB,CAAjBA,IACAmB,KAAK,KAAMvB,QAAQ,CAAC,CAAD,CAARA,CAAgCJ,QAF7C,EAGE;UACAyB,IAAI,CAACG,WAALH,CAAiBE,KAAjBF;UACA;QACD;;QAQD,IAAI,CAAC3B,YAAEsB,iBAAFtB,CAAoB6B,KAApB7B,CAAL,EAAiC;UAC/B6B,KAAK,GAAG7B,YAAEgB,eAAFhB,CAAkB,EAAlBA,CAAR6B;QADF,OAEO;UACLnB,KAAK,CAACqB,KAANrB;QACD;;QAEDiB,IAAI,CAACG,WAALH,CACE3B,YAAEuB,cAAFvB,CACEA,YAAEgC,gBAAFhC,CAAmB6B,KAAnB7B,EAA0BA,YAAEiC,UAAFjC,CAAa,QAAbA,CAA1BA,CADFA,EAEEU,KAFFV,CADF2B;MAjCK;;MAwCPO,cAAc,CAACP,IAAD,EAAa;QACzB,MAAM;UAAEC,IAAF;UAAQ7B;QAAR,IAAkB4B,IAAxB;QAEA,MAAMQ,IAAI,GAAGP,IAAI,CAACQ,SAAlB;QACA,IAAI,CAAC3B,SAAS,CAAC0B,IAAD,CAAd,EAAsB;QACtB,MAAME,UAAU,GAAG,0EACjBV,IAAI,CAACW,GAALX,CAAS,QAATA,CADiB,CAAnB;;QAGA,IAAIU,UAAU,CAACE,OAAXF,EAAJ,EAA0B;UAExB,MAAMV,IAAI,CAACa,mBAALb,CACJ,4FACE,2EAFEA,CAAN;QAID;;QACD,IAAIc,cAAsC,GAAG1C,KAAK,CAAC2C,kBAAN3C,EAA7C;QACA6B,IAAI,CAACQ,SAALR,GAAiB,EAAjBA;QAEA,IAAIlB,KAAJ;;QACA,IACEyB,IAAI,CAACvB,MAALuB,KAAgB,CAAhBA,IACAnC,YAAEC,YAAFD,CAAgBmC,IAAI,CAAC,CAAD,CAAJA,CAA4BjC,QAA5CF,EAAsD;UACpDG,IAAI,EAAE;QAD8C,CAAtDH,CAFF,EAKE;UACAU,KAAK,GAAG,CAAEyB,IAAI,CAAC,CAAD,CAAJA,CAA4BjC,QAA9B,CAARQ;QANF,OAOO;UACLA,KAAK,GAAGO,KAAK,CAACkB,IAAD,EAAOpC,KAAP,EAAc,KAAKoB,IAAnB,CAAbT;QACD;;QAED,MAAMmB,KAAK,GAAGnB,KAAK,CAACqB,KAANrB,EAAd;;QACA,IAAIA,KAAK,CAACE,MAAV,EAAkB;UAChBgB,IAAI,CAACQ,SAALR,CAAed,IAAfc,CACE5B,YAAEuB,cAAFvB,CACEA,YAAEgC,gBAAFhC,CAAmB6B,KAAnB7B,EAA0BA,YAAEiC,UAAFjC,CAAa,QAAbA,CAA1BA,CADFA,EAEEU,KAFFV,CADF4B;QADF,OAOO;UACLA,IAAI,CAACQ,SAALR,CAAed,IAAfc,CAAoBC,KAApBD;QACD;;QAED,MAAMe,MAAM,GAAGN,UAAU,CAACT,IAA1B;;QAEA,IAAI5B,YAAE4C,kBAAF5C,CAAqB2C,MAArB3C,CAAJ,EAAkC;UAChC,MAAM6C,IAAI,GAAG9C,KAAK,CAAC+C,qBAAN/C,CAA4B4C,MAAM,CAACI,MAAnChD,CAAb;;UACA,IAAI8C,IAAJ,EAAU;YACRF,MAAM,CAACI,MAAPJ,GAAgB3C,YAAEgD,oBAAFhD,CACd,GADcA,EAEd6C,IAFc7C,EAId2C,MAAM,CAACI,MAJO/C,CAAhB2C;YAMAF,cAAc,GAAGI,IAAjBJ;UAPF,OAQO;YACLA,cAAc,GAAGzC,YAAEiD,SAAFjD,CAAY2C,MAAM,CAACI,MAAnB/C,CAAjByC;UACD;QACF;;QAGDb,IAAI,CAACe,MAALf,GAAc5B,YAAEgC,gBAAFhC,CACZ4B,IAAI,CAACe,MADO3C,EAEZA,YAAEiC,UAAFjC,CAAa,OAAbA,CAFYA,CAAd4B;;QAIA,IAAI5B,YAAEuC,OAAFvC,CAAUyC,cAAVzC,CAAJ,EAA+B;UAC7ByC,cAAc,GAAGzC,YAAEkD,cAAFlD,EAAjByC;QACD;;QAEDb,IAAI,CAACQ,SAALR,CAAeuB,OAAfvB,CAAuB5B,YAAEiD,SAAFjD,CAAYyC,cAAZzC,CAAvB4B;MA5GK;;MA+GPwB,aAAa,CAACzB,IAAD,EAAa;QACxB,MAAM;UAAEC,IAAF;UAAQ7B;QAAR,IAAkB4B,IAAxB;QACA,IAAI,CAAClB,SAAS,CAACmB,IAAI,CAACQ,SAAN,CAAd,EAAgC;QAEhC,MAAM1B,KAAK,GAAGO,KAAK,CACjBW,IAAI,CAACQ,SADY,EAEjBrC,KAFiB,EAGjB,KAAKoB,IAHY,CAAnB;QAMA,MAAMU,KAAK,GAAGnB,KAAK,CAACqB,KAANrB,EAAd;QAEA,IAAIyB,IAAJ;;QACA,IAAIzB,KAAK,CAACE,MAAV,EAAkB;UAChBuB,IAAI,GAAGnC,YAAEuB,cAAFvB,CACLA,YAAEgC,gBAAFhC,CAAmB6B,KAAnB7B,EAA0BA,YAAEiC,UAAFjC,CAAa,QAAbA,CAA1BA,CADKA,EAELU,KAFKV,CAAPmC;QADF,OAKO;UACLA,IAAI,GAAGN,KAAPM;QACD;;QAEDR,IAAI,CAACG,WAALH,CACE3B,YAAEuB,cAAFvB,CAAiB2B,IAAI,CAAC0B,GAAL1B,CAASH,SAATG,CAAmB,WAAnBA,CAAjB3B,EAAkD,CAChD4B,IAAI,CAACe,MAD2C,EAEhDR,IAFgD,CAAlDnC,CADF2B;MAMD;;IA3IM;EAHJ,CAAP;AA3Ea","names":["api","options","assertVersion","iterableIsArray","assumption","loose","arrayLikeIsIterable","allowArrayLike","getSpreadLiteral","spread","scope","t","isIdentifier","argument","name","toArray","hasHole","elements","some","el","hasSpread","nodes","i","length","isSpreadElement","push","_props","arrayExpression","build","props","file","prop","spreadLiteral","isArrayExpression","callExpression","addHelper","visitor","ArrayExpression","path","node","first","replaceWith","shift","memberExpression","identifier","CallExpression","args","arguments","calleePath","get","isSuper","buildCodeFrameError","contextLiteral","buildUndefinedNode","callee","isMemberExpression","temp","maybeGenerateMemoised","object","assignmentExpression","cloneNode","thisExpression","unshift","NewExpression","hub"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-transform-spread\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport { skipTransparentExprWrappers } from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport type { File } from \"@babel/core\";\nimport { types as t } from \"@babel/core\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\n\ntype ListElement = t.SpreadElement | t.Expression;\n\nexport interface Options {\n  allowArrayLike?: boolean;\n  loose?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(7);\n\n  const iterableIsArray = api.assumption(\"iterableIsArray\") ?? options.loose;\n  const arrayLikeIsIterable =\n    options.allowArrayLike ?? api.assumption(\"arrayLikeIsIterable\");\n\n  function getSpreadLiteral(\n    spread: t.SpreadElement,\n    scope: Scope,\n  ): t.Expression {\n    if (\n      iterableIsArray &&\n      !t.isIdentifier(spread.argument, { name: \"arguments\" })\n    ) {\n      return spread.argument;\n    } else {\n      return scope.toArray(spread.argument, true, arrayLikeIsIterable);\n    }\n  }\n\n  function hasHole(spread: t.ArrayExpression): boolean {\n    return spread.elements.some(el => el === null);\n  }\n\n  function hasSpread(nodes: Array<t.Node>): boolean {\n    for (let i = 0; i < nodes.length; i++) {\n      if (t.isSpreadElement(nodes[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function push(_props: Array<ListElement>, nodes: Array<t.Expression>) {\n    if (!_props.length) return _props;\n    nodes.push(t.arrayExpression(_props));\n    return [];\n  }\n\n  function build(\n    props: Array<ListElement>,\n    scope: Scope,\n    file: File,\n  ): t.Expression[] {\n    const nodes: Array<t.Expression> = [];\n    let _props: Array<ListElement> = [];\n\n    for (const prop of props) {\n      if (t.isSpreadElement(prop)) {\n        _props = push(_props, nodes);\n        let spreadLiteral = getSpreadLiteral(prop, scope);\n\n        if (t.isArrayExpression(spreadLiteral) && hasHole(spreadLiteral)) {\n          spreadLiteral = t.callExpression(\n            file.addHelper(\n              process.env.BABEL_8_BREAKING\n                ? \"arrayLikeToArray\"\n                : \"arrayWithoutHoles\",\n            ),\n            [spreadLiteral],\n          );\n        }\n\n        nodes.push(spreadLiteral);\n      } else {\n        _props.push(prop);\n      }\n    }\n\n    push(_props, nodes);\n\n    return nodes;\n  }\n\n  return {\n    name: \"transform-spread\",\n\n    visitor: {\n      ArrayExpression(path): void {\n        const { node, scope } = path;\n        const elements = node.elements;\n        if (!hasSpread(elements)) return;\n\n        const nodes = build(elements, scope, this.file);\n        let first = nodes[0];\n\n        // If there is only one element in the ArrayExpression and\n        // the element was transformed (Array.prototype.slice.call or toConsumableArray)\n        // we know that the transformed code already takes care of cloning the array.\n        // So we can simply return that element.\n        if (\n          nodes.length === 1 &&\n          first !== (elements[0] as t.SpreadElement).argument\n        ) {\n          path.replaceWith(first);\n          return;\n        }\n\n        // If the first element is a ArrayExpression we can directly call\n        // concat on it.\n        // `[..].concat(..)`\n        // If not then we have to use `[].concat(arr)` and not `arr.concat`\n        // because `arr` could be extended/modified (e.g. Immutable) and we do not know exactly\n        // what concat would produce.\n        if (!t.isArrayExpression(first)) {\n          first = t.arrayExpression([]);\n        } else {\n          nodes.shift();\n        }\n\n        path.replaceWith(\n          t.callExpression(\n            t.memberExpression(first, t.identifier(\"concat\")),\n            nodes,\n          ),\n        );\n      },\n      CallExpression(path): void {\n        const { node, scope } = path;\n\n        const args = node.arguments as Array<ListElement>;\n        if (!hasSpread(args)) return;\n        const calleePath = skipTransparentExprWrappers(\n          path.get(\"callee\") as NodePath<t.Expression>,\n        );\n        if (calleePath.isSuper()) {\n          // NOTE: spread and classes have almost the same compat data, so this is very unlikely to happen in practice.\n          throw path.buildCodeFrameError(\n            \"It's not possible to compile spread arguments in `super()` without compiling classes.\\n\" +\n              \"Please add '@babel/plugin-transform-classes' to your Babel configuration.\",\n          );\n        }\n        let contextLiteral: t.Expression | t.Super = scope.buildUndefinedNode();\n        node.arguments = [];\n\n        let nodes: t.Expression[];\n        if (\n          args.length === 1 &&\n          t.isIdentifier((args[0] as t.SpreadElement).argument, {\n            name: \"arguments\",\n          })\n        ) {\n          nodes = [(args[0] as t.SpreadElement).argument];\n        } else {\n          nodes = build(args, scope, this.file);\n        }\n\n        const first = nodes.shift();\n        if (nodes.length) {\n          node.arguments.push(\n            t.callExpression(\n              t.memberExpression(first, t.identifier(\"concat\")),\n              nodes,\n            ),\n          );\n        } else {\n          node.arguments.push(first);\n        }\n\n        const callee = calleePath.node as t.MemberExpression;\n\n        if (t.isMemberExpression(callee)) {\n          const temp = scope.maybeGenerateMemoised(callee.object);\n          if (temp) {\n            callee.object = t.assignmentExpression(\n              \"=\",\n              temp,\n              // object must not be Super when `temp` is an identifier\n              callee.object as t.Expression,\n            );\n            contextLiteral = temp;\n          } else {\n            contextLiteral = t.cloneNode(callee.object);\n          }\n        }\n\n        // We use the original callee here, to preserve any types/parentheses\n        node.callee = t.memberExpression(\n          node.callee as t.Expression,\n          t.identifier(\"apply\"),\n        );\n        if (t.isSuper(contextLiteral)) {\n          contextLiteral = t.thisExpression();\n        }\n\n        node.arguments.unshift(t.cloneNode(contextLiteral));\n      },\n\n      NewExpression(path): void {\n        const { node, scope } = path;\n        if (!hasSpread(node.arguments)) return;\n\n        const nodes = build(\n          node.arguments as Array<ListElement>,\n          scope,\n          this.file,\n        );\n\n        const first = nodes.shift();\n\n        let args: t.Expression;\n        if (nodes.length) {\n          args = t.callExpression(\n            t.memberExpression(first, t.identifier(\"concat\")),\n            nodes,\n          );\n        } else {\n          args = first;\n        }\n\n        path.replaceWith(\n          t.callExpression(path.hub.addHelper(\"construct\"), [\n            node.callee as t.Expression,\n            args,\n          ]),\n        );\n      },\n    },\n  };\n});\n"]},"metadata":{},"sourceType":"script"}