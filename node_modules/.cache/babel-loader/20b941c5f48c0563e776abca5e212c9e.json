{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nconst LT = `[${Array.from(new Set(['\\r\\n', '\\r', '\\n', '\\u2028', '\\u2029'])).join('')}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`, 'u');\n/**\n * Creates tester which check if a node starts with specific keyword with the\n * appropriate AST_NODE_TYPES.\n * @param keyword The keyword to test.\n * @returns the created tester.\n * @private\n */\n\nfunction newKeywordTester(type, keyword) {\n  return {\n    test(node, sourceCode) {\n      var _a;\n\n      const isSameKeyword = ((_a = sourceCode.getFirstToken(node)) === null || _a === void 0 ? void 0 : _a.value) === keyword;\n      const isSameType = Array.isArray(type) ? type.some(val => val === node.type) : type === node.type;\n      return isSameKeyword && isSameType;\n    }\n\n  };\n}\n/**\n * Creates tester which check if a node starts with specific keyword and spans a single line.\n * @param keyword The keyword to test.\n * @returns the created tester.\n * @private\n */\n\n\nfunction newSinglelineKeywordTester(keyword) {\n  return {\n    test(node, sourceCode) {\n      return node.loc.start.line === node.loc.end.line && sourceCode.getFirstToken(node).value === keyword;\n    }\n\n  };\n}\n/**\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\n * @param keyword The keyword to test.\n * @returns the created tester.\n * @private\n */\n\n\nfunction newMultilineKeywordTester(keyword) {\n  return {\n    test(node, sourceCode) {\n      return node.loc.start.line !== node.loc.end.line && sourceCode.getFirstToken(node).value === keyword;\n    }\n\n  };\n}\n/**\n * Creates tester which check if a node is specific type.\n * @param type The node type to test.\n * @returns the created tester.\n * @private\n */\n\n\nfunction newNodeTypeTester(type) {\n  return {\n    test: node => node.type === type\n  };\n}\n/**\n * Skips a chain expression node\n * @param node The node to test\n * @returnsA non-chain expression\n * @private\n */\n\n\nfunction skipChainExpression(node) {\n  return node && node.type === utils_1.AST_NODE_TYPES.ChainExpression ? node.expression : node;\n}\n/**\n * Checks the given node is an expression statement of IIFE.\n * @param node The node to check.\n * @returns `true` if the node is an expression statement of IIFE.\n * @private\n */\n\n\nfunction isIIFEStatement(node) {\n  if (node.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {\n    let expression = skipChainExpression(node.expression);\n\n    if (expression.type === utils_1.AST_NODE_TYPES.UnaryExpression) {\n      expression = skipChainExpression(expression.argument);\n    }\n\n    if (expression.type === utils_1.AST_NODE_TYPES.CallExpression) {\n      let node = expression.callee;\n\n      while (node.type === utils_1.AST_NODE_TYPES.SequenceExpression) {\n        node = node.expressions[node.expressions.length - 1];\n      }\n\n      return util.isFunction(node);\n    }\n  }\n\n  return false;\n}\n/**\n * Checks the given node is a CommonJS require statement\n * @param node The node to check.\n * @returns `true` if the node is a CommonJS require statement.\n * @private\n */\n\n\nfunction isCJSRequire(node) {\n  if (node.type === utils_1.AST_NODE_TYPES.VariableDeclaration) {\n    const declaration = node.declarations[0];\n\n    if (declaration === null || declaration === void 0 ? void 0 : declaration.init) {\n      let call = declaration === null || declaration === void 0 ? void 0 : declaration.init;\n\n      while (call.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n        call = call.object;\n      }\n\n      if (call.type === utils_1.AST_NODE_TYPES.CallExpression && call.callee.type === utils_1.AST_NODE_TYPES.Identifier) {\n        return call.callee.name === 'require';\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * Checks whether the given node is a block-like statement.\n * This checks the last token of the node is the closing brace of a block.\n * @param sourceCode The source code to get tokens.\n * @param node The node to check.\n * @returns `true` if the node is a block-like statement.\n * @private\n */\n\n\nfunction isBlockLikeStatement(node, sourceCode) {\n  // do-while with a block is a block-like statement.\n  if (node.type === utils_1.AST_NODE_TYPES.DoWhileStatement && node.body.type === utils_1.AST_NODE_TYPES.BlockStatement) {\n    return true;\n  }\n  /**\n   * IIFE is a block-like statement specially from\n   * JSCS#disallowPaddingNewLinesAfterBlocks.\n   */\n\n\n  if (isIIFEStatement(node)) {\n    return true;\n  } // Checks the last token is a closing brace of blocks.\n\n\n  const lastToken = sourceCode.getLastToken(node, util.isNotSemicolonToken);\n  const belongingNode = lastToken && util.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;\n  return !!belongingNode && (belongingNode.type === utils_1.AST_NODE_TYPES.BlockStatement || belongingNode.type === utils_1.AST_NODE_TYPES.SwitchStatement);\n}\n/**\n * Check whether the given node is a directive or not.\n * @param node The node to check.\n * @param sourceCode The source code object to get tokens.\n * @returns `true` if the node is a directive.\n */\n\n\nfunction isDirective(node, sourceCode) {\n  var _a, _b;\n\n  return node.type === utils_1.AST_NODE_TYPES.ExpressionStatement && (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.Program || ((_b = node.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.BlockStatement && util.isFunction(node.parent.parent)) && node.expression.type === utils_1.AST_NODE_TYPES.Literal && typeof node.expression.value === 'string' && !util.isParenthesized(node.expression, sourceCode);\n}\n/**\n * Check whether the given node is a part of directive prologue or not.\n * @param node The node to check.\n * @param sourceCode The source code object to get tokens.\n * @returns `true` if the node is a part of directive prologue.\n */\n\n\nfunction isDirectivePrologue(node, sourceCode) {\n  if (isDirective(node, sourceCode) && node.parent && 'body' in node.parent && Array.isArray(node.parent.body)) {\n    for (const sibling of node.parent.body) {\n      if (sibling === node) {\n        break;\n      }\n\n      if (!isDirective(sibling, sourceCode)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Checks the given node is a CommonJS export statement\n * @param node The node to check.\n * @returns `true` if the node is a CommonJS export statement.\n * @private\n */\n\n\nfunction isCJSExport(node) {\n  if (node.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {\n    const expression = node.expression;\n\n    if (expression.type === utils_1.AST_NODE_TYPES.AssignmentExpression) {\n      let left = expression.left;\n\n      if (left.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n        while (left.object.type === utils_1.AST_NODE_TYPES.MemberExpression) {\n          left = left.object;\n        }\n\n        return left.object.type === utils_1.AST_NODE_TYPES.Identifier && (left.object.name === 'exports' || left.object.name === 'module' && left.property.type === utils_1.AST_NODE_TYPES.Identifier && left.property.name === 'exports');\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * Check whether the given node is an expression\n * @param node The node to check.\n * @param sourceCode The source code object to get tokens.\n * @returns `true` if the node is an expression\n */\n\n\nfunction isExpression(node, sourceCode) {\n  return node.type === utils_1.AST_NODE_TYPES.ExpressionStatement && !isDirectivePrologue(node, sourceCode);\n}\n/**\n * Gets the actual last token.\n *\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\n * For example:\n *\n *     foo()\n *     ;[1, 2, 3].forEach(bar)\n * @param sourceCode The source code to get tokens.\n * @param node The node to get.\n * @returns The actual last token.\n * @private\n */\n\n\nfunction getActualLastToken(node, sourceCode) {\n  const semiToken = sourceCode.getLastToken(node);\n  const prevToken = sourceCode.getTokenBefore(semiToken);\n  const nextToken = sourceCode.getTokenAfter(semiToken);\n  const isSemicolonLessStyle = prevToken && nextToken && prevToken.range[0] >= node.range[0] && util.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line;\n  return isSemicolonLessStyle ? prevToken : semiToken;\n}\n/**\n * This returns the concatenation of the first 2 captured strings.\n * @param _ Unused. Whole matched string.\n * @param trailingSpaces The trailing spaces of the first line.\n * @param indentSpaces The indentation spaces of the last line.\n * @returns The concatenation of trailingSpaces and indentSpaces.\n * @private\n */\n\n\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n  return trailingSpaces + indentSpaces;\n}\n/**\n * Check and report statements for `any` configuration.\n * It does nothing.\n *\n * @private\n */\n\n\nfunction verifyForAny() {// Empty\n}\n/**\n * Check and report statements for `never` configuration.\n * This autofix removes blank lines between the given 2 statements.\n * However, if comments exist between 2 blank lines, it does not remove those\n * blank lines automatically.\n * @param context The rule context to report.\n * @param _ Unused. The previous node to check.\n * @param nextNode The next node to check.\n * @param paddingLines The array of token pairs that blank\n * lines exist between the pair.\n *\n * @private\n */\n\n\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n  if (paddingLines.length === 0) {\n    return;\n  }\n\n  context.report({\n    node: nextNode,\n    messageId: 'unexpectedBlankLine',\n\n    fix(fixer) {\n      if (paddingLines.length >= 2) {\n        return null;\n      }\n\n      const prevToken = paddingLines[0][0];\n      const nextToken = paddingLines[0][1];\n      const start = prevToken.range[1];\n      const end = nextToken.range[0];\n      const text = context.getSourceCode().text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n      return fixer.replaceTextRange([start, end], text);\n    }\n\n  });\n}\n/**\n * Check and report statements for `always` configuration.\n * This autofix inserts a blank line between the given 2 statements.\n * If the `prevNode` has trailing comments, it inserts a blank line after the\n * trailing comments.\n * @param context The rule context to report.\n * @param prevNode The previous node to check.\n * @param nextNode The next node to check.\n * @param paddingLines The array of token pairs that blank\n * lines exist between the pair.\n *\n * @private\n */\n\n\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n  if (paddingLines.length > 0) {\n    return;\n  }\n\n  context.report({\n    node: nextNode,\n    messageId: 'expectedBlankLine',\n\n    fix(fixer) {\n      const sourceCode = context.getSourceCode();\n      let prevToken = getActualLastToken(prevNode, sourceCode);\n      const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {\n        includeComments: true,\n\n        /**\n         * Skip the trailing comments of the previous node.\n         * This inserts a blank line after the last trailing comment.\n         *\n         * For example:\n         *\n         *     foo(); // trailing comment.\n         *     // comment.\n         *     bar();\n         *\n         * Get fixed to:\n         *\n         *     foo(); // trailing comment.\n         *\n         *     // comment.\n         *     bar();\n         * @param token The token to check.\n         * @returns `true` if the token is not a trailing comment.\n         * @private\n         */\n        filter(token) {\n          if (util.isTokenOnSameLine(prevToken, token)) {\n            prevToken = token;\n            return false;\n          }\n\n          return true;\n        }\n\n      }) || nextNode;\n      const insertText = util.isTokenOnSameLine(prevToken, nextToken) ? '\\n\\n' : '\\n';\n      return fixer.insertTextAfter(prevToken, insertText);\n    }\n\n  });\n}\n/**\n * Types of blank lines.\n * `any`, `never`, and `always` are defined.\n * Those have `verify` method to check and report statements.\n * @private\n */\n\n\nconst PaddingTypes = {\n  any: {\n    verify: verifyForAny\n  },\n  never: {\n    verify: verifyForNever\n  },\n  always: {\n    verify: verifyForAlways\n  }\n};\n/**\n * Types of statements.\n * Those have `test` method to check it matches to the given statement.\n * @private\n */\n\nconst StatementTypes = {\n  '*': {\n    test: () => true\n  },\n  'block-like': {\n    test: isBlockLikeStatement\n  },\n  exports: {\n    test: isCJSExport\n  },\n  require: {\n    test: isCJSRequire\n  },\n  directive: {\n    test: isDirectivePrologue\n  },\n  expression: {\n    test: isExpression\n  },\n  iife: {\n    test: isIIFEStatement\n  },\n  'multiline-block-like': {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(node, sourceCode)\n  },\n  'multiline-expression': {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && node.type === utils_1.AST_NODE_TYPES.ExpressionStatement && !isDirectivePrologue(node, sourceCode)\n  },\n  'multiline-const': newMultilineKeywordTester('const'),\n  'multiline-let': newMultilineKeywordTester('let'),\n  'multiline-var': newMultilineKeywordTester('var'),\n  'singleline-const': newSinglelineKeywordTester('const'),\n  'singleline-let': newSinglelineKeywordTester('let'),\n  'singleline-var': newSinglelineKeywordTester('var'),\n  block: newNodeTypeTester(utils_1.AST_NODE_TYPES.BlockStatement),\n  empty: newNodeTypeTester(utils_1.AST_NODE_TYPES.EmptyStatement),\n  function: newNodeTypeTester(utils_1.AST_NODE_TYPES.FunctionDeclaration),\n  break: newKeywordTester(utils_1.AST_NODE_TYPES.BreakStatement, 'break'),\n  case: newKeywordTester(utils_1.AST_NODE_TYPES.SwitchCase, 'case'),\n  class: newKeywordTester(utils_1.AST_NODE_TYPES.ClassDeclaration, 'class'),\n  const: newKeywordTester(utils_1.AST_NODE_TYPES.VariableDeclaration, 'const'),\n  continue: newKeywordTester(utils_1.AST_NODE_TYPES.ContinueStatement, 'continue'),\n  debugger: newKeywordTester(utils_1.AST_NODE_TYPES.DebuggerStatement, 'debugger'),\n  default: newKeywordTester([utils_1.AST_NODE_TYPES.SwitchCase, utils_1.AST_NODE_TYPES.ExportDefaultDeclaration], 'default'),\n  do: newKeywordTester(utils_1.AST_NODE_TYPES.DoWhileStatement, 'do'),\n  export: newKeywordTester([utils_1.AST_NODE_TYPES.ExportDefaultDeclaration, utils_1.AST_NODE_TYPES.ExportNamedDeclaration], 'export'),\n  for: newKeywordTester([utils_1.AST_NODE_TYPES.ForStatement, utils_1.AST_NODE_TYPES.ForInStatement, utils_1.AST_NODE_TYPES.ForOfStatement], 'for'),\n  if: newKeywordTester(utils_1.AST_NODE_TYPES.IfStatement, 'if'),\n  import: newKeywordTester(utils_1.AST_NODE_TYPES.ImportDeclaration, 'import'),\n  let: newKeywordTester(utils_1.AST_NODE_TYPES.VariableDeclaration, 'let'),\n  return: newKeywordTester(utils_1.AST_NODE_TYPES.ReturnStatement, 'return'),\n  switch: newKeywordTester(utils_1.AST_NODE_TYPES.SwitchStatement, 'switch'),\n  throw: newKeywordTester(utils_1.AST_NODE_TYPES.ThrowStatement, 'throw'),\n  try: newKeywordTester(utils_1.AST_NODE_TYPES.TryStatement, 'try'),\n  var: newKeywordTester(utils_1.AST_NODE_TYPES.VariableDeclaration, 'var'),\n  while: newKeywordTester([utils_1.AST_NODE_TYPES.WhileStatement, utils_1.AST_NODE_TYPES.DoWhileStatement], 'while'),\n  with: newKeywordTester(utils_1.AST_NODE_TYPES.WithStatement, 'with'),\n  // Additional Typescript constructs\n  interface: newKeywordTester(utils_1.AST_NODE_TYPES.TSInterfaceDeclaration, 'interface'),\n  type: newKeywordTester(utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration, 'type')\n}; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nexports.default = util.createRule({\n  name: 'padding-line-between-statements',\n  meta: {\n    type: 'layout',\n    docs: {\n      description: 'Require or disallow padding lines between statements',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    fixable: 'whitespace',\n    hasSuggestions: false,\n    schema: {\n      $defs: {\n        paddingType: {\n          enum: Object.keys(PaddingTypes)\n        },\n        statementType: {\n          anyOf: [{\n            enum: Object.keys(StatementTypes)\n          }, {\n            type: 'array',\n            items: {\n              enum: Object.keys(StatementTypes)\n            },\n            minItems: 1,\n            uniqueItems: true,\n            additionalItems: false\n          }]\n        }\n      },\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          blankLine: {\n            $ref: '#/$defs/paddingType'\n          },\n          prev: {\n            $ref: '#/$defs/statementType'\n          },\n          next: {\n            $ref: '#/$defs/statementType'\n          }\n        },\n        additionalProperties: false,\n        required: ['blankLine', 'prev', 'next']\n      },\n      additionalItems: false\n    },\n    messages: {\n      unexpectedBlankLine: 'Unexpected blank line before this statement.',\n      expectedBlankLine: 'Expected blank line before this statement.'\n    }\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const configureList = context.options || [];\n    let scopeInfo = null;\n    /**\n     * Processes to enter to new scope.\n     * This manages the current previous statement.\n     *\n     * @private\n     */\n\n    function enterScope() {\n      scopeInfo = {\n        upper: scopeInfo,\n        prevNode: null\n      };\n    }\n    /**\n     * Processes to exit from the current scope.\n     *\n     * @private\n     */\n\n\n    function exitScope() {\n      if (scopeInfo) {\n        scopeInfo = scopeInfo.upper;\n      }\n    }\n    /**\n     * Checks whether the given node matches the given type.\n     * @param node The statement node to check.\n     * @param type The statement type to check.\n     * @returns `true` if the statement node matched the type.\n     * @private\n     */\n\n\n    function match(node, type) {\n      let innerStatementNode = node;\n\n      while (innerStatementNode.type === utils_1.AST_NODE_TYPES.LabeledStatement) {\n        innerStatementNode = innerStatementNode.body;\n      }\n\n      if (Array.isArray(type)) {\n        return type.some(match.bind(null, innerStatementNode));\n      }\n\n      return StatementTypes[type].test(innerStatementNode, sourceCode);\n    }\n    /**\n     * Finds the last matched configure from configureList.\n     * @paramprevNode The previous statement to match.\n     * @paramnextNode The current statement to match.\n     * @returns The tester of the last matched configure.\n     * @private\n     */\n\n\n    function getPaddingType(prevNode, nextNode) {\n      for (let i = configureList.length - 1; i >= 0; --i) {\n        const configure = configureList[i];\n\n        if (match(prevNode, configure.prev) && match(nextNode, configure.next)) {\n          return PaddingTypes[configure.blankLine];\n        }\n      }\n\n      return PaddingTypes.any;\n    }\n    /**\n     * Gets padding line sequences between the given 2 statements.\n     * Comments are separators of the padding line sequences.\n     * @paramprevNode The previous statement to count.\n     * @paramnextNode The current statement to count.\n     * @returns The array of token pairs.\n     * @private\n     */\n\n\n    function getPaddingLineSequences(prevNode, nextNode) {\n      const pairs = [];\n      let prevToken = getActualLastToken(prevNode, sourceCode);\n\n      if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n        do {\n          const token = sourceCode.getTokenAfter(prevToken, {\n            includeComments: true\n          });\n\n          if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n            pairs.push([prevToken, token]);\n          }\n\n          prevToken = token;\n        } while (prevToken.range[0] < nextNode.range[0]);\n      }\n\n      return pairs;\n    }\n    /**\n     * Verify padding lines between the given node and the previous node.\n     * @param node The node to verify.\n     *\n     * @private\n     */\n\n\n    function verify(node) {\n      if (!node.parent || ![utils_1.AST_NODE_TYPES.BlockStatement, utils_1.AST_NODE_TYPES.Program, utils_1.AST_NODE_TYPES.SwitchCase, utils_1.AST_NODE_TYPES.SwitchStatement, utils_1.AST_NODE_TYPES.TSModuleBlock].includes(node.parent.type)) {\n        return;\n      } // Save this node as the current previous statement.\n\n\n      const prevNode = scopeInfo.prevNode; // Verify.\n\n      if (prevNode) {\n        const type = getPaddingType(prevNode, node);\n        const paddingLines = getPaddingLineSequences(prevNode, node);\n        type.verify(context, prevNode, node, paddingLines);\n      }\n\n      scopeInfo.prevNode = node;\n    }\n    /**\n     * Verify padding lines between the given node and the previous node.\n     * Then process to enter to new scope.\n     * @param node The node to verify.\n     *\n     * @private\n     */\n\n\n    function verifyThenEnterScope(node) {\n      verify(node);\n      enterScope();\n    }\n\n    return {\n      Program: enterScope,\n      BlockStatement: enterScope,\n      SwitchStatement: enterScope,\n      TSModuleBlock: enterScope,\n      'Program:exit': exitScope,\n      'BlockStatement:exit': exitScope,\n      'SwitchStatement:exit': exitScope,\n      'TSModuleBlock:exit': exitScope,\n      ':statement': verify,\n      SwitchCase: verifyThenEnterScope,\n      TSDeclareFunction: verifyThenEnterScope,\n      'SwitchCase:exit': exitScope,\n      'TSDeclareFunction:exit': exitScope\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["LT","Array","from","Set","join","PADDING_LINE_SEQUENCE","RegExp","String","raw","newKeywordTester","type","keyword","test","node","sourceCode","isSameKeyword","getFirstToken","_a","value","isSameType","isArray","some","val","newSinglelineKeywordTester","loc","start","line","end","newMultilineKeywordTester","newNodeTypeTester","skipChainExpression","utils_1","ChainExpression","expression","isIIFEStatement","ExpressionStatement","UnaryExpression","argument","CallExpression","callee","SequenceExpression","expressions","length","util","isFunction","isCJSRequire","VariableDeclaration","declaration","declarations","init","call","MemberExpression","object","Identifier","name","isBlockLikeStatement","DoWhileStatement","body","BlockStatement","lastToken","getLastToken","isNotSemicolonToken","belongingNode","isClosingBraceToken","getNodeByRangeIndex","range","SwitchStatement","isDirective","parent","Program","_b","Literal","isParenthesized","isDirectivePrologue","sibling","isCJSExport","AssignmentExpression","left","property","isExpression","getActualLastToken","semiToken","prevToken","getTokenBefore","nextToken","getTokenAfter","isSemicolonLessStyle","isSemicolonToken","replacerToRemovePaddingLines","_","trailingSpaces","indentSpaces","verifyForAny","verifyForNever","context","nextNode","paddingLines","report","messageId","fix","fixer","text","getSourceCode","slice","replace","replaceTextRange","verifyForAlways","prevNode","getFirstTokenBetween","includeComments","filter","token","isTokenOnSameLine","insertText","insertTextAfter","PaddingTypes","any","verify","never","always","StatementTypes","exports","require","directive","iife","block","empty","EmptyStatement","function","FunctionDeclaration","break","BreakStatement","case","SwitchCase","class","ClassDeclaration","const","continue","ContinueStatement","debugger","DebuggerStatement","default","ExportDefaultDeclaration","do","export","ExportNamedDeclaration","for","ForStatement","ForInStatement","ForOfStatement","if","IfStatement","import","ImportDeclaration","let","return","ReturnStatement","switch","throw","ThrowStatement","try","TryStatement","var","while","WhileStatement","with","WithStatement","interface","TSInterfaceDeclaration","TSTypeAliasDeclaration","createRule","meta","docs","description","recommended","extendsBaseRule","fixable","hasSuggestions","schema","$defs","paddingType","enum","Object","keys","statementType","anyOf","items","minItems","uniqueItems","additionalItems","properties","blankLine","$ref","prev","next","additionalProperties","required","messages","unexpectedBlankLine","expectedBlankLine","defaultOptions","create","configureList","options","scopeInfo","enterScope","upper","exitScope","match","innerStatementNode","LabeledStatement","bind","getPaddingType","i","configure","getPaddingLineSequences","pairs","push","TSModuleBlock","includes","verifyThenEnterScope","TSDeclareFunction"],"sources":["../../src/rules/padding-line-between-statements.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}