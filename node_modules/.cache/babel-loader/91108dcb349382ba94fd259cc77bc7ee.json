{"ast":null,"code":"import * as t from \"../../lib/index.js\";\nimport * as definitions from \"../../lib/definitions/index.js\";\nimport formatBuilderName from \"../utils/formatBuilderName.js\";\nimport lowerFirst from \"../utils/lowerFirst.js\";\nimport stringifyValidator from \"../utils/stringifyValidator.js\";\n\nfunction areAllRemainingFieldsNullable(fieldName, fieldNames, fields) {\n  const index = fieldNames.indexOf(fieldName);\n  return fieldNames.slice(index).every(_ => isNullable(fields[_]));\n}\n\nfunction hasDefault(field) {\n  return field.default != null;\n}\n\nfunction isNullable(field) {\n  return field.optional || hasDefault(field);\n}\n\nfunction sortFieldNames(fields, type) {\n  return fields.sort((fieldA, fieldB) => {\n    const indexA = t.BUILDER_KEYS[type].indexOf(fieldA);\n    const indexB = t.BUILDER_KEYS[type].indexOf(fieldB);\n    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;\n    if (indexA === -1) return 1;\n    if (indexB === -1) return -1;\n    return indexA - indexB;\n  });\n}\n\nfunction generateBuilderArgs(type) {\n  const fields = t.NODE_FIELDS[type];\n  const fieldNames = sortFieldNames(Object.keys(t.NODE_FIELDS[type]), type);\n  const builderNames = t.BUILDER_KEYS[type];\n  const args = [];\n  fieldNames.forEach(fieldName => {\n    const field = fields[fieldName]; // Future / annoying TODO:\n    // MemberExpression.property, ObjectProperty.key and ObjectMethod.key need special cases; either:\n    // - convert the declaration to chain() like ClassProperty.key and ClassMethod.key,\n    // - declare an alias type for valid keys, detect the case and reuse it here,\n    // - declare a disjoint union with, for example, ObjectPropertyBase,\n    //   ObjectPropertyLiteralKey and ObjectPropertyComputedKey, and declare ObjectProperty\n    //   as \"ObjectPropertyBase & (ObjectPropertyLiteralKey | ObjectPropertyComputedKey)\"\n\n    let typeAnnotation = stringifyValidator(field.validate, \"t.\");\n\n    if (isNullable(field) && !hasDefault(field)) {\n      typeAnnotation += \" | null\";\n    }\n\n    if (builderNames.includes(fieldName)) {\n      const field = definitions.NODE_FIELDS[type][fieldName];\n      const def = JSON.stringify(field.default);\n      const bindingIdentifierName = t.toBindingIdentifierName(fieldName);\n      let arg;\n\n      if (areAllRemainingFieldsNullable(fieldName, builderNames, fields)) {\n        arg = `${bindingIdentifierName}${isNullable(field) && !def ? \"?:\" : \":\"} ${typeAnnotation}`;\n      } else {\n        arg = `${bindingIdentifierName}: ${typeAnnotation}${isNullable(field) ? \" | undefined\" : \"\"}`;\n      }\n\n      if (def !== \"null\" || isNullable(field)) {\n        arg += `= ${def}`;\n      }\n\n      args.push(arg);\n    }\n  });\n  return args;\n}\n\nexport default function generateBuilders(kind) {\n  return kind === \"uppercase.js\" ? generateUppercaseBuilders() : generateLowercaseBuilders();\n}\n\nfunction generateLowercaseBuilders() {\n  let output = `/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport validateNode from \"../validateNode\";\nimport type * as t from \"../..\";\n`;\n  const reservedNames = new Set([\"super\", \"import\"]);\n  Object.keys(definitions.BUILDER_KEYS).forEach(type => {\n    const defArgs = generateBuilderArgs(type);\n    const formatedBuilderName = formatBuilderName(type);\n    const formatedBuilderNameLocal = reservedNames.has(formatedBuilderName) ? `_${formatedBuilderName}` : formatedBuilderName;\n    const fieldNames = sortFieldNames(Object.keys(definitions.NODE_FIELDS[type]), type);\n    const builderNames = definitions.BUILDER_KEYS[type];\n    const objectFields = [[\"type\", JSON.stringify(type)]];\n    fieldNames.forEach(fieldName => {\n      const field = definitions.NODE_FIELDS[type][fieldName];\n\n      if (builderNames.includes(fieldName)) {\n        const bindingIdentifierName = t.toBindingIdentifierName(fieldName);\n        objectFields.push([fieldName, bindingIdentifierName]);\n      } else if (!field.optional) {\n        const def = JSON.stringify(field.default);\n        objectFields.push([fieldName, def]);\n      }\n    });\n    output += `${formatedBuilderNameLocal === formatedBuilderName ? \"export \" : \"\"}function ${formatedBuilderNameLocal}(${defArgs.join(\", \")}): t.${type} {`;\n    const nodeObjectExpression = `{\\n${objectFields.map(_ref => {\n      let [k, v] = _ref;\n      return k === v ? `    ${k},` : `    ${k}: ${v},`;\n    }).join(\"\\n\")}\\n  }`;\n\n    if (builderNames.length > 0) {\n      output += `\\n  return validateNode<t.${type}>(${nodeObjectExpression});`;\n    } else {\n      output += `\\n  return ${nodeObjectExpression};`;\n    }\n\n    output += `\\n}\\n`;\n\n    if (formatedBuilderNameLocal !== formatedBuilderName) {\n      output += `export { ${formatedBuilderNameLocal} as ${formatedBuilderName} };\\n`;\n    } // This is needed for backwards compatibility.\n    // It should be removed in the next major version.\n    // JSXIdentifier -> jSXIdentifier\n\n\n    if (/^[A-Z]{2}/.test(type)) {\n      output += `export { ${formatedBuilderNameLocal} as ${lowerFirst(type)} }\\n`;\n    }\n  });\n  Object.keys(definitions.DEPRECATED_KEYS).forEach(type => {\n    const newType = definitions.DEPRECATED_KEYS[type];\n    const formatedBuilderName = formatBuilderName(type);\n    const formatedNewBuilderName = formatBuilderName(newType);\n    output += `/** @deprecated */\nfunction ${type}(${generateBuilderArgs(newType).join(\", \")}) {\n  console.trace(\"The node type ${type} has been renamed to ${newType}\");\n  return ${formatedNewBuilderName}(${t.BUILDER_KEYS[newType].join(\", \")});\n}\nexport { ${type} as ${formatedBuilderName} };\\n`; // This is needed for backwards compatibility.\n    // It should be removed in the next major version.\n    // JSXIdentifier -> jSXIdentifier\n\n    if (/^[A-Z]{2}/.test(type)) {\n      output += `export { ${type} as ${lowerFirst(type)} }\\n`;\n    }\n  });\n  return output;\n}\n\nfunction generateUppercaseBuilders() {\n  let output = `/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\n\n/**\n * This file is written in JavaScript and not TypeScript because uppercase builders\n * conflict with AST types. TypeScript reads the uppercase.d.ts file instead.\n */\n\n export {\\n`;\n  Object.keys(definitions.BUILDER_KEYS).forEach(type => {\n    const formatedBuilderName = formatBuilderName(type);\n    output += `  ${formatedBuilderName} as ${type},\\n`;\n  });\n  Object.keys(definitions.DEPRECATED_KEYS).forEach(type => {\n    const formatedBuilderName = formatBuilderName(type);\n    output += `  ${formatedBuilderName} as ${type},\\n`;\n  });\n  output += ` } from './index';\\n`;\n  return output;\n}","map":{"version":3,"names":["t","definitions","formatBuilderName","lowerFirst","stringifyValidator","areAllRemainingFieldsNullable","fieldName","fieldNames","fields","index","indexOf","slice","every","_","isNullable","hasDefault","field","default","optional","sortFieldNames","type","sort","fieldA","fieldB","indexA","BUILDER_KEYS","indexB","generateBuilderArgs","NODE_FIELDS","Object","keys","builderNames","args","forEach","typeAnnotation","validate","includes","def","JSON","stringify","bindingIdentifierName","toBindingIdentifierName","arg","push","generateBuilders","kind","generateUppercaseBuilders","generateLowercaseBuilders","output","reservedNames","Set","defArgs","formatedBuilderName","formatedBuilderNameLocal","has","objectFields","join","nodeObjectExpression","map","k","v","length","test","DEPRECATED_KEYS","newType","formatedNewBuilderName"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/types/scripts/generators/builders.js"],"sourcesContent":["import * as t from \"../../lib/index.js\";\nimport * as definitions from \"../../lib/definitions/index.js\";\nimport formatBuilderName from \"../utils/formatBuilderName.js\";\nimport lowerFirst from \"../utils/lowerFirst.js\";\nimport stringifyValidator from \"../utils/stringifyValidator.js\";\n\nfunction areAllRemainingFieldsNullable(fieldName, fieldNames, fields) {\n  const index = fieldNames.indexOf(fieldName);\n  return fieldNames.slice(index).every(_ => isNullable(fields[_]));\n}\n\nfunction hasDefault(field) {\n  return field.default != null;\n}\n\nfunction isNullable(field) {\n  return field.optional || hasDefault(field);\n}\n\nfunction sortFieldNames(fields, type) {\n  return fields.sort((fieldA, fieldB) => {\n    const indexA = t.BUILDER_KEYS[type].indexOf(fieldA);\n    const indexB = t.BUILDER_KEYS[type].indexOf(fieldB);\n    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;\n    if (indexA === -1) return 1;\n    if (indexB === -1) return -1;\n    return indexA - indexB;\n  });\n}\n\nfunction generateBuilderArgs(type) {\n  const fields = t.NODE_FIELDS[type];\n  const fieldNames = sortFieldNames(Object.keys(t.NODE_FIELDS[type]), type);\n  const builderNames = t.BUILDER_KEYS[type];\n\n  const args = [];\n\n  fieldNames.forEach(fieldName => {\n    const field = fields[fieldName];\n    // Future / annoying TODO:\n    // MemberExpression.property, ObjectProperty.key and ObjectMethod.key need special cases; either:\n    // - convert the declaration to chain() like ClassProperty.key and ClassMethod.key,\n    // - declare an alias type for valid keys, detect the case and reuse it here,\n    // - declare a disjoint union with, for example, ObjectPropertyBase,\n    //   ObjectPropertyLiteralKey and ObjectPropertyComputedKey, and declare ObjectProperty\n    //   as \"ObjectPropertyBase & (ObjectPropertyLiteralKey | ObjectPropertyComputedKey)\"\n    let typeAnnotation = stringifyValidator(field.validate, \"t.\");\n\n    if (isNullable(field) && !hasDefault(field)) {\n      typeAnnotation += \" | null\";\n    }\n\n    if (builderNames.includes(fieldName)) {\n      const field = definitions.NODE_FIELDS[type][fieldName];\n      const def = JSON.stringify(field.default);\n      const bindingIdentifierName = t.toBindingIdentifierName(fieldName);\n      let arg;\n      if (areAllRemainingFieldsNullable(fieldName, builderNames, fields)) {\n        arg = `${bindingIdentifierName}${\n          isNullable(field) && !def ? \"?:\" : \":\"\n        } ${typeAnnotation}`;\n      } else {\n        arg = `${bindingIdentifierName}: ${typeAnnotation}${\n          isNullable(field) ? \" | undefined\" : \"\"\n        }`;\n      }\n      if (def !== \"null\" || isNullable(field)) {\n        arg += `= ${def}`;\n      }\n      args.push(arg);\n    }\n  });\n\n  return args;\n}\n\nexport default function generateBuilders(kind) {\n  return kind === \"uppercase.js\"\n    ? generateUppercaseBuilders()\n    : generateLowercaseBuilders();\n}\n\nfunction generateLowercaseBuilders() {\n  let output = `/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport validateNode from \"../validateNode\";\nimport type * as t from \"../..\";\n`;\n\n  const reservedNames = new Set([\"super\", \"import\"]);\n  Object.keys(definitions.BUILDER_KEYS).forEach(type => {\n    const defArgs = generateBuilderArgs(type);\n    const formatedBuilderName = formatBuilderName(type);\n    const formatedBuilderNameLocal = reservedNames.has(formatedBuilderName)\n      ? `_${formatedBuilderName}`\n      : formatedBuilderName;\n\n    const fieldNames = sortFieldNames(\n      Object.keys(definitions.NODE_FIELDS[type]),\n      type\n    );\n    const builderNames = definitions.BUILDER_KEYS[type];\n    const objectFields = [[\"type\", JSON.stringify(type)]];\n    fieldNames.forEach(fieldName => {\n      const field = definitions.NODE_FIELDS[type][fieldName];\n      if (builderNames.includes(fieldName)) {\n        const bindingIdentifierName = t.toBindingIdentifierName(fieldName);\n        objectFields.push([fieldName, bindingIdentifierName]);\n      } else if (!field.optional) {\n        const def = JSON.stringify(field.default);\n        objectFields.push([fieldName, def]);\n      }\n    });\n\n    output += `${\n      formatedBuilderNameLocal === formatedBuilderName ? \"export \" : \"\"\n    }function ${formatedBuilderNameLocal}(${defArgs.join(\", \")}): t.${type} {`;\n\n    const nodeObjectExpression = `{\\n${objectFields\n      .map(([k, v]) => (k === v ? `    ${k},` : `    ${k}: ${v},`))\n      .join(\"\\n\")}\\n  }`;\n\n    if (builderNames.length > 0) {\n      output += `\\n  return validateNode<t.${type}>(${nodeObjectExpression});`;\n    } else {\n      output += `\\n  return ${nodeObjectExpression};`;\n    }\n    output += `\\n}\\n`;\n\n    if (formatedBuilderNameLocal !== formatedBuilderName) {\n      output += `export { ${formatedBuilderNameLocal} as ${formatedBuilderName} };\\n`;\n    }\n\n    // This is needed for backwards compatibility.\n    // It should be removed in the next major version.\n    // JSXIdentifier -> jSXIdentifier\n    if (/^[A-Z]{2}/.test(type)) {\n      output += `export { ${formatedBuilderNameLocal} as ${lowerFirst(\n        type\n      )} }\\n`;\n    }\n  });\n\n  Object.keys(definitions.DEPRECATED_KEYS).forEach(type => {\n    const newType = definitions.DEPRECATED_KEYS[type];\n    const formatedBuilderName = formatBuilderName(type);\n    const formatedNewBuilderName = formatBuilderName(newType);\n    output += `/** @deprecated */\nfunction ${type}(${generateBuilderArgs(newType).join(\", \")}) {\n  console.trace(\"The node type ${type} has been renamed to ${newType}\");\n  return ${formatedNewBuilderName}(${t.BUILDER_KEYS[newType].join(\", \")});\n}\nexport { ${type} as ${formatedBuilderName} };\\n`;\n    // This is needed for backwards compatibility.\n    // It should be removed in the next major version.\n    // JSXIdentifier -> jSXIdentifier\n    if (/^[A-Z]{2}/.test(type)) {\n      output += `export { ${type} as ${lowerFirst(type)} }\\n`;\n    }\n  });\n\n  return output;\n}\n\nfunction generateUppercaseBuilders() {\n  let output = `/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\n\n/**\n * This file is written in JavaScript and not TypeScript because uppercase builders\n * conflict with AST types. TypeScript reads the uppercase.d.ts file instead.\n */\n\n export {\\n`;\n\n  Object.keys(definitions.BUILDER_KEYS).forEach(type => {\n    const formatedBuilderName = formatBuilderName(type);\n    output += `  ${formatedBuilderName} as ${type},\\n`;\n  });\n\n  Object.keys(definitions.DEPRECATED_KEYS).forEach(type => {\n    const formatedBuilderName = formatBuilderName(type);\n    output += `  ${formatedBuilderName} as ${type},\\n`;\n  });\n\n  output += ` } from './index';\\n`;\n  return output;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}