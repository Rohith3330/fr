{"ast":null,"code":"/**\n * @fileoverview Translates tokens between Acorn format and Esprima format.\n * @author Nicholas C. Zakas\n */\n\n/* eslint no-underscore-dangle: 0 */\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n// none!\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n// Esprima Token Types\nconst Token = {\n  Boolean: \"Boolean\",\n  EOF: \"<end>\",\n  Identifier: \"Identifier\",\n  PrivateIdentifier: \"PrivateIdentifier\",\n  Keyword: \"Keyword\",\n  Null: \"Null\",\n  Numeric: \"Numeric\",\n  Punctuator: \"Punctuator\",\n  String: \"String\",\n  RegularExpression: \"RegularExpression\",\n  Template: \"Template\",\n  JSXIdentifier: \"JSXIdentifier\",\n  JSXText: \"JSXText\"\n};\n/**\n * Converts part of a template into an Esprima token.\n * @param {AcornToken[]} tokens The Acorn tokens representing the template.\n * @param {string} code The source code.\n * @returns {EsprimaToken} The Esprima equivalent of the template token.\n * @private\n */\n\nfunction convertTemplatePart(tokens, code) {\n  const firstToken = tokens[0],\n        lastTemplateToken = tokens[tokens.length - 1];\n  const token = {\n    type: Token.Template,\n    value: code.slice(firstToken.start, lastTemplateToken.end)\n  };\n\n  if (firstToken.loc) {\n    token.loc = {\n      start: firstToken.loc.start,\n      end: lastTemplateToken.loc.end\n    };\n  }\n\n  if (firstToken.range) {\n    token.start = firstToken.range[0];\n    token.end = lastTemplateToken.range[1];\n    token.range = [token.start, token.end];\n  }\n\n  return token;\n}\n/**\n * Contains logic to translate Acorn tokens into Esprima tokens.\n * @param {Object} acornTokTypes The Acorn token types.\n * @param {string} code The source code Acorn is parsing. This is necessary\n *      to correct the \"value\" property of some tokens.\n * @constructor\n */\n\n\nfunction TokenTranslator(acornTokTypes, code) {\n  // token types\n  this._acornTokTypes = acornTokTypes; // token buffer for templates\n\n  this._tokens = []; // track the last curly brace\n\n  this._curlyBrace = null; // the source code\n\n  this._code = code;\n}\n\nTokenTranslator.prototype = {\n  constructor: TokenTranslator,\n\n  /**\n   * Translates a single Esprima token to a single Acorn token. This may be\n   * inaccurate due to how templates are handled differently in Esprima and\n   * Acorn, but should be accurate for all other tokens.\n   * @param {AcornToken} token The Acorn token to translate.\n   * @param {Object} extra Espree extra object.\n   * @returns {EsprimaToken} The Esprima version of the token.\n   */\n  translate(token, extra) {\n    const type = token.type,\n          tt = this._acornTokTypes;\n\n    if (type === tt.name) {\n      token.type = Token.Identifier; // TODO: See if this is an Acorn bug\n\n      if (token.value === \"static\") {\n        token.type = Token.Keyword;\n      }\n\n      if (extra.ecmaVersion > 5 && (token.value === \"yield\" || token.value === \"let\")) {\n        token.type = Token.Keyword;\n      }\n    } else if (type === tt.privateId) {\n      token.type = Token.PrivateIdentifier;\n    } else if (type === tt.semi || type === tt.comma || type === tt.parenL || type === tt.parenR || type === tt.braceL || type === tt.braceR || type === tt.dot || type === tt.bracketL || type === tt.colon || type === tt.question || type === tt.bracketR || type === tt.ellipsis || type === tt.arrow || type === tt.jsxTagStart || type === tt.incDec || type === tt.starstar || type === tt.jsxTagEnd || type === tt.prefix || type === tt.questionDot || type.binop && !type.keyword || type.isAssign) {\n      token.type = Token.Punctuator;\n      token.value = this._code.slice(token.start, token.end);\n    } else if (type === tt.jsxName) {\n      token.type = Token.JSXIdentifier;\n    } else if (type.label === \"jsxText\" || type === tt.jsxAttrValueToken) {\n      token.type = Token.JSXText;\n    } else if (type.keyword) {\n      if (type.keyword === \"true\" || type.keyword === \"false\") {\n        token.type = Token.Boolean;\n      } else if (type.keyword === \"null\") {\n        token.type = Token.Null;\n      } else {\n        token.type = Token.Keyword;\n      }\n    } else if (type === tt.num) {\n      token.type = Token.Numeric;\n      token.value = this._code.slice(token.start, token.end);\n    } else if (type === tt.string) {\n      if (extra.jsxAttrValueToken) {\n        extra.jsxAttrValueToken = false;\n        token.type = Token.JSXText;\n      } else {\n        token.type = Token.String;\n      }\n\n      token.value = this._code.slice(token.start, token.end);\n    } else if (type === tt.regexp) {\n      token.type = Token.RegularExpression;\n      const value = token.value;\n      token.regex = {\n        flags: value.flags,\n        pattern: value.pattern\n      };\n      token.value = `/${value.pattern}/${value.flags}`;\n    }\n\n    return token;\n  },\n\n  /**\n   * Function to call during Acorn's onToken handler.\n   * @param {AcornToken} token The Acorn token.\n   * @param {Object} extra The Espree extra object.\n   * @returns {void}\n   */\n  onToken(token, extra) {\n    const that = this,\n          tt = this._acornTokTypes,\n          tokens = extra.tokens,\n          templateTokens = this._tokens;\n    /**\n     * Flushes the buffered template tokens and resets the template\n     * tracking.\n     * @returns {void}\n     * @private\n     */\n\n    function translateTemplateTokens() {\n      tokens.push(convertTemplatePart(that._tokens, that._code));\n      that._tokens = [];\n    }\n\n    if (token.type === tt.eof) {\n      // might be one last curlyBrace\n      if (this._curlyBrace) {\n        tokens.push(this.translate(this._curlyBrace, extra));\n      }\n\n      return;\n    }\n\n    if (token.type === tt.backQuote) {\n      // if there's already a curly, it's not part of the template\n      if (this._curlyBrace) {\n        tokens.push(this.translate(this._curlyBrace, extra));\n        this._curlyBrace = null;\n      }\n\n      templateTokens.push(token); // it's the end\n\n      if (templateTokens.length > 1) {\n        translateTemplateTokens();\n      }\n\n      return;\n    }\n\n    if (token.type === tt.dollarBraceL) {\n      templateTokens.push(token);\n      translateTemplateTokens();\n      return;\n    }\n\n    if (token.type === tt.braceR) {\n      // if there's already a curly, it's not part of the template\n      if (this._curlyBrace) {\n        tokens.push(this.translate(this._curlyBrace, extra));\n      } // store new curly for later\n\n\n      this._curlyBrace = token;\n      return;\n    }\n\n    if (token.type === tt.template || token.type === tt.invalidTemplate) {\n      if (this._curlyBrace) {\n        templateTokens.push(this._curlyBrace);\n        this._curlyBrace = null;\n      }\n\n      templateTokens.push(token);\n      return;\n    }\n\n    if (this._curlyBrace) {\n      tokens.push(this.translate(this._curlyBrace, extra));\n      this._curlyBrace = null;\n    }\n\n    tokens.push(this.translate(token, extra));\n  }\n\n}; //------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nexport default TokenTranslator;","map":{"version":3,"names":["Token","Boolean","EOF","Identifier","PrivateIdentifier","Keyword","Null","Numeric","Punctuator","String","RegularExpression","Template","JSXIdentifier","JSXText","convertTemplatePart","tokens","code","firstToken","lastTemplateToken","length","token","type","value","slice","start","end","loc","range","TokenTranslator","acornTokTypes","_acornTokTypes","_tokens","_curlyBrace","_code","prototype","constructor","translate","extra","tt","name","ecmaVersion","privateId","semi","comma","parenL","parenR","braceL","braceR","dot","bracketL","colon","question","bracketR","ellipsis","arrow","jsxTagStart","incDec","starstar","jsxTagEnd","prefix","questionDot","binop","keyword","isAssign","jsxName","label","jsxAttrValueToken","num","string","regexp","regex","flags","pattern","onToken","that","templateTokens","translateTemplateTokens","push","eof","backQuote","dollarBraceL","template","invalidTemplate"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/espree/lib/token-translator.js"],"sourcesContent":["/**\n * @fileoverview Translates tokens between Acorn format and Esprima format.\n * @author Nicholas C. Zakas\n */\n/* eslint no-underscore-dangle: 0 */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\n// none!\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n\n// Esprima Token Types\nconst Token = {\n    Boolean: \"Boolean\",\n    EOF: \"<end>\",\n    Identifier: \"Identifier\",\n    PrivateIdentifier: \"PrivateIdentifier\",\n    Keyword: \"Keyword\",\n    Null: \"Null\",\n    Numeric: \"Numeric\",\n    Punctuator: \"Punctuator\",\n    String: \"String\",\n    RegularExpression: \"RegularExpression\",\n    Template: \"Template\",\n    JSXIdentifier: \"JSXIdentifier\",\n    JSXText: \"JSXText\"\n};\n\n/**\n * Converts part of a template into an Esprima token.\n * @param {AcornToken[]} tokens The Acorn tokens representing the template.\n * @param {string} code The source code.\n * @returns {EsprimaToken} The Esprima equivalent of the template token.\n * @private\n */\nfunction convertTemplatePart(tokens, code) {\n    const firstToken = tokens[0],\n        lastTemplateToken = tokens[tokens.length - 1];\n\n    const token = {\n        type: Token.Template,\n        value: code.slice(firstToken.start, lastTemplateToken.end)\n    };\n\n    if (firstToken.loc) {\n        token.loc = {\n            start: firstToken.loc.start,\n            end: lastTemplateToken.loc.end\n        };\n    }\n\n    if (firstToken.range) {\n        token.start = firstToken.range[0];\n        token.end = lastTemplateToken.range[1];\n        token.range = [token.start, token.end];\n    }\n\n    return token;\n}\n\n/**\n * Contains logic to translate Acorn tokens into Esprima tokens.\n * @param {Object} acornTokTypes The Acorn token types.\n * @param {string} code The source code Acorn is parsing. This is necessary\n *      to correct the \"value\" property of some tokens.\n * @constructor\n */\nfunction TokenTranslator(acornTokTypes, code) {\n\n    // token types\n    this._acornTokTypes = acornTokTypes;\n\n    // token buffer for templates\n    this._tokens = [];\n\n    // track the last curly brace\n    this._curlyBrace = null;\n\n    // the source code\n    this._code = code;\n\n}\n\nTokenTranslator.prototype = {\n    constructor: TokenTranslator,\n\n    /**\n     * Translates a single Esprima token to a single Acorn token. This may be\n     * inaccurate due to how templates are handled differently in Esprima and\n     * Acorn, but should be accurate for all other tokens.\n     * @param {AcornToken} token The Acorn token to translate.\n     * @param {Object} extra Espree extra object.\n     * @returns {EsprimaToken} The Esprima version of the token.\n     */\n    translate(token, extra) {\n\n        const type = token.type,\n            tt = this._acornTokTypes;\n\n        if (type === tt.name) {\n            token.type = Token.Identifier;\n\n            // TODO: See if this is an Acorn bug\n            if (token.value === \"static\") {\n                token.type = Token.Keyword;\n            }\n\n            if (extra.ecmaVersion > 5 && (token.value === \"yield\" || token.value === \"let\")) {\n                token.type = Token.Keyword;\n            }\n\n        } else if (type === tt.privateId) {\n            token.type = Token.PrivateIdentifier;\n\n        } else if (type === tt.semi || type === tt.comma ||\n                 type === tt.parenL || type === tt.parenR ||\n                 type === tt.braceL || type === tt.braceR ||\n                 type === tt.dot || type === tt.bracketL ||\n                 type === tt.colon || type === tt.question ||\n                 type === tt.bracketR || type === tt.ellipsis ||\n                 type === tt.arrow || type === tt.jsxTagStart ||\n                 type === tt.incDec || type === tt.starstar ||\n                 type === tt.jsxTagEnd || type === tt.prefix ||\n                 type === tt.questionDot ||\n                 (type.binop && !type.keyword) ||\n                 type.isAssign) {\n\n            token.type = Token.Punctuator;\n            token.value = this._code.slice(token.start, token.end);\n        } else if (type === tt.jsxName) {\n            token.type = Token.JSXIdentifier;\n        } else if (type.label === \"jsxText\" || type === tt.jsxAttrValueToken) {\n            token.type = Token.JSXText;\n        } else if (type.keyword) {\n            if (type.keyword === \"true\" || type.keyword === \"false\") {\n                token.type = Token.Boolean;\n            } else if (type.keyword === \"null\") {\n                token.type = Token.Null;\n            } else {\n                token.type = Token.Keyword;\n            }\n        } else if (type === tt.num) {\n            token.type = Token.Numeric;\n            token.value = this._code.slice(token.start, token.end);\n        } else if (type === tt.string) {\n\n            if (extra.jsxAttrValueToken) {\n                extra.jsxAttrValueToken = false;\n                token.type = Token.JSXText;\n            } else {\n                token.type = Token.String;\n            }\n\n            token.value = this._code.slice(token.start, token.end);\n        } else if (type === tt.regexp) {\n            token.type = Token.RegularExpression;\n            const value = token.value;\n\n            token.regex = {\n                flags: value.flags,\n                pattern: value.pattern\n            };\n            token.value = `/${value.pattern}/${value.flags}`;\n        }\n\n        return token;\n    },\n\n    /**\n     * Function to call during Acorn's onToken handler.\n     * @param {AcornToken} token The Acorn token.\n     * @param {Object} extra The Espree extra object.\n     * @returns {void}\n     */\n    onToken(token, extra) {\n\n        const that = this,\n            tt = this._acornTokTypes,\n            tokens = extra.tokens,\n            templateTokens = this._tokens;\n\n        /**\n         * Flushes the buffered template tokens and resets the template\n         * tracking.\n         * @returns {void}\n         * @private\n         */\n        function translateTemplateTokens() {\n            tokens.push(convertTemplatePart(that._tokens, that._code));\n            that._tokens = [];\n        }\n\n        if (token.type === tt.eof) {\n\n            // might be one last curlyBrace\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n            }\n\n            return;\n        }\n\n        if (token.type === tt.backQuote) {\n\n            // if there's already a curly, it's not part of the template\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n                this._curlyBrace = null;\n            }\n\n            templateTokens.push(token);\n\n            // it's the end\n            if (templateTokens.length > 1) {\n                translateTemplateTokens();\n            }\n\n            return;\n        }\n        if (token.type === tt.dollarBraceL) {\n            templateTokens.push(token);\n            translateTemplateTokens();\n            return;\n        }\n        if (token.type === tt.braceR) {\n\n            // if there's already a curly, it's not part of the template\n            if (this._curlyBrace) {\n                tokens.push(this.translate(this._curlyBrace, extra));\n            }\n\n            // store new curly for later\n            this._curlyBrace = token;\n            return;\n        }\n        if (token.type === tt.template || token.type === tt.invalidTemplate) {\n            if (this._curlyBrace) {\n                templateTokens.push(this._curlyBrace);\n                this._curlyBrace = null;\n            }\n\n            templateTokens.push(token);\n            return;\n        }\n\n        if (this._curlyBrace) {\n            tokens.push(this.translate(this._curlyBrace, extra));\n            this._curlyBrace = null;\n        }\n\n        tokens.push(this.translate(token, extra));\n    }\n};\n\n//------------------------------------------------------------------------------\n// Public\n//------------------------------------------------------------------------------\n\nexport default TokenTranslator;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}