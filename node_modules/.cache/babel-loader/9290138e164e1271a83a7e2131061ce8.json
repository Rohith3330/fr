{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst isBooleanLiteral = node => node.type === _experimentalUtils.AST_NODE_TYPES.Literal && typeof node.value === 'boolean';\n/**\n * Checks if the given `ParsedExpectMatcher` is a call to one of the equality matchers,\n * with a boolean literal as the sole argument.\n *\n * @example javascript\n * toBe(true);\n * toEqual(false);\n *\n * @param {ParsedExpectMatcher} matcher\n *\n * @return {matcher is ParsedBooleanEqualityMatcher}\n */\n\n\nconst isBooleanEqualityMatcher = matcher => (0, _utils.isParsedEqualityMatcherCall)(matcher) && isBooleanLiteral((0, _utils.followTypeAssertionChain)(matcher.arguments[0]));\n/**\n * Checks if the given `node` is a `CallExpression` representing the calling\n * of an `includes`-like method that can be 'fixed' (using `toContain`).\n *\n * @param {CallExpression} node\n *\n * @return {node is FixableIncludesCallExpression}\n */\n\n\nconst isFixableIncludesCallExpression = node => node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && node.callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && (0, _utils.isSupportedAccessor)(node.callee.property, 'includes') && (0, _utils.hasOnlyOneArgument)(node); // expect(array.includes(<value>)[not.]{toBe,toEqual}(<boolean>)\n\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Suggest using `toContain()`',\n      recommended: false\n    },\n    messages: {\n      useToContain: 'Use toContain() instead'\n    },\n    fixable: 'code',\n    type: 'suggestion',\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        if (!(0, _utils.isExpectCall)(node)) {\n          return;\n        }\n\n        const {\n          expect: {\n            arguments: [includesCall],\n            range: [, expectCallEnd]\n          },\n          matcher,\n          modifier\n        } = (0, _utils.parseExpectCall)(node);\n\n        if (!matcher || !includesCall || modifier && modifier.name !== _utils.ModifierName.not || !isBooleanEqualityMatcher(matcher) || !isFixableIncludesCallExpression(includesCall)) {\n          return;\n        }\n\n        context.report({\n          fix(fixer) {\n            const sourceCode = context.getSourceCode(); // we need to negate the expectation if the current expected\n            // value is itself negated by the \"not\" modifier\n\n            const addNotModifier = (0, _utils.followTypeAssertionChain)(matcher.arguments[0]).value === !!modifier;\n            return [// remove the \"includes\" call entirely\n            fixer.removeRange([includesCall.callee.property.range[0] - 1, includesCall.range[1]]), // replace the current matcher with \"toContain\", adding \"not\" if needed\n            fixer.replaceTextRange([expectCallEnd, matcher.node.range[1]], addNotModifier ? `.${_utils.ModifierName.not}.toContain` : '.toContain'), // replace the matcher argument with the value from the \"includes\"\n            fixer.replaceText(matcher.arguments[0], sourceCode.getText(includesCall.arguments[0]))];\n          },\n\n          messageId: 'useToContain',\n          node: (modifier || matcher).node.property\n        });\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_experimentalUtils","require","_utils","isBooleanLiteral","node","type","AST_NODE_TYPES","Literal","isBooleanEqualityMatcher","matcher","isParsedEqualityMatcherCall","followTypeAssertionChain","arguments","isFixableIncludesCallExpression","CallExpression","callee","MemberExpression","isSupportedAccessor","property","hasOnlyOneArgument","_default","createRule","name","__filename","meta","docs","category","description","recommended","messages","useToContain","fixable","schema","defaultOptions","create","context","isExpectCall","expect","includesCall","range","expectCallEnd","modifier","parseExpectCall","ModifierName","not","report","fix","fixer","sourceCode","getSourceCode","addNotModifier","removeRange","replaceTextRange","replaceText","getText","messageId"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-jest/lib/rules/prefer-to-contain.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst isBooleanLiteral = node => node.type === _experimentalUtils.AST_NODE_TYPES.Literal && typeof node.value === 'boolean';\n\n/**\n * Checks if the given `ParsedExpectMatcher` is a call to one of the equality matchers,\n * with a boolean literal as the sole argument.\n *\n * @example javascript\n * toBe(true);\n * toEqual(false);\n *\n * @param {ParsedExpectMatcher} matcher\n *\n * @return {matcher is ParsedBooleanEqualityMatcher}\n */\nconst isBooleanEqualityMatcher = matcher => (0, _utils.isParsedEqualityMatcherCall)(matcher) && isBooleanLiteral((0, _utils.followTypeAssertionChain)(matcher.arguments[0]));\n\n/**\n * Checks if the given `node` is a `CallExpression` representing the calling\n * of an `includes`-like method that can be 'fixed' (using `toContain`).\n *\n * @param {CallExpression} node\n *\n * @return {node is FixableIncludesCallExpression}\n */\nconst isFixableIncludesCallExpression = node => node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && node.callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && (0, _utils.isSupportedAccessor)(node.callee.property, 'includes') && (0, _utils.hasOnlyOneArgument)(node); // expect(array.includes(<value>)[not.]{toBe,toEqual}(<boolean>)\n\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Suggest using `toContain()`',\n      recommended: false\n    },\n    messages: {\n      useToContain: 'Use toContain() instead'\n    },\n    fixable: 'code',\n    type: 'suggestion',\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        if (!(0, _utils.isExpectCall)(node)) {\n          return;\n        }\n\n        const {\n          expect: {\n            arguments: [includesCall],\n            range: [, expectCallEnd]\n          },\n          matcher,\n          modifier\n        } = (0, _utils.parseExpectCall)(node);\n\n        if (!matcher || !includesCall || modifier && modifier.name !== _utils.ModifierName.not || !isBooleanEqualityMatcher(matcher) || !isFixableIncludesCallExpression(includesCall)) {\n          return;\n        }\n\n        context.report({\n          fix(fixer) {\n            const sourceCode = context.getSourceCode(); // we need to negate the expectation if the current expected\n            // value is itself negated by the \"not\" modifier\n\n            const addNotModifier = (0, _utils.followTypeAssertionChain)(matcher.arguments[0]).value === !!modifier;\n            return [// remove the \"includes\" call entirely\n            fixer.removeRange([includesCall.callee.property.range[0] - 1, includesCall.range[1]]), // replace the current matcher with \"toContain\", adding \"not\" if needed\n            fixer.replaceTextRange([expectCallEnd, matcher.node.range[1]], addNotModifier ? `.${_utils.ModifierName.not}.toContain` : '.toContain'), // replace the matcher argument with the value from the \"includes\"\n            fixer.replaceText(matcher.arguments[0], sourceCode.getText(includesCall.arguments[0]))];\n          },\n\n          messageId: 'useToContain',\n          node: (modifier || matcher).node.property\n        });\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}