{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canSkipRegexpu = canSkipRegexpu;\nexports.generateRegexpuOptions = generateRegexpuOptions;\nexports.transformFlags = transformFlags;\n\nvar _features = require(\"./features\");\n\nfunction generateRegexpuOptions(pattern, toTransform) {\n  const feat = function (name) {\n    let ok = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"transform\";\n    return (0, _features.hasFeature)(toTransform, _features.FEATURES[name]) ? ok : false;\n  };\n\n  const featDuplicateNamedGroups = () => {\n    if (!feat(\"duplicateNamedCaptureGroups\")) return false;\n    const regex = /\\(\\?<([^>]+)>/g;\n    const seen = new Set();\n\n    for (let match; match = regex.exec(pattern); seen.add(match[1])) {\n      if (seen.has(match[1])) return \"transform\";\n    }\n\n    return false;\n  };\n\n  return {\n    unicodeFlag: feat(\"unicodeFlag\"),\n    unicodeSetsFlag: feat(\"unicodeSetsFlag\") || feat(\"unicodeSetsFlag_syntax\", \"parse\"),\n    dotAllFlag: feat(\"dotAllFlag\"),\n    unicodePropertyEscapes: feat(\"unicodePropertyEscape\"),\n    namedGroups: feat(\"namedCaptureGroups\") || featDuplicateNamedGroups(),\n    onNamedGroup: () => {}\n  };\n}\n\nfunction canSkipRegexpu(node, options) {\n  const {\n    flags,\n    pattern\n  } = node;\n\n  if (flags.includes(\"v\")) {\n    if (options.unicodeSetsFlag === \"transform\") return false;\n  }\n\n  if (flags.includes(\"u\")) {\n    if (options.unicodeFlag === \"transform\") return false;\n\n    if (options.unicodePropertyEscapes === \"transform\" && /\\\\[pP]{/.test(pattern)) {\n      return false;\n    }\n  }\n\n  if (flags.includes(\"s\")) {\n    if (options.dotAllFlag === \"transform\") return false;\n  }\n\n  if (options.namedGroups === \"transform\" && /\\(\\?<(?![=!])/.test(pattern)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction transformFlags(regexpuOptions, flags) {\n  if (regexpuOptions.unicodeSetsFlag === \"transform\") {\n    flags = flags.replace(\"v\", \"u\");\n  }\n\n  if (regexpuOptions.unicodeFlag === \"transform\") {\n    flags = flags.replace(\"u\", \"\");\n  }\n\n  if (regexpuOptions.dotAllFlag === \"transform\") {\n    flags = flags.replace(\"s\", \"\");\n  }\n\n  return flags;\n}","map":{"version":3,"mappings":";;;;;;;;;AACA;;AAIO,SAASA,sBAAT,CACLC,OADK,EAELC,WAFK,EAGW;EAGhB,MAAMC,IAAI,GAAG,UACXC,IADW,EAGR;IAAA,IADHC,EACG,uEADyD,WACzD;IACH,OAAO,0BAAWH,WAAX,EAAwBI,mBAASF,IAATE,CAAxB,IAA0CD,EAA1C,GAA+C,KAAtD;EAJF;;EAOA,MAAME,wBAAwB,GAAG,MAA2B;IAC1D,IAAI,CAACJ,IAAI,CAAC,6BAAD,CAAT,EAA0C,OAAO,KAAP;IAM1C,MAAMK,KAAK,GAAG,gBAAd;IACA,MAAMC,IAAI,GAAG,IAAIC,GAAJ,EAAb;;IACA,KAAK,IAAIC,KAAT,EAAiBA,KAAK,GAAGH,KAAK,CAACI,IAANJ,CAAWP,OAAXO,CAAzB,EAA+CC,IAAI,CAACI,GAALJ,CAASE,KAAK,CAAC,CAAD,CAAdF,CAA/C,EAAmE;MACjE,IAAIA,IAAI,CAACK,GAALL,CAASE,KAAK,CAAC,CAAD,CAAdF,CAAJ,EAAwB,OAAO,WAAP;IACzB;;IACD,OAAO,KAAP;EAZF;;EAeA,OAAO;IACLM,WAAW,EAAEZ,IAAI,CAAC,aAAD,CADZ;IAELa,eAAe,EACbb,IAAI,CAAe,iBAAf,CAAJA,IACAA,IAAI,CAAe,wBAAf,EAAyC,OAAzC,CAJD;IAKLc,UAAU,EAAEd,IAAI,CAAC,YAAD,CALX;IAMLe,sBAAsB,EAAEf,IAAI,CAAC,uBAAD,CANvB;IAOLgB,WAAW,EAAEhB,IAAI,CAAC,oBAAD,CAAJA,IAA8BI,wBAAwB,EAP9D;IAQLa,YAAY,EAAE,MAAM,CAAE;EARjB,CAAP;AAUD;;AAEM,SAASC,cAAT,CACLC,IADK,EAELC,OAFK,EAGI;EACT,MAAM;IAAEC,KAAF;IAASvB;EAAT,IAAqBqB,IAA3B;;EAEA,IAAIE,KAAK,CAACC,QAAND,CAAe,GAAfA,CAAJ,EAAyB;IACvB,IAAID,OAAO,CAACP,eAARO,KAA4B,WAAhC,EAA6C,OAAO,KAAP;EAC9C;;EAED,IAAIC,KAAK,CAACC,QAAND,CAAe,GAAfA,CAAJ,EAAyB;IACvB,IAAID,OAAO,CAACR,WAARQ,KAAwB,WAA5B,EAAyC,OAAO,KAAP;;IACzC,IACEA,OAAO,CAACL,sBAARK,KAAmC,WAAnCA,IACA,UAAUG,IAAV,CAAezB,OAAf,CAFF,EAGE;MACA,OAAO,KAAP;IACD;EACF;;EAED,IAAIuB,KAAK,CAACC,QAAND,CAAe,GAAfA,CAAJ,EAAyB;IACvB,IAAID,OAAO,CAACN,UAARM,KAAuB,WAA3B,EAAwC,OAAO,KAAP;EACzC;;EAED,IAAIA,OAAO,CAACJ,WAARI,KAAwB,WAAxBA,IAAuC,gBAAgBG,IAAhB,CAAqBzB,OAArB,CAA3C,EAA0E;IACxE,OAAO,KAAP;EACD;;EAED,OAAO,IAAP;AACD;;AAEM,SAAS0B,cAAT,CAAwBC,cAAxB,EAAwDJ,KAAxD,EAAuE;EAC5E,IAAII,cAAc,CAACZ,eAAfY,KAAmC,WAAvC,EAAoD;IAClDJ,KAAK,GAAGA,KAAK,CAACK,OAANL,CAAc,GAAdA,EAAmB,GAAnBA,CAARA;EACD;;EACD,IAAII,cAAc,CAACb,WAAfa,KAA+B,WAAnC,EAAgD;IAC9CJ,KAAK,GAAGA,KAAK,CAACK,OAANL,CAAc,GAAdA,EAAmB,EAAnBA,CAARA;EACD;;EACD,IAAII,cAAc,CAACX,UAAfW,KAA8B,WAAlC,EAA+C;IAC7CJ,KAAK,GAAGA,KAAK,CAACK,OAANL,CAAc,GAAdA,EAAmB,EAAnBA,CAARA;EACD;;EACD,OAAOA,KAAP;AACD","names":["generateRegexpuOptions","pattern","toTransform","feat","name","ok","FEATURES","featDuplicateNamedGroups","regex","seen","Set","match","exec","add","has","unicodeFlag","unicodeSetsFlag","dotAllFlag","unicodePropertyEscapes","namedGroups","onNamedGroup","canSkipRegexpu","node","options","flags","includes","test","transformFlags","regexpuOptions","replace"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-create-regexp-features-plugin\\src\\util.ts"],"sourcesContent":["import type { types as t } from \"@babel/core\";\nimport { FEATURES, hasFeature } from \"./features\";\n\nimport type { RegexpuOptions } from \"regexpu-core\";\n\nexport function generateRegexpuOptions(\n  pattern: string,\n  toTransform: number,\n): RegexpuOptions {\n  type Experimental = 1;\n\n  const feat = <Stability extends 0 | 1 = 0>(\n    name: keyof typeof FEATURES,\n    ok: \"transform\" | (Stability extends 0 ? never : \"parse\") = \"transform\",\n  ) => {\n    return hasFeature(toTransform, FEATURES[name]) ? ok : false;\n  };\n\n  const featDuplicateNamedGroups = (): \"transform\" | false => {\n    if (!feat(\"duplicateNamedCaptureGroups\")) return false;\n\n    // This can return false positive, for example for /\\(?<a>\\)/.\n    // However, it's such a rare occurrence that it's ok to compile\n    // the regexp even if we only need to compile regexps with\n    // duplicate named capturing groups.\n    const regex = /\\(\\?<([^>]+)>/g;\n    const seen = new Set();\n    for (let match; (match = regex.exec(pattern)); seen.add(match[1])) {\n      if (seen.has(match[1])) return \"transform\";\n    }\n    return false;\n  };\n\n  return {\n    unicodeFlag: feat(\"unicodeFlag\"),\n    unicodeSetsFlag:\n      feat<Experimental>(\"unicodeSetsFlag\") ||\n      feat<Experimental>(\"unicodeSetsFlag_syntax\", \"parse\"),\n    dotAllFlag: feat(\"dotAllFlag\"),\n    unicodePropertyEscapes: feat(\"unicodePropertyEscape\"),\n    namedGroups: feat(\"namedCaptureGroups\") || featDuplicateNamedGroups(),\n    onNamedGroup: () => {},\n  };\n}\n\nexport function canSkipRegexpu(\n  node: t.RegExpLiteral,\n  options: RegexpuOptions,\n): boolean {\n  const { flags, pattern } = node;\n\n  if (flags.includes(\"v\")) {\n    if (options.unicodeSetsFlag === \"transform\") return false;\n  }\n\n  if (flags.includes(\"u\")) {\n    if (options.unicodeFlag === \"transform\") return false;\n    if (\n      options.unicodePropertyEscapes === \"transform\" &&\n      /\\\\[pP]{/.test(pattern)\n    ) {\n      return false;\n    }\n  }\n\n  if (flags.includes(\"s\")) {\n    if (options.dotAllFlag === \"transform\") return false;\n  }\n\n  if (options.namedGroups === \"transform\" && /\\(\\?<(?![=!])/.test(pattern)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function transformFlags(regexpuOptions: RegexpuOptions, flags: string) {\n  if (regexpuOptions.unicodeSetsFlag === \"transform\") {\n    flags = flags.replace(\"v\", \"u\");\n  }\n  if (regexpuOptions.unicodeFlag === \"transform\") {\n    flags = flags.replace(\"u\", \"\");\n  }\n  if (regexpuOptions.dotAllFlag === \"transform\") {\n    flags = flags.replace(\"s\", \"\");\n  }\n  return flags;\n}\n"]},"metadata":{},"sourceType":"script"}