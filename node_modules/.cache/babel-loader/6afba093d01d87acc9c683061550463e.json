{"ast":null,"code":"/* global a2c */\n'use strict';\n\nvar rNumber = String.raw`[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*`,\n    rCommaWsp = String.raw`(?:\\s,?\\s*|,\\s*)`,\n    rNumberCommaWsp = `(${rNumber})` + rCommaWsp,\n    rFlagCommaWsp = `([01])${rCommaWsp}?`,\n    rCoordinatePair = String.raw`(${rNumber})${rCommaWsp}?(${rNumber})`,\n    rArcSeq = (rNumberCommaWsp + '?').repeat(2) + rNumberCommaWsp + rFlagCommaWsp.repeat(2) + rCoordinatePair;\n\nvar regPathInstructions = /([MmLlHhVvCcSsQqTtAaZz])\\s*/,\n    regCoordinateSequence = new RegExp(rNumber, 'g'),\n    regArcArgumentSequence = new RegExp(rArcSeq, 'g'),\n    regNumericValues = /[-+]?(\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/,\n    transform2js = require('./_transforms').transform2js,\n    transformsMultiply = require('./_transforms').transformsMultiply,\n    transformArc = require('./_transforms').transformArc,\n    collections = require('./_collections.js'),\n    referencesProps = collections.referencesProps,\n    defaultStrokeWidth = collections.attrsGroupsDefaults.presentation['stroke-width'],\n    cleanupOutData = require('../lib/svgo/tools').cleanupOutData,\n    removeLeadingZero = require('../lib/svgo/tools').removeLeadingZero,\n    prevCtrlPoint;\n/**\n * Convert path string to JS representation.\n *\n * @param {String} pathString input string\n * @param {Object} params plugin params\n * @return {Array} output array\n */\n\n\nexports.path2js = function (path) {\n  if (path.pathJS) return path.pathJS;\n  var paramsLength = {\n    // Number of parameters of every path command\n    H: 1,\n    V: 1,\n    M: 2,\n    L: 2,\n    T: 2,\n    Q: 4,\n    S: 4,\n    C: 6,\n    A: 7,\n    h: 1,\n    v: 1,\n    m: 2,\n    l: 2,\n    t: 2,\n    q: 4,\n    s: 4,\n    c: 6,\n    a: 7\n  },\n      pathData = [],\n      // JS representation of the path data\n  instruction,\n      // current instruction context\n  startMoveto = false; // splitting path string into array like ['M', '10 50', 'L', '20 30']\n\n  path.attr('d').value.split(regPathInstructions).forEach(function (data) {\n    if (!data) return;\n\n    if (!startMoveto) {\n      if (data == 'M' || data == 'm') {\n        startMoveto = true;\n      } else return;\n    } // instruction item\n\n\n    if (regPathInstructions.test(data)) {\n      instruction = data; // z - instruction w/o data\n\n      if (instruction == 'Z' || instruction == 'z') {\n        pathData.push({\n          instruction: 'z'\n        });\n      } // data item\n\n    } else {\n      /* jshint boss: true */\n      if (instruction == 'A' || instruction == 'a') {\n        var newData = [];\n\n        for (var args; args = regArcArgumentSequence.exec(data);) {\n          for (var i = 1; i < args.length; i++) {\n            newData.push(args[i]);\n          }\n        }\n\n        data = newData;\n      } else {\n        data = data.match(regCoordinateSequence);\n      }\n\n      if (!data) return;\n      data = data.map(Number); // Subsequent moveto pairs of coordinates are threated as implicit lineto commands\n      // http://www.w3.org/TR/SVG/paths.html#PathDataMovetoCommands\n\n      if (instruction == 'M' || instruction == 'm') {\n        pathData.push({\n          instruction: pathData.length == 0 ? 'M' : instruction,\n          data: data.splice(0, 2)\n        });\n        instruction = instruction == 'M' ? 'L' : 'l';\n      }\n\n      for (var pair = paramsLength[instruction]; data.length;) {\n        pathData.push({\n          instruction: instruction,\n          data: data.splice(0, pair)\n        });\n      }\n    }\n  }); // First moveto is actually absolute. Subsequent coordinates were separated above.\n\n  if (pathData.length && pathData[0].instruction == 'm') {\n    pathData[0].instruction = 'M';\n  }\n\n  path.pathJS = pathData;\n  return pathData;\n};\n/**\n * Convert relative Path data to absolute.\n *\n * @param {Array} data input data\n * @return {Array} output data\n */\n\n\nvar relative2absolute = exports.relative2absolute = function (data) {\n  var currentPoint = [0, 0],\n      subpathPoint = [0, 0],\n      i;\n  return data.map(function (item) {\n    var instruction = item.instruction,\n        itemData = item.data && item.data.slice();\n\n    if (instruction == 'M') {\n      set(currentPoint, itemData);\n      set(subpathPoint, itemData);\n    } else if ('mlcsqt'.indexOf(instruction) > -1) {\n      for (i = 0; i < itemData.length; i++) {\n        itemData[i] += currentPoint[i % 2];\n      }\n\n      set(currentPoint, itemData);\n\n      if (instruction == 'm') {\n        set(subpathPoint, itemData);\n      }\n    } else if (instruction == 'a') {\n      itemData[5] += currentPoint[0];\n      itemData[6] += currentPoint[1];\n      set(currentPoint, itemData);\n    } else if (instruction == 'h') {\n      itemData[0] += currentPoint[0];\n      currentPoint[0] = itemData[0];\n    } else if (instruction == 'v') {\n      itemData[0] += currentPoint[1];\n      currentPoint[1] = itemData[0];\n    } else if ('MZLCSQTA'.indexOf(instruction) > -1) {\n      set(currentPoint, itemData);\n    } else if (instruction == 'H') {\n      currentPoint[0] = itemData[0];\n    } else if (instruction == 'V') {\n      currentPoint[1] = itemData[0];\n    } else if (instruction == 'z') {\n      set(currentPoint, subpathPoint);\n    }\n\n    return instruction == 'z' ? {\n      instruction: 'z'\n    } : {\n      instruction: instruction.toUpperCase(),\n      data: itemData\n    };\n  });\n};\n/**\n * Apply transformation(s) to the Path data.\n *\n * @param {Object} elem current element\n * @param {Array} path input path data\n * @param {Object} params whether to apply transforms to stroked lines and transform precision (used for stroke width)\n * @return {Array} output path data\n */\n\n\nexports.applyTransforms = function (elem, path, params) {\n  // if there are no 'stroke' attr and references to other objects such as\n  // gradiends or clip-path which are also subjects to transform.\n  if (!elem.hasAttr('transform') || !elem.attr('transform').value || elem.someAttr(function (attr) {\n    return ~referencesProps.indexOf(attr.name) && ~attr.value.indexOf('url(');\n  })) return path;\n  var matrix = transformsMultiply(transform2js(elem.attr('transform').value)),\n      stroke = elem.computedAttr('stroke'),\n      id = elem.computedAttr('id'),\n      transformPrecision = params.transformPrecision,\n      newPoint,\n      scale;\n\n  if (stroke && stroke != 'none') {\n    if (!params.applyTransformsStroked || (matrix.data[0] != matrix.data[3] || matrix.data[1] != -matrix.data[2]) && (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2])) return path; // \"stroke-width\" should be inside the part with ID, otherwise it can be overrided in <use>\n\n    if (id) {\n      var idElem = elem,\n          hasStrokeWidth = false;\n\n      do {\n        if (idElem.hasAttr('stroke-width')) hasStrokeWidth = true;\n      } while (!idElem.hasAttr('id', id) && !hasStrokeWidth && (idElem = idElem.parentNode));\n\n      if (!hasStrokeWidth) return path;\n    }\n\n    scale = +Math.sqrt(matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]).toFixed(transformPrecision);\n\n    if (scale !== 1) {\n      var strokeWidth = elem.computedAttr('stroke-width') || defaultStrokeWidth;\n\n      if (!elem.hasAttr('vector-effect') || elem.attr('vector-effect').value !== 'non-scaling-stroke') {\n        if (elem.hasAttr('stroke-width')) {\n          elem.attrs['stroke-width'].value = elem.attrs['stroke-width'].value.trim().replace(regNumericValues, function (num) {\n            return removeLeadingZero(num * scale);\n          });\n        } else {\n          elem.addAttr({\n            name: 'stroke-width',\n            prefix: '',\n            local: 'stroke-width',\n            value: strokeWidth.replace(regNumericValues, function (num) {\n              return removeLeadingZero(num * scale);\n            })\n          });\n        }\n      }\n    }\n  } else if (id) {\n    // Stroke and stroke-width can be redefined with <use>\n    return path;\n  }\n\n  path.forEach(function (pathItem) {\n    if (pathItem.data) {\n      // h -> l\n      if (pathItem.instruction === 'h') {\n        pathItem.instruction = 'l';\n        pathItem.data[1] = 0; // v -> l\n      } else if (pathItem.instruction === 'v') {\n        pathItem.instruction = 'l';\n        pathItem.data[1] = pathItem.data[0];\n        pathItem.data[0] = 0;\n      } // if there is a translate() transform\n\n\n      if (pathItem.instruction === 'M' && (matrix.data[4] !== 0 || matrix.data[5] !== 0)) {\n        // then apply it only to the first absoluted M\n        newPoint = transformPoint(matrix.data, pathItem.data[0], pathItem.data[1]);\n        set(pathItem.data, newPoint);\n        set(pathItem.coords, newPoint); // clear translate() data from transform matrix\n\n        matrix.data[4] = 0;\n        matrix.data[5] = 0;\n      } else {\n        if (pathItem.instruction == 'a') {\n          transformArc(pathItem.data, matrix.data); // reduce number of digits in rotation angle\n\n          if (Math.abs(pathItem.data[2]) > 80) {\n            var a = pathItem.data[0],\n                rotation = pathItem.data[2];\n            pathItem.data[0] = pathItem.data[1];\n            pathItem.data[1] = a;\n            pathItem.data[2] = rotation + (rotation > 0 ? -90 : 90);\n          }\n\n          newPoint = transformPoint(matrix.data, pathItem.data[5], pathItem.data[6]);\n          pathItem.data[5] = newPoint[0];\n          pathItem.data[6] = newPoint[1];\n        } else {\n          for (var i = 0; i < pathItem.data.length; i += 2) {\n            newPoint = transformPoint(matrix.data, pathItem.data[i], pathItem.data[i + 1]);\n            pathItem.data[i] = newPoint[0];\n            pathItem.data[i + 1] = newPoint[1];\n          }\n        }\n\n        pathItem.coords[0] = pathItem.base[0] + pathItem.data[pathItem.data.length - 2];\n        pathItem.coords[1] = pathItem.base[1] + pathItem.data[pathItem.data.length - 1];\n      }\n    }\n  }); // remove transform attr\n\n  elem.removeAttr('transform');\n  return path;\n};\n/**\n * Apply transform 3x3 matrix to x-y point.\n *\n * @param {Array} matrix transform 3x3 matrix\n * @param {Array} point x-y point\n * @return {Array} point with new coordinates\n */\n\n\nfunction transformPoint(matrix, x, y) {\n  return [matrix[0] * x + matrix[2] * y + matrix[4], matrix[1] * x + matrix[3] * y + matrix[5]];\n}\n/**\n * Compute Cubic Bézie bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n * @param {Float} xd\n * @param {Float} yd\n *\n * @return {Object}\n */\n\n\nexports.computeCubicBoundingBox = function (xa, ya, xb, yb, xc, yc, xd, yd) {\n  var minx = Number.POSITIVE_INFINITY,\n      miny = Number.POSITIVE_INFINITY,\n      maxx = Number.NEGATIVE_INFINITY,\n      maxy = Number.NEGATIVE_INFINITY,\n      ts,\n      t,\n      x,\n      y,\n      i; // X\n\n  if (xa < minx) {\n    minx = xa;\n  }\n\n  if (xa > maxx) {\n    maxx = xa;\n  }\n\n  if (xd < minx) {\n    minx = xd;\n  }\n\n  if (xd > maxx) {\n    maxx = xd;\n  }\n\n  ts = computeCubicFirstDerivativeRoots(xa, xb, xc, xd);\n\n  for (i = 0; i < ts.length; i++) {\n    t = ts[i];\n\n    if (t >= 0 && t <= 1) {\n      x = computeCubicBaseValue(t, xa, xb, xc, xd); // y = computeCubicBaseValue(t, ya, yb, yc, yd);\n\n      if (x < minx) {\n        minx = x;\n      }\n\n      if (x > maxx) {\n        maxx = x;\n      }\n    }\n  } // Y\n\n\n  if (ya < miny) {\n    miny = ya;\n  }\n\n  if (ya > maxy) {\n    maxy = ya;\n  }\n\n  if (yd < miny) {\n    miny = yd;\n  }\n\n  if (yd > maxy) {\n    maxy = yd;\n  }\n\n  ts = computeCubicFirstDerivativeRoots(ya, yb, yc, yd);\n\n  for (i = 0; i < ts.length; i++) {\n    t = ts[i];\n\n    if (t >= 0 && t <= 1) {\n      // x = computeCubicBaseValue(t, xa, xb, xc, xd);\n      y = computeCubicBaseValue(t, ya, yb, yc, yd);\n\n      if (y < miny) {\n        miny = y;\n      }\n\n      if (y > maxy) {\n        maxy = y;\n      }\n    }\n  }\n\n  return {\n    minx: minx,\n    miny: miny,\n    maxx: maxx,\n    maxy: maxy\n  };\n}; // compute the value for the cubic bezier function at time=t\n\n\nfunction computeCubicBaseValue(t, a, b, c, d) {\n  var mt = 1 - t;\n  return mt * mt * mt * a + 3 * mt * mt * t * b + 3 * mt * t * t * c + t * t * t * d;\n} // compute the value for the first derivative of the cubic bezier function at time=t\n\n\nfunction computeCubicFirstDerivativeRoots(a, b, c, d) {\n  var result = [-1, -1],\n      tl = -a + 2 * b - c,\n      tr = -Math.sqrt(-a * (c - d) + b * b - b * (c + d) + c * c),\n      dn = -a + 3 * b - 3 * c + d;\n\n  if (dn !== 0) {\n    result[0] = (tl + tr) / dn;\n    result[1] = (tl - tr) / dn;\n  }\n\n  return result;\n}\n/**\n * Compute Quadratic Bézier bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n *\n * @return {Object}\n */\n\n\nexports.computeQuadraticBoundingBox = function (xa, ya, xb, yb, xc, yc) {\n  var minx = Number.POSITIVE_INFINITY,\n      miny = Number.POSITIVE_INFINITY,\n      maxx = Number.NEGATIVE_INFINITY,\n      maxy = Number.NEGATIVE_INFINITY,\n      t,\n      x,\n      y; // X\n\n  if (xa < minx) {\n    minx = xa;\n  }\n\n  if (xa > maxx) {\n    maxx = xa;\n  }\n\n  if (xc < minx) {\n    minx = xc;\n  }\n\n  if (xc > maxx) {\n    maxx = xc;\n  }\n\n  t = computeQuadraticFirstDerivativeRoot(xa, xb, xc);\n\n  if (t >= 0 && t <= 1) {\n    x = computeQuadraticBaseValue(t, xa, xb, xc); // y = computeQuadraticBaseValue(t, ya, yb, yc);\n\n    if (x < minx) {\n      minx = x;\n    }\n\n    if (x > maxx) {\n      maxx = x;\n    }\n  } // Y\n\n\n  if (ya < miny) {\n    miny = ya;\n  }\n\n  if (ya > maxy) {\n    maxy = ya;\n  }\n\n  if (yc < miny) {\n    miny = yc;\n  }\n\n  if (yc > maxy) {\n    maxy = yc;\n  }\n\n  t = computeQuadraticFirstDerivativeRoot(ya, yb, yc);\n\n  if (t >= 0 && t <= 1) {\n    // x = computeQuadraticBaseValue(t, xa, xb, xc);\n    y = computeQuadraticBaseValue(t, ya, yb, yc);\n\n    if (y < miny) {\n      miny = y;\n    }\n\n    if (y > maxy) {\n      maxy = y;\n    }\n  }\n\n  return {\n    minx: minx,\n    miny: miny,\n    maxx: maxx,\n    maxy: maxy\n  };\n}; // compute the value for the quadratic bezier function at time=t\n\n\nfunction computeQuadraticBaseValue(t, a, b, c) {\n  var mt = 1 - t;\n  return mt * mt * a + 2 * mt * t * b + t * t * c;\n} // compute the value for the first derivative of the quadratic bezier function at time=t\n\n\nfunction computeQuadraticFirstDerivativeRoot(a, b, c) {\n  var t = -1,\n      denominator = a - 2 * b + c;\n\n  if (denominator !== 0) {\n    t = (a - b) / denominator;\n  }\n\n  return t;\n}\n/**\n * Convert path array to string.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {String} output path string\n */\n\n\nexports.js2path = function (path, data, params) {\n  path.pathJS = data;\n\n  if (params.collapseRepeated) {\n    data = collapseRepeated(data);\n  }\n\n  path.attr('d').value = data.reduce(function (pathString, item) {\n    var strData = '';\n\n    if (item.data) {\n      strData = cleanupOutData(item.data, params, item.instruction);\n    }\n\n    return pathString += item.instruction + strData;\n  }, '');\n};\n/**\n * Collapse repeated instructions data\n *\n * @param {Array} path input path data\n * @return {Array} output path data\n */\n\n\nfunction collapseRepeated(data) {\n  var prev, prevIndex; // copy an array and modifieds item to keep original data untouched\n\n  data = data.reduce(function (newPath, item) {\n    if (prev && item.data && item.instruction == prev.instruction) {\n      // concat previous data with current\n      if (item.instruction != 'M') {\n        prev = newPath[prevIndex] = {\n          instruction: prev.instruction,\n          data: prev.data.concat(item.data),\n          coords: item.coords,\n          base: prev.base\n        };\n      } else {\n        prev.data = item.data;\n        prev.coords = item.coords;\n      }\n    } else {\n      newPath.push(item);\n      prev = item;\n      prevIndex = newPath.length - 1;\n    }\n\n    return newPath;\n  }, []);\n  return data;\n}\n\nfunction set(dest, source) {\n  dest[0] = source[source.length - 2];\n  dest[1] = source[source.length - 1];\n  return dest;\n}\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @param {Array} path1 JS path representation\n * @param {Array} path2 JS path representation\n * @return {Boolean}\n */\n\n\nexports.intersects = function (path1, path2) {\n  if (path1.length < 3 || path2.length < 3) return false; // nothing to fill\n  // Collect points of every subpath.\n\n  var points1 = relative2absolute(path1).reduce(gatherPoints, []),\n      points2 = relative2absolute(path2).reduce(gatherPoints, []); // Axis-aligned bounding box check.\n\n  if (points1.maxX <= points2.minX || points2.maxX <= points1.minX || points1.maxY <= points2.minY || points2.maxY <= points1.minY || points1.every(function (set1) {\n    return points2.every(function (set2) {\n      return set1[set1.maxX][0] <= set2[set2.minX][0] || set2[set2.maxX][0] <= set1[set1.minX][0] || set1[set1.maxY][1] <= set2[set2.minY][1] || set2[set2.maxY][1] <= set1[set1.minY][1];\n    });\n  })) return false; // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).\n\n  var hullNest1 = points1.map(convexHull),\n      hullNest2 = points2.map(convexHull); // Check intersection of every subpath of the first path with every subpath of the second.\n\n  return hullNest1.some(function (hull1) {\n    if (hull1.length < 3) return false;\n    return hullNest2.some(function (hull2) {\n      if (hull2.length < 3) return false;\n      var simplex = [getSupport(hull1, hull2, [1, 0])],\n          // create the initial simplex\n      direction = minus(simplex[0]); // set the direction to point towards the origin\n\n      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n\n      while (true) {\n        if (iterations-- == 0) {\n          console.error('Error: infinite loop while processing mergePaths plugin.');\n          return true; // true is the safe value that means “do nothing with paths”\n        } // add a new point\n\n\n        simplex.push(getSupport(hull1, hull2, direction)); // see if the new point was on the correct side of the origin\n\n        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false; // process the simplex\n\n        if (processSimplex(simplex, direction)) return true;\n      }\n    });\n  });\n\n  function getSupport(a, b, direction) {\n    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n  } // Computes farthest polygon point in particular direction.\n  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n\n\n  function supportPoint(polygon, direction) {\n    var index = direction[1] >= 0 ? direction[0] < 0 ? polygon.maxY : polygon.maxX : direction[0] < 0 ? polygon.minX : polygon.minY,\n        max = -Infinity,\n        value;\n\n    while ((value = dot(polygon[index], direction)) > max) {\n      max = value;\n      index = ++index % polygon.length;\n    }\n\n    return polygon[(index || polygon.length) - 1];\n  }\n};\n\nfunction processSimplex(simplex, direction) {\n  /* jshint -W004 */\n  // we only need to handle to 1-simplex and 2-simplex\n  if (simplex.length == 2) {\n    // 1-simplex\n    var a = simplex[1],\n        b = simplex[0],\n        AO = minus(simplex[1]),\n        AB = sub(b, a); // AO is in the same direction as AB\n\n    if (dot(AO, AB) > 0) {\n      // get the vector perpendicular to AB facing O\n      set(direction, orth(AB, a));\n    } else {\n      set(direction, AO); // only A remains in the simplex\n\n      simplex.shift();\n    }\n  } else {\n    // 2-simplex\n    var a = simplex[2],\n        // [a, b, c] = simplex\n    b = simplex[1],\n        c = simplex[0],\n        AB = sub(b, a),\n        AC = sub(c, a),\n        AO = minus(a),\n        ACB = orth(AB, AC),\n        // the vector perpendicular to AB facing away from C\n    ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n    if (dot(ACB, AO) > 0) {\n      if (dot(AB, AO) > 0) {\n        // region 4\n        set(direction, ACB);\n        simplex.shift(); // simplex = [b, a]\n      } else {\n        // region 5\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else if (dot(ABC, AO) > 0) {\n      if (dot(AC, AO) > 0) {\n        // region 6\n        set(direction, ABC);\n        simplex.splice(1, 1); // simplex = [c, a]\n      } else {\n        // region 5 (again)\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else // region 7\n      return true;\n  }\n\n  return false;\n}\n\nfunction minus(v) {\n  return [-v[0], -v[1]];\n}\n\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n\nfunction orth(v, from) {\n  var o = [-v[1], v[0]];\n  return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\n\nfunction gatherPoints(points, item, index, path) {\n  var subPath = points.length && points[points.length - 1],\n      prev = index && path[index - 1],\n      basePoint = subPath.length && subPath[subPath.length - 1],\n      data = item.data,\n      ctrlPoint = basePoint;\n\n  switch (item.instruction) {\n    case 'M':\n      points.push(subPath = []);\n      break;\n\n    case 'H':\n      addPoint(subPath, [data[0], basePoint[1]]);\n      break;\n\n    case 'V':\n      addPoint(subPath, [basePoint[0], data[0]]);\n      break;\n\n    case 'Q':\n      addPoint(subPath, data.slice(0, 2));\n      prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n\n      break;\n\n    case 'T':\n      if (prev.instruction == 'Q' || prev.instruction == 'T') {\n        ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n        addPoint(subPath, ctrlPoint);\n        prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n      }\n\n      break;\n\n    case 'C':\n      // Approximate quibic Bezier curve with middle points between control points\n      addPoint(subPath, [.5 * (basePoint[0] + data[0]), .5 * (basePoint[1] + data[1])]);\n      addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n      addPoint(subPath, [.5 * (data[2] + data[4]), .5 * (data[3] + data[5])]);\n      prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n\n      break;\n\n    case 'S':\n      if (prev.instruction == 'C' || prev.instruction == 'S') {\n        addPoint(subPath, [basePoint[0] + .5 * prevCtrlPoint[0], basePoint[1] + .5 * prevCtrlPoint[1]]);\n        ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n      }\n\n      addPoint(subPath, [.5 * (ctrlPoint[0] + data[0]), .5 * (ctrlPoint[1] + data[1])]);\n      addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n      prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n      break;\n\n    case 'A':\n      // Convert the arc to bezier curves and use the same approximation\n      var curves = a2c.apply(0, basePoint.concat(data));\n\n      for (var cData; (cData = curves.splice(0, 6).map(toAbsolute)).length;) {\n        addPoint(subPath, [.5 * (basePoint[0] + cData[0]), .5 * (basePoint[1] + cData[1])]);\n        addPoint(subPath, [.5 * (cData[0] + cData[2]), .5 * (cData[1] + cData[3])]);\n        addPoint(subPath, [.5 * (cData[2] + cData[4]), .5 * (cData[3] + cData[5])]);\n        if (curves.length) addPoint(subPath, basePoint = cData.slice(-2));\n      }\n\n      break;\n  } // Save final command coordinates\n\n\n  if (data && data.length >= 2) addPoint(subPath, data.slice(-2));\n  return points;\n\n  function toAbsolute(n, i) {\n    return n + basePoint[i % 2];\n  } // Writes data about the extreme points on each axle\n\n\n  function addPoint(path, point) {\n    if (!path.length || point[1] > path[path.maxY][1]) {\n      path.maxY = path.length;\n      points.maxY = points.length ? Math.max(point[1], points.maxY) : point[1];\n    }\n\n    if (!path.length || point[0] > path[path.maxX][0]) {\n      path.maxX = path.length;\n      points.maxX = points.length ? Math.max(point[0], points.maxX) : point[0];\n    }\n\n    if (!path.length || point[1] < path[path.minY][1]) {\n      path.minY = path.length;\n      points.minY = points.length ? Math.min(point[1], points.minY) : point[1];\n    }\n\n    if (!path.length || point[0] < path[path.minX][0]) {\n      path.minX = path.length;\n      points.minX = points.length ? Math.min(point[0], points.minX) : point[0];\n    }\n\n    path.push(point);\n  }\n}\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @param points An array of [X, Y] coordinates\n */\n\n\nfunction convexHull(points) {\n  /* jshint -W004 */\n  points.sort(function (a, b) {\n    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n  });\n  var lower = [],\n      minY = 0,\n      bottom = 0;\n\n  for (var i = 0; i < points.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n      lower.pop();\n    }\n\n    if (points[i][1] < points[minY][1]) {\n      minY = i;\n      bottom = lower.length;\n    }\n\n    lower.push(points[i]);\n  }\n\n  var upper = [],\n      maxY = points.length - 1,\n      top = 0;\n\n  for (var i = points.length; i--;) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\n      upper.pop();\n    }\n\n    if (points[i][1] > points[maxY][1]) {\n      maxY = i;\n      top = upper.length;\n    }\n\n    upper.push(points[i]);\n  } // last points are equal to starting points of the other part\n\n\n  upper.pop();\n  lower.pop();\n  var hull = lower.concat(upper);\n  hull.minX = 0; // by sorting\n\n  hull.maxX = lower.length;\n  hull.minY = bottom;\n  hull.maxY = (lower.length + top) % hull.length;\n  return hull;\n}\n\nfunction cross(o, a, b) {\n  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n/* Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n */\n// jshint ignore: start\n\n\nfunction a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  var _120 = Math.PI * 120 / 180,\n      rad = Math.PI / 180 * (+angle || 0),\n      res = [],\n      rotateX = function (x, y, rad) {\n    return x * Math.cos(rad) - y * Math.sin(rad);\n  },\n      rotateY = function (x, y, rad) {\n    return x * Math.sin(rad) + y * Math.cos(rad);\n  };\n\n  if (!recursive) {\n    x1 = rotateX(x1, y1, -rad);\n    y1 = rotateY(x1, y1, -rad);\n    x2 = rotateX(x2, y2, -rad);\n    y2 = rotateY(x2, y2, -rad);\n    var x = (x1 - x2) / 2,\n        y = (y1 - y2) / 2;\n    var h = x * x / (rx * rx) + y * y / (ry * ry);\n\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n\n    var rx2 = rx * rx,\n        ry2 = ry * ry,\n        k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n        cx = k * rx * y / ry + (x1 + x2) / 2,\n        cy = k * -ry * x / rx + (y1 + y2) / 2,\n        f1 = Math.asin(((y1 - cy) / ry).toFixed(9)),\n        f2 = Math.asin(((y2 - cy) / ry).toFixed(9));\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n\n  var df = f2 - f1;\n\n  if (Math.abs(df) > _120) {\n    var f2old = f2,\n        x2old = x2,\n        y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n\n  df = f2 - f1;\n  var c1 = Math.cos(f1),\n      s1 = Math.sin(f1),\n      c2 = Math.cos(f2),\n      s2 = Math.sin(f2),\n      t = Math.tan(df / 4),\n      hx = 4 / 3 * rx * t,\n      hy = 4 / 3 * ry * t,\n      m = [-hx * s1, hy * c1, x2 + hx * s2 - x1, y2 - hy * c2 - y1, x2 - x1, y2 - y1];\n\n  if (recursive) {\n    return m.concat(res);\n  } else {\n    res = m.concat(res);\n    var newres = [];\n\n    for (var i = 0, n = res.length; i < n; i++) {\n      newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);\n    }\n\n    return newres;\n  }\n} // jshint ignore: end","map":{"version":3,"names":["rNumber","String","raw","rCommaWsp","rNumberCommaWsp","rFlagCommaWsp","rCoordinatePair","rArcSeq","repeat","regPathInstructions","regCoordinateSequence","RegExp","regArcArgumentSequence","regNumericValues","transform2js","require","transformsMultiply","transformArc","collections","referencesProps","defaultStrokeWidth","attrsGroupsDefaults","presentation","cleanupOutData","removeLeadingZero","prevCtrlPoint","exports","path2js","path","pathJS","paramsLength","H","V","M","L","T","Q","S","C","A","h","v","m","l","t","q","s","c","a","pathData","instruction","startMoveto","attr","value","split","forEach","data","test","push","newData","args","exec","i","length","match","map","Number","splice","pair","relative2absolute","currentPoint","subpathPoint","item","itemData","slice","set","indexOf","toUpperCase","applyTransforms","elem","params","hasAttr","someAttr","name","matrix","stroke","computedAttr","id","transformPrecision","newPoint","scale","applyTransformsStroked","idElem","hasStrokeWidth","parentNode","Math","sqrt","toFixed","strokeWidth","attrs","trim","replace","num","addAttr","prefix","local","pathItem","transformPoint","coords","abs","rotation","base","removeAttr","x","y","computeCubicBoundingBox","xa","ya","xb","yb","xc","yc","xd","yd","minx","POSITIVE_INFINITY","miny","maxx","NEGATIVE_INFINITY","maxy","ts","computeCubicFirstDerivativeRoots","computeCubicBaseValue","b","d","mt","result","tl","tr","dn","computeQuadraticBoundingBox","computeQuadraticFirstDerivativeRoot","computeQuadraticBaseValue","denominator","js2path","collapseRepeated","reduce","pathString","strData","prev","prevIndex","newPath","concat","dest","source","intersects","path1","path2","points1","gatherPoints","points2","maxX","minX","maxY","minY","every","set1","set2","hullNest1","convexHull","hullNest2","some","hull1","hull2","simplex","getSupport","direction","minus","iterations","console","error","dot","processSimplex","sub","supportPoint","polygon","index","max","Infinity","AO","AB","orth","shift","AC","ACB","ABC","v1","v2","from","o","points","subPath","basePoint","ctrlPoint","addPoint","curves","a2c","apply","cData","toAbsolute","n","point","min","sort","lower","bottom","cross","pop","upper","top","hull","x1","y1","rx","ry","angle","large_arc_flag","sweep_flag","x2","y2","recursive","_120","PI","rad","res","rotateX","cos","sin","rotateY","rx2","ry2","k","cx","cy","f1","asin","f2","df","f2old","x2old","y2old","c1","s1","c2","s2","tan","hx","hy","newres"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/svgo/plugins/_path.js"],"sourcesContent":["/* global a2c */\n'use strict';\n\nvar rNumber = String.raw`[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*`,\n    rCommaWsp = String.raw`(?:\\s,?\\s*|,\\s*)`,\n    rNumberCommaWsp = `(${rNumber})` + rCommaWsp,\n    rFlagCommaWsp = `([01])${rCommaWsp}?`,\n    rCoordinatePair = String.raw`(${rNumber})${rCommaWsp}?(${rNumber})`,\n    rArcSeq = (rNumberCommaWsp + '?').repeat(2) + rNumberCommaWsp + rFlagCommaWsp.repeat(2) + rCoordinatePair;\n\nvar regPathInstructions = /([MmLlHhVvCcSsQqTtAaZz])\\s*/,\n    regCoordinateSequence = new RegExp(rNumber, 'g'),\n    regArcArgumentSequence = new RegExp(rArcSeq, 'g'),\n    regNumericValues = /[-+]?(\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/,\n    transform2js = require('./_transforms').transform2js,\n    transformsMultiply = require('./_transforms').transformsMultiply,\n    transformArc = require('./_transforms').transformArc,\n    collections = require('./_collections.js'),\n    referencesProps = collections.referencesProps,\n    defaultStrokeWidth = collections.attrsGroupsDefaults.presentation['stroke-width'],\n    cleanupOutData = require('../lib/svgo/tools').cleanupOutData,\n    removeLeadingZero = require('../lib/svgo/tools').removeLeadingZero,\n    prevCtrlPoint;\n\n/**\n * Convert path string to JS representation.\n *\n * @param {String} pathString input string\n * @param {Object} params plugin params\n * @return {Array} output array\n */\nexports.path2js = function(path) {\n    if (path.pathJS) return path.pathJS;\n\n    var paramsLength = { // Number of parameters of every path command\n            H: 1, V: 1, M: 2, L: 2, T: 2, Q: 4, S: 4, C: 6, A: 7,\n            h: 1, v: 1, m: 2, l: 2, t: 2, q: 4, s: 4, c: 6, a: 7\n        },\n        pathData = [],   // JS representation of the path data\n        instruction, // current instruction context\n        startMoveto = false;\n\n    // splitting path string into array like ['M', '10 50', 'L', '20 30']\n    path.attr('d').value.split(regPathInstructions).forEach(function(data) {\n        if (!data) return;\n        if (!startMoveto) {\n            if (data == 'M' || data == 'm') {\n                startMoveto = true;\n            } else return;\n        }\n\n        // instruction item\n        if (regPathInstructions.test(data)) {\n            instruction = data;\n\n            // z - instruction w/o data\n            if (instruction == 'Z' || instruction == 'z') {\n                pathData.push({\n                    instruction: 'z'\n                });\n            }\n        // data item\n        } else {\n            /* jshint boss: true */\n            if (instruction == 'A' || instruction == 'a') {\n                var newData = [];\n                for (var args; (args = regArcArgumentSequence.exec(data));) {\n                    for (var i = 1; i < args.length; i++) {\n                        newData.push(args[i]);\n                    }\n                }\n                data = newData;\n            } else {\n                data = data.match(regCoordinateSequence);\n            }\n            if (!data) return;\n\n            data = data.map(Number);\n            // Subsequent moveto pairs of coordinates are threated as implicit lineto commands\n            // http://www.w3.org/TR/SVG/paths.html#PathDataMovetoCommands\n            if (instruction == 'M' || instruction == 'm') {\n                pathData.push({\n                    instruction: pathData.length == 0 ? 'M' : instruction,\n                    data: data.splice(0, 2)\n                });\n                instruction = instruction == 'M' ? 'L' : 'l';\n            }\n\n            for (var pair = paramsLength[instruction]; data.length;) {\n                pathData.push({\n                    instruction: instruction,\n                    data: data.splice(0, pair)\n                });\n            }\n        }\n    });\n\n    // First moveto is actually absolute. Subsequent coordinates were separated above.\n    if (pathData.length && pathData[0].instruction == 'm') {\n        pathData[0].instruction = 'M';\n    }\n    path.pathJS = pathData;\n\n    return pathData;\n};\n\n/**\n * Convert relative Path data to absolute.\n *\n * @param {Array} data input data\n * @return {Array} output data\n */\nvar relative2absolute = exports.relative2absolute = function(data) {\n    var currentPoint = [0, 0],\n        subpathPoint = [0, 0],\n        i;\n\n    return data.map(function(item) {\n\n        var instruction = item.instruction,\n            itemData = item.data && item.data.slice();\n\n        if (instruction == 'M') {\n\n            set(currentPoint, itemData);\n            set(subpathPoint, itemData);\n\n        } else if ('mlcsqt'.indexOf(instruction) > -1) {\n\n            for (i = 0; i < itemData.length; i++) {\n                itemData[i] += currentPoint[i % 2];\n            }\n            set(currentPoint, itemData);\n\n            if (instruction == 'm') {\n                set(subpathPoint, itemData);\n            }\n\n        } else if (instruction == 'a') {\n\n            itemData[5] += currentPoint[0];\n            itemData[6] += currentPoint[1];\n            set(currentPoint, itemData);\n\n        } else if (instruction == 'h') {\n\n            itemData[0] += currentPoint[0];\n            currentPoint[0] = itemData[0];\n\n        } else if (instruction == 'v') {\n\n            itemData[0] += currentPoint[1];\n            currentPoint[1] = itemData[0];\n\n        } else if ('MZLCSQTA'.indexOf(instruction) > -1) {\n\n            set(currentPoint, itemData);\n\n        } else if (instruction == 'H') {\n\n            currentPoint[0] = itemData[0];\n\n        } else if (instruction == 'V') {\n\n            currentPoint[1] = itemData[0];\n\n        } else if (instruction == 'z') {\n\n            set(currentPoint, subpathPoint);\n\n        }\n\n        return instruction == 'z' ?\n            { instruction: 'z' } :\n            {\n                instruction: instruction.toUpperCase(),\n                data: itemData\n            };\n\n    });\n};\n\n/**\n * Apply transformation(s) to the Path data.\n *\n * @param {Object} elem current element\n * @param {Array} path input path data\n * @param {Object} params whether to apply transforms to stroked lines and transform precision (used for stroke width)\n * @return {Array} output path data\n */\nexports.applyTransforms = function(elem, path, params) {\n    // if there are no 'stroke' attr and references to other objects such as\n    // gradiends or clip-path which are also subjects to transform.\n    if (!elem.hasAttr('transform') || !elem.attr('transform').value ||\n        elem.someAttr(function(attr) {\n            return ~referencesProps.indexOf(attr.name) && ~attr.value.indexOf('url(');\n        }))\n        return path;\n\n    var matrix = transformsMultiply(transform2js(elem.attr('transform').value)),\n        stroke = elem.computedAttr('stroke'),\n        id = elem.computedAttr('id'),\n        transformPrecision = params.transformPrecision,\n        newPoint, scale;\n\n    if (stroke && stroke != 'none') {\n        if (!params.applyTransformsStroked ||\n            (matrix.data[0] != matrix.data[3] || matrix.data[1] != -matrix.data[2]) &&\n            (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2]))\n            return path;\n\n        // \"stroke-width\" should be inside the part with ID, otherwise it can be overrided in <use>\n        if (id) {\n            var idElem = elem,\n                hasStrokeWidth = false;\n\n            do {\n                if (idElem.hasAttr('stroke-width')) hasStrokeWidth = true;\n            } while (!idElem.hasAttr('id', id) && !hasStrokeWidth && (idElem = idElem.parentNode));\n\n            if (!hasStrokeWidth) return path;\n        }\n\n        scale = +Math.sqrt(matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]).toFixed(transformPrecision);\n\n        if (scale !== 1) {\n            var strokeWidth = elem.computedAttr('stroke-width') || defaultStrokeWidth;\n\n            if (!elem.hasAttr('vector-effect') || elem.attr('vector-effect').value !== 'non-scaling-stroke') {\n                if (elem.hasAttr('stroke-width')) {\n                    elem.attrs['stroke-width'].value = elem.attrs['stroke-width'].value.trim()\n                        .replace(regNumericValues, function(num) {\n                            return removeLeadingZero(num * scale);\n                        });\n                } else {\n                    elem.addAttr({\n                        name: 'stroke-width',\n                        prefix: '',\n                        local: 'stroke-width',\n                        value: strokeWidth.replace(regNumericValues, function(num) {\n                            return removeLeadingZero(num * scale);\n                        })\n                    });\n                }\n            }\n        }\n    } else if (id) { // Stroke and stroke-width can be redefined with <use>\n        return path;\n    }\n\n    path.forEach(function(pathItem) {\n\n        if (pathItem.data) {\n\n            // h -> l\n            if (pathItem.instruction === 'h') {\n\n                pathItem.instruction = 'l';\n                pathItem.data[1] = 0;\n\n            // v -> l\n            } else if (pathItem.instruction === 'v') {\n\n                pathItem.instruction = 'l';\n                pathItem.data[1] = pathItem.data[0];\n                pathItem.data[0] = 0;\n\n            }\n\n            // if there is a translate() transform\n            if (pathItem.instruction === 'M' &&\n                (matrix.data[4] !== 0 ||\n                matrix.data[5] !== 0)\n            ) {\n\n                // then apply it only to the first absoluted M\n                newPoint = transformPoint(matrix.data, pathItem.data[0], pathItem.data[1]);\n                set(pathItem.data, newPoint);\n                set(pathItem.coords, newPoint);\n\n                // clear translate() data from transform matrix\n                matrix.data[4] = 0;\n                matrix.data[5] = 0;\n\n            } else {\n\n                if (pathItem.instruction == 'a') {\n\n                    transformArc(pathItem.data, matrix.data);\n\n                    // reduce number of digits in rotation angle\n                    if (Math.abs(pathItem.data[2]) > 80) {\n                        var a = pathItem.data[0],\n                            rotation = pathItem.data[2];\n                        pathItem.data[0] = pathItem.data[1];\n                        pathItem.data[1] = a;\n                        pathItem.data[2] = rotation + (rotation > 0 ? -90 : 90);\n                    }\n\n                    newPoint = transformPoint(matrix.data, pathItem.data[5], pathItem.data[6]);\n                    pathItem.data[5] = newPoint[0];\n                    pathItem.data[6] = newPoint[1];\n\n                } else {\n\n                    for (var i = 0; i < pathItem.data.length; i += 2) {\n                        newPoint = transformPoint(matrix.data, pathItem.data[i], pathItem.data[i + 1]);\n                        pathItem.data[i] = newPoint[0];\n                        pathItem.data[i + 1] = newPoint[1];\n                    }\n                }\n\n                pathItem.coords[0] = pathItem.base[0] + pathItem.data[pathItem.data.length - 2];\n                pathItem.coords[1] = pathItem.base[1] + pathItem.data[pathItem.data.length - 1];\n\n            }\n\n        }\n\n    });\n\n    // remove transform attr\n    elem.removeAttr('transform');\n\n    return path;\n};\n\n/**\n * Apply transform 3x3 matrix to x-y point.\n *\n * @param {Array} matrix transform 3x3 matrix\n * @param {Array} point x-y point\n * @return {Array} point with new coordinates\n */\nfunction transformPoint(matrix, x, y) {\n\n    return [\n        matrix[0] * x + matrix[2] * y + matrix[4],\n        matrix[1] * x + matrix[3] * y + matrix[5]\n    ];\n\n}\n\n/**\n * Compute Cubic Bézie bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n * @param {Float} xd\n * @param {Float} yd\n *\n * @return {Object}\n */\nexports.computeCubicBoundingBox = function(xa, ya, xb, yb, xc, yc, xd, yd) {\n\n    var minx = Number.POSITIVE_INFINITY,\n        miny = Number.POSITIVE_INFINITY,\n        maxx = Number.NEGATIVE_INFINITY,\n        maxy = Number.NEGATIVE_INFINITY,\n        ts,\n        t,\n        x,\n        y,\n        i;\n\n    // X\n    if (xa < minx) { minx = xa; }\n    if (xa > maxx) { maxx = xa; }\n    if (xd < minx) { minx= xd; }\n    if (xd > maxx) { maxx = xd; }\n\n    ts = computeCubicFirstDerivativeRoots(xa, xb, xc, xd);\n\n    for (i = 0; i < ts.length; i++) {\n\n        t = ts[i];\n\n        if (t >= 0 && t <= 1) {\n            x = computeCubicBaseValue(t, xa, xb, xc, xd);\n            // y = computeCubicBaseValue(t, ya, yb, yc, yd);\n\n            if (x < minx) { minx = x; }\n            if (x > maxx) { maxx = x; }\n        }\n\n    }\n\n    // Y\n    if (ya < miny) { miny = ya; }\n    if (ya > maxy) { maxy = ya; }\n    if (yd < miny) { miny = yd; }\n    if (yd > maxy) { maxy = yd; }\n\n    ts = computeCubicFirstDerivativeRoots(ya, yb, yc, yd);\n\n    for (i = 0; i < ts.length; i++) {\n\n        t = ts[i];\n\n        if (t >= 0 && t <= 1) {\n            // x = computeCubicBaseValue(t, xa, xb, xc, xd);\n            y = computeCubicBaseValue(t, ya, yb, yc, yd);\n\n            if (y < miny) { miny = y; }\n            if (y > maxy) { maxy = y; }\n        }\n\n    }\n\n    return {\n        minx: minx,\n        miny: miny,\n        maxx: maxx,\n        maxy: maxy\n    };\n\n};\n\n// compute the value for the cubic bezier function at time=t\nfunction computeCubicBaseValue(t, a, b, c, d) {\n\n    var mt = 1 - t;\n\n    return mt * mt * mt * a + 3 * mt * mt * t * b + 3 * mt * t * t * c + t * t * t * d;\n\n}\n\n// compute the value for the first derivative of the cubic bezier function at time=t\nfunction computeCubicFirstDerivativeRoots(a, b, c, d) {\n\n    var result = [-1, -1],\n        tl = -a + 2 * b - c,\n        tr = -Math.sqrt(-a * (c - d) + b * b - b * (c + d) + c * c),\n        dn = -a + 3 * b - 3 * c + d;\n\n    if (dn !== 0) {\n        result[0] = (tl + tr) / dn;\n        result[1] = (tl - tr) / dn;\n    }\n\n    return result;\n\n}\n\n/**\n * Compute Quadratic Bézier bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n *\n * @return {Object}\n */\nexports.computeQuadraticBoundingBox = function(xa, ya, xb, yb, xc, yc) {\n\n    var minx = Number.POSITIVE_INFINITY,\n        miny = Number.POSITIVE_INFINITY,\n        maxx = Number.NEGATIVE_INFINITY,\n        maxy = Number.NEGATIVE_INFINITY,\n        t,\n        x,\n        y;\n\n    // X\n    if (xa < minx) { minx = xa; }\n    if (xa > maxx) { maxx = xa; }\n    if (xc < minx) { minx = xc; }\n    if (xc > maxx) { maxx = xc; }\n\n    t = computeQuadraticFirstDerivativeRoot(xa, xb, xc);\n\n    if (t >= 0 && t <= 1) {\n        x = computeQuadraticBaseValue(t, xa, xb, xc);\n        // y = computeQuadraticBaseValue(t, ya, yb, yc);\n\n        if (x < minx) { minx = x; }\n        if (x > maxx) { maxx = x; }\n    }\n\n    // Y\n    if (ya < miny) { miny = ya; }\n    if (ya > maxy) { maxy = ya; }\n    if (yc < miny) { miny = yc; }\n    if (yc > maxy) { maxy = yc; }\n\n    t = computeQuadraticFirstDerivativeRoot(ya, yb, yc);\n\n    if (t >= 0 && t <=1 ) {\n        // x = computeQuadraticBaseValue(t, xa, xb, xc);\n        y = computeQuadraticBaseValue(t, ya, yb, yc);\n\n        if (y < miny) { miny = y; }\n        if (y > maxy) { maxy = y ; }\n\n    }\n\n    return {\n        minx: minx,\n        miny: miny,\n        maxx: maxx,\n        maxy: maxy\n    };\n\n};\n\n// compute the value for the quadratic bezier function at time=t\nfunction computeQuadraticBaseValue(t, a, b, c) {\n\n    var mt = 1 - t;\n\n    return mt * mt * a + 2 * mt * t * b + t * t * c;\n\n}\n\n// compute the value for the first derivative of the quadratic bezier function at time=t\nfunction computeQuadraticFirstDerivativeRoot(a, b, c) {\n\n    var t = -1,\n        denominator = a - 2 * b + c;\n\n    if (denominator !== 0) {\n        t = (a - b) / denominator;\n    }\n\n    return t;\n\n}\n\n/**\n * Convert path array to string.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {String} output path string\n */\nexports.js2path = function(path, data, params) {\n\n    path.pathJS = data;\n\n    if (params.collapseRepeated) {\n        data = collapseRepeated(data);\n    }\n\n    path.attr('d').value = data.reduce(function(pathString, item) {\n        var strData = '';\n        if (item.data) {\n            strData = cleanupOutData(item.data, params, item.instruction);\n        }\n        return pathString += item.instruction + strData;\n    }, '');\n\n};\n\n/**\n * Collapse repeated instructions data\n *\n * @param {Array} path input path data\n * @return {Array} output path data\n */\nfunction collapseRepeated(data) {\n\n    var prev,\n        prevIndex;\n\n    // copy an array and modifieds item to keep original data untouched\n    data = data.reduce(function(newPath, item) {\n        if (\n            prev && item.data &&\n            item.instruction == prev.instruction\n        ) {\n            // concat previous data with current\n            if (item.instruction != 'M') {\n                prev = newPath[prevIndex] = {\n                    instruction: prev.instruction,\n                    data: prev.data.concat(item.data),\n                    coords: item.coords,\n                    base: prev.base\n                };\n            } else {\n                prev.data = item.data;\n                prev.coords = item.coords;\n            }\n        } else {\n            newPath.push(item);\n            prev = item;\n            prevIndex = newPath.length - 1;\n        }\n\n        return newPath;\n    }, []);\n\n    return data;\n\n}\n\nfunction set(dest, source) {\n    dest[0] = source[source.length - 2];\n    dest[1] = source[source.length - 1];\n    return dest;\n}\n\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @param {Array} path1 JS path representation\n * @param {Array} path2 JS path representation\n * @return {Boolean}\n */\nexports.intersects = function(path1, path2) {\n    if (path1.length < 3 || path2.length < 3) return false; // nothing to fill\n\n    // Collect points of every subpath.\n    var points1 = relative2absolute(path1).reduce(gatherPoints, []),\n        points2 = relative2absolute(path2).reduce(gatherPoints, []);\n\n    // Axis-aligned bounding box check.\n    if (points1.maxX <= points2.minX || points2.maxX <= points1.minX ||\n        points1.maxY <= points2.minY || points2.maxY <= points1.minY ||\n        points1.every(function (set1) {\n            return points2.every(function (set2) {\n                return set1[set1.maxX][0] <= set2[set2.minX][0] ||\n                    set2[set2.maxX][0] <= set1[set1.minX][0] ||\n                    set1[set1.maxY][1] <= set2[set2.minY][1] ||\n                    set2[set2.maxY][1] <= set1[set1.minY][1];\n            });\n        })\n    ) return false;\n\n    // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).\n    var hullNest1 = points1.map(convexHull),\n        hullNest2 = points2.map(convexHull);\n\n    // Check intersection of every subpath of the first path with every subpath of the second.\n    return hullNest1.some(function(hull1) {\n        if (hull1.length < 3) return false;\n\n        return hullNest2.some(function(hull2) {\n            if (hull2.length < 3) return false;\n\n            var simplex = [getSupport(hull1, hull2, [1, 0])], // create the initial simplex\n                direction = minus(simplex[0]); // set the direction to point towards the origin\n\n            var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n            while (true) {\n                if (iterations-- == 0) {\n                    console.error('Error: infinite loop while processing mergePaths plugin.');\n                    return true; // true is the safe value that means “do nothing with paths”\n                }\n                // add a new point\n                simplex.push(getSupport(hull1, hull2, direction));\n                // see if the new point was on the correct side of the origin\n                if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;\n                // process the simplex\n                if (processSimplex(simplex, direction)) return true;\n            }\n        });\n    });\n\n    function getSupport(a, b, direction) {\n        return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n    }\n\n    // Computes farthest polygon point in particular direction.\n    // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n    // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n    function supportPoint(polygon, direction) {\n        var index = direction[1] >= 0 ?\n                direction[0] < 0 ? polygon.maxY : polygon.maxX :\n                direction[0] < 0 ? polygon.minX : polygon.minY,\n            max = -Infinity,\n            value;\n        while ((value = dot(polygon[index], direction)) > max) {\n            max = value;\n            index = ++index % polygon.length;\n        }\n        return polygon[(index || polygon.length) - 1];\n    }\n};\n\nfunction processSimplex(simplex, direction) {\n    /* jshint -W004 */\n\n    // we only need to handle to 1-simplex and 2-simplex\n    if (simplex.length == 2) { // 1-simplex\n        var a = simplex[1],\n            b = simplex[0],\n            AO = minus(simplex[1]),\n            AB = sub(b, a);\n        // AO is in the same direction as AB\n        if (dot(AO, AB) > 0) {\n            // get the vector perpendicular to AB facing O\n            set(direction, orth(AB, a));\n        } else {\n            set(direction, AO);\n            // only A remains in the simplex\n            simplex.shift();\n        }\n    } else { // 2-simplex\n        var a = simplex[2], // [a, b, c] = simplex\n            b = simplex[1],\n            c = simplex[0],\n            AB = sub(b, a),\n            AC = sub(c, a),\n            AO = minus(a),\n            ACB = orth(AB, AC), // the vector perpendicular to AB facing away from C\n            ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n        if (dot(ACB, AO) > 0) {\n            if (dot(AB, AO) > 0) { // region 4\n                set(direction, ACB);\n                simplex.shift(); // simplex = [b, a]\n            } else { // region 5\n                set(direction, AO);\n                simplex.splice(0, 2); // simplex = [a]\n            }\n        } else if (dot(ABC, AO) > 0) {\n            if (dot(AC, AO) > 0) { // region 6\n                set(direction, ABC);\n                simplex.splice(1, 1); // simplex = [c, a]\n            } else { // region 5 (again)\n                set(direction, AO);\n                simplex.splice(0, 2); // simplex = [a]\n            }\n        } else // region 7\n            return true;\n    }\n    return false;\n}\n\nfunction minus(v) {\n    return [-v[0], -v[1]];\n}\n\nfunction sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\nfunction dot(v1, v2) {\n    return v1[0] * v2[0] + v1[1] * v2[1];\n}\n\nfunction orth(v, from) {\n    var o = [-v[1], v[0]];\n    return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\n\nfunction gatherPoints(points, item, index, path) {\n\n    var subPath = points.length && points[points.length - 1],\n        prev = index && path[index - 1],\n        basePoint = subPath.length && subPath[subPath.length - 1],\n        data = item.data,\n        ctrlPoint = basePoint;\n\n    switch (item.instruction) {\n        case 'M':\n            points.push(subPath = []);\n            break;\n        case 'H':\n            addPoint(subPath, [data[0], basePoint[1]]);\n            break;\n        case 'V':\n            addPoint(subPath, [basePoint[0], data[0]]);\n            break;\n        case 'Q':\n            addPoint(subPath, data.slice(0, 2));\n            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n            break;\n        case 'T':\n            if (prev.instruction == 'Q' || prev.instruction == 'T') {\n                ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n                addPoint(subPath, ctrlPoint);\n                prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n            }\n            break;\n        case 'C':\n            // Approximate quibic Bezier curve with middle points between control points\n            addPoint(subPath, [.5 * (basePoint[0] + data[0]), .5 * (basePoint[1] + data[1])]);\n            addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n            addPoint(subPath, [.5 * (data[2] + data[4]), .5 * (data[3] + data[5])]);\n            prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n            break;\n        case 'S':\n            if (prev.instruction == 'C' || prev.instruction == 'S') {\n                addPoint(subPath, [basePoint[0] + .5 * prevCtrlPoint[0], basePoint[1] + .5 * prevCtrlPoint[1]]);\n                ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n            }\n            addPoint(subPath, [.5 * (ctrlPoint[0] + data[0]), .5 * (ctrlPoint[1]+ data[1])]);\n            addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n            break;\n        case 'A':\n            // Convert the arc to bezier curves and use the same approximation\n            var curves = a2c.apply(0, basePoint.concat(data));\n            for (var cData; (cData = curves.splice(0,6).map(toAbsolute)).length;) {\n                addPoint(subPath, [.5 * (basePoint[0] + cData[0]), .5 * (basePoint[1] + cData[1])]);\n                addPoint(subPath, [.5 * (cData[0] + cData[2]), .5 * (cData[1] + cData[3])]);\n                addPoint(subPath, [.5 * (cData[2] + cData[4]), .5 * (cData[3] + cData[5])]);\n                if (curves.length) addPoint(subPath, basePoint = cData.slice(-2));\n            }\n            break;\n    }\n    // Save final command coordinates\n    if (data && data.length >= 2) addPoint(subPath, data.slice(-2));\n    return points;\n\n    function toAbsolute(n, i) { return n + basePoint[i % 2] }\n\n    // Writes data about the extreme points on each axle\n    function addPoint(path, point) {\n        if (!path.length || point[1] > path[path.maxY][1]) {\n            path.maxY = path.length;\n            points.maxY = points.length ? Math.max(point[1], points.maxY) : point[1];\n        }\n        if (!path.length || point[0] > path[path.maxX][0]) {\n            path.maxX = path.length;\n            points.maxX = points.length ? Math.max(point[0], points.maxX) : point[0];\n        }\n        if (!path.length || point[1] < path[path.minY][1]) {\n            path.minY = path.length;\n            points.minY = points.length ? Math.min(point[1], points.minY) : point[1];\n        }\n        if (!path.length || point[0] < path[path.minX][0]) {\n            path.minX = path.length;\n            points.minX = points.length ? Math.min(point[0], points.minX) : point[0];\n        }\n        path.push(point);\n    }\n}\n\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @param points An array of [X, Y] coordinates\n */\nfunction convexHull(points) {\n    /* jshint -W004 */\n\n    points.sort(function(a, b) {\n        return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n    });\n\n    var lower = [],\n        minY = 0,\n        bottom = 0;\n    for (var i = 0; i < points.length; i++) {\n        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n            lower.pop();\n        }\n        if (points[i][1] < points[minY][1]) {\n            minY = i;\n            bottom = lower.length;\n        }\n        lower.push(points[i]);\n    }\n\n    var upper = [],\n        maxY = points.length - 1,\n        top = 0;\n    for (var i = points.length; i--;) {\n        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\n            upper.pop();\n        }\n        if (points[i][1] > points[maxY][1]) {\n            maxY = i;\n            top = upper.length;\n        }\n        upper.push(points[i]);\n    }\n\n    // last points are equal to starting points of the other part\n    upper.pop();\n    lower.pop();\n\n    var hull = lower.concat(upper);\n\n    hull.minX = 0; // by sorting\n    hull.maxX = lower.length;\n    hull.minY = bottom;\n    hull.maxY = (lower.length + top) % hull.length;\n\n    return hull;\n}\n\nfunction cross(o, a, b) {\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\n/* Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n */\n\n// jshint ignore: start\nfunction a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n    // for more information of where this Math came from visit:\n    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n    var _120 = Math.PI * 120 / 180,\n        rad = Math.PI / 180 * (+angle || 0),\n        res = [],\n        rotateX = function(x, y, rad) { return x * Math.cos(rad) - y * Math.sin(rad) },\n        rotateY = function(x, y, rad) { return x * Math.sin(rad) + y * Math.cos(rad) };\n    if (!recursive) {\n        x1 = rotateX(x1, y1, -rad);\n        y1 = rotateY(x1, y1, -rad);\n        x2 = rotateX(x2, y2, -rad);\n        y2 = rotateY(x2, y2, -rad);\n        var x = (x1 - x2) / 2,\n            y = (y1 - y2) / 2;\n        var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n        if (h > 1) {\n            h = Math.sqrt(h);\n            rx = h * rx;\n            ry = h * ry;\n        }\n        var rx2 = rx * rx,\n            ry2 = ry * ry,\n            k = (large_arc_flag == sweep_flag ? -1 : 1) *\n                Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n            cx = k * rx * y / ry + (x1 + x2) / 2,\n            cy = k * -ry * x / rx + (y1 + y2) / 2,\n            f1 = Math.asin(((y1 - cy) / ry).toFixed(9)),\n            f2 = Math.asin(((y2 - cy) / ry).toFixed(9));\n\n        f1 = x1 < cx ? Math.PI - f1 : f1;\n        f2 = x2 < cx ? Math.PI - f2 : f2;\n        f1 < 0 && (f1 = Math.PI * 2 + f1);\n        f2 < 0 && (f2 = Math.PI * 2 + f2);\n        if (sweep_flag && f1 > f2) {\n            f1 = f1 - Math.PI * 2;\n        }\n        if (!sweep_flag && f2 > f1) {\n            f2 = f2 - Math.PI * 2;\n        }\n    } else {\n        f1 = recursive[0];\n        f2 = recursive[1];\n        cx = recursive[2];\n        cy = recursive[3];\n    }\n    var df = f2 - f1;\n    if (Math.abs(df) > _120) {\n        var f2old = f2,\n            x2old = x2,\n            y2old = y2;\n        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n        x2 = cx + rx * Math.cos(f2);\n        y2 = cy + ry * Math.sin(f2);\n        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n    }\n    df = f2 - f1;\n    var c1 = Math.cos(f1),\n        s1 = Math.sin(f1),\n        c2 = Math.cos(f2),\n        s2 = Math.sin(f2),\n        t = Math.tan(df / 4),\n        hx = 4 / 3 * rx * t,\n        hy = 4 / 3 * ry * t,\n        m = [\n            - hx * s1, hy * c1,\n            x2 + hx * s2 - x1, y2 - hy * c2 - y1,\n            x2 - x1, y2 - y1\n        ];\n    if (recursive) {\n        return m.concat(res);\n    } else {\n        res = m.concat(res);\n        var newres = [];\n        for (var i = 0, n = res.length; i < n; i++) {\n            newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);\n        }\n        return newres;\n    }\n}\n// jshint ignore: end\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}