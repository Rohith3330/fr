{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchFromAbsolutePathsAsync = exports.createMatchPathAsync = void 0;\n\nvar path = require(\"path\");\n\nvar TryPath = require(\"./try-path\");\n\nvar MappingEntry = require(\"./mapping-entry\");\n\nvar Filesystem = require(\"./filesystem\");\n/**\n * See the sync version for docs.\n */\n\n\nfunction createMatchPathAsync(absoluteBaseUrl, paths, mainFields, addMatchAll) {\n  if (mainFields === void 0) {\n    mainFields = [\"main\"];\n  }\n\n  if (addMatchAll === void 0) {\n    addMatchAll = true;\n  }\n\n  var absolutePaths = MappingEntry.getAbsoluteMappingEntries(absoluteBaseUrl, paths, addMatchAll);\n  return function (requestedModule, readJson, fileExists, extensions, callback) {\n    return matchFromAbsolutePathsAsync(absolutePaths, requestedModule, readJson, fileExists, extensions, callback, mainFields);\n  };\n}\n\nexports.createMatchPathAsync = createMatchPathAsync;\n/**\n * See the sync version for docs.\n */\n\nfunction matchFromAbsolutePathsAsync(absolutePathMappings, requestedModule, readJson, fileExists, extensions, callback, mainFields) {\n  if (readJson === void 0) {\n    readJson = Filesystem.readJsonFromDiskAsync;\n  }\n\n  if (fileExists === void 0) {\n    fileExists = Filesystem.fileExistsAsync;\n  }\n\n  if (extensions === void 0) {\n    extensions = Object.keys(require.extensions);\n  }\n\n  if (mainFields === void 0) {\n    mainFields = [\"main\"];\n  }\n\n  var tryPaths = TryPath.getPathsToTry(extensions, absolutePathMappings, requestedModule);\n\n  if (!tryPaths) {\n    return callback();\n  }\n\n  findFirstExistingPath(tryPaths, readJson, fileExists, callback, 0, mainFields);\n}\n\nexports.matchFromAbsolutePathsAsync = matchFromAbsolutePathsAsync;\n\nfunction findFirstExistingMainFieldMappedFile(packageJson, mainFields, packageJsonPath, fileExistsAsync, doneCallback, index) {\n  if (index === void 0) {\n    index = 0;\n  }\n\n  if (index >= mainFields.length) {\n    return doneCallback(undefined, undefined);\n  }\n\n  var tryNext = function () {\n    return findFirstExistingMainFieldMappedFile(packageJson, mainFields, packageJsonPath, fileExistsAsync, doneCallback, index + 1);\n  };\n\n  var mainFieldMapping = packageJson[mainFields[index]];\n\n  if (typeof mainFieldMapping !== \"string\") {\n    // Skip mappings that are not pointers to replacement files\n    return tryNext();\n  }\n\n  var mappedFilePath = path.join(path.dirname(packageJsonPath), mainFieldMapping);\n  fileExistsAsync(mappedFilePath, function (err, exists) {\n    if (err) {\n      return doneCallback(err);\n    }\n\n    if (exists) {\n      return doneCallback(undefined, mappedFilePath);\n    }\n\n    return tryNext();\n  });\n} // Recursive loop to probe for physical files\n\n\nfunction findFirstExistingPath(tryPaths, readJson, fileExists, doneCallback, index, mainFields) {\n  if (index === void 0) {\n    index = 0;\n  }\n\n  if (mainFields === void 0) {\n    mainFields = [\"main\"];\n  }\n\n  var tryPath = tryPaths[index];\n\n  if (tryPath.type === \"file\" || tryPath.type === \"extension\" || tryPath.type === \"index\") {\n    fileExists(tryPath.path, function (err, exists) {\n      if (err) {\n        return doneCallback(err);\n      }\n\n      if (exists) {\n        return doneCallback(undefined, TryPath.getStrippedPath(tryPath));\n      }\n\n      if (index === tryPaths.length - 1) {\n        return doneCallback();\n      } // Continue with the next path\n\n\n      return findFirstExistingPath(tryPaths, readJson, fileExists, doneCallback, index + 1, mainFields);\n    });\n  } else if (tryPath.type === \"package\") {\n    readJson(tryPath.path, function (err, packageJson) {\n      if (err) {\n        return doneCallback(err);\n      }\n\n      if (packageJson) {\n        return findFirstExistingMainFieldMappedFile(packageJson, mainFields, tryPath.path, fileExists, function (mainFieldErr, mainFieldMappedFile) {\n          if (mainFieldErr) {\n            return doneCallback(mainFieldErr);\n          }\n\n          if (mainFieldMappedFile) {\n            return doneCallback(undefined, mainFieldMappedFile);\n          } // No field in package json was a valid option. Continue with the next path.\n\n\n          return findFirstExistingPath(tryPaths, readJson, fileExists, doneCallback, index + 1, mainFields);\n        });\n      } // This is async code, we need to return unconditionally, otherwise the code still falls\n      // through and keeps recursing. While this might work in general, libraries that use neo-async\n      // like Webpack will actually not allow you to call the same callback twice.\n      //\n      // An example of where this caused issues:\n      // https://github.com/dividab/tsconfig-paths-webpack-plugin/issues/11\n      //\n      // Continue with the next path\n\n\n      return findFirstExistingPath(tryPaths, readJson, fileExists, doneCallback, index + 1, mainFields);\n    });\n  } else {\n    TryPath.exhaustiveTypeException(tryPath.type);\n  }\n}","map":{"version":3,"mappings":"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","names":["createMatchPathAsync","absoluteBaseUrl","paths","mainFields","addMatchAll","absolutePaths","MappingEntry","getAbsoluteMappingEntries","requestedModule","readJson","fileExists","extensions","callback","exports","matchFromAbsolutePathsAsync","absolutePathMappings","Filesystem","readJsonFromDiskAsync","fileExistsAsync","Object","keys","require","tryPaths","TryPath","getPathsToTry","findFirstExistingPath","findFirstExistingMainFieldMappedFile","packageJson","packageJsonPath","doneCallback","index","length","undefined","tryNext","mainFieldMapping","mappedFilePath","path","join","dirname","err","exists","tryPath","type","getStrippedPath","mainFieldErr","mainFieldMappedFile","exhaustiveTypeException"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\tsconfig-paths\\src\\match-path-async.ts"],"sourcesContent":["import * as path from \"path\";\nimport * as TryPath from \"./try-path\";\nimport * as MappingEntry from \"./mapping-entry\";\nimport * as Filesystem from \"./filesystem\";\n\n/**\n * Function that can match a path async\n */\nexport interface MatchPathAsync {\n  (\n    requestedModule: string,\n    readJson: Filesystem.ReadJsonAsync | undefined,\n    fileExists: Filesystem.FileExistsAsync | undefined,\n    extensions: ReadonlyArray<string> | undefined,\n    callback: MatchPathAsyncCallback\n  ): void;\n}\n\nexport interface MatchPathAsyncCallback {\n  (err?: Error, path?: string): void;\n}\n\n/**\n * See the sync version for docs.\n */\nexport function createMatchPathAsync(\n  absoluteBaseUrl: string,\n  paths: { [key: string]: Array<string> },\n  mainFields: string[] = [\"main\"],\n  addMatchAll: boolean = true\n): MatchPathAsync {\n  const absolutePaths = MappingEntry.getAbsoluteMappingEntries(\n    absoluteBaseUrl,\n    paths,\n    addMatchAll\n  );\n\n  return (\n    requestedModule: string,\n    readJson: Filesystem.ReadJsonAsync | undefined,\n    fileExists: Filesystem.FileExistsAsync | undefined,\n    extensions: ReadonlyArray<string> | undefined,\n    callback: MatchPathAsyncCallback\n  ) =>\n    matchFromAbsolutePathsAsync(\n      absolutePaths,\n      requestedModule,\n      readJson,\n      fileExists,\n      extensions,\n      callback,\n      mainFields\n    );\n}\n\n/**\n * See the sync version for docs.\n */\nexport function matchFromAbsolutePathsAsync(\n  absolutePathMappings: ReadonlyArray<MappingEntry.MappingEntry>,\n  requestedModule: string,\n  readJson: Filesystem.ReadJsonAsync = Filesystem.readJsonFromDiskAsync,\n  fileExists: Filesystem.FileExistsAsync = Filesystem.fileExistsAsync,\n  extensions: ReadonlyArray<string> = Object.keys(require.extensions),\n  callback: MatchPathAsyncCallback,\n  mainFields: string[] = [\"main\"]\n): void {\n  const tryPaths = TryPath.getPathsToTry(\n    extensions,\n    absolutePathMappings,\n    requestedModule\n  );\n\n  if (!tryPaths) {\n    return callback();\n  }\n\n  findFirstExistingPath(\n    tryPaths,\n    readJson,\n    fileExists,\n    callback,\n    0,\n    mainFields\n  );\n}\n\nfunction findFirstExistingMainFieldMappedFile(\n  packageJson: Filesystem.PackageJson,\n  mainFields: string[],\n  packageJsonPath: string,\n  fileExistsAsync: Filesystem.FileExistsAsync,\n  doneCallback: (err?: Error, filepath?: string) => void,\n  index: number = 0\n): void {\n  if (index >= mainFields.length) {\n    return doneCallback(undefined, undefined);\n  }\n\n  const tryNext = () =>\n    findFirstExistingMainFieldMappedFile(\n      packageJson,\n      mainFields,\n      packageJsonPath,\n      fileExistsAsync,\n      doneCallback,\n      index + 1\n    );\n\n  const mainFieldMapping = packageJson[mainFields[index]];\n  if (typeof mainFieldMapping !== \"string\") {\n    // Skip mappings that are not pointers to replacement files\n    return tryNext();\n  }\n\n  const mappedFilePath = path.join(\n    path.dirname(packageJsonPath),\n    mainFieldMapping\n  );\n  fileExistsAsync(mappedFilePath, (err?: Error, exists?: boolean) => {\n    if (err) {\n      return doneCallback(err);\n    }\n    if (exists) {\n      return doneCallback(undefined, mappedFilePath);\n    }\n    return tryNext();\n  });\n}\n\n// Recursive loop to probe for physical files\nfunction findFirstExistingPath(\n  tryPaths: ReadonlyArray<TryPath.TryPath>,\n  readJson: Filesystem.ReadJsonAsync,\n  fileExists: Filesystem.FileExistsAsync,\n  doneCallback: MatchPathAsyncCallback,\n  index: number = 0,\n  mainFields: string[] = [\"main\"]\n): void {\n  const tryPath = tryPaths[index];\n  if (\n    tryPath.type === \"file\" ||\n    tryPath.type === \"extension\" ||\n    tryPath.type === \"index\"\n  ) {\n    fileExists(tryPath.path, (err: Error, exists: boolean) => {\n      if (err) {\n        return doneCallback(err);\n      }\n      if (exists) {\n        return doneCallback(undefined, TryPath.getStrippedPath(tryPath));\n      }\n      if (index === tryPaths.length - 1) {\n        return doneCallback();\n      }\n      // Continue with the next path\n      return findFirstExistingPath(\n        tryPaths,\n        readJson,\n        fileExists,\n        doneCallback,\n        index + 1,\n        mainFields\n      );\n    });\n  } else if (tryPath.type === \"package\") {\n    readJson(tryPath.path, (err, packageJson) => {\n      if (err) {\n        return doneCallback(err);\n      }\n      if (packageJson) {\n        return findFirstExistingMainFieldMappedFile(\n          packageJson,\n          mainFields,\n          tryPath.path,\n          fileExists,\n          (mainFieldErr?: Error, mainFieldMappedFile?: string) => {\n            if (mainFieldErr) {\n              return doneCallback(mainFieldErr);\n            }\n            if (mainFieldMappedFile) {\n              return doneCallback(undefined, mainFieldMappedFile);\n            }\n\n            // No field in package json was a valid option. Continue with the next path.\n            return findFirstExistingPath(\n              tryPaths,\n              readJson,\n              fileExists,\n              doneCallback,\n              index + 1,\n              mainFields\n            );\n          }\n        );\n      }\n\n      // This is async code, we need to return unconditionally, otherwise the code still falls\n      // through and keeps recursing. While this might work in general, libraries that use neo-async\n      // like Webpack will actually not allow you to call the same callback twice.\n      //\n      // An example of where this caused issues:\n      // https://github.com/dividab/tsconfig-paths-webpack-plugin/issues/11\n      //\n      // Continue with the next path\n      return findFirstExistingPath(\n        tryPaths,\n        readJson,\n        fileExists,\n        doneCallback,\n        index + 1,\n        mainFields\n      );\n    });\n  } else {\n    TryPath.exhaustiveTypeException(tryPath.type);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}