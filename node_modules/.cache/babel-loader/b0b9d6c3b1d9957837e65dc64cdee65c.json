{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nfunction parseChecksVoidReturn(checksVoidReturn) {\n  var _a, _b, _c, _d, _e;\n\n  switch (checksVoidReturn) {\n    case false:\n      return false;\n\n    case true:\n    case undefined:\n      return {\n        arguments: true,\n        attributes: true,\n        properties: true,\n        returns: true,\n        variables: true\n      };\n\n    default:\n      return {\n        arguments: (_a = checksVoidReturn.arguments) !== null && _a !== void 0 ? _a : true,\n        attributes: (_b = checksVoidReturn.attributes) !== null && _b !== void 0 ? _b : true,\n        properties: (_c = checksVoidReturn.properties) !== null && _c !== void 0 ? _c : true,\n        returns: (_d = checksVoidReturn.returns) !== null && _d !== void 0 ? _d : true,\n        variables: (_e = checksVoidReturn.variables) !== null && _e !== void 0 ? _e : true\n      };\n  }\n}\n\nexports.default = util.createRule({\n  name: 'no-misused-promises',\n  meta: {\n    docs: {\n      description: 'Disallow Promises in places not designed to handle them',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    messages: {\n      voidReturnArgument: 'Promise returned in function argument where a void return was expected.',\n      voidReturnVariable: 'Promise-returning function provided to variable where a void return was expected.',\n      voidReturnProperty: 'Promise-returning function provided to property where a void return was expected.',\n      voidReturnReturnValue: 'Promise-returning function provided to return value where a void return was expected.',\n      voidReturnAttribute: 'Promise-returning function provided to attribute where a void return was expected.',\n      conditional: 'Expected non-Promise value in a boolean conditional.',\n      spread: 'Expected a non-Promise value to be spreaded in an object.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        checksConditionals: {\n          type: 'boolean'\n        },\n        checksVoidReturn: {\n          oneOf: [{\n            type: 'boolean'\n          }, {\n            additionalProperties: false,\n            properties: {\n              arguments: {\n                type: 'boolean'\n              },\n              attributes: {\n                type: 'boolean'\n              },\n              properties: {\n                type: 'boolean'\n              },\n              returns: {\n                type: 'boolean'\n              },\n              variables: {\n                type: 'boolean'\n              }\n            },\n            type: 'object'\n          }]\n        },\n        checksSpreads: {\n          type: 'boolean'\n        }\n      }\n    }],\n    type: 'problem'\n  },\n  defaultOptions: [{\n    checksConditionals: true,\n    checksVoidReturn: true,\n    checksSpreads: true\n  }],\n\n  create(context, _ref) {\n    let [{\n      checksConditionals,\n      checksVoidReturn,\n      checksSpreads\n    }] = _ref;\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const checkedNodes = new Set();\n    const conditionalChecks = {\n      ConditionalExpression: checkTestConditional,\n      DoWhileStatement: checkTestConditional,\n      ForStatement: checkTestConditional,\n      IfStatement: checkTestConditional,\n      LogicalExpression: checkConditional,\n\n      'UnaryExpression[operator=\"!\"]'(node) {\n        checkConditional(node.argument, true);\n      },\n\n      WhileStatement: checkTestConditional\n    };\n    checksVoidReturn = parseChecksVoidReturn(checksVoidReturn);\n    const voidReturnChecks = checksVoidReturn ? Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, checksVoidReturn.arguments && {\n      CallExpression: checkArguments,\n      NewExpression: checkArguments\n    }), checksVoidReturn.attributes && {\n      JSXAttribute: checkJSXAttribute\n    }), checksVoidReturn.properties && {\n      Property: checkProperty\n    }), checksVoidReturn.returns && {\n      ReturnStatement: checkReturnStatement\n    }), checksVoidReturn.variables && {\n      AssignmentExpression: checkAssignment,\n      VariableDeclarator: checkVariableDeclaration\n    }) : {};\n    const spreadChecks = {\n      SpreadElement: checkSpread\n    };\n\n    function checkTestConditional(node) {\n      if (node.test) {\n        checkConditional(node.test, true);\n      }\n    }\n    /**\n     * This function analyzes the type of a node and checks if it is a Promise in a boolean conditional.\n     * It uses recursion when checking nested logical operators.\n     * @param node The AST node to check.\n     * @param isTestExpr Whether the node is a descendant of a test expression.\n     */\n\n\n    function checkConditional(node) {\n      let isTestExpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // prevent checking the same node multiple times\n      if (checkedNodes.has(node)) {\n        return;\n      }\n\n      checkedNodes.add(node);\n\n      if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression) {\n        // ignore the left operand for nullish coalescing expressions not in a context of a test expression\n        if (node.operator !== '??' || isTestExpr) {\n          checkConditional(node.left, isTestExpr);\n        } // we ignore the right operand when not in a context of a test expression\n\n\n        if (isTestExpr) {\n          checkConditional(node.right, isTestExpr);\n        }\n\n        return;\n      }\n\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n\n      if (isAlwaysThenable(checker, tsNode)) {\n        context.report({\n          messageId: 'conditional',\n          node\n        });\n      }\n    }\n\n    function checkArguments(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      const voidParams = voidFunctionParams(checker, tsNode);\n\n      if (voidParams.size === 0) {\n        return;\n      }\n\n      for (const [index, argument] of node.arguments.entries()) {\n        if (!voidParams.has(index)) {\n          continue;\n        }\n\n        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(argument);\n\n        if (returnsThenable(checker, tsNode)) {\n          context.report({\n            messageId: 'voidReturnArgument',\n            node: argument\n          });\n        }\n      }\n    }\n\n    function checkAssignment(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      const varType = checker.getTypeAtLocation(tsNode.left);\n\n      if (!isVoidReturningFunctionType(checker, tsNode.left, varType)) {\n        return;\n      }\n\n      if (returnsThenable(checker, tsNode.right)) {\n        context.report({\n          messageId: 'voidReturnVariable',\n          node: node.right\n        });\n      }\n    }\n\n    function checkVariableDeclaration(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n\n      if (tsNode.initializer === undefined || node.init === null) {\n        return;\n      }\n\n      const varType = checker.getTypeAtLocation(tsNode.name);\n\n      if (!isVoidReturningFunctionType(checker, tsNode.initializer, varType)) {\n        return;\n      }\n\n      if (returnsThenable(checker, tsNode.initializer)) {\n        context.report({\n          messageId: 'voidReturnVariable',\n          node: node.init\n        });\n      }\n    }\n\n    function checkProperty(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n\n      if (ts.isPropertyAssignment(tsNode)) {\n        const contextualType = checker.getContextualType(tsNode.initializer);\n\n        if (contextualType !== undefined && isVoidReturningFunctionType(checker, tsNode.initializer, contextualType) && returnsThenable(checker, tsNode.initializer)) {\n          context.report({\n            messageId: 'voidReturnProperty',\n            node: node.value\n          });\n        }\n      } else if (ts.isShorthandPropertyAssignment(tsNode)) {\n        const contextualType = checker.getContextualType(tsNode.name);\n\n        if (contextualType !== undefined && isVoidReturningFunctionType(checker, tsNode.name, contextualType) && returnsThenable(checker, tsNode.name)) {\n          context.report({\n            messageId: 'voidReturnProperty',\n            node: node.value\n          });\n        }\n      } else if (ts.isMethodDeclaration(tsNode)) {\n        if (ts.isComputedPropertyName(tsNode.name)) {\n          return;\n        }\n\n        const obj = tsNode.parent; // Below condition isn't satisfied unless something goes wrong,\n        // but is needed for type checking.\n        // 'node' does not include class method declaration so 'obj' is\n        // always an object literal expression, but after converting 'node'\n        // to TypeScript AST, its type includes MethodDeclaration which\n        // does include the case of class method declaration.\n\n        if (!ts.isObjectLiteralExpression(obj)) {\n          return;\n        }\n\n        const objType = checker.getContextualType(obj);\n\n        if (objType === undefined) {\n          return;\n        }\n\n        const propertySymbol = checker.getPropertyOfType(objType, tsNode.name.text);\n\n        if (propertySymbol === undefined) {\n          return;\n        }\n\n        const contextualType = checker.getTypeOfSymbolAtLocation(propertySymbol, tsNode.name);\n\n        if (isVoidReturningFunctionType(checker, tsNode.name, contextualType) && returnsThenable(checker, tsNode)) {\n          context.report({\n            messageId: 'voidReturnProperty',\n            node: node.value\n          });\n        }\n\n        return;\n      }\n    }\n\n    function checkReturnStatement(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n\n      if (tsNode.expression === undefined || node.argument === null) {\n        return;\n      }\n\n      const contextualType = checker.getContextualType(tsNode.expression);\n\n      if (contextualType !== undefined && isVoidReturningFunctionType(checker, tsNode.expression, contextualType) && returnsThenable(checker, tsNode.expression)) {\n        context.report({\n          messageId: 'voidReturnReturnValue',\n          node: node.argument\n        });\n      }\n    }\n\n    function checkJSXAttribute(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      const value = tsNode.initializer;\n\n      if (node.value === null || value === undefined || !ts.isJsxExpression(value) || value.expression === undefined) {\n        return;\n      }\n\n      const contextualType = checker.getContextualType(value);\n\n      if (contextualType !== undefined && isVoidReturningFunctionType(checker, value, contextualType) && returnsThenable(checker, value.expression)) {\n        context.report({\n          messageId: 'voidReturnAttribute',\n          node: node.value\n        });\n      }\n    }\n\n    function checkSpread(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n\n      if (isSometimesThenable(checker, tsNode.expression)) {\n        context.report({\n          messageId: 'spread',\n          node: node.argument\n        });\n      }\n    }\n\n    return Object.assign(Object.assign(Object.assign({}, checksConditionals ? conditionalChecks : {}), checksVoidReturn ? voidReturnChecks : {}), checksSpreads ? spreadChecks : {});\n  }\n\n});\n\nfunction isSometimesThenable(checker, node) {\n  const type = checker.getTypeAtLocation(node);\n\n  for (const subType of tsutils.unionTypeParts(checker.getApparentType(type))) {\n    if (tsutils.isThenableType(checker, node, subType)) {\n      return true;\n    }\n  }\n\n  return false;\n} // Variation on the thenable check which requires all forms of the type (read:\n// alternates in a union) to be thenable. Otherwise, you might be trying to\n// check if something is defined or undefined and get caught because one of the\n// branches is thenable.\n\n\nfunction isAlwaysThenable(checker, node) {\n  const type = checker.getTypeAtLocation(node);\n\n  for (const subType of tsutils.unionTypeParts(checker.getApparentType(type))) {\n    const thenProp = subType.getProperty('then'); // If one of the alternates has no then property, it is not thenable in all\n    // cases.\n\n    if (thenProp === undefined) {\n      return false;\n    } // We walk through each variation of the then property. Since we know it\n    // exists at this point, we just need at least one of the alternates to\n    // be of the right form to consider it thenable.\n\n\n    const thenType = checker.getTypeOfSymbolAtLocation(thenProp, node);\n    let hasThenableSignature = false;\n\n    for (const subType of tsutils.unionTypeParts(thenType)) {\n      for (const signature of subType.getCallSignatures()) {\n        if (signature.parameters.length !== 0 && isFunctionParam(checker, signature.parameters[0], node)) {\n          hasThenableSignature = true;\n          break;\n        }\n      } // We only need to find one variant of the then property that has a\n      // function signature for it to be thenable.\n\n\n      if (hasThenableSignature) {\n        break;\n      }\n    } // If no flavors of the then property are thenable, we don't consider the\n    // overall type to be thenable\n\n\n    if (!hasThenableSignature) {\n      return false;\n    }\n  } // If all variants are considered thenable (i.e. haven't returned false), we\n  // consider the overall type thenable\n\n\n  return true;\n}\n\nfunction isFunctionParam(checker, param, node) {\n  const type = checker.getApparentType(checker.getTypeOfSymbolAtLocation(param, node));\n\n  for (const subType of tsutils.unionTypeParts(type)) {\n    if (subType.getCallSignatures().length !== 0) {\n      return true;\n    }\n  }\n\n  return false;\n} // Get the positions of parameters which are void functions (and not also\n// thenable functions). These are the candidates for the void-return check at\n// the current call site.\n\n\nfunction voidFunctionParams(checker, node) {\n  const thenableReturnIndices = new Set();\n  const voidReturnIndices = new Set();\n  const type = checker.getTypeAtLocation(node.expression); // We can't use checker.getResolvedSignature because it prefers an early '() => void' over a later '() => Promise<void>'\n  // See https://github.com/microsoft/TypeScript/issues/48077\n\n  for (const subType of tsutils.unionTypeParts(type)) {\n    // Standard function calls and `new` have two different types of signatures\n    const signatures = ts.isCallExpression(node) ? subType.getCallSignatures() : subType.getConstructSignatures();\n\n    for (const signature of signatures) {\n      for (const [index, parameter] of signature.parameters.entries()) {\n        const type = checker.getTypeOfSymbolAtLocation(parameter, node.expression);\n\n        if (isThenableReturningFunctionType(checker, node.expression, type)) {\n          thenableReturnIndices.add(index);\n        } else if (!thenableReturnIndices.has(index) && isVoidReturningFunctionType(checker, node.expression, type)) {\n          voidReturnIndices.add(index);\n        }\n      }\n    }\n  }\n\n  for (const index of thenableReturnIndices) {\n    voidReturnIndices.delete(index);\n  }\n\n  return voidReturnIndices;\n}\n/**\n * @returns Whether any call signature of the type has a thenable return type.\n */\n\n\nfunction anySignatureIsThenableType(checker, node, type) {\n  for (const signature of type.getCallSignatures()) {\n    const returnType = signature.getReturnType();\n\n    if (tsutils.isThenableType(checker, node, returnType)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * @returns Whether type is a thenable-returning function.\n */\n\n\nfunction isThenableReturningFunctionType(checker, node, type) {\n  for (const subType of tsutils.unionTypeParts(type)) {\n    if (anySignatureIsThenableType(checker, node, subType)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * @returns Whether type is a void-returning function.\n */\n\n\nfunction isVoidReturningFunctionType(checker, node, type) {\n  let hadVoidReturn = false;\n\n  for (const subType of tsutils.unionTypeParts(type)) {\n    for (const signature of subType.getCallSignatures()) {\n      const returnType = signature.getReturnType(); // If a certain positional argument accepts both thenable and void returns,\n      // a promise-returning function is valid\n\n      if (tsutils.isThenableType(checker, node, returnType)) {\n        return false;\n      }\n\n      hadVoidReturn || (hadVoidReturn = tsutils.isTypeFlagSet(returnType, ts.TypeFlags.Void));\n    }\n  }\n\n  return hadVoidReturn;\n}\n/**\n * @returns Whether expression is a function that returns a thenable.\n */\n\n\nfunction returnsThenable(checker, node) {\n  const type = checker.getApparentType(checker.getTypeAtLocation(node));\n\n  if (anySignatureIsThenableType(checker, node, type)) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"mappings":"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","names":["parseChecksVoidReturn","checksVoidReturn","undefined","arguments","attributes","properties","returns","variables","_a","_b","_c","_d","_e","exports","util","createRule","name","meta","docs","description","recommended","requiresTypeChecking","messages","voidReturnArgument","voidReturnVariable","voidReturnProperty","voidReturnReturnValue","voidReturnAttribute","conditional","spread","schema","type","checksConditionals","oneOf","additionalProperties","checksSpreads","defaultOptions","create","context","parserServices","getParserServices","checker","program","getTypeChecker","checkedNodes","Set","conditionalChecks","ConditionalExpression","checkTestConditional","DoWhileStatement","ForStatement","IfStatement","LogicalExpression","checkConditional","node","argument","WhileStatement","voidReturnChecks","Object","CallExpression","checkArguments","NewExpression","JSXAttribute","checkJSXAttribute","Property","checkProperty","ReturnStatement","checkReturnStatement","AssignmentExpression","checkAssignment","VariableDeclarator","checkVariableDeclaration","spreadChecks","SpreadElement","checkSpread","test","isTestExpr","has","add","utils_1","operator","left","right","tsNode","esTreeNodeToTSNodeMap","get","isAlwaysThenable","report","messageId","voidParams","voidFunctionParams","size","index","entries","returnsThenable","varType","getTypeAtLocation","isVoidReturningFunctionType","initializer","init","ts","isPropertyAssignment","contextualType","getContextualType","value","isShorthandPropertyAssignment","isMethodDeclaration","isComputedPropertyName","obj","parent","isObjectLiteralExpression","objType","propertySymbol","getPropertyOfType","text","getTypeOfSymbolAtLocation","expression","isJsxExpression","isSometimesThenable","subType","tsutils","unionTypeParts","getApparentType","isThenableType","thenProp","getProperty","thenType","hasThenableSignature","signature","getCallSignatures","parameters","length","isFunctionParam","param","thenableReturnIndices","voidReturnIndices","signatures","isCallExpression","getConstructSignatures","parameter","isThenableReturningFunctionType","delete","anySignatureIsThenableType","returnType","getReturnType","hadVoidReturn","isTypeFlagSet","TypeFlags","Void"],"sources":["../../src/rules/no-misused-promises.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}