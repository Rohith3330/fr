{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'no-inferrable-types',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow explicit type declarations for variables or parameters initialized to a number, string, or boolean',\n      recommended: 'error'\n    },\n    fixable: 'code',\n    messages: {\n      noInferrableType: 'Type {{type}} trivially inferred from a {{type}} literal, remove type annotation.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreParameters: {\n          type: 'boolean'\n        },\n        ignoreProperties: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    ignoreParameters: false,\n    ignoreProperties: false\n  }],\n\n  create(context, _ref) {\n    let [{\n      ignoreParameters,\n      ignoreProperties\n    }] = _ref;\n    const sourceCode = context.getSourceCode();\n\n    function isFunctionCall(init, callName) {\n      if (init.type === utils_1.AST_NODE_TYPES.ChainExpression) {\n        return isFunctionCall(init.expression, callName);\n      }\n\n      return init.type === utils_1.AST_NODE_TYPES.CallExpression && init.callee.type === utils_1.AST_NODE_TYPES.Identifier && init.callee.name === callName;\n    }\n\n    function isLiteral(init, typeName) {\n      return init.type === utils_1.AST_NODE_TYPES.Literal && typeof init.value === typeName;\n    }\n\n    function isIdentifier(init) {\n      for (var _len = arguments.length, names = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        names[_key - 1] = arguments[_key];\n      }\n\n      return init.type === utils_1.AST_NODE_TYPES.Identifier && names.includes(init.name);\n    }\n\n    function hasUnaryPrefix(init) {\n      for (var _len2 = arguments.length, operators = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        operators[_key2 - 1] = arguments[_key2];\n      }\n\n      return init.type === utils_1.AST_NODE_TYPES.UnaryExpression && operators.includes(init.operator);\n    }\n\n    const keywordMap = {\n      [utils_1.AST_NODE_TYPES.TSBigIntKeyword]: 'bigint',\n      [utils_1.AST_NODE_TYPES.TSBooleanKeyword]: 'boolean',\n      [utils_1.AST_NODE_TYPES.TSNumberKeyword]: 'number',\n      [utils_1.AST_NODE_TYPES.TSNullKeyword]: 'null',\n      [utils_1.AST_NODE_TYPES.TSStringKeyword]: 'string',\n      [utils_1.AST_NODE_TYPES.TSSymbolKeyword]: 'symbol',\n      [utils_1.AST_NODE_TYPES.TSUndefinedKeyword]: 'undefined'\n    };\n    /**\n     * Returns whether a node has an inferrable value or not\n     */\n\n    function isInferrable(annotation, init) {\n      switch (annotation.type) {\n        case utils_1.AST_NODE_TYPES.TSBigIntKeyword:\n          {\n            // note that bigint cannot have + prefixed to it\n            const unwrappedInit = hasUnaryPrefix(init, '-') ? init.argument : init;\n            return isFunctionCall(unwrappedInit, 'BigInt') || unwrappedInit.type === utils_1.AST_NODE_TYPES.Literal && 'bigint' in unwrappedInit;\n          }\n\n        case utils_1.AST_NODE_TYPES.TSBooleanKeyword:\n          return hasUnaryPrefix(init, '!') || isFunctionCall(init, 'Boolean') || isLiteral(init, 'boolean');\n\n        case utils_1.AST_NODE_TYPES.TSNumberKeyword:\n          {\n            const unwrappedInit = hasUnaryPrefix(init, '+', '-') ? init.argument : init;\n            return isIdentifier(unwrappedInit, 'Infinity', 'NaN') || isFunctionCall(unwrappedInit, 'Number') || isLiteral(unwrappedInit, 'number');\n          }\n\n        case utils_1.AST_NODE_TYPES.TSNullKeyword:\n          return init.type === utils_1.AST_NODE_TYPES.Literal && init.value === null;\n\n        case utils_1.AST_NODE_TYPES.TSStringKeyword:\n          return isFunctionCall(init, 'String') || isLiteral(init, 'string') || init.type === utils_1.AST_NODE_TYPES.TemplateLiteral;\n\n        case utils_1.AST_NODE_TYPES.TSSymbolKeyword:\n          return isFunctionCall(init, 'Symbol');\n\n        case utils_1.AST_NODE_TYPES.TSTypeReference:\n          {\n            if (annotation.typeName.type === utils_1.AST_NODE_TYPES.Identifier && annotation.typeName.name === 'RegExp') {\n              const isRegExpLiteral = init.type === utils_1.AST_NODE_TYPES.Literal && init.value instanceof RegExp;\n              const isRegExpNewCall = init.type === utils_1.AST_NODE_TYPES.NewExpression && init.callee.type === utils_1.AST_NODE_TYPES.Identifier && init.callee.name === 'RegExp';\n              const isRegExpCall = isFunctionCall(init, 'RegExp');\n              return isRegExpLiteral || isRegExpCall || isRegExpNewCall;\n            }\n\n            return false;\n          }\n\n        case utils_1.AST_NODE_TYPES.TSUndefinedKeyword:\n          return hasUnaryPrefix(init, 'void') || isIdentifier(init, 'undefined');\n      }\n\n      return false;\n    }\n    /**\n     * Reports an inferrable type declaration, if any\n     */\n\n\n    function reportInferrableType(node, typeNode, initNode) {\n      if (!typeNode || !initNode || !typeNode.typeAnnotation) {\n        return;\n      }\n\n      if (!isInferrable(typeNode.typeAnnotation, initNode)) {\n        return;\n      }\n\n      const type = typeNode.typeAnnotation.type === utils_1.AST_NODE_TYPES.TSTypeReference ? // TODO - if we add more references\n      'RegExp' : keywordMap[typeNode.typeAnnotation.type];\n      context.report({\n        node,\n        messageId: 'noInferrableType',\n        data: {\n          type\n        },\n\n        *fix(fixer) {\n          if (node.type === utils_1.AST_NODE_TYPES.AssignmentPattern && node.left.optional || node.type === utils_1.AST_NODE_TYPES.PropertyDefinition && node.definite) {\n            yield fixer.remove(sourceCode.getTokenBefore(typeNode));\n          }\n\n          yield fixer.remove(typeNode);\n        }\n\n      });\n    }\n\n    function inferrableVariableVisitor(node) {\n      if (!node.id) {\n        return;\n      }\n\n      reportInferrableType(node, node.id.typeAnnotation, node.init);\n    }\n\n    function inferrableParameterVisitor(node) {\n      if (ignoreParameters || !node.params) {\n        return;\n      }\n\n      node.params.filter(param => param.type === utils_1.AST_NODE_TYPES.AssignmentPattern && param.left && param.right).forEach(param => {\n        reportInferrableType(param, param.left.typeAnnotation, param.right);\n      });\n    }\n\n    function inferrablePropertyVisitor(node) {\n      // We ignore `readonly` because of Microsoft/TypeScript#14416\n      // Essentially a readonly property without a type\n      // will result in its value being the type, leading to\n      // compile errors if the type is stripped.\n      if (ignoreProperties || node.readonly || node.optional) {\n        return;\n      }\n\n      reportInferrableType(node, node.typeAnnotation, node.value);\n    }\n\n    return {\n      VariableDeclarator: inferrableVariableVisitor,\n      FunctionExpression: inferrableParameterVisitor,\n      FunctionDeclaration: inferrableParameterVisitor,\n      ArrowFunctionExpression: inferrableParameterVisitor,\n      PropertyDefinition: inferrablePropertyVisitor\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","fixable","messages","noInferrableType","schema","properties","ignoreParameters","ignoreProperties","additionalProperties","defaultOptions","create","context","sourceCode","getSourceCode","isFunctionCall","init","callName","utils_1","ChainExpression","expression","CallExpression","callee","Identifier","isLiteral","typeName","Literal","value","isIdentifier","names","includes","hasUnaryPrefix","operators","UnaryExpression","operator","keywordMap","TSBigIntKeyword","TSBooleanKeyword","TSNumberKeyword","TSNullKeyword","TSStringKeyword","TSSymbolKeyword","TSUndefinedKeyword","isInferrable","annotation","unwrappedInit","argument","TemplateLiteral","TSTypeReference","isRegExpLiteral","RegExp","isRegExpNewCall","NewExpression","isRegExpCall","reportInferrableType","node","typeNode","initNode","typeAnnotation","report","messageId","data","fix","fixer","AssignmentPattern","left","optional","PropertyDefinition","definite","remove","getTokenBefore","inferrableVariableVisitor","id","inferrableParameterVisitor","params","filter","param","right","forEach","inferrablePropertyVisitor","readonly","VariableDeclarator","FunctionExpression","FunctionDeclaration","ArrowFunctionExpression"],"sources":["../../src/rules/no-inferrable-types.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}