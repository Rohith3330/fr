{"ast":null,"code":"\"use strict\";\n\nconst globalObject = require(\"@sinonjs/commons\").global;\n/**\n * @typedef {object} IdleDeadline\n * @property {boolean} didTimeout - whether or not the callback was called before reaching the optional timeout\n * @property {function():number} timeRemaining - a floating-point value providing an estimate of the number of milliseconds remaining in the current idle period\n */\n\n/**\n * Queues a function to be called during a browser's idle periods\n *\n * @callback RequestIdleCallback\n * @param {function(IdleDeadline)} callback\n * @param {{timeout: number}} options - an options object\n * @returns {number} the id\n */\n\n/**\n * @callback NextTick\n * @param {VoidVarArgsFunc} callback - the callback to run\n * @param {...*} arguments - optional arguments to call the callback with\n * @returns {void}\n */\n\n/**\n * @callback SetImmediate\n * @param {VoidVarArgsFunc} callback - the callback to run\n * @param {...*} arguments - optional arguments to call the callback with\n * @returns {NodeImmediate}\n */\n\n/**\n * @callback VoidVarArgsFunc\n * @param {...*} callback - the callback to run\n * @returns {void}\n */\n\n/**\n * @typedef RequestAnimationFrame\n * @property {function(number):void} requestAnimationFrame\n * @returns {number} - the id\n */\n\n/**\n * @typedef Performance\n * @property {function(): number} now\n */\n\n/* eslint-disable jsdoc/require-property-description */\n\n/**\n * @typedef {object} Clock\n * @property {number} now - the current time\n * @property {Date} Date - the Date constructor\n * @property {number} loopLimit - the maximum number of timers before assuming an infinite loop\n * @property {RequestIdleCallback} requestIdleCallback\n * @property {function(number):void} cancelIdleCallback\n * @property {setTimeout} setTimeout\n * @property {clearTimeout} clearTimeout\n * @property {NextTick} nextTick\n * @property {queueMicrotask} queueMicrotask\n * @property {setInterval} setInterval\n * @property {clearInterval} clearInterval\n * @property {SetImmediate} setImmediate\n * @property {function(NodeImmediate):void} clearImmediate\n * @property {function():number} countTimers\n * @property {RequestAnimationFrame} requestAnimationFrame\n * @property {function(number):void} cancelAnimationFrame\n * @property {function():void} runMicrotasks\n * @property {function(string | number): number} tick\n * @property {function(string | number): Promise<number>} tickAsync\n * @property {function(): number} next\n * @property {function(): Promise<number>} nextAsync\n * @property {function(): number} runAll\n * @property {function(): number} runToFrame\n * @property {function(): Promise<number>} runAllAsync\n * @property {function(): number} runToLast\n * @property {function(): Promise<number>} runToLastAsync\n * @property {function(): void} reset\n * @property {function(number | Date): void} setSystemTime\n * @property {Performance} performance\n * @property {function(number[]): number[]} hrtime - process.hrtime (legacy)\n * @property {function(): void} uninstall Uninstall the clock.\n * @property {Function[]} methods - the methods that are faked\n * @property {boolean} [shouldClearNativeTimers] inherited from config\n */\n\n/* eslint-enable jsdoc/require-property-description */\n\n/**\n * Configuration object for the `install` method.\n *\n * @typedef {object} Config\n * @property {number|Date} [now] a number (in milliseconds) or a Date object (default epoch)\n * @property {string[]} [toFake] names of the methods that should be faked.\n * @property {number} [loopLimit] the maximum number of timers that will be run when calling runAll()\n * @property {boolean} [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false)\n * @property {number} [advanceTimeDelta] increment mocked time every <<advanceTimeDelta>> ms (default: 20ms)\n * @property {boolean} [shouldClearNativeTimers] forwards clear timer calls to native functions if they are not fakes (default: false)\n */\n\n/* eslint-disable jsdoc/require-property-description */\n\n/**\n * The internal structure to describe a scheduled fake timer\n *\n * @typedef {object} Timer\n * @property {Function} func\n * @property {*[]} args\n * @property {number} delay\n * @property {number} callAt\n * @property {number} createdAt\n * @property {boolean} immediate\n * @property {number} id\n * @property {Error} [error]\n */\n\n/**\n * A Node timer\n *\n * @typedef {object} NodeImmediate\n * @property {function(): boolean} hasRef\n * @property {function(): NodeImmediate} ref\n * @property {function(): NodeImmediate} unref\n */\n\n/* eslint-enable jsdoc/require-property-description */\n\n/* eslint-disable complexity */\n\n/**\n * Mocks available features in the specified global namespace.\n *\n * @param {*} _global Namespace to mock (e.g. `window`)\n * @returns {FakeTimers}\n */\n\n\nfunction withGlobal(_global) {\n  const userAgent = _global.navigator && _global.navigator.userAgent;\n  const isRunningInIE = userAgent && userAgent.indexOf(\"MSIE \") > -1;\n  const maxTimeout = Math.pow(2, 31) - 1; //see https://heycam.github.io/webidl/#abstract-opdef-converttoint\n\n  const idCounterStart = 1e12; // arbitrarily large number to avoid collisions with native timer IDs\n\n  const NOOP = function () {\n    return undefined;\n  };\n\n  const NOOP_ARRAY = function () {\n    return [];\n  };\n\n  const timeoutResult = _global.setTimeout(NOOP, 0);\n\n  const addTimerReturnsObject = typeof timeoutResult === \"object\";\n  const hrtimePresent = _global.process && typeof _global.process.hrtime === \"function\";\n  const hrtimeBigintPresent = hrtimePresent && typeof _global.process.hrtime.bigint === \"function\";\n  const nextTickPresent = _global.process && typeof _global.process.nextTick === \"function\";\n\n  const utilPromisify = _global.process && require(\"util\").promisify;\n\n  const performancePresent = _global.performance && typeof _global.performance.now === \"function\";\n  const hasPerformancePrototype = _global.Performance && (typeof _global.Performance).match(/^(function|object)$/);\n\n  const queueMicrotaskPresent = _global.hasOwnProperty(\"queueMicrotask\");\n\n  const requestAnimationFramePresent = _global.requestAnimationFrame && typeof _global.requestAnimationFrame === \"function\";\n  const cancelAnimationFramePresent = _global.cancelAnimationFrame && typeof _global.cancelAnimationFrame === \"function\";\n  const requestIdleCallbackPresent = _global.requestIdleCallback && typeof _global.requestIdleCallback === \"function\";\n  const cancelIdleCallbackPresent = _global.cancelIdleCallback && typeof _global.cancelIdleCallback === \"function\";\n  const setImmediatePresent = _global.setImmediate && typeof _global.setImmediate === \"function\"; // Make properties writable in IE, as per\n  // https://www.adequatelygood.com/Replacing-setTimeout-Globally.html\n\n  /* eslint-disable no-self-assign */\n\n  if (isRunningInIE) {\n    _global.setTimeout = _global.setTimeout;\n    _global.clearTimeout = _global.clearTimeout;\n    _global.setInterval = _global.setInterval;\n    _global.clearInterval = _global.clearInterval;\n    _global.Date = _global.Date;\n  } // setImmediate is not a standard function\n  // avoid adding the prop to the window object if not present\n\n\n  if (setImmediatePresent) {\n    _global.setImmediate = _global.setImmediate;\n    _global.clearImmediate = _global.clearImmediate;\n  }\n  /* eslint-enable no-self-assign */\n\n\n  _global.clearTimeout(timeoutResult);\n\n  const NativeDate = _global.Date;\n  let uniqueTimerId = idCounterStart;\n  /**\n   * @param {number} num\n   * @returns {boolean}\n   */\n\n  function isNumberFinite(num) {\n    if (Number.isFinite) {\n      return Number.isFinite(num);\n    }\n\n    return isFinite(num);\n  }\n\n  let isNearInfiniteLimit = false;\n  /**\n   * @param {Clock} clock\n   * @param {number} i\n   */\n\n  function checkIsNearInfiniteLimit(clock, i) {\n    if (clock.loopLimit && i === clock.loopLimit - 1) {\n      isNearInfiniteLimit = true;\n    }\n  }\n  /**\n   *\n   */\n\n\n  function resetIsNearInfiniteLimit() {\n    isNearInfiniteLimit = false;\n  }\n  /**\n   * Parse strings like \"01:10:00\" (meaning 1 hour, 10 minutes, 0 seconds) into\n   * number of milliseconds. This is used to support human-readable strings passed\n   * to clock.tick()\n   *\n   * @param {string} str\n   * @returns {number}\n   */\n\n\n  function parseTime(str) {\n    if (!str) {\n      return 0;\n    }\n\n    const strings = str.split(\":\");\n    const l = strings.length;\n    let i = l;\n    let ms = 0;\n    let parsed;\n\n    if (l > 3 || !/^(\\d\\d:){0,2}\\d\\d?$/.test(str)) {\n      throw new Error(\"tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits\");\n    }\n\n    while (i--) {\n      parsed = parseInt(strings[i], 10);\n\n      if (parsed >= 60) {\n        throw new Error(`Invalid time ${str}`);\n      }\n\n      ms += parsed * Math.pow(60, l - i - 1);\n    }\n\n    return ms * 1000;\n  }\n  /**\n   * Get the decimal part of the millisecond value as nanoseconds\n   *\n   * @param {number} msFloat the number of milliseconds\n   * @returns {number} an integer number of nanoseconds in the range [0,1e6)\n   *\n   * Example: nanoRemainer(123.456789) -> 456789\n   */\n\n\n  function nanoRemainder(msFloat) {\n    const modulo = 1e6;\n    const remainder = msFloat * 1e6 % modulo;\n    const positiveRemainder = remainder < 0 ? remainder + modulo : remainder;\n    return Math.floor(positiveRemainder);\n  }\n  /**\n   * Used to grok the `now` parameter to createClock.\n   *\n   * @param {Date|number} epoch the system time\n   * @returns {number}\n   */\n\n\n  function getEpoch(epoch) {\n    if (!epoch) {\n      return 0;\n    }\n\n    if (typeof epoch.getTime === \"function\") {\n      return epoch.getTime();\n    }\n\n    if (typeof epoch === \"number\") {\n      return epoch;\n    }\n\n    throw new TypeError(\"now should be milliseconds since UNIX epoch\");\n  }\n  /**\n   * @param {number} from\n   * @param {number} to\n   * @param {Timer} timer\n   * @returns {boolean}\n   */\n\n\n  function inRange(from, to, timer) {\n    return timer && timer.callAt >= from && timer.callAt <= to;\n  }\n  /**\n   * @param {Clock} clock\n   * @param {Timer} job\n   */\n\n\n  function getInfiniteLoopError(clock, job) {\n    const infiniteLoopError = new Error(`Aborting after running ${clock.loopLimit} timers, assuming an infinite loop!`);\n\n    if (!job.error) {\n      return infiniteLoopError;\n    } // pattern never matched in Node\n\n\n    const computedTargetPattern = /target\\.*[<|(|[].*?[>|\\]|)]\\s*/;\n    let clockMethodPattern = new RegExp(String(Object.keys(clock).join(\"|\")));\n\n    if (addTimerReturnsObject) {\n      // node.js environment\n      clockMethodPattern = new RegExp(`\\\\s+at (Object\\\\.)?(?:${Object.keys(clock).join(\"|\")})\\\\s+`);\n    }\n\n    let matchedLineIndex = -1;\n    job.error.stack.split(\"\\n\").some(function (line, i) {\n      // If we've matched a computed target line (e.g. setTimeout) then we\n      // don't need to look any further. Return true to stop iterating.\n      const matchedComputedTarget = line.match(computedTargetPattern);\n      /* istanbul ignore if */\n\n      if (matchedComputedTarget) {\n        matchedLineIndex = i;\n        return true;\n      } // If we've matched a clock method line, then there may still be\n      // others further down the trace. Return false to keep iterating.\n\n\n      const matchedClockMethod = line.match(clockMethodPattern);\n\n      if (matchedClockMethod) {\n        matchedLineIndex = i;\n        return false;\n      } // If we haven't matched anything on this line, but we matched\n      // previously and set the matched line index, then we can stop.\n      // If we haven't matched previously, then we should keep iterating.\n\n\n      return matchedLineIndex >= 0;\n    });\n    const stack = `${infiniteLoopError}\\n${job.type || \"Microtask\"} - ${job.func.name || \"anonymous\"}\\n${job.error.stack.split(\"\\n\").slice(matchedLineIndex + 1).join(\"\\n\")}`;\n\n    try {\n      Object.defineProperty(infiniteLoopError, \"stack\", {\n        value: stack\n      });\n    } catch (e) {// noop\n    }\n\n    return infiniteLoopError;\n  }\n  /**\n   * @param {Date} target\n   * @param {Date} source\n   * @returns {Date} the target after modifications\n   */\n\n\n  function mirrorDateProperties(target, source) {\n    let prop;\n\n    for (prop in source) {\n      if (source.hasOwnProperty(prop)) {\n        target[prop] = source[prop];\n      }\n    } // set special now implementation\n\n\n    if (source.now) {\n      target.now = function now() {\n        return target.clock.now;\n      };\n    } else {\n      delete target.now;\n    } // set special toSource implementation\n\n\n    if (source.toSource) {\n      target.toSource = function toSource() {\n        return source.toSource();\n      };\n    } else {\n      delete target.toSource;\n    } // set special toString implementation\n\n\n    target.toString = function toString() {\n      return source.toString();\n    };\n\n    target.prototype = source.prototype;\n    target.parse = source.parse;\n    target.UTC = source.UTC;\n    target.prototype.toUTCString = source.prototype.toUTCString;\n    return target;\n  } //eslint-disable-next-line jsdoc/require-jsdoc\n\n\n  function createDate() {\n    /**\n     * @param {number} year\n     * @param {number} month\n     * @param {number} date\n     * @param {number} hour\n     * @param {number} minute\n     * @param {number} second\n     * @param {number} ms\n     *\n     * @returns {Date}\n     */\n    function ClockDate(year, month, date, hour, minute, second, ms) {\n      // the Date constructor called as a function, ref Ecma-262 Edition 5.1, section 15.9.2.\n      // This remains so in the 10th edition of 2019 as well.\n      if (!(this instanceof ClockDate)) {\n        return new NativeDate(ClockDate.clock.now).toString();\n      } // if Date is called as a constructor with 'new' keyword\n      // Defensive and verbose to avoid potential harm in passing\n      // explicit undefined when user does not pass argument\n\n\n      switch (arguments.length) {\n        case 0:\n          return new NativeDate(ClockDate.clock.now);\n\n        case 1:\n          return new NativeDate(year);\n\n        case 2:\n          return new NativeDate(year, month);\n\n        case 3:\n          return new NativeDate(year, month, date);\n\n        case 4:\n          return new NativeDate(year, month, date, hour);\n\n        case 5:\n          return new NativeDate(year, month, date, hour, minute);\n\n        case 6:\n          return new NativeDate(year, month, date, hour, minute, second);\n\n        default:\n          return new NativeDate(year, month, date, hour, minute, second, ms);\n      }\n    }\n\n    return mirrorDateProperties(ClockDate, NativeDate);\n  } //eslint-disable-next-line jsdoc/require-jsdoc\n\n\n  function enqueueJob(clock, job) {\n    // enqueues a microtick-deferred task - ecma262/#sec-enqueuejob\n    if (!clock.jobs) {\n      clock.jobs = [];\n    }\n\n    clock.jobs.push(job);\n  } //eslint-disable-next-line jsdoc/require-jsdoc\n\n\n  function runJobs(clock) {\n    // runs all microtick-deferred tasks - ecma262/#sec-runjobs\n    if (!clock.jobs) {\n      return;\n    }\n\n    for (let i = 0; i < clock.jobs.length; i++) {\n      const job = clock.jobs[i];\n      job.func.apply(null, job.args);\n      checkIsNearInfiniteLimit(clock, i);\n\n      if (clock.loopLimit && i > clock.loopLimit) {\n        throw getInfiniteLoopError(clock, job);\n      }\n    }\n\n    resetIsNearInfiniteLimit();\n    clock.jobs = [];\n  }\n  /**\n   * @param {Clock} clock\n   * @param {Timer} timer\n   * @returns {number} id of the created timer\n   */\n\n\n  function addTimer(clock, timer) {\n    if (timer.func === undefined) {\n      throw new Error(\"Callback must be provided to timer calls\");\n    }\n\n    if (addTimerReturnsObject) {\n      // Node.js environment\n      if (typeof timer.func !== \"function\") {\n        throw new TypeError(`[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${timer.func} of type ${typeof timer.func}`);\n      }\n    }\n\n    if (isNearInfiniteLimit) {\n      timer.error = new Error();\n    }\n\n    timer.type = timer.immediate ? \"Immediate\" : \"Timeout\";\n\n    if (timer.hasOwnProperty(\"delay\")) {\n      if (typeof timer.delay !== \"number\") {\n        timer.delay = parseInt(timer.delay, 10);\n      }\n\n      if (!isNumberFinite(timer.delay)) {\n        timer.delay = 0;\n      }\n\n      timer.delay = timer.delay > maxTimeout ? 1 : timer.delay;\n      timer.delay = Math.max(0, timer.delay);\n    }\n\n    if (timer.hasOwnProperty(\"interval\")) {\n      timer.type = \"Interval\";\n      timer.interval = timer.interval > maxTimeout ? 1 : timer.interval;\n    }\n\n    if (timer.hasOwnProperty(\"animation\")) {\n      timer.type = \"AnimationFrame\";\n      timer.animation = true;\n    }\n\n    if (timer.hasOwnProperty(\"idleCallback\")) {\n      timer.type = \"IdleCallback\";\n      timer.idleCallback = true;\n    }\n\n    if (!clock.timers) {\n      clock.timers = {};\n    }\n\n    timer.id = uniqueTimerId++;\n    timer.createdAt = clock.now;\n    timer.callAt = clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));\n    clock.timers[timer.id] = timer;\n\n    if (addTimerReturnsObject) {\n      const res = {\n        ref: function () {\n          return res;\n        },\n        unref: function () {\n          return res;\n        },\n        refresh: function () {\n          clearTimeout(timer.id);\n          const args = [timer.func, timer.delay].concat(timer.args);\n          return setTimeout.apply(null, args);\n        },\n        [Symbol.toPrimitive]: function () {\n          return timer.id;\n        }\n      };\n      return res;\n    }\n\n    return timer.id;\n  }\n  /* eslint consistent-return: \"off\" */\n\n  /**\n   * Timer comparitor\n   *\n   * @param {Timer} a\n   * @param {Timer} b\n   * @returns {number}\n   */\n\n\n  function compareTimers(a, b) {\n    // Sort first by absolute timing\n    if (a.callAt < b.callAt) {\n      return -1;\n    }\n\n    if (a.callAt > b.callAt) {\n      return 1;\n    } // Sort next by immediate, immediate timers take precedence\n\n\n    if (a.immediate && !b.immediate) {\n      return -1;\n    }\n\n    if (!a.immediate && b.immediate) {\n      return 1;\n    } // Sort next by creation time, earlier-created timers take precedence\n\n\n    if (a.createdAt < b.createdAt) {\n      return -1;\n    }\n\n    if (a.createdAt > b.createdAt) {\n      return 1;\n    } // Sort next by id, lower-id timers take precedence\n\n\n    if (a.id < b.id) {\n      return -1;\n    }\n\n    if (a.id > b.id) {\n      return 1;\n    } // As timer ids are unique, no fallback `0` is necessary\n\n  }\n  /**\n   * @param {Clock} clock\n   * @param {number} from\n   * @param {number} to\n   *\n   * @returns {Timer}\n   */\n\n\n  function firstTimerInRange(clock, from, to) {\n    const timers = clock.timers;\n    let timer = null;\n    let id, isInRange;\n\n    for (id in timers) {\n      if (timers.hasOwnProperty(id)) {\n        isInRange = inRange(from, to, timers[id]);\n\n        if (isInRange && (!timer || compareTimers(timer, timers[id]) === 1)) {\n          timer = timers[id];\n        }\n      }\n    }\n\n    return timer;\n  }\n  /**\n   * @param {Clock} clock\n   * @returns {Timer}\n   */\n\n\n  function firstTimer(clock) {\n    const timers = clock.timers;\n    let timer = null;\n    let id;\n\n    for (id in timers) {\n      if (timers.hasOwnProperty(id)) {\n        if (!timer || compareTimers(timer, timers[id]) === 1) {\n          timer = timers[id];\n        }\n      }\n    }\n\n    return timer;\n  }\n  /**\n   * @param {Clock} clock\n   * @returns {Timer}\n   */\n\n\n  function lastTimer(clock) {\n    const timers = clock.timers;\n    let timer = null;\n    let id;\n\n    for (id in timers) {\n      if (timers.hasOwnProperty(id)) {\n        if (!timer || compareTimers(timer, timers[id]) === -1) {\n          timer = timers[id];\n        }\n      }\n    }\n\n    return timer;\n  }\n  /**\n   * @param {Clock} clock\n   * @param {Timer} timer\n   */\n\n\n  function callTimer(clock, timer) {\n    if (typeof timer.interval === \"number\") {\n      clock.timers[timer.id].callAt += timer.interval;\n    } else {\n      delete clock.timers[timer.id];\n    }\n\n    if (typeof timer.func === \"function\") {\n      timer.func.apply(null, timer.args);\n    } else {\n      /* eslint no-eval: \"off\" */\n      const eval2 = eval;\n\n      (function () {\n        eval2(timer.func);\n      })();\n    }\n  }\n  /**\n   * Gets clear handler name for a given timer type\n   * @param {string} ttype\n   */\n\n\n  function getClearHandler(ttype) {\n    if (ttype === \"IdleCallback\" || ttype === \"AnimationFrame\") {\n      return `cancel${ttype}`;\n    }\n\n    return `clear${ttype}`;\n  }\n  /**\n   * Gets schedule handler name for a given timer type\n   * @param {string} ttype\n   */\n\n\n  function getScheduleHandler(ttype) {\n    if (ttype === \"IdleCallback\" || ttype === \"AnimationFrame\") {\n      return `request${ttype}`;\n    }\n\n    return `set${ttype}`;\n  }\n  /**\n   * Creates an anonymous function to warn only once\n   */\n\n\n  function createWarnOnce() {\n    let calls = 0;\n    return function (msg) {\n      // eslint-disable-next-line\n      !calls++ && console.warn(msg);\n    };\n  }\n\n  const warnOnce = createWarnOnce();\n  /**\n   * @param {Clock} clock\n   * @param {number} timerId\n   * @param {string} ttype\n   */\n\n  function clearTimer(clock, timerId, ttype) {\n    if (!timerId) {\n      // null appears to be allowed in most browsers, and appears to be\n      // relied upon by some libraries, like Bootstrap carousel\n      return;\n    }\n\n    if (!clock.timers) {\n      clock.timers = {};\n    } // in Node, the ID is stored as the primitive value for `Timeout` objects\n    // for `Immediate` objects, no ID exists, so it gets coerced to NaN\n\n\n    const id = Number(timerId);\n\n    if (Number.isNaN(id) || id < idCounterStart) {\n      const handlerName = getClearHandler(ttype);\n\n      if (clock.shouldClearNativeTimers === true) {\n        const nativeHandler = clock[`_${handlerName}`];\n        return typeof nativeHandler === \"function\" ? nativeHandler(timerId) : undefined;\n      }\n\n      warnOnce(`FakeTimers: ${handlerName} was invoked to clear a native timer instead of one created by this library.` + \"\\nTo automatically clean-up native timers, use `shouldClearNativeTimers`.\");\n    }\n\n    if (clock.timers.hasOwnProperty(id)) {\n      // check that the ID matches a timer of the correct type\n      const timer = clock.timers[id];\n\n      if (timer.type === ttype || timer.type === \"Timeout\" && ttype === \"Interval\" || timer.type === \"Interval\" && ttype === \"Timeout\") {\n        delete clock.timers[id];\n      } else {\n        const clear = getClearHandler(ttype);\n        const schedule = getScheduleHandler(timer.type);\n        throw new Error(`Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`);\n      }\n    }\n  }\n  /**\n   * @param {Clock} clock\n   * @param {Config} config\n   * @returns {Timer[]}\n   */\n\n\n  function uninstall(clock, config) {\n    let method, i, l;\n    const installedHrTime = \"_hrtime\";\n    const installedNextTick = \"_nextTick\";\n\n    for (i = 0, l = clock.methods.length; i < l; i++) {\n      method = clock.methods[i];\n\n      if (method === \"hrtime\" && _global.process) {\n        _global.process.hrtime = clock[installedHrTime];\n      } else if (method === \"nextTick\" && _global.process) {\n        _global.process.nextTick = clock[installedNextTick];\n      } else if (method === \"performance\") {\n        const originalPerfDescriptor = Object.getOwnPropertyDescriptor(clock, `_${method}`);\n\n        if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) {\n          Object.defineProperty(_global, method, originalPerfDescriptor);\n        } else if (originalPerfDescriptor.configurable) {\n          _global[method] = clock[`_${method}`];\n        }\n      } else {\n        if (_global[method] && _global[method].hadOwnProperty) {\n          _global[method] = clock[`_${method}`];\n        } else {\n          try {\n            delete _global[method];\n          } catch (ignore) {\n            /* eslint no-empty: \"off\" */\n          }\n        }\n      }\n    }\n\n    if (config.shouldAdvanceTime === true) {\n      _global.clearInterval(clock.attachedInterval);\n    } // Prevent multiple executions which will completely remove these props\n\n\n    clock.methods = []; // return pending timers, to enable checking what timers remained on uninstall\n\n    if (!clock.timers) {\n      return [];\n    }\n\n    return Object.keys(clock.timers).map(function mapper(key) {\n      return clock.timers[key];\n    });\n  }\n  /**\n   * @param {object} target the target containing the method to replace\n   * @param {string} method the keyname of the method on the target\n   * @param {Clock} clock\n   */\n\n\n  function hijackMethod(target, method, clock) {\n    clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(target, method);\n    clock[`_${method}`] = target[method];\n\n    if (method === \"Date\") {\n      const date = mirrorDateProperties(clock[method], target[method]);\n      target[method] = date;\n    } else if (method === \"performance\") {\n      const originalPerfDescriptor = Object.getOwnPropertyDescriptor(target, method); // JSDOM has a read only performance field so we have to save/copy it differently\n\n      if (originalPerfDescriptor && originalPerfDescriptor.get && !originalPerfDescriptor.set) {\n        Object.defineProperty(clock, `_${method}`, originalPerfDescriptor);\n        const perfDescriptor = Object.getOwnPropertyDescriptor(clock, method);\n        Object.defineProperty(target, method, perfDescriptor);\n      } else {\n        target[method] = clock[method];\n      }\n    } else {\n      target[method] = function () {\n        return clock[method].apply(clock, arguments);\n      };\n\n      Object.defineProperties(target[method], Object.getOwnPropertyDescriptors(clock[method]));\n    }\n\n    target[method].clock = clock;\n  }\n  /**\n   * @param {Clock} clock\n   * @param {number} advanceTimeDelta\n   */\n\n\n  function doIntervalTick(clock, advanceTimeDelta) {\n    clock.tick(advanceTimeDelta);\n  }\n  /**\n   * @typedef {object} Timers\n   * @property {setTimeout} setTimeout\n   * @property {clearTimeout} clearTimeout\n   * @property {setInterval} setInterval\n   * @property {clearInterval} clearInterval\n   * @property {Date} Date\n   * @property {SetImmediate=} setImmediate\n   * @property {function(NodeImmediate): void=} clearImmediate\n   * @property {function(number[]):number[]=} hrtime\n   * @property {NextTick=} nextTick\n   * @property {Performance=} performance\n   * @property {RequestAnimationFrame=} requestAnimationFrame\n   * @property {boolean=} queueMicrotask\n   * @property {function(number): void=} cancelAnimationFrame\n   * @property {RequestIdleCallback=} requestIdleCallback\n   * @property {function(number): void=} cancelIdleCallback\n   */\n\n  /** @type {Timers} */\n\n\n  const timers = {\n    setTimeout: _global.setTimeout,\n    clearTimeout: _global.clearTimeout,\n    setInterval: _global.setInterval,\n    clearInterval: _global.clearInterval,\n    Date: _global.Date\n  };\n\n  if (setImmediatePresent) {\n    timers.setImmediate = _global.setImmediate;\n    timers.clearImmediate = _global.clearImmediate;\n  }\n\n  if (hrtimePresent) {\n    timers.hrtime = _global.process.hrtime;\n  }\n\n  if (nextTickPresent) {\n    timers.nextTick = _global.process.nextTick;\n  }\n\n  if (performancePresent) {\n    timers.performance = _global.performance;\n  }\n\n  if (requestAnimationFramePresent) {\n    timers.requestAnimationFrame = _global.requestAnimationFrame;\n  }\n\n  if (queueMicrotaskPresent) {\n    timers.queueMicrotask = true;\n  }\n\n  if (cancelAnimationFramePresent) {\n    timers.cancelAnimationFrame = _global.cancelAnimationFrame;\n  }\n\n  if (requestIdleCallbackPresent) {\n    timers.requestIdleCallback = _global.requestIdleCallback;\n  }\n\n  if (cancelIdleCallbackPresent) {\n    timers.cancelIdleCallback = _global.cancelIdleCallback;\n  }\n\n  const originalSetTimeout = _global.setImmediate || _global.setTimeout;\n  /**\n   * @param {Date|number} [start] the system time - non-integer values are floored\n   * @param {number} [loopLimit] maximum number of timers that will be run when calling runAll()\n   * @returns {Clock}\n   */\n\n  function createClock(start, loopLimit) {\n    // eslint-disable-next-line no-param-reassign\n    start = Math.floor(getEpoch(start)); // eslint-disable-next-line no-param-reassign\n\n    loopLimit = loopLimit || 1000;\n    let nanos = 0;\n    const adjustedSystemTime = [0, 0]; // [millis, nanoremainder]\n\n    if (NativeDate === undefined) {\n      throw new Error(\"The global scope doesn't have a `Date` object\" + \" (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)\");\n    }\n\n    const clock = {\n      now: start,\n      Date: createDate(),\n      loopLimit: loopLimit\n    };\n    clock.Date.clock = clock; //eslint-disable-next-line jsdoc/require-jsdoc\n\n    function getTimeToNextFrame() {\n      return 16 - (clock.now - start) % 16;\n    } //eslint-disable-next-line jsdoc/require-jsdoc\n\n\n    function hrtime(prev) {\n      const millisSinceStart = clock.now - adjustedSystemTime[0] - start;\n      const secsSinceStart = Math.floor(millisSinceStart / 1000);\n      const remainderInNanos = (millisSinceStart - secsSinceStart * 1e3) * 1e6 + nanos - adjustedSystemTime[1];\n\n      if (Array.isArray(prev)) {\n        if (prev[1] > 1e9) {\n          throw new TypeError(\"Number of nanoseconds can't exceed a billion\");\n        }\n\n        const oldSecs = prev[0];\n        let nanoDiff = remainderInNanos - prev[1];\n        let secDiff = secsSinceStart - oldSecs;\n\n        if (nanoDiff < 0) {\n          nanoDiff += 1e9;\n          secDiff -= 1;\n        }\n\n        return [secDiff, nanoDiff];\n      }\n\n      return [secsSinceStart, remainderInNanos];\n    }\n\n    if (hrtimeBigintPresent) {\n      hrtime.bigint = function () {\n        const parts = hrtime();\n        return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]); // eslint-disable-line\n      };\n    }\n\n    clock.requestIdleCallback = function requestIdleCallback(func, timeout) {\n      let timeToNextIdlePeriod = 0;\n\n      if (clock.countTimers() > 0) {\n        timeToNextIdlePeriod = 50; // const for now\n      }\n\n      const result = addTimer(clock, {\n        func: func,\n        args: Array.prototype.slice.call(arguments, 2),\n        delay: typeof timeout === \"undefined\" ? timeToNextIdlePeriod : Math.min(timeout, timeToNextIdlePeriod),\n        idleCallback: true\n      });\n      return Number(result);\n    };\n\n    clock.cancelIdleCallback = function cancelIdleCallback(timerId) {\n      return clearTimer(clock, timerId, \"IdleCallback\");\n    };\n\n    clock.setTimeout = function setTimeout(func, timeout) {\n      return addTimer(clock, {\n        func: func,\n        args: Array.prototype.slice.call(arguments, 2),\n        delay: timeout\n      });\n    };\n\n    if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n      clock.setTimeout[utilPromisify.custom] = function promisifiedSetTimeout(timeout, arg) {\n        return new _global.Promise(function setTimeoutExecutor(resolve) {\n          addTimer(clock, {\n            func: resolve,\n            args: [arg],\n            delay: timeout\n          });\n        });\n      };\n    }\n\n    clock.clearTimeout = function clearTimeout(timerId) {\n      return clearTimer(clock, timerId, \"Timeout\");\n    };\n\n    clock.nextTick = function nextTick(func) {\n      return enqueueJob(clock, {\n        func: func,\n        args: Array.prototype.slice.call(arguments, 1),\n        error: isNearInfiniteLimit ? new Error() : null\n      });\n    };\n\n    clock.queueMicrotask = function queueMicrotask(func) {\n      return clock.nextTick(func); // explicitly drop additional arguments\n    };\n\n    clock.setInterval = function setInterval(func, timeout) {\n      // eslint-disable-next-line no-param-reassign\n      timeout = parseInt(timeout, 10);\n      return addTimer(clock, {\n        func: func,\n        args: Array.prototype.slice.call(arguments, 2),\n        delay: timeout,\n        interval: timeout\n      });\n    };\n\n    clock.clearInterval = function clearInterval(timerId) {\n      return clearTimer(clock, timerId, \"Interval\");\n    };\n\n    if (setImmediatePresent) {\n      clock.setImmediate = function setImmediate(func) {\n        return addTimer(clock, {\n          func: func,\n          args: Array.prototype.slice.call(arguments, 1),\n          immediate: true\n        });\n      };\n\n      if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n        clock.setImmediate[utilPromisify.custom] = function promisifiedSetImmediate(arg) {\n          return new _global.Promise(function setImmediateExecutor(resolve) {\n            addTimer(clock, {\n              func: resolve,\n              args: [arg],\n              immediate: true\n            });\n          });\n        };\n      }\n\n      clock.clearImmediate = function clearImmediate(timerId) {\n        return clearTimer(clock, timerId, \"Immediate\");\n      };\n    }\n\n    clock.countTimers = function countTimers() {\n      return Object.keys(clock.timers || {}).length + (clock.jobs || []).length;\n    };\n\n    clock.requestAnimationFrame = function requestAnimationFrame(func) {\n      const result = addTimer(clock, {\n        func: func,\n        delay: getTimeToNextFrame(),\n        args: [clock.now + getTimeToNextFrame()],\n        animation: true\n      });\n      return Number(result);\n    };\n\n    clock.cancelAnimationFrame = function cancelAnimationFrame(timerId) {\n      return clearTimer(clock, timerId, \"AnimationFrame\");\n    };\n\n    clock.runMicrotasks = function runMicrotasks() {\n      runJobs(clock);\n    };\n    /**\n     * @param {number|string} tickValue milliseconds or a string parseable by parseTime\n     * @param {boolean} isAsync\n     * @param {Function} resolve\n     * @param {Function} reject\n     * @returns {number|undefined} will return the new `now` value or nothing for async\n     */\n\n\n    function doTick(tickValue, isAsync, resolve, reject) {\n      const msFloat = typeof tickValue === \"number\" ? tickValue : parseTime(tickValue);\n      const ms = Math.floor(msFloat);\n      const remainder = nanoRemainder(msFloat);\n      let nanosTotal = nanos + remainder;\n      let tickTo = clock.now + ms;\n\n      if (msFloat < 0) {\n        throw new TypeError(\"Negative ticks are not supported\");\n      } // adjust for positive overflow\n\n\n      if (nanosTotal >= 1e6) {\n        tickTo += 1;\n        nanosTotal -= 1e6;\n      }\n\n      nanos = nanosTotal;\n      let tickFrom = clock.now;\n      let previous = clock.now; // ESLint fails to detect this correctly\n\n      /* eslint-disable prefer-const */\n\n      let timer, firstException, oldNow, nextPromiseTick, compensationCheck, postTimerCall;\n      /* eslint-enable prefer-const */\n\n      clock.duringTick = true; // perform microtasks\n\n      oldNow = clock.now;\n      runJobs(clock);\n\n      if (oldNow !== clock.now) {\n        // compensate for any setSystemTime() call during microtask callback\n        tickFrom += clock.now - oldNow;\n        tickTo += clock.now - oldNow;\n      } //eslint-disable-next-line jsdoc/require-jsdoc\n\n\n      function doTickInner() {\n        // perform each timer in the requested range\n        timer = firstTimerInRange(clock, tickFrom, tickTo); // eslint-disable-next-line no-unmodified-loop-condition\n\n        while (timer && tickFrom <= tickTo) {\n          if (clock.timers[timer.id]) {\n            tickFrom = timer.callAt;\n            clock.now = timer.callAt;\n            oldNow = clock.now;\n\n            try {\n              runJobs(clock);\n              callTimer(clock, timer);\n            } catch (e) {\n              firstException = firstException || e;\n            }\n\n            if (isAsync) {\n              // finish up after native setImmediate callback to allow\n              // all native es6 promises to process their callbacks after\n              // each timer fires.\n              originalSetTimeout(nextPromiseTick);\n              return;\n            }\n\n            compensationCheck();\n          }\n\n          postTimerCall();\n        } // perform process.nextTick()s again\n\n\n        oldNow = clock.now;\n        runJobs(clock);\n\n        if (oldNow !== clock.now) {\n          // compensate for any setSystemTime() call during process.nextTick() callback\n          tickFrom += clock.now - oldNow;\n          tickTo += clock.now - oldNow;\n        }\n\n        clock.duringTick = false; // corner case: during runJobs new timers were scheduled which could be in the range [clock.now, tickTo]\n\n        timer = firstTimerInRange(clock, tickFrom, tickTo);\n\n        if (timer) {\n          try {\n            clock.tick(tickTo - clock.now); // do it all again - for the remainder of the requested range\n          } catch (e) {\n            firstException = firstException || e;\n          }\n        } else {\n          // no timers remaining in the requested range: move the clock all the way to the end\n          clock.now = tickTo; // update nanos\n\n          nanos = nanosTotal;\n        }\n\n        if (firstException) {\n          throw firstException;\n        }\n\n        if (isAsync) {\n          resolve(clock.now);\n        } else {\n          return clock.now;\n        }\n      }\n\n      nextPromiseTick = isAsync && function () {\n        try {\n          compensationCheck();\n          postTimerCall();\n          doTickInner();\n        } catch (e) {\n          reject(e);\n        }\n      };\n\n      compensationCheck = function () {\n        // compensate for any setSystemTime() call during timer callback\n        if (oldNow !== clock.now) {\n          tickFrom += clock.now - oldNow;\n          tickTo += clock.now - oldNow;\n          previous += clock.now - oldNow;\n        }\n      };\n\n      postTimerCall = function () {\n        timer = firstTimerInRange(clock, previous, tickTo);\n        previous = tickFrom;\n      };\n\n      return doTickInner();\n    }\n    /**\n     * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n     * @returns {number} will return the new `now` value\n     */\n\n\n    clock.tick = function tick(tickValue) {\n      return doTick(tickValue, false);\n    };\n\n    if (typeof _global.Promise !== \"undefined\") {\n      /**\n       * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n       * @returns {Promise}\n       */\n      clock.tickAsync = function tickAsync(tickValue) {\n        return new _global.Promise(function (resolve, reject) {\n          originalSetTimeout(function () {\n            try {\n              doTick(tickValue, true, resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          });\n        });\n      };\n    }\n\n    clock.next = function next() {\n      runJobs(clock);\n      const timer = firstTimer(clock);\n\n      if (!timer) {\n        return clock.now;\n      }\n\n      clock.duringTick = true;\n\n      try {\n        clock.now = timer.callAt;\n        callTimer(clock, timer);\n        runJobs(clock);\n        return clock.now;\n      } finally {\n        clock.duringTick = false;\n      }\n    };\n\n    if (typeof _global.Promise !== \"undefined\") {\n      clock.nextAsync = function nextAsync() {\n        return new _global.Promise(function (resolve, reject) {\n          originalSetTimeout(function () {\n            try {\n              const timer = firstTimer(clock);\n\n              if (!timer) {\n                resolve(clock.now);\n                return;\n              }\n\n              let err;\n              clock.duringTick = true;\n              clock.now = timer.callAt;\n\n              try {\n                callTimer(clock, timer);\n              } catch (e) {\n                err = e;\n              }\n\n              clock.duringTick = false;\n              originalSetTimeout(function () {\n                if (err) {\n                  reject(err);\n                } else {\n                  resolve(clock.now);\n                }\n              });\n            } catch (e) {\n              reject(e);\n            }\n          });\n        });\n      };\n    }\n\n    clock.runAll = function runAll() {\n      let numTimers, i;\n      runJobs(clock);\n\n      for (i = 0; i < clock.loopLimit; i++) {\n        if (!clock.timers) {\n          resetIsNearInfiniteLimit();\n          return clock.now;\n        }\n\n        numTimers = Object.keys(clock.timers).length;\n\n        if (numTimers === 0) {\n          resetIsNearInfiniteLimit();\n          return clock.now;\n        }\n\n        clock.next();\n        checkIsNearInfiniteLimit(clock, i);\n      }\n\n      const excessJob = firstTimer(clock);\n      throw getInfiniteLoopError(clock, excessJob);\n    };\n\n    clock.runToFrame = function runToFrame() {\n      return clock.tick(getTimeToNextFrame());\n    };\n\n    if (typeof _global.Promise !== \"undefined\") {\n      clock.runAllAsync = function runAllAsync() {\n        return new _global.Promise(function (resolve, reject) {\n          let i = 0;\n          /**\n           *\n           */\n\n          function doRun() {\n            originalSetTimeout(function () {\n              try {\n                let numTimers;\n\n                if (i < clock.loopLimit) {\n                  if (!clock.timers) {\n                    resetIsNearInfiniteLimit();\n                    resolve(clock.now);\n                    return;\n                  }\n\n                  numTimers = Object.keys(clock.timers).length;\n\n                  if (numTimers === 0) {\n                    resetIsNearInfiniteLimit();\n                    resolve(clock.now);\n                    return;\n                  }\n\n                  clock.next();\n                  i++;\n                  doRun();\n                  checkIsNearInfiniteLimit(clock, i);\n                  return;\n                }\n\n                const excessJob = firstTimer(clock);\n                reject(getInfiniteLoopError(clock, excessJob));\n              } catch (e) {\n                reject(e);\n              }\n            });\n          }\n\n          doRun();\n        });\n      };\n    }\n\n    clock.runToLast = function runToLast() {\n      const timer = lastTimer(clock);\n\n      if (!timer) {\n        runJobs(clock);\n        return clock.now;\n      }\n\n      return clock.tick(timer.callAt - clock.now);\n    };\n\n    if (typeof _global.Promise !== \"undefined\") {\n      clock.runToLastAsync = function runToLastAsync() {\n        return new _global.Promise(function (resolve, reject) {\n          originalSetTimeout(function () {\n            try {\n              const timer = lastTimer(clock);\n\n              if (!timer) {\n                resolve(clock.now);\n              }\n\n              resolve(clock.tickAsync(timer.callAt));\n            } catch (e) {\n              reject(e);\n            }\n          });\n        });\n      };\n    }\n\n    clock.reset = function reset() {\n      nanos = 0;\n      clock.timers = {};\n      clock.jobs = [];\n      clock.now = start;\n    };\n\n    clock.setSystemTime = function setSystemTime(systemTime) {\n      // determine time difference\n      const newNow = getEpoch(systemTime);\n      const difference = newNow - clock.now;\n      let id, timer;\n      adjustedSystemTime[0] = adjustedSystemTime[0] + difference;\n      adjustedSystemTime[1] = adjustedSystemTime[1] + nanos; // update 'system clock'\n\n      clock.now = newNow;\n      nanos = 0; // update timers and intervals to keep them stable\n\n      for (id in clock.timers) {\n        if (clock.timers.hasOwnProperty(id)) {\n          timer = clock.timers[id];\n          timer.createdAt += difference;\n          timer.callAt += difference;\n        }\n      }\n    };\n\n    if (performancePresent) {\n      clock.performance = Object.create(null);\n\n      if (hasPerformancePrototype) {\n        const proto = _global.Performance.prototype;\n        Object.getOwnPropertyNames(proto).forEach(function (name) {\n          if (name.indexOf(\"getEntries\") === 0) {\n            // match expected return type for getEntries functions\n            clock.performance[name] = NOOP_ARRAY;\n          } else {\n            clock.performance[name] = NOOP;\n          }\n        });\n      }\n\n      clock.performance.now = function FakeTimersNow() {\n        const hrt = hrtime();\n        const millis = hrt[0] * 1000 + hrt[1] / 1e6;\n        return millis;\n      };\n    }\n\n    if (hrtimePresent) {\n      clock.hrtime = hrtime;\n    }\n\n    return clock;\n  }\n  /* eslint-disable complexity */\n\n  /**\n   * @param {Config=} [config] Optional config\n   * @returns {Clock}\n   */\n\n\n  function install(config) {\n    if (arguments.length > 1 || config instanceof Date || Array.isArray(config) || typeof config === \"number\") {\n      throw new TypeError(`FakeTimers.install called with ${String(config)} install requires an object parameter`);\n    } // eslint-disable-next-line no-param-reassign\n\n\n    config = typeof config !== \"undefined\" ? config : {};\n    config.shouldAdvanceTime = config.shouldAdvanceTime || false;\n    config.advanceTimeDelta = config.advanceTimeDelta || 20;\n    config.shouldClearNativeTimers = config.shouldClearNativeTimers || false;\n\n    if (config.target) {\n      throw new TypeError(\"config.target is no longer supported. Use `withGlobal(target)` instead.\");\n    }\n\n    let i, l;\n    const clock = createClock(config.now, config.loopLimit);\n    clock.shouldClearNativeTimers = config.shouldClearNativeTimers;\n\n    clock.uninstall = function () {\n      return uninstall(clock, config);\n    };\n\n    clock.methods = config.toFake || [];\n\n    if (clock.methods.length === 0) {\n      // do not fake nextTick by default - GitHub#126\n      clock.methods = Object.keys(timers).filter(function (key) {\n        return key !== \"nextTick\" && key !== \"queueMicrotask\";\n      });\n    }\n\n    if (config.shouldAdvanceTime === true) {\n      const intervalTick = doIntervalTick.bind(null, clock, config.advanceTimeDelta);\n\n      const intervalId = _global.setInterval(intervalTick, config.advanceTimeDelta);\n\n      clock.attachedInterval = intervalId;\n    }\n\n    for (i = 0, l = clock.methods.length; i < l; i++) {\n      const nameOfMethodToReplace = clock.methods[i];\n\n      if (nameOfMethodToReplace === \"hrtime\") {\n        if (_global.process && typeof _global.process.hrtime === \"function\") {\n          hijackMethod(_global.process, nameOfMethodToReplace, clock);\n        }\n      } else if (nameOfMethodToReplace === \"nextTick\") {\n        if (_global.process && typeof _global.process.nextTick === \"function\") {\n          hijackMethod(_global.process, nameOfMethodToReplace, clock);\n        }\n      } else {\n        hijackMethod(_global, nameOfMethodToReplace, clock);\n      }\n    }\n\n    return clock;\n  }\n  /* eslint-enable complexity */\n\n\n  return {\n    timers: timers,\n    createClock: createClock,\n    install: install,\n    withGlobal: withGlobal\n  };\n}\n/**\n * @typedef {object} FakeTimers\n * @property {Timers} timers\n * @property {createClock} createClock\n * @property {Function} install\n * @property {withGlobal} withGlobal\n */\n\n/* eslint-enable complexity */\n\n/** @type {FakeTimers} */\n\n\nconst defaultImplementation = withGlobal(globalObject);\nexports.timers = defaultImplementation.timers;\nexports.createClock = defaultImplementation.createClock;\nexports.install = defaultImplementation.install;\nexports.withGlobal = withGlobal;","map":{"version":3,"names":["globalObject","require","global","withGlobal","_global","userAgent","navigator","isRunningInIE","indexOf","maxTimeout","Math","pow","idCounterStart","NOOP","undefined","NOOP_ARRAY","timeoutResult","setTimeout","addTimerReturnsObject","hrtimePresent","process","hrtime","hrtimeBigintPresent","bigint","nextTickPresent","nextTick","utilPromisify","promisify","performancePresent","performance","now","hasPerformancePrototype","Performance","match","queueMicrotaskPresent","hasOwnProperty","requestAnimationFramePresent","requestAnimationFrame","cancelAnimationFramePresent","cancelAnimationFrame","requestIdleCallbackPresent","requestIdleCallback","cancelIdleCallbackPresent","cancelIdleCallback","setImmediatePresent","setImmediate","clearTimeout","setInterval","clearInterval","Date","clearImmediate","NativeDate","uniqueTimerId","isNumberFinite","num","Number","isFinite","isNearInfiniteLimit","checkIsNearInfiniteLimit","clock","i","loopLimit","resetIsNearInfiniteLimit","parseTime","str","strings","split","l","length","ms","parsed","test","Error","parseInt","nanoRemainder","msFloat","modulo","remainder","positiveRemainder","floor","getEpoch","epoch","getTime","TypeError","inRange","from","to","timer","callAt","getInfiniteLoopError","job","infiniteLoopError","error","computedTargetPattern","clockMethodPattern","RegExp","String","Object","keys","join","matchedLineIndex","stack","some","line","matchedComputedTarget","matchedClockMethod","type","func","name","slice","defineProperty","value","e","mirrorDateProperties","target","source","prop","toSource","toString","prototype","parse","UTC","toUTCString","createDate","ClockDate","year","month","date","hour","minute","second","arguments","enqueueJob","jobs","push","runJobs","apply","args","addTimer","immediate","delay","max","interval","animation","idleCallback","timers","id","createdAt","duringTick","res","ref","unref","refresh","concat","Symbol","toPrimitive","compareTimers","a","b","firstTimerInRange","isInRange","firstTimer","lastTimer","callTimer","eval2","eval","getClearHandler","ttype","getScheduleHandler","createWarnOnce","calls","msg","console","warn","warnOnce","clearTimer","timerId","isNaN","handlerName","shouldClearNativeTimers","nativeHandler","clear","schedule","uninstall","config","method","installedHrTime","installedNextTick","methods","originalPerfDescriptor","getOwnPropertyDescriptor","get","set","configurable","hadOwnProperty","ignore","shouldAdvanceTime","attachedInterval","map","mapper","key","hijackMethod","call","perfDescriptor","defineProperties","getOwnPropertyDescriptors","doIntervalTick","advanceTimeDelta","tick","queueMicrotask","originalSetTimeout","createClock","start","nanos","adjustedSystemTime","getTimeToNextFrame","prev","millisSinceStart","secsSinceStart","remainderInNanos","Array","isArray","oldSecs","nanoDiff","secDiff","parts","BigInt","timeout","timeToNextIdlePeriod","countTimers","result","min","Promise","custom","promisifiedSetTimeout","arg","setTimeoutExecutor","resolve","promisifiedSetImmediate","setImmediateExecutor","runMicrotasks","doTick","tickValue","isAsync","reject","nanosTotal","tickTo","tickFrom","previous","firstException","oldNow","nextPromiseTick","compensationCheck","postTimerCall","doTickInner","tickAsync","next","nextAsync","err","runAll","numTimers","excessJob","runToFrame","runAllAsync","doRun","runToLast","runToLastAsync","reset","setSystemTime","systemTime","newNow","difference","create","proto","getOwnPropertyNames","forEach","FakeTimersNow","hrt","millis","install","toFake","filter","intervalTick","bind","intervalId","nameOfMethodToReplace","defaultImplementation","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@sinonjs/fake-timers/src/fake-timers-src.js"],"sourcesContent":["\"use strict\";\n\nconst globalObject = require(\"@sinonjs/commons\").global;\n\n/**\n * @typedef {object} IdleDeadline\n * @property {boolean} didTimeout - whether or not the callback was called before reaching the optional timeout\n * @property {function():number} timeRemaining - a floating-point value providing an estimate of the number of milliseconds remaining in the current idle period\n */\n\n/**\n * Queues a function to be called during a browser's idle periods\n *\n * @callback RequestIdleCallback\n * @param {function(IdleDeadline)} callback\n * @param {{timeout: number}} options - an options object\n * @returns {number} the id\n */\n\n/**\n * @callback NextTick\n * @param {VoidVarArgsFunc} callback - the callback to run\n * @param {...*} arguments - optional arguments to call the callback with\n * @returns {void}\n */\n\n/**\n * @callback SetImmediate\n * @param {VoidVarArgsFunc} callback - the callback to run\n * @param {...*} arguments - optional arguments to call the callback with\n * @returns {NodeImmediate}\n */\n\n/**\n * @callback VoidVarArgsFunc\n * @param {...*} callback - the callback to run\n * @returns {void}\n */\n\n/**\n * @typedef RequestAnimationFrame\n * @property {function(number):void} requestAnimationFrame\n * @returns {number} - the id\n */\n\n/**\n * @typedef Performance\n * @property {function(): number} now\n */\n\n/* eslint-disable jsdoc/require-property-description */\n/**\n * @typedef {object} Clock\n * @property {number} now - the current time\n * @property {Date} Date - the Date constructor\n * @property {number} loopLimit - the maximum number of timers before assuming an infinite loop\n * @property {RequestIdleCallback} requestIdleCallback\n * @property {function(number):void} cancelIdleCallback\n * @property {setTimeout} setTimeout\n * @property {clearTimeout} clearTimeout\n * @property {NextTick} nextTick\n * @property {queueMicrotask} queueMicrotask\n * @property {setInterval} setInterval\n * @property {clearInterval} clearInterval\n * @property {SetImmediate} setImmediate\n * @property {function(NodeImmediate):void} clearImmediate\n * @property {function():number} countTimers\n * @property {RequestAnimationFrame} requestAnimationFrame\n * @property {function(number):void} cancelAnimationFrame\n * @property {function():void} runMicrotasks\n * @property {function(string | number): number} tick\n * @property {function(string | number): Promise<number>} tickAsync\n * @property {function(): number} next\n * @property {function(): Promise<number>} nextAsync\n * @property {function(): number} runAll\n * @property {function(): number} runToFrame\n * @property {function(): Promise<number>} runAllAsync\n * @property {function(): number} runToLast\n * @property {function(): Promise<number>} runToLastAsync\n * @property {function(): void} reset\n * @property {function(number | Date): void} setSystemTime\n * @property {Performance} performance\n * @property {function(number[]): number[]} hrtime - process.hrtime (legacy)\n * @property {function(): void} uninstall Uninstall the clock.\n * @property {Function[]} methods - the methods that are faked\n * @property {boolean} [shouldClearNativeTimers] inherited from config\n */\n/* eslint-enable jsdoc/require-property-description */\n\n/**\n * Configuration object for the `install` method.\n *\n * @typedef {object} Config\n * @property {number|Date} [now] a number (in milliseconds) or a Date object (default epoch)\n * @property {string[]} [toFake] names of the methods that should be faked.\n * @property {number} [loopLimit] the maximum number of timers that will be run when calling runAll()\n * @property {boolean} [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false)\n * @property {number} [advanceTimeDelta] increment mocked time every <<advanceTimeDelta>> ms (default: 20ms)\n * @property {boolean} [shouldClearNativeTimers] forwards clear timer calls to native functions if they are not fakes (default: false)\n */\n\n/* eslint-disable jsdoc/require-property-description */\n/**\n * The internal structure to describe a scheduled fake timer\n *\n * @typedef {object} Timer\n * @property {Function} func\n * @property {*[]} args\n * @property {number} delay\n * @property {number} callAt\n * @property {number} createdAt\n * @property {boolean} immediate\n * @property {number} id\n * @property {Error} [error]\n */\n\n/**\n * A Node timer\n *\n * @typedef {object} NodeImmediate\n * @property {function(): boolean} hasRef\n * @property {function(): NodeImmediate} ref\n * @property {function(): NodeImmediate} unref\n */\n/* eslint-enable jsdoc/require-property-description */\n\n/* eslint-disable complexity */\n\n/**\n * Mocks available features in the specified global namespace.\n *\n * @param {*} _global Namespace to mock (e.g. `window`)\n * @returns {FakeTimers}\n */\nfunction withGlobal(_global) {\n    const userAgent = _global.navigator && _global.navigator.userAgent;\n    const isRunningInIE = userAgent && userAgent.indexOf(\"MSIE \") > -1;\n    const maxTimeout = Math.pow(2, 31) - 1; //see https://heycam.github.io/webidl/#abstract-opdef-converttoint\n    const idCounterStart = 1e12; // arbitrarily large number to avoid collisions with native timer IDs\n    const NOOP = function () {\n        return undefined;\n    };\n    const NOOP_ARRAY = function () {\n        return [];\n    };\n    const timeoutResult = _global.setTimeout(NOOP, 0);\n    const addTimerReturnsObject = typeof timeoutResult === \"object\";\n    const hrtimePresent =\n        _global.process && typeof _global.process.hrtime === \"function\";\n    const hrtimeBigintPresent =\n        hrtimePresent && typeof _global.process.hrtime.bigint === \"function\";\n    const nextTickPresent =\n        _global.process && typeof _global.process.nextTick === \"function\";\n    const utilPromisify = _global.process && require(\"util\").promisify;\n    const performancePresent =\n        _global.performance && typeof _global.performance.now === \"function\";\n    const hasPerformancePrototype =\n        _global.Performance &&\n        (typeof _global.Performance).match(/^(function|object)$/);\n    const queueMicrotaskPresent = _global.hasOwnProperty(\"queueMicrotask\");\n    const requestAnimationFramePresent =\n        _global.requestAnimationFrame &&\n        typeof _global.requestAnimationFrame === \"function\";\n    const cancelAnimationFramePresent =\n        _global.cancelAnimationFrame &&\n        typeof _global.cancelAnimationFrame === \"function\";\n    const requestIdleCallbackPresent =\n        _global.requestIdleCallback &&\n        typeof _global.requestIdleCallback === \"function\";\n    const cancelIdleCallbackPresent =\n        _global.cancelIdleCallback &&\n        typeof _global.cancelIdleCallback === \"function\";\n    const setImmediatePresent =\n        _global.setImmediate && typeof _global.setImmediate === \"function\";\n\n    // Make properties writable in IE, as per\n    // https://www.adequatelygood.com/Replacing-setTimeout-Globally.html\n    /* eslint-disable no-self-assign */\n    if (isRunningInIE) {\n        _global.setTimeout = _global.setTimeout;\n        _global.clearTimeout = _global.clearTimeout;\n        _global.setInterval = _global.setInterval;\n        _global.clearInterval = _global.clearInterval;\n        _global.Date = _global.Date;\n    }\n\n    // setImmediate is not a standard function\n    // avoid adding the prop to the window object if not present\n    if (setImmediatePresent) {\n        _global.setImmediate = _global.setImmediate;\n        _global.clearImmediate = _global.clearImmediate;\n    }\n    /* eslint-enable no-self-assign */\n\n    _global.clearTimeout(timeoutResult);\n\n    const NativeDate = _global.Date;\n    let uniqueTimerId = idCounterStart;\n\n    /**\n     * @param {number} num\n     * @returns {boolean}\n     */\n    function isNumberFinite(num) {\n        if (Number.isFinite) {\n            return Number.isFinite(num);\n        }\n\n        return isFinite(num);\n    }\n\n    let isNearInfiniteLimit = false;\n\n    /**\n     * @param {Clock} clock\n     * @param {number} i\n     */\n    function checkIsNearInfiniteLimit(clock, i) {\n        if (clock.loopLimit && i === clock.loopLimit - 1) {\n            isNearInfiniteLimit = true;\n        }\n    }\n\n    /**\n     *\n     */\n    function resetIsNearInfiniteLimit() {\n        isNearInfiniteLimit = false;\n    }\n\n    /**\n     * Parse strings like \"01:10:00\" (meaning 1 hour, 10 minutes, 0 seconds) into\n     * number of milliseconds. This is used to support human-readable strings passed\n     * to clock.tick()\n     *\n     * @param {string} str\n     * @returns {number}\n     */\n    function parseTime(str) {\n        if (!str) {\n            return 0;\n        }\n\n        const strings = str.split(\":\");\n        const l = strings.length;\n        let i = l;\n        let ms = 0;\n        let parsed;\n\n        if (l > 3 || !/^(\\d\\d:){0,2}\\d\\d?$/.test(str)) {\n            throw new Error(\n                \"tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits\"\n            );\n        }\n\n        while (i--) {\n            parsed = parseInt(strings[i], 10);\n\n            if (parsed >= 60) {\n                throw new Error(`Invalid time ${str}`);\n            }\n\n            ms += parsed * Math.pow(60, l - i - 1);\n        }\n\n        return ms * 1000;\n    }\n\n    /**\n     * Get the decimal part of the millisecond value as nanoseconds\n     *\n     * @param {number} msFloat the number of milliseconds\n     * @returns {number} an integer number of nanoseconds in the range [0,1e6)\n     *\n     * Example: nanoRemainer(123.456789) -> 456789\n     */\n    function nanoRemainder(msFloat) {\n        const modulo = 1e6;\n        const remainder = (msFloat * 1e6) % modulo;\n        const positiveRemainder =\n            remainder < 0 ? remainder + modulo : remainder;\n\n        return Math.floor(positiveRemainder);\n    }\n\n    /**\n     * Used to grok the `now` parameter to createClock.\n     *\n     * @param {Date|number} epoch the system time\n     * @returns {number}\n     */\n    function getEpoch(epoch) {\n        if (!epoch) {\n            return 0;\n        }\n        if (typeof epoch.getTime === \"function\") {\n            return epoch.getTime();\n        }\n        if (typeof epoch === \"number\") {\n            return epoch;\n        }\n        throw new TypeError(\"now should be milliseconds since UNIX epoch\");\n    }\n\n    /**\n     * @param {number} from\n     * @param {number} to\n     * @param {Timer} timer\n     * @returns {boolean}\n     */\n    function inRange(from, to, timer) {\n        return timer && timer.callAt >= from && timer.callAt <= to;\n    }\n\n    /**\n     * @param {Clock} clock\n     * @param {Timer} job\n     */\n    function getInfiniteLoopError(clock, job) {\n        const infiniteLoopError = new Error(\n            `Aborting after running ${clock.loopLimit} timers, assuming an infinite loop!`\n        );\n\n        if (!job.error) {\n            return infiniteLoopError;\n        }\n\n        // pattern never matched in Node\n        const computedTargetPattern = /target\\.*[<|(|[].*?[>|\\]|)]\\s*/;\n        let clockMethodPattern = new RegExp(\n            String(Object.keys(clock).join(\"|\"))\n        );\n\n        if (addTimerReturnsObject) {\n            // node.js environment\n            clockMethodPattern = new RegExp(\n                `\\\\s+at (Object\\\\.)?(?:${Object.keys(clock).join(\"|\")})\\\\s+`\n            );\n        }\n\n        let matchedLineIndex = -1;\n        job.error.stack.split(\"\\n\").some(function (line, i) {\n            // If we've matched a computed target line (e.g. setTimeout) then we\n            // don't need to look any further. Return true to stop iterating.\n            const matchedComputedTarget = line.match(computedTargetPattern);\n            /* istanbul ignore if */\n            if (matchedComputedTarget) {\n                matchedLineIndex = i;\n                return true;\n            }\n\n            // If we've matched a clock method line, then there may still be\n            // others further down the trace. Return false to keep iterating.\n            const matchedClockMethod = line.match(clockMethodPattern);\n            if (matchedClockMethod) {\n                matchedLineIndex = i;\n                return false;\n            }\n\n            // If we haven't matched anything on this line, but we matched\n            // previously and set the matched line index, then we can stop.\n            // If we haven't matched previously, then we should keep iterating.\n            return matchedLineIndex >= 0;\n        });\n\n        const stack = `${infiniteLoopError}\\n${job.type || \"Microtask\"} - ${\n            job.func.name || \"anonymous\"\n        }\\n${job.error.stack\n            .split(\"\\n\")\n            .slice(matchedLineIndex + 1)\n            .join(\"\\n\")}`;\n\n        try {\n            Object.defineProperty(infiniteLoopError, \"stack\", {\n                value: stack,\n            });\n        } catch (e) {\n            // noop\n        }\n\n        return infiniteLoopError;\n    }\n\n    /**\n     * @param {Date} target\n     * @param {Date} source\n     * @returns {Date} the target after modifications\n     */\n    function mirrorDateProperties(target, source) {\n        let prop;\n        for (prop in source) {\n            if (source.hasOwnProperty(prop)) {\n                target[prop] = source[prop];\n            }\n        }\n\n        // set special now implementation\n        if (source.now) {\n            target.now = function now() {\n                return target.clock.now;\n            };\n        } else {\n            delete target.now;\n        }\n\n        // set special toSource implementation\n        if (source.toSource) {\n            target.toSource = function toSource() {\n                return source.toSource();\n            };\n        } else {\n            delete target.toSource;\n        }\n\n        // set special toString implementation\n        target.toString = function toString() {\n            return source.toString();\n        };\n\n        target.prototype = source.prototype;\n        target.parse = source.parse;\n        target.UTC = source.UTC;\n        target.prototype.toUTCString = source.prototype.toUTCString;\n\n        return target;\n    }\n\n    //eslint-disable-next-line jsdoc/require-jsdoc\n    function createDate() {\n        /**\n         * @param {number} year\n         * @param {number} month\n         * @param {number} date\n         * @param {number} hour\n         * @param {number} minute\n         * @param {number} second\n         * @param {number} ms\n         *\n         * @returns {Date}\n         */\n        function ClockDate(year, month, date, hour, minute, second, ms) {\n            // the Date constructor called as a function, ref Ecma-262 Edition 5.1, section 15.9.2.\n            // This remains so in the 10th edition of 2019 as well.\n            if (!(this instanceof ClockDate)) {\n                return new NativeDate(ClockDate.clock.now).toString();\n            }\n\n            // if Date is called as a constructor with 'new' keyword\n            // Defensive and verbose to avoid potential harm in passing\n            // explicit undefined when user does not pass argument\n            switch (arguments.length) {\n                case 0:\n                    return new NativeDate(ClockDate.clock.now);\n                case 1:\n                    return new NativeDate(year);\n                case 2:\n                    return new NativeDate(year, month);\n                case 3:\n                    return new NativeDate(year, month, date);\n                case 4:\n                    return new NativeDate(year, month, date, hour);\n                case 5:\n                    return new NativeDate(year, month, date, hour, minute);\n                case 6:\n                    return new NativeDate(\n                        year,\n                        month,\n                        date,\n                        hour,\n                        minute,\n                        second\n                    );\n                default:\n                    return new NativeDate(\n                        year,\n                        month,\n                        date,\n                        hour,\n                        minute,\n                        second,\n                        ms\n                    );\n            }\n        }\n\n        return mirrorDateProperties(ClockDate, NativeDate);\n    }\n\n    //eslint-disable-next-line jsdoc/require-jsdoc\n    function enqueueJob(clock, job) {\n        // enqueues a microtick-deferred task - ecma262/#sec-enqueuejob\n        if (!clock.jobs) {\n            clock.jobs = [];\n        }\n        clock.jobs.push(job);\n    }\n\n    //eslint-disable-next-line jsdoc/require-jsdoc\n    function runJobs(clock) {\n        // runs all microtick-deferred tasks - ecma262/#sec-runjobs\n        if (!clock.jobs) {\n            return;\n        }\n        for (let i = 0; i < clock.jobs.length; i++) {\n            const job = clock.jobs[i];\n            job.func.apply(null, job.args);\n\n            checkIsNearInfiniteLimit(clock, i);\n            if (clock.loopLimit && i > clock.loopLimit) {\n                throw getInfiniteLoopError(clock, job);\n            }\n        }\n        resetIsNearInfiniteLimit();\n        clock.jobs = [];\n    }\n\n    /**\n     * @param {Clock} clock\n     * @param {Timer} timer\n     * @returns {number} id of the created timer\n     */\n    function addTimer(clock, timer) {\n        if (timer.func === undefined) {\n            throw new Error(\"Callback must be provided to timer calls\");\n        }\n\n        if (addTimerReturnsObject) {\n            // Node.js environment\n            if (typeof timer.func !== \"function\") {\n                throw new TypeError(\n                    `[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${\n                        timer.func\n                    } of type ${typeof timer.func}`\n                );\n            }\n        }\n\n        if (isNearInfiniteLimit) {\n            timer.error = new Error();\n        }\n\n        timer.type = timer.immediate ? \"Immediate\" : \"Timeout\";\n\n        if (timer.hasOwnProperty(\"delay\")) {\n            if (typeof timer.delay !== \"number\") {\n                timer.delay = parseInt(timer.delay, 10);\n            }\n\n            if (!isNumberFinite(timer.delay)) {\n                timer.delay = 0;\n            }\n            timer.delay = timer.delay > maxTimeout ? 1 : timer.delay;\n            timer.delay = Math.max(0, timer.delay);\n        }\n\n        if (timer.hasOwnProperty(\"interval\")) {\n            timer.type = \"Interval\";\n            timer.interval = timer.interval > maxTimeout ? 1 : timer.interval;\n        }\n\n        if (timer.hasOwnProperty(\"animation\")) {\n            timer.type = \"AnimationFrame\";\n            timer.animation = true;\n        }\n\n        if (timer.hasOwnProperty(\"idleCallback\")) {\n            timer.type = \"IdleCallback\";\n            timer.idleCallback = true;\n        }\n\n        if (!clock.timers) {\n            clock.timers = {};\n        }\n\n        timer.id = uniqueTimerId++;\n        timer.createdAt = clock.now;\n        timer.callAt =\n            clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));\n\n        clock.timers[timer.id] = timer;\n\n        if (addTimerReturnsObject) {\n            const res = {\n                ref: function () {\n                    return res;\n                },\n                unref: function () {\n                    return res;\n                },\n                refresh: function () {\n                    clearTimeout(timer.id);\n                    const args = [timer.func, timer.delay].concat(timer.args);\n                    return setTimeout.apply(null, args);\n                },\n                [Symbol.toPrimitive]: function () {\n                    return timer.id;\n                },\n            };\n            return res;\n        }\n\n        return timer.id;\n    }\n\n    /* eslint consistent-return: \"off\" */\n    /**\n     * Timer comparitor\n     *\n     * @param {Timer} a\n     * @param {Timer} b\n     * @returns {number}\n     */\n    function compareTimers(a, b) {\n        // Sort first by absolute timing\n        if (a.callAt < b.callAt) {\n            return -1;\n        }\n        if (a.callAt > b.callAt) {\n            return 1;\n        }\n\n        // Sort next by immediate, immediate timers take precedence\n        if (a.immediate && !b.immediate) {\n            return -1;\n        }\n        if (!a.immediate && b.immediate) {\n            return 1;\n        }\n\n        // Sort next by creation time, earlier-created timers take precedence\n        if (a.createdAt < b.createdAt) {\n            return -1;\n        }\n        if (a.createdAt > b.createdAt) {\n            return 1;\n        }\n\n        // Sort next by id, lower-id timers take precedence\n        if (a.id < b.id) {\n            return -1;\n        }\n        if (a.id > b.id) {\n            return 1;\n        }\n\n        // As timer ids are unique, no fallback `0` is necessary\n    }\n\n    /**\n     * @param {Clock} clock\n     * @param {number} from\n     * @param {number} to\n     *\n     * @returns {Timer}\n     */\n    function firstTimerInRange(clock, from, to) {\n        const timers = clock.timers;\n        let timer = null;\n        let id, isInRange;\n\n        for (id in timers) {\n            if (timers.hasOwnProperty(id)) {\n                isInRange = inRange(from, to, timers[id]);\n\n                if (\n                    isInRange &&\n                    (!timer || compareTimers(timer, timers[id]) === 1)\n                ) {\n                    timer = timers[id];\n                }\n            }\n        }\n\n        return timer;\n    }\n\n    /**\n     * @param {Clock} clock\n     * @returns {Timer}\n     */\n    function firstTimer(clock) {\n        const timers = clock.timers;\n        let timer = null;\n        let id;\n\n        for (id in timers) {\n            if (timers.hasOwnProperty(id)) {\n                if (!timer || compareTimers(timer, timers[id]) === 1) {\n                    timer = timers[id];\n                }\n            }\n        }\n\n        return timer;\n    }\n\n    /**\n     * @param {Clock} clock\n     * @returns {Timer}\n     */\n    function lastTimer(clock) {\n        const timers = clock.timers;\n        let timer = null;\n        let id;\n\n        for (id in timers) {\n            if (timers.hasOwnProperty(id)) {\n                if (!timer || compareTimers(timer, timers[id]) === -1) {\n                    timer = timers[id];\n                }\n            }\n        }\n\n        return timer;\n    }\n\n    /**\n     * @param {Clock} clock\n     * @param {Timer} timer\n     */\n    function callTimer(clock, timer) {\n        if (typeof timer.interval === \"number\") {\n            clock.timers[timer.id].callAt += timer.interval;\n        } else {\n            delete clock.timers[timer.id];\n        }\n\n        if (typeof timer.func === \"function\") {\n            timer.func.apply(null, timer.args);\n        } else {\n            /* eslint no-eval: \"off\" */\n            const eval2 = eval;\n            (function () {\n                eval2(timer.func);\n            })();\n        }\n    }\n\n    /**\n     * Gets clear handler name for a given timer type\n     * @param {string} ttype\n     */\n    function getClearHandler(ttype) {\n        if (ttype === \"IdleCallback\" || ttype === \"AnimationFrame\") {\n            return `cancel${ttype}`;\n        }\n        return `clear${ttype}`;\n    }\n\n    /**\n     * Gets schedule handler name for a given timer type\n     * @param {string} ttype\n     */\n    function getScheduleHandler(ttype) {\n        if (ttype === \"IdleCallback\" || ttype === \"AnimationFrame\") {\n            return `request${ttype}`;\n        }\n        return `set${ttype}`;\n    }\n\n    /**\n     * Creates an anonymous function to warn only once\n     */\n    function createWarnOnce() {\n        let calls = 0;\n        return function (msg) {\n            // eslint-disable-next-line\n            !calls++ && console.warn(msg);\n        };\n    }\n    const warnOnce = createWarnOnce();\n\n    /**\n     * @param {Clock} clock\n     * @param {number} timerId\n     * @param {string} ttype\n     */\n    function clearTimer(clock, timerId, ttype) {\n        if (!timerId) {\n            // null appears to be allowed in most browsers, and appears to be\n            // relied upon by some libraries, like Bootstrap carousel\n            return;\n        }\n\n        if (!clock.timers) {\n            clock.timers = {};\n        }\n\n        // in Node, the ID is stored as the primitive value for `Timeout` objects\n        // for `Immediate` objects, no ID exists, so it gets coerced to NaN\n        const id = Number(timerId);\n\n        if (Number.isNaN(id) || id < idCounterStart) {\n            const handlerName = getClearHandler(ttype);\n\n            if (clock.shouldClearNativeTimers === true) {\n                const nativeHandler = clock[`_${handlerName}`];\n                return typeof nativeHandler === \"function\"\n                    ? nativeHandler(timerId)\n                    : undefined;\n            }\n            warnOnce(\n                `FakeTimers: ${handlerName} was invoked to clear a native timer instead of one created by this library.` +\n                    \"\\nTo automatically clean-up native timers, use `shouldClearNativeTimers`.\"\n            );\n        }\n\n        if (clock.timers.hasOwnProperty(id)) {\n            // check that the ID matches a timer of the correct type\n            const timer = clock.timers[id];\n            if (\n                timer.type === ttype ||\n                (timer.type === \"Timeout\" && ttype === \"Interval\") ||\n                (timer.type === \"Interval\" && ttype === \"Timeout\")\n            ) {\n                delete clock.timers[id];\n            } else {\n                const clear = getClearHandler(ttype);\n                const schedule = getScheduleHandler(timer.type);\n                throw new Error(\n                    `Cannot clear timer: timer created with ${schedule}() but cleared with ${clear}()`\n                );\n            }\n        }\n    }\n\n    /**\n     * @param {Clock} clock\n     * @param {Config} config\n     * @returns {Timer[]}\n     */\n    function uninstall(clock, config) {\n        let method, i, l;\n        const installedHrTime = \"_hrtime\";\n        const installedNextTick = \"_nextTick\";\n\n        for (i = 0, l = clock.methods.length; i < l; i++) {\n            method = clock.methods[i];\n            if (method === \"hrtime\" && _global.process) {\n                _global.process.hrtime = clock[installedHrTime];\n            } else if (method === \"nextTick\" && _global.process) {\n                _global.process.nextTick = clock[installedNextTick];\n            } else if (method === \"performance\") {\n                const originalPerfDescriptor = Object.getOwnPropertyDescriptor(\n                    clock,\n                    `_${method}`\n                );\n                if (\n                    originalPerfDescriptor &&\n                    originalPerfDescriptor.get &&\n                    !originalPerfDescriptor.set\n                ) {\n                    Object.defineProperty(\n                        _global,\n                        method,\n                        originalPerfDescriptor\n                    );\n                } else if (originalPerfDescriptor.configurable) {\n                    _global[method] = clock[`_${method}`];\n                }\n            } else {\n                if (_global[method] && _global[method].hadOwnProperty) {\n                    _global[method] = clock[`_${method}`];\n                } else {\n                    try {\n                        delete _global[method];\n                    } catch (ignore) {\n                        /* eslint no-empty: \"off\" */\n                    }\n                }\n            }\n        }\n\n        if (config.shouldAdvanceTime === true) {\n            _global.clearInterval(clock.attachedInterval);\n        }\n\n        // Prevent multiple executions which will completely remove these props\n        clock.methods = [];\n\n        // return pending timers, to enable checking what timers remained on uninstall\n        if (!clock.timers) {\n            return [];\n        }\n        return Object.keys(clock.timers).map(function mapper(key) {\n            return clock.timers[key];\n        });\n    }\n\n    /**\n     * @param {object} target the target containing the method to replace\n     * @param {string} method the keyname of the method on the target\n     * @param {Clock} clock\n     */\n    function hijackMethod(target, method, clock) {\n        clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(\n            target,\n            method\n        );\n        clock[`_${method}`] = target[method];\n\n        if (method === \"Date\") {\n            const date = mirrorDateProperties(clock[method], target[method]);\n            target[method] = date;\n        } else if (method === \"performance\") {\n            const originalPerfDescriptor = Object.getOwnPropertyDescriptor(\n                target,\n                method\n            );\n            // JSDOM has a read only performance field so we have to save/copy it differently\n            if (\n                originalPerfDescriptor &&\n                originalPerfDescriptor.get &&\n                !originalPerfDescriptor.set\n            ) {\n                Object.defineProperty(\n                    clock,\n                    `_${method}`,\n                    originalPerfDescriptor\n                );\n\n                const perfDescriptor = Object.getOwnPropertyDescriptor(\n                    clock,\n                    method\n                );\n                Object.defineProperty(target, method, perfDescriptor);\n            } else {\n                target[method] = clock[method];\n            }\n        } else {\n            target[method] = function () {\n                return clock[method].apply(clock, arguments);\n            };\n\n            Object.defineProperties(\n                target[method],\n                Object.getOwnPropertyDescriptors(clock[method])\n            );\n        }\n\n        target[method].clock = clock;\n    }\n\n    /**\n     * @param {Clock} clock\n     * @param {number} advanceTimeDelta\n     */\n    function doIntervalTick(clock, advanceTimeDelta) {\n        clock.tick(advanceTimeDelta);\n    }\n\n    /**\n     * @typedef {object} Timers\n     * @property {setTimeout} setTimeout\n     * @property {clearTimeout} clearTimeout\n     * @property {setInterval} setInterval\n     * @property {clearInterval} clearInterval\n     * @property {Date} Date\n     * @property {SetImmediate=} setImmediate\n     * @property {function(NodeImmediate): void=} clearImmediate\n     * @property {function(number[]):number[]=} hrtime\n     * @property {NextTick=} nextTick\n     * @property {Performance=} performance\n     * @property {RequestAnimationFrame=} requestAnimationFrame\n     * @property {boolean=} queueMicrotask\n     * @property {function(number): void=} cancelAnimationFrame\n     * @property {RequestIdleCallback=} requestIdleCallback\n     * @property {function(number): void=} cancelIdleCallback\n     */\n\n    /** @type {Timers} */\n    const timers = {\n        setTimeout: _global.setTimeout,\n        clearTimeout: _global.clearTimeout,\n        setInterval: _global.setInterval,\n        clearInterval: _global.clearInterval,\n        Date: _global.Date,\n    };\n\n    if (setImmediatePresent) {\n        timers.setImmediate = _global.setImmediate;\n        timers.clearImmediate = _global.clearImmediate;\n    }\n\n    if (hrtimePresent) {\n        timers.hrtime = _global.process.hrtime;\n    }\n\n    if (nextTickPresent) {\n        timers.nextTick = _global.process.nextTick;\n    }\n\n    if (performancePresent) {\n        timers.performance = _global.performance;\n    }\n\n    if (requestAnimationFramePresent) {\n        timers.requestAnimationFrame = _global.requestAnimationFrame;\n    }\n\n    if (queueMicrotaskPresent) {\n        timers.queueMicrotask = true;\n    }\n\n    if (cancelAnimationFramePresent) {\n        timers.cancelAnimationFrame = _global.cancelAnimationFrame;\n    }\n\n    if (requestIdleCallbackPresent) {\n        timers.requestIdleCallback = _global.requestIdleCallback;\n    }\n\n    if (cancelIdleCallbackPresent) {\n        timers.cancelIdleCallback = _global.cancelIdleCallback;\n    }\n\n    const originalSetTimeout = _global.setImmediate || _global.setTimeout;\n\n    /**\n     * @param {Date|number} [start] the system time - non-integer values are floored\n     * @param {number} [loopLimit] maximum number of timers that will be run when calling runAll()\n     * @returns {Clock}\n     */\n    function createClock(start, loopLimit) {\n        // eslint-disable-next-line no-param-reassign\n        start = Math.floor(getEpoch(start));\n        // eslint-disable-next-line no-param-reassign\n        loopLimit = loopLimit || 1000;\n        let nanos = 0;\n        const adjustedSystemTime = [0, 0]; // [millis, nanoremainder]\n\n        if (NativeDate === undefined) {\n            throw new Error(\n                \"The global scope doesn't have a `Date` object\" +\n                    \" (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)\"\n            );\n        }\n\n        const clock = {\n            now: start,\n            Date: createDate(),\n            loopLimit: loopLimit,\n        };\n\n        clock.Date.clock = clock;\n\n        //eslint-disable-next-line jsdoc/require-jsdoc\n        function getTimeToNextFrame() {\n            return 16 - ((clock.now - start) % 16);\n        }\n\n        //eslint-disable-next-line jsdoc/require-jsdoc\n        function hrtime(prev) {\n            const millisSinceStart = clock.now - adjustedSystemTime[0] - start;\n            const secsSinceStart = Math.floor(millisSinceStart / 1000);\n            const remainderInNanos =\n                (millisSinceStart - secsSinceStart * 1e3) * 1e6 +\n                nanos -\n                adjustedSystemTime[1];\n\n            if (Array.isArray(prev)) {\n                if (prev[1] > 1e9) {\n                    throw new TypeError(\n                        \"Number of nanoseconds can't exceed a billion\"\n                    );\n                }\n\n                const oldSecs = prev[0];\n                let nanoDiff = remainderInNanos - prev[1];\n                let secDiff = secsSinceStart - oldSecs;\n\n                if (nanoDiff < 0) {\n                    nanoDiff += 1e9;\n                    secDiff -= 1;\n                }\n\n                return [secDiff, nanoDiff];\n            }\n            return [secsSinceStart, remainderInNanos];\n        }\n\n        if (hrtimeBigintPresent) {\n            hrtime.bigint = function () {\n                const parts = hrtime();\n                return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]); // eslint-disable-line\n            };\n        }\n\n        clock.requestIdleCallback = function requestIdleCallback(\n            func,\n            timeout\n        ) {\n            let timeToNextIdlePeriod = 0;\n\n            if (clock.countTimers() > 0) {\n                timeToNextIdlePeriod = 50; // const for now\n            }\n\n            const result = addTimer(clock, {\n                func: func,\n                args: Array.prototype.slice.call(arguments, 2),\n                delay:\n                    typeof timeout === \"undefined\"\n                        ? timeToNextIdlePeriod\n                        : Math.min(timeout, timeToNextIdlePeriod),\n                idleCallback: true,\n            });\n\n            return Number(result);\n        };\n\n        clock.cancelIdleCallback = function cancelIdleCallback(timerId) {\n            return clearTimer(clock, timerId, \"IdleCallback\");\n        };\n\n        clock.setTimeout = function setTimeout(func, timeout) {\n            return addTimer(clock, {\n                func: func,\n                args: Array.prototype.slice.call(arguments, 2),\n                delay: timeout,\n            });\n        };\n        if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n            clock.setTimeout[\n                utilPromisify.custom\n            ] = function promisifiedSetTimeout(timeout, arg) {\n                return new _global.Promise(function setTimeoutExecutor(\n                    resolve\n                ) {\n                    addTimer(clock, {\n                        func: resolve,\n                        args: [arg],\n                        delay: timeout,\n                    });\n                });\n            };\n        }\n\n        clock.clearTimeout = function clearTimeout(timerId) {\n            return clearTimer(clock, timerId, \"Timeout\");\n        };\n\n        clock.nextTick = function nextTick(func) {\n            return enqueueJob(clock, {\n                func: func,\n                args: Array.prototype.slice.call(arguments, 1),\n                error: isNearInfiniteLimit ? new Error() : null,\n            });\n        };\n\n        clock.queueMicrotask = function queueMicrotask(func) {\n            return clock.nextTick(func); // explicitly drop additional arguments\n        };\n\n        clock.setInterval = function setInterval(func, timeout) {\n            // eslint-disable-next-line no-param-reassign\n            timeout = parseInt(timeout, 10);\n            return addTimer(clock, {\n                func: func,\n                args: Array.prototype.slice.call(arguments, 2),\n                delay: timeout,\n                interval: timeout,\n            });\n        };\n\n        clock.clearInterval = function clearInterval(timerId) {\n            return clearTimer(clock, timerId, \"Interval\");\n        };\n\n        if (setImmediatePresent) {\n            clock.setImmediate = function setImmediate(func) {\n                return addTimer(clock, {\n                    func: func,\n                    args: Array.prototype.slice.call(arguments, 1),\n                    immediate: true,\n                });\n            };\n\n            if (typeof _global.Promise !== \"undefined\" && utilPromisify) {\n                clock.setImmediate[\n                    utilPromisify.custom\n                ] = function promisifiedSetImmediate(arg) {\n                    return new _global.Promise(function setImmediateExecutor(\n                        resolve\n                    ) {\n                        addTimer(clock, {\n                            func: resolve,\n                            args: [arg],\n                            immediate: true,\n                        });\n                    });\n                };\n            }\n\n            clock.clearImmediate = function clearImmediate(timerId) {\n                return clearTimer(clock, timerId, \"Immediate\");\n            };\n        }\n\n        clock.countTimers = function countTimers() {\n            return (\n                Object.keys(clock.timers || {}).length +\n                (clock.jobs || []).length\n            );\n        };\n\n        clock.requestAnimationFrame = function requestAnimationFrame(func) {\n            const result = addTimer(clock, {\n                func: func,\n                delay: getTimeToNextFrame(),\n                args: [clock.now + getTimeToNextFrame()],\n                animation: true,\n            });\n\n            return Number(result);\n        };\n\n        clock.cancelAnimationFrame = function cancelAnimationFrame(timerId) {\n            return clearTimer(clock, timerId, \"AnimationFrame\");\n        };\n\n        clock.runMicrotasks = function runMicrotasks() {\n            runJobs(clock);\n        };\n\n        /**\n         * @param {number|string} tickValue milliseconds or a string parseable by parseTime\n         * @param {boolean} isAsync\n         * @param {Function} resolve\n         * @param {Function} reject\n         * @returns {number|undefined} will return the new `now` value or nothing for async\n         */\n        function doTick(tickValue, isAsync, resolve, reject) {\n            const msFloat =\n                typeof tickValue === \"number\"\n                    ? tickValue\n                    : parseTime(tickValue);\n            const ms = Math.floor(msFloat);\n            const remainder = nanoRemainder(msFloat);\n            let nanosTotal = nanos + remainder;\n            let tickTo = clock.now + ms;\n\n            if (msFloat < 0) {\n                throw new TypeError(\"Negative ticks are not supported\");\n            }\n\n            // adjust for positive overflow\n            if (nanosTotal >= 1e6) {\n                tickTo += 1;\n                nanosTotal -= 1e6;\n            }\n\n            nanos = nanosTotal;\n            let tickFrom = clock.now;\n            let previous = clock.now;\n            // ESLint fails to detect this correctly\n            /* eslint-disable prefer-const */\n            let timer,\n                firstException,\n                oldNow,\n                nextPromiseTick,\n                compensationCheck,\n                postTimerCall;\n            /* eslint-enable prefer-const */\n\n            clock.duringTick = true;\n\n            // perform microtasks\n            oldNow = clock.now;\n            runJobs(clock);\n            if (oldNow !== clock.now) {\n                // compensate for any setSystemTime() call during microtask callback\n                tickFrom += clock.now - oldNow;\n                tickTo += clock.now - oldNow;\n            }\n\n            //eslint-disable-next-line jsdoc/require-jsdoc\n            function doTickInner() {\n                // perform each timer in the requested range\n                timer = firstTimerInRange(clock, tickFrom, tickTo);\n                // eslint-disable-next-line no-unmodified-loop-condition\n                while (timer && tickFrom <= tickTo) {\n                    if (clock.timers[timer.id]) {\n                        tickFrom = timer.callAt;\n                        clock.now = timer.callAt;\n                        oldNow = clock.now;\n                        try {\n                            runJobs(clock);\n                            callTimer(clock, timer);\n                        } catch (e) {\n                            firstException = firstException || e;\n                        }\n\n                        if (isAsync) {\n                            // finish up after native setImmediate callback to allow\n                            // all native es6 promises to process their callbacks after\n                            // each timer fires.\n                            originalSetTimeout(nextPromiseTick);\n                            return;\n                        }\n\n                        compensationCheck();\n                    }\n\n                    postTimerCall();\n                }\n\n                // perform process.nextTick()s again\n                oldNow = clock.now;\n                runJobs(clock);\n                if (oldNow !== clock.now) {\n                    // compensate for any setSystemTime() call during process.nextTick() callback\n                    tickFrom += clock.now - oldNow;\n                    tickTo += clock.now - oldNow;\n                }\n                clock.duringTick = false;\n\n                // corner case: during runJobs new timers were scheduled which could be in the range [clock.now, tickTo]\n                timer = firstTimerInRange(clock, tickFrom, tickTo);\n                if (timer) {\n                    try {\n                        clock.tick(tickTo - clock.now); // do it all again - for the remainder of the requested range\n                    } catch (e) {\n                        firstException = firstException || e;\n                    }\n                } else {\n                    // no timers remaining in the requested range: move the clock all the way to the end\n                    clock.now = tickTo;\n\n                    // update nanos\n                    nanos = nanosTotal;\n                }\n                if (firstException) {\n                    throw firstException;\n                }\n\n                if (isAsync) {\n                    resolve(clock.now);\n                } else {\n                    return clock.now;\n                }\n            }\n\n            nextPromiseTick =\n                isAsync &&\n                function () {\n                    try {\n                        compensationCheck();\n                        postTimerCall();\n                        doTickInner();\n                    } catch (e) {\n                        reject(e);\n                    }\n                };\n\n            compensationCheck = function () {\n                // compensate for any setSystemTime() call during timer callback\n                if (oldNow !== clock.now) {\n                    tickFrom += clock.now - oldNow;\n                    tickTo += clock.now - oldNow;\n                    previous += clock.now - oldNow;\n                }\n            };\n\n            postTimerCall = function () {\n                timer = firstTimerInRange(clock, previous, tickTo);\n                previous = tickFrom;\n            };\n\n            return doTickInner();\n        }\n\n        /**\n         * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n         * @returns {number} will return the new `now` value\n         */\n        clock.tick = function tick(tickValue) {\n            return doTick(tickValue, false);\n        };\n\n        if (typeof _global.Promise !== \"undefined\") {\n            /**\n             * @param {string|number} tickValue number of milliseconds or a human-readable value like \"01:11:15\"\n             * @returns {Promise}\n             */\n            clock.tickAsync = function tickAsync(tickValue) {\n                return new _global.Promise(function (resolve, reject) {\n                    originalSetTimeout(function () {\n                        try {\n                            doTick(tickValue, true, resolve, reject);\n                        } catch (e) {\n                            reject(e);\n                        }\n                    });\n                });\n            };\n        }\n\n        clock.next = function next() {\n            runJobs(clock);\n            const timer = firstTimer(clock);\n            if (!timer) {\n                return clock.now;\n            }\n\n            clock.duringTick = true;\n            try {\n                clock.now = timer.callAt;\n                callTimer(clock, timer);\n                runJobs(clock);\n                return clock.now;\n            } finally {\n                clock.duringTick = false;\n            }\n        };\n\n        if (typeof _global.Promise !== \"undefined\") {\n            clock.nextAsync = function nextAsync() {\n                return new _global.Promise(function (resolve, reject) {\n                    originalSetTimeout(function () {\n                        try {\n                            const timer = firstTimer(clock);\n                            if (!timer) {\n                                resolve(clock.now);\n                                return;\n                            }\n\n                            let err;\n                            clock.duringTick = true;\n                            clock.now = timer.callAt;\n                            try {\n                                callTimer(clock, timer);\n                            } catch (e) {\n                                err = e;\n                            }\n                            clock.duringTick = false;\n\n                            originalSetTimeout(function () {\n                                if (err) {\n                                    reject(err);\n                                } else {\n                                    resolve(clock.now);\n                                }\n                            });\n                        } catch (e) {\n                            reject(e);\n                        }\n                    });\n                });\n            };\n        }\n\n        clock.runAll = function runAll() {\n            let numTimers, i;\n            runJobs(clock);\n            for (i = 0; i < clock.loopLimit; i++) {\n                if (!clock.timers) {\n                    resetIsNearInfiniteLimit();\n                    return clock.now;\n                }\n\n                numTimers = Object.keys(clock.timers).length;\n                if (numTimers === 0) {\n                    resetIsNearInfiniteLimit();\n                    return clock.now;\n                }\n\n                clock.next();\n                checkIsNearInfiniteLimit(clock, i);\n            }\n\n            const excessJob = firstTimer(clock);\n            throw getInfiniteLoopError(clock, excessJob);\n        };\n\n        clock.runToFrame = function runToFrame() {\n            return clock.tick(getTimeToNextFrame());\n        };\n\n        if (typeof _global.Promise !== \"undefined\") {\n            clock.runAllAsync = function runAllAsync() {\n                return new _global.Promise(function (resolve, reject) {\n                    let i = 0;\n                    /**\n                     *\n                     */\n                    function doRun() {\n                        originalSetTimeout(function () {\n                            try {\n                                let numTimers;\n                                if (i < clock.loopLimit) {\n                                    if (!clock.timers) {\n                                        resetIsNearInfiniteLimit();\n                                        resolve(clock.now);\n                                        return;\n                                    }\n\n                                    numTimers = Object.keys(clock.timers)\n                                        .length;\n                                    if (numTimers === 0) {\n                                        resetIsNearInfiniteLimit();\n                                        resolve(clock.now);\n                                        return;\n                                    }\n\n                                    clock.next();\n\n                                    i++;\n\n                                    doRun();\n                                    checkIsNearInfiniteLimit(clock, i);\n                                    return;\n                                }\n\n                                const excessJob = firstTimer(clock);\n                                reject(getInfiniteLoopError(clock, excessJob));\n                            } catch (e) {\n                                reject(e);\n                            }\n                        });\n                    }\n                    doRun();\n                });\n            };\n        }\n\n        clock.runToLast = function runToLast() {\n            const timer = lastTimer(clock);\n            if (!timer) {\n                runJobs(clock);\n                return clock.now;\n            }\n\n            return clock.tick(timer.callAt - clock.now);\n        };\n\n        if (typeof _global.Promise !== \"undefined\") {\n            clock.runToLastAsync = function runToLastAsync() {\n                return new _global.Promise(function (resolve, reject) {\n                    originalSetTimeout(function () {\n                        try {\n                            const timer = lastTimer(clock);\n                            if (!timer) {\n                                resolve(clock.now);\n                            }\n\n                            resolve(clock.tickAsync(timer.callAt));\n                        } catch (e) {\n                            reject(e);\n                        }\n                    });\n                });\n            };\n        }\n\n        clock.reset = function reset() {\n            nanos = 0;\n            clock.timers = {};\n            clock.jobs = [];\n            clock.now = start;\n        };\n\n        clock.setSystemTime = function setSystemTime(systemTime) {\n            // determine time difference\n            const newNow = getEpoch(systemTime);\n            const difference = newNow - clock.now;\n            let id, timer;\n\n            adjustedSystemTime[0] = adjustedSystemTime[0] + difference;\n            adjustedSystemTime[1] = adjustedSystemTime[1] + nanos;\n            // update 'system clock'\n            clock.now = newNow;\n            nanos = 0;\n\n            // update timers and intervals to keep them stable\n            for (id in clock.timers) {\n                if (clock.timers.hasOwnProperty(id)) {\n                    timer = clock.timers[id];\n                    timer.createdAt += difference;\n                    timer.callAt += difference;\n                }\n            }\n        };\n\n        if (performancePresent) {\n            clock.performance = Object.create(null);\n\n            if (hasPerformancePrototype) {\n                const proto = _global.Performance.prototype;\n\n                Object.getOwnPropertyNames(proto).forEach(function (name) {\n                    if (name.indexOf(\"getEntries\") === 0) {\n                        // match expected return type for getEntries functions\n                        clock.performance[name] = NOOP_ARRAY;\n                    } else {\n                        clock.performance[name] = NOOP;\n                    }\n                });\n            }\n\n            clock.performance.now = function FakeTimersNow() {\n                const hrt = hrtime();\n                const millis = hrt[0] * 1000 + hrt[1] / 1e6;\n                return millis;\n            };\n        }\n\n        if (hrtimePresent) {\n            clock.hrtime = hrtime;\n        }\n\n        return clock;\n    }\n\n    /* eslint-disable complexity */\n\n    /**\n     * @param {Config=} [config] Optional config\n     * @returns {Clock}\n     */\n    function install(config) {\n        if (\n            arguments.length > 1 ||\n            config instanceof Date ||\n            Array.isArray(config) ||\n            typeof config === \"number\"\n        ) {\n            throw new TypeError(\n                `FakeTimers.install called with ${String(\n                    config\n                )} install requires an object parameter`\n            );\n        }\n\n        // eslint-disable-next-line no-param-reassign\n        config = typeof config !== \"undefined\" ? config : {};\n        config.shouldAdvanceTime = config.shouldAdvanceTime || false;\n        config.advanceTimeDelta = config.advanceTimeDelta || 20;\n        config.shouldClearNativeTimers =\n            config.shouldClearNativeTimers || false;\n\n        if (config.target) {\n            throw new TypeError(\n                \"config.target is no longer supported. Use `withGlobal(target)` instead.\"\n            );\n        }\n\n        let i, l;\n        const clock = createClock(config.now, config.loopLimit);\n        clock.shouldClearNativeTimers = config.shouldClearNativeTimers;\n\n        clock.uninstall = function () {\n            return uninstall(clock, config);\n        };\n\n        clock.methods = config.toFake || [];\n\n        if (clock.methods.length === 0) {\n            // do not fake nextTick by default - GitHub#126\n            clock.methods = Object.keys(timers).filter(function (key) {\n                return key !== \"nextTick\" && key !== \"queueMicrotask\";\n            });\n        }\n\n        if (config.shouldAdvanceTime === true) {\n            const intervalTick = doIntervalTick.bind(\n                null,\n                clock,\n                config.advanceTimeDelta\n            );\n            const intervalId = _global.setInterval(\n                intervalTick,\n                config.advanceTimeDelta\n            );\n            clock.attachedInterval = intervalId;\n        }\n\n        for (i = 0, l = clock.methods.length; i < l; i++) {\n            const nameOfMethodToReplace = clock.methods[i];\n            if (nameOfMethodToReplace === \"hrtime\") {\n                if (\n                    _global.process &&\n                    typeof _global.process.hrtime === \"function\"\n                ) {\n                    hijackMethod(_global.process, nameOfMethodToReplace, clock);\n                }\n            } else if (nameOfMethodToReplace === \"nextTick\") {\n                if (\n                    _global.process &&\n                    typeof _global.process.nextTick === \"function\"\n                ) {\n                    hijackMethod(_global.process, nameOfMethodToReplace, clock);\n                }\n            } else {\n                hijackMethod(_global, nameOfMethodToReplace, clock);\n            }\n        }\n\n        return clock;\n    }\n\n    /* eslint-enable complexity */\n\n    return {\n        timers: timers,\n        createClock: createClock,\n        install: install,\n        withGlobal: withGlobal,\n    };\n}\n\n/**\n * @typedef {object} FakeTimers\n * @property {Timers} timers\n * @property {createClock} createClock\n * @property {Function} install\n * @property {withGlobal} withGlobal\n */\n\n/* eslint-enable complexity */\n\n/** @type {FakeTimers} */\nconst defaultImplementation = withGlobal(globalObject);\n\nexports.timers = defaultImplementation.timers;\nexports.createClock = defaultImplementation.createClock;\nexports.install = defaultImplementation.install;\nexports.withGlobal = withGlobal;\n"],"mappings":"AAAA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,kBAAD,CAAP,CAA4BC,MAAjD;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,UAAT,CAAoBC,OAApB,EAA6B;EACzB,MAAMC,SAAS,GAAGD,OAAO,CAACE,SAAR,IAAqBF,OAAO,CAACE,SAAR,CAAkBD,SAAzD;EACA,MAAME,aAAa,GAAGF,SAAS,IAAIA,SAAS,CAACG,OAAV,CAAkB,OAAlB,IAA6B,CAAC,CAAjE;EACA,MAAMC,UAAU,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,EAAZ,IAAkB,CAArC,CAHyB,CAGe;;EACxC,MAAMC,cAAc,GAAG,IAAvB,CAJyB,CAII;;EAC7B,MAAMC,IAAI,GAAG,YAAY;IACrB,OAAOC,SAAP;EACH,CAFD;;EAGA,MAAMC,UAAU,GAAG,YAAY;IAC3B,OAAO,EAAP;EACH,CAFD;;EAGA,MAAMC,aAAa,GAAGZ,OAAO,CAACa,UAAR,CAAmBJ,IAAnB,EAAyB,CAAzB,CAAtB;;EACA,MAAMK,qBAAqB,GAAG,OAAOF,aAAP,KAAyB,QAAvD;EACA,MAAMG,aAAa,GACff,OAAO,CAACgB,OAAR,IAAmB,OAAOhB,OAAO,CAACgB,OAAR,CAAgBC,MAAvB,KAAkC,UADzD;EAEA,MAAMC,mBAAmB,GACrBH,aAAa,IAAI,OAAOf,OAAO,CAACgB,OAAR,CAAgBC,MAAhB,CAAuBE,MAA9B,KAAyC,UAD9D;EAEA,MAAMC,eAAe,GACjBpB,OAAO,CAACgB,OAAR,IAAmB,OAAOhB,OAAO,CAACgB,OAAR,CAAgBK,QAAvB,KAAoC,UAD3D;;EAEA,MAAMC,aAAa,GAAGtB,OAAO,CAACgB,OAAR,IAAmBnB,OAAO,CAAC,MAAD,CAAP,CAAgB0B,SAAzD;;EACA,MAAMC,kBAAkB,GACpBxB,OAAO,CAACyB,WAAR,IAAuB,OAAOzB,OAAO,CAACyB,WAAR,CAAoBC,GAA3B,KAAmC,UAD9D;EAEA,MAAMC,uBAAuB,GACzB3B,OAAO,CAAC4B,WAAR,IACA,CAAC,OAAO5B,OAAO,CAAC4B,WAAhB,EAA6BC,KAA7B,CAAmC,qBAAnC,CAFJ;;EAGA,MAAMC,qBAAqB,GAAG9B,OAAO,CAAC+B,cAAR,CAAuB,gBAAvB,CAA9B;;EACA,MAAMC,4BAA4B,GAC9BhC,OAAO,CAACiC,qBAAR,IACA,OAAOjC,OAAO,CAACiC,qBAAf,KAAyC,UAF7C;EAGA,MAAMC,2BAA2B,GAC7BlC,OAAO,CAACmC,oBAAR,IACA,OAAOnC,OAAO,CAACmC,oBAAf,KAAwC,UAF5C;EAGA,MAAMC,0BAA0B,GAC5BpC,OAAO,CAACqC,mBAAR,IACA,OAAOrC,OAAO,CAACqC,mBAAf,KAAuC,UAF3C;EAGA,MAAMC,yBAAyB,GAC3BtC,OAAO,CAACuC,kBAAR,IACA,OAAOvC,OAAO,CAACuC,kBAAf,KAAsC,UAF1C;EAGA,MAAMC,mBAAmB,GACrBxC,OAAO,CAACyC,YAAR,IAAwB,OAAOzC,OAAO,CAACyC,YAAf,KAAgC,UAD5D,CAtCyB,CAyCzB;EACA;;EACA;;EACA,IAAItC,aAAJ,EAAmB;IACfH,OAAO,CAACa,UAAR,GAAqBb,OAAO,CAACa,UAA7B;IACAb,OAAO,CAAC0C,YAAR,GAAuB1C,OAAO,CAAC0C,YAA/B;IACA1C,OAAO,CAAC2C,WAAR,GAAsB3C,OAAO,CAAC2C,WAA9B;IACA3C,OAAO,CAAC4C,aAAR,GAAwB5C,OAAO,CAAC4C,aAAhC;IACA5C,OAAO,CAAC6C,IAAR,GAAe7C,OAAO,CAAC6C,IAAvB;EACH,CAlDwB,CAoDzB;EACA;;;EACA,IAAIL,mBAAJ,EAAyB;IACrBxC,OAAO,CAACyC,YAAR,GAAuBzC,OAAO,CAACyC,YAA/B;IACAzC,OAAO,CAAC8C,cAAR,GAAyB9C,OAAO,CAAC8C,cAAjC;EACH;EACD;;;EAEA9C,OAAO,CAAC0C,YAAR,CAAqB9B,aAArB;;EAEA,MAAMmC,UAAU,GAAG/C,OAAO,CAAC6C,IAA3B;EACA,IAAIG,aAAa,GAAGxC,cAApB;EAEA;AACJ;AACA;AACA;;EACI,SAASyC,cAAT,CAAwBC,GAAxB,EAA6B;IACzB,IAAIC,MAAM,CAACC,QAAX,EAAqB;MACjB,OAAOD,MAAM,CAACC,QAAP,CAAgBF,GAAhB,CAAP;IACH;;IAED,OAAOE,QAAQ,CAACF,GAAD,CAAf;EACH;;EAED,IAAIG,mBAAmB,GAAG,KAA1B;EAEA;AACJ;AACA;AACA;;EACI,SAASC,wBAAT,CAAkCC,KAAlC,EAAyCC,CAAzC,EAA4C;IACxC,IAAID,KAAK,CAACE,SAAN,IAAmBD,CAAC,KAAKD,KAAK,CAACE,SAAN,GAAkB,CAA/C,EAAkD;MAC9CJ,mBAAmB,GAAG,IAAtB;IACH;EACJ;EAED;AACJ;AACA;;;EACI,SAASK,wBAAT,GAAoC;IAChCL,mBAAmB,GAAG,KAAtB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI,SAASM,SAAT,CAAmBC,GAAnB,EAAwB;IACpB,IAAI,CAACA,GAAL,EAAU;MACN,OAAO,CAAP;IACH;;IAED,MAAMC,OAAO,GAAGD,GAAG,CAACE,KAAJ,CAAU,GAAV,CAAhB;IACA,MAAMC,CAAC,GAAGF,OAAO,CAACG,MAAlB;IACA,IAAIR,CAAC,GAAGO,CAAR;IACA,IAAIE,EAAE,GAAG,CAAT;IACA,IAAIC,MAAJ;;IAEA,IAAIH,CAAC,GAAG,CAAJ,IAAS,CAAC,sBAAsBI,IAAtB,CAA2BP,GAA3B,CAAd,EAA+C;MAC3C,MAAM,IAAIQ,KAAJ,CACF,gFADE,CAAN;IAGH;;IAED,OAAOZ,CAAC,EAAR,EAAY;MACRU,MAAM,GAAGG,QAAQ,CAACR,OAAO,CAACL,CAAD,CAAR,EAAa,EAAb,CAAjB;;MAEA,IAAIU,MAAM,IAAI,EAAd,EAAkB;QACd,MAAM,IAAIE,KAAJ,CAAW,gBAAeR,GAAI,EAA9B,CAAN;MACH;;MAEDK,EAAE,IAAIC,MAAM,GAAG5D,IAAI,CAACC,GAAL,CAAS,EAAT,EAAawD,CAAC,GAAGP,CAAJ,GAAQ,CAArB,CAAf;IACH;;IAED,OAAOS,EAAE,GAAG,IAAZ;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI,SAASK,aAAT,CAAuBC,OAAvB,EAAgC;IAC5B,MAAMC,MAAM,GAAG,GAAf;IACA,MAAMC,SAAS,GAAIF,OAAO,GAAG,GAAX,GAAkBC,MAApC;IACA,MAAME,iBAAiB,GACnBD,SAAS,GAAG,CAAZ,GAAgBA,SAAS,GAAGD,MAA5B,GAAqCC,SADzC;IAGA,OAAOnE,IAAI,CAACqE,KAAL,CAAWD,iBAAX,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACI,SAASE,QAAT,CAAkBC,KAAlB,EAAyB;IACrB,IAAI,CAACA,KAAL,EAAY;MACR,OAAO,CAAP;IACH;;IACD,IAAI,OAAOA,KAAK,CAACC,OAAb,KAAyB,UAA7B,EAAyC;MACrC,OAAOD,KAAK,CAACC,OAAN,EAAP;IACH;;IACD,IAAI,OAAOD,KAAP,KAAiB,QAArB,EAA+B;MAC3B,OAAOA,KAAP;IACH;;IACD,MAAM,IAAIE,SAAJ,CAAc,6CAAd,CAAN;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACI,SAASC,OAAT,CAAiBC,IAAjB,EAAuBC,EAAvB,EAA2BC,KAA3B,EAAkC;IAC9B,OAAOA,KAAK,IAAIA,KAAK,CAACC,MAAN,IAAgBH,IAAzB,IAAiCE,KAAK,CAACC,MAAN,IAAgBF,EAAxD;EACH;EAED;AACJ;AACA;AACA;;;EACI,SAASG,oBAAT,CAA8B9B,KAA9B,EAAqC+B,GAArC,EAA0C;IACtC,MAAMC,iBAAiB,GAAG,IAAInB,KAAJ,CACrB,0BAAyBb,KAAK,CAACE,SAAU,qCADpB,CAA1B;;IAIA,IAAI,CAAC6B,GAAG,CAACE,KAAT,EAAgB;MACZ,OAAOD,iBAAP;IACH,CAPqC,CAStC;;;IACA,MAAME,qBAAqB,GAAG,gCAA9B;IACA,IAAIC,kBAAkB,GAAG,IAAIC,MAAJ,CACrBC,MAAM,CAACC,MAAM,CAACC,IAAP,CAAYvC,KAAZ,EAAmBwC,IAAnB,CAAwB,GAAxB,CAAD,CADe,CAAzB;;IAIA,IAAIjF,qBAAJ,EAA2B;MACvB;MACA4E,kBAAkB,GAAG,IAAIC,MAAJ,CAChB,yBAAwBE,MAAM,CAACC,IAAP,CAAYvC,KAAZ,EAAmBwC,IAAnB,CAAwB,GAAxB,CAA6B,OADrC,CAArB;IAGH;;IAED,IAAIC,gBAAgB,GAAG,CAAC,CAAxB;IACAV,GAAG,CAACE,KAAJ,CAAUS,KAAV,CAAgBnC,KAAhB,CAAsB,IAAtB,EAA4BoC,IAA5B,CAAiC,UAAUC,IAAV,EAAgB3C,CAAhB,EAAmB;MAChD;MACA;MACA,MAAM4C,qBAAqB,GAAGD,IAAI,CAACtE,KAAL,CAAW4D,qBAAX,CAA9B;MACA;;MACA,IAAIW,qBAAJ,EAA2B;QACvBJ,gBAAgB,GAAGxC,CAAnB;QACA,OAAO,IAAP;MACH,CAR+C,CAUhD;MACA;;;MACA,MAAM6C,kBAAkB,GAAGF,IAAI,CAACtE,KAAL,CAAW6D,kBAAX,CAA3B;;MACA,IAAIW,kBAAJ,EAAwB;QACpBL,gBAAgB,GAAGxC,CAAnB;QACA,OAAO,KAAP;MACH,CAhB+C,CAkBhD;MACA;MACA;;;MACA,OAAOwC,gBAAgB,IAAI,CAA3B;IACH,CAtBD;IAwBA,MAAMC,KAAK,GAAI,GAAEV,iBAAkB,KAAID,GAAG,CAACgB,IAAJ,IAAY,WAAY,MAC3DhB,GAAG,CAACiB,IAAJ,CAASC,IAAT,IAAiB,WACpB,KAAIlB,GAAG,CAACE,KAAJ,CAAUS,KAAV,CACAnC,KADA,CACM,IADN,EAEA2C,KAFA,CAEMT,gBAAgB,GAAG,CAFzB,EAGAD,IAHA,CAGK,IAHL,CAGW,EALhB;;IAOA,IAAI;MACAF,MAAM,CAACa,cAAP,CAAsBnB,iBAAtB,EAAyC,OAAzC,EAAkD;QAC9CoB,KAAK,EAAEV;MADuC,CAAlD;IAGH,CAJD,CAIE,OAAOW,CAAP,EAAU,CACR;IACH;;IAED,OAAOrB,iBAAP;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACI,SAASsB,oBAAT,CAA8BC,MAA9B,EAAsCC,MAAtC,EAA8C;IAC1C,IAAIC,IAAJ;;IACA,KAAKA,IAAL,IAAaD,MAAb,EAAqB;MACjB,IAAIA,MAAM,CAAChF,cAAP,CAAsBiF,IAAtB,CAAJ,EAAiC;QAC7BF,MAAM,CAACE,IAAD,CAAN,GAAeD,MAAM,CAACC,IAAD,CAArB;MACH;IACJ,CANyC,CAQ1C;;;IACA,IAAID,MAAM,CAACrF,GAAX,EAAgB;MACZoF,MAAM,CAACpF,GAAP,GAAa,SAASA,GAAT,GAAe;QACxB,OAAOoF,MAAM,CAACvD,KAAP,CAAa7B,GAApB;MACH,CAFD;IAGH,CAJD,MAIO;MACH,OAAOoF,MAAM,CAACpF,GAAd;IACH,CAfyC,CAiB1C;;;IACA,IAAIqF,MAAM,CAACE,QAAX,EAAqB;MACjBH,MAAM,CAACG,QAAP,GAAkB,SAASA,QAAT,GAAoB;QAClC,OAAOF,MAAM,CAACE,QAAP,EAAP;MACH,CAFD;IAGH,CAJD,MAIO;MACH,OAAOH,MAAM,CAACG,QAAd;IACH,CAxByC,CA0B1C;;;IACAH,MAAM,CAACI,QAAP,GAAkB,SAASA,QAAT,GAAoB;MAClC,OAAOH,MAAM,CAACG,QAAP,EAAP;IACH,CAFD;;IAIAJ,MAAM,CAACK,SAAP,GAAmBJ,MAAM,CAACI,SAA1B;IACAL,MAAM,CAACM,KAAP,GAAeL,MAAM,CAACK,KAAtB;IACAN,MAAM,CAACO,GAAP,GAAaN,MAAM,CAACM,GAApB;IACAP,MAAM,CAACK,SAAP,CAAiBG,WAAjB,GAA+BP,MAAM,CAACI,SAAP,CAAiBG,WAAhD;IAEA,OAAOR,MAAP;EACH,CAnSwB,CAqSzB;;;EACA,SAASS,UAAT,GAAsB;IAClB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,SAASC,SAAT,CAAmBC,IAAnB,EAAyBC,KAAzB,EAAgCC,IAAhC,EAAsCC,IAAtC,EAA4CC,MAA5C,EAAoDC,MAApD,EAA4D7D,EAA5D,EAAgE;MAC5D;MACA;MACA,IAAI,EAAE,gBAAgBuD,SAAlB,CAAJ,EAAkC;QAC9B,OAAO,IAAIzE,UAAJ,CAAeyE,SAAS,CAACjE,KAAV,CAAgB7B,GAA/B,EAAoCwF,QAApC,EAAP;MACH,CAL2D,CAO5D;MACA;MACA;;;MACA,QAAQa,SAAS,CAAC/D,MAAlB;QACI,KAAK,CAAL;UACI,OAAO,IAAIjB,UAAJ,CAAeyE,SAAS,CAACjE,KAAV,CAAgB7B,GAA/B,CAAP;;QACJ,KAAK,CAAL;UACI,OAAO,IAAIqB,UAAJ,CAAe0E,IAAf,CAAP;;QACJ,KAAK,CAAL;UACI,OAAO,IAAI1E,UAAJ,CAAe0E,IAAf,EAAqBC,KAArB,CAAP;;QACJ,KAAK,CAAL;UACI,OAAO,IAAI3E,UAAJ,CAAe0E,IAAf,EAAqBC,KAArB,EAA4BC,IAA5B,CAAP;;QACJ,KAAK,CAAL;UACI,OAAO,IAAI5E,UAAJ,CAAe0E,IAAf,EAAqBC,KAArB,EAA4BC,IAA5B,EAAkCC,IAAlC,CAAP;;QACJ,KAAK,CAAL;UACI,OAAO,IAAI7E,UAAJ,CAAe0E,IAAf,EAAqBC,KAArB,EAA4BC,IAA5B,EAAkCC,IAAlC,EAAwCC,MAAxC,CAAP;;QACJ,KAAK,CAAL;UACI,OAAO,IAAI9E,UAAJ,CACH0E,IADG,EAEHC,KAFG,EAGHC,IAHG,EAIHC,IAJG,EAKHC,MALG,EAMHC,MANG,CAAP;;QAQJ;UACI,OAAO,IAAI/E,UAAJ,CACH0E,IADG,EAEHC,KAFG,EAGHC,IAHG,EAIHC,IAJG,EAKHC,MALG,EAMHC,MANG,EAOH7D,EAPG,CAAP;MAvBR;IAiCH;;IAED,OAAO4C,oBAAoB,CAACW,SAAD,EAAYzE,UAAZ,CAA3B;EACH,CAhWwB,CAkWzB;;;EACA,SAASiF,UAAT,CAAoBzE,KAApB,EAA2B+B,GAA3B,EAAgC;IAC5B;IACA,IAAI,CAAC/B,KAAK,CAAC0E,IAAX,EAAiB;MACb1E,KAAK,CAAC0E,IAAN,GAAa,EAAb;IACH;;IACD1E,KAAK,CAAC0E,IAAN,CAAWC,IAAX,CAAgB5C,GAAhB;EACH,CAzWwB,CA2WzB;;;EACA,SAAS6C,OAAT,CAAiB5E,KAAjB,EAAwB;IACpB;IACA,IAAI,CAACA,KAAK,CAAC0E,IAAX,EAAiB;MACb;IACH;;IACD,KAAK,IAAIzE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAAC0E,IAAN,CAAWjE,MAA/B,EAAuCR,CAAC,EAAxC,EAA4C;MACxC,MAAM8B,GAAG,GAAG/B,KAAK,CAAC0E,IAAN,CAAWzE,CAAX,CAAZ;MACA8B,GAAG,CAACiB,IAAJ,CAAS6B,KAAT,CAAe,IAAf,EAAqB9C,GAAG,CAAC+C,IAAzB;MAEA/E,wBAAwB,CAACC,KAAD,EAAQC,CAAR,CAAxB;;MACA,IAAID,KAAK,CAACE,SAAN,IAAmBD,CAAC,GAAGD,KAAK,CAACE,SAAjC,EAA4C;QACxC,MAAM4B,oBAAoB,CAAC9B,KAAD,EAAQ+B,GAAR,CAA1B;MACH;IACJ;;IACD5B,wBAAwB;IACxBH,KAAK,CAAC0E,IAAN,GAAa,EAAb;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACI,SAASK,QAAT,CAAkB/E,KAAlB,EAAyB4B,KAAzB,EAAgC;IAC5B,IAAIA,KAAK,CAACoB,IAAN,KAAe7F,SAAnB,EAA8B;MAC1B,MAAM,IAAI0D,KAAJ,CAAU,0CAAV,CAAN;IACH;;IAED,IAAItD,qBAAJ,EAA2B;MACvB;MACA,IAAI,OAAOqE,KAAK,CAACoB,IAAb,KAAsB,UAA1B,EAAsC;QAClC,MAAM,IAAIxB,SAAJ,CACD,iEACGI,KAAK,CAACoB,IACT,YAAW,OAAOpB,KAAK,CAACoB,IAAK,EAH5B,CAAN;MAKH;IACJ;;IAED,IAAIlD,mBAAJ,EAAyB;MACrB8B,KAAK,CAACK,KAAN,GAAc,IAAIpB,KAAJ,EAAd;IACH;;IAEDe,KAAK,CAACmB,IAAN,GAAanB,KAAK,CAACoD,SAAN,GAAkB,WAAlB,GAAgC,SAA7C;;IAEA,IAAIpD,KAAK,CAACpD,cAAN,CAAqB,OAArB,CAAJ,EAAmC;MAC/B,IAAI,OAAOoD,KAAK,CAACqD,KAAb,KAAuB,QAA3B,EAAqC;QACjCrD,KAAK,CAACqD,KAAN,GAAcnE,QAAQ,CAACc,KAAK,CAACqD,KAAP,EAAc,EAAd,CAAtB;MACH;;MAED,IAAI,CAACvF,cAAc,CAACkC,KAAK,CAACqD,KAAP,CAAnB,EAAkC;QAC9BrD,KAAK,CAACqD,KAAN,GAAc,CAAd;MACH;;MACDrD,KAAK,CAACqD,KAAN,GAAcrD,KAAK,CAACqD,KAAN,GAAcnI,UAAd,GAA2B,CAA3B,GAA+B8E,KAAK,CAACqD,KAAnD;MACArD,KAAK,CAACqD,KAAN,GAAclI,IAAI,CAACmI,GAAL,CAAS,CAAT,EAAYtD,KAAK,CAACqD,KAAlB,CAAd;IACH;;IAED,IAAIrD,KAAK,CAACpD,cAAN,CAAqB,UAArB,CAAJ,EAAsC;MAClCoD,KAAK,CAACmB,IAAN,GAAa,UAAb;MACAnB,KAAK,CAACuD,QAAN,GAAiBvD,KAAK,CAACuD,QAAN,GAAiBrI,UAAjB,GAA8B,CAA9B,GAAkC8E,KAAK,CAACuD,QAAzD;IACH;;IAED,IAAIvD,KAAK,CAACpD,cAAN,CAAqB,WAArB,CAAJ,EAAuC;MACnCoD,KAAK,CAACmB,IAAN,GAAa,gBAAb;MACAnB,KAAK,CAACwD,SAAN,GAAkB,IAAlB;IACH;;IAED,IAAIxD,KAAK,CAACpD,cAAN,CAAqB,cAArB,CAAJ,EAA0C;MACtCoD,KAAK,CAACmB,IAAN,GAAa,cAAb;MACAnB,KAAK,CAACyD,YAAN,GAAqB,IAArB;IACH;;IAED,IAAI,CAACrF,KAAK,CAACsF,MAAX,EAAmB;MACftF,KAAK,CAACsF,MAAN,GAAe,EAAf;IACH;;IAED1D,KAAK,CAAC2D,EAAN,GAAW9F,aAAa,EAAxB;IACAmC,KAAK,CAAC4D,SAAN,GAAkBxF,KAAK,CAAC7B,GAAxB;IACAyD,KAAK,CAACC,MAAN,GACI7B,KAAK,CAAC7B,GAAN,IAAa2C,QAAQ,CAACc,KAAK,CAACqD,KAAP,CAAR,KAA0BjF,KAAK,CAACyF,UAAN,GAAmB,CAAnB,GAAuB,CAAjD,CAAb,CADJ;IAGAzF,KAAK,CAACsF,MAAN,CAAa1D,KAAK,CAAC2D,EAAnB,IAAyB3D,KAAzB;;IAEA,IAAIrE,qBAAJ,EAA2B;MACvB,MAAMmI,GAAG,GAAG;QACRC,GAAG,EAAE,YAAY;UACb,OAAOD,GAAP;QACH,CAHO;QAIRE,KAAK,EAAE,YAAY;UACf,OAAOF,GAAP;QACH,CANO;QAORG,OAAO,EAAE,YAAY;UACjB1G,YAAY,CAACyC,KAAK,CAAC2D,EAAP,CAAZ;UACA,MAAMT,IAAI,GAAG,CAAClD,KAAK,CAACoB,IAAP,EAAapB,KAAK,CAACqD,KAAnB,EAA0Ba,MAA1B,CAAiClE,KAAK,CAACkD,IAAvC,CAAb;UACA,OAAOxH,UAAU,CAACuH,KAAX,CAAiB,IAAjB,EAAuBC,IAAvB,CAAP;QACH,CAXO;QAYR,CAACiB,MAAM,CAACC,WAAR,GAAsB,YAAY;UAC9B,OAAOpE,KAAK,CAAC2D,EAAb;QACH;MAdO,CAAZ;MAgBA,OAAOG,GAAP;IACH;;IAED,OAAO9D,KAAK,CAAC2D,EAAb;EACH;EAED;;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACI,SAASU,aAAT,CAAuBC,CAAvB,EAA0BC,CAA1B,EAA6B;IACzB;IACA,IAAID,CAAC,CAACrE,MAAF,GAAWsE,CAAC,CAACtE,MAAjB,EAAyB;MACrB,OAAO,CAAC,CAAR;IACH;;IACD,IAAIqE,CAAC,CAACrE,MAAF,GAAWsE,CAAC,CAACtE,MAAjB,EAAyB;MACrB,OAAO,CAAP;IACH,CAPwB,CASzB;;;IACA,IAAIqE,CAAC,CAAClB,SAAF,IAAe,CAACmB,CAAC,CAACnB,SAAtB,EAAiC;MAC7B,OAAO,CAAC,CAAR;IACH;;IACD,IAAI,CAACkB,CAAC,CAAClB,SAAH,IAAgBmB,CAAC,CAACnB,SAAtB,EAAiC;MAC7B,OAAO,CAAP;IACH,CAfwB,CAiBzB;;;IACA,IAAIkB,CAAC,CAACV,SAAF,GAAcW,CAAC,CAACX,SAApB,EAA+B;MAC3B,OAAO,CAAC,CAAR;IACH;;IACD,IAAIU,CAAC,CAACV,SAAF,GAAcW,CAAC,CAACX,SAApB,EAA+B;MAC3B,OAAO,CAAP;IACH,CAvBwB,CAyBzB;;;IACA,IAAIU,CAAC,CAACX,EAAF,GAAOY,CAAC,CAACZ,EAAb,EAAiB;MACb,OAAO,CAAC,CAAR;IACH;;IACD,IAAIW,CAAC,CAACX,EAAF,GAAOY,CAAC,CAACZ,EAAb,EAAiB;MACb,OAAO,CAAP;IACH,CA/BwB,CAiCzB;;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACI,SAASa,iBAAT,CAA2BpG,KAA3B,EAAkC0B,IAAlC,EAAwCC,EAAxC,EAA4C;IACxC,MAAM2D,MAAM,GAAGtF,KAAK,CAACsF,MAArB;IACA,IAAI1D,KAAK,GAAG,IAAZ;IACA,IAAI2D,EAAJ,EAAQc,SAAR;;IAEA,KAAKd,EAAL,IAAWD,MAAX,EAAmB;MACf,IAAIA,MAAM,CAAC9G,cAAP,CAAsB+G,EAAtB,CAAJ,EAA+B;QAC3Bc,SAAS,GAAG5E,OAAO,CAACC,IAAD,EAAOC,EAAP,EAAW2D,MAAM,CAACC,EAAD,CAAjB,CAAnB;;QAEA,IACIc,SAAS,KACR,CAACzE,KAAD,IAAUqE,aAAa,CAACrE,KAAD,EAAQ0D,MAAM,CAACC,EAAD,CAAd,CAAb,KAAqC,CADvC,CADb,EAGE;UACE3D,KAAK,GAAG0D,MAAM,CAACC,EAAD,CAAd;QACH;MACJ;IACJ;;IAED,OAAO3D,KAAP;EACH;EAED;AACJ;AACA;AACA;;;EACI,SAAS0E,UAAT,CAAoBtG,KAApB,EAA2B;IACvB,MAAMsF,MAAM,GAAGtF,KAAK,CAACsF,MAArB;IACA,IAAI1D,KAAK,GAAG,IAAZ;IACA,IAAI2D,EAAJ;;IAEA,KAAKA,EAAL,IAAWD,MAAX,EAAmB;MACf,IAAIA,MAAM,CAAC9G,cAAP,CAAsB+G,EAAtB,CAAJ,EAA+B;QAC3B,IAAI,CAAC3D,KAAD,IAAUqE,aAAa,CAACrE,KAAD,EAAQ0D,MAAM,CAACC,EAAD,CAAd,CAAb,KAAqC,CAAnD,EAAsD;UAClD3D,KAAK,GAAG0D,MAAM,CAACC,EAAD,CAAd;QACH;MACJ;IACJ;;IAED,OAAO3D,KAAP;EACH;EAED;AACJ;AACA;AACA;;;EACI,SAAS2E,SAAT,CAAmBvG,KAAnB,EAA0B;IACtB,MAAMsF,MAAM,GAAGtF,KAAK,CAACsF,MAArB;IACA,IAAI1D,KAAK,GAAG,IAAZ;IACA,IAAI2D,EAAJ;;IAEA,KAAKA,EAAL,IAAWD,MAAX,EAAmB;MACf,IAAIA,MAAM,CAAC9G,cAAP,CAAsB+G,EAAtB,CAAJ,EAA+B;QAC3B,IAAI,CAAC3D,KAAD,IAAUqE,aAAa,CAACrE,KAAD,EAAQ0D,MAAM,CAACC,EAAD,CAAd,CAAb,KAAqC,CAAC,CAApD,EAAuD;UACnD3D,KAAK,GAAG0D,MAAM,CAACC,EAAD,CAAd;QACH;MACJ;IACJ;;IAED,OAAO3D,KAAP;EACH;EAED;AACJ;AACA;AACA;;;EACI,SAAS4E,SAAT,CAAmBxG,KAAnB,EAA0B4B,KAA1B,EAAiC;IAC7B,IAAI,OAAOA,KAAK,CAACuD,QAAb,KAA0B,QAA9B,EAAwC;MACpCnF,KAAK,CAACsF,MAAN,CAAa1D,KAAK,CAAC2D,EAAnB,EAAuB1D,MAAvB,IAAiCD,KAAK,CAACuD,QAAvC;IACH,CAFD,MAEO;MACH,OAAOnF,KAAK,CAACsF,MAAN,CAAa1D,KAAK,CAAC2D,EAAnB,CAAP;IACH;;IAED,IAAI,OAAO3D,KAAK,CAACoB,IAAb,KAAsB,UAA1B,EAAsC;MAClCpB,KAAK,CAACoB,IAAN,CAAW6B,KAAX,CAAiB,IAAjB,EAAuBjD,KAAK,CAACkD,IAA7B;IACH,CAFD,MAEO;MACH;MACA,MAAM2B,KAAK,GAAGC,IAAd;;MACA,CAAC,YAAY;QACTD,KAAK,CAAC7E,KAAK,CAACoB,IAAP,CAAL;MACH,CAFD;IAGH;EACJ;EAED;AACJ;AACA;AACA;;;EACI,SAAS2D,eAAT,CAAyBC,KAAzB,EAAgC;IAC5B,IAAIA,KAAK,KAAK,cAAV,IAA4BA,KAAK,KAAK,gBAA1C,EAA4D;MACxD,OAAQ,SAAQA,KAAM,EAAtB;IACH;;IACD,OAAQ,QAAOA,KAAM,EAArB;EACH;EAED;AACJ;AACA;AACA;;;EACI,SAASC,kBAAT,CAA4BD,KAA5B,EAAmC;IAC/B,IAAIA,KAAK,KAAK,cAAV,IAA4BA,KAAK,KAAK,gBAA1C,EAA4D;MACxD,OAAQ,UAASA,KAAM,EAAvB;IACH;;IACD,OAAQ,MAAKA,KAAM,EAAnB;EACH;EAED;AACJ;AACA;;;EACI,SAASE,cAAT,GAA0B;IACtB,IAAIC,KAAK,GAAG,CAAZ;IACA,OAAO,UAAUC,GAAV,EAAe;MAClB;MACA,CAACD,KAAK,EAAN,IAAYE,OAAO,CAACC,IAAR,CAAaF,GAAb,CAAZ;IACH,CAHD;EAIH;;EACD,MAAMG,QAAQ,GAAGL,cAAc,EAA/B;EAEA;AACJ;AACA;AACA;AACA;;EACI,SAASM,UAAT,CAAoBpH,KAApB,EAA2BqH,OAA3B,EAAoCT,KAApC,EAA2C;IACvC,IAAI,CAACS,OAAL,EAAc;MACV;MACA;MACA;IACH;;IAED,IAAI,CAACrH,KAAK,CAACsF,MAAX,EAAmB;MACftF,KAAK,CAACsF,MAAN,GAAe,EAAf;IACH,CATsC,CAWvC;IACA;;;IACA,MAAMC,EAAE,GAAG3F,MAAM,CAACyH,OAAD,CAAjB;;IAEA,IAAIzH,MAAM,CAAC0H,KAAP,CAAa/B,EAAb,KAAoBA,EAAE,GAAGtI,cAA7B,EAA6C;MACzC,MAAMsK,WAAW,GAAGZ,eAAe,CAACC,KAAD,CAAnC;;MAEA,IAAI5G,KAAK,CAACwH,uBAAN,KAAkC,IAAtC,EAA4C;QACxC,MAAMC,aAAa,GAAGzH,KAAK,CAAE,IAAGuH,WAAY,EAAjB,CAA3B;QACA,OAAO,OAAOE,aAAP,KAAyB,UAAzB,GACDA,aAAa,CAACJ,OAAD,CADZ,GAEDlK,SAFN;MAGH;;MACDgK,QAAQ,CACH,eAAcI,WAAY,8EAA3B,GACI,2EAFA,CAAR;IAIH;;IAED,IAAIvH,KAAK,CAACsF,MAAN,CAAa9G,cAAb,CAA4B+G,EAA5B,CAAJ,EAAqC;MACjC;MACA,MAAM3D,KAAK,GAAG5B,KAAK,CAACsF,MAAN,CAAaC,EAAb,CAAd;;MACA,IACI3D,KAAK,CAACmB,IAAN,KAAe6D,KAAf,IACChF,KAAK,CAACmB,IAAN,KAAe,SAAf,IAA4B6D,KAAK,KAAK,UADvC,IAEChF,KAAK,CAACmB,IAAN,KAAe,UAAf,IAA6B6D,KAAK,KAAK,SAH5C,EAIE;QACE,OAAO5G,KAAK,CAACsF,MAAN,CAAaC,EAAb,CAAP;MACH,CAND,MAMO;QACH,MAAMmC,KAAK,GAAGf,eAAe,CAACC,KAAD,CAA7B;QACA,MAAMe,QAAQ,GAAGd,kBAAkB,CAACjF,KAAK,CAACmB,IAAP,CAAnC;QACA,MAAM,IAAIlC,KAAJ,CACD,0CAAyC8G,QAAS,uBAAsBD,KAAM,IAD7E,CAAN;MAGH;IACJ;EACJ;EAED;AACJ;AACA;AACA;AACA;;;EACI,SAASE,SAAT,CAAmB5H,KAAnB,EAA0B6H,MAA1B,EAAkC;IAC9B,IAAIC,MAAJ,EAAY7H,CAAZ,EAAeO,CAAf;IACA,MAAMuH,eAAe,GAAG,SAAxB;IACA,MAAMC,iBAAiB,GAAG,WAA1B;;IAEA,KAAK/H,CAAC,GAAG,CAAJ,EAAOO,CAAC,GAAGR,KAAK,CAACiI,OAAN,CAAcxH,MAA9B,EAAsCR,CAAC,GAAGO,CAA1C,EAA6CP,CAAC,EAA9C,EAAkD;MAC9C6H,MAAM,GAAG9H,KAAK,CAACiI,OAAN,CAAchI,CAAd,CAAT;;MACA,IAAI6H,MAAM,KAAK,QAAX,IAAuBrL,OAAO,CAACgB,OAAnC,EAA4C;QACxChB,OAAO,CAACgB,OAAR,CAAgBC,MAAhB,GAAyBsC,KAAK,CAAC+H,eAAD,CAA9B;MACH,CAFD,MAEO,IAAID,MAAM,KAAK,UAAX,IAAyBrL,OAAO,CAACgB,OAArC,EAA8C;QACjDhB,OAAO,CAACgB,OAAR,CAAgBK,QAAhB,GAA2BkC,KAAK,CAACgI,iBAAD,CAAhC;MACH,CAFM,MAEA,IAAIF,MAAM,KAAK,aAAf,EAA8B;QACjC,MAAMI,sBAAsB,GAAG5F,MAAM,CAAC6F,wBAAP,CAC3BnI,KAD2B,EAE1B,IAAG8H,MAAO,EAFgB,CAA/B;;QAIA,IACII,sBAAsB,IACtBA,sBAAsB,CAACE,GADvB,IAEA,CAACF,sBAAsB,CAACG,GAH5B,EAIE;UACE/F,MAAM,CAACa,cAAP,CACI1G,OADJ,EAEIqL,MAFJ,EAGII,sBAHJ;QAKH,CAVD,MAUO,IAAIA,sBAAsB,CAACI,YAA3B,EAAyC;UAC5C7L,OAAO,CAACqL,MAAD,CAAP,GAAkB9H,KAAK,CAAE,IAAG8H,MAAO,EAAZ,CAAvB;QACH;MACJ,CAlBM,MAkBA;QACH,IAAIrL,OAAO,CAACqL,MAAD,CAAP,IAAmBrL,OAAO,CAACqL,MAAD,CAAP,CAAgBS,cAAvC,EAAuD;UACnD9L,OAAO,CAACqL,MAAD,CAAP,GAAkB9H,KAAK,CAAE,IAAG8H,MAAO,EAAZ,CAAvB;QACH,CAFD,MAEO;UACH,IAAI;YACA,OAAOrL,OAAO,CAACqL,MAAD,CAAd;UACH,CAFD,CAEE,OAAOU,MAAP,EAAe;YACb;UACH;QACJ;MACJ;IACJ;;IAED,IAAIX,MAAM,CAACY,iBAAP,KAA6B,IAAjC,EAAuC;MACnChM,OAAO,CAAC4C,aAAR,CAAsBW,KAAK,CAAC0I,gBAA5B;IACH,CA5C6B,CA8C9B;;;IACA1I,KAAK,CAACiI,OAAN,GAAgB,EAAhB,CA/C8B,CAiD9B;;IACA,IAAI,CAACjI,KAAK,CAACsF,MAAX,EAAmB;MACf,OAAO,EAAP;IACH;;IACD,OAAOhD,MAAM,CAACC,IAAP,CAAYvC,KAAK,CAACsF,MAAlB,EAA0BqD,GAA1B,CAA8B,SAASC,MAAT,CAAgBC,GAAhB,EAAqB;MACtD,OAAO7I,KAAK,CAACsF,MAAN,CAAauD,GAAb,CAAP;IACH,CAFM,CAAP;EAGH;EAED;AACJ;AACA;AACA;AACA;;;EACI,SAASC,YAAT,CAAsBvF,MAAtB,EAA8BuE,MAA9B,EAAsC9H,KAAtC,EAA6C;IACzCA,KAAK,CAAC8H,MAAD,CAAL,CAAcS,cAAd,GAA+BjG,MAAM,CAACsB,SAAP,CAAiBpF,cAAjB,CAAgCuK,IAAhC,CAC3BxF,MAD2B,EAE3BuE,MAF2B,CAA/B;IAIA9H,KAAK,CAAE,IAAG8H,MAAO,EAAZ,CAAL,GAAsBvE,MAAM,CAACuE,MAAD,CAA5B;;IAEA,IAAIA,MAAM,KAAK,MAAf,EAAuB;MACnB,MAAM1D,IAAI,GAAGd,oBAAoB,CAACtD,KAAK,CAAC8H,MAAD,CAAN,EAAgBvE,MAAM,CAACuE,MAAD,CAAtB,CAAjC;MACAvE,MAAM,CAACuE,MAAD,CAAN,GAAiB1D,IAAjB;IACH,CAHD,MAGO,IAAI0D,MAAM,KAAK,aAAf,EAA8B;MACjC,MAAMI,sBAAsB,GAAG5F,MAAM,CAAC6F,wBAAP,CAC3B5E,MAD2B,EAE3BuE,MAF2B,CAA/B,CADiC,CAKjC;;MACA,IACII,sBAAsB,IACtBA,sBAAsB,CAACE,GADvB,IAEA,CAACF,sBAAsB,CAACG,GAH5B,EAIE;QACE/F,MAAM,CAACa,cAAP,CACInD,KADJ,EAEK,IAAG8H,MAAO,EAFf,EAGII,sBAHJ;QAMA,MAAMc,cAAc,GAAG1G,MAAM,CAAC6F,wBAAP,CACnBnI,KADmB,EAEnB8H,MAFmB,CAAvB;QAIAxF,MAAM,CAACa,cAAP,CAAsBI,MAAtB,EAA8BuE,MAA9B,EAAsCkB,cAAtC;MACH,CAhBD,MAgBO;QACHzF,MAAM,CAACuE,MAAD,CAAN,GAAiB9H,KAAK,CAAC8H,MAAD,CAAtB;MACH;IACJ,CAzBM,MAyBA;MACHvE,MAAM,CAACuE,MAAD,CAAN,GAAiB,YAAY;QACzB,OAAO9H,KAAK,CAAC8H,MAAD,CAAL,CAAcjD,KAAd,CAAoB7E,KAApB,EAA2BwE,SAA3B,CAAP;MACH,CAFD;;MAIAlC,MAAM,CAAC2G,gBAAP,CACI1F,MAAM,CAACuE,MAAD,CADV,EAEIxF,MAAM,CAAC4G,yBAAP,CAAiClJ,KAAK,CAAC8H,MAAD,CAAtC,CAFJ;IAIH;;IAEDvE,MAAM,CAACuE,MAAD,CAAN,CAAe9H,KAAf,GAAuBA,KAAvB;EACH;EAED;AACJ;AACA;AACA;;;EACI,SAASmJ,cAAT,CAAwBnJ,KAAxB,EAA+BoJ,gBAA/B,EAAiD;IAC7CpJ,KAAK,CAACqJ,IAAN,CAAWD,gBAAX;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEI;;;EACA,MAAM9D,MAAM,GAAG;IACXhI,UAAU,EAAEb,OAAO,CAACa,UADT;IAEX6B,YAAY,EAAE1C,OAAO,CAAC0C,YAFX;IAGXC,WAAW,EAAE3C,OAAO,CAAC2C,WAHV;IAIXC,aAAa,EAAE5C,OAAO,CAAC4C,aAJZ;IAKXC,IAAI,EAAE7C,OAAO,CAAC6C;EALH,CAAf;;EAQA,IAAIL,mBAAJ,EAAyB;IACrBqG,MAAM,CAACpG,YAAP,GAAsBzC,OAAO,CAACyC,YAA9B;IACAoG,MAAM,CAAC/F,cAAP,GAAwB9C,OAAO,CAAC8C,cAAhC;EACH;;EAED,IAAI/B,aAAJ,EAAmB;IACf8H,MAAM,CAAC5H,MAAP,GAAgBjB,OAAO,CAACgB,OAAR,CAAgBC,MAAhC;EACH;;EAED,IAAIG,eAAJ,EAAqB;IACjByH,MAAM,CAACxH,QAAP,GAAkBrB,OAAO,CAACgB,OAAR,CAAgBK,QAAlC;EACH;;EAED,IAAIG,kBAAJ,EAAwB;IACpBqH,MAAM,CAACpH,WAAP,GAAqBzB,OAAO,CAACyB,WAA7B;EACH;;EAED,IAAIO,4BAAJ,EAAkC;IAC9B6G,MAAM,CAAC5G,qBAAP,GAA+BjC,OAAO,CAACiC,qBAAvC;EACH;;EAED,IAAIH,qBAAJ,EAA2B;IACvB+G,MAAM,CAACgE,cAAP,GAAwB,IAAxB;EACH;;EAED,IAAI3K,2BAAJ,EAAiC;IAC7B2G,MAAM,CAAC1G,oBAAP,GAA8BnC,OAAO,CAACmC,oBAAtC;EACH;;EAED,IAAIC,0BAAJ,EAAgC;IAC5ByG,MAAM,CAACxG,mBAAP,GAA6BrC,OAAO,CAACqC,mBAArC;EACH;;EAED,IAAIC,yBAAJ,EAA+B;IAC3BuG,MAAM,CAACtG,kBAAP,GAA4BvC,OAAO,CAACuC,kBAApC;EACH;;EAED,MAAMuK,kBAAkB,GAAG9M,OAAO,CAACyC,YAAR,IAAwBzC,OAAO,CAACa,UAA3D;EAEA;AACJ;AACA;AACA;AACA;;EACI,SAASkM,WAAT,CAAqBC,KAArB,EAA4BvJ,SAA5B,EAAuC;IACnC;IACAuJ,KAAK,GAAG1M,IAAI,CAACqE,KAAL,CAAWC,QAAQ,CAACoI,KAAD,CAAnB,CAAR,CAFmC,CAGnC;;IACAvJ,SAAS,GAAGA,SAAS,IAAI,IAAzB;IACA,IAAIwJ,KAAK,GAAG,CAAZ;IACA,MAAMC,kBAAkB,GAAG,CAAC,CAAD,EAAI,CAAJ,CAA3B,CANmC,CAMA;;IAEnC,IAAInK,UAAU,KAAKrC,SAAnB,EAA8B;MAC1B,MAAM,IAAI0D,KAAJ,CACF,kDACI,4EAFF,CAAN;IAIH;;IAED,MAAMb,KAAK,GAAG;MACV7B,GAAG,EAAEsL,KADK;MAEVnK,IAAI,EAAE0E,UAAU,EAFN;MAGV9D,SAAS,EAAEA;IAHD,CAAd;IAMAF,KAAK,CAACV,IAAN,CAAWU,KAAX,GAAmBA,KAAnB,CArBmC,CAuBnC;;IACA,SAAS4J,kBAAT,GAA8B;MAC1B,OAAO,KAAM,CAAC5J,KAAK,CAAC7B,GAAN,GAAYsL,KAAb,IAAsB,EAAnC;IACH,CA1BkC,CA4BnC;;;IACA,SAAS/L,MAAT,CAAgBmM,IAAhB,EAAsB;MAClB,MAAMC,gBAAgB,GAAG9J,KAAK,CAAC7B,GAAN,GAAYwL,kBAAkB,CAAC,CAAD,CAA9B,GAAoCF,KAA7D;MACA,MAAMM,cAAc,GAAGhN,IAAI,CAACqE,KAAL,CAAW0I,gBAAgB,GAAG,IAA9B,CAAvB;MACA,MAAME,gBAAgB,GAClB,CAACF,gBAAgB,GAAGC,cAAc,GAAG,GAArC,IAA4C,GAA5C,GACAL,KADA,GAEAC,kBAAkB,CAAC,CAAD,CAHtB;;MAKA,IAAIM,KAAK,CAACC,OAAN,CAAcL,IAAd,CAAJ,EAAyB;QACrB,IAAIA,IAAI,CAAC,CAAD,CAAJ,GAAU,GAAd,EAAmB;UACf,MAAM,IAAIrI,SAAJ,CACF,8CADE,CAAN;QAGH;;QAED,MAAM2I,OAAO,GAAGN,IAAI,CAAC,CAAD,CAApB;QACA,IAAIO,QAAQ,GAAGJ,gBAAgB,GAAGH,IAAI,CAAC,CAAD,CAAtC;QACA,IAAIQ,OAAO,GAAGN,cAAc,GAAGI,OAA/B;;QAEA,IAAIC,QAAQ,GAAG,CAAf,EAAkB;UACdA,QAAQ,IAAI,GAAZ;UACAC,OAAO,IAAI,CAAX;QACH;;QAED,OAAO,CAACA,OAAD,EAAUD,QAAV,CAAP;MACH;;MACD,OAAO,CAACL,cAAD,EAAiBC,gBAAjB,CAAP;IACH;;IAED,IAAIrM,mBAAJ,EAAyB;MACrBD,MAAM,CAACE,MAAP,GAAgB,YAAY;QACxB,MAAM0M,KAAK,GAAG5M,MAAM,EAApB;QACA,OAAO6M,MAAM,CAACD,KAAK,CAAC,CAAD,CAAN,CAAN,GAAmBC,MAAM,CAAC,GAAD,CAAzB,GAAiCA,MAAM,CAACD,KAAK,CAAC,CAAD,CAAN,CAA9C,CAFwB,CAEkC;MAC7D,CAHD;IAIH;;IAEDtK,KAAK,CAAClB,mBAAN,GAA4B,SAASA,mBAAT,CACxBkE,IADwB,EAExBwH,OAFwB,EAG1B;MACE,IAAIC,oBAAoB,GAAG,CAA3B;;MAEA,IAAIzK,KAAK,CAAC0K,WAAN,KAAsB,CAA1B,EAA6B;QACzBD,oBAAoB,GAAG,EAAvB,CADyB,CACE;MAC9B;;MAED,MAAME,MAAM,GAAG5F,QAAQ,CAAC/E,KAAD,EAAQ;QAC3BgD,IAAI,EAAEA,IADqB;QAE3B8B,IAAI,EAAEmF,KAAK,CAACrG,SAAN,CAAgBV,KAAhB,CAAsB6F,IAAtB,CAA2BvE,SAA3B,EAAsC,CAAtC,CAFqB;QAG3BS,KAAK,EACD,OAAOuF,OAAP,KAAmB,WAAnB,GACMC,oBADN,GAEM1N,IAAI,CAAC6N,GAAL,CAASJ,OAAT,EAAkBC,oBAAlB,CANiB;QAO3BpF,YAAY,EAAE;MAPa,CAAR,CAAvB;MAUA,OAAOzF,MAAM,CAAC+K,MAAD,CAAb;IACH,CArBD;;IAuBA3K,KAAK,CAAChB,kBAAN,GAA2B,SAASA,kBAAT,CAA4BqI,OAA5B,EAAqC;MAC5D,OAAOD,UAAU,CAACpH,KAAD,EAAQqH,OAAR,EAAiB,cAAjB,CAAjB;IACH,CAFD;;IAIArH,KAAK,CAAC1C,UAAN,GAAmB,SAASA,UAAT,CAAoB0F,IAApB,EAA0BwH,OAA1B,EAAmC;MAClD,OAAOzF,QAAQ,CAAC/E,KAAD,EAAQ;QACnBgD,IAAI,EAAEA,IADa;QAEnB8B,IAAI,EAAEmF,KAAK,CAACrG,SAAN,CAAgBV,KAAhB,CAAsB6F,IAAtB,CAA2BvE,SAA3B,EAAsC,CAAtC,CAFa;QAGnBS,KAAK,EAAEuF;MAHY,CAAR,CAAf;IAKH,CAND;;IAOA,IAAI,OAAO/N,OAAO,CAACoO,OAAf,KAA2B,WAA3B,IAA0C9M,aAA9C,EAA6D;MACzDiC,KAAK,CAAC1C,UAAN,CACIS,aAAa,CAAC+M,MADlB,IAEI,SAASC,qBAAT,CAA+BP,OAA/B,EAAwCQ,GAAxC,EAA6C;QAC7C,OAAO,IAAIvO,OAAO,CAACoO,OAAZ,CAAoB,SAASI,kBAAT,CACvBC,OADuB,EAEzB;UACEnG,QAAQ,CAAC/E,KAAD,EAAQ;YACZgD,IAAI,EAAEkI,OADM;YAEZpG,IAAI,EAAE,CAACkG,GAAD,CAFM;YAGZ/F,KAAK,EAAEuF;UAHK,CAAR,CAAR;QAKH,CARM,CAAP;MASH,CAZD;IAaH;;IAEDxK,KAAK,CAACb,YAAN,GAAqB,SAASA,YAAT,CAAsBkI,OAAtB,EAA+B;MAChD,OAAOD,UAAU,CAACpH,KAAD,EAAQqH,OAAR,EAAiB,SAAjB,CAAjB;IACH,CAFD;;IAIArH,KAAK,CAAClC,QAAN,GAAiB,SAASA,QAAT,CAAkBkF,IAAlB,EAAwB;MACrC,OAAOyB,UAAU,CAACzE,KAAD,EAAQ;QACrBgD,IAAI,EAAEA,IADe;QAErB8B,IAAI,EAAEmF,KAAK,CAACrG,SAAN,CAAgBV,KAAhB,CAAsB6F,IAAtB,CAA2BvE,SAA3B,EAAsC,CAAtC,CAFe;QAGrBvC,KAAK,EAAEnC,mBAAmB,GAAG,IAAIe,KAAJ,EAAH,GAAiB;MAHtB,CAAR,CAAjB;IAKH,CAND;;IAQAb,KAAK,CAACsJ,cAAN,GAAuB,SAASA,cAAT,CAAwBtG,IAAxB,EAA8B;MACjD,OAAOhD,KAAK,CAAClC,QAAN,CAAekF,IAAf,CAAP,CADiD,CACpB;IAChC,CAFD;;IAIAhD,KAAK,CAACZ,WAAN,GAAoB,SAASA,WAAT,CAAqB4D,IAArB,EAA2BwH,OAA3B,EAAoC;MACpD;MACAA,OAAO,GAAG1J,QAAQ,CAAC0J,OAAD,EAAU,EAAV,CAAlB;MACA,OAAOzF,QAAQ,CAAC/E,KAAD,EAAQ;QACnBgD,IAAI,EAAEA,IADa;QAEnB8B,IAAI,EAAEmF,KAAK,CAACrG,SAAN,CAAgBV,KAAhB,CAAsB6F,IAAtB,CAA2BvE,SAA3B,EAAsC,CAAtC,CAFa;QAGnBS,KAAK,EAAEuF,OAHY;QAInBrF,QAAQ,EAAEqF;MAJS,CAAR,CAAf;IAMH,CATD;;IAWAxK,KAAK,CAACX,aAAN,GAAsB,SAASA,aAAT,CAAuBgI,OAAvB,EAAgC;MAClD,OAAOD,UAAU,CAACpH,KAAD,EAAQqH,OAAR,EAAiB,UAAjB,CAAjB;IACH,CAFD;;IAIA,IAAIpI,mBAAJ,EAAyB;MACrBe,KAAK,CAACd,YAAN,GAAqB,SAASA,YAAT,CAAsB8D,IAAtB,EAA4B;QAC7C,OAAO+B,QAAQ,CAAC/E,KAAD,EAAQ;UACnBgD,IAAI,EAAEA,IADa;UAEnB8B,IAAI,EAAEmF,KAAK,CAACrG,SAAN,CAAgBV,KAAhB,CAAsB6F,IAAtB,CAA2BvE,SAA3B,EAAsC,CAAtC,CAFa;UAGnBQ,SAAS,EAAE;QAHQ,CAAR,CAAf;MAKH,CAND;;MAQA,IAAI,OAAOvI,OAAO,CAACoO,OAAf,KAA2B,WAA3B,IAA0C9M,aAA9C,EAA6D;QACzDiC,KAAK,CAACd,YAAN,CACInB,aAAa,CAAC+M,MADlB,IAEI,SAASK,uBAAT,CAAiCH,GAAjC,EAAsC;UACtC,OAAO,IAAIvO,OAAO,CAACoO,OAAZ,CAAoB,SAASO,oBAAT,CACvBF,OADuB,EAEzB;YACEnG,QAAQ,CAAC/E,KAAD,EAAQ;cACZgD,IAAI,EAAEkI,OADM;cAEZpG,IAAI,EAAE,CAACkG,GAAD,CAFM;cAGZhG,SAAS,EAAE;YAHC,CAAR,CAAR;UAKH,CARM,CAAP;QASH,CAZD;MAaH;;MAEDhF,KAAK,CAACT,cAAN,GAAuB,SAASA,cAAT,CAAwB8H,OAAxB,EAAiC;QACpD,OAAOD,UAAU,CAACpH,KAAD,EAAQqH,OAAR,EAAiB,WAAjB,CAAjB;MACH,CAFD;IAGH;;IAEDrH,KAAK,CAAC0K,WAAN,GAAoB,SAASA,WAAT,GAAuB;MACvC,OACIpI,MAAM,CAACC,IAAP,CAAYvC,KAAK,CAACsF,MAAN,IAAgB,EAA5B,EAAgC7E,MAAhC,GACA,CAACT,KAAK,CAAC0E,IAAN,IAAc,EAAf,EAAmBjE,MAFvB;IAIH,CALD;;IAOAT,KAAK,CAACtB,qBAAN,GAA8B,SAASA,qBAAT,CAA+BsE,IAA/B,EAAqC;MAC/D,MAAM2H,MAAM,GAAG5F,QAAQ,CAAC/E,KAAD,EAAQ;QAC3BgD,IAAI,EAAEA,IADqB;QAE3BiC,KAAK,EAAE2E,kBAAkB,EAFE;QAG3B9E,IAAI,EAAE,CAAC9E,KAAK,CAAC7B,GAAN,GAAYyL,kBAAkB,EAA/B,CAHqB;QAI3BxE,SAAS,EAAE;MAJgB,CAAR,CAAvB;MAOA,OAAOxF,MAAM,CAAC+K,MAAD,CAAb;IACH,CATD;;IAWA3K,KAAK,CAACpB,oBAAN,GAA6B,SAASA,oBAAT,CAA8ByI,OAA9B,EAAuC;MAChE,OAAOD,UAAU,CAACpH,KAAD,EAAQqH,OAAR,EAAiB,gBAAjB,CAAjB;IACH,CAFD;;IAIArH,KAAK,CAACqL,aAAN,GAAsB,SAASA,aAAT,GAAyB;MAC3CzG,OAAO,CAAC5E,KAAD,CAAP;IACH,CAFD;IAIA;AACR;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASsL,MAAT,CAAgBC,SAAhB,EAA2BC,OAA3B,EAAoCN,OAApC,EAA6CO,MAA7C,EAAqD;MACjD,MAAMzK,OAAO,GACT,OAAOuK,SAAP,KAAqB,QAArB,GACMA,SADN,GAEMnL,SAAS,CAACmL,SAAD,CAHnB;MAIA,MAAM7K,EAAE,GAAG3D,IAAI,CAACqE,KAAL,CAAWJ,OAAX,CAAX;MACA,MAAME,SAAS,GAAGH,aAAa,CAACC,OAAD,CAA/B;MACA,IAAI0K,UAAU,GAAGhC,KAAK,GAAGxI,SAAzB;MACA,IAAIyK,MAAM,GAAG3L,KAAK,CAAC7B,GAAN,GAAYuC,EAAzB;;MAEA,IAAIM,OAAO,GAAG,CAAd,EAAiB;QACb,MAAM,IAAIQ,SAAJ,CAAc,kCAAd,CAAN;MACH,CAZgD,CAcjD;;;MACA,IAAIkK,UAAU,IAAI,GAAlB,EAAuB;QACnBC,MAAM,IAAI,CAAV;QACAD,UAAU,IAAI,GAAd;MACH;;MAEDhC,KAAK,GAAGgC,UAAR;MACA,IAAIE,QAAQ,GAAG5L,KAAK,CAAC7B,GAArB;MACA,IAAI0N,QAAQ,GAAG7L,KAAK,CAAC7B,GAArB,CAtBiD,CAuBjD;;MACA;;MACA,IAAIyD,KAAJ,EACIkK,cADJ,EAEIC,MAFJ,EAGIC,eAHJ,EAIIC,iBAJJ,EAKIC,aALJ;MAMA;;MAEAlM,KAAK,CAACyF,UAAN,GAAmB,IAAnB,CAjCiD,CAmCjD;;MACAsG,MAAM,GAAG/L,KAAK,CAAC7B,GAAf;MACAyG,OAAO,CAAC5E,KAAD,CAAP;;MACA,IAAI+L,MAAM,KAAK/L,KAAK,CAAC7B,GAArB,EAA0B;QACtB;QACAyN,QAAQ,IAAI5L,KAAK,CAAC7B,GAAN,GAAY4N,MAAxB;QACAJ,MAAM,IAAI3L,KAAK,CAAC7B,GAAN,GAAY4N,MAAtB;MACH,CA1CgD,CA4CjD;;;MACA,SAASI,WAAT,GAAuB;QACnB;QACAvK,KAAK,GAAGwE,iBAAiB,CAACpG,KAAD,EAAQ4L,QAAR,EAAkBD,MAAlB,CAAzB,CAFmB,CAGnB;;QACA,OAAO/J,KAAK,IAAIgK,QAAQ,IAAID,MAA5B,EAAoC;UAChC,IAAI3L,KAAK,CAACsF,MAAN,CAAa1D,KAAK,CAAC2D,EAAnB,CAAJ,EAA4B;YACxBqG,QAAQ,GAAGhK,KAAK,CAACC,MAAjB;YACA7B,KAAK,CAAC7B,GAAN,GAAYyD,KAAK,CAACC,MAAlB;YACAkK,MAAM,GAAG/L,KAAK,CAAC7B,GAAf;;YACA,IAAI;cACAyG,OAAO,CAAC5E,KAAD,CAAP;cACAwG,SAAS,CAACxG,KAAD,EAAQ4B,KAAR,CAAT;YACH,CAHD,CAGE,OAAOyB,CAAP,EAAU;cACRyI,cAAc,GAAGA,cAAc,IAAIzI,CAAnC;YACH;;YAED,IAAImI,OAAJ,EAAa;cACT;cACA;cACA;cACAjC,kBAAkB,CAACyC,eAAD,CAAlB;cACA;YACH;;YAEDC,iBAAiB;UACpB;;UAEDC,aAAa;QAChB,CA5BkB,CA8BnB;;;QACAH,MAAM,GAAG/L,KAAK,CAAC7B,GAAf;QACAyG,OAAO,CAAC5E,KAAD,CAAP;;QACA,IAAI+L,MAAM,KAAK/L,KAAK,CAAC7B,GAArB,EAA0B;UACtB;UACAyN,QAAQ,IAAI5L,KAAK,CAAC7B,GAAN,GAAY4N,MAAxB;UACAJ,MAAM,IAAI3L,KAAK,CAAC7B,GAAN,GAAY4N,MAAtB;QACH;;QACD/L,KAAK,CAACyF,UAAN,GAAmB,KAAnB,CAtCmB,CAwCnB;;QACA7D,KAAK,GAAGwE,iBAAiB,CAACpG,KAAD,EAAQ4L,QAAR,EAAkBD,MAAlB,CAAzB;;QACA,IAAI/J,KAAJ,EAAW;UACP,IAAI;YACA5B,KAAK,CAACqJ,IAAN,CAAWsC,MAAM,GAAG3L,KAAK,CAAC7B,GAA1B,EADA,CACgC;UACnC,CAFD,CAEE,OAAOkF,CAAP,EAAU;YACRyI,cAAc,GAAGA,cAAc,IAAIzI,CAAnC;UACH;QACJ,CAND,MAMO;UACH;UACArD,KAAK,CAAC7B,GAAN,GAAYwN,MAAZ,CAFG,CAIH;;UACAjC,KAAK,GAAGgC,UAAR;QACH;;QACD,IAAII,cAAJ,EAAoB;UAChB,MAAMA,cAAN;QACH;;QAED,IAAIN,OAAJ,EAAa;UACTN,OAAO,CAAClL,KAAK,CAAC7B,GAAP,CAAP;QACH,CAFD,MAEO;UACH,OAAO6B,KAAK,CAAC7B,GAAb;QACH;MACJ;;MAED6N,eAAe,GACXR,OAAO,IACP,YAAY;QACR,IAAI;UACAS,iBAAiB;UACjBC,aAAa;UACbC,WAAW;QACd,CAJD,CAIE,OAAO9I,CAAP,EAAU;UACRoI,MAAM,CAACpI,CAAD,CAAN;QACH;MACJ,CAVL;;MAYA4I,iBAAiB,GAAG,YAAY;QAC5B;QACA,IAAIF,MAAM,KAAK/L,KAAK,CAAC7B,GAArB,EAA0B;UACtByN,QAAQ,IAAI5L,KAAK,CAAC7B,GAAN,GAAY4N,MAAxB;UACAJ,MAAM,IAAI3L,KAAK,CAAC7B,GAAN,GAAY4N,MAAtB;UACAF,QAAQ,IAAI7L,KAAK,CAAC7B,GAAN,GAAY4N,MAAxB;QACH;MACJ,CAPD;;MASAG,aAAa,GAAG,YAAY;QACxBtK,KAAK,GAAGwE,iBAAiB,CAACpG,KAAD,EAAQ6L,QAAR,EAAkBF,MAAlB,CAAzB;QACAE,QAAQ,GAAGD,QAAX;MACH,CAHD;;MAKA,OAAOO,WAAW,EAAlB;IACH;IAED;AACR;AACA;AACA;;;IACQnM,KAAK,CAACqJ,IAAN,GAAa,SAASA,IAAT,CAAckC,SAAd,EAAyB;MAClC,OAAOD,MAAM,CAACC,SAAD,EAAY,KAAZ,CAAb;IACH,CAFD;;IAIA,IAAI,OAAO9O,OAAO,CAACoO,OAAf,KAA2B,WAA/B,EAA4C;MACxC;AACZ;AACA;AACA;MACY7K,KAAK,CAACoM,SAAN,GAAkB,SAASA,SAAT,CAAmBb,SAAnB,EAA8B;QAC5C,OAAO,IAAI9O,OAAO,CAACoO,OAAZ,CAAoB,UAAUK,OAAV,EAAmBO,MAAnB,EAA2B;UAClDlC,kBAAkB,CAAC,YAAY;YAC3B,IAAI;cACA+B,MAAM,CAACC,SAAD,EAAY,IAAZ,EAAkBL,OAAlB,EAA2BO,MAA3B,CAAN;YACH,CAFD,CAEE,OAAOpI,CAAP,EAAU;cACRoI,MAAM,CAACpI,CAAD,CAAN;YACH;UACJ,CANiB,CAAlB;QAOH,CARM,CAAP;MASH,CAVD;IAWH;;IAEDrD,KAAK,CAACqM,IAAN,GAAa,SAASA,IAAT,GAAgB;MACzBzH,OAAO,CAAC5E,KAAD,CAAP;MACA,MAAM4B,KAAK,GAAG0E,UAAU,CAACtG,KAAD,CAAxB;;MACA,IAAI,CAAC4B,KAAL,EAAY;QACR,OAAO5B,KAAK,CAAC7B,GAAb;MACH;;MAED6B,KAAK,CAACyF,UAAN,GAAmB,IAAnB;;MACA,IAAI;QACAzF,KAAK,CAAC7B,GAAN,GAAYyD,KAAK,CAACC,MAAlB;QACA2E,SAAS,CAACxG,KAAD,EAAQ4B,KAAR,CAAT;QACAgD,OAAO,CAAC5E,KAAD,CAAP;QACA,OAAOA,KAAK,CAAC7B,GAAb;MACH,CALD,SAKU;QACN6B,KAAK,CAACyF,UAAN,GAAmB,KAAnB;MACH;IACJ,CAhBD;;IAkBA,IAAI,OAAOhJ,OAAO,CAACoO,OAAf,KAA2B,WAA/B,EAA4C;MACxC7K,KAAK,CAACsM,SAAN,GAAkB,SAASA,SAAT,GAAqB;QACnC,OAAO,IAAI7P,OAAO,CAACoO,OAAZ,CAAoB,UAAUK,OAAV,EAAmBO,MAAnB,EAA2B;UAClDlC,kBAAkB,CAAC,YAAY;YAC3B,IAAI;cACA,MAAM3H,KAAK,GAAG0E,UAAU,CAACtG,KAAD,CAAxB;;cACA,IAAI,CAAC4B,KAAL,EAAY;gBACRsJ,OAAO,CAAClL,KAAK,CAAC7B,GAAP,CAAP;gBACA;cACH;;cAED,IAAIoO,GAAJ;cACAvM,KAAK,CAACyF,UAAN,GAAmB,IAAnB;cACAzF,KAAK,CAAC7B,GAAN,GAAYyD,KAAK,CAACC,MAAlB;;cACA,IAAI;gBACA2E,SAAS,CAACxG,KAAD,EAAQ4B,KAAR,CAAT;cACH,CAFD,CAEE,OAAOyB,CAAP,EAAU;gBACRkJ,GAAG,GAAGlJ,CAAN;cACH;;cACDrD,KAAK,CAACyF,UAAN,GAAmB,KAAnB;cAEA8D,kBAAkB,CAAC,YAAY;gBAC3B,IAAIgD,GAAJ,EAAS;kBACLd,MAAM,CAACc,GAAD,CAAN;gBACH,CAFD,MAEO;kBACHrB,OAAO,CAAClL,KAAK,CAAC7B,GAAP,CAAP;gBACH;cACJ,CANiB,CAAlB;YAOH,CAxBD,CAwBE,OAAOkF,CAAP,EAAU;cACRoI,MAAM,CAACpI,CAAD,CAAN;YACH;UACJ,CA5BiB,CAAlB;QA6BH,CA9BM,CAAP;MA+BH,CAhCD;IAiCH;;IAEDrD,KAAK,CAACwM,MAAN,GAAe,SAASA,MAAT,GAAkB;MAC7B,IAAIC,SAAJ,EAAexM,CAAf;MACA2E,OAAO,CAAC5E,KAAD,CAAP;;MACA,KAAKC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGD,KAAK,CAACE,SAAtB,EAAiCD,CAAC,EAAlC,EAAsC;QAClC,IAAI,CAACD,KAAK,CAACsF,MAAX,EAAmB;UACfnF,wBAAwB;UACxB,OAAOH,KAAK,CAAC7B,GAAb;QACH;;QAEDsO,SAAS,GAAGnK,MAAM,CAACC,IAAP,CAAYvC,KAAK,CAACsF,MAAlB,EAA0B7E,MAAtC;;QACA,IAAIgM,SAAS,KAAK,CAAlB,EAAqB;UACjBtM,wBAAwB;UACxB,OAAOH,KAAK,CAAC7B,GAAb;QACH;;QAED6B,KAAK,CAACqM,IAAN;QACAtM,wBAAwB,CAACC,KAAD,EAAQC,CAAR,CAAxB;MACH;;MAED,MAAMyM,SAAS,GAAGpG,UAAU,CAACtG,KAAD,CAA5B;MACA,MAAM8B,oBAAoB,CAAC9B,KAAD,EAAQ0M,SAAR,CAA1B;IACH,CArBD;;IAuBA1M,KAAK,CAAC2M,UAAN,GAAmB,SAASA,UAAT,GAAsB;MACrC,OAAO3M,KAAK,CAACqJ,IAAN,CAAWO,kBAAkB,EAA7B,CAAP;IACH,CAFD;;IAIA,IAAI,OAAOnN,OAAO,CAACoO,OAAf,KAA2B,WAA/B,EAA4C;MACxC7K,KAAK,CAAC4M,WAAN,GAAoB,SAASA,WAAT,GAAuB;QACvC,OAAO,IAAInQ,OAAO,CAACoO,OAAZ,CAAoB,UAAUK,OAAV,EAAmBO,MAAnB,EAA2B;UAClD,IAAIxL,CAAC,GAAG,CAAR;UACA;AACpB;AACA;;UACoB,SAAS4M,KAAT,GAAiB;YACbtD,kBAAkB,CAAC,YAAY;cAC3B,IAAI;gBACA,IAAIkD,SAAJ;;gBACA,IAAIxM,CAAC,GAAGD,KAAK,CAACE,SAAd,EAAyB;kBACrB,IAAI,CAACF,KAAK,CAACsF,MAAX,EAAmB;oBACfnF,wBAAwB;oBACxB+K,OAAO,CAAClL,KAAK,CAAC7B,GAAP,CAAP;oBACA;kBACH;;kBAEDsO,SAAS,GAAGnK,MAAM,CAACC,IAAP,CAAYvC,KAAK,CAACsF,MAAlB,EACP7E,MADL;;kBAEA,IAAIgM,SAAS,KAAK,CAAlB,EAAqB;oBACjBtM,wBAAwB;oBACxB+K,OAAO,CAAClL,KAAK,CAAC7B,GAAP,CAAP;oBACA;kBACH;;kBAED6B,KAAK,CAACqM,IAAN;kBAEApM,CAAC;kBAED4M,KAAK;kBACL9M,wBAAwB,CAACC,KAAD,EAAQC,CAAR,CAAxB;kBACA;gBACH;;gBAED,MAAMyM,SAAS,GAAGpG,UAAU,CAACtG,KAAD,CAA5B;gBACAyL,MAAM,CAAC3J,oBAAoB,CAAC9B,KAAD,EAAQ0M,SAAR,CAArB,CAAN;cACH,CA5BD,CA4BE,OAAOrJ,CAAP,EAAU;gBACRoI,MAAM,CAACpI,CAAD,CAAN;cACH;YACJ,CAhCiB,CAAlB;UAiCH;;UACDwJ,KAAK;QACR,CAzCM,CAAP;MA0CH,CA3CD;IA4CH;;IAED7M,KAAK,CAAC8M,SAAN,GAAkB,SAASA,SAAT,GAAqB;MACnC,MAAMlL,KAAK,GAAG2E,SAAS,CAACvG,KAAD,CAAvB;;MACA,IAAI,CAAC4B,KAAL,EAAY;QACRgD,OAAO,CAAC5E,KAAD,CAAP;QACA,OAAOA,KAAK,CAAC7B,GAAb;MACH;;MAED,OAAO6B,KAAK,CAACqJ,IAAN,CAAWzH,KAAK,CAACC,MAAN,GAAe7B,KAAK,CAAC7B,GAAhC,CAAP;IACH,CARD;;IAUA,IAAI,OAAO1B,OAAO,CAACoO,OAAf,KAA2B,WAA/B,EAA4C;MACxC7K,KAAK,CAAC+M,cAAN,GAAuB,SAASA,cAAT,GAA0B;QAC7C,OAAO,IAAItQ,OAAO,CAACoO,OAAZ,CAAoB,UAAUK,OAAV,EAAmBO,MAAnB,EAA2B;UAClDlC,kBAAkB,CAAC,YAAY;YAC3B,IAAI;cACA,MAAM3H,KAAK,GAAG2E,SAAS,CAACvG,KAAD,CAAvB;;cACA,IAAI,CAAC4B,KAAL,EAAY;gBACRsJ,OAAO,CAAClL,KAAK,CAAC7B,GAAP,CAAP;cACH;;cAED+M,OAAO,CAAClL,KAAK,CAACoM,SAAN,CAAgBxK,KAAK,CAACC,MAAtB,CAAD,CAAP;YACH,CAPD,CAOE,OAAOwB,CAAP,EAAU;cACRoI,MAAM,CAACpI,CAAD,CAAN;YACH;UACJ,CAXiB,CAAlB;QAYH,CAbM,CAAP;MAcH,CAfD;IAgBH;;IAEDrD,KAAK,CAACgN,KAAN,GAAc,SAASA,KAAT,GAAiB;MAC3BtD,KAAK,GAAG,CAAR;MACA1J,KAAK,CAACsF,MAAN,GAAe,EAAf;MACAtF,KAAK,CAAC0E,IAAN,GAAa,EAAb;MACA1E,KAAK,CAAC7B,GAAN,GAAYsL,KAAZ;IACH,CALD;;IAOAzJ,KAAK,CAACiN,aAAN,GAAsB,SAASA,aAAT,CAAuBC,UAAvB,EAAmC;MACrD;MACA,MAAMC,MAAM,GAAG9L,QAAQ,CAAC6L,UAAD,CAAvB;MACA,MAAME,UAAU,GAAGD,MAAM,GAAGnN,KAAK,CAAC7B,GAAlC;MACA,IAAIoH,EAAJ,EAAQ3D,KAAR;MAEA+H,kBAAkB,CAAC,CAAD,CAAlB,GAAwBA,kBAAkB,CAAC,CAAD,CAAlB,GAAwByD,UAAhD;MACAzD,kBAAkB,CAAC,CAAD,CAAlB,GAAwBA,kBAAkB,CAAC,CAAD,CAAlB,GAAwBD,KAAhD,CAPqD,CAQrD;;MACA1J,KAAK,CAAC7B,GAAN,GAAYgP,MAAZ;MACAzD,KAAK,GAAG,CAAR,CAVqD,CAYrD;;MACA,KAAKnE,EAAL,IAAWvF,KAAK,CAACsF,MAAjB,EAAyB;QACrB,IAAItF,KAAK,CAACsF,MAAN,CAAa9G,cAAb,CAA4B+G,EAA5B,CAAJ,EAAqC;UACjC3D,KAAK,GAAG5B,KAAK,CAACsF,MAAN,CAAaC,EAAb,CAAR;UACA3D,KAAK,CAAC4D,SAAN,IAAmB4H,UAAnB;UACAxL,KAAK,CAACC,MAAN,IAAgBuL,UAAhB;QACH;MACJ;IACJ,CApBD;;IAsBA,IAAInP,kBAAJ,EAAwB;MACpB+B,KAAK,CAAC9B,WAAN,GAAoBoE,MAAM,CAAC+K,MAAP,CAAc,IAAd,CAApB;;MAEA,IAAIjP,uBAAJ,EAA6B;QACzB,MAAMkP,KAAK,GAAG7Q,OAAO,CAAC4B,WAAR,CAAoBuF,SAAlC;QAEAtB,MAAM,CAACiL,mBAAP,CAA2BD,KAA3B,EAAkCE,OAAlC,CAA0C,UAAUvK,IAAV,EAAgB;UACtD,IAAIA,IAAI,CAACpG,OAAL,CAAa,YAAb,MAA+B,CAAnC,EAAsC;YAClC;YACAmD,KAAK,CAAC9B,WAAN,CAAkB+E,IAAlB,IAA0B7F,UAA1B;UACH,CAHD,MAGO;YACH4C,KAAK,CAAC9B,WAAN,CAAkB+E,IAAlB,IAA0B/F,IAA1B;UACH;QACJ,CAPD;MAQH;;MAED8C,KAAK,CAAC9B,WAAN,CAAkBC,GAAlB,GAAwB,SAASsP,aAAT,GAAyB;QAC7C,MAAMC,GAAG,GAAGhQ,MAAM,EAAlB;QACA,MAAMiQ,MAAM,GAAGD,GAAG,CAAC,CAAD,CAAH,GAAS,IAAT,GAAgBA,GAAG,CAAC,CAAD,CAAH,GAAS,GAAxC;QACA,OAAOC,MAAP;MACH,CAJD;IAKH;;IAED,IAAInQ,aAAJ,EAAmB;MACfwC,KAAK,CAACtC,MAAN,GAAeA,MAAf;IACH;;IAED,OAAOsC,KAAP;EACH;EAED;;EAEA;AACJ;AACA;AACA;;;EACI,SAAS4N,OAAT,CAAiB/F,MAAjB,EAAyB;IACrB,IACIrD,SAAS,CAAC/D,MAAV,GAAmB,CAAnB,IACAoH,MAAM,YAAYvI,IADlB,IAEA2K,KAAK,CAACC,OAAN,CAAcrC,MAAd,CAFA,IAGA,OAAOA,MAAP,KAAkB,QAJtB,EAKE;MACE,MAAM,IAAIrG,SAAJ,CACD,kCAAiCa,MAAM,CACpCwF,MADoC,CAEtC,uCAHA,CAAN;IAKH,CAZoB,CAcrB;;;IACAA,MAAM,GAAG,OAAOA,MAAP,KAAkB,WAAlB,GAAgCA,MAAhC,GAAyC,EAAlD;IACAA,MAAM,CAACY,iBAAP,GAA2BZ,MAAM,CAACY,iBAAP,IAA4B,KAAvD;IACAZ,MAAM,CAACuB,gBAAP,GAA0BvB,MAAM,CAACuB,gBAAP,IAA2B,EAArD;IACAvB,MAAM,CAACL,uBAAP,GACIK,MAAM,CAACL,uBAAP,IAAkC,KADtC;;IAGA,IAAIK,MAAM,CAACtE,MAAX,EAAmB;MACf,MAAM,IAAI/B,SAAJ,CACF,yEADE,CAAN;IAGH;;IAED,IAAIvB,CAAJ,EAAOO,CAAP;IACA,MAAMR,KAAK,GAAGwJ,WAAW,CAAC3B,MAAM,CAAC1J,GAAR,EAAa0J,MAAM,CAAC3H,SAApB,CAAzB;IACAF,KAAK,CAACwH,uBAAN,GAAgCK,MAAM,CAACL,uBAAvC;;IAEAxH,KAAK,CAAC4H,SAAN,GAAkB,YAAY;MAC1B,OAAOA,SAAS,CAAC5H,KAAD,EAAQ6H,MAAR,CAAhB;IACH,CAFD;;IAIA7H,KAAK,CAACiI,OAAN,GAAgBJ,MAAM,CAACgG,MAAP,IAAiB,EAAjC;;IAEA,IAAI7N,KAAK,CAACiI,OAAN,CAAcxH,MAAd,KAAyB,CAA7B,EAAgC;MAC5B;MACAT,KAAK,CAACiI,OAAN,GAAgB3F,MAAM,CAACC,IAAP,CAAY+C,MAAZ,EAAoBwI,MAApB,CAA2B,UAAUjF,GAAV,EAAe;QACtD,OAAOA,GAAG,KAAK,UAAR,IAAsBA,GAAG,KAAK,gBAArC;MACH,CAFe,CAAhB;IAGH;;IAED,IAAIhB,MAAM,CAACY,iBAAP,KAA6B,IAAjC,EAAuC;MACnC,MAAMsF,YAAY,GAAG5E,cAAc,CAAC6E,IAAf,CACjB,IADiB,EAEjBhO,KAFiB,EAGjB6H,MAAM,CAACuB,gBAHU,CAArB;;MAKA,MAAM6E,UAAU,GAAGxR,OAAO,CAAC2C,WAAR,CACf2O,YADe,EAEflG,MAAM,CAACuB,gBAFQ,CAAnB;;MAIApJ,KAAK,CAAC0I,gBAAN,GAAyBuF,UAAzB;IACH;;IAED,KAAKhO,CAAC,GAAG,CAAJ,EAAOO,CAAC,GAAGR,KAAK,CAACiI,OAAN,CAAcxH,MAA9B,EAAsCR,CAAC,GAAGO,CAA1C,EAA6CP,CAAC,EAA9C,EAAkD;MAC9C,MAAMiO,qBAAqB,GAAGlO,KAAK,CAACiI,OAAN,CAAchI,CAAd,CAA9B;;MACA,IAAIiO,qBAAqB,KAAK,QAA9B,EAAwC;QACpC,IACIzR,OAAO,CAACgB,OAAR,IACA,OAAOhB,OAAO,CAACgB,OAAR,CAAgBC,MAAvB,KAAkC,UAFtC,EAGE;UACEoL,YAAY,CAACrM,OAAO,CAACgB,OAAT,EAAkByQ,qBAAlB,EAAyClO,KAAzC,CAAZ;QACH;MACJ,CAPD,MAOO,IAAIkO,qBAAqB,KAAK,UAA9B,EAA0C;QAC7C,IACIzR,OAAO,CAACgB,OAAR,IACA,OAAOhB,OAAO,CAACgB,OAAR,CAAgBK,QAAvB,KAAoC,UAFxC,EAGE;UACEgL,YAAY,CAACrM,OAAO,CAACgB,OAAT,EAAkByQ,qBAAlB,EAAyClO,KAAzC,CAAZ;QACH;MACJ,CAPM,MAOA;QACH8I,YAAY,CAACrM,OAAD,EAAUyR,qBAAV,EAAiClO,KAAjC,CAAZ;MACH;IACJ;;IAED,OAAOA,KAAP;EACH;EAED;;;EAEA,OAAO;IACHsF,MAAM,EAAEA,MADL;IAEHkE,WAAW,EAAEA,WAFV;IAGHoE,OAAO,EAAEA,OAHN;IAIHpR,UAAU,EAAEA;EAJT,CAAP;AAMH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AACA,MAAM2R,qBAAqB,GAAG3R,UAAU,CAACH,YAAD,CAAxC;AAEA+R,OAAO,CAAC9I,MAAR,GAAiB6I,qBAAqB,CAAC7I,MAAvC;AACA8I,OAAO,CAAC5E,WAAR,GAAsB2E,qBAAqB,CAAC3E,WAA5C;AACA4E,OAAO,CAACR,OAAR,GAAkBO,qBAAqB,CAACP,OAAxC;AACAQ,OAAO,CAAC5R,UAAR,GAAqBA,UAArB"},"metadata":{},"sourceType":"script"}