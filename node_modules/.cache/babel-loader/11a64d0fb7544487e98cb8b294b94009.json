{"ast":null,"code":"/**\n * @fileoverview Enforce style prop value is an object\n * @author David Petersen\n */\n'use strict';\n\nconst variableUtil = require('../util/variable');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst isCreateElement = require('../util/isCreateElement');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst messages = {\n  stylePropNotObject: 'Style prop value must be an object'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce style prop value is an object',\n      category: 'Possible Errors',\n      recommended: false,\n      url: docsUrl('style-prop-object')\n    },\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        allow: {\n          type: 'array',\n          items: {\n            type: 'string'\n          },\n          additionalItems: false,\n          uniqueItems: true\n        }\n      }\n    }]\n  },\n\n  create(context) {\n    const allowed = new Set(context.options.length > 0 && context.options[0].allow || []);\n    /**\n     * @param {ASTNode} expression An Identifier node\n     * @returns {boolean}\n     */\n\n    function isNonNullaryLiteral(expression) {\n      return expression.type === 'Literal' && expression.value !== null;\n    }\n    /**\n     * @param {object} node A Identifier node\n     */\n\n\n    function checkIdentifiers(node) {\n      const variable = variableUtil.variablesInScope(context).find(item => item.name === node.name);\n\n      if (!variable || !variable.defs[0] || !variable.defs[0].node.init) {\n        return;\n      }\n\n      if (isNonNullaryLiteral(variable.defs[0].node.init)) {\n        report(context, messages.stylePropNotObject, 'stylePropNotObject', {\n          node\n        });\n      }\n    }\n\n    return {\n      CallExpression(node) {\n        if (isCreateElement(node, context) && node.arguments.length > 1) {\n          if (node.arguments[0].name) {\n            // store name of component\n            const componentName = node.arguments[0].name; // allowed list contains the name\n\n            if (allowed.has(componentName)) {\n              // abort operation\n              return;\n            }\n          }\n\n          if (node.arguments[1].type === 'ObjectExpression') {\n            const style = node.arguments[1].properties.find(property => property.key && property.key.name === 'style' && !property.computed);\n\n            if (style) {\n              if (style.value.type === 'Identifier') {\n                checkIdentifiers(style.value);\n              } else if (isNonNullaryLiteral(style.value)) {\n                report(context, messages.stylePropNotObject, 'stylePropNotObject', {\n                  node: style.value\n                });\n              }\n            }\n          }\n        }\n      },\n\n      JSXAttribute(node) {\n        if (!node.value || node.name.name !== 'style') {\n          return;\n        } // store parent element\n\n\n        const parentElement = node.parent; // parent element is a JSXOpeningElement\n\n        if (parentElement && parentElement.type === 'JSXOpeningElement') {\n          // get the name of the JSX element\n          const name = parentElement.name && parentElement.name.name; // allowed list contains the name\n\n          if (allowed.has(name)) {\n            // abort operation\n            return;\n          }\n        }\n\n        if (node.value.type !== 'JSXExpressionContainer' || isNonNullaryLiteral(node.value.expression)) {\n          report(context, messages.stylePropNotObject, 'stylePropNotObject', {\n            node\n          });\n        } else if (node.value.expression.type === 'Identifier') {\n          checkIdentifiers(node.value.expression);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["variableUtil","require","docsUrl","isCreateElement","report","messages","stylePropNotObject","module","exports","meta","docs","description","category","recommended","url","schema","type","properties","allow","items","additionalItems","uniqueItems","create","context","allowed","Set","options","length","isNonNullaryLiteral","expression","value","checkIdentifiers","node","variable","variablesInScope","find","item","name","defs","init","CallExpression","arguments","componentName","has","style","property","key","computed","JSXAttribute","parentElement","parent"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/style-prop-object.js"],"sourcesContent":["/**\n * @fileoverview Enforce style prop value is an object\n * @author David Petersen\n */\n\n'use strict';\n\nconst variableUtil = require('../util/variable');\nconst docsUrl = require('../util/docsUrl');\nconst isCreateElement = require('../util/isCreateElement');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  stylePropNotObject: 'Style prop value must be an object',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce style prop value is an object',\n      category: 'Possible Errors',\n      recommended: false,\n      url: docsUrl('style-prop-object'),\n    },\n\n    messages,\n\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          allow: {\n            type: 'array',\n            items: {\n              type: 'string',\n            },\n            additionalItems: false,\n            uniqueItems: true,\n          },\n        },\n      },\n    ],\n  },\n\n  create(context) {\n    const allowed = new Set(((context.options.length > 0) && context.options[0].allow) || []);\n\n    /**\n     * @param {ASTNode} expression An Identifier node\n     * @returns {boolean}\n     */\n    function isNonNullaryLiteral(expression) {\n      return expression.type === 'Literal' && expression.value !== null;\n    }\n\n    /**\n     * @param {object} node A Identifier node\n     */\n    function checkIdentifiers(node) {\n      const variable = variableUtil.variablesInScope(context).find((item) => item.name === node.name);\n\n      if (!variable || !variable.defs[0] || !variable.defs[0].node.init) {\n        return;\n      }\n\n      if (isNonNullaryLiteral(variable.defs[0].node.init)) {\n        report(context, messages.stylePropNotObject, 'stylePropNotObject', {\n          node,\n        });\n      }\n    }\n\n    return {\n      CallExpression(node) {\n        if (\n          isCreateElement(node, context)\n          && node.arguments.length > 1\n        ) {\n          if (node.arguments[0].name) {\n            // store name of component\n            const componentName = node.arguments[0].name;\n\n            // allowed list contains the name\n            if (allowed.has(componentName)) {\n              // abort operation\n              return;\n            }\n          }\n          if (node.arguments[1].type === 'ObjectExpression') {\n            const style = node.arguments[1].properties.find((property) => property.key && property.key.name === 'style' && !property.computed);\n            if (style) {\n              if (style.value.type === 'Identifier') {\n                checkIdentifiers(style.value);\n              } else if (isNonNullaryLiteral(style.value)) {\n                report(context, messages.stylePropNotObject, 'stylePropNotObject', {\n                  node: style.value,\n                });\n              }\n            }\n          }\n        }\n      },\n\n      JSXAttribute(node) {\n        if (!node.value || node.name.name !== 'style') {\n          return;\n        }\n        // store parent element\n        const parentElement = node.parent;\n\n        // parent element is a JSXOpeningElement\n        if (parentElement && parentElement.type === 'JSXOpeningElement') {\n          // get the name of the JSX element\n          const name = parentElement.name && parentElement.name.name;\n\n          // allowed list contains the name\n          if (allowed.has(name)) {\n            // abort operation\n            return;\n          }\n        }\n\n        if (node.value.type !== 'JSXExpressionContainer' || isNonNullaryLiteral(node.value.expression)) {\n          report(context, messages.stylePropNotObject, 'stylePropNotObject', {\n            node,\n          });\n        } else if (node.value.expression.type === 'Identifier') {\n          checkIdentifiers(node.value.expression);\n        }\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}