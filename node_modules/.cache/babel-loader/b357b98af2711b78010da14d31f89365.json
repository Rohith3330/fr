{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = resolve;\n\nfunction _module() {\n  var data = require(\"module\");\n\n  _module = function _module() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _importMetaResolve = require(\"../../vendor/import-meta-resolve\");\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nvar import_;\n\ntry {\n  import_ = require(\"./import.cjs\");\n} catch (_unused) {}\n\nvar importMetaResolveP = import_ && process.execArgv.includes(\"--experimental-import-meta-resolve\") ? import_(\"data:text/javascript,export default import.meta.resolve\").then(function (m) {\n  return m.default || _importMetaResolve.resolve;\n}, function () {\n  return _importMetaResolve.resolve;\n}) : Promise.resolve(_importMetaResolve.resolve);\n\nfunction resolve(_x, _x2) {\n  return _resolve.apply(this, arguments);\n}\n\nfunction _resolve() {\n  _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(specifier, parent) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return importMetaResolveP;\n\n          case 2:\n            _context.t0 = _context.sent;\n            return _context.abrupt(\"return\", (0, _context.t0)(specifier, parent));\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _resolve.apply(this, arguments);\n}\n\n0 && 0;","map":{"version":3,"mappings":";;;;;;;;;AAAA;EAAA;;EAAAA;IAAA;EAAA;;EAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,IAAIC,OAAJ;;AACA,IAAI;EAEFA,OAAO,GAAGC,OAAO,CAAC,cAAD,CAAjBD;AAFF,EAGE,gBAAM,CAAE;;AAIV,IAAME,kBAAkD,GACtDF,OAAO,IAoBPG,OAAO,CAACC,QAARD,CAAiBE,QAAjBF,CAA0B,oCAA1BA,CApBAH,GAqBIA,OAAO,CAAC,yDAAD,CAAPA,CAAmEM,IAAnEN,CACGO,WAAD;EAAA,OACEA,CAAC,CAACC,OAAFD,IAAaE,0BADf;AAAA,CADFT,EAGE;EAAA,OAAMS,0BAAN;AAAA,CAHFT,CArBJA,GA0BIU,OAAO,CAACC,OAARD,CAAgBD,0BAAhBC,CA3BN;;SA6B8BC,Q;;;;;wEAAf,iBACbC,SADa,EAEbC,MAFa;IAAA;MAAA;QAAA;UAAA;YAAA;YAIN,OAAOX,kBAAP;;UAJM;YAAA;YAAA,kDAIqBU,SAJrB,EAIgCC,MAJhC;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA","names":["_module","import_","require","importMetaResolveP","process","execArgv","includes","then","m","default","polyfill","Promise","resolve","specifier","parent"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\files\\import-meta-resolve.ts"],"sourcesContent":["import { createRequire } from \"module\";\nimport { resolve as polyfill } from \"../../vendor/import-meta-resolve\";\n\nconst require = createRequire(import.meta.url);\n\nlet import_;\ntry {\n  // Node < 13.3 doesn't support import() syntax.\n  import_ = require(\"./import.cjs\");\n} catch {}\n\n// import.meta.resolve is only available in ESM, but this file is compiled to CJS.\n// We can extract it using dynamic import.\nconst importMetaResolveP: Promise<ImportMeta[\"resolve\"]> =\n  import_ &&\n  // Due to a Node.js/V8 bug (https://github.com/nodejs/node/issues/35889), we cannot\n  // use always dynamic import because it segfaults when running in a Node.js `vm` context,\n  // which is used by the default Jest environment and by webpack-cli.\n  //\n  // However, import.meta.resolve is experimental and only enabled when Node.js is run\n  // with the `--experimental-import-meta-resolve` flag: we can avoid calling import()\n  // when that flag is not enabled, so that the default behavior never segfaults.\n  //\n  // Hopefully, before Node.js unflags import.meta.resolve, either:\n  // - we will move to ESM, so that we have direct access to import.meta.resolve, or\n  // - the V8 bug will be fixed so that we can safely use dynamic import by default.\n  //\n  // I (@nicolo-ribaudo) am really anoyed by this bug, because there is no known\n  // work-around other than \"don't use dynamic import if you are running in a `vm` context\",\n  // but there is no reliable way to detect it (you cannot try/catch segfaults).\n  //\n  // This is the only place where we *need* to use dynamic import because we need to access\n  // an ES module. All the other places will first try using require() and *then*, if\n  // it throws because it's a module, will fallback to import().\n  process.execArgv.includes(\"--experimental-import-meta-resolve\")\n    ? import_(\"data:text/javascript,export default import.meta.resolve\").then(\n        (m: { default: ImportMeta[\"resolve\"] | undefined }) =>\n          m.default || polyfill,\n        () => polyfill,\n      )\n    : Promise.resolve(polyfill);\n\nexport default async function resolve(\n  specifier: Parameters<ImportMeta[\"resolve\"]>[0],\n  parent?: Parameters<ImportMeta[\"resolve\"]>[1],\n): ReturnType<ImportMeta[\"resolve\"]> {\n  return (await importMetaResolveP)(specifier, parent);\n}\n"]},"metadata":{},"sourceType":"script"}