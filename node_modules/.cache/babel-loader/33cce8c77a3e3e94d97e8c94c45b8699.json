{"ast":null,"code":"/**\n * @fileoverview Rule to enforce location of semicolons.\n * @author Toru Nagashima\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst SELECTOR = [\"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\", \"DoWhileStatement\", \"ExportAllDeclaration\", \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\", \"ExpressionStatement\", \"ImportDeclaration\", \"ReturnStatement\", \"ThrowStatement\", \"VariableDeclaration\", \"PropertyDefinition\"].join(\",\");\n/**\n * Get the child node list of a given node.\n * This returns `BlockStatement#body`, `StaticBlock#body`, `Program#body`,\n * `ClassBody#body`, or `SwitchCase#consequent`.\n * This is used to check whether a node is the first/last child.\n * @param {Node} node A node to get child node list.\n * @returns {Node[]|null} The child node list.\n */\n\nfunction getChildren(node) {\n  const t = node.type;\n\n  if (t === \"BlockStatement\" || t === \"StaticBlock\" || t === \"Program\" || t === \"ClassBody\") {\n    return node.body;\n  }\n\n  if (t === \"SwitchCase\") {\n    return node.consequent;\n  }\n\n  return null;\n}\n/**\n * Check whether a given node is the last statement in the parent block.\n * @param {Node} node A node to check.\n * @returns {boolean} `true` if the node is the last statement in the parent block.\n */\n\n\nfunction isLastChild(node) {\n  const t = node.parent.type;\n\n  if (t === \"IfStatement\" && node.parent.consequent === node && node.parent.alternate) {\n    // before `else` keyword.\n    return true;\n  }\n\n  if (t === \"DoWhileStatement\") {\n    // before `while` keyword.\n    return true;\n  }\n\n  const nodeList = getChildren(node.parent);\n  return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.\n}\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"Enforce location of semicolons\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/semi-style\"\n    },\n    schema: [{\n      enum: [\"last\", \"first\"]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expectedSemiColon: \"Expected this semicolon to be at {{pos}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"last\";\n    /**\n     * Check the given semicolon token.\n     * @param {Token} semiToken The semicolon token to check.\n     * @param {\"first\"|\"last\"} expected The expected location to check.\n     * @returns {void}\n     */\n\n    function check(semiToken, expected) {\n      const prevToken = sourceCode.getTokenBefore(semiToken);\n      const nextToken = sourceCode.getTokenAfter(semiToken);\n      const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);\n      const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);\n\n      if (expected === \"last\" && !prevIsSameLine || expected === \"first\" && !nextIsSameLine) {\n        context.report({\n          loc: semiToken.loc,\n          messageId: \"expectedSemiColon\",\n          data: {\n            pos: expected === \"last\" ? \"the end of the previous line\" : \"the beginning of the next line\"\n          },\n\n          fix(fixer) {\n            if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {\n              return null;\n            }\n\n            const start = prevToken ? prevToken.range[1] : semiToken.range[0];\n            const end = nextToken ? nextToken.range[0] : semiToken.range[1];\n            const text = expected === \"last\" ? \";\\n\" : \"\\n;\";\n            return fixer.replaceTextRange([start, end], text);\n          }\n\n        });\n      }\n    }\n\n    return {\n      [SELECTOR](node) {\n        if (option === \"first\" && isLastChild(node)) {\n          return;\n        }\n\n        const lastToken = sourceCode.getLastToken(node);\n\n        if (astUtils.isSemicolonToken(lastToken)) {\n          check(lastToken, option);\n        }\n      },\n\n      ForStatement(node) {\n        const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);\n        const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);\n\n        if (firstSemi) {\n          check(firstSemi, \"last\");\n        }\n\n        if (secondSemi) {\n          check(secondSemi, \"last\");\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","SELECTOR","join","getChildren","node","t","type","body","consequent","isLastChild","parent","alternate","nodeList","length","module","exports","meta","docs","description","recommended","url","schema","enum","fixable","messages","expectedSemiColon","create","context","sourceCode","getSourceCode","option","options","check","semiToken","expected","prevToken","getTokenBefore","nextToken","getTokenAfter","prevIsSameLine","isTokenOnSameLine","nextIsSameLine","report","loc","messageId","data","pos","fix","fixer","commentsExistBetween","start","range","end","text","replaceTextRange","lastToken","getLastToken","isSemicolonToken","ForStatement","firstSemi","init","secondSemi","test"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/semi-style.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce location of semicolons.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst SELECTOR = [\n    \"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\",\n    \"DoWhileStatement\", \"ExportAllDeclaration\",\n    \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\",\n    \"ExpressionStatement\", \"ImportDeclaration\", \"ReturnStatement\",\n    \"ThrowStatement\", \"VariableDeclaration\", \"PropertyDefinition\"\n].join(\",\");\n\n/**\n * Get the child node list of a given node.\n * This returns `BlockStatement#body`, `StaticBlock#body`, `Program#body`,\n * `ClassBody#body`, or `SwitchCase#consequent`.\n * This is used to check whether a node is the first/last child.\n * @param {Node} node A node to get child node list.\n * @returns {Node[]|null} The child node list.\n */\nfunction getChildren(node) {\n    const t = node.type;\n\n    if (\n        t === \"BlockStatement\" ||\n        t === \"StaticBlock\" ||\n        t === \"Program\" ||\n        t === \"ClassBody\"\n    ) {\n        return node.body;\n    }\n    if (t === \"SwitchCase\") {\n        return node.consequent;\n    }\n    return null;\n}\n\n/**\n * Check whether a given node is the last statement in the parent block.\n * @param {Node} node A node to check.\n * @returns {boolean} `true` if the node is the last statement in the parent block.\n */\nfunction isLastChild(node) {\n    const t = node.parent.type;\n\n    if (t === \"IfStatement\" && node.parent.consequent === node && node.parent.alternate) { // before `else` keyword.\n        return true;\n    }\n    if (t === \"DoWhileStatement\") { // before `while` keyword.\n        return true;\n    }\n    const nodeList = getChildren(node.parent);\n\n    return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.\n}\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce location of semicolons\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/semi-style\"\n        },\n\n        schema: [{ enum: [\"last\", \"first\"] }],\n        fixable: \"whitespace\",\n\n        messages: {\n            expectedSemiColon: \"Expected this semicolon to be at {{pos}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const option = context.options[0] || \"last\";\n\n        /**\n         * Check the given semicolon token.\n         * @param {Token} semiToken The semicolon token to check.\n         * @param {\"first\"|\"last\"} expected The expected location to check.\n         * @returns {void}\n         */\n        function check(semiToken, expected) {\n            const prevToken = sourceCode.getTokenBefore(semiToken);\n            const nextToken = sourceCode.getTokenAfter(semiToken);\n            const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);\n            const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);\n\n            if ((expected === \"last\" && !prevIsSameLine) || (expected === \"first\" && !nextIsSameLine)) {\n                context.report({\n                    loc: semiToken.loc,\n                    messageId: \"expectedSemiColon\",\n                    data: {\n                        pos: (expected === \"last\")\n                            ? \"the end of the previous line\"\n                            : \"the beginning of the next line\"\n                    },\n                    fix(fixer) {\n                        if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {\n                            return null;\n                        }\n\n                        const start = prevToken ? prevToken.range[1] : semiToken.range[0];\n                        const end = nextToken ? nextToken.range[0] : semiToken.range[1];\n                        const text = (expected === \"last\") ? \";\\n\" : \"\\n;\";\n\n                        return fixer.replaceTextRange([start, end], text);\n                    }\n                });\n            }\n        }\n\n        return {\n            [SELECTOR](node) {\n                if (option === \"first\" && isLastChild(node)) {\n                    return;\n                }\n\n                const lastToken = sourceCode.getLastToken(node);\n\n                if (astUtils.isSemicolonToken(lastToken)) {\n                    check(lastToken, option);\n                }\n            },\n\n            ForStatement(node) {\n                const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);\n                const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);\n\n                if (firstSemi) {\n                    check(firstSemi, \"last\");\n                }\n                if (secondSemi) {\n                    check(secondSemi, \"last\");\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}