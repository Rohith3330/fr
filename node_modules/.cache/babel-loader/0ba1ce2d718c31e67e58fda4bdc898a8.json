{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getContextualType = void 0;\n\nconst tsutils_1 = require(\"tsutils\");\n\nconst ts = __importStar(require(\"typescript\"));\n/**\n * Returns the contextual type of a given node.\n * Contextual type is the type of the target the node is going into.\n * i.e. the type of a called function's parameter, or the defined type of a variable declaration\n */\n\n\nfunction getContextualType(checker, node) {\n  const parent = node.parent;\n\n  if (!parent) {\n    return;\n  }\n\n  if ((0, tsutils_1.isCallExpression)(parent) || (0, tsutils_1.isNewExpression)(parent)) {\n    if (node === parent.expression) {\n      // is the callee, so has no contextual type\n      return;\n    }\n  } else if ((0, tsutils_1.isVariableDeclaration)(parent) || (0, tsutils_1.isPropertyDeclaration)(parent) || (0, tsutils_1.isParameterDeclaration)(parent)) {\n    return parent.type ? checker.getTypeFromTypeNode(parent.type) : undefined;\n  } else if ((0, tsutils_1.isJsxExpression)(parent)) {\n    return checker.getContextualType(parent);\n  } else if ((0, tsutils_1.isPropertyAssignment)(parent) && (0, tsutils_1.isIdentifier)(node)) {\n    return checker.getContextualType(node);\n  } else if ((0, tsutils_1.isBinaryExpression)(parent) && parent.operatorToken.kind === ts.SyntaxKind.EqualsToken && parent.right === node) {\n    // is RHS of assignment\n    return checker.getTypeAtLocation(parent.left);\n  } else if (![ts.SyntaxKind.TemplateSpan, ts.SyntaxKind.JsxExpression].includes(parent.kind)) {\n    // parent is not something we know we can get the contextual type of\n    return;\n  } // TODO - support return statement checking\n\n\n  return checker.getContextualType(node);\n}\n\nexports.getContextualType = getContextualType;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAWA;AAEA;;;;;;;AAKA,SAAgBA,iBAAhB,CACEC,OADF,EAEEC,IAFF,EAEqB;EAEnB,MAAMC,MAAM,GAAGD,IAAI,CAACC,MAApB;;EACA,IAAI,CAACA,MAAL,EAAa;IACX;EACD;;EAED,IAAI,gCAAiBA,MAAjB,KAA4B,+BAAgBA,MAAhB,CAAhC,EAAyD;IACvD,IAAID,IAAI,KAAKC,MAAM,CAACC,UAApB,EAAgC;MAC9B;MACA;IACD;EACF,CALD,MAKO,IACL,qCAAsBD,MAAtB,KACA,qCAAsBA,MAAtB,CADA,IAEA,sCAAuBA,MAAvB,CAHK,EAIL;IACA,OAAOA,MAAM,CAACE,IAAP,GAAcJ,OAAO,CAACK,mBAAR,CAA4BH,MAAM,CAACE,IAAnC,CAAd,GAAyDE,SAAhE;EACD,CANM,MAMA,IAAI,+BAAgBJ,MAAhB,CAAJ,EAA6B;IAClC,OAAOF,OAAO,CAACD,iBAAR,CAA0BG,MAA1B,CAAP;EACD,CAFM,MAEA,IAAI,oCAAqBA,MAArB,KAAgC,4BAAaD,IAAb,CAApC,EAAwD;IAC7D,OAAOD,OAAO,CAACD,iBAAR,CAA0BE,IAA1B,CAAP;EACD,CAFM,MAEA,IACL,kCAAmBC,MAAnB,KACAA,MAAM,CAACK,aAAP,CAAqBC,IAArB,KAA8BC,EAAE,CAACC,UAAH,CAAcC,WAD5C,IAEAT,MAAM,CAACU,KAAP,KAAiBX,IAHZ,EAIL;IACA;IACA,OAAOD,OAAO,CAACa,iBAAR,CAA0BX,MAAM,CAACY,IAAjC,CAAP;EACD,CAPM,MAOA,IACL,CAAC,CAACL,EAAE,CAACC,UAAH,CAAcK,YAAf,EAA6BN,EAAE,CAACC,UAAH,CAAcM,aAA3C,EAA0DC,QAA1D,CACCf,MAAM,CAACM,IADR,CADI,EAIL;IACA;IACA;EACD,CApCkB,CAqCnB;;;EAEA,OAAOR,OAAO,CAACD,iBAAR,CAA0BE,IAA1B,CAAP;AACD;;AA1CDiB","names":["getContextualType","checker","node","parent","expression","type","getTypeFromTypeNode","undefined","operatorToken","kind","ts","SyntaxKind","EqualsToken","right","getTypeAtLocation","left","TemplateSpan","JsxExpression","includes","exports"],"sources":["../src/getContextualType.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}