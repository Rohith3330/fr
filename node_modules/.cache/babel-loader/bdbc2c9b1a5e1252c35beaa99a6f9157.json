{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\n\nvar pluginProposalOptionalChaining = require('@babel/plugin-proposal-optional-chaining');\n\nvar helperSkipTransparentExpressionWrappers = require('@babel/helper-skip-transparent-expression-wrappers');\n\nvar core = require('@babel/core');\n\nfunction matchAffectedArguments(argumentNodes) {\n  const spreadIndex = argumentNodes.findIndex(node => core.types.isSpreadElement(node));\n  return spreadIndex >= 0 && spreadIndex !== argumentNodes.length - 1;\n}\n\nfunction shouldTransform(path) {\n  let optionalPath = path;\n  const chains = [];\n\n  for (;;) {\n    if (optionalPath.isOptionalMemberExpression()) {\n      chains.push(optionalPath.node);\n      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      chains.push(optionalPath.node);\n      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    } else {\n      break;\n    }\n  }\n\n  for (let i = 0; i < chains.length; i++) {\n    const node = chains[i];\n\n    if (core.types.isOptionalCallExpression(node) && matchAffectedArguments(node.arguments)) {\n      if (node.optional) {\n        return true;\n      }\n\n      const callee = chains[i + 1];\n\n      if (core.types.isOptionalMemberExpression(callee, {\n        optional: true\n      })) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nvar index = helperPluginUtils.declare(api => {\n  var _api$assumption, _api$assumption2;\n\n  api.assertVersion(7);\n  const noDocumentAll = (_api$assumption = api.assumption(\"noDocumentAll\")) != null ? _api$assumption : false;\n  const pureGetters = (_api$assumption2 = api.assumption(\"pureGetters\")) != null ? _api$assumption2 : false;\n  return {\n    name: \"bugfix-v8-spread-parameters-in-optional-chaining\",\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(path) {\n        if (shouldTransform(path)) {\n          pluginProposalOptionalChaining.transform(path, {\n            noDocumentAll,\n            pureGetters\n          });\n        }\n      }\n\n    }\n  };\n});\nexports[\"default\"] = index;","map":{"version":3,"mappings":";;;;;;;;;;;;;;AAQA,SAASA,sBAAT,CAAgCC,aAAhC,EAA8E;EAC5E,MAAMC,WAAW,GAAGD,aAAa,CAACE,SAAdF,CAAwBG,IAAI,IAAIC,WAAEC,eAAFD,CAAkBD,IAAlBC,CAAhCJ,CAApB;EACA,OAAOC,WAAW,IAAI,CAAfA,IAAoBA,WAAW,KAAKD,aAAa,CAACM,MAAdN,GAAuB,CAAlE;AACD;;AAUM,SAASO,eAAT,CACLC,IADK,EAEI;EACT,IAAIC,YAAoC,GAAGD,IAA3C;EACA,MAAME,MAAiE,GAAG,EAA1E;;EACA,SAAS;IACP,IAAID,YAAY,CAACE,0BAAbF,EAAJ,EAA+C;MAC7CC,MAAM,CAACE,IAAPF,CAAYD,YAAY,CAACN,IAAzBO;MACAD,YAAY,GAAGI,oEAA4BJ,YAAY,CAACK,GAAbL,CAAiB,QAAjBA,CAA5BI,CAAfJ;IAFF,OAGO,IAAIA,YAAY,CAACM,wBAAbN,EAAJ,EAA6C;MAClDC,MAAM,CAACE,IAAPF,CAAYD,YAAY,CAACN,IAAzBO;MACAD,YAAY,GAAGI,oEAA4BJ,YAAY,CAACK,GAAbL,CAAiB,QAAjBA,CAA5BI,CAAfJ;IAFK,OAGA;MACL;IACD;EACF;;EACD,KAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,MAAM,CAACJ,MAA3B,EAAmCU,CAAC,EAApC,EAAwC;IACtC,MAAMb,IAAI,GAAGO,MAAM,CAACM,CAAD,CAAnB;;IACA,IACEZ,WAAEW,wBAAFX,CAA2BD,IAA3BC,KACAL,sBAAsB,CAACI,IAAI,CAACc,SAAN,CAFxB,EAGE;MAEA,IAAId,IAAI,CAACe,QAAT,EAAmB;QACjB,OAAO,IAAP;MACD;;MAGD,MAAMC,MAAM,GAAGT,MAAM,CAACM,CAAC,GAAG,CAAL,CAArB;;MACA,IAAIZ,WAAEO,0BAAFP,CAA6Be,MAA7Bf,EAAqC;QAAEc,QAAQ,EAAE;MAAZ,CAArCd,CAAJ,EAA8D;QAC5D,OAAO,IAAP;MACD;IACF;EACF;;EACD,OAAO,KAAP;AACD;;AClDD,YAAegB,0BAAQC,GAAG,IAAI;EAAA;;EAC5BA,GAAG,CAACC,aAAJD,CAAkB,CAAlBA;EAEA,MAAME,aAAa,sBAAIF,GAAG,CAACG,UAAJH,CAAe,eAAfA,CAAJ,8BAAuC,KAA1D;EACA,MAAMI,WAAW,uBAAIJ,GAAG,CAACG,UAAJH,CAAe,aAAfA,CAAJ,+BAAqC,KAAtD;EAEA,OAAO;IACLK,IAAI,EAAE,kDADD;IAGLC,OAAO,EAAE;MACP,kDACEnB,IADF,EAEE;QACA,IAAID,eAAe,CAACC,IAAD,CAAnB,EAA2B;UACzBoB,yCAAUpB,IAAVoB,EAAgB;YAAEL,aAAF;YAAiBE;UAAjB,CAAhBG;QACD;MACF;;IAPM;EAHJ,CAAP;AANoB,CAAPR,CAAf","names":["matchAffectedArguments","argumentNodes","spreadIndex","findIndex","node","t","isSpreadElement","length","shouldTransform","path","optionalPath","chains","isOptionalMemberExpression","push","skipTransparentExprWrappers","get","isOptionalCallExpression","i","arguments","optional","callee","declare","api","assertVersion","noDocumentAll","assumption","pureGetters","name","visitor","transform"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-bugfix-v8-spread-parameters-in-optional-chaining\\src\\util.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-bugfix-v8-spread-parameters-in-optional-chaining\\src\\index.ts"],"sourcesContent":["import { skipTransparentExprWrappers } from \"@babel/helper-skip-transparent-expression-wrappers\";\nimport type { NodePath } from \"@babel/traverse\";\nimport { types as t } from \"@babel/core\";\n// https://crbug.com/v8/11558\n\n// check if there is a spread element followed by another argument.\n// (...[], 0) or (...[], ...[])\n\nfunction matchAffectedArguments(argumentNodes: t.CallExpression[\"arguments\"]) {\n  const spreadIndex = argumentNodes.findIndex(node => t.isSpreadElement(node));\n  return spreadIndex >= 0 && spreadIndex !== argumentNodes.length - 1;\n}\n\n/**\n * Check whether the optional chain is affected by https://crbug.com/v8/11558.\n * This routine MUST not manipulate NodePath\n *\n * @export\n * @param {(NodePath<t.OptionalMemberExpression | t.OptionalCallExpression>)} path\n * @returns {boolean}\n */\nexport function shouldTransform(\n  path: NodePath<t.OptionalMemberExpression | t.OptionalCallExpression>,\n): boolean {\n  let optionalPath: NodePath<t.Expression> = path;\n  const chains: (t.OptionalCallExpression | t.OptionalMemberExpression)[] = [];\n  for (;;) {\n    if (optionalPath.isOptionalMemberExpression()) {\n      chains.push(optionalPath.node);\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"object\"));\n    } else if (optionalPath.isOptionalCallExpression()) {\n      chains.push(optionalPath.node);\n      optionalPath = skipTransparentExprWrappers(optionalPath.get(\"callee\"));\n    } else {\n      break;\n    }\n  }\n  for (let i = 0; i < chains.length; i++) {\n    const node = chains[i];\n    if (\n      t.isOptionalCallExpression(node) &&\n      matchAffectedArguments(node.arguments)\n    ) {\n      // f?.(...[], 0)\n      if (node.optional) {\n        return true;\n      }\n      // o?.m(...[], 0)\n      // when node.optional is false, chains[i + 1] is always well defined\n      const callee = chains[i + 1];\n      if (t.isOptionalMemberExpression(callee, { optional: true })) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { transform } from \"@babel/plugin-proposal-optional-chaining\";\nimport { shouldTransform } from \"./util\";\nimport type { NodePath } from \"@babel/traverse\";\nimport type * as t from \"@babel/types\";\n\nexport default declare(api => {\n  api.assertVersion(7);\n\n  const noDocumentAll = (api.assumption(\"noDocumentAll\") ?? false) as boolean;\n  const pureGetters = (api.assumption(\"pureGetters\") ?? false) as boolean;\n\n  return {\n    name: \"bugfix-v8-spread-parameters-in-optional-chaining\",\n\n    visitor: {\n      \"OptionalCallExpression|OptionalMemberExpression\"(\n        path: NodePath<t.OptionalCallExpression | t.OptionalMemberExpression>,\n      ) {\n        if (shouldTransform(path)) {\n          transform(path, { noDocumentAll, pureGetters });\n        }\n      },\n    },\n  };\n});\n"]},"metadata":{},"sourceType":"script"}