{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar path = require('path');\n\nvar builtinList = require('builtin-modules');\n\nvar deepMerge = require('deepmerge');\n\nvar isModule = require('is-module');\n\nvar fs = require('fs');\n\nvar util = require('util');\n\nvar url = require('url');\n\nvar resolve = require('resolve');\n\nvar pluginutils = require('@rollup/pluginutils');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar path__default = /*#__PURE__*/_interopDefaultLegacy(path);\n\nvar builtinList__default = /*#__PURE__*/_interopDefaultLegacy(builtinList);\n\nvar deepMerge__default = /*#__PURE__*/_interopDefaultLegacy(deepMerge);\n\nvar isModule__default = /*#__PURE__*/_interopDefaultLegacy(isModule);\n\nvar fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);\n\nvar resolve__default = /*#__PURE__*/_interopDefaultLegacy(resolve);\n\nconst access = util.promisify(fs__default['default'].access);\nconst readFile = util.promisify(fs__default['default'].readFile);\nconst realpath = util.promisify(fs__default['default'].realpath);\nconst stat = util.promisify(fs__default['default'].stat);\n\nasync function exists(filePath) {\n  try {\n    await access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nconst onError = error => {\n  if (error.code === 'ENOENT') {\n    return false;\n  }\n\n  throw error;\n};\n\nconst makeCache = fn => {\n  const cache = new Map();\n\n  const wrapped = async (param, done) => {\n    if (cache.has(param) === false) {\n      cache.set(param, fn(param).catch(err => {\n        cache.delete(param);\n        throw err;\n      }));\n    }\n\n    try {\n      const result = cache.get(param);\n      const value = await result;\n      return done(null, value);\n    } catch (error) {\n      return done(error);\n    }\n  };\n\n  wrapped.clear = () => cache.clear();\n\n  return wrapped;\n};\n\nconst isDirCached = makeCache(async file => {\n  try {\n    const stats = await stat(file);\n    return stats.isDirectory();\n  } catch (error) {\n    return onError(error);\n  }\n});\nconst isFileCached = makeCache(async file => {\n  try {\n    const stats = await stat(file);\n    return stats.isFile();\n  } catch (error) {\n    return onError(error);\n  }\n});\nconst readCachedFile = makeCache(readFile); // returns the imported package name for bare module imports\n\nfunction getPackageName(id) {\n  if (id.startsWith('.') || id.startsWith('/')) {\n    return null;\n  }\n\n  const split = id.split('/'); // @my-scope/my-package/foo.js -> @my-scope/my-package\n  // @my-scope/my-package -> @my-scope/my-package\n\n  if (split[0][0] === '@') {\n    return `${split[0]}/${split[1]}`;\n  } // my-package/foo.js -> my-package\n  // my-package -> my-package\n\n\n  return split[0];\n}\n\nfunction getMainFields(options) {\n  let mainFields;\n\n  if (options.mainFields) {\n    ({\n      mainFields\n    } = options);\n  } else {\n    mainFields = ['module', 'main'];\n  }\n\n  if (options.browser && mainFields.indexOf('browser') === -1) {\n    return ['browser'].concat(mainFields);\n  }\n\n  if (!mainFields.length) {\n    throw new Error('Please ensure at least one `mainFields` value is specified');\n  }\n\n  return mainFields;\n}\n\nfunction getPackageInfo(options) {\n  const {\n    cache,\n    extensions,\n    pkg,\n    mainFields,\n    preserveSymlinks,\n    useBrowserOverrides,\n    rootDir,\n    ignoreSideEffectsForRoot\n  } = options;\n  let {\n    pkgPath\n  } = options;\n\n  if (cache.has(pkgPath)) {\n    return cache.get(pkgPath);\n  } // browserify/resolve doesn't realpath paths returned in its packageFilter callback\n\n\n  if (!preserveSymlinks) {\n    pkgPath = fs.realpathSync(pkgPath);\n  }\n\n  const pkgRoot = path.dirname(pkgPath);\n  const packageInfo = {\n    // copy as we are about to munge the `main` field of `pkg`.\n    packageJson: { ...pkg\n    },\n    // path to package.json file\n    packageJsonPath: pkgPath,\n    // directory containing the package.json\n    root: pkgRoot,\n    // which main field was used during resolution of this module (main, module, or browser)\n    resolvedMainField: 'main',\n    // whether the browser map was used to resolve the entry point to this module\n    browserMappedMain: false,\n    // the entry point of the module with respect to the selected main field and any\n    // relevant browser mappings.\n    resolvedEntryPoint: ''\n  };\n  let overriddenMain = false;\n\n  for (let i = 0; i < mainFields.length; i++) {\n    const field = mainFields[i];\n\n    if (typeof pkg[field] === 'string') {\n      pkg.main = pkg[field];\n      packageInfo.resolvedMainField = field;\n      overriddenMain = true;\n      break;\n    }\n  }\n\n  const internalPackageInfo = {\n    cachedPkg: pkg,\n    hasModuleSideEffects: () => null,\n    hasPackageEntry: overriddenMain !== false || mainFields.indexOf('main') !== -1,\n    packageBrowserField: useBrowserOverrides && typeof pkg.browser === 'object' && Object.keys(pkg.browser).reduce((browser, key) => {\n      let resolved = pkg.browser[key];\n\n      if (resolved && resolved[0] === '.') {\n        resolved = path.resolve(pkgRoot, resolved);\n      }\n      /* eslint-disable no-param-reassign */\n\n\n      browser[key] = resolved;\n\n      if (key[0] === '.') {\n        const absoluteKey = path.resolve(pkgRoot, key);\n        browser[absoluteKey] = resolved;\n\n        if (!path.extname(key)) {\n          extensions.reduce((subBrowser, ext) => {\n            subBrowser[absoluteKey + ext] = subBrowser[key];\n            return subBrowser;\n          }, browser);\n        }\n      }\n\n      return browser;\n    }, {}),\n    packageInfo\n  };\n  const browserMap = internalPackageInfo.packageBrowserField;\n\n  if (useBrowserOverrides && typeof pkg.browser === 'object' && // eslint-disable-next-line no-prototype-builtins\n  browserMap.hasOwnProperty(pkg.main)) {\n    packageInfo.resolvedEntryPoint = browserMap[pkg.main];\n    packageInfo.browserMappedMain = true;\n  } else {\n    // index.node is technically a valid default entrypoint as well...\n    packageInfo.resolvedEntryPoint = path.resolve(pkgRoot, pkg.main || 'index.js');\n    packageInfo.browserMappedMain = false;\n  }\n\n  if (!ignoreSideEffectsForRoot || rootDir !== pkgRoot) {\n    const packageSideEffects = pkg.sideEffects;\n\n    if (typeof packageSideEffects === 'boolean') {\n      internalPackageInfo.hasModuleSideEffects = () => packageSideEffects;\n    } else if (Array.isArray(packageSideEffects)) {\n      internalPackageInfo.hasModuleSideEffects = pluginutils.createFilter(packageSideEffects, null, {\n        resolve: pkgRoot\n      });\n    }\n  }\n\n  cache.set(pkgPath, internalPackageInfo);\n  return internalPackageInfo;\n}\n\nfunction normalizeInput(input) {\n  if (Array.isArray(input)) {\n    return input;\n  } else if (typeof input === 'object') {\n    return Object.values(input);\n  } // otherwise it's a string\n\n\n  return [input];\n}\n/* eslint-disable no-await-in-loop */\n\n\nconst fileExists = util.promisify(fs__default['default'].exists);\n\nfunction isModuleDir(current, moduleDirs) {\n  return moduleDirs.some(dir => current.endsWith(dir));\n}\n\nasync function findPackageJson(base, moduleDirs) {\n  const {\n    root\n  } = path__default['default'].parse(base);\n  let current = base;\n\n  while (current !== root && !isModuleDir(current, moduleDirs)) {\n    const pkgJsonPath = path__default['default'].join(current, 'package.json');\n\n    if (await fileExists(pkgJsonPath)) {\n      const pkgJsonString = fs__default['default'].readFileSync(pkgJsonPath, 'utf-8');\n      return {\n        pkgJson: JSON.parse(pkgJsonString),\n        pkgPath: current,\n        pkgJsonPath\n      };\n    }\n\n    current = path__default['default'].resolve(current, '..');\n  }\n\n  return null;\n}\n\nfunction isUrl(str) {\n  try {\n    return !!new URL(str);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction isConditions(exports) {\n  return typeof exports === 'object' && Object.keys(exports).every(k => !k.startsWith('.'));\n}\n\nfunction isMappings(exports) {\n  return typeof exports === 'object' && !isConditions(exports);\n}\n\nfunction isMixedExports(exports) {\n  const keys = Object.keys(exports);\n  return keys.some(k => k.startsWith('.')) && keys.some(k => !k.startsWith('.'));\n}\n\nfunction createBaseErrorMsg(importSpecifier, importer) {\n  return `Could not resolve import \"${importSpecifier}\" in ${importer}`;\n}\n\nfunction createErrorMsg(context, reason, internal) {\n  const {\n    importSpecifier,\n    importer,\n    pkgJsonPath\n  } = context;\n  const base = createBaseErrorMsg(importSpecifier, importer);\n  const field = internal ? 'imports' : 'exports';\n  return `${base} using ${field} defined in ${pkgJsonPath}.${reason ? ` ${reason}` : ''}`;\n}\n\nclass ResolveError extends Error {}\n\nclass InvalidConfigurationError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, `Invalid \"exports\" field. ${reason}`));\n  }\n\n}\n\nclass InvalidModuleSpecifierError extends ResolveError {\n  constructor(context, internal) {\n    super(createErrorMsg(context, internal));\n  }\n\n}\n\nclass InvalidPackageTargetError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, reason));\n  }\n\n}\n/* eslint-disable no-await-in-loop, no-undefined */\n\n\nfunction includesInvalidSegments(pathSegments, moduleDirs) {\n  return pathSegments.split('/').slice(1).some(t => ['.', '..', ...moduleDirs].includes(t));\n}\n\nasync function resolvePackageTarget(context, _ref) {\n  let {\n    target,\n    subpath,\n    pattern,\n    internal\n  } = _ref;\n\n  if (typeof target === 'string') {\n    if (!pattern && subpath.length > 0 && !target.endsWith('/')) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n\n    if (!target.startsWith('./')) {\n      if (internal && !['/', '../'].some(p => target.startsWith(p)) && !isUrl(target)) {\n        // this is a bare package import, remap it and resolve it using regular node resolve\n        if (pattern) {\n          const result = await context.resolveId(target.replace(/\\*/g, subpath), context.pkgURL.href);\n          return result ? url.pathToFileURL(result.location) : null;\n        }\n\n        const result = await context.resolveId(`${target}${subpath}`, context.pkgURL.href);\n        return result ? url.pathToFileURL(result.location) : null;\n      }\n\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n\n    if (includesInvalidSegments(target, context.moduleDirs)) {\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n\n    const resolvedTarget = new URL(target, context.pkgURL);\n\n    if (!resolvedTarget.href.startsWith(context.pkgURL.href)) {\n      throw new InvalidPackageTargetError(context, `Resolved to ${resolvedTarget.href} which is outside package ${context.pkgURL.href}`);\n    }\n\n    if (includesInvalidSegments(subpath, context.moduleDirs)) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n\n    if (pattern) {\n      return resolvedTarget.href.replace(/\\*/g, subpath);\n    }\n\n    return new URL(subpath, resolvedTarget).href;\n  }\n\n  if (Array.isArray(target)) {\n    let lastError;\n\n    for (const item of target) {\n      try {\n        const resolved = await resolvePackageTarget(context, {\n          target: item,\n          subpath,\n          pattern,\n          internal\n        }); // return if defined or null, but not undefined\n\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      } catch (error) {\n        if (!(error instanceof InvalidPackageTargetError)) {\n          throw error;\n        } else {\n          lastError = error;\n        }\n      }\n    }\n\n    if (lastError) {\n      throw lastError;\n    }\n\n    return null;\n  }\n\n  if (target && typeof target === 'object') {\n    for (const [key, value] of Object.entries(target)) {\n      if (key === 'default' || context.conditions.includes(key)) {\n        const resolved = await resolvePackageTarget(context, {\n          target: value,\n          subpath,\n          pattern,\n          internal\n        }); // return if defined or null, but not undefined\n\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  if (target === null) {\n    return null;\n  }\n\n  throw new InvalidPackageTargetError(context, `Invalid exports field.`);\n}\n/* eslint-disable no-await-in-loop */\n\n\nasync function resolvePackageImportsExports(context, _ref2) {\n  let {\n    matchKey,\n    matchObj,\n    internal\n  } = _ref2;\n\n  if (!matchKey.endsWith('*') && matchKey in matchObj) {\n    const target = matchObj[matchKey];\n    const resolved = await resolvePackageTarget(context, {\n      target,\n      subpath: '',\n      internal\n    });\n    return resolved;\n  }\n\n  const expansionKeys = Object.keys(matchObj).filter(k => k.endsWith('/') || k.endsWith('*')).sort((a, b) => b.length - a.length);\n\n  for (const expansionKey of expansionKeys) {\n    const prefix = expansionKey.substring(0, expansionKey.length - 1);\n\n    if (expansionKey.endsWith('*') && matchKey.startsWith(prefix)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length - 1);\n      const resolved = await resolvePackageTarget(context, {\n        target,\n        subpath,\n        pattern: true,\n        internal\n      });\n      return resolved;\n    }\n\n    if (matchKey.startsWith(expansionKey)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length);\n      const resolved = await resolvePackageTarget(context, {\n        target,\n        subpath,\n        internal\n      });\n      return resolved;\n    }\n  }\n\n  throw new InvalidModuleSpecifierError(context, internal);\n}\n\nasync function resolvePackageExports(context, subpath, exports) {\n  if (isMixedExports(exports)) {\n    throw new InvalidConfigurationError(context, 'All keys must either start with ./, or without one.');\n  }\n\n  if (subpath === '.') {\n    let mainExport; // If exports is a String or Array, or an Object containing no keys starting with \".\", then\n\n    if (typeof exports === 'string' || Array.isArray(exports) || isConditions(exports)) {\n      mainExport = exports;\n    } else if (isMappings(exports)) {\n      mainExport = exports['.'];\n    }\n\n    if (mainExport) {\n      const resolved = await resolvePackageTarget(context, {\n        target: mainExport,\n        subpath: ''\n      });\n\n      if (resolved) {\n        return resolved;\n      }\n    }\n  } else if (isMappings(exports)) {\n    const resolvedMatch = await resolvePackageImportsExports(context, {\n      matchKey: subpath,\n      matchObj: exports\n    });\n\n    if (resolvedMatch) {\n      return resolvedMatch;\n    }\n  }\n\n  throw new InvalidModuleSpecifierError(context);\n}\n\nasync function resolvePackageImports(_ref3) {\n  let {\n    importSpecifier,\n    importer,\n    moduleDirs,\n    conditions,\n    resolveId\n  } = _ref3;\n  const result = await findPackageJson(importer, moduleDirs);\n\n  if (!result) {\n    throw new Error(createBaseErrorMsg('. Could not find a parent package.json.'));\n  }\n\n  const {\n    pkgPath,\n    pkgJsonPath,\n    pkgJson\n  } = result;\n  const pkgURL = url.pathToFileURL(`${pkgPath}/`);\n  const context = {\n    importer,\n    importSpecifier,\n    moduleDirs,\n    pkgURL,\n    pkgJsonPath,\n    conditions,\n    resolveId\n  };\n  const {\n    imports\n  } = pkgJson;\n\n  if (!imports) {\n    throw new InvalidModuleSpecifierError(context, true);\n  }\n\n  if (importSpecifier === '#' || importSpecifier.startsWith('#/')) {\n    throw new InvalidModuleSpecifierError(context, 'Invalid import specifier.');\n  }\n\n  return resolvePackageImportsExports(context, {\n    matchKey: importSpecifier,\n    matchObj: imports,\n    internal: true\n  });\n}\n\nconst resolveImportPath = util.promisify(resolve__default['default']);\nconst readFile$1 = util.promisify(fs__default['default'].readFile);\n\nasync function getPackageJson(importer, pkgName, resolveOptions, moduleDirectories) {\n  if (importer) {\n    const selfPackageJsonResult = await findPackageJson(importer, moduleDirectories);\n\n    if (selfPackageJsonResult && selfPackageJsonResult.pkgJson.name === pkgName) {\n      // the referenced package name is the current package\n      return selfPackageJsonResult;\n    }\n  }\n\n  try {\n    const pkgJsonPath = await resolveImportPath(`${pkgName}/package.json`, resolveOptions);\n    const pkgJson = JSON.parse(await readFile$1(pkgJsonPath, 'utf-8'));\n    return {\n      pkgJsonPath,\n      pkgJson\n    };\n  } catch (_) {\n    return null;\n  }\n}\n\nasync function resolveId(_ref4) {\n  let {\n    importer,\n    importSpecifier,\n    exportConditions,\n    warn,\n    packageInfoCache,\n    extensions,\n    mainFields,\n    preserveSymlinks,\n    useBrowserOverrides,\n    baseDir,\n    moduleDirectories,\n    rootDir,\n    ignoreSideEffectsForRoot\n  } = _ref4;\n\n  let hasModuleSideEffects = () => null;\n\n  let hasPackageEntry = true;\n  let packageBrowserField = false;\n  let packageInfo;\n\n  const filter = (pkg, pkgPath) => {\n    const info = getPackageInfo({\n      cache: packageInfoCache,\n      extensions,\n      pkg,\n      pkgPath,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n    ({\n      packageInfo,\n      hasModuleSideEffects,\n      hasPackageEntry,\n      packageBrowserField\n    } = info);\n    return info.cachedPkg;\n  };\n\n  const resolveOptions = {\n    basedir: baseDir,\n    readFile: readCachedFile,\n    isFile: isFileCached,\n    isDirectory: isDirCached,\n    extensions,\n    includeCoreModules: false,\n    moduleDirectory: moduleDirectories,\n    preserveSymlinks,\n    packageFilter: filter\n  };\n  let location;\n  const pkgName = getPackageName(importSpecifier);\n\n  if (importSpecifier.startsWith('#')) {\n    // this is a package internal import, resolve using package imports field\n    const resolveResult = await resolvePackageImports({\n      importSpecifier,\n      importer,\n      moduleDirs: moduleDirectories,\n      conditions: exportConditions,\n\n      resolveId(id, parent) {\n        return resolveId({\n          importSpecifier: id,\n          importer: parent,\n          exportConditions,\n          warn,\n          packageInfoCache,\n          extensions,\n          mainFields,\n          preserveSymlinks,\n          useBrowserOverrides,\n          baseDir,\n          moduleDirectories\n        });\n      }\n\n    });\n    location = url.fileURLToPath(resolveResult);\n  } else if (pkgName) {\n    // it's a bare import, find the package.json and resolve using package exports if available\n    const result = await getPackageJson(importer, pkgName, resolveOptions, moduleDirectories);\n\n    if (result && result.pkgJson.exports) {\n      const {\n        pkgJson,\n        pkgJsonPath\n      } = result;\n\n      try {\n        const subpath = pkgName === importSpecifier ? '.' : `.${importSpecifier.substring(pkgName.length)}`;\n        const pkgDr = pkgJsonPath.replace('package.json', '');\n        const pkgURL = url.pathToFileURL(pkgDr);\n        const context = {\n          importer,\n          importSpecifier,\n          moduleDirs: moduleDirectories,\n          pkgURL,\n          pkgJsonPath,\n          conditions: exportConditions\n        };\n        const resolvedPackageExport = await resolvePackageExports(context, subpath, pkgJson.exports);\n        location = url.fileURLToPath(resolvedPackageExport);\n      } catch (error) {\n        if (error instanceof ResolveError) {\n          return error;\n        }\n\n        throw error;\n      }\n    }\n  }\n\n  if (!location) {\n    // package has no imports or exports, use classic node resolve\n    try {\n      location = await resolveImportPath(importSpecifier, resolveOptions);\n    } catch (error) {\n      if (error.code !== 'MODULE_NOT_FOUND') {\n        throw error;\n      }\n\n      return null;\n    }\n  }\n\n  if (!preserveSymlinks) {\n    if (await exists(location)) {\n      location = await realpath(location);\n    }\n  }\n\n  return {\n    location,\n    hasModuleSideEffects,\n    hasPackageEntry,\n    packageBrowserField,\n    packageInfo\n  };\n} // Resolve module specifiers in order. Promise resolves to the first module that resolves\n// successfully, or the error that resulted from the last attempted module resolution.\n\n\nasync function resolveImportSpecifiers(_ref5) {\n  let {\n    importer,\n    importSpecifierList,\n    exportConditions,\n    warn,\n    packageInfoCache,\n    extensions,\n    mainFields,\n    preserveSymlinks,\n    useBrowserOverrides,\n    baseDir,\n    moduleDirectories,\n    rootDir,\n    ignoreSideEffectsForRoot\n  } = _ref5;\n  let lastResolveError;\n\n  for (let i = 0; i < importSpecifierList.length; i++) {\n    // eslint-disable-next-line no-await-in-loop\n    const result = await resolveId({\n      importer,\n      importSpecifier: importSpecifierList[i],\n      exportConditions,\n      warn,\n      packageInfoCache,\n      extensions,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      baseDir,\n      moduleDirectories,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n\n    if (result instanceof ResolveError) {\n      lastResolveError = result;\n    } else if (result) {\n      return result;\n    }\n  }\n\n  if (lastResolveError) {\n    // only log the last failed resolve error\n    warn(lastResolveError);\n  }\n\n  return null;\n}\n\nfunction handleDeprecatedOptions(opts) {\n  const warnings = [];\n\n  if (opts.customResolveOptions) {\n    const {\n      customResolveOptions\n    } = opts;\n\n    if (customResolveOptions.moduleDirectory) {\n      // eslint-disable-next-line no-param-reassign\n      opts.moduleDirectories = Array.isArray(customResolveOptions.moduleDirectory) ? customResolveOptions.moduleDirectory : [customResolveOptions.moduleDirectory];\n      warnings.push('node-resolve: The `customResolveOptions.moduleDirectory` option has been deprecated. Use `moduleDirectories`, which must be an array.');\n    }\n\n    if (customResolveOptions.preserveSymlinks) {\n      throw new Error('node-resolve: `customResolveOptions.preserveSymlinks` is no longer an option. We now always use the rollup `preserveSymlinks` option.');\n    }\n\n    ['basedir', 'package', 'extensions', 'includeCoreModules', 'readFile', 'isFile', 'isDirectory', 'realpath', 'packageFilter', 'pathFilter', 'paths', 'packageIterator'].forEach(resolveOption => {\n      if (customResolveOptions[resolveOption]) {\n        throw new Error(`node-resolve: \\`customResolveOptions.${resolveOption}\\` is no longer an option. If you need this, please open an issue.`);\n      }\n    });\n  }\n\n  return {\n    warnings\n  };\n}\n/* eslint-disable no-param-reassign, no-shadow, no-undefined */\n\n\nconst builtins = new Set(builtinList__default['default']);\nconst ES6_BROWSER_EMPTY = '\\0node-resolve:empty.js';\n\nconst deepFreeze = object => {\n  Object.freeze(object);\n\n  for (const value of Object.values(object)) {\n    if (typeof value === 'object' && !Object.isFrozen(value)) {\n      deepFreeze(value);\n    }\n  }\n\n  return object;\n};\n\nconst baseConditions = ['default', 'module'];\nconst baseConditionsEsm = [...baseConditions, 'import'];\nconst baseConditionsCjs = [...baseConditions, 'require'];\nconst defaults = {\n  dedupe: [],\n  // It's important that .mjs is listed before .js so that Rollup will interpret npm modules\n  // which deploy both ESM .mjs and CommonJS .js files as ESM.\n  extensions: ['.mjs', '.js', '.json', '.node'],\n  resolveOnly: [],\n  moduleDirectories: ['node_modules'],\n  ignoreSideEffectsForRoot: false\n};\nconst DEFAULTS = deepFreeze(deepMerge__default['default']({}, defaults));\n\nfunction nodeResolve() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    warnings\n  } = handleDeprecatedOptions(opts);\n  const options = { ...defaults,\n    ...opts\n  };\n  const {\n    extensions,\n    jail,\n    moduleDirectories,\n    ignoreSideEffectsForRoot\n  } = options;\n  const conditionsEsm = [...baseConditionsEsm, ...(options.exportConditions || [])];\n  const conditionsCjs = [...baseConditionsCjs, ...(options.exportConditions || [])];\n  const packageInfoCache = new Map();\n  const idToPackageInfo = new Map();\n  const mainFields = getMainFields(options);\n  const useBrowserOverrides = mainFields.indexOf('browser') !== -1;\n  const isPreferBuiltinsSet = options.preferBuiltins === true || options.preferBuiltins === false;\n  const preferBuiltins = isPreferBuiltinsSet ? options.preferBuiltins : true;\n  const rootDir = path.resolve(options.rootDir || process.cwd());\n  let {\n    dedupe\n  } = options;\n  let rollupOptions;\n\n  if (typeof dedupe !== 'function') {\n    dedupe = importee => options.dedupe.includes(importee) || options.dedupe.includes(getPackageName(importee));\n  }\n\n  const resolveOnly = options.resolveOnly.map(pattern => {\n    if (pattern instanceof RegExp) {\n      return pattern;\n    }\n\n    const normalized = pattern.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    return new RegExp(`^${normalized}$`);\n  });\n  const browserMapCache = new Map();\n  let preserveSymlinks;\n  return {\n    name: 'node-resolve',\n\n    buildStart(options) {\n      rollupOptions = options;\n\n      for (const warning of warnings) {\n        this.warn(warning);\n      }\n\n      ({\n        preserveSymlinks\n      } = options);\n    },\n\n    generateBundle() {\n      readCachedFile.clear();\n      isFileCached.clear();\n      isDirCached.clear();\n    },\n\n    async resolveId(importee, importer, opts) {\n      var _this = this;\n\n      if (importee === ES6_BROWSER_EMPTY) {\n        return importee;\n      } // ignore IDs with null character, these belong to other plugins\n\n\n      if (/\\0/.test(importee)) return null;\n\n      if (/\\0/.test(importer)) {\n        importer = undefined;\n      } // strip query params from import\n\n\n      const [importPath, params] = importee.split('?');\n      const importSuffix = `${params ? `?${params}` : ''}`;\n      importee = importPath;\n      const baseDir = !importer || dedupe(importee) ? rootDir : path.dirname(importer); // https://github.com/defunctzombie/package-browser-field-spec\n\n      const browser = browserMapCache.get(importer);\n\n      if (useBrowserOverrides && browser) {\n        const resolvedImportee = path.resolve(baseDir, importee);\n\n        if (browser[importee] === false || browser[resolvedImportee] === false) {\n          return ES6_BROWSER_EMPTY;\n        }\n\n        const browserImportee = browser[importee] || browser[resolvedImportee] || browser[`${resolvedImportee}.js`] || browser[`${resolvedImportee}.json`];\n\n        if (browserImportee) {\n          importee = browserImportee;\n        }\n      }\n\n      const parts = importee.split(/[/\\\\]/);\n      let id = parts.shift();\n      let isRelativeImport = false;\n\n      if (id[0] === '@' && parts.length > 0) {\n        // scoped packages\n        id += `/${parts.shift()}`;\n      } else if (id[0] === '.') {\n        // an import relative to the parent dir of the importer\n        id = path.resolve(baseDir, importee);\n        isRelativeImport = true;\n      }\n\n      if (!isRelativeImport && resolveOnly.length && !resolveOnly.some(pattern => pattern.test(id))) {\n        if (normalizeInput(rollupOptions.input).includes(importee)) {\n          return null;\n        }\n\n        return false;\n      }\n\n      const importSpecifierList = [];\n\n      if (importer === undefined && !importee[0].match(/^\\.?\\.?\\//)) {\n        // For module graph roots (i.e. when importer is undefined), we\n        // need to handle 'path fragments` like `foo/bar` that are commonly\n        // found in rollup config files. If importee doesn't look like a\n        // relative or absolute path, we make it relative and attempt to\n        // resolve it. If we don't find anything, we try resolving it as we\n        // got it.\n        importSpecifierList.push(`./${importee}`);\n      }\n\n      const importeeIsBuiltin = builtins.has(importee);\n\n      if (importeeIsBuiltin) {\n        // The `resolve` library will not resolve packages with the same\n        // name as a node built-in module. If we're resolving something\n        // that's a builtin, and we don't prefer to find built-ins, we\n        // first try to look up a local module with that name. If we don't\n        // find anything, we resolve the builtin which just returns back\n        // the built-in's name.\n        importSpecifierList.push(`${importee}/`);\n      } // TypeScript files may import '.js' to refer to either '.ts' or '.tsx'\n\n\n      if (importer && importee.endsWith('.js')) {\n        for (const ext of ['.ts', '.tsx']) {\n          if (importer.endsWith(ext) && extensions.includes(ext)) {\n            importSpecifierList.push(importee.replace(/.js$/, ext));\n          }\n        }\n      }\n\n      importSpecifierList.push(importee);\n\n      const warn = function () {\n        return _this.warn(...arguments);\n      };\n\n      const isRequire = opts && opts.custom && opts.custom['node-resolve'] && opts.custom['node-resolve'].isRequire;\n      const exportConditions = isRequire ? conditionsCjs : conditionsEsm;\n      const resolvedWithoutBuiltins = await resolveImportSpecifiers({\n        importer,\n        importSpecifierList,\n        exportConditions,\n        warn,\n        packageInfoCache,\n        extensions,\n        mainFields,\n        preserveSymlinks,\n        useBrowserOverrides,\n        baseDir,\n        moduleDirectories,\n        rootDir,\n        ignoreSideEffectsForRoot\n      });\n      const resolved = importeeIsBuiltin && preferBuiltins ? {\n        packageInfo: undefined,\n        hasModuleSideEffects: () => null,\n        hasPackageEntry: true,\n        packageBrowserField: false\n      } : resolvedWithoutBuiltins;\n\n      if (!resolved) {\n        return null;\n      }\n\n      const {\n        packageInfo,\n        hasModuleSideEffects,\n        hasPackageEntry,\n        packageBrowserField\n      } = resolved;\n      let {\n        location\n      } = resolved;\n\n      if (packageBrowserField) {\n        if (Object.prototype.hasOwnProperty.call(packageBrowserField, location)) {\n          if (!packageBrowserField[location]) {\n            browserMapCache.set(location, packageBrowserField);\n            return ES6_BROWSER_EMPTY;\n          }\n\n          location = packageBrowserField[location];\n        }\n\n        browserMapCache.set(location, packageBrowserField);\n      }\n\n      if (hasPackageEntry && !preserveSymlinks) {\n        const fileExists = await exists(location);\n\n        if (fileExists) {\n          location = await realpath(location);\n        }\n      }\n\n      idToPackageInfo.set(location, packageInfo);\n\n      if (hasPackageEntry) {\n        if (importeeIsBuiltin && preferBuiltins) {\n          if (!isPreferBuiltinsSet && resolvedWithoutBuiltins && resolved !== importee) {\n            this.warn(`preferring built-in module '${importee}' over local alternative at '${resolvedWithoutBuiltins.location}', pass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning`);\n          }\n\n          return false;\n        } else if (jail && location.indexOf(path.normalize(jail.trim(path.sep))) !== 0) {\n          return null;\n        }\n      }\n\n      if (options.modulesOnly && (await exists(location))) {\n        const code = await readFile(location, 'utf-8');\n\n        if (isModule__default['default'](code)) {\n          return {\n            id: `${location}${importSuffix}`,\n            moduleSideEffects: hasModuleSideEffects(location)\n          };\n        }\n\n        return null;\n      }\n\n      const result = {\n        id: `${location}${importSuffix}`,\n        moduleSideEffects: hasModuleSideEffects(location)\n      };\n      return result;\n    },\n\n    load(importee) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return 'export default {};';\n      }\n\n      return null;\n    },\n\n    getPackageInfoForId(id) {\n      return idToPackageInfo.get(id);\n    }\n\n  };\n}\n\nexports.DEFAULTS = DEFAULTS;\nexports.default = nodeResolve;\nexports.nodeResolve = nodeResolve;","map":{"version":3,"names":["Object","defineProperty","exports","value","path","require","builtinList","deepMerge","isModule","fs","util","url","resolve","pluginutils","_interopDefaultLegacy","e","path__default","builtinList__default","deepMerge__default","isModule__default","fs__default","resolve__default","access","promisify","readFile","realpath","stat","exists","filePath","onError","error","code","makeCache","fn","cache","Map","wrapped","param","done","has","set","catch","err","delete","result","get","clear","isDirCached","file","stats","isDirectory","isFileCached","isFile","readCachedFile","getPackageName","id","startsWith","split","getMainFields","options","mainFields","browser","indexOf","concat","length","Error","getPackageInfo","extensions","pkg","preserveSymlinks","useBrowserOverrides","rootDir","ignoreSideEffectsForRoot","pkgPath","realpathSync","pkgRoot","dirname","packageInfo","packageJson","packageJsonPath","root","resolvedMainField","browserMappedMain","resolvedEntryPoint","overriddenMain","i","field","main","internalPackageInfo","cachedPkg","hasModuleSideEffects","hasPackageEntry","packageBrowserField","keys","reduce","key","resolved","absoluteKey","extname","subBrowser","ext","browserMap","hasOwnProperty","packageSideEffects","sideEffects","Array","isArray","createFilter","normalizeInput","input","values","fileExists","isModuleDir","current","moduleDirs","some","dir","endsWith","findPackageJson","base","parse","pkgJsonPath","join","pkgJsonString","readFileSync","pkgJson","JSON","isUrl","str","URL","_","isConditions","every","k","isMappings","isMixedExports","createBaseErrorMsg","importSpecifier","importer","createErrorMsg","context","reason","internal","ResolveError","InvalidConfigurationError","constructor","InvalidModuleSpecifierError","InvalidPackageTargetError","includesInvalidSegments","pathSegments","slice","t","includes","resolvePackageTarget","target","subpath","pattern","p","resolveId","replace","pkgURL","href","pathToFileURL","location","resolvedTarget","lastError","item","undefined","entries","conditions","resolvePackageImportsExports","matchKey","matchObj","expansionKeys","filter","sort","a","b","expansionKey","prefix","substring","resolvePackageExports","mainExport","resolvedMatch","resolvePackageImports","imports","resolveImportPath","readFile$1","getPackageJson","pkgName","resolveOptions","moduleDirectories","selfPackageJsonResult","name","exportConditions","warn","packageInfoCache","baseDir","info","basedir","includeCoreModules","moduleDirectory","packageFilter","resolveResult","parent","fileURLToPath","pkgDr","resolvedPackageExport","resolveImportSpecifiers","importSpecifierList","lastResolveError","handleDeprecatedOptions","opts","warnings","customResolveOptions","push","forEach","resolveOption","builtins","Set","ES6_BROWSER_EMPTY","deepFreeze","object","freeze","isFrozen","baseConditions","baseConditionsEsm","baseConditionsCjs","defaults","dedupe","resolveOnly","DEFAULTS","nodeResolve","jail","conditionsEsm","conditionsCjs","idToPackageInfo","isPreferBuiltinsSet","preferBuiltins","process","cwd","rollupOptions","importee","map","RegExp","normalized","browserMapCache","buildStart","warning","generateBundle","test","importPath","params","importSuffix","resolvedImportee","browserImportee","parts","shift","isRelativeImport","match","importeeIsBuiltin","isRequire","custom","resolvedWithoutBuiltins","prototype","call","normalize","trim","sep","modulesOnly","moduleSideEffects","load","getPackageInfoForId","default"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@rollup/plugin-node-resolve/dist/cjs/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar path = require('path');\nvar builtinList = require('builtin-modules');\nvar deepMerge = require('deepmerge');\nvar isModule = require('is-module');\nvar fs = require('fs');\nvar util = require('util');\nvar url = require('url');\nvar resolve = require('resolve');\nvar pluginutils = require('@rollup/pluginutils');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar path__default = /*#__PURE__*/_interopDefaultLegacy(path);\nvar builtinList__default = /*#__PURE__*/_interopDefaultLegacy(builtinList);\nvar deepMerge__default = /*#__PURE__*/_interopDefaultLegacy(deepMerge);\nvar isModule__default = /*#__PURE__*/_interopDefaultLegacy(isModule);\nvar fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);\nvar resolve__default = /*#__PURE__*/_interopDefaultLegacy(resolve);\n\nconst access = util.promisify(fs__default['default'].access);\nconst readFile = util.promisify(fs__default['default'].readFile);\nconst realpath = util.promisify(fs__default['default'].realpath);\nconst stat = util.promisify(fs__default['default'].stat);\nasync function exists(filePath) {\n  try {\n    await access(filePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nconst onError = (error) => {\n  if (error.code === 'ENOENT') {\n    return false;\n  }\n  throw error;\n};\n\nconst makeCache = (fn) => {\n  const cache = new Map();\n  const wrapped = async (param, done) => {\n    if (cache.has(param) === false) {\n      cache.set(\n        param,\n        fn(param).catch((err) => {\n          cache.delete(param);\n          throw err;\n        })\n      );\n    }\n\n    try {\n      const result = cache.get(param);\n      const value = await result;\n      return done(null, value);\n    } catch (error) {\n      return done(error);\n    }\n  };\n\n  wrapped.clear = () => cache.clear();\n\n  return wrapped;\n};\n\nconst isDirCached = makeCache(async (file) => {\n  try {\n    const stats = await stat(file);\n    return stats.isDirectory();\n  } catch (error) {\n    return onError(error);\n  }\n});\n\nconst isFileCached = makeCache(async (file) => {\n  try {\n    const stats = await stat(file);\n    return stats.isFile();\n  } catch (error) {\n    return onError(error);\n  }\n});\n\nconst readCachedFile = makeCache(readFile);\n\n// returns the imported package name for bare module imports\nfunction getPackageName(id) {\n  if (id.startsWith('.') || id.startsWith('/')) {\n    return null;\n  }\n\n  const split = id.split('/');\n\n  // @my-scope/my-package/foo.js -> @my-scope/my-package\n  // @my-scope/my-package -> @my-scope/my-package\n  if (split[0][0] === '@') {\n    return `${split[0]}/${split[1]}`;\n  }\n\n  // my-package/foo.js -> my-package\n  // my-package -> my-package\n  return split[0];\n}\n\nfunction getMainFields(options) {\n  let mainFields;\n  if (options.mainFields) {\n    ({ mainFields } = options);\n  } else {\n    mainFields = ['module', 'main'];\n  }\n  if (options.browser && mainFields.indexOf('browser') === -1) {\n    return ['browser'].concat(mainFields);\n  }\n  if (!mainFields.length) {\n    throw new Error('Please ensure at least one `mainFields` value is specified');\n  }\n  return mainFields;\n}\n\nfunction getPackageInfo(options) {\n  const {\n    cache,\n    extensions,\n    pkg,\n    mainFields,\n    preserveSymlinks,\n    useBrowserOverrides,\n    rootDir,\n    ignoreSideEffectsForRoot\n  } = options;\n  let { pkgPath } = options;\n\n  if (cache.has(pkgPath)) {\n    return cache.get(pkgPath);\n  }\n\n  // browserify/resolve doesn't realpath paths returned in its packageFilter callback\n  if (!preserveSymlinks) {\n    pkgPath = fs.realpathSync(pkgPath);\n  }\n\n  const pkgRoot = path.dirname(pkgPath);\n\n  const packageInfo = {\n    // copy as we are about to munge the `main` field of `pkg`.\n    packageJson: { ...pkg },\n\n    // path to package.json file\n    packageJsonPath: pkgPath,\n\n    // directory containing the package.json\n    root: pkgRoot,\n\n    // which main field was used during resolution of this module (main, module, or browser)\n    resolvedMainField: 'main',\n\n    // whether the browser map was used to resolve the entry point to this module\n    browserMappedMain: false,\n\n    // the entry point of the module with respect to the selected main field and any\n    // relevant browser mappings.\n    resolvedEntryPoint: ''\n  };\n\n  let overriddenMain = false;\n  for (let i = 0; i < mainFields.length; i++) {\n    const field = mainFields[i];\n    if (typeof pkg[field] === 'string') {\n      pkg.main = pkg[field];\n      packageInfo.resolvedMainField = field;\n      overriddenMain = true;\n      break;\n    }\n  }\n\n  const internalPackageInfo = {\n    cachedPkg: pkg,\n    hasModuleSideEffects: () => null,\n    hasPackageEntry: overriddenMain !== false || mainFields.indexOf('main') !== -1,\n    packageBrowserField:\n      useBrowserOverrides &&\n      typeof pkg.browser === 'object' &&\n      Object.keys(pkg.browser).reduce((browser, key) => {\n        let resolved = pkg.browser[key];\n        if (resolved && resolved[0] === '.') {\n          resolved = path.resolve(pkgRoot, resolved);\n        }\n        /* eslint-disable no-param-reassign */\n        browser[key] = resolved;\n        if (key[0] === '.') {\n          const absoluteKey = path.resolve(pkgRoot, key);\n          browser[absoluteKey] = resolved;\n          if (!path.extname(key)) {\n            extensions.reduce((subBrowser, ext) => {\n              subBrowser[absoluteKey + ext] = subBrowser[key];\n              return subBrowser;\n            }, browser);\n          }\n        }\n        return browser;\n      }, {}),\n    packageInfo\n  };\n\n  const browserMap = internalPackageInfo.packageBrowserField;\n  if (\n    useBrowserOverrides &&\n    typeof pkg.browser === 'object' &&\n    // eslint-disable-next-line no-prototype-builtins\n    browserMap.hasOwnProperty(pkg.main)\n  ) {\n    packageInfo.resolvedEntryPoint = browserMap[pkg.main];\n    packageInfo.browserMappedMain = true;\n  } else {\n    // index.node is technically a valid default entrypoint as well...\n    packageInfo.resolvedEntryPoint = path.resolve(pkgRoot, pkg.main || 'index.js');\n    packageInfo.browserMappedMain = false;\n  }\n\n  if (!ignoreSideEffectsForRoot || rootDir !== pkgRoot) {\n    const packageSideEffects = pkg.sideEffects;\n    if (typeof packageSideEffects === 'boolean') {\n      internalPackageInfo.hasModuleSideEffects = () => packageSideEffects;\n    } else if (Array.isArray(packageSideEffects)) {\n      internalPackageInfo.hasModuleSideEffects = pluginutils.createFilter(packageSideEffects, null, {\n        resolve: pkgRoot\n      });\n    }\n  }\n\n  cache.set(pkgPath, internalPackageInfo);\n  return internalPackageInfo;\n}\n\nfunction normalizeInput(input) {\n  if (Array.isArray(input)) {\n    return input;\n  } else if (typeof input === 'object') {\n    return Object.values(input);\n  }\n\n  // otherwise it's a string\n  return [input];\n}\n\n/* eslint-disable no-await-in-loop */\n\nconst fileExists = util.promisify(fs__default['default'].exists);\n\nfunction isModuleDir(current, moduleDirs) {\n  return moduleDirs.some((dir) => current.endsWith(dir));\n}\n\nasync function findPackageJson(base, moduleDirs) {\n  const { root } = path__default['default'].parse(base);\n  let current = base;\n\n  while (current !== root && !isModuleDir(current, moduleDirs)) {\n    const pkgJsonPath = path__default['default'].join(current, 'package.json');\n    if (await fileExists(pkgJsonPath)) {\n      const pkgJsonString = fs__default['default'].readFileSync(pkgJsonPath, 'utf-8');\n      return { pkgJson: JSON.parse(pkgJsonString), pkgPath: current, pkgJsonPath };\n    }\n    current = path__default['default'].resolve(current, '..');\n  }\n  return null;\n}\n\nfunction isUrl(str) {\n  try {\n    return !!new URL(str);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction isConditions(exports) {\n  return typeof exports === 'object' && Object.keys(exports).every((k) => !k.startsWith('.'));\n}\n\nfunction isMappings(exports) {\n  return typeof exports === 'object' && !isConditions(exports);\n}\n\nfunction isMixedExports(exports) {\n  const keys = Object.keys(exports);\n  return keys.some((k) => k.startsWith('.')) && keys.some((k) => !k.startsWith('.'));\n}\n\nfunction createBaseErrorMsg(importSpecifier, importer) {\n  return `Could not resolve import \"${importSpecifier}\" in ${importer}`;\n}\n\nfunction createErrorMsg(context, reason, internal) {\n  const { importSpecifier, importer, pkgJsonPath } = context;\n  const base = createBaseErrorMsg(importSpecifier, importer);\n  const field = internal ? 'imports' : 'exports';\n  return `${base} using ${field} defined in ${pkgJsonPath}.${reason ? ` ${reason}` : ''}`;\n}\n\nclass ResolveError extends Error {}\n\nclass InvalidConfigurationError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, `Invalid \"exports\" field. ${reason}`));\n  }\n}\n\nclass InvalidModuleSpecifierError extends ResolveError {\n  constructor(context, internal) {\n    super(createErrorMsg(context, internal));\n  }\n}\n\nclass InvalidPackageTargetError extends ResolveError {\n  constructor(context, reason) {\n    super(createErrorMsg(context, reason));\n  }\n}\n\n/* eslint-disable no-await-in-loop, no-undefined */\n\nfunction includesInvalidSegments(pathSegments, moduleDirs) {\n  return pathSegments\n    .split('/')\n    .slice(1)\n    .some((t) => ['.', '..', ...moduleDirs].includes(t));\n}\n\nasync function resolvePackageTarget(context, { target, subpath, pattern, internal }) {\n  if (typeof target === 'string') {\n    if (!pattern && subpath.length > 0 && !target.endsWith('/')) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n\n    if (!target.startsWith('./')) {\n      if (internal && !['/', '../'].some((p) => target.startsWith(p)) && !isUrl(target)) {\n        // this is a bare package import, remap it and resolve it using regular node resolve\n        if (pattern) {\n          const result = await context.resolveId(\n            target.replace(/\\*/g, subpath),\n            context.pkgURL.href\n          );\n          return result ? url.pathToFileURL(result.location) : null;\n        }\n\n        const result = await context.resolveId(`${target}${subpath}`, context.pkgURL.href);\n        return result ? url.pathToFileURL(result.location) : null;\n      }\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n\n    if (includesInvalidSegments(target, context.moduleDirs)) {\n      throw new InvalidPackageTargetError(context, `Invalid mapping: \"${target}\".`);\n    }\n\n    const resolvedTarget = new URL(target, context.pkgURL);\n    if (!resolvedTarget.href.startsWith(context.pkgURL.href)) {\n      throw new InvalidPackageTargetError(\n        context,\n        `Resolved to ${resolvedTarget.href} which is outside package ${context.pkgURL.href}`\n      );\n    }\n\n    if (includesInvalidSegments(subpath, context.moduleDirs)) {\n      throw new InvalidModuleSpecifierError(context);\n    }\n\n    if (pattern) {\n      return resolvedTarget.href.replace(/\\*/g, subpath);\n    }\n    return new URL(subpath, resolvedTarget).href;\n  }\n\n  if (Array.isArray(target)) {\n    let lastError;\n    for (const item of target) {\n      try {\n        const resolved = await resolvePackageTarget(context, {\n          target: item,\n          subpath,\n          pattern,\n          internal\n        });\n\n        // return if defined or null, but not undefined\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      } catch (error) {\n        if (!(error instanceof InvalidPackageTargetError)) {\n          throw error;\n        } else {\n          lastError = error;\n        }\n      }\n    }\n\n    if (lastError) {\n      throw lastError;\n    }\n    return null;\n  }\n\n  if (target && typeof target === 'object') {\n    for (const [key, value] of Object.entries(target)) {\n      if (key === 'default' || context.conditions.includes(key)) {\n        const resolved = await resolvePackageTarget(context, {\n          target: value,\n          subpath,\n          pattern,\n          internal\n        });\n\n        // return if defined or null, but not undefined\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  if (target === null) {\n    return null;\n  }\n\n  throw new InvalidPackageTargetError(context, `Invalid exports field.`);\n}\n\n/* eslint-disable no-await-in-loop */\n\nasync function resolvePackageImportsExports(context, { matchKey, matchObj, internal }) {\n  if (!matchKey.endsWith('*') && matchKey in matchObj) {\n    const target = matchObj[matchKey];\n    const resolved = await resolvePackageTarget(context, { target, subpath: '', internal });\n    return resolved;\n  }\n\n  const expansionKeys = Object.keys(matchObj)\n    .filter((k) => k.endsWith('/') || k.endsWith('*'))\n    .sort((a, b) => b.length - a.length);\n\n  for (const expansionKey of expansionKeys) {\n    const prefix = expansionKey.substring(0, expansionKey.length - 1);\n\n    if (expansionKey.endsWith('*') && matchKey.startsWith(prefix)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length - 1);\n      const resolved = await resolvePackageTarget(context, {\n        target,\n        subpath,\n        pattern: true,\n        internal\n      });\n      return resolved;\n    }\n\n    if (matchKey.startsWith(expansionKey)) {\n      const target = matchObj[expansionKey];\n      const subpath = matchKey.substring(expansionKey.length);\n\n      const resolved = await resolvePackageTarget(context, { target, subpath, internal });\n      return resolved;\n    }\n  }\n\n  throw new InvalidModuleSpecifierError(context, internal);\n}\n\nasync function resolvePackageExports(context, subpath, exports) {\n  if (isMixedExports(exports)) {\n    throw new InvalidConfigurationError(\n      context,\n      'All keys must either start with ./, or without one.'\n    );\n  }\n\n  if (subpath === '.') {\n    let mainExport;\n    // If exports is a String or Array, or an Object containing no keys starting with \".\", then\n    if (typeof exports === 'string' || Array.isArray(exports) || isConditions(exports)) {\n      mainExport = exports;\n    } else if (isMappings(exports)) {\n      mainExport = exports['.'];\n    }\n\n    if (mainExport) {\n      const resolved = await resolvePackageTarget(context, { target: mainExport, subpath: '' });\n      if (resolved) {\n        return resolved;\n      }\n    }\n  } else if (isMappings(exports)) {\n    const resolvedMatch = await resolvePackageImportsExports(context, {\n      matchKey: subpath,\n      matchObj: exports\n    });\n\n    if (resolvedMatch) {\n      return resolvedMatch;\n    }\n  }\n\n  throw new InvalidModuleSpecifierError(context);\n}\n\nasync function resolvePackageImports({\n  importSpecifier,\n  importer,\n  moduleDirs,\n  conditions,\n  resolveId\n}) {\n  const result = await findPackageJson(importer, moduleDirs);\n  if (!result) {\n    throw new Error(createBaseErrorMsg('. Could not find a parent package.json.'));\n  }\n\n  const { pkgPath, pkgJsonPath, pkgJson } = result;\n  const pkgURL = url.pathToFileURL(`${pkgPath}/`);\n  const context = {\n    importer,\n    importSpecifier,\n    moduleDirs,\n    pkgURL,\n    pkgJsonPath,\n    conditions,\n    resolveId\n  };\n\n  const { imports } = pkgJson;\n  if (!imports) {\n    throw new InvalidModuleSpecifierError(context, true);\n  }\n\n  if (importSpecifier === '#' || importSpecifier.startsWith('#/')) {\n    throw new InvalidModuleSpecifierError(context, 'Invalid import specifier.');\n  }\n\n  return resolvePackageImportsExports(context, {\n    matchKey: importSpecifier,\n    matchObj: imports,\n    internal: true\n  });\n}\n\nconst resolveImportPath = util.promisify(resolve__default['default']);\nconst readFile$1 = util.promisify(fs__default['default'].readFile);\n\nasync function getPackageJson(importer, pkgName, resolveOptions, moduleDirectories) {\n  if (importer) {\n    const selfPackageJsonResult = await findPackageJson(importer, moduleDirectories);\n    if (selfPackageJsonResult && selfPackageJsonResult.pkgJson.name === pkgName) {\n      // the referenced package name is the current package\n      return selfPackageJsonResult;\n    }\n  }\n\n  try {\n    const pkgJsonPath = await resolveImportPath(`${pkgName}/package.json`, resolveOptions);\n    const pkgJson = JSON.parse(await readFile$1(pkgJsonPath, 'utf-8'));\n    return { pkgJsonPath, pkgJson };\n  } catch (_) {\n    return null;\n  }\n}\n\nasync function resolveId({\n  importer,\n  importSpecifier,\n  exportConditions,\n  warn,\n  packageInfoCache,\n  extensions,\n  mainFields,\n  preserveSymlinks,\n  useBrowserOverrides,\n  baseDir,\n  moduleDirectories,\n  rootDir,\n  ignoreSideEffectsForRoot\n}) {\n  let hasModuleSideEffects = () => null;\n  let hasPackageEntry = true;\n  let packageBrowserField = false;\n  let packageInfo;\n\n  const filter = (pkg, pkgPath) => {\n    const info = getPackageInfo({\n      cache: packageInfoCache,\n      extensions,\n      pkg,\n      pkgPath,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n\n    ({ packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = info);\n\n    return info.cachedPkg;\n  };\n\n  const resolveOptions = {\n    basedir: baseDir,\n    readFile: readCachedFile,\n    isFile: isFileCached,\n    isDirectory: isDirCached,\n    extensions,\n    includeCoreModules: false,\n    moduleDirectory: moduleDirectories,\n    preserveSymlinks,\n    packageFilter: filter\n  };\n\n  let location;\n\n  const pkgName = getPackageName(importSpecifier);\n  if (importSpecifier.startsWith('#')) {\n    // this is a package internal import, resolve using package imports field\n    const resolveResult = await resolvePackageImports({\n      importSpecifier,\n      importer,\n      moduleDirs: moduleDirectories,\n      conditions: exportConditions,\n      resolveId(id, parent) {\n        return resolveId({\n          importSpecifier: id,\n          importer: parent,\n          exportConditions,\n          warn,\n          packageInfoCache,\n          extensions,\n          mainFields,\n          preserveSymlinks,\n          useBrowserOverrides,\n          baseDir,\n          moduleDirectories\n        });\n      }\n    });\n    location = url.fileURLToPath(resolveResult);\n  } else if (pkgName) {\n    // it's a bare import, find the package.json and resolve using package exports if available\n    const result = await getPackageJson(importer, pkgName, resolveOptions, moduleDirectories);\n\n    if (result && result.pkgJson.exports) {\n      const { pkgJson, pkgJsonPath } = result;\n      try {\n        const subpath =\n          pkgName === importSpecifier ? '.' : `.${importSpecifier.substring(pkgName.length)}`;\n        const pkgDr = pkgJsonPath.replace('package.json', '');\n        const pkgURL = url.pathToFileURL(pkgDr);\n\n        const context = {\n          importer,\n          importSpecifier,\n          moduleDirs: moduleDirectories,\n          pkgURL,\n          pkgJsonPath,\n          conditions: exportConditions\n        };\n        const resolvedPackageExport = await resolvePackageExports(\n          context,\n          subpath,\n          pkgJson.exports\n        );\n        location = url.fileURLToPath(resolvedPackageExport);\n      } catch (error) {\n        if (error instanceof ResolveError) {\n          return error;\n        }\n        throw error;\n      }\n    }\n  }\n\n  if (!location) {\n    // package has no imports or exports, use classic node resolve\n    try {\n      location = await resolveImportPath(importSpecifier, resolveOptions);\n    } catch (error) {\n      if (error.code !== 'MODULE_NOT_FOUND') {\n        throw error;\n      }\n      return null;\n    }\n  }\n\n  if (!preserveSymlinks) {\n    if (await exists(location)) {\n      location = await realpath(location);\n    }\n  }\n\n  return {\n    location,\n    hasModuleSideEffects,\n    hasPackageEntry,\n    packageBrowserField,\n    packageInfo\n  };\n}\n\n// Resolve module specifiers in order. Promise resolves to the first module that resolves\n// successfully, or the error that resulted from the last attempted module resolution.\nasync function resolveImportSpecifiers({\n  importer,\n  importSpecifierList,\n  exportConditions,\n  warn,\n  packageInfoCache,\n  extensions,\n  mainFields,\n  preserveSymlinks,\n  useBrowserOverrides,\n  baseDir,\n  moduleDirectories,\n  rootDir,\n  ignoreSideEffectsForRoot\n}) {\n  let lastResolveError;\n\n  for (let i = 0; i < importSpecifierList.length; i++) {\n    // eslint-disable-next-line no-await-in-loop\n    const result = await resolveId({\n      importer,\n      importSpecifier: importSpecifierList[i],\n      exportConditions,\n      warn,\n      packageInfoCache,\n      extensions,\n      mainFields,\n      preserveSymlinks,\n      useBrowserOverrides,\n      baseDir,\n      moduleDirectories,\n      rootDir,\n      ignoreSideEffectsForRoot\n    });\n\n    if (result instanceof ResolveError) {\n      lastResolveError = result;\n    } else if (result) {\n      return result;\n    }\n  }\n\n  if (lastResolveError) {\n    // only log the last failed resolve error\n    warn(lastResolveError);\n  }\n  return null;\n}\n\nfunction handleDeprecatedOptions(opts) {\n  const warnings = [];\n\n  if (opts.customResolveOptions) {\n    const { customResolveOptions } = opts;\n    if (customResolveOptions.moduleDirectory) {\n      // eslint-disable-next-line no-param-reassign\n      opts.moduleDirectories = Array.isArray(customResolveOptions.moduleDirectory)\n        ? customResolveOptions.moduleDirectory\n        : [customResolveOptions.moduleDirectory];\n\n      warnings.push(\n        'node-resolve: The `customResolveOptions.moduleDirectory` option has been deprecated. Use `moduleDirectories`, which must be an array.'\n      );\n    }\n\n    if (customResolveOptions.preserveSymlinks) {\n      throw new Error(\n        'node-resolve: `customResolveOptions.preserveSymlinks` is no longer an option. We now always use the rollup `preserveSymlinks` option.'\n      );\n    }\n\n    [\n      'basedir',\n      'package',\n      'extensions',\n      'includeCoreModules',\n      'readFile',\n      'isFile',\n      'isDirectory',\n      'realpath',\n      'packageFilter',\n      'pathFilter',\n      'paths',\n      'packageIterator'\n    ].forEach((resolveOption) => {\n      if (customResolveOptions[resolveOption]) {\n        throw new Error(\n          `node-resolve: \\`customResolveOptions.${resolveOption}\\` is no longer an option. If you need this, please open an issue.`\n        );\n      }\n    });\n  }\n\n  return { warnings };\n}\n\n/* eslint-disable no-param-reassign, no-shadow, no-undefined */\n\nconst builtins = new Set(builtinList__default['default']);\nconst ES6_BROWSER_EMPTY = '\\0node-resolve:empty.js';\nconst deepFreeze = (object) => {\n  Object.freeze(object);\n\n  for (const value of Object.values(object)) {\n    if (typeof value === 'object' && !Object.isFrozen(value)) {\n      deepFreeze(value);\n    }\n  }\n\n  return object;\n};\n\nconst baseConditions = ['default', 'module'];\nconst baseConditionsEsm = [...baseConditions, 'import'];\nconst baseConditionsCjs = [...baseConditions, 'require'];\nconst defaults = {\n  dedupe: [],\n  // It's important that .mjs is listed before .js so that Rollup will interpret npm modules\n  // which deploy both ESM .mjs and CommonJS .js files as ESM.\n  extensions: ['.mjs', '.js', '.json', '.node'],\n  resolveOnly: [],\n  moduleDirectories: ['node_modules'],\n  ignoreSideEffectsForRoot: false\n};\nconst DEFAULTS = deepFreeze(deepMerge__default['default']({}, defaults));\n\nfunction nodeResolve(opts = {}) {\n  const { warnings } = handleDeprecatedOptions(opts);\n\n  const options = { ...defaults, ...opts };\n  const { extensions, jail, moduleDirectories, ignoreSideEffectsForRoot } = options;\n  const conditionsEsm = [...baseConditionsEsm, ...(options.exportConditions || [])];\n  const conditionsCjs = [...baseConditionsCjs, ...(options.exportConditions || [])];\n  const packageInfoCache = new Map();\n  const idToPackageInfo = new Map();\n  const mainFields = getMainFields(options);\n  const useBrowserOverrides = mainFields.indexOf('browser') !== -1;\n  const isPreferBuiltinsSet = options.preferBuiltins === true || options.preferBuiltins === false;\n  const preferBuiltins = isPreferBuiltinsSet ? options.preferBuiltins : true;\n  const rootDir = path.resolve(options.rootDir || process.cwd());\n  let { dedupe } = options;\n  let rollupOptions;\n\n  if (typeof dedupe !== 'function') {\n    dedupe = (importee) =>\n      options.dedupe.includes(importee) || options.dedupe.includes(getPackageName(importee));\n  }\n\n  const resolveOnly = options.resolveOnly.map((pattern) => {\n    if (pattern instanceof RegExp) {\n      return pattern;\n    }\n    const normalized = pattern.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    return new RegExp(`^${normalized}$`);\n  });\n\n  const browserMapCache = new Map();\n  let preserveSymlinks;\n\n  return {\n    name: 'node-resolve',\n\n    buildStart(options) {\n      rollupOptions = options;\n\n      for (const warning of warnings) {\n        this.warn(warning);\n      }\n\n      ({ preserveSymlinks } = options);\n    },\n\n    generateBundle() {\n      readCachedFile.clear();\n      isFileCached.clear();\n      isDirCached.clear();\n    },\n\n    async resolveId(importee, importer, opts) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return importee;\n      }\n      // ignore IDs with null character, these belong to other plugins\n      if (/\\0/.test(importee)) return null;\n\n      if (/\\0/.test(importer)) {\n        importer = undefined;\n      }\n\n      // strip query params from import\n      const [importPath, params] = importee.split('?');\n      const importSuffix = `${params ? `?${params}` : ''}`;\n      importee = importPath;\n\n      const baseDir = !importer || dedupe(importee) ? rootDir : path.dirname(importer);\n\n      // https://github.com/defunctzombie/package-browser-field-spec\n      const browser = browserMapCache.get(importer);\n      if (useBrowserOverrides && browser) {\n        const resolvedImportee = path.resolve(baseDir, importee);\n        if (browser[importee] === false || browser[resolvedImportee] === false) {\n          return ES6_BROWSER_EMPTY;\n        }\n        const browserImportee =\n          browser[importee] ||\n          browser[resolvedImportee] ||\n          browser[`${resolvedImportee}.js`] ||\n          browser[`${resolvedImportee}.json`];\n        if (browserImportee) {\n          importee = browserImportee;\n        }\n      }\n\n      const parts = importee.split(/[/\\\\]/);\n      let id = parts.shift();\n      let isRelativeImport = false;\n\n      if (id[0] === '@' && parts.length > 0) {\n        // scoped packages\n        id += `/${parts.shift()}`;\n      } else if (id[0] === '.') {\n        // an import relative to the parent dir of the importer\n        id = path.resolve(baseDir, importee);\n        isRelativeImport = true;\n      }\n\n      if (\n        !isRelativeImport &&\n        resolveOnly.length &&\n        !resolveOnly.some((pattern) => pattern.test(id))\n      ) {\n        if (normalizeInput(rollupOptions.input).includes(importee)) {\n          return null;\n        }\n        return false;\n      }\n\n      const importSpecifierList = [];\n\n      if (importer === undefined && !importee[0].match(/^\\.?\\.?\\//)) {\n        // For module graph roots (i.e. when importer is undefined), we\n        // need to handle 'path fragments` like `foo/bar` that are commonly\n        // found in rollup config files. If importee doesn't look like a\n        // relative or absolute path, we make it relative and attempt to\n        // resolve it. If we don't find anything, we try resolving it as we\n        // got it.\n        importSpecifierList.push(`./${importee}`);\n      }\n\n      const importeeIsBuiltin = builtins.has(importee);\n\n      if (importeeIsBuiltin) {\n        // The `resolve` library will not resolve packages with the same\n        // name as a node built-in module. If we're resolving something\n        // that's a builtin, and we don't prefer to find built-ins, we\n        // first try to look up a local module with that name. If we don't\n        // find anything, we resolve the builtin which just returns back\n        // the built-in's name.\n        importSpecifierList.push(`${importee}/`);\n      }\n\n      // TypeScript files may import '.js' to refer to either '.ts' or '.tsx'\n      if (importer && importee.endsWith('.js')) {\n        for (const ext of ['.ts', '.tsx']) {\n          if (importer.endsWith(ext) && extensions.includes(ext)) {\n            importSpecifierList.push(importee.replace(/.js$/, ext));\n          }\n        }\n      }\n\n      importSpecifierList.push(importee);\n\n      const warn = (...args) => this.warn(...args);\n      const isRequire =\n        opts && opts.custom && opts.custom['node-resolve'] && opts.custom['node-resolve'].isRequire;\n      const exportConditions = isRequire ? conditionsCjs : conditionsEsm;\n\n      const resolvedWithoutBuiltins = await resolveImportSpecifiers({\n        importer,\n        importSpecifierList,\n        exportConditions,\n        warn,\n        packageInfoCache,\n        extensions,\n        mainFields,\n        preserveSymlinks,\n        useBrowserOverrides,\n        baseDir,\n        moduleDirectories,\n        rootDir,\n        ignoreSideEffectsForRoot\n      });\n\n      const resolved =\n        importeeIsBuiltin && preferBuiltins\n          ? {\n              packageInfo: undefined,\n              hasModuleSideEffects: () => null,\n              hasPackageEntry: true,\n              packageBrowserField: false\n            }\n          : resolvedWithoutBuiltins;\n      if (!resolved) {\n        return null;\n      }\n\n      const { packageInfo, hasModuleSideEffects, hasPackageEntry, packageBrowserField } = resolved;\n      let { location } = resolved;\n      if (packageBrowserField) {\n        if (Object.prototype.hasOwnProperty.call(packageBrowserField, location)) {\n          if (!packageBrowserField[location]) {\n            browserMapCache.set(location, packageBrowserField);\n            return ES6_BROWSER_EMPTY;\n          }\n          location = packageBrowserField[location];\n        }\n        browserMapCache.set(location, packageBrowserField);\n      }\n\n      if (hasPackageEntry && !preserveSymlinks) {\n        const fileExists = await exists(location);\n        if (fileExists) {\n          location = await realpath(location);\n        }\n      }\n\n      idToPackageInfo.set(location, packageInfo);\n\n      if (hasPackageEntry) {\n        if (importeeIsBuiltin && preferBuiltins) {\n          if (!isPreferBuiltinsSet && resolvedWithoutBuiltins && resolved !== importee) {\n            this.warn(\n              `preferring built-in module '${importee}' over local alternative at '${resolvedWithoutBuiltins.location}', pass 'preferBuiltins: false' to disable this behavior or 'preferBuiltins: true' to disable this warning`\n            );\n          }\n          return false;\n        } else if (jail && location.indexOf(path.normalize(jail.trim(path.sep))) !== 0) {\n          return null;\n        }\n      }\n\n      if (options.modulesOnly && (await exists(location))) {\n        const code = await readFile(location, 'utf-8');\n        if (isModule__default['default'](code)) {\n          return {\n            id: `${location}${importSuffix}`,\n            moduleSideEffects: hasModuleSideEffects(location)\n          };\n        }\n        return null;\n      }\n      const result = {\n        id: `${location}${importSuffix}`,\n        moduleSideEffects: hasModuleSideEffects(location)\n      };\n      return result;\n    },\n\n    load(importee) {\n      if (importee === ES6_BROWSER_EMPTY) {\n        return 'export default {};';\n      }\n      return null;\n    },\n\n    getPackageInfoForId(id) {\n      return idToPackageInfo.get(id);\n    }\n  };\n}\n\nexports.DEFAULTS = DEFAULTS;\nexports.default = nodeResolve;\nexports.nodeResolve = nodeResolve;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}