{"ast":null,"code":"/* eslint-disable no-param-reassign*/\nimport TokenTranslator from \"./token-translator.js\";\nimport { normalizeOptions } from \"./options.js\";\nconst STATE = Symbol(\"espree's internal state\");\nconst ESPRIMA_FINISH_NODE = Symbol(\"espree's esprimaFinishNode\");\n/**\n * Converts an Acorn comment to a Esprima comment.\n * @param {boolean} block True if it's a block comment, false if not.\n * @param {string} text The text of the comment.\n * @param {int} start The index at which the comment starts.\n * @param {int} end The index at which the comment ends.\n * @param {Location} startLoc The location at which the comment starts.\n * @param {Location} endLoc The location at which the comment ends.\n * @param {string} code The source code being parsed.\n * @returns {Object} The comment object.\n * @private\n */\n\nfunction convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code) {\n  let type;\n\n  if (block) {\n    type = \"Block\";\n  } else if (code.slice(start, start + 2) === \"#!\") {\n    type = \"Hashbang\";\n  } else {\n    type = \"Line\";\n  }\n\n  const comment = {\n    type,\n    value: text\n  };\n\n  if (typeof start === \"number\") {\n    comment.start = start;\n    comment.end = end;\n    comment.range = [start, end];\n  }\n\n  if (typeof startLoc === \"object\") {\n    comment.loc = {\n      start: startLoc,\n      end: endLoc\n    };\n  }\n\n  return comment;\n}\n\nexport default (() => Parser => {\n  const tokTypes = Object.assign({}, Parser.acorn.tokTypes);\n\n  if (Parser.acornJsx) {\n    Object.assign(tokTypes, Parser.acornJsx.tokTypes);\n  }\n\n  return class Espree extends Parser {\n    constructor(opts, code) {\n      if (typeof opts !== \"object\" || opts === null) {\n        opts = {};\n      }\n\n      if (typeof code !== \"string\" && !(code instanceof String)) {\n        code = String(code);\n      } // save original source type in case of commonjs\n\n\n      const originalSourceType = opts.sourceType;\n      const options = normalizeOptions(opts);\n      const ecmaFeatures = options.ecmaFeatures || {};\n      const tokenTranslator = options.tokens === true ? new TokenTranslator(tokTypes, code) : null;\n      /*\n       * Data that is unique to Espree and is not represented internally\n       * in Acorn.\n       *\n       * For ES2023 hashbangs, Espree will call `onComment()` during the\n       * constructor, so we must define state before having access to\n       * `this`.\n       */\n\n      const state = {\n        originalSourceType: originalSourceType || options.sourceType,\n        tokens: tokenTranslator ? [] : null,\n        comments: options.comment === true ? [] : null,\n        impliedStrict: ecmaFeatures.impliedStrict === true && options.ecmaVersion >= 5,\n        ecmaVersion: options.ecmaVersion,\n        jsxAttrValueToken: false,\n        lastToken: null,\n        templateElements: []\n      }; // Initialize acorn parser.\n\n      super({\n        // do not use spread, because we don't want to pass any unknown options to acorn\n        ecmaVersion: options.ecmaVersion,\n        sourceType: options.sourceType,\n        ranges: options.ranges,\n        locations: options.locations,\n        allowReserved: options.allowReserved,\n        // Truthy value is true for backward compatibility.\n        allowReturnOutsideFunction: options.allowReturnOutsideFunction,\n        // Collect tokens\n        onToken: token => {\n          if (tokenTranslator) {\n            // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.\n            tokenTranslator.onToken(token, state);\n          }\n\n          if (token.type !== tokTypes.eof) {\n            state.lastToken = token;\n          }\n        },\n        // Collect comments\n        onComment: (block, text, start, end, startLoc, endLoc) => {\n          if (state.comments) {\n            const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code);\n            state.comments.push(comment);\n          }\n        }\n      }, code);\n      /*\n       * We put all of this data into a symbol property as a way to avoid\n       * potential naming conflicts with future versions of Acorn.\n       */\n\n      this[STATE] = state;\n    }\n\n    tokenize() {\n      do {\n        this.next();\n      } while (this.type !== tokTypes.eof); // Consume the final eof token\n\n\n      this.next();\n      const extra = this[STATE];\n      const tokens = extra.tokens;\n\n      if (extra.comments) {\n        tokens.comments = extra.comments;\n      }\n\n      return tokens;\n    }\n\n    finishNode() {\n      const result = super.finishNode(...arguments);\n      return this[ESPRIMA_FINISH_NODE](result);\n    }\n\n    finishNodeAt() {\n      const result = super.finishNodeAt(...arguments);\n      return this[ESPRIMA_FINISH_NODE](result);\n    }\n\n    parse() {\n      const extra = this[STATE];\n      const program = super.parse();\n      program.sourceType = extra.originalSourceType;\n\n      if (extra.comments) {\n        program.comments = extra.comments;\n      }\n\n      if (extra.tokens) {\n        program.tokens = extra.tokens;\n      }\n      /*\n       * Adjust opening and closing position of program to match Esprima.\n       * Acorn always starts programs at range 0 whereas Esprima starts at the\n       * first AST node's start (the only real difference is when there's leading\n       * whitespace or leading comments). Acorn also counts trailing whitespace\n       * as part of the program whereas Esprima only counts up to the last token.\n       */\n\n\n      if (program.body.length) {\n        const [firstNode] = program.body;\n\n        if (program.range) {\n          program.range[0] = firstNode.range[0];\n        }\n\n        if (program.loc) {\n          program.loc.start = firstNode.loc.start;\n        }\n\n        program.start = firstNode.start;\n      }\n\n      if (extra.lastToken) {\n        if (program.range) {\n          program.range[1] = extra.lastToken.range[1];\n        }\n\n        if (program.loc) {\n          program.loc.end = extra.lastToken.loc.end;\n        }\n\n        program.end = extra.lastToken.end;\n      }\n      /*\n       * https://github.com/eslint/espree/issues/349\n       * Ensure that template elements have correct range information.\n       * This is one location where Acorn produces a different value\n       * for its start and end properties vs. the values present in the\n       * range property. In order to avoid confusion, we set the start\n       * and end properties to the values that are present in range.\n       * This is done here, instead of in finishNode(), because Acorn\n       * uses the values of start and end internally while parsing, making\n       * it dangerous to change those values while parsing is ongoing.\n       * By waiting until the end of parsing, we can safely change these\n       * values without affect any other part of the process.\n       */\n\n\n      this[STATE].templateElements.forEach(templateElement => {\n        const startOffset = -1;\n        const endOffset = templateElement.tail ? 1 : 2;\n        templateElement.start += startOffset;\n        templateElement.end += endOffset;\n\n        if (templateElement.range) {\n          templateElement.range[0] += startOffset;\n          templateElement.range[1] += endOffset;\n        }\n\n        if (templateElement.loc) {\n          templateElement.loc.start.column += startOffset;\n          templateElement.loc.end.column += endOffset;\n        }\n      });\n      return program;\n    }\n\n    parseTopLevel(node) {\n      if (this[STATE].impliedStrict) {\n        this.strict = true;\n      }\n\n      return super.parseTopLevel(node);\n    }\n    /**\n     * Overwrites the default raise method to throw Esprima-style errors.\n     * @param {int} pos The position of the error.\n     * @param {string} message The error message.\n     * @throws {SyntaxError} A syntax error.\n     * @returns {void}\n     */\n\n\n    raise(pos, message) {\n      const loc = Parser.acorn.getLineInfo(this.input, pos);\n      const err = new SyntaxError(message);\n      err.index = pos;\n      err.lineNumber = loc.line;\n      err.column = loc.column + 1; // acorn uses 0-based columns\n\n      throw err;\n    }\n    /**\n     * Overwrites the default raise method to throw Esprima-style errors.\n     * @param {int} pos The position of the error.\n     * @param {string} message The error message.\n     * @throws {SyntaxError} A syntax error.\n     * @returns {void}\n     */\n\n\n    raiseRecoverable(pos, message) {\n      this.raise(pos, message);\n    }\n    /**\n     * Overwrites the default unexpected method to throw Esprima-style errors.\n     * @param {int} pos The position of the error.\n     * @throws {SyntaxError} A syntax error.\n     * @returns {void}\n     */\n\n\n    unexpected(pos) {\n      let message = \"Unexpected token\";\n\n      if (pos !== null && pos !== void 0) {\n        this.pos = pos;\n\n        if (this.options.locations) {\n          while (this.pos < this.lineStart) {\n            this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n            --this.curLine;\n          }\n        }\n\n        this.nextToken();\n      }\n\n      if (this.end > this.start) {\n        message += ` ${this.input.slice(this.start, this.end)}`;\n      }\n\n      this.raise(this.start, message);\n    }\n    /*\n    * Esprima-FB represents JSX strings as tokens called \"JSXText\", but Acorn-JSX\n    * uses regular tt.string without any distinction between this and regular JS\n    * strings. As such, we intercept an attempt to read a JSX string and set a flag\n    * on extra so that when tokens are converted, the next token will be switched\n    * to JSXText via onToken.\n    */\n\n\n    jsx_readString(quote) {\n      // eslint-disable-line camelcase\n      const result = super.jsx_readString(quote);\n\n      if (this.type === tokTypes.string) {\n        this[STATE].jsxAttrValueToken = true;\n      }\n\n      return result;\n    }\n    /**\n     * Performs last-minute Esprima-specific compatibility checks and fixes.\n     * @param {ASTNode} result The node to check.\n     * @returns {ASTNode} The finished node.\n     */\n\n\n    [ESPRIMA_FINISH_NODE](result) {\n      // Acorn doesn't count the opening and closing backticks as part of templates\n      // so we have to adjust ranges/locations appropriately.\n      if (result.type === \"TemplateElement\") {\n        // save template element references to fix start/end later\n        this[STATE].templateElements.push(result);\n      }\n\n      if (result.type.includes(\"Function\") && !result.generator) {\n        result.generator = false;\n      }\n\n      return result;\n    }\n\n  };\n});","map":{"version":3,"names":["TokenTranslator","normalizeOptions","STATE","Symbol","ESPRIMA_FINISH_NODE","convertAcornCommentToEsprimaComment","block","text","start","end","startLoc","endLoc","code","type","slice","comment","value","range","loc","Parser","tokTypes","Object","assign","acorn","acornJsx","Espree","constructor","opts","String","originalSourceType","sourceType","options","ecmaFeatures","tokenTranslator","tokens","state","comments","impliedStrict","ecmaVersion","jsxAttrValueToken","lastToken","templateElements","ranges","locations","allowReserved","allowReturnOutsideFunction","onToken","token","eof","onComment","push","tokenize","next","extra","finishNode","result","finishNodeAt","parse","program","body","length","firstNode","forEach","templateElement","startOffset","endOffset","tail","column","parseTopLevel","node","strict","raise","pos","message","getLineInfo","input","err","SyntaxError","index","lineNumber","line","raiseRecoverable","unexpected","lineStart","lastIndexOf","curLine","nextToken","jsx_readString","quote","string","includes","generator"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/espree/lib/espree.js"],"sourcesContent":["/* eslint-disable no-param-reassign*/\nimport TokenTranslator from \"./token-translator.js\";\nimport { normalizeOptions } from \"./options.js\";\n\n\nconst STATE = Symbol(\"espree's internal state\");\nconst ESPRIMA_FINISH_NODE = Symbol(\"espree's esprimaFinishNode\");\n\n\n/**\n * Converts an Acorn comment to a Esprima comment.\n * @param {boolean} block True if it's a block comment, false if not.\n * @param {string} text The text of the comment.\n * @param {int} start The index at which the comment starts.\n * @param {int} end The index at which the comment ends.\n * @param {Location} startLoc The location at which the comment starts.\n * @param {Location} endLoc The location at which the comment ends.\n * @param {string} code The source code being parsed.\n * @returns {Object} The comment object.\n * @private\n */\nfunction convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code) {\n    let type;\n\n    if (block) {\n        type = \"Block\";\n    } else if (code.slice(start, start + 2) === \"#!\") {\n        type = \"Hashbang\";\n    } else {\n        type = \"Line\";\n    }\n\n    const comment = {\n        type,\n        value: text\n    };\n\n    if (typeof start === \"number\") {\n        comment.start = start;\n        comment.end = end;\n        comment.range = [start, end];\n    }\n\n    if (typeof startLoc === \"object\") {\n        comment.loc = {\n            start: startLoc,\n            end: endLoc\n        };\n    }\n\n    return comment;\n}\n\nexport default () => Parser => {\n    const tokTypes = Object.assign({}, Parser.acorn.tokTypes);\n\n    if (Parser.acornJsx) {\n        Object.assign(tokTypes, Parser.acornJsx.tokTypes);\n    }\n\n    return class Espree extends Parser {\n        constructor(opts, code) {\n            if (typeof opts !== \"object\" || opts === null) {\n                opts = {};\n            }\n            if (typeof code !== \"string\" && !(code instanceof String)) {\n                code = String(code);\n            }\n\n            // save original source type in case of commonjs\n            const originalSourceType = opts.sourceType;\n            const options = normalizeOptions(opts);\n            const ecmaFeatures = options.ecmaFeatures || {};\n            const tokenTranslator =\n                options.tokens === true\n                    ? new TokenTranslator(tokTypes, code)\n                    : null;\n\n            /*\n             * Data that is unique to Espree and is not represented internally\n             * in Acorn.\n             *\n             * For ES2023 hashbangs, Espree will call `onComment()` during the\n             * constructor, so we must define state before having access to\n             * `this`.\n             */\n            const state = {\n                originalSourceType: originalSourceType || options.sourceType,\n                tokens: tokenTranslator ? [] : null,\n                comments: options.comment === true ? [] : null,\n                impliedStrict: ecmaFeatures.impliedStrict === true && options.ecmaVersion >= 5,\n                ecmaVersion: options.ecmaVersion,\n                jsxAttrValueToken: false,\n                lastToken: null,\n                templateElements: []\n            };\n\n            // Initialize acorn parser.\n            super({\n\n                // do not use spread, because we don't want to pass any unknown options to acorn\n                ecmaVersion: options.ecmaVersion,\n                sourceType: options.sourceType,\n                ranges: options.ranges,\n                locations: options.locations,\n                allowReserved: options.allowReserved,\n\n                // Truthy value is true for backward compatibility.\n                allowReturnOutsideFunction: options.allowReturnOutsideFunction,\n\n                // Collect tokens\n                onToken: token => {\n                    if (tokenTranslator) {\n\n                        // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.\n                        tokenTranslator.onToken(token, state);\n                    }\n                    if (token.type !== tokTypes.eof) {\n                        state.lastToken = token;\n                    }\n                },\n\n                // Collect comments\n                onComment: (block, text, start, end, startLoc, endLoc) => {\n                    if (state.comments) {\n                        const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc, code);\n\n                        state.comments.push(comment);\n                    }\n                }\n            }, code);\n\n            /*\n             * We put all of this data into a symbol property as a way to avoid\n             * potential naming conflicts with future versions of Acorn.\n             */\n            this[STATE] = state;\n        }\n\n        tokenize() {\n            do {\n                this.next();\n            } while (this.type !== tokTypes.eof);\n\n            // Consume the final eof token\n            this.next();\n\n            const extra = this[STATE];\n            const tokens = extra.tokens;\n\n            if (extra.comments) {\n                tokens.comments = extra.comments;\n            }\n\n            return tokens;\n        }\n\n        finishNode(...args) {\n            const result = super.finishNode(...args);\n\n            return this[ESPRIMA_FINISH_NODE](result);\n        }\n\n        finishNodeAt(...args) {\n            const result = super.finishNodeAt(...args);\n\n            return this[ESPRIMA_FINISH_NODE](result);\n        }\n\n        parse() {\n            const extra = this[STATE];\n            const program = super.parse();\n\n            program.sourceType = extra.originalSourceType;\n\n            if (extra.comments) {\n                program.comments = extra.comments;\n            }\n            if (extra.tokens) {\n                program.tokens = extra.tokens;\n            }\n\n            /*\n             * Adjust opening and closing position of program to match Esprima.\n             * Acorn always starts programs at range 0 whereas Esprima starts at the\n             * first AST node's start (the only real difference is when there's leading\n             * whitespace or leading comments). Acorn also counts trailing whitespace\n             * as part of the program whereas Esprima only counts up to the last token.\n             */\n            if (program.body.length) {\n                const [firstNode] = program.body;\n\n                if (program.range) {\n                    program.range[0] = firstNode.range[0];\n                }\n                if (program.loc) {\n                    program.loc.start = firstNode.loc.start;\n                }\n                program.start = firstNode.start;\n            }\n            if (extra.lastToken) {\n                if (program.range) {\n                    program.range[1] = extra.lastToken.range[1];\n                }\n                if (program.loc) {\n                    program.loc.end = extra.lastToken.loc.end;\n                }\n                program.end = extra.lastToken.end;\n            }\n\n\n            /*\n             * https://github.com/eslint/espree/issues/349\n             * Ensure that template elements have correct range information.\n             * This is one location where Acorn produces a different value\n             * for its start and end properties vs. the values present in the\n             * range property. In order to avoid confusion, we set the start\n             * and end properties to the values that are present in range.\n             * This is done here, instead of in finishNode(), because Acorn\n             * uses the values of start and end internally while parsing, making\n             * it dangerous to change those values while parsing is ongoing.\n             * By waiting until the end of parsing, we can safely change these\n             * values without affect any other part of the process.\n             */\n            this[STATE].templateElements.forEach(templateElement => {\n                const startOffset = -1;\n                const endOffset = templateElement.tail ? 1 : 2;\n\n                templateElement.start += startOffset;\n                templateElement.end += endOffset;\n\n                if (templateElement.range) {\n                    templateElement.range[0] += startOffset;\n                    templateElement.range[1] += endOffset;\n                }\n\n                if (templateElement.loc) {\n                    templateElement.loc.start.column += startOffset;\n                    templateElement.loc.end.column += endOffset;\n                }\n            });\n\n            return program;\n        }\n\n        parseTopLevel(node) {\n            if (this[STATE].impliedStrict) {\n                this.strict = true;\n            }\n            return super.parseTopLevel(node);\n        }\n\n        /**\n         * Overwrites the default raise method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @param {string} message The error message.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        raise(pos, message) {\n            const loc = Parser.acorn.getLineInfo(this.input, pos);\n            const err = new SyntaxError(message);\n\n            err.index = pos;\n            err.lineNumber = loc.line;\n            err.column = loc.column + 1; // acorn uses 0-based columns\n            throw err;\n        }\n\n        /**\n         * Overwrites the default raise method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @param {string} message The error message.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        raiseRecoverable(pos, message) {\n            this.raise(pos, message);\n        }\n\n        /**\n         * Overwrites the default unexpected method to throw Esprima-style errors.\n         * @param {int} pos The position of the error.\n         * @throws {SyntaxError} A syntax error.\n         * @returns {void}\n         */\n        unexpected(pos) {\n            let message = \"Unexpected token\";\n\n            if (pos !== null && pos !== void 0) {\n                this.pos = pos;\n\n                if (this.options.locations) {\n                    while (this.pos < this.lineStart) {\n                        this.lineStart = this.input.lastIndexOf(\"\\n\", this.lineStart - 2) + 1;\n                        --this.curLine;\n                    }\n                }\n\n                this.nextToken();\n            }\n\n            if (this.end > this.start) {\n                message += ` ${this.input.slice(this.start, this.end)}`;\n            }\n\n            this.raise(this.start, message);\n        }\n\n        /*\n        * Esprima-FB represents JSX strings as tokens called \"JSXText\", but Acorn-JSX\n        * uses regular tt.string without any distinction between this and regular JS\n        * strings. As such, we intercept an attempt to read a JSX string and set a flag\n        * on extra so that when tokens are converted, the next token will be switched\n        * to JSXText via onToken.\n        */\n        jsx_readString(quote) { // eslint-disable-line camelcase\n            const result = super.jsx_readString(quote);\n\n            if (this.type === tokTypes.string) {\n                this[STATE].jsxAttrValueToken = true;\n            }\n            return result;\n        }\n\n        /**\n         * Performs last-minute Esprima-specific compatibility checks and fixes.\n         * @param {ASTNode} result The node to check.\n         * @returns {ASTNode} The finished node.\n         */\n        [ESPRIMA_FINISH_NODE](result) {\n\n            // Acorn doesn't count the opening and closing backticks as part of templates\n            // so we have to adjust ranges/locations appropriately.\n            if (result.type === \"TemplateElement\") {\n\n                // save template element references to fix start/end later\n                this[STATE].templateElements.push(result);\n            }\n\n            if (result.type.includes(\"Function\") && !result.generator) {\n                result.generator = false;\n            }\n\n            return result;\n        }\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}