{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { tidy, util } from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport var executeOp = function executeOp(node, tensorMap, context) {\n  var ops = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : tfOps;\n  switch (node.op) {\n    case 'ConcatV2':\n    case 'Concat':\n      {\n        var n = getParamValue('n', node, tensorMap, context);\n        var axis = getParamValue('axis', node, tensorMap, context);\n        var inputs = getParamValue('tensors', node, tensorMap, context);\n        inputs = inputs.slice(0, n);\n        return [ops.concat(inputs, axis)];\n      }\n    case 'Gather':\n      {\n        var input = getParamValue('x', node, tensorMap, context);\n        var indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(input, ops.cast(indices, 'int32'), 0)];\n      }\n    case 'GatherV2':\n      {\n        var _axis = getParamValue('axis', node, tensorMap, context);\n        var batchDims = getParamValue('batchDims', node, tensorMap, context);\n        var _input = getParamValue('x', node, tensorMap, context);\n        var _indices = getParamValue('indices', node, tensorMap, context);\n        return [ops.gather(_input, ops.cast(_indices, 'int32'), _axis, batchDims)];\n      }\n    case 'Reverse':\n      {\n        var dims = getParamValue('dims', node, tensorMap, context);\n        var _axis2 = [];\n        for (var i = 0; i < dims.length; i++) {\n          if (dims[i]) {\n            _axis2.push(i);\n          }\n        }\n        var _input2 = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(_input2, _axis2)];\n      }\n    case 'ReverseV2':\n      {\n        var _axis3 = getParamValue('axis', node, tensorMap, context);\n        var _input3 = getParamValue('x', node, tensorMap, context);\n        return [ops.reverse(_input3, _axis3)];\n      }\n    case 'Slice':\n      {\n        // tslint:disable-next-line:no-any\n        var begin = getParamValue('begin', node, tensorMap, context);\n        // tslint:disable-next-line:no-any\n        var size = getParamValue('size', node, tensorMap, context);\n        return [ops.slice(getParamValue('x', node, tensorMap, context), begin, size)];\n      }\n    case 'StridedSlice':\n      {\n        var _begin = getParamValue('begin', node, tensorMap, context);\n        var end = getParamValue('end', node, tensorMap, context);\n        var strides = getParamValue('strides', node, tensorMap, context);\n        var beginMask = getParamValue('beginMask', node, tensorMap, context);\n        var endMask = getParamValue('endMask', node, tensorMap, context);\n        var ellipsisMask = getParamValue('ellipsisMask', node, tensorMap, context);\n        var newAxisMask = getParamValue('newAxisMask', node, tensorMap, context);\n        var shrinkAxisMask = getParamValue('shrinkAxisMask', node, tensorMap, context);\n        var tensor = getParamValue('x', node, tensorMap, context);\n        return [ops.stridedSlice(tensor, _begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n      }\n    case 'Pack':\n      {\n        return tidy(function () {\n          var axis = getParamValue('axis', node, tensorMap, context);\n          var tensors = getParamValue('tensors', node, tensorMap, context);\n          // Reshape the tensors to the first tensor's shape if they don't\n          // match.\n          var shape = tensors[0].shape;\n          var squeezedShape = ops.squeeze(tensors[0]).shape;\n          var mapped = tensors.map(function (tensor) {\n            var sameShape = util.arraysEqual(tensor.shape, shape);\n            if (!sameShape && !util.arraysEqual(ops.squeeze(tensor).shape, squeezedShape)) {\n              throw new Error('the input tensors shape does not match');\n            }\n            return sameShape ? tensor : ops.reshape(tensor, shape);\n          });\n          return [ops.stack(mapped, axis)];\n        });\n      }\n    case 'Unpack':\n      {\n        var _axis4 = getParamValue('axis', node, tensorMap, context);\n        var _tensor = getParamValue('tensor', node, tensorMap, context);\n        return ops.unstack(_tensor, _axis4);\n      }\n    case 'Tile':\n      {\n        var reps = getParamValue('reps', node, tensorMap, context);\n        return [ops.tile(getParamValue('x', node, tensorMap, context), reps)];\n      }\n    case 'Split':\n    case 'SplitV':\n      {\n        var _axis5 = getParamValue('axis', node, tensorMap, context);\n        var numOrSizeSplits = getParamValue('numOrSizeSplits', node, tensorMap, context);\n        var _tensor2 = getParamValue('x', node, tensorMap, context);\n        return ops.split(_tensor2, numOrSizeSplits, _axis5);\n      }\n    case 'ScatterNd':\n      {\n        var _indices2 = getParamValue('indices', node, tensorMap, context);\n        var values = getParamValue('values', node, tensorMap, context);\n        var shape = getParamValue('shape', node, tensorMap, context);\n        return [ops.scatterND(_indices2, values, shape)];\n      }\n    case 'GatherNd':\n      {\n        var x = getParamValue('x', node, tensorMap, context);\n        var _indices3 = getParamValue('indices', node, tensorMap, context);\n        return [ops.gatherND(x, _indices3)];\n      }\n    case 'SparseToDense':\n      {\n        var _indices4 = getParamValue('sparseIndices', node, tensorMap, context);\n        var _shape = getParamValue('outputShape', node, tensorMap, context);\n        var sparseValues = getParamValue('sparseValues', node, tensorMap, context);\n        var defaultValue = getParamValue('defaultValue', node, tensorMap, context);\n        return [ops.sparseToDense(_indices4, sparseValues, _shape, sparseValues.dtype === defaultValue.dtype ? defaultValue : ops.cast(defaultValue, sparseValues.dtype))];\n      }\n    default:\n      throw TypeError(\"Node type \".concat(node.op, \" is not implemented\"));\n  }\n};\nexport var CATEGORY = 'slice_join';","map":null,"metadata":{},"sourceType":"module"}