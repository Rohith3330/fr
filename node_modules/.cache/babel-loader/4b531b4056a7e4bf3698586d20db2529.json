{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nclass FunctionSignature {\n  constructor(paramTypes, restType) {\n    this.paramTypes = paramTypes;\n    this.restType = restType;\n    this.parameterTypeIndex = 0;\n    this.hasConsumedArguments = false;\n  }\n\n  static create(checker, tsNode) {\n    var _a;\n\n    const signature = checker.getResolvedSignature(tsNode);\n\n    if (!signature) {\n      return null;\n    }\n\n    const paramTypes = [];\n    let restType = null;\n    const parameters = signature.getParameters();\n\n    for (let i = 0; i < parameters.length; i += 1) {\n      const param = parameters[i];\n      const type = checker.getTypeOfSymbolAtLocation(param, tsNode);\n      const decl = (_a = param.getDeclarations()) === null || _a === void 0 ? void 0 : _a[0];\n\n      if (decl && ts.isParameter(decl) && decl.dotDotDotToken) {\n        // is a rest param\n        if (checker.isArrayType(type)) {\n          restType = {\n            type: checker.getTypeArguments(type)[0],\n            kind: 0\n            /* RestTypeKind.Array */\n            ,\n            index: i\n          };\n        } else if (checker.isTupleType(type)) {\n          restType = {\n            typeArguments: checker.getTypeArguments(type),\n            kind: 1\n            /* RestTypeKind.Tuple */\n            ,\n            index: i\n          };\n        } else {\n          restType = {\n            type,\n            kind: 2\n            /* RestTypeKind.Other */\n            ,\n            index: i\n          };\n        }\n\n        break;\n      }\n\n      paramTypes.push(type);\n    }\n\n    return new this(paramTypes, restType);\n  }\n\n  getNextParameterType() {\n    const index = this.parameterTypeIndex;\n    this.parameterTypeIndex += 1;\n\n    if (index >= this.paramTypes.length || this.hasConsumedArguments) {\n      if (this.restType == null) {\n        return null;\n      }\n\n      switch (this.restType.kind) {\n        case 1\n        /* RestTypeKind.Tuple */\n        :\n          {\n            const typeArguments = this.restType.typeArguments;\n\n            if (this.hasConsumedArguments) {\n              // all types consumed by a rest - just assume it's the last type\n              // there is one edge case where this is wrong, but we ignore it because\n              // it's rare and really complicated to handle\n              // eg: function foo(...a: [number, ...string[], number])\n              return typeArguments[typeArguments.length - 1];\n            }\n\n            const typeIndex = index - this.restType.index;\n\n            if (typeIndex >= typeArguments.length) {\n              return typeArguments[typeArguments.length - 1];\n            }\n\n            return typeArguments[typeIndex];\n          }\n\n        case 0\n        /* RestTypeKind.Array */\n        :\n        case 2\n        /* RestTypeKind.Other */\n        :\n          return this.restType.type;\n      }\n    }\n\n    return this.paramTypes[index];\n  }\n\n  consumeRemainingArguments() {\n    this.hasConsumedArguments = true;\n  }\n\n}\n\nexports.default = util.createRule({\n  name: 'no-unsafe-argument',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow calling a function with a value with type `any`',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    messages: {\n      unsafeArgument: 'Unsafe argument of type `{{sender}}` assigned to a parameter of type `{{receiver}}`.',\n      unsafeTupleSpread: 'Unsafe spread of a tuple type. The argument is of type `{{sender}}` and is assigned to a parameter of type `{{receiver}}`.',\n      unsafeArraySpread: 'Unsafe spread of an `any` array type.',\n      unsafeSpread: 'Unsafe spread of an `any` type.'\n    },\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const {\n      program,\n      esTreeNodeToTSNodeMap\n    } = util.getParserServices(context);\n    const checker = program.getTypeChecker();\n    return {\n      'CallExpression, NewExpression'(node) {\n        if (node.arguments.length === 0) {\n          return;\n        } // ignore any-typed calls as these are caught by no-unsafe-call\n\n\n        if (util.isTypeAnyType(checker.getTypeAtLocation(esTreeNodeToTSNodeMap.get(node.callee)))) {\n          return;\n        }\n\n        const tsNode = esTreeNodeToTSNodeMap.get(node);\n        const signature = FunctionSignature.create(checker, tsNode);\n\n        if (!signature) {\n          return;\n        }\n\n        for (const argument of node.arguments) {\n          switch (argument.type) {\n            // spreads consume\n            case utils_1.AST_NODE_TYPES.SpreadElement:\n              {\n                const spreadArgType = checker.getTypeAtLocation(esTreeNodeToTSNodeMap.get(argument.argument));\n\n                if (util.isTypeAnyType(spreadArgType)) {\n                  // foo(...any)\n                  context.report({\n                    node: argument,\n                    messageId: 'unsafeSpread'\n                  });\n                } else if (util.isTypeAnyArrayType(spreadArgType, checker)) {\n                  // foo(...any[])\n                  // TODO - we could break down the spread and compare the array type against each argument\n                  context.report({\n                    node: argument,\n                    messageId: 'unsafeArraySpread'\n                  });\n                } else if (checker.isTupleType(spreadArgType)) {\n                  // foo(...[tuple1, tuple2])\n                  const spreadTypeArguments = checker.getTypeArguments(spreadArgType);\n\n                  for (const tupleType of spreadTypeArguments) {\n                    const parameterType = signature.getNextParameterType();\n\n                    if (parameterType == null) {\n                      continue;\n                    }\n\n                    const result = util.isUnsafeAssignment(tupleType, parameterType, checker, // we can't pass the individual tuple members in here as this will most likely be a spread variable\n                    // not a spread array\n                    null);\n\n                    if (result) {\n                      context.report({\n                        node: argument,\n                        messageId: 'unsafeTupleSpread',\n                        data: {\n                          sender: checker.typeToString(tupleType),\n                          receiver: checker.typeToString(parameterType)\n                        }\n                      });\n                    }\n                  }\n\n                  if (spreadArgType.target.hasRestElement) {\n                    // the last element was a rest - so all remaining defined arguments can be considered \"consumed\"\n                    // all remaining arguments should be compared against the rest type (if one exists)\n                    signature.consumeRemainingArguments();\n                  }\n                } else {// something that's iterable\n                  // handling this will be pretty complex - so we ignore it for now\n                  // TODO - handle generic iterable case\n                }\n\n                break;\n              }\n\n            default:\n              {\n                const parameterType = signature.getNextParameterType();\n\n                if (parameterType == null) {\n                  continue;\n                }\n\n                const argumentType = checker.getTypeAtLocation(esTreeNodeToTSNodeMap.get(argument));\n                const result = util.isUnsafeAssignment(argumentType, parameterType, checker, argument);\n\n                if (result) {\n                  context.report({\n                    node: argument,\n                    messageId: 'unsafeArgument',\n                    data: {\n                      sender: checker.typeToString(argumentType),\n                      receiver: checker.typeToString(parameterType)\n                    }\n                  });\n                }\n              }\n          }\n        }\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["FunctionSignature","constructor","paramTypes","restType","create","checker","tsNode","signature","getResolvedSignature","parameters","getParameters","i","length","param","type","getTypeOfSymbolAtLocation","decl","getDeclarations","_a","ts","isParameter","dotDotDotToken","isArrayType","getTypeArguments","kind","index","isTupleType","typeArguments","push","getNextParameterType","parameterTypeIndex","hasConsumedArguments","typeIndex","consumeRemainingArguments","exports","util","createRule","name","meta","docs","description","recommended","requiresTypeChecking","messages","unsafeArgument","unsafeTupleSpread","unsafeArraySpread","unsafeSpread","schema","defaultOptions","context","program","esTreeNodeToTSNodeMap","getParserServices","getTypeChecker","node","arguments","isTypeAnyType","getTypeAtLocation","get","callee","argument","utils_1","SpreadElement","spreadArgType","report","messageId","isTypeAnyArrayType","spreadTypeArguments","tupleType","parameterType","result","isUnsafeAssignment","data","sender","typeToString","receiver","target","hasRestElement","argumentType"],"sources":["../../src/rules/no-unsafe-argument.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}