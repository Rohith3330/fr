{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = convertFunctionRest;\n\nvar _core = require(\"@babel/core\");\n\nvar _shadowUtils = require(\"./shadow-utils\");\n\nconst buildRest = _core.template.statement(`\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n`);\n\nconst restIndex = _core.template.expression(`\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n`);\n\nconst restIndexImpure = _core.template.expression(`\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n`);\n\nconst restLength = _core.template.expression(`\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n`);\n\nfunction referencesRest(path, state) {\n  if (path.node.name === state.name) {\n    return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);\n  }\n\n  return false;\n}\n\nconst memberExpressionOptimisationVisitor = {\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {\n      path.skip();\n    }\n  },\n\n  Flow(path) {\n    if (path.isTypeCastExpression()) return;\n    path.skip();\n  },\n\n  Function(path, state) {\n    const oldNoOptimise = state.noOptimise;\n    state.noOptimise = true;\n    path.traverse(memberExpressionOptimisationVisitor, state);\n    state.noOptimise = oldNoOptimise;\n    path.skip();\n  },\n\n  ReferencedIdentifier(path, state) {\n    const {\n      node\n    } = path;\n\n    if (node.name === \"arguments\") {\n      state.deopted = true;\n    }\n\n    if (!referencesRest(path, state)) return;\n\n    if (state.noOptimise) {\n      state.deopted = true;\n    } else {\n      const {\n        parentPath\n      } = path;\n\n      if (parentPath.listKey === \"params\" && parentPath.key < state.offset) {\n        return;\n      }\n\n      if (parentPath.isMemberExpression({\n        object: node\n      })) {\n        const grandparentPath = parentPath.parentPath;\n        const argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({\n          operator: \"delete\"\n        }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);\n\n        if (argsOptEligible) {\n          if (parentPath.node.computed) {\n            if (parentPath.get(\"property\").isBaseType(\"number\")) {\n              state.candidates.push({\n                cause: \"indexGetter\",\n                path\n              });\n              return;\n            }\n          } else if (parentPath.node.property.name === \"length\") {\n            state.candidates.push({\n              cause: \"lengthGetter\",\n              path\n            });\n            return;\n          }\n        }\n      }\n\n      if (state.offset === 0 && parentPath.isSpreadElement()) {\n        const call = parentPath.parentPath;\n\n        if (call.isCallExpression() && call.node.arguments.length === 1) {\n          state.candidates.push({\n            cause: \"argSpread\",\n            path\n          });\n          return;\n        }\n      }\n\n      state.references.push(path);\n    }\n  },\n\n  BindingIdentifier(path, state) {\n    if (referencesRest(path, state)) {\n      state.deopted = true;\n    }\n  }\n\n};\n\nfunction getParamsCount(node) {\n  let count = node.params.length;\n\n  if (count > 0 && _core.types.isIdentifier(node.params[0], {\n    name: \"this\"\n  })) {\n    count -= 1;\n  }\n\n  return count;\n}\n\nfunction hasRest(node) {\n  const length = node.params.length;\n  return length > 0 && _core.types.isRestElement(node.params[length - 1]);\n}\n\nfunction optimiseIndexGetter(path, argsId, offset) {\n  const offsetLiteral = _core.types.numericLiteral(offset);\n\n  let index;\n  const parent = path.parent;\n\n  if (_core.types.isNumericLiteral(parent.property)) {\n    index = _core.types.numericLiteral(parent.property.value + offset);\n  } else if (offset === 0) {\n    index = parent.property;\n  } else {\n    index = _core.types.binaryExpression(\"+\", parent.property, _core.types.cloneNode(offsetLiteral));\n  }\n\n  const {\n    scope,\n    parentPath\n  } = path;\n\n  if (!scope.isPure(index)) {\n    const temp = scope.generateUidIdentifierBasedOnNode(index);\n    scope.push({\n      id: temp,\n      kind: \"var\"\n    });\n    parentPath.replaceWith(restIndexImpure({\n      ARGUMENTS: argsId,\n      OFFSET: offsetLiteral,\n      INDEX: index,\n      REF: _core.types.cloneNode(temp)\n    }));\n  } else {\n    parentPath.replaceWith(restIndex({\n      ARGUMENTS: argsId,\n      OFFSET: offsetLiteral,\n      INDEX: index\n    }));\n    const replacedParentPath = parentPath;\n    const offsetTestPath = replacedParentPath.get(\"test\");\n    const valRes = offsetTestPath.get(\"left\").evaluate();\n\n    if (valRes.confident) {\n      if (valRes.value === true) {\n        replacedParentPath.replaceWith(scope.buildUndefinedNode());\n      } else {\n        offsetTestPath.replaceWith(offsetTestPath.get(\"right\"));\n      }\n    }\n  }\n}\n\nfunction optimiseLengthGetter(path, argsId, offset) {\n  if (offset) {\n    path.parentPath.replaceWith(restLength({\n      ARGUMENTS: argsId,\n      OFFSET: _core.types.numericLiteral(offset)\n    }));\n  } else {\n    path.replaceWith(argsId);\n  }\n}\n\nfunction convertFunctionRest(path) {\n  const {\n    node,\n    scope\n  } = path;\n  if (!hasRest(node)) return false;\n  const restPath = path.get(`params.${node.params.length - 1}.argument`);\n\n  if (!restPath.isIdentifier()) {\n    const shadowedParams = new Set();\n    (0, _shadowUtils.collectShadowedParamsNames)(restPath, path.scope, shadowedParams);\n    let needsIIFE = shadowedParams.size > 0;\n\n    if (!needsIIFE) {\n      const state = {\n        needsOuterBinding: false,\n        scope\n      };\n      restPath.traverse(_shadowUtils.iifeVisitor, state);\n      needsIIFE = state.needsOuterBinding;\n    }\n\n    if (needsIIFE) {\n      path.ensureBlock();\n      path.set(\"body\", _core.types.blockStatement([(0, _shadowUtils.buildScopeIIFE)(shadowedParams, path.node.body)]));\n    }\n  }\n\n  let rest = restPath.node;\n  node.params.pop();\n\n  if (_core.types.isPattern(rest)) {\n    const pattern = rest;\n    rest = scope.generateUidIdentifier(\"ref\");\n\n    const declar = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(pattern, rest)]);\n\n    path.ensureBlock();\n    node.body.body.unshift(declar);\n  } else if (rest.name === \"arguments\") {\n    scope.rename(rest.name);\n  }\n\n  const argsId = _core.types.identifier(\"arguments\");\n\n  const paramsCount = getParamsCount(node);\n  const state = {\n    references: [],\n    offset: paramsCount,\n    argumentsNode: argsId,\n    outerBinding: scope.getBindingIdentifier(rest.name),\n    candidates: [],\n    name: rest.name,\n    deopted: false\n  };\n  path.traverse(memberExpressionOptimisationVisitor, state);\n\n  if (!state.deopted && !state.references.length) {\n    for (const {\n      path,\n      cause\n    } of state.candidates) {\n      const clonedArgsId = _core.types.cloneNode(argsId);\n\n      switch (cause) {\n        case \"indexGetter\":\n          optimiseIndexGetter(path, clonedArgsId, state.offset);\n          break;\n\n        case \"lengthGetter\":\n          optimiseLengthGetter(path, clonedArgsId, state.offset);\n          break;\n\n        default:\n          path.replaceWith(clonedArgsId);\n      }\n    }\n\n    return true;\n  }\n\n  state.references.push(...state.candidates.map(_ref => {\n    let {\n      path\n    } = _ref;\n    return path;\n  }));\n\n  const start = _core.types.numericLiteral(paramsCount);\n\n  const key = scope.generateUidIdentifier(\"key\");\n  const len = scope.generateUidIdentifier(\"len\");\n  let arrKey, arrLen;\n\n  if (paramsCount) {\n    arrKey = _core.types.binaryExpression(\"-\", _core.types.cloneNode(key), _core.types.cloneNode(start));\n    arrLen = _core.types.conditionalExpression(_core.types.binaryExpression(\">\", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.binaryExpression(\"-\", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.numericLiteral(0));\n  } else {\n    arrKey = _core.types.identifier(key.name);\n    arrLen = _core.types.identifier(len.name);\n  }\n\n  const loop = buildRest({\n    ARGUMENTS: argsId,\n    ARRAY_KEY: arrKey,\n    ARRAY_LEN: arrLen,\n    START: start,\n    ARRAY: rest,\n    KEY: key,\n    LEN: len\n  });\n\n  if (state.deopted) {\n    node.body.body.unshift(loop);\n  } else {\n    let target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();\n    target.findParent(path => {\n      if (path.isLoop()) {\n        target = path;\n      } else {\n        return path.isFunction();\n      }\n    });\n    target.insertBefore(loop);\n  }\n\n  return true;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","convertFunctionRest","_core","require","_shadowUtils","buildRest","template","statement","restIndex","expression","restIndexImpure","restLength","referencesRest","path","state","node","name","scope","bindingIdentifierEquals","outerBinding","memberExpressionOptimisationVisitor","Scope","skip","Flow","isTypeCastExpression","Function","oldNoOptimise","noOptimise","traverse","ReferencedIdentifier","deopted","parentPath","listKey","key","offset","isMemberExpression","object","grandparentPath","argsOptEligible","isAssignmentExpression","left","isLVal","isForXStatement","isUpdateExpression","isUnaryExpression","operator","isCallExpression","isNewExpression","callee","computed","get","isBaseType","candidates","push","cause","property","isSpreadElement","call","arguments","length","references","BindingIdentifier","getParamsCount","count","params","types","isIdentifier","hasRest","isRestElement","optimiseIndexGetter","argsId","offsetLiteral","numericLiteral","index","parent","isNumericLiteral","binaryExpression","cloneNode","isPure","temp","generateUidIdentifierBasedOnNode","id","kind","replaceWith","ARGUMENTS","OFFSET","INDEX","REF","replacedParentPath","offsetTestPath","valRes","evaluate","confident","buildUndefinedNode","optimiseLengthGetter","restPath","shadowedParams","Set","collectShadowedParamsNames","needsIIFE","size","needsOuterBinding","iifeVisitor","ensureBlock","set","blockStatement","buildScopeIIFE","body","rest","pop","isPattern","pattern","generateUidIdentifier","declar","variableDeclaration","variableDeclarator","unshift","rename","identifier","paramsCount","argumentsNode","getBindingIdentifier","clonedArgsId","map","start","len","arrKey","arrLen","conditionalExpression","loop","ARRAY_KEY","ARRAY_LEN","START","ARRAY","KEY","LEN","target","getEarliestCommonAncestorFrom","getStatementParent","findParent","isLoop","isFunction","insertBefore"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/plugin-transform-parameters/lib/rest.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = convertFunctionRest;\n\nvar _core = require(\"@babel/core\");\n\nvar _shadowUtils = require(\"./shadow-utils\");\n\nconst buildRest = _core.template.statement(`\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n`);\n\nconst restIndex = _core.template.expression(`\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n`);\n\nconst restIndexImpure = _core.template.expression(`\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n`);\n\nconst restLength = _core.template.expression(`\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n`);\n\nfunction referencesRest(path, state) {\n  if (path.node.name === state.name) {\n    return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);\n  }\n\n  return false;\n}\n\nconst memberExpressionOptimisationVisitor = {\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {\n      path.skip();\n    }\n  },\n\n  Flow(path) {\n    if (path.isTypeCastExpression()) return;\n    path.skip();\n  },\n\n  Function(path, state) {\n    const oldNoOptimise = state.noOptimise;\n    state.noOptimise = true;\n    path.traverse(memberExpressionOptimisationVisitor, state);\n    state.noOptimise = oldNoOptimise;\n    path.skip();\n  },\n\n  ReferencedIdentifier(path, state) {\n    const {\n      node\n    } = path;\n\n    if (node.name === \"arguments\") {\n      state.deopted = true;\n    }\n\n    if (!referencesRest(path, state)) return;\n\n    if (state.noOptimise) {\n      state.deopted = true;\n    } else {\n      const {\n        parentPath\n      } = path;\n\n      if (parentPath.listKey === \"params\" && parentPath.key < state.offset) {\n        return;\n      }\n\n      if (parentPath.isMemberExpression({\n        object: node\n      })) {\n        const grandparentPath = parentPath.parentPath;\n        const argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({\n          operator: \"delete\"\n        }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);\n\n        if (argsOptEligible) {\n          if (parentPath.node.computed) {\n            if (parentPath.get(\"property\").isBaseType(\"number\")) {\n              state.candidates.push({\n                cause: \"indexGetter\",\n                path\n              });\n              return;\n            }\n          } else if (parentPath.node.property.name === \"length\") {\n            state.candidates.push({\n              cause: \"lengthGetter\",\n              path\n            });\n            return;\n          }\n        }\n      }\n\n      if (state.offset === 0 && parentPath.isSpreadElement()) {\n        const call = parentPath.parentPath;\n\n        if (call.isCallExpression() && call.node.arguments.length === 1) {\n          state.candidates.push({\n            cause: \"argSpread\",\n            path\n          });\n          return;\n        }\n      }\n\n      state.references.push(path);\n    }\n  },\n\n  BindingIdentifier(path, state) {\n    if (referencesRest(path, state)) {\n      state.deopted = true;\n    }\n  }\n\n};\n\nfunction getParamsCount(node) {\n  let count = node.params.length;\n\n  if (count > 0 && _core.types.isIdentifier(node.params[0], {\n    name: \"this\"\n  })) {\n    count -= 1;\n  }\n\n  return count;\n}\n\nfunction hasRest(node) {\n  const length = node.params.length;\n  return length > 0 && _core.types.isRestElement(node.params[length - 1]);\n}\n\nfunction optimiseIndexGetter(path, argsId, offset) {\n  const offsetLiteral = _core.types.numericLiteral(offset);\n\n  let index;\n  const parent = path.parent;\n\n  if (_core.types.isNumericLiteral(parent.property)) {\n    index = _core.types.numericLiteral(parent.property.value + offset);\n  } else if (offset === 0) {\n    index = parent.property;\n  } else {\n    index = _core.types.binaryExpression(\"+\", parent.property, _core.types.cloneNode(offsetLiteral));\n  }\n\n  const {\n    scope,\n    parentPath\n  } = path;\n\n  if (!scope.isPure(index)) {\n    const temp = scope.generateUidIdentifierBasedOnNode(index);\n    scope.push({\n      id: temp,\n      kind: \"var\"\n    });\n    parentPath.replaceWith(restIndexImpure({\n      ARGUMENTS: argsId,\n      OFFSET: offsetLiteral,\n      INDEX: index,\n      REF: _core.types.cloneNode(temp)\n    }));\n  } else {\n    parentPath.replaceWith(restIndex({\n      ARGUMENTS: argsId,\n      OFFSET: offsetLiteral,\n      INDEX: index\n    }));\n    const replacedParentPath = parentPath;\n    const offsetTestPath = replacedParentPath.get(\"test\");\n    const valRes = offsetTestPath.get(\"left\").evaluate();\n\n    if (valRes.confident) {\n      if (valRes.value === true) {\n        replacedParentPath.replaceWith(scope.buildUndefinedNode());\n      } else {\n        offsetTestPath.replaceWith(offsetTestPath.get(\"right\"));\n      }\n    }\n  }\n}\n\nfunction optimiseLengthGetter(path, argsId, offset) {\n  if (offset) {\n    path.parentPath.replaceWith(restLength({\n      ARGUMENTS: argsId,\n      OFFSET: _core.types.numericLiteral(offset)\n    }));\n  } else {\n    path.replaceWith(argsId);\n  }\n}\n\nfunction convertFunctionRest(path) {\n  const {\n    node,\n    scope\n  } = path;\n  if (!hasRest(node)) return false;\n  const restPath = path.get(`params.${node.params.length - 1}.argument`);\n\n  if (!restPath.isIdentifier()) {\n    const shadowedParams = new Set();\n    (0, _shadowUtils.collectShadowedParamsNames)(restPath, path.scope, shadowedParams);\n    let needsIIFE = shadowedParams.size > 0;\n\n    if (!needsIIFE) {\n      const state = {\n        needsOuterBinding: false,\n        scope\n      };\n      restPath.traverse(_shadowUtils.iifeVisitor, state);\n      needsIIFE = state.needsOuterBinding;\n    }\n\n    if (needsIIFE) {\n      path.ensureBlock();\n      path.set(\"body\", _core.types.blockStatement([(0, _shadowUtils.buildScopeIIFE)(shadowedParams, path.node.body)]));\n    }\n  }\n\n  let rest = restPath.node;\n  node.params.pop();\n\n  if (_core.types.isPattern(rest)) {\n    const pattern = rest;\n    rest = scope.generateUidIdentifier(\"ref\");\n\n    const declar = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(pattern, rest)]);\n\n    path.ensureBlock();\n    node.body.body.unshift(declar);\n  } else if (rest.name === \"arguments\") {\n    scope.rename(rest.name);\n  }\n\n  const argsId = _core.types.identifier(\"arguments\");\n\n  const paramsCount = getParamsCount(node);\n  const state = {\n    references: [],\n    offset: paramsCount,\n    argumentsNode: argsId,\n    outerBinding: scope.getBindingIdentifier(rest.name),\n    candidates: [],\n    name: rest.name,\n    deopted: false\n  };\n  path.traverse(memberExpressionOptimisationVisitor, state);\n\n  if (!state.deopted && !state.references.length) {\n    for (const {\n      path,\n      cause\n    } of state.candidates) {\n      const clonedArgsId = _core.types.cloneNode(argsId);\n\n      switch (cause) {\n        case \"indexGetter\":\n          optimiseIndexGetter(path, clonedArgsId, state.offset);\n          break;\n\n        case \"lengthGetter\":\n          optimiseLengthGetter(path, clonedArgsId, state.offset);\n          break;\n\n        default:\n          path.replaceWith(clonedArgsId);\n      }\n    }\n\n    return true;\n  }\n\n  state.references.push(...state.candidates.map(({\n    path\n  }) => path));\n\n  const start = _core.types.numericLiteral(paramsCount);\n\n  const key = scope.generateUidIdentifier(\"key\");\n  const len = scope.generateUidIdentifier(\"len\");\n  let arrKey, arrLen;\n\n  if (paramsCount) {\n    arrKey = _core.types.binaryExpression(\"-\", _core.types.cloneNode(key), _core.types.cloneNode(start));\n    arrLen = _core.types.conditionalExpression(_core.types.binaryExpression(\">\", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.binaryExpression(\"-\", _core.types.cloneNode(len), _core.types.cloneNode(start)), _core.types.numericLiteral(0));\n  } else {\n    arrKey = _core.types.identifier(key.name);\n    arrLen = _core.types.identifier(len.name);\n  }\n\n  const loop = buildRest({\n    ARGUMENTS: argsId,\n    ARRAY_KEY: arrKey,\n    ARRAY_LEN: arrLen,\n    START: start,\n    ARRAY: rest,\n    KEY: key,\n    LEN: len\n  });\n\n  if (state.deopted) {\n    node.body.body.unshift(loop);\n  } else {\n    let target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();\n    target.findParent(path => {\n      if (path.isLoop()) {\n        target = path;\n      } else {\n        return path.isFunction();\n      }\n    });\n    target.insertBefore(loop);\n  }\n\n  return true;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}