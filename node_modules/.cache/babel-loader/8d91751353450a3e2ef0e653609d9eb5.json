{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst code_1 = require(\"../code\");\n\nexports.error = {\n  message: _ref => {\n    let {\n      params: {\n        property,\n        depsCount,\n        deps\n      }\n    } = _ref;\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\";\n    return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        property,\n        depsCount,\n        deps,\n        missingProperty\n      }\n    } = _ref2;\n    return (0, codegen_1._)`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`;\n  } // TODO change to reference\n\n};\nconst def = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error: exports.error,\n\n  code(cxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt);\n    validatePropertyDeps(cxt, propDeps);\n    validateSchemaDeps(cxt, schDeps);\n  }\n\n};\n\nfunction splitDependencies(_ref3) {\n  let {\n    schema\n  } = _ref3;\n  const propertyDeps = {};\n  const schemaDeps = {};\n\n  for (const key in schema) {\n    if (key === \"__proto__\") continue;\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;\n    deps[key] = schema[key];\n  }\n\n  return [propertyDeps, schemaDeps];\n}\n\nfunction validatePropertyDeps(cxt) {\n  let propertyDeps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cxt.schema;\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  if (Object.keys(propertyDeps).length === 0) return;\n  const missing = gen.let(\"missing\");\n\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop];\n    if (deps.length === 0) continue;\n    const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \")\n    });\n\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          (0, code_1.checkReportMissingProp)(cxt, depProp);\n        }\n      });\n    } else {\n      gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);\n      (0, code_1.reportMissingProp)(cxt, missing);\n      gen.else();\n    }\n  }\n}\n\nexports.validatePropertyDeps = validatePropertyDeps;\n\nfunction validateSchemaDeps(cxt) {\n  let schemaDeps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : cxt.schema;\n  const {\n    gen,\n    data,\n    keyword,\n    it\n  } = cxt;\n  const valid = gen.name(\"valid\");\n\n  for (const prop in schemaDeps) {\n    if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop])) continue;\n    gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => {\n      const schCxt = cxt.subschema({\n        keyword,\n        schemaProp: prop\n      }, valid);\n      cxt.mergeValidEvaluated(schCxt, valid);\n    }, () => gen.var(valid, true) // TODO var\n    );\n    cxt.ok(valid);\n  }\n}\n\nexports.validateSchemaDeps = validateSchemaDeps;\nexports.default = def;","map":{"version":3,"mappings":"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","names":["exports","message","params","property","depsCount","deps","property_ies","missingProperty","def","keyword","type","schemaType","error","code","cxt","propDeps","schDeps","splitDependencies","validatePropertyDeps","validateSchemaDeps","schema","propertyDeps","schemaDeps","key","Array","isArray","gen","data","it","Object","keys","length","missing","let","prop","hasProperty","opts","ownProperties","setParams","join","allErrors","if","depProp","else","valid","name","schCxt","subschema","schemaProp","mergeValidEvaluated","var","ok"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-webpack-plugin\\node_modules\\ajv\\lib\\vocabularies\\applicator\\dependencies.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}