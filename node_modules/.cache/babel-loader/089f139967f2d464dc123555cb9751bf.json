{"ast":null,"code":"'use strict';\n\nconst {\n  stringify\n} = require('postcss-value-parser');\n/**\n * @param {string[]} list\n * @return {string[]}\n */\n\n\nfunction uniqueFontFamilies(list) {\n  return list.filter((item, i) => {\n    if (item.toLowerCase() === 'monospace') {\n      return true;\n    }\n\n    return i === list.indexOf(item);\n  });\n}\n\nconst globalKeywords = ['inherit', 'initial', 'unset'];\nconst genericFontFamilykeywords = new Set(['sans-serif', 'serif', 'fantasy', 'cursive', 'monospace', 'system-ui']);\n/**\n * @param {string} value\n * @param {number} length\n * @return {string[]}\n */\n\nfunction makeArray(value, length) {\n  let array = [];\n\n  while (length--) {\n    array[length] = value;\n  }\n\n  return array;\n} // eslint-disable-next-line no-useless-escape\n\n\nconst regexSimpleEscapeCharacters = /[ !\"#$%&'()*+,.\\/;<=>?@\\[\\\\\\]^`{|}~]/;\n/**\n * @param {string} string\n * @param {boolean} escapeForString\n * @return {string}\n */\n\nfunction escape(string, escapeForString) {\n  let counter = 0;\n  let character;\n  let charCode;\n  let value;\n  let output = '';\n\n  while (counter < string.length) {\n    character = string.charAt(counter++);\n    charCode = character.charCodeAt(0); // \\r is already tokenized away at this point\n    // `:` can be escaped as `\\:`, but that fails in IE < 8\n\n    if (!escapeForString && /[\\t\\n\\v\\f:]/.test(character)) {\n      value = '\\\\' + charCode.toString(16) + ' ';\n    } else if (!escapeForString && regexSimpleEscapeCharacters.test(character)) {\n      value = '\\\\' + character;\n    } else {\n      value = character;\n    }\n\n    output += value;\n  }\n\n  if (!escapeForString) {\n    if (/^-[-\\d]/.test(output)) {\n      output = '\\\\-' + output.slice(1);\n    }\n\n    const firstChar = string.charAt(0);\n\n    if (/\\d/.test(firstChar)) {\n      output = '\\\\3' + firstChar + ' ' + output.slice(1);\n    }\n  }\n\n  return output;\n}\n\nconst regexKeyword = new RegExp([...genericFontFamilykeywords].concat(globalKeywords).join('|'), 'i');\nconst regexInvalidIdentifier = /^(-?\\d|--)/;\nconst regexSpaceAtStart = /^\\x20/;\nconst regexWhitespace = /[\\t\\n\\f\\r\\x20]/g;\nconst regexIdentifierCharacter = /^[a-zA-Z\\d\\xa0-\\uffff_-]+$/;\nconst regexConsecutiveSpaces = /(\\\\(?:[a-fA-F0-9]{1,6}\\x20|\\x20))?(\\x20{2,})/g;\nconst regexTrailingEscape = /\\\\[a-fA-F0-9]{0,6}\\x20$/;\nconst regexTrailingSpace = /\\x20$/;\n/**\n * @param {string} string\n * @return {string}\n */\n\nfunction escapeIdentifierSequence(string) {\n  let identifiers = string.split(regexWhitespace);\n  let index = 0;\n  /** @type {string[] | string} */\n\n  let result = [];\n  let escapeResult;\n\n  while (index < identifiers.length) {\n    let subString = identifiers[index++];\n\n    if (subString === '') {\n      result.push(subString);\n      continue;\n    }\n\n    escapeResult = escape(subString, false);\n\n    if (regexIdentifierCharacter.test(subString)) {\n      // the font family name part consists of allowed characters exclusively\n      if (regexInvalidIdentifier.test(subString)) {\n        // the font family name part starts with two hyphens, a digit, or a\n        // hyphen followed by a digit\n        if (index === 1) {\n          // if this is the first item\n          result.push(escapeResult);\n        } else {\n          // if it’s not the first item, we can simply escape the space\n          // between the two identifiers to merge them into a single\n          // identifier rather than escaping the start characters of the\n          // second identifier\n          result[index - 2] += '\\\\';\n          result.push(escape(subString, true));\n        }\n      } else {\n        // the font family name part doesn’t start with two hyphens, a digit,\n        // or a hyphen followed by a digit\n        result.push(escapeResult);\n      }\n    } else {\n      // the font family name part contains invalid identifier characters\n      result.push(escapeResult);\n    }\n  }\n\n  result = result.join(' ').replace(regexConsecutiveSpaces, ($0, $1, $2) => {\n    const spaceCount = $2.length;\n    const escapesNeeded = Math.floor(spaceCount / 2);\n    const array = makeArray('\\\\ ', escapesNeeded);\n\n    if (spaceCount % 2) {\n      array[escapesNeeded - 1] += '\\\\ ';\n    }\n\n    return ($1 || '') + ' ' + array.join(' ');\n  }); // Escape trailing spaces unless they’re already part of an escape\n\n  if (regexTrailingSpace.test(result) && !regexTrailingEscape.test(result)) {\n    result = result.replace(regexTrailingSpace, '\\\\ ');\n  }\n\n  if (regexSpaceAtStart.test(result)) {\n    result = '\\\\ ' + result.slice(1);\n  }\n\n  return result;\n}\n/**\n * @param {import('postcss-value-parser').Node[]} nodes\n * @param {import('../index').Options} opts\n * @return {import('postcss-value-parser').WordNode[]}\n */\n\n\nmodule.exports = function (nodes, opts) {\n  /** @type {import('postcss-value-parser').Node[]} */\n  const family = [];\n  /** @type {import('postcss-value-parser').WordNode | null} */\n\n  let last = null;\n  let i, max;\n  nodes.forEach((node, index, arr) => {\n    if (node.type === 'string' || node.type === 'function') {\n      family.push(node);\n    } else if (node.type === 'word') {\n      if (!last) {\n        last =\n        /** @type {import('postcss-value-parser').WordNode} */\n        {\n          type: 'word',\n          value: ''\n        };\n        family.push(last);\n      }\n\n      last.value += node.value;\n    } else if (node.type === 'space') {\n      if (last && index !== arr.length - 1) {\n        last.value += ' ';\n      }\n    } else {\n      last = null;\n    }\n  });\n  let normalizedFamilies = family.map(node => {\n    if (node.type === 'string') {\n      const isKeyword = regexKeyword.test(node.value);\n\n      if (!opts.removeQuotes || isKeyword || /[0-9]/.test(node.value.slice(0, 1))) {\n        return stringify(node);\n      }\n\n      let escaped = escapeIdentifierSequence(node.value);\n\n      if (escaped.length < node.value.length + 2) {\n        return escaped;\n      }\n    }\n\n    return stringify(node);\n  });\n\n  if (opts.removeAfterKeyword) {\n    for (i = 0, max = normalizedFamilies.length; i < max; i += 1) {\n      if (genericFontFamilykeywords.has(normalizedFamilies[i].toLowerCase())) {\n        normalizedFamilies = normalizedFamilies.slice(0, i + 1);\n        break;\n      }\n    }\n  }\n\n  if (opts.removeDuplicates) {\n    normalizedFamilies = uniqueFontFamilies(normalizedFamilies);\n  }\n\n  return [\n  /** @type {import('postcss-value-parser').WordNode} */\n  {\n    type: 'word',\n    value: normalizedFamilies.join()\n  }];\n};","map":{"version":3,"names":["stringify","require","uniqueFontFamilies","list","filter","item","i","toLowerCase","indexOf","globalKeywords","genericFontFamilykeywords","Set","makeArray","value","length","array","regexSimpleEscapeCharacters","escape","string","escapeForString","counter","character","charCode","output","charAt","charCodeAt","test","toString","slice","firstChar","regexKeyword","RegExp","concat","join","regexInvalidIdentifier","regexSpaceAtStart","regexWhitespace","regexIdentifierCharacter","regexConsecutiveSpaces","regexTrailingEscape","regexTrailingSpace","escapeIdentifierSequence","identifiers","split","index","result","escapeResult","subString","push","replace","$0","$1","$2","spaceCount","escapesNeeded","Math","floor","module","exports","nodes","opts","family","last","max","forEach","node","arr","type","normalizedFamilies","map","isKeyword","removeQuotes","escaped","removeAfterKeyword","has","removeDuplicates"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-minify-font-values/src/lib/minify-family.js"],"sourcesContent":["'use strict';\nconst { stringify } = require('postcss-value-parser');\n\n/**\n * @param {string[]} list\n * @return {string[]}\n */\nfunction uniqueFontFamilies(list) {\n  return list.filter((item, i) => {\n    if (item.toLowerCase() === 'monospace') {\n      return true;\n    }\n    return i === list.indexOf(item);\n  });\n}\n\nconst globalKeywords = ['inherit', 'initial', 'unset'];\nconst genericFontFamilykeywords = new Set([\n  'sans-serif',\n  'serif',\n  'fantasy',\n  'cursive',\n  'monospace',\n  'system-ui',\n]);\n\n/**\n * @param {string} value\n * @param {number} length\n * @return {string[]}\n */\nfunction makeArray(value, length) {\n  let array = [];\n  while (length--) {\n    array[length] = value;\n  }\n  return array;\n}\n\n// eslint-disable-next-line no-useless-escape\nconst regexSimpleEscapeCharacters = /[ !\"#$%&'()*+,.\\/;<=>?@\\[\\\\\\]^`{|}~]/;\n\n/**\n * @param {string} string\n * @param {boolean} escapeForString\n * @return {string}\n */\nfunction escape(string, escapeForString) {\n  let counter = 0;\n  let character;\n  let charCode;\n  let value;\n  let output = '';\n\n  while (counter < string.length) {\n    character = string.charAt(counter++);\n    charCode = character.charCodeAt(0);\n\n    // \\r is already tokenized away at this point\n    // `:` can be escaped as `\\:`, but that fails in IE < 8\n    if (!escapeForString && /[\\t\\n\\v\\f:]/.test(character)) {\n      value = '\\\\' + charCode.toString(16) + ' ';\n    } else if (\n      !escapeForString &&\n      regexSimpleEscapeCharacters.test(character)\n    ) {\n      value = '\\\\' + character;\n    } else {\n      value = character;\n    }\n\n    output += value;\n  }\n\n  if (!escapeForString) {\n    if (/^-[-\\d]/.test(output)) {\n      output = '\\\\-' + output.slice(1);\n    }\n\n    const firstChar = string.charAt(0);\n\n    if (/\\d/.test(firstChar)) {\n      output = '\\\\3' + firstChar + ' ' + output.slice(1);\n    }\n  }\n\n  return output;\n}\n\nconst regexKeyword = new RegExp(\n  [...genericFontFamilykeywords].concat(globalKeywords).join('|'),\n  'i'\n);\nconst regexInvalidIdentifier = /^(-?\\d|--)/;\nconst regexSpaceAtStart = /^\\x20/;\nconst regexWhitespace = /[\\t\\n\\f\\r\\x20]/g;\nconst regexIdentifierCharacter = /^[a-zA-Z\\d\\xa0-\\uffff_-]+$/;\nconst regexConsecutiveSpaces = /(\\\\(?:[a-fA-F0-9]{1,6}\\x20|\\x20))?(\\x20{2,})/g;\nconst regexTrailingEscape = /\\\\[a-fA-F0-9]{0,6}\\x20$/;\nconst regexTrailingSpace = /\\x20$/;\n\n/**\n * @param {string} string\n * @return {string}\n */\nfunction escapeIdentifierSequence(string) {\n  let identifiers = string.split(regexWhitespace);\n  let index = 0;\n  /** @type {string[] | string} */\n  let result = [];\n  let escapeResult;\n\n  while (index < identifiers.length) {\n    let subString = identifiers[index++];\n\n    if (subString === '') {\n      result.push(subString);\n      continue;\n    }\n\n    escapeResult = escape(subString, false);\n\n    if (regexIdentifierCharacter.test(subString)) {\n      // the font family name part consists of allowed characters exclusively\n      if (regexInvalidIdentifier.test(subString)) {\n        // the font family name part starts with two hyphens, a digit, or a\n        // hyphen followed by a digit\n        if (index === 1) {\n          // if this is the first item\n          result.push(escapeResult);\n        } else {\n          // if it’s not the first item, we can simply escape the space\n          // between the two identifiers to merge them into a single\n          // identifier rather than escaping the start characters of the\n          // second identifier\n          result[index - 2] += '\\\\';\n          result.push(escape(subString, true));\n        }\n      } else {\n        // the font family name part doesn’t start with two hyphens, a digit,\n        // or a hyphen followed by a digit\n        result.push(escapeResult);\n      }\n    } else {\n      // the font family name part contains invalid identifier characters\n      result.push(escapeResult);\n    }\n  }\n\n  result = result.join(' ').replace(regexConsecutiveSpaces, ($0, $1, $2) => {\n    const spaceCount = $2.length;\n    const escapesNeeded = Math.floor(spaceCount / 2);\n    const array = makeArray('\\\\ ', escapesNeeded);\n\n    if (spaceCount % 2) {\n      array[escapesNeeded - 1] += '\\\\ ';\n    }\n\n    return ($1 || '') + ' ' + array.join(' ');\n  });\n\n  // Escape trailing spaces unless they’re already part of an escape\n  if (regexTrailingSpace.test(result) && !regexTrailingEscape.test(result)) {\n    result = result.replace(regexTrailingSpace, '\\\\ ');\n  }\n\n  if (regexSpaceAtStart.test(result)) {\n    result = '\\\\ ' + result.slice(1);\n  }\n\n  return result;\n}\n/**\n * @param {import('postcss-value-parser').Node[]} nodes\n * @param {import('../index').Options} opts\n * @return {import('postcss-value-parser').WordNode[]}\n */\nmodule.exports = function (nodes, opts) {\n  /** @type {import('postcss-value-parser').Node[]} */\n  const family = [];\n  /** @type {import('postcss-value-parser').WordNode | null} */\n  let last = null;\n  let i, max;\n\n  nodes.forEach((node, index, arr) => {\n    if (node.type === 'string' || node.type === 'function') {\n      family.push(node);\n    } else if (node.type === 'word') {\n      if (!last) {\n        last = /** @type {import('postcss-value-parser').WordNode} */ ({\n          type: 'word',\n          value: '',\n        });\n        family.push(last);\n      }\n\n      last.value += node.value;\n    } else if (node.type === 'space') {\n      if (last && index !== arr.length - 1) {\n        last.value += ' ';\n      }\n    } else {\n      last = null;\n    }\n  });\n\n  let normalizedFamilies = family.map((node) => {\n    if (node.type === 'string') {\n      const isKeyword = regexKeyword.test(node.value);\n\n      if (\n        !opts.removeQuotes ||\n        isKeyword ||\n        /[0-9]/.test(node.value.slice(0, 1))\n      ) {\n        return stringify(node);\n      }\n\n      let escaped = escapeIdentifierSequence(node.value);\n\n      if (escaped.length < node.value.length + 2) {\n        return escaped;\n      }\n    }\n\n    return stringify(node);\n  });\n\n  if (opts.removeAfterKeyword) {\n    for (i = 0, max = normalizedFamilies.length; i < max; i += 1) {\n      if (genericFontFamilykeywords.has(normalizedFamilies[i].toLowerCase())) {\n        normalizedFamilies = normalizedFamilies.slice(0, i + 1);\n        break;\n      }\n    }\n  }\n\n  if (opts.removeDuplicates) {\n    normalizedFamilies = uniqueFontFamilies(normalizedFamilies);\n  }\n\n  return [\n    /** @type {import('postcss-value-parser').WordNode} */ ({\n      type: 'word',\n      value: normalizedFamilies.join(),\n    }),\n  ];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}