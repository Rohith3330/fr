{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'no-shadow',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow variable declarations from shadowing variables declared in the outer scope',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        builtinGlobals: {\n          type: 'boolean'\n        },\n        hoist: {\n          enum: ['all', 'functions', 'never']\n        },\n        allow: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n        ignoreOnInitialization: {\n          type: 'boolean'\n        },\n        ignoreTypeValueShadow: {\n          type: 'boolean'\n        },\n        ignoreFunctionTypeParameterNameValueShadow: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      noShadow: \"'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.\",\n      noShadowGlobal: \"'{{name}}' is already a global variable.\"\n    }\n  },\n  defaultOptions: [{\n    allow: [],\n    builtinGlobals: false,\n    hoist: 'functions',\n    ignoreOnInitialization: false,\n    ignoreTypeValueShadow: true,\n    ignoreFunctionTypeParameterNameValueShadow: true\n  }],\n\n  create(context, _ref) {\n    let [options] = _ref;\n\n    /**\n     * Check if a scope is a TypeScript module augmenting the global namespace.\n     */\n    function isGlobalAugmentation(scope) {\n      return scope.type === scope_manager_1.ScopeType.tsModule && !!scope.block.global || !!scope.upper && isGlobalAugmentation(scope.upper);\n    }\n    /**\n     * Check if variable is a `this` parameter.\n     */\n\n\n    function isThisParam(variable) {\n      return variable.defs[0].type === scope_manager_1.DefinitionType.Parameter && variable.name === 'this';\n    }\n\n    function isTypeImport(definition) {\n      return (definition === null || definition === void 0 ? void 0 : definition.type) === scope_manager_1.DefinitionType.ImportBinding && (definition.parent.importKind === 'type' || definition.node.type === utils_1.AST_NODE_TYPES.ImportSpecifier && definition.node.importKind === 'type');\n    }\n\n    function isTypeValueShadow(variable, shadowed) {\n      if (options.ignoreTypeValueShadow !== true) {\n        return false;\n      }\n\n      if (!('isValueVariable' in variable)) {\n        // this shouldn't happen...\n        return false;\n      }\n\n      const [firstDefinition] = shadowed.defs;\n      const isShadowedValue = !('isValueVariable' in shadowed) || !firstDefinition || !isTypeImport(firstDefinition) && shadowed.isValueVariable;\n      return variable.isValueVariable !== isShadowedValue;\n    }\n\n    function isFunctionTypeParameterNameValueShadow(variable, shadowed) {\n      if (options.ignoreFunctionTypeParameterNameValueShadow !== true) {\n        return false;\n      }\n\n      if (!('isValueVariable' in variable)) {\n        // this shouldn't happen...\n        return false;\n      }\n\n      const isShadowedValue = 'isValueVariable' in shadowed ? shadowed.isValueVariable : true;\n\n      if (!isShadowedValue) {\n        return false;\n      }\n\n      const id = variable.identifiers[0];\n      return util.isFunctionType(id.parent);\n    }\n\n    function isGenericOfStaticMethod(variable) {\n      if (!('isTypeVariable' in variable)) {\n        // this shouldn't happen...\n        return false;\n      }\n\n      if (!variable.isTypeVariable) {\n        return false;\n      }\n\n      if (variable.identifiers.length === 0) {\n        return false;\n      }\n\n      const typeParameter = variable.identifiers[0].parent;\n\n      if ((typeParameter === null || typeParameter === void 0 ? void 0 : typeParameter.type) !== utils_1.AST_NODE_TYPES.TSTypeParameter) {\n        return false;\n      }\n\n      const typeParameterDecl = typeParameter.parent;\n\n      if ((typeParameterDecl === null || typeParameterDecl === void 0 ? void 0 : typeParameterDecl.type) !== utils_1.AST_NODE_TYPES.TSTypeParameterDeclaration) {\n        return false;\n      }\n\n      const functionExpr = typeParameterDecl.parent;\n\n      if (!functionExpr || functionExpr.type !== utils_1.AST_NODE_TYPES.FunctionExpression && functionExpr.type !== utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {\n        return false;\n      }\n\n      const methodDefinition = functionExpr.parent;\n\n      if ((methodDefinition === null || methodDefinition === void 0 ? void 0 : methodDefinition.type) !== utils_1.AST_NODE_TYPES.MethodDefinition) {\n        return false;\n      }\n\n      return methodDefinition.static;\n    }\n\n    function isGenericOfClassDecl(variable) {\n      if (!('isTypeVariable' in variable)) {\n        // this shouldn't happen...\n        return false;\n      }\n\n      if (!variable.isTypeVariable) {\n        return false;\n      }\n\n      if (variable.identifiers.length === 0) {\n        return false;\n      }\n\n      const typeParameter = variable.identifiers[0].parent;\n\n      if ((typeParameter === null || typeParameter === void 0 ? void 0 : typeParameter.type) !== utils_1.AST_NODE_TYPES.TSTypeParameter) {\n        return false;\n      }\n\n      const typeParameterDecl = typeParameter.parent;\n\n      if ((typeParameterDecl === null || typeParameterDecl === void 0 ? void 0 : typeParameterDecl.type) !== utils_1.AST_NODE_TYPES.TSTypeParameterDeclaration) {\n        return false;\n      }\n\n      const classDecl = typeParameterDecl.parent;\n      return (classDecl === null || classDecl === void 0 ? void 0 : classDecl.type) === utils_1.AST_NODE_TYPES.ClassDeclaration;\n    }\n\n    function isGenericOfAStaticMethodShadow(variable, shadowed) {\n      return isGenericOfStaticMethod(variable) && isGenericOfClassDecl(shadowed);\n    }\n\n    function isImportDeclaration(definition) {\n      return definition.type === utils_1.AST_NODE_TYPES.ImportDeclaration;\n    }\n\n    function isExternalModuleDeclarationWithName(scope, name) {\n      return scope.type === scope_manager_1.ScopeType.tsModule && scope.block.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration && scope.block.id.type === utils_1.AST_NODE_TYPES.Literal && scope.block.id.value === name;\n    }\n\n    function isExternalDeclarationMerging(scope, variable, shadowed) {\n      var _a;\n\n      const [firstDefinition] = shadowed.defs;\n      const [secondDefinition] = variable.defs;\n      return isTypeImport(firstDefinition) && isImportDeclaration(firstDefinition.parent) && isExternalModuleDeclarationWithName(scope, firstDefinition.parent.source.value) && secondDefinition.node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration && ((_a = secondDefinition.node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ExportNamedDeclaration;\n    }\n    /**\n     * Check if variable name is allowed.\n     * @param variable The variable to check.\n     * @returns Whether or not the variable name is allowed.\n     */\n\n\n    function isAllowed(variable) {\n      return options.allow.indexOf(variable.name) !== -1;\n    }\n    /**\n     * Checks if a variable of the class name in the class scope of ClassDeclaration.\n     *\n     * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\n     * So we should ignore the variable in the class scope.\n     * @param variable The variable to check.\n     * @returns Whether or not the variable of the class name in the class scope of ClassDeclaration.\n     */\n\n\n    function isDuplicatedClassNameVariable(variable) {\n      const block = variable.scope.block;\n      return block.type === utils_1.AST_NODE_TYPES.ClassDeclaration && block.id === variable.identifiers[0];\n    }\n    /**\n     * Checks if a variable of the class name in the class scope of TSEnumDeclaration.\n     *\n     * TSEnumDeclaration creates two variables of its name into its outer scope and its class scope.\n     * So we should ignore the variable in the class scope.\n     * @param variable The variable to check.\n     * @returns Whether or not the variable of the class name in the class scope of TSEnumDeclaration.\n     */\n\n\n    function isDuplicatedEnumNameVariable(variable) {\n      const block = variable.scope.block;\n      return block.type === utils_1.AST_NODE_TYPES.TSEnumDeclaration && block.id === variable.identifiers[0];\n    }\n    /**\n     * Checks whether or not a given location is inside of the range of a given node.\n     * @param node An node to check.\n     * @param location A location to check.\n     * @returns `true` if the location is inside of the range of the node.\n     */\n\n\n    function isInRange(node, location) {\n      return node && node.range[0] <= location && location <= node.range[1];\n    }\n    /**\n     * Searches from the current node through its ancestry to find a matching node.\n     * @param node a node to get.\n     * @param match a callback that checks whether or not the node verifies its condition or not.\n     * @returns the matching node.\n     */\n\n\n    function findSelfOrAncestor(node, match) {\n      let currentNode = node;\n\n      while (currentNode && !match(currentNode)) {\n        currentNode = currentNode.parent;\n      }\n\n      return currentNode;\n    }\n    /**\n     * Finds function's outer scope.\n     * @param scope Function's own scope.\n     * @returns Function's outer scope.\n     */\n\n\n    function getOuterScope(scope) {\n      const upper = scope.upper;\n\n      if ((upper === null || upper === void 0 ? void 0 : upper.type) === 'function-expression-name') {\n        return upper.upper;\n      }\n\n      return upper;\n    }\n    /**\n     * Checks if a variable and a shadowedVariable have the same init pattern ancestor.\n     * @param variable a variable to check.\n     * @param shadowedVariable a shadowedVariable to check.\n     * @returns Whether or not the variable and the shadowedVariable have the same init pattern ancestor.\n     */\n\n\n    function isInitPatternNode(variable, shadowedVariable) {\n      var _a, _b, _c, _d;\n\n      const outerDef = shadowedVariable.defs[0];\n\n      if (!outerDef) {\n        return false;\n      }\n\n      const {\n        variableScope\n      } = variable.scope;\n\n      if (!((variableScope.block.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression || variableScope.block.type === utils_1.AST_NODE_TYPES.FunctionExpression) && getOuterScope(variableScope) === shadowedVariable.scope)) {\n        return false;\n      }\n\n      const fun = variableScope.block;\n      const {\n        parent\n      } = fun;\n      const callExpression = findSelfOrAncestor(parent, node => node.type === utils_1.AST_NODE_TYPES.CallExpression);\n\n      if (!callExpression) {\n        return false;\n      }\n\n      let node = outerDef.name;\n      const location = callExpression.range[1];\n\n      while (node) {\n        if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {\n          if (isInRange(node.init, location)) {\n            return true;\n          }\n\n          if ((((_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.ForInStatement || ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.type) === utils_1.AST_NODE_TYPES.ForOfStatement) && isInRange(node.parent.parent.right, location)) {\n            return true;\n          }\n\n          break;\n        } else if (node.type === utils_1.AST_NODE_TYPES.AssignmentPattern) {\n          if (isInRange(node.right, location)) {\n            return true;\n          }\n        } else if ([utils_1.AST_NODE_TYPES.FunctionDeclaration, utils_1.AST_NODE_TYPES.ClassDeclaration, utils_1.AST_NODE_TYPES.FunctionExpression, utils_1.AST_NODE_TYPES.ClassExpression, utils_1.AST_NODE_TYPES.ArrowFunctionExpression, utils_1.AST_NODE_TYPES.CatchClause, utils_1.AST_NODE_TYPES.ImportDeclaration, utils_1.AST_NODE_TYPES.ExportNamedDeclaration].includes(node.type)) {\n          break;\n        }\n\n        node = node.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Checks if a variable is inside the initializer of scopeVar.\n     *\n     * To avoid reporting at declarations such as `var a = function a() {};`.\n     * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\n     * @param variable The variable to check.\n     * @param scopeVar The scope variable to look for.\n     * @returns Whether or not the variable is inside initializer of scopeVar.\n     */\n\n\n    function isOnInitializer(variable, scopeVar) {\n      var _a;\n\n      const outerScope = scopeVar.scope;\n      const outerDef = scopeVar.defs[0];\n      const outer = (_a = outerDef === null || outerDef === void 0 ? void 0 : outerDef.parent) === null || _a === void 0 ? void 0 : _a.range;\n      const innerScope = variable.scope;\n      const innerDef = variable.defs[0];\n      const inner = innerDef === null || innerDef === void 0 ? void 0 : innerDef.name.range;\n      return !!(outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && (innerDef.type === scope_manager_1.DefinitionType.FunctionName && innerDef.node.type === utils_1.AST_NODE_TYPES.FunctionExpression || innerDef.node.type === utils_1.AST_NODE_TYPES.ClassExpression) && outerScope === innerScope.upper);\n    }\n    /**\n     * Get a range of a variable's identifier node.\n     * @param variable The variable to get.\n     * @returns The range of the variable's identifier node.\n     */\n\n\n    function getNameRange(variable) {\n      const def = variable.defs[0];\n      return def === null || def === void 0 ? void 0 : def.name.range;\n    }\n    /**\n     * Checks if a variable is in TDZ of scopeVar.\n     * @param variable The variable to check.\n     * @param scopeVar The variable of TDZ.\n     * @returns Whether or not the variable is in TDZ of scopeVar.\n     */\n\n\n    function isInTdz(variable, scopeVar) {\n      const outerDef = scopeVar.defs[0];\n      const inner = getNameRange(variable);\n      const outer = getNameRange(scopeVar);\n      return !!(inner && outer && inner[1] < outer[0] && ( // Excepts FunctionDeclaration if is {\"hoist\":\"function\"}.\n      options.hoist !== 'functions' || !outerDef || outerDef.node.type !== utils_1.AST_NODE_TYPES.FunctionDeclaration));\n    }\n    /**\n     * Get declared line and column of a variable.\n     * @param  variable The variable to get.\n     * @returns The declared line and column of the variable.\n     */\n\n\n    function getDeclaredLocation(variable) {\n      const identifier = variable.identifiers[0];\n\n      if (identifier) {\n        return {\n          global: false,\n          line: identifier.loc.start.line,\n          column: identifier.loc.start.column + 1\n        };\n      } else {\n        return {\n          global: true\n        };\n      }\n    }\n    /**\n     * Checks the current context for shadowed variables.\n     * @param {Scope} scope Fixme\n     */\n\n\n    function checkForShadows(scope) {\n      // ignore global augmentation\n      if (isGlobalAugmentation(scope)) {\n        return;\n      }\n\n      const variables = scope.variables;\n\n      for (const variable of variables) {\n        // ignore \"arguments\"\n        if (variable.identifiers.length === 0) {\n          continue;\n        } // this params are pseudo-params that cannot be shadowed\n\n\n        if (isThisParam(variable)) {\n          continue;\n        } // ignore variables of a class name in the class scope of ClassDeclaration\n\n\n        if (isDuplicatedClassNameVariable(variable)) {\n          continue;\n        } // ignore variables of a class name in the class scope of ClassDeclaration\n\n\n        if (isDuplicatedEnumNameVariable(variable)) {\n          continue;\n        } // ignore configured allowed names\n\n\n        if (isAllowed(variable)) {\n          continue;\n        } // Gets shadowed variable.\n\n\n        const shadowed = scope.upper ? utils_1.ASTUtils.findVariable(scope.upper, variable.name) : null;\n\n        if (!shadowed) {\n          continue;\n        } // ignore type value variable shadowing if configured\n\n\n        if (isTypeValueShadow(variable, shadowed)) {\n          continue;\n        } // ignore function type parameter name shadowing if configured\n\n\n        if (isFunctionTypeParameterNameValueShadow(variable, shadowed)) {\n          continue;\n        } // ignore static class method generic shadowing class generic\n        // this is impossible for the scope analyser to understand\n        // so we have to handle this manually in this rule\n\n\n        if (isGenericOfAStaticMethodShadow(variable, shadowed)) {\n          continue;\n        }\n\n        if (isExternalDeclarationMerging(scope, variable, shadowed)) {\n          continue;\n        }\n\n        const isESLintGlobal = ('writeable' in shadowed);\n\n        if ((shadowed.identifiers.length > 0 || options.builtinGlobals && isESLintGlobal) && !isOnInitializer(variable, shadowed) && !(options.ignoreOnInitialization && isInitPatternNode(variable, shadowed)) && !(options.hoist !== 'all' && isInTdz(variable, shadowed))) {\n          const location = getDeclaredLocation(shadowed);\n          context.report(Object.assign({\n            node: variable.identifiers[0]\n          }, location.global ? {\n            messageId: 'noShadowGlobal',\n            data: {\n              name: variable.name\n            }\n          } : {\n            messageId: 'noShadow',\n            data: {\n              name: variable.name,\n              shadowedLine: location.line,\n              shadowedColumn: location.column\n            }\n          }));\n        }\n      }\n    }\n\n    return {\n      'Program:exit'() {\n        const globalScope = context.getScope();\n        const stack = globalScope.childScopes.slice();\n\n        while (stack.length) {\n          const scope = stack.pop();\n          stack.push(...scope.childScopes);\n          checkForShadows(scope);\n        }\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","extendsBaseRule","schema","properties","builtinGlobals","hoist","enum","allow","items","ignoreOnInitialization","ignoreTypeValueShadow","ignoreFunctionTypeParameterNameValueShadow","additionalProperties","messages","noShadow","noShadowGlobal","defaultOptions","create","context","options","isGlobalAugmentation","scope","scope_manager_1","tsModule","block","global","upper","isThisParam","variable","defs","Parameter","isTypeImport","definition","ImportBinding","parent","importKind","node","utils_1","ImportSpecifier","isTypeValueShadow","shadowed","firstDefinition","isShadowedValue","isValueVariable","isFunctionTypeParameterNameValueShadow","id","identifiers","isFunctionType","isGenericOfStaticMethod","isTypeVariable","length","typeParameter","TSTypeParameter","typeParameterDecl","TSTypeParameterDeclaration","functionExpr","FunctionExpression","TSEmptyBodyFunctionExpression","methodDefinition","MethodDefinition","static","isGenericOfClassDecl","classDecl","ClassDeclaration","isGenericOfAStaticMethodShadow","isImportDeclaration","ImportDeclaration","isExternalModuleDeclarationWithName","TSModuleDeclaration","Literal","value","isExternalDeclarationMerging","secondDefinition","source","TSInterfaceDeclaration","_a","ExportNamedDeclaration","isAllowed","indexOf","isDuplicatedClassNameVariable","isDuplicatedEnumNameVariable","TSEnumDeclaration","isInRange","location","range","findSelfOrAncestor","match","currentNode","getOuterScope","isInitPatternNode","shadowedVariable","outerDef","variableScope","ArrowFunctionExpression","fun","callExpression","CallExpression","VariableDeclarator","init","_b","ForInStatement","_c","_d","ForOfStatement","right","AssignmentPattern","FunctionDeclaration","ClassExpression","CatchClause","includes","isOnInitializer","scopeVar","outerScope","outer","innerScope","innerDef","inner","FunctionName","getNameRange","def","isInTdz","getDeclaredLocation","identifier","line","loc","start","column","checkForShadows","variables","findVariable","isESLintGlobal","report","Object","messageId","data","shadowedLine","shadowedColumn","globalScope","getScope","stack","childScopes","slice","pop","push"],"sources":["../../src/rules/no-shadow.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}