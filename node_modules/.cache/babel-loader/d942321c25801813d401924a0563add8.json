{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _helperRemapAsyncToGenerator = require(\"@babel/helper-remap-async-to-generator\");\n\nvar _pluginSyntaxAsyncGenerators = require(\"@babel/plugin-syntax-async-generators\");\n\nvar _core = require(\"@babel/core\");\n\nvar _forAwait = require(\"./for-await\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nvar _default = (0, _helperPluginUtils.declare)(api => {\n  api.assertVersion(7);\n\n  const yieldStarVisitor = _core.traverse.visitors.merge([{\n    ArrowFunctionExpression(path) {\n      path.skip();\n    },\n\n    YieldExpression(_ref, state) {\n      let {\n        node\n      } = _ref;\n      if (!node.delegate) return;\n\n      const asyncIter = _core.types.callExpression(state.addHelper(\"asyncIterator\"), [node.argument]);\n\n      node.argument = _core.types.callExpression(state.addHelper(\"asyncGeneratorDelegate\"), [asyncIter, state.addHelper(\"awaitAsyncGenerator\")]);\n    }\n\n  }, _helperEnvironmentVisitor.default]);\n\n  const forAwaitVisitor = _core.traverse.visitors.merge([{\n    ArrowFunctionExpression(path) {\n      path.skip();\n    },\n\n    ForOfStatement(path, _ref2) {\n      let {\n        file\n      } = _ref2;\n      const {\n        node\n      } = path;\n      if (!node.await) return;\n      const build = (0, _forAwait.default)(path, {\n        getAsyncIterator: file.addHelper(\"asyncIterator\")\n      });\n      const {\n        declar,\n        loop\n      } = build;\n      const block = loop.body;\n      path.ensureBlock();\n\n      if (declar) {\n        block.body.push(declar);\n      }\n\n      block.body.push(...path.node.body.body);\n\n      _core.types.inherits(loop, node);\n\n      _core.types.inherits(loop.body, node.body);\n\n      if (build.replaceParent) {\n        path.parentPath.replaceWithMultiple(build.node);\n      } else {\n        path.replaceWithMultiple(build.node);\n      }\n    }\n\n  }, _helperEnvironmentVisitor.default]);\n\n  const visitor = {\n    Function(path, state) {\n      if (!path.node.async) return;\n      path.traverse(forAwaitVisitor, state);\n      if (!path.node.generator) return;\n      path.traverse(yieldStarVisitor, state);\n      (0, _helperRemapAsyncToGenerator.default)(path, {\n        wrapAsync: state.addHelper(\"wrapAsyncGenerator\"),\n        wrapAwait: state.addHelper(\"awaitAsyncGenerator\")\n      });\n    }\n\n  };\n  return {\n    name: \"proposal-async-generator-functions\",\n    inherits: _pluginSyntaxAsyncGenerators.default,\n    visitor: {\n      Program(path, state) {\n        path.traverse(visitor, state);\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["api","assertVersion","yieldStarVisitor","traverse","visitors","merge","ArrowFunctionExpression","path","skip","YieldExpression","state","node","delegate","asyncIter","t","callExpression","addHelper","argument","environmentVisitor","forAwaitVisitor","ForOfStatement","file","await","build","getAsyncIterator","declar","loop","block","body","ensureBlock","push","inherits","replaceParent","parentPath","replaceWithMultiple","visitor","Function","async","generator","wrapAsync","wrapAwait","name","syntaxAsyncGenerators","default","Program"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-proposal-async-generator-functions\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport remapAsyncToGenerator from \"@babel/helper-remap-async-to-generator\";\nimport syntaxAsyncGenerators from \"@babel/plugin-syntax-async-generators\";\nimport type { NodePath, Visitor } from \"@babel/traverse\";\nimport { traverse, types as t, type PluginPass } from \"@babel/core\";\nimport rewriteForAwait from \"./for-await\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\n\nexport default declare(api => {\n  api.assertVersion(7);\n\n  const yieldStarVisitor = traverse.visitors.merge<PluginPass>([\n    {\n      ArrowFunctionExpression(path) {\n        path.skip();\n      },\n\n      YieldExpression({ node }, state) {\n        if (!node.delegate) return;\n        const asyncIter = t.callExpression(state.addHelper(\"asyncIterator\"), [\n          node.argument,\n        ]);\n        node.argument = t.callExpression(\n          state.addHelper(\"asyncGeneratorDelegate\"),\n          process.env.BABEL_8_BREAKING\n            ? [asyncIter]\n            : [asyncIter, state.addHelper(\"awaitAsyncGenerator\")],\n        );\n      },\n    },\n    environmentVisitor,\n  ]);\n\n  const forAwaitVisitor = traverse.visitors.merge<PluginPass>([\n    {\n      ArrowFunctionExpression(path) {\n        path.skip();\n      },\n\n      ForOfStatement(path: NodePath<t.ForOfStatement>, { file }) {\n        const { node } = path;\n        if (!node.await) return;\n\n        const build = rewriteForAwait(path, {\n          getAsyncIterator: file.addHelper(\"asyncIterator\"),\n        });\n\n        const { declar, loop } = build;\n        const block = loop.body as t.BlockStatement;\n\n        // ensure that it's a block so we can take all its statements\n        path.ensureBlock();\n\n        // add the value declaration to the new loop body\n        if (declar) {\n          block.body.push(declar);\n        }\n\n        // push the rest of the original loop body onto our new body\n        block.body.push(...path.node.body.body);\n\n        t.inherits(loop, node);\n        t.inherits(loop.body, node.body);\n\n        if (build.replaceParent) {\n          path.parentPath.replaceWithMultiple(build.node);\n        } else {\n          path.replaceWithMultiple(build.node);\n        }\n      },\n    },\n    environmentVisitor,\n  ]);\n\n  const visitor: Visitor<PluginPass> = {\n    Function(path, state) {\n      if (!path.node.async) return;\n\n      path.traverse(forAwaitVisitor, state);\n\n      if (!path.node.generator) return;\n\n      path.traverse(yieldStarVisitor, state);\n\n      // We don't need to pass the noNewArrows assumption, since\n      // async generators are never arrow functions.\n      remapAsyncToGenerator(path, {\n        wrapAsync: state.addHelper(\"wrapAsyncGenerator\"),\n        wrapAwait: state.addHelper(\"awaitAsyncGenerator\"),\n      });\n    },\n  };\n\n  return {\n    name: \"proposal-async-generator-functions\",\n    inherits: syntaxAsyncGenerators.default,\n\n    visitor: {\n      Program(path, state) {\n        // We need to traverse the ast here (instead of just vising Function\n        // in the top level visitor) because for-await needs to run before the\n        // async-to-generator plugin. This is because for-await is transpiled\n        // using \"await\" expressions, which are then converted to \"yield\".\n        //\n        // This is bad for performance, but plugin ordering will allow as to\n        // directly visit Function in the top level visitor.\n        path.traverse(visitor, state);\n      },\n    },\n  };\n});\n"]},"metadata":{},"sourceType":"script"}