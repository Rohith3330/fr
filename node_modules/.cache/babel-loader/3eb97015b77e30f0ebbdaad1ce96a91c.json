{"ast":null,"code":"'use strict';\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _minimatch = require('minimatch');\n\nvar _minimatch2 = _interopRequireDefault(_minimatch);\n\nvar _staticRequire = require('../core/staticRequire');\n\nvar _staticRequire2 = _interopRequireDefault(_staticRequire);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction report(context, node) {\n  context.report({\n    node: node,\n    message: 'Imported module should be assigned'\n  });\n}\n\nfunction testIsAllow(globs, filename, source) {\n  if (!Array.isArray(globs)) {\n    return false; // default doesn't allow any patterns\n  }\n\n  var filePath = void 0;\n\n  if (source[0] !== '.' && source[0] !== '/') {\n    // a node module\n    filePath = source;\n  } else {\n    filePath = _path2['default'].resolve(_path2['default'].dirname(filename), source); // get source absolute path\n  }\n\n  return globs.find(function (glob) {\n    return (0, _minimatch2['default'])(filePath, glob) || (0, _minimatch2['default'])(filePath, _path2['default'].join(process.cwd(), glob));\n  }) !== undefined;\n}\n\nfunction create(context) {\n  var options = context.options[0] || {};\n  var filename = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n\n  var isAllow = function isAllow(source) {\n    return testIsAllow(options.allow, filename, source);\n  };\n\n  return {\n    ImportDeclaration: function () {\n      function ImportDeclaration(node) {\n        if (node.specifiers.length === 0 && !isAllow(node.source.value)) {\n          report(context, node);\n        }\n      }\n\n      return ImportDeclaration;\n    }(),\n    ExpressionStatement: function () {\n      function ExpressionStatement(node) {\n        if (node.expression.type === 'CallExpression' && (0, _staticRequire2['default'])(node.expression) && !isAllow(node.expression.arguments[0].value)) {\n          report(context, node.expression);\n        }\n      }\n\n      return ExpressionStatement;\n    }()\n  };\n}\n\nmodule.exports = {\n  create: create,\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: (0, _docsUrl2['default'])('no-unassigned-import')\n    },\n    schema: [{\n      'type': 'object',\n      'properties': {\n        'devDependencies': {\n          'type': ['boolean', 'array']\n        },\n        'optionalDependencies': {\n          'type': ['boolean', 'array']\n        },\n        'peerDependencies': {\n          'type': ['boolean', 'array']\n        },\n        'allow': {\n          'type': 'array',\n          'items': {\n            'type': 'string'\n          }\n        }\n      },\n      'additionalProperties': false\n    }]\n  }\n};","map":{"version":3,"mappings":";;AAAA;;;;AACA;;;;AAEA;;;;AACA;;;;;;;;;;AAEA,SAASA,MAAT,CAAgBC,OAAhB,EAAyBC,IAAzB,EAA+B;EAC7BD,QAAQD,MAARC,CAAe;IACbC,UADa;IAEbC,SAAS;EAFI,CAAfF;AAID;;AAED,SAASG,WAAT,CAAqBC,KAArB,EAA4BC,QAA5B,EAAsCC,MAAtC,EAA8C;EAC5C,IAAI,CAACC,MAAMC,OAAND,CAAcH,KAAdG,CAAL,EAA2B;IACzB,OAAO,KAAP,CADyB,CACX;EACf;;EAED,IAAIE,iBAAJ;;EAEA,IAAIH,OAAO,CAAPA,MAAc,GAAdA,IAAqBA,OAAO,CAAPA,MAAc,GAAvC,EAA4C;IAAE;IAC5CG,WAAWH,MAAXG;EADF,OAEO;IACLA,WAAWC,kBAAKC,OAALD,CAAaA,kBAAKE,OAALF,CAAaL,QAAbK,CAAbA,EAAqCJ,MAArCI,CAAXD,CADK,CACoD;EAC1D;;EAED,OAAOL,MAAMS,IAANT,CAAW;IAAA,OAChB,4BAAUK,QAAV,EAAoBK,IAApB,KACA,4BAAUL,QAAV,EAAoBC,kBAAKK,IAALL,CAAUM,QAAQC,GAARD,EAAVN,EAAyBI,IAAzBJ,CAApB,CAFgB;EAAX,OAGAQ,SAHP;AAID;;AAED,SAASC,MAAT,CAAgBnB,OAAhB,EAAyB;EACvB,IAAMoB,UAAUpB,QAAQoB,OAARpB,CAAgB,CAAhBA,KAAsB,EAAtC;EACA,IAAMK,WAAWL,QAAQqB,mBAARrB,GAA8BA,QAAQqB,mBAARrB,EAA9BA,GAA8DA,QAAQsB,WAARtB,EAA/E;;EACA,IAAMuB,UAAU,SAAVA,OAAU;IAAA,OAAUpB,YAAYiB,QAAQI,KAApBrB,EAA2BE,QAA3BF,EAAqCG,MAArCH,CAAV;EAAhB;;EAEA,OAAO;IACLsB,iBADK;MAAA,2BACaxB,IADb,EACmB;QACtB,IAAIA,KAAKyB,UAALzB,CAAgB0B,MAAhB1B,KAA2B,CAA3BA,IAAgC,CAACsB,QAAQtB,KAAKK,MAALL,CAAY2B,KAApBL,CAArC,EAAiE;UAC/DxB,OAAOC,OAAPD,EAAgBE,IAAhBF;QACD;MAJE;;MAAA;IAAA;IAML8B,mBANK;MAAA,6BAMe5B,IANf,EAMqB;QACxB,IAAIA,KAAK6B,UAAL7B,CAAgB8B,IAAhB9B,KAAyB,gBAAzBA,IACF,gCAAgBA,KAAK6B,UAArB,CADE7B,IAEF,CAACsB,QAAQtB,KAAK6B,UAAL7B,CAAgB+B,SAAhB/B,CAA0B,CAA1BA,EAA6B2B,KAArCL,CAFH,EAEgD;UAC9CxB,OAAOC,OAAPD,EAAgBE,KAAK6B,UAArB/B;QACD;MAXE;;MAAA;IAAA;EAAA,CAAP;AAcD;;AAEDkC,OAAOC,OAAPD,GAAiB;EACfd,cADe;EAEfgB,MAAM;IACJJ,MAAM,YADF;IAEJK,MAAM;MACJC,KAAK,0BAAQ,sBAAR;IADD,CAFF;IAKJC,QAAQ,CACN;MACE,QAAQ,QADV;MAEE,cAAc;QACZ,mBAAmB;UAAE,QAAQ,CAAC,SAAD,EAAY,OAAZ;QAAV,CADP;QAEZ,wBAAwB;UAAE,QAAQ,CAAC,SAAD,EAAY,OAAZ;QAAV,CAFZ;QAGZ,oBAAoB;UAAE,QAAQ,CAAC,SAAD,EAAY,OAAZ;QAAV,CAHR;QAIZ,SAAS;UACP,QAAQ,OADD;UAEP,SAAS;YACP,QAAQ;UADD;QAFF;MAJG,CAFhB;MAaE,wBAAwB;IAb1B,CADM;EALJ;AAFS,CAAjBL","names":["report","context","node","message","testIsAllow","globs","filename","source","Array","isArray","filePath","path","resolve","dirname","find","glob","join","process","cwd","undefined","create","options","getPhysicalFilename","getFilename","isAllow","allow","ImportDeclaration","specifiers","length","value","ExpressionStatement","expression","type","arguments","module","exports","meta","docs","url","schema"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\no-unassigned-import.js"],"sourcesContent":["import path from 'path';\nimport minimatch from 'minimatch';\n\nimport isStaticRequire from '../core/staticRequire';\nimport docsUrl from '../docsUrl';\n\nfunction report(context, node) {\n  context.report({\n    node,\n    message: 'Imported module should be assigned',\n  });\n}\n\nfunction testIsAllow(globs, filename, source) {\n  if (!Array.isArray(globs)) {\n    return false; // default doesn't allow any patterns\n  }\n\n  let filePath;\n\n  if (source[0] !== '.' && source[0] !== '/') { // a node module\n    filePath = source;\n  } else {\n    filePath = path.resolve(path.dirname(filename), source); // get source absolute path\n  }\n\n  return globs.find(glob => (\n    minimatch(filePath, glob) ||\n    minimatch(filePath, path.join(process.cwd(), glob))\n  )) !== undefined;\n}\n\nfunction create(context) {\n  const options = context.options[0] || {};\n  const filename = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n  const isAllow = source => testIsAllow(options.allow, filename, source);\n\n  return {\n    ImportDeclaration(node) {\n      if (node.specifiers.length === 0 && !isAllow(node.source.value)) {\n        report(context, node);\n      }\n    },\n    ExpressionStatement(node) {\n      if (node.expression.type === 'CallExpression' &&\n        isStaticRequire(node.expression) &&\n        !isAllow(node.expression.arguments[0].value)) {\n        report(context, node.expression);\n      }\n    },\n  };\n}\n\nmodule.exports = {\n  create,\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: docsUrl('no-unassigned-import'),\n    },\n    schema: [\n      {\n        'type': 'object',\n        'properties': {\n          'devDependencies': { 'type': ['boolean', 'array'] },\n          'optionalDependencies': { 'type': ['boolean', 'array'] },\n          'peerDependencies': { 'type': ['boolean', 'array'] },\n          'allow': {\n            'type': 'array',\n            'items': {\n              'type': 'string',\n            },\n          },\n        },\n        'additionalProperties': false,\n      },\n    ],\n  },\n};\n"]},"metadata":{},"sourceType":"script"}