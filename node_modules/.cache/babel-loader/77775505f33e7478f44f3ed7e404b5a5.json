{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst util_2 = require(\"../../compile/util\");\n\nconst def = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      data,\n      parentSchema,\n      it\n    } = cxt;\n    const {\n      opts\n    } = it;\n    const patterns = (0, code_1.allSchemaProperties)(schema);\n    const alwaysValidPatterns = patterns.filter(p => (0, util_1.alwaysValidSchema)(it, schema[p]));\n\n    if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {\n      return;\n    }\n\n    const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;\n    const valid = gen.name(\"valid\");\n\n    if (it.props !== true && !(it.props instanceof codegen_1.Name)) {\n      it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);\n    }\n\n    const {\n      props\n    } = it;\n    validatePatternProperties();\n\n    function validatePatternProperties() {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat);\n\n        if (it.allErrors) {\n          validateProperties(pat);\n        } else {\n          gen.var(valid, true); // TODO var\n\n          validateProperties(pat);\n          gen.if(valid);\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat) {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);\n        }\n      }\n    }\n\n    function validateProperties(pat) {\n      gen.forIn(\"key\", data, key => {\n        gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat);\n\n          if (!alwaysValid) {\n            cxt.subschema({\n              keyword: \"patternProperties\",\n              schemaProp: pat,\n              dataProp: key,\n              dataPropType: util_2.Type.Str\n            }, valid);\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign((0, codegen_1._)`${props}[${key}]`, true);\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if((0, codegen_1.not)(valid), () => gen.break());\n          }\n        });\n      });\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["def","keyword","type","schemaType","code","cxt","gen","schema","data","parentSchema","it","opts","patterns","alwaysValidPatterns","filter","p","length","unevaluated","props","checkProperties","strictSchema","allowMatchingProperties","properties","valid","name","codegen_1","validatePatternProperties","pat","checkMatchingProperties","allErrors","validateProperties","var","if","prop","RegExp","test","forIn","key","alwaysValid","includes","subschema","schemaProp","dataProp","dataPropType","util_2","Str","assign","break","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\vocabularies\\applicator\\patternProperties.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}