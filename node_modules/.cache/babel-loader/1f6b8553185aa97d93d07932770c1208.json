{"ast":null,"code":"'use strict';\n\nvar _minimatch = require('minimatch');\n\nvar _minimatch2 = _interopRequireDefault(_minimatch);\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _pkgUp = require('eslint-module-utils/pkgUp');\n\nvar _pkgUp2 = _interopRequireDefault(_pkgUp);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction getEntryPoint(context) {\n  var pkgPath = (0, _pkgUp2['default'])({\n    cwd: context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename()\n  });\n\n  try {\n    return require.resolve(_path2['default'].dirname(pkgPath));\n  } catch (error) {\n    // Assume the package has no entrypoint (e.g. CLI packages)\n    // in which case require.resolve would throw.\n    return null;\n  }\n}\n\nfunction findScope(context, identifier) {\n  var _context$getSourceCod = context.getSourceCode(),\n      scopeManager = _context$getSourceCod.scopeManager;\n\n  return scopeManager && scopeManager.scopes.slice().reverse().find(function (scope) {\n    return scope.variables.some(function (variable) {\n      return variable.identifiers.some(function (node) {\n        return node.name === identifier;\n      });\n    });\n  });\n}\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow import statements with module.exports',\n      category: 'Best Practices',\n      recommended: true\n    },\n    fixable: 'code',\n    schema: [{\n      'type': 'object',\n      'properties': {\n        'exceptions': {\n          'type': 'array'\n        }\n      },\n      'additionalProperties': false\n    }]\n  },\n  create: function () {\n    function create(context) {\n      var importDeclarations = [];\n      var entryPoint = getEntryPoint(context);\n      var options = context.options[0] || {};\n      var alreadyReported = false;\n\n      function report(node) {\n        var fileName = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n        var isEntryPoint = entryPoint === fileName;\n        var isIdentifier = node.object.type === 'Identifier';\n        var hasKeywords = /^(module|exports)$/.test(node.object.name);\n        var objectScope = hasKeywords && findScope(context, node.object.name);\n        var hasCJSExportReference = hasKeywords && (!objectScope || objectScope.type === 'module');\n        var isException = !!options.exceptions && options.exceptions.some(function (glob) {\n          return (0, _minimatch2['default'])(fileName, glob);\n        });\n\n        if (isIdentifier && hasCJSExportReference && !isEntryPoint && !isException) {\n          importDeclarations.forEach(function (importDeclaration) {\n            context.report({\n              node: importDeclaration,\n              message: 'Cannot use import declarations in modules that export using ' + 'CommonJS (module.exports = \\'foo\\' or exports.bar = \\'hi\\')'\n            });\n          });\n          alreadyReported = true;\n        }\n      }\n\n      return {\n        ImportDeclaration: function () {\n          function ImportDeclaration(node) {\n            importDeclarations.push(node);\n          }\n\n          return ImportDeclaration;\n        }(),\n        MemberExpression: function () {\n          function MemberExpression(node) {\n            if (!alreadyReported) {\n              report(node);\n            }\n          }\n\n          return MemberExpression;\n        }()\n      };\n    }\n\n    return create;\n  }()\n};","map":{"version":3,"mappings":"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","names":["getEntryPoint","context","pkgPath","cwd","getPhysicalFilename","getFilename","require","resolve","path","dirname","error","findScope","identifier","getSourceCode","scopeManager","scopes","slice","reverse","find","scope","variables","some","variable","identifiers","node","name","module","exports","meta","type","docs","description","category","recommended","fixable","schema","create","importDeclarations","entryPoint","options","alreadyReported","report","fileName","isEntryPoint","isIdentifier","object","hasKeywords","test","objectScope","hasCJSExportReference","isException","exceptions","glob","forEach","importDeclaration","message","ImportDeclaration","push","MemberExpression"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\no-import-module-exports.js"],"sourcesContent":["import minimatch from 'minimatch';\nimport path from 'path';\nimport pkgUp from 'eslint-module-utils/pkgUp';\n\nfunction getEntryPoint(context) {\n  const pkgPath = pkgUp({ cwd: context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename() });\n  try {\n    return require.resolve(path.dirname(pkgPath));\n  } catch (error) {\n    // Assume the package has no entrypoint (e.g. CLI packages)\n    // in which case require.resolve would throw.\n    return null;\n  }\n}\n\nfunction findScope(context, identifier) {\n  const { scopeManager } = context.getSourceCode();\n\n  return scopeManager && scopeManager.scopes.slice().reverse().find((scope) => scope.variables.some(variable => variable.identifiers.some((node) => node.name === identifier)));\n}\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow import statements with module.exports',\n      category: 'Best Practices',\n      recommended: true,\n    },\n    fixable: 'code',\n    schema: [\n      {\n        'type': 'object',\n        'properties': {\n          'exceptions': { 'type': 'array' },\n        },\n        'additionalProperties': false,\n      },\n    ],\n  },\n  create(context) {\n    const importDeclarations = [];\n    const entryPoint = getEntryPoint(context);\n    const options = context.options[0] || {};\n    let alreadyReported = false;\n\n    function report(node) {\n      const fileName = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n      const isEntryPoint = entryPoint === fileName;\n      const isIdentifier = node.object.type === 'Identifier';\n      const hasKeywords = (/^(module|exports)$/).test(node.object.name);\n      const objectScope = hasKeywords && findScope(context, node.object.name);\n      const hasCJSExportReference = hasKeywords && (!objectScope || objectScope.type === 'module');\n      const isException = !!options.exceptions && options.exceptions.some(glob => minimatch(fileName, glob));\n\n      if (isIdentifier && hasCJSExportReference && !isEntryPoint && !isException) {\n        importDeclarations.forEach(importDeclaration => {\n          context.report({\n            node: importDeclaration,\n            message: `Cannot use import declarations in modules that export using ` +\n              `CommonJS (module.exports = 'foo' or exports.bar = 'hi')`,\n          });\n        });\n        alreadyReported = true;\n      }\n    }\n\n    return {\n      ImportDeclaration(node) {\n        importDeclarations.push(node);\n      },\n      MemberExpression(node) {\n        if (!alreadyReported) {\n          report(node);\n        }\n      },\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"script"}