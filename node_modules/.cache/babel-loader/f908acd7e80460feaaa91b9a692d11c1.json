{"ast":null,"code":"import * as t from \"../../lib/index.js\";\nimport stringifyValidator from \"../utils/stringifyValidator.js\";\nimport toFunctionName from \"../utils/toFunctionName.js\";\nconst NODE_PREFIX = \"BabelNode\";\nlet code = `// NOTE: This file is autogenerated. Do not modify.\n// See packages/babel-types/scripts/generators/flow.js for script used.\n\ndeclare class ${NODE_PREFIX}Comment {\n  value: string;\n  start: number;\n  end: number;\n  loc: ${NODE_PREFIX}SourceLocation;\n}\n\ndeclare class ${NODE_PREFIX}CommentBlock extends ${NODE_PREFIX}Comment {\n  type: \"CommentBlock\";\n}\n\ndeclare class ${NODE_PREFIX}CommentLine extends ${NODE_PREFIX}Comment {\n  type: \"CommentLine\";\n}\n\ndeclare class ${NODE_PREFIX}SourceLocation {\n  start: {\n    line: number;\n    column: number;\n  };\n\n  end: {\n    line: number;\n    column: number;\n  };\n}\n\ndeclare class ${NODE_PREFIX} {\n  leadingComments?: Array<${NODE_PREFIX}Comment>;\n  innerComments?: Array<${NODE_PREFIX}Comment>;\n  trailingComments?: Array<${NODE_PREFIX}Comment>;\n  start: ?number;\n  end: ?number;\n  loc: ?${NODE_PREFIX}SourceLocation;\n  extra?: { [string]: mixed };\n}\\n\\n`; //\n\nconst lines = [];\n\nfor (const type in t.NODE_FIELDS) {\n  const fields = t.NODE_FIELDS[type];\n  const struct = ['type: \"' + type + '\";'];\n  const args = [];\n  const builderNames = t.BUILDER_KEYS[type];\n  Object.keys(t.NODE_FIELDS[type]).sort((fieldA, fieldB) => {\n    const indexA = t.BUILDER_KEYS[type].indexOf(fieldA);\n    const indexB = t.BUILDER_KEYS[type].indexOf(fieldB);\n    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;\n    if (indexA === -1) return 1;\n    if (indexB === -1) return -1;\n    return indexA - indexB;\n  }).forEach(fieldName => {\n    const field = fields[fieldName];\n    let suffix = \"\";\n    if (field.optional || field.default != null) suffix += \"?\";\n    let typeAnnotation = \"any\";\n    const validate = field.validate;\n\n    if (validate) {\n      typeAnnotation = stringifyValidator(validate, NODE_PREFIX);\n    }\n\n    if (typeAnnotation) {\n      suffix += \": \" + typeAnnotation;\n    }\n\n    if (builderNames.includes(fieldName)) {\n      args.push(t.toBindingIdentifierName(fieldName) + suffix);\n    }\n\n    if (t.isValidIdentifier(fieldName)) {\n      struct.push(fieldName + suffix + \";\");\n    }\n  });\n  code += `declare class ${NODE_PREFIX}${type} extends ${NODE_PREFIX} {\n  ${struct.join(\"\\n  \").trim()}\n}\\n\\n`; // Flow chokes on super() and import() :/\n\n  if (type !== \"Super\" && type !== \"Import\") {\n    lines.push(`declare export function ${toFunctionName(type)}(${args.join(\", \")}): ${NODE_PREFIX}${type};`);\n  } else {\n    const functionName = toFunctionName(type);\n    lines.push(`declare function _${functionName}(${args.join(\", \")}): ${NODE_PREFIX}${type};`, `declare export { _${functionName} as ${functionName} }`);\n  }\n}\n\nfor (const typeName of t.TYPES) {\n  const isDeprecated = !!t.DEPRECATED_KEYS[typeName];\n  const realName = isDeprecated ? t.DEPRECATED_KEYS[typeName] : typeName;\n  let decl = `declare export function is${typeName}(node: ?Object, opts?: ?Object): boolean`;\n\n  if (t.NODE_FIELDS[realName]) {\n    decl += ` %checks (node instanceof ${NODE_PREFIX}${realName})`;\n  }\n\n  lines.push(decl);\n  lines.push(`declare export function assert${typeName}(node: ?Object, opts?: ?Object): void`);\n}\n\nlines.push(`declare export var VISITOR_KEYS: { [type: string]: string[] }`, // assert/\n`declare export function assertNode(obj: any): void`, // builders/\n// eslint-disable-next-line max-len\n`declare export function createTypeAnnotationBasedOnTypeof(type: 'string' | 'number' | 'undefined' | 'boolean' | 'function' | 'object' | 'symbol'): ${NODE_PREFIX}TypeAnnotation`, // eslint-disable-next-line max-len\n`declare export function createUnionTypeAnnotation(types: Array<${NODE_PREFIX}FlowType>): ${NODE_PREFIX}UnionTypeAnnotation`, // eslint-disable-next-line max-len\n`declare export function createFlowUnionType(types: Array<${NODE_PREFIX}FlowType>): ${NODE_PREFIX}UnionTypeAnnotation`, // this smells like \"internal API\"\n// eslint-disable-next-line max-len\n`declare export function buildChildren(node: { children: Array<${NODE_PREFIX}JSXText | ${NODE_PREFIX}JSXExpressionContainer | ${NODE_PREFIX}JSXSpreadChild | ${NODE_PREFIX}JSXElement | ${NODE_PREFIX}JSXFragment | ${NODE_PREFIX}JSXEmptyExpression> }): Array<${NODE_PREFIX}JSXText | ${NODE_PREFIX}JSXExpressionContainer | ${NODE_PREFIX}JSXSpreadChild | ${NODE_PREFIX}JSXElement | ${NODE_PREFIX}JSXFragment>`, // clone/\n`declare export function clone<T>(n: T): T;`, `declare export function cloneDeep<T>(n: T): T;`, `declare export function cloneDeepWithoutLoc<T>(n: T): T;`, `declare export function cloneNode<T>(n: T, deep?: boolean, withoutLoc?: boolean): T;`, `declare export function cloneWithoutLoc<T>(n: T): T;`, // comments/\n`declare type CommentTypeShorthand = 'leading' | 'inner' | 'trailing'`, // eslint-disable-next-line max-len\n`declare export function addComment<T: BabelNode>(node: T, type: CommentTypeShorthand, content: string, line?: boolean): T`, // eslint-disable-next-line max-len\n`declare export function addComments<T: BabelNode>(node: T, type: CommentTypeShorthand, comments: Array<Comment>): T`, `declare export function inheritInnerComments(node: BabelNode, parent: BabelNode): void`, `declare export function inheritLeadingComments(node: BabelNode, parent: BabelNode): void`, `declare export function inheritsComments<T: BabelNode>(node: T, parent: BabelNode): void`, `declare export function inheritTrailingComments(node: BabelNode, parent: BabelNode): void`, `declare export function removeComments<T: BabelNode>(node: T): T`, // converters/\n`declare export function ensureBlock(node: ${NODE_PREFIX}, key: string): ${NODE_PREFIX}BlockStatement`, `declare export function toBindingIdentifierName(name?: ?string): string`, // eslint-disable-next-line max-len\n`declare export function toBlock(node: ${NODE_PREFIX}Statement | ${NODE_PREFIX}Expression, parent?: ${NODE_PREFIX}Function | null): ${NODE_PREFIX}BlockStatement`, // eslint-disable-next-line max-len\n`declare export function toComputedKey(node: ${NODE_PREFIX}Method | ${NODE_PREFIX}Property, key?: ${NODE_PREFIX}Expression | ${NODE_PREFIX}Identifier): ${NODE_PREFIX}Expression`, // eslint-disable-next-line max-len\n`declare export function toExpression(node: ${NODE_PREFIX}ExpressionStatement | ${NODE_PREFIX}Expression | ${NODE_PREFIX}Class | ${NODE_PREFIX}Function): ${NODE_PREFIX}Expression`, `declare export function toIdentifier(name?: ?string): string`, // eslint-disable-next-line max-len\n`declare export function toKeyAlias(node: ${NODE_PREFIX}Method | ${NODE_PREFIX}Property, key?: ${NODE_PREFIX}): string`, // toSequenceExpression relies on types that aren't declared in flow\n// eslint-disable-next-line max-len\n`declare export function toStatement(node: ${NODE_PREFIX}Statement | ${NODE_PREFIX}Class | ${NODE_PREFIX}Function | ${NODE_PREFIX}AssignmentExpression, ignore?: boolean): ${NODE_PREFIX}Statement | void`, `declare export function valueToNode(value: any): ${NODE_PREFIX}Expression`, // modifications/\n// eslint-disable-next-line max-len\n`declare export function removeTypeDuplicates(types: Array<${NODE_PREFIX}FlowType>): Array<${NODE_PREFIX}FlowType>`, // eslint-disable-next-line max-len\n`declare export function appendToMemberExpression(member: ${NODE_PREFIX}MemberExpression, append: ${NODE_PREFIX}, computed?: boolean): ${NODE_PREFIX}MemberExpression`, // eslint-disable-next-line max-len\n`declare export function inherits<T: BabelNode>(child: T, parent: ${NODE_PREFIX} | null | void): T`, // eslint-disable-next-line max-len\n`declare export function prependToMemberExpression(member: ${NODE_PREFIX}MemberExpression, prepend: ${NODE_PREFIX}Expression): ${NODE_PREFIX}MemberExpression`, `declare export function removeProperties<T>(n: T, opts: ?{}): void;`, `declare export function removePropertiesDeep<T>(n: T, opts: ?{}): T;`, // retrievers/\n// eslint-disable-next-line max-len\n`declare export var getBindingIdentifiers: {\n    (node: ${NODE_PREFIX}, duplicates?: boolean, outerOnly?: boolean): { [key: string]: ${NODE_PREFIX}Identifier | Array<${NODE_PREFIX}Identifier> },\n    keys: { [type: string]: string[] }\n  }`, // eslint-disable-next-line max-len\n`declare export function getOuterBindingIdentifiers(node: BabelNode, duplicates?: boolean): { [key: string]: ${NODE_PREFIX}Identifier | Array<${NODE_PREFIX}Identifier> }`, // traverse/\n`declare type TraversalAncestors = Array<{\n    node: BabelNode,\n    key: string,\n    index?: number,\n  }>;\n  declare type TraversalHandler<T> = (BabelNode, TraversalAncestors, T) => void;\n  declare type TraversalHandlers<T> = {\n    enter?: TraversalHandler<T>,\n    exit?: TraversalHandler<T>,\n  };`.replace(/(^|\\n) {2}/g, \"$1\"), // eslint-disable-next-line\n`declare export function traverse<T>(n: BabelNode, TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;`, `declare export function traverseFast<T>(n: BabelNode, h: TraversalHandler<T>, state?: T): void;`, // utils/\n// cleanJSXElementLiteralChild is not exported\n// inherit is not exported\n`declare export function shallowEqual(actual: Object, expected: Object): boolean`, // validators/\n// eslint-disable-next-line max-len\n`declare export function buildMatchMemberExpression(match: string, allowPartial?: boolean): (?BabelNode) => boolean`, `declare export function is(type: string, n: BabelNode, opts: Object): boolean;`, `declare export function isBinding(node: BabelNode, parent: BabelNode, grandparent?: BabelNode): boolean`, `declare export function isBlockScoped(node: BabelNode): boolean`, `declare export function isImmutable(node: BabelNode): boolean`, `declare export function isLet(node: BabelNode): boolean`, `declare export function isNode(node: ?Object): boolean`, `declare export function isNodesEquivalent(a: any, b: any): boolean`, `declare export function isPlaceholderType(placeholderType: string, targetType: string): boolean`, `declare export function isReferenced(node: BabelNode, parent: BabelNode, grandparent?: BabelNode): boolean`, `declare export function isScope(node: BabelNode, parent: BabelNode): boolean`, `declare export function isSpecifierDefault(specifier: BabelNodeModuleSpecifier): boolean`, `declare export function isType(nodetype: ?string, targetType: string): boolean`, `declare export function isValidES3Identifier(name: string): boolean`, `declare export function isValidES3Identifier(name: string): boolean`, `declare export function isValidIdentifier(name: string): boolean`, `declare export function isVar(node: BabelNode): boolean`, // eslint-disable-next-line max-len\n`declare export function matchesPattern(node: ?BabelNode, match: string | Array<string>, allowPartial?: boolean): boolean`, `declare export function validate(n: BabelNode, key: string, value: mixed): void;`);\n\nfor (const type in t.FLIPPED_ALIAS_KEYS) {\n  const types = t.FLIPPED_ALIAS_KEYS[type];\n  code += `type ${NODE_PREFIX}${type} = ${types.map(type => `${NODE_PREFIX}${type}`).join(\" | \")};\\n`;\n}\n\ncode += `\\ndeclare module \"@babel/types\" {\n  ${lines.join(\"\\n\").replace(/\\n/g, \"\\n  \").trim()}\n}\\n`; //\n\nprocess.stdout.write(code);","map":{"version":3,"names":["t","stringifyValidator","toFunctionName","NODE_PREFIX","code","lines","type","NODE_FIELDS","fields","struct","args","builderNames","BUILDER_KEYS","Object","keys","sort","fieldA","fieldB","indexA","indexOf","indexB","forEach","fieldName","field","suffix","optional","default","typeAnnotation","validate","includes","push","toBindingIdentifierName","isValidIdentifier","join","trim","functionName","typeName","TYPES","isDeprecated","DEPRECATED_KEYS","realName","decl","replace","FLIPPED_ALIAS_KEYS","types","map","process","stdout","write"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/types/scripts/generators/flow.js"],"sourcesContent":["import * as t from \"../../lib/index.js\";\nimport stringifyValidator from \"../utils/stringifyValidator.js\";\nimport toFunctionName from \"../utils/toFunctionName.js\";\n\nconst NODE_PREFIX = \"BabelNode\";\n\nlet code = `// NOTE: This file is autogenerated. Do not modify.\n// See packages/babel-types/scripts/generators/flow.js for script used.\n\ndeclare class ${NODE_PREFIX}Comment {\n  value: string;\n  start: number;\n  end: number;\n  loc: ${NODE_PREFIX}SourceLocation;\n}\n\ndeclare class ${NODE_PREFIX}CommentBlock extends ${NODE_PREFIX}Comment {\n  type: \"CommentBlock\";\n}\n\ndeclare class ${NODE_PREFIX}CommentLine extends ${NODE_PREFIX}Comment {\n  type: \"CommentLine\";\n}\n\ndeclare class ${NODE_PREFIX}SourceLocation {\n  start: {\n    line: number;\n    column: number;\n  };\n\n  end: {\n    line: number;\n    column: number;\n  };\n}\n\ndeclare class ${NODE_PREFIX} {\n  leadingComments?: Array<${NODE_PREFIX}Comment>;\n  innerComments?: Array<${NODE_PREFIX}Comment>;\n  trailingComments?: Array<${NODE_PREFIX}Comment>;\n  start: ?number;\n  end: ?number;\n  loc: ?${NODE_PREFIX}SourceLocation;\n  extra?: { [string]: mixed };\n}\\n\\n`;\n\n//\n\nconst lines = [];\n\nfor (const type in t.NODE_FIELDS) {\n  const fields = t.NODE_FIELDS[type];\n\n  const struct = ['type: \"' + type + '\";'];\n  const args = [];\n  const builderNames = t.BUILDER_KEYS[type];\n\n  Object.keys(t.NODE_FIELDS[type])\n    .sort((fieldA, fieldB) => {\n      const indexA = t.BUILDER_KEYS[type].indexOf(fieldA);\n      const indexB = t.BUILDER_KEYS[type].indexOf(fieldB);\n      if (indexA === indexB) return fieldA < fieldB ? -1 : 1;\n      if (indexA === -1) return 1;\n      if (indexB === -1) return -1;\n      return indexA - indexB;\n    })\n    .forEach(fieldName => {\n      const field = fields[fieldName];\n\n      let suffix = \"\";\n      if (field.optional || field.default != null) suffix += \"?\";\n\n      let typeAnnotation = \"any\";\n\n      const validate = field.validate;\n      if (validate) {\n        typeAnnotation = stringifyValidator(validate, NODE_PREFIX);\n      }\n\n      if (typeAnnotation) {\n        suffix += \": \" + typeAnnotation;\n      }\n      if (builderNames.includes(fieldName)) {\n        args.push(t.toBindingIdentifierName(fieldName) + suffix);\n      }\n\n      if (t.isValidIdentifier(fieldName)) {\n        struct.push(fieldName + suffix + \";\");\n      }\n    });\n\n  code += `declare class ${NODE_PREFIX}${type} extends ${NODE_PREFIX} {\n  ${struct.join(\"\\n  \").trim()}\n}\\n\\n`;\n\n  // Flow chokes on super() and import() :/\n  if (type !== \"Super\" && type !== \"Import\") {\n    lines.push(\n      `declare export function ${toFunctionName(type)}(${args.join(\n        \", \"\n      )}): ${NODE_PREFIX}${type};`\n    );\n  } else {\n    const functionName = toFunctionName(type);\n    lines.push(\n      `declare function _${functionName}(${args.join(\n        \", \"\n      )}): ${NODE_PREFIX}${type};`,\n      `declare export { _${functionName} as ${functionName} }`\n    );\n  }\n}\n\nfor (const typeName of t.TYPES) {\n  const isDeprecated = !!t.DEPRECATED_KEYS[typeName];\n  const realName = isDeprecated ? t.DEPRECATED_KEYS[typeName] : typeName;\n\n  let decl = `declare export function is${typeName}(node: ?Object, opts?: ?Object): boolean`;\n  if (t.NODE_FIELDS[realName]) {\n    decl += ` %checks (node instanceof ${NODE_PREFIX}${realName})`;\n  }\n  lines.push(decl);\n\n  lines.push(\n    `declare export function assert${typeName}(node: ?Object, opts?: ?Object): void`\n  );\n}\n\nlines.push(\n  `declare export var VISITOR_KEYS: { [type: string]: string[] }`,\n\n  // assert/\n  `declare export function assertNode(obj: any): void`,\n\n  // builders/\n  // eslint-disable-next-line max-len\n  `declare export function createTypeAnnotationBasedOnTypeof(type: 'string' | 'number' | 'undefined' | 'boolean' | 'function' | 'object' | 'symbol'): ${NODE_PREFIX}TypeAnnotation`,\n  // eslint-disable-next-line max-len\n  `declare export function createUnionTypeAnnotation(types: Array<${NODE_PREFIX}FlowType>): ${NODE_PREFIX}UnionTypeAnnotation`,\n  // eslint-disable-next-line max-len\n  `declare export function createFlowUnionType(types: Array<${NODE_PREFIX}FlowType>): ${NODE_PREFIX}UnionTypeAnnotation`,\n  // this smells like \"internal API\"\n  // eslint-disable-next-line max-len\n  `declare export function buildChildren(node: { children: Array<${NODE_PREFIX}JSXText | ${NODE_PREFIX}JSXExpressionContainer | ${NODE_PREFIX}JSXSpreadChild | ${NODE_PREFIX}JSXElement | ${NODE_PREFIX}JSXFragment | ${NODE_PREFIX}JSXEmptyExpression> }): Array<${NODE_PREFIX}JSXText | ${NODE_PREFIX}JSXExpressionContainer | ${NODE_PREFIX}JSXSpreadChild | ${NODE_PREFIX}JSXElement | ${NODE_PREFIX}JSXFragment>`,\n\n  // clone/\n  `declare export function clone<T>(n: T): T;`,\n  `declare export function cloneDeep<T>(n: T): T;`,\n  `declare export function cloneDeepWithoutLoc<T>(n: T): T;`,\n  `declare export function cloneNode<T>(n: T, deep?: boolean, withoutLoc?: boolean): T;`,\n  `declare export function cloneWithoutLoc<T>(n: T): T;`,\n\n  // comments/\n  `declare type CommentTypeShorthand = 'leading' | 'inner' | 'trailing'`,\n  // eslint-disable-next-line max-len\n  `declare export function addComment<T: BabelNode>(node: T, type: CommentTypeShorthand, content: string, line?: boolean): T`,\n  // eslint-disable-next-line max-len\n  `declare export function addComments<T: BabelNode>(node: T, type: CommentTypeShorthand, comments: Array<Comment>): T`,\n  `declare export function inheritInnerComments(node: BabelNode, parent: BabelNode): void`,\n  `declare export function inheritLeadingComments(node: BabelNode, parent: BabelNode): void`,\n  `declare export function inheritsComments<T: BabelNode>(node: T, parent: BabelNode): void`,\n  `declare export function inheritTrailingComments(node: BabelNode, parent: BabelNode): void`,\n  `declare export function removeComments<T: BabelNode>(node: T): T`,\n\n  // converters/\n  `declare export function ensureBlock(node: ${NODE_PREFIX}, key: string): ${NODE_PREFIX}BlockStatement`,\n  `declare export function toBindingIdentifierName(name?: ?string): string`,\n  // eslint-disable-next-line max-len\n  `declare export function toBlock(node: ${NODE_PREFIX}Statement | ${NODE_PREFIX}Expression, parent?: ${NODE_PREFIX}Function | null): ${NODE_PREFIX}BlockStatement`,\n  // eslint-disable-next-line max-len\n  `declare export function toComputedKey(node: ${NODE_PREFIX}Method | ${NODE_PREFIX}Property, key?: ${NODE_PREFIX}Expression | ${NODE_PREFIX}Identifier): ${NODE_PREFIX}Expression`,\n  // eslint-disable-next-line max-len\n  `declare export function toExpression(node: ${NODE_PREFIX}ExpressionStatement | ${NODE_PREFIX}Expression | ${NODE_PREFIX}Class | ${NODE_PREFIX}Function): ${NODE_PREFIX}Expression`,\n  `declare export function toIdentifier(name?: ?string): string`,\n  // eslint-disable-next-line max-len\n  `declare export function toKeyAlias(node: ${NODE_PREFIX}Method | ${NODE_PREFIX}Property, key?: ${NODE_PREFIX}): string`,\n  // toSequenceExpression relies on types that aren't declared in flow\n  // eslint-disable-next-line max-len\n  `declare export function toStatement(node: ${NODE_PREFIX}Statement | ${NODE_PREFIX}Class | ${NODE_PREFIX}Function | ${NODE_PREFIX}AssignmentExpression, ignore?: boolean): ${NODE_PREFIX}Statement | void`,\n  `declare export function valueToNode(value: any): ${NODE_PREFIX}Expression`,\n\n  // modifications/\n  // eslint-disable-next-line max-len\n  `declare export function removeTypeDuplicates(types: Array<${NODE_PREFIX}FlowType>): Array<${NODE_PREFIX}FlowType>`,\n  // eslint-disable-next-line max-len\n  `declare export function appendToMemberExpression(member: ${NODE_PREFIX}MemberExpression, append: ${NODE_PREFIX}, computed?: boolean): ${NODE_PREFIX}MemberExpression`,\n  // eslint-disable-next-line max-len\n  `declare export function inherits<T: BabelNode>(child: T, parent: ${NODE_PREFIX} | null | void): T`,\n  // eslint-disable-next-line max-len\n  `declare export function prependToMemberExpression(member: ${NODE_PREFIX}MemberExpression, prepend: ${NODE_PREFIX}Expression): ${NODE_PREFIX}MemberExpression`,\n  `declare export function removeProperties<T>(n: T, opts: ?{}): void;`,\n  `declare export function removePropertiesDeep<T>(n: T, opts: ?{}): T;`,\n\n  // retrievers/\n  // eslint-disable-next-line max-len\n  `declare export var getBindingIdentifiers: {\n    (node: ${NODE_PREFIX}, duplicates?: boolean, outerOnly?: boolean): { [key: string]: ${NODE_PREFIX}Identifier | Array<${NODE_PREFIX}Identifier> },\n    keys: { [type: string]: string[] }\n  }`,\n  // eslint-disable-next-line max-len\n  `declare export function getOuterBindingIdentifiers(node: BabelNode, duplicates?: boolean): { [key: string]: ${NODE_PREFIX}Identifier | Array<${NODE_PREFIX}Identifier> }`,\n\n  // traverse/\n  `declare type TraversalAncestors = Array<{\n    node: BabelNode,\n    key: string,\n    index?: number,\n  }>;\n  declare type TraversalHandler<T> = (BabelNode, TraversalAncestors, T) => void;\n  declare type TraversalHandlers<T> = {\n    enter?: TraversalHandler<T>,\n    exit?: TraversalHandler<T>,\n  };`.replace(/(^|\\n) {2}/g, \"$1\"),\n  // eslint-disable-next-line\n  `declare export function traverse<T>(n: BabelNode, TraversalHandler<T> | TraversalHandlers<T>, state?: T): void;`,\n  `declare export function traverseFast<T>(n: BabelNode, h: TraversalHandler<T>, state?: T): void;`,\n\n  // utils/\n  // cleanJSXElementLiteralChild is not exported\n  // inherit is not exported\n  `declare export function shallowEqual(actual: Object, expected: Object): boolean`,\n\n  // validators/\n  // eslint-disable-next-line max-len\n  `declare export function buildMatchMemberExpression(match: string, allowPartial?: boolean): (?BabelNode) => boolean`,\n  `declare export function is(type: string, n: BabelNode, opts: Object): boolean;`,\n  `declare export function isBinding(node: BabelNode, parent: BabelNode, grandparent?: BabelNode): boolean`,\n  `declare export function isBlockScoped(node: BabelNode): boolean`,\n  `declare export function isImmutable(node: BabelNode): boolean`,\n  `declare export function isLet(node: BabelNode): boolean`,\n  `declare export function isNode(node: ?Object): boolean`,\n  `declare export function isNodesEquivalent(a: any, b: any): boolean`,\n  `declare export function isPlaceholderType(placeholderType: string, targetType: string): boolean`,\n  `declare export function isReferenced(node: BabelNode, parent: BabelNode, grandparent?: BabelNode): boolean`,\n  `declare export function isScope(node: BabelNode, parent: BabelNode): boolean`,\n  `declare export function isSpecifierDefault(specifier: BabelNodeModuleSpecifier): boolean`,\n  `declare export function isType(nodetype: ?string, targetType: string): boolean`,\n  `declare export function isValidES3Identifier(name: string): boolean`,\n  `declare export function isValidES3Identifier(name: string): boolean`,\n  `declare export function isValidIdentifier(name: string): boolean`,\n  `declare export function isVar(node: BabelNode): boolean`,\n  // eslint-disable-next-line max-len\n  `declare export function matchesPattern(node: ?BabelNode, match: string | Array<string>, allowPartial?: boolean): boolean`,\n  `declare export function validate(n: BabelNode, key: string, value: mixed): void;`\n);\n\nfor (const type in t.FLIPPED_ALIAS_KEYS) {\n  const types = t.FLIPPED_ALIAS_KEYS[type];\n  code += `type ${NODE_PREFIX}${type} = ${types\n    .map(type => `${NODE_PREFIX}${type}`)\n    .join(\" | \")};\\n`;\n}\n\ncode += `\\ndeclare module \"@babel/types\" {\n  ${lines.join(\"\\n\").replace(/\\n/g, \"\\n  \").trim()}\n}\\n`;\n\n//\n\nprocess.stdout.write(code);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}