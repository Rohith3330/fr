{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = mayContainChildComponent;\n\nvar _jsxAstUtils = require(\"jsx-ast-utils\");\n\nvar _minimatch = _interopRequireDefault(require(\"minimatch\"));\n/**\n * Returns true if it can positively determine that the element lacks an\n * accessible label. If no determination is possible, it returns false. Treat\n * false as an unknown value. The element might still have an accessible label,\n * but this module cannot determine it positively.\n *\n * \n */\n\n\nfunction mayContainChildComponent(root, componentName) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var elementType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _jsxAstUtils.elementType;\n\n  function traverseChildren(node, depth) {\n    // Bail when maxDepth is exceeded.\n    if (depth > maxDepth) {\n      return false;\n    }\n\n    if (node.children) {\n      /* $FlowFixMe */\n      for (var i = 0; i < node.children.length; i += 1) {\n        /* $FlowFixMe */\n        var childNode = node.children[i]; // Assume an expression container renders a label. It is the best we can\n        // do in this case.\n\n        if (childNode.type === 'JSXExpressionContainer') {\n          return true;\n        } // Check for comonents with the provided name.\n\n\n        if (childNode.type === 'JSXElement' && childNode.openingElement && (0, _minimatch[\"default\"])(elementType(childNode.openingElement), componentName)) {\n          return true;\n        }\n\n        if (traverseChildren(childNode, depth + 1)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return traverseChildren(root, 1);\n}\n\nmodule.exports = exports.default;","map":{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","mayContainChildComponent","_jsxAstUtils","_minimatch","root","componentName","maxDepth","arguments","length","undefined","elementType","traverseChildren","node","depth","children","i","childNode","type","openingElement","module","default"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-jsx-a11y/lib/util/mayContainChildComponent.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = mayContainChildComponent;\n\nvar _jsxAstUtils = require(\"jsx-ast-utils\");\n\nvar _minimatch = _interopRequireDefault(require(\"minimatch\"));\n\n/**\n * Returns true if it can positively determine that the element lacks an\n * accessible label. If no determination is possible, it returns false. Treat\n * false as an unknown value. The element might still have an accessible label,\n * but this module cannot determine it positively.\n *\n * \n */\nfunction mayContainChildComponent(root, componentName) {\n  var maxDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var elementType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _jsxAstUtils.elementType;\n\n  function traverseChildren(node, depth) {\n    // Bail when maxDepth is exceeded.\n    if (depth > maxDepth) {\n      return false;\n    }\n\n    if (node.children) {\n      /* $FlowFixMe */\n      for (var i = 0; i < node.children.length; i += 1) {\n        /* $FlowFixMe */\n        var childNode = node.children[i]; // Assume an expression container renders a label. It is the best we can\n        // do in this case.\n\n        if (childNode.type === 'JSXExpressionContainer') {\n          return true;\n        } // Check for comonents with the provided name.\n\n\n        if (childNode.type === 'JSXElement' && childNode.openingElement && (0, _minimatch[\"default\"])(elementType(childNode.openingElement), componentName)) {\n          return true;\n        }\n\n        if (traverseChildren(childNode, depth + 1)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  return traverseChildren(root, 1);\n}\n\nmodule.exports = exports.default;"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAAC,SAAD,CAAP,GAAqBE,wBAArB;;AAEA,IAAIC,YAAY,GAAGN,OAAO,CAAC,eAAD,CAA1B;;AAEA,IAAIO,UAAU,GAAGR,sBAAsB,CAACC,OAAO,CAAC,WAAD,CAAR,CAAvC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,wBAAT,CAAkCG,IAAlC,EAAwCC,aAAxC,EAAuD;EACrD,IAAIC,QAAQ,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAnF;EACA,IAAIG,WAAW,GAAGH,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoEL,YAAY,CAACQ,WAAnG;;EAEA,SAASC,gBAAT,CAA0BC,IAA1B,EAAgCC,KAAhC,EAAuC;IACrC;IACA,IAAIA,KAAK,GAAGP,QAAZ,EAAsB;MACpB,OAAO,KAAP;IACD;;IAED,IAAIM,IAAI,CAACE,QAAT,EAAmB;MACjB;MACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAAI,CAACE,QAAL,CAAcN,MAAlC,EAA0CO,CAAC,IAAI,CAA/C,EAAkD;QAChD;QACA,IAAIC,SAAS,GAAGJ,IAAI,CAACE,QAAL,CAAcC,CAAd,CAAhB,CAFgD,CAEd;QAClC;;QAEA,IAAIC,SAAS,CAACC,IAAV,KAAmB,wBAAvB,EAAiD;UAC/C,OAAO,IAAP;QACD,CAP+C,CAO9C;;;QAGF,IAAID,SAAS,CAACC,IAAV,KAAmB,YAAnB,IAAmCD,SAAS,CAACE,cAA7C,IAA+D,CAAC,GAAGf,UAAU,CAAC,SAAD,CAAd,EAA2BO,WAAW,CAACM,SAAS,CAACE,cAAX,CAAtC,EAAkEb,aAAlE,CAAnE,EAAqJ;UACnJ,OAAO,IAAP;QACD;;QAED,IAAIM,gBAAgB,CAACK,SAAD,EAAYH,KAAK,GAAG,CAApB,CAApB,EAA4C;UAC1C,OAAO,IAAP;QACD;MACF;IACF;;IAED,OAAO,KAAP;EACD;;EAED,OAAOF,gBAAgB,CAACP,IAAD,EAAO,CAAP,CAAvB;AACD;;AAEDe,MAAM,CAACpB,OAAP,GAAiBA,OAAO,CAACqB,OAAzB"},"metadata":{},"sourceType":"script"}