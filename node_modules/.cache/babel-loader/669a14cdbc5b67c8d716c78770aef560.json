{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst groups = {\n  function: 'function',\n  intersection: 'intersection',\n  keyword: 'keyword',\n  literal: 'literal',\n  named: 'named',\n  nullish: 'nullish',\n  object: 'object',\n  tuple: 'tuple',\n  union: 'union',\n  unknown: 'unknown'\n}; // eslint-disable-next-line complexity\n\nconst getGroup = node => {\n  // eslint-disable-next-line default-case\n  switch (node.type) {\n    case 'FunctionTypeAnnotation':\n      return groups.function;\n\n    case 'IntersectionTypeAnnotation':\n      return groups.intersection;\n\n    case 'AnyTypeAnnotation':\n    case 'BooleanTypeAnnotation':\n    case 'NumberTypeAnnotation':\n    case 'StringTypeAnnotation':\n    case 'SymbolTypeAnnotation':\n    case 'ThisTypeAnnotation':\n      return groups.keyword;\n\n    case 'NullLiteralTypeAnnotation':\n    case 'NullableTypeAnnotation':\n    case 'VoidTypeAnnotation':\n      return groups.nullish;\n\n    case 'BooleanLiteralTypeAnnotation':\n    case 'NumberLiteralTypeAnnotation':\n    case 'StringLiteralTypeAnnotation':\n      return groups.literal;\n\n    case 'ArrayTypeAnnotation':\n    case 'IndexedAccessType':\n    case 'GenericTypeAnnotation':\n    case 'OptionalIndexedAccessType':\n      return groups.named;\n\n    case 'ObjectTypeAnnotation':\n      return groups.object;\n\n    case 'TupleTypeAnnotation':\n      return groups.tuple;\n\n    case 'UnionTypeAnnotation':\n      return groups.union;\n  }\n\n  return groups.unknown;\n};\n\nconst fallbackSort = (a, b) => {\n  if (a < b) {\n    return -1;\n  }\n\n  if (a > b) {\n    return 1;\n  }\n\n  return 0;\n};\n\nconst sorters = {\n  asc: (collator, a, b) => {\n    return collator.compare(a, b) || fallbackSort(a, b);\n  },\n  desc: (collator, a, b) => {\n    return collator.compare(b, a) || fallbackSort(b, a);\n  }\n};\n\nconst create = context => {\n  const sourceCode = context.getSourceCode();\n  const {\n    checkIntersections = true,\n    checkUnions = true,\n    groupOrder = [groups.keyword, groups.named, groups.literal, groups.function, groups.object, groups.tuple, groups.intersection, groups.union, groups.nullish],\n    order = 'asc'\n  } = context.options[1] || {};\n  const sort = sorters[order];\n  const collator = new Intl.Collator('en', {\n    numeric: true,\n    sensitivity: 'base'\n  });\n\n  const checkSorting = node => {\n    const sourceOrder = node.types.map(type => {\n      var _groupOrder$indexOf;\n\n      const group = (_groupOrder$indexOf = groupOrder === null || groupOrder === void 0 ? void 0 : groupOrder.indexOf(getGroup(type))) !== null && _groupOrder$indexOf !== void 0 ? _groupOrder$indexOf : -1;\n      return {\n        group: group === -1 ? Number.MAX_SAFE_INTEGER : group,\n        node: type,\n        text: sourceCode.getText(type)\n      };\n    });\n    const expectedOrder = [...sourceOrder].sort((a, b) => {\n      if (a.group !== b.group) {\n        return a.group - b.group;\n      }\n\n      return sort(collator, a.text, b.text);\n    });\n    const hasComments = node.types.some(type => {\n      const count = sourceCode.getCommentsBefore(type).length + sourceCode.getCommentsAfter(type).length;\n      return count > 0;\n    });\n    let prev = null;\n\n    for (let i = 0; i < expectedOrder.length; i += 1) {\n      const type = node.type === 'UnionTypeAnnotation' ? 'union' : 'intersection';\n      const current = sourceOrder[i].text;\n      const last = prev; // keep track of the last token\n\n      prev = current || last;\n\n      if (!last || !current) {\n        continue;\n      }\n\n      if (expectedOrder[i].node !== sourceOrder[i].node) {\n        const data = {\n          current,\n          last,\n          order,\n          type\n        };\n\n        const fix = fixer => {\n          const sorted = expectedOrder.map(t => {\n            return t.text;\n          }).join(node.type === 'UnionTypeAnnotation' ? ' | ' : ' & ');\n          return fixer.replaceText(node, sorted);\n        };\n\n        context.report(_objectSpread({\n          data,\n          messageId: 'notSorted',\n          node\n        }, hasComments ? {\n          suggest: [{\n            fix,\n            messageId: 'suggestFix'\n          }]\n        } : {\n          fix\n        }));\n      }\n    }\n  };\n\n  return {\n    IntersectionTypeAnnotation(node) {\n      if (checkIntersections === true) {\n        checkSorting(node);\n      }\n    },\n\n    UnionTypeAnnotation(node) {\n      if (checkUnions === true) {\n        checkSorting(node);\n      }\n    }\n\n  };\n};\n\nvar _default = {\n  create,\n  meta: {\n    fixable: 'code',\n    messages: {\n      notSorted: 'Expected {{type}} members to be in {{order}}ending order. \"{{current}}\" should be before \"{{last}}\".',\n      suggestFix: 'Sort members of type (removes all comments).'\n    },\n    schema: [{\n      properties: {\n        checkIntersections: {\n          type: 'boolean'\n        },\n        checkUnions: {\n          type: 'boolean'\n        },\n        groupOrder: {\n          items: {\n            enum: Object.keys(groups),\n            type: 'string'\n          },\n          type: 'array'\n        },\n        order: {\n          enum: ['asc', 'desc'],\n          type: 'string'\n        }\n      },\n      type: 'object'\n    }]\n  }\n};\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","obj","configurable","writable","groups","function","intersection","keyword","literal","named","nullish","tuple","union","unknown","getGroup","node","type","fallbackSort","a","b","sorters","asc","collator","compare","desc","create","context","sourceCode","getSourceCode","checkIntersections","checkUnions","groupOrder","order","options","sort","Intl","Collator","numeric","sensitivity","checkSorting","sourceOrder","types","map","_groupOrder$indexOf","group","indexOf","Number","MAX_SAFE_INTEGER","text","getText","expectedOrder","hasComments","some","count","getCommentsBefore","getCommentsAfter","prev","current","last","data","fix","fixer","sorted","t","join","replaceText","report","messageId","suggest","IntersectionTypeAnnotation","UnionTypeAnnotation","_default","meta","fixable","messages","notSorted","suggestFix","schema","properties","items","enum","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-flowtype/dist/rules/sortTypeUnionIntersectionMembers.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst groups = {\n  function: 'function',\n  intersection: 'intersection',\n  keyword: 'keyword',\n  literal: 'literal',\n  named: 'named',\n  nullish: 'nullish',\n  object: 'object',\n  tuple: 'tuple',\n  union: 'union',\n  unknown: 'unknown'\n}; // eslint-disable-next-line complexity\n\nconst getGroup = node => {\n  // eslint-disable-next-line default-case\n  switch (node.type) {\n    case 'FunctionTypeAnnotation':\n      return groups.function;\n\n    case 'IntersectionTypeAnnotation':\n      return groups.intersection;\n\n    case 'AnyTypeAnnotation':\n    case 'BooleanTypeAnnotation':\n    case 'NumberTypeAnnotation':\n    case 'StringTypeAnnotation':\n    case 'SymbolTypeAnnotation':\n    case 'ThisTypeAnnotation':\n      return groups.keyword;\n\n    case 'NullLiteralTypeAnnotation':\n    case 'NullableTypeAnnotation':\n    case 'VoidTypeAnnotation':\n      return groups.nullish;\n\n    case 'BooleanLiteralTypeAnnotation':\n    case 'NumberLiteralTypeAnnotation':\n    case 'StringLiteralTypeAnnotation':\n      return groups.literal;\n\n    case 'ArrayTypeAnnotation':\n    case 'IndexedAccessType':\n    case 'GenericTypeAnnotation':\n    case 'OptionalIndexedAccessType':\n      return groups.named;\n\n    case 'ObjectTypeAnnotation':\n      return groups.object;\n\n    case 'TupleTypeAnnotation':\n      return groups.tuple;\n\n    case 'UnionTypeAnnotation':\n      return groups.union;\n  }\n\n  return groups.unknown;\n};\n\nconst fallbackSort = (a, b) => {\n  if (a < b) {\n    return -1;\n  }\n\n  if (a > b) {\n    return 1;\n  }\n\n  return 0;\n};\n\nconst sorters = {\n  asc: (collator, a, b) => {\n    return collator.compare(a, b) || fallbackSort(a, b);\n  },\n  desc: (collator, a, b) => {\n    return collator.compare(b, a) || fallbackSort(b, a);\n  }\n};\n\nconst create = context => {\n  const sourceCode = context.getSourceCode();\n  const {\n    checkIntersections = true,\n    checkUnions = true,\n    groupOrder = [groups.keyword, groups.named, groups.literal, groups.function, groups.object, groups.tuple, groups.intersection, groups.union, groups.nullish],\n    order = 'asc'\n  } = context.options[1] || {};\n  const sort = sorters[order];\n  const collator = new Intl.Collator('en', {\n    numeric: true,\n    sensitivity: 'base'\n  });\n\n  const checkSorting = node => {\n    const sourceOrder = node.types.map(type => {\n      var _groupOrder$indexOf;\n\n      const group = (_groupOrder$indexOf = groupOrder === null || groupOrder === void 0 ? void 0 : groupOrder.indexOf(getGroup(type))) !== null && _groupOrder$indexOf !== void 0 ? _groupOrder$indexOf : -1;\n      return {\n        group: group === -1 ? Number.MAX_SAFE_INTEGER : group,\n        node: type,\n        text: sourceCode.getText(type)\n      };\n    });\n    const expectedOrder = [...sourceOrder].sort((a, b) => {\n      if (a.group !== b.group) {\n        return a.group - b.group;\n      }\n\n      return sort(collator, a.text, b.text);\n    });\n    const hasComments = node.types.some(type => {\n      const count = sourceCode.getCommentsBefore(type).length + sourceCode.getCommentsAfter(type).length;\n      return count > 0;\n    });\n    let prev = null;\n\n    for (let i = 0; i < expectedOrder.length; i += 1) {\n      const type = node.type === 'UnionTypeAnnotation' ? 'union' : 'intersection';\n      const current = sourceOrder[i].text;\n      const last = prev; // keep track of the last token\n\n      prev = current || last;\n\n      if (!last || !current) {\n        continue;\n      }\n\n      if (expectedOrder[i].node !== sourceOrder[i].node) {\n        const data = {\n          current,\n          last,\n          order,\n          type\n        };\n\n        const fix = fixer => {\n          const sorted = expectedOrder.map(t => {\n            return t.text;\n          }).join(node.type === 'UnionTypeAnnotation' ? ' | ' : ' & ');\n          return fixer.replaceText(node, sorted);\n        };\n\n        context.report(_objectSpread({\n          data,\n          messageId: 'notSorted',\n          node\n        }, hasComments ? {\n          suggest: [{\n            fix,\n            messageId: 'suggestFix'\n          }]\n        } : {\n          fix\n        }));\n      }\n    }\n  };\n\n  return {\n    IntersectionTypeAnnotation(node) {\n      if (checkIntersections === true) {\n        checkSorting(node);\n      }\n    },\n\n    UnionTypeAnnotation(node) {\n      if (checkUnions === true) {\n        checkSorting(node);\n      }\n    }\n\n  };\n};\n\nvar _default = {\n  create,\n  meta: {\n    fixable: 'code',\n    messages: {\n      notSorted: 'Expected {{type}} members to be in {{order}}ending order. \"{{current}}\" should be before \"{{last}}\".',\n      suggestFix: 'Sort members of type (removes all comments).'\n    },\n    schema: [{\n      properties: {\n        checkIntersections: {\n          type: 'boolean'\n        },\n        checkUnions: {\n          type: 'boolean'\n        },\n        groupOrder: {\n          items: {\n            enum: Object.keys(groups),\n            type: 'string'\n          },\n          type: 'array'\n        },\n        order: {\n          enum: ['asc', 'desc'],\n          type: 'string'\n        }\n      },\n      type: 'object'\n    }]\n  }\n};\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}