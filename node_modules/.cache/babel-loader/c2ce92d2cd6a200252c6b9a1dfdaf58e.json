{"ast":null,"code":"\"use strict\";\n\nconst baseEncodeTables = {\n  26: \"abcdefghijklmnopqrstuvwxyz\",\n  32: \"123456789abcdefghjkmnpqrstuvwxyz\",\n  // no 0lio\n  36: \"0123456789abcdefghijklmnopqrstuvwxyz\",\n  49: \"abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\",\n  // no lIO\n  52: \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n  58: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\",\n  // no 0lIO\n  62: \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n  64: \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_\"\n};\n/**\n * @param {Uint32Array} uint32Array Treated as a long base-0x100000000 number, little endian\n * @param {number} divisor The divisor\n * @return {number} Modulo (remainder) of the division\n */\n\nfunction divmod32(uint32Array, divisor) {\n  let carry = 0;\n\n  for (let i = uint32Array.length - 1; i >= 0; i--) {\n    const value = carry * 0x100000000 + uint32Array[i];\n    carry = value % divisor;\n    uint32Array[i] = Math.floor(value / divisor);\n  }\n\n  return carry;\n}\n\nfunction encodeBufferToBase(buffer, base, length) {\n  const encodeTable = baseEncodeTables[base];\n\n  if (!encodeTable) {\n    throw new Error(\"Unknown encoding base\" + base);\n  } // Input bits are only enough to generate this many characters\n\n\n  const limit = Math.ceil(buffer.length * 8 / Math.log2(base));\n  length = Math.min(length, limit); // Most of the crypto digests (if not all) has length a multiple of 4 bytes.\n  // Fewer numbers in the array means faster math.\n\n  const uint32Array = new Uint32Array(Math.ceil(buffer.length / 4)); // Make sure the input buffer data is copied and is not mutated by reference.\n  // divmod32() would corrupt the BulkUpdateDecorator cache otherwise.\n\n  buffer.copy(Buffer.from(uint32Array.buffer));\n  let output = \"\";\n\n  for (let i = 0; i < length; i++) {\n    output = encodeTable[divmod32(uint32Array, base)] + output;\n  }\n\n  return output;\n}\n\nlet crypto = undefined;\nlet createXXHash64 = undefined;\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\nlet BulkUpdateDecorator = undefined;\n\nfunction getHashDigest(buffer, algorithm, digestType, maxLength) {\n  algorithm = algorithm || \"xxhash64\";\n  maxLength = maxLength || 9999;\n  let hash;\n\n  if (algorithm === \"xxhash64\") {\n    if (createXXHash64 === undefined) {\n      createXXHash64 = require(\"./hash/xxhash64\");\n\n      if (BatchedHash === undefined) {\n        BatchedHash = require(\"./hash/BatchedHash\");\n      }\n    }\n\n    hash = new BatchedHash(createXXHash64());\n  } else if (algorithm === \"md4\") {\n    if (createMd4 === undefined) {\n      createMd4 = require(\"./hash/md4\");\n\n      if (BatchedHash === undefined) {\n        BatchedHash = require(\"./hash/BatchedHash\");\n      }\n    }\n\n    hash = new BatchedHash(createMd4());\n  } else if (algorithm === \"native-md4\") {\n    if (typeof crypto === \"undefined\") {\n      crypto = require(\"crypto\");\n\n      if (BulkUpdateDecorator === undefined) {\n        BulkUpdateDecorator = require(\"./hash/BulkUpdateDecorator\");\n      }\n    }\n\n    hash = new BulkUpdateDecorator(() => crypto.createHash(\"md4\"), \"md4\");\n  } else {\n    if (typeof crypto === \"undefined\") {\n      crypto = require(\"crypto\");\n\n      if (BulkUpdateDecorator === undefined) {\n        BulkUpdateDecorator = require(\"./hash/BulkUpdateDecorator\");\n      }\n    }\n\n    hash = new BulkUpdateDecorator(() => crypto.createHash(algorithm), algorithm);\n  }\n\n  hash.update(buffer);\n\n  if (digestType === \"base26\" || digestType === \"base32\" || digestType === \"base36\" || digestType === \"base49\" || digestType === \"base52\" || digestType === \"base58\" || digestType === \"base62\") {\n    return encodeBufferToBase(hash.digest(), digestType.substr(4), maxLength);\n  } else {\n    return hash.digest(digestType || \"hex\").substr(0, maxLength);\n  }\n}\n\nmodule.exports = getHashDigest;","map":{"version":3,"names":["baseEncodeTables","divmod32","uint32Array","divisor","carry","i","length","value","Math","floor","encodeBufferToBase","buffer","base","encodeTable","Error","limit","ceil","log2","min","Uint32Array","copy","Buffer","from","output","crypto","undefined","createXXHash64","createMd4","BatchedHash","BulkUpdateDecorator","getHashDigest","algorithm","digestType","maxLength","hash","require","createHash","update","digest","substr","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/react-dev-utils/node_modules/loader-utils/lib/getHashDigest.js"],"sourcesContent":["\"use strict\";\n\nconst baseEncodeTables = {\n  26: \"abcdefghijklmnopqrstuvwxyz\",\n  32: \"123456789abcdefghjkmnpqrstuvwxyz\", // no 0lio\n  36: \"0123456789abcdefghijklmnopqrstuvwxyz\",\n  49: \"abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\", // no lIO\n  52: \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n  58: \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\", // no 0lIO\n  62: \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n  64: \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_\",\n};\n\n/**\n * @param {Uint32Array} uint32Array Treated as a long base-0x100000000 number, little endian\n * @param {number} divisor The divisor\n * @return {number} Modulo (remainder) of the division\n */\nfunction divmod32(uint32Array, divisor) {\n  let carry = 0;\n  for (let i = uint32Array.length - 1; i >= 0; i--) {\n    const value = carry * 0x100000000 + uint32Array[i];\n    carry = value % divisor;\n    uint32Array[i] = Math.floor(value / divisor);\n  }\n  return carry;\n}\n\nfunction encodeBufferToBase(buffer, base, length) {\n  const encodeTable = baseEncodeTables[base];\n\n  if (!encodeTable) {\n    throw new Error(\"Unknown encoding base\" + base);\n  }\n\n  // Input bits are only enough to generate this many characters\n  const limit = Math.ceil((buffer.length * 8) / Math.log2(base));\n  length = Math.min(length, limit);\n\n  // Most of the crypto digests (if not all) has length a multiple of 4 bytes.\n  // Fewer numbers in the array means faster math.\n  const uint32Array = new Uint32Array(Math.ceil(buffer.length / 4));\n\n  // Make sure the input buffer data is copied and is not mutated by reference.\n  // divmod32() would corrupt the BulkUpdateDecorator cache otherwise.\n  buffer.copy(Buffer.from(uint32Array.buffer));\n\n  let output = \"\";\n\n  for (let i = 0; i < length; i++) {\n    output = encodeTable[divmod32(uint32Array, base)] + output;\n  }\n\n  return output;\n}\n\nlet crypto = undefined;\nlet createXXHash64 = undefined;\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\nlet BulkUpdateDecorator = undefined;\n\nfunction getHashDigest(buffer, algorithm, digestType, maxLength) {\n  algorithm = algorithm || \"xxhash64\";\n  maxLength = maxLength || 9999;\n\n  let hash;\n\n  if (algorithm === \"xxhash64\") {\n    if (createXXHash64 === undefined) {\n      createXXHash64 = require(\"./hash/xxhash64\");\n\n      if (BatchedHash === undefined) {\n        BatchedHash = require(\"./hash/BatchedHash\");\n      }\n    }\n\n    hash = new BatchedHash(createXXHash64());\n  } else if (algorithm === \"md4\") {\n    if (createMd4 === undefined) {\n      createMd4 = require(\"./hash/md4\");\n\n      if (BatchedHash === undefined) {\n        BatchedHash = require(\"./hash/BatchedHash\");\n      }\n    }\n\n    hash = new BatchedHash(createMd4());\n  } else if (algorithm === \"native-md4\") {\n    if (typeof crypto === \"undefined\") {\n      crypto = require(\"crypto\");\n\n      if (BulkUpdateDecorator === undefined) {\n        BulkUpdateDecorator = require(\"./hash/BulkUpdateDecorator\");\n      }\n    }\n\n    hash = new BulkUpdateDecorator(() => crypto.createHash(\"md4\"), \"md4\");\n  } else {\n    if (typeof crypto === \"undefined\") {\n      crypto = require(\"crypto\");\n\n      if (BulkUpdateDecorator === undefined) {\n        BulkUpdateDecorator = require(\"./hash/BulkUpdateDecorator\");\n      }\n    }\n\n    hash = new BulkUpdateDecorator(\n      () => crypto.createHash(algorithm),\n      algorithm\n    );\n  }\n\n  hash.update(buffer);\n\n  if (\n    digestType === \"base26\" ||\n    digestType === \"base32\" ||\n    digestType === \"base36\" ||\n    digestType === \"base49\" ||\n    digestType === \"base52\" ||\n    digestType === \"base58\" ||\n    digestType === \"base62\"\n  ) {\n    return encodeBufferToBase(hash.digest(), digestType.substr(4), maxLength);\n  } else {\n    return hash.digest(digestType || \"hex\").substr(0, maxLength);\n  }\n}\n\nmodule.exports = getHashDigest;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}