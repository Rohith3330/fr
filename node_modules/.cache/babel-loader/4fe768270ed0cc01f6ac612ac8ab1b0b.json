{"ast":null,"code":"const createCustomError = require('../utils/createCustomError');\n\nconst generate = require('../definition-syntax/generate');\n\nconst defaultLoc = {\n  offset: 0,\n  line: 1,\n  column: 1\n};\n\nfunction locateMismatch(matchResult, node) {\n  const tokens = matchResult.tokens;\n  const longestMatch = matchResult.longestMatch;\n  const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;\n  const badNode = mismatchNode !== node ? mismatchNode : null;\n  let mismatchOffset = 0;\n  let mismatchLength = 0;\n  let entries = 0;\n  let css = '';\n  let start;\n  let end;\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i].value;\n\n    if (i === longestMatch) {\n      mismatchLength = token.length;\n      mismatchOffset = css.length;\n    }\n\n    if (badNode !== null && tokens[i].node === badNode) {\n      if (i <= longestMatch) {\n        entries++;\n      } else {\n        entries = 0;\n      }\n    }\n\n    css += token;\n  }\n\n  if (longestMatch === tokens.length || entries > 1) {\n    // last\n    start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);\n    end = buildLoc(start);\n  } else {\n    start = fromLoc(badNode, 'start') || buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));\n    end = fromLoc(badNode, 'end') || buildLoc(start, css.substr(mismatchOffset, mismatchLength));\n  }\n\n  return {\n    css,\n    mismatchOffset,\n    mismatchLength,\n    start,\n    end\n  };\n}\n\nfunction fromLoc(node, point) {\n  const value = node && node.loc && node.loc[point];\n\n  if (value) {\n    return 'line' in value ? buildLoc(value) : value;\n  }\n\n  return null;\n}\n\nfunction buildLoc(_ref, extra) {\n  let {\n    offset,\n    line,\n    column\n  } = _ref;\n  const loc = {\n    offset,\n    line,\n    column\n  };\n\n  if (extra) {\n    const lines = extra.split(/\\n|\\r\\n?|\\f/);\n    loc.offset += extra.length;\n    loc.line += lines.length - 1;\n    loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;\n  }\n\n  return loc;\n}\n\nconst SyntaxReferenceError = function (type, referenceName) {\n  const error = createCustomError('SyntaxReferenceError', type + (referenceName ? ' `' + referenceName + '`' : ''));\n  error.reference = referenceName;\n  return error;\n};\n\nconst SyntaxMatchError = function (message, syntax, node, matchResult) {\n  const error = createCustomError('SyntaxMatchError', message);\n  const {\n    css,\n    mismatchOffset,\n    mismatchLength,\n    start,\n    end\n  } = locateMismatch(matchResult, node);\n  error.rawMessage = message;\n  error.syntax = syntax ? generate(syntax) : '<generic>';\n  error.css = css;\n  error.mismatchOffset = mismatchOffset;\n  error.mismatchLength = mismatchLength;\n  error.message = message + '\\n' + '  syntax: ' + error.syntax + '\\n' + '   value: ' + (css || '<empty string>') + '\\n' + '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';\n  Object.assign(error, start);\n  error.loc = {\n    source: node && node.loc && node.loc.source || '<unknown>',\n    start,\n    end\n  };\n  return error;\n};\n\nmodule.exports = {\n  SyntaxReferenceError,\n  SyntaxMatchError\n};","map":{"version":3,"names":["createCustomError","require","generate","defaultLoc","offset","line","column","locateMismatch","matchResult","node","tokens","longestMatch","mismatchNode","length","badNode","mismatchOffset","mismatchLength","entries","css","start","end","i","token","value","fromLoc","buildLoc","slice","substr","point","loc","extra","lines","split","pop","SyntaxReferenceError","type","referenceName","error","reference","SyntaxMatchError","message","syntax","rawMessage","Array","join","Object","assign","source","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/css-tree/lib/lexer/error.js"],"sourcesContent":["const createCustomError = require('../utils/createCustomError');\nconst generate = require('../definition-syntax/generate');\nconst defaultLoc = { offset: 0, line: 1, column: 1 };\n\nfunction locateMismatch(matchResult, node) {\n    const tokens = matchResult.tokens;\n    const longestMatch = matchResult.longestMatch;\n    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;\n    const badNode = mismatchNode !== node ? mismatchNode : null;\n    let mismatchOffset = 0;\n    let mismatchLength = 0;\n    let entries = 0;\n    let css = '';\n    let start;\n    let end;\n\n    for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i].value;\n\n        if (i === longestMatch) {\n            mismatchLength = token.length;\n            mismatchOffset = css.length;\n        }\n\n        if (badNode !== null && tokens[i].node === badNode) {\n            if (i <= longestMatch) {\n                entries++;\n            } else {\n                entries = 0;\n            }\n        }\n\n        css += token;\n    }\n\n    if (longestMatch === tokens.length || entries > 1) { // last\n        start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);\n        end = buildLoc(start);\n    } else {\n        start = fromLoc(badNode, 'start') ||\n            buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));\n        end = fromLoc(badNode, 'end') ||\n            buildLoc(start, css.substr(mismatchOffset, mismatchLength));\n    }\n\n    return {\n        css,\n        mismatchOffset,\n        mismatchLength,\n        start,\n        end\n    };\n}\n\nfunction fromLoc(node, point) {\n    const value = node && node.loc && node.loc[point];\n\n    if (value) {\n        return 'line' in value ? buildLoc(value) : value;\n    }\n\n    return null;\n}\n\nfunction buildLoc({ offset, line, column }, extra) {\n    const loc = {\n        offset,\n        line,\n        column\n    };\n\n    if (extra) {\n        const lines = extra.split(/\\n|\\r\\n?|\\f/);\n\n        loc.offset += extra.length;\n        loc.line += lines.length - 1;\n        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;\n    }\n\n    return loc;\n}\n\nconst SyntaxReferenceError = function(type, referenceName) {\n    const error = createCustomError(\n        'SyntaxReferenceError',\n        type + (referenceName ? ' `' + referenceName + '`' : '')\n    );\n\n    error.reference = referenceName;\n\n    return error;\n};\n\nconst SyntaxMatchError = function(message, syntax, node, matchResult) {\n    const error = createCustomError('SyntaxMatchError', message);\n    const {\n        css,\n        mismatchOffset,\n        mismatchLength,\n        start,\n        end\n    } = locateMismatch(matchResult, node);\n\n    error.rawMessage = message;\n    error.syntax = syntax ? generate(syntax) : '<generic>';\n    error.css = css;\n    error.mismatchOffset = mismatchOffset;\n    error.mismatchLength = mismatchLength;\n    error.message = message + '\\n' +\n        '  syntax: ' + error.syntax + '\\n' +\n        '   value: ' + (css || '<empty string>') + '\\n' +\n        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';\n\n    Object.assign(error, start);\n    error.loc = {\n        source: (node && node.loc && node.loc.source) || '<unknown>',\n        start,\n        end\n    };\n\n    return error;\n};\n\nmodule.exports = {\n    SyntaxReferenceError,\n    SyntaxMatchError\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}