{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'no-empty-interface',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow the declaration of empty interfaces',\n      recommended: 'error'\n    },\n    fixable: 'code',\n    hasSuggestions: true,\n    messages: {\n      noEmpty: 'An empty interface is equivalent to `{}`.',\n      noEmptyWithSuper: 'An interface declaring no members is equivalent to its supertype.'\n    },\n    schema: [{\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        allowSingleExtends: {\n          type: 'boolean'\n        }\n      }\n    }]\n  },\n  defaultOptions: [{\n    allowSingleExtends: false\n  }],\n\n  create(context, _ref) {\n    let [{\n      allowSingleExtends\n    }] = _ref;\n    return {\n      TSInterfaceDeclaration(node) {\n        const sourceCode = context.getSourceCode();\n        const filename = context.getFilename();\n\n        if (node.body.body.length !== 0) {\n          // interface contains members --> Nothing to report\n          return;\n        }\n\n        const extend = node.extends;\n\n        if (!extend || extend.length === 0) {\n          context.report({\n            node: node.id,\n            messageId: 'noEmpty'\n          });\n        } else if (extend.length === 1) {\n          // interface extends exactly 1 interface --> Report depending on rule setting\n          if (!allowSingleExtends) {\n            const fix = fixer => {\n              let typeParam = '';\n\n              if (node.typeParameters) {\n                typeParam = sourceCode.getText(node.typeParameters);\n              }\n\n              return fixer.replaceText(node, `type ${sourceCode.getText(node.id)}${typeParam} = ${sourceCode.getText(extend[0])}`);\n            }; // Check if interface is within ambient declaration\n\n\n            let useAutoFix = true;\n\n            if (util.isDefinitionFile(filename)) {\n              const scope = context.getScope();\n\n              if (scope.type === 'tsModule' && scope.block.declare) {\n                useAutoFix = false;\n              }\n            }\n\n            context.report(Object.assign({\n              node: node.id,\n              messageId: 'noEmptyWithSuper'\n            }, useAutoFix ? {\n              fix\n            } : {\n              suggest: [{\n                messageId: 'noEmptyWithSuper',\n                fix\n              }]\n            }));\n          }\n        }\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;AASAA,kBAAeC,IAAI,CAACC,UAAL,CAAqC;EAClDC,IAAI,EAAE,oBAD4C;EAElDC,IAAI,EAAE;IACJC,IAAI,EAAE,YADF;IAEJC,IAAI,EAAE;MACJC,WAAW,EAAE,8CADT;MAEJC,WAAW,EAAE;IAFT,CAFF;IAMJC,OAAO,EAAE,MANL;IAOJC,cAAc,EAAE,IAPZ;IAQJC,QAAQ,EAAE;MACRC,OAAO,EAAE,2CADD;MAERC,gBAAgB,EACd;IAHM,CARN;IAaJC,MAAM,EAAE,CACN;MACET,IAAI,EAAE,QADR;MAEEU,oBAAoB,EAAE,KAFxB;MAGEC,UAAU,EAAE;QACVC,kBAAkB,EAAE;UAClBZ,IAAI,EAAE;QADY;MADV;IAHd,CADM;EAbJ,CAF4C;EA2BlDa,cAAc,EAAE,CACd;IACED,kBAAkB,EAAE;EADtB,CADc,CA3BkC;;EAgClDE,MAAM,CAACC,OAAD,QAAkC;IAAA,IAAxB,CAAC;MAAEH;IAAF,CAAD,CAAwB;IACtC,OAAO;MACLI,sBAAsB,CAACC,IAAD,EAAK;QACzB,MAAMC,UAAU,GAAGH,OAAO,CAACI,aAAR,EAAnB;QACA,MAAMC,QAAQ,GAAGL,OAAO,CAACM,WAAR,EAAjB;;QAEA,IAAIJ,IAAI,CAACK,IAAL,CAAUA,IAAV,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;UAC/B;UACA;QACD;;QAED,MAAMC,MAAM,GAAGP,IAAI,CAACQ,OAApB;;QACA,IAAI,CAACD,MAAD,IAAWA,MAAM,CAACD,MAAP,KAAkB,CAAjC,EAAoC;UAClCR,OAAO,CAACW,MAAR,CAAe;YACbT,IAAI,EAAEA,IAAI,CAACU,EADE;YAEbC,SAAS,EAAE;UAFE,CAAf;QAID,CALD,MAKO,IAAIJ,MAAM,CAACD,MAAP,KAAkB,CAAtB,EAAyB;UAC9B;UACA,IAAI,CAACX,kBAAL,EAAyB;YACvB,MAAMiB,GAAG,GAAIC,KAAD,IAAgD;cAC1D,IAAIC,SAAS,GAAG,EAAhB;;cACA,IAAId,IAAI,CAACe,cAAT,EAAyB;gBACvBD,SAAS,GAAGb,UAAU,CAACe,OAAX,CAAmBhB,IAAI,CAACe,cAAxB,CAAZ;cACD;;cACD,OAAOF,KAAK,CAACI,WAAN,CACLjB,IADK,EAEL,QAAQC,UAAU,CAACe,OAAX,CACNhB,IAAI,CAACU,EADC,CAEP,GAAGI,SAAS,MAAMb,UAAU,CAACe,OAAX,CAAmBT,MAAM,CAAC,CAAD,CAAzB,CAA6B,EAJ3C,CAAP;YAMD,CAXD,CADuB,CAcvB;;;YACA,IAAIW,UAAU,GAAG,IAAjB;;YACA,IAAIvC,IAAI,CAACwC,gBAAL,CAAsBhB,QAAtB,CAAJ,EAAqC;cACnC,MAAMiB,KAAK,GAAGtB,OAAO,CAACuB,QAAR,EAAd;;cACA,IAAID,KAAK,CAACrC,IAAN,KAAe,UAAf,IAA6BqC,KAAK,CAACE,KAAN,CAAYC,OAA7C,EAAsD;gBACpDL,UAAU,GAAG,KAAb;cACD;YACF;;YAEDpB,OAAO,CAACW,MAAR,CAAce;cACZxB,IAAI,EAAEA,IAAI,CAACU,EADC;cAEZC,SAAS,EAAE;YAFC,GAGRO,UAAU,GACV;cAAEN;YAAF,CADU,GAEV;cACEa,OAAO,EAAE,CACP;gBACEd,SAAS,EAAE,kBADb;gBAEEC;cAFF,CADO;YADX,CALQ,CAAd;UAcD;QACF;MACF;;IAzDI,CAAP;EA2DD;;AA5FiD,CAArC,CAAf","names":["exports","util","createRule","name","meta","type","docs","description","recommended","fixable","hasSuggestions","messages","noEmpty","noEmptyWithSuper","schema","additionalProperties","properties","allowSingleExtends","defaultOptions","create","context","TSInterfaceDeclaration","node","sourceCode","getSourceCode","filename","getFilename","body","length","extend","extends","report","id","messageId","fix","fixer","typeParam","typeParameters","getText","replaceText","useAutoFix","isDefinitionFile","scope","getScope","block","declare","Object","suggest"],"sources":["../../src/rules/no-empty-interface.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}