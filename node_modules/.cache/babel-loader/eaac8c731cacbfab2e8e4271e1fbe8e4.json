{"ast":null,"code":"'use strict';\n\nvar _path = require('path');\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _resolve = require('eslint-module-utils/resolve');\n\nvar _resolve2 = _interopRequireDefault(_resolve);\n\nvar _moduleVisitor = require('eslint-module-utils/moduleVisitor');\n\nvar _moduleVisitor2 = _interopRequireDefault(_moduleVisitor);\n\nvar _isGlob = require('is-glob');\n\nvar _isGlob2 = _interopRequireDefault(_isGlob);\n\nvar _minimatch = require('minimatch');\n\nvar _minimatch2 = _interopRequireDefault(_minimatch);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nvar _importType = require('../core/importType');\n\nvar _importType2 = _interopRequireDefault(_importType);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar containsPath = function containsPath(filepath, target) {\n  var relative = _path2['default'].relative(target, filepath);\n\n  return relative === '' || !relative.startsWith('..');\n};\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      url: (0, _docsUrl2['default'])('no-restricted-paths')\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        zones: {\n          type: 'array',\n          minItems: 1,\n          items: {\n            type: 'object',\n            properties: {\n              target: {\n                type: 'string'\n              },\n              from: {\n                type: 'string'\n              },\n              except: {\n                type: 'array',\n                items: {\n                  type: 'string'\n                },\n                uniqueItems: true\n              },\n              message: {\n                type: 'string'\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        basePath: {\n          type: 'string'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  create: function () {\n    function noRestrictedPaths(context) {\n      var options = context.options[0] || {};\n      var restrictedPaths = options.zones || [];\n      var basePath = options.basePath || process.cwd();\n      var currentFilename = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n      var matchingZones = restrictedPaths.filter(function (zone) {\n        var targetPath = _path2['default'].resolve(basePath, zone.target);\n\n        if ((0, _isGlob2['default'])(targetPath)) {\n          return (0, _minimatch2['default'])(currentFilename, targetPath);\n        }\n\n        return containsPath(currentFilename, targetPath);\n      });\n\n      function isValidExceptionPath(absoluteFromPath, absoluteExceptionPath) {\n        var relativeExceptionPath = _path2['default'].relative(absoluteFromPath, absoluteExceptionPath);\n\n        return (0, _importType2['default'])(relativeExceptionPath, context) !== 'parent';\n      }\n\n      function reportInvalidExceptionPath(node) {\n        context.report({\n          node: node,\n          message: 'Restricted path exceptions must be descendants of the configured `from` path for that zone.'\n        });\n      }\n\n      function reportInvalidExceptionGlob(node) {\n        context.report({\n          node: node,\n          message: 'Restricted path exceptions must be glob patterns when`from` is a glob pattern'\n        });\n      }\n\n      var makePathValidator = function () {\n        function makePathValidator(zoneFrom) {\n          var zoneExcept = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n          var absoluteFrom = _path2['default'].resolve(basePath, zoneFrom);\n\n          var isGlobPattern = (0, _isGlob2['default'])(zoneFrom);\n          var isPathRestricted = void 0;\n          var hasValidExceptions = void 0;\n          var isPathException = void 0;\n          var reportInvalidException = void 0;\n\n          if (isGlobPattern) {\n            var mm = new _minimatch.Minimatch(absoluteFrom);\n\n            isPathRestricted = function () {\n              function isPathRestricted(absoluteImportPath) {\n                return mm.match(absoluteImportPath);\n              }\n\n              return isPathRestricted;\n            }();\n\n            hasValidExceptions = zoneExcept.every(_isGlob2['default']);\n\n            if (hasValidExceptions) {\n              var exceptionsMm = zoneExcept.map(function (except) {\n                return new _minimatch.Minimatch(except);\n              });\n\n              isPathException = function () {\n                function isPathException(absoluteImportPath) {\n                  return exceptionsMm.some(function (mm) {\n                    return mm.match(absoluteImportPath);\n                  });\n                }\n\n                return isPathException;\n              }();\n            }\n\n            reportInvalidException = reportInvalidExceptionGlob;\n          } else {\n            isPathRestricted = function () {\n              function isPathRestricted(absoluteImportPath) {\n                return containsPath(absoluteImportPath, absoluteFrom);\n              }\n\n              return isPathRestricted;\n            }();\n\n            var absoluteExceptionPaths = zoneExcept.map(function (exceptionPath) {\n              return _path2['default'].resolve(absoluteFrom, exceptionPath);\n            });\n            hasValidExceptions = absoluteExceptionPaths.every(function (absoluteExceptionPath) {\n              return isValidExceptionPath(absoluteFrom, absoluteExceptionPath);\n            });\n\n            if (hasValidExceptions) {\n              isPathException = function () {\n                function isPathException(absoluteImportPath) {\n                  return absoluteExceptionPaths.some(function (absoluteExceptionPath) {\n                    return containsPath(absoluteImportPath, absoluteExceptionPath);\n                  });\n                }\n\n                return isPathException;\n              }();\n            }\n\n            reportInvalidException = reportInvalidExceptionPath;\n          }\n\n          return {\n            isPathRestricted: isPathRestricted,\n            hasValidExceptions: hasValidExceptions,\n            isPathException: isPathException,\n            reportInvalidException: reportInvalidException\n          };\n        }\n\n        return makePathValidator;\n      }();\n\n      var validators = [];\n\n      function checkForRestrictedImportPath(importPath, node) {\n        var absoluteImportPath = (0, _resolve2['default'])(importPath, context);\n\n        if (!absoluteImportPath) {\n          return;\n        }\n\n        matchingZones.forEach(function (zone, index) {\n          if (!validators[index]) {\n            validators[index] = makePathValidator(zone.from, zone.except);\n          }\n\n          var _validators$index = validators[index],\n              isPathRestricted = _validators$index.isPathRestricted,\n              hasValidExceptions = _validators$index.hasValidExceptions,\n              isPathException = _validators$index.isPathException,\n              reportInvalidException = _validators$index.reportInvalidException;\n\n          if (!isPathRestricted(absoluteImportPath)) {\n            return;\n          }\n\n          if (!hasValidExceptions) {\n            reportInvalidException(node);\n            return;\n          }\n\n          var pathIsExcepted = isPathException(absoluteImportPath);\n\n          if (pathIsExcepted) {\n            return;\n          }\n\n          context.report({\n            node: node,\n            message: 'Unexpected path \"{{importPath}}\" imported in restricted zone.' + (zone.message ? ' ' + String(zone.message) : ''),\n            data: {\n              importPath: importPath\n            }\n          });\n        });\n      }\n\n      return (0, _moduleVisitor2['default'])(function (source) {\n        checkForRestrictedImportPath(source.value, source);\n      }, {\n        commonjs: true\n      });\n    }\n\n    return noRestrictedPaths;\n  }()\n};","map":{"version":3,"mappings":";;AAAA;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;AAEA,IAAMA,eAAe,SAAfA,YAAe,CAACC,QAAD,EAAWC,MAAX,EAAsB;EACzC,IAAMC,WAAWC,kBAAKD,QAALC,CAAcF,MAAdE,EAAsBH,QAAtBG,CAAjB;;EACA,OAAOD,aAAa,EAAbA,IAAmB,CAACA,SAASE,UAATF,CAAoB,IAApBA,CAA3B;AAFF;;AAKAG,OAAOC,OAAPD,GAAiB;EACfE,MAAM;IACJC,MAAM,SADF;IAEJC,MAAM;MACJC,KAAK,0BAAQ,qBAAR;IADD,CAFF;IAMJC,QAAQ,CACN;MACEH,MAAM,QADR;MAEEI,YAAY;QACVC,OAAO;UACLL,MAAM,OADD;UAELM,UAAU,CAFL;UAGLC,OAAO;YACLP,MAAM,QADD;YAELI,YAAY;cACVX,QAAQ;gBAAEO,MAAM;cAAR,CADE;cAEVQ,MAAM;gBAAER,MAAM;cAAR,CAFI;cAGVS,QAAQ;gBACNT,MAAM,OADA;gBAENO,OAAO;kBACLP,MAAM;gBADD,CAFD;gBAKNU,aAAa;cALP,CAHE;cAUVC,SAAS;gBAAEX,MAAM;cAAR;YAVC,CAFP;YAcLY,sBAAsB;UAdjB;QAHF,CADG;QAqBVC,UAAU;UAAEb,MAAM;QAAR;MArBA,CAFd;MAyBEY,sBAAsB;IAzBxB,CADM;EANJ,CADS;EAsCfE;IAAQ,SAASC,iBAAT,CAA2BC,OAA3B,EAAoC;MAC1C,IAAMC,UAAUD,QAAQC,OAARD,CAAgB,CAAhBA,KAAsB,EAAtC;MACA,IAAME,kBAAkBD,QAAQZ,KAARY,IAAiB,EAAzC;MACA,IAAMJ,WAAWI,QAAQJ,QAARI,IAAoBE,QAAQC,GAARD,EAArC;MACA,IAAME,kBAAkBL,QAAQM,mBAARN,GAA8BA,QAAQM,mBAARN,EAA9BA,GAA8DA,QAAQO,WAARP,EAAtF;MACA,IAAMQ,gBAAgBN,gBAAgBO,MAAhBP,CAAuB,UAACQ,IAAD,EAAU;QACrD,IAAMC,aAAahC,kBAAKiC,OAALjC,CAAakB,QAAblB,EAAuB+B,KAAKjC,MAA5BE,CAAnB;;QAEA,IAAI,yBAAOgC,UAAP,CAAJ,EAAwB;UACtB,OAAO,4BAAUN,eAAV,EAA2BM,UAA3B,CAAP;QACD;;QAED,OAAOpC,aAAa8B,eAAb9B,EAA8BoC,UAA9BpC,CAAP;MAPoB,EAAtB;;MAUA,SAASsC,oBAAT,CAA8BC,gBAA9B,EAAgDC,qBAAhD,EAAuE;QACrE,IAAMC,wBAAwBrC,kBAAKD,QAALC,CAAcmC,gBAAdnC,EAAgCoC,qBAAhCpC,CAA9B;;QAEA,OAAO,6BAAWqC,qBAAX,EAAkChB,OAAlC,MAA+C,QAAtD;MACD;;MAED,SAASiB,0BAAT,CAAoCC,IAApC,EAA0C;QACxClB,QAAQmB,MAARnB,CAAe;UACbkB,UADa;UAEbvB,SAAS;QAFI,CAAfK;MAID;;MAED,SAASoB,0BAAT,CAAoCF,IAApC,EAA0C;QACxClB,QAAQmB,MAARnB,CAAe;UACbkB,UADa;UAEbvB,SAAS;QAFI,CAAfK;MAID;;MAED,IAAMqB;QAAoB,SAApBA,iBAAoB,CAACC,QAAD,EAA+B;UAAA,IAApBC,UAAoB,uEAAP,EAAO;;UACvD,IAAMC,eAAe7C,kBAAKiC,OAALjC,CAAakB,QAAblB,EAAuB2C,QAAvB3C,CAArB;;UACA,IAAM8C,gBAAgB,yBAAOH,QAAP,CAAtB;UACA,IAAII,yBAAJ;UACA,IAAIC,2BAAJ;UACA,IAAIC,wBAAJ;UACA,IAAIC,+BAAJ;;UAEA,IAAIJ,aAAJ,EAAmB;YACjB,IAAMK,KAAK,IAAIC,oBAAJ,CAAcP,YAAd,CAAX;;YACAE;cAAmB,0BAACM,kBAAD;gBAAA,OAAwBF,GAAGG,KAAHH,CAASE,kBAATF,CAAxB;cAAnB;;cAAA;YAAA;;YAEAH,qBAAqBJ,WAAWW,KAAXX,CAAiBY,mBAAjBZ,CAArBI;;YAEA,IAAIA,kBAAJ,EAAwB;cACtB,IAAMS,eAAeb,WAAWc,GAAXd,CAAe,UAAC9B,MAAD;gBAAA,OAAY,IAAIsC,oBAAJ,CAActC,MAAd,CAAZ;cAAf,EAArB;;cACAmC;gBAAkB,yBAACI,kBAAD;kBAAA,OAAwBI,aAAaE,IAAbF,CAAkB,UAACN,EAAD;oBAAA,OAAQA,GAAGG,KAAHH,CAASE,kBAATF,CAAR;kBAAlB,EAAxB;gBAAlB;;gBAAA;cAAA;YACD;;YAEDD,yBAAyBT,0BAAzBS;UAXF,OAYO;YACLH;cAAmB,0BAACM,kBAAD;gBAAA,OAAwBzD,aAAayD,kBAAbzD,EAAiCiD,YAAjCjD,CAAxB;cAAnB;;cAAA;YAAA;;YAEA,IAAMgE,yBAAyBhB,WAC5Bc,GAD4Bd,CACxB,UAACiB,aAAD;cAAA,OAAmB7D,kBAAKiC,OAALjC,CAAa6C,YAAb7C,EAA2B6D,aAA3B7D,CAAnB;YADwB,EAA/B;YAEAgD,qBAAqBY,uBAClBL,KADkBK,CACZ,UAACxB,qBAAD;cAAA,OAA2BF,qBAAqBW,YAArBX,EAAmCE,qBAAnCF,CAA3B;YADY,EAArBc;;YAGA,IAAIA,kBAAJ,EAAwB;cACtBC;gBAAkB,yBAACI,kBAAD;kBAAA,OAAwBO,uBAAuBD,IAAvBC,CACxC,UAACxB,qBAAD;oBAAA,OAA2BxC,aAAayD,kBAAbzD,EAAiCwC,qBAAjCxC,CAA3B;kBADwC,EAAxB;gBAAlB;;gBAAA;cAAA;YAGD;;YAEDsD,yBAAyBZ,0BAAzBY;UACD;;UAED,OAAO;YACLH,kCADK;YAELC,sCAFK;YAGLC,gCAHK;YAILC;UAJK,CAAP;QArCI;;QAAA;MAAA,GAAN;;MA6CA,IAAMY,aAAa,EAAnB;;MAEA,SAASC,4BAAT,CAAsCC,UAAtC,EAAkDzB,IAAlD,EAAwD;QACtD,IAAMc,qBAAqB,0BAAQW,UAAR,EAAoB3C,OAApB,CAA3B;;QAEA,IAAI,CAACgC,kBAAL,EAAyB;UACvB;QACD;;QAEDxB,cAAcoC,OAAdpC,CAAsB,UAACE,IAAD,EAAOmC,KAAP,EAAiB;UACrC,IAAI,CAACJ,WAAWI,KAAXJ,CAAL,EAAwB;YACtBA,WAAWI,KAAXJ,IAAoBpB,kBAAkBX,KAAKlB,IAAvB6B,EAA6BX,KAAKjB,MAAlC4B,CAApBoB;UAFmC;;UAAA,wBAUjCA,WAAWI,KAAXJ,CAViC;UAAA,IAMnCf,gBANmC,qBAMnCA,gBANmC;UAAA,IAOnCC,kBAPmC,qBAOnCA,kBAPmC;UAAA,IAQnCC,eARmC,qBAQnCA,eARmC;UAAA,IASnCC,sBATmC,qBASnCA,sBATmC;;UAYrC,IAAI,CAACH,iBAAiBM,kBAAjBN,CAAL,EAA2C;YACzC;UACD;;UAED,IAAI,CAACC,kBAAL,EAAyB;YACvBE,uBAAuBX,IAAvBW;YACA;UACD;;UAED,IAAMiB,iBAAiBlB,gBAAgBI,kBAAhBJ,CAAvB;;UACA,IAAIkB,cAAJ,EAAoB;YAClB;UACD;;UAED9C,QAAQmB,MAARnB,CAAe;YACbkB,UADa;YAEbvB,4EAAyEe,KAAKf,OAALe,gBAAmBA,KAAKf,OAAxB,IAAoC,EAA7GA,CAFa;YAGboD,MAAM;cAAEJ;YAAF;UAHO,CAAf3C;QA1BF;MAgCD;;MAED,OAAO,gCAAc,UAACgD,MAAD,EAAY;QAC/BN,6BAA6BM,OAAOC,KAApCP,EAA2CM,MAA3CN;MADK,GAEJ;QAAEQ,UAAU;MAAZ,CAFI,CAAP;IA3HF;;IAAA,OAAiBnD,iBAAjB;EAAA;AAtCe,CAAjBlB","names":["containsPath","filepath","target","relative","path","startsWith","module","exports","meta","type","docs","url","schema","properties","zones","minItems","items","from","except","uniqueItems","message","additionalProperties","basePath","create","noRestrictedPaths","context","options","restrictedPaths","process","cwd","currentFilename","getPhysicalFilename","getFilename","matchingZones","filter","zone","targetPath","resolve","isValidExceptionPath","absoluteFromPath","absoluteExceptionPath","relativeExceptionPath","reportInvalidExceptionPath","node","report","reportInvalidExceptionGlob","makePathValidator","zoneFrom","zoneExcept","absoluteFrom","isGlobPattern","isPathRestricted","hasValidExceptions","isPathException","reportInvalidException","mm","Minimatch","absoluteImportPath","match","every","isGlob","exceptionsMm","map","some","absoluteExceptionPaths","exceptionPath","validators","checkForRestrictedImportPath","importPath","forEach","index","pathIsExcepted","data","source","value","commonjs"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\no-restricted-paths.js"],"sourcesContent":["import path from 'path';\n\nimport resolve from 'eslint-module-utils/resolve';\nimport moduleVisitor from 'eslint-module-utils/moduleVisitor';\nimport isGlob from 'is-glob';\nimport { Minimatch, default as minimatch } from 'minimatch';\nimport docsUrl from '../docsUrl';\nimport importType from '../core/importType';\n\nconst containsPath = (filepath, target) => {\n  const relative = path.relative(target, filepath);\n  return relative === '' || !relative.startsWith('..');\n};\n\nmodule.exports = {\n  meta: {\n    type: 'problem',\n    docs: {\n      url: docsUrl('no-restricted-paths'),\n    },\n\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          zones: {\n            type: 'array',\n            minItems: 1,\n            items: {\n              type: 'object',\n              properties: {\n                target: { type: 'string' },\n                from: { type: 'string' },\n                except: {\n                  type: 'array',\n                  items: {\n                    type: 'string',\n                  },\n                  uniqueItems: true,\n                },\n                message: { type: 'string' },\n              },\n              additionalProperties: false,\n            },\n          },\n          basePath: { type: 'string' },\n        },\n        additionalProperties: false,\n      },\n    ],\n  },\n\n  create: function noRestrictedPaths(context) {\n    const options = context.options[0] || {};\n    const restrictedPaths = options.zones || [];\n    const basePath = options.basePath || process.cwd();\n    const currentFilename = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n    const matchingZones = restrictedPaths.filter((zone) => {\n      const targetPath = path.resolve(basePath, zone.target);\n\n      if (isGlob(targetPath)) {\n        return minimatch(currentFilename, targetPath);\n      }\n\n      return containsPath(currentFilename, targetPath);\n    });\n\n    function isValidExceptionPath(absoluteFromPath, absoluteExceptionPath) {\n      const relativeExceptionPath = path.relative(absoluteFromPath, absoluteExceptionPath);\n\n      return importType(relativeExceptionPath, context) !== 'parent';\n    }\n\n    function reportInvalidExceptionPath(node) {\n      context.report({\n        node,\n        message: 'Restricted path exceptions must be descendants of the configured `from` path for that zone.',\n      });\n    }\n\n    function reportInvalidExceptionGlob(node) {\n      context.report({\n        node,\n        message: 'Restricted path exceptions must be glob patterns when`from` is a glob pattern',\n      });\n    }\n\n    const makePathValidator = (zoneFrom, zoneExcept = []) => {\n      const absoluteFrom = path.resolve(basePath, zoneFrom);\n      const isGlobPattern = isGlob(zoneFrom);\n      let isPathRestricted;\n      let hasValidExceptions;\n      let isPathException;\n      let reportInvalidException;\n\n      if (isGlobPattern) {\n        const mm = new Minimatch(absoluteFrom);\n        isPathRestricted = (absoluteImportPath) => mm.match(absoluteImportPath);\n\n        hasValidExceptions = zoneExcept.every(isGlob);\n\n        if (hasValidExceptions) {\n          const exceptionsMm = zoneExcept.map((except) => new Minimatch(except));\n          isPathException = (absoluteImportPath) => exceptionsMm.some((mm) => mm.match(absoluteImportPath));\n        }\n\n        reportInvalidException = reportInvalidExceptionGlob;\n      } else {\n        isPathRestricted = (absoluteImportPath) => containsPath(absoluteImportPath, absoluteFrom);\n\n        const absoluteExceptionPaths = zoneExcept\n          .map((exceptionPath) => path.resolve(absoluteFrom, exceptionPath));\n        hasValidExceptions = absoluteExceptionPaths\n          .every((absoluteExceptionPath) => isValidExceptionPath(absoluteFrom, absoluteExceptionPath));\n\n        if (hasValidExceptions) {\n          isPathException = (absoluteImportPath) => absoluteExceptionPaths.some(\n            (absoluteExceptionPath) => containsPath(absoluteImportPath, absoluteExceptionPath),\n          );\n        }\n\n        reportInvalidException = reportInvalidExceptionPath;\n      }\n\n      return {\n        isPathRestricted,\n        hasValidExceptions,\n        isPathException,\n        reportInvalidException,\n      };\n    };\n\n    const validators = [];\n\n    function checkForRestrictedImportPath(importPath, node) {\n      const absoluteImportPath = resolve(importPath, context);\n\n      if (!absoluteImportPath) {\n        return;\n      }\n\n      matchingZones.forEach((zone, index) => {\n        if (!validators[index]) {\n          validators[index] = makePathValidator(zone.from, zone.except);\n        }\n\n        const {\n          isPathRestricted,\n          hasValidExceptions,\n          isPathException,\n          reportInvalidException,\n        } = validators[index];\n\n        if (!isPathRestricted(absoluteImportPath)) {\n          return;\n        }\n\n        if (!hasValidExceptions) {\n          reportInvalidException(node);\n          return;\n        }\n\n        const pathIsExcepted = isPathException(absoluteImportPath);\n        if (pathIsExcepted) {\n          return;\n        }\n\n        context.report({\n          node,\n          message: `Unexpected path \"{{importPath}}\" imported in restricted zone.${zone.message ? ` ${zone.message}` : ''}`,\n          data: { importPath },\n        });\n      });\n    }\n\n    return moduleVisitor((source) => {\n      checkForRestrictedImportPath(source.value, source);\n    }, { commonjs: true });\n  },\n};\n"]},"metadata":{},"sourceType":"script"}