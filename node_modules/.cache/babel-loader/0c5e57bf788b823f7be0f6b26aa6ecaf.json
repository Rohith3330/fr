{"ast":null,"code":"import esutils from \"esutils\";\n/**\n * Converts JSX Spread arguments into Object Spread, avoiding Babel's helper or Object.assign injection.\n * Input:\n * \t <div a=\"1\" {...b} />\n * Output:\n *   <div {...{ a: \"1\", ...b }} />\n * ...which Babel converts to:\n *   h(\"div\", { a: \"1\", ...b })\n */\n\nexport default (_ref => {\n  let {\n    types: t\n  } = _ref;\n\n  // converts a set of JSXAttributes to an Object.assign() call\n  function convertAttributesAssign(attributes) {\n    const args = [];\n\n    for (let i = 0, current; i < attributes.length; i++) {\n      const node = attributes[i];\n\n      if (t.isJSXSpreadAttribute(node)) {\n        // the first attribute is a spread, avoid copying all other attributes onto it\n        if (i === 0) {\n          args.push(t.objectExpression([]));\n        }\n\n        current = null;\n        args.push(node.argument);\n      } else {\n        const name = getAttributeName(node);\n        const value = getAttributeValue(node);\n\n        if (!current) {\n          current = t.objectExpression([]);\n          args.push(current);\n        }\n\n        current.properties.push(t.objectProperty(name, value));\n      }\n    }\n\n    return t.callExpression(t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")), args);\n  } // Converts a JSXAttribute to the equivalent ObjectExpression property\n\n\n  function convertAttributeSpread(node) {\n    if (t.isJSXSpreadAttribute(node)) {\n      return t.spreadElement(node.argument);\n    }\n\n    const name = getAttributeName(node);\n    const value = getAttributeValue(node);\n    return t.inherits(t.objectProperty(name, value), node);\n  } // Convert a JSX attribute name to an Object expression property name\n\n\n  function getAttributeName(node) {\n    if (t.isJSXNamespacedName(node.name)) {\n      return t.stringLiteral(node.name.namespace.name + \":\" + node.name.name.name);\n    }\n\n    if (esutils.keyword.isIdentifierNameES6(node.name.name)) {\n      return t.identifier(node.name.name);\n    }\n\n    return t.stringLiteral(node.name.name);\n  } // Convert a JSX attribute value to a JavaScript expression value\n\n\n  function getAttributeValue(node) {\n    let value = node.value || t.booleanLiteral(true);\n\n    if (t.isJSXExpressionContainer(value)) {\n      value = value.expression;\n    } else if (t.isStringLiteral(value)) {\n      value.value = value.value.replace(/\\n\\s+/g, \" \"); // \"raw\" JSXText should not be used from a StringLiteral because it needs to be escaped.\n\n      if (value.extra && value.extra.raw) {\n        delete value.extra.raw;\n      }\n    }\n\n    return value;\n  }\n\n  return {\n    name: \"transform-jsx-spread\",\n    visitor: {\n      JSXOpeningElement(path, state) {\n        const useSpread = state.opts.useSpread === true;\n        const hasSpread = path.node.attributes.some(attr => t.isJSXSpreadAttribute(attr)); // ignore JSX Elements without spread or with lone spread:\n\n        if (!hasSpread || path.node.attributes.length === 1) return;\n\n        if (useSpread) {\n          path.node.attributes = [t.jsxSpreadAttribute(t.objectExpression(path.node.attributes.map(convertAttributeSpread)))];\n        } else {\n          path.node.attributes = [t.jsxSpreadAttribute(convertAttributesAssign(path.node.attributes))];\n        }\n      }\n\n    }\n  };\n});","map":{"version":3,"names":["esutils","types","t","convertAttributesAssign","attributes","args","i","current","length","node","isJSXSpreadAttribute","push","objectExpression","argument","name","getAttributeName","value","getAttributeValue","properties","objectProperty","callExpression","memberExpression","identifier","convertAttributeSpread","spreadElement","inherits","isJSXNamespacedName","stringLiteral","namespace","keyword","isIdentifierNameES6","booleanLiteral","isJSXExpressionContainer","expression","isStringLiteral","replace","extra","raw","visitor","JSXOpeningElement","path","state","useSpread","opts","hasSpread","some","attr","jsxSpreadAttribute","map"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/preset-modules/src/plugins/transform-jsx-spread/index.js"],"sourcesContent":["import esutils from \"esutils\";\n\n/**\n * Converts JSX Spread arguments into Object Spread, avoiding Babel's helper or Object.assign injection.\n * Input:\n * \t <div a=\"1\" {...b} />\n * Output:\n *   <div {...{ a: \"1\", ...b }} />\n * ...which Babel converts to:\n *   h(\"div\", { a: \"1\", ...b })\n */\nexport default ({ types: t }) => {\n  // converts a set of JSXAttributes to an Object.assign() call\n  function convertAttributesAssign(attributes) {\n    const args = [];\n    for (let i = 0, current; i < attributes.length; i++) {\n      const node = attributes[i];\n      if (t.isJSXSpreadAttribute(node)) {\n        // the first attribute is a spread, avoid copying all other attributes onto it\n        if (i === 0) {\n          args.push(t.objectExpression([]));\n        }\n        current = null;\n        args.push(node.argument);\n      } else {\n        const name = getAttributeName(node);\n        const value = getAttributeValue(node);\n        if (!current) {\n          current = t.objectExpression([]);\n          args.push(current);\n        }\n        current.properties.push(t.objectProperty(name, value));\n      }\n    }\n    return t.callExpression(\n      t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")),\n      args\n    );\n  }\n\n  // Converts a JSXAttribute to the equivalent ObjectExpression property\n  function convertAttributeSpread(node) {\n    if (t.isJSXSpreadAttribute(node)) {\n      return t.spreadElement(node.argument);\n    }\n\n    const name = getAttributeName(node);\n    const value = getAttributeValue(node);\n    return t.inherits(t.objectProperty(name, value), node);\n  }\n\n  // Convert a JSX attribute name to an Object expression property name\n  function getAttributeName(node) {\n    if (t.isJSXNamespacedName(node.name)) {\n      return t.stringLiteral(\n        node.name.namespace.name + \":\" + node.name.name.name\n      );\n    }\n    if (esutils.keyword.isIdentifierNameES6(node.name.name)) {\n      return t.identifier(node.name.name);\n    }\n    return t.stringLiteral(node.name.name);\n  }\n\n  // Convert a JSX attribute value to a JavaScript expression value\n  function getAttributeValue(node) {\n    let value = node.value || t.booleanLiteral(true);\n\n    if (t.isJSXExpressionContainer(value)) {\n      value = value.expression;\n    } else if (t.isStringLiteral(value)) {\n      value.value = value.value.replace(/\\n\\s+/g, \" \");\n\n      // \"raw\" JSXText should not be used from a StringLiteral because it needs to be escaped.\n      if (value.extra && value.extra.raw) {\n        delete value.extra.raw;\n      }\n    }\n\n    return value;\n  }\n\n  return {\n    name: \"transform-jsx-spread\",\n    visitor: {\n      JSXOpeningElement(path, state) {\n        const useSpread = state.opts.useSpread === true;\n        const hasSpread = path.node.attributes.some(attr =>\n          t.isJSXSpreadAttribute(attr)\n        );\n\n        // ignore JSX Elements without spread or with lone spread:\n        if (!hasSpread || path.node.attributes.length === 1) return;\n\n        if (useSpread) {\n          path.node.attributes = [\n            t.jsxSpreadAttribute(\n              t.objectExpression(\n                path.node.attributes.map(convertAttributeSpread)\n              )\n            ),\n          ];\n        } else {\n          path.node.attributes = [\n            t.jsxSpreadAttribute(convertAttributesAssign(path.node.attributes)),\n          ];\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}