{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchFromAbsolutePaths = exports.createMatchPath = void 0;\n\nvar path = require(\"path\");\n\nvar Filesystem = require(\"./filesystem\");\n\nvar MappingEntry = require(\"./mapping-entry\");\n\nvar TryPath = require(\"./try-path\");\n/**\n * Creates a function that can resolve paths according to tsconfig paths property.\n * @param absoluteBaseUrl Absolute version of baseUrl as specified in tsconfig.\n * @param paths The paths as specified in tsconfig.\n * @param mainFields A list of package.json field names to try when resolving module files.\n * @param addMatchAll Add a match-all \"*\" rule if none is present\n * @returns a function that can resolve paths.\n */\n\n\nfunction createMatchPath(absoluteBaseUrl, paths, mainFields, addMatchAll) {\n  if (mainFields === void 0) {\n    mainFields = [\"main\"];\n  }\n\n  if (addMatchAll === void 0) {\n    addMatchAll = true;\n  }\n\n  var absolutePaths = MappingEntry.getAbsoluteMappingEntries(absoluteBaseUrl, paths, addMatchAll);\n  return function (requestedModule, readJson, fileExists, extensions) {\n    return matchFromAbsolutePaths(absolutePaths, requestedModule, readJson, fileExists, extensions, mainFields);\n  };\n}\n\nexports.createMatchPath = createMatchPath;\n/**\n * Finds a path from tsconfig that matches a module load request.\n * @param absolutePathMappings The paths to try as specified in tsconfig but resolved to absolute form.\n * @param requestedModule The required module name.\n * @param readJson Function that can read json from a path (useful for testing).\n * @param fileExists Function that checks for existence of a file at a path (useful for testing).\n * @param extensions File extensions to probe for (useful for testing).\n * @param mainFields A list of package.json field names to try when resolving module files.\n * @returns the found path, or undefined if no path was found.\n */\n\nfunction matchFromAbsolutePaths(absolutePathMappings, requestedModule, readJson, fileExists, extensions, mainFields) {\n  if (readJson === void 0) {\n    readJson = Filesystem.readJsonFromDiskSync;\n  }\n\n  if (fileExists === void 0) {\n    fileExists = Filesystem.fileExistsSync;\n  }\n\n  if (extensions === void 0) {\n    extensions = Object.keys(require.extensions);\n  }\n\n  if (mainFields === void 0) {\n    mainFields = [\"main\"];\n  }\n\n  var tryPaths = TryPath.getPathsToTry(extensions, absolutePathMappings, requestedModule);\n\n  if (!tryPaths) {\n    return undefined;\n  }\n\n  return findFirstExistingPath(tryPaths, readJson, fileExists, mainFields);\n}\n\nexports.matchFromAbsolutePaths = matchFromAbsolutePaths;\n\nfunction findFirstExistingMainFieldMappedFile(packageJson, mainFields, packageJsonPath, fileExists) {\n  for (var index = 0; index < mainFields.length; index++) {\n    var mainFieldName = mainFields[index];\n    var candidateMapping = packageJson[mainFieldName];\n\n    if (candidateMapping && typeof candidateMapping === \"string\") {\n      var candidateFilePath = path.join(path.dirname(packageJsonPath), candidateMapping);\n\n      if (fileExists(candidateFilePath)) {\n        return candidateFilePath;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction findFirstExistingPath(tryPaths, readJson, fileExists, mainFields) {\n  if (readJson === void 0) {\n    readJson = Filesystem.readJsonFromDiskSync;\n  }\n\n  if (mainFields === void 0) {\n    mainFields = [\"main\"];\n  }\n\n  for (var _i = 0, tryPaths_1 = tryPaths; _i < tryPaths_1.length; _i++) {\n    var tryPath = tryPaths_1[_i];\n\n    if (tryPath.type === \"file\" || tryPath.type === \"extension\" || tryPath.type === \"index\") {\n      if (fileExists(tryPath.path)) {\n        return TryPath.getStrippedPath(tryPath);\n      }\n    } else if (tryPath.type === \"package\") {\n      var packageJson = readJson(tryPath.path);\n\n      if (packageJson) {\n        var mainFieldMappedFile = findFirstExistingMainFieldMappedFile(packageJson, mainFields, tryPath.path, fileExists);\n\n        if (mainFieldMappedFile) {\n          return mainFieldMappedFile;\n        }\n      }\n    } else {\n      TryPath.exhaustiveTypeException(tryPath.type);\n    }\n  }\n\n  return undefined;\n}","map":{"version":3,"mappings":"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","names":["createMatchPath","absoluteBaseUrl","paths","mainFields","addMatchAll","absolutePaths","MappingEntry","getAbsoluteMappingEntries","requestedModule","readJson","fileExists","extensions","exports","matchFromAbsolutePaths","absolutePathMappings","Filesystem","readJsonFromDiskSync","fileExistsSync","Object","keys","require","tryPaths","TryPath","getPathsToTry","undefined","findFirstExistingPath","findFirstExistingMainFieldMappedFile","packageJson","packageJsonPath","index","length","mainFieldName","candidateMapping","candidateFilePath","path","join","dirname","_i","tryPath","type","getStrippedPath","mainFieldMappedFile","exhaustiveTypeException"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\tsconfig-paths\\src\\match-path-sync.ts"],"sourcesContent":["import * as path from \"path\";\nimport * as Filesystem from \"./filesystem\";\nimport * as MappingEntry from \"./mapping-entry\";\nimport * as TryPath from \"./try-path\";\n\n/**\n * Function that can match a path\n */\nexport interface MatchPath {\n  (\n    requestedModule: string,\n    readJson?: Filesystem.ReadJsonSync,\n    fileExists?: (name: string) => boolean,\n    extensions?: ReadonlyArray<string>\n  ): string | undefined;\n}\n\n/**\n * Creates a function that can resolve paths according to tsconfig paths property.\n * @param absoluteBaseUrl Absolute version of baseUrl as specified in tsconfig.\n * @param paths The paths as specified in tsconfig.\n * @param mainFields A list of package.json field names to try when resolving module files.\n * @param addMatchAll Add a match-all \"*\" rule if none is present\n * @returns a function that can resolve paths.\n */\nexport function createMatchPath(\n  absoluteBaseUrl: string,\n  paths: { [key: string]: Array<string> },\n  mainFields: string[] = [\"main\"],\n  addMatchAll: boolean = true\n): MatchPath {\n  const absolutePaths = MappingEntry.getAbsoluteMappingEntries(\n    absoluteBaseUrl,\n    paths,\n    addMatchAll\n  );\n\n  return (\n    requestedModule: string,\n    readJson?: Filesystem.ReadJsonSync,\n    fileExists?: Filesystem.FileExistsSync,\n    extensions?: Array<string>\n  ) =>\n    matchFromAbsolutePaths(\n      absolutePaths,\n      requestedModule,\n      readJson,\n      fileExists,\n      extensions,\n      mainFields\n    );\n}\n\n/**\n * Finds a path from tsconfig that matches a module load request.\n * @param absolutePathMappings The paths to try as specified in tsconfig but resolved to absolute form.\n * @param requestedModule The required module name.\n * @param readJson Function that can read json from a path (useful for testing).\n * @param fileExists Function that checks for existence of a file at a path (useful for testing).\n * @param extensions File extensions to probe for (useful for testing).\n * @param mainFields A list of package.json field names to try when resolving module files.\n * @returns the found path, or undefined if no path was found.\n */\nexport function matchFromAbsolutePaths(\n  absolutePathMappings: ReadonlyArray<MappingEntry.MappingEntry>,\n  requestedModule: string,\n  readJson: Filesystem.ReadJsonSync = Filesystem.readJsonFromDiskSync,\n  fileExists: Filesystem.FileExistsSync = Filesystem.fileExistsSync,\n  extensions: Array<string> = Object.keys(require.extensions),\n  mainFields: string[] = [\"main\"]\n): string | undefined {\n  const tryPaths = TryPath.getPathsToTry(\n    extensions,\n    absolutePathMappings,\n    requestedModule\n  );\n\n  if (!tryPaths) {\n    return undefined;\n  }\n\n  return findFirstExistingPath(tryPaths, readJson, fileExists, mainFields);\n}\n\nfunction findFirstExistingMainFieldMappedFile(\n  packageJson: Filesystem.PackageJson,\n  mainFields: string[],\n  packageJsonPath: string,\n  fileExists: Filesystem.FileExistsSync\n): string | undefined {\n  for (let index = 0; index < mainFields.length; index++) {\n    const mainFieldName = mainFields[index];\n    const candidateMapping = packageJson[mainFieldName];\n    if (candidateMapping && typeof candidateMapping === \"string\") {\n      const candidateFilePath = path.join(\n        path.dirname(packageJsonPath),\n        candidateMapping\n      );\n      if (fileExists(candidateFilePath)) {\n        return candidateFilePath;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nfunction findFirstExistingPath(\n  tryPaths: ReadonlyArray<TryPath.TryPath>,\n  readJson: Filesystem.ReadJsonSync = Filesystem.readJsonFromDiskSync,\n  fileExists: Filesystem.FileExistsSync,\n  mainFields: string[] = [\"main\"]\n): string | undefined {\n  for (const tryPath of tryPaths) {\n    if (\n      tryPath.type === \"file\" ||\n      tryPath.type === \"extension\" ||\n      tryPath.type === \"index\"\n    ) {\n      if (fileExists(tryPath.path)) {\n        return TryPath.getStrippedPath(tryPath);\n      }\n    } else if (tryPath.type === \"package\") {\n      const packageJson: Filesystem.PackageJson = readJson(tryPath.path);\n      if (packageJson) {\n        const mainFieldMappedFile = findFirstExistingMainFieldMappedFile(\n          packageJson,\n          mainFields,\n          tryPath.path,\n          fileExists\n        );\n        if (mainFieldMappedFile) {\n          return mainFieldMappedFile;\n        }\n      }\n    } else {\n      TryPath.exhaustiveTypeException(tryPath.type);\n    }\n  }\n  return undefined;\n}\n"]},"metadata":{},"sourceType":"script"}