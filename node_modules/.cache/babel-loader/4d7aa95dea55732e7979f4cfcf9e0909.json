{"ast":null,"code":"const {\n  humanReadableArgName\n} = require('./argument.js');\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n// @ts-check\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\n\n\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n  }\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);\n\n      const helpCommand = cmd.createCommand(helpName).helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n      if (helpArgs) helpCommand.arguments(helpArgs);\n      visibleCommands.push(helpCommand);\n    }\n\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n\n    return visibleCommands;\n  }\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter(option => !option.hidden); // Implicit help\n\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n\n      visibleOptions.push(helpOption);\n    }\n\n    if (this.sortOptions) {\n      const getSortKey = option => {\n        // WYSIWYG for order displayed in help with short before long, no special handling for negated.\n        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n      };\n\n      visibleOptions.sort((a, b) => {\n        return getSortKey(a).localeCompare(getSortKey(b));\n      });\n    }\n\n    return visibleOptions;\n  }\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd._args.forEach(argument => {\n        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    } // If there are any arguments with a description then return all the arguments.\n\n\n    if (cmd._args.find(argument => argument.description)) {\n      return cmd._args;\n    }\n\n    ;\n    return [];\n  }\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');\n\n    return cmd._name + (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') + (cmd.options.length ? ' [options]' : '') + ( // simplistic check for non-help option\n    args ? ' ' + args : '');\n  }\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n\n  optionTerm(option) {\n    return option.flags;\n  }\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, helper.argumentTerm(argument).length);\n    }, 0);\n  }\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n\n    let parentCmdNames = '';\n\n    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {\n      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n    }\n\n    return parentCmdNames + cmdName + ' ' + cmd.usage();\n  }\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n  /**\n   * Get the command description to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n\n  optionDescription(option) {\n    const extraInfo = []; // Some of these do not make sense for negated boolean and suppress for backwards compatibility.\n\n    if (option.argChoices && !option.negate) {\n      extraInfo.push( // use stringify to match the display of the default value\n      `choices: ${option.argChoices.map(choice => JSON.stringify(choice)).join(', ')}`);\n    }\n\n    if (option.defaultValue !== undefined && !option.negate) {\n      extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n    }\n\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n\n    return option.description;\n  }\n\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n  argumentDescription(argument) {\n    const extraInfo = [];\n\n    if (argument.argChoices) {\n      extraInfo.push( // use stringify to match the display of the default value\n      `choices: ${argument.argChoices.map(choice => JSON.stringify(choice)).join(', ')}`);\n    }\n\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);\n    }\n\n    if (extraInfo.length > 0) {\n      const extraDescripton = `(${extraInfo.join(', ')})`;\n\n      if (argument.description) {\n        return `${argument.description} ${extraDescripton}`;\n      }\n\n      return extraDescripton;\n    }\n\n    return argument.description;\n  }\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n\n      return term;\n    }\n\n    ;\n\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    } // Usage\n\n\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, '']; // Description\n\n    const commandDescription = helper.commandDescription(cmd);\n\n    if (commandDescription.length > 0) {\n      output = output.concat([commandDescription, '']);\n    } // Arguments\n\n\n    const argumentList = helper.visibleArguments(cmd).map(argument => {\n      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));\n    });\n\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    } // Options\n\n\n    const optionList = helper.visibleOptions(cmd).map(option => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    } // Commands\n\n\n    const commandList = helper.visibleCommands(cmd).map(cmd => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n\n  padWidth(cmd, helper) {\n    return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));\n  }\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n  wrap(str, width, indent) {\n    let minColumnWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 40;\n    // Detect manually wrapped and indented strings by searching for line breaks\n    // followed by multiple spaces/tabs.\n    if (str.match(/[\\n]\\s+/)) return str; // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n    const leadingStr = str.substr(0, indent);\n    const columnText = str.substr(indent);\n    const indentString = ' '.repeat(indent);\n    const regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\\\s\\u200B]|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]|$)', 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line.slice(-1) === '\\n') {\n        line = line.slice(0, line.length - 1);\n      }\n\n      return (i > 0 ? indentString : '') + line.trimRight();\n    }).join('\\n');\n  }\n\n}\n\nexports.Help = Help;","map":{"version":3,"names":["humanReadableArgName","require","Help","constructor","helpWidth","undefined","sortSubcommands","sortOptions","visibleCommands","cmd","commands","filter","_hidden","_hasImplicitHelpCommand","helpName","helpArgs","_helpCommandnameAndArgs","match","helpCommand","createCommand","helpOption","description","_helpCommandDescription","arguments","push","sort","a","b","name","localeCompare","visibleOptions","options","option","hidden","showShortHelpFlag","_hasHelpOption","_helpShortFlag","_findOption","showLongHelpFlag","_helpLongFlag","createOption","_helpDescription","_helpFlags","getSortKey","short","replace","long","visibleArguments","_argsDescription","_args","forEach","argument","find","subcommandTerm","args","map","arg","join","_name","_aliases","length","optionTerm","flags","argumentTerm","longestSubcommandTermLength","helper","reduce","max","command","Math","longestOptionTermLength","longestArgumentTermLength","commandUsage","cmdName","parentCmdNames","parentCmd","parent","usage","commandDescription","subcommandDescription","optionDescription","extraInfo","argChoices","negate","choice","JSON","stringify","defaultValue","defaultValueDescription","envVar","argumentDescription","extraDescripton","formatHelp","termWidth","padWidth","itemIndentWidth","itemSeparatorWidth","formatItem","term","fullText","padEnd","wrap","formatList","textArray","repeat","output","concat","argumentList","optionList","commandList","str","width","indent","minColumnWidth","columnWidth","leadingStr","substr","columnText","indentString","regex","RegExp","lines","line","i","slice","trimRight","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/commander/lib/help.js"],"sourcesContent":["const { humanReadableArgName } = require('./argument.js');\n\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n\n// @ts-check\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);\n      const helpCommand = cmd.createCommand(helpName)\n        .helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n      if (helpArgs) helpCommand.arguments(helpArgs);\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter((option) => !option.hidden);\n    // Implicit help\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n      visibleOptions.push(helpOption);\n    }\n    if (this.sortOptions) {\n      const getSortKey = (option) => {\n        // WYSIWYG for order displayed in help with short before long, no special handling for negated.\n        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n      };\n      visibleOptions.sort((a, b) => {\n        return getSortKey(a).localeCompare(getSortKey(b));\n      });\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd._args.forEach(argument => {\n        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    }\n\n    // If there are any arguments with a description then return all the arguments.\n    if (cmd._args.find(argument => argument.description)) {\n      return cmd._args;\n    };\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');\n    return cmd._name +\n      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option\n      (args ? ' ' + args : '');\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  };\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  };\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, helper.argumentTerm(argument).length);\n    }, 0);\n  };\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let parentCmdNames = '';\n    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {\n      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n    }\n    return parentCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the command description to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    const extraInfo = [];\n    // Some of these do not make sense for negated boolean and suppress for backwards compatibility.\n\n    if (option.argChoices && !option.negate) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (option.defaultValue !== undefined && !option.negate) {\n      extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n    }\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n\n    return option.description;\n  };\n\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n\n  argumentDescription(argument) {\n    const extraInfo = [];\n    if (argument.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);\n    }\n    if (extraInfo.length > 0) {\n      const extraDescripton = `(${extraInfo.join(', ')})`;\n      if (argument.description) {\n        return `${argument.description} ${extraDescripton}`;\n      }\n      return extraDescripton;\n    }\n    return argument.description;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n      return term;\n    };\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([commandDescription, '']);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map((argument) => {\n      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map((option) => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map((cmd) => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(\n      helper.longestOptionTermLength(cmd, helper),\n      helper.longestSubcommandTermLength(cmd, helper),\n      helper.longestArgumentTermLength(cmd, helper)\n    );\n  };\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Detect manually wrapped and indented strings by searching for line breaks\n    // followed by multiple spaces/tabs.\n    if (str.match(/[\\n]\\s+/)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n\n    const leadingStr = str.substr(0, indent);\n    const columnText = str.substr(indent);\n\n    const indentString = ' '.repeat(indent);\n    const regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\\\s\\u200B]|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]|$)', 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line.slice(-1) === '\\n') {\n        line = line.slice(0, line.length - 1);\n      }\n      return ((i > 0) ? indentString : '') + line.trimRight();\n    }).join('\\n');\n  }\n}\n\nexports.Help = Help;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}