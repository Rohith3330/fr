{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTypeReadonly = exports.readonlynessOptionsDefaults = exports.readonlynessOptionsSchema = void 0;\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils_1 = require(\"tsutils\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst propertyTypes_1 = require(\"./propertyTypes\");\n\nexports.readonlynessOptionsSchema = {\n  type: 'object',\n  additionalProperties: false,\n  properties: {\n    treatMethodsAsReadonly: {\n      type: 'boolean'\n    }\n  }\n};\nexports.readonlynessOptionsDefaults = {\n  treatMethodsAsReadonly: false\n};\n\nfunction hasSymbol(node) {\n  return Object.prototype.hasOwnProperty.call(node, 'symbol');\n}\n\nfunction isTypeReadonlyArrayOrTuple(checker, type, options, seenTypes) {\n  function checkTypeArguments(arrayType) {\n    var _a;\n\n    const typeArguments = // getTypeArguments was only added in TS3.7\n    checker.getTypeArguments ? checker.getTypeArguments(arrayType) : (_a = arrayType.typeArguments) !== null && _a !== void 0 ? _a : []; // this shouldn't happen in reality as:\n    // - tuples require at least 1 type argument\n    // - ReadonlyArray requires at least 1 type argument\n\n    /* istanbul ignore if */\n\n    if (typeArguments.length === 0) {\n      return 3\n      /* Readonlyness.Readonly */\n      ;\n    } // validate the element types are also readonly\n\n\n    if (typeArguments.some(typeArg => isTypeReadonlyRecurser(checker, typeArg, options, seenTypes) === 2\n    /* Readonlyness.Mutable */\n    )) {\n      return 2\n      /* Readonlyness.Mutable */\n      ;\n    }\n\n    return 3\n    /* Readonlyness.Readonly */\n    ;\n  }\n\n  if (checker.isArrayType(type)) {\n    const symbol = utils_1.ESLintUtils.nullThrows(type.getSymbol(), utils_1.ESLintUtils.NullThrowsReasons.MissingToken('symbol', 'array type'));\n    const escapedName = symbol.getEscapedName();\n\n    if (escapedName === 'Array') {\n      return 2\n      /* Readonlyness.Mutable */\n      ;\n    }\n\n    return checkTypeArguments(type);\n  }\n\n  if (checker.isTupleType(type)) {\n    if (!type.target.readonly) {\n      return 2\n      /* Readonlyness.Mutable */\n      ;\n    }\n\n    return checkTypeArguments(type);\n  }\n\n  return 1\n  /* Readonlyness.UnknownType */\n  ;\n}\n\nfunction isTypeReadonlyObject(checker, type, options, seenTypes) {\n  function checkIndexSignature(kind) {\n    const indexInfo = checker.getIndexInfoOfType(type, kind);\n\n    if (indexInfo) {\n      if (!indexInfo.isReadonly) {\n        return 2\n        /* Readonlyness.Mutable */\n        ;\n      }\n\n      return isTypeReadonlyRecurser(checker, indexInfo.type, options, seenTypes);\n    }\n\n    return 1\n    /* Readonlyness.UnknownType */\n    ;\n  }\n\n  const properties = type.getProperties();\n\n  if (properties.length) {\n    // ensure the properties are marked as readonly\n    for (const property of properties) {\n      if (options.treatMethodsAsReadonly) {\n        if (property.valueDeclaration !== undefined && hasSymbol(property.valueDeclaration) && (0, tsutils_1.isSymbolFlagSet)(property.valueDeclaration.symbol, ts.SymbolFlags.Method)) {\n          continue;\n        }\n\n        const declarations = property.getDeclarations();\n        const lastDeclaration = declarations !== undefined && declarations.length > 0 ? declarations[declarations.length - 1] : undefined;\n\n        if (lastDeclaration !== undefined && hasSymbol(lastDeclaration) && (0, tsutils_1.isSymbolFlagSet)(lastDeclaration.symbol, ts.SymbolFlags.Method)) {\n          continue;\n        }\n      }\n\n      if ((0, tsutils_1.isPropertyReadonlyInType)(type, property.getEscapedName(), checker)) {\n        continue;\n      }\n\n      const name = ts.getNameOfDeclaration(property.valueDeclaration);\n\n      if (name && ts.isPrivateIdentifier(name)) {\n        continue;\n      }\n\n      return 2\n      /* Readonlyness.Mutable */\n      ;\n    } // all properties were readonly\n    // now ensure that all of the values are readonly also.\n    // do this after checking property readonly-ness as a perf optimization,\n    // as we might be able to bail out early due to a mutable property before\n    // doing this deep, potentially expensive check.\n\n\n    for (const property of properties) {\n      const propertyType = utils_1.ESLintUtils.nullThrows((0, propertyTypes_1.getTypeOfPropertyOfType)(checker, type, property), utils_1.ESLintUtils.NullThrowsReasons.MissingToken(`property \"${property.name}\"`, 'type')); // handle recursive types.\n      // we only need this simple check, because a mutable recursive type will break via the above prop readonly check\n\n      if (seenTypes.has(propertyType)) {\n        continue;\n      }\n\n      if (isTypeReadonlyRecurser(checker, propertyType, options, seenTypes) === 2\n      /* Readonlyness.Mutable */\n      ) {\n        return 2\n        /* Readonlyness.Mutable */\n        ;\n      }\n    }\n  }\n\n  const isStringIndexSigReadonly = checkIndexSignature(ts.IndexKind.String);\n\n  if (isStringIndexSigReadonly === 2\n  /* Readonlyness.Mutable */\n  ) {\n    return isStringIndexSigReadonly;\n  }\n\n  const isNumberIndexSigReadonly = checkIndexSignature(ts.IndexKind.Number);\n\n  if (isNumberIndexSigReadonly === 2\n  /* Readonlyness.Mutable */\n  ) {\n    return isNumberIndexSigReadonly;\n  }\n\n  return 3\n  /* Readonlyness.Readonly */\n  ;\n} // a helper function to ensure the seenTypes map is always passed down, except by the external caller\n\n\nfunction isTypeReadonlyRecurser(checker, type, options, seenTypes) {\n  seenTypes.add(type);\n\n  if ((0, tsutils_1.isUnionType)(type)) {\n    // all types in the union must be readonly\n    const result = (0, tsutils_1.unionTypeParts)(type).every(t => seenTypes.has(t) || isTypeReadonlyRecurser(checker, t, options, seenTypes) === 3\n    /* Readonlyness.Readonly */\n    );\n    const readonlyness = result ? 3\n    /* Readonlyness.Readonly */\n    : 2\n    /* Readonlyness.Mutable */\n    ;\n    return readonlyness;\n  }\n\n  if ((0, tsutils_1.isIntersectionType)(type)) {\n    // Special case for handling arrays/tuples (as readonly arrays/tuples always have mutable methods).\n    if (type.types.some(t => checker.isArrayType(t) || checker.isTupleType(t))) {\n      const allReadonlyParts = type.types.every(t => seenTypes.has(t) || isTypeReadonlyRecurser(checker, t, options, seenTypes) === 3\n      /* Readonlyness.Readonly */\n      );\n      return allReadonlyParts ? 3\n      /* Readonlyness.Readonly */\n      : 2\n      /* Readonlyness.Mutable */\n      ;\n    } // Normal case.\n\n\n    const isReadonlyObject = isTypeReadonlyObject(checker, type, options, seenTypes);\n\n    if (isReadonlyObject !== 1\n    /* Readonlyness.UnknownType */\n    ) {\n      return isReadonlyObject;\n    }\n  }\n\n  if ((0, tsutils_1.isConditionalType)(type)) {\n    const result = [type.root.node.trueType, type.root.node.falseType].map(checker.getTypeFromTypeNode).every(t => seenTypes.has(t) || isTypeReadonlyRecurser(checker, t, options, seenTypes) === 3\n    /* Readonlyness.Readonly */\n    );\n    const readonlyness = result ? 3\n    /* Readonlyness.Readonly */\n    : 2\n    /* Readonlyness.Mutable */\n    ;\n    return readonlyness;\n  } // all non-object, non-intersection types are readonly.\n  // this should only be primitive types\n\n\n  if (!(0, tsutils_1.isObjectType)(type)) {\n    return 3\n    /* Readonlyness.Readonly */\n    ;\n  } // pure function types are readonly\n\n\n  if (type.getCallSignatures().length > 0 && type.getProperties().length === 0) {\n    return 3\n    /* Readonlyness.Readonly */\n    ;\n  }\n\n  const isReadonlyArray = isTypeReadonlyArrayOrTuple(checker, type, options, seenTypes);\n\n  if (isReadonlyArray !== 1\n  /* Readonlyness.UnknownType */\n  ) {\n    return isReadonlyArray;\n  }\n\n  const isReadonlyObject = isTypeReadonlyObject(checker, type, options, seenTypes);\n  /* istanbul ignore else */\n\n  if (isReadonlyObject !== 1\n  /* Readonlyness.UnknownType */\n  ) {\n    return isReadonlyObject;\n  }\n\n  throw new Error('Unhandled type');\n}\n/**\n * Checks if the given type is readonly\n */\n\n\nfunction isTypeReadonly(checker, type) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : exports.readonlynessOptionsDefaults;\n  return isTypeReadonlyRecurser(checker, type, options, new Set()) === 3\n  /* Readonlyness.Readonly */\n  ;\n}\n\nexports.isTypeReadonly = isTypeReadonly;","map":{"version":3,"mappings":"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","names":["exports","type","additionalProperties","properties","treatMethodsAsReadonly","hasSymbol","node","Object","prototype","hasOwnProperty","call","isTypeReadonlyArrayOrTuple","checker","options","seenTypes","checkTypeArguments","arrayType","typeArguments","getTypeArguments","_a","length","some","typeArg","isTypeReadonlyRecurser","isArrayType","symbol","utils_1","nullThrows","getSymbol","NullThrowsReasons","MissingToken","escapedName","getEscapedName","isTupleType","target","readonly","isTypeReadonlyObject","checkIndexSignature","kind","indexInfo","getIndexInfoOfType","isReadonly","getProperties","property","valueDeclaration","undefined","ts","SymbolFlags","Method","declarations","getDeclarations","lastDeclaration","name","getNameOfDeclaration","isPrivateIdentifier","propertyType","has","isStringIndexSigReadonly","IndexKind","String","isNumberIndexSigReadonly","Number","add","result","every","t","readonlyness","types","allReadonlyParts","isReadonlyObject","root","trueType","falseType","map","getTypeFromTypeNode","getCallSignatures","isReadonlyArray","Error","isTypeReadonly","Set"],"sources":["../src/isTypeReadonly.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}