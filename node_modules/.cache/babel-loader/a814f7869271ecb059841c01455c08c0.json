{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.dynamicRef = void 0;\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst names_1 = require(\"../../compile/names\");\n\nconst ref_1 = require(\"../core/ref\");\n\nconst def = {\n  keyword: \"$dynamicRef\",\n  schemaType: \"string\",\n  code: cxt => dynamicRef(cxt, cxt.schema)\n};\n\nfunction dynamicRef(cxt, ref) {\n  const {\n    gen,\n    keyword,\n    it\n  } = cxt;\n  if (ref[0] !== \"#\") throw new Error(`\"${keyword}\" only supports hash fragment reference`);\n  const anchor = ref.slice(1);\n\n  if (it.allErrors) {\n    _dynamicRef();\n  } else {\n    const valid = gen.let(\"valid\", false);\n\n    _dynamicRef(valid);\n\n    cxt.ok(valid);\n  }\n\n  function _dynamicRef(valid) {\n    // TODO the assumption here is that `recursiveRef: #` always points to the root\n    // of the schema object, which is not correct, because there may be $id that\n    // makes # point to it, and the target schema may not contain dynamic/recursiveAnchor.\n    // Because of that 2 tests in recursiveRef.json fail.\n    // This is a similar problem to #815 (`$id` doesn't alter resolution scope for `{ \"$ref\": \"#\" }`).\n    // (This problem is not tested in JSON-Schema-Test-Suite)\n    if (it.schemaEnv.root.dynamicAnchors[anchor]) {\n      const v = gen.let(\"_v\", (0, codegen_1._)`${names_1.default.dynamicAnchors}${(0, codegen_1.getProperty)(anchor)}`);\n      gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid));\n    } else {\n      _callRef(it.validateName, valid)();\n    }\n  }\n\n  function _callRef(validate, valid) {\n    return valid ? () => gen.block(() => {\n      (0, ref_1.callRef)(cxt, validate);\n      gen.let(valid, true);\n    }) : () => (0, ref_1.callRef)(cxt, validate);\n  }\n}\n\nexports.dynamicRef = dynamicRef;\nexports.default = def;","map":{"version":3,"mappings":";;;;;;;AAEA;;AACA;;AACA;;AAEA,MAAMA,GAAG,GAA0B;EACjCC,OAAO,EAAE,aADwB;EAEjCC,UAAU,EAAE,QAFqB;EAGjCC,IAAI,EAAGC,GAAD,IAASC,UAAU,CAACD,GAAD,EAAMA,GAAG,CAACE,MAAV;AAHQ,CAAnC;;AAMA,SAAgBD,UAAhB,CAA2BD,GAA3B,EAA4CG,GAA5C,EAAuD;EACrD,MAAM;IAACC,GAAD;IAAMP,OAAN;IAAeQ;EAAf,IAAqBL,GAA3B;EACA,IAAIG,GAAG,CAAC,CAAD,CAAH,KAAW,GAAf,EAAoB,MAAM,IAAIG,KAAJ,CAAU,IAAIT,OAAO,yCAArB,CAAN;EACpB,MAAMU,MAAM,GAAGJ,GAAG,CAACK,KAAJ,CAAU,CAAV,CAAf;;EACA,IAAIH,EAAE,CAACI,SAAP,EAAkB;IAChBC,WAAW;EACZ,CAFD,MAEO;IACL,MAAMC,KAAK,GAAGP,GAAG,CAACQ,GAAJ,CAAQ,OAAR,EAAiB,KAAjB,CAAd;;IACAF,WAAW,CAACC,KAAD,CAAX;;IACAX,GAAG,CAACa,EAAJ,CAAOF,KAAP;EACD;;EAED,SAASD,WAAT,CAAqBC,KAArB,EAAiC;IAC/B;IACA;IACA;IACA;IACA;IACA;IACA,IAAIN,EAAE,CAACS,SAAH,CAAaC,IAAb,CAAkBC,cAAlB,CAAiCT,MAAjC,CAAJ,EAA8C;MAC5C,MAAMU,CAAC,GAAGb,GAAG,CAACQ,GAAJ,CAAQ,IAAR,EAAc,gBAAC,GAAGM,gBAAEF,cAAc,GAAG,2BAAYT,MAAZ,CAAmB,EAAxD,CAAV;MACAH,GAAG,CAACe,EAAJ,CAAOF,CAAP,EAAUG,QAAQ,CAACH,CAAD,EAAIN,KAAJ,CAAlB,EAA8BS,QAAQ,CAACf,EAAE,CAACgB,YAAJ,EAAkBV,KAAlB,CAAtC;IACD,CAHD,MAGO;MACLS,QAAQ,CAACf,EAAE,CAACgB,YAAJ,EAAkBV,KAAlB,CAAR;IACD;EACF;;EAED,SAASS,QAAT,CAAkBE,QAAlB,EAAkCX,KAAlC,EAA8C;IAC5C,OAAOA,KAAK,GACR,MACEP,GAAG,CAACmB,KAAJ,CAAU,MAAK;MACb,mBAAQvB,GAAR,EAAasB,QAAb;MACAlB,GAAG,CAACQ,GAAJ,CAAQD,KAAR,EAAe,IAAf;IACD,CAHD,CAFM,GAMR,MAAM,mBAAQX,GAAR,EAAasB,QAAb,CANV;EAOD;AACF;;AApCDE;AAsCAA,kBAAe5B,GAAf","names":["def","keyword","schemaType","code","cxt","dynamicRef","schema","ref","gen","it","Error","anchor","slice","allErrors","_dynamicRef","valid","let","ok","schemaEnv","root","dynamicAnchors","v","names_1","if","_callRef","validateName","validate","block","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\mini-css-extract-plugin\\node_modules\\ajv\\lib\\vocabularies\\dynamic\\dynamicRef.ts"],"sourcesContent":["import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {callRef} from \"../core/ref\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$dynamicRef\",\n  schemaType: \"string\",\n  code: (cxt) => dynamicRef(cxt, cxt.schema),\n}\n\nexport function dynamicRef(cxt: KeywordCxt, ref: string): void {\n  const {gen, keyword, it} = cxt\n  if (ref[0] !== \"#\") throw new Error(`\"${keyword}\" only supports hash fragment reference`)\n  const anchor = ref.slice(1)\n  if (it.allErrors) {\n    _dynamicRef()\n  } else {\n    const valid = gen.let(\"valid\", false)\n    _dynamicRef(valid)\n    cxt.ok(valid)\n  }\n\n  function _dynamicRef(valid?: Name): void {\n    // TODO the assumption here is that `recursiveRef: #` always points to the root\n    // of the schema object, which is not correct, because there may be $id that\n    // makes # point to it, and the target schema may not contain dynamic/recursiveAnchor.\n    // Because of that 2 tests in recursiveRef.json fail.\n    // This is a similar problem to #815 (`$id` doesn't alter resolution scope for `{ \"$ref\": \"#\" }`).\n    // (This problem is not tested in JSON-Schema-Test-Suite)\n    if (it.schemaEnv.root.dynamicAnchors[anchor]) {\n      const v = gen.let(\"_v\", _`${N.dynamicAnchors}${getProperty(anchor)}`)\n      gen.if(v, _callRef(v, valid), _callRef(it.validateName, valid))\n    } else {\n      _callRef(it.validateName, valid)()\n    }\n  }\n\n  function _callRef(validate: Code, valid?: Name): () => void {\n    return valid\n      ? () =>\n          gen.block(() => {\n            callRef(cxt, validate)\n            gen.let(valid, true)\n          })\n      : () => callRef(cxt, validate)\n  }\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}