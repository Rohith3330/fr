{"ast":null,"code":"module.exports = compile;\n\nvar BaseFuncs = require(\"boolbase\"),\n    trueFunc = BaseFuncs.trueFunc,\n    falseFunc = BaseFuncs.falseFunc;\n/*\n\treturns a function that checks if an elements index matches the given rule\n\thighly optimized to return the fastest solution\n*/\n\n\nfunction compile(parsed) {\n  var a = parsed[0],\n      b = parsed[1] - 1; //when b <= 0, a*n won't be possible for any matches when a < 0\n  //besides, the specification says that no element is matched when a and b are 0\n\n  if (b < 0 && a <= 0) return falseFunc; //when a is in the range -1..1, it matches any element (so only b is checked)\n\n  if (a === -1) return function (pos) {\n    return pos <= b;\n  };\n  if (a === 0) return function (pos) {\n    return pos === b;\n  }; //when b <= 0 and a === 1, they match any element\n\n  if (a === 1) return b < 0 ? trueFunc : function (pos) {\n    return pos >= b;\n  }; //when a > 0, modulo can be used to check if there is a match\n\n  var bMod = b % a;\n  if (bMod < 0) bMod += a;\n\n  if (a > 1) {\n    return function (pos) {\n      return pos >= b && pos % a === bMod;\n    };\n  }\n\n  a *= -1; //make `a` positive\n\n  return function (pos) {\n    return pos <= b && pos % a === bMod;\n  };\n}","map":{"version":3,"names":["module","exports","compile","BaseFuncs","require","trueFunc","falseFunc","parsed","a","b","pos","bMod"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/svgo/node_modules/nth-check/compile.js"],"sourcesContent":["module.exports = compile;\n\nvar BaseFuncs = require(\"boolbase\"),\n    trueFunc  = BaseFuncs.trueFunc,\n    falseFunc = BaseFuncs.falseFunc;\n\n/*\n\treturns a function that checks if an elements index matches the given rule\n\thighly optimized to return the fastest solution\n*/\nfunction compile(parsed){\n\tvar a = parsed[0],\n\t    b = parsed[1] - 1;\n\n\t//when b <= 0, a*n won't be possible for any matches when a < 0\n\t//besides, the specification says that no element is matched when a and b are 0\n\tif(b < 0 && a <= 0) return falseFunc;\n\n\t//when a is in the range -1..1, it matches any element (so only b is checked)\n\tif(a ===-1) return function(pos){ return pos <= b; };\n\tif(a === 0) return function(pos){ return pos === b; };\n\t//when b <= 0 and a === 1, they match any element\n\tif(a === 1) return b < 0 ? trueFunc : function(pos){ return pos >= b; };\n\n\t//when a > 0, modulo can be used to check if there is a match\n\tvar bMod = b % a;\n\tif(bMod < 0) bMod += a;\n\n\tif(a > 1){\n\t\treturn function(pos){\n\t\t\treturn pos >= b && pos % a === bMod;\n\t\t};\n\t}\n\n\ta *= -1; //make `a` positive\n\n\treturn function(pos){\n\t\treturn pos <= b && pos % a === bMod;\n\t};\n}"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,OAAjB;;AAEA,IAAIC,SAAS,GAAGC,OAAO,CAAC,UAAD,CAAvB;AAAA,IACIC,QAAQ,GAAIF,SAAS,CAACE,QAD1B;AAAA,IAEIC,SAAS,GAAGH,SAAS,CAACG,SAF1B;AAIA;AACA;AACA;AACA;;;AACA,SAASJ,OAAT,CAAiBK,MAAjB,EAAwB;EACvB,IAAIC,CAAC,GAAGD,MAAM,CAAC,CAAD,CAAd;EAAA,IACIE,CAAC,GAAGF,MAAM,CAAC,CAAD,CAAN,GAAY,CADpB,CADuB,CAIvB;EACA;;EACA,IAAGE,CAAC,GAAG,CAAJ,IAASD,CAAC,IAAI,CAAjB,EAAoB,OAAOF,SAAP,CANG,CAQvB;;EACA,IAAGE,CAAC,KAAI,CAAC,CAAT,EAAY,OAAO,UAASE,GAAT,EAAa;IAAE,OAAOA,GAAG,IAAID,CAAd;EAAkB,CAAxC;EACZ,IAAGD,CAAC,KAAK,CAAT,EAAY,OAAO,UAASE,GAAT,EAAa;IAAE,OAAOA,GAAG,KAAKD,CAAf;EAAmB,CAAzC,CAVW,CAWvB;;EACA,IAAGD,CAAC,KAAK,CAAT,EAAY,OAAOC,CAAC,GAAG,CAAJ,GAAQJ,QAAR,GAAmB,UAASK,GAAT,EAAa;IAAE,OAAOA,GAAG,IAAID,CAAd;EAAkB,CAA3D,CAZW,CAcvB;;EACA,IAAIE,IAAI,GAAGF,CAAC,GAAGD,CAAf;EACA,IAAGG,IAAI,GAAG,CAAV,EAAaA,IAAI,IAAIH,CAAR;;EAEb,IAAGA,CAAC,GAAG,CAAP,EAAS;IACR,OAAO,UAASE,GAAT,EAAa;MACnB,OAAOA,GAAG,IAAID,CAAP,IAAYC,GAAG,GAAGF,CAAN,KAAYG,IAA/B;IACA,CAFD;EAGA;;EAEDH,CAAC,IAAI,CAAC,CAAN,CAxBuB,CAwBd;;EAET,OAAO,UAASE,GAAT,EAAa;IACnB,OAAOA,GAAG,IAAID,CAAP,IAAYC,GAAG,GAAGF,CAAN,KAAYG,IAA/B;EACA,CAFD;AAGA"},"metadata":{},"sourceType":"script"}