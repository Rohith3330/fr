{"ast":null,"code":"var forge = require('node-forge'); // a hexString is considered negative if it's most significant bit is 1\n// because serial numbers use ones' complement notation\n// this RFC in section 4.1.2.2 requires serial numbers to be positive\n// http://www.ietf.org/rfc/rfc5280.txt\n\n\nfunction toPositiveHex(hexString) {\n  var mostSiginficativeHexAsInt = parseInt(hexString[0], 16);\n\n  if (mostSiginficativeHexAsInt < 8) {\n    return hexString;\n  }\n\n  mostSiginficativeHexAsInt -= 8;\n  return mostSiginficativeHexAsInt.toString() + hexString.substring(1);\n}\n\nfunction getAlgorithm(key) {\n  switch (key) {\n    case 'sha256':\n      return forge.md.sha256.create();\n\n    default:\n      return forge.md.sha1.create();\n  }\n}\n/**\n *\n * @param {forge.pki.CertificateField[]} attrs Attributes used for subject and issuer.\n * @param {object} options\n * @param {number} [options.days=365] the number of days before expiration\n * @param {number} [options.keySize=1024] the size for the private key in bits\n * @param {object} [options.extensions] additional extensions for the certificate\n * @param {string} [options.algorithm=\"sha1\"] The signature algorithm sha256 or sha1\n * @param {boolean} [options.pkcs7=false] include PKCS#7 as part of the output\n * @param {boolean} [options.clientCertificate=false] generate client cert signed by the original key\n * @param {string} [options.clientCertificateCN=\"John Doe jdoe123\"] client certificate's common name\n * @param {function} [done] Optional callback, if not provided the generation is synchronous\n * @returns\n */\n\n\nexports.generate = function generate(attrs, options, done) {\n  if (typeof attrs === 'function') {\n    done = attrs;\n    attrs = undefined;\n  } else if (typeof options === 'function') {\n    done = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  var generatePem = function (keyPair) {\n    var cert = forge.pki.createCertificate();\n    cert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9))); // the serial number can be decimal or hex (if preceded by 0x)\n\n    cert.validity.notBefore = new Date();\n    cert.validity.notAfter = new Date();\n    cert.validity.notAfter.setDate(cert.validity.notBefore.getDate() + (options.days || 365));\n    attrs = attrs || [{\n      name: 'commonName',\n      value: 'example.org'\n    }, {\n      name: 'countryName',\n      value: 'US'\n    }, {\n      shortName: 'ST',\n      value: 'Virginia'\n    }, {\n      name: 'localityName',\n      value: 'Blacksburg'\n    }, {\n      name: 'organizationName',\n      value: 'Test'\n    }, {\n      shortName: 'OU',\n      value: 'Test'\n    }];\n    cert.setSubject(attrs);\n    cert.setIssuer(attrs);\n    cert.publicKey = keyPair.publicKey;\n    cert.setExtensions(options.extensions || [{\n      name: 'basicConstraints',\n      cA: true\n    }, {\n      name: 'keyUsage',\n      keyCertSign: true,\n      digitalSignature: true,\n      nonRepudiation: true,\n      keyEncipherment: true,\n      dataEncipherment: true\n    }, {\n      name: 'subjectAltName',\n      altNames: [{\n        type: 6,\n        // URI\n        value: 'http://example.org/webid#me'\n      }]\n    }]);\n    cert.sign(keyPair.privateKey, getAlgorithm(options && options.algorithm));\n    const fingerprint = forge.md.sha1.create().update(forge.asn1.toDer(forge.pki.certificateToAsn1(cert)).getBytes()).digest().toHex().match(/.{2}/g).join(':');\n    var pem = {\n      private: forge.pki.privateKeyToPem(keyPair.privateKey),\n      public: forge.pki.publicKeyToPem(keyPair.publicKey),\n      cert: forge.pki.certificateToPem(cert),\n      fingerprint: fingerprint\n    };\n\n    if (options && options.pkcs7) {\n      var p7 = forge.pkcs7.createSignedData();\n      p7.addCertificate(cert);\n      pem.pkcs7 = forge.pkcs7.messageToPem(p7);\n    }\n\n    if (options && options.clientCertificate) {\n      var clientkeys = forge.pki.rsa.generateKeyPair(1024);\n      var clientcert = forge.pki.createCertificate();\n      clientcert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9)));\n      clientcert.validity.notBefore = new Date();\n      clientcert.validity.notAfter = new Date();\n      clientcert.validity.notAfter.setFullYear(clientcert.validity.notBefore.getFullYear() + 1);\n      var clientAttrs = JSON.parse(JSON.stringify(attrs));\n\n      for (var i = 0; i < clientAttrs.length; i++) {\n        if (clientAttrs[i].name === 'commonName') {\n          if (options.clientCertificateCN) clientAttrs[i] = {\n            name: 'commonName',\n            value: options.clientCertificateCN\n          };else clientAttrs[i] = {\n            name: 'commonName',\n            value: 'John Doe jdoe123'\n          };\n        }\n      }\n\n      clientcert.setSubject(clientAttrs); // Set the issuer to the parent key\n\n      clientcert.setIssuer(attrs);\n      clientcert.publicKey = clientkeys.publicKey; // Sign client cert with root cert\n\n      clientcert.sign(keyPair.privateKey);\n      pem.clientprivate = forge.pki.privateKeyToPem(clientkeys.privateKey);\n      pem.clientpublic = forge.pki.publicKeyToPem(clientkeys.publicKey);\n      pem.clientcert = forge.pki.certificateToPem(clientcert);\n\n      if (options.pkcs7) {\n        var clientp7 = forge.pkcs7.createSignedData();\n        clientp7.addCertificate(clientcert);\n        pem.clientpkcs7 = forge.pkcs7.messageToPem(clientp7);\n      }\n    }\n\n    var caStore = forge.pki.createCaStore();\n    caStore.addCertificate(cert);\n\n    try {\n      forge.pki.verifyCertificateChain(caStore, [cert], function (vfd, depth, chain) {\n        if (vfd !== true) {\n          throw new Error('Certificate could not be verified.');\n        }\n\n        return true;\n      });\n    } catch (ex) {\n      throw new Error(ex);\n    }\n\n    return pem;\n  };\n\n  var keySize = options.keySize || 1024;\n\n  if (done) {\n    // async scenario\n    return forge.pki.rsa.generateKeyPair({\n      bits: keySize\n    }, function (err, keyPair) {\n      if (err) {\n        return done(err);\n      }\n\n      try {\n        return done(null, generatePem(keyPair));\n      } catch (ex) {\n        return done(ex);\n      }\n    });\n  }\n\n  var keyPair = options.keyPair ? {\n    privateKey: forge.pki.privateKeyFromPem(options.keyPair.privateKey),\n    publicKey: forge.pki.publicKeyFromPem(options.keyPair.publicKey)\n  } : forge.pki.rsa.generateKeyPair(keySize);\n  return generatePem(keyPair);\n};","map":{"version":3,"names":["forge","require","toPositiveHex","hexString","mostSiginficativeHexAsInt","parseInt","toString","substring","getAlgorithm","key","md","sha256","create","sha1","exports","generate","attrs","options","done","undefined","generatePem","keyPair","cert","pki","createCertificate","serialNumber","util","bytesToHex","random","getBytesSync","validity","notBefore","Date","notAfter","setDate","getDate","days","name","value","shortName","setSubject","setIssuer","publicKey","setExtensions","extensions","cA","keyCertSign","digitalSignature","nonRepudiation","keyEncipherment","dataEncipherment","altNames","type","sign","privateKey","algorithm","fingerprint","update","asn1","toDer","certificateToAsn1","getBytes","digest","toHex","match","join","pem","private","privateKeyToPem","public","publicKeyToPem","certificateToPem","pkcs7","p7","createSignedData","addCertificate","messageToPem","clientCertificate","clientkeys","rsa","generateKeyPair","clientcert","setFullYear","getFullYear","clientAttrs","JSON","parse","stringify","i","length","clientCertificateCN","clientprivate","clientpublic","clientp7","clientpkcs7","caStore","createCaStore","verifyCertificateChain","vfd","depth","chain","Error","ex","keySize","bits","err","privateKeyFromPem","publicKeyFromPem"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/selfsigned/index.js"],"sourcesContent":["var forge = require('node-forge');\n\n// a hexString is considered negative if it's most significant bit is 1\n// because serial numbers use ones' complement notation\n// this RFC in section 4.1.2.2 requires serial numbers to be positive\n// http://www.ietf.org/rfc/rfc5280.txt\nfunction toPositiveHex(hexString){\n  var mostSiginficativeHexAsInt = parseInt(hexString[0], 16);\n  if (mostSiginficativeHexAsInt < 8){\n    return hexString;\n  }\n\n  mostSiginficativeHexAsInt -= 8;\n  return mostSiginficativeHexAsInt.toString() + hexString.substring(1);\n}\n\nfunction getAlgorithm(key) {\n  switch (key) {\n    case 'sha256':\n      return forge.md.sha256.create();\n    default:\n      return forge.md.sha1.create();\n  }\n}\n\n/**\n *\n * @param {forge.pki.CertificateField[]} attrs Attributes used for subject and issuer.\n * @param {object} options\n * @param {number} [options.days=365] the number of days before expiration\n * @param {number} [options.keySize=1024] the size for the private key in bits\n * @param {object} [options.extensions] additional extensions for the certificate\n * @param {string} [options.algorithm=\"sha1\"] The signature algorithm sha256 or sha1\n * @param {boolean} [options.pkcs7=false] include PKCS#7 as part of the output\n * @param {boolean} [options.clientCertificate=false] generate client cert signed by the original key\n * @param {string} [options.clientCertificateCN=\"John Doe jdoe123\"] client certificate's common name\n * @param {function} [done] Optional callback, if not provided the generation is synchronous\n * @returns\n */\nexports.generate = function generate(attrs, options, done) {\n  if (typeof attrs === 'function') {\n    done = attrs;\n    attrs = undefined;\n  } else if (typeof options === 'function') {\n    done = options;\n    options = {};\n  }\n\n  options = options || {};\n\n  var generatePem = function (keyPair) {\n    var cert = forge.pki.createCertificate();\n\n    cert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9))); // the serial number can be decimal or hex (if preceded by 0x)\n\n    cert.validity.notBefore = new Date();\n    cert.validity.notAfter = new Date();\n    cert.validity.notAfter.setDate(cert.validity.notBefore.getDate() + (options.days || 365));\n\n    attrs = attrs || [{\n      name: 'commonName',\n      value: 'example.org'\n    }, {\n      name: 'countryName',\n      value: 'US'\n    }, {\n      shortName: 'ST',\n      value: 'Virginia'\n    }, {\n      name: 'localityName',\n      value: 'Blacksburg'\n    }, {\n      name: 'organizationName',\n      value: 'Test'\n    }, {\n      shortName: 'OU',\n      value: 'Test'\n    }];\n\n    cert.setSubject(attrs);\n    cert.setIssuer(attrs);\n\n    cert.publicKey = keyPair.publicKey;\n\n    cert.setExtensions(options.extensions || [{\n      name: 'basicConstraints',\n      cA: true\n    }, {\n      name: 'keyUsage',\n      keyCertSign: true,\n      digitalSignature: true,\n      nonRepudiation: true,\n      keyEncipherment: true,\n      dataEncipherment: true\n    }, {\n      name: 'subjectAltName',\n      altNames: [{\n        type: 6, // URI\n        value: 'http://example.org/webid#me'\n      }]\n    }]);\n\n    cert.sign(keyPair.privateKey, getAlgorithm(options && options.algorithm));\n\n    const fingerprint = forge.md.sha1\n                          .create()\n                          .update(forge.asn1.toDer(forge.pki.certificateToAsn1(cert)).getBytes())\n                          .digest()\n                          .toHex()\n                          .match(/.{2}/g)\n                          .join(':');\n\n    var pem = {\n      private:     forge.pki.privateKeyToPem(keyPair.privateKey),\n      public:      forge.pki.publicKeyToPem(keyPair.publicKey),\n      cert:        forge.pki.certificateToPem(cert),\n      fingerprint: fingerprint,\n    };\n\n    if (options && options.pkcs7) {\n      var p7 = forge.pkcs7.createSignedData();\n      p7.addCertificate(cert);\n      pem.pkcs7 = forge.pkcs7.messageToPem(p7);\n    }\n\n    if (options && options.clientCertificate) {\n      var clientkeys = forge.pki.rsa.generateKeyPair(1024);\n      var clientcert = forge.pki.createCertificate();\n      clientcert.serialNumber = toPositiveHex(forge.util.bytesToHex(forge.random.getBytesSync(9)));\n      clientcert.validity.notBefore = new Date();\n      clientcert.validity.notAfter = new Date();\n      clientcert.validity.notAfter.setFullYear(clientcert.validity.notBefore.getFullYear() + 1);\n\n      var clientAttrs = JSON.parse(JSON.stringify(attrs));\n\n      for(var i = 0; i < clientAttrs.length; i++) {\n        if(clientAttrs[i].name === 'commonName') {\n          if( options.clientCertificateCN )\n            clientAttrs[i] = { name: 'commonName', value: options.clientCertificateCN };\n          else\n            clientAttrs[i] = { name: 'commonName', value: 'John Doe jdoe123' };\n        }\n      }\n\n      clientcert.setSubject(clientAttrs);\n\n      // Set the issuer to the parent key\n      clientcert.setIssuer(attrs);\n\n      clientcert.publicKey = clientkeys.publicKey;\n\n      // Sign client cert with root cert\n      clientcert.sign(keyPair.privateKey);\n\n      pem.clientprivate = forge.pki.privateKeyToPem(clientkeys.privateKey);\n      pem.clientpublic = forge.pki.publicKeyToPem(clientkeys.publicKey);\n      pem.clientcert = forge.pki.certificateToPem(clientcert);\n\n      if (options.pkcs7) {\n        var clientp7 = forge.pkcs7.createSignedData();\n        clientp7.addCertificate(clientcert);\n        pem.clientpkcs7 = forge.pkcs7.messageToPem(clientp7);\n      }\n    }\n\n    var caStore = forge.pki.createCaStore();\n    caStore.addCertificate(cert);\n\n    try {\n      forge.pki.verifyCertificateChain(caStore, [cert],\n        function (vfd, depth, chain) {\n          if (vfd !== true) {\n            throw new Error('Certificate could not be verified.');\n          }\n          return true;\n        });\n    }\n    catch(ex) {\n      throw new Error(ex);\n    }\n\n    return pem;\n  };\n\n  var keySize = options.keySize || 1024;\n\n  if (done) { // async scenario\n    return forge.pki.rsa.generateKeyPair({ bits: keySize }, function (err, keyPair) {\n      if (err) { return done(err); }\n\n      try {\n        return done(null, generatePem(keyPair));\n      } catch (ex) {\n        return done(ex);\n      }\n    });\n  }\n\n  var keyPair = options.keyPair ? {\n    privateKey: forge.pki.privateKeyFromPem(options.keyPair.privateKey),\n    publicKey: forge.pki.publicKeyFromPem(options.keyPair.publicKey)\n  } : forge.pki.rsa.generateKeyPair(keySize);\n\n  return generatePem(keyPair);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}