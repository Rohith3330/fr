{"ast":null,"code":"\"use strict\";\n\nconst selectorParser = require(\"postcss-selector-parser\");\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getSingleLocalNamesForComposes(root) {\n  return root.nodes.map(node => {\n    if (node.type !== \"selector\" || node.nodes.length !== 1) {\n      throw new Error(`composition is only allowed when selector is single :local class name not in \"${root}\"`);\n    }\n\n    node = node.nodes[0];\n\n    if (node.type !== \"pseudo\" || node.value !== \":local\" || node.nodes.length !== 1) {\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n\n    node = node.first;\n\n    if (node.type !== \"selector\" || node.length !== 1) {\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n\n    node = node.first;\n\n    if (node.type !== \"class\") {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error('composition is only allowed when selector is single :local class name not in \"' + root + '\", \"' + node + '\" is weird');\n    }\n\n    return node.value;\n  });\n}\n\nconst whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\nconst unescapeRegExp = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\");\n\nfunction unescape(str) {\n  return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {\n    const high = \"0x\" + escaped - 0x10000; // NaN means non-codepoint\n    // Workaround erroneous numeric interpretation of +\"0x\"\n\n    return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n    String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n    String.fromCharCode(high >> 10 | 0xd800, high & 0x3ff | 0xdc00);\n  });\n}\n\nconst plugin = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const generateScopedName = options && options.generateScopedName || plugin.generateScopedName;\n  const generateExportEntry = options && options.generateExportEntry || plugin.generateExportEntry;\n  const exportGlobals = options && options.exportGlobals;\n  return {\n    postcssPlugin: \"postcss-modules-scope\",\n\n    Once(root, _ref) {\n      let {\n        rule\n      } = _ref;\n      const exports = Object.create(null);\n\n      function exportScopedName(name, rawName) {\n        const scopedName = generateScopedName(rawName ? rawName : name, root.source.input.from, root.source.input.css);\n        const exportEntry = generateExportEntry(rawName ? rawName : name, scopedName, root.source.input.from, root.source.input.css);\n        const {\n          key,\n          value\n        } = exportEntry;\n        exports[key] = exports[key] || [];\n\n        if (exports[key].indexOf(value) < 0) {\n          exports[key].push(value);\n        }\n\n        return scopedName;\n      }\n\n      function localizeNode(node) {\n        switch (node.type) {\n          case \"selector\":\n            node.nodes = node.map(localizeNode);\n            return node;\n\n          case \"class\":\n            return selectorParser.className({\n              value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null)\n            });\n\n          case \"id\":\n            {\n              return selectorParser.id({\n                value: exportScopedName(node.value, node.raws && node.raws.value ? node.raws.value : null)\n              });\n            }\n        }\n\n        throw new Error(`${node.type} (\"${node}\") is not allowed in a :local block`);\n      }\n\n      function traverseNode(node) {\n        switch (node.type) {\n          case \"pseudo\":\n            if (node.value === \":local\") {\n              if (node.nodes.length !== 1) {\n                throw new Error('Unexpected comma (\",\") in :local block');\n              }\n\n              const selector = localizeNode(node.first, node.spaces); // move the spaces that were around the psuedo selector to the first\n              // non-container node\n\n              selector.first.spaces = node.spaces;\n              const nextNode = node.next();\n\n              if (nextNode && nextNode.type === \"combinator\" && nextNode.value === \" \" && /\\\\[A-F0-9]{1,6}$/.test(selector.last.value)) {\n                selector.last.spaces.after = \" \";\n              }\n\n              node.replaceWith(selector);\n              return;\n            }\n\n          /* falls through */\n\n          case \"root\":\n          case \"selector\":\n            {\n              node.each(traverseNode);\n              break;\n            }\n\n          case \"id\":\n          case \"class\":\n            if (exportGlobals) {\n              exports[node.value] = [node.value];\n            }\n\n            break;\n        }\n\n        return node;\n      } // Find any :import and remember imported names\n\n\n      const importedNames = {};\n      root.walkRules(/^:import\\(.+\\)$/, rule => {\n        rule.walkDecls(decl => {\n          importedNames[decl.prop] = true;\n        });\n      }); // Find any :local selectors\n\n      root.walkRules(rule => {\n        let parsedSelector = selectorParser().astSync(rule);\n        rule.selector = traverseNode(parsedSelector.clone()).toString();\n        rule.walkDecls(/composes|compose-with/i, decl => {\n          const localNames = getSingleLocalNamesForComposes(parsedSelector);\n          const classes = decl.value.split(/\\s+/);\n          classes.forEach(className => {\n            const global = /^global\\(([^)]+)\\)$/.exec(className);\n\n            if (global) {\n              localNames.forEach(exportedName => {\n                exports[exportedName].push(global[1]);\n              });\n            } else if (hasOwnProperty.call(importedNames, className)) {\n              localNames.forEach(exportedName => {\n                exports[exportedName].push(className);\n              });\n            } else if (hasOwnProperty.call(exports, className)) {\n              localNames.forEach(exportedName => {\n                exports[className].forEach(item => {\n                  exports[exportedName].push(item);\n                });\n              });\n            } else {\n              throw decl.error(`referenced class name \"${className}\" in ${decl.prop} not found`);\n            }\n          });\n          decl.remove();\n        }); // Find any :local values\n\n        rule.walkDecls(decl => {\n          if (!/:local\\s*\\((.+?)\\)/.test(decl.value)) {\n            return;\n          }\n\n          let tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n          tokens = tokens.map((token, idx) => {\n            if (idx === 0 || tokens[idx - 1] === \",\") {\n              let result = token;\n              const localMatch = /:local\\s*\\((.+?)\\)/.exec(token);\n\n              if (localMatch) {\n                const input = localMatch.input;\n                const matchPattern = localMatch[0];\n                const matchVal = localMatch[1];\n                const newVal = exportScopedName(matchVal);\n                result = input.replace(matchPattern, newVal);\n              } else {\n                return token;\n              }\n\n              return result;\n            } else {\n              return token;\n            }\n          });\n          decl.value = tokens.join(\"\");\n        });\n      }); // Find any :local keyframes\n\n      root.walkAtRules(/keyframes$/i, atRule => {\n        const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atRule.params);\n\n        if (!localMatch) {\n          return;\n        }\n\n        atRule.params = exportScopedName(localMatch[1]);\n      }); // If we found any :locals, insert an :export rule\n\n      const exportedNames = Object.keys(exports);\n\n      if (exportedNames.length > 0) {\n        const exportRule = rule({\n          selector: \":export\"\n        });\n        exportedNames.forEach(exportedName => exportRule.append({\n          prop: exportedName,\n          value: exports[exportedName].join(\" \"),\n          raws: {\n            before: \"\\n  \"\n          }\n        }));\n        root.append(exportRule);\n      }\n    }\n\n  };\n};\n\nplugin.postcss = true;\n\nplugin.generateScopedName = function (name, path) {\n  const sanitisedPath = path.replace(/\\.[^./\\\\]+$/, \"\").replace(/[\\W_]+/g, \"_\").replace(/^_|_$/g, \"\");\n  return `_${sanitisedPath}__${name}`.trim();\n};\n\nplugin.generateExportEntry = function (name, scopedName) {\n  return {\n    key: unescape(name),\n    value: unescape(scopedName)\n  };\n};\n\nmodule.exports = plugin;","map":{"version":3,"names":["selectorParser","require","hasOwnProperty","Object","prototype","getSingleLocalNamesForComposes","root","nodes","map","node","type","length","Error","value","first","whitespace","unescapeRegExp","RegExp","unescape","str","replace","_","escaped","escapedWhitespace","high","String","fromCharCode","plugin","options","generateScopedName","generateExportEntry","exportGlobals","postcssPlugin","Once","rule","exports","create","exportScopedName","name","rawName","scopedName","source","input","from","css","exportEntry","key","indexOf","push","localizeNode","className","raws","id","traverseNode","selector","spaces","nextNode","next","test","last","after","replaceWith","each","importedNames","walkRules","walkDecls","decl","prop","parsedSelector","astSync","clone","toString","localNames","classes","split","forEach","global","exec","exportedName","call","item","error","remove","tokens","token","idx","result","localMatch","matchPattern","matchVal","newVal","join","walkAtRules","atRule","params","exportedNames","keys","exportRule","append","before","postcss","path","sanitisedPath","trim","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-modules-scope/src/index.js"],"sourcesContent":["\"use strict\";\n\nconst selectorParser = require(\"postcss-selector-parser\");\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction getSingleLocalNamesForComposes(root) {\n  return root.nodes.map((node) => {\n    if (node.type !== \"selector\" || node.nodes.length !== 1) {\n      throw new Error(\n        `composition is only allowed when selector is single :local class name not in \"${root}\"`\n      );\n    }\n\n    node = node.nodes[0];\n\n    if (\n      node.type !== \"pseudo\" ||\n      node.value !== \":local\" ||\n      node.nodes.length !== 1\n    ) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== \"selector\" || node.length !== 1) {\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    node = node.first;\n\n    if (node.type !== \"class\") {\n      // 'id' is not possible, because you can't compose ids\n      throw new Error(\n        'composition is only allowed when selector is single :local class name not in \"' +\n          root +\n          '\", \"' +\n          node +\n          '\" is weird'\n      );\n    }\n\n    return node.value;\n  });\n}\n\nconst whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\";\nconst unescapeRegExp = new RegExp(\n  \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\",\n  \"ig\"\n);\n\nfunction unescape(str) {\n  return str.replace(unescapeRegExp, (_, escaped, escapedWhitespace) => {\n    const high = \"0x\" + escaped - 0x10000;\n\n    // NaN means non-codepoint\n    // Workaround erroneous numeric interpretation of +\"0x\"\n    return high !== high || escapedWhitespace\n      ? escaped\n      : high < 0\n      ? // BMP codepoint\n        String.fromCharCode(high + 0x10000)\n      : // Supplemental Plane codepoint (surrogate pair)\n        String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00);\n  });\n}\n\nconst plugin = (options = {}) => {\n  const generateScopedName =\n    (options && options.generateScopedName) || plugin.generateScopedName;\n  const generateExportEntry =\n    (options && options.generateExportEntry) || plugin.generateExportEntry;\n  const exportGlobals = options && options.exportGlobals;\n\n  return {\n    postcssPlugin: \"postcss-modules-scope\",\n    Once(root, { rule }) {\n      const exports = Object.create(null);\n\n      function exportScopedName(name, rawName) {\n        const scopedName = generateScopedName(\n          rawName ? rawName : name,\n          root.source.input.from,\n          root.source.input.css\n        );\n        const exportEntry = generateExportEntry(\n          rawName ? rawName : name,\n          scopedName,\n          root.source.input.from,\n          root.source.input.css\n        );\n        const { key, value } = exportEntry;\n\n        exports[key] = exports[key] || [];\n\n        if (exports[key].indexOf(value) < 0) {\n          exports[key].push(value);\n        }\n\n        return scopedName;\n      }\n\n      function localizeNode(node) {\n        switch (node.type) {\n          case \"selector\":\n            node.nodes = node.map(localizeNode);\n            return node;\n          case \"class\":\n            return selectorParser.className({\n              value: exportScopedName(\n                node.value,\n                node.raws && node.raws.value ? node.raws.value : null\n              ),\n            });\n          case \"id\": {\n            return selectorParser.id({\n              value: exportScopedName(\n                node.value,\n                node.raws && node.raws.value ? node.raws.value : null\n              ),\n            });\n          }\n        }\n\n        throw new Error(\n          `${node.type} (\"${node}\") is not allowed in a :local block`\n        );\n      }\n\n      function traverseNode(node) {\n        switch (node.type) {\n          case \"pseudo\":\n            if (node.value === \":local\") {\n              if (node.nodes.length !== 1) {\n                throw new Error('Unexpected comma (\",\") in :local block');\n              }\n\n              const selector = localizeNode(node.first, node.spaces);\n              // move the spaces that were around the psuedo selector to the first\n              // non-container node\n              selector.first.spaces = node.spaces;\n\n              const nextNode = node.next();\n\n              if (\n                nextNode &&\n                nextNode.type === \"combinator\" &&\n                nextNode.value === \" \" &&\n                /\\\\[A-F0-9]{1,6}$/.test(selector.last.value)\n              ) {\n                selector.last.spaces.after = \" \";\n              }\n\n              node.replaceWith(selector);\n\n              return;\n            }\n          /* falls through */\n          case \"root\":\n          case \"selector\": {\n            node.each(traverseNode);\n            break;\n          }\n          case \"id\":\n          case \"class\":\n            if (exportGlobals) {\n              exports[node.value] = [node.value];\n            }\n            break;\n        }\n        return node;\n      }\n\n      // Find any :import and remember imported names\n      const importedNames = {};\n\n      root.walkRules(/^:import\\(.+\\)$/, (rule) => {\n        rule.walkDecls((decl) => {\n          importedNames[decl.prop] = true;\n        });\n      });\n\n      // Find any :local selectors\n      root.walkRules((rule) => {\n        let parsedSelector = selectorParser().astSync(rule);\n\n        rule.selector = traverseNode(parsedSelector.clone()).toString();\n\n        rule.walkDecls(/composes|compose-with/i, (decl) => {\n          const localNames = getSingleLocalNamesForComposes(parsedSelector);\n          const classes = decl.value.split(/\\s+/);\n\n          classes.forEach((className) => {\n            const global = /^global\\(([^)]+)\\)$/.exec(className);\n\n            if (global) {\n              localNames.forEach((exportedName) => {\n                exports[exportedName].push(global[1]);\n              });\n            } else if (hasOwnProperty.call(importedNames, className)) {\n              localNames.forEach((exportedName) => {\n                exports[exportedName].push(className);\n              });\n            } else if (hasOwnProperty.call(exports, className)) {\n              localNames.forEach((exportedName) => {\n                exports[className].forEach((item) => {\n                  exports[exportedName].push(item);\n                });\n              });\n            } else {\n              throw decl.error(\n                `referenced class name \"${className}\" in ${decl.prop} not found`\n              );\n            }\n          });\n\n          decl.remove();\n        });\n\n        // Find any :local values\n        rule.walkDecls((decl) => {\n          if (!/:local\\s*\\((.+?)\\)/.test(decl.value)) {\n            return;\n          }\n\n          let tokens = decl.value.split(/(,|'[^']*'|\"[^\"]*\")/);\n\n          tokens = tokens.map((token, idx) => {\n            if (idx === 0 || tokens[idx - 1] === \",\") {\n              let result = token;\n\n              const localMatch = /:local\\s*\\((.+?)\\)/.exec(token);\n\n              if (localMatch) {\n                const input = localMatch.input;\n                const matchPattern = localMatch[0];\n                const matchVal = localMatch[1];\n                const newVal = exportScopedName(matchVal);\n\n                result = input.replace(matchPattern, newVal);\n              } else {\n                return token;\n              }\n\n              return result;\n            } else {\n              return token;\n            }\n          });\n\n          decl.value = tokens.join(\"\");\n        });\n      });\n\n      // Find any :local keyframes\n      root.walkAtRules(/keyframes$/i, (atRule) => {\n        const localMatch = /^\\s*:local\\s*\\((.+?)\\)\\s*$/.exec(atRule.params);\n\n        if (!localMatch) {\n          return;\n        }\n\n        atRule.params = exportScopedName(localMatch[1]);\n      });\n\n      // If we found any :locals, insert an :export rule\n      const exportedNames = Object.keys(exports);\n\n      if (exportedNames.length > 0) {\n        const exportRule = rule({ selector: \":export\" });\n\n        exportedNames.forEach((exportedName) =>\n          exportRule.append({\n            prop: exportedName,\n            value: exports[exportedName].join(\" \"),\n            raws: { before: \"\\n  \" },\n          })\n        );\n\n        root.append(exportRule);\n      }\n    },\n  };\n};\n\nplugin.postcss = true;\n\nplugin.generateScopedName = function (name, path) {\n  const sanitisedPath = path\n    .replace(/\\.[^./\\\\]+$/, \"\")\n    .replace(/[\\W_]+/g, \"_\")\n    .replace(/^_|_$/g, \"\");\n\n  return `_${sanitisedPath}__${name}`.trim();\n};\n\nplugin.generateExportEntry = function (name, scopedName) {\n  return {\n    key: unescape(name),\n    value: unescape(scopedName),\n  };\n};\n\nmodule.exports = plugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}