{"ast":null,"code":"'use strict';\n\nconst {\n  list\n} = require('postcss');\n\nconst stylehacks = require('stylehacks');\n\nconst insertCloned = require('../insertCloned.js');\n\nconst parseTrbl = require('../parseTrbl.js');\n\nconst hasAllProps = require('../hasAllProps.js');\n\nconst getDecls = require('../getDecls.js');\n\nconst getRules = require('../getRules.js');\n\nconst getValue = require('../getValue.js');\n\nconst mergeRules = require('../mergeRules.js');\n\nconst minifyTrbl = require('../minifyTrbl.js');\n\nconst minifyWsc = require('../minifyWsc.js');\n\nconst canMerge = require('../canMerge.js');\n\nconst trbl = require('../trbl.js');\n\nconst isCustomProp = require('../isCustomProp.js');\n\nconst canExplode = require('../canExplode.js');\n\nconst getLastNode = require('../getLastNode.js');\n\nconst parseWsc = require('../parseWsc.js');\n\nconst {\n  isValidWsc\n} = require('../validateWsc.js');\n\nconst wsc = ['width', 'style', 'color'];\nconst defaults = ['medium', 'none', 'currentcolor'];\nconst colorMightRequireFallback = /(hsla|rgba|color|hwb|lab|lch|oklab|oklch)\\(/i;\n/**\n * @param {...string} parts\n * @return {string}\n */\n\nfunction borderProperty() {\n  for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {\n    parts[_key] = arguments[_key];\n  }\n\n  return `border-${parts.join('-')}`;\n}\n/**\n * @param {string} value\n * @return {string}\n */\n\n\nfunction mapBorderProperty(value) {\n  return borderProperty(value);\n}\n\nconst directions = trbl.map(mapBorderProperty);\nconst properties = wsc.map(mapBorderProperty);\n/** @type {string[]} */\n\nconst directionalProperties = directions.reduce((prev, curr) => prev.concat(wsc.map(prop => `${curr}-${prop}`)),\n/** @type {string[]} */\n[]);\nconst precedence = [['border'], directions.concat(properties), directionalProperties];\nconst allProperties = precedence.reduce((a, b) => a.concat(b));\n/**\n * @param {string} prop\n * @return {number | undefined}\n */\n\nfunction getLevel(prop) {\n  for (let i = 0; i < precedence.length; i++) {\n    if (precedence[i].includes(prop.toLowerCase())) {\n      return i;\n    }\n  }\n}\n/** @type {(value: string) => boolean} */\n\n\nconst isValueCustomProp = value => value !== undefined && value.search(/var\\s*\\(\\s*--/i) !== -1;\n/**\n * @param {string[]} values\n * @return {boolean}\n */\n\n\nfunction canMergeValues(values) {\n  return !values.some(isValueCustomProp);\n}\n/**\n * @param {import('postcss').Declaration} decl\n * @return {string}\n */\n\n\nfunction getColorValue(decl) {\n  if (decl.prop.substr(-5) === 'color') {\n    return decl.value;\n  }\n\n  return parseWsc(decl.value)[2] || defaults[2];\n}\n/**\n * @param {[string, string, string]} values\n * @param {[string, string, string]} nextValues\n * @return {string[]}\n */\n\n\nfunction diffingProps(values, nextValues) {\n  return wsc.reduce((prev, curr, i) => {\n    if (values[i] === nextValues[i]) {\n      return prev;\n    }\n\n    return [...prev, curr];\n  },\n  /** @type {string[]} */\n  []);\n}\n/**\n * @param {{values: [string, string, string], nextValues: [string, string, string], decl: import('postcss').Declaration, nextDecl: import('postcss').Declaration, index: number}} arg\n * @return {void}\n */\n\n\nfunction mergeRedundant(_ref) {\n  let {\n    values,\n    nextValues,\n    decl,\n    nextDecl,\n    index\n  } = _ref;\n\n  if (!canMerge([decl, nextDecl])) {\n    return;\n  }\n\n  if (stylehacks.detect(decl) || stylehacks.detect(nextDecl)) {\n    return;\n  }\n\n  const diff = diffingProps(values, nextValues);\n\n  if (diff.length !== 1) {\n    return;\n  }\n\n  const prop =\n  /** @type {string} */\n  diff.pop();\n  const position = wsc.indexOf(prop);\n  const prop1 = `${nextDecl.prop}-${prop}`;\n  const prop2 = `border-${prop}`;\n  let props = parseTrbl(values[position]);\n  props[index] = nextValues[position];\n  const borderValue2 = values.filter((e, i) => i !== position).join(' ');\n  const propValue2 = minifyTrbl(props);\n  const origLength = (minifyWsc(decl.value) + nextDecl.prop + nextDecl.value).length;\n  const newLength1 = decl.value.length + prop1.length + minifyWsc(nextValues[position]).length;\n  const newLength2 = borderValue2.length + prop2.length + propValue2.length;\n\n  if (newLength1 < newLength2 && newLength1 < origLength) {\n    nextDecl.prop = prop1;\n    nextDecl.value = nextValues[position];\n  }\n\n  if (newLength2 < newLength1 && newLength2 < origLength) {\n    decl.value = borderValue2;\n    nextDecl.prop = prop2;\n    nextDecl.value = propValue2;\n  }\n}\n/**\n * @param {string | string[]} mapped\n * @return {boolean}\n */\n\n\nfunction isCloseEnough(mapped) {\n  return mapped[0] === mapped[1] && mapped[1] === mapped[2] || mapped[1] === mapped[2] && mapped[2] === mapped[3] || mapped[2] === mapped[3] && mapped[3] === mapped[0] || mapped[3] === mapped[0] && mapped[0] === mapped[1];\n}\n/**\n * @param {string[]} mapped\n * @return {string[]}\n */\n\n\nfunction getDistinctShorthands(mapped) {\n  return [...new Set(mapped)];\n}\n/**\n * @param {import('postcss').Rule} rule\n * @return {void}\n */\n\n\nfunction explode(rule) {\n  rule.walkDecls(/^border/i, decl => {\n    if (!canExplode(decl, false)) {\n      return;\n    }\n\n    if (stylehacks.detect(decl)) {\n      return;\n    }\n\n    const prop = decl.prop.toLowerCase(); // border -> border-trbl\n\n    if (prop === 'border') {\n      if (isValidWsc(parseWsc(decl.value))) {\n        directions.forEach(direction => {\n          insertCloned(\n          /** @type {import('postcss').Rule} */\n          decl.parent, decl, {\n            prop: direction\n          });\n        });\n        decl.remove();\n      }\n    } // border-trbl -> border-trbl-wsc\n\n\n    if (directions.some(direction => prop === direction)) {\n      let values = parseWsc(decl.value);\n\n      if (isValidWsc(values)) {\n        wsc.forEach((d, i) => {\n          insertCloned(\n          /** @type {import('postcss').Rule} */\n          decl.parent, decl, {\n            prop: `${prop}-${d}`,\n            value: values[i] || defaults[i]\n          });\n        });\n        decl.remove();\n      }\n    } // border-wsc -> border-trbl-wsc\n\n\n    wsc.some(style => {\n      if (prop !== borderProperty(style)) {\n        return false;\n      }\n\n      if (isCustomProp(decl)) {\n        decl.prop = decl.prop.toLowerCase();\n        return false;\n      }\n\n      parseTrbl(decl.value).forEach((value, i) => {\n        insertCloned(\n        /** @type {import('postcss').Rule} */\n        decl.parent, decl, {\n          prop: borderProperty(trbl[i], style),\n          value\n        });\n      });\n      return decl.remove();\n    });\n  });\n}\n/**\n * @param {import('postcss').Rule} rule\n * @return {void}\n */\n\n\nfunction merge(rule) {\n  // border-trbl-wsc -> border-trbl\n  trbl.forEach(direction => {\n    const prop = borderProperty(direction);\n    mergeRules(rule, wsc.map(style => borderProperty(direction, style)), (rules, lastNode) => {\n      if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n        insertCloned(\n        /** @type {import('postcss').Rule} */\n        lastNode.parent, lastNode, {\n          prop,\n          value: rules.map(getValue).join(' ')\n        });\n\n        for (const node of rules) {\n          node.remove();\n        }\n\n        return true;\n      }\n\n      return false;\n    });\n  }); // border-trbl-wsc -> border-wsc\n\n  wsc.forEach(style => {\n    const prop = borderProperty(style);\n    mergeRules(rule, trbl.map(direction => borderProperty(direction, style)), (rules, lastNode) => {\n      if (canMerge(rules) && !rules.some(stylehacks.detect)) {\n        insertCloned(\n        /** @type {import('postcss').Rule} */\n        lastNode.parent, lastNode, {\n          prop,\n          value: minifyTrbl(rules.map(getValue).join(' '))\n        });\n\n        for (const node of rules) {\n          node.remove();\n        }\n\n        return true;\n      }\n\n      return false;\n    });\n  }); // border-trbl -> border-wsc\n\n  mergeRules(rule, directions, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return false;\n    }\n\n    const values = rules.map(_ref2 => {\n      let {\n        value\n      } = _ref2;\n      return value;\n    });\n\n    if (!canMergeValues(values)) {\n      return false;\n    }\n\n    const parsed = values.map(value => parseWsc(value));\n\n    if (!parsed.every(isValidWsc)) {\n      return false;\n    }\n\n    wsc.forEach((d, i) => {\n      const value = parsed.map(v => v[i] || defaults[i]);\n\n      if (canMergeValues(value)) {\n        insertCloned(\n        /** @type {import('postcss').Rule} */\n        lastNode.parent, lastNode, {\n          prop: borderProperty(d),\n          value: minifyTrbl(\n          /** @type {[string, string, string, string]} */\n          value)\n        });\n      } else {\n        insertCloned(\n        /** @type {import('postcss').Rule} */\n        lastNode.parent, lastNode);\n      }\n    });\n\n    for (const node of rules) {\n      node.remove();\n    }\n\n    return true;\n  }); // border-wsc -> border\n  // border-wsc -> border + border-color\n  // border-wsc -> border + border-dir\n\n  mergeRules(rule, properties, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return false;\n    }\n\n    const values = rules.map(node => parseTrbl(node.value));\n    const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));\n\n    if (!canMergeValues(mapped)) {\n      return false;\n    }\n\n    const [width, style, color] = rules;\n    const reduced = getDistinctShorthands(mapped);\n\n    if (isCloseEnough(mapped) && canMerge(rules, false)) {\n      const first = mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);\n      const border = insertCloned(\n      /** @type {import('postcss').Rule} */\n      lastNode.parent, lastNode, {\n        prop: 'border',\n        value: first ? reduced[0] : reduced[1]\n      });\n\n      if (reduced[1]) {\n        const value = first ? reduced[1] : reduced[0];\n        const prop = borderProperty(trbl[mapped.indexOf(value)]);\n        rule.insertAfter(border, Object.assign(lastNode.clone(), {\n          prop,\n          value\n        }));\n      }\n\n      for (const node of rules) {\n        node.remove();\n      }\n\n      return true;\n    } else if (reduced.length === 1) {\n      rule.insertBefore(color, Object.assign(lastNode.clone(), {\n        prop: 'border',\n        value: [width, style].map(getValue).join(' ')\n      }));\n      rules.filter(node => node.prop.toLowerCase() !== properties[2]).forEach(node => node.remove());\n      return true;\n    }\n\n    return false;\n  }); // border-wsc -> border + border-trbl\n\n  mergeRules(rule, properties, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return false;\n    }\n\n    const values = rules.map(node => parseTrbl(node.value));\n    const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));\n    const reduced = getDistinctShorthands(mapped);\n    const none = 'medium none currentcolor';\n\n    if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {\n      const filtered = mapped.filter(p => p !== none);\n      const mostCommon = reduced.sort((a, b) => mapped.filter(v => v === b).length - mapped.filter(v => v === a).length)[0];\n      const borderValue = reduced.length === 2 ? filtered[0] : mostCommon;\n      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n        prop: 'border',\n        value: borderValue\n      }));\n      directions.forEach((dir, i) => {\n        if (mapped[i] !== borderValue) {\n          rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n            prop: dir,\n            value: mapped[i]\n          }));\n        }\n      });\n\n      for (const node of rules) {\n        node.remove();\n      }\n\n      return true;\n    }\n\n    return false;\n  }); // border-trbl -> border\n  // border-trbl -> border + border-trbl\n\n  mergeRules(rule, directions, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return false;\n    }\n\n    const values = rules.map(node => {\n      const wscValue = parseWsc(node.value);\n\n      if (!isValidWsc(wscValue)) {\n        return node.value;\n      }\n\n      return wscValue.map((value, i) => value || defaults[i]).join(' ');\n    });\n    const reduced = getDistinctShorthands(values);\n\n    if (isCloseEnough(values)) {\n      const first = values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);\n      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n        prop: 'border',\n        value: minifyWsc(first ? values[0] : values[1])\n      }));\n\n      if (reduced[1]) {\n        const value = first ? reduced[1] : reduced[0];\n        const prop = directions[values.indexOf(value)];\n        rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {\n          prop: prop,\n          value: minifyWsc(value)\n        }));\n      }\n\n      for (const node of rules) {\n        node.remove();\n      }\n\n      return true;\n    }\n\n    return false;\n  }); // border-trbl-wsc + border-trbl (custom prop) -> border-trbl + border-trbl-wsc (custom prop)\n\n  directions.forEach(direction => {\n    wsc.forEach((style, i) => {\n      const prop = `${direction}-${style}`;\n      mergeRules(rule, [direction, prop], (rules, lastNode) => {\n        if (lastNode.prop !== direction) {\n          return false;\n        }\n\n        const values = parseWsc(lastNode.value);\n\n        if (!isValidWsc(values)) {\n          return false;\n        }\n\n        const wscProp = rules.filter(r => r !== lastNode)[0];\n\n        if (!isValueCustomProp(values[i]) || isCustomProp(wscProp)) {\n          return false;\n        }\n\n        const wscValue = values[i];\n        values[i] = wscProp.value;\n\n        if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n          insertCloned(\n          /** @type {import('postcss').Rule} */\n          lastNode.parent, lastNode, {\n            prop,\n            value: wscValue\n          });\n          lastNode.value = minifyWsc(\n          /** @type {any} */\n          values);\n          wscProp.remove();\n          return true;\n        }\n\n        return false;\n      });\n    });\n  }); // border-wsc + border (custom prop) -> border + border-wsc (custom prop)\n\n  wsc.forEach((style, i) => {\n    const prop = borderProperty(style);\n    mergeRules(rule, ['border', prop], (rules, lastNode) => {\n      if (lastNode.prop !== 'border') {\n        return false;\n      }\n\n      const values = parseWsc(lastNode.value);\n\n      if (!isValidWsc(values)) {\n        return false;\n      }\n\n      const wscProp = rules.filter(r => r !== lastNode)[0];\n\n      if (!isValueCustomProp(values[i]) || isCustomProp(wscProp)) {\n        return false;\n      }\n\n      const wscValue = values[i];\n      values[i] = wscProp.value;\n\n      if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n        insertCloned(\n        /** @type {import('postcss').Rule} */\n        lastNode.parent, lastNode, {\n          prop,\n          value: wscValue\n        });\n        lastNode.value = minifyWsc(\n        /** @type {any} */\n        values);\n        wscProp.remove();\n        return true;\n      }\n\n      return false;\n    });\n  }); // optimize border-trbl\n\n  let decls = getDecls(rule, directions);\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n    wsc.forEach((d, i) => {\n      const names = directions.filter(name => name !== lastNode.prop).map(name => `${name}-${d}`);\n      let nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));\n      const border = getLastNode(nodes, 'border');\n\n      if (border) {\n        nodes = nodes.slice(nodes.indexOf(border));\n      }\n\n      const props = nodes.filter(node => node.type === 'decl' && names.includes(node.prop) && node.important === lastNode.important);\n      const rules = getRules(\n      /** @type {import('postcss').Declaration[]} */\n      props, names);\n\n      if (hasAllProps(rules, ...names) && !rules.some(stylehacks.detect)) {\n        const values = rules.map(node => node ? node.value : null);\n        const filteredValues = values.filter(Boolean);\n        const lastNodeValue = list.space(lastNode.value)[i];\n        values[directions.indexOf(lastNode.prop)] = lastNodeValue;\n        let value = minifyTrbl(values.join(' '));\n\n        if (filteredValues[0] === filteredValues[1] && filteredValues[1] === filteredValues[2]) {\n          value =\n          /** @type {string} */\n          filteredValues[0];\n        }\n\n        let refNode = props[props.length - 1];\n\n        if (value === lastNodeValue) {\n          refNode = lastNode;\n          let valueArray = list.space(lastNode.value);\n          valueArray.splice(i, 1);\n          lastNode.value = valueArray.join(' ');\n        }\n\n        insertCloned(\n        /** @type {import('postcss').Rule} */\n        refNode.parent,\n        /** @type {import('postcss').Declaration} */\n        refNode, {\n          prop: borderProperty(d),\n          value\n        });\n        decls = decls.filter(node => !rules.includes(node));\n\n        for (const node of rules) {\n          node.remove();\n        }\n      }\n    });\n    decls = decls.filter(node => node !== lastNode);\n  }\n\n  rule.walkDecls('border', decl => {\n    const nextDecl = decl.next();\n\n    if (!nextDecl || nextDecl.type !== 'decl') {\n      return false;\n    }\n\n    const index = directions.indexOf(nextDecl.prop);\n\n    if (index === -1) {\n      return;\n    }\n\n    const values = parseWsc(decl.value);\n    const nextValues = parseWsc(nextDecl.value);\n\n    if (!isValidWsc(values) || !isValidWsc(nextValues)) {\n      return;\n    }\n\n    const config = {\n      values,\n      nextValues,\n      decl,\n      nextDecl,\n      index\n    };\n    return mergeRedundant(config);\n  });\n  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {\n    let values = parseWsc(decl.value);\n\n    if (!isValidWsc(values)) {\n      return;\n    }\n\n    const position = directions.indexOf(decl.prop);\n    let dirs = [...directions];\n    dirs.splice(position, 1);\n    wsc.forEach((d, i) => {\n      const props = dirs.map(dir => `${dir}-${d}`);\n      mergeRules(rule, [decl.prop, ...props], rules => {\n        if (!rules.includes(decl)) {\n          return false;\n        }\n\n        const longhands = rules.filter(p => p !== decl);\n\n        if (longhands[0].value.toLowerCase() === longhands[1].value.toLowerCase() && longhands[1].value.toLowerCase() === longhands[2].value.toLowerCase() && values[i] !== undefined && longhands[0].value.toLowerCase() === values[i].toLowerCase()) {\n          for (const node of longhands) {\n            node.remove();\n          }\n\n          insertCloned(\n          /** @type {import('postcss').Rule} */\n          decl.parent, decl, {\n            prop: borderProperty(d),\n            value: values[i]\n          });\n          /** @type {string|null} */\n\n          values[i] = null;\n        }\n\n        return false;\n      });\n      const newValue = values.join(' ');\n\n      if (newValue) {\n        decl.value = newValue;\n      } else {\n        decl.remove();\n      }\n    });\n  }); // clean-up values\n\n  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {\n    decl.value = minifyWsc(decl.value);\n  }); // border-spacing-hv -> border-spacing\n\n  rule.walkDecls(/^border-spacing$/i, decl => {\n    const value = list.space(decl.value); // merge vertical and horizontal dups\n\n    if (value.length > 1 && value[0] === value[1]) {\n      decl.value = value.slice(1).join(' ');\n    }\n  }); // clean-up rules\n\n  decls = getDecls(rule, allProperties);\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n    const lastPart = lastNode.prop.split('-').pop(); // remove properties of lower precedence\n\n    const lesser = decls.filter(node => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && !isCustomProp(lastNode) && node !== lastNode && node.important === lastNode.important &&\n    /** @type {number} */\n    getLevel(node.prop) >\n    /** @type {number} */\n    getLevel(lastNode.prop) && (node.prop.toLowerCase().includes(lastNode.prop) || node.prop.toLowerCase().endsWith(\n    /** @type {string} */\n    lastPart)));\n\n    for (const node of lesser) {\n      node.remove();\n    }\n\n    decls = decls.filter(node => !lesser.includes(node)); // get duplicate properties\n\n    let duplicates = decls.filter(node => !stylehacks.detect(lastNode) && !stylehacks.detect(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!isCustomProp(node) && isCustomProp(lastNode)));\n\n    if (duplicates.length) {\n      if (colorMightRequireFallback.test(getColorValue(lastNode))) {\n        const preserve = duplicates.filter(node => !colorMightRequireFallback.test(getColorValue(node))).pop();\n        duplicates = duplicates.filter(node => node !== preserve);\n      }\n\n      for (const node of duplicates) {\n        node.remove();\n      }\n    }\n\n    decls = decls.filter(node => node !== lastNode && !duplicates.includes(node));\n  }\n}\n\nmodule.exports = {\n  explode,\n  merge\n};","map":{"version":3,"names":["list","require","stylehacks","insertCloned","parseTrbl","hasAllProps","getDecls","getRules","getValue","mergeRules","minifyTrbl","minifyWsc","canMerge","trbl","isCustomProp","canExplode","getLastNode","parseWsc","isValidWsc","wsc","defaults","colorMightRequireFallback","borderProperty","parts","join","mapBorderProperty","value","directions","map","properties","directionalProperties","reduce","prev","curr","concat","prop","precedence","allProperties","a","b","getLevel","i","length","includes","toLowerCase","isValueCustomProp","undefined","search","canMergeValues","values","some","getColorValue","decl","substr","diffingProps","nextValues","mergeRedundant","nextDecl","index","detect","diff","pop","position","indexOf","prop1","prop2","props","borderValue2","filter","e","propValue2","origLength","newLength1","newLength2","isCloseEnough","mapped","getDistinctShorthands","Set","explode","rule","walkDecls","forEach","direction","parent","remove","d","style","merge","rules","lastNode","node","parsed","every","v","width","color","reduced","first","lastIndexOf","border","insertAfter","Object","assign","clone","insertBefore","none","filtered","p","mostCommon","sort","borderValue","dir","wscValue","wscProp","r","decls","names","name","nodes","slice","type","important","filteredValues","Boolean","lastNodeValue","space","refNode","valueArray","splice","next","config","dirs","longhands","newValue","lastPart","split","lesser","endsWith","duplicates","test","preserve","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-merge-longhand/src/lib/decl/borders.js"],"sourcesContent":["'use strict';\nconst { list } = require('postcss');\nconst stylehacks = require('stylehacks');\nconst insertCloned = require('../insertCloned.js');\nconst parseTrbl = require('../parseTrbl.js');\nconst hasAllProps = require('../hasAllProps.js');\nconst getDecls = require('../getDecls.js');\nconst getRules = require('../getRules.js');\nconst getValue = require('../getValue.js');\nconst mergeRules = require('../mergeRules.js');\nconst minifyTrbl = require('../minifyTrbl.js');\nconst minifyWsc = require('../minifyWsc.js');\nconst canMerge = require('../canMerge.js');\nconst trbl = require('../trbl.js');\nconst isCustomProp = require('../isCustomProp.js');\nconst canExplode = require('../canExplode.js');\nconst getLastNode = require('../getLastNode.js');\nconst parseWsc = require('../parseWsc.js');\nconst { isValidWsc } = require('../validateWsc.js');\n\nconst wsc = ['width', 'style', 'color'];\nconst defaults = ['medium', 'none', 'currentcolor'];\nconst colorMightRequireFallback =\n  /(hsla|rgba|color|hwb|lab|lch|oklab|oklch)\\(/i;\n\n/**\n * @param {...string} parts\n * @return {string}\n */\nfunction borderProperty(...parts) {\n  return `border-${parts.join('-')}`;\n}\n/**\n * @param {string} value\n * @return {string}\n */\nfunction mapBorderProperty(value) {\n  return borderProperty(value);\n}\n\nconst directions = trbl.map(mapBorderProperty);\nconst properties = wsc.map(mapBorderProperty);\n/** @type {string[]} */\nconst directionalProperties = directions.reduce(\n  (prev, curr) => prev.concat(wsc.map((prop) => `${curr}-${prop}`)),\n  /** @type {string[]} */ ([])\n);\n\nconst precedence = [\n  ['border'],\n  directions.concat(properties),\n  directionalProperties,\n];\n\nconst allProperties = precedence.reduce((a, b) => a.concat(b));\n\n/**\n * @param {string} prop\n * @return {number | undefined}\n */\nfunction getLevel(prop) {\n  for (let i = 0; i < precedence.length; i++) {\n    if (precedence[i].includes(prop.toLowerCase())) {\n      return i;\n    }\n  }\n}\n\n/** @type {(value: string) => boolean} */\nconst isValueCustomProp = (value) =>\n  value !== undefined && value.search(/var\\s*\\(\\s*--/i) !== -1;\n\n/**\n * @param {string[]} values\n * @return {boolean}\n */\nfunction canMergeValues(values) {\n  return !values.some(isValueCustomProp);\n}\n\n/**\n * @param {import('postcss').Declaration} decl\n * @return {string}\n */\nfunction getColorValue(decl) {\n  if (decl.prop.substr(-5) === 'color') {\n    return decl.value;\n  }\n\n  return parseWsc(decl.value)[2] || defaults[2];\n}\n\n/**\n * @param {[string, string, string]} values\n * @param {[string, string, string]} nextValues\n * @return {string[]}\n */\nfunction diffingProps(values, nextValues) {\n  return wsc.reduce((prev, curr, i) => {\n    if (values[i] === nextValues[i]) {\n      return prev;\n    }\n\n    return [...prev, curr];\n  }, /** @type {string[]} */ ([]));\n}\n\n/**\n * @param {{values: [string, string, string], nextValues: [string, string, string], decl: import('postcss').Declaration, nextDecl: import('postcss').Declaration, index: number}} arg\n * @return {void}\n */\nfunction mergeRedundant({ values, nextValues, decl, nextDecl, index }) {\n  if (!canMerge([decl, nextDecl])) {\n    return;\n  }\n\n  if (stylehacks.detect(decl) || stylehacks.detect(nextDecl)) {\n    return;\n  }\n\n  const diff = diffingProps(values, nextValues);\n\n  if (diff.length !== 1) {\n    return;\n  }\n\n  const prop = /** @type {string} */ (diff.pop());\n  const position = wsc.indexOf(prop);\n\n  const prop1 = `${nextDecl.prop}-${prop}`;\n  const prop2 = `border-${prop}`;\n\n  let props = parseTrbl(values[position]);\n\n  props[index] = nextValues[position];\n\n  const borderValue2 = values.filter((e, i) => i !== position).join(' ');\n  const propValue2 = minifyTrbl(props);\n\n  const origLength = (minifyWsc(decl.value) + nextDecl.prop + nextDecl.value)\n    .length;\n  const newLength1 =\n    decl.value.length + prop1.length + minifyWsc(nextValues[position]).length;\n  const newLength2 = borderValue2.length + prop2.length + propValue2.length;\n\n  if (newLength1 < newLength2 && newLength1 < origLength) {\n    nextDecl.prop = prop1;\n    nextDecl.value = nextValues[position];\n  }\n\n  if (newLength2 < newLength1 && newLength2 < origLength) {\n    decl.value = borderValue2;\n    nextDecl.prop = prop2;\n    nextDecl.value = propValue2;\n  }\n}\n\n/**\n * @param {string | string[]} mapped\n * @return {boolean}\n */\nfunction isCloseEnough(mapped) {\n  return (\n    (mapped[0] === mapped[1] && mapped[1] === mapped[2]) ||\n    (mapped[1] === mapped[2] && mapped[2] === mapped[3]) ||\n    (mapped[2] === mapped[3] && mapped[3] === mapped[0]) ||\n    (mapped[3] === mapped[0] && mapped[0] === mapped[1])\n  );\n}\n\n/**\n * @param {string[]} mapped\n * @return {string[]}\n */\nfunction getDistinctShorthands(mapped) {\n  return [...new Set(mapped)];\n}\n/**\n * @param {import('postcss').Rule} rule\n * @return {void}\n */\nfunction explode(rule) {\n  rule.walkDecls(/^border/i, (decl) => {\n    if (!canExplode(decl, false)) {\n      return;\n    }\n\n    if (stylehacks.detect(decl)) {\n      return;\n    }\n\n    const prop = decl.prop.toLowerCase();\n\n    // border -> border-trbl\n    if (prop === 'border') {\n      if (isValidWsc(parseWsc(decl.value))) {\n        directions.forEach((direction) => {\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (decl.parent),\n            decl,\n            { prop: direction }\n          );\n        });\n\n        decl.remove();\n      }\n    }\n\n    // border-trbl -> border-trbl-wsc\n    if (directions.some((direction) => prop === direction)) {\n      let values = parseWsc(decl.value);\n\n      if (isValidWsc(values)) {\n        wsc.forEach((d, i) => {\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (decl.parent),\n            decl,\n            {\n              prop: `${prop}-${d}`,\n              value: values[i] || defaults[i],\n            }\n          );\n        });\n\n        decl.remove();\n      }\n    }\n\n    // border-wsc -> border-trbl-wsc\n    wsc.some((style) => {\n      if (prop !== borderProperty(style)) {\n        return false;\n      }\n\n      if (isCustomProp(decl)) {\n        decl.prop = decl.prop.toLowerCase();\n        return false;\n      }\n      parseTrbl(decl.value).forEach((value, i) => {\n        insertCloned(\n          /** @type {import('postcss').Rule} */ (decl.parent),\n          decl,\n          {\n            prop: borderProperty(trbl[i], style),\n            value,\n          }\n        );\n      });\n\n      return decl.remove();\n    });\n  });\n}\n\n/**\n * @param {import('postcss').Rule} rule\n * @return {void}\n */\nfunction merge(rule) {\n  // border-trbl-wsc -> border-trbl\n  trbl.forEach((direction) => {\n    const prop = borderProperty(direction);\n\n    mergeRules(\n      rule,\n      wsc.map((style) => borderProperty(direction, style)),\n      (rules, lastNode) => {\n        if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (lastNode.parent),\n            lastNode,\n            {\n              prop,\n              value: rules.map(getValue).join(' '),\n            }\n          );\n          for (const node of rules) {\n            node.remove();\n          }\n\n          return true;\n        }\n        return false;\n      }\n    );\n  });\n\n  // border-trbl-wsc -> border-wsc\n  wsc.forEach((style) => {\n    const prop = borderProperty(style);\n\n    mergeRules(\n      rule,\n      trbl.map((direction) => borderProperty(direction, style)),\n      (rules, lastNode) => {\n        if (canMerge(rules) && !rules.some(stylehacks.detect)) {\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (lastNode.parent),\n            lastNode,\n            {\n              prop,\n              value: minifyTrbl(rules.map(getValue).join(' ')),\n            }\n          );\n\n          for (const node of rules) {\n            node.remove();\n          }\n\n          return true;\n        }\n        return false;\n      }\n    );\n  });\n\n  // border-trbl -> border-wsc\n  mergeRules(rule, directions, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return false;\n    }\n\n    const values = rules.map(({ value }) => value);\n\n    if (!canMergeValues(values)) {\n      return false;\n    }\n\n    const parsed = values.map((value) => parseWsc(value));\n\n    if (!parsed.every(isValidWsc)) {\n      return false;\n    }\n\n    wsc.forEach((d, i) => {\n      const value = parsed.map((v) => v[i] || defaults[i]);\n\n      if (canMergeValues(value)) {\n        insertCloned(\n          /** @type {import('postcss').Rule} */ (lastNode.parent),\n          lastNode,\n          {\n            prop: borderProperty(d),\n            value: minifyTrbl(\n              /** @type {[string, string, string, string]} */ (value)\n            ),\n          }\n        );\n      } else {\n        insertCloned(\n          /** @type {import('postcss').Rule} */ (lastNode.parent),\n          lastNode\n        );\n      }\n    });\n\n    for (const node of rules) {\n      node.remove();\n    }\n\n    return true;\n  });\n\n  // border-wsc -> border\n  // border-wsc -> border + border-color\n  // border-wsc -> border + border-dir\n  mergeRules(rule, properties, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return false;\n    }\n\n    const values = rules.map((node) => parseTrbl(node.value));\n    const mapped = [0, 1, 2, 3].map((i) =>\n      [values[0][i], values[1][i], values[2][i]].join(' ')\n    );\n\n    if (!canMergeValues(mapped)) {\n      return false;\n    }\n\n    const [width, style, color] = rules;\n    const reduced = getDistinctShorthands(mapped);\n\n    if (isCloseEnough(mapped) && canMerge(rules, false)) {\n      const first =\n        mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);\n\n      const border = insertCloned(\n        /** @type {import('postcss').Rule} */ (lastNode.parent),\n        lastNode,\n        {\n          prop: 'border',\n          value: first ? reduced[0] : reduced[1],\n        }\n      );\n\n      if (reduced[1]) {\n        const value = first ? reduced[1] : reduced[0];\n        const prop = borderProperty(trbl[mapped.indexOf(value)]);\n\n        rule.insertAfter(\n          border,\n          Object.assign(lastNode.clone(), {\n            prop,\n            value,\n          })\n        );\n      }\n      for (const node of rules) {\n        node.remove();\n      }\n\n      return true;\n    } else if (reduced.length === 1) {\n      rule.insertBefore(\n        color,\n        Object.assign(lastNode.clone(), {\n          prop: 'border',\n          value: [width, style].map(getValue).join(' '),\n        })\n      );\n      rules\n        .filter((node) => node.prop.toLowerCase() !== properties[2])\n        .forEach((node) => node.remove());\n\n      return true;\n    }\n    return false;\n  });\n\n  // border-wsc -> border + border-trbl\n  mergeRules(rule, properties, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return false;\n    }\n\n    const values = rules.map((node) => parseTrbl(node.value));\n    const mapped = [0, 1, 2, 3].map((i) =>\n      [values[0][i], values[1][i], values[2][i]].join(' ')\n    );\n    const reduced = getDistinctShorthands(mapped);\n    const none = 'medium none currentcolor';\n\n    if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {\n      const filtered = mapped.filter((p) => p !== none);\n      const mostCommon = reduced.sort(\n        (a, b) =>\n          mapped.filter((v) => v === b).length -\n          mapped.filter((v) => v === a).length\n      )[0];\n      const borderValue = reduced.length === 2 ? filtered[0] : mostCommon;\n\n      rule.insertBefore(\n        lastNode,\n        Object.assign(lastNode.clone(), {\n          prop: 'border',\n          value: borderValue,\n        })\n      );\n\n      directions.forEach((dir, i) => {\n        if (mapped[i] !== borderValue) {\n          rule.insertBefore(\n            lastNode,\n            Object.assign(lastNode.clone(), {\n              prop: dir,\n              value: mapped[i],\n            })\n          );\n        }\n      });\n\n      for (const node of rules) {\n        node.remove();\n      }\n\n      return true;\n    }\n    return false;\n  });\n\n  // border-trbl -> border\n  // border-trbl -> border + border-trbl\n  mergeRules(rule, directions, (rules, lastNode) => {\n    if (rules.some(stylehacks.detect)) {\n      return false;\n    }\n\n    const values = rules.map((node) => {\n      const wscValue = parseWsc(node.value);\n\n      if (!isValidWsc(wscValue)) {\n        return node.value;\n      }\n\n      return wscValue.map((value, i) => value || defaults[i]).join(' ');\n    });\n\n    const reduced = getDistinctShorthands(values);\n\n    if (isCloseEnough(values)) {\n      const first =\n        values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);\n\n      rule.insertBefore(\n        lastNode,\n        Object.assign(lastNode.clone(), {\n          prop: 'border',\n          value: minifyWsc(first ? values[0] : values[1]),\n        })\n      );\n\n      if (reduced[1]) {\n        const value = first ? reduced[1] : reduced[0];\n        const prop = directions[values.indexOf(value)];\n        rule.insertBefore(\n          lastNode,\n          Object.assign(lastNode.clone(), {\n            prop: prop,\n            value: minifyWsc(value),\n          })\n        );\n      }\n\n      for (const node of rules) {\n        node.remove();\n      }\n\n      return true;\n    }\n    return false;\n  });\n\n  // border-trbl-wsc + border-trbl (custom prop) -> border-trbl + border-trbl-wsc (custom prop)\n  directions.forEach((direction) => {\n    wsc.forEach((style, i) => {\n      const prop = `${direction}-${style}`;\n\n      mergeRules(rule, [direction, prop], (rules, lastNode) => {\n        if (lastNode.prop !== direction) {\n          return false;\n        }\n\n        const values = parseWsc(lastNode.value);\n\n        if (!isValidWsc(values)) {\n          return false;\n        }\n\n        const wscProp = rules.filter((r) => r !== lastNode)[0];\n\n        if (!isValueCustomProp(values[i]) || isCustomProp(wscProp)) {\n          return false;\n        }\n\n        const wscValue = values[i];\n\n        values[i] = wscProp.value;\n\n        if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (lastNode.parent),\n            lastNode,\n            {\n              prop,\n              value: wscValue,\n            }\n          );\n          lastNode.value = minifyWsc(/** @type {any} */ (values));\n\n          wscProp.remove();\n\n          return true;\n        }\n        return false;\n      });\n    });\n  });\n\n  // border-wsc + border (custom prop) -> border + border-wsc (custom prop)\n  wsc.forEach((style, i) => {\n    const prop = borderProperty(style);\n    mergeRules(rule, ['border', prop], (rules, lastNode) => {\n      if (lastNode.prop !== 'border') {\n        return false;\n      }\n\n      const values = parseWsc(lastNode.value);\n\n      if (!isValidWsc(values)) {\n        return false;\n      }\n\n      const wscProp = rules.filter((r) => r !== lastNode)[0];\n\n      if (!isValueCustomProp(values[i]) || isCustomProp(wscProp)) {\n        return false;\n      }\n\n      const wscValue = values[i];\n\n      values[i] = wscProp.value;\n\n      if (canMerge(rules, false) && !rules.some(stylehacks.detect)) {\n        insertCloned(\n          /** @type {import('postcss').Rule} */ (lastNode.parent),\n          lastNode,\n          {\n            prop,\n            value: wscValue,\n          }\n        );\n        lastNode.value = minifyWsc(/** @type {any} */ (values));\n        wscProp.remove();\n\n        return true;\n      }\n      return false;\n    });\n  });\n\n  // optimize border-trbl\n  let decls = getDecls(rule, directions);\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n\n    wsc.forEach((d, i) => {\n      const names = directions\n        .filter((name) => name !== lastNode.prop)\n        .map((name) => `${name}-${d}`);\n\n      let nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));\n\n      const border = getLastNode(nodes, 'border');\n\n      if (border) {\n        nodes = nodes.slice(nodes.indexOf(border));\n      }\n\n      const props = nodes.filter(\n        (node) =>\n          node.type === 'decl' &&\n          names.includes(node.prop) &&\n          node.important === lastNode.important\n      );\n      const rules = getRules(\n        /** @type {import('postcss').Declaration[]} */ (props),\n        names\n      );\n\n      if (hasAllProps(rules, ...names) && !rules.some(stylehacks.detect)) {\n        const values = rules.map((node) => (node ? node.value : null));\n        const filteredValues = values.filter(Boolean);\n        const lastNodeValue = list.space(lastNode.value)[i];\n\n        values[directions.indexOf(lastNode.prop)] = lastNodeValue;\n\n        let value = minifyTrbl(values.join(' '));\n\n        if (\n          filteredValues[0] === filteredValues[1] &&\n          filteredValues[1] === filteredValues[2]\n        ) {\n          value = /** @type {string} */ (filteredValues[0]);\n        }\n\n        let refNode = props[props.length - 1];\n\n        if (value === lastNodeValue) {\n          refNode = lastNode;\n          let valueArray = list.space(lastNode.value);\n          valueArray.splice(i, 1);\n          lastNode.value = valueArray.join(' ');\n        }\n\n        insertCloned(\n          /** @type {import('postcss').Rule} */ (refNode.parent),\n          /** @type {import('postcss').Declaration} */ (refNode),\n          {\n            prop: borderProperty(d),\n            value,\n          }\n        );\n\n        decls = decls.filter((node) => !rules.includes(node));\n        for (const node of rules) {\n          node.remove();\n        }\n      }\n    });\n\n    decls = decls.filter((node) => node !== lastNode);\n  }\n\n  rule.walkDecls('border', (decl) => {\n    const nextDecl = decl.next();\n\n    if (!nextDecl || nextDecl.type !== 'decl') {\n      return false;\n    }\n\n    const index = directions.indexOf(nextDecl.prop);\n\n    if (index === -1) {\n      return;\n    }\n\n    const values = parseWsc(decl.value);\n    const nextValues = parseWsc(nextDecl.value);\n\n    if (!isValidWsc(values) || !isValidWsc(nextValues)) {\n      return;\n    }\n\n    const config = {\n      values,\n      nextValues,\n      decl,\n      nextDecl,\n      index,\n    };\n\n    return mergeRedundant(config);\n  });\n\n  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, (decl) => {\n    let values = parseWsc(decl.value);\n\n    if (!isValidWsc(values)) {\n      return;\n    }\n\n    const position = directions.indexOf(decl.prop);\n    let dirs = [...directions];\n\n    dirs.splice(position, 1);\n    wsc.forEach((d, i) => {\n      const props = dirs.map((dir) => `${dir}-${d}`);\n\n      mergeRules(rule, [decl.prop, ...props], (rules) => {\n        if (!rules.includes(decl)) {\n          return false;\n        }\n\n        const longhands = rules.filter((p) => p !== decl);\n\n        if (\n          longhands[0].value.toLowerCase() ===\n            longhands[1].value.toLowerCase() &&\n          longhands[1].value.toLowerCase() ===\n            longhands[2].value.toLowerCase() &&\n          values[i] !== undefined &&\n          longhands[0].value.toLowerCase() === values[i].toLowerCase()\n        ) {\n          for (const node of longhands) {\n            node.remove();\n          }\n\n          insertCloned(\n            /** @type {import('postcss').Rule} */ (decl.parent),\n            decl,\n            {\n              prop: borderProperty(d),\n              value: values[i],\n            }\n          );\n\n          /** @type {string|null} */ (values[i]) = null;\n        }\n        return false;\n      });\n\n      const newValue = values.join(' ');\n\n      if (newValue) {\n        decl.value = newValue;\n      } else {\n        decl.remove();\n      }\n    });\n  });\n\n  // clean-up values\n  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, (decl) => {\n    decl.value = minifyWsc(decl.value);\n  });\n\n  // border-spacing-hv -> border-spacing\n  rule.walkDecls(/^border-spacing$/i, (decl) => {\n    const value = list.space(decl.value);\n\n    // merge vertical and horizontal dups\n    if (value.length > 1 && value[0] === value[1]) {\n      decl.value = value.slice(1).join(' ');\n    }\n  });\n\n  // clean-up rules\n  decls = getDecls(rule, allProperties);\n\n  while (decls.length) {\n    const lastNode = decls[decls.length - 1];\n    const lastPart = lastNode.prop.split('-').pop();\n\n    // remove properties of lower precedence\n    const lesser = decls.filter(\n      (node) =>\n        !stylehacks.detect(lastNode) &&\n        !stylehacks.detect(node) &&\n        !isCustomProp(lastNode) &&\n        node !== lastNode &&\n        node.important === lastNode.important &&\n        /** @type {number} */ (getLevel(node.prop)) >\n          /** @type {number} */ (getLevel(lastNode.prop)) &&\n        (node.prop.toLowerCase().includes(lastNode.prop) ||\n          node.prop.toLowerCase().endsWith(/** @type {string} */ (lastPart)))\n    );\n\n    for (const node of lesser) {\n      node.remove();\n    }\n    decls = decls.filter((node) => !lesser.includes(node));\n\n    // get duplicate properties\n    let duplicates = decls.filter(\n      (node) =>\n        !stylehacks.detect(lastNode) &&\n        !stylehacks.detect(node) &&\n        node !== lastNode &&\n        node.important === lastNode.important &&\n        node.prop === lastNode.prop &&\n        !(!isCustomProp(node) && isCustomProp(lastNode))\n    );\n\n    if (duplicates.length) {\n      if (colorMightRequireFallback.test(getColorValue(lastNode))) {\n        const preserve = duplicates\n          .filter(\n            (node) => !colorMightRequireFallback.test(getColorValue(node))\n          )\n          .pop();\n\n        duplicates = duplicates.filter((node) => node !== preserve);\n      }\n      for (const node of duplicates) {\n        node.remove();\n      }\n    }\n\n    decls = decls.filter(\n      (node) => node !== lastNode && !duplicates.includes(node)\n    );\n  }\n}\n\nmodule.exports = {\n  explode,\n  merge,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}