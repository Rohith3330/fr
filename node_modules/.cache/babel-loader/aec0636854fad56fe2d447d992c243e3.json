{"ast":null,"code":"import util from \"util\";\nimport stringifyValidator from \"../utils/stringifyValidator.js\";\nimport toFunctionName from \"../utils/toFunctionName.js\";\nimport * as t from \"../../lib/index.js\";\nconst readme = [`---\nid: babel-types\ntitle: @babel/types\n---\n<!-- Do not modify! This file is automatically generated by\n  github.com/babel/babel/babel-types/scripts/generators/docs.js !-->\n\n> This module contains methods for building ASTs manually and for checking the types of AST nodes.\n\n## Install\n\n\\`\\`\\`sh\nnpm install --save-dev @babel/types\n\\`\\`\\`\n\n## API`];\nconst customTypes = {\n  ClassMethod: {\n    key: \"if computed then `Expression` else `Identifier | Literal`\"\n  },\n  Identifier: {\n    name: \"`string`\"\n  },\n  MemberExpression: {\n    property: \"if computed then `Expression` else `Identifier`\"\n  },\n  ObjectMethod: {\n    key: \"if computed then `Expression` else `Identifier | Literal`\"\n  },\n  ObjectProperty: {\n    key: \"if computed then `Expression` else `Identifier | Literal`\"\n  },\n  ClassPrivateMethod: {\n    computed: \"'false'\"\n  },\n  ClassPrivateProperty: {\n    computed: \"'false'\"\n  }\n};\nconst APIHistory = {\n  ClassProperty: [[\"v7.6.0\", \"Supports `static`\"]]\n};\n\nfunction formatHistory(historyItems) {\n  const lines = historyItems.map(item => \"| `\" + item[0] + \"` | \" + item[1] + \" |\");\n  return [\"<details>\", \"  <summary>History</summary>\", \"| Version | Changes |\", \"| --- | --- |\", ...lines, \"</details>\"];\n}\n\nfunction printAPIHistory(key, readme) {\n  if (APIHistory[key]) {\n    readme.push(\"\");\n    readme.push(...formatHistory(APIHistory[key]));\n  }\n}\n\nfunction printNodeFields(key, readme) {\n  if (Object.keys(t.NODE_FIELDS[key]).length > 0) {\n    readme.push(\"\");\n    readme.push(\"AST Node `\" + key + \"` shape:\");\n    Object.keys(t.NODE_FIELDS[key]).sort(function (fieldA, fieldB) {\n      const indexA = t.BUILDER_KEYS[key].indexOf(fieldA);\n      const indexB = t.BUILDER_KEYS[key].indexOf(fieldB);\n      if (indexA === indexB) return fieldA < fieldB ? -1 : 1;\n      if (indexA === -1) return 1;\n      if (indexB === -1) return -1;\n      return indexA - indexB;\n    }).forEach(function (field) {\n      const defaultValue = t.NODE_FIELDS[key][field].default;\n      const fieldDescription = [\"`\" + field + \"`\"];\n      const validator = t.NODE_FIELDS[key][field].validate;\n\n      if (customTypes[key] && customTypes[key][field]) {\n        fieldDescription.push(`: ${customTypes[key][field]}`);\n      } else if (validator) {\n        try {\n          fieldDescription.push(\": `\" + stringifyValidator(validator, \"\") + \"`\");\n        } catch (ex) {\n          if (ex.code === \"UNEXPECTED_VALIDATOR_TYPE\") {\n            console.log(\"Unrecognised validator type for \" + key + \".\" + field);\n            console.dir(ex.validator, {\n              depth: 10,\n              colors: true\n            });\n          }\n        }\n      }\n\n      if (defaultValue !== null || t.NODE_FIELDS[key][field].optional) {\n        fieldDescription.push(\" (default: `\" + util.inspect(defaultValue) + \"`\");\n\n        if (t.BUILDER_KEYS[key].indexOf(field) < 0) {\n          fieldDescription.push(\", excluded from builder function\");\n        }\n\n        fieldDescription.push(\")\");\n      } else {\n        fieldDescription.push(\" (required)\");\n      }\n\n      readme.push(\"- \" + fieldDescription.join(\"\"));\n    });\n  }\n}\n\nfunction printAliasKeys(key, readme) {\n  if (t.ALIAS_KEYS[key] && t.ALIAS_KEYS[key].length) {\n    readme.push(\"\");\n    readme.push(\"Aliases: \" + t.ALIAS_KEYS[key].map(function (key) {\n      return \"[`\" + key + \"`](#\" + key.toLowerCase() + \")\";\n    }).join(\", \"));\n  }\n}\n\nreadme.push(\"### Node Builders\");\nreadme.push(\"\");\nObject.keys(t.BUILDER_KEYS).sort().forEach(function (key) {\n  readme.push(\"#### \" + toFunctionName(key));\n  readme.push(\"\");\n  readme.push(\"```javascript\");\n  readme.push(\"t.\" + toFunctionName(key) + \"(\" + t.BUILDER_KEYS[key].join(\", \") + \");\");\n  readme.push(\"```\");\n  printAPIHistory(key, readme);\n  readme.push(\"\");\n  readme.push(\"See also `t.is\" + key + \"(node, opts)` and `t.assert\" + key + \"(node, opts)`.\");\n  printNodeFields(key, readme);\n  printAliasKeys(key, readme);\n  readme.push(\"\");\n  readme.push(\"---\");\n  readme.push(\"\");\n});\n\nfunction generateMapAliasToNodeTypes() {\n  const result = new Map();\n\n  for (const nodeType of Object.keys(t.ALIAS_KEYS)) {\n    const aliases = t.ALIAS_KEYS[nodeType];\n    if (!aliases) continue;\n\n    for (const alias of aliases) {\n      if (!result.has(alias)) {\n        result.set(alias, []);\n      }\n\n      const nodeTypes = result.get(alias);\n      nodeTypes.push(nodeType);\n    }\n  }\n\n  return result;\n}\n\nconst aliasDescriptions = {\n  Accessor: \"Deprecated. Will be removed in Babel 8.\",\n  Binary: \"A cover of BinaryExpression and LogicalExpression, which share the same AST shape.\",\n  Block: \"Deprecated. Will be removed in Babel 8.\",\n  BlockParent: \"A cover of AST nodes that start an execution context with new [LexicalEnvironment](https://tc39.es/ecma262/#table-additional-state-components-for-ecmascript-code-execution-contexts). In other words, they define the scope of `let` and `const` declarations.\",\n  Class: \"A cover of ClassExpression and ClassDeclaration, which share the same AST shape.\",\n  CompletionStatement: \"A statement that indicates the [completion records](https://tc39.es/ecma262/#sec-completion-record-specification-type). In other words, they define the control flow of the program, such as when should a loop break or an action throws critical errors.\",\n  Conditional: \"A cover of ConditionalExpression and IfStatement, which share the same AST shape.\",\n  Declaration: \"A cover of any [Declaration](https://tc39.es/ecma262/#prod-Declaration)s.\",\n  EnumBody: \"A cover of Flow enum bodies.\",\n  EnumMember: \"A cover of Flow enum membors.\",\n  ExportDeclaration: \"A cover of any [ExportDeclaration](https://tc39.es/ecma262/#prod-ExportDeclaration)s.\",\n  Expression: \"A cover of any [Expression](https://tc39.es/ecma262/#sec-ecmascript-language-expressions)s.\",\n  ExpressionWrapper: \"A wrapper of expression that does not have runtime semantics.\",\n  Flow: \"A cover of AST nodes defined for Flow.\",\n  FlowBaseAnnotation: \"A cover of primary Flow type annotations.\",\n  FlowDeclaration: \"A cover of Flow declarations.\",\n  FlowPredicate: \"A cover of Flow predicates.\",\n  FlowType: \"A cover of Flow type annotations.\",\n  For: \"A cover of [ForStatement](https://tc39.es/ecma262/#sec-for-statement)s and [ForXStatement](#forxstatement)s.\",\n  ForXStatement: \"A cover of [ForInStatements and ForOfStatements](https://tc39.es/ecma262/#sec-for-in-and-for-of-statements).\",\n  Function: \"A cover of functions and [method](#method)s, the must have `body` and `params`. Note: `Function` is different to `FunctionParent`. For example, a `StaticBlock` is a `FunctionParent` but not `Function`.\",\n  FunctionParent: \"A cover of AST nodes that start an execution context with new [VariableEnvironment](https://tc39.es/ecma262/#table-additional-state-components-for-ecmascript-code-execution-contexts). In other words, they define the scope of `var` declarations. FunctionParent did not include `Program` since Babel 7.\",\n  Immutable: \"A cover of immutable objects and JSX elements. An object is [immutable](https://tc39.es/ecma262/#immutable-prototype-exotic-object) if no other properties can be defined once created.\",\n  JSX: \"A cover of AST nodes defined for [JSX](https://facebook.github.io/jsx/).\",\n  LVal: \"A cover of left hand side expressions used in the `left` of assignment expressions and [ForXStatement](#forxstatement)s. \",\n  Literal: \"A cover of [Literal](https://tc39.es/ecma262/#sec-primary-expression-literals)s, [Regular Expression Literal](https://tc39.es/ecma262/#sec-primary-expression-regular-expression-literals)s and [Template Literal](https://tc39.es/ecma262/#sec-template-literals)s.\",\n  Loop: \"A cover of loop statements.\",\n  Method: \"A cover of object methods and class methods.\",\n  Miscellaneous: \"A cover of non-standard AST types that are sometimes useful for development.\",\n  ModuleDeclaration: \"A cover of ImportDeclaration and [ExportDeclaration](#exportdeclaration)\",\n  ModuleSpecifier: \"A cover of import and export specifiers. Note: It is _not_ the [ModuleSpecifier](https://tc39.es/ecma262/#prod-ModuleSpecifier) defined in the spec.\",\n  ObjectMember: \"A cover of [members](https://tc39.es/ecma262/#prod-PropertyDefinitionList) in an object literal.\",\n  Pattern: \"A cover of [BindingPattern](https://tc39.es/ecma262/#prod-BindingPattern) except Identifiers.\",\n  PatternLike: \"A cover of [BindingPattern](https://tc39.es/ecma262/#prod-BindingPattern)s. \",\n  Private: \"A cover of private class elements and private identifiers.\",\n  Property: \"A cover of object properties and class properties.\",\n  Pureish: \"A cover of AST nodes which do not have side-effects. In other words, there is no observable behaviour changes if they are evaluated more than once.\",\n  Scopable: \"A cover of [FunctionParent](#functionparent) and [BlockParent](#blockparent).\",\n  Standardized: \"A cover of AST nodes which are part of an official ECMAScript specification.\",\n  Statement: \"A cover of any [Statement](https://tc39.es/ecma262/#prod-Statement)s.\",\n  TSBaseType: \"A cover of primary TypeScript type annotations.\",\n  TSEntityName: \"A cover of ts entities.\",\n  TSType: \"A cover of TypeScript type annotations.\",\n  TSTypeElement: \"A cover of TypeScript type declarations.\",\n  TypeScript: \"A cover of AST nodes defined for TypeScript.\",\n  Terminatorless: \"A cover of AST nodes whose semantic will change when a line terminator is inserted between the operator and the operand.\",\n  UnaryLike: \"A cover of UnaryExpression and SpreadElement.\",\n  UserWhitespacable: \"Deprecated. Will be removed in Babel 8.\",\n  While: \"A cover of DoWhileStatement and WhileStatement, which share the same AST shape.\"\n};\nconst mapAliasToNodeTypes = generateMapAliasToNodeTypes();\nreadme.push(\"### Aliases\");\nreadme.push(\"\");\n\nfor (const alias of [...mapAliasToNodeTypes.keys()].sort()) {\n  const nodeTypes = mapAliasToNodeTypes.get(alias);\n  nodeTypes.sort();\n\n  if (!(alias in aliasDescriptions)) {\n    throw new Error('Missing alias descriptions of \"' + alias + \", which covers \" + nodeTypes.join(\",\"));\n  }\n\n  readme.push(\"#### \" + alias);\n  readme.push(\"\");\n  readme.push(aliasDescriptions[alias]);\n  readme.push(\"```javascript\");\n  readme.push(\"t.is\" + alias + \"(node);\");\n  readme.push(\"```\");\n  readme.push(\"\");\n  readme.push(\"Covered nodes: \");\n\n  for (const nodeType of nodeTypes) {\n    readme.push(\"- [`\" + nodeType + \"`](#\" + nodeType.toLowerCase() + \")\");\n  }\n\n  readme.push(\"\");\n}\n\nprocess.stdout.write(readme.join(\"\\n\"));","map":{"version":3,"names":["util","stringifyValidator","toFunctionName","t","readme","customTypes","ClassMethod","key","Identifier","name","MemberExpression","property","ObjectMethod","ObjectProperty","ClassPrivateMethod","computed","ClassPrivateProperty","APIHistory","ClassProperty","formatHistory","historyItems","lines","map","item","printAPIHistory","push","printNodeFields","Object","keys","NODE_FIELDS","length","sort","fieldA","fieldB","indexA","BUILDER_KEYS","indexOf","indexB","forEach","field","defaultValue","default","fieldDescription","validator","validate","ex","code","console","log","dir","depth","colors","optional","inspect","join","printAliasKeys","ALIAS_KEYS","toLowerCase","generateMapAliasToNodeTypes","result","Map","nodeType","aliases","alias","has","set","nodeTypes","get","aliasDescriptions","Accessor","Binary","Block","BlockParent","Class","CompletionStatement","Conditional","Declaration","EnumBody","EnumMember","ExportDeclaration","Expression","ExpressionWrapper","Flow","FlowBaseAnnotation","FlowDeclaration","FlowPredicate","FlowType","For","ForXStatement","Function","FunctionParent","Immutable","JSX","LVal","Literal","Loop","Method","Miscellaneous","ModuleDeclaration","ModuleSpecifier","ObjectMember","Pattern","PatternLike","Private","Property","Pureish","Scopable","Standardized","Statement","TSBaseType","TSEntityName","TSType","TSTypeElement","TypeScript","Terminatorless","UnaryLike","UserWhitespacable","While","mapAliasToNodeTypes","Error","process","stdout","write"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/types/scripts/generators/docs.js"],"sourcesContent":["import util from \"util\";\nimport stringifyValidator from \"../utils/stringifyValidator.js\";\nimport toFunctionName from \"../utils/toFunctionName.js\";\n\nimport * as t from \"../../lib/index.js\";\n\nconst readme = [\n  `---\nid: babel-types\ntitle: @babel/types\n---\n<!-- Do not modify! This file is automatically generated by\n  github.com/babel/babel/babel-types/scripts/generators/docs.js !-->\n\n> This module contains methods for building ASTs manually and for checking the types of AST nodes.\n\n## Install\n\n\\`\\`\\`sh\nnpm install --save-dev @babel/types\n\\`\\`\\`\n\n## API`,\n];\n\nconst customTypes = {\n  ClassMethod: {\n    key: \"if computed then `Expression` else `Identifier | Literal`\",\n  },\n  Identifier: {\n    name: \"`string`\",\n  },\n  MemberExpression: {\n    property: \"if computed then `Expression` else `Identifier`\",\n  },\n  ObjectMethod: {\n    key: \"if computed then `Expression` else `Identifier | Literal`\",\n  },\n  ObjectProperty: {\n    key: \"if computed then `Expression` else `Identifier | Literal`\",\n  },\n  ClassPrivateMethod: {\n    computed: \"'false'\",\n  },\n  ClassPrivateProperty: {\n    computed: \"'false'\",\n  },\n};\nconst APIHistory = {\n  ClassProperty: [[\"v7.6.0\", \"Supports `static`\"]],\n};\nfunction formatHistory(historyItems) {\n  const lines = historyItems.map(\n    item => \"| `\" + item[0] + \"` | \" + item[1] + \" |\"\n  );\n  return [\n    \"<details>\",\n    \"  <summary>History</summary>\",\n    \"| Version | Changes |\",\n    \"| --- | --- |\",\n    ...lines,\n    \"</details>\",\n  ];\n}\nfunction printAPIHistory(key, readme) {\n  if (APIHistory[key]) {\n    readme.push(\"\");\n    readme.push(...formatHistory(APIHistory[key]));\n  }\n}\nfunction printNodeFields(key, readme) {\n  if (Object.keys(t.NODE_FIELDS[key]).length > 0) {\n    readme.push(\"\");\n    readme.push(\"AST Node `\" + key + \"` shape:\");\n    Object.keys(t.NODE_FIELDS[key])\n      .sort(function (fieldA, fieldB) {\n        const indexA = t.BUILDER_KEYS[key].indexOf(fieldA);\n        const indexB = t.BUILDER_KEYS[key].indexOf(fieldB);\n        if (indexA === indexB) return fieldA < fieldB ? -1 : 1;\n        if (indexA === -1) return 1;\n        if (indexB === -1) return -1;\n        return indexA - indexB;\n      })\n      .forEach(function (field) {\n        const defaultValue = t.NODE_FIELDS[key][field].default;\n        const fieldDescription = [\"`\" + field + \"`\"];\n        const validator = t.NODE_FIELDS[key][field].validate;\n        if (customTypes[key] && customTypes[key][field]) {\n          fieldDescription.push(`: ${customTypes[key][field]}`);\n        } else if (validator) {\n          try {\n            fieldDescription.push(\n              \": `\" + stringifyValidator(validator, \"\") + \"`\"\n            );\n          } catch (ex) {\n            if (ex.code === \"UNEXPECTED_VALIDATOR_TYPE\") {\n              console.log(\n                \"Unrecognised validator type for \" + key + \".\" + field\n              );\n              console.dir(ex.validator, { depth: 10, colors: true });\n            }\n          }\n        }\n        if (defaultValue !== null || t.NODE_FIELDS[key][field].optional) {\n          fieldDescription.push(\n            \" (default: `\" + util.inspect(defaultValue) + \"`\"\n          );\n          if (t.BUILDER_KEYS[key].indexOf(field) < 0) {\n            fieldDescription.push(\", excluded from builder function\");\n          }\n          fieldDescription.push(\")\");\n        } else {\n          fieldDescription.push(\" (required)\");\n        }\n        readme.push(\"- \" + fieldDescription.join(\"\"));\n      });\n  }\n}\n\nfunction printAliasKeys(key, readme) {\n  if (t.ALIAS_KEYS[key] && t.ALIAS_KEYS[key].length) {\n    readme.push(\"\");\n    readme.push(\n      \"Aliases: \" +\n        t.ALIAS_KEYS[key]\n          .map(function (key) {\n            return \"[`\" + key + \"`](#\" + key.toLowerCase() + \")\";\n          })\n          .join(\", \")\n    );\n  }\n}\nreadme.push(\"### Node Builders\");\nreadme.push(\"\");\nObject.keys(t.BUILDER_KEYS)\n  .sort()\n  .forEach(function (key) {\n    readme.push(\"#### \" + toFunctionName(key));\n    readme.push(\"\");\n    readme.push(\"```javascript\");\n    readme.push(\n      \"t.\" + toFunctionName(key) + \"(\" + t.BUILDER_KEYS[key].join(\", \") + \");\"\n    );\n    readme.push(\"```\");\n    printAPIHistory(key, readme);\n    readme.push(\"\");\n    readme.push(\n      \"See also `t.is\" +\n        key +\n        \"(node, opts)` and `t.assert\" +\n        key +\n        \"(node, opts)`.\"\n    );\n\n    printNodeFields(key, readme);\n    printAliasKeys(key, readme);\n\n    readme.push(\"\");\n    readme.push(\"---\");\n    readme.push(\"\");\n  });\n\nfunction generateMapAliasToNodeTypes() {\n  const result = new Map();\n  for (const nodeType of Object.keys(t.ALIAS_KEYS)) {\n    const aliases = t.ALIAS_KEYS[nodeType];\n    if (!aliases) continue;\n    for (const alias of aliases) {\n      if (!result.has(alias)) {\n        result.set(alias, []);\n      }\n      const nodeTypes = result.get(alias);\n      nodeTypes.push(nodeType);\n    }\n  }\n  return result;\n}\nconst aliasDescriptions = {\n  Accessor: \"Deprecated. Will be removed in Babel 8.\",\n  Binary:\n    \"A cover of BinaryExpression and LogicalExpression, which share the same AST shape.\",\n  Block: \"Deprecated. Will be removed in Babel 8.\",\n  BlockParent:\n    \"A cover of AST nodes that start an execution context with new [LexicalEnvironment](https://tc39.es/ecma262/#table-additional-state-components-for-ecmascript-code-execution-contexts). In other words, they define the scope of `let` and `const` declarations.\",\n  Class:\n    \"A cover of ClassExpression and ClassDeclaration, which share the same AST shape.\",\n  CompletionStatement:\n    \"A statement that indicates the [completion records](https://tc39.es/ecma262/#sec-completion-record-specification-type). In other words, they define the control flow of the program, such as when should a loop break or an action throws critical errors.\",\n  Conditional:\n    \"A cover of ConditionalExpression and IfStatement, which share the same AST shape.\",\n  Declaration:\n    \"A cover of any [Declaration](https://tc39.es/ecma262/#prod-Declaration)s.\",\n  EnumBody: \"A cover of Flow enum bodies.\",\n  EnumMember: \"A cover of Flow enum membors.\",\n  ExportDeclaration:\n    \"A cover of any [ExportDeclaration](https://tc39.es/ecma262/#prod-ExportDeclaration)s.\",\n  Expression:\n    \"A cover of any [Expression](https://tc39.es/ecma262/#sec-ecmascript-language-expressions)s.\",\n  ExpressionWrapper:\n    \"A wrapper of expression that does not have runtime semantics.\",\n  Flow: \"A cover of AST nodes defined for Flow.\",\n  FlowBaseAnnotation: \"A cover of primary Flow type annotations.\",\n  FlowDeclaration: \"A cover of Flow declarations.\",\n  FlowPredicate: \"A cover of Flow predicates.\",\n  FlowType: \"A cover of Flow type annotations.\",\n  For: \"A cover of [ForStatement](https://tc39.es/ecma262/#sec-for-statement)s and [ForXStatement](#forxstatement)s.\",\n  ForXStatement:\n    \"A cover of [ForInStatements and ForOfStatements](https://tc39.es/ecma262/#sec-for-in-and-for-of-statements).\",\n  Function:\n    \"A cover of functions and [method](#method)s, the must have `body` and `params`. Note: `Function` is different to `FunctionParent`. For example, a `StaticBlock` is a `FunctionParent` but not `Function`.\",\n  FunctionParent:\n    \"A cover of AST nodes that start an execution context with new [VariableEnvironment](https://tc39.es/ecma262/#table-additional-state-components-for-ecmascript-code-execution-contexts). In other words, they define the scope of `var` declarations. FunctionParent did not include `Program` since Babel 7.\",\n  Immutable:\n    \"A cover of immutable objects and JSX elements. An object is [immutable](https://tc39.es/ecma262/#immutable-prototype-exotic-object) if no other properties can be defined once created.\",\n  JSX: \"A cover of AST nodes defined for [JSX](https://facebook.github.io/jsx/).\",\n  LVal: \"A cover of left hand side expressions used in the `left` of assignment expressions and [ForXStatement](#forxstatement)s. \",\n  Literal:\n    \"A cover of [Literal](https://tc39.es/ecma262/#sec-primary-expression-literals)s, [Regular Expression Literal](https://tc39.es/ecma262/#sec-primary-expression-regular-expression-literals)s and [Template Literal](https://tc39.es/ecma262/#sec-template-literals)s.\",\n  Loop: \"A cover of loop statements.\",\n  Method: \"A cover of object methods and class methods.\",\n  Miscellaneous:\n    \"A cover of non-standard AST types that are sometimes useful for development.\",\n  ModuleDeclaration:\n    \"A cover of ImportDeclaration and [ExportDeclaration](#exportdeclaration)\",\n  ModuleSpecifier:\n    \"A cover of import and export specifiers. Note: It is _not_ the [ModuleSpecifier](https://tc39.es/ecma262/#prod-ModuleSpecifier) defined in the spec.\",\n  ObjectMember:\n    \"A cover of [members](https://tc39.es/ecma262/#prod-PropertyDefinitionList) in an object literal.\",\n  Pattern:\n    \"A cover of [BindingPattern](https://tc39.es/ecma262/#prod-BindingPattern) except Identifiers.\",\n  PatternLike:\n    \"A cover of [BindingPattern](https://tc39.es/ecma262/#prod-BindingPattern)s. \",\n  Private: \"A cover of private class elements and private identifiers.\",\n  Property: \"A cover of object properties and class properties.\",\n  Pureish:\n    \"A cover of AST nodes which do not have side-effects. In other words, there is no observable behaviour changes if they are evaluated more than once.\",\n  Scopable:\n    \"A cover of [FunctionParent](#functionparent) and [BlockParent](#blockparent).\",\n  Standardized:\n    \"A cover of AST nodes which are part of an official ECMAScript specification.\",\n  Statement:\n    \"A cover of any [Statement](https://tc39.es/ecma262/#prod-Statement)s.\",\n  TSBaseType: \"A cover of primary TypeScript type annotations.\",\n  TSEntityName: \"A cover of ts entities.\",\n  TSType: \"A cover of TypeScript type annotations.\",\n  TSTypeElement: \"A cover of TypeScript type declarations.\",\n  TypeScript: \"A cover of AST nodes defined for TypeScript.\",\n  Terminatorless:\n    \"A cover of AST nodes whose semantic will change when a line terminator is inserted between the operator and the operand.\",\n  UnaryLike: \"A cover of UnaryExpression and SpreadElement.\",\n  UserWhitespacable: \"Deprecated. Will be removed in Babel 8.\",\n  While:\n    \"A cover of DoWhileStatement and WhileStatement, which share the same AST shape.\",\n};\nconst mapAliasToNodeTypes = generateMapAliasToNodeTypes();\nreadme.push(\"### Aliases\");\nreadme.push(\"\");\nfor (const alias of [...mapAliasToNodeTypes.keys()].sort()) {\n  const nodeTypes = mapAliasToNodeTypes.get(alias);\n  nodeTypes.sort();\n  if (!(alias in aliasDescriptions)) {\n    throw new Error(\n      'Missing alias descriptions of \"' +\n        alias +\n        \", which covers \" +\n        nodeTypes.join(\",\")\n    );\n  }\n  readme.push(\"#### \" + alias);\n  readme.push(\"\");\n  readme.push(aliasDescriptions[alias]);\n  readme.push(\"```javascript\");\n  readme.push(\"t.is\" + alias + \"(node);\");\n  readme.push(\"```\");\n  readme.push(\"\");\n  readme.push(\"Covered nodes: \");\n  for (const nodeType of nodeTypes) {\n    readme.push(\"- [`\" + nodeType + \"`](#\" + nodeType.toLowerCase() + \")\");\n  }\n  readme.push(\"\");\n}\n\nprocess.stdout.write(readme.join(\"\\n\"));\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}