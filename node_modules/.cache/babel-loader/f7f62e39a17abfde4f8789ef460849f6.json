{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\n\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-magic-numbers'); // Extend base schema with additional property to ignore TS numeric literal types\n\nconst schema = util.deepMerge( // eslint-disable-next-line @typescript-eslint/no-unsafe-argument -- https://github.com/microsoft/TypeScript/issues/17002\nArray.isArray(baseRule.meta.schema) ? baseRule.meta.schema[0] : baseRule.meta.schema, {\n  properties: {\n    ignoreNumericLiteralTypes: {\n      type: 'boolean'\n    },\n    ignoreEnums: {\n      type: 'boolean'\n    },\n    ignoreReadonlyClassProperties: {\n      type: 'boolean'\n    },\n    ignoreTypeIndexes: {\n      type: 'boolean'\n    }\n  }\n});\nexports.default = util.createRule({\n  name: 'no-magic-numbers',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow magic numbers',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    schema: [schema],\n    messages: baseRule.meta.messages\n  },\n  defaultOptions: [{\n    ignore: [],\n    ignoreArrayIndexes: false,\n    enforceConst: false,\n    detectObjects: false,\n    ignoreNumericLiteralTypes: false,\n    ignoreEnums: false,\n    ignoreReadonlyClassProperties: false\n  }],\n\n  create(context, _ref) {\n    let [options] = _ref;\n    const rules = baseRule.create(context);\n    return {\n      Literal(node) {\n        var _a; // If it’s not a numeric literal we’re not interested\n\n\n        if (typeof node.value !== 'number' && typeof node.value !== 'bigint') {\n          return;\n        } // This will be `true` if we’re configured to ignore this case (eg. it’s\n        // an enum and `ignoreEnums` is `true`). It will be `false` if we’re not\n        // configured to ignore this case. It will remain `undefined` if this is\n        // not one of our exception cases, and we’ll fall back to the base rule.\n\n\n        let isAllowed; // Check if the node is a TypeScript enum declaration\n\n        if (isParentTSEnumDeclaration(node)) {\n          isAllowed = options.ignoreEnums === true;\n        } // Check TypeScript specific nodes for Numeric Literal\n        else if (isTSNumericLiteralType(node)) {\n          isAllowed = options.ignoreNumericLiteralTypes === true;\n        } // Check if the node is a type index\n        else if (isAncestorTSIndexedAccessType(node)) {\n          isAllowed = options.ignoreTypeIndexes === true;\n        } // Check if the node is a readonly class property\n        else if (isParentTSReadonlyPropertyDefinition(node)) {\n          isAllowed = options.ignoreReadonlyClassProperties === true;\n        } // If we’ve hit a case where the ignore option is true we can return now\n\n\n        if (isAllowed === true) {\n          return;\n        } // If the ignore option is *not* set we can report it now\n        else if (isAllowed === false) {\n          let fullNumberNode = node;\n          let raw = node.raw;\n\n          if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.UnaryExpression && // the base rule only shows the operator for negative numbers\n          // https://github.com/eslint/eslint/blob/9dfc8501fb1956c90dc11e6377b4cb38a6bea65d/lib/rules/no-magic-numbers.js#L126\n          node.parent.operator === '-') {\n            fullNumberNode = node.parent;\n            raw = `${node.parent.operator}${node.raw}`;\n          }\n\n          context.report({\n            messageId: 'noMagic',\n            node: fullNumberNode,\n            data: {\n              raw\n            }\n          });\n          return;\n        } // Let the base rule deal with the rest\n\n\n        rules.Literal(node);\n      }\n\n    };\n  }\n\n});\n/**\n * Gets the true parent of the literal, handling prefixed numbers (-1 / +1)\n */\n\nfunction getLiteralParent(node) {\n  var _a;\n\n  if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.UnaryExpression && ['-', '+'].includes(node.parent.operator)) {\n    return node.parent.parent;\n  }\n\n  return node.parent;\n}\n/**\n * Checks if the node grandparent is a Typescript type alias declaration\n * @param node the node to be validated.\n * @returns true if the node grandparent is a Typescript type alias declaration\n * @private\n */\n\n\nfunction isGrandparentTSTypeAliasDeclaration(node) {\n  var _a, _b;\n\n  return ((_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration;\n}\n/**\n * Checks if the node grandparent is a Typescript union type and its parent is a type alias declaration\n * @param node the node to be validated.\n * @returns true if the node grandparent is a Typescript union type and its parent is a type alias declaration\n * @private\n */\n\n\nfunction isGrandparentTSUnionType(node) {\n  var _a, _b;\n\n  if (((_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.TSUnionType) {\n    return isGrandparentTSTypeAliasDeclaration(node.parent);\n  }\n\n  return false;\n}\n/**\n * Checks if the node parent is a Typescript enum member\n * @param node the node to be validated.\n * @returns true if the node parent is a Typescript enum member\n * @private\n */\n\n\nfunction isParentTSEnumDeclaration(node) {\n  const parent = getLiteralParent(node);\n  return (parent === null || parent === void 0 ? void 0 : parent.type) === utils_1.AST_NODE_TYPES.TSEnumMember;\n}\n/**\n * Checks if the node parent is a Typescript literal type\n * @param node the node to be validated.\n * @returns true if the node parent is a Typescript literal type\n * @private\n */\n\n\nfunction isParentTSLiteralType(node) {\n  var _a;\n\n  return ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.TSLiteralType;\n}\n/**\n * Checks if the node is a valid TypeScript numeric literal type.\n * @param node the node to be validated.\n * @returns true if the node is a TypeScript numeric literal type.\n * @private\n */\n\n\nfunction isTSNumericLiteralType(node) {\n  var _a; // For negative numbers, use the parent node\n\n\n  if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.UnaryExpression && node.parent.operator === '-') {\n    node = node.parent;\n  } // If the parent node is not a TSLiteralType, early return\n\n\n  if (!isParentTSLiteralType(node)) {\n    return false;\n  } // If the grandparent is a TSTypeAliasDeclaration, ignore\n\n\n  if (isGrandparentTSTypeAliasDeclaration(node)) {\n    return true;\n  } // If the grandparent is a TSUnionType and it's parent is a TSTypeAliasDeclaration, ignore\n\n\n  if (isGrandparentTSUnionType(node)) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Checks if the node parent is a readonly class property\n * @param node the node to be validated.\n * @returns true if the node parent is a readonly class property\n * @private\n */\n\n\nfunction isParentTSReadonlyPropertyDefinition(node) {\n  const parent = getLiteralParent(node);\n\n  if ((parent === null || parent === void 0 ? void 0 : parent.type) === utils_1.AST_NODE_TYPES.PropertyDefinition && parent.readonly) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Checks if the node is part of a type indexed access (eg. Foo[4])\n * @param node the node to be validated.\n * @returns true if the node is part of an indexed access\n * @private\n */\n\n\nfunction isAncestorTSIndexedAccessType(node) {\n  var _a, _b, _c; // Handle unary expressions (eg. -4)\n\n\n  let ancestor = getLiteralParent(node); // Go up another level while we’re part of a type union (eg. 1 | 2) or\n  // intersection (eg. 1 & 2)\n\n  while (((_a = ancestor === null || ancestor === void 0 ? void 0 : ancestor.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.TSUnionType || ((_b = ancestor === null || ancestor === void 0 ? void 0 : ancestor.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.TSIntersectionType) {\n    ancestor = ancestor.parent;\n  }\n\n  return ((_c = ancestor === null || ancestor === void 0 ? void 0 : ancestor.parent) === null || _c === void 0 ? void 0 : _c.type) === utils_1.AST_NODE_TYPES.TSIndexedAccessType;\n}","map":{"version":3,"mappings":"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","names":["baseRule","schema","util","deepMerge","Array","isArray","meta","properties","ignoreNumericLiteralTypes","type","ignoreEnums","ignoreReadonlyClassProperties","ignoreTypeIndexes","exports","createRule","name","docs","description","recommended","extendsBaseRule","messages","defaultOptions","ignore","ignoreArrayIndexes","enforceConst","detectObjects","create","context","options","rules","Literal","node","value","isAllowed","isParentTSEnumDeclaration","isTSNumericLiteralType","isAncestorTSIndexedAccessType","isParentTSReadonlyPropertyDefinition","fullNumberNode","raw","parent","_a","utils_1","UnaryExpression","operator","report","messageId","data","getLiteralParent","includes","isGrandparentTSTypeAliasDeclaration","_b","TSTypeAliasDeclaration","isGrandparentTSUnionType","TSUnionType","TSEnumMember","isParentTSLiteralType","TSLiteralType","PropertyDefinition","readonly","ancestor","TSIntersectionType","_c","TSIndexedAccessType"],"sources":["../../src/rules/no-magic-numbers.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}