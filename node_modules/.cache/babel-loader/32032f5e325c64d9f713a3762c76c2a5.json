{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateProperties = exports.error = void 0;\n\nconst code_1 = require(\"../code\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst nullable_1 = require(\"./nullable\");\n\nconst error_1 = require(\"./error\");\n\nvar PropError;\n\n(function (PropError) {\n  PropError[\"Additional\"] = \"additional\";\n  PropError[\"Missing\"] = \"missing\";\n})(PropError || (PropError = {}));\n\nexports.error = {\n  message: cxt => {\n    const {\n      params\n    } = cxt;\n    return params.propError ? params.propError === PropError.Additional ? \"must NOT have additional properties\" : `must have property '${params.missingProperty}'` : (0, error_1.typeErrorMessage)(cxt, \"object\");\n  },\n  params: cxt => {\n    const {\n      params\n    } = cxt;\n    return params.propError ? params.propError === PropError.Additional ? (0, codegen_1._)`{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}` : (0, codegen_1._)`{error: ${params.propError}, missingProperty: ${params.missingProperty}}` : (0, error_1.typeErrorParams)(cxt, \"object\");\n  }\n};\nconst def = {\n  keyword: \"properties\",\n  schemaType: \"object\",\n  error: exports.error,\n  code: validateProperties\n}; // const error: KeywordErrorDefinition = {\n//   message: \"should NOT have additional properties\",\n//   params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n// }\n\nfunction validateProperties(cxt) {\n  (0, metadata_1.checkMetadata)(cxt);\n  const {\n    gen,\n    data,\n    parentSchema,\n    it\n  } = cxt;\n  const {\n    additionalProperties,\n    nullable\n  } = parentSchema;\n  if (it.jtdDiscriminator && nullable) throw new Error(\"JTD: nullable inside discriminator mapping\");\n\n  if (commonProperties()) {\n    throw new Error(\"JTD: properties and optionalProperties have common members\");\n  }\n\n  const [allProps, properties] = schemaProperties(\"properties\");\n  const [allOptProps, optProperties] = schemaProperties(\"optionalProperties\");\n\n  if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {\n    return;\n  }\n\n  const [valid, cond] = it.jtdDiscriminator === undefined ? (0, nullable_1.checkNullableObject)(cxt, data) : [gen.let(\"valid\", false), true];\n  gen.if(cond, () => gen.assign(valid, true).block(() => {\n    validateProps(properties, \"properties\", true);\n    validateProps(optProperties, \"optionalProperties\");\n    if (!additionalProperties) validateAdditional();\n  }));\n  cxt.pass(valid);\n\n  function commonProperties() {\n    const props = parentSchema.properties;\n    const optProps = parentSchema.optionalProperties;\n    if (!(props && optProps)) return false;\n\n    for (const p in props) {\n      if (Object.prototype.hasOwnProperty.call(optProps, p)) return true;\n    }\n\n    return false;\n  }\n\n  function schemaProperties(keyword) {\n    const schema = parentSchema[keyword];\n    const allPs = schema ? (0, code_1.allSchemaProperties)(schema) : [];\n\n    if (it.jtdDiscriminator && allPs.some(p => p === it.jtdDiscriminator)) {\n      throw new Error(`JTD: discriminator tag used in ${keyword}`);\n    }\n\n    const ps = allPs.filter(p => !(0, util_1.alwaysValidSchema)(it, schema[p]));\n    return [allPs, ps];\n  }\n\n  function validateProps(props, keyword, required) {\n    const _valid = gen.var(\"valid\");\n\n    for (const prop of props) {\n      gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties), () => applyPropertySchema(prop, keyword, _valid), () => missingProperty(prop));\n      cxt.ok(_valid);\n    }\n\n    function missingProperty(prop) {\n      if (required) {\n        gen.assign(_valid, false);\n        cxt.error(false, {\n          propError: PropError.Missing,\n          missingProperty: prop\n        }, {\n          schemaPath: prop\n        });\n      } else {\n        gen.assign(_valid, true);\n      }\n    }\n  }\n\n  function applyPropertySchema(prop, keyword, _valid) {\n    cxt.subschema({\n      keyword,\n      schemaProp: prop,\n      dataProp: prop\n    }, _valid);\n  }\n\n  function validateAdditional() {\n    gen.forIn(\"key\", data, key => {\n      const _allProps = it.jtdDiscriminator === undefined ? allProps : [it.jtdDiscriminator].concat(allProps);\n\n      const addProp = isAdditional(key, _allProps, \"properties\");\n      const addOptProp = isAdditional(key, allOptProps, \"optionalProperties\");\n      const extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_1.and)(addProp, addOptProp);\n      gen.if(extra, () => {\n        if (it.opts.removeAdditional) {\n          gen.code((0, codegen_1._)`delete ${data}[${key}]`);\n        } else {\n          cxt.error(false, {\n            propError: PropError.Additional,\n            additionalProperty: key\n          }, {\n            instancePath: key,\n            parentSchema: true\n          });\n          if (!it.opts.allErrors) gen.break();\n        }\n      });\n    });\n  }\n\n  function isAdditional(key, props, keyword) {\n    let additional;\n\n    if (props.length > 8) {\n      // TODO maybe an option instead of hard-coded 8?\n      const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema[keyword], keyword);\n      additional = (0, codegen_1.not)((0, code_1.isOwnProperty)(gen, propsSchema, key));\n    } else if (props.length) {\n      additional = (0, codegen_1.and)(...props.map(p => (0, codegen_1._)`${key} !== ${p}`));\n    } else {\n      additional = true;\n    }\n\n    return additional;\n  }\n}\n\nexports.validateProperties = validateProperties;\nexports.default = def;","map":{"version":3,"mappings":"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","names":["PropError","exports","message","cxt","params","propError","Additional","missingProperty","additionalProperty","def","keyword","schemaType","error","code","validateProperties","gen","data","parentSchema","it","additionalProperties","nullable","jtdDiscriminator","Error","commonProperties","allProps","properties","schemaProperties","allOptProps","optProperties","length","valid","cond","undefined","let","if","assign","block","validateProps","validateAdditional","pass","props","optProps","optionalProperties","p","Object","prototype","hasOwnProperty","call","schema","allPs","some","ps","filter","required","_valid","var","prop","opts","ownProperties","applyPropertySchema","ok","Missing","schemaPath","subschema","schemaProp","dataProp","forIn","key","_allProps","concat","addProp","isAdditional","addOptProp","extra","removeAdditional","instancePath","allErrors","break","additional","propsSchema","map"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\css-minimizer-webpack-plugin\\node_modules\\ajv\\lib\\vocabularies\\jtd\\properties.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties, isOwnProperty} from \"../code\"\nimport {alwaysValidSchema, schemaRefOrVal} from \"../../compile/util\"\nimport {_, and, not, Code, Name} from \"../../compile/codegen\"\nimport {checkMetadata} from \"./metadata\"\nimport {checkNullableObject} from \"./nullable\"\nimport {typeErrorMessage, typeErrorParams, _JTDTypeError} from \"./error\"\n\nenum PropError {\n  Additional = \"additional\",\n  Missing = \"missing\",\n}\n\ntype PropKeyword = \"properties\" | \"optionalProperties\"\n\ntype PropSchema = {[P in string]?: SchemaObject}\n\nexport type JTDPropertiesError =\n  | _JTDTypeError<PropKeyword, \"object\", PropSchema>\n  | ErrorObject<PropKeyword, {error: PropError.Additional; additionalProperty: string}, PropSchema>\n  | ErrorObject<PropKeyword, {error: PropError.Missing; missingProperty: string}, PropSchema>\n\nexport const error: KeywordErrorDefinition = {\n  message: (cxt) => {\n    const {params} = cxt\n    return params.propError\n      ? params.propError === PropError.Additional\n        ? \"must NOT have additional properties\"\n        : `must have property '${params.missingProperty}'`\n      : typeErrorMessage(cxt, \"object\")\n  },\n  params: (cxt) => {\n    const {params} = cxt\n    return params.propError\n      ? params.propError === PropError.Additional\n        ? _`{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}`\n        : _`{error: ${params.propError}, missingProperty: ${params.missingProperty}}`\n      : typeErrorParams(cxt, \"object\")\n  },\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  schemaType: \"object\",\n  error,\n  code: validateProperties,\n}\n\n// const error: KeywordErrorDefinition = {\n//   message: \"should NOT have additional properties\",\n//   params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n// }\n\nexport function validateProperties(cxt: KeywordCxt): void {\n  checkMetadata(cxt)\n  const {gen, data, parentSchema, it} = cxt\n  const {additionalProperties, nullable} = parentSchema\n  if (it.jtdDiscriminator && nullable) throw new Error(\"JTD: nullable inside discriminator mapping\")\n  if (commonProperties()) {\n    throw new Error(\"JTD: properties and optionalProperties have common members\")\n  }\n  const [allProps, properties] = schemaProperties(\"properties\")\n  const [allOptProps, optProperties] = schemaProperties(\"optionalProperties\")\n  if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {\n    return\n  }\n\n  const [valid, cond] =\n    it.jtdDiscriminator === undefined\n      ? checkNullableObject(cxt, data)\n      : [gen.let(\"valid\", false), true]\n  gen.if(cond, () =>\n    gen.assign(valid, true).block(() => {\n      validateProps(properties, \"properties\", true)\n      validateProps(optProperties, \"optionalProperties\")\n      if (!additionalProperties) validateAdditional()\n    })\n  )\n  cxt.pass(valid)\n\n  function commonProperties(): boolean {\n    const props = parentSchema.properties as Record<string, any> | undefined\n    const optProps = parentSchema.optionalProperties as Record<string, any> | undefined\n    if (!(props && optProps)) return false\n    for (const p in props) {\n      if (Object.prototype.hasOwnProperty.call(optProps, p)) return true\n    }\n    return false\n  }\n\n  function schemaProperties(keyword: string): [string[], string[]] {\n    const schema = parentSchema[keyword]\n    const allPs = schema ? allSchemaProperties(schema) : []\n    if (it.jtdDiscriminator && allPs.some((p) => p === it.jtdDiscriminator)) {\n      throw new Error(`JTD: discriminator tag used in ${keyword}`)\n    }\n    const ps = allPs.filter((p) => !alwaysValidSchema(it, schema[p]))\n    return [allPs, ps]\n  }\n\n  function validateProps(props: string[], keyword: string, required?: boolean): void {\n    const _valid = gen.var(\"valid\")\n    for (const prop of props) {\n      gen.if(\n        propertyInData(gen, data, prop, it.opts.ownProperties),\n        () => applyPropertySchema(prop, keyword, _valid),\n        () => missingProperty(prop)\n      )\n      cxt.ok(_valid)\n    }\n\n    function missingProperty(prop: string): void {\n      if (required) {\n        gen.assign(_valid, false)\n        cxt.error(false, {propError: PropError.Missing, missingProperty: prop}, {schemaPath: prop})\n      } else {\n        gen.assign(_valid, true)\n      }\n    }\n  }\n\n  function applyPropertySchema(prop: string, keyword: string, _valid: Name): void {\n    cxt.subschema(\n      {\n        keyword,\n        schemaProp: prop,\n        dataProp: prop,\n      },\n      _valid\n    )\n  }\n\n  function validateAdditional(): void {\n    gen.forIn(\"key\", data, (key: Name) => {\n      const _allProps =\n        it.jtdDiscriminator === undefined ? allProps : [it.jtdDiscriminator].concat(allProps)\n      const addProp = isAdditional(key, _allProps, \"properties\")\n      const addOptProp = isAdditional(key, allOptProps, \"optionalProperties\")\n      const extra =\n        addProp === true ? addOptProp : addOptProp === true ? addProp : and(addProp, addOptProp)\n      gen.if(extra, () => {\n        if (it.opts.removeAdditional) {\n          gen.code(_`delete ${data}[${key}]`)\n        } else {\n          cxt.error(\n            false,\n            {propError: PropError.Additional, additionalProperty: key},\n            {instancePath: key, parentSchema: true}\n          )\n          if (!it.opts.allErrors) gen.break()\n        }\n      })\n    })\n  }\n\n  function isAdditional(key: Name, props: string[], keyword: string): Code | true {\n    let additional: Code | boolean\n    if (props.length > 8) {\n      // TODO maybe an option instead of hard-coded 8?\n      const propsSchema = schemaRefOrVal(it, parentSchema[keyword], keyword)\n      additional = not(isOwnProperty(gen, propsSchema as Code, key))\n    } else if (props.length) {\n      additional = and(...props.map((p) => _`${key} !== ${p}`))\n    } else {\n      additional = true\n    }\n    return additional\n  }\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}