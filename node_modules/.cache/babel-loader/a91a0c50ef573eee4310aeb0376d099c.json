{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst shared = root => {\n  const sch = {\n    nullable: {\n      type: \"boolean\"\n    },\n    metadata: {\n      optionalProperties: {\n        union: {\n          elements: {\n            ref: \"schema\"\n          }\n        }\n      },\n      additionalProperties: true\n    }\n  };\n  if (root) sch.definitions = {\n    values: {\n      ref: \"schema\"\n    }\n  };\n  return sch;\n};\n\nconst emptyForm = root => ({\n  optionalProperties: shared(root)\n});\n\nconst refForm = root => ({\n  properties: {\n    ref: {\n      type: \"string\"\n    }\n  },\n  optionalProperties: shared(root)\n});\n\nconst typeForm = root => ({\n  properties: {\n    type: {\n      enum: [\"boolean\", \"timestamp\", \"string\", \"float32\", \"float64\", \"int8\", \"uint8\", \"int16\", \"uint16\", \"int32\", \"uint32\"]\n    }\n  },\n  optionalProperties: shared(root)\n});\n\nconst enumForm = root => ({\n  properties: {\n    enum: {\n      elements: {\n        type: \"string\"\n      }\n    }\n  },\n  optionalProperties: shared(root)\n});\n\nconst elementsForm = root => ({\n  properties: {\n    elements: {\n      ref: \"schema\"\n    }\n  },\n  optionalProperties: shared(root)\n});\n\nconst propertiesForm = root => ({\n  properties: {\n    properties: {\n      values: {\n        ref: \"schema\"\n      }\n    }\n  },\n  optionalProperties: {\n    optionalProperties: {\n      values: {\n        ref: \"schema\"\n      }\n    },\n    additionalProperties: {\n      type: \"boolean\"\n    },\n    ...shared(root)\n  }\n});\n\nconst optionalPropertiesForm = root => ({\n  properties: {\n    optionalProperties: {\n      values: {\n        ref: \"schema\"\n      }\n    }\n  },\n  optionalProperties: {\n    additionalProperties: {\n      type: \"boolean\"\n    },\n    ...shared(root)\n  }\n});\n\nconst discriminatorForm = root => ({\n  properties: {\n    discriminator: {\n      type: \"string\"\n    },\n    mapping: {\n      values: {\n        metadata: {\n          union: [propertiesForm(false), optionalPropertiesForm(false)]\n        }\n      }\n    }\n  },\n  optionalProperties: shared(root)\n});\n\nconst valuesForm = root => ({\n  properties: {\n    values: {\n      ref: \"schema\"\n    }\n  },\n  optionalProperties: shared(root)\n});\n\nconst schema = root => ({\n  metadata: {\n    union: [emptyForm, refForm, typeForm, enumForm, elementsForm, propertiesForm, optionalPropertiesForm, discriminatorForm, valuesForm].map(s => s(root))\n  }\n});\n\nconst jtdMetaSchema = {\n  definitions: {\n    schema: schema(false)\n  },\n  ...schema(true)\n};\nexports.default = jtdMetaSchema;","map":{"version":3,"mappings":"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","names":["shared","root","sch","nullable","type","metadata","optionalProperties","union","elements","ref","additionalProperties","definitions","values","emptyForm","refForm","properties","typeForm","enum","enumForm","elementsForm","propertiesForm","optionalPropertiesForm","discriminatorForm","discriminator","mapping","valuesForm","schema","map","s","jtdMetaSchema","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\mini-css-extract-plugin\\node_modules\\ajv\\lib\\refs\\jtd-schema.ts"],"sourcesContent":["import {SchemaObject} from \"../types\"\n\ntype MetaSchema = (root: boolean) => SchemaObject\n\nconst shared: MetaSchema = (root) => {\n  const sch: SchemaObject = {\n    nullable: {type: \"boolean\"},\n    metadata: {\n      optionalProperties: {\n        union: {elements: {ref: \"schema\"}},\n      },\n      additionalProperties: true,\n    },\n  }\n  if (root) sch.definitions = {values: {ref: \"schema\"}}\n  return sch\n}\n\nconst emptyForm: MetaSchema = (root) => ({\n  optionalProperties: shared(root),\n})\n\nconst refForm: MetaSchema = (root) => ({\n  properties: {\n    ref: {type: \"string\"},\n  },\n  optionalProperties: shared(root),\n})\n\nconst typeForm: MetaSchema = (root) => ({\n  properties: {\n    type: {\n      enum: [\n        \"boolean\",\n        \"timestamp\",\n        \"string\",\n        \"float32\",\n        \"float64\",\n        \"int8\",\n        \"uint8\",\n        \"int16\",\n        \"uint16\",\n        \"int32\",\n        \"uint32\",\n      ],\n    },\n  },\n  optionalProperties: shared(root),\n})\n\nconst enumForm: MetaSchema = (root) => ({\n  properties: {\n    enum: {elements: {type: \"string\"}},\n  },\n  optionalProperties: shared(root),\n})\n\nconst elementsForm: MetaSchema = (root) => ({\n  properties: {\n    elements: {ref: \"schema\"},\n  },\n  optionalProperties: shared(root),\n})\n\nconst propertiesForm: MetaSchema = (root) => ({\n  properties: {\n    properties: {values: {ref: \"schema\"}},\n  },\n  optionalProperties: {\n    optionalProperties: {values: {ref: \"schema\"}},\n    additionalProperties: {type: \"boolean\"},\n    ...shared(root),\n  },\n})\n\nconst optionalPropertiesForm: MetaSchema = (root) => ({\n  properties: {\n    optionalProperties: {values: {ref: \"schema\"}},\n  },\n  optionalProperties: {\n    additionalProperties: {type: \"boolean\"},\n    ...shared(root),\n  },\n})\n\nconst discriminatorForm: MetaSchema = (root) => ({\n  properties: {\n    discriminator: {type: \"string\"},\n    mapping: {\n      values: {\n        metadata: {\n          union: [propertiesForm(false), optionalPropertiesForm(false)],\n        },\n      },\n    },\n  },\n  optionalProperties: shared(root),\n})\n\nconst valuesForm: MetaSchema = (root) => ({\n  properties: {\n    values: {ref: \"schema\"},\n  },\n  optionalProperties: shared(root),\n})\n\nconst schema: MetaSchema = (root) => ({\n  metadata: {\n    union: [\n      emptyForm,\n      refForm,\n      typeForm,\n      enumForm,\n      elementsForm,\n      propertiesForm,\n      optionalPropertiesForm,\n      discriminatorForm,\n      valuesForm,\n    ].map((s) => s(root)),\n  },\n})\n\nconst jtdMetaSchema: SchemaObject = {\n  definitions: {\n    schema: schema(false),\n  },\n  ...schema(true),\n}\n\nexport default jtdMetaSchema\n"]},"metadata":{},"sourceType":"script"}