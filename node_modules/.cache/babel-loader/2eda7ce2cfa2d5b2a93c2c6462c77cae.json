{"ast":null,"code":"/**\n * @fileoverview enforce consistent line breaks inside jsx curly\n */\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nfunction getNormalizedOption(context) {\n  const rawOption = context.options[0] || 'consistent';\n\n  if (rawOption === 'consistent') {\n    return {\n      multiline: 'consistent',\n      singleline: 'consistent'\n    };\n  }\n\n  if (rawOption === 'never') {\n    return {\n      multiline: 'forbid',\n      singleline: 'forbid'\n    };\n  }\n\n  return {\n    multiline: rawOption.multiline || 'consistent',\n    singleline: rawOption.singleline || 'consistent'\n  };\n}\n\nconst messages = {\n  expectedBefore: 'Expected newline before \\'}\\'.',\n  expectedAfter: 'Expected newline after \\'{\\'.',\n  unexpectedBefore: 'Unexpected newline before \\'}\\'.',\n  unexpectedAfter: 'Unexpected newline after \\'{\\'.'\n};\nmodule.exports = {\n  meta: {\n    type: 'layout',\n    docs: {\n      description: 'Enforce consistent linebreaks in curly braces in JSX attributes and expressions',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-curly-newline')\n    },\n    fixable: 'whitespace',\n    schema: [{\n      oneOf: [{\n        enum: ['consistent', 'never']\n      }, {\n        type: 'object',\n        properties: {\n          singleline: {\n            enum: ['consistent', 'require', 'forbid']\n          },\n          multiline: {\n            enum: ['consistent', 'require', 'forbid']\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = getNormalizedOption(context); // ----------------------------------------------------------------------\n    // Helpers\n    // ----------------------------------------------------------------------\n\n    /**\n     * Determines whether two adjacent tokens are on the same line.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not the tokens are on the same line.\n     */\n\n    function isTokenOnSameLine(left, right) {\n      return left.loc.end.line === right.loc.start.line;\n    }\n    /**\n     * Determines whether there should be newlines inside curlys\n     * @param {ASTNode} expression The expression contained in the curlys\n     * @param {boolean} hasLeftNewline `true` if the left curly has a newline in the current code.\n     * @returns {boolean} `true` if there should be newlines inside the function curlys\n     */\n\n\n    function shouldHaveNewlines(expression, hasLeftNewline) {\n      const isMultiline = expression.loc.start.line !== expression.loc.end.line;\n\n      switch (isMultiline ? option.multiline : option.singleline) {\n        case 'forbid':\n          return false;\n\n        case 'require':\n          return true;\n\n        case 'consistent':\n        default:\n          return hasLeftNewline;\n      }\n    }\n    /**\n     * Validates curlys\n     * @param {Object} curlys An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n     * @param {ASTNode} expression The expression inside the curly\n     * @returns {void}\n     */\n\n\n    function validateCurlys(curlys, expression) {\n      const leftCurly = curlys.leftCurly;\n      const rightCurly = curlys.rightCurly;\n      const tokenAfterLeftCurly = sourceCode.getTokenAfter(leftCurly);\n      const tokenBeforeRightCurly = sourceCode.getTokenBefore(rightCurly);\n      const hasLeftNewline = !isTokenOnSameLine(leftCurly, tokenAfterLeftCurly);\n      const hasRightNewline = !isTokenOnSameLine(tokenBeforeRightCurly, rightCurly);\n      const needsNewlines = shouldHaveNewlines(expression, hasLeftNewline);\n\n      if (hasLeftNewline && !needsNewlines) {\n        report(context, messages.unexpectedAfter, 'unexpectedAfter', {\n          node: leftCurly,\n\n          fix(fixer) {\n            return sourceCode.getText().slice(leftCurly.range[1], tokenAfterLeftCurly.range[0]).trim() ? null // If there is a comment between the { and the first element, don't do a fix.\n            : fixer.removeRange([leftCurly.range[1], tokenAfterLeftCurly.range[0]]);\n          }\n\n        });\n      } else if (!hasLeftNewline && needsNewlines) {\n        report(context, messages.expectedAfter, 'expectedAfter', {\n          node: leftCurly,\n          fix: fixer => fixer.insertTextAfter(leftCurly, '\\n')\n        });\n      }\n\n      if (hasRightNewline && !needsNewlines) {\n        report(context, messages.unexpectedBefore, 'unexpectedBefore', {\n          node: rightCurly,\n\n          fix(fixer) {\n            return sourceCode.getText().slice(tokenBeforeRightCurly.range[1], rightCurly.range[0]).trim() ? null // If there is a comment between the last element and the }, don't do a fix.\n            : fixer.removeRange([tokenBeforeRightCurly.range[1], rightCurly.range[0]]);\n          }\n\n        });\n      } else if (!hasRightNewline && needsNewlines) {\n        report(context, messages.expectedBefore, 'expectedBefore', {\n          node: rightCurly,\n          fix: fixer => fixer.insertTextBefore(rightCurly, '\\n')\n        });\n      }\n    } // ----------------------------------------------------------------------\n    // Public\n    // ----------------------------------------------------------------------\n\n\n    return {\n      JSXExpressionContainer(node) {\n        const curlyTokens = {\n          leftCurly: sourceCode.getFirstToken(node),\n          rightCurly: sourceCode.getLastToken(node)\n        };\n        validateCurlys(curlyTokens, node.expression);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["docsUrl","require","report","getNormalizedOption","context","rawOption","options","multiline","singleline","messages","expectedBefore","expectedAfter","unexpectedBefore","unexpectedAfter","module","exports","meta","type","docs","description","category","recommended","url","fixable","schema","oneOf","enum","properties","additionalProperties","create","sourceCode","getSourceCode","option","isTokenOnSameLine","left","right","loc","end","line","start","shouldHaveNewlines","expression","hasLeftNewline","isMultiline","validateCurlys","curlys","leftCurly","rightCurly","tokenAfterLeftCurly","getTokenAfter","tokenBeforeRightCurly","getTokenBefore","hasRightNewline","needsNewlines","node","fix","fixer","getText","slice","range","trim","removeRange","insertTextAfter","insertTextBefore","JSXExpressionContainer","curlyTokens","getFirstToken","getLastToken"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-curly-newline.js"],"sourcesContent":["/**\n * @fileoverview enforce consistent line breaks inside jsx curly\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nfunction getNormalizedOption(context) {\n  const rawOption = context.options[0] || 'consistent';\n\n  if (rawOption === 'consistent') {\n    return {\n      multiline: 'consistent',\n      singleline: 'consistent',\n    };\n  }\n\n  if (rawOption === 'never') {\n    return {\n      multiline: 'forbid',\n      singleline: 'forbid',\n    };\n  }\n\n  return {\n    multiline: rawOption.multiline || 'consistent',\n    singleline: rawOption.singleline || 'consistent',\n  };\n}\n\nconst messages = {\n  expectedBefore: 'Expected newline before \\'}\\'.',\n  expectedAfter: 'Expected newline after \\'{\\'.',\n  unexpectedBefore: 'Unexpected newline before \\'}\\'.',\n  unexpectedAfter: 'Unexpected newline after \\'{\\'.',\n};\n\nmodule.exports = {\n  meta: {\n    type: 'layout',\n\n    docs: {\n      description: 'Enforce consistent linebreaks in curly braces in JSX attributes and expressions',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-curly-newline'),\n    },\n\n    fixable: 'whitespace',\n\n    schema: [\n      {\n        oneOf: [\n          {\n            enum: ['consistent', 'never'],\n          },\n          {\n            type: 'object',\n            properties: {\n              singleline: { enum: ['consistent', 'require', 'forbid'] },\n              multiline: { enum: ['consistent', 'require', 'forbid'] },\n            },\n            additionalProperties: false,\n          },\n        ],\n      },\n    ],\n\n    messages,\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = getNormalizedOption(context);\n\n    // ----------------------------------------------------------------------\n    // Helpers\n    // ----------------------------------------------------------------------\n\n    /**\n     * Determines whether two adjacent tokens are on the same line.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not the tokens are on the same line.\n     */\n    function isTokenOnSameLine(left, right) {\n      return left.loc.end.line === right.loc.start.line;\n    }\n\n    /**\n     * Determines whether there should be newlines inside curlys\n     * @param {ASTNode} expression The expression contained in the curlys\n     * @param {boolean} hasLeftNewline `true` if the left curly has a newline in the current code.\n     * @returns {boolean} `true` if there should be newlines inside the function curlys\n     */\n    function shouldHaveNewlines(expression, hasLeftNewline) {\n      const isMultiline = expression.loc.start.line !== expression.loc.end.line;\n\n      switch (isMultiline ? option.multiline : option.singleline) {\n        case 'forbid': return false;\n        case 'require': return true;\n        case 'consistent':\n        default: return hasLeftNewline;\n      }\n    }\n\n    /**\n     * Validates curlys\n     * @param {Object} curlys An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\n     * @param {ASTNode} expression The expression inside the curly\n     * @returns {void}\n     */\n    function validateCurlys(curlys, expression) {\n      const leftCurly = curlys.leftCurly;\n      const rightCurly = curlys.rightCurly;\n      const tokenAfterLeftCurly = sourceCode.getTokenAfter(leftCurly);\n      const tokenBeforeRightCurly = sourceCode.getTokenBefore(rightCurly);\n      const hasLeftNewline = !isTokenOnSameLine(leftCurly, tokenAfterLeftCurly);\n      const hasRightNewline = !isTokenOnSameLine(tokenBeforeRightCurly, rightCurly);\n      const needsNewlines = shouldHaveNewlines(expression, hasLeftNewline);\n\n      if (hasLeftNewline && !needsNewlines) {\n        report(context, messages.unexpectedAfter, 'unexpectedAfter', {\n          node: leftCurly,\n          fix(fixer) {\n            return sourceCode\n              .getText()\n              .slice(leftCurly.range[1], tokenAfterLeftCurly.range[0])\n              .trim()\n              ? null // If there is a comment between the { and the first element, don't do a fix.\n              : fixer.removeRange([leftCurly.range[1], tokenAfterLeftCurly.range[0]]);\n          },\n        });\n      } else if (!hasLeftNewline && needsNewlines) {\n        report(context, messages.expectedAfter, 'expectedAfter', {\n          node: leftCurly,\n          fix: (fixer) => fixer.insertTextAfter(leftCurly, '\\n'),\n        });\n      }\n\n      if (hasRightNewline && !needsNewlines) {\n        report(context, messages.unexpectedBefore, 'unexpectedBefore', {\n          node: rightCurly,\n          fix(fixer) {\n            return sourceCode\n              .getText()\n              .slice(tokenBeforeRightCurly.range[1], rightCurly.range[0])\n              .trim()\n              ? null // If there is a comment between the last element and the }, don't do a fix.\n              : fixer.removeRange([\n                tokenBeforeRightCurly.range[1],\n                rightCurly.range[0],\n              ]);\n          },\n        });\n      } else if (!hasRightNewline && needsNewlines) {\n        report(context, messages.expectedBefore, 'expectedBefore', {\n          node: rightCurly,\n          fix: (fixer) => fixer.insertTextBefore(rightCurly, '\\n'),\n        });\n      }\n    }\n\n    // ----------------------------------------------------------------------\n    // Public\n    // ----------------------------------------------------------------------\n\n    return {\n      JSXExpressionContainer(node) {\n        const curlyTokens = {\n          leftCurly: sourceCode.getFirstToken(node),\n          rightCurly: sourceCode.getLastToken(node),\n        };\n        validateCurlys(curlyTokens, node.expression);\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}