{"ast":null,"code":"/**\n * @fileoverview Prevent using string literals in React component definition\n * @author Caleb Morris\n * @author David Buchan-Swanson\n */\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nfunction trimIfString(val) {\n  return typeof val === 'string' ? val.trim() : val;\n}\n\nconst messages = {\n  invalidPropValue: 'Invalid prop value: \"{{text}}\"',\n  noStringsInAttributes: 'Strings not allowed in attributes: \"{{text}}\"',\n  noStringsInJSX: 'Strings not allowed in JSX files: \"{{text}}\"',\n  literalNotInJSXExpression: 'Missing JSX expression container around literal string: \"{{text}}\"'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow usage of string literals in JSX',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-no-literals')\n    },\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        noStrings: {\n          type: 'boolean'\n        },\n        allowedStrings: {\n          type: 'array',\n          uniqueItems: true,\n          items: {\n            type: 'string'\n          }\n        },\n        ignoreProps: {\n          type: 'boolean'\n        },\n        noAttributeStrings: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const defaults = {\n      noStrings: false,\n      allowedStrings: [],\n      ignoreProps: false,\n      noAttributeStrings: false\n    };\n    const config = Object.assign({}, defaults, context.options[0] || {});\n    config.allowedStrings = new Set(config.allowedStrings.map(trimIfString));\n\n    function defaultMessageId() {\n      const ancestorIsJSXElement = arguments.length >= 1 && arguments[0];\n\n      if (config.noAttributeStrings && !ancestorIsJSXElement) {\n        return 'noStringsInAttributes';\n      }\n\n      if (config.noStrings) {\n        return 'noStringsInJSX';\n      }\n\n      return 'literalNotInJSXExpression';\n    }\n\n    function getParentIgnoringBinaryExpressions(node) {\n      let current = node;\n\n      while (current.parent.type === 'BinaryExpression') {\n        current = current.parent;\n      }\n\n      return current.parent;\n    }\n\n    function getValidation(node) {\n      const values = [trimIfString(node.raw), trimIfString(node.value)];\n\n      if (values.some(value => config.allowedStrings.has(value))) {\n        return false;\n      }\n\n      const parent = getParentIgnoringBinaryExpressions(node);\n\n      function isParentNodeStandard() {\n        if (!/^[\\s]+$/.test(node.value) && typeof node.value === 'string' && parent.type.includes('JSX')) {\n          if (config.noAttributeStrings) {\n            return parent.type === 'JSXAttribute' || parent.type === 'JSXElement';\n          }\n\n          if (!config.noAttributeStrings) {\n            return parent.type !== 'JSXAttribute';\n          }\n        }\n\n        return false;\n      }\n\n      const standard = isParentNodeStandard();\n\n      if (config.noStrings) {\n        return standard;\n      }\n\n      return standard && parent.type !== 'JSXExpressionContainer';\n    }\n\n    function getParentAndGrandParentType(node) {\n      const parent = getParentIgnoringBinaryExpressions(node);\n      const parentType = parent.type;\n      const grandParentType = parent.parent.type;\n      return {\n        parent,\n        parentType,\n        grandParentType,\n        grandParent: parent.parent\n      };\n    }\n\n    function hasJSXElementParentOrGrandParent(node) {\n      const parents = getParentAndGrandParentType(node);\n      const parentType = parents.parentType;\n      const grandParentType = parents.grandParentType;\n      return parentType === 'JSXFragment' || parentType === 'JSXElement' || grandParentType === 'JSXElement';\n    }\n\n    function reportLiteralNode(node, messageId) {\n      const ancestorIsJSXElement = hasJSXElementParentOrGrandParent(node);\n      messageId = messageId || defaultMessageId(ancestorIsJSXElement);\n      report(context, messages[messageId], messageId, {\n        node,\n        data: {\n          text: context.getSourceCode().getText(node).trim()\n        }\n      });\n    } // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n\n    return {\n      Literal(node) {\n        if (getValidation(node) && (hasJSXElementParentOrGrandParent(node) || !config.ignoreProps)) {\n          reportLiteralNode(node);\n        }\n      },\n\n      JSXAttribute(node) {\n        const isNodeValueString = node && node.value && node.value.type === 'Literal' && typeof node.value.value === 'string' && !config.allowedStrings.has(node.value.value);\n\n        if (config.noStrings && !config.ignoreProps && isNodeValueString) {\n          const messageId = 'invalidPropValue';\n          reportLiteralNode(node, messageId);\n        }\n      },\n\n      JSXText(node) {\n        if (getValidation(node)) {\n          reportLiteralNode(node);\n        }\n      },\n\n      TemplateLiteral(node) {\n        const parents = getParentAndGrandParentType(node);\n        const parentType = parents.parentType;\n        const grandParentType = parents.grandParentType;\n        const isParentJSXExpressionCont = parentType === 'JSXExpressionContainer';\n        const isParentJSXElement = parentType === 'JSXElement' || grandParentType === 'JSXElement';\n\n        if (isParentJSXExpressionCont && config.noStrings && (isParentJSXElement || !config.ignoreProps)) {\n          reportLiteralNode(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["docsUrl","require","report","trimIfString","val","trim","messages","invalidPropValue","noStringsInAttributes","noStringsInJSX","literalNotInJSXExpression","module","exports","meta","docs","description","category","recommended","url","schema","type","properties","noStrings","allowedStrings","uniqueItems","items","ignoreProps","noAttributeStrings","additionalProperties","create","context","defaults","config","Object","assign","options","Set","map","defaultMessageId","ancestorIsJSXElement","arguments","length","getParentIgnoringBinaryExpressions","node","current","parent","getValidation","values","raw","value","some","has","isParentNodeStandard","test","includes","standard","getParentAndGrandParentType","parentType","grandParentType","grandParent","hasJSXElementParentOrGrandParent","parents","reportLiteralNode","messageId","data","text","getSourceCode","getText","Literal","JSXAttribute","isNodeValueString","JSXText","TemplateLiteral","isParentJSXExpressionCont","isParentJSXElement"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-no-literals.js"],"sourcesContent":["/**\n * @fileoverview Prevent using string literals in React component definition\n * @author Caleb Morris\n * @author David Buchan-Swanson\n */\n\n'use strict';\n\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nfunction trimIfString(val) {\n  return typeof val === 'string' ? val.trim() : val;\n}\n\nconst messages = {\n  invalidPropValue: 'Invalid prop value: \"{{text}}\"',\n  noStringsInAttributes: 'Strings not allowed in attributes: \"{{text}}\"',\n  noStringsInJSX: 'Strings not allowed in JSX files: \"{{text}}\"',\n  literalNotInJSXExpression: 'Missing JSX expression container around literal string: \"{{text}}\"',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow usage of string literals in JSX',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-no-literals'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        noStrings: {\n          type: 'boolean',\n        },\n        allowedStrings: {\n          type: 'array',\n          uniqueItems: true,\n          items: {\n            type: 'string',\n          },\n        },\n        ignoreProps: {\n          type: 'boolean',\n        },\n        noAttributeStrings: {\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create(context) {\n    const defaults = {\n      noStrings: false,\n      allowedStrings: [],\n      ignoreProps: false,\n      noAttributeStrings: false,\n    };\n    const config = Object.assign({}, defaults, context.options[0] || {});\n    config.allowedStrings = new Set(config.allowedStrings.map(trimIfString));\n\n    function defaultMessageId() {\n      const ancestorIsJSXElement = arguments.length >= 1 && arguments[0];\n      if (config.noAttributeStrings && !ancestorIsJSXElement) {\n        return 'noStringsInAttributes';\n      }\n      if (config.noStrings) {\n        return 'noStringsInJSX';\n      }\n      return 'literalNotInJSXExpression';\n    }\n\n    function getParentIgnoringBinaryExpressions(node) {\n      let current = node;\n      while (current.parent.type === 'BinaryExpression') {\n        current = current.parent;\n      }\n      return current.parent;\n    }\n\n    function getValidation(node) {\n      const values = [trimIfString(node.raw), trimIfString(node.value)];\n      if (values.some((value) => config.allowedStrings.has(value))) {\n        return false;\n      }\n\n      const parent = getParentIgnoringBinaryExpressions(node);\n\n      function isParentNodeStandard() {\n        if (!/^[\\s]+$/.test(node.value) && typeof node.value === 'string' && parent.type.includes('JSX')) {\n          if (config.noAttributeStrings) {\n            return parent.type === 'JSXAttribute' || parent.type === 'JSXElement';\n          }\n          if (!config.noAttributeStrings) {\n            return parent.type !== 'JSXAttribute';\n          }\n        }\n\n        return false;\n      }\n\n      const standard = isParentNodeStandard();\n\n      if (config.noStrings) {\n        return standard;\n      }\n      return standard && parent.type !== 'JSXExpressionContainer';\n    }\n\n    function getParentAndGrandParentType(node) {\n      const parent = getParentIgnoringBinaryExpressions(node);\n      const parentType = parent.type;\n      const grandParentType = parent.parent.type;\n\n      return {\n        parent,\n        parentType,\n        grandParentType,\n        grandParent: parent.parent,\n      };\n    }\n\n    function hasJSXElementParentOrGrandParent(node) {\n      const parents = getParentAndGrandParentType(node);\n      const parentType = parents.parentType;\n      const grandParentType = parents.grandParentType;\n\n      return parentType === 'JSXFragment' || parentType === 'JSXElement' || grandParentType === 'JSXElement';\n    }\n\n    function reportLiteralNode(node, messageId) {\n      const ancestorIsJSXElement = hasJSXElementParentOrGrandParent(node);\n      messageId = messageId || defaultMessageId(ancestorIsJSXElement);\n\n      report(context, messages[messageId], messageId, {\n        node,\n        data: {\n          text: context.getSourceCode().getText(node).trim(),\n        },\n      });\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      Literal(node) {\n        if (getValidation(node) && (hasJSXElementParentOrGrandParent(node) || !config.ignoreProps)) {\n          reportLiteralNode(node);\n        }\n      },\n\n      JSXAttribute(node) {\n        const isNodeValueString = node && node.value && node.value.type === 'Literal' && typeof node.value.value === 'string' && !config.allowedStrings.has(node.value.value);\n\n        if (config.noStrings && !config.ignoreProps && isNodeValueString) {\n          const messageId = 'invalidPropValue';\n          reportLiteralNode(node, messageId);\n        }\n      },\n\n      JSXText(node) {\n        if (getValidation(node)) {\n          reportLiteralNode(node);\n        }\n      },\n\n      TemplateLiteral(node) {\n        const parents = getParentAndGrandParentType(node);\n        const parentType = parents.parentType;\n        const grandParentType = parents.grandParentType;\n        const isParentJSXExpressionCont = parentType === 'JSXExpressionContainer';\n        const isParentJSXElement = parentType === 'JSXElement' || grandParentType === 'JSXElement';\n\n        if (isParentJSXExpressionCont && config.noStrings && (isParentJSXElement || !config.ignoreProps)) {\n          reportLiteralNode(node);\n        }\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}