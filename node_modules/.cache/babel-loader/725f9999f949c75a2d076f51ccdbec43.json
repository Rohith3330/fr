{"ast":null,"code":"const EventEmitter = require('events').EventEmitter;\n\nconst childProcess = require('child_process');\n\nconst path = require('path');\n\nconst fs = require('fs');\n\nconst {\n  Argument,\n  humanReadableArgName\n} = require('./argument.js');\n\nconst {\n  CommanderError\n} = require('./error.js');\n\nconst {\n  Help\n} = require('./help.js');\n\nconst {\n  Option,\n  splitOptionFlags\n} = require('./option.js');\n\nconst {\n  suggestSimilar\n} = require('./suggestSimilar'); // @ts-check\n\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n  constructor(name) {\n    super();\n    /** @type {Command[]} */\n\n    this.commands = [];\n    /** @type {Option[]} */\n\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    /** @type {Argument[]} */\n\n    this._args = [];\n    /** @type {string[]} */\n\n    this.args = []; // cli args with options removed\n\n    this.rawArgs = [];\n    this.processedArgs = []; // like .args but after custom processing and collecting variadic\n\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._optionValueSources = {}; // default < config < env < cli\n\n    this._storeOptionsAsProperties = false;\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._argsDescription = undefined; // legacy\n\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n    this._lifeCycleHooks = {}; // a hash of arrays\n\n    /** @type {boolean | string} */\n\n    this._showHelpAfterError = false;\n    this._showSuggestionAfterError = false; // see .configureOutput() for docs\n\n    this._outputConfiguration = {\n      writeOut: str => process.stdout.write(str),\n      writeErr: str => process.stderr.write(str),\n      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str)\n    };\n    this._hidden = false;\n    this._hasHelpOption = true;\n    this._helpFlags = '-h, --help';\n    this._helpDescription = 'display help for command';\n    this._helpShortFlag = '-h';\n    this._helpLongFlag = '--help';\n    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false\n\n    this._helpCommandName = 'help';\n    this._helpCommandnameAndArgs = 'help [command]';\n    this._helpCommandDescription = 'display help for command';\n    this._helpConfiguration = {};\n  }\n  /**\n   * Copy settings that are useful to have in common across root command and subcommands.\n   *\n   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)\n   *\n   * @param {Command} sourceCommand\n   * @return {Command} returns `this` for executable command\n   */\n\n\n  copyInheritedSettings(sourceCommand) {\n    this._outputConfiguration = sourceCommand._outputConfiguration;\n    this._hasHelpOption = sourceCommand._hasHelpOption;\n    this._helpFlags = sourceCommand._helpFlags;\n    this._helpDescription = sourceCommand._helpDescription;\n    this._helpShortFlag = sourceCommand._helpShortFlag;\n    this._helpLongFlag = sourceCommand._helpLongFlag;\n    this._helpCommandName = sourceCommand._helpCommandName;\n    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;\n    this._helpCommandDescription = sourceCommand._helpCommandDescription;\n    this._helpConfiguration = sourceCommand._helpConfiguration;\n    this._exitCallback = sourceCommand._exitCallback;\n    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;\n    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;\n    this._allowExcessArguments = sourceCommand._allowExcessArguments;\n    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;\n    this._showHelpAfterError = sourceCommand._showHelpAfterError;\n    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;\n    return this;\n  }\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * @example\n   * // Command implemented using action handler (description is supplied separately to `.command`)\n   * program\n   *   .command('clone <source> [destination]')\n   *   .description('clone a repository into a newly created directory')\n   *   .action((source, destination) => {\n   *     console.log('clone command called');\n   *   });\n   *\n   * // Command implemented using separate executable file (description is second parameter to `.command`)\n   * program\n   *   .command('start <service>', 'start named service')\n   *   .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n\n    opts = opts || {};\n    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);\n    const cmd = this.createCommand(name);\n\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n\n    if (args) cmd.arguments(args);\n    this.commands.push(cmd);\n    cmd.parent = this;\n    cmd.copyInheritedSettings(this);\n    if (desc) return this;\n    return cmd;\n  }\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n  createCommand(name) {\n    return new Command(name);\n  }\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  }\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n    this._helpConfiguration = configuration;\n    return this;\n  }\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *     // functions to change where being written, stdout and stderr\n   *     writeOut(str)\n   *     writeErr(str)\n   *     // matching functions to specify width for wrapping help\n   *     getOutHelpWidth()\n   *     getErrHelpWidth()\n   *     // functions based on what is being written out\n   *     outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n  /**\n   * Display the help or a custom message after an error occurs.\n   *\n   * @param {boolean|string} [displayHelp]\n   * @return {Command} `this` command for chaining\n   */\n\n\n  showHelpAfterError() {\n    let displayHelp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;\n    this._showHelpAfterError = displayHelp;\n    return this;\n  }\n  /**\n   * Display suggestion of similar commands for unknown commands, or options for unknown options.\n   *\n   * @param {boolean} [displaySuggestion]\n   * @return {Command} `this` command for chaining\n   */\n\n\n  showSuggestionAfterError() {\n    let displaySuggestion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._showSuggestionAfterError = !!displaySuggestion;\n    return this;\n  }\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) throw new Error('Command passed to .addCommand() must have a name'); // To keep things simple, block automatic name generation for deeply nested executables.\n    // Fail fast and detect when adding rather than later when parsing.\n\n    function checkExplicitNames(commandArray) {\n      commandArray.forEach(cmd => {\n        if (cmd._executableHandler && !cmd._executableFile) {\n          throw new Error(`Must specify executableFile for deeply nested executable: ${cmd.name()}`);\n        }\n\n        checkExplicitNames(cmd.commands);\n      });\n    }\n\n    checkExplicitNames(cmd.commands);\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this.commands.push(cmd);\n    cmd.parent = this;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached argument.\n   *\n   * See .argument() for creating an attached argument, which uses this routine to\n   * create the argument. You can override createArgument to return a custom argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @return {Argument} new argument\n   */\n  createArgument(name, description) {\n    return new Argument(name, description);\n  }\n\n  /**\n   * Define argument syntax for command.\n   *\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @example\n   * program.argument('<input-file>');\n   * program.argument('[output-file]');\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom argument processing function\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n  argument(name, description, fn, defaultValue) {\n    const argument = this.createArgument(name, description);\n\n    if (typeof fn === 'function') {\n      argument.default(defaultValue).argParser(fn);\n    } else {\n      argument.default(fn);\n    }\n\n    this.addArgument(argument);\n    return this;\n  }\n  /**\n   * Define argument syntax for command, adding multiple at once (without descriptions).\n   *\n   * See also .argument().\n   *\n   * @example\n   * program.arguments('<cmd> [env]');\n   *\n   * @param {string} names\n   * @return {Command} `this` command for chaining\n   */\n\n\n  arguments(names) {\n    names.split(/ +/).forEach(detail => {\n      this.argument(detail);\n    });\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding a prepared argument.\n   *\n   * @param {Argument} argument\n   * @return {Command} `this` command for chaining\n   */\n  addArgument(argument) {\n    const previousArgument = this._args.slice(-1)[0];\n\n    if (previousArgument && previousArgument.variadic) {\n      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);\n    }\n\n    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {\n      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);\n    }\n\n    this._args.push(argument);\n\n    return this;\n  }\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   *    addHelpCommand() // force on\n   *    addHelpCommand(false); // force off\n   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   *\n   * @return {Command} `this` command for chaining\n   */\n\n\n  addHelpCommand(enableOrNameAndArgs, description) {\n    if (enableOrNameAndArgs === false) {\n      this._addImplicitHelpCommand = false;\n    } else {\n      this._addImplicitHelpCommand = true;\n\n      if (typeof enableOrNameAndArgs === 'string') {\n        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];\n        this._helpCommandnameAndArgs = enableOrNameAndArgs;\n      }\n\n      this._helpCommandDescription = description || this._helpCommandDescription;\n    }\n\n    return this;\n  }\n\n  /**\n   * @return {boolean}\n   * @api private\n   */\n  _hasImplicitHelpCommand() {\n    if (this._addImplicitHelpCommand === undefined) {\n      return this.commands.length && !this._actionHandler && !this._findCommand('help');\n    }\n\n    return this._addImplicitHelpCommand;\n  }\n\n  /**\n   * Add hook for life cycle event.\n   *\n   * @param {string} event\n   * @param {Function} listener\n   * @return {Command} `this` command for chaining\n   */\n  hook(event, listener) {\n    const allowedValues = ['preAction', 'postAction'];\n\n    if (!allowedValues.includes(event)) {\n      throw new Error(`Unexpected value for event passed to hook : '${event}'.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n\n    if (this._lifeCycleHooks[event]) {\n      this._lifeCycleHooks[event].push(listener);\n    } else {\n      this._lifeCycleHooks[event] = [listener];\n    }\n\n    return this;\n  }\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = err => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {// Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n\n    return this;\n  }\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @api private\n   */\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message)); // Expecting this line is not reached.\n\n    }\n\n    process.exit(exitCode);\n  }\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * @example\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *      // do work here\n   *   });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n  action(fn) {\n    const listener = args => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this._args.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n\n      actionArgs.push(this);\n      return fn.apply(this, actionArgs);\n    };\n\n    this._actionHandler = listener;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n  createOption(flags, description) {\n    return new Option(flags, description);\n  }\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    const oname = option.name();\n    const name = option.attributeName();\n    let defaultValue = option.defaultValue; // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value\n\n    if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {\n      // when --no-foo we make sure default is true, unless a --foo option is already defined\n      if (option.negate) {\n        const positiveLongFlag = option.long.replace(/^--no-/, '--');\n        defaultValue = this._findOption(positiveLongFlag) ? this.getOptionValue(name) : true;\n      } // preassign only if we have a default\n\n\n      if (defaultValue !== undefined) {\n        this.setOptionValueWithSource(name, defaultValue, 'default');\n      }\n    } // register the option\n\n\n    this.options.push(option); // handler for cli and env supplied values\n\n    const handleOptionValue = (val, invalidValueMessage, valueSource) => {\n      // Note: using closure to access lots of lexical scoped variables.\n      const oldValue = this.getOptionValue(name); // custom processing\n\n      if (val !== null && option.parseArg) {\n        try {\n          val = option.parseArg(val, oldValue === undefined ? defaultValue : oldValue);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `${invalidValueMessage} ${err.message}`;\n\n            this._displayError(err.exitCode, err.code, message);\n          }\n\n          throw err;\n        }\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      } // unassigned or boolean value\n\n\n      if (typeof oldValue === 'boolean' || typeof oldValue === 'undefined') {\n        // if no value, negate false, and we have a default, then use it!\n        if (val == null) {\n          this.setOptionValueWithSource(name, option.negate ? false : defaultValue || true, valueSource);\n        } else {\n          this.setOptionValueWithSource(name, val, valueSource);\n        }\n      } else if (val !== null) {\n        // reassign\n        this.setOptionValueWithSource(name, option.negate ? false : val, valueSource);\n      }\n    };\n\n    this.on('option:' + oname, val => {\n      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;\n      handleOptionValue(val, invalidValueMessage, 'cli');\n    });\n\n    if (option.envVar) {\n      this.on('optionEnv:' + oname, val => {\n        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;\n        handleOptionValue(val, invalidValueMessage, 'env');\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @api private\n   */\n\n\n  _optionEx(config, flags, description, fn, defaultValue) {\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n  /**\n   * Define option with `flags`, `description` and optional\n   * coercion `fn`.\n   *\n   * The `flags` string contains the short and/or long flags,\n   * separated by comma, a pipe or space. The following are all valid\n   * all will output this way when `--help` is used.\n   *\n   *     \"-p, --pepper\"\n   *     \"-p|--pepper\"\n   *     \"-p --pepper\"\n   *\n   * @example\n   * // simple boolean defaulting to undefined\n   * program.option('-p, --pepper', 'add pepper');\n   *\n   * program.pepper\n   * // => undefined\n   *\n   * --pepper\n   * program.pepper\n   * // => true\n   *\n   * // simple boolean defaulting to true (unless non-negated option is also defined)\n   * program.option('-C, --no-cheese', 'remove cheese');\n   *\n   * program.cheese\n   * // => true\n   *\n   * --no-cheese\n   * program.cheese\n   * // => false\n   *\n   * // required argument\n   * program.option('-C, --chdir <path>', 'change the working directory');\n   *\n   * --chdir /tmp\n   * program.chdir\n   * // => \"/tmp\"\n   *\n   * // optional argument\n   * program.option('-c, --cheese [type]', 'add cheese [marble]');\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n\n  option(flags, description, fn, defaultValue) {\n    return this._optionEx({}, flags, description, fn, defaultValue);\n  }\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} [description]\n  * @param {Function|*} [fn] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  */\n  requiredOption(flags, description, fn, defaultValue) {\n    return this._optionEx({\n      mandatory: true\n    }, flags, description, fn, defaultValue);\n  }\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * @example\n   * // for `.option('-f,--flag [value]'):\n   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.\n   */\n  combineFlagAndOptionalValue() {\n    let combine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  }\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   */\n  allowUnknownOption() {\n    let allowUnknown = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  }\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown\n   * for excess arguments.\n   */\n  allowExcessArguments() {\n    let allowExcess = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  }\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {Boolean} [positional=true]\n   */\n  enablePositionalOptions() {\n    let positional = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._enablePositionalOptions = !!positional;\n    return this;\n  }\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {Boolean} [passThrough=true]\n   * for unknown options.\n   */\n  passThroughOptions() {\n    let passThrough = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._passThroughOptions = !!passThrough;\n\n    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {\n      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');\n    }\n\n    return this;\n  }\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} [storeAsProperties=true]\n    * @return {Command} `this` command for chaining\n    */\n  storeOptionsAsProperties() {\n    let storeAsProperties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this._storeOptionsAsProperties = !!storeAsProperties;\n\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n\n    return this;\n  }\n\n  /**\n   * Retrieve option value.\n   *\n   * @param {string} key\n   * @return {Object} value\n   */\n  getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n\n    return this._optionValues[key];\n  }\n\n  /**\n   * Store option value.\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @return {Command} `this` command for chaining\n   */\n  setOptionValue(key, value) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n\n    return this;\n  }\n\n  /**\n   * Store option value and where the value came from.\n    *\n    * @param {string} key\n    * @param {Object} value\n    * @param {string} source - expected values are default/config/env/cli\n    * @return {Command} `this` command for chaining\n    */\n  setOptionValueWithSource(key, value, source) {\n    this.setOptionValue(key, value);\n    this._optionValueSources[key] = source;\n    return this;\n  }\n  /**\n    * Get source of option value.\n    * Expected values are default | config | env | cli\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n\n  getOptionValueSource(key) {\n    return this._optionValueSources[key];\n  }\n\n  /**\n   * Get user arguments implied or explicit arguments.\n   * Side-effects: set _scriptPath if args included application, and use that to set implicit command name.\n   *\n   * @api private\n   */\n  _prepareUserArgs(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n\n    parseOptions = parseOptions || {}; // Default to using process.argv\n\n    if (argv === undefined) {\n      argv = process.argv; // @ts-ignore: unknown property\n\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n\n    this.rawArgs = argv.slice(); // make it a little easier for callers by supporting various argv conventions\n\n    let userArgs;\n\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n\n      case 'electron':\n        // @ts-ignore: unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n\n        break;\n\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n\n    if (!this._scriptPath && require.main) {\n      this._scriptPath = require.main.filename;\n    } // Guess name, used in usage in help.\n\n\n    this._name = this._name || this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath));\n    return userArgs;\n  }\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * program.parse(process.argv);\n   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n\n  parse(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n\n    this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * await program.parseAsync(process.argv);\n   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n  async parseAsync(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n\n    await this._parseCommand([], userArgs);\n    return this;\n  }\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @api private\n   */\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs']; // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n\n    this._checkForMissingMandatoryOptions(); // Want the entry script as the reference for command name and directory for searching for other files.\n\n\n    let scriptPath = this._scriptPath; // Fallback in case not set, due to how Command created or called.\n\n    if (!scriptPath && require.main) {\n      scriptPath = require.main.filename;\n    }\n\n    let baseDir;\n\n    try {\n      const resolvedLink = fs.realpathSync(scriptPath);\n      baseDir = path.dirname(resolvedLink);\n    } catch (e) {\n      baseDir = '.'; // dummy, probably not going to find executable!\n    } // name of the subcommand, like `pm-install`\n\n\n    let bin = path.basename(scriptPath, path.extname(scriptPath)) + '-' + subcommand._name;\n\n    if (subcommand._executableFile) {\n      bin = subcommand._executableFile;\n    }\n\n    const localBin = path.join(baseDir, bin);\n\n    if (fs.existsSync(localBin)) {\n      // prefer local `./<bin>` to bin in the $PATH\n      bin = localBin;\n    } else {\n      // Look for source files.\n      sourceExt.forEach(ext => {\n        if (fs.existsSync(`${localBin}${ext}`)) {\n          bin = `${localBin}${ext}`;\n        }\n      });\n    }\n\n    launchWithNode = sourceExt.includes(path.extname(bin));\n    let proc;\n\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(bin); // add executable arguments to spawn\n\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n        proc = childProcess.spawn(process.argv[0], args, {\n          stdio: 'inherit'\n        });\n      } else {\n        proc = childProcess.spawn(bin, args, {\n          stdio: 'inherit'\n        });\n      }\n    } else {\n      args.unshift(bin); // add executable arguments to spawn\n\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, {\n        stdio: 'inherit'\n      });\n    }\n\n    const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n    signals.forEach(signal => {\n      // @ts-ignore\n      process.on(signal, () => {\n        if (proc.killed === false && proc.exitCode === null) {\n          proc.kill(signal);\n        }\n      });\n    }); // By default terminate process when spawned process terminates.\n    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n\n    const exitCallback = this._exitCallback;\n\n    if (!exitCallback) {\n      proc.on('close', process.exit.bind(process));\n    } else {\n      proc.on('close', () => {\n        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n      });\n    }\n\n    proc.on('error', err => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableMissing = `'${bin}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name`;\n        throw new Error(executableMissing); // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${bin}' not executable`);\n      }\n\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    }); // Store the reference to the child process\n\n    this.runningCommand = proc;\n  }\n\n  /**\n   * @api private\n   */\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n\n    if (!subCommand) this.help({\n      error: true\n    });\n\n    if (subCommand._executableHandler) {\n      this._executeSubCommand(subCommand, operands.concat(unknown));\n    } else {\n      return subCommand._parseCommand(operands, unknown);\n    }\n  }\n\n  /**\n   * Check this.args against expected this._args.\n   *\n   * @api private\n   */\n  _checkNumberOfArguments() {\n    // too few\n    this._args.forEach((arg, i) => {\n      if (arg.required && this.args[i] == null) {\n        this.missingArgument(arg.name());\n      }\n    }); // too many\n\n\n    if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {\n      return;\n    }\n\n    if (this.args.length > this._args.length) {\n      this._excessArguments(this.args);\n    }\n  }\n\n  /**\n   * Process this.args using this._args and save as this.processedArgs!\n   *\n   * @api private\n   */\n  _processArguments() {\n    const myParseArg = (argument, value, previous) => {\n      // Extra processing for nice error message on parsing failure.\n      let parsedValue = value;\n\n      if (value !== null && argument.parseArg) {\n        try {\n          parsedValue = argument.parseArg(value, previous);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;\n\n            this._displayError(err.exitCode, err.code, message);\n          }\n\n          throw err;\n        }\n      }\n\n      return parsedValue;\n    };\n\n    this._checkNumberOfArguments();\n\n    const processedArgs = [];\n\n    this._args.forEach((declaredArg, index) => {\n      let value = declaredArg.defaultValue;\n\n      if (declaredArg.variadic) {\n        // Collect together remaining arguments for passing together as an array.\n        if (index < this.args.length) {\n          value = this.args.slice(index);\n\n          if (declaredArg.parseArg) {\n            value = value.reduce((processed, v) => {\n              return myParseArg(declaredArg, v, processed);\n            }, declaredArg.defaultValue);\n          }\n        } else if (value === undefined) {\n          value = [];\n        }\n      } else if (index < this.args.length) {\n        value = this.args[index];\n\n        if (declaredArg.parseArg) {\n          value = myParseArg(declaredArg, value, declaredArg.defaultValue);\n        }\n      }\n\n      processedArgs[index] = value;\n    });\n\n    this.processedArgs = processedArgs;\n  }\n  /**\n   * Once we have a promise we chain, but call synchronously until then.\n   *\n   * @param {Promise|undefined} promise\n   * @param {Function} fn\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n\n  _chainOrCall(promise, fn) {\n    // thenable\n    if (promise && promise.then && typeof promise.then === 'function') {\n      // already have a promise, chain callback\n      return promise.then(() => fn());\n    } // callback might return a promise\n\n\n    return fn();\n  }\n  /**\n   *\n   * @param {Promise|undefined} promise\n   * @param {string} event\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n\n  _chainOrCallHooks(promise, event) {\n    let result = promise;\n    const hooks = [];\n    getCommandAndParents(this).reverse().filter(cmd => cmd._lifeCycleHooks[event] !== undefined).forEach(hookedCommand => {\n      hookedCommand._lifeCycleHooks[event].forEach(callback => {\n        hooks.push({\n          hookedCommand,\n          callback\n        });\n      });\n    });\n\n    if (event === 'postAction') {\n      hooks.reverse();\n    }\n\n    hooks.forEach(hookDetail => {\n      result = this._chainOrCall(result, () => {\n        return hookDetail.callback(hookDetail.hookedCommand, this);\n      });\n    });\n    return result;\n  }\n  /**\n   * Process arguments in context of this command.\n   * Returns action result, in case it is a promise.\n   *\n   * @api private\n   */\n\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n\n    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env\n\n\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    }\n\n    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {\n      if (operands.length === 1) {\n        this.help();\n      }\n\n      return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);\n    }\n\n    if (this._defaultCommandName) {\n      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command\n\n      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    }\n\n    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n      // probably missing subcommand and no handler, user needs help (and exit)\n      this.help({\n        error: true\n      });\n    }\n\n    outputHelpIfRequested(this, parsed.unknown);\n\n    this._checkForMissingMandatoryOptions(); // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n\n\n    const checkForUnknownOptions = () => {\n      if (parsed.unknown.length > 0) {\n        this.unknownOption(parsed.unknown[0]);\n      }\n    };\n\n    const commandEvent = `command:${this.name()}`;\n\n    if (this._actionHandler) {\n      checkForUnknownOptions();\n\n      this._processArguments();\n\n      let actionResult;\n      actionResult = this._chainOrCallHooks(actionResult, 'preAction');\n      actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));\n      if (this.parent) this.parent.emit(commandEvent, operands, unknown); // legacy\n\n      actionResult = this._chainOrCallHooks(actionResult, 'postAction');\n      return actionResult;\n    }\n\n    if (this.parent && this.parent.listenerCount(commandEvent)) {\n      checkForUnknownOptions();\n\n      this._processArguments();\n\n      this.parent.emit(commandEvent, operands, unknown); // legacy\n    } else if (operands.length) {\n      if (this._findCommand('*')) {\n        // legacy default command\n        return this._dispatchSubcommand('*', operands, unknown);\n      }\n\n      if (this.listenerCount('command:*')) {\n        // skip option check, emit event for possible misspelling suggestion\n        this.emit('command:*', operands, unknown);\n      } else if (this.commands.length) {\n        this.unknownCommand();\n      } else {\n        checkForUnknownOptions();\n\n        this._processArguments();\n      }\n    } else if (this.commands.length) {\n      checkForUnknownOptions(); // This command has subcommands and nothing hooked up at this level, so display help (and exit).\n\n      this.help({\n        error: true\n      });\n    } else {\n      checkForUnknownOptions();\n\n      this._processArguments(); // fall through for caller to handle after calling .parse()\n\n    }\n  }\n\n  /**\n   * Find matching command.\n   *\n   * @api private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  }\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @api private\n   */\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  }\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Lazy calling after checking for help flags from leaf subcommand.\n   *\n   * @api private\n   */\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    for (let cmd = this; cmd; cmd = cmd.parent) {\n      cmd.options.forEach(anOption => {\n        if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    }\n  }\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *     argv => operands, unknown\n   *     --known kkk op => [op], []\n   *     op --known kkk => [op], []\n   *     sub --unknown uuu op => [sub], [--unknown uuu op]\n   *     sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {String[]} argv\n   * @return {{operands: String[], unknown: String[]}}\n   */\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n\n    const unknown = []; // first unknown option and remaining unknown args\n\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    } // parse options\n\n\n    let activeVariadicOption = null;\n\n    while (args.length) {\n      const arg = args.shift(); // literal\n\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg); // recognised option, call listener to assign value with possible custom processing\n\n\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null; // historical behaviour is optional value is following arg unless an option\n\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n\n            this.emit(`option:${option.name()}`, value);\n          } else {\n            // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      } // Look for combo options following single dash, eat first one if known.\n\n\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n\n        if (option) {\n          if (option.required || option.optional && this._combineFlagAndOptionalValue) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n\n          continue;\n        }\n      } // Look for known long flag with value, like --foo=bar\n\n\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n\n        const option = this._findOption(arg.slice(0, index));\n\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      } // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n\n\n      if (maybeOption(arg)) {\n        dest = unknown;\n      } // If using positionalOptions, stop processing our options at subcommand.\n\n\n      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      } // If using passThroughOptions, stop processing options at first command-argument.\n\n\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      } // add arg\n\n\n      dest.push(arg);\n    }\n\n    return {\n      operands,\n      unknown\n    };\n  }\n\n  /**\n   * Return an object containing options as key-value pairs\n   *\n   * @return {Object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n\n      return result;\n    }\n\n    return this._optionValues;\n  }\n\n  /**\n   * Internal bottleneck for handling of parsing errors.\n   *\n   * @api private\n   */\n  _displayError(exitCode, code, message) {\n    this._outputConfiguration.outputError(`${message}\\n`, this._outputConfiguration.writeErr);\n\n    if (typeof this._showHelpAfterError === 'string') {\n      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\\n`);\n    } else if (this._showHelpAfterError) {\n      this._outputConfiguration.writeErr('\\n');\n\n      this.outputHelp({\n        error: true\n      });\n    }\n\n    this._exit(exitCode, code, message);\n  }\n  /**\n   * Apply any option related environment variables, if option does\n   * not have a value from cli or client code.\n   *\n   * @api private\n   */\n\n\n  _parseOptionsEnv() {\n    this.options.forEach(option => {\n      if (option.envVar && option.envVar in process.env) {\n        const optionKey = option.attributeName(); // Priority check. Do not overwrite cli or options from unknown source (client-code).\n\n        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {\n          if (option.required || option.optional) {\n            // option can take a value\n            // keep very simple, optional always takes value\n            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);\n          } else {\n            // boolean\n            // keep very simple, only care that envVar defined and not the value\n            this.emit(`optionEnv:${option.name()}`);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @api private\n   */\n\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n\n    this._displayError(1, 'commander.missingArgument', message);\n  }\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @api private\n   */\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n\n    this._displayError(1, 'commander.optionMissingArgument', message);\n  }\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @api private\n   */\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n\n    this._displayError(1, 'commander.missingMandatoryOptionValue', message);\n  }\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @api private\n   */\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    let suggestion = '';\n\n    if (flag.startsWith('--') && this._showSuggestionAfterError) {\n      // Looping to pick up the global options too\n      let candidateFlags = [];\n      let command = this;\n\n      do {\n        const moreFlags = command.createHelp().visibleOptions(command).filter(option => option.long).map(option => option.long);\n        candidateFlags = candidateFlags.concat(moreFlags);\n        command = command.parent;\n      } while (command && !command._enablePositionalOptions);\n\n      suggestion = suggestSimilar(flag, candidateFlags);\n    }\n\n    const message = `error: unknown option '${flag}'${suggestion}`;\n\n    this._displayError(1, 'commander.unknownOption', message);\n  }\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @api private\n   */\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n    const expected = this._args.length;\n    const s = expected === 1 ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n\n    this._displayError(1, 'commander.excessArguments', message);\n  }\n\n  /**\n   * Unknown command.\n   *\n   * @api private\n   */\n  unknownCommand() {\n    const unknownName = this.args[0];\n    let suggestion = '';\n\n    if (this._showSuggestionAfterError) {\n      const candidateNames = [];\n      this.createHelp().visibleCommands(this).forEach(command => {\n        candidateNames.push(command.name()); // just visible alias\n\n        if (command.alias()) candidateNames.push(command.alias());\n      });\n      suggestion = suggestSimilar(unknownName, candidateNames);\n    }\n\n    const message = `error: unknown command '${unknownName}'${suggestion}`;\n\n    this._displayError(1, 'commander.unknownCommand', message);\n  }\n\n  /**\n   * Set the program version to `str`.\n   *\n   * This method auto-registers the \"-V, --version\" flag\n   * which will print the version number when passed.\n   *\n   * You can optionally supply the  flags and description to override the defaults.\n   *\n   * @param {string} str\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {this | string} `this` command for chaining, or version string if no arguments\n   */\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this.options.push(versionOption);\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  }\n\n  /**\n   * Set the description to `str`.\n   *\n   * @param {string} [str]\n   * @param {Object} [argsDescription]\n   * @return {string|Command}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n\n    if (argsDescription) {\n      this._argsDescription = argsDescription;\n    }\n\n    return this;\n  }\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {string|Command}\n   */\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    /** @type {Command} */\n\n    let command = this;\n\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n    command._aliases.push(alias);\n\n    return this;\n  }\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {string[]|Command}\n   */\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n    aliases.forEach(alias => this.alias(alias));\n    return this;\n  }\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   */\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this._args.map(arg => {\n        return humanReadableArgName(arg);\n      });\n\n      return [].concat(this.options.length || this._hasHelpOption ? '[options]' : [], this.commands.length ? '[command]' : [], this._args.length ? args : []).join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  }\n\n  /**\n   * Get or set the name of the command\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  }\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();\n    }\n\n    return helper.formatHelp(this, helper);\n  }\n\n  /**\n   * @api private\n   */\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = {\n      error: !!contextOptions.error\n    };\n    let write;\n\n    if (context.error) {\n      write = arg => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = arg => this._outputConfiguration.writeOut(arg);\n    }\n\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n\n    const context = this._getHelpContext(contextOptions);\n\n    getCommandAndParents(this).reverse().forEach(command => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n    let helpInformation = this.helpInformation(context);\n\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n\n      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n\n    context.write(helpInformation);\n    this.emit(this._helpLongFlag); // deprecated\n\n    this.emit('afterHelp', context);\n    getCommandAndParents(this).forEach(command => command.emit('afterAllHelp', context));\n  }\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false to\n   * disable the built-in help option.\n   *\n   * @param {string | boolean} [flags]\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n  helpOption(flags, description) {\n    if (typeof flags === 'boolean') {\n      this._hasHelpOption = flags;\n      return this;\n    }\n\n    this._helpFlags = flags || this._helpFlags;\n    this._helpDescription = description || this._helpDescription;\n    const helpFlags = splitOptionFlags(this._helpFlags);\n    this._helpShortFlag = helpFlags.shortFlag;\n    this._helpLongFlag = helpFlags.longFlag;\n    return this;\n  }\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n\n    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {\n      exitCode = 1;\n    } // message: do not have all displayed text available so only passing placeholder.\n\n\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  }\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {string | Function} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, context => {\n      let helpStr;\n\n      if (typeof text === 'function') {\n        helpStr = text({\n          error: context.error,\n          command: context.command\n        });\n      } else {\n        helpStr = text;\n      } // Ignore falsy value when nothing to output.\n\n\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n\n}\n\n;\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} args - array of options to search for help flags\n * @api private\n */\n\nfunction outputHelpIfRequested(cmd, args) {\n  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);\n\n  if (helpOption) {\n    cmd.outputHelp(); // (Do not have all displayed text available so only passing placeholder.)\n\n    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n  }\n}\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map(arg => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n\n    return arg;\n  });\n}\n/**\n * @param {Command} startCommand\n * @returns {Command[]}\n * @api private\n */\n\n\nfunction getCommandAndParents(startCommand) {\n  const result = [];\n\n  for (let command = startCommand; command; command = command.parent) {\n    result.push(command);\n  }\n\n  return result;\n}\n\nexports.Command = Command;","map":{"version":3,"names":["EventEmitter","require","childProcess","path","fs","Argument","humanReadableArgName","CommanderError","Help","Option","splitOptionFlags","suggestSimilar","Command","constructor","name","commands","options","parent","_allowUnknownOption","_allowExcessArguments","_args","args","rawArgs","processedArgs","_scriptPath","_name","_optionValues","_optionValueSources","_storeOptionsAsProperties","_actionHandler","_executableHandler","_executableFile","_defaultCommandName","_exitCallback","_aliases","_combineFlagAndOptionalValue","_description","_argsDescription","undefined","_enablePositionalOptions","_passThroughOptions","_lifeCycleHooks","_showHelpAfterError","_showSuggestionAfterError","_outputConfiguration","writeOut","str","process","stdout","write","writeErr","stderr","getOutHelpWidth","isTTY","columns","getErrHelpWidth","outputError","_hidden","_hasHelpOption","_helpFlags","_helpDescription","_helpShortFlag","_helpLongFlag","_addImplicitHelpCommand","_helpCommandName","_helpCommandnameAndArgs","_helpCommandDescription","_helpConfiguration","copyInheritedSettings","sourceCommand","command","nameAndArgs","actionOptsOrExecDesc","execOpts","desc","opts","match","cmd","createCommand","description","isDefault","noHelp","hidden","executableFile","arguments","push","createHelp","Object","assign","configureHelp","configuration","configureOutput","showHelpAfterError","displayHelp","showSuggestionAfterError","displaySuggestion","addCommand","Error","checkExplicitNames","commandArray","forEach","createArgument","argument","fn","defaultValue","default","argParser","addArgument","names","split","detail","previousArgument","slice","variadic","required","parseArg","addHelpCommand","enableOrNameAndArgs","_hasImplicitHelpCommand","length","_findCommand","hook","event","listener","allowedValues","includes","join","exitOverride","err","code","_exit","exitCode","message","exit","action","expectedArgsCount","actionArgs","apply","createOption","flags","addOption","option","oname","attributeName","negate","optional","positiveLongFlag","long","replace","_findOption","getOptionValue","setOptionValueWithSource","handleOptionValue","val","invalidValueMessage","valueSource","oldValue","_displayError","_concatValue","on","envVar","_optionEx","config","makeOptionMandatory","mandatory","RegExp","regex","def","m","exec","requiredOption","combineFlagAndOptionalValue","combine","allowUnknownOption","allowUnknown","allowExcessArguments","allowExcess","enablePositionalOptions","positional","passThroughOptions","passThrough","storeOptionsAsProperties","storeAsProperties","key","setOptionValue","value","source","getOptionValueSource","_prepareUserArgs","argv","parseOptions","Array","isArray","versions","electron","from","userArgs","defaultApp","main","filename","basename","extname","parse","_parseCommand","parseAsync","_executeSubCommand","subcommand","launchWithNode","sourceExt","_checkForMissingMandatoryOptions","scriptPath","baseDir","resolvedLink","realpathSync","dirname","e","bin","localBin","existsSync","ext","proc","platform","unshift","incrementNodeInspectorPort","execArgv","concat","spawn","stdio","execPath","signals","signal","killed","kill","exitCallback","bind","executableMissing","wrappedError","nestedError","runningCommand","_dispatchSubcommand","commandName","operands","unknown","subCommand","help","error","_checkNumberOfArguments","arg","i","missingArgument","_excessArguments","_processArguments","myParseArg","previous","parsedValue","declaredArg","index","reduce","processed","v","_chainOrCall","promise","then","_chainOrCallHooks","result","hooks","getCommandAndParents","reverse","filter","hookedCommand","callback","hookDetail","parsed","_parseOptionsEnv","outputHelpIfRequested","checkForUnknownOptions","unknownOption","commandEvent","actionResult","emit","listenerCount","unknownCommand","find","is","anOption","missingMandatoryOptionValue","dest","maybeOption","activeVariadicOption","shift","optionMissingArgument","test","indexOf","len","_versionOptionName","_version","outputHelp","env","optionKey","flag","suggestion","startsWith","candidateFlags","moreFlags","visibleOptions","map","receivedArgs","expected","s","forSubcommand","unknownName","candidateNames","visibleCommands","alias","version","versionOption","argsDescription","aliases","usage","_usage","helpInformation","contextOptions","helper","helpWidth","formatHelp","_getHelpContext","context","deprecatedCallback","Buffer","isBuffer","helpOption","helpFlags","shortFlag","longFlag","addHelpText","position","text","helpEvent","helpStr","debugOption","debugHost","debugPort","parseInt","startCommand","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/commander/lib/command.js"],"sourcesContent":["const EventEmitter = require('events').EventEmitter;\nconst childProcess = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\n\nconst { Argument, humanReadableArgName } = require('./argument.js');\nconst { CommanderError } = require('./error.js');\nconst { Help } = require('./help.js');\nconst { Option, splitOptionFlags } = require('./option.js');\nconst { suggestSimilar } = require('./suggestSimilar');\n\n// @ts-check\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n\n  constructor(name) {\n    super();\n    /** @type {Command[]} */\n    this.commands = [];\n    /** @type {Option[]} */\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    /** @type {Argument[]} */\n    this._args = [];\n    /** @type {string[]} */\n    this.args = []; // cli args with options removed\n    this.rawArgs = [];\n    this.processedArgs = []; // like .args but after custom processing and collecting variadic\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._optionValueSources = {}; // default < config < env < cli\n    this._storeOptionsAsProperties = false;\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._argsDescription = undefined; // legacy\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n    this._lifeCycleHooks = {}; // a hash of arrays\n    /** @type {boolean | string} */\n    this._showHelpAfterError = false;\n    this._showSuggestionAfterError = false;\n\n    // see .configureOutput() for docs\n    this._outputConfiguration = {\n      writeOut: (str) => process.stdout.write(str),\n      writeErr: (str) => process.stderr.write(str),\n      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str)\n    };\n\n    this._hidden = false;\n    this._hasHelpOption = true;\n    this._helpFlags = '-h, --help';\n    this._helpDescription = 'display help for command';\n    this._helpShortFlag = '-h';\n    this._helpLongFlag = '--help';\n    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false\n    this._helpCommandName = 'help';\n    this._helpCommandnameAndArgs = 'help [command]';\n    this._helpCommandDescription = 'display help for command';\n    this._helpConfiguration = {};\n  }\n\n  /**\n   * Copy settings that are useful to have in common across root command and subcommands.\n   *\n   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)\n   *\n   * @param {Command} sourceCommand\n   * @return {Command} returns `this` for executable command\n   */\n  copyInheritedSettings(sourceCommand) {\n    this._outputConfiguration = sourceCommand._outputConfiguration;\n    this._hasHelpOption = sourceCommand._hasHelpOption;\n    this._helpFlags = sourceCommand._helpFlags;\n    this._helpDescription = sourceCommand._helpDescription;\n    this._helpShortFlag = sourceCommand._helpShortFlag;\n    this._helpLongFlag = sourceCommand._helpLongFlag;\n    this._helpCommandName = sourceCommand._helpCommandName;\n    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;\n    this._helpCommandDescription = sourceCommand._helpCommandDescription;\n    this._helpConfiguration = sourceCommand._helpConfiguration;\n    this._exitCallback = sourceCommand._exitCallback;\n    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;\n    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;\n    this._allowExcessArguments = sourceCommand._allowExcessArguments;\n    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;\n    this._showHelpAfterError = sourceCommand._showHelpAfterError;\n    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;\n\n    return this;\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * @example\n   * // Command implemented using action handler (description is supplied separately to `.command`)\n   * program\n   *   .command('clone <source> [destination]')\n   *   .description('clone a repository into a newly created directory')\n   *   .action((source, destination) => {\n   *     console.log('clone command called');\n   *   });\n   *\n   * // Command implemented using separate executable file (description is second parameter to `.command`)\n   * program\n   *   .command('start <service>', 'start named service')\n   *   .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);\n\n    const cmd = this.createCommand(name);\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    if (args) cmd.arguments(args);\n    this.commands.push(cmd);\n    cmd.parent = this;\n    cmd.copyInheritedSettings(this);\n\n    if (desc) return this;\n    return cmd;\n  };\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  };\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  };\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n\n    this._helpConfiguration = configuration;\n    return this;\n  }\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *     // functions to change where being written, stdout and stderr\n   *     writeOut(str)\n   *     writeErr(str)\n   *     // matching functions to specify width for wrapping help\n   *     getOutHelpWidth()\n   *     getErrHelpWidth()\n   *     // functions based on what is being written out\n   *     outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n\n  /**\n   * Display the help or a custom message after an error occurs.\n   *\n   * @param {boolean|string} [displayHelp]\n   * @return {Command} `this` command for chaining\n   */\n  showHelpAfterError(displayHelp = true) {\n    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;\n    this._showHelpAfterError = displayHelp;\n    return this;\n  }\n\n  /**\n   * Display suggestion of similar commands for unknown commands, or options for unknown options.\n   *\n   * @param {boolean} [displaySuggestion]\n   * @return {Command} `this` command for chaining\n   */\n  showSuggestionAfterError(displaySuggestion = true) {\n    this._showSuggestionAfterError = !!displaySuggestion;\n    return this;\n  }\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) throw new Error('Command passed to .addCommand() must have a name');\n\n    // To keep things simple, block automatic name generation for deeply nested executables.\n    // Fail fast and detect when adding rather than later when parsing.\n    function checkExplicitNames(commandArray) {\n      commandArray.forEach((cmd) => {\n        if (cmd._executableHandler && !cmd._executableFile) {\n          throw new Error(`Must specify executableFile for deeply nested executable: ${cmd.name()}`);\n        }\n        checkExplicitNames(cmd.commands);\n      });\n    }\n    checkExplicitNames(cmd.commands);\n\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this.commands.push(cmd);\n    cmd.parent = this;\n    return this;\n  };\n\n  /**\n   * Factory routine to create a new unattached argument.\n   *\n   * See .argument() for creating an attached argument, which uses this routine to\n   * create the argument. You can override createArgument to return a custom argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @return {Argument} new argument\n   */\n\n  createArgument(name, description) {\n    return new Argument(name, description);\n  };\n\n  /**\n   * Define argument syntax for command.\n   *\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @example\n   * program.argument('<input-file>');\n   * program.argument('[output-file]');\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom argument processing function\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n  argument(name, description, fn, defaultValue) {\n    const argument = this.createArgument(name, description);\n    if (typeof fn === 'function') {\n      argument.default(defaultValue).argParser(fn);\n    } else {\n      argument.default(fn);\n    }\n    this.addArgument(argument);\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding multiple at once (without descriptions).\n   *\n   * See also .argument().\n   *\n   * @example\n   * program.arguments('<cmd> [env]');\n   *\n   * @param {string} names\n   * @return {Command} `this` command for chaining\n   */\n\n  arguments(names) {\n    names.split(/ +/).forEach((detail) => {\n      this.argument(detail);\n    });\n    return this;\n  };\n\n  /**\n   * Define argument syntax for command, adding a prepared argument.\n   *\n   * @param {Argument} argument\n   * @return {Command} `this` command for chaining\n   */\n  addArgument(argument) {\n    const previousArgument = this._args.slice(-1)[0];\n    if (previousArgument && previousArgument.variadic) {\n      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);\n    }\n    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {\n      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);\n    }\n    this._args.push(argument);\n    return this;\n  }\n\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   *    addHelpCommand() // force on\n   *    addHelpCommand(false); // force off\n   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   *\n   * @return {Command} `this` command for chaining\n   */\n\n  addHelpCommand(enableOrNameAndArgs, description) {\n    if (enableOrNameAndArgs === false) {\n      this._addImplicitHelpCommand = false;\n    } else {\n      this._addImplicitHelpCommand = true;\n      if (typeof enableOrNameAndArgs === 'string') {\n        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];\n        this._helpCommandnameAndArgs = enableOrNameAndArgs;\n      }\n      this._helpCommandDescription = description || this._helpCommandDescription;\n    }\n    return this;\n  };\n\n  /**\n   * @return {boolean}\n   * @api private\n   */\n\n  _hasImplicitHelpCommand() {\n    if (this._addImplicitHelpCommand === undefined) {\n      return this.commands.length && !this._actionHandler && !this._findCommand('help');\n    }\n    return this._addImplicitHelpCommand;\n  };\n\n  /**\n   * Add hook for life cycle event.\n   *\n   * @param {string} event\n   * @param {Function} listener\n   * @return {Command} `this` command for chaining\n   */\n\n  hook(event, listener) {\n    const allowedValues = ['preAction', 'postAction'];\n    if (!allowedValues.includes(event)) {\n      throw new Error(`Unexpected value for event passed to hook : '${event}'.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    if (this._lifeCycleHooks[event]) {\n      this._lifeCycleHooks[event].push(listener);\n    } else {\n      this._lifeCycleHooks[event] = [listener];\n    }\n    return this;\n  }\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = (err) => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  };\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @api private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  };\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * @example\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *      // do work here\n   *   });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n\n  action(fn) {\n    const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this._args.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      actionArgs.push(this);\n\n      return fn.apply(this, actionArgs);\n    };\n    this._actionHandler = listener;\n    return this;\n  };\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n\n  createOption(flags, description) {\n    return new Option(flags, description);\n  };\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    const oname = option.name();\n    const name = option.attributeName();\n\n    let defaultValue = option.defaultValue;\n\n    // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value\n    if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {\n      // when --no-foo we make sure default is true, unless a --foo option is already defined\n      if (option.negate) {\n        const positiveLongFlag = option.long.replace(/^--no-/, '--');\n        defaultValue = this._findOption(positiveLongFlag) ? this.getOptionValue(name) : true;\n      }\n      // preassign only if we have a default\n      if (defaultValue !== undefined) {\n        this.setOptionValueWithSource(name, defaultValue, 'default');\n      }\n    }\n\n    // register the option\n    this.options.push(option);\n\n    // handler for cli and env supplied values\n    const handleOptionValue = (val, invalidValueMessage, valueSource) => {\n      // Note: using closure to access lots of lexical scoped variables.\n      const oldValue = this.getOptionValue(name);\n\n      // custom processing\n      if (val !== null && option.parseArg) {\n        try {\n          val = option.parseArg(val, oldValue === undefined ? defaultValue : oldValue);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `${invalidValueMessage} ${err.message}`;\n            this._displayError(err.exitCode, err.code, message);\n          }\n          throw err;\n        }\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      }\n\n      // unassigned or boolean value\n      if (typeof oldValue === 'boolean' || typeof oldValue === 'undefined') {\n        // if no value, negate false, and we have a default, then use it!\n        if (val == null) {\n          this.setOptionValueWithSource(name, option.negate ? false : defaultValue || true, valueSource);\n        } else {\n          this.setOptionValueWithSource(name, val, valueSource);\n        }\n      } else if (val !== null) {\n        // reassign\n        this.setOptionValueWithSource(name, option.negate ? false : val, valueSource);\n      }\n    };\n\n    this.on('option:' + oname, (val) => {\n      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;\n      handleOptionValue(val, invalidValueMessage, 'cli');\n    });\n\n    if (option.envVar) {\n      this.on('optionEnv:' + oname, (val) => {\n        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;\n        handleOptionValue(val, invalidValueMessage, 'env');\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @api private\n   */\n  _optionEx(config, flags, description, fn, defaultValue) {\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n\n  /**\n   * Define option with `flags`, `description` and optional\n   * coercion `fn`.\n   *\n   * The `flags` string contains the short and/or long flags,\n   * separated by comma, a pipe or space. The following are all valid\n   * all will output this way when `--help` is used.\n   *\n   *     \"-p, --pepper\"\n   *     \"-p|--pepper\"\n   *     \"-p --pepper\"\n   *\n   * @example\n   * // simple boolean defaulting to undefined\n   * program.option('-p, --pepper', 'add pepper');\n   *\n   * program.pepper\n   * // => undefined\n   *\n   * --pepper\n   * program.pepper\n   * // => true\n   *\n   * // simple boolean defaulting to true (unless non-negated option is also defined)\n   * program.option('-C, --no-cheese', 'remove cheese');\n   *\n   * program.cheese\n   * // => true\n   *\n   * --no-cheese\n   * program.cheese\n   * // => false\n   *\n   * // required argument\n   * program.option('-C, --chdir <path>', 'change the working directory');\n   *\n   * --chdir /tmp\n   * program.chdir\n   * // => \"/tmp\"\n   *\n   * // optional argument\n   * program.option('-c, --cheese [type]', 'add cheese [marble]');\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  option(flags, description, fn, defaultValue) {\n    return this._optionEx({}, flags, description, fn, defaultValue);\n  };\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} [description]\n  * @param {Function|*} [fn] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  */\n\n  requiredOption(flags, description, fn, defaultValue) {\n    return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);\n  };\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * @example\n   * // for `.option('-f,--flag [value]'):\n   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.\n   */\n  combineFlagAndOptionalValue(combine = true) {\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  };\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   */\n  allowUnknownOption(allowUnknown = true) {\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  };\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown\n   * for excess arguments.\n   */\n  allowExcessArguments(allowExcess = true) {\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  };\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {Boolean} [positional=true]\n   */\n  enablePositionalOptions(positional = true) {\n    this._enablePositionalOptions = !!positional;\n    return this;\n  };\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {Boolean} [passThrough=true]\n   * for unknown options.\n   */\n  passThroughOptions(passThrough = true) {\n    this._passThroughOptions = !!passThrough;\n    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {\n      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');\n    }\n    return this;\n  };\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} [storeAsProperties=true]\n    * @return {Command} `this` command for chaining\n    */\n\n  storeOptionsAsProperties(storeAsProperties = true) {\n    this._storeOptionsAsProperties = !!storeAsProperties;\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    return this;\n  };\n\n  /**\n   * Retrieve option value.\n   *\n   * @param {string} key\n   * @return {Object} value\n   */\n\n  getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  };\n\n  /**\n   * Store option value.\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @return {Command} `this` command for chaining\n   */\n\n  setOptionValue(key, value) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n    return this;\n  };\n\n  /**\n   * Store option value and where the value came from.\n    *\n    * @param {string} key\n    * @param {Object} value\n    * @param {string} source - expected values are default/config/env/cli\n    * @return {Command} `this` command for chaining\n    */\n\n  setOptionValueWithSource(key, value, source) {\n    this.setOptionValue(key, value);\n    this._optionValueSources[key] = source;\n    return this;\n  }\n\n  /**\n    * Get source of option value.\n    * Expected values are default | config | env | cli\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n  getOptionValueSource(key) {\n    return this._optionValueSources[key];\n  };\n\n  /**\n   * Get user arguments implied or explicit arguments.\n   * Side-effects: set _scriptPath if args included application, and use that to set implicit command name.\n   *\n   * @api private\n   */\n\n  _prepareUserArgs(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // Default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n      // @ts-ignore: unknown property\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n    this.rawArgs = argv.slice();\n\n    // make it a little easier for callers by supporting various argv conventions\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore: unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n    if (!this._scriptPath && require.main) {\n      this._scriptPath = require.main.filename;\n    }\n\n    // Guess name, used in usage in help.\n    this._name = this._name || (this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath)));\n\n    return userArgs;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * program.parse(process.argv);\n   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n  parse(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    this._parseCommand([], userArgs);\n\n    return this;\n  };\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * await program.parseAsync(process.argv);\n   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n\n  async parseAsync(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    await this._parseCommand([], userArgs);\n\n    return this;\n  };\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @api private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n\n    // Want the entry script as the reference for command name and directory for searching for other files.\n    let scriptPath = this._scriptPath;\n    // Fallback in case not set, due to how Command created or called.\n    if (!scriptPath && require.main) {\n      scriptPath = require.main.filename;\n    }\n\n    let baseDir;\n    try {\n      const resolvedLink = fs.realpathSync(scriptPath);\n      baseDir = path.dirname(resolvedLink);\n    } catch (e) {\n      baseDir = '.'; // dummy, probably not going to find executable!\n    }\n\n    // name of the subcommand, like `pm-install`\n    let bin = path.basename(scriptPath, path.extname(scriptPath)) + '-' + subcommand._name;\n    if (subcommand._executableFile) {\n      bin = subcommand._executableFile;\n    }\n\n    const localBin = path.join(baseDir, bin);\n    if (fs.existsSync(localBin)) {\n      // prefer local `./<bin>` to bin in the $PATH\n      bin = localBin;\n    } else {\n      // Look for source files.\n      sourceExt.forEach((ext) => {\n        if (fs.existsSync(`${localBin}${ext}`)) {\n          bin = `${localBin}${ext}`;\n        }\n      });\n    }\n    launchWithNode = sourceExt.includes(path.extname(bin));\n\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(bin);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });\n      } else {\n        proc = childProcess.spawn(bin, args, { stdio: 'inherit' });\n      }\n    } else {\n      args.unshift(bin);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });\n    }\n\n    const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n    signals.forEach((signal) => {\n      // @ts-ignore\n      process.on(signal, () => {\n        if (proc.killed === false && proc.exitCode === null) {\n          proc.kill(signal);\n        }\n      });\n    });\n\n    // By default terminate process when spawned process terminates.\n    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n    const exitCallback = this._exitCallback;\n    if (!exitCallback) {\n      proc.on('close', process.exit.bind(process));\n    } else {\n      proc.on('close', () => {\n        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n      });\n    }\n    proc.on('error', (err) => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableMissing = `'${bin}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name`;\n        throw new Error(executableMissing);\n      // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${bin}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  };\n\n  /**\n   * @api private\n   */\n\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this.help({ error: true });\n\n    if (subCommand._executableHandler) {\n      this._executeSubCommand(subCommand, operands.concat(unknown));\n    } else {\n      return subCommand._parseCommand(operands, unknown);\n    }\n  };\n\n  /**\n   * Check this.args against expected this._args.\n   *\n   * @api private\n   */\n\n  _checkNumberOfArguments() {\n    // too few\n    this._args.forEach((arg, i) => {\n      if (arg.required && this.args[i] == null) {\n        this.missingArgument(arg.name());\n      }\n    });\n    // too many\n    if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {\n      return;\n    }\n    if (this.args.length > this._args.length) {\n      this._excessArguments(this.args);\n    }\n  };\n\n  /**\n   * Process this.args using this._args and save as this.processedArgs!\n   *\n   * @api private\n   */\n\n  _processArguments() {\n    const myParseArg = (argument, value, previous) => {\n      // Extra processing for nice error message on parsing failure.\n      let parsedValue = value;\n      if (value !== null && argument.parseArg) {\n        try {\n          parsedValue = argument.parseArg(value, previous);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;\n            this._displayError(err.exitCode, err.code, message);\n          }\n          throw err;\n        }\n      }\n      return parsedValue;\n    };\n\n    this._checkNumberOfArguments();\n\n    const processedArgs = [];\n    this._args.forEach((declaredArg, index) => {\n      let value = declaredArg.defaultValue;\n      if (declaredArg.variadic) {\n        // Collect together remaining arguments for passing together as an array.\n        if (index < this.args.length) {\n          value = this.args.slice(index);\n          if (declaredArg.parseArg) {\n            value = value.reduce((processed, v) => {\n              return myParseArg(declaredArg, v, processed);\n            }, declaredArg.defaultValue);\n          }\n        } else if (value === undefined) {\n          value = [];\n        }\n      } else if (index < this.args.length) {\n        value = this.args[index];\n        if (declaredArg.parseArg) {\n          value = myParseArg(declaredArg, value, declaredArg.defaultValue);\n        }\n      }\n      processedArgs[index] = value;\n    });\n    this.processedArgs = processedArgs;\n  }\n\n  /**\n   * Once we have a promise we chain, but call synchronously until then.\n   *\n   * @param {Promise|undefined} promise\n   * @param {Function} fn\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCall(promise, fn) {\n    // thenable\n    if (promise && promise.then && typeof promise.then === 'function') {\n      // already have a promise, chain callback\n      return promise.then(() => fn());\n    }\n    // callback might return a promise\n    return fn();\n  }\n\n  /**\n   *\n   * @param {Promise|undefined} promise\n   * @param {string} event\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCallHooks(promise, event) {\n    let result = promise;\n    const hooks = [];\n    getCommandAndParents(this)\n      .reverse()\n      .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)\n      .forEach(hookedCommand => {\n        hookedCommand._lifeCycleHooks[event].forEach((callback) => {\n          hooks.push({ hookedCommand, callback });\n        });\n      });\n    if (event === 'postAction') {\n      hooks.reverse();\n    }\n\n    hooks.forEach((hookDetail) => {\n      result = this._chainOrCall(result, () => {\n        return hookDetail.callback(hookDetail.hookedCommand, this);\n      });\n    });\n    return result;\n  }\n\n  /**\n   * Process arguments in context of this command.\n   * Returns action result, in case it is a promise.\n   *\n   * @api private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    }\n    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {\n      if (operands.length === 1) {\n        this.help();\n      }\n      return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);\n    }\n    if (this._defaultCommandName) {\n      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command\n      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    }\n    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n      // probably missing subcommand and no handler, user needs help (and exit)\n      this.help({ error: true });\n    }\n\n    outputHelpIfRequested(this, parsed.unknown);\n    this._checkForMissingMandatoryOptions();\n\n    // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n    const checkForUnknownOptions = () => {\n      if (parsed.unknown.length > 0) {\n        this.unknownOption(parsed.unknown[0]);\n      }\n    };\n\n    const commandEvent = `command:${this.name()}`;\n    if (this._actionHandler) {\n      checkForUnknownOptions();\n      this._processArguments();\n\n      let actionResult;\n      actionResult = this._chainOrCallHooks(actionResult, 'preAction');\n      actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));\n      if (this.parent) this.parent.emit(commandEvent, operands, unknown); // legacy\n      actionResult = this._chainOrCallHooks(actionResult, 'postAction');\n      return actionResult;\n    }\n    if (this.parent && this.parent.listenerCount(commandEvent)) {\n      checkForUnknownOptions();\n      this._processArguments();\n      this.parent.emit(commandEvent, operands, unknown); // legacy\n    } else if (operands.length) {\n      if (this._findCommand('*')) { // legacy default command\n        return this._dispatchSubcommand('*', operands, unknown);\n      }\n      if (this.listenerCount('command:*')) {\n        // skip option check, emit event for possible misspelling suggestion\n        this.emit('command:*', operands, unknown);\n      } else if (this.commands.length) {\n        this.unknownCommand();\n      } else {\n        checkForUnknownOptions();\n        this._processArguments();\n      }\n    } else if (this.commands.length) {\n      checkForUnknownOptions();\n      // This command has subcommands and nothing hooked up at this level, so display help (and exit).\n      this.help({ error: true });\n    } else {\n      checkForUnknownOptions();\n      this._processArguments();\n      // fall through for caller to handle after calling .parse()\n    }\n  };\n\n  /**\n   * Find matching command.\n   *\n   * @api private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  };\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @api private\n   */\n\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  };\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Lazy calling after checking for help flags from leaf subcommand.\n   *\n   * @api private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    for (let cmd = this; cmd; cmd = cmd.parent) {\n      cmd.options.forEach((anOption) => {\n        if (anOption.mandatory && (cmd.getOptionValue(anOption.attributeName()) === undefined)) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    }\n  };\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *     argv => operands, unknown\n   *     --known kkk op => [op], []\n   *     op --known kkk => [op], []\n   *     sub --unknown uuu op => [sub], [--unknown uuu op]\n   *     sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {String[]} argv\n   * @return {{operands: String[], unknown: String[]}}\n   */\n\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    // parse options\n    let activeVariadicOption = null;\n    while (args.length) {\n      const arg = args.shift();\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else { // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n      if (maybeOption(arg)) {\n        dest = unknown;\n      }\n\n      // If using positionalOptions, stop processing our options at subcommand.\n      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      }\n\n      // If using passThroughOptions, stop processing options at first command-argument.\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n\n    return { operands, unknown };\n  };\n\n  /**\n   * Return an object containing options as key-value pairs\n   *\n   * @return {Object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n\n    return this._optionValues;\n  };\n\n  /**\n   * Internal bottleneck for handling of parsing errors.\n   *\n   * @api private\n   */\n  _displayError(exitCode, code, message) {\n    this._outputConfiguration.outputError(`${message}\\n`, this._outputConfiguration.writeErr);\n    if (typeof this._showHelpAfterError === 'string') {\n      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\\n`);\n    } else if (this._showHelpAfterError) {\n      this._outputConfiguration.writeErr('\\n');\n      this.outputHelp({ error: true });\n    }\n    this._exit(exitCode, code, message);\n  }\n\n  /**\n   * Apply any option related environment variables, if option does\n   * not have a value from cli or client code.\n   *\n   * @api private\n   */\n  _parseOptionsEnv() {\n    this.options.forEach((option) => {\n      if (option.envVar && option.envVar in process.env) {\n        const optionKey = option.attributeName();\n        // Priority check. Do not overwrite cli or options from unknown source (client-code).\n        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {\n          if (option.required || option.optional) { // option can take a value\n            // keep very simple, optional always takes value\n            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);\n          } else { // boolean\n            // keep very simple, only care that envVar defined and not the value\n            this.emit(`optionEnv:${option.name()}`);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @api private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    this._displayError(1, 'commander.missingArgument', message);\n  };\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n    this._displayError(1, 'commander.optionMissingArgument', message);\n  };\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    this._displayError(1, 'commander.missingMandatoryOptionValue', message);\n  };\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @api private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    let suggestion = '';\n\n    if (flag.startsWith('--') && this._showSuggestionAfterError) {\n      // Looping to pick up the global options too\n      let candidateFlags = [];\n      let command = this;\n      do {\n        const moreFlags = command.createHelp().visibleOptions(command)\n          .filter(option => option.long)\n          .map(option => option.long);\n        candidateFlags = candidateFlags.concat(moreFlags);\n        command = command.parent;\n      } while (command && !command._enablePositionalOptions);\n      suggestion = suggestSimilar(flag, candidateFlags);\n    }\n\n    const message = `error: unknown option '${flag}'${suggestion}`;\n    this._displayError(1, 'commander.unknownOption', message);\n  };\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @api private\n   */\n\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n\n    const expected = this._args.length;\n    const s = (expected === 1) ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n    this._displayError(1, 'commander.excessArguments', message);\n  };\n\n  /**\n   * Unknown command.\n   *\n   * @api private\n   */\n\n  unknownCommand() {\n    const unknownName = this.args[0];\n    let suggestion = '';\n\n    if (this._showSuggestionAfterError) {\n      const candidateNames = [];\n      this.createHelp().visibleCommands(this).forEach((command) => {\n        candidateNames.push(command.name());\n        // just visible alias\n        if (command.alias()) candidateNames.push(command.alias());\n      });\n      suggestion = suggestSimilar(unknownName, candidateNames);\n    }\n\n    const message = `error: unknown command '${unknownName}'${suggestion}`;\n    this._displayError(1, 'commander.unknownCommand', message);\n  };\n\n  /**\n   * Set the program version to `str`.\n   *\n   * This method auto-registers the \"-V, --version\" flag\n   * which will print the version number when passed.\n   *\n   * You can optionally supply the  flags and description to override the defaults.\n   *\n   * @param {string} str\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {this | string} `this` command for chaining, or version string if no arguments\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this.options.push(versionOption);\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  };\n\n  /**\n   * Set the description to `str`.\n   *\n   * @param {string} [str]\n   * @param {Object} [argsDescription]\n   * @return {string|Command}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n    if (argsDescription) {\n      this._argsDescription = argsDescription;\n    }\n    return this;\n  };\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {string|Command}\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    /** @type {Command} */\n    let command = this;\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n    command._aliases.push(alias);\n    return this;\n  };\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {string[]|Command}\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n\n    aliases.forEach((alias) => this.alias(alias));\n    return this;\n  };\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this._args.map((arg) => {\n        return humanReadableArgName(arg);\n      });\n      return [].concat(\n        (this.options.length || this._hasHelpOption ? '[options]' : []),\n        (this.commands.length ? '[command]' : []),\n        (this._args.length ? args : [])\n      ).join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  };\n\n  /**\n   * Get or set the name of the command\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  };\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();\n    }\n    return helper.formatHelp(this, helper);\n  };\n\n  /**\n   * @api private\n   */\n\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = { error: !!contextOptions.error };\n    let write;\n    if (context.error) {\n      write = (arg) => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = (arg) => this._outputConfiguration.writeOut(arg);\n    }\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n    const context = this._getHelpContext(contextOptions);\n\n    getCommandAndParents(this).reverse().forEach(command => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n\n    let helpInformation = this.helpInformation(context);\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n    context.write(helpInformation);\n\n    this.emit(this._helpLongFlag); // deprecated\n    this.emit('afterHelp', context);\n    getCommandAndParents(this).forEach(command => command.emit('afterAllHelp', context));\n  };\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false to\n   * disable the built-in help option.\n   *\n   * @param {string | boolean} [flags]\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n\n  helpOption(flags, description) {\n    if (typeof flags === 'boolean') {\n      this._hasHelpOption = flags;\n      return this;\n    }\n    this._helpFlags = flags || this._helpFlags;\n    this._helpDescription = description || this._helpDescription;\n\n    const helpFlags = splitOptionFlags(this._helpFlags);\n    this._helpShortFlag = helpFlags.shortFlag;\n    this._helpLongFlag = helpFlags.longFlag;\n\n    return this;\n  };\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {\n      exitCode = 1;\n    }\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  };\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {string | Function} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, (context) => {\n      let helpStr;\n      if (typeof text === 'function') {\n        helpStr = text({ error: context.error, command: context.command });\n      } else {\n        helpStr = text;\n      }\n      // Ignore falsy value when nothing to output.\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n};\n\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} args - array of options to search for help flags\n * @api private\n */\n\nfunction outputHelpIfRequested(cmd, args) {\n  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);\n  if (helpOption) {\n    cmd.outputHelp();\n    // (Do not have all displayed text available so only passing placeholder.)\n    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n  }\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\n\n/**\n * @param {Command} startCommand\n * @returns {Command[]}\n * @api private\n */\n\nfunction getCommandAndParents(startCommand) {\n  const result = [];\n  for (let command = startCommand; command; command = command.parent) {\n    result.push(command);\n  }\n  return result;\n}\n\nexports.Command = Command;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}