{"ast":null,"code":"'use strict';\n\nconst order = {\n  '*': 0,\n  '/': 0,\n  '+': 1,\n  '-': 1\n};\n/**\n * @param {number} value\n * @param {number | false} prec\n */\n\nfunction round(value, prec) {\n  if (prec !== false) {\n    const precision = Math.pow(10, prec);\n    return Math.round(value * precision) / precision;\n  }\n\n  return value;\n}\n/**\n * @param {number | false} prec\n * @param {import('../parser').CalcNode} node\n *\n * @return {string}\n */\n\n\nfunction stringify(node, prec) {\n  switch (node.type) {\n    case 'MathExpression':\n      {\n        const {\n          left,\n          right,\n          operator: op\n        } = node;\n        let str = '';\n\n        if (left.type === 'MathExpression' && order[op] < order[left.operator]) {\n          str += `(${stringify(left, prec)})`;\n        } else {\n          str += stringify(left, prec);\n        }\n\n        str += order[op] ? ` ${node.operator} ` : node.operator;\n\n        if (right.type === 'MathExpression' && order[op] < order[right.operator]) {\n          str += `(${stringify(right, prec)})`;\n        } else {\n          str += stringify(right, prec);\n        }\n\n        return str;\n      }\n\n    case 'Number':\n      return round(node.value, prec).toString();\n\n    case 'Function':\n      return node.value.toString();\n\n    case 'ParenthesizedExpression':\n      return `(${stringify(node.content, prec)})`;\n\n    default:\n      return round(node.value, prec) + node.unit;\n  }\n}\n/**\n * @param {string} calc\n * @param {import('../parser').CalcNode} node\n * @param {string} originalValue\n * @param {{precision: number | false, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n *\n * @returns {string}\n */\n\n\nmodule.exports = function (calc, node, originalValue, options, result, item) {\n  let str = stringify(node, options.precision);\n  const shouldPrintCalc = node.type === 'MathExpression' || node.type === 'Function';\n\n  if (shouldPrintCalc) {\n    // if calc expression couldn't be resolved to a single value, re-wrap it as\n    // a calc()\n    str = `${calc}(${str})`; // if the warnWhenCannotResolve option is on, inform the user that the calc\n    // expression could not be resolved to a single value\n\n    if (options.warnWhenCannotResolve) {\n      result.warn('Could not reduce expression: ' + originalValue, {\n        plugin: 'postcss-calc',\n        node: item\n      });\n    }\n  }\n\n  return str;\n};","map":{"version":3,"names":["order","round","value","prec","precision","Math","pow","stringify","node","type","left","right","operator","op","str","toString","content","unit","module","exports","calc","originalValue","options","result","item","shouldPrintCalc","warnWhenCannotResolve","warn","plugin"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-calc/src/lib/stringifier.js"],"sourcesContent":["'use strict';\nconst order = {\n  '*': 0,\n  '/': 0,\n  '+': 1,\n  '-': 1,\n};\n\n/**\n * @param {number} value\n * @param {number | false} prec\n */\nfunction round(value, prec) {\n  if (prec !== false) {\n    const precision = Math.pow(10, prec);\n    return Math.round(value * precision) / precision;\n  }\n  return value;\n}\n\n/**\n * @param {number | false} prec\n * @param {import('../parser').CalcNode} node\n *\n * @return {string}\n */\nfunction stringify(node, prec) {\n  switch (node.type) {\n    case 'MathExpression': {\n      const { left, right, operator: op } = node;\n      let str = '';\n      if (left.type === 'MathExpression' && order[op] < order[left.operator]) {\n        str += `(${stringify(left, prec)})`;\n      } else {\n        str += stringify(left, prec);\n      }\n\n      str += order[op] ? ` ${node.operator} ` : node.operator;\n\n      if (\n        right.type === 'MathExpression' &&\n        order[op] < order[right.operator]\n      ) {\n        str += `(${stringify(right, prec)})`;\n      } else {\n        str += stringify(right, prec);\n      }\n\n      return str;\n    }\n    case 'Number':\n      return round(node.value, prec).toString();\n    case 'Function':\n      return node.value.toString();\n    case 'ParenthesizedExpression':\n      return `(${stringify(node.content, prec)})`;\n    default:\n      return round(node.value, prec) + node.unit;\n  }\n}\n\n/**\n * @param {string} calc\n * @param {import('../parser').CalcNode} node\n * @param {string} originalValue\n * @param {{precision: number | false, warnWhenCannotResolve: boolean}} options\n * @param {import(\"postcss\").Result} result\n * @param {import(\"postcss\").ChildNode} item\n *\n * @returns {string}\n */\nmodule.exports = function (calc, node, originalValue, options, result, item) {\n  let str = stringify(node, options.precision);\n\n  const shouldPrintCalc =\n    node.type === 'MathExpression' || node.type === 'Function';\n\n  if (shouldPrintCalc) {\n    // if calc expression couldn't be resolved to a single value, re-wrap it as\n    // a calc()\n    str = `${calc}(${str})`;\n\n    // if the warnWhenCannotResolve option is on, inform the user that the calc\n    // expression could not be resolved to a single value\n    if (options.warnWhenCannotResolve) {\n      result.warn('Could not reduce expression: ' + originalValue, {\n        plugin: 'postcss-calc',\n        node: item,\n      });\n    }\n  }\n  return str;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}