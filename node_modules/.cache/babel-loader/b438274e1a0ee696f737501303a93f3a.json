{"ast":null,"code":"/**\n * @fileoverview Mocha/Jest test wrapper\n * @author Ilya Volodin\n */\n\"use strict\";\n/* globals describe, it -- Mocha globals */\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n      util = require(\"util\"),\n      equal = require(\"fast-deep-equal\"),\n      Traverser = require(\"../shared/traverser\"),\n      {\n  getRuleOptionsSchema\n} = require(\"../config/flat-config-helpers\"),\n      {\n  Linter,\n  SourceCodeFixer,\n  interpolate\n} = require(\"../linter\");\n\nconst {\n  FlatConfigArray\n} = require(\"../config/flat-config-array\");\n\nconst {\n  defaultConfig\n} = require(\"../config/default-config\");\n\nconst ajv = require(\"../shared/ajv\")({\n  strictDefaults: true\n});\n\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\n\nconst {\n  SourceCode\n} = require(\"../source-code\");\n\nconst {\n  ConfigArraySymbol\n} = require(\"@humanwhocodes/config-array\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").Parser} Parser */\n\n/** @typedef {import(\"../shared/types\").LanguageOptions} LanguageOptions */\n\n/* eslint-disable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n\n/**\n * A test case that is expected to pass lint.\n * @typedef {Object} ValidTestCase\n * @property {string} [name] Name for the test case.\n * @property {string} code Code for the test case.\n * @property {any[]} [options] Options for the test case.\n * @property {LanguageOptions} [languageOptions] The language options to use in the test case.\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\n */\n\n/**\n * A test case that is expected to fail lint.\n * @typedef {Object} InvalidTestCase\n * @property {string} [name] Name for the test case.\n * @property {string} code Code for the test case.\n * @property {number | Array<TestCaseError | string | RegExp>} errors Expected errors.\n * @property {string | null} [output] The expected code after autofixes are applied. If set to `null`, the test runner will assert that no autofix is suggested.\n * @property {any[]} [options] Options for the test case.\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\n * @property {LanguageOptions} [languageOptions] The language options to use in the test case.\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\n */\n\n/**\n * A description of a reported error used in a rule tester test.\n * @typedef {Object} TestCaseError\n * @property {string | RegExp} [message] Message.\n * @property {string} [messageId] Message ID.\n * @property {string} [type] The type of the reported AST node.\n * @property {{ [name: string]: string }} [data] The data used to fill the message template.\n * @property {number} [line] The 1-based line number of the reported start location.\n * @property {number} [column] The 1-based column number of the reported start location.\n * @property {number} [endLine] The 1-based line number of the reported end location.\n * @property {number} [endColumn] The 1-based column number of the reported end location.\n */\n\n/* eslint-enable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n//------------------------------------------------------------------------------\n// Private Members\n//------------------------------------------------------------------------------\n\n/*\n * testerDefaultConfig must not be modified as it allows to reset the tester to\n * the initial default configuration\n */\n\n\nconst testerDefaultConfig = {\n  rules: {}\n};\n/*\n * RuleTester uses this config as its default. This can be overwritten via\n * setDefaultConfig().\n */\n\nlet sharedDefaultConfig = {\n  rules: {}\n};\n/*\n * List every parameters possible on a test case that are not related to eslint\n * configuration\n */\n\nconst RuleTesterParameters = [\"name\", \"code\", \"filename\", \"options\", \"errors\", \"output\", \"only\"];\n/*\n * All allowed property names in error objects.\n */\n\nconst errorObjectParameters = new Set([\"message\", \"messageId\", \"data\", \"type\", \"line\", \"column\", \"endLine\", \"endColumn\", \"suggestions\"]);\nconst friendlyErrorObjectParameterList = `[${[...errorObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\n/*\n * All allowed property names in suggestion objects.\n */\n\nconst suggestionObjectParameters = new Set([\"desc\", \"messageId\", \"data\", \"output\"]);\nconst friendlySuggestionObjectParameterList = `[${[...suggestionObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\nconst hasOwnProperty = Function.call.bind(Object.hasOwnProperty);\n/**\n * Clones a given value deeply.\n * Note: This ignores `parent` property.\n * @param {any} x A value to clone.\n * @returns {any} A cloned value.\n */\n\nfunction cloneDeeplyExcludesParent(x) {\n  if (typeof x === \"object\" && x !== null) {\n    if (Array.isArray(x)) {\n      return x.map(cloneDeeplyExcludesParent);\n    }\n\n    const retv = {};\n\n    for (const key in x) {\n      if (key !== \"parent\" && hasOwnProperty(x, key)) {\n        retv[key] = cloneDeeplyExcludesParent(x[key]);\n      }\n    }\n\n    return retv;\n  }\n\n  return x;\n}\n/**\n * Freezes a given value deeply.\n * @param {any} x A value to freeze.\n * @returns {void}\n */\n\n\nfunction freezeDeeply(x) {\n  if (typeof x === \"object\" && x !== null) {\n    if (Array.isArray(x)) {\n      x.forEach(freezeDeeply);\n    } else {\n      for (const key in x) {\n        if (key !== \"parent\" && hasOwnProperty(x, key)) {\n          freezeDeeply(x[key]);\n        }\n      }\n    }\n\n    Object.freeze(x);\n  }\n}\n/**\n * Replace control characters by `\\u00xx` form.\n * @param {string} text The text to sanitize.\n * @returns {string} The sanitized text.\n */\n\n\nfunction sanitize(text) {\n  if (typeof text !== \"string\") {\n    return \"\";\n  }\n\n  return text.replace(/[\\u0000-\\u0009\\u000b-\\u001a]/gu, // eslint-disable-line no-control-regex -- Escaping controls\n  c => `\\\\u${c.codePointAt(0).toString(16).padStart(4, \"0\")}`);\n}\n/**\n * Define `start`/`end` properties as throwing error.\n * @param {string} objName Object name used for error messages.\n * @param {ASTNode} node The node to define.\n * @returns {void}\n */\n\n\nfunction defineStartEndAsError(objName, node) {\n  Object.defineProperties(node, {\n    start: {\n      get() {\n        throw new Error(`Use ${objName}.range[0] instead of ${objName}.start`);\n      },\n\n      configurable: true,\n      enumerable: false\n    },\n    end: {\n      get() {\n        throw new Error(`Use ${objName}.range[1] instead of ${objName}.end`);\n      },\n\n      configurable: true,\n      enumerable: false\n    }\n  });\n}\n/**\n * Define `start`/`end` properties of all nodes of the given AST as throwing error.\n * @param {ASTNode} ast The root node to errorize `start`/`end` properties.\n * @param {Object} [visitorKeys] Visitor keys to be used for traversing the given ast.\n * @returns {void}\n */\n\n\nfunction defineStartEndAsErrorInTree(ast, visitorKeys) {\n  Traverser.traverse(ast, {\n    visitorKeys,\n    enter: defineStartEndAsError.bind(null, \"node\")\n  });\n  ast.tokens.forEach(defineStartEndAsError.bind(null, \"token\"));\n  ast.comments.forEach(defineStartEndAsError.bind(null, \"token\"));\n}\n/**\n * Wraps the given parser in order to intercept and modify return values from the `parse` and `parseForESLint` methods, for test purposes.\n * In particular, to modify ast nodes, tokens and comments to throw on access to their `start` and `end` properties.\n * @param {Parser} parser Parser object.\n * @returns {Parser} Wrapped parser object.\n */\n\n\nfunction wrapParser(parser) {\n  if (typeof parser.parseForESLint === \"function\") {\n    return {\n      [parserSymbol]: parser,\n\n      parseForESLint() {\n        const ret = parser.parseForESLint(...arguments);\n        defineStartEndAsErrorInTree(ret.ast, ret.visitorKeys);\n        return ret;\n      }\n\n    };\n  }\n\n  return {\n    [parserSymbol]: parser,\n\n    parse() {\n      const ast = parser.parse(...arguments);\n      defineStartEndAsErrorInTree(ast);\n      return ast;\n    }\n\n  };\n}\n/**\n * Function to replace `SourceCode.prototype.getComments`.\n * @returns {void}\n * @throws {Error} Deprecation message.\n */\n\n\nfunction getCommentsDeprecation() {\n  throw new Error(\"`SourceCode#getComments()` is deprecated and will be removed in a future major version. Use `getCommentsBefore()`, `getCommentsAfter()`, and `getCommentsInside()` instead.\");\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n// default separators for testing\n\n\nconst DESCRIBE = Symbol(\"describe\");\nconst IT = Symbol(\"it\");\nconst IT_ONLY = Symbol(\"itOnly\");\n/**\n * This is `it` default handler if `it` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @throws {Error} Any error upon execution of `method`.\n * @returns {any} Returned value of `method`.\n */\n\nfunction itDefaultHandler(text, method) {\n  try {\n    return method.call(this);\n  } catch (err) {\n    if (err instanceof assert.AssertionError) {\n      err.message += ` (${util.inspect(err.actual)} ${err.operator} ${util.inspect(err.expected)})`;\n    }\n\n    throw err;\n  }\n}\n/**\n * This is `describe` default handler if `describe` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @returns {any} Returned value of `method`.\n */\n\n\nfunction describeDefaultHandler(text, method) {\n  return method.call(this);\n}\n/**\n * Mocha test wrapper.\n */\n\n\nclass FlatRuleTester {\n  /**\n   * Creates a new instance of RuleTester.\n   * @param {Object} [testerConfig] Optional, extra configuration for the tester\n   */\n  constructor() {\n    let testerConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /**\n     * The configuration to use for this tester. Combination of the tester\n     * configuration and the default configuration.\n     * @type {Object}\n     */\n    this.testerConfig = [sharedDefaultConfig, testerConfig, {\n      rules: {\n        \"rule-tester/validate-ast\": \"error\"\n      }\n    }];\n    this.linter = new Linter({\n      configType: \"flat\"\n    });\n  }\n  /**\n   * Set the configuration to use for all future tests\n   * @param {Object} config the configuration to use.\n   * @throws {TypeError} If non-object config.\n   * @returns {void}\n   */\n\n\n  static setDefaultConfig(config) {\n    if (typeof config !== \"object\") {\n      throw new TypeError(\"FlatRuleTester.setDefaultConfig: config must be an object\");\n    }\n\n    sharedDefaultConfig = config; // Make sure the rules object exists since it is assumed to exist later\n\n    sharedDefaultConfig.rules = sharedDefaultConfig.rules || {};\n  }\n  /**\n   * Get the current configuration used for all tests\n   * @returns {Object} the current configuration\n   */\n\n\n  static getDefaultConfig() {\n    return sharedDefaultConfig;\n  }\n  /**\n   * Reset the configuration to the initial configuration of the tester removing\n   * any changes made until now.\n   * @returns {void}\n   */\n\n\n  static resetDefaultConfig() {\n    sharedDefaultConfig = {\n      rules: { ...testerDefaultConfig.rules\n      }\n    };\n  }\n  /*\n   * If people use `mocha test.js --watch` command, `describe` and `it` function\n   * instances are different for each execution. So `describe` and `it` should get fresh instance\n   * always.\n   */\n\n\n  static get describe() {\n    return this[DESCRIBE] || (typeof describe === \"function\" ? describe : describeDefaultHandler);\n  }\n\n  static set describe(value) {\n    this[DESCRIBE] = value;\n  }\n\n  static get it() {\n    return this[IT] || (typeof it === \"function\" ? it : itDefaultHandler);\n  }\n\n  static set it(value) {\n    this[IT] = value;\n  }\n  /**\n   * Adds the `only` property to a test to run it in isolation.\n   * @param {string | ValidTestCase | InvalidTestCase} item A single test to run by itself.\n   * @returns {ValidTestCase | InvalidTestCase} The test with `only` set.\n   */\n\n\n  static only(item) {\n    if (typeof item === \"string\") {\n      return {\n        code: item,\n        only: true\n      };\n    }\n\n    return { ...item,\n      only: true\n    };\n  }\n\n  static get itOnly() {\n    if (typeof this[IT_ONLY] === \"function\") {\n      return this[IT_ONLY];\n    }\n\n    if (typeof this[IT] === \"function\" && typeof this[IT].only === \"function\") {\n      return Function.bind.call(this[IT].only, this[IT]);\n    }\n\n    if (typeof it === \"function\" && typeof it.only === \"function\") {\n      return Function.bind.call(it.only, it);\n    }\n\n    if (typeof this[DESCRIBE] === \"function\" || typeof this[IT] === \"function\") {\n      throw new Error(\"Set `RuleTester.itOnly` to use `only` with a custom test framework.\\n\" + \"See https://eslint.org/docs/developer-guide/nodejs-api#customizing-ruletester for more.\");\n    }\n\n    if (typeof it === \"function\") {\n      throw new Error(\"The current test framework does not support exclusive tests with `only`.\");\n    }\n\n    throw new Error(\"To use `only`, use RuleTester with a test framework that provides `it.only()` like Mocha.\");\n  }\n\n  static set itOnly(value) {\n    this[IT_ONLY] = value;\n  }\n  /**\n   * Adds a new rule test to execute.\n   * @param {string} ruleName The name of the rule to run.\n   * @param {Function} rule The rule to test.\n   * @param {{\n   *   valid: (ValidTestCase | string)[],\n   *   invalid: InvalidTestCase[]\n   * }} test The collection of tests to run.\n   * @throws {TypeError|Error} If non-object `test`, or if a required\n   * scenario of the given type is missing.\n   * @returns {void}\n   */\n\n\n  run(ruleName, rule, test) {\n    const testerConfig = this.testerConfig,\n          requiredScenarios = [\"valid\", \"invalid\"],\n          scenarioErrors = [],\n          linter = this.linter,\n          ruleId = `rule-to-test/${ruleName}`;\n\n    if (!test || typeof test !== \"object\") {\n      throw new TypeError(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);\n    }\n\n    requiredScenarios.forEach(scenarioType => {\n      if (!test[scenarioType]) {\n        scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);\n      }\n    });\n\n    if (scenarioErrors.length > 0) {\n      throw new Error([`Test Scenarios for rule ${ruleName} is invalid:`].concat(scenarioErrors).join(\"\\n\"));\n    }\n\n    const baseConfig = [{\n      plugins: {\n        // copy root plugin over\n        \"@\": {\n          /*\n           * Parsers are wrapped to detect more errors, so this needs\n           * to be a new object for each call to run(), otherwise the\n           * parsers will be wrapped multiple times.\n           */\n          parsers: { ...defaultConfig[0].plugins[\"@\"].parsers\n          },\n\n          /*\n           * The rules key on the default plugin is a proxy to lazy-load\n           * just the rules that are needed. So, don't create a new object\n           * here, just use the default one to keep that performance\n           * enhancement.\n           */\n          rules: defaultConfig[0].plugins[\"@\"].rules\n        },\n        \"rule-to-test\": {\n          rules: {\n            [ruleName]: Object.assign({}, rule, {\n              // Create a wrapper rule that freezes the `context` properties.\n              create(context) {\n                freezeDeeply(context.options);\n                freezeDeeply(context.settings);\n                freezeDeeply(context.parserOptions); // freezeDeeply(context.languageOptions);\n\n                return (typeof rule === \"function\" ? rule : rule.create)(context);\n              }\n\n            })\n          }\n        }\n      },\n      languageOptions: { ...defaultConfig[0].languageOptions\n      }\n    }, ...defaultConfig.slice(1)];\n    /**\n     * Run the rule for the given item\n     * @param {string|Object} item Item to run the rule against\n     * @throws {Error} If an invalid schema.\n     * @returns {Object} Eslint run result\n     * @private\n     */\n\n    function runRuleForItem(item) {\n      const configs = new FlatConfigArray(testerConfig, {\n        baseConfig\n      });\n      /*\n       * Modify the returned config so that the parser is wrapped to catch\n       * access of the start/end properties. This method is called just\n       * once per code snippet being tested, so each test case gets a clean\n       * parser.\n       */\n\n      configs[ConfigArraySymbol.finalizeConfig] = function () {\n        // can't do super here :(\n        const proto = Object.getPrototypeOf(this);\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        const calculatedConfig = proto[ConfigArraySymbol.finalizeConfig].apply(this, args); // wrap the parser to catch start/end property access\n\n        calculatedConfig.languageOptions.parser = wrapParser(calculatedConfig.languageOptions.parser);\n        return calculatedConfig;\n      };\n\n      let code, filename, output, beforeAST, afterAST;\n\n      if (typeof item === \"string\") {\n        code = item;\n      } else {\n        code = item.code;\n        /*\n         * Assumes everything on the item is a config except for the\n         * parameters used by this tester\n         */\n\n        const itemConfig = { ...item\n        };\n\n        for (const parameter of RuleTesterParameters) {\n          delete itemConfig[parameter];\n        } // wrap any parsers\n\n\n        if (itemConfig.languageOptions && itemConfig.languageOptions.parser) {\n          const parser = itemConfig.languageOptions.parser;\n\n          if (parser && typeof parser !== \"object\") {\n            throw new Error(\"Parser must be an object with a parse() or parseForESLint() method.\");\n          }\n        }\n        /*\n         * Create the config object from the tester config and this item\n         * specific configurations.\n         */\n\n\n        configs.push(itemConfig);\n      }\n\n      if (item.filename) {\n        filename = item.filename;\n      }\n\n      let ruleConfig = 1;\n\n      if (hasOwnProperty(item, \"options\")) {\n        assert(Array.isArray(item.options), \"options must be an array\");\n        ruleConfig = [1, ...item.options];\n      }\n\n      configs.push({\n        rules: {\n          [ruleId]: ruleConfig\n        }\n      });\n      const schema = getRuleOptionsSchema(rule);\n      /*\n       * Setup AST getters.\n       * The goal is to check whether or not AST was modified when\n       * running the rule under test.\n       */\n\n      configs.push({\n        plugins: {\n          \"rule-tester\": {\n            rules: {\n              \"validate-ast\"() {\n                return {\n                  Program(node) {\n                    beforeAST = cloneDeeplyExcludesParent(node);\n                  },\n\n                  \"Program:exit\"(node) {\n                    afterAST = node;\n                  }\n\n                };\n              }\n\n            }\n          }\n        }\n      });\n\n      if (schema) {\n        ajv.validateSchema(schema);\n\n        if (ajv.errors) {\n          const errors = ajv.errors.map(error => {\n            const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n            return `\\t${field}: ${error.message}`;\n          }).join(\"\\n\");\n          throw new Error([`Schema for rule ${ruleName} is invalid:`, errors]);\n        }\n        /*\n         * `ajv.validateSchema` checks for errors in the structure of the schema (by comparing the schema against a \"meta-schema\"),\n         * and it reports those errors individually. However, there are other types of schema errors that only occur when compiling\n         * the schema (e.g. using invalid defaults in a schema), and only one of these errors can be reported at a time. As a result,\n         * the schema is compiled here separately from checking for `validateSchema` errors.\n         */\n\n\n        try {\n          ajv.compile(schema);\n        } catch (err) {\n          throw new Error(`Schema for rule ${ruleName} is invalid: ${err.message}`);\n        }\n      } // Verify the code.\n\n\n      const {\n        getComments\n      } = SourceCode.prototype;\n      let messages; // check for validation errors\n\n      try {\n        configs.normalizeSync();\n        configs.getConfig(\"test.js\");\n      } catch (error) {\n        error.message = `ESLint configuration in rule-tester is invalid: ${error.message}`;\n        throw error;\n      }\n\n      try {\n        SourceCode.prototype.getComments = getCommentsDeprecation;\n        messages = linter.verify(code, configs, filename);\n      } finally {\n        SourceCode.prototype.getComments = getComments;\n      }\n\n      const fatalErrorMessage = messages.find(m => m.fatal);\n      assert(!fatalErrorMessage, `A fatal parsing error occurred: ${fatalErrorMessage && fatalErrorMessage.message}`); // Verify if autofix makes a syntax error or not.\n\n      if (messages.some(m => m.fix)) {\n        output = SourceCodeFixer.applyFixes(code, messages).output;\n        const errorMessageInFix = linter.verify(output, configs, filename).find(m => m.fatal);\n        assert(!errorMessageInFix, [\"A fatal parsing error occurred in autofix.\", `Error: ${errorMessageInFix && errorMessageInFix.message}`, \"Autofix output:\", output].join(\"\\n\"));\n      } else {\n        output = code;\n      }\n\n      return {\n        messages,\n        output,\n        beforeAST,\n        afterAST: cloneDeeplyExcludesParent(afterAST)\n      };\n    }\n    /**\n     * Check if the AST was changed\n     * @param {ASTNode} beforeAST AST node before running\n     * @param {ASTNode} afterAST AST node after running\n     * @returns {void}\n     * @private\n     */\n\n\n    function assertASTDidntChange(beforeAST, afterAST) {\n      if (!equal(beforeAST, afterAST)) {\n        assert.fail(\"Rule should not modify AST.\");\n      }\n    }\n    /**\n     * Check if the template is valid or not\n     * all valid cases go through this\n     * @param {string|Object} item Item to run the rule against\n     * @returns {void}\n     * @private\n     */\n\n\n    function testValidTemplate(item) {\n      const code = typeof item === \"object\" ? item.code : item;\n      assert.ok(typeof code === \"string\", \"Test case must specify a string value for 'code'\");\n\n      if (item.name) {\n        assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\n      }\n\n      const result = runRuleForItem(item);\n      const messages = result.messages;\n      assert.strictEqual(messages.length, 0, util.format(\"Should have no errors but had %d: %s\", messages.length, util.inspect(messages)));\n      assertASTDidntChange(result.beforeAST, result.afterAST);\n    }\n    /**\n     * Asserts that the message matches its expected value. If the expected\n     * value is a regular expression, it is checked against the actual\n     * value.\n     * @param {string} actual Actual value\n     * @param {string|RegExp} expected Expected value\n     * @returns {void}\n     * @private\n     */\n\n\n    function assertMessageMatches(actual, expected) {\n      if (expected instanceof RegExp) {\n        // assert.js doesn't have a built-in RegExp match function\n        assert.ok(expected.test(actual), `Expected '${actual}' to match ${expected}`);\n      } else {\n        assert.strictEqual(actual, expected);\n      }\n    }\n    /**\n     * Check if the template is invalid or not\n     * all invalid cases go through this.\n     * @param {string|Object} item Item to run the rule against\n     * @returns {void}\n     * @private\n     */\n\n\n    function testInvalidTemplate(item) {\n      assert.ok(typeof item.code === \"string\", \"Test case must specify a string value for 'code'\");\n\n      if (item.name) {\n        assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\n      }\n\n      assert.ok(item.errors || item.errors === 0, `Did not specify errors for an invalid test of ${ruleName}`);\n\n      if (Array.isArray(item.errors) && item.errors.length === 0) {\n        assert.fail(\"Invalid cases must have at least one error\");\n      }\n\n      const ruleHasMetaMessages = hasOwnProperty(rule, \"meta\") && hasOwnProperty(rule.meta, \"messages\");\n      const friendlyIDList = ruleHasMetaMessages ? `[${Object.keys(rule.meta.messages).map(key => `'${key}'`).join(\", \")}]` : null;\n      const result = runRuleForItem(item);\n      const messages = result.messages;\n\n      if (typeof item.errors === \"number\") {\n        if (item.errors === 0) {\n          assert.fail(\"Invalid cases must have 'error' value greater than 0\");\n        }\n\n        assert.strictEqual(messages.length, item.errors, util.format(\"Should have %d error%s but had %d: %s\", item.errors, item.errors === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n      } else {\n        assert.strictEqual(messages.length, item.errors.length, util.format(\"Should have %d error%s but had %d: %s\", item.errors.length, item.errors.length === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n        const hasMessageOfThisRule = messages.some(m => m.ruleId === ruleId);\n\n        for (let i = 0, l = item.errors.length; i < l; i++) {\n          const error = item.errors[i];\n          const message = messages[i];\n          assert(hasMessageOfThisRule, \"Error rule name should be the same as the name of the rule being tested\");\n\n          if (typeof error === \"string\" || error instanceof RegExp) {\n            // Just an error message.\n            assertMessageMatches(message.message, error);\n          } else if (typeof error === \"object\" && error !== null) {\n            /*\n             * Error object.\n             * This may have a message, messageId, data, node type, line, and/or\n             * column.\n             */\n            Object.keys(error).forEach(propertyName => {\n              assert.ok(errorObjectParameters.has(propertyName), `Invalid error property name '${propertyName}'. Expected one of ${friendlyErrorObjectParameterList}.`);\n            });\n\n            if (hasOwnProperty(error, \"message\")) {\n              assert.ok(!hasOwnProperty(error, \"messageId\"), \"Error should not specify both 'message' and a 'messageId'.\");\n              assert.ok(!hasOwnProperty(error, \"data\"), \"Error should not specify both 'data' and 'message'.\");\n              assertMessageMatches(message.message, error.message);\n            } else if (hasOwnProperty(error, \"messageId\")) {\n              assert.ok(ruleHasMetaMessages, \"Error can not use 'messageId' if rule under test doesn't define 'meta.messages'.\");\n\n              if (!hasOwnProperty(rule.meta.messages, error.messageId)) {\n                assert(false, `Invalid messageId '${error.messageId}'. Expected one of ${friendlyIDList}.`);\n              }\n\n              assert.strictEqual(message.messageId, error.messageId, `messageId '${message.messageId}' does not match expected messageId '${error.messageId}'.`);\n\n              if (hasOwnProperty(error, \"data\")) {\n                /*\n                 *  if data was provided, then directly compare the returned message to a synthetic\n                 *  interpolated message using the same message ID and data provided in the test.\n                 *  See https://github.com/eslint/eslint/issues/9890 for context.\n                 */\n                const unformattedOriginalMessage = rule.meta.messages[error.messageId];\n                const rehydratedMessage = interpolate(unformattedOriginalMessage, error.data);\n                assert.strictEqual(message.message, rehydratedMessage, `Hydrated message \"${rehydratedMessage}\" does not match \"${message.message}\"`);\n              }\n            }\n\n            assert.ok(hasOwnProperty(error, \"data\") ? hasOwnProperty(error, \"messageId\") : true, \"Error must specify 'messageId' if 'data' is used.\");\n\n            if (error.type) {\n              assert.strictEqual(message.nodeType, error.type, `Error type should be ${error.type}, found ${message.nodeType}`);\n            }\n\n            if (hasOwnProperty(error, \"line\")) {\n              assert.strictEqual(message.line, error.line, `Error line should be ${error.line}`);\n            }\n\n            if (hasOwnProperty(error, \"column\")) {\n              assert.strictEqual(message.column, error.column, `Error column should be ${error.column}`);\n            }\n\n            if (hasOwnProperty(error, \"endLine\")) {\n              assert.strictEqual(message.endLine, error.endLine, `Error endLine should be ${error.endLine}`);\n            }\n\n            if (hasOwnProperty(error, \"endColumn\")) {\n              assert.strictEqual(message.endColumn, error.endColumn, `Error endColumn should be ${error.endColumn}`);\n            }\n\n            if (hasOwnProperty(error, \"suggestions\")) {\n              // Support asserting there are no suggestions\n              if (!error.suggestions || Array.isArray(error.suggestions) && error.suggestions.length === 0) {\n                if (Array.isArray(message.suggestions) && message.suggestions.length > 0) {\n                  assert.fail(`Error should have no suggestions on error with message: \"${message.message}\"`);\n                }\n              } else {\n                assert.strictEqual(Array.isArray(message.suggestions), true, `Error should have an array of suggestions. Instead received \"${message.suggestions}\" on error with message: \"${message.message}\"`);\n                assert.strictEqual(message.suggestions.length, error.suggestions.length, `Error should have ${error.suggestions.length} suggestions. Instead found ${message.suggestions.length} suggestions`);\n                error.suggestions.forEach((expectedSuggestion, index) => {\n                  assert.ok(typeof expectedSuggestion === \"object\" && expectedSuggestion !== null, \"Test suggestion in 'suggestions' array must be an object.\");\n                  Object.keys(expectedSuggestion).forEach(propertyName => {\n                    assert.ok(suggestionObjectParameters.has(propertyName), `Invalid suggestion property name '${propertyName}'. Expected one of ${friendlySuggestionObjectParameterList}.`);\n                  });\n                  const actualSuggestion = message.suggestions[index];\n                  const suggestionPrefix = `Error Suggestion at index ${index} :`;\n\n                  if (hasOwnProperty(expectedSuggestion, \"desc\")) {\n                    assert.ok(!hasOwnProperty(expectedSuggestion, \"data\"), `${suggestionPrefix} Test should not specify both 'desc' and 'data'.`);\n                    assert.strictEqual(actualSuggestion.desc, expectedSuggestion.desc, `${suggestionPrefix} desc should be \"${expectedSuggestion.desc}\" but got \"${actualSuggestion.desc}\" instead.`);\n                  }\n\n                  if (hasOwnProperty(expectedSuggestion, \"messageId\")) {\n                    assert.ok(ruleHasMetaMessages, `${suggestionPrefix} Test can not use 'messageId' if rule under test doesn't define 'meta.messages'.`);\n                    assert.ok(hasOwnProperty(rule.meta.messages, expectedSuggestion.messageId), `${suggestionPrefix} Test has invalid messageId '${expectedSuggestion.messageId}', the rule under test allows only one of ${friendlyIDList}.`);\n                    assert.strictEqual(actualSuggestion.messageId, expectedSuggestion.messageId, `${suggestionPrefix} messageId should be '${expectedSuggestion.messageId}' but got '${actualSuggestion.messageId}' instead.`);\n\n                    if (hasOwnProperty(expectedSuggestion, \"data\")) {\n                      const unformattedMetaMessage = rule.meta.messages[expectedSuggestion.messageId];\n                      const rehydratedDesc = interpolate(unformattedMetaMessage, expectedSuggestion.data);\n                      assert.strictEqual(actualSuggestion.desc, rehydratedDesc, `${suggestionPrefix} Hydrated test desc \"${rehydratedDesc}\" does not match received desc \"${actualSuggestion.desc}\".`);\n                    }\n                  } else {\n                    assert.ok(!hasOwnProperty(expectedSuggestion, \"data\"), `${suggestionPrefix} Test must specify 'messageId' if 'data' is used.`);\n                  }\n\n                  if (hasOwnProperty(expectedSuggestion, \"output\")) {\n                    const codeWithAppliedSuggestion = SourceCodeFixer.applyFixes(item.code, [actualSuggestion]).output;\n                    assert.strictEqual(codeWithAppliedSuggestion, expectedSuggestion.output, `Expected the applied suggestion fix to match the test suggestion output for suggestion at index: ${index} on error with message: \"${message.message}\"`);\n                  }\n                });\n              }\n            }\n          } else {\n            // Message was an unexpected type\n            assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(message)})`);\n          }\n        }\n      }\n\n      if (hasOwnProperty(item, \"output\")) {\n        if (item.output === null) {\n          assert.strictEqual(result.output, item.code, \"Expected no autofixes to be suggested\");\n        } else {\n          assert.strictEqual(result.output, item.output, \"Output is incorrect.\");\n        }\n      } else {\n        assert.strictEqual(result.output, item.code, \"The rule fixed the code. Please add 'output' property.\");\n      }\n\n      assertASTDidntChange(result.beforeAST, result.afterAST);\n    }\n    /*\n     * This creates a mocha test suite and pipes all supplied info through\n     * one of the templates above.\n     */\n\n\n    this.constructor.describe(ruleName, () => {\n      this.constructor.describe(\"valid\", () => {\n        test.valid.forEach(valid => {\n          this.constructor[valid.only ? \"itOnly\" : \"it\"](sanitize(typeof valid === \"object\" ? valid.name || valid.code : valid), () => {\n            testValidTemplate(valid);\n          });\n        });\n      });\n      this.constructor.describe(\"invalid\", () => {\n        test.invalid.forEach(invalid => {\n          this.constructor[invalid.only ? \"itOnly\" : \"it\"](sanitize(invalid.name || invalid.code), () => {\n            testInvalidTemplate(invalid);\n          });\n        });\n      });\n    });\n  }\n\n}\n\nFlatRuleTester[DESCRIBE] = FlatRuleTester[IT] = FlatRuleTester[IT_ONLY] = null;\nmodule.exports = FlatRuleTester;","map":{"version":3,"names":["assert","require","util","equal","Traverser","getRuleOptionsSchema","Linter","SourceCodeFixer","interpolate","FlatConfigArray","defaultConfig","ajv","strictDefaults","parserSymbol","Symbol","for","SourceCode","ConfigArraySymbol","testerDefaultConfig","rules","sharedDefaultConfig","RuleTesterParameters","errorObjectParameters","Set","friendlyErrorObjectParameterList","map","key","join","suggestionObjectParameters","friendlySuggestionObjectParameterList","hasOwnProperty","Function","call","bind","Object","cloneDeeplyExcludesParent","x","Array","isArray","retv","freezeDeeply","forEach","freeze","sanitize","text","replace","c","codePointAt","toString","padStart","defineStartEndAsError","objName","node","defineProperties","start","get","Error","configurable","enumerable","end","defineStartEndAsErrorInTree","ast","visitorKeys","traverse","enter","tokens","comments","wrapParser","parser","parseForESLint","ret","parse","getCommentsDeprecation","DESCRIBE","IT","IT_ONLY","itDefaultHandler","method","err","AssertionError","message","inspect","actual","operator","expected","describeDefaultHandler","FlatRuleTester","constructor","testerConfig","linter","configType","setDefaultConfig","config","TypeError","getDefaultConfig","resetDefaultConfig","describe","value","it","only","item","code","itOnly","run","ruleName","rule","test","requiredScenarios","scenarioErrors","ruleId","scenarioType","push","length","concat","baseConfig","plugins","parsers","assign","create","context","options","settings","parserOptions","languageOptions","slice","runRuleForItem","configs","finalizeConfig","proto","getPrototypeOf","args","calculatedConfig","apply","filename","output","beforeAST","afterAST","itemConfig","parameter","ruleConfig","schema","Program","validateSchema","errors","error","field","dataPath","compile","getComments","prototype","messages","normalizeSync","getConfig","verify","fatalErrorMessage","find","m","fatal","some","fix","applyFixes","errorMessageInFix","assertASTDidntChange","fail","testValidTemplate","ok","name","result","strictEqual","format","assertMessageMatches","RegExp","testInvalidTemplate","ruleHasMetaMessages","meta","friendlyIDList","keys","hasMessageOfThisRule","i","l","propertyName","has","messageId","unformattedOriginalMessage","rehydratedMessage","data","type","nodeType","line","column","endLine","endColumn","suggestions","expectedSuggestion","index","actualSuggestion","suggestionPrefix","desc","unformattedMetaMessage","rehydratedDesc","codeWithAppliedSuggestion","valid","invalid","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rule-tester/flat-rule-tester.js"],"sourcesContent":["/**\n * @fileoverview Mocha/Jest test wrapper\n * @author Ilya Volodin\n */\n\"use strict\";\n\n/* globals describe, it -- Mocha globals */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst\n    assert = require(\"assert\"),\n    util = require(\"util\"),\n    equal = require(\"fast-deep-equal\"),\n    Traverser = require(\"../shared/traverser\"),\n    { getRuleOptionsSchema } = require(\"../config/flat-config-helpers\"),\n    { Linter, SourceCodeFixer, interpolate } = require(\"../linter\");\nconst { FlatConfigArray } = require(\"../config/flat-config-array\");\nconst { defaultConfig } = require(\"../config/default-config\");\n\nconst ajv = require(\"../shared/ajv\")({ strictDefaults: true });\n\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\nconst { SourceCode } = require(\"../source-code\");\nconst { ConfigArraySymbol } = require(\"@humanwhocodes/config-array\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").Parser} Parser */\n/** @typedef {import(\"../shared/types\").LanguageOptions} LanguageOptions */\n\n/* eslint-disable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n/**\n * A test case that is expected to pass lint.\n * @typedef {Object} ValidTestCase\n * @property {string} [name] Name for the test case.\n * @property {string} code Code for the test case.\n * @property {any[]} [options] Options for the test case.\n * @property {LanguageOptions} [languageOptions] The language options to use in the test case.\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\n */\n\n/**\n * A test case that is expected to fail lint.\n * @typedef {Object} InvalidTestCase\n * @property {string} [name] Name for the test case.\n * @property {string} code Code for the test case.\n * @property {number | Array<TestCaseError | string | RegExp>} errors Expected errors.\n * @property {string | null} [output] The expected code after autofixes are applied. If set to `null`, the test runner will assert that no autofix is suggested.\n * @property {any[]} [options] Options for the test case.\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\n * @property {LanguageOptions} [languageOptions] The language options to use in the test case.\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\n */\n\n/**\n * A description of a reported error used in a rule tester test.\n * @typedef {Object} TestCaseError\n * @property {string | RegExp} [message] Message.\n * @property {string} [messageId] Message ID.\n * @property {string} [type] The type of the reported AST node.\n * @property {{ [name: string]: string }} [data] The data used to fill the message template.\n * @property {number} [line] The 1-based line number of the reported start location.\n * @property {number} [column] The 1-based column number of the reported start location.\n * @property {number} [endLine] The 1-based line number of the reported end location.\n * @property {number} [endColumn] The 1-based column number of the reported end location.\n */\n/* eslint-enable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n\n//------------------------------------------------------------------------------\n// Private Members\n//------------------------------------------------------------------------------\n\n/*\n * testerDefaultConfig must not be modified as it allows to reset the tester to\n * the initial default configuration\n */\nconst testerDefaultConfig = { rules: {} };\n\n/*\n * RuleTester uses this config as its default. This can be overwritten via\n * setDefaultConfig().\n */\nlet sharedDefaultConfig = { rules: {} };\n\n/*\n * List every parameters possible on a test case that are not related to eslint\n * configuration\n */\nconst RuleTesterParameters = [\n    \"name\",\n    \"code\",\n    \"filename\",\n    \"options\",\n    \"errors\",\n    \"output\",\n    \"only\"\n];\n\n/*\n * All allowed property names in error objects.\n */\nconst errorObjectParameters = new Set([\n    \"message\",\n    \"messageId\",\n    \"data\",\n    \"type\",\n    \"line\",\n    \"column\",\n    \"endLine\",\n    \"endColumn\",\n    \"suggestions\"\n]);\nconst friendlyErrorObjectParameterList = `[${[...errorObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\n\n/*\n * All allowed property names in suggestion objects.\n */\nconst suggestionObjectParameters = new Set([\n    \"desc\",\n    \"messageId\",\n    \"data\",\n    \"output\"\n]);\nconst friendlySuggestionObjectParameterList = `[${[...suggestionObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\n\nconst hasOwnProperty = Function.call.bind(Object.hasOwnProperty);\n\n/**\n * Clones a given value deeply.\n * Note: This ignores `parent` property.\n * @param {any} x A value to clone.\n * @returns {any} A cloned value.\n */\nfunction cloneDeeplyExcludesParent(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            return x.map(cloneDeeplyExcludesParent);\n        }\n\n        const retv = {};\n\n        for (const key in x) {\n            if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                retv[key] = cloneDeeplyExcludesParent(x[key]);\n            }\n        }\n\n        return retv;\n    }\n\n    return x;\n}\n\n/**\n * Freezes a given value deeply.\n * @param {any} x A value to freeze.\n * @returns {void}\n */\nfunction freezeDeeply(x) {\n    if (typeof x === \"object\" && x !== null) {\n        if (Array.isArray(x)) {\n            x.forEach(freezeDeeply);\n        } else {\n            for (const key in x) {\n                if (key !== \"parent\" && hasOwnProperty(x, key)) {\n                    freezeDeeply(x[key]);\n                }\n            }\n        }\n        Object.freeze(x);\n    }\n}\n\n/**\n * Replace control characters by `\\u00xx` form.\n * @param {string} text The text to sanitize.\n * @returns {string} The sanitized text.\n */\nfunction sanitize(text) {\n    if (typeof text !== \"string\") {\n        return \"\";\n    }\n    return text.replace(\n        /[\\u0000-\\u0009\\u000b-\\u001a]/gu, // eslint-disable-line no-control-regex -- Escaping controls\n        c => `\\\\u${c.codePointAt(0).toString(16).padStart(4, \"0\")}`\n    );\n}\n\n/**\n * Define `start`/`end` properties as throwing error.\n * @param {string} objName Object name used for error messages.\n * @param {ASTNode} node The node to define.\n * @returns {void}\n */\nfunction defineStartEndAsError(objName, node) {\n    Object.defineProperties(node, {\n        start: {\n            get() {\n                throw new Error(`Use ${objName}.range[0] instead of ${objName}.start`);\n            },\n            configurable: true,\n            enumerable: false\n        },\n        end: {\n            get() {\n                throw new Error(`Use ${objName}.range[1] instead of ${objName}.end`);\n            },\n            configurable: true,\n            enumerable: false\n        }\n    });\n}\n\n\n/**\n * Define `start`/`end` properties of all nodes of the given AST as throwing error.\n * @param {ASTNode} ast The root node to errorize `start`/`end` properties.\n * @param {Object} [visitorKeys] Visitor keys to be used for traversing the given ast.\n * @returns {void}\n */\nfunction defineStartEndAsErrorInTree(ast, visitorKeys) {\n    Traverser.traverse(ast, { visitorKeys, enter: defineStartEndAsError.bind(null, \"node\") });\n    ast.tokens.forEach(defineStartEndAsError.bind(null, \"token\"));\n    ast.comments.forEach(defineStartEndAsError.bind(null, \"token\"));\n}\n\n/**\n * Wraps the given parser in order to intercept and modify return values from the `parse` and `parseForESLint` methods, for test purposes.\n * In particular, to modify ast nodes, tokens and comments to throw on access to their `start` and `end` properties.\n * @param {Parser} parser Parser object.\n * @returns {Parser} Wrapped parser object.\n */\nfunction wrapParser(parser) {\n\n    if (typeof parser.parseForESLint === \"function\") {\n        return {\n            [parserSymbol]: parser,\n            parseForESLint(...args) {\n                const ret = parser.parseForESLint(...args);\n\n                defineStartEndAsErrorInTree(ret.ast, ret.visitorKeys);\n                return ret;\n            }\n        };\n    }\n\n    return {\n        [parserSymbol]: parser,\n        parse(...args) {\n            const ast = parser.parse(...args);\n\n            defineStartEndAsErrorInTree(ast);\n            return ast;\n        }\n    };\n}\n\n/**\n * Function to replace `SourceCode.prototype.getComments`.\n * @returns {void}\n * @throws {Error} Deprecation message.\n */\nfunction getCommentsDeprecation() {\n    throw new Error(\n        \"`SourceCode#getComments()` is deprecated and will be removed in a future major version. Use `getCommentsBefore()`, `getCommentsAfter()`, and `getCommentsInside()` instead.\"\n    );\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n// default separators for testing\nconst DESCRIBE = Symbol(\"describe\");\nconst IT = Symbol(\"it\");\nconst IT_ONLY = Symbol(\"itOnly\");\n\n/**\n * This is `it` default handler if `it` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @throws {Error} Any error upon execution of `method`.\n * @returns {any} Returned value of `method`.\n */\nfunction itDefaultHandler(text, method) {\n    try {\n        return method.call(this);\n    } catch (err) {\n        if (err instanceof assert.AssertionError) {\n            err.message += ` (${util.inspect(err.actual)} ${err.operator} ${util.inspect(err.expected)})`;\n        }\n        throw err;\n    }\n}\n\n/**\n * This is `describe` default handler if `describe` don't exist.\n * @this {Mocha}\n * @param {string} text The description of the test case.\n * @param {Function} method The logic of the test case.\n * @returns {any} Returned value of `method`.\n */\nfunction describeDefaultHandler(text, method) {\n    return method.call(this);\n}\n\n/**\n * Mocha test wrapper.\n */\nclass FlatRuleTester {\n\n    /**\n     * Creates a new instance of RuleTester.\n     * @param {Object} [testerConfig] Optional, extra configuration for the tester\n     */\n    constructor(testerConfig = {}) {\n\n        /**\n         * The configuration to use for this tester. Combination of the tester\n         * configuration and the default configuration.\n         * @type {Object}\n         */\n        this.testerConfig = [\n            sharedDefaultConfig,\n            testerConfig,\n            { rules: { \"rule-tester/validate-ast\": \"error\" } }\n        ];\n\n        this.linter = new Linter({ configType: \"flat\" });\n    }\n\n    /**\n     * Set the configuration to use for all future tests\n     * @param {Object} config the configuration to use.\n     * @throws {TypeError} If non-object config.\n     * @returns {void}\n     */\n    static setDefaultConfig(config) {\n        if (typeof config !== \"object\") {\n            throw new TypeError(\"FlatRuleTester.setDefaultConfig: config must be an object\");\n        }\n        sharedDefaultConfig = config;\n\n        // Make sure the rules object exists since it is assumed to exist later\n        sharedDefaultConfig.rules = sharedDefaultConfig.rules || {};\n    }\n\n    /**\n     * Get the current configuration used for all tests\n     * @returns {Object} the current configuration\n     */\n    static getDefaultConfig() {\n        return sharedDefaultConfig;\n    }\n\n    /**\n     * Reset the configuration to the initial configuration of the tester removing\n     * any changes made until now.\n     * @returns {void}\n     */\n    static resetDefaultConfig() {\n        sharedDefaultConfig = {\n            rules: {\n                ...testerDefaultConfig.rules\n            }\n        };\n    }\n\n\n    /*\n     * If people use `mocha test.js --watch` command, `describe` and `it` function\n     * instances are different for each execution. So `describe` and `it` should get fresh instance\n     * always.\n     */\n    static get describe() {\n        return (\n            this[DESCRIBE] ||\n            (typeof describe === \"function\" ? describe : describeDefaultHandler)\n        );\n    }\n\n    static set describe(value) {\n        this[DESCRIBE] = value;\n    }\n\n    static get it() {\n        return (\n            this[IT] ||\n            (typeof it === \"function\" ? it : itDefaultHandler)\n        );\n    }\n\n    static set it(value) {\n        this[IT] = value;\n    }\n\n    /**\n     * Adds the `only` property to a test to run it in isolation.\n     * @param {string | ValidTestCase | InvalidTestCase} item A single test to run by itself.\n     * @returns {ValidTestCase | InvalidTestCase} The test with `only` set.\n     */\n    static only(item) {\n        if (typeof item === \"string\") {\n            return { code: item, only: true };\n        }\n\n        return { ...item, only: true };\n    }\n\n    static get itOnly() {\n        if (typeof this[IT_ONLY] === \"function\") {\n            return this[IT_ONLY];\n        }\n        if (typeof this[IT] === \"function\" && typeof this[IT].only === \"function\") {\n            return Function.bind.call(this[IT].only, this[IT]);\n        }\n        if (typeof it === \"function\" && typeof it.only === \"function\") {\n            return Function.bind.call(it.only, it);\n        }\n\n        if (typeof this[DESCRIBE] === \"function\" || typeof this[IT] === \"function\") {\n            throw new Error(\n                \"Set `RuleTester.itOnly` to use `only` with a custom test framework.\\n\" +\n                \"See https://eslint.org/docs/developer-guide/nodejs-api#customizing-ruletester for more.\"\n            );\n        }\n        if (typeof it === \"function\") {\n            throw new Error(\"The current test framework does not support exclusive tests with `only`.\");\n        }\n        throw new Error(\"To use `only`, use RuleTester with a test framework that provides `it.only()` like Mocha.\");\n    }\n\n    static set itOnly(value) {\n        this[IT_ONLY] = value;\n    }\n\n\n    /**\n     * Adds a new rule test to execute.\n     * @param {string} ruleName The name of the rule to run.\n     * @param {Function} rule The rule to test.\n     * @param {{\n     *   valid: (ValidTestCase | string)[],\n     *   invalid: InvalidTestCase[]\n     * }} test The collection of tests to run.\n     * @throws {TypeError|Error} If non-object `test`, or if a required\n     * scenario of the given type is missing.\n     * @returns {void}\n     */\n    run(ruleName, rule, test) {\n\n        const testerConfig = this.testerConfig,\n            requiredScenarios = [\"valid\", \"invalid\"],\n            scenarioErrors = [],\n            linter = this.linter,\n            ruleId = `rule-to-test/${ruleName}`;\n\n        if (!test || typeof test !== \"object\") {\n            throw new TypeError(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);\n        }\n\n        requiredScenarios.forEach(scenarioType => {\n            if (!test[scenarioType]) {\n                scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);\n            }\n        });\n\n        if (scenarioErrors.length > 0) {\n            throw new Error([\n                `Test Scenarios for rule ${ruleName} is invalid:`\n            ].concat(scenarioErrors).join(\"\\n\"));\n        }\n\n        const baseConfig = [\n            {\n                plugins: {\n\n                    // copy root plugin over\n                    \"@\": {\n\n                        /*\n                         * Parsers are wrapped to detect more errors, so this needs\n                         * to be a new object for each call to run(), otherwise the\n                         * parsers will be wrapped multiple times.\n                         */\n                        parsers: {\n                            ...defaultConfig[0].plugins[\"@\"].parsers\n                        },\n\n                        /*\n                         * The rules key on the default plugin is a proxy to lazy-load\n                         * just the rules that are needed. So, don't create a new object\n                         * here, just use the default one to keep that performance\n                         * enhancement.\n                         */\n                        rules: defaultConfig[0].plugins[\"@\"].rules\n                    },\n                    \"rule-to-test\": {\n                        rules: {\n                            [ruleName]: Object.assign({}, rule, {\n\n                                // Create a wrapper rule that freezes the `context` properties.\n                                create(context) {\n                                    freezeDeeply(context.options);\n                                    freezeDeeply(context.settings);\n                                    freezeDeeply(context.parserOptions);\n\n                                    // freezeDeeply(context.languageOptions);\n\n                                    return (typeof rule === \"function\" ? rule : rule.create)(context);\n                                }\n                            })\n                        }\n                    }\n                },\n                languageOptions: {\n                    ...defaultConfig[0].languageOptions\n                }\n            },\n            ...defaultConfig.slice(1)\n        ];\n\n        /**\n         * Run the rule for the given item\n         * @param {string|Object} item Item to run the rule against\n         * @throws {Error} If an invalid schema.\n         * @returns {Object} Eslint run result\n         * @private\n         */\n        function runRuleForItem(item) {\n            const configs = new FlatConfigArray(testerConfig, { baseConfig });\n\n            /*\n             * Modify the returned config so that the parser is wrapped to catch\n             * access of the start/end properties. This method is called just\n             * once per code snippet being tested, so each test case gets a clean\n             * parser.\n             */\n            configs[ConfigArraySymbol.finalizeConfig] = function(...args) {\n\n                // can't do super here :(\n                const proto = Object.getPrototypeOf(this);\n                const calculatedConfig = proto[ConfigArraySymbol.finalizeConfig].apply(this, args);\n\n                // wrap the parser to catch start/end property access\n                calculatedConfig.languageOptions.parser = wrapParser(calculatedConfig.languageOptions.parser);\n                return calculatedConfig;\n            };\n\n            let code, filename, output, beforeAST, afterAST;\n\n            if (typeof item === \"string\") {\n                code = item;\n            } else {\n                code = item.code;\n\n                /*\n                 * Assumes everything on the item is a config except for the\n                 * parameters used by this tester\n                 */\n                const itemConfig = { ...item };\n\n                for (const parameter of RuleTesterParameters) {\n                    delete itemConfig[parameter];\n                }\n\n                // wrap any parsers\n                if (itemConfig.languageOptions && itemConfig.languageOptions.parser) {\n\n                    const parser = itemConfig.languageOptions.parser;\n\n                    if (parser && typeof parser !== \"object\") {\n                        throw new Error(\"Parser must be an object with a parse() or parseForESLint() method.\");\n                    }\n\n                }\n\n                /*\n                 * Create the config object from the tester config and this item\n                 * specific configurations.\n                 */\n                configs.push(itemConfig);\n            }\n\n            if (item.filename) {\n                filename = item.filename;\n            }\n\n            let ruleConfig = 1;\n\n            if (hasOwnProperty(item, \"options\")) {\n                assert(Array.isArray(item.options), \"options must be an array\");\n                ruleConfig = [1, ...item.options];\n            }\n\n            configs.push({\n                rules: {\n                    [ruleId]: ruleConfig\n                }\n            });\n\n            const schema = getRuleOptionsSchema(rule);\n\n            /*\n             * Setup AST getters.\n             * The goal is to check whether or not AST was modified when\n             * running the rule under test.\n             */\n            configs.push({\n                plugins: {\n                    \"rule-tester\": {\n                        rules: {\n                            \"validate-ast\"() {\n                                return {\n                                    Program(node) {\n                                        beforeAST = cloneDeeplyExcludesParent(node);\n                                    },\n                                    \"Program:exit\"(node) {\n                                        afterAST = node;\n                                    }\n                                };\n                            }\n                        }\n                    }\n                }\n            });\n\n            if (schema) {\n                ajv.validateSchema(schema);\n\n                if (ajv.errors) {\n                    const errors = ajv.errors.map(error => {\n                        const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n\n                        return `\\t${field}: ${error.message}`;\n                    }).join(\"\\n\");\n\n                    throw new Error([`Schema for rule ${ruleName} is invalid:`, errors]);\n                }\n\n                /*\n                 * `ajv.validateSchema` checks for errors in the structure of the schema (by comparing the schema against a \"meta-schema\"),\n                 * and it reports those errors individually. However, there are other types of schema errors that only occur when compiling\n                 * the schema (e.g. using invalid defaults in a schema), and only one of these errors can be reported at a time. As a result,\n                 * the schema is compiled here separately from checking for `validateSchema` errors.\n                 */\n                try {\n                    ajv.compile(schema);\n                } catch (err) {\n                    throw new Error(`Schema for rule ${ruleName} is invalid: ${err.message}`);\n                }\n            }\n\n            // Verify the code.\n            const { getComments } = SourceCode.prototype;\n            let messages;\n\n            // check for validation errors\n            try {\n                configs.normalizeSync();\n                configs.getConfig(\"test.js\");\n            } catch (error) {\n                error.message = `ESLint configuration in rule-tester is invalid: ${error.message}`;\n                throw error;\n            }\n\n            try {\n                SourceCode.prototype.getComments = getCommentsDeprecation;\n                messages = linter.verify(code, configs, filename);\n            } finally {\n                SourceCode.prototype.getComments = getComments;\n            }\n\n            const fatalErrorMessage = messages.find(m => m.fatal);\n\n            assert(!fatalErrorMessage, `A fatal parsing error occurred: ${fatalErrorMessage && fatalErrorMessage.message}`);\n\n            // Verify if autofix makes a syntax error or not.\n            if (messages.some(m => m.fix)) {\n                output = SourceCodeFixer.applyFixes(code, messages).output;\n                const errorMessageInFix = linter.verify(output, configs, filename).find(m => m.fatal);\n\n                assert(!errorMessageInFix, [\n                    \"A fatal parsing error occurred in autofix.\",\n                    `Error: ${errorMessageInFix && errorMessageInFix.message}`,\n                    \"Autofix output:\",\n                    output\n                ].join(\"\\n\"));\n            } else {\n                output = code;\n            }\n\n            return {\n                messages,\n                output,\n                beforeAST,\n                afterAST: cloneDeeplyExcludesParent(afterAST)\n            };\n        }\n\n        /**\n         * Check if the AST was changed\n         * @param {ASTNode} beforeAST AST node before running\n         * @param {ASTNode} afterAST AST node after running\n         * @returns {void}\n         * @private\n         */\n        function assertASTDidntChange(beforeAST, afterAST) {\n            if (!equal(beforeAST, afterAST)) {\n                assert.fail(\"Rule should not modify AST.\");\n            }\n        }\n\n        /**\n         * Check if the template is valid or not\n         * all valid cases go through this\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testValidTemplate(item) {\n            const code = typeof item === \"object\" ? item.code : item;\n\n            assert.ok(typeof code === \"string\", \"Test case must specify a string value for 'code'\");\n            if (item.name) {\n                assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\n            }\n\n            const result = runRuleForItem(item);\n            const messages = result.messages;\n\n            assert.strictEqual(messages.length, 0, util.format(\"Should have no errors but had %d: %s\",\n                messages.length,\n                util.inspect(messages)));\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /**\n         * Asserts that the message matches its expected value. If the expected\n         * value is a regular expression, it is checked against the actual\n         * value.\n         * @param {string} actual Actual value\n         * @param {string|RegExp} expected Expected value\n         * @returns {void}\n         * @private\n         */\n        function assertMessageMatches(actual, expected) {\n            if (expected instanceof RegExp) {\n\n                // assert.js doesn't have a built-in RegExp match function\n                assert.ok(\n                    expected.test(actual),\n                    `Expected '${actual}' to match ${expected}`\n                );\n            } else {\n                assert.strictEqual(actual, expected);\n            }\n        }\n\n        /**\n         * Check if the template is invalid or not\n         * all invalid cases go through this.\n         * @param {string|Object} item Item to run the rule against\n         * @returns {void}\n         * @private\n         */\n        function testInvalidTemplate(item) {\n            assert.ok(typeof item.code === \"string\", \"Test case must specify a string value for 'code'\");\n            if (item.name) {\n                assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\n            }\n            assert.ok(item.errors || item.errors === 0,\n                `Did not specify errors for an invalid test of ${ruleName}`);\n\n            if (Array.isArray(item.errors) && item.errors.length === 0) {\n                assert.fail(\"Invalid cases must have at least one error\");\n            }\n\n            const ruleHasMetaMessages = hasOwnProperty(rule, \"meta\") && hasOwnProperty(rule.meta, \"messages\");\n            const friendlyIDList = ruleHasMetaMessages ? `[${Object.keys(rule.meta.messages).map(key => `'${key}'`).join(\", \")}]` : null;\n\n            const result = runRuleForItem(item);\n            const messages = result.messages;\n\n            if (typeof item.errors === \"number\") {\n\n                if (item.errors === 0) {\n                    assert.fail(\"Invalid cases must have 'error' value greater than 0\");\n                }\n\n                assert.strictEqual(messages.length, item.errors, util.format(\"Should have %d error%s but had %d: %s\",\n                    item.errors,\n                    item.errors === 1 ? \"\" : \"s\",\n                    messages.length,\n                    util.inspect(messages)));\n            } else {\n                assert.strictEqual(\n                    messages.length, item.errors.length, util.format(\n                        \"Should have %d error%s but had %d: %s\",\n                        item.errors.length,\n                        item.errors.length === 1 ? \"\" : \"s\",\n                        messages.length,\n                        util.inspect(messages)\n                    )\n                );\n\n                const hasMessageOfThisRule = messages.some(m => m.ruleId === ruleId);\n\n                for (let i = 0, l = item.errors.length; i < l; i++) {\n                    const error = item.errors[i];\n                    const message = messages[i];\n\n                    assert(hasMessageOfThisRule, \"Error rule name should be the same as the name of the rule being tested\");\n\n                    if (typeof error === \"string\" || error instanceof RegExp) {\n\n                        // Just an error message.\n                        assertMessageMatches(message.message, error);\n                    } else if (typeof error === \"object\" && error !== null) {\n\n                        /*\n                         * Error object.\n                         * This may have a message, messageId, data, node type, line, and/or\n                         * column.\n                         */\n\n                        Object.keys(error).forEach(propertyName => {\n                            assert.ok(\n                                errorObjectParameters.has(propertyName),\n                                `Invalid error property name '${propertyName}'. Expected one of ${friendlyErrorObjectParameterList}.`\n                            );\n                        });\n\n                        if (hasOwnProperty(error, \"message\")) {\n                            assert.ok(!hasOwnProperty(error, \"messageId\"), \"Error should not specify both 'message' and a 'messageId'.\");\n                            assert.ok(!hasOwnProperty(error, \"data\"), \"Error should not specify both 'data' and 'message'.\");\n                            assertMessageMatches(message.message, error.message);\n                        } else if (hasOwnProperty(error, \"messageId\")) {\n                            assert.ok(\n                                ruleHasMetaMessages,\n                                \"Error can not use 'messageId' if rule under test doesn't define 'meta.messages'.\"\n                            );\n                            if (!hasOwnProperty(rule.meta.messages, error.messageId)) {\n                                assert(false, `Invalid messageId '${error.messageId}'. Expected one of ${friendlyIDList}.`);\n                            }\n                            assert.strictEqual(\n                                message.messageId,\n                                error.messageId,\n                                `messageId '${message.messageId}' does not match expected messageId '${error.messageId}'.`\n                            );\n                            if (hasOwnProperty(error, \"data\")) {\n\n                                /*\n                                 *  if data was provided, then directly compare the returned message to a synthetic\n                                 *  interpolated message using the same message ID and data provided in the test.\n                                 *  See https://github.com/eslint/eslint/issues/9890 for context.\n                                 */\n                                const unformattedOriginalMessage = rule.meta.messages[error.messageId];\n                                const rehydratedMessage = interpolate(unformattedOriginalMessage, error.data);\n\n                                assert.strictEqual(\n                                    message.message,\n                                    rehydratedMessage,\n                                    `Hydrated message \"${rehydratedMessage}\" does not match \"${message.message}\"`\n                                );\n                            }\n                        }\n\n                        assert.ok(\n                            hasOwnProperty(error, \"data\") ? hasOwnProperty(error, \"messageId\") : true,\n                            \"Error must specify 'messageId' if 'data' is used.\"\n                        );\n\n                        if (error.type) {\n                            assert.strictEqual(message.nodeType, error.type, `Error type should be ${error.type}, found ${message.nodeType}`);\n                        }\n\n                        if (hasOwnProperty(error, \"line\")) {\n                            assert.strictEqual(message.line, error.line, `Error line should be ${error.line}`);\n                        }\n\n                        if (hasOwnProperty(error, \"column\")) {\n                            assert.strictEqual(message.column, error.column, `Error column should be ${error.column}`);\n                        }\n\n                        if (hasOwnProperty(error, \"endLine\")) {\n                            assert.strictEqual(message.endLine, error.endLine, `Error endLine should be ${error.endLine}`);\n                        }\n\n                        if (hasOwnProperty(error, \"endColumn\")) {\n                            assert.strictEqual(message.endColumn, error.endColumn, `Error endColumn should be ${error.endColumn}`);\n                        }\n\n                        if (hasOwnProperty(error, \"suggestions\")) {\n\n                            // Support asserting there are no suggestions\n                            if (!error.suggestions || (Array.isArray(error.suggestions) && error.suggestions.length === 0)) {\n                                if (Array.isArray(message.suggestions) && message.suggestions.length > 0) {\n                                    assert.fail(`Error should have no suggestions on error with message: \"${message.message}\"`);\n                                }\n                            } else {\n                                assert.strictEqual(Array.isArray(message.suggestions), true, `Error should have an array of suggestions. Instead received \"${message.suggestions}\" on error with message: \"${message.message}\"`);\n                                assert.strictEqual(message.suggestions.length, error.suggestions.length, `Error should have ${error.suggestions.length} suggestions. Instead found ${message.suggestions.length} suggestions`);\n\n                                error.suggestions.forEach((expectedSuggestion, index) => {\n                                    assert.ok(\n                                        typeof expectedSuggestion === \"object\" && expectedSuggestion !== null,\n                                        \"Test suggestion in 'suggestions' array must be an object.\"\n                                    );\n                                    Object.keys(expectedSuggestion).forEach(propertyName => {\n                                        assert.ok(\n                                            suggestionObjectParameters.has(propertyName),\n                                            `Invalid suggestion property name '${propertyName}'. Expected one of ${friendlySuggestionObjectParameterList}.`\n                                        );\n                                    });\n\n                                    const actualSuggestion = message.suggestions[index];\n                                    const suggestionPrefix = `Error Suggestion at index ${index} :`;\n\n                                    if (hasOwnProperty(expectedSuggestion, \"desc\")) {\n                                        assert.ok(\n                                            !hasOwnProperty(expectedSuggestion, \"data\"),\n                                            `${suggestionPrefix} Test should not specify both 'desc' and 'data'.`\n                                        );\n                                        assert.strictEqual(\n                                            actualSuggestion.desc,\n                                            expectedSuggestion.desc,\n                                            `${suggestionPrefix} desc should be \"${expectedSuggestion.desc}\" but got \"${actualSuggestion.desc}\" instead.`\n                                        );\n                                    }\n\n                                    if (hasOwnProperty(expectedSuggestion, \"messageId\")) {\n                                        assert.ok(\n                                            ruleHasMetaMessages,\n                                            `${suggestionPrefix} Test can not use 'messageId' if rule under test doesn't define 'meta.messages'.`\n                                        );\n                                        assert.ok(\n                                            hasOwnProperty(rule.meta.messages, expectedSuggestion.messageId),\n                                            `${suggestionPrefix} Test has invalid messageId '${expectedSuggestion.messageId}', the rule under test allows only one of ${friendlyIDList}.`\n                                        );\n                                        assert.strictEqual(\n                                            actualSuggestion.messageId,\n                                            expectedSuggestion.messageId,\n                                            `${suggestionPrefix} messageId should be '${expectedSuggestion.messageId}' but got '${actualSuggestion.messageId}' instead.`\n                                        );\n                                        if (hasOwnProperty(expectedSuggestion, \"data\")) {\n                                            const unformattedMetaMessage = rule.meta.messages[expectedSuggestion.messageId];\n                                            const rehydratedDesc = interpolate(unformattedMetaMessage, expectedSuggestion.data);\n\n                                            assert.strictEqual(\n                                                actualSuggestion.desc,\n                                                rehydratedDesc,\n                                                `${suggestionPrefix} Hydrated test desc \"${rehydratedDesc}\" does not match received desc \"${actualSuggestion.desc}\".`\n                                            );\n                                        }\n                                    } else {\n                                        assert.ok(\n                                            !hasOwnProperty(expectedSuggestion, \"data\"),\n                                            `${suggestionPrefix} Test must specify 'messageId' if 'data' is used.`\n                                        );\n                                    }\n\n                                    if (hasOwnProperty(expectedSuggestion, \"output\")) {\n                                        const codeWithAppliedSuggestion = SourceCodeFixer.applyFixes(item.code, [actualSuggestion]).output;\n\n                                        assert.strictEqual(codeWithAppliedSuggestion, expectedSuggestion.output, `Expected the applied suggestion fix to match the test suggestion output for suggestion at index: ${index} on error with message: \"${message.message}\"`);\n                                    }\n                                });\n                            }\n                        }\n                    } else {\n\n                        // Message was an unexpected type\n                        assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(message)})`);\n                    }\n                }\n            }\n\n            if (hasOwnProperty(item, \"output\")) {\n                if (item.output === null) {\n                    assert.strictEqual(\n                        result.output,\n                        item.code,\n                        \"Expected no autofixes to be suggested\"\n                    );\n                } else {\n                    assert.strictEqual(result.output, item.output, \"Output is incorrect.\");\n                }\n            } else {\n                assert.strictEqual(\n                    result.output,\n                    item.code,\n                    \"The rule fixed the code. Please add 'output' property.\"\n                );\n            }\n\n            assertASTDidntChange(result.beforeAST, result.afterAST);\n        }\n\n        /*\n         * This creates a mocha test suite and pipes all supplied info through\n         * one of the templates above.\n         */\n        this.constructor.describe(ruleName, () => {\n            this.constructor.describe(\"valid\", () => {\n                test.valid.forEach(valid => {\n                    this.constructor[valid.only ? \"itOnly\" : \"it\"](\n                        sanitize(typeof valid === \"object\" ? valid.name || valid.code : valid),\n                        () => {\n                            testValidTemplate(valid);\n                        }\n                    );\n                });\n            });\n\n            this.constructor.describe(\"invalid\", () => {\n                test.invalid.forEach(invalid => {\n                    this.constructor[invalid.only ? \"itOnly\" : \"it\"](\n                        sanitize(invalid.name || invalid.code),\n                        () => {\n                            testInvalidTemplate(invalid);\n                        }\n                    );\n                });\n            });\n        });\n    }\n}\n\nFlatRuleTester[DESCRIBE] = FlatRuleTester[IT] = FlatRuleTester[IT_ONLY] = null;\n\nmodule.exports = FlatRuleTester;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}