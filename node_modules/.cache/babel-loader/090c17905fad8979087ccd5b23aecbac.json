{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst RpcMessage_1 = require(\"./RpcMessage\");\n\nfunction createRpcService(port) {\n  const handlers = new Map();\n  let isListenerRegistered = false;\n\n  const callListener = message => __awaiter(this, void 0, void 0, function* () {\n    if (RpcMessage_1.isRpcCallMessage(message)) {\n      const handler = handlers.get(message.procedure);\n\n      try {\n        if (!handler) {\n          throw new Error(`No handler found for procedure ${message.procedure}.`);\n        }\n\n        const result = yield handler(message.payload);\n        yield port.dispatchMessage(RpcMessage_1.createRpcReturn(message.procedure, message.id, result));\n      } catch (error) {\n        yield port.dispatchMessage(RpcMessage_1.createRpcThrow(message.procedure, message.id, {\n          message: error.toString(),\n          stack: error.stack\n        }));\n      }\n    }\n  });\n\n  return {\n    isOpen: () => port.isOpen() && isListenerRegistered,\n    open: () => __awaiter(this, void 0, void 0, function* () {\n      if (!port.isOpen()) {\n        yield port.open();\n      }\n\n      if (!isListenerRegistered) {\n        port.addMessageListener(callListener);\n        isListenerRegistered = true;\n      }\n    }),\n    close: () => __awaiter(this, void 0, void 0, function* () {\n      if (isListenerRegistered) {\n        port.removeMessageListener(callListener);\n        isListenerRegistered = false;\n      }\n\n      if (port.isOpen()) {\n        yield port.close();\n      }\n    }),\n    addCallHandler: (procedure, handler) => {\n      if (handlers.has(procedure)) {\n        throw new Error(`Handler for '${procedure}' procedure has been already registered`);\n      }\n\n      handlers.set(procedure, handler);\n    },\n    removeCallHandler: procedure => handlers.delete(procedure)\n  };\n}\n\nexports.createRpcService = createRpcService;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","RpcMessage_1","require","createRpcService","port","handlers","Map","isListenerRegistered","callListener","message","isRpcCallMessage","handler","get","procedure","Error","payload","dispatchMessage","createRpcReturn","id","error","createRpcThrow","toString","stack","isOpen","open","addMessageListener","close","removeMessageListener","addCallHandler","has","set","removeCallHandler","delete"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/fork-ts-checker-webpack-plugin/lib/rpc/RpcService.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst RpcMessage_1 = require(\"./RpcMessage\");\nfunction createRpcService(port) {\n    const handlers = new Map();\n    let isListenerRegistered = false;\n    const callListener = (message) => __awaiter(this, void 0, void 0, function* () {\n        if (RpcMessage_1.isRpcCallMessage(message)) {\n            const handler = handlers.get(message.procedure);\n            try {\n                if (!handler) {\n                    throw new Error(`No handler found for procedure ${message.procedure}.`);\n                }\n                const result = yield handler(message.payload);\n                yield port.dispatchMessage(RpcMessage_1.createRpcReturn(message.procedure, message.id, result));\n            }\n            catch (error) {\n                yield port.dispatchMessage(RpcMessage_1.createRpcThrow(message.procedure, message.id, {\n                    message: error.toString(),\n                    stack: error.stack,\n                }));\n            }\n        }\n    });\n    return {\n        isOpen: () => port.isOpen() && isListenerRegistered,\n        open: () => __awaiter(this, void 0, void 0, function* () {\n            if (!port.isOpen()) {\n                yield port.open();\n            }\n            if (!isListenerRegistered) {\n                port.addMessageListener(callListener);\n                isListenerRegistered = true;\n            }\n        }),\n        close: () => __awaiter(this, void 0, void 0, function* () {\n            if (isListenerRegistered) {\n                port.removeMessageListener(callListener);\n                isListenerRegistered = false;\n            }\n            if (port.isOpen()) {\n                yield port.close();\n            }\n        }),\n        addCallHandler: (procedure, handler) => {\n            if (handlers.has(procedure)) {\n                throw new Error(`Handler for '${procedure}' procedure has been already registered`);\n            }\n            handlers.set(procedure, handler);\n        },\n        removeCallHandler: (procedure) => handlers.delete(procedure),\n    };\n}\nexports.createRpcService = createRpcService;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}