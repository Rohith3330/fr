{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentPlaceholder = ArgumentPlaceholder;\nexports.ArrayPattern = exports.ArrayExpression = ArrayExpression;\nexports.BigIntLiteral = BigIntLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.DecimalLiteral = DecimalLiteral;\nexports.Identifier = Identifier;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectPattern = exports.ObjectExpression = ObjectExpression;\nexports.ObjectMethod = ObjectMethod;\nexports.ObjectProperty = ObjectProperty;\nexports.PipelineBareFunction = PipelineBareFunction;\nexports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;\nexports.PipelineTopicExpression = PipelineTopicExpression;\nexports.RecordExpression = RecordExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.SpreadElement = exports.RestElement = RestElement;\nexports.StringLiteral = StringLiteral;\nexports.TopicReference = TopicReference;\nexports.TupleExpression = TupleExpression;\n\nvar _t = require(\"@babel/types\");\n\nvar _jsesc = require(\"jsesc\");\n\nconst {\n  isAssignmentPattern,\n  isIdentifier\n} = _t;\n\nfunction Identifier(node) {\n  this.exactSource(node.loc, () => {\n    this.word(node.name);\n  });\n}\n\nfunction ArgumentPlaceholder() {\n  this.tokenChar(63);\n}\n\nfunction RestElement(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nfunction ObjectExpression(node) {\n  const props = node.properties;\n  this.tokenChar(123);\n  this.printInnerComments(node);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, node, {\n      indent: true,\n      statement: true\n    });\n    this.space();\n  }\n\n  this.tokenChar(125);\n}\n\nfunction ObjectMethod(node) {\n  this.printJoin(node.decorators, node);\n\n  this._methodHead(node);\n\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ObjectProperty(node) {\n  this.printJoin(node.decorators, node);\n\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key, node);\n    this.tokenChar(93);\n  } else {\n    if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {\n      this.print(node.value, node);\n      return;\n    }\n\n    this.print(node.key, node);\n\n    if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {\n      return;\n    }\n  }\n\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value, node);\n}\n\nfunction ArrayExpression(node) {\n  const elems = node.elements;\n  const len = elems.length;\n  this.tokenChar(91);\n  this.printInnerComments(node);\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.tokenChar(44);\n    } else {\n      this.tokenChar(44);\n    }\n  }\n\n  this.tokenChar(93);\n}\n\nfunction RecordExpression(node) {\n  const props = node.properties;\n  let startToken;\n  let endToken;\n\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"{|\";\n    endToken = \"|}\";\n  } else if (this.format.recordAndTupleSyntaxType !== \"hash\" && this.format.recordAndTupleSyntaxType != null) {\n    throw new Error(`The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);\n  } else {\n    startToken = \"#{\";\n    endToken = \"}\";\n  }\n\n  this.token(startToken);\n  this.printInnerComments(node);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, node, {\n      indent: true,\n      statement: true\n    });\n    this.space();\n  }\n\n  this.token(endToken);\n}\n\nfunction TupleExpression(node) {\n  const elems = node.elements;\n  const len = elems.length;\n  let startToken;\n  let endToken;\n\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"[|\";\n    endToken = \"|]\";\n  } else if (this.format.recordAndTupleSyntaxType === \"hash\") {\n    startToken = \"#[\";\n    endToken = \"]\";\n  } else {\n    throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);\n  }\n\n  this.token(startToken);\n  this.printInnerComments(node);\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.tokenChar(44);\n    }\n  }\n\n  this.token(endToken);\n}\n\nfunction RegExpLiteral(node) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\n\nfunction BooleanLiteral(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nfunction NullLiteral() {\n  this.word(\"null\");\n}\n\nfunction NumericLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value + \"\";\n\n  if (opts.numbers) {\n    this.number(_jsesc(node.value, opts));\n  } else if (raw == null) {\n    this.number(value);\n  } else if (this.format.minified) {\n    this.number(raw.length < value.length ? raw : value);\n  } else {\n    this.number(raw);\n  }\n}\n\nfunction StringLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const val = _jsesc(node.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && {\n    json: true\n  }));\n\n  return this.token(val);\n}\n\nfunction BigIntLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n\n  this.word(node.value + \"n\");\n}\n\nfunction DecimalLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n\n  this.word(node.value + \"m\");\n}\n\nconst validTopicTokenSet = new Set([\"^^\", \"@@\", \"^\", \"%\", \"#\"]);\n\nfunction TopicReference() {\n  const {\n    topicToken\n  } = this.format;\n\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(`The \"topicToken\" generator option must be one of ` + `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`);\n  }\n}\n\nfunction PipelineTopicExpression(node) {\n  this.print(node.expression, node);\n}\n\nfunction PipelineBareFunction(node) {\n  this.print(node.callee, node);\n}\n\nfunction PipelinePrimaryTopicReference() {\n  this.tokenChar(35);\n}","map":{"version":3,"mappings":"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","names":["isAssignmentPattern","isIdentifier","Identifier","node","exactSource","loc","word","name","ArgumentPlaceholder","token","RestElement","print","argument","ObjectExpression","props","properties","printInnerComments","length","space","printList","indent","statement","ObjectMethod","printJoin","decorators","_methodHead","body","ObjectProperty","computed","key","value","left","shorthand","ArrayExpression","elems","elements","len","i","elem","RecordExpression","startToken","endToken","format","recordAndTupleSyntaxType","Error","JSON","stringify","TupleExpression","RegExpLiteral","pattern","flags","BooleanLiteral","NullLiteral","NumericLiteral","raw","getPossibleRaw","opts","jsescOption","numbers","number","jsesc","minified","StringLiteral","undefined","val","Object","assign","jsonCompatibleStrings","json","BigIntLiteral","DecimalLiteral","validTopicTokenSet","Set","TopicReference","topicToken","has","givenTopicTokenJSON","validTopics","Array","from","v","join","PipelineTopicExpression","expression","PipelineBareFunction","callee","PipelinePrimaryTopicReference"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\generator\\src\\generators\\types.ts"],"sourcesContent":["import type Printer from \"../printer\";\nimport { isAssignmentPattern, isIdentifier } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport jsesc from \"jsesc\";\n\nexport function Identifier(this: Printer, node: t.Identifier) {\n  this.exactSource(node.loc, () => {\n    this.word(node.name);\n  });\n}\n\nexport function ArgumentPlaceholder(this: Printer) {\n  this.token(\"?\");\n}\n\nexport function RestElement(this: Printer, node: t.RestElement) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nexport { RestElement as SpreadElement };\n\nexport function ObjectExpression(this: Printer, node: t.ObjectExpression) {\n  const props = node.properties;\n\n  this.token(\"{\");\n  this.printInnerComments(node);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, node, { indent: true, statement: true });\n    this.space();\n  }\n\n  this.token(\"}\");\n}\n\nexport { ObjectExpression as ObjectPattern };\n\nexport function ObjectMethod(this: Printer, node: t.ObjectMethod) {\n  this.printJoin(node.decorators, node);\n  this._methodHead(node);\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function ObjectProperty(this: Printer, node: t.ObjectProperty) {\n  this.printJoin(node.decorators, node);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key, node);\n    this.token(\"]\");\n  } else {\n    // print `({ foo: foo = 5 } = {})` as `({ foo = 5 } = {});`\n    if (\n      isAssignmentPattern(node.value) &&\n      isIdentifier(node.key) &&\n      // @ts-expect-error todo(flow->ts) `.name` does not exist on some types in union\n      node.key.name === node.value.left.name\n    ) {\n      this.print(node.value, node);\n      return;\n    }\n\n    this.print(node.key, node);\n\n    // shorthand!\n    if (\n      node.shorthand &&\n      isIdentifier(node.key) &&\n      isIdentifier(node.value) &&\n      node.key.name === node.value.name\n    ) {\n      return;\n    }\n  }\n\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nexport function ArrayExpression(this: Printer, node: t.ArrayExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  this.token(\"[\");\n  this.printInnerComments(node);\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.token(\",\");\n    } else {\n      // If the array expression ends with a hole, that hole\n      // will be ignored by the interpreter, but if it ends with\n      // two (or more) holes, we need to write out two (or more)\n      // commas so that the resulting code is interpreted with\n      // both (all) of the holes.\n      this.token(\",\");\n    }\n  }\n\n  this.token(\"]\");\n}\n\nexport { ArrayExpression as ArrayPattern };\n\nexport function RecordExpression(this: Printer, node: t.RecordExpression) {\n  const props = node.properties;\n\n  let startToken;\n  let endToken;\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"{|\";\n    endToken = \"|}\";\n  } else if (\n    this.format.recordAndTupleSyntaxType !== \"hash\" &&\n    this.format.recordAndTupleSyntaxType != null\n  ) {\n    throw new Error(\n      `The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (${JSON.stringify(\n        this.format.recordAndTupleSyntaxType,\n      )} received).`,\n    );\n  } else {\n    startToken = \"#{\";\n    endToken = \"}\";\n  }\n\n  this.token(startToken);\n  this.printInnerComments(node);\n\n  if (props.length) {\n    this.space();\n    this.printList(props, node, { indent: true, statement: true });\n    this.space();\n  }\n  this.token(endToken);\n}\n\nexport function TupleExpression(this: Printer, node: t.TupleExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  let startToken;\n  let endToken;\n  if (this.format.recordAndTupleSyntaxType === \"bar\") {\n    startToken = \"[|\";\n    endToken = \"|]\";\n  } else if (this.format.recordAndTupleSyntaxType === \"hash\") {\n    startToken = \"#[\";\n    endToken = \"]\";\n  } else {\n    throw new Error(\n      `${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`,\n    );\n  }\n\n  this.token(startToken);\n  this.printInnerComments(node);\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem, node);\n      if (i < len - 1) this.token(\",\");\n    }\n  }\n\n  this.token(endToken);\n}\n\nexport function RegExpLiteral(this: Printer, node: t.RegExpLiteral) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\n\nexport function BooleanLiteral(this: Printer, node: t.BooleanLiteral) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteral(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function NumericLiteral(this: Printer, node: t.NumericLiteral) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value + \"\";\n  if (opts.numbers) {\n    this.number(jsesc(node.value, opts));\n  } else if (raw == null) {\n    this.number(value); // normalize\n  } else if (this.format.minified) {\n    this.number(raw.length < value.length ? raw : value);\n  } else {\n    this.number(raw);\n  }\n}\n\nexport function StringLiteral(this: Printer, node: t.StringLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const val = jsesc(\n    node.value,\n    process.env.BABEL_8_BREAKING\n      ? this.format.jsescOption\n      : Object.assign(\n          this.format.jsescOption,\n          this.format.jsonCompatibleStrings && { json: true },\n        ),\n  );\n\n  return this.token(val);\n}\n\nexport function BigIntLiteral(this: Printer, node: t.BigIntLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"n\");\n}\n\nexport function DecimalLiteral(this: Printer, node: t.DecimalLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"m\");\n}\n\n// Hack pipe operator\nconst validTopicTokenSet = new Set([\"^^\", \"@@\", \"^\", \"%\", \"#\"]);\nexport function TopicReference(this: Printer) {\n  const { topicToken } = this.format;\n\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(\n      `The \"topicToken\" generator option must be one of ` +\n        `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`,\n    );\n  }\n}\n\n// Smart-mix pipe operator\nexport function PipelineTopicExpression(\n  this: Printer,\n  node: t.PipelineTopicExpression,\n) {\n  this.print(node.expression, node);\n}\n\nexport function PipelineBareFunction(\n  this: Printer,\n  node: t.PipelineBareFunction,\n) {\n  this.print(node.callee, node);\n}\n\nexport function PipelinePrimaryTopicReference(this: Printer) {\n  this.token(\"#\");\n}\n"]},"metadata":{},"sourceType":"script"}