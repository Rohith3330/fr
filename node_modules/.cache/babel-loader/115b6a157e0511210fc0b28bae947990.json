{"ast":null,"code":"const REGEX_SPECIAL = /[\\\\^$.*+?()[\\]{}|]/g;\nconst REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source);\n/**\n * @param {string|RegExp|Array<string|RegExp>} source\n */\n\nfunction toSource(source) {\n  source = Array.isArray(source) ? source : [source];\n  source = source.map(item => item instanceof RegExp ? item.source : item);\n  return source.join('');\n}\n/**\n * @param {string|RegExp|Array<string|RegExp>} source\n */\n\n\nexport function pattern(source) {\n  return new RegExp(toSource(source), 'g');\n}\n/**\n * @param {string|RegExp|Array<string|RegExp>} source\n */\n\nexport function withoutCapturing(source) {\n  return new RegExp(`(?:${toSource(source)})`, 'g');\n}\n/**\n * @param {Array<string|RegExp>} sources\n */\n\nexport function any(sources) {\n  return `(?:${sources.map(toSource).join('|')})`;\n}\n/**\n * @param {string|RegExp} source\n */\n\nexport function optional(source) {\n  return `(?:${toSource(source)})?`;\n}\n/**\n * @param {string|RegExp|Array<string|RegExp>} source\n */\n\nexport function zeroOrMore(source) {\n  return `(?:${toSource(source)})*`;\n}\n/**\n * Generate a RegExp that matches balanced brackets for a given depth\n * We have to specify a depth because JS doesn't support recursive groups using ?R\n *\n * Based on https://stackoverflow.com/questions/17759004/how-to-match-string-within-parentheses-nested-in-java/17759264#17759264\n *\n * @param {string|RegExp|Array<string|RegExp>} source\n */\n\nexport function nestedBrackets(open, close) {\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return withoutCapturing([escape(open), /[^\\s]*/, depth === 1 ? `[^${escape(open)}${escape(close)}\\s]*` : any([`[^${escape(open)}${escape(close)}\\s]*`, nestedBrackets(open, close, depth - 1)]), /[^\\s]*/, escape(close)]);\n}\nexport function escape(string) {\n  return string && REGEX_HAS_SPECIAL.test(string) ? string.replace(REGEX_SPECIAL, '\\\\$&') : string || '';\n}","map":{"version":3,"names":["REGEX_SPECIAL","REGEX_HAS_SPECIAL","RegExp","source","toSource","Array","isArray","map","item","join","pattern","withoutCapturing","any","sources","optional","zeroOrMore","nestedBrackets","open","close","depth","escape","string","test","replace"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/src/lib/regex.js"],"sourcesContent":["const REGEX_SPECIAL = /[\\\\^$.*+?()[\\]{}|]/g\nconst REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source)\n\n/**\n * @param {string|RegExp|Array<string|RegExp>} source\n */\nfunction toSource(source) {\n  source = Array.isArray(source) ? source : [source]\n\n  source = source.map((item) => (item instanceof RegExp ? item.source : item))\n\n  return source.join('')\n}\n\n/**\n * @param {string|RegExp|Array<string|RegExp>} source\n */\nexport function pattern(source) {\n  return new RegExp(toSource(source), 'g')\n}\n\n/**\n * @param {string|RegExp|Array<string|RegExp>} source\n */\nexport function withoutCapturing(source) {\n  return new RegExp(`(?:${toSource(source)})`, 'g')\n}\n\n/**\n * @param {Array<string|RegExp>} sources\n */\nexport function any(sources) {\n  return `(?:${sources.map(toSource).join('|')})`\n}\n\n/**\n * @param {string|RegExp} source\n */\nexport function optional(source) {\n  return `(?:${toSource(source)})?`\n}\n\n/**\n * @param {string|RegExp|Array<string|RegExp>} source\n */\nexport function zeroOrMore(source) {\n  return `(?:${toSource(source)})*`\n}\n\n/**\n * Generate a RegExp that matches balanced brackets for a given depth\n * We have to specify a depth because JS doesn't support recursive groups using ?R\n *\n * Based on https://stackoverflow.com/questions/17759004/how-to-match-string-within-parentheses-nested-in-java/17759264#17759264\n *\n * @param {string|RegExp|Array<string|RegExp>} source\n */\nexport function nestedBrackets(open, close, depth = 1) {\n  return withoutCapturing([\n    escape(open),\n    /[^\\s]*/,\n    depth === 1\n      ? `[^${escape(open)}${escape(close)}\\s]*`\n      : any([`[^${escape(open)}${escape(close)}\\s]*`, nestedBrackets(open, close, depth - 1)]),\n    /[^\\s]*/,\n    escape(close),\n  ])\n}\n\nexport function escape(string) {\n  return string && REGEX_HAS_SPECIAL.test(string)\n    ? string.replace(REGEX_SPECIAL, '\\\\$&')\n    : string || ''\n}\n"],"mappings":"AAAA,MAAMA,aAAa,GAAG,qBAAtB;AACA,MAAMC,iBAAiB,GAAGC,MAAM,CAACF,aAAa,CAACG,MAAf,CAAhC;AAEA;AACA;AACA;;AACA,SAASC,QAAT,CAAkBD,MAAlB,EAA0B;EACxBA,MAAM,GAAGE,KAAK,CAACC,OAAN,CAAcH,MAAd,IAAwBA,MAAxB,GAAiC,CAACA,MAAD,CAA1C;EAEAA,MAAM,GAAGA,MAAM,CAACI,GAAP,CAAYC,IAAD,IAAWA,IAAI,YAAYN,MAAhB,GAAyBM,IAAI,CAACL,MAA9B,GAAuCK,IAA7D,CAAT;EAEA,OAAOL,MAAM,CAACM,IAAP,CAAY,EAAZ,CAAP;AACD;AAED;AACA;AACA;;;AACA,OAAO,SAASC,OAAT,CAAiBP,MAAjB,EAAyB;EAC9B,OAAO,IAAID,MAAJ,CAAWE,QAAQ,CAACD,MAAD,CAAnB,EAA6B,GAA7B,CAAP;AACD;AAED;AACA;AACA;;AACA,OAAO,SAASQ,gBAAT,CAA0BR,MAA1B,EAAkC;EACvC,OAAO,IAAID,MAAJ,CAAY,MAAKE,QAAQ,CAACD,MAAD,CAAS,GAAlC,EAAsC,GAAtC,CAAP;AACD;AAED;AACA;AACA;;AACA,OAAO,SAASS,GAAT,CAAaC,OAAb,EAAsB;EAC3B,OAAQ,MAAKA,OAAO,CAACN,GAAR,CAAYH,QAAZ,EAAsBK,IAAtB,CAA2B,GAA3B,CAAgC,GAA7C;AACD;AAED;AACA;AACA;;AACA,OAAO,SAASK,QAAT,CAAkBX,MAAlB,EAA0B;EAC/B,OAAQ,MAAKC,QAAQ,CAACD,MAAD,CAAS,IAA9B;AACD;AAED;AACA;AACA;;AACA,OAAO,SAASY,UAAT,CAAoBZ,MAApB,EAA4B;EACjC,OAAQ,MAAKC,QAAQ,CAACD,MAAD,CAAS,IAA9B;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASa,cAAT,CAAwBC,IAAxB,EAA8BC,KAA9B,EAAgD;EAAA,IAAXC,KAAW,uEAAH,CAAG;EACrD,OAAOR,gBAAgB,CAAC,CACtBS,MAAM,CAACH,IAAD,CADgB,EAEtB,QAFsB,EAGtBE,KAAK,KAAK,CAAV,GACK,KAAIC,MAAM,CAACH,IAAD,CAAO,GAAEG,MAAM,CAACF,KAAD,CAAQ,MADtC,GAEIN,GAAG,CAAC,CAAE,KAAIQ,MAAM,CAACH,IAAD,CAAO,GAAEG,MAAM,CAACF,KAAD,CAAQ,MAAnC,EAA0CF,cAAc,CAACC,IAAD,EAAOC,KAAP,EAAcC,KAAK,GAAG,CAAtB,CAAxD,CAAD,CALe,EAMtB,QANsB,EAOtBC,MAAM,CAACF,KAAD,CAPgB,CAAD,CAAvB;AASD;AAED,OAAO,SAASE,MAAT,CAAgBC,MAAhB,EAAwB;EAC7B,OAAOA,MAAM,IAAIpB,iBAAiB,CAACqB,IAAlB,CAAuBD,MAAvB,CAAV,GACHA,MAAM,CAACE,OAAP,CAAevB,aAAf,EAA8B,MAA9B,CADG,GAEHqB,MAAM,IAAI,EAFd;AAGD"},"metadata":{},"sourceType":"module"}