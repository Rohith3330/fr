{"ast":null,"code":"\"use strict\"; // any is required to work around manipulating the AST in weird ways\n\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\n\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-extra-parens');\nexports.default = util.createRule({\n  name: 'no-extra-parens',\n  meta: {\n    type: 'layout',\n    docs: {\n      description: 'Disallow unnecessary parentheses',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    fixable: 'code',\n    hasSuggestions: baseRule.meta.hasSuggestions,\n    schema: baseRule.meta.schema,\n    messages: baseRule.meta.messages\n  },\n  defaultOptions: ['all'],\n\n  create(context) {\n    const rules = baseRule.create(context);\n\n    function binaryExp(node) {\n      const rule = rules.BinaryExpression; // makes the rule think it should skip the left or right\n\n      const isLeftTypeAssertion = util.isTypeAssertion(node.left);\n      const isRightTypeAssertion = util.isTypeAssertion(node.right);\n\n      if (isLeftTypeAssertion && isRightTypeAssertion) {\n        return; // ignore\n      }\n\n      if (isLeftTypeAssertion) {\n        return rule(Object.assign(Object.assign({}, node), {\n          left: Object.assign(Object.assign({}, node.left), {\n            type: utils_1.AST_NODE_TYPES.SequenceExpression\n          })\n        }));\n      }\n\n      if (isRightTypeAssertion) {\n        return rule(Object.assign(Object.assign({}, node), {\n          right: Object.assign(Object.assign({}, node.right), {\n            type: utils_1.AST_NODE_TYPES.SequenceExpression\n          })\n        }));\n      }\n\n      return rule(node);\n    }\n\n    function callExp(node) {\n      var _a;\n\n      const rule = rules.CallExpression;\n\n      if (util.isTypeAssertion(node.callee)) {\n        // reduces the precedence of the node so the rule thinks it needs to be wrapped\n        return rule(Object.assign(Object.assign({}, node), {\n          callee: Object.assign(Object.assign({}, node.callee), {\n            type: utils_1.AST_NODE_TYPES.SequenceExpression\n          })\n        }));\n      }\n\n      if (node.arguments.length === 1 && ((_a = node.typeParameters) === null || _a === void 0 ? void 0 : _a.params.some(param => param.type === utils_1.AST_NODE_TYPES.TSImportType || param.type === utils_1.AST_NODE_TYPES.TSArrayType))) {\n        return rule(Object.assign(Object.assign({}, node), {\n          arguments: [Object.assign(Object.assign({}, node.arguments[0]), {\n            type: utils_1.AST_NODE_TYPES.SequenceExpression\n          })]\n        }));\n      }\n\n      return rule(node);\n    }\n\n    function unaryUpdateExpression(node) {\n      const rule = rules.UnaryExpression;\n\n      if (util.isTypeAssertion(node.argument)) {\n        // reduces the precedence of the node so the rule thinks it needs to be wrapped\n        return rule(Object.assign(Object.assign({}, node), {\n          argument: Object.assign(Object.assign({}, node.argument), {\n            type: utils_1.AST_NODE_TYPES.SequenceExpression\n          })\n        }));\n      }\n\n      return rule(node);\n    }\n\n    const overrides = {\n      // ArrayExpression\n      ArrowFunctionExpression(node) {\n        if (!util.isTypeAssertion(node.body)) {\n          return rules.ArrowFunctionExpression(node);\n        }\n      },\n\n      // AssignmentExpression\n      AwaitExpression(node) {\n        if (util.isTypeAssertion(node.argument)) {\n          // reduces the precedence of the node so the rule thinks it needs to be wrapped\n          return rules.AwaitExpression(Object.assign(Object.assign({}, node), {\n            argument: Object.assign(Object.assign({}, node.argument), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n\n        return rules.AwaitExpression(node);\n      },\n\n      BinaryExpression: binaryExp,\n      CallExpression: callExp,\n\n      // ClassDeclaration\n      // ClassExpression\n      ConditionalExpression(node) {\n        // reduces the precedence of the node so the rule thinks it needs to be wrapped\n        if (util.isTypeAssertion(node.test)) {\n          return rules.ConditionalExpression(Object.assign(Object.assign({}, node), {\n            test: Object.assign(Object.assign({}, node.test), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n\n        if (util.isTypeAssertion(node.consequent)) {\n          return rules.ConditionalExpression(Object.assign(Object.assign({}, node), {\n            consequent: Object.assign(Object.assign({}, node.consequent), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n\n        if (util.isTypeAssertion(node.alternate)) {\n          // reduces the precedence of the node so the rule thinks it needs to be wrapped\n          return rules.ConditionalExpression(Object.assign(Object.assign({}, node), {\n            alternate: Object.assign(Object.assign({}, node.alternate), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n\n        return rules.ConditionalExpression(node);\n      },\n\n      // DoWhileStatement\n      // ForIn and ForOf are guarded by eslint version\n      ForStatement(node) {\n        // make the rule skip the piece by removing it entirely\n        if (node.init && util.isTypeAssertion(node.init)) {\n          return rules.ForStatement(Object.assign(Object.assign({}, node), {\n            init: null\n          }));\n        }\n\n        if (node.test && util.isTypeAssertion(node.test)) {\n          return rules.ForStatement(Object.assign(Object.assign({}, node), {\n            test: null\n          }));\n        }\n\n        if (node.update && util.isTypeAssertion(node.update)) {\n          return rules.ForStatement(Object.assign(Object.assign({}, node), {\n            update: null\n          }));\n        }\n\n        return rules.ForStatement(node);\n      },\n\n      'ForStatement > *.init:exit'(node) {\n        if (!util.isTypeAssertion(node)) {\n          return rules['ForStatement > *.init:exit'](node);\n        }\n      },\n\n      // IfStatement\n      LogicalExpression: binaryExp,\n\n      MemberExpression(node) {\n        if (util.isTypeAssertion(node.object)) {\n          // reduces the precedence of the node so the rule thinks it needs to be wrapped\n          return rules.MemberExpression(Object.assign(Object.assign({}, node), {\n            object: Object.assign(Object.assign({}, node.object), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n\n        return rules.MemberExpression(node);\n      },\n\n      NewExpression: callExp,\n\n      // ObjectExpression\n      // ReturnStatement\n      // SequenceExpression\n      SpreadElement(node) {\n        if (!util.isTypeAssertion(node.argument)) {\n          return rules.SpreadElement(node);\n        }\n      },\n\n      SwitchCase(node) {\n        if (node.test && !util.isTypeAssertion(node.test)) {\n          return rules.SwitchCase(node);\n        }\n      },\n\n      // SwitchStatement\n      ThrowStatement(node) {\n        if (node.argument && !util.isTypeAssertion(node.argument)) {\n          return rules.ThrowStatement(node);\n        }\n      },\n\n      UnaryExpression: unaryUpdateExpression,\n      UpdateExpression: unaryUpdateExpression,\n\n      // VariableDeclarator\n      // WhileStatement\n      // WithStatement - i'm not going to even bother implementing this terrible and never used feature\n      YieldExpression(node) {\n        if (node.argument && !util.isTypeAssertion(node.argument)) {\n          return rules.YieldExpression(node);\n        }\n      }\n\n    };\n\n    if (rules.ForInStatement && rules.ForOfStatement) {\n      overrides.ForInStatement = function (node) {\n        if (util.isTypeAssertion(node.right)) {\n          // as of 7.20.0 there's no way to skip checking the right of the ForIn\n          // so just don't validate it at all\n          return;\n        }\n\n        return rules.ForInStatement(node);\n      };\n\n      overrides.ForOfStatement = function (node) {\n        if (util.isTypeAssertion(node.right)) {\n          // makes the rule skip checking of the right\n          return rules.ForOfStatement(Object.assign(Object.assign({}, node), {\n            type: utils_1.AST_NODE_TYPES.ForOfStatement,\n            right: Object.assign(Object.assign({}, node.right), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n\n        return rules.ForOfStatement(node);\n      };\n    } else {\n      overrides['ForInStatement, ForOfStatement'] = function (node) {\n        if (util.isTypeAssertion(node.right)) {\n          // makes the rule skip checking of the right\n          return rules['ForInStatement, ForOfStatement'](Object.assign(Object.assign({}, node), {\n            type: utils_1.AST_NODE_TYPES.ForOfStatement,\n            right: Object.assign(Object.assign({}, node.right), {\n              type: utils_1.AST_NODE_TYPES.SequenceExpression\n            })\n          }));\n        }\n\n        return rules['ForInStatement, ForOfStatement'](node);\n      };\n    }\n\n    return Object.assign({}, rules, overrides);\n  }\n\n});","map":{"version":3,"mappings":"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","names":["baseRule","exports","util","createRule","name","meta","type","docs","description","recommended","extendsBaseRule","fixable","hasSuggestions","schema","messages","defaultOptions","create","context","rules","binaryExp","node","rule","BinaryExpression","isLeftTypeAssertion","isTypeAssertion","left","isRightTypeAssertion","right","utils_1","SequenceExpression","callExp","CallExpression","callee","arguments","length","typeParameters","_a","params","some","param","TSImportType","TSArrayType","unaryUpdateExpression","UnaryExpression","argument","overrides","ArrowFunctionExpression","body","AwaitExpression","Object","ConditionalExpression","test","consequent","alternate","ForStatement","init","update","LogicalExpression","MemberExpression","object","NewExpression","SpreadElement","SwitchCase","ThrowStatement","UpdateExpression","YieldExpression","ForInStatement","ForOfStatement","assign"],"sources":["../../src/rules/no-extra-parens.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}