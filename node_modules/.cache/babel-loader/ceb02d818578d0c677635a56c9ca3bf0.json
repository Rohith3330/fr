{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n\n_export(exports, {\n  selectorFunctions: () => selectorFunctions,\n  formatVariantSelector: () => formatVariantSelector,\n  finalizeSelector: () => finalizeSelector\n});\n\nconst _postcssSelectorParser = /*#__PURE__*/_interopRequireDefault(require(\"postcss-selector-parser\"));\n\nconst _unesc = /*#__PURE__*/_interopRequireDefault(require(\"postcss-selector-parser/dist/util/unesc\"));\n\nconst _escapeClassName = /*#__PURE__*/_interopRequireDefault(require(\"../util/escapeClassName\"));\n\nconst _prefixSelector = /*#__PURE__*/_interopRequireDefault(require(\"../util/prefixSelector\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar ref;\nlet MERGE = \":merge\";\nlet PARENT = \"&\";\nlet selectorFunctions = new Set([MERGE]);\n\nfunction formatVariantSelector(current) {\n  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    others[_key - 1] = arguments[_key];\n  }\n\n  for (let other of others) {\n    let incomingValue = resolveFunctionArgument(other, MERGE);\n\n    if (incomingValue !== null) {\n      let existingValue = resolveFunctionArgument(current, MERGE, incomingValue);\n\n      if (existingValue !== null) {\n        let existingTarget = `${MERGE}(${incomingValue})`;\n        let splitIdx = other.indexOf(existingTarget);\n        let addition = other.slice(splitIdx + existingTarget.length).split(\" \")[0];\n        current = current.replace(existingTarget, existingTarget + addition);\n        continue;\n      }\n    }\n\n    current = other.replace(PARENT, current);\n  }\n\n  return current;\n}\n\nvar ref1;\n\nfunction finalizeSelector(format, _ref) {\n  let {\n    selector,\n    candidate,\n    context,\n    isArbitraryVariant,\n    // Split by the separator, but ignore the separator inside square brackets:\n    //\n    // E.g.: dark:lg:hover:[paint-order:markers]\n    //           ┬  ┬     ┬            ┬\n    //           │  │     │            ╰── We will not split here\n    //           ╰──┴─────┴─────────────── We will split here\n    //\n    base = candidate.split(new RegExp(`\\\\${(ref1 = context === null || context === void 0 ? void 0 : (ref = context.tailwindConfig) === null || ref === void 0 ? void 0 : ref.separator) !== null && ref1 !== void 0 ? ref1 : \":\"}(?![^[]*\\\\])`)).pop()\n  } = _ref;\n  var ref2;\n  let ast = (0, _postcssSelectorParser.default)().astSync(selector); // We explicitly DO NOT prefix classes in arbitrary variants\n\n  if ((context === null || context === void 0 ? void 0 : (ref2 = context.tailwindConfig) === null || ref2 === void 0 ? void 0 : ref2.prefix) && !isArbitraryVariant) {\n    format = (0, _prefixSelector.default)(context.tailwindConfig.prefix, format);\n  }\n\n  format = format.replace(PARENT, `.${(0, _escapeClassName.default)(candidate)}`);\n  let formatAst = (0, _postcssSelectorParser.default)().astSync(format); // Remove extraneous selectors that do not include the base class/candidate being matched against\n  // For example if we have a utility defined `.a, .b { color: red}`\n  // And the formatted variant is sm:b then we want the final selector to be `.sm\\:b` and not `.a, .sm\\:b`\n\n  ast.each(node => {\n    let hasClassesMatchingCandidate = node.some(n => n.type === \"class\" && n.value === base);\n\n    if (!hasClassesMatchingCandidate) {\n      node.remove();\n    }\n  }); // Normalize escaped classes, e.g.:\n  //\n  // The idea would be to replace the escaped `base` in the selector with the\n  // `format`. However, in css you can escape the same selector in a few\n  // different ways. This would result in different strings and therefore we\n  // can't replace it properly.\n  //\n  //               base: bg-[rgb(255,0,0)]\n  //   base in selector: bg-\\\\[rgb\\\\(255\\\\,0\\\\,0\\\\)\\\\]\n  //       escaped base: bg-\\\\[rgb\\\\(255\\\\2c 0\\\\2c 0\\\\)\\\\]\n  //\n\n  ast.walkClasses(node => {\n    if (node.raws && node.value.includes(base)) {\n      node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));\n    }\n  }); // We can safely replace the escaped base now, since the `base` section is\n  // now in a normalized escaped value.\n\n  ast.walkClasses(node => {\n    if (node.value === base) {\n      node.replaceWith(...formatAst.nodes);\n    }\n  }); // This will make sure to move pseudo's to the correct spot (the end for\n  // pseudo elements) because otherwise the selector will never work\n  // anyway.\n  //\n  // E.g.:\n  //  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n  //  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n  //\n  // `::before:hover` doesn't work, which means that we can make it work for you by flipping the order.\n\n  function collectPseudoElements(selector) {\n    let nodes = [];\n\n    for (let node of selector.nodes) {\n      if (isPseudoElement(node)) {\n        nodes.push(node);\n        selector.removeChild(node);\n      }\n\n      if (node === null || node === void 0 ? void 0 : node.nodes) {\n        nodes.push(...collectPseudoElements(node));\n      }\n    }\n\n    return nodes;\n  } // Remove unnecessary pseudo selectors that we used as placeholders\n\n\n  ast.each(selector => {\n    selector.walkPseudos(p => {\n      if (selectorFunctions.has(p.value)) {\n        p.replaceWith(p.nodes);\n      }\n    });\n    let pseudoElements = collectPseudoElements(selector);\n\n    if (pseudoElements.length > 0) {\n      selector.nodes.push(pseudoElements.sort(sortSelector));\n    }\n  });\n  return ast.toString();\n} // Note: As a rule, double colons (::) should be used instead of a single colon\n// (:). This distinguishes pseudo-classes from pseudo-elements. However, since\n// this distinction was not present in older versions of the W3C spec, most\n// browsers support both syntaxes for the original pseudo-elements.\n\n\nlet pseudoElementsBC = [\":before\", \":after\", \":first-line\", \":first-letter\"]; // These pseudo-elements _can_ be combined with other pseudo selectors AND the order does matter.\n\nlet pseudoElementExceptions = [\"::file-selector-button\"]; // This will make sure to move pseudo's to the correct spot (the end for\n// pseudo elements) because otherwise the selector will never work\n// anyway.\n//\n// E.g.:\n//  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n//  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n//\n// `::before:hover` doesn't work, which means that we can make it work\n// for you by flipping the order.\n\nfunction sortSelector(a, z) {\n  // Both nodes are non-pseudo's so we can safely ignore them and keep\n  // them in the same order.\n  if (a.type !== \"pseudo\" && z.type !== \"pseudo\") {\n    return 0;\n  } // If one of them is a combinator, we need to keep it in the same order\n  // because that means it will start a new \"section\" in the selector.\n\n\n  if (a.type === \"combinator\" ^ z.type === \"combinator\") {\n    return 0;\n  } // One of the items is a pseudo and the other one isn't. Let's move\n  // the pseudo to the right.\n\n\n  if (a.type === \"pseudo\" ^ z.type === \"pseudo\") {\n    return (a.type === \"pseudo\") - (z.type === \"pseudo\");\n  } // Both are pseudo's, move the pseudo elements (except for\n  // ::file-selector-button) to the right.\n\n\n  return isPseudoElement(a) - isPseudoElement(z);\n}\n\nfunction isPseudoElement(node) {\n  if (node.type !== \"pseudo\") return false;\n  if (pseudoElementExceptions.includes(node.value)) return false;\n  return node.value.startsWith(\"::\") || pseudoElementsBC.includes(node.value);\n}\n\nfunction resolveFunctionArgument(haystack, needle, arg) {\n  let startIdx = haystack.indexOf(arg ? `${needle}(${arg})` : needle);\n  if (startIdx === -1) return null; // Start inside the `(`\n\n  startIdx += needle.length + 1;\n  let target = \"\";\n  let count = 0;\n\n  for (let char of haystack.slice(startIdx)) {\n    if (char !== \"(\" && char !== \")\") {\n      target += char;\n    } else if (char === \"(\") {\n      target += char;\n      count++;\n    } else if (char === \")\") {\n      if (--count < 0) break; // unbalanced\n\n      target += char;\n    }\n  }\n\n  return target;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","selectorFunctions","formatVariantSelector","finalizeSelector","_postcssSelectorParser","_interopRequireDefault","require","_unesc","_escapeClassName","_prefixSelector","obj","__esModule","default","ref","MERGE","PARENT","Set","current","others","other","incomingValue","resolveFunctionArgument","existingValue","existingTarget","splitIdx","indexOf","addition","slice","length","split","replace","ref1","format","selector","candidate","context","isArbitraryVariant","base","RegExp","tailwindConfig","separator","pop","ref2","ast","astSync","prefix","formatAst","each","node","hasClassesMatchingCandidate","some","n","type","remove","walkClasses","raws","includes","replaceWith","nodes","collectPseudoElements","isPseudoElement","push","removeChild","walkPseudos","p","has","pseudoElements","sort","sortSelector","toString","pseudoElementsBC","pseudoElementExceptions","a","z","startsWith","haystack","needle","arg","startIdx","count","char"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/lib/util/formatVariantSelector.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    selectorFunctions: ()=>selectorFunctions,\n    formatVariantSelector: ()=>formatVariantSelector,\n    finalizeSelector: ()=>finalizeSelector\n});\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _unesc = /*#__PURE__*/ _interopRequireDefault(require(\"postcss-selector-parser/dist/util/unesc\"));\nconst _escapeClassName = /*#__PURE__*/ _interopRequireDefault(require(\"../util/escapeClassName\"));\nconst _prefixSelector = /*#__PURE__*/ _interopRequireDefault(require(\"../util/prefixSelector\"));\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nvar ref;\nlet MERGE = \":merge\";\nlet PARENT = \"&\";\nlet selectorFunctions = new Set([\n    MERGE\n]);\nfunction formatVariantSelector(current, ...others) {\n    for (let other of others){\n        let incomingValue = resolveFunctionArgument(other, MERGE);\n        if (incomingValue !== null) {\n            let existingValue = resolveFunctionArgument(current, MERGE, incomingValue);\n            if (existingValue !== null) {\n                let existingTarget = `${MERGE}(${incomingValue})`;\n                let splitIdx = other.indexOf(existingTarget);\n                let addition = other.slice(splitIdx + existingTarget.length).split(\" \")[0];\n                current = current.replace(existingTarget, existingTarget + addition);\n                continue;\n            }\n        }\n        current = other.replace(PARENT, current);\n    }\n    return current;\n}\nvar ref1;\nfunction finalizeSelector(format, { selector , candidate , context , isArbitraryVariant , // Split by the separator, but ignore the separator inside square brackets:\n//\n// E.g.: dark:lg:hover:[paint-order:markers]\n//           ┬  ┬     ┬            ┬\n//           │  │     │            ╰── We will not split here\n//           ╰──┴─────┴─────────────── We will split here\n//\nbase =candidate.split(new RegExp(`\\\\${(ref1 = context === null || context === void 0 ? void 0 : (ref = context.tailwindConfig) === null || ref === void 0 ? void 0 : ref.separator) !== null && ref1 !== void 0 ? ref1 : \":\"}(?![^[]*\\\\])`)).pop() ,  }) {\n    var ref2;\n    let ast = (0, _postcssSelectorParser.default)().astSync(selector);\n    // We explicitly DO NOT prefix classes in arbitrary variants\n    if ((context === null || context === void 0 ? void 0 : (ref2 = context.tailwindConfig) === null || ref2 === void 0 ? void 0 : ref2.prefix) && !isArbitraryVariant) {\n        format = (0, _prefixSelector.default)(context.tailwindConfig.prefix, format);\n    }\n    format = format.replace(PARENT, `.${(0, _escapeClassName.default)(candidate)}`);\n    let formatAst = (0, _postcssSelectorParser.default)().astSync(format);\n    // Remove extraneous selectors that do not include the base class/candidate being matched against\n    // For example if we have a utility defined `.a, .b { color: red}`\n    // And the formatted variant is sm:b then we want the final selector to be `.sm\\:b` and not `.a, .sm\\:b`\n    ast.each((node)=>{\n        let hasClassesMatchingCandidate = node.some((n)=>n.type === \"class\" && n.value === base);\n        if (!hasClassesMatchingCandidate) {\n            node.remove();\n        }\n    });\n    // Normalize escaped classes, e.g.:\n    //\n    // The idea would be to replace the escaped `base` in the selector with the\n    // `format`. However, in css you can escape the same selector in a few\n    // different ways. This would result in different strings and therefore we\n    // can't replace it properly.\n    //\n    //               base: bg-[rgb(255,0,0)]\n    //   base in selector: bg-\\\\[rgb\\\\(255\\\\,0\\\\,0\\\\)\\\\]\n    //       escaped base: bg-\\\\[rgb\\\\(255\\\\2c 0\\\\2c 0\\\\)\\\\]\n    //\n    ast.walkClasses((node)=>{\n        if (node.raws && node.value.includes(base)) {\n            node.raws.value = (0, _escapeClassName.default)((0, _unesc.default)(node.raws.value));\n        }\n    });\n    // We can safely replace the escaped base now, since the `base` section is\n    // now in a normalized escaped value.\n    ast.walkClasses((node)=>{\n        if (node.value === base) {\n            node.replaceWith(...formatAst.nodes);\n        }\n    });\n    // This will make sure to move pseudo's to the correct spot (the end for\n    // pseudo elements) because otherwise the selector will never work\n    // anyway.\n    //\n    // E.g.:\n    //  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n    //  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n    //\n    // `::before:hover` doesn't work, which means that we can make it work for you by flipping the order.\n    function collectPseudoElements(selector) {\n        let nodes = [];\n        for (let node of selector.nodes){\n            if (isPseudoElement(node)) {\n                nodes.push(node);\n                selector.removeChild(node);\n            }\n            if (node === null || node === void 0 ? void 0 : node.nodes) {\n                nodes.push(...collectPseudoElements(node));\n            }\n        }\n        return nodes;\n    }\n    // Remove unnecessary pseudo selectors that we used as placeholders\n    ast.each((selector)=>{\n        selector.walkPseudos((p)=>{\n            if (selectorFunctions.has(p.value)) {\n                p.replaceWith(p.nodes);\n            }\n        });\n        let pseudoElements = collectPseudoElements(selector);\n        if (pseudoElements.length > 0) {\n            selector.nodes.push(pseudoElements.sort(sortSelector));\n        }\n    });\n    return ast.toString();\n}\n// Note: As a rule, double colons (::) should be used instead of a single colon\n// (:). This distinguishes pseudo-classes from pseudo-elements. However, since\n// this distinction was not present in older versions of the W3C spec, most\n// browsers support both syntaxes for the original pseudo-elements.\nlet pseudoElementsBC = [\n    \":before\",\n    \":after\",\n    \":first-line\",\n    \":first-letter\"\n];\n// These pseudo-elements _can_ be combined with other pseudo selectors AND the order does matter.\nlet pseudoElementExceptions = [\n    \"::file-selector-button\"\n];\n// This will make sure to move pseudo's to the correct spot (the end for\n// pseudo elements) because otherwise the selector will never work\n// anyway.\n//\n// E.g.:\n//  - `before:hover:text-center` would result in `.before\\:hover\\:text-center:hover::before`\n//  - `hover:before:text-center` would result in `.hover\\:before\\:text-center:hover::before`\n//\n// `::before:hover` doesn't work, which means that we can make it work\n// for you by flipping the order.\nfunction sortSelector(a, z) {\n    // Both nodes are non-pseudo's so we can safely ignore them and keep\n    // them in the same order.\n    if (a.type !== \"pseudo\" && z.type !== \"pseudo\") {\n        return 0;\n    }\n    // If one of them is a combinator, we need to keep it in the same order\n    // because that means it will start a new \"section\" in the selector.\n    if (a.type === \"combinator\" ^ z.type === \"combinator\") {\n        return 0;\n    }\n    // One of the items is a pseudo and the other one isn't. Let's move\n    // the pseudo to the right.\n    if (a.type === \"pseudo\" ^ z.type === \"pseudo\") {\n        return (a.type === \"pseudo\") - (z.type === \"pseudo\");\n    }\n    // Both are pseudo's, move the pseudo elements (except for\n    // ::file-selector-button) to the right.\n    return isPseudoElement(a) - isPseudoElement(z);\n}\nfunction isPseudoElement(node) {\n    if (node.type !== \"pseudo\") return false;\n    if (pseudoElementExceptions.includes(node.value)) return false;\n    return node.value.startsWith(\"::\") || pseudoElementsBC.includes(node.value);\n}\nfunction resolveFunctionArgument(haystack, needle, arg) {\n    let startIdx = haystack.indexOf(arg ? `${needle}(${arg})` : needle);\n    if (startIdx === -1) return null;\n    // Start inside the `(`\n    startIdx += needle.length + 1;\n    let target = \"\";\n    let count = 0;\n    for (let char of haystack.slice(startIdx)){\n        if (char !== \"(\" && char !== \")\") {\n            target += char;\n        } else if (char === \"(\") {\n            target += char;\n            count++;\n        } else if (char === \")\") {\n            if (--count < 0) break; // unbalanced\n            target += char;\n        }\n    }\n    return target;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}