{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst util_1 = require(\"../util\");\n\nvar ArgumentType;\n\n(function (ArgumentType) {\n  ArgumentType[ArgumentType[\"Other\"] = 0] = \"Other\";\n  ArgumentType[ArgumentType[\"String\"] = 1] = \"String\";\n  ArgumentType[ArgumentType[\"RegExp\"] = 2] = \"RegExp\";\n  ArgumentType[ArgumentType[\"Both\"] = 3] = \"Both\";\n})(ArgumentType || (ArgumentType = {}));\n\nexports.default = (0, util_1.createRule)({\n  name: 'prefer-regexp-exec',\n  defaultOptions: [],\n  meta: {\n    type: 'suggestion',\n    fixable: 'code',\n    docs: {\n      description: 'Enforce `RegExp#exec` over `String#match` if no global flag is provided',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    messages: {\n      regExpExecOverStringMatch: 'Use the `RegExp#exec()` method instead.'\n    },\n    schema: []\n  },\n\n  create(context) {\n    const globalScope = context.getScope();\n    const parserServices = (0, util_1.getParserServices)(context);\n    const typeChecker = parserServices.program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n    /**\n     * Check if a given node type is a string.\n     * @param node The node type to check.\n     */\n\n    function isStringType(type) {\n      return (0, util_1.getTypeName)(typeChecker, type) === 'string';\n    }\n    /**\n     * Check if a given node type is a RegExp.\n     * @param node The node type to check.\n     */\n\n\n    function isRegExpType(type) {\n      return (0, util_1.getTypeName)(typeChecker, type) === 'RegExp';\n    }\n\n    function collectArgumentTypes(types) {\n      let result = ArgumentType.Other;\n\n      for (const type of types) {\n        if (isRegExpType(type)) {\n          result |= ArgumentType.RegExp;\n        } else if (isStringType(type)) {\n          result |= ArgumentType.String;\n        }\n      }\n\n      return result;\n    }\n\n    function isLikelyToContainGlobalFlag(node) {\n      if (node.type === utils_1.AST_NODE_TYPES.CallExpression || node.type === utils_1.AST_NODE_TYPES.NewExpression) {\n        const [, flags] = node.arguments;\n        return flags && flags.type === utils_1.AST_NODE_TYPES.Literal && typeof flags.value === 'string' && flags.value.includes('g');\n      }\n\n      return node.type === utils_1.AST_NODE_TYPES.Identifier;\n    }\n\n    return {\n      \"CallExpression[arguments.length=1] > MemberExpression.callee[property.name='match'][computed=false]\"(memberNode) {\n        const objectNode = memberNode.object;\n        const callNode = memberNode.parent;\n        const [argumentNode] = callNode.arguments;\n        const argumentValue = (0, util_1.getStaticValue)(argumentNode, globalScope);\n\n        if (!isStringType(typeChecker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(objectNode)))) {\n          return;\n        } // Don't report regular expressions with global flag.\n\n\n        if (!argumentValue && isLikelyToContainGlobalFlag(argumentNode) || argumentValue && argumentValue.value instanceof RegExp && argumentValue.value.flags.includes('g')) {\n          return;\n        }\n\n        if (argumentNode.type === utils_1.AST_NODE_TYPES.Literal && typeof argumentNode.value == 'string') {\n          const regExp = RegExp(argumentNode.value);\n          return context.report({\n            node: memberNode.property,\n            messageId: 'regExpExecOverStringMatch',\n            fix: (0, util_1.getWrappingFixer)({\n              sourceCode,\n              node: callNode,\n              innerNode: [objectNode],\n              wrap: objectCode => `${regExp.toString()}.exec(${objectCode})`\n            })\n          });\n        }\n\n        const argumentType = typeChecker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(argumentNode));\n        const argumentTypes = collectArgumentTypes(tsutils.unionTypeParts(argumentType));\n\n        switch (argumentTypes) {\n          case ArgumentType.RegExp:\n            return context.report({\n              node: memberNode.property,\n              messageId: 'regExpExecOverStringMatch',\n              fix: (0, util_1.getWrappingFixer)({\n                sourceCode,\n                node: callNode,\n                innerNode: [objectNode, argumentNode],\n                wrap: (objectCode, argumentCode) => `${argumentCode}.exec(${objectCode})`\n              })\n            });\n\n          case ArgumentType.String:\n            return context.report({\n              node: memberNode.property,\n              messageId: 'regExpExecOverStringMatch',\n              fix: (0, util_1.getWrappingFixer)({\n                sourceCode,\n                node: callNode,\n                innerNode: [objectNode, argumentNode],\n                wrap: (objectCode, argumentCode) => `RegExp(${argumentCode}).exec(${objectCode})`\n              })\n            });\n        }\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["ArgumentType","exports","name","defaultOptions","meta","type","fixable","docs","description","recommended","requiresTypeChecking","messages","regExpExecOverStringMatch","schema","create","context","globalScope","getScope","parserServices","typeChecker","program","getTypeChecker","sourceCode","getSourceCode","isStringType","isRegExpType","collectArgumentTypes","types","result","Other","RegExp","String","isLikelyToContainGlobalFlag","node","utils_1","CallExpression","NewExpression","flags","arguments","Literal","value","includes","Identifier","memberNode","objectNode","object","callNode","parent","argumentNode","argumentValue","getTypeAtLocation","esTreeNodeToTSNodeMap","get","regExp","report","property","messageId","fix","innerNode","wrap","objectCode","toString","argumentType","argumentTypes","tsutils","unionTypeParts","argumentCode"],"sources":["../../src/rules/prefer-regexp-exec.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}