{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = useStateAsync;\n\nvar _react = require(\"react\");\n/**\n * A hook that mirrors `useState` in function and API, expect that setState\n * calls return a promise that resolves after the state has been set (in an effect).\n *\n * This is _similar_ to the second callback in classy setState calls, but fires later.\n *\n * ```ts\n * const [counter, setState] = useStateAsync(1);\n *\n * const handleIncrement = async () => {\n *   await setState(2);\n *   doWorkRequiringCurrentState()\n * }\n * ```\n *\n * @param initialState initialize with some state value same as `useState`\n */\n\n\nfunction useStateAsync(initialState) {\n  var _useState = (0, _react.useState)(initialState),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var resolvers = (0, _react.useRef)([]);\n  (0, _react.useEffect)(function () {\n    resolvers.current.forEach(function (resolve) {\n      return resolve(state);\n    });\n    resolvers.current.length = 0;\n  }, [state]);\n  var setStateAsync = (0, _react.useCallback)(function (update) {\n    return new Promise(function (resolve, reject) {\n      setState(function (prevState) {\n        try {\n          var nextState; // ugly instanceof for typescript\n\n          if (update instanceof Function) {\n            nextState = update(prevState);\n          } else {\n            nextState = update;\n          } // If state does not change, we must resolve the promise because\n          // react won't re-render and effect will not resolve. If there are already\n          // resolvers queued, then it should be safe to assume an update will happen\n\n\n          if (!resolvers.current.length && Object.is(nextState, prevState)) {\n            resolve(nextState);\n          } else {\n            resolvers.current.push(resolve);\n          }\n\n          return nextState;\n        } catch (e) {\n          reject(e);\n          throw e;\n        }\n      });\n    });\n  }, [setState]);\n  return [state, setStateAsync];\n}","map":{"version":3,"names":["exports","__esModule","default","useStateAsync","_react","require","initialState","_useState","useState","state","setState","resolvers","useRef","useEffect","current","forEach","resolve","length","setStateAsync","useCallback","update","Promise","reject","prevState","nextState","Function","Object","is","push","e"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@restart/hooks/cjs/useStateAsync.js"],"sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = useStateAsync;\n\nvar _react = require(\"react\");\n\n/**\n * A hook that mirrors `useState` in function and API, expect that setState\n * calls return a promise that resolves after the state has been set (in an effect).\n *\n * This is _similar_ to the second callback in classy setState calls, but fires later.\n *\n * ```ts\n * const [counter, setState] = useStateAsync(1);\n *\n * const handleIncrement = async () => {\n *   await setState(2);\n *   doWorkRequiringCurrentState()\n * }\n * ```\n *\n * @param initialState initialize with some state value same as `useState`\n */\nfunction useStateAsync(initialState) {\n  var _useState = (0, _react.useState)(initialState),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var resolvers = (0, _react.useRef)([]);\n  (0, _react.useEffect)(function () {\n    resolvers.current.forEach(function (resolve) {\n      return resolve(state);\n    });\n    resolvers.current.length = 0;\n  }, [state]);\n  var setStateAsync = (0, _react.useCallback)(function (update) {\n    return new Promise(function (resolve, reject) {\n      setState(function (prevState) {\n        try {\n          var nextState; // ugly instanceof for typescript\n\n          if (update instanceof Function) {\n            nextState = update(prevState);\n          } else {\n            nextState = update;\n          } // If state does not change, we must resolve the promise because\n          // react won't re-render and effect will not resolve. If there are already\n          // resolvers queued, then it should be safe to assume an update will happen\n\n\n          if (!resolvers.current.length && Object.is(nextState, prevState)) {\n            resolve(nextState);\n          } else {\n            resolvers.current.push(resolve);\n          }\n\n          return nextState;\n        } catch (e) {\n          reject(e);\n          throw e;\n        }\n      });\n    });\n  }, [setState]);\n  return [state, setStateAsync];\n}"],"mappings":"AAAA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAACE,OAAR,GAAkBC,aAAlB;;AAEA,IAAIC,MAAM,GAAGC,OAAO,CAAC,OAAD,CAApB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,aAAT,CAAuBG,YAAvB,EAAqC;EACnC,IAAIC,SAAS,GAAG,CAAC,GAAGH,MAAM,CAACI,QAAX,EAAqBF,YAArB,CAAhB;EAAA,IACIG,KAAK,GAAGF,SAAS,CAAC,CAAD,CADrB;EAAA,IAEIG,QAAQ,GAAGH,SAAS,CAAC,CAAD,CAFxB;;EAIA,IAAII,SAAS,GAAG,CAAC,GAAGP,MAAM,CAACQ,MAAX,EAAmB,EAAnB,CAAhB;EACA,CAAC,GAAGR,MAAM,CAACS,SAAX,EAAsB,YAAY;IAChCF,SAAS,CAACG,OAAV,CAAkBC,OAAlB,CAA0B,UAAUC,OAAV,EAAmB;MAC3C,OAAOA,OAAO,CAACP,KAAD,CAAd;IACD,CAFD;IAGAE,SAAS,CAACG,OAAV,CAAkBG,MAAlB,GAA2B,CAA3B;EACD,CALD,EAKG,CAACR,KAAD,CALH;EAMA,IAAIS,aAAa,GAAG,CAAC,GAAGd,MAAM,CAACe,WAAX,EAAwB,UAAUC,MAAV,EAAkB;IAC5D,OAAO,IAAIC,OAAJ,CAAY,UAAUL,OAAV,EAAmBM,MAAnB,EAA2B;MAC5CZ,QAAQ,CAAC,UAAUa,SAAV,EAAqB;QAC5B,IAAI;UACF,IAAIC,SAAJ,CADE,CACa;;UAEf,IAAIJ,MAAM,YAAYK,QAAtB,EAAgC;YAC9BD,SAAS,GAAGJ,MAAM,CAACG,SAAD,CAAlB;UACD,CAFD,MAEO;YACLC,SAAS,GAAGJ,MAAZ;UACD,CAPC,CAOA;UACF;UACA;;;UAGA,IAAI,CAACT,SAAS,CAACG,OAAV,CAAkBG,MAAnB,IAA6BS,MAAM,CAACC,EAAP,CAAUH,SAAV,EAAqBD,SAArB,CAAjC,EAAkE;YAChEP,OAAO,CAACQ,SAAD,CAAP;UACD,CAFD,MAEO;YACLb,SAAS,CAACG,OAAV,CAAkBc,IAAlB,CAAuBZ,OAAvB;UACD;;UAED,OAAOQ,SAAP;QACD,CAnBD,CAmBE,OAAOK,CAAP,EAAU;UACVP,MAAM,CAACO,CAAD,CAAN;UACA,MAAMA,CAAN;QACD;MACF,CAxBO,CAAR;IAyBD,CA1BM,CAAP;EA2BD,CA5BmB,EA4BjB,CAACnB,QAAD,CA5BiB,CAApB;EA6BA,OAAO,CAACD,KAAD,EAAQS,aAAR,CAAP;AACD"},"metadata":{},"sourceType":"script"}