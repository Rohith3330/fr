{"ast":null,"code":"/**\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\n * @author Benoît Zugmeyer\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"Enforce consistent linebreak style for operators\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/operator-linebreak\"\n    },\n    schema: [{\n      enum: [\"after\", \"before\", \"none\", null]\n    }, {\n      type: \"object\",\n      properties: {\n        overrides: {\n          type: \"object\",\n          additionalProperties: {\n            enum: [\"after\", \"before\", \"none\", \"ignore\"]\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      operatorAtBeginning: \"'{{operator}}' should be placed at the beginning of the line.\",\n      operatorAtEnd: \"'{{operator}}' should be placed at the end of the line.\",\n      badLinebreak: \"Bad line breaking before and after '{{operator}}'.\",\n      noLinebreak: \"There should be no line break before or after '{{operator}}'.\"\n    }\n  },\n\n  create(context) {\n    const usedDefaultGlobal = !context.options[0];\n    const globalStyle = context.options[0] || \"after\";\n    const options = context.options[1] || {};\n    const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\n\n    if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n      styleOverrides[\"?\"] = \"before\";\n    }\n\n    if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n      styleOverrides[\":\"] = \"before\";\n    }\n\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Gets a fixer function to fix rule issues\n     * @param {Token} operatorToken The operator token of an expression\n     * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'\n     * @returns {Function} A fixer function\n     */\n\n    function getFixer(operatorToken, desiredStyle) {\n      return fixer => {\n        const tokenBefore = sourceCode.getTokenBefore(operatorToken);\n        const tokenAfter = sourceCode.getTokenAfter(operatorToken);\n        const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\n        const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\n        const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\n        const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\n        let newTextBefore, newTextAfter;\n\n        if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\n          // If there is a comment before and after the operator, don't do a fix.\n          if (sourceCode.getTokenBefore(operatorToken, {\n            includeComments: true\n          }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, {\n            includeComments: true\n          }) !== tokenAfter) {\n            return null;\n          }\n          /*\n           * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.\n           * foo &&\n           *           bar\n           * would get fixed to\n           * foo\n           *        && bar\n           */\n\n\n          newTextBefore = textAfter;\n          newTextAfter = textBefore;\n        } else {\n          const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher(); // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.\n\n          newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\n          newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\"); // If there was no change (due to interfering comments), don't output a fix.\n\n          if (newTextBefore === textBefore && newTextAfter === textAfter) {\n            return null;\n          }\n        }\n\n        if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\n          // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.\n          newTextAfter += \" \";\n        }\n\n        return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\n      };\n    }\n    /**\n     * Checks the operator placement\n     * @param {ASTNode} node The node to check\n     * @param {ASTNode} rightSide The node that comes after the operator in `node`\n     * @param {string} operator The operator\n     * @private\n     * @returns {void}\n     */\n\n\n    function validateNode(node, rightSide, operator) {\n      /*\n       * Find the operator token by searching from the right side, because between the left side and the operator\n       * there could be additional tokens from type annotations. Search specifically for the token which\n       * value equals the operator, in order to skip possible opening parentheses before the right side node.\n       */\n      const operatorToken = sourceCode.getTokenBefore(rightSide, token => token.value === operator);\n      const leftToken = sourceCode.getTokenBefore(operatorToken);\n      const rightToken = sourceCode.getTokenAfter(operatorToken);\n      const operatorStyleOverride = styleOverrides[operator];\n      const style = operatorStyleOverride || globalStyle;\n      const fix = getFixer(operatorToken, style); // if single line\n\n      if (astUtils.isTokenOnSameLine(leftToken, operatorToken) && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {// do nothing.\n      } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) && !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n        // lone operator\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"badLinebreak\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"operatorAtBeginning\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"operatorAtEnd\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"none\") {\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"noLinebreak\",\n          data: {\n            operator\n          },\n          fix\n        });\n      }\n    }\n    /**\n     * Validates a binary expression using `validateNode`\n     * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\n     * @returns {void}\n     */\n\n\n    function validateBinaryExpression(node) {\n      validateNode(node, node.right, node.operator);\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      BinaryExpression: validateBinaryExpression,\n      LogicalExpression: validateBinaryExpression,\n      AssignmentExpression: validateBinaryExpression,\n\n      VariableDeclarator(node) {\n        if (node.init) {\n          validateNode(node, node.init, \"=\");\n        }\n      },\n\n      PropertyDefinition(node) {\n        if (node.value) {\n          validateNode(node, node.value, \"=\");\n        }\n      },\n\n      ConditionalExpression(node) {\n        validateNode(node, node.consequent, \"?\");\n        validateNode(node, node.alternate, \":\");\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","enum","properties","overrides","additionalProperties","fixable","messages","operatorAtBeginning","operatorAtEnd","badLinebreak","noLinebreak","create","context","usedDefaultGlobal","options","globalStyle","styleOverrides","Object","assign","sourceCode","getSourceCode","getFixer","operatorToken","desiredStyle","fixer","tokenBefore","getTokenBefore","tokenAfter","getTokenAfter","textBefore","text","slice","range","textAfter","hasLinebreakBefore","isTokenOnSameLine","hasLinebreakAfter","newTextBefore","newTextAfter","includeComments","LINEBREAK_REGEX","createGlobalLinebreakMatcher","trim","replace","includes","value","replaceTextRange","validateNode","node","rightSide","operator","token","leftToken","rightToken","operatorStyleOverride","style","fix","report","loc","messageId","data","validateBinaryExpression","right","BinaryExpression","LogicalExpression","AssignmentExpression","VariableDeclarator","init","PropertyDefinition","ConditionalExpression","consequent","alternate"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/operator-linebreak.js"],"sourcesContent":["/**\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\n * @author Benoît Zugmeyer\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"Enforce consistent linebreak style for operators\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/operator-linebreak\"\n        },\n\n        schema: [\n            {\n                enum: [\"after\", \"before\", \"none\", null]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    overrides: {\n                        type: \"object\",\n                        additionalProperties: {\n                            enum: [\"after\", \"before\", \"none\", \"ignore\"]\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n\n        messages: {\n            operatorAtBeginning: \"'{{operator}}' should be placed at the beginning of the line.\",\n            operatorAtEnd: \"'{{operator}}' should be placed at the end of the line.\",\n            badLinebreak: \"Bad line breaking before and after '{{operator}}'.\",\n            noLinebreak: \"There should be no line break before or after '{{operator}}'.\"\n        }\n    },\n\n    create(context) {\n\n        const usedDefaultGlobal = !context.options[0];\n        const globalStyle = context.options[0] || \"after\";\n        const options = context.options[1] || {};\n        const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\n\n        if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n            styleOverrides[\"?\"] = \"before\";\n        }\n\n        if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n            styleOverrides[\":\"] = \"before\";\n        }\n\n        const sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Gets a fixer function to fix rule issues\n         * @param {Token} operatorToken The operator token of an expression\n         * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'\n         * @returns {Function} A fixer function\n         */\n        function getFixer(operatorToken, desiredStyle) {\n            return fixer => {\n                const tokenBefore = sourceCode.getTokenBefore(operatorToken);\n                const tokenAfter = sourceCode.getTokenAfter(operatorToken);\n                const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\n                const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\n                const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\n                const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\n                let newTextBefore, newTextAfter;\n\n                if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\n\n                    // If there is a comment before and after the operator, don't do a fix.\n                    if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore &&\n                        sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) {\n\n                        return null;\n                    }\n\n                    /*\n                     * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.\n                     * foo &&\n                     *           bar\n                     * would get fixed to\n                     * foo\n                     *        && bar\n                     */\n                    newTextBefore = textAfter;\n                    newTextAfter = textBefore;\n                } else {\n                    const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();\n\n                    // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.\n                    newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\n                    newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\");\n\n                    // If there was no change (due to interfering comments), don't output a fix.\n                    if (newTextBefore === textBefore && newTextAfter === textAfter) {\n                        return null;\n                    }\n                }\n\n                if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\n\n                    // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.\n                    newTextAfter += \" \";\n                }\n\n                return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\n            };\n        }\n\n        /**\n         * Checks the operator placement\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} rightSide The node that comes after the operator in `node`\n         * @param {string} operator The operator\n         * @private\n         * @returns {void}\n         */\n        function validateNode(node, rightSide, operator) {\n\n            /*\n             * Find the operator token by searching from the right side, because between the left side and the operator\n             * there could be additional tokens from type annotations. Search specifically for the token which\n             * value equals the operator, in order to skip possible opening parentheses before the right side node.\n             */\n            const operatorToken = sourceCode.getTokenBefore(rightSide, token => token.value === operator);\n            const leftToken = sourceCode.getTokenBefore(operatorToken);\n            const rightToken = sourceCode.getTokenAfter(operatorToken);\n            const operatorStyleOverride = styleOverrides[operator];\n            const style = operatorStyleOverride || globalStyle;\n            const fix = getFixer(operatorToken, style);\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // do nothing.\n\n            } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // lone operator\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"badLinebreak\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"operatorAtBeginning\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"operatorAtEnd\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            } else if (style === \"none\") {\n\n                context.report({\n                    node,\n                    loc: operatorToken.loc,\n                    messageId: \"noLinebreak\",\n                    data: {\n                        operator\n                    },\n                    fix\n                });\n\n            }\n        }\n\n        /**\n         * Validates a binary expression using `validateNode`\n         * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\n         * @returns {void}\n         */\n        function validateBinaryExpression(node) {\n            validateNode(node, node.right, node.operator);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression: validateBinaryExpression,\n            LogicalExpression: validateBinaryExpression,\n            AssignmentExpression: validateBinaryExpression,\n            VariableDeclarator(node) {\n                if (node.init) {\n                    validateNode(node, node.init, \"=\");\n                }\n            },\n            PropertyDefinition(node) {\n                if (node.value) {\n                    validateNode(node, node.value, \"=\");\n                }\n            },\n            ConditionalExpression(node) {\n                validateNode(node, node.consequent, \"?\");\n                validateNode(node, node.alternate, \":\");\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}