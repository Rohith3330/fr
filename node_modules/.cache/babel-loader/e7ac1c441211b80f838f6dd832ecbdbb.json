{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.get = get;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getNextSibling = getNextSibling;\nexports.getOpposite = getOpposite;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getPrevSibling = getPrevSibling;\nexports.getSibling = getSibling;\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  getBindingIdentifiers: _getBindingIdentifiers,\n  getOuterBindingIdentifiers: _getOuterBindingIdentifiers,\n  isDeclaration,\n  numericLiteral,\n  unaryExpression\n} = _t;\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) {\n    records.push(..._getCompletionRecords(path, context));\n  }\n\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records.push(...breakCompletions);\n  }\n\n  records.push(...lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(unaryExpression(\"void\", numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  const completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions.push(...lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions.push(...statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions.push(...statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions.push(...statementCompletions);\n      } else {\n        lastNormalCompletions = [];\n\n        for (let i = 0; i < statementCompletions.length; i++) {\n          const c = statementCompletions[i];\n\n          if (c.type === BREAK_COMPLETION) {\n            completions.push(c);\n          }\n\n          if (c.type === NORMAL_COMPLETION) {\n            lastNormalCompletions.push(c);\n          }\n        }\n      }\n    }\n  } else if (paths.length) {\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n\n      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {\n        completions.push(...pathCompletions);\n        break;\n      }\n    }\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    return getStatementListCompletion(path.get(\"body\"), context);\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    return completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    return getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    });\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key) {\n  let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return _getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return _getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths() {\n  let duplicates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  let outerOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const path = this;\n  const search = [path];\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = _getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (isDeclaration(declaration)) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child)) {\n          search.push(...child);\n        } else if (child.node) {\n          search.push(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths() {\n  let duplicates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","map":{"version":3,"mappings":"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","names":["getBindingIdentifiers","_getBindingIdentifiers","getOuterBindingIdentifiers","_getOuterBindingIdentifiers","isDeclaration","numericLiteral","unaryExpression","NORMAL_COMPLETION","BREAK_COMPLETION","NormalCompletion","path","type","BreakCompletion","getOpposite","key","getSibling","addCompletionRecords","records","context","push","_getCompletionRecords","completionRecordForSwitch","cases","lastNormalCompletions","i","length","casePath","caseCompletions","normalCompletions","breakCompletions","c","normalCompletionToBreak","completions","forEach","replaceBreakStatementInBreakCompletion","reachable","isBreakStatement","label","replaceWith","remove","getStatementListCompletion","paths","canHaveBreak","newContext","inCaseClause","isBlockStatement","shouldPopulateBreak","statementCompletions","every","some","pathCompletions","isVariableDeclaration","isIfStatement","get","isDoExpression","isFor","isWhile","isLabeledStatement","isProgram","isFunction","isTryStatement","isCatchClause","isSwitchStatement","isSwitchCase","getCompletionRecords","map","r","NodePath","parentPath","parent","container","listKey","setContext","getPrevSibling","getNextSibling","getAllNextSiblings","_key","sibling","siblings","node","getAllPrevSiblings","parts","split","_getKey","_getPattern","Array","isArray","_","part","duplicates","getBindingIdentifierPaths","outerOnly","search","ids","Object","create","id","shift","keys","isIdentifier","_ids","name","isExportDeclaration","declaration","isFunctionDeclaration","isFunctionExpression","child","getOuterBindingIdentifierPaths"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\path\\family.ts"],"sourcesContent":["// This file contains methods responsible for dealing with/retrieving children or siblings.\n\nimport type TraversalContext from \"../context\";\nimport NodePath from \"./index\";\nimport {\n  getBindingIdentifiers as _getBindingIdentifiers,\n  getOuterBindingIdentifiers as _getOuterBindingIdentifiers,\n  isDeclaration,\n  numericLiteral,\n  unaryExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nconst NORMAL_COMPLETION = 0 as const;\nconst BREAK_COMPLETION = 1 as const;\n\ntype Completion = {\n  path: NodePath;\n  type: 0 | 1;\n};\n\ntype CompletionContext = {\n  // whether the current context allows `break` statement. When it allows, we have\n  // to search all the statements for potential `break`\n  canHaveBreak: boolean;\n  // whether the statement is an immediate descendant of a switch case clause\n  inCaseClause: boolean;\n  // whether the `break` statement record should be populated to upper level\n  // when a `break` statement is an immediate descendant of a block statement, e.g.\n  // `{ break }`, it can influence the control flow in the upper levels.\n  shouldPopulateBreak: boolean;\n};\n\nfunction NormalCompletion(path: NodePath) {\n  return { type: NORMAL_COMPLETION, path };\n}\n\nfunction BreakCompletion(path: NodePath) {\n  return { type: BREAK_COMPLETION, path };\n}\n\nexport function getOpposite(this: NodePath): NodePath | null {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n  return null;\n}\n\nfunction addCompletionRecords(\n  path: NodePath | null | undefined,\n  records: Completion[],\n  context: CompletionContext,\n): Completion[] {\n  if (path) {\n    records.push(..._getCompletionRecords(path, context));\n  }\n  return records;\n}\n\nfunction completionRecordForSwitch(\n  cases: NodePath<t.SwitchCase>[],\n  records: Completion[],\n  context: CompletionContext,\n): Completion[] {\n  // https://tc39.es/ecma262/#sec-runtime-semantics-caseblockevaluation\n  let lastNormalCompletions: Completion[] = [];\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n    const caseCompletions = _getCompletionRecords(casePath, context);\n    const normalCompletions = [];\n    const breakCompletions = [];\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n    records.push(...breakCompletions);\n  }\n  records.push(...lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions: Completion[]) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\n/**\n * Determine how we should handle the break statement for break completions\n *\n * @param {Completion[]} completions\n * @param {boolean} reachable Whether the break statement is reachable after\n   we mark the normal completions _before_ the given break completions as the final\n   completions. For example,\n   `{ 0 }; break;` is transformed to `{ return 0 }; break;`, the `break` here is unreachable\n   and thus can be removed without consequences. We may in the future reserve them instead since\n   we do not consistently remove unreachable statements _after_ break\n   `{ var x = 0 }; break;` is transformed to `{ var x = 0 }; return void 0;`, the `break` is reachable\n   because we can not wrap variable declaration under a return statement\n */\nfunction replaceBreakStatementInBreakCompletion(\n  completions: Completion[],\n  reachable: boolean,\n) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({ label: null })) {\n      if (reachable) {\n        c.path.replaceWith(unaryExpression(\"void\", numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(\n  paths: NodePath[],\n  context: CompletionContext,\n): Completion[] {\n  const completions = [];\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = { ...context, inCaseClause: false };\n      if (\n        path.isBlockStatement() &&\n        (context.inCaseClause || // case test: { break }\n          context.shouldPopulateBreak) // case test: { { break } }\n      ) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n      const statementCompletions = _getCompletionRecords(path, newContext);\n      if (\n        statementCompletions.length > 0 &&\n        // we can stop search `paths` when we have seen a `path` that is\n        // effectively a `break` statement. Examples are\n        // - `break`\n        // - `if (true) { 1; break } else { 2; break }`\n        // - `{ break }```\n        // In other words, the paths after this `path` are unreachable\n        statementCompletions.every(c => c.type === BREAK_COMPLETION)\n      ) {\n        if (\n          lastNormalCompletions.length > 0 &&\n          statementCompletions.every(c =>\n            c.path.isBreakStatement({ label: null }),\n          )\n        ) {\n          // when a break completion has a path as BreakStatement, it must be `{ break }`\n          // whose completion value we can not determine, otherwise it would have been\n          // replaced by `replaceBreakStatementInBreakCompletion`\n          // When we have seen normal completions from the last statement\n          // it is safe to stop populating break and mark normal completions as break\n          normalCompletionToBreak(lastNormalCompletions);\n          completions.push(...lastNormalCompletions);\n          // Declarations have empty completion record, however they can not be nested\n          // directly in return statement, i.e. `return (var a = 1)` is invalid.\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions.push(...statementCompletions);\n            replaceBreakStatementInBreakCompletion(\n              statementCompletions,\n              /* reachable */ true,\n            );\n          }\n          replaceBreakStatementInBreakCompletion(\n            statementCompletions,\n            /* reachable */ false,\n          );\n        } else {\n          completions.push(...statementCompletions);\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(\n              statementCompletions,\n              /* reachable */ true,\n            );\n          }\n        }\n        break;\n      }\n      if (i === paths.length - 1) {\n        completions.push(...statementCompletions);\n      } else {\n        lastNormalCompletions = [];\n        for (let i = 0; i < statementCompletions.length; i++) {\n          const c = statementCompletions[i];\n          if (c.type === BREAK_COMPLETION) {\n            completions.push(c);\n          }\n          if (c.type === NORMAL_COMPLETION) {\n            lastNormalCompletions.push(c);\n          }\n        }\n      }\n    }\n  } else if (paths.length) {\n    // When we are in a context where `break` must not exist, we can skip linear\n    // search on statement lists and assume that the last\n    // non-variable-declaration statement determines the completion.\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n      if (\n        pathCompletions.length > 1 ||\n        (pathCompletions.length === 1 &&\n          !pathCompletions[0].path.isVariableDeclaration())\n      ) {\n        completions.push(...pathCompletions);\n        break;\n      }\n    }\n  }\n  return completions;\n}\n\nfunction _getCompletionRecords(\n  path: NodePath,\n  context: CompletionContext,\n): Completion[] {\n  let records: Completion[] = [];\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (\n    path.isDoExpression() ||\n    path.isFor() ||\n    path.isWhile() ||\n    path.isLabeledStatement()\n  ) {\n    // @ts-expect-error(flow->ts): todo\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    // @ts-expect-error(flow->ts): todo\n    return getStatementListCompletion(path.get(\"body\"), context);\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    return completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    return getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true,\n    });\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\n/**\n * Retrieve the completion records of a given path.\n * Note: to ensure proper support on `break` statement, this method\n * will manipulate the AST around the break statement. Do not call the method\n * twice for the same path.\n *\n * @export\n * @param {NodePath} this\n * @returns {NodePath[]} Completion records\n */\nexport function getCompletionRecords(this: NodePath): NodePath[] {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false,\n  });\n  return records.map(r => r.path);\n}\n\nexport function getSibling(this: NodePath, key: string | number): NodePath {\n  return NodePath.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key,\n  }).setContext(this.context);\n}\n\nexport function getPrevSibling(this: NodePath): NodePath {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  return this.getSibling(this.key - 1);\n}\n\nexport function getNextSibling(this: NodePath): NodePath {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  return this.getSibling(this.key + 1);\n}\n\nexport function getAllNextSiblings(this: NodePath): NodePath[] {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  let _key: number = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n  return siblings;\n}\n\nexport function getAllPrevSiblings(this: NodePath): NodePath[] {\n  // @ts-expect-error todo(flow->ts) this.key could be a string\n  let _key: number = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n  return siblings;\n}\n\n// convert \"1\" to 1 (string index to number index)\ntype MaybeToIndex<T extends string> = T extends `${bigint}` ? number : T;\n\ntype Pattern<Obj extends string, Prop extends string> = `${Obj}.${Prop}`;\n\n// split \"body.body.1\" to [\"body\", \"body\", 1]\ntype Split<P extends string> = P extends Pattern<infer O, infer U>\n  ? [MaybeToIndex<O>, ...Split<U>]\n  : [MaybeToIndex<P>];\n\n// get all K with Node[K] is t.Node | t.Node[]\ntype NodeKeyOf<Node extends t.Node | t.Node[]> = keyof Pick<\n  Node,\n  {\n    [Key in keyof Node]-?: Node[Key] extends t.Node | t.Node[] ? Key : never;\n  }[keyof Node]\n>;\n\n// traverse the Node with tuple path [\"body\", \"body\", 1]\n// Path should be created with Split\ntype Trav<\n  Node extends t.Node | t.Node[],\n  Path extends unknown[],\n> = Path extends [infer K, ...infer R]\n  ? K extends NodeKeyOf<Node>\n    ? R extends []\n      ? Node[K]\n      : // @ts-expect-error ignore since TS is not smart enough\n        Trav<Node[K], R>\n    : never\n  : never;\n\ntype ToNodePath<T> = T extends Array<t.Node | null | undefined>\n  ? Array<NodePath<T[number]>>\n  : T extends t.Node | null | undefined\n  ? NodePath<T>\n  : never;\n\nfunction get<T extends t.Node, K extends keyof T>(\n  this: NodePath<T>,\n  key: K,\n  context?: boolean | TraversalContext,\n): T[K] extends Array<t.Node | null | undefined>\n  ? Array<NodePath<T[K][number]>>\n  : T[K] extends t.Node | null | undefined\n  ? NodePath<T[K]>\n  : never;\n\nfunction get<T extends t.Node, K extends string>(\n  this: NodePath<T>,\n  key: K,\n  context?: boolean | TraversalContext,\n): ToNodePath<Trav<T, Split<K>>>;\n\nfunction get<T extends t.Node>(\n  this: NodePath<T>,\n  key: string,\n  context?: true | TraversalContext,\n): NodePath | NodePath[];\n\nfunction get<T extends t.Node>(\n  this: NodePath<T>,\n  key: string,\n  context: true | TraversalContext = true,\n): NodePath | NodePath[] {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n  if (parts.length === 1) {\n    // \"foo\"\n    // @ts-expect-error key may not index T\n    return this._getKey(key, context);\n  } else {\n    // \"foo.bar\"\n    return this._getPattern(parts, context);\n  }\n}\n\nexport { get };\n\nexport function _getKey<T extends t.Node>(\n  this: NodePath<T>,\n  key: keyof T & string,\n  context?: TraversalContext,\n): NodePath | NodePath[] {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    // requested a container so give them all the paths\n    return container.map((_, i) => {\n      return NodePath.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i,\n      }).setContext(context);\n    });\n  } else {\n    return NodePath.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key,\n    }).setContext(context);\n  }\n}\n\nexport function _getPattern(\n  this: NodePath,\n  parts: string[],\n  context?: TraversalContext,\n): NodePath | NodePath[] {\n  let path: NodePath | NodePath[] = this;\n  for (const part of parts) {\n    if (part === \".\") {\n      // @ts-expect-error todo(flow-ts): Can path be an array here?\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        // @ts-expect-error part may not index path\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n  return path;\n}\n\nfunction getBindingIdentifiers(\n  duplicates: true,\n): Record<string, t.Identifier[]>;\nfunction getBindingIdentifiers(\n  duplicates?: false,\n): Record<string, t.Identifier>;\nfunction getBindingIdentifiers(\n  duplicates: boolean,\n): Record<string, t.Identifier[] | t.Identifier>;\n\nfunction getBindingIdentifiers(\n  this: NodePath,\n  duplicates?: boolean,\n): Record<string, t.Identifier[] | t.Identifier> {\n  return _getBindingIdentifiers(this.node, duplicates);\n}\n\nexport { getBindingIdentifiers };\n\nfunction getOuterBindingIdentifiers(\n  duplicates: true,\n): Record<string, t.Identifier[]>;\nfunction getOuterBindingIdentifiers(\n  duplicates?: false,\n): Record<string, t.Identifier>;\nfunction getOuterBindingIdentifiers(\n  duplicates: boolean,\n): Record<string, t.Identifier[] | t.Identifier>;\n\nfunction getOuterBindingIdentifiers(\n  this: NodePath,\n  duplicates?: boolean,\n): Record<string, t.Identifier[] | t.Identifier> {\n  return _getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nexport { getOuterBindingIdentifiers };\n\nfunction getBindingIdentifierPaths(\n  duplicates: true,\n  outerOnly?: boolean,\n): Record<string, NodePath<t.Identifier>[]>;\nfunction getBindingIdentifierPaths(\n  duplicates: false,\n  outerOnly?: boolean,\n): Record<string, NodePath<t.Identifier>>;\nfunction getBindingIdentifierPaths(\n  duplicates?: boolean,\n  outerOnly?: boolean,\n): Record<string, NodePath<t.Identifier> | NodePath<t.Identifier>[]>;\n\n// original source - https://github.com/babel/babel/blob/main/packages/babel-types/src/retrievers/getBindingIdentifiers.js\n// path.getBindingIdentifiers returns nodes where the following re-implementation returns paths\nfunction getBindingIdentifierPaths(\n  this: NodePath,\n  duplicates: boolean = false,\n  outerOnly: boolean = false,\n): Record<string, NodePath<t.Identifier> | NodePath<t.Identifier>[]> {\n  const path = this;\n  const search = [path];\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n\n    const keys =\n      // @ts-expect-error _getBindingIdentifiers.keys do not cover all node types\n      _getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = (ids[id.node.name] = ids[id.node.name] || []);\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n      if (isDeclaration(declaration)) {\n        search.push(declaration);\n      }\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n        if (Array.isArray(child)) {\n          search.push(...child);\n        } else if (child.node) {\n          search.push(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nexport { getBindingIdentifierPaths };\n\nfunction getOuterBindingIdentifierPaths(\n  duplicates: true,\n): Record<string, NodePath<t.Identifier>[]>;\nfunction getOuterBindingIdentifierPaths(\n  duplicates?: false,\n): Record<string, NodePath<t.Identifier>>;\nfunction getOuterBindingIdentifierPaths(\n  duplicates?: boolean,\n): Record<string, NodePath<t.Identifier> | NodePath<t.Identifier>[]>;\n\nfunction getOuterBindingIdentifierPaths(\n  this: NodePath,\n  duplicates: boolean = false,\n) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}\n\nexport { getOuterBindingIdentifierPaths };\n"]},"metadata":{},"sourceType":"script"}