{"ast":null,"code":"\"use strict\";\n\nconst ICSSUtils = require(\"icss-utils\");\n\nconst matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nconst matchValueDefinition = /(?:\\s+|^)([\\w-]+):?(.*?)$/;\nconst matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\n\nmodule.exports = options => {\n  let importIndex = 0;\n\n  const createImportedName = options && options.createImportedName || ((importName\n  /*, path*/\n  ) => `i__const_${importName.replace(/\\W/g, \"_\")}_${importIndex++}`);\n\n  return {\n    postcssPlugin: \"postcss-modules-values\",\n\n    prepare(result) {\n      const importAliases = [];\n      const definitions = {};\n      return {\n        Once(root, postcss) {\n          root.walkAtRules(/value/i, atRule => {\n            const matches = atRule.params.match(matchImports);\n\n            if (matches) {\n              let [,\n              /*match*/\n              aliases, path] = matches; // We can use constants for path names\n\n              if (definitions[path]) {\n                path = definitions[path];\n              }\n\n              const imports = aliases.replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, \"$1\").split(/\\s*,\\s*/).map(alias => {\n                const tokens = matchImport.exec(alias);\n\n                if (tokens) {\n                  const [,\n                  /*match*/\n                  theirName, myName = theirName] = tokens;\n                  const importedName = createImportedName(myName);\n                  definitions[myName] = importedName;\n                  return {\n                    theirName,\n                    importedName\n                  };\n                } else {\n                  throw new Error(`@import statement \"${alias}\" is invalid!`);\n                }\n              });\n              importAliases.push({\n                path,\n                imports\n              });\n              atRule.remove();\n              return;\n            }\n\n            if (atRule.params.indexOf(\"@value\") !== -1) {\n              result.warn(\"Invalid value definition: \" + atRule.params);\n            }\n\n            let [, key, value] = `${atRule.params}${atRule.raws.between}`.match(matchValueDefinition);\n            const normalizedValue = value.replace(/\\/\\*((?!\\*\\/).*?)\\*\\//g, \"\");\n\n            if (normalizedValue.length === 0) {\n              result.warn(\"Invalid value definition: \" + atRule.params);\n              atRule.remove();\n              return;\n            }\n\n            let isOnlySpace = /^\\s+$/.test(normalizedValue);\n\n            if (!isOnlySpace) {\n              value = value.trim();\n            } // Add to the definitions, knowing that values can refer to each other\n\n\n            definitions[key] = ICSSUtils.replaceValueSymbols(value, definitions);\n            atRule.remove();\n          });\n          /* If we have no definitions, don't continue */\n\n          if (!Object.keys(definitions).length) {\n            return;\n          }\n          /* Perform replacements */\n\n\n          ICSSUtils.replaceSymbols(root, definitions);\n          /* We want to export anything defined by now, but don't add it to the CSS yet or it well get picked up by the replacement stuff */\n\n          const exportDeclarations = Object.keys(definitions).map(key => postcss.decl({\n            value: definitions[key],\n            prop: key,\n            raws: {\n              before: \"\\n  \"\n            }\n          }));\n          /* Add export rules if any */\n\n          if (exportDeclarations.length > 0) {\n            const exportRule = postcss.rule({\n              selector: \":export\",\n              raws: {\n                after: \"\\n\"\n              }\n            });\n            exportRule.append(exportDeclarations);\n            root.prepend(exportRule);\n          }\n          /* Add import rules */\n\n\n          importAliases.reverse().forEach(_ref => {\n            let {\n              path,\n              imports\n            } = _ref;\n            const importRule = postcss.rule({\n              selector: `:import(${path})`,\n              raws: {\n                after: \"\\n\"\n              }\n            });\n            imports.forEach(_ref2 => {\n              let {\n                theirName,\n                importedName\n              } = _ref2;\n              importRule.append({\n                value: theirName,\n                prop: importedName,\n                raws: {\n                  before: \"\\n  \"\n                }\n              });\n            });\n            root.prepend(importRule);\n          });\n        }\n\n      };\n    }\n\n  };\n};\n\nmodule.exports.postcss = true;","map":{"version":3,"names":["ICSSUtils","require","matchImports","matchValueDefinition","matchImport","module","exports","options","importIndex","createImportedName","importName","replace","postcssPlugin","prepare","result","importAliases","definitions","Once","root","postcss","walkAtRules","atRule","matches","params","match","aliases","path","imports","split","map","alias","tokens","exec","theirName","myName","importedName","Error","push","remove","indexOf","warn","key","value","raws","between","normalizedValue","length","isOnlySpace","test","trim","replaceValueSymbols","Object","keys","replaceSymbols","exportDeclarations","decl","prop","before","exportRule","rule","selector","after","append","prepend","reverse","forEach","importRule"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-modules-values/src/index.js"],"sourcesContent":["\"use strict\";\n\nconst ICSSUtils = require(\"icss-utils\");\n\nconst matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nconst matchValueDefinition = /(?:\\s+|^)([\\w-]+):?(.*?)$/;\nconst matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\n\nmodule.exports = (options) => {\n  let importIndex = 0;\n  const createImportedName =\n    (options && options.createImportedName) ||\n    ((importName /*, path*/) =>\n      `i__const_${importName.replace(/\\W/g, \"_\")}_${importIndex++}`);\n\n  return {\n    postcssPlugin: \"postcss-modules-values\",\n    prepare(result) {\n      const importAliases = [];\n      const definitions = {};\n\n      return {\n        Once(root, postcss) {\n          root.walkAtRules(/value/i, (atRule) => {\n            const matches = atRule.params.match(matchImports);\n\n            if (matches) {\n              let [, /*match*/ aliases, path] = matches;\n\n              // We can use constants for path names\n              if (definitions[path]) {\n                path = definitions[path];\n              }\n\n              const imports = aliases\n                .replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, \"$1\")\n                .split(/\\s*,\\s*/)\n                .map((alias) => {\n                  const tokens = matchImport.exec(alias);\n\n                  if (tokens) {\n                    const [, /*match*/ theirName, myName = theirName] = tokens;\n                    const importedName = createImportedName(myName);\n                    definitions[myName] = importedName;\n                    return { theirName, importedName };\n                  } else {\n                    throw new Error(`@import statement \"${alias}\" is invalid!`);\n                  }\n                });\n\n              importAliases.push({ path, imports });\n\n              atRule.remove();\n\n              return;\n            }\n\n            if (atRule.params.indexOf(\"@value\") !== -1) {\n              result.warn(\"Invalid value definition: \" + atRule.params);\n            }\n\n            let [, key, value] = `${atRule.params}${atRule.raws.between}`.match(\n              matchValueDefinition\n            );\n\n            const normalizedValue = value.replace(/\\/\\*((?!\\*\\/).*?)\\*\\//g, \"\");\n\n            if (normalizedValue.length === 0) {\n              result.warn(\"Invalid value definition: \" + atRule.params);\n              atRule.remove();\n\n              return;\n            }\n\n            let isOnlySpace = /^\\s+$/.test(normalizedValue);\n\n            if (!isOnlySpace) {\n              value = value.trim();\n            }\n\n            // Add to the definitions, knowing that values can refer to each other\n            definitions[key] = ICSSUtils.replaceValueSymbols(\n              value,\n              definitions\n            );\n\n            atRule.remove();\n          });\n\n          /* If we have no definitions, don't continue */\n          if (!Object.keys(definitions).length) {\n            return;\n          }\n\n          /* Perform replacements */\n          ICSSUtils.replaceSymbols(root, definitions);\n\n          /* We want to export anything defined by now, but don't add it to the CSS yet or it well get picked up by the replacement stuff */\n          const exportDeclarations = Object.keys(definitions).map((key) =>\n            postcss.decl({\n              value: definitions[key],\n              prop: key,\n              raws: { before: \"\\n  \" },\n            })\n          );\n\n          /* Add export rules if any */\n          if (exportDeclarations.length > 0) {\n            const exportRule = postcss.rule({\n              selector: \":export\",\n              raws: { after: \"\\n\" },\n            });\n\n            exportRule.append(exportDeclarations);\n\n            root.prepend(exportRule);\n          }\n\n          /* Add import rules */\n          importAliases.reverse().forEach(({ path, imports }) => {\n            const importRule = postcss.rule({\n              selector: `:import(${path})`,\n              raws: { after: \"\\n\" },\n            });\n\n            imports.forEach(({ theirName, importedName }) => {\n              importRule.append({\n                value: theirName,\n                prop: importedName,\n                raws: { before: \"\\n  \" },\n              });\n            });\n\n            root.prepend(importRule);\n          });\n        },\n      };\n    },\n  };\n};\n\nmodule.exports.postcss = true;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}