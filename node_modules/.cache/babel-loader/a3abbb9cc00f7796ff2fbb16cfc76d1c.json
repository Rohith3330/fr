{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nconst literalToPrimitiveTypeFlags = {\n  [ts.TypeFlags.BigIntLiteral]: ts.TypeFlags.BigInt,\n  [ts.TypeFlags.BooleanLiteral]: ts.TypeFlags.Boolean,\n  [ts.TypeFlags.NumberLiteral]: ts.TypeFlags.Number,\n  [ts.TypeFlags.StringLiteral]: ts.TypeFlags.String,\n  [ts.TypeFlags.TemplateLiteral]: ts.TypeFlags.String\n};\nconst literalTypeFlags = [ts.TypeFlags.BigIntLiteral, ts.TypeFlags.BooleanLiteral, ts.TypeFlags.NumberLiteral, ts.TypeFlags.StringLiteral, ts.TypeFlags.TemplateLiteral];\nconst primitiveTypeFlags = [ts.TypeFlags.BigInt, ts.TypeFlags.Boolean, ts.TypeFlags.Number, ts.TypeFlags.String];\nconst primitiveTypeFlagNames = {\n  [ts.TypeFlags.BigInt]: 'bigint',\n  [ts.TypeFlags.Boolean]: 'boolean',\n  [ts.TypeFlags.Number]: 'number',\n  [ts.TypeFlags.String]: 'string'\n};\nconst primitiveTypeFlagTypes = {\n  bigint: ts.TypeFlags.BigIntLiteral,\n  boolean: ts.TypeFlags.BooleanLiteral,\n  number: ts.TypeFlags.NumberLiteral,\n  string: ts.TypeFlags.StringLiteral\n};\nconst keywordNodeTypesToTsTypes = new Map([[utils_1.TSESTree.AST_NODE_TYPES.TSAnyKeyword, ts.TypeFlags.Any], [utils_1.TSESTree.AST_NODE_TYPES.TSBigIntKeyword, ts.TypeFlags.BigInt], [utils_1.TSESTree.AST_NODE_TYPES.TSBooleanKeyword, ts.TypeFlags.Boolean], [utils_1.TSESTree.AST_NODE_TYPES.TSNeverKeyword, ts.TypeFlags.Never], [utils_1.TSESTree.AST_NODE_TYPES.TSUnknownKeyword, ts.TypeFlags.Unknown], [utils_1.TSESTree.AST_NODE_TYPES.TSNumberKeyword, ts.TypeFlags.Number], [utils_1.TSESTree.AST_NODE_TYPES.TSStringKeyword, ts.TypeFlags.String]]);\n\nfunction addToMapGroup(map, key, value) {\n  const existing = map.get(key);\n\n  if (existing) {\n    existing.push(value);\n  } else {\n    map.set(key, [value]);\n  }\n}\n\nfunction describeLiteralType(type) {\n  if (type.isStringLiteral()) {\n    return JSON.stringify(type.value);\n  }\n\n  if (type.isLiteral()) {\n    return type.value.toString();\n  }\n\n  if (util.isTypeAnyType(type)) {\n    return 'any';\n  }\n\n  if (util.isTypeNeverType(type)) {\n    return 'never';\n  }\n\n  if (util.isTypeUnknownType(type)) {\n    return 'unknown';\n  }\n\n  if (util.isTypeTemplateLiteralType(type)) {\n    return 'template literal type';\n  }\n\n  if (util.isTypeBigIntLiteralType(type)) {\n    return `${type.value.negative ? '-' : ''}${type.value.base10Value}n`;\n  }\n\n  if (tsutils.isBooleanLiteralType(type, true)) {\n    return 'true';\n  }\n\n  if (tsutils.isBooleanLiteralType(type, false)) {\n    return 'false';\n  }\n\n  return 'literal type';\n}\n\nfunction describeLiteralTypeNode(typeNode) {\n  switch (typeNode.type) {\n    case utils_1.AST_NODE_TYPES.TSAnyKeyword:\n      return 'any';\n\n    case utils_1.AST_NODE_TYPES.TSBooleanKeyword:\n      return 'boolean';\n\n    case utils_1.AST_NODE_TYPES.TSNeverKeyword:\n      return 'never';\n\n    case utils_1.AST_NODE_TYPES.TSNumberKeyword:\n      return 'number';\n\n    case utils_1.AST_NODE_TYPES.TSStringKeyword:\n      return 'string';\n\n    case utils_1.AST_NODE_TYPES.TSUnknownKeyword:\n      return 'unknown';\n\n    case utils_1.AST_NODE_TYPES.TSLiteralType:\n      switch (typeNode.literal.type) {\n        case utils_1.TSESTree.AST_NODE_TYPES.Literal:\n          switch (typeof typeNode.literal.value) {\n            case 'bigint':\n              return `${typeNode.literal.value < 0 ? '-' : ''}${typeNode.literal.value}n`;\n\n            case 'string':\n              return JSON.stringify(typeNode.literal.value);\n\n            default:\n              return `${typeNode.literal.value}`;\n          }\n\n        case utils_1.TSESTree.AST_NODE_TYPES.TemplateLiteral:\n          return 'template literal type';\n      }\n\n  }\n\n  return 'literal type';\n}\n\nfunction isNodeInsideReturnType(node) {\n  var _a;\n\n  return !!(((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.TSTypeAnnotation && node.parent.parent && (util.isFunctionType(node.parent.parent) || util.isFunction(node.parent.parent)));\n}\n/**\n * @remarks TypeScript stores boolean types as the union false | true, always.\n */\n\n\nfunction unionTypePartsUnlessBoolean(type) {\n  return type.isUnion() && type.types.length === 2 && tsutils.isBooleanLiteralType(type.types[0], false) && tsutils.isBooleanLiteralType(type.types[1], true) ? [type] : tsutils.unionTypeParts(type);\n}\n\nexports.default = util.createRule({\n  name: 'no-redundant-type-constituents',\n  meta: {\n    docs: {\n      description: 'Disallow members of unions and intersections that do nothing or override type information',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    messages: {\n      literalOverridden: `{{literal}} is overridden by {{primitive}} in this union type.`,\n      primitiveOverridden: `{{primitive}} is overridden by the {{literal}} in this intersection type.`,\n      overridden: `'{{typeName}}' is overridden by other types in this {{container}} type.`,\n      overrides: `'{{typeName}}' overrides all other types in this {{container}} type.`\n    },\n    schema: [],\n    type: 'suggestion'\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const parserServices = util.getParserServices(context);\n    const typesCache = new Map();\n\n    function getTypeNodeTypePartFlags(typeNode) {\n      const keywordTypeFlags = keywordNodeTypesToTsTypes.get(typeNode.type);\n\n      if (keywordTypeFlags) {\n        return [{\n          typeFlags: keywordTypeFlags,\n          typeName: describeLiteralTypeNode(typeNode)\n        }];\n      }\n\n      if (typeNode.type === utils_1.AST_NODE_TYPES.TSLiteralType && typeNode.literal.type === utils_1.AST_NODE_TYPES.Literal) {\n        return [{\n          typeFlags: primitiveTypeFlagTypes[typeof typeNode.literal.value],\n          typeName: describeLiteralTypeNode(typeNode)\n        }];\n      }\n\n      if (typeNode.type === utils_1.AST_NODE_TYPES.TSUnionType) {\n        return typeNode.types.flatMap(getTypeNodeTypePartFlags);\n      }\n\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(typeNode);\n      const checker = parserServices.program.getTypeChecker();\n      const nodeType = checker.getTypeAtLocation(tsNode);\n      const typeParts = unionTypePartsUnlessBoolean(nodeType);\n      return typeParts.map(typePart => ({\n        typeFlags: typePart.flags,\n        typeName: describeLiteralType(typePart)\n      }));\n    }\n\n    function getTypeNodeTypePartFlagsCached(typeNode) {\n      const existing = typesCache.get(typeNode);\n\n      if (existing) {\n        return existing;\n      }\n\n      const created = getTypeNodeTypePartFlags(typeNode);\n      typesCache.set(typeNode, created);\n      return created;\n    }\n\n    return {\n      'TSIntersectionType:exit'(node) {\n        const seenLiteralTypes = new Map();\n        const seenPrimitiveTypes = new Map();\n\n        function checkIntersectionBottomAndTopTypes(_ref, typeNode) {\n          let {\n            typeFlags,\n            typeName\n          } = _ref;\n\n          for (const [messageId, checkFlag] of [['overrides', ts.TypeFlags.Any], ['overrides', ts.TypeFlags.Never], ['overridden', ts.TypeFlags.Unknown]]) {\n            if (typeFlags === checkFlag) {\n              context.report({\n                data: {\n                  container: 'intersection',\n                  typeName\n                },\n                messageId,\n                node: typeNode\n              });\n              return true;\n            }\n          }\n\n          return false;\n        }\n\n        for (const typeNode of node.types) {\n          const typePartFlags = getTypeNodeTypePartFlagsCached(typeNode);\n\n          for (const typePart of typePartFlags) {\n            if (checkIntersectionBottomAndTopTypes(typePart, typeNode)) {\n              continue;\n            }\n\n            for (const literalTypeFlag of literalTypeFlags) {\n              if (typePart.typeFlags === literalTypeFlag) {\n                addToMapGroup(seenLiteralTypes, literalToPrimitiveTypeFlags[literalTypeFlag], typePart.typeName);\n                break;\n              }\n            }\n\n            for (const primitiveTypeFlag of primitiveTypeFlags) {\n              if (typePart.typeFlags === primitiveTypeFlag) {\n                addToMapGroup(seenPrimitiveTypes, primitiveTypeFlag, typeNode);\n              }\n            }\n          }\n        } // For each primitive type of all the seen primitive types,\n        // if there was a literal type seen that overrides it,\n        // report each of the primitive type's type nodes\n\n\n        for (const [primitiveTypeFlag, typeNodes] of seenPrimitiveTypes) {\n          const matchedLiteralTypes = seenLiteralTypes.get(primitiveTypeFlag);\n\n          if (matchedLiteralTypes) {\n            for (const typeNode of typeNodes) {\n              context.report({\n                data: {\n                  literal: matchedLiteralTypes.join(' | '),\n                  primitive: primitiveTypeFlagNames[primitiveTypeFlag]\n                },\n                messageId: 'primitiveOverridden',\n                node: typeNode\n              });\n            }\n          }\n        }\n      },\n\n      'TSUnionType:exit'(node) {\n        const seenLiteralTypes = new Map();\n        const seenPrimitiveTypes = new Set();\n\n        function checkUnionBottomAndTopTypes(_ref2, typeNode) {\n          let {\n            typeFlags,\n            typeName\n          } = _ref2;\n\n          for (const checkFlag of [ts.TypeFlags.Any, ts.TypeFlags.Unknown]) {\n            if (typeFlags === checkFlag) {\n              context.report({\n                data: {\n                  container: 'union',\n                  typeName\n                },\n                messageId: 'overrides',\n                node: typeNode\n              });\n              return true;\n            }\n          }\n\n          if (typeFlags === ts.TypeFlags.Never && !isNodeInsideReturnType(node)) {\n            context.report({\n              data: {\n                container: 'union',\n                typeName: 'never'\n              },\n              messageId: 'overridden',\n              node: typeNode\n            });\n            return true;\n          }\n\n          return false;\n        }\n\n        for (const typeNode of node.types) {\n          const typePartFlags = getTypeNodeTypePartFlagsCached(typeNode);\n\n          for (const typePart of typePartFlags) {\n            if (checkUnionBottomAndTopTypes(typePart, typeNode)) {\n              continue;\n            }\n\n            for (const literalTypeFlag of literalTypeFlags) {\n              if (typePart.typeFlags === literalTypeFlag) {\n                addToMapGroup(seenLiteralTypes, literalToPrimitiveTypeFlags[literalTypeFlag], {\n                  literalValue: typePart.typeName,\n                  typeNode\n                });\n                break;\n              }\n            }\n\n            for (const primitiveTypeFlag of primitiveTypeFlags) {\n              if ((typePart.typeFlags & primitiveTypeFlag) !== 0) {\n                seenPrimitiveTypes.add(primitiveTypeFlag);\n              }\n            }\n          }\n        }\n\n        const overriddenTypeNodes = new Map(); // For each primitive type of all the seen literal types,\n        // if there was a primitive type seen that overrides it,\n        // upsert the literal text and primitive type under the backing type node\n\n        for (const [primitiveTypeFlag, typeNodesWithText] of seenLiteralTypes) {\n          if (seenPrimitiveTypes.has(primitiveTypeFlag)) {\n            for (const {\n              literalValue,\n              typeNode\n            } of typeNodesWithText) {\n              addToMapGroup(overriddenTypeNodes, typeNode, {\n                literalValue,\n                primitiveTypeFlag\n              });\n            }\n          }\n        } // For each type node that had at least one overridden literal,\n        // group those literals by their primitive type,\n        // then report each primitive type with all its literals\n\n\n        for (const [typeNode, typeFlagsWithText] of overriddenTypeNodes) {\n          const grouped = util.arrayGroupByToMap(typeFlagsWithText, pair => pair.primitiveTypeFlag);\n\n          for (const [primitiveTypeFlag, pairs] of grouped) {\n            context.report({\n              data: {\n                literal: pairs.map(pair => pair.literalValue).join(' | '),\n                primitive: primitiveTypeFlagNames[primitiveTypeFlag]\n              },\n              messageId: 'literalOverridden',\n              node: typeNode\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["literalToPrimitiveTypeFlags","ts","TypeFlags","BigIntLiteral","BigInt","BooleanLiteral","Boolean","NumberLiteral","Number","StringLiteral","String","TemplateLiteral","literalTypeFlags","primitiveTypeFlags","primitiveTypeFlagNames","primitiveTypeFlagTypes","bigint","boolean","number","string","keywordNodeTypesToTsTypes","Map","utils_1","AST_NODE_TYPES","TSAnyKeyword","Any","TSBigIntKeyword","TSBooleanKeyword","TSNeverKeyword","Never","TSUnknownKeyword","Unknown","TSNumberKeyword","TSStringKeyword","addToMapGroup","map","key","value","existing","get","push","set","describeLiteralType","type","isStringLiteral","JSON","stringify","isLiteral","toString","util","isTypeAnyType","isTypeNeverType","isTypeUnknownType","isTypeTemplateLiteralType","isTypeBigIntLiteralType","negative","base10Value","tsutils","isBooleanLiteralType","describeLiteralTypeNode","typeNode","TSLiteralType","literal","Literal","isNodeInsideReturnType","node","parent","_a","TSTypeAnnotation","isFunctionType","isFunction","unionTypePartsUnlessBoolean","isUnion","types","length","unionTypeParts","exports","createRule","name","meta","docs","description","recommended","requiresTypeChecking","messages","literalOverridden","primitiveOverridden","overridden","overrides","schema","defaultOptions","create","context","parserServices","getParserServices","typesCache","getTypeNodeTypePartFlags","keywordTypeFlags","typeFlags","typeName","TSUnionType","flatMap","tsNode","esTreeNodeToTSNodeMap","checker","program","getTypeChecker","nodeType","getTypeAtLocation","typeParts","typePart","flags","getTypeNodeTypePartFlagsCached","created","seenLiteralTypes","seenPrimitiveTypes","checkIntersectionBottomAndTopTypes","messageId","checkFlag","report","data","container","typePartFlags","literalTypeFlag","primitiveTypeFlag","typeNodes","matchedLiteralTypes","join","primitive","Set","checkUnionBottomAndTopTypes","literalValue","add","overriddenTypeNodes","typeNodesWithText","has","typeFlagsWithText","grouped","arrayGroupByToMap","pair","pairs"],"sources":["../../src/rules/no-redundant-type-constituents.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}