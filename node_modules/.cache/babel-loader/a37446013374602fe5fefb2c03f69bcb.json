{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.recursivePatternCapture = recursivePatternCapture;\n\nvar _fs = require('fs');\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = require('path');\n\nvar _doctrine = require('doctrine');\n\nvar _doctrine2 = _interopRequireDefault(_doctrine);\n\nvar _debug = require('debug');\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar _eslint = require('eslint');\n\nvar _parse = require('eslint-module-utils/parse');\n\nvar _parse2 = _interopRequireDefault(_parse);\n\nvar _visit = require('eslint-module-utils/visit');\n\nvar _visit2 = _interopRequireDefault(_visit);\n\nvar _resolve = require('eslint-module-utils/resolve');\n\nvar _resolve2 = _interopRequireDefault(_resolve);\n\nvar _ignore = require('eslint-module-utils/ignore');\n\nvar _ignore2 = _interopRequireDefault(_ignore);\n\nvar _hash = require('eslint-module-utils/hash');\n\nvar _unambiguous = require('eslint-module-utils/unambiguous');\n\nvar unambiguous = _interopRequireWildcard(_unambiguous);\n\nvar _tsconfigLoader = require('tsconfig-paths/lib/tsconfig-loader');\n\nvar _arrayIncludes = require('array-includes');\n\nvar _arrayIncludes2 = _interopRequireDefault(_arrayIncludes);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj['default'] = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar ts = void 0;\nvar log = (0, _debug2['default'])('eslint-plugin-import:ExportMap');\nvar exportCache = new Map();\nvar tsConfigCache = new Map();\n\nvar ExportMap = function () {\n  function ExportMap(path) {\n    _classCallCheck(this, ExportMap);\n\n    this.path = path;\n    this.namespace = new Map(); // todo: restructure to key on path, value is resolver + map of names\n\n    this.reexports = new Map();\n    /**\n     * star-exports\n     * @type {Set} of () => ExportMap\n     */\n\n    this.dependencies = new Set();\n    /**\n     * dependencies of this module that are not explicitly re-exported\n     * @type {Map} from path = () => ExportMap\n     */\n\n    this.imports = new Map();\n    this.errors = [];\n    /**\n     * type {'ambiguous' | 'Module' | 'Script'}\n     */\n\n    this.parseGoal = 'ambiguous';\n  }\n\n  _createClass(ExportMap, [{\n    key: 'has',\n\n    /**\n     * Note that this does not check explicitly re-exported names for existence\n     * in the base namespace, but it will expand all `export * from '...'` exports\n     * if not found in the explicit namespace.\n     * @param  {string}  name\n     * @return {Boolean} true if `name` is exported by this module.\n     */\n    value: function () {\n      function has(name) {\n        if (this.namespace.has(name)) return true;\n        if (this.reexports.has(name)) return true; // default exports must be explicitly re-exported (#328)\n\n        if (name !== 'default') {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = this.dependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var dep = _step.value;\n              var innerMap = dep(); // todo: report as unresolved?\n\n              if (!innerMap) continue;\n              if (innerMap.has(name)) return true;\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator['return']) {\n                _iterator['return']();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n\n        return false;\n      }\n\n      return has;\n    }()\n    /**\n     * ensure that imported name fully resolves.\n     * @param  {string} name\n     * @return {{ found: boolean, path: ExportMap[] }}\n     */\n\n  }, {\n    key: 'hasDeep',\n    value: function () {\n      function hasDeep(name) {\n        if (this.namespace.has(name)) return {\n          found: true,\n          path: [this]\n        };\n\n        if (this.reexports.has(name)) {\n          var reexports = this.reexports.get(name);\n          var imported = reexports.getImport(); // if import is ignored, return explicit 'null'\n\n          if (imported == null) return {\n            found: true,\n            path: [this]\n          }; // safeguard against cycles, only if name matches\n\n          if (imported.path === this.path && reexports.local === name) {\n            return {\n              found: false,\n              path: [this]\n            };\n          }\n\n          var deep = imported.hasDeep(reexports.local);\n          deep.path.unshift(this);\n          return deep;\n        } // default exports must be explicitly re-exported (#328)\n\n\n        if (name !== 'default') {\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = this.dependencies[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var dep = _step2.value;\n              var innerMap = dep();\n              if (innerMap == null) return {\n                found: true,\n                path: [this]\n              }; // todo: report as unresolved?\n\n              if (!innerMap) continue; // safeguard against cycles\n\n              if (innerMap.path === this.path) continue;\n              var innerValue = innerMap.hasDeep(name);\n\n              if (innerValue.found) {\n                innerValue.path.unshift(this);\n                return innerValue;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n                _iterator2['return']();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n\n        return {\n          found: false,\n          path: [this]\n        };\n      }\n\n      return hasDeep;\n    }()\n  }, {\n    key: 'get',\n    value: function () {\n      function get(name) {\n        if (this.namespace.has(name)) return this.namespace.get(name);\n\n        if (this.reexports.has(name)) {\n          var reexports = this.reexports.get(name);\n          var imported = reexports.getImport(); // if import is ignored, return explicit 'null'\n\n          if (imported == null) return null; // safeguard against cycles, only if name matches\n\n          if (imported.path === this.path && reexports.local === name) return undefined;\n          return imported.get(reexports.local);\n        } // default exports must be explicitly re-exported (#328)\n\n\n        if (name !== 'default') {\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = this.dependencies[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var dep = _step3.value;\n              var innerMap = dep(); // todo: report as unresolved?\n\n              if (!innerMap) continue; // safeguard against cycles\n\n              if (innerMap.path === this.path) continue;\n              var innerValue = innerMap.get(name);\n              if (innerValue !== undefined) return innerValue;\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3['return']) {\n                _iterator3['return']();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n\n        return undefined;\n      }\n\n      return get;\n    }()\n  }, {\n    key: 'forEach',\n    value: function () {\n      function forEach(callback, thisArg) {\n        var _this = this;\n\n        this.namespace.forEach(function (v, n) {\n          return callback.call(thisArg, v, n, _this);\n        });\n        this.reexports.forEach(function (reexports, name) {\n          var reexported = reexports.getImport(); // can't look up meta for ignored re-exports (#348)\n\n          callback.call(thisArg, reexported && reexported.get(reexports.local), name, _this);\n        });\n        this.dependencies.forEach(function (dep) {\n          var d = dep(); // CJS / ignored dependencies won't exist (#717)\n\n          if (d == null) return;\n          d.forEach(function (v, n) {\n            return n !== 'default' && callback.call(thisArg, v, n, _this);\n          });\n        });\n      }\n\n      return forEach;\n    }() // todo: keys, values, entries?\n\n  }, {\n    key: 'reportErrors',\n    value: function () {\n      function reportErrors(context, declaration) {\n        context.report({\n          node: declaration.source,\n          message: 'Parse errors in imported module \\'' + String(declaration.source.value) + '\\': ' + ('' + String(this.errors.map(function (e) {\n            return String(e.message) + ' (' + String(e.lineNumber) + ':' + String(e.column) + ')';\n          }).join(', ')))\n        });\n      }\n\n      return reportErrors;\n    }()\n  }, {\n    key: 'hasDefault',\n    get: function () {\n      function get() {\n        return this.get('default') != null;\n      }\n\n      return get;\n    }() // stronger than this.has\n\n  }, {\n    key: 'size',\n    get: function () {\n      function get() {\n        var size = this.namespace.size + this.reexports.size;\n        this.dependencies.forEach(function (dep) {\n          var d = dep(); // CJS / ignored dependencies won't exist (#717)\n\n          if (d == null) return;\n          size += d.size;\n        });\n        return size;\n      }\n\n      return get;\n    }()\n  }]);\n\n  return ExportMap;\n}();\n/**\n * parse docs from the first node that has leading comments\n */\n\n\nexports['default'] = ExportMap;\n\nfunction captureDoc(source, docStyleParsers) {\n  var metadata = {}; // 'some' short-circuits on first 'true'\n\n  for (var _len = arguments.length, nodes = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    nodes[_key - 2] = arguments[_key];\n  }\n\n  nodes.some(function (n) {\n    try {\n      var leadingComments = void 0; // n.leadingComments is legacy `attachComments` behavior\n\n      if ('leadingComments' in n) {\n        leadingComments = n.leadingComments;\n      } else if (n.range) {\n        leadingComments = source.getCommentsBefore(n);\n      }\n\n      if (!leadingComments || leadingComments.length === 0) return false;\n\n      for (var name in docStyleParsers) {\n        var doc = docStyleParsers[name](leadingComments);\n\n        if (doc) {\n          metadata.doc = doc;\n        }\n      }\n\n      return true;\n    } catch (err) {\n      return false;\n    }\n  });\n  return metadata;\n}\n\nvar availableDocStyleParsers = {\n  jsdoc: captureJsDoc,\n  tomdoc: captureTomDoc\n};\n/**\n * parse JSDoc from leading comments\n * @param {object[]} comments\n * @return {{ doc: object }}\n */\n\nfunction captureJsDoc(comments) {\n  var doc = void 0; // capture XSDoc\n\n  comments.forEach(function (comment) {\n    // skip non-block comments\n    if (comment.type !== 'Block') return;\n\n    try {\n      doc = _doctrine2['default'].parse(comment.value, {\n        unwrap: true\n      });\n    } catch (err) {\n      /* don't care, for now? maybe add to `errors?` */\n    }\n  });\n  return doc;\n}\n/**\n  * parse TomDoc section from comments\n  */\n\n\nfunction captureTomDoc(comments) {\n  // collect lines up to first paragraph break\n  var lines = [];\n\n  for (var i = 0; i < comments.length; i++) {\n    var comment = comments[i];\n    if (comment.value.match(/^\\s*$/)) break;\n    lines.push(comment.value.trim());\n  } // return doctrine-like object\n\n\n  var statusMatch = lines.join(' ').match(/^(Public|Internal|Deprecated):\\s*(.+)/);\n\n  if (statusMatch) {\n    return {\n      description: statusMatch[2],\n      tags: [{\n        title: statusMatch[1].toLowerCase(),\n        description: statusMatch[2]\n      }]\n    };\n  }\n}\n\nvar supportedImportTypes = new Set(['ImportDefaultSpecifier', 'ImportNamespaceSpecifier']);\n\nExportMap.get = function (source, context) {\n  var path = (0, _resolve2['default'])(source, context);\n  if (path == null) return null;\n  return ExportMap['for'](childContext(path, context));\n};\n\nExportMap['for'] = function (context) {\n  var path = context.path;\n  var cacheKey = (0, _hash.hashObject)(context).digest('hex');\n  var exportMap = exportCache.get(cacheKey); // return cached ignore\n\n  if (exportMap === null) return null;\n\n  var stats = _fs2['default'].statSync(path);\n\n  if (exportMap != null) {\n    // date equality check\n    if (exportMap.mtime - stats.mtime === 0) {\n      return exportMap;\n    } // future: check content equality?\n\n  } // check valid extensions first\n\n\n  if (!(0, _ignore.hasValidExtension)(path, context)) {\n    exportCache.set(cacheKey, null);\n    return null;\n  } // check for and cache ignore\n\n\n  if ((0, _ignore2['default'])(path, context)) {\n    log('ignored path due to ignore settings:', path);\n    exportCache.set(cacheKey, null);\n    return null;\n  }\n\n  var content = _fs2['default'].readFileSync(path, {\n    encoding: 'utf8'\n  }); // check for and cache unambiguous modules\n\n\n  if (!unambiguous.test(content)) {\n    log('ignored path due to unambiguous regex:', path);\n    exportCache.set(cacheKey, null);\n    return null;\n  }\n\n  log('cache miss', cacheKey, 'for path', path);\n  exportMap = ExportMap.parse(path, content, context); // ambiguous modules return null\n\n  if (exportMap == null) return null;\n  exportMap.mtime = stats.mtime;\n  exportCache.set(cacheKey, exportMap);\n  return exportMap;\n};\n\nExportMap.parse = function (path, content, context) {\n  var m = new ExportMap(path);\n  var isEsModuleInteropTrue = isEsModuleInterop();\n  var ast = void 0;\n  var visitorKeys = void 0;\n\n  try {\n    var result = (0, _parse2['default'])(path, content, context);\n    ast = result.ast;\n    visitorKeys = result.visitorKeys;\n  } catch (err) {\n    m.errors.push(err);\n    return m; // can't continue\n  }\n\n  m.visitorKeys = visitorKeys;\n  var hasDynamicImports = false;\n\n  function processDynamicImport(source) {\n    hasDynamicImports = true;\n\n    if (source.type !== 'Literal') {\n      return null;\n    }\n\n    var p = remotePath(source.value);\n\n    if (p == null) {\n      return null;\n    }\n\n    var importedSpecifiers = new Set();\n    importedSpecifiers.add('ImportNamespaceSpecifier');\n    var getter = thunkFor(p, context);\n    m.imports.set(p, {\n      getter: getter,\n      declarations: new Set([{\n        source: {\n          // capturing actual node reference holds full AST in memory!\n          value: source.value,\n          loc: source.loc\n        },\n        importedSpecifiers: importedSpecifiers\n      }])\n    });\n  }\n\n  (0, _visit2['default'])(ast, visitorKeys, {\n    ImportExpression: function () {\n      function ImportExpression(node) {\n        processDynamicImport(node.source);\n      }\n\n      return ImportExpression;\n    }(),\n    CallExpression: function () {\n      function CallExpression(node) {\n        if (node.callee.type === 'Import') {\n          processDynamicImport(node.arguments[0]);\n        }\n      }\n\n      return CallExpression;\n    }()\n  });\n  var unambiguouslyESM = unambiguous.isModule(ast);\n  if (!unambiguouslyESM && !hasDynamicImports) return null;\n  var docstyle = context.settings && context.settings['import/docstyle'] || ['jsdoc'];\n  var docStyleParsers = {};\n  docstyle.forEach(function (style) {\n    docStyleParsers[style] = availableDocStyleParsers[style];\n  }); // attempt to collect module doc\n\n  if (ast.comments) {\n    ast.comments.some(function (c) {\n      if (c.type !== 'Block') return false;\n\n      try {\n        var doc = _doctrine2['default'].parse(c.value, {\n          unwrap: true\n        });\n\n        if (doc.tags.some(function (t) {\n          return t.title === 'module';\n        })) {\n          m.doc = doc;\n          return true;\n        }\n      } catch (err) {\n        /* ignore */\n      }\n\n      return false;\n    });\n  }\n\n  var namespaces = new Map();\n\n  function remotePath(value) {\n    return _resolve2['default'].relative(value, path, context.settings);\n  }\n\n  function resolveImport(value) {\n    var rp = remotePath(value);\n    if (rp == null) return null;\n    return ExportMap['for'](childContext(rp, context));\n  }\n\n  function getNamespace(identifier) {\n    if (!namespaces.has(identifier.name)) return;\n    return function () {\n      return resolveImport(namespaces.get(identifier.name));\n    };\n  }\n\n  function addNamespace(object, identifier) {\n    var nsfn = getNamespace(identifier);\n\n    if (nsfn) {\n      Object.defineProperty(object, 'namespace', {\n        get: nsfn\n      });\n    }\n\n    return object;\n  }\n\n  function processSpecifier(s, n, m) {\n    var nsource = n.source && n.source.value;\n    var exportMeta = {};\n    var local = void 0;\n\n    switch (s.type) {\n      case 'ExportDefaultSpecifier':\n        if (!nsource) return;\n        local = 'default';\n        break;\n\n      case 'ExportNamespaceSpecifier':\n        m.namespace.set(s.exported.name, Object.defineProperty(exportMeta, 'namespace', {\n          get: function () {\n            function get() {\n              return resolveImport(nsource);\n            }\n\n            return get;\n          }()\n        }));\n        return;\n\n      case 'ExportAllDeclaration':\n        m.namespace.set(s.exported.name || s.exported.value, addNamespace(exportMeta, s.source.value));\n        return;\n\n      case 'ExportSpecifier':\n        if (!n.source) {\n          m.namespace.set(s.exported.name || s.exported.value, addNamespace(exportMeta, s.local));\n          return;\n        }\n\n      // else falls through\n\n      default:\n        local = s.local.name;\n        break;\n    } // todo: JSDoc\n\n\n    m.reexports.set(s.exported.name, {\n      local: local,\n      getImport: function () {\n        function getImport() {\n          return resolveImport(nsource);\n        }\n\n        return getImport;\n      }()\n    });\n  }\n\n  function captureDependency(_ref, isOnlyImportingTypes) {\n    var source = _ref.source;\n    var importedSpecifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n    if (source == null) return null;\n    var p = remotePath(source.value);\n    if (p == null) return null;\n    var declarationMetadata = {\n      // capturing actual node reference holds full AST in memory!\n      source: {\n        value: source.value,\n        loc: source.loc\n      },\n      isOnlyImportingTypes: isOnlyImportingTypes,\n      importedSpecifiers: importedSpecifiers\n    };\n    var existing = m.imports.get(p);\n\n    if (existing != null) {\n      existing.declarations.add(declarationMetadata);\n      return existing.getter;\n    }\n\n    var getter = thunkFor(p, context);\n    m.imports.set(p, {\n      getter: getter,\n      declarations: new Set([declarationMetadata])\n    });\n    return getter;\n  }\n\n  var source = makeSourceCode(content, ast);\n\n  function readTsConfig() {\n    var tsConfigInfo = (0, _tsconfigLoader.tsConfigLoader)({\n      cwd: context.parserOptions && context.parserOptions.tsconfigRootDir || process.cwd(),\n      getEnv: function () {\n        function getEnv(key) {\n          return process.env[key];\n        }\n\n        return getEnv;\n      }()\n    });\n\n    try {\n      if (tsConfigInfo.tsConfigPath !== undefined) {\n        // Projects not using TypeScript won't have `typescript` installed.\n        if (!ts) {\n          ts = require('typescript');\n        }\n\n        var configFile = ts.readConfigFile(tsConfigInfo.tsConfigPath, ts.sys.readFile);\n        return ts.parseJsonConfigFileContent(configFile.config, ts.sys, (0, _path.dirname)(tsConfigInfo.tsConfigPath));\n      }\n    } catch (e) {// Catch any errors\n    }\n\n    return null;\n  }\n\n  function isEsModuleInterop() {\n    var cacheKey = (0, _hash.hashObject)({\n      tsconfigRootDir: context.parserOptions && context.parserOptions.tsconfigRootDir\n    }).digest('hex');\n    var tsConfig = tsConfigCache.get(cacheKey);\n\n    if (typeof tsConfig === 'undefined') {\n      tsConfig = readTsConfig(context);\n      tsConfigCache.set(cacheKey, tsConfig);\n    }\n\n    return tsConfig && tsConfig.options ? tsConfig.options.esModuleInterop : false;\n  }\n\n  ast.body.forEach(function (n) {\n    if (n.type === 'ExportDefaultDeclaration') {\n      var exportMeta = captureDoc(source, docStyleParsers, n);\n\n      if (n.declaration.type === 'Identifier') {\n        addNamespace(exportMeta, n.declaration);\n      }\n\n      m.namespace.set('default', exportMeta);\n      return;\n    }\n\n    if (n.type === 'ExportAllDeclaration') {\n      var getter = captureDependency(n, n.exportKind === 'type');\n      if (getter) m.dependencies.add(getter);\n\n      if (n.exported) {\n        processSpecifier(n, n.exported, m);\n      }\n\n      return;\n    } // capture namespaces in case of later export\n\n\n    if (n.type === 'ImportDeclaration') {\n      // import type { Foo } (TS and Flow)\n      var declarationIsType = n.importKind === 'type'; // import './foo' or import {} from './foo' (both 0 specifiers) is a side effect and\n      // shouldn't be considered to be just importing types\n\n      var specifiersOnlyImportingTypes = n.specifiers.length;\n      var importedSpecifiers = new Set();\n      n.specifiers.forEach(function (specifier) {\n        if (supportedImportTypes.has(specifier.type)) {\n          importedSpecifiers.add(specifier.type);\n        }\n\n        if (specifier.type === 'ImportSpecifier') {\n          importedSpecifiers.add(specifier.imported.name || specifier.imported.value);\n        } // import { type Foo } (Flow)\n\n\n        specifiersOnlyImportingTypes = specifiersOnlyImportingTypes && specifier.importKind === 'type';\n      });\n      captureDependency(n, declarationIsType || specifiersOnlyImportingTypes, importedSpecifiers);\n      var ns = n.specifiers.find(function (s) {\n        return s.type === 'ImportNamespaceSpecifier';\n      });\n\n      if (ns) {\n        namespaces.set(ns.local.name, n.source.value);\n      }\n\n      return;\n    }\n\n    if (n.type === 'ExportNamedDeclaration') {\n      // capture declaration\n      if (n.declaration != null) {\n        switch (n.declaration.type) {\n          case 'FunctionDeclaration':\n          case 'ClassDeclaration':\n          case 'TypeAlias': // flowtype with babel-eslint parser\n\n          case 'InterfaceDeclaration':\n          case 'DeclareFunction':\n          case 'TSDeclareFunction':\n          case 'TSEnumDeclaration':\n          case 'TSTypeAliasDeclaration':\n          case 'TSInterfaceDeclaration':\n          case 'TSAbstractClassDeclaration':\n          case 'TSModuleDeclaration':\n            m.namespace.set(n.declaration.id.name, captureDoc(source, docStyleParsers, n));\n            break;\n\n          case 'VariableDeclaration':\n            n.declaration.declarations.forEach(function (d) {\n              return recursivePatternCapture(d.id, function (id) {\n                return m.namespace.set(id.name, captureDoc(source, docStyleParsers, d, n));\n              });\n            });\n            break;\n        }\n      }\n\n      n.specifiers.forEach(function (s) {\n        return processSpecifier(s, n, m);\n      });\n    }\n\n    var exports = ['TSExportAssignment'];\n\n    if (isEsModuleInteropTrue) {\n      exports.push('TSNamespaceExportDeclaration');\n    } // This doesn't declare anything, but changes what's being exported.\n\n\n    if ((0, _arrayIncludes2['default'])(exports, n.type)) {\n      var exportedName = n.type === 'TSNamespaceExportDeclaration' ? (n.id || n.name).name : n.expression && n.expression.name || n.expression.id && n.expression.id.name || null;\n      var declTypes = ['VariableDeclaration', 'ClassDeclaration', 'TSDeclareFunction', 'TSEnumDeclaration', 'TSTypeAliasDeclaration', 'TSInterfaceDeclaration', 'TSAbstractClassDeclaration', 'TSModuleDeclaration'];\n      var exportedDecls = ast.body.filter(function (_ref2) {\n        var type = _ref2.type,\n            id = _ref2.id,\n            declarations = _ref2.declarations;\n        return (0, _arrayIncludes2['default'])(declTypes, type) && (id && id.name === exportedName || declarations && declarations.find(function (d) {\n          return d.id.name === exportedName;\n        }));\n      });\n\n      if (exportedDecls.length === 0) {\n        // Export is not referencing any local declaration, must be re-exporting\n        m.namespace.set('default', captureDoc(source, docStyleParsers, n));\n        return;\n      }\n\n      if (isEsModuleInteropTrue // esModuleInterop is on in tsconfig\n      && !m.namespace.has('default') // and default isn't added already\n      ) {\n        m.namespace.set('default', {}); // add default export\n      }\n\n      exportedDecls.forEach(function (decl) {\n        if (decl.type === 'TSModuleDeclaration') {\n          if (decl.body && decl.body.type === 'TSModuleDeclaration') {\n            m.namespace.set(decl.body.id.name, captureDoc(source, docStyleParsers, decl.body));\n          } else if (decl.body && decl.body.body) {\n            decl.body.body.forEach(function (moduleBlockNode) {\n              // Export-assignment exports all members in the namespace,\n              // explicitly exported or not.\n              var namespaceDecl = moduleBlockNode.type === 'ExportNamedDeclaration' ? moduleBlockNode.declaration : moduleBlockNode;\n\n              if (!namespaceDecl) {// TypeScript can check this for us; we needn't\n              } else if (namespaceDecl.type === 'VariableDeclaration') {\n                namespaceDecl.declarations.forEach(function (d) {\n                  return recursivePatternCapture(d.id, function (id) {\n                    return m.namespace.set(id.name, captureDoc(source, docStyleParsers, decl, namespaceDecl, moduleBlockNode));\n                  });\n                });\n              } else {\n                m.namespace.set(namespaceDecl.id.name, captureDoc(source, docStyleParsers, moduleBlockNode));\n              }\n            });\n          }\n        } else {\n          // Export as default\n          m.namespace.set('default', captureDoc(source, docStyleParsers, decl));\n        }\n      });\n    }\n  });\n\n  if (isEsModuleInteropTrue // esModuleInterop is on in tsconfig\n  && m.namespace.size > 0 // anything is exported\n  && !m.namespace.has('default') // and default isn't added already\n  ) {\n    m.namespace.set('default', {}); // add default export\n  }\n\n  if (unambiguouslyESM) {\n    m.parseGoal = 'Module';\n  }\n\n  return m;\n};\n/**\n * The creation of this closure is isolated from other scopes\n * to avoid over-retention of unrelated variables, which has\n * caused memory leaks. See #1266.\n */\n\n\nfunction thunkFor(p, context) {\n  return function () {\n    return ExportMap['for'](childContext(p, context));\n  };\n}\n/**\n * Traverse a pattern/identifier node, calling 'callback'\n * for each leaf identifier.\n * @param  {node}   pattern\n * @param  {Function} callback\n * @return {void}\n */\n\n\nfunction recursivePatternCapture(pattern, callback) {\n  switch (pattern.type) {\n    case 'Identifier':\n      // base case\n      callback(pattern);\n      break;\n\n    case 'ObjectPattern':\n      pattern.properties.forEach(function (p) {\n        if (p.type === 'ExperimentalRestProperty' || p.type === 'RestElement') {\n          callback(p.argument);\n          return;\n        }\n\n        recursivePatternCapture(p.value, callback);\n      });\n      break;\n\n    case 'ArrayPattern':\n      pattern.elements.forEach(function (element) {\n        if (element == null) return;\n\n        if (element.type === 'ExperimentalRestProperty' || element.type === 'RestElement') {\n          callback(element.argument);\n          return;\n        }\n\n        recursivePatternCapture(element, callback);\n      });\n      break;\n\n    case 'AssignmentPattern':\n      callback(pattern.left);\n      break;\n  }\n}\n/**\n * don't hold full context object in memory, just grab what we need.\n */\n\n\nfunction childContext(path, context) {\n  var settings = context.settings,\n      parserOptions = context.parserOptions,\n      parserPath = context.parserPath;\n  return {\n    settings: settings,\n    parserOptions: parserOptions,\n    parserPath: parserPath,\n    path: path\n  };\n}\n/**\n * sometimes legacy support isn't _that_ hard... right?\n */\n\n\nfunction makeSourceCode(text, ast) {\n  if (_eslint.SourceCode.length > 1) {\n    // ESLint 3\n    return new _eslint.SourceCode(text, ast);\n  } else {\n    // ESLint 4, 5\n    return new _eslint.SourceCode({\n      text: text,\n      ast: ast\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["recursivePatternCapture","unambiguous","ts","log","exportCache","Map","tsConfigCache","ExportMap","path","_classCallCheck","namespace","reexports","dependencies","Set","imports","errors","parseGoal","name","has","Symbol","dep","innerMap","_didIteratorError","_iteratorError","_iterator","found","get","imported","getImport","local","deep","hasDeep","unshift","innerValue","_didIteratorError2","_iteratorError2","_iterator2","undefined","_didIteratorError3","_iteratorError3","_iterator3","callback","thisArg","forEach","v","n","call","_this","reexported","d","context","declaration","report","node","source","message","value","map","e","lineNumber","column","join","size","captureDoc","docStyleParsers","metadata","nodes","arguments","some","leadingComments","range","getCommentsBefore","length","doc","err","availableDocStyleParsers","jsdoc","captureJsDoc","tomdoc","captureTomDoc","comments","comment","type","doctrine","parse","unwrap","lines","i","match","push","trim","statusMatch","description","tags","title","toLowerCase","supportedImportTypes","childContext","cacheKey","digest","exportMap","stats","fs","statSync","mtime","set","content","readFileSync","encoding","test","m","isEsModuleInteropTrue","isEsModuleInterop","ast","visitorKeys","result","hasDynamicImports","processDynamicImport","p","remotePath","importedSpecifiers","add","getter","thunkFor","declarations","loc","ImportExpression","CallExpression","callee","unambiguouslyESM","isModule","docstyle","settings","style","c","t","namespaces","resolve","relative","resolveImport","rp","getNamespace","identifier","addNamespace","object","nsfn","Object","defineProperty","processSpecifier","s","nsource","exportMeta","exported","captureDependency","isOnlyImportingTypes","declarationMetadata","existing","makeSourceCode","readTsConfig","tsConfigInfo","cwd","parserOptions","tsconfigRootDir","process","getEnv","key","env","tsConfigPath","require","configFile","readConfigFile","sys","readFile","parseJsonConfigFileContent","config","tsConfig","options","esModuleInterop","body","exportKind","declarationIsType","importKind","specifiersOnlyImportingTypes","specifiers","specifier","ns","find","id","exports","exportedName","expression","declTypes","exportedDecls","filter","decl","moduleBlockNode","namespaceDecl","pattern","properties","argument","elements","element","left","parserPath","text","SourceCode"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\ExportMap.js"],"sourcesContent":["import fs from 'fs';\nimport { dirname } from 'path';\n\nimport doctrine from 'doctrine';\n\nimport debug from 'debug';\n\nimport { SourceCode } from 'eslint';\n\nimport parse from 'eslint-module-utils/parse';\nimport visit from 'eslint-module-utils/visit';\nimport resolve from 'eslint-module-utils/resolve';\nimport isIgnored, { hasValidExtension } from 'eslint-module-utils/ignore';\n\nimport { hashObject } from 'eslint-module-utils/hash';\nimport * as unambiguous from 'eslint-module-utils/unambiguous';\n\nimport { tsConfigLoader } from 'tsconfig-paths/lib/tsconfig-loader';\n\nimport includes from 'array-includes';\n\nlet ts;\n\nconst log = debug('eslint-plugin-import:ExportMap');\n\nconst exportCache = new Map();\nconst tsConfigCache = new Map();\n\nexport default class ExportMap {\n  constructor(path) {\n    this.path = path;\n    this.namespace = new Map();\n    // todo: restructure to key on path, value is resolver + map of names\n    this.reexports = new Map();\n    /**\n     * star-exports\n     * @type {Set} of () => ExportMap\n     */\n    this.dependencies = new Set();\n    /**\n     * dependencies of this module that are not explicitly re-exported\n     * @type {Map} from path = () => ExportMap\n     */\n    this.imports = new Map();\n    this.errors = [];\n    /**\n     * type {'ambiguous' | 'Module' | 'Script'}\n     */\n    this.parseGoal = 'ambiguous';\n  }\n\n  get hasDefault() { return this.get('default') != null; } // stronger than this.has\n\n  get size() {\n    let size = this.namespace.size + this.reexports.size;\n    this.dependencies.forEach(dep => {\n      const d = dep();\n      // CJS / ignored dependencies won't exist (#717)\n      if (d == null) return;\n      size += d.size;\n    });\n    return size;\n  }\n\n  /**\n   * Note that this does not check explicitly re-exported names for existence\n   * in the base namespace, but it will expand all `export * from '...'` exports\n   * if not found in the explicit namespace.\n   * @param  {string}  name\n   * @return {Boolean} true if `name` is exported by this module.\n   */\n  has(name) {\n    if (this.namespace.has(name)) return true;\n    if (this.reexports.has(name)) return true;\n\n    // default exports must be explicitly re-exported (#328)\n    if (name !== 'default') {\n      for (const dep of this.dependencies) {\n        const innerMap = dep();\n\n        // todo: report as unresolved?\n        if (!innerMap) continue;\n\n        if (innerMap.has(name)) return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * ensure that imported name fully resolves.\n   * @param  {string} name\n   * @return {{ found: boolean, path: ExportMap[] }}\n   */\n  hasDeep(name) {\n    if (this.namespace.has(name)) return { found: true, path: [this] };\n\n    if (this.reexports.has(name)) {\n      const reexports = this.reexports.get(name);\n      const imported = reexports.getImport();\n\n      // if import is ignored, return explicit 'null'\n      if (imported == null) return { found: true, path: [this] };\n\n      // safeguard against cycles, only if name matches\n      if (imported.path === this.path && reexports.local === name) {\n        return { found: false, path: [this] };\n      }\n\n      const deep = imported.hasDeep(reexports.local);\n      deep.path.unshift(this);\n\n      return deep;\n    }\n\n\n    // default exports must be explicitly re-exported (#328)\n    if (name !== 'default') {\n      for (const dep of this.dependencies) {\n        const innerMap = dep();\n        if (innerMap == null) return { found: true, path: [this] };\n        // todo: report as unresolved?\n        if (!innerMap) continue;\n\n        // safeguard against cycles\n        if (innerMap.path === this.path) continue;\n\n        const innerValue = innerMap.hasDeep(name);\n        if (innerValue.found) {\n          innerValue.path.unshift(this);\n          return innerValue;\n        }\n      }\n    }\n\n    return { found: false, path: [this] };\n  }\n\n  get(name) {\n    if (this.namespace.has(name)) return this.namespace.get(name);\n\n    if (this.reexports.has(name)) {\n      const reexports = this.reexports.get(name);\n      const imported = reexports.getImport();\n\n      // if import is ignored, return explicit 'null'\n      if (imported == null) return null;\n\n      // safeguard against cycles, only if name matches\n      if (imported.path === this.path && reexports.local === name) return undefined;\n\n      return imported.get(reexports.local);\n    }\n\n    // default exports must be explicitly re-exported (#328)\n    if (name !== 'default') {\n      for (const dep of this.dependencies) {\n        const innerMap = dep();\n        // todo: report as unresolved?\n        if (!innerMap) continue;\n\n        // safeguard against cycles\n        if (innerMap.path === this.path) continue;\n\n        const innerValue = innerMap.get(name);\n        if (innerValue !== undefined) return innerValue;\n      }\n    }\n\n    return undefined;\n  }\n\n  forEach(callback, thisArg) {\n    this.namespace.forEach((v, n) =>\n      callback.call(thisArg, v, n, this));\n\n    this.reexports.forEach((reexports, name) => {\n      const reexported = reexports.getImport();\n      // can't look up meta for ignored re-exports (#348)\n      callback.call(thisArg, reexported && reexported.get(reexports.local), name, this);\n    });\n\n    this.dependencies.forEach(dep => {\n      const d = dep();\n      // CJS / ignored dependencies won't exist (#717)\n      if (d == null) return;\n\n      d.forEach((v, n) =>\n        n !== 'default' && callback.call(thisArg, v, n, this));\n    });\n  }\n\n  // todo: keys, values, entries?\n\n  reportErrors(context, declaration) {\n    context.report({\n      node: declaration.source,\n      message: `Parse errors in imported module '${declaration.source.value}': ` +\n                  `${this.errors\n                    .map(e => `${e.message} (${e.lineNumber}:${e.column})`)\n                    .join(', ')}`,\n    });\n  }\n}\n\n/**\n * parse docs from the first node that has leading comments\n */\nfunction captureDoc(source, docStyleParsers, ...nodes) {\n  const metadata = {};\n\n  // 'some' short-circuits on first 'true'\n  nodes.some(n => {\n    try {\n\n      let leadingComments;\n\n      // n.leadingComments is legacy `attachComments` behavior\n      if ('leadingComments' in n) {\n        leadingComments = n.leadingComments;\n      } else if (n.range) {\n        leadingComments = source.getCommentsBefore(n);\n      }\n\n      if (!leadingComments || leadingComments.length === 0) return false;\n\n      for (const name in docStyleParsers) {\n        const doc = docStyleParsers[name](leadingComments);\n        if (doc) {\n          metadata.doc = doc;\n        }\n      }\n\n      return true;\n    } catch (err) {\n      return false;\n    }\n  });\n\n  return metadata;\n}\n\nconst availableDocStyleParsers = {\n  jsdoc: captureJsDoc,\n  tomdoc: captureTomDoc,\n};\n\n/**\n * parse JSDoc from leading comments\n * @param {object[]} comments\n * @return {{ doc: object }}\n */\nfunction captureJsDoc(comments) {\n  let doc;\n\n  // capture XSDoc\n  comments.forEach(comment => {\n    // skip non-block comments\n    if (comment.type !== 'Block') return;\n    try {\n      doc = doctrine.parse(comment.value, { unwrap: true });\n    } catch (err) {\n      /* don't care, for now? maybe add to `errors?` */\n    }\n  });\n\n  return doc;\n}\n\n/**\n  * parse TomDoc section from comments\n  */\nfunction captureTomDoc(comments) {\n  // collect lines up to first paragraph break\n  const lines = [];\n  for (let i = 0; i < comments.length; i++) {\n    const comment = comments[i];\n    if (comment.value.match(/^\\s*$/)) break;\n    lines.push(comment.value.trim());\n  }\n\n  // return doctrine-like object\n  const statusMatch = lines.join(' ').match(/^(Public|Internal|Deprecated):\\s*(.+)/);\n  if (statusMatch) {\n    return {\n      description: statusMatch[2],\n      tags: [{\n        title: statusMatch[1].toLowerCase(),\n        description: statusMatch[2],\n      }],\n    };\n  }\n}\n\nconst supportedImportTypes = new Set(['ImportDefaultSpecifier', 'ImportNamespaceSpecifier']);\n\nExportMap.get = function (source, context) {\n  const path = resolve(source, context);\n  if (path == null) return null;\n\n  return ExportMap.for(childContext(path, context));\n};\n\nExportMap.for = function (context) {\n  const { path } = context;\n\n  const cacheKey = hashObject(context).digest('hex');\n  let exportMap = exportCache.get(cacheKey);\n\n  // return cached ignore\n  if (exportMap === null) return null;\n\n  const stats = fs.statSync(path);\n  if (exportMap != null) {\n    // date equality check\n    if (exportMap.mtime - stats.mtime === 0) {\n      return exportMap;\n    }\n    // future: check content equality?\n  }\n\n  // check valid extensions first\n  if (!hasValidExtension(path, context)) {\n    exportCache.set(cacheKey, null);\n    return null;\n  }\n\n  // check for and cache ignore\n  if (isIgnored(path, context)) {\n    log('ignored path due to ignore settings:', path);\n    exportCache.set(cacheKey, null);\n    return null;\n  }\n\n  const content = fs.readFileSync(path, { encoding: 'utf8' });\n\n  // check for and cache unambiguous modules\n  if (!unambiguous.test(content)) {\n    log('ignored path due to unambiguous regex:', path);\n    exportCache.set(cacheKey, null);\n    return null;\n  }\n\n  log('cache miss', cacheKey, 'for path', path);\n  exportMap = ExportMap.parse(path, content, context);\n\n  // ambiguous modules return null\n  if (exportMap == null) return null;\n\n  exportMap.mtime = stats.mtime;\n\n  exportCache.set(cacheKey, exportMap);\n  return exportMap;\n};\n\n\nExportMap.parse = function (path, content, context) {\n  const m = new ExportMap(path);\n  const isEsModuleInteropTrue = isEsModuleInterop();\n\n  let ast;\n  let visitorKeys;\n  try {\n    const result = parse(path, content, context);\n    ast = result.ast;\n    visitorKeys = result.visitorKeys;\n  } catch (err) {\n    m.errors.push(err);\n    return m; // can't continue\n  }\n\n  m.visitorKeys = visitorKeys;\n\n  let hasDynamicImports = false;\n\n  function processDynamicImport(source) {\n    hasDynamicImports = true;\n    if (source.type !== 'Literal') {\n      return null;\n    }\n    const p = remotePath(source.value);\n    if (p == null) {\n      return null;\n    }\n    const importedSpecifiers = new Set();\n    importedSpecifiers.add('ImportNamespaceSpecifier');\n    const getter = thunkFor(p, context);\n    m.imports.set(p, {\n      getter,\n      declarations: new Set([{\n        source: {\n        // capturing actual node reference holds full AST in memory!\n          value: source.value,\n          loc: source.loc,\n        },\n        importedSpecifiers,\n      }]),\n    });\n  }\n\n  visit(ast, visitorKeys, {\n    ImportExpression(node) {\n      processDynamicImport(node.source);\n    },\n    CallExpression(node) {\n      if (node.callee.type === 'Import') {\n        processDynamicImport(node.arguments[0]);\n      }\n    },\n  });\n\n  const unambiguouslyESM = unambiguous.isModule(ast);\n  if (!unambiguouslyESM && !hasDynamicImports) return null;\n\n  const docstyle = (context.settings && context.settings['import/docstyle']) || ['jsdoc'];\n  const docStyleParsers = {};\n  docstyle.forEach(style => {\n    docStyleParsers[style] = availableDocStyleParsers[style];\n  });\n\n  // attempt to collect module doc\n  if (ast.comments) {\n    ast.comments.some(c => {\n      if (c.type !== 'Block') return false;\n      try {\n        const doc = doctrine.parse(c.value, { unwrap: true });\n        if (doc.tags.some(t => t.title === 'module')) {\n          m.doc = doc;\n          return true;\n        }\n      } catch (err) { /* ignore */ }\n      return false;\n    });\n  }\n\n  const namespaces = new Map();\n\n  function remotePath(value) {\n    return resolve.relative(value, path, context.settings);\n  }\n\n  function resolveImport(value) {\n    const rp = remotePath(value);\n    if (rp == null) return null;\n    return ExportMap.for(childContext(rp, context));\n  }\n\n  function getNamespace(identifier) {\n    if (!namespaces.has(identifier.name)) return;\n\n    return function () {\n      return resolveImport(namespaces.get(identifier.name));\n    };\n  }\n\n  function addNamespace(object, identifier) {\n    const nsfn = getNamespace(identifier);\n    if (nsfn) {\n      Object.defineProperty(object, 'namespace', { get: nsfn });\n    }\n\n    return object;\n  }\n\n  function processSpecifier(s, n, m) {\n    const nsource = n.source && n.source.value;\n    const exportMeta = {};\n    let local;\n\n    switch (s.type) {\n    case 'ExportDefaultSpecifier':\n      if (!nsource) return;\n      local = 'default';\n      break;\n    case 'ExportNamespaceSpecifier':\n      m.namespace.set(s.exported.name, Object.defineProperty(exportMeta, 'namespace', {\n        get() { return resolveImport(nsource); },\n      }));\n      return;\n    case 'ExportAllDeclaration':\n      m.namespace.set(s.exported.name || s.exported.value, addNamespace(exportMeta, s.source.value));\n      return;\n    case 'ExportSpecifier':\n      if (!n.source) {\n        m.namespace.set(s.exported.name || s.exported.value, addNamespace(exportMeta, s.local));\n        return;\n      }\n      // else falls through\n    default:\n      local = s.local.name;\n      break;\n    }\n\n    // todo: JSDoc\n    m.reexports.set(s.exported.name, { local, getImport: () => resolveImport(nsource) });\n  }\n\n  function captureDependency({ source }, isOnlyImportingTypes, importedSpecifiers = new Set()) {\n    if (source == null) return null;\n\n    const p = remotePath(source.value);\n    if (p == null) return null;\n\n    const declarationMetadata = {\n      // capturing actual node reference holds full AST in memory!\n      source: { value: source.value, loc: source.loc },\n      isOnlyImportingTypes,\n      importedSpecifiers,\n    };\n\n    const existing = m.imports.get(p);\n    if (existing != null) {\n      existing.declarations.add(declarationMetadata);\n      return existing.getter;\n    }\n\n    const getter = thunkFor(p, context);\n    m.imports.set(p, { getter, declarations: new Set([declarationMetadata]) });\n    return getter;\n  }\n\n  const source = makeSourceCode(content, ast);\n\n  function readTsConfig() {\n    const tsConfigInfo = tsConfigLoader({\n      cwd:\n        (context.parserOptions && context.parserOptions.tsconfigRootDir) ||\n        process.cwd(),\n      getEnv: (key) => process.env[key],\n    });\n    try {\n      if (tsConfigInfo.tsConfigPath !== undefined) {\n        // Projects not using TypeScript won't have `typescript` installed.\n        if (!ts) { ts = require('typescript'); }\n  \n        const configFile = ts.readConfigFile(tsConfigInfo.tsConfigPath, ts.sys.readFile);\n        return ts.parseJsonConfigFileContent(\n          configFile.config,\n          ts.sys,\n          dirname(tsConfigInfo.tsConfigPath),\n        );\n      }\n    } catch (e) {\n      // Catch any errors\n    }\n\n    return null;\n  }\n\n  function isEsModuleInterop() {\n    const cacheKey = hashObject({\n      tsconfigRootDir: context.parserOptions && context.parserOptions.tsconfigRootDir,\n    }).digest('hex');\n    let tsConfig = tsConfigCache.get(cacheKey);\n    if (typeof tsConfig === 'undefined') {\n      tsConfig = readTsConfig(context);\n      tsConfigCache.set(cacheKey, tsConfig);\n    }\n\n    return tsConfig && tsConfig.options ? tsConfig.options.esModuleInterop : false;\n  }\n\n  ast.body.forEach(function (n) {\n    if (n.type === 'ExportDefaultDeclaration') {\n      const exportMeta = captureDoc(source, docStyleParsers, n);\n      if (n.declaration.type === 'Identifier') {\n        addNamespace(exportMeta, n.declaration);\n      }\n      m.namespace.set('default', exportMeta);\n      return;\n    }\n\n    if (n.type === 'ExportAllDeclaration') {\n      const getter = captureDependency(n, n.exportKind === 'type');\n      if (getter) m.dependencies.add(getter);\n      if (n.exported) {\n        processSpecifier(n, n.exported, m);\n      }\n      return;\n    }\n\n    // capture namespaces in case of later export\n    if (n.type === 'ImportDeclaration') {\n      // import type { Foo } (TS and Flow)\n      const declarationIsType = n.importKind === 'type';\n      // import './foo' or import {} from './foo' (both 0 specifiers) is a side effect and\n      // shouldn't be considered to be just importing types\n      let specifiersOnlyImportingTypes = n.specifiers.length;\n      const importedSpecifiers = new Set();\n      n.specifiers.forEach(specifier => {\n        if (supportedImportTypes.has(specifier.type)) {\n          importedSpecifiers.add(specifier.type);\n        }\n        if (specifier.type === 'ImportSpecifier') {\n          importedSpecifiers.add(specifier.imported.name || specifier.imported.value);\n        }\n\n        // import { type Foo } (Flow)\n        specifiersOnlyImportingTypes =\n          specifiersOnlyImportingTypes && specifier.importKind === 'type';\n      });\n      captureDependency(n, declarationIsType || specifiersOnlyImportingTypes, importedSpecifiers);\n\n      const ns = n.specifiers.find(s => s.type === 'ImportNamespaceSpecifier');\n      if (ns) {\n        namespaces.set(ns.local.name, n.source.value);\n      }\n      return;\n    }\n\n    if (n.type === 'ExportNamedDeclaration') {\n      // capture declaration\n      if (n.declaration != null) {\n        switch (n.declaration.type) {\n        case 'FunctionDeclaration':\n        case 'ClassDeclaration':\n        case 'TypeAlias': // flowtype with babel-eslint parser\n        case 'InterfaceDeclaration':\n        case 'DeclareFunction':\n        case 'TSDeclareFunction':\n        case 'TSEnumDeclaration':\n        case 'TSTypeAliasDeclaration':\n        case 'TSInterfaceDeclaration':\n        case 'TSAbstractClassDeclaration':\n        case 'TSModuleDeclaration':\n          m.namespace.set(n.declaration.id.name, captureDoc(source, docStyleParsers, n));\n          break;\n        case 'VariableDeclaration':\n          n.declaration.declarations.forEach((d) =>\n            recursivePatternCapture(d.id,\n              id => m.namespace.set(id.name, captureDoc(source, docStyleParsers, d, n))));\n          break;\n        }\n      }\n\n      n.specifiers.forEach((s) => processSpecifier(s, n, m));\n    }\n\n    const exports = ['TSExportAssignment'];\n    if (isEsModuleInteropTrue) {\n      exports.push('TSNamespaceExportDeclaration');\n    }\n\n    // This doesn't declare anything, but changes what's being exported.\n    if (includes(exports, n.type)) {\n      const exportedName = n.type === 'TSNamespaceExportDeclaration'\n        ? (n.id || n.name).name\n        : (n.expression && n.expression.name || (n.expression.id && n.expression.id.name) || null);\n      const declTypes = [\n        'VariableDeclaration',\n        'ClassDeclaration',\n        'TSDeclareFunction',\n        'TSEnumDeclaration',\n        'TSTypeAliasDeclaration',\n        'TSInterfaceDeclaration',\n        'TSAbstractClassDeclaration',\n        'TSModuleDeclaration',\n      ];\n      const exportedDecls = ast.body.filter(({ type, id, declarations }) => includes(declTypes, type) && (\n        (id && id.name === exportedName) || (declarations && declarations.find((d) => d.id.name === exportedName))\n      ));\n      if (exportedDecls.length === 0) {\n        // Export is not referencing any local declaration, must be re-exporting\n        m.namespace.set('default', captureDoc(source, docStyleParsers, n));\n        return;\n      }\n      if (\n        isEsModuleInteropTrue // esModuleInterop is on in tsconfig\n        && !m.namespace.has('default') // and default isn't added already\n      ) {\n        m.namespace.set('default', {}); // add default export\n      }\n      exportedDecls.forEach((decl) => {\n        if (decl.type === 'TSModuleDeclaration') {\n          if (decl.body && decl.body.type === 'TSModuleDeclaration') {\n            m.namespace.set(decl.body.id.name, captureDoc(source, docStyleParsers, decl.body));\n          } else if (decl.body && decl.body.body) {\n            decl.body.body.forEach((moduleBlockNode) => {\n              // Export-assignment exports all members in the namespace,\n              // explicitly exported or not.\n              const namespaceDecl = moduleBlockNode.type === 'ExportNamedDeclaration' ?\n                moduleBlockNode.declaration :\n                moduleBlockNode;\n\n              if (!namespaceDecl) {\n                // TypeScript can check this for us; we needn't\n              } else if (namespaceDecl.type === 'VariableDeclaration') {\n                namespaceDecl.declarations.forEach((d) =>\n                  recursivePatternCapture(d.id, (id) => m.namespace.set(\n                    id.name,\n                    captureDoc(source, docStyleParsers, decl, namespaceDecl, moduleBlockNode),\n                  )),\n                );\n              } else {\n                m.namespace.set(\n                  namespaceDecl.id.name,\n                  captureDoc(source, docStyleParsers, moduleBlockNode));\n              }\n            });\n          }\n        } else {\n          // Export as default\n          m.namespace.set('default', captureDoc(source, docStyleParsers, decl));\n        }\n      });\n    }\n  });\n\n  if (\n    isEsModuleInteropTrue // esModuleInterop is on in tsconfig\n    && m.namespace.size > 0 // anything is exported\n    && !m.namespace.has('default') // and default isn't added already\n  ) {\n    m.namespace.set('default', {}); // add default export\n  }\n\n  if (unambiguouslyESM) {\n    m.parseGoal = 'Module';\n  }\n  return m;\n};\n\n/**\n * The creation of this closure is isolated from other scopes\n * to avoid over-retention of unrelated variables, which has\n * caused memory leaks. See #1266.\n */\nfunction thunkFor(p, context) {\n  return () => ExportMap.for(childContext(p, context));\n}\n\n\n/**\n * Traverse a pattern/identifier node, calling 'callback'\n * for each leaf identifier.\n * @param  {node}   pattern\n * @param  {Function} callback\n * @return {void}\n */\nexport function recursivePatternCapture(pattern, callback) {\n  switch (pattern.type) {\n  case 'Identifier': // base case\n    callback(pattern);\n    break;\n\n  case 'ObjectPattern':\n    pattern.properties.forEach(p => {\n      if (p.type === 'ExperimentalRestProperty' || p.type === 'RestElement') {\n        callback(p.argument);\n        return;\n      }\n      recursivePatternCapture(p.value, callback);\n    });\n    break;\n\n  case 'ArrayPattern':\n    pattern.elements.forEach((element) => {\n      if (element == null) return;\n      if (element.type === 'ExperimentalRestProperty' || element.type === 'RestElement') {\n        callback(element.argument);\n        return;\n      }\n      recursivePatternCapture(element, callback);\n    });\n    break;\n\n  case 'AssignmentPattern':\n    callback(pattern.left);\n    break;\n  }\n}\n\n/**\n * don't hold full context object in memory, just grab what we need.\n */\nfunction childContext(path, context) {\n  const { settings, parserOptions, parserPath } = context;\n  return {\n    settings,\n    parserOptions,\n    parserPath,\n    path,\n  };\n}\n\n\n/**\n * sometimes legacy support isn't _that_ hard... right?\n */\nfunction makeSourceCode(text, ast) {\n  if (SourceCode.length > 1) {\n    // ESLint 3\n    return new SourceCode(text, ast);\n  } else {\n    // ESLint 4, 5\n    return new SourceCode({ text, ast });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}