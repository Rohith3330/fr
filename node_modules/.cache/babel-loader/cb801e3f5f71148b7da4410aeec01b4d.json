{"ast":null,"code":"/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStringsOrObjects = {\n  type: \"array\",\n  items: {\n    anyOf: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        name: {\n          type: \"string\"\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        },\n        importNames: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false,\n      required: [\"name\"]\n    }]\n  },\n  uniqueItems: true\n};\nconst arrayOfStringsOrObjectPatterns = {\n  anyOf: [{\n    type: \"array\",\n    items: {\n      type: \"string\"\n    },\n    uniqueItems: true\n  }, {\n    type: \"array\",\n    items: {\n      type: \"object\",\n      properties: {\n        importNames: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          minItems: 1,\n          uniqueItems: true\n        },\n        group: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          minItems: 1,\n          uniqueItems: true\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        },\n        caseSensitive: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false,\n      required: [\"group\"]\n    },\n    uniqueItems: true\n  }]\n};\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow specified modules when loaded by `import`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-restricted-imports\"\n    },\n    messages: {\n      path: \"'{{importSource}}' import is restricted from being used.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n      patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      patternWithCustomMessage: \"'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}\",\n      patternAndImportName: \"'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      patternAndImportNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}\",\n      patternAndEverything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      patternAndEverythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}\",\n      everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\",\n      importName: \"'{{importName}}' import from '{{importSource}}' is restricted.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      importNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}\"\n    },\n    schema: {\n      anyOf: [arrayOfStringsOrObjects, {\n        type: \"array\",\n        items: [{\n          type: \"object\",\n          properties: {\n            paths: arrayOfStringsOrObjects,\n            patterns: arrayOfStringsOrObjectPatterns\n          },\n          additionalProperties: false\n        }],\n        additionalItems: false\n      }]\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = Array.isArray(context.options) ? context.options : [];\n    const isPathAndPatternsObject = typeof options[0] === \"object\" && (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n    const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n      if (typeof importSource === \"string\") {\n        memo[importSource] = {\n          message: null\n        };\n      } else {\n        memo[importSource.name] = {\n          message: importSource.message,\n          importNames: importSource.importNames\n        };\n      }\n\n      return memo;\n    }, {}); // Handle patterns too, either as strings or groups\n\n    let restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || []; // standardize to array of objects if we have an array of strings\n\n    if (restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === \"string\") {\n      restrictedPatterns = [{\n        group: restrictedPatterns\n      }];\n    } // relative paths are supported for this rule\n\n\n    const restrictedPatternGroups = restrictedPatterns.map(_ref => {\n      let {\n        group,\n        message,\n        caseSensitive,\n        importNames\n      } = _ref;\n      return {\n        matcher: ignore({\n          allowRelativePaths: true,\n          ignorecase: !caseSensitive\n        }).add(group),\n        customMessage: message,\n        importNames\n      };\n    }); // if no imports are restricted we don't need to check\n\n    if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {\n      return {};\n    }\n    /**\n     * Report a restricted path.\n     * @param {string} importSource path of the import\n     * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n     * @param {node} node representing the restricted path reference\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkRestrictedPathAndReport(importSource, importNames, node) {\n      if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n        return;\n      }\n\n      const customMessage = restrictedPathMessages[importSource].message;\n      const restrictedImportNames = restrictedPathMessages[importSource].importNames;\n\n      if (restrictedImportNames) {\n        if (importNames.has(\"*\")) {\n          const specifierData = importNames.get(\"*\")[0];\n          context.report({\n            node,\n            messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n            loc: specifierData.loc,\n            data: {\n              importSource,\n              importNames: restrictedImportNames,\n              customMessage\n            }\n          });\n        }\n\n        restrictedImportNames.forEach(importName => {\n          if (importNames.has(importName)) {\n            const specifiers = importNames.get(importName);\n            specifiers.forEach(specifier => {\n              context.report({\n                node,\n                messageId: customMessage ? \"importNameWithCustomMessage\" : \"importName\",\n                loc: specifier.loc,\n                data: {\n                  importSource,\n                  customMessage,\n                  importName\n                }\n              });\n            });\n          }\n        });\n      } else {\n        context.report({\n          node,\n          messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n          data: {\n            importSource,\n            customMessage\n          }\n        });\n      }\n    }\n    /**\n     * Report a restricted path specifically for patterns.\n     * @param {node} node representing the restricted path reference\n     * @param {Object} group contains an Ignore instance for paths, the customMessage to show on failure,\n     * and any restricted import names that have been specified in the config\n     * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n     * @returns {void}\n     * @private\n     */\n\n\n    function reportPathForPatterns(node, group, importNames) {\n      const importSource = node.source.value.trim();\n      const customMessage = group.customMessage;\n      const restrictedImportNames = group.importNames;\n      /*\n       * If we are not restricting to any specific import names and just the pattern itself,\n       * report the error and move on\n       */\n\n      if (!restrictedImportNames) {\n        context.report({\n          node,\n          messageId: customMessage ? \"patternWithCustomMessage\" : \"patterns\",\n          data: {\n            importSource,\n            customMessage\n          }\n        });\n        return;\n      }\n\n      if (importNames.has(\"*\")) {\n        const specifierData = importNames.get(\"*\")[0];\n        context.report({\n          node,\n          messageId: customMessage ? \"patternAndEverythingWithCustomMessage\" : \"patternAndEverything\",\n          loc: specifierData.loc,\n          data: {\n            importSource,\n            importNames: restrictedImportNames,\n            customMessage\n          }\n        });\n      }\n\n      restrictedImportNames.forEach(importName => {\n        if (!importNames.has(importName)) {\n          return;\n        }\n\n        const specifiers = importNames.get(importName);\n        specifiers.forEach(specifier => {\n          context.report({\n            node,\n            messageId: customMessage ? \"patternAndImportNameWithCustomMessage\" : \"patternAndImportName\",\n            loc: specifier.loc,\n            data: {\n              importSource,\n              customMessage,\n              importName\n            }\n          });\n        });\n      });\n    }\n    /**\n     * Check if the given importSource is restricted by a pattern.\n     * @param {string} importSource path of the import\n     * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\n     * @returns {boolean} whether the variable is a restricted pattern or not\n     * @private\n     */\n\n\n    function isRestrictedPattern(importSource, group) {\n      return group.matcher.ignores(importSource);\n    }\n    /**\n     * Checks a node to see if any problems should be reported.\n     * @param {ASTNode} node The node to check.\n     * @returns {void}\n     * @private\n     */\n\n\n    function checkNode(node) {\n      const importSource = node.source.value.trim();\n      const importNames = new Map();\n\n      if (node.type === \"ExportAllDeclaration\") {\n        const starToken = sourceCode.getFirstToken(node, 1);\n        importNames.set(\"*\", [{\n          loc: starToken.loc\n        }]);\n      } else if (node.specifiers) {\n        for (const specifier of node.specifiers) {\n          let name;\n          const specifierData = {\n            loc: specifier.loc\n          };\n\n          if (specifier.type === \"ImportDefaultSpecifier\") {\n            name = \"default\";\n          } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n            name = \"*\";\n          } else if (specifier.imported) {\n            name = astUtils.getModuleExportName(specifier.imported);\n          } else if (specifier.local) {\n            name = astUtils.getModuleExportName(specifier.local);\n          }\n\n          if (typeof name === \"string\") {\n            if (importNames.has(name)) {\n              importNames.get(name).push(specifierData);\n            } else {\n              importNames.set(name, [specifierData]);\n            }\n          }\n        }\n      }\n\n      checkRestrictedPathAndReport(importSource, importNames, node);\n      restrictedPatternGroups.forEach(group => {\n        if (isRestrictedPattern(importSource, group)) {\n          reportPathForPatterns(node, group, importNames);\n        }\n      });\n    }\n\n    return {\n      ImportDeclaration: checkNode,\n\n      ExportNamedDeclaration(node) {\n        if (node.source) {\n          checkNode(node);\n        }\n      },\n\n      ExportAllDeclaration: checkNode\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","ignore","arrayOfStringsOrObjects","type","items","anyOf","properties","name","message","minLength","importNames","additionalProperties","required","uniqueItems","arrayOfStringsOrObjectPatterns","minItems","group","caseSensitive","module","exports","meta","docs","description","recommended","url","messages","path","pathWithCustomMessage","patterns","patternWithCustomMessage","patternAndImportName","patternAndImportNameWithCustomMessage","patternAndEverything","patternAndEverythingWithCustomMessage","everything","everythingWithCustomMessage","importName","importNameWithCustomMessage","schema","paths","additionalItems","create","context","sourceCode","getSourceCode","options","Array","isArray","isPathAndPatternsObject","Object","prototype","hasOwnProperty","call","restrictedPaths","restrictedPathMessages","reduce","memo","importSource","restrictedPatterns","length","restrictedPatternGroups","map","matcher","allowRelativePaths","ignorecase","add","customMessage","keys","checkRestrictedPathAndReport","node","restrictedImportNames","has","specifierData","get","report","messageId","loc","data","forEach","specifiers","specifier","reportPathForPatterns","source","value","trim","isRestrictedPattern","ignores","checkNode","Map","starToken","getFirstToken","set","imported","getModuleExportName","local","push","ImportDeclaration","ExportNamedDeclaration","ExportAllDeclaration"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/no-restricted-imports.js"],"sourcesContent":["/**\n * @fileoverview Restrict usage of specified node imports.\n * @author Guy Ellis\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStringsOrObjects = {\n    type: \"array\",\n    items: {\n        anyOf: [\n            { type: \"string\" },\n            {\n                type: \"object\",\n                properties: {\n                    name: { type: \"string\" },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    },\n                    importNames: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    }\n                },\n                additionalProperties: false,\n                required: [\"name\"]\n            }\n        ]\n    },\n    uniqueItems: true\n};\n\nconst arrayOfStringsOrObjectPatterns = {\n    anyOf: [\n        {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        },\n        {\n            type: \"array\",\n            items: {\n                type: \"object\",\n                properties: {\n                    importNames: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    },\n                    group: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        },\n                        minItems: 1,\n                        uniqueItems: true\n                    },\n                    message: {\n                        type: \"string\",\n                        minLength: 1\n                    },\n                    caseSensitive: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false,\n                required: [\"group\"]\n            },\n            uniqueItems: true\n        }\n    ]\n};\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow specified modules when loaded by `import`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-restricted-imports\"\n        },\n\n        messages: {\n            path: \"'{{importSource}}' import is restricted from being used.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n\n            patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            patternWithCustomMessage: \"'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}\",\n\n            patternAndImportName: \"'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            patternAndImportNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}\",\n\n            patternAndEverything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            patternAndEverythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted from being used by a pattern. {{customMessage}}\",\n\n            everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\",\n\n            importName: \"'{{importName}}' import from '{{importSource}}' is restricted.\",\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n            importNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}\"\n        },\n\n        schema: {\n            anyOf: [\n                arrayOfStringsOrObjects,\n                {\n                    type: \"array\",\n                    items: [{\n                        type: \"object\",\n                        properties: {\n                            paths: arrayOfStringsOrObjects,\n                            patterns: arrayOfStringsOrObjectPatterns\n                        },\n                        additionalProperties: false\n                    }],\n                    additionalItems: false\n                }\n            ]\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n        const options = Array.isArray(context.options) ? context.options : [];\n        const isPathAndPatternsObject =\n            typeof options[0] === \"object\" &&\n            (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n        const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n            if (typeof importSource === \"string\") {\n                memo[importSource] = { message: null };\n            } else {\n                memo[importSource.name] = {\n                    message: importSource.message,\n                    importNames: importSource.importNames\n                };\n            }\n            return memo;\n        }, {});\n\n        // Handle patterns too, either as strings or groups\n        let restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n\n        // standardize to array of objects if we have an array of strings\n        if (restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === \"string\") {\n            restrictedPatterns = [{ group: restrictedPatterns }];\n        }\n\n        // relative paths are supported for this rule\n        const restrictedPatternGroups = restrictedPatterns.map(({ group, message, caseSensitive, importNames }) => ({\n            matcher: ignore({ allowRelativePaths: true, ignorecase: !caseSensitive }).add(group),\n            customMessage: message,\n            importNames\n        }));\n\n        // if no imports are restricted we don't need to check\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {\n            return {};\n        }\n\n        /**\n         * Report a restricted path.\n         * @param {string} importSource path of the import\n         * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n         * @param {node} node representing the restricted path reference\n         * @returns {void}\n         * @private\n         */\n        function checkRestrictedPathAndReport(importSource, importNames, node) {\n            if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n                return;\n            }\n\n            const customMessage = restrictedPathMessages[importSource].message;\n            const restrictedImportNames = restrictedPathMessages[importSource].importNames;\n\n            if (restrictedImportNames) {\n                if (importNames.has(\"*\")) {\n                    const specifierData = importNames.get(\"*\")[0];\n\n                    context.report({\n                        node,\n                        messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n                        loc: specifierData.loc,\n                        data: {\n                            importSource,\n                            importNames: restrictedImportNames,\n                            customMessage\n                        }\n                    });\n                }\n\n                restrictedImportNames.forEach(importName => {\n                    if (importNames.has(importName)) {\n                        const specifiers = importNames.get(importName);\n\n                        specifiers.forEach(specifier => {\n                            context.report({\n                                node,\n                                messageId: customMessage ? \"importNameWithCustomMessage\" : \"importName\",\n                                loc: specifier.loc,\n                                data: {\n                                    importSource,\n                                    customMessage,\n                                    importName\n                                }\n                            });\n                        });\n                    }\n                });\n            } else {\n                context.report({\n                    node,\n                    messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n                    data: {\n                        importSource,\n                        customMessage\n                    }\n                });\n            }\n        }\n\n        /**\n         * Report a restricted path specifically for patterns.\n         * @param {node} node representing the restricted path reference\n         * @param {Object} group contains an Ignore instance for paths, the customMessage to show on failure,\n         * and any restricted import names that have been specified in the config\n         * @param {Map<string,Object[]>} importNames Map of import names that are being imported\n         * @returns {void}\n         * @private\n         */\n        function reportPathForPatterns(node, group, importNames) {\n            const importSource = node.source.value.trim();\n\n            const customMessage = group.customMessage;\n            const restrictedImportNames = group.importNames;\n\n            /*\n             * If we are not restricting to any specific import names and just the pattern itself,\n             * report the error and move on\n             */\n            if (!restrictedImportNames) {\n                context.report({\n                    node,\n                    messageId: customMessage ? \"patternWithCustomMessage\" : \"patterns\",\n                    data: {\n                        importSource,\n                        customMessage\n                    }\n                });\n                return;\n            }\n\n            if (importNames.has(\"*\")) {\n                const specifierData = importNames.get(\"*\")[0];\n\n                context.report({\n                    node,\n                    messageId: customMessage ? \"patternAndEverythingWithCustomMessage\" : \"patternAndEverything\",\n                    loc: specifierData.loc,\n                    data: {\n                        importSource,\n                        importNames: restrictedImportNames,\n                        customMessage\n                    }\n                });\n            }\n\n            restrictedImportNames.forEach(importName => {\n                if (!importNames.has(importName)) {\n                    return;\n                }\n\n                const specifiers = importNames.get(importName);\n\n                specifiers.forEach(specifier => {\n                    context.report({\n                        node,\n                        messageId: customMessage ? \"patternAndImportNameWithCustomMessage\" : \"patternAndImportName\",\n                        loc: specifier.loc,\n                        data: {\n                            importSource,\n                            customMessage,\n                            importName\n                        }\n                    });\n                });\n            });\n        }\n\n        /**\n         * Check if the given importSource is restricted by a pattern.\n         * @param {string} importSource path of the import\n         * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\n         * @returns {boolean} whether the variable is a restricted pattern or not\n         * @private\n         */\n        function isRestrictedPattern(importSource, group) {\n            return group.matcher.ignores(importSource);\n        }\n\n        /**\n         * Checks a node to see if any problems should be reported.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkNode(node) {\n            const importSource = node.source.value.trim();\n            const importNames = new Map();\n\n            if (node.type === \"ExportAllDeclaration\") {\n                const starToken = sourceCode.getFirstToken(node, 1);\n\n                importNames.set(\"*\", [{ loc: starToken.loc }]);\n            } else if (node.specifiers) {\n                for (const specifier of node.specifiers) {\n                    let name;\n                    const specifierData = { loc: specifier.loc };\n\n                    if (specifier.type === \"ImportDefaultSpecifier\") {\n                        name = \"default\";\n                    } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                        name = \"*\";\n                    } else if (specifier.imported) {\n                        name = astUtils.getModuleExportName(specifier.imported);\n                    } else if (specifier.local) {\n                        name = astUtils.getModuleExportName(specifier.local);\n                    }\n\n                    if (typeof name === \"string\") {\n                        if (importNames.has(name)) {\n                            importNames.get(name).push(specifierData);\n                        } else {\n                            importNames.set(name, [specifierData]);\n                        }\n                    }\n                }\n            }\n\n            checkRestrictedPathAndReport(importSource, importNames, node);\n            restrictedPatternGroups.forEach(group => {\n                if (isRestrictedPattern(importSource, group)) {\n                    reportPathForPatterns(node, group, importNames);\n                }\n            });\n        }\n\n        return {\n            ImportDeclaration: checkNode,\n            ExportNamedDeclaration(node) {\n                if (node.source) {\n                    checkNode(node);\n                }\n            },\n            ExportAllDeclaration: checkNode\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}