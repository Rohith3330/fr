{"ast":null,"code":"// Copyright 2012 The Obvious Corporation.\n\n/*\n * bits: Bitwise buffer utilities. The utilities here treat a buffer\n * as a little-endian bigint, so the lowest-order bit is bit #0 of\n * `buffer[0]`, and the highest-order bit is bit #7 of\n * `buffer[buffer.length - 1]`.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n/*\n * Exported bindings\n */\n\n/**\n * Extracts the given number of bits from the buffer at the indicated\n * index, returning a simple number as the result. If bits are requested\n * that aren't covered by the buffer, the `defaultBit` is used as their\n * value.\n *\n * The `bitLength` must be no more than 32. The `defaultBit` if not\n * specified is taken to be `0`.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extract = extract;\nexports.inject = inject;\nexports.getSign = getSign;\nexports.highOrder = highOrder;\n\nfunction extract(buffer, bitIndex, bitLength, defaultBit) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  if (defaultBit === undefined) {\n    defaultBit = 0;\n  } else if (defaultBit !== 0 && defaultBit !== 1) {\n    throw new Error(\"Bad value for defaultBit.\");\n  }\n\n  var defaultByte = defaultBit * 0xff;\n  var result = 0; // All starts are inclusive. The {endByte, endBit} pair is exclusive, but\n  // if endBit !== 0, then endByte is inclusive.\n\n  var lastBit = bitIndex + bitLength;\n  var startByte = Math.floor(bitIndex / 8);\n  var startBit = bitIndex % 8;\n  var endByte = Math.floor(lastBit / 8);\n  var endBit = lastBit % 8;\n\n  if (endBit !== 0) {\n    // `(1 << endBit) - 1` is the mask of all bits up to but not including\n    // the endBit.\n    result = get(endByte) & (1 << endBit) - 1;\n  }\n\n  while (endByte > startByte) {\n    endByte--;\n    result = result << 8 | get(endByte);\n  }\n\n  result >>>= startBit;\n  return result;\n\n  function get(index) {\n    var result = buffer[index];\n    return result === undefined ? defaultByte : result;\n  }\n}\n/**\n * Injects the given bits into the given buffer at the given index. Any\n * bits in the value beyond the length to set are ignored.\n */\n\n\nfunction inject(buffer, bitIndex, bitLength, value) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  var lastByte = Math.floor((bitIndex + bitLength - 1) / 8);\n\n  if (bitIndex < 0 || lastByte >= buffer.length) {\n    throw new Error(\"Index out of range.\");\n  } // Just keeping it simple, until / unless profiling shows that this\n  // is a problem.\n\n\n  var atByte = Math.floor(bitIndex / 8);\n  var atBit = bitIndex % 8;\n\n  while (bitLength > 0) {\n    if (value & 1) {\n      buffer[atByte] |= 1 << atBit;\n    } else {\n      buffer[atByte] &= ~(1 << atBit);\n    }\n\n    value >>= 1;\n    bitLength--;\n    atBit = (atBit + 1) % 8;\n\n    if (atBit === 0) {\n      atByte++;\n    }\n  }\n}\n/**\n * Gets the sign bit of the given buffer.\n */\n\n\nfunction getSign(buffer) {\n  return buffer[buffer.length - 1] >>> 7;\n}\n/**\n * Gets the zero-based bit number of the highest-order bit with the\n * given value in the given buffer.\n *\n * If the buffer consists entirely of the other bit value, then this returns\n * `-1`.\n */\n\n\nfunction highOrder(bit, buffer) {\n  var length = buffer.length;\n  var fullyWrongByte = (bit ^ 1) * 0xff; // the other-bit extended to a full byte\n\n  while (length > 0 && buffer[length - 1] === fullyWrongByte) {\n    length--;\n  }\n\n  if (length === 0) {\n    // Degenerate case. The buffer consists entirely of ~bit.\n    return -1;\n  }\n\n  var byteToCheck = buffer[length - 1];\n  var result = length * 8 - 1;\n\n  for (var i = 7; i > 0; i--) {\n    if ((byteToCheck >> i & 1) === bit) {\n      break;\n    }\n\n    result--;\n  }\n\n  return result;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","extract","inject","getSign","highOrder","buffer","bitIndex","bitLength","defaultBit","Error","undefined","defaultByte","result","lastBit","startByte","Math","floor","startBit","endByte","endBit","get","index","lastByte","length","atByte","atBit","bit","fullyWrongByte","byteToCheck","i"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@webassemblyjs/leb128/lib/bits.js"],"sourcesContent":["// Copyright 2012 The Obvious Corporation.\n\n/*\n * bits: Bitwise buffer utilities. The utilities here treat a buffer\n * as a little-endian bigint, so the lowest-order bit is bit #0 of\n * `buffer[0]`, and the highest-order bit is bit #7 of\n * `buffer[buffer.length - 1]`.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n/*\n * Exported bindings\n */\n\n/**\n * Extracts the given number of bits from the buffer at the indicated\n * index, returning a simple number as the result. If bits are requested\n * that aren't covered by the buffer, the `defaultBit` is used as their\n * value.\n *\n * The `bitLength` must be no more than 32. The `defaultBit` if not\n * specified is taken to be `0`.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extract = extract;\nexports.inject = inject;\nexports.getSign = getSign;\nexports.highOrder = highOrder;\n\nfunction extract(buffer, bitIndex, bitLength, defaultBit) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  if (defaultBit === undefined) {\n    defaultBit = 0;\n  } else if (defaultBit !== 0 && defaultBit !== 1) {\n    throw new Error(\"Bad value for defaultBit.\");\n  }\n\n  var defaultByte = defaultBit * 0xff;\n  var result = 0; // All starts are inclusive. The {endByte, endBit} pair is exclusive, but\n  // if endBit !== 0, then endByte is inclusive.\n\n  var lastBit = bitIndex + bitLength;\n  var startByte = Math.floor(bitIndex / 8);\n  var startBit = bitIndex % 8;\n  var endByte = Math.floor(lastBit / 8);\n  var endBit = lastBit % 8;\n\n  if (endBit !== 0) {\n    // `(1 << endBit) - 1` is the mask of all bits up to but not including\n    // the endBit.\n    result = get(endByte) & (1 << endBit) - 1;\n  }\n\n  while (endByte > startByte) {\n    endByte--;\n    result = result << 8 | get(endByte);\n  }\n\n  result >>>= startBit;\n  return result;\n\n  function get(index) {\n    var result = buffer[index];\n    return result === undefined ? defaultByte : result;\n  }\n}\n/**\n * Injects the given bits into the given buffer at the given index. Any\n * bits in the value beyond the length to set are ignored.\n */\n\n\nfunction inject(buffer, bitIndex, bitLength, value) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  var lastByte = Math.floor((bitIndex + bitLength - 1) / 8);\n\n  if (bitIndex < 0 || lastByte >= buffer.length) {\n    throw new Error(\"Index out of range.\");\n  } // Just keeping it simple, until / unless profiling shows that this\n  // is a problem.\n\n\n  var atByte = Math.floor(bitIndex / 8);\n  var atBit = bitIndex % 8;\n\n  while (bitLength > 0) {\n    if (value & 1) {\n      buffer[atByte] |= 1 << atBit;\n    } else {\n      buffer[atByte] &= ~(1 << atBit);\n    }\n\n    value >>= 1;\n    bitLength--;\n    atBit = (atBit + 1) % 8;\n\n    if (atBit === 0) {\n      atByte++;\n    }\n  }\n}\n/**\n * Gets the sign bit of the given buffer.\n */\n\n\nfunction getSign(buffer) {\n  return buffer[buffer.length - 1] >>> 7;\n}\n/**\n * Gets the zero-based bit number of the highest-order bit with the\n * given value in the given buffer.\n *\n * If the buffer consists entirely of the other bit value, then this returns\n * `-1`.\n */\n\n\nfunction highOrder(bit, buffer) {\n  var length = buffer.length;\n  var fullyWrongByte = (bit ^ 1) * 0xff; // the other-bit extended to a full byte\n\n  while (length > 0 && buffer[length - 1] === fullyWrongByte) {\n    length--;\n  }\n\n  if (length === 0) {\n    // Degenerate case. The buffer consists entirely of ~bit.\n    return -1;\n  }\n\n  var byteToCheck = buffer[length - 1];\n  var result = length * 8 - 1;\n\n  for (var i = 7; i > 0; i--) {\n    if ((byteToCheck >> i & 1) === bit) {\n      break;\n    }\n\n    result--;\n  }\n\n  return result;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}