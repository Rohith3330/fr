{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst index_1 = __importDefault(require(\"./Base/index\"));\n\nconst Vector_1 = __importDefault(require(\"../SequentialContainer/Vector\"));\n\nconst OrderedSet_1 = __importDefault(require(\"../TreeContainer/OrderedSet\"));\n\nclass HashSet extends index_1.default {\n  constructor() {\n    let container = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let initBucketNum = arguments.length > 1 ? arguments[1] : undefined;\n    let hashFunc = arguments.length > 2 ? arguments[2] : undefined;\n    super(initBucketNum, hashFunc);\n    this.hashTable = [];\n    container.forEach(element => this.insert(element));\n  }\n\n  reAllocate() {\n    if (this.bucketNum >= index_1.default.maxBucketNum) return;\n    const newHashTable = [];\n    const originalBucketNum = this.bucketNum;\n    this.bucketNum <<= 1;\n    const keys = Object.keys(this.hashTable);\n    const keyNums = keys.length;\n\n    for (let i = 0; i < keyNums; ++i) {\n      const index = parseInt(keys[i]);\n      const container = this.hashTable[index];\n      const size = container.size();\n      if (size === 0) continue;\n\n      if (size === 1) {\n        const element = container.front();\n        newHashTable[this.hashFunc(element) & this.bucketNum - 1] = new Vector_1.default([element], false);\n        continue;\n      }\n\n      const lowList = [];\n      const highList = [];\n      container.forEach(element => {\n        const hashCode = this.hashFunc(element);\n\n        if ((hashCode & originalBucketNum) === 0) {\n          lowList.push(element);\n        } else highList.push(element);\n      });\n\n      if (container instanceof OrderedSet_1.default) {\n        if (lowList.length > index_1.default.untreeifyThreshold) {\n          newHashTable[index] = new OrderedSet_1.default(lowList);\n        } else if (lowList.length) {\n          newHashTable[index] = new Vector_1.default(lowList, false);\n        }\n\n        if (highList.length > index_1.default.untreeifyThreshold) {\n          newHashTable[index + originalBucketNum] = new OrderedSet_1.default(highList);\n        } else if (highList.length) {\n          newHashTable[index + originalBucketNum] = new Vector_1.default(highList, false);\n        }\n      } else {\n        if (lowList.length >= index_1.default.treeifyThreshold) {\n          newHashTable[index] = new OrderedSet_1.default(lowList);\n        } else if (lowList.length) {\n          newHashTable[index] = new Vector_1.default(lowList, false);\n        }\n\n        if (highList.length >= index_1.default.treeifyThreshold) {\n          newHashTable[index + originalBucketNum] = new OrderedSet_1.default(highList);\n        } else if (highList.length) {\n          newHashTable[index + originalBucketNum] = new Vector_1.default(highList, false);\n        }\n      }\n    }\n\n    this.hashTable = newHashTable;\n  }\n\n  forEach(callback) {\n    const containers = Object.values(this.hashTable);\n    const containersNum = containers.length;\n    let index = 0;\n\n    for (let i = 0; i < containersNum; ++i) {\n      containers[i].forEach(element => callback(element, index++));\n    }\n  }\n  /**\n   * @description Insert element to hash set.\n   * @param element The element you want to insert.\n   */\n\n\n  insert(element) {\n    const index = this.hashFunc(element) & this.bucketNum - 1;\n    const container = this.hashTable[index];\n\n    if (!container) {\n      this.hashTable[index] = new Vector_1.default([element], false);\n      this.length += 1;\n    } else {\n      const preSize = container.size();\n\n      if (container instanceof Vector_1.default) {\n        if (!container.find(element).equals(container.end())) return;\n        container.pushBack(element);\n\n        if (preSize + 1 >= index_1.default.treeifyThreshold) {\n          if (this.bucketNum <= index_1.default.minTreeifySize) {\n            this.length += 1;\n            this.reAllocate();\n            return;\n          }\n\n          this.hashTable[index] = new OrderedSet_1.default(container);\n        }\n\n        this.length += 1;\n      } else {\n        container.insert(element);\n        const curSize = container.size();\n        this.length += curSize - preSize;\n      }\n    }\n\n    if (this.length > this.bucketNum * index_1.default.sigma) {\n      this.reAllocate();\n    }\n  }\n\n  eraseElementByKey(key) {\n    const index = this.hashFunc(key) & this.bucketNum - 1;\n    const container = this.hashTable[index];\n    if (!container) return;\n    const preSize = container.size();\n    if (preSize === 0) return;\n\n    if (container instanceof Vector_1.default) {\n      container.eraseElementByValue(key);\n      const curSize = container.size();\n      this.length += curSize - preSize;\n    } else {\n      container.eraseElementByKey(key);\n      const curSize = container.size();\n      this.length += curSize - preSize;\n\n      if (curSize <= index_1.default.untreeifyThreshold) {\n        this.hashTable[index] = new Vector_1.default(container);\n      }\n    }\n  }\n\n  find(element) {\n    const index = this.hashFunc(element) & this.bucketNum - 1;\n    const container = this.hashTable[index];\n    if (!container) return false;\n    return !container.find(element).equals(container.end());\n  }\n\n  [Symbol.iterator]() {\n    return function* () {\n      const containers = Object.values(this.hashTable);\n      const containersNum = containers.length;\n\n      for (let i = 0; i < containersNum; ++i) {\n        const container = containers[i];\n\n        for (const element of container) {\n          yield element;\n        }\n      }\n    }.bind(this)();\n  }\n\n}\n\nexports.default = HashSet;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","index_1","require","Vector_1","OrderedSet_1","HashSet","default","constructor","container","initBucketNum","hashFunc","hashTable","forEach","element","insert","reAllocate","bucketNum","maxBucketNum","newHashTable","originalBucketNum","keys","keyNums","length","i","index","parseInt","size","front","lowList","highList","hashCode","push","untreeifyThreshold","treeifyThreshold","callback","containers","values","containersNum","preSize","find","equals","end","pushBack","minTreeifySize","curSize","sigma","eraseElementByKey","key","eraseElementByValue","Symbol","iterator","bind"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/js-sdsl/dist/cjs/container/HashContainer/HashSet.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst index_1 = __importDefault(require(\"./Base/index\"));\nconst Vector_1 = __importDefault(require(\"../SequentialContainer/Vector\"));\nconst OrderedSet_1 = __importDefault(require(\"../TreeContainer/OrderedSet\"));\nclass HashSet extends index_1.default {\n    constructor(container = [], initBucketNum, hashFunc) {\n        super(initBucketNum, hashFunc);\n        this.hashTable = [];\n        container.forEach(element => this.insert(element));\n    }\n    reAllocate() {\n        if (this.bucketNum >= index_1.default.maxBucketNum)\n            return;\n        const newHashTable = [];\n        const originalBucketNum = this.bucketNum;\n        this.bucketNum <<= 1;\n        const keys = Object.keys(this.hashTable);\n        const keyNums = keys.length;\n        for (let i = 0; i < keyNums; ++i) {\n            const index = parseInt(keys[i]);\n            const container = this.hashTable[index];\n            const size = container.size();\n            if (size === 0)\n                continue;\n            if (size === 1) {\n                const element = container.front();\n                newHashTable[this.hashFunc(element) & (this.bucketNum - 1)] = new Vector_1.default([element], false);\n                continue;\n            }\n            const lowList = [];\n            const highList = [];\n            container.forEach(element => {\n                const hashCode = this.hashFunc(element);\n                if ((hashCode & originalBucketNum) === 0) {\n                    lowList.push(element);\n                }\n                else\n                    highList.push(element);\n            });\n            if (container instanceof OrderedSet_1.default) {\n                if (lowList.length > index_1.default.untreeifyThreshold) {\n                    newHashTable[index] = new OrderedSet_1.default(lowList);\n                }\n                else if (lowList.length) {\n                    newHashTable[index] = new Vector_1.default(lowList, false);\n                }\n                if (highList.length > index_1.default.untreeifyThreshold) {\n                    newHashTable[index + originalBucketNum] = new OrderedSet_1.default(highList);\n                }\n                else if (highList.length) {\n                    newHashTable[index + originalBucketNum] = new Vector_1.default(highList, false);\n                }\n            }\n            else {\n                if (lowList.length >= index_1.default.treeifyThreshold) {\n                    newHashTable[index] = new OrderedSet_1.default(lowList);\n                }\n                else if (lowList.length) {\n                    newHashTable[index] = new Vector_1.default(lowList, false);\n                }\n                if (highList.length >= index_1.default.treeifyThreshold) {\n                    newHashTable[index + originalBucketNum] = new OrderedSet_1.default(highList);\n                }\n                else if (highList.length) {\n                    newHashTable[index + originalBucketNum] = new Vector_1.default(highList, false);\n                }\n            }\n        }\n        this.hashTable = newHashTable;\n    }\n    forEach(callback) {\n        const containers = Object.values(this.hashTable);\n        const containersNum = containers.length;\n        let index = 0;\n        for (let i = 0; i < containersNum; ++i) {\n            containers[i].forEach(element => callback(element, index++));\n        }\n    }\n    /**\n     * @description Insert element to hash set.\n     * @param element The element you want to insert.\n     */\n    insert(element) {\n        const index = this.hashFunc(element) & (this.bucketNum - 1);\n        const container = this.hashTable[index];\n        if (!container) {\n            this.hashTable[index] = new Vector_1.default([element], false);\n            this.length += 1;\n        }\n        else {\n            const preSize = container.size();\n            if (container instanceof Vector_1.default) {\n                if (!container.find(element)\n                    .equals(container.end()))\n                    return;\n                container.pushBack(element);\n                if (preSize + 1 >= index_1.default.treeifyThreshold) {\n                    if (this.bucketNum <= index_1.default.minTreeifySize) {\n                        this.length += 1;\n                        this.reAllocate();\n                        return;\n                    }\n                    this.hashTable[index] = new OrderedSet_1.default(container);\n                }\n                this.length += 1;\n            }\n            else {\n                container.insert(element);\n                const curSize = container.size();\n                this.length += curSize - preSize;\n            }\n        }\n        if (this.length > this.bucketNum * index_1.default.sigma) {\n            this.reAllocate();\n        }\n    }\n    eraseElementByKey(key) {\n        const index = this.hashFunc(key) & (this.bucketNum - 1);\n        const container = this.hashTable[index];\n        if (!container)\n            return;\n        const preSize = container.size();\n        if (preSize === 0)\n            return;\n        if (container instanceof Vector_1.default) {\n            container.eraseElementByValue(key);\n            const curSize = container.size();\n            this.length += curSize - preSize;\n        }\n        else {\n            container.eraseElementByKey(key);\n            const curSize = container.size();\n            this.length += curSize - preSize;\n            if (curSize <= index_1.default.untreeifyThreshold) {\n                this.hashTable[index] = new Vector_1.default(container);\n            }\n        }\n    }\n    find(element) {\n        const index = this.hashFunc(element) & (this.bucketNum - 1);\n        const container = this.hashTable[index];\n        if (!container)\n            return false;\n        return !container.find(element)\n            .equals(container.end());\n    }\n    [Symbol.iterator]() {\n        return function* () {\n            const containers = Object.values(this.hashTable);\n            const containersNum = containers.length;\n            for (let i = 0; i < containersNum; ++i) {\n                const container = containers[i];\n                for (const element of container) {\n                    yield element;\n                }\n            }\n        }.bind(this)();\n    }\n}\nexports.default = HashSet;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}