{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('./types').XastNode} XastNode\n * @typedef {import('./types').XastInstruction} XastInstruction\n * @typedef {import('./types').XastDoctype} XastDoctype\n * @typedef {import('./types').XastComment} XastComment\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastCdata} XastCdata\n * @typedef {import('./types').XastText} XastText\n * @typedef {import('./types').XastParent} XastParent\n */\n// @ts-ignore sax will be replaced with something else later\n\nconst SAX = require('@trysound/sax');\n\nconst JSAPI = require('./svgo/jsAPI.js');\n\nconst {\n  textElems\n} = require('../plugins/_collections.js');\n\nclass SvgoParserError extends Error {\n  /**\n   * @param message {string}\n   * @param line {number}\n   * @param column {number}\n   * @param source {string}\n   * @param file {void | string}\n   */\n  constructor(message, line, column, source, file) {\n    super(message);\n    this.name = 'SvgoParserError';\n    this.message = `${file || '<input>'}:${line}:${column}: ${message}`;\n    this.reason = message;\n    this.line = line;\n    this.column = column;\n    this.source = source;\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, SvgoParserError);\n    }\n  }\n\n  toString() {\n    const lines = this.source.split(/\\r?\\n/);\n    const startLine = Math.max(this.line - 3, 0);\n    const endLine = Math.min(this.line + 2, lines.length);\n    const lineNumberWidth = String(endLine).length;\n    const startColumn = Math.max(this.column - 54, 0);\n    const endColumn = Math.max(this.column + 20, 80);\n    const code = lines.slice(startLine, endLine).map((line, index) => {\n      const lineSlice = line.slice(startColumn, endColumn);\n      let ellipsisPrefix = '';\n      let ellipsisSuffix = '';\n\n      if (startColumn !== 0) {\n        ellipsisPrefix = startColumn > line.length - 1 ? ' ' : '…';\n      }\n\n      if (endColumn < line.length - 1) {\n        ellipsisSuffix = '…';\n      }\n\n      const number = startLine + 1 + index;\n      const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;\n\n      if (number === this.line) {\n        const gutterSpacing = gutter.replace(/[^|]/g, ' ');\n        const lineSpacing = (ellipsisPrefix + line.slice(startColumn, this.column - 1)).replace(/[^\\t]/g, ' ');\n        const spacing = gutterSpacing + lineSpacing;\n        return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\\n ${spacing}^`;\n      }\n\n      return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;\n    }).join('\\n');\n    return `${this.name}: ${this.message}\\n\\n${code}\\n`;\n  }\n\n}\n\nconst entityDeclaration = /<!ENTITY\\s+(\\S+)\\s+(?:'([^']+)'|\"([^\"]+)\")\\s*>/g;\nconst config = {\n  strict: true,\n  trim: false,\n  normalize: false,\n  lowercase: true,\n  xmlns: true,\n  position: true\n};\n/**\n * Convert SVG (XML) string to SVG-as-JS object.\n *\n * @type {(data: string, from?: string) => XastRoot}\n */\n\nconst parseSvg = (data, from) => {\n  const sax = SAX.parser(config.strict, config);\n  /**\n   * @type {XastRoot}\n   */\n\n  const root = new JSAPI({\n    type: 'root',\n    children: []\n  });\n  /**\n   * @type {XastParent}\n   */\n\n  let current = root;\n  /**\n   * @type {Array<XastParent>}\n   */\n\n  const stack = [root];\n  /**\n   * @type {<T extends XastNode>(node: T) => T}\n   */\n\n  const pushToContent = node => {\n    const wrapped = new JSAPI(node, current);\n    current.children.push(wrapped);\n    return wrapped;\n  };\n  /**\n   * @type {(doctype: string) => void}\n   */\n\n\n  sax.ondoctype = doctype => {\n    /**\n     * @type {XastDoctype}\n     */\n    const node = {\n      type: 'doctype',\n      // TODO parse doctype for name, public and system to match xast\n      name: 'svg',\n      data: {\n        doctype\n      }\n    };\n    pushToContent(node);\n    const subsetStart = doctype.indexOf('[');\n\n    if (subsetStart >= 0) {\n      entityDeclaration.lastIndex = subsetStart;\n      let entityMatch = entityDeclaration.exec(data);\n\n      while (entityMatch != null) {\n        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];\n        entityMatch = entityDeclaration.exec(data);\n      }\n    }\n  };\n  /**\n   * @type {(data: { name: string, body: string }) => void}\n   */\n\n\n  sax.onprocessinginstruction = data => {\n    /**\n     * @type {XastInstruction}\n     */\n    const node = {\n      type: 'instruction',\n      name: data.name,\n      value: data.body\n    };\n    pushToContent(node);\n  };\n  /**\n   * @type {(comment: string) => void}\n   */\n\n\n  sax.oncomment = comment => {\n    /**\n     * @type {XastComment}\n     */\n    const node = {\n      type: 'comment',\n      value: comment.trim()\n    };\n    pushToContent(node);\n  };\n  /**\n   * @type {(cdata: string) => void}\n   */\n\n\n  sax.oncdata = cdata => {\n    /**\n     * @type {XastCdata}\n     */\n    const node = {\n      type: 'cdata',\n      value: cdata\n    };\n    pushToContent(node);\n  };\n  /**\n   * @type {(data: { name: string, attributes: Record<string, { value: string }>}) => void}\n   */\n\n\n  sax.onopentag = data => {\n    /**\n     * @type {XastElement}\n     */\n    let element = {\n      type: 'element',\n      name: data.name,\n      attributes: {},\n      children: []\n    };\n\n    for (const [name, attr] of Object.entries(data.attributes)) {\n      element.attributes[name] = attr.value;\n    }\n\n    element = pushToContent(element);\n    current = element;\n    stack.push(element);\n  };\n  /**\n   * @type {(text: string) => void}\n   */\n\n\n  sax.ontext = text => {\n    if (current.type === 'element') {\n      // prevent trimming of meaningful whitespace inside textual tags\n      if (textElems.includes(current.name)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text\n        };\n        pushToContent(node);\n      } else if (/\\S/.test(text)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text.trim()\n        };\n        pushToContent(node);\n      }\n    }\n  };\n\n  sax.onclosetag = () => {\n    stack.pop();\n    current = stack[stack.length - 1];\n  };\n  /**\n   * @type {(e: any) => void}\n   */\n\n\n  sax.onerror = e => {\n    const error = new SvgoParserError(e.reason, e.line + 1, e.column, data, from);\n\n    if (e.message.indexOf('Unexpected end') === -1) {\n      throw error;\n    }\n  };\n\n  sax.write(data).close();\n  return root;\n};\n\nexports.parseSvg = parseSvg;","map":{"version":3,"names":["SAX","require","JSAPI","textElems","SvgoParserError","Error","constructor","message","line","column","source","file","name","reason","captureStackTrace","toString","lines","split","startLine","Math","max","endLine","min","length","lineNumberWidth","String","startColumn","endColumn","code","slice","map","index","lineSlice","ellipsisPrefix","ellipsisSuffix","number","gutter","padStart","gutterSpacing","replace","lineSpacing","spacing","join","entityDeclaration","config","strict","trim","normalize","lowercase","xmlns","position","parseSvg","data","from","sax","parser","root","type","children","current","stack","pushToContent","node","wrapped","push","ondoctype","doctype","subsetStart","indexOf","lastIndex","entityMatch","exec","ENTITIES","onprocessinginstruction","value","body","oncomment","comment","oncdata","cdata","onopentag","element","attributes","attr","Object","entries","ontext","text","includes","test","onclosetag","pop","onerror","e","error","write","close","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/svgo/lib/parser.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('./types').XastNode} XastNode\n * @typedef {import('./types').XastInstruction} XastInstruction\n * @typedef {import('./types').XastDoctype} XastDoctype\n * @typedef {import('./types').XastComment} XastComment\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastCdata} XastCdata\n * @typedef {import('./types').XastText} XastText\n * @typedef {import('./types').XastParent} XastParent\n */\n\n// @ts-ignore sax will be replaced with something else later\nconst SAX = require('@trysound/sax');\nconst JSAPI = require('./svgo/jsAPI.js');\nconst { textElems } = require('../plugins/_collections.js');\n\nclass SvgoParserError extends Error {\n  /**\n   * @param message {string}\n   * @param line {number}\n   * @param column {number}\n   * @param source {string}\n   * @param file {void | string}\n   */\n  constructor(message, line, column, source, file) {\n    super(message);\n    this.name = 'SvgoParserError';\n    this.message = `${file || '<input>'}:${line}:${column}: ${message}`;\n    this.reason = message;\n    this.line = line;\n    this.column = column;\n    this.source = source;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, SvgoParserError);\n    }\n  }\n  toString() {\n    const lines = this.source.split(/\\r?\\n/);\n    const startLine = Math.max(this.line - 3, 0);\n    const endLine = Math.min(this.line + 2, lines.length);\n    const lineNumberWidth = String(endLine).length;\n    const startColumn = Math.max(this.column - 54, 0);\n    const endColumn = Math.max(this.column + 20, 80);\n    const code = lines\n      .slice(startLine, endLine)\n      .map((line, index) => {\n        const lineSlice = line.slice(startColumn, endColumn);\n        let ellipsisPrefix = '';\n        let ellipsisSuffix = '';\n        if (startColumn !== 0) {\n          ellipsisPrefix = startColumn > line.length - 1 ? ' ' : '…';\n        }\n        if (endColumn < line.length - 1) {\n          ellipsisSuffix = '…';\n        }\n        const number = startLine + 1 + index;\n        const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;\n        if (number === this.line) {\n          const gutterSpacing = gutter.replace(/[^|]/g, ' ');\n          const lineSpacing = (\n            ellipsisPrefix + line.slice(startColumn, this.column - 1)\n          ).replace(/[^\\t]/g, ' ');\n          const spacing = gutterSpacing + lineSpacing;\n          return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\\n ${spacing}^`;\n        }\n        return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;\n      })\n      .join('\\n');\n    return `${this.name}: ${this.message}\\n\\n${code}\\n`;\n  }\n}\n\nconst entityDeclaration = /<!ENTITY\\s+(\\S+)\\s+(?:'([^']+)'|\"([^\"]+)\")\\s*>/g;\n\nconst config = {\n  strict: true,\n  trim: false,\n  normalize: false,\n  lowercase: true,\n  xmlns: true,\n  position: true,\n};\n\n/**\n * Convert SVG (XML) string to SVG-as-JS object.\n *\n * @type {(data: string, from?: string) => XastRoot}\n */\nconst parseSvg = (data, from) => {\n  const sax = SAX.parser(config.strict, config);\n  /**\n   * @type {XastRoot}\n   */\n  const root = new JSAPI({ type: 'root', children: [] });\n  /**\n   * @type {XastParent}\n   */\n  let current = root;\n  /**\n   * @type {Array<XastParent>}\n   */\n  const stack = [root];\n\n  /**\n   * @type {<T extends XastNode>(node: T) => T}\n   */\n  const pushToContent = (node) => {\n    const wrapped = new JSAPI(node, current);\n    current.children.push(wrapped);\n    return wrapped;\n  };\n\n  /**\n   * @type {(doctype: string) => void}\n   */\n  sax.ondoctype = (doctype) => {\n    /**\n     * @type {XastDoctype}\n     */\n    const node = {\n      type: 'doctype',\n      // TODO parse doctype for name, public and system to match xast\n      name: 'svg',\n      data: {\n        doctype,\n      },\n    };\n    pushToContent(node);\n    const subsetStart = doctype.indexOf('[');\n    if (subsetStart >= 0) {\n      entityDeclaration.lastIndex = subsetStart;\n      let entityMatch = entityDeclaration.exec(data);\n      while (entityMatch != null) {\n        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];\n        entityMatch = entityDeclaration.exec(data);\n      }\n    }\n  };\n\n  /**\n   * @type {(data: { name: string, body: string }) => void}\n   */\n  sax.onprocessinginstruction = (data) => {\n    /**\n     * @type {XastInstruction}\n     */\n    const node = {\n      type: 'instruction',\n      name: data.name,\n      value: data.body,\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(comment: string) => void}\n   */\n  sax.oncomment = (comment) => {\n    /**\n     * @type {XastComment}\n     */\n    const node = {\n      type: 'comment',\n      value: comment.trim(),\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(cdata: string) => void}\n   */\n  sax.oncdata = (cdata) => {\n    /**\n     * @type {XastCdata}\n     */\n    const node = {\n      type: 'cdata',\n      value: cdata,\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(data: { name: string, attributes: Record<string, { value: string }>}) => void}\n   */\n  sax.onopentag = (data) => {\n    /**\n     * @type {XastElement}\n     */\n    let element = {\n      type: 'element',\n      name: data.name,\n      attributes: {},\n      children: [],\n    };\n    for (const [name, attr] of Object.entries(data.attributes)) {\n      element.attributes[name] = attr.value;\n    }\n    element = pushToContent(element);\n    current = element;\n    stack.push(element);\n  };\n\n  /**\n   * @type {(text: string) => void}\n   */\n  sax.ontext = (text) => {\n    if (current.type === 'element') {\n      // prevent trimming of meaningful whitespace inside textual tags\n      if (textElems.includes(current.name)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text,\n        };\n        pushToContent(node);\n      } else if (/\\S/.test(text)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text.trim(),\n        };\n        pushToContent(node);\n      }\n    }\n  };\n\n  sax.onclosetag = () => {\n    stack.pop();\n    current = stack[stack.length - 1];\n  };\n\n  /**\n   * @type {(e: any) => void}\n   */\n  sax.onerror = (e) => {\n    const error = new SvgoParserError(\n      e.reason,\n      e.line + 1,\n      e.column,\n      data,\n      from\n    );\n    if (e.message.indexOf('Unexpected end') === -1) {\n      throw error;\n    }\n  };\n\n  sax.write(data).close();\n  return root;\n};\nexports.parseSvg = parseSvg;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}