{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyOperations = applyOperations;\n\nvar _wasmGen = require(\"@webassemblyjs/wasm-gen\");\n\nvar _encoder = require(\"@webassemblyjs/wasm-gen/lib/encoder\");\n\nvar _ast = require(\"@webassemblyjs/ast\");\n\nvar _helperWasmSection = require(\"@webassemblyjs/helper-wasm-section\");\n\nvar _helperBuffer = require(\"@webassemblyjs/helper-buffer\");\n\nvar _helperWasmBytecode = require(\"@webassemblyjs/helper-wasm-bytecode\");\n\nfunction _sliceIterator(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _slicedToArray(arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    return _sliceIterator(arr, i);\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n}\n\nfunction shiftLocNodeByDelta(node, delta) {\n  (0, _ast.assertHasLoc)(node); // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.start.column += delta; // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.end.column += delta;\n}\n\nfunction applyUpdate(ast, uint8Buffer, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      oldNode = _ref2[0],\n      newNode = _ref2[1];\n\n  var deltaElements = 0;\n  (0, _ast.assertHasLoc)(oldNode);\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(newNode);\n  var replacementByteArray = (0, _wasmGen.encodeNode)(newNode);\n  /**\n   * Replace new node as bytes\n   */\n\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column, replacementByteArray);\n  /**\n   * Update function body size if needed\n   */\n\n  if (sectionName === \"code\") {\n    // Find the parent func\n    (0, _ast.traverse)(ast, {\n      Func: function Func(_ref3) {\n        var node = _ref3.node;\n        var funcHasThisIntr = node.body.find(function (n) {\n          return n === newNode;\n        }) !== undefined; // Update func's body size if needed\n\n        if (funcHasThisIntr === true) {\n          // These are the old functions locations informations\n          (0, _ast.assertHasLoc)(node);\n          var oldNodeSize = (0, _wasmGen.encodeNode)(oldNode).length;\n          var bodySizeDeltaBytes = replacementByteArray.length - oldNodeSize;\n\n          if (bodySizeDeltaBytes !== 0) {\n            var newValue = node.metadata.bodySize + bodySizeDeltaBytes;\n            var newByteArray = (0, _encoder.encodeU32)(newValue); // function body size byte\n            // FIXME(sven): only handles one byte u32\n\n            var start = node.loc.start.column;\n            var end = start + 1;\n            uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, start, end, newByteArray);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Update section size\n   */\n\n\n  var deltaBytes = replacementByteArray.length - ( // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column - oldNode.loc.start.column); // Init location informations\n\n  newNode.loc = {\n    start: {\n      line: -1,\n      column: -1\n    },\n    end: {\n      line: -1,\n      column: -1\n    }\n  }; // Update new node end position\n  // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.start.column = oldNode.loc.start.column; // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.end.column = // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column + replacementByteArray.length;\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyDelete(ast, uint8Buffer, node) {\n  var deltaElements = -1; // since we removed an element\n\n  (0, _ast.assertHasLoc)(node);\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(node);\n\n  if (sectionName === \"start\") {\n    var sectionMetadata = (0, _ast.getSectionMetadata)(ast, \"start\");\n    /**\n     * The start section only contains one element,\n     * we need to remove the whole section\n     */\n\n    uint8Buffer = (0, _helperWasmSection.removeSections)(ast, uint8Buffer, \"start\");\n\n    var _deltaBytes = -(sectionMetadata.size.value + 1);\n    /* section id */\n\n\n    return {\n      uint8Buffer: uint8Buffer,\n      deltaBytes: _deltaBytes,\n      deltaElements: deltaElements\n    };\n  } // replacement is nothing\n\n\n  var replacement = [];\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\n  node.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\n  node.loc.end.column, replacement);\n  /**\n   * Update section\n   */\n  // $FlowIgnore: assertHasLoc ensures that\n\n  var deltaBytes = -(node.loc.end.column - node.loc.start.column);\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyAdd(ast, uint8Buffer, node) {\n  var deltaElements = +1; // since we added an element\n\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(node);\n  var sectionMetadata = (0, _ast.getSectionMetadata)(ast, sectionName); // Section doesn't exists, we create an empty one\n\n  if (typeof sectionMetadata === \"undefined\") {\n    var res = (0, _helperWasmSection.createEmptySection)(ast, uint8Buffer, sectionName);\n    uint8Buffer = res.uint8Buffer;\n    sectionMetadata = res.sectionMetadata;\n  }\n  /**\n   * check that the expressions were ended\n   */\n\n\n  if ((0, _ast.isFunc)(node)) {\n    // $FlowIgnore\n    var body = node.body;\n\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n\n  if ((0, _ast.isGlobal)(node)) {\n    // $FlowIgnore\n    var body = node.init;\n\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n  /**\n   * Add nodes\n   */\n\n\n  var newByteArray = (0, _wasmGen.encodeNode)(node); // The size of the section doesn't include the storage of the size itself\n  // we need to manually add it here\n\n  var start = (0, _ast.getEndOfSection)(sectionMetadata);\n  var end = start;\n  /**\n   * Update section\n   */\n\n  var deltaBytes = newByteArray.length;\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, start, end, newByteArray);\n  node.loc = {\n    start: {\n      line: -1,\n      column: start\n    },\n    end: {\n      line: -1,\n      column: start + deltaBytes\n    }\n  }; // for func add the additional metadata in the AST\n\n  if (node.type === \"Func\") {\n    // the size is the first byte\n    // FIXME(sven): handle LEB128 correctly here\n    var bodySize = newByteArray[0];\n    node.metadata = {\n      bodySize: bodySize\n    };\n  }\n\n  if (node.type !== \"IndexInFuncSection\") {\n    (0, _ast.orderedInsertNode)(ast.body[0], node);\n  }\n\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyOperations(ast, uint8Buffer, ops) {\n  ops.forEach(function (op) {\n    var state;\n    var sectionName;\n\n    switch (op.kind) {\n      case \"update\":\n        state = applyUpdate(ast, uint8Buffer, [op.oldNode, op.node]);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n\n      case \"delete\":\n        state = applyDelete(ast, uint8Buffer, op.node);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n\n      case \"add\":\n        state = applyAdd(ast, uint8Buffer, op.node);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n\n      default:\n        throw new Error(\"Unknown operation\");\n    }\n    /**\n     * Resize section vec size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the byte length of the section and the offset for nodes in the\n     * section. So we do this first before resizing section byte size\n     * or shifting following operations' nodes.\n     */\n\n\n    if (state.deltaElements !== 0 && sectionName !== \"start\") {\n      var oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = (0, _helperWasmSection.resizeSectionVecSize)(ast, state.uint8Buffer, sectionName, state.deltaElements); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - oldBufferLength;\n    }\n    /**\n     * Resize section byte size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the offset for nodes in the section. So we do this before\n     * shifting following operations' nodes.\n     */\n\n\n    if (state.deltaBytes !== 0 && sectionName !== \"start\") {\n      var _oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = (0, _helperWasmSection.resizeSectionByteSize)(ast, state.uint8Buffer, sectionName, state.deltaBytes); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - _oldBufferLength;\n    }\n    /**\n     * Shift following operation's nodes\n     */\n\n\n    if (state.deltaBytes !== 0) {\n      ops.forEach(function (op) {\n        // We don't need to handle add ops, they are positioning independent\n        switch (op.kind) {\n          case \"update\":\n            shiftLocNodeByDelta(op.oldNode, state.deltaBytes);\n            break;\n\n          case \"delete\":\n            shiftLocNodeByDelta(op.node, state.deltaBytes);\n            break;\n        }\n      });\n    }\n\n    uint8Buffer = state.uint8Buffer;\n  });\n  return uint8Buffer;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","applyOperations","_wasmGen","require","_encoder","_ast","_helperWasmSection","_helperBuffer","_helperWasmBytecode","_sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","length","err","_slicedToArray","Array","isArray","TypeError","shiftLocNodeByDelta","node","delta","assertHasLoc","loc","start","column","end","applyUpdate","ast","uint8Buffer","_ref","_ref2","oldNode","newNode","deltaElements","sectionName","getSectionForNode","replacementByteArray","encodeNode","overrideBytesInBuffer","traverse","Func","_ref3","funcHasThisIntr","body","find","n","oldNodeSize","bodySizeDeltaBytes","newValue","metadata","bodySize","newByteArray","encodeU32","deltaBytes","line","applyDelete","sectionMetadata","getSectionMetadata","removeSections","_deltaBytes","size","replacement","applyAdd","res","createEmptySection","isFunc","id","Error","isGlobal","init","getEndOfSection","type","orderedInsertNode","ops","forEach","op","state","kind","oldBufferLength","resizeSectionVecSize","_oldBufferLength","resizeSectionByteSize"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@webassemblyjs/wasm-edit/lib/apply.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyOperations = applyOperations;\n\nvar _wasmGen = require(\"@webassemblyjs/wasm-gen\");\n\nvar _encoder = require(\"@webassemblyjs/wasm-gen/lib/encoder\");\n\nvar _ast = require(\"@webassemblyjs/ast\");\n\nvar _helperWasmSection = require(\"@webassemblyjs/helper-wasm-section\");\n\nvar _helperBuffer = require(\"@webassemblyjs/helper-buffer\");\n\nvar _helperWasmBytecode = require(\"@webassemblyjs/helper-wasm-bytecode\");\n\nfunction _sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return _sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }\n\nfunction shiftLocNodeByDelta(node, delta) {\n  (0, _ast.assertHasLoc)(node); // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.start.column += delta; // $FlowIgnore: assertHasLoc ensures that\n\n  node.loc.end.column += delta;\n}\n\nfunction applyUpdate(ast, uint8Buffer, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      oldNode = _ref2[0],\n      newNode = _ref2[1];\n\n  var deltaElements = 0;\n  (0, _ast.assertHasLoc)(oldNode);\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(newNode);\n  var replacementByteArray = (0, _wasmGen.encodeNode)(newNode);\n  /**\n   * Replace new node as bytes\n   */\n\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column, replacementByteArray);\n  /**\n   * Update function body size if needed\n   */\n\n  if (sectionName === \"code\") {\n    // Find the parent func\n    (0, _ast.traverse)(ast, {\n      Func: function Func(_ref3) {\n        var node = _ref3.node;\n        var funcHasThisIntr = node.body.find(function (n) {\n          return n === newNode;\n        }) !== undefined; // Update func's body size if needed\n\n        if (funcHasThisIntr === true) {\n          // These are the old functions locations informations\n          (0, _ast.assertHasLoc)(node);\n          var oldNodeSize = (0, _wasmGen.encodeNode)(oldNode).length;\n          var bodySizeDeltaBytes = replacementByteArray.length - oldNodeSize;\n\n          if (bodySizeDeltaBytes !== 0) {\n            var newValue = node.metadata.bodySize + bodySizeDeltaBytes;\n            var newByteArray = (0, _encoder.encodeU32)(newValue); // function body size byte\n            // FIXME(sven): only handles one byte u32\n\n            var start = node.loc.start.column;\n            var end = start + 1;\n            uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, start, end, newByteArray);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Update section size\n   */\n\n\n  var deltaBytes = replacementByteArray.length - ( // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.end.column - oldNode.loc.start.column); // Init location informations\n\n  newNode.loc = {\n    start: {\n      line: -1,\n      column: -1\n    },\n    end: {\n      line: -1,\n      column: -1\n    }\n  }; // Update new node end position\n  // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.start.column = oldNode.loc.start.column; // $FlowIgnore: assertHasLoc ensures that\n\n  newNode.loc.end.column = // $FlowIgnore: assertHasLoc ensures that\n  oldNode.loc.start.column + replacementByteArray.length;\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyDelete(ast, uint8Buffer, node) {\n  var deltaElements = -1; // since we removed an element\n\n  (0, _ast.assertHasLoc)(node);\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(node);\n\n  if (sectionName === \"start\") {\n    var sectionMetadata = (0, _ast.getSectionMetadata)(ast, \"start\");\n    /**\n     * The start section only contains one element,\n     * we need to remove the whole section\n     */\n\n    uint8Buffer = (0, _helperWasmSection.removeSections)(ast, uint8Buffer, \"start\");\n\n    var _deltaBytes = -(sectionMetadata.size.value + 1);\n    /* section id */\n\n\n    return {\n      uint8Buffer: uint8Buffer,\n      deltaBytes: _deltaBytes,\n      deltaElements: deltaElements\n    };\n  } // replacement is nothing\n\n\n  var replacement = [];\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, // $FlowIgnore: assertHasLoc ensures that\n  node.loc.start.column, // $FlowIgnore: assertHasLoc ensures that\n  node.loc.end.column, replacement);\n  /**\n   * Update section\n   */\n  // $FlowIgnore: assertHasLoc ensures that\n\n  var deltaBytes = -(node.loc.end.column - node.loc.start.column);\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyAdd(ast, uint8Buffer, node) {\n  var deltaElements = +1; // since we added an element\n\n  var sectionName = (0, _helperWasmBytecode.getSectionForNode)(node);\n  var sectionMetadata = (0, _ast.getSectionMetadata)(ast, sectionName); // Section doesn't exists, we create an empty one\n\n  if (typeof sectionMetadata === \"undefined\") {\n    var res = (0, _helperWasmSection.createEmptySection)(ast, uint8Buffer, sectionName);\n    uint8Buffer = res.uint8Buffer;\n    sectionMetadata = res.sectionMetadata;\n  }\n  /**\n   * check that the expressions were ended\n   */\n\n\n  if ((0, _ast.isFunc)(node)) {\n    // $FlowIgnore\n    var body = node.body;\n\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n\n  if ((0, _ast.isGlobal)(node)) {\n    // $FlowIgnore\n    var body = node.init;\n\n    if (body.length === 0 || body[body.length - 1].id !== \"end\") {\n      throw new Error(\"expressions must be ended\");\n    }\n  }\n  /**\n   * Add nodes\n   */\n\n\n  var newByteArray = (0, _wasmGen.encodeNode)(node); // The size of the section doesn't include the storage of the size itself\n  // we need to manually add it here\n\n  var start = (0, _ast.getEndOfSection)(sectionMetadata);\n  var end = start;\n  /**\n   * Update section\n   */\n\n  var deltaBytes = newByteArray.length;\n  uint8Buffer = (0, _helperBuffer.overrideBytesInBuffer)(uint8Buffer, start, end, newByteArray);\n  node.loc = {\n    start: {\n      line: -1,\n      column: start\n    },\n    end: {\n      line: -1,\n      column: start + deltaBytes\n    }\n  }; // for func add the additional metadata in the AST\n\n  if (node.type === \"Func\") {\n    // the size is the first byte\n    // FIXME(sven): handle LEB128 correctly here\n    var bodySize = newByteArray[0];\n    node.metadata = {\n      bodySize: bodySize\n    };\n  }\n\n  if (node.type !== \"IndexInFuncSection\") {\n    (0, _ast.orderedInsertNode)(ast.body[0], node);\n  }\n\n  return {\n    uint8Buffer: uint8Buffer,\n    deltaBytes: deltaBytes,\n    deltaElements: deltaElements\n  };\n}\n\nfunction applyOperations(ast, uint8Buffer, ops) {\n  ops.forEach(function (op) {\n    var state;\n    var sectionName;\n\n    switch (op.kind) {\n      case \"update\":\n        state = applyUpdate(ast, uint8Buffer, [op.oldNode, op.node]);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n\n      case \"delete\":\n        state = applyDelete(ast, uint8Buffer, op.node);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n\n      case \"add\":\n        state = applyAdd(ast, uint8Buffer, op.node);\n        sectionName = (0, _helperWasmBytecode.getSectionForNode)(op.node);\n        break;\n\n      default:\n        throw new Error(\"Unknown operation\");\n    }\n    /**\n     * Resize section vec size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the byte length of the section and the offset for nodes in the\n     * section. So we do this first before resizing section byte size\n     * or shifting following operations' nodes.\n     */\n\n\n    if (state.deltaElements !== 0 && sectionName !== \"start\") {\n      var oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = (0, _helperWasmSection.resizeSectionVecSize)(ast, state.uint8Buffer, sectionName, state.deltaElements); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - oldBufferLength;\n    }\n    /**\n     * Resize section byte size.\n     * If the length of the LEB-encoded size changes, this can change\n     * the offset for nodes in the section. So we do this before\n     * shifting following operations' nodes.\n     */\n\n\n    if (state.deltaBytes !== 0 && sectionName !== \"start\") {\n      var _oldBufferLength = state.uint8Buffer.length;\n      state.uint8Buffer = (0, _helperWasmSection.resizeSectionByteSize)(ast, state.uint8Buffer, sectionName, state.deltaBytes); // Infer bytes added/removed by comparing buffer lengths\n\n      state.deltaBytes += state.uint8Buffer.length - _oldBufferLength;\n    }\n    /**\n     * Shift following operation's nodes\n     */\n\n\n    if (state.deltaBytes !== 0) {\n      ops.forEach(function (op) {\n        // We don't need to handle add ops, they are positioning independent\n        switch (op.kind) {\n          case \"update\":\n            shiftLocNodeByDelta(op.oldNode, state.deltaBytes);\n            break;\n\n          case \"delete\":\n            shiftLocNodeByDelta(op.node, state.deltaBytes);\n            break;\n        }\n      });\n    }\n\n    uint8Buffer = state.uint8Buffer;\n  });\n  return uint8Buffer;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}