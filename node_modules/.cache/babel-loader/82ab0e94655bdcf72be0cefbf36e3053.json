{"ast":null,"code":"/**\n * @fileoverview Enforce propTypes declarations alphabetical sorting\n */\n'use strict';\n\nconst variableUtil = require('../util/variable');\n\nconst propsUtil = require('../util/props');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst propWrapperUtil = require('../util/propWrapper'); // const propTypesSortUtil = require('../util/propTypesSort');\n\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst messages = {\n  requiredPropsFirst: 'Required prop types must be listed before all other prop types',\n  callbackPropsLast: 'Callback prop types must be listed after all other prop types',\n  propsNotSorted: 'Prop types declarations should be sorted alphabetically'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce propTypes declarations alphabetical sorting',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('sort-prop-types')\n    },\n    // fixable: 'code',\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        requiredFirst: {\n          type: 'boolean'\n        },\n        callbacksLast: {\n          type: 'boolean'\n        },\n        ignoreCase: {\n          type: 'boolean'\n        },\n        // Whether alphabetical sorting should be enforced\n        noSortAlphabetically: {\n          type: 'boolean'\n        },\n        sortShapeProp: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {};\n    const requiredFirst = configuration.requiredFirst || false;\n    const callbacksLast = configuration.callbacksLast || false;\n    const ignoreCase = configuration.ignoreCase || false;\n    const noSortAlphabetically = configuration.noSortAlphabetically || false;\n    const sortShapeProp = configuration.sortShapeProp || false;\n\n    function getKey(node) {\n      if (node.key && node.key.value) {\n        return node.key.value;\n      }\n\n      return context.getSourceCode().getText(node.key || node.argument);\n    }\n\n    function getValueName(node) {\n      return node.type === 'Property' && node.value.property && node.value.property.name;\n    }\n\n    function isCallbackPropName(propName) {\n      return /^on[A-Z]/.test(propName);\n    }\n\n    function isRequiredProp(node) {\n      return getValueName(node) === 'isRequired';\n    }\n\n    function isShapeProp(node) {\n      return Boolean(node && node.callee && node.callee.property && node.callee.property.name === 'shape');\n    }\n\n    function toLowerCase(item) {\n      return String(item).toLowerCase();\n    }\n    /**\n     * Checks if propTypes declarations are sorted\n     * @param {Array} declarations The array of AST nodes being checked.\n     * @returns {void}\n     */\n\n\n    function checkSorted(declarations) {\n      // Declarations will be `undefined` if the `shape` is not a literal. For\n      // example, if it is a propType imported from another file.\n      if (!declarations) {\n        return;\n      } // function fix(fixer) {\n      //   return propTypesSortUtil.fixPropTypesSort(\n      //     fixer,\n      //     context,\n      //     declarations,\n      //     ignoreCase,\n      //     requiredFirst,\n      //     callbacksLast,\n      //     sortShapeProp\n      //   );\n      // }\n\n\n      const callbackPropsLastSeen = new WeakSet();\n      const requiredPropsFirstSeen = new WeakSet();\n      const propsNotSortedSeen = new WeakSet();\n      declarations.reduce((prev, curr, idx, decls) => {\n        if (curr.type === 'ExperimentalSpreadProperty' || curr.type === 'SpreadElement') {\n          return decls[idx + 1];\n        }\n\n        let prevPropName = getKey(prev);\n        let currentPropName = getKey(curr);\n        const previousIsRequired = isRequiredProp(prev);\n        const currentIsRequired = isRequiredProp(curr);\n        const previousIsCallback = isCallbackPropName(prevPropName);\n        const currentIsCallback = isCallbackPropName(currentPropName);\n\n        if (ignoreCase) {\n          prevPropName = toLowerCase(prevPropName);\n          currentPropName = toLowerCase(currentPropName);\n        }\n\n        if (requiredFirst) {\n          if (previousIsRequired && !currentIsRequired) {\n            // Transition between required and non-required. Don't compare for alphabetical.\n            return curr;\n          }\n\n          if (!previousIsRequired && currentIsRequired) {\n            // Encountered a non-required prop after a required prop\n            if (!requiredPropsFirstSeen.has(curr)) {\n              requiredPropsFirstSeen.add(curr);\n              report(context, messages.requiredPropsFirst, 'requiredPropsFirst', {\n                node: curr //  fix\n\n              });\n            }\n\n            return curr;\n          }\n        }\n\n        if (callbacksLast) {\n          if (!previousIsCallback && currentIsCallback) {\n            // Entering the callback prop section\n            return curr;\n          }\n\n          if (previousIsCallback && !currentIsCallback) {\n            // Encountered a non-callback prop after a callback prop\n            if (!callbackPropsLastSeen.has(prev)) {\n              callbackPropsLastSeen.add(prev);\n              report(context, messages.callbackPropsLast, 'callbackPropsLast', {\n                node: prev // fix\n\n              });\n            }\n\n            return prev;\n          }\n        }\n\n        if (!noSortAlphabetically && currentPropName < prevPropName) {\n          if (!propsNotSortedSeen.has(curr)) {\n            propsNotSortedSeen.add(curr);\n            report(context, messages.propsNotSorted, 'propsNotSorted', {\n              node: curr // fix\n\n            });\n          }\n\n          return prev;\n        }\n\n        return curr;\n      }, declarations[0]);\n    }\n\n    function checkNode(node) {\n      switch (node && node.type) {\n        case 'ObjectExpression':\n          checkSorted(node.properties);\n          break;\n\n        case 'Identifier':\n          {\n            const propTypesObject = variableUtil.findVariableByName(context, node.name);\n\n            if (propTypesObject && propTypesObject.properties) {\n              checkSorted(propTypesObject.properties);\n            }\n\n            break;\n          }\n\n        case 'CallExpression':\n          {\n            const innerNode = node.arguments && node.arguments[0];\n\n            if (propWrapperUtil.isPropWrapperFunction(context, node.callee.name) && innerNode) {\n              checkNode(innerNode);\n            }\n\n            break;\n          }\n\n        default:\n          break;\n      }\n    }\n\n    return {\n      CallExpression(node) {\n        if (!sortShapeProp || !isShapeProp(node) || !(node.arguments && node.arguments[0])) {\n          return;\n        }\n\n        const firstArg = node.arguments[0];\n\n        if (firstArg.properties) {\n          checkSorted(firstArg.properties);\n        } else if (firstArg.type === 'Identifier') {\n          const variable = variableUtil.findVariableByName(context, firstArg.name);\n\n          if (variable && variable.properties) {\n            checkSorted(variable.properties);\n          }\n        }\n      },\n\n      'ClassProperty, PropertyDefinition'(node) {\n        if (!propsUtil.isPropTypesDeclaration(node)) {\n          return;\n        }\n\n        checkNode(node.value);\n      },\n\n      MemberExpression(node) {\n        if (!propsUtil.isPropTypesDeclaration(node)) {\n          return;\n        }\n\n        checkNode(node.parent.right);\n      },\n\n      ObjectExpression(node) {\n        node.properties.forEach(property => {\n          if (!property.key) {\n            return;\n          }\n\n          if (!propsUtil.isPropTypesDeclaration(property)) {\n            return;\n          }\n\n          if (property.value.type === 'ObjectExpression') {\n            checkSorted(property.value.properties);\n          }\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["variableUtil","require","propsUtil","docsUrl","propWrapperUtil","report","messages","requiredPropsFirst","callbackPropsLast","propsNotSorted","module","exports","meta","docs","description","category","recommended","url","schema","type","properties","requiredFirst","callbacksLast","ignoreCase","noSortAlphabetically","sortShapeProp","additionalProperties","create","context","configuration","options","getKey","node","key","value","getSourceCode","getText","argument","getValueName","property","name","isCallbackPropName","propName","test","isRequiredProp","isShapeProp","Boolean","callee","toLowerCase","item","String","checkSorted","declarations","callbackPropsLastSeen","WeakSet","requiredPropsFirstSeen","propsNotSortedSeen","reduce","prev","curr","idx","decls","prevPropName","currentPropName","previousIsRequired","currentIsRequired","previousIsCallback","currentIsCallback","has","add","checkNode","propTypesObject","findVariableByName","innerNode","arguments","isPropWrapperFunction","CallExpression","firstArg","variable","isPropTypesDeclaration","MemberExpression","parent","right","ObjectExpression","forEach"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/sort-prop-types.js"],"sourcesContent":["/**\n * @fileoverview Enforce propTypes declarations alphabetical sorting\n */\n\n'use strict';\n\nconst variableUtil = require('../util/variable');\nconst propsUtil = require('../util/props');\nconst docsUrl = require('../util/docsUrl');\nconst propWrapperUtil = require('../util/propWrapper');\n// const propTypesSortUtil = require('../util/propTypesSort');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  requiredPropsFirst: 'Required prop types must be listed before all other prop types',\n  callbackPropsLast: 'Callback prop types must be listed after all other prop types',\n  propsNotSorted: 'Prop types declarations should be sorted alphabetically',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce propTypes declarations alphabetical sorting',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('sort-prop-types'),\n    },\n    // fixable: 'code',\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        requiredFirst: {\n          type: 'boolean',\n        },\n        callbacksLast: {\n          type: 'boolean',\n        },\n        ignoreCase: {\n          type: 'boolean',\n        },\n        // Whether alphabetical sorting should be enforced\n        noSortAlphabetically: {\n          type: 'boolean',\n        },\n        sortShapeProp: {\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {};\n    const requiredFirst = configuration.requiredFirst || false;\n    const callbacksLast = configuration.callbacksLast || false;\n    const ignoreCase = configuration.ignoreCase || false;\n    const noSortAlphabetically = configuration.noSortAlphabetically || false;\n    const sortShapeProp = configuration.sortShapeProp || false;\n\n    function getKey(node) {\n      if (node.key && node.key.value) {\n        return node.key.value;\n      }\n      return context.getSourceCode().getText(node.key || node.argument);\n    }\n\n    function getValueName(node) {\n      return node.type === 'Property' && node.value.property && node.value.property.name;\n    }\n\n    function isCallbackPropName(propName) {\n      return /^on[A-Z]/.test(propName);\n    }\n\n    function isRequiredProp(node) {\n      return getValueName(node) === 'isRequired';\n    }\n\n    function isShapeProp(node) {\n      return Boolean(\n        node && node.callee && node.callee.property && node.callee.property.name === 'shape'\n      );\n    }\n\n    function toLowerCase(item) {\n      return String(item).toLowerCase();\n    }\n\n    /**\n     * Checks if propTypes declarations are sorted\n     * @param {Array} declarations The array of AST nodes being checked.\n     * @returns {void}\n     */\n    function checkSorted(declarations) {\n      // Declarations will be `undefined` if the `shape` is not a literal. For\n      // example, if it is a propType imported from another file.\n      if (!declarations) {\n        return;\n      }\n\n      // function fix(fixer) {\n      //   return propTypesSortUtil.fixPropTypesSort(\n      //     fixer,\n      //     context,\n      //     declarations,\n      //     ignoreCase,\n      //     requiredFirst,\n      //     callbacksLast,\n      //     sortShapeProp\n      //   );\n      // }\n\n      const callbackPropsLastSeen = new WeakSet();\n      const requiredPropsFirstSeen = new WeakSet();\n      const propsNotSortedSeen = new WeakSet();\n\n      declarations.reduce((prev, curr, idx, decls) => {\n        if (curr.type === 'ExperimentalSpreadProperty' || curr.type === 'SpreadElement') {\n          return decls[idx + 1];\n        }\n\n        let prevPropName = getKey(prev);\n        let currentPropName = getKey(curr);\n        const previousIsRequired = isRequiredProp(prev);\n        const currentIsRequired = isRequiredProp(curr);\n        const previousIsCallback = isCallbackPropName(prevPropName);\n        const currentIsCallback = isCallbackPropName(currentPropName);\n\n        if (ignoreCase) {\n          prevPropName = toLowerCase(prevPropName);\n          currentPropName = toLowerCase(currentPropName);\n        }\n\n        if (requiredFirst) {\n          if (previousIsRequired && !currentIsRequired) {\n            // Transition between required and non-required. Don't compare for alphabetical.\n            return curr;\n          }\n          if (!previousIsRequired && currentIsRequired) {\n            // Encountered a non-required prop after a required prop\n            if (!requiredPropsFirstSeen.has(curr)) {\n              requiredPropsFirstSeen.add(curr);\n              report(context, messages.requiredPropsFirst, 'requiredPropsFirst', {\n                node: curr,\n                //  fix\n              });\n            }\n            return curr;\n          }\n        }\n\n        if (callbacksLast) {\n          if (!previousIsCallback && currentIsCallback) {\n            // Entering the callback prop section\n            return curr;\n          }\n          if (previousIsCallback && !currentIsCallback) {\n            // Encountered a non-callback prop after a callback prop\n            if (!callbackPropsLastSeen.has(prev)) {\n              callbackPropsLastSeen.add(prev);\n              report(context, messages.callbackPropsLast, 'callbackPropsLast', {\n                node: prev,\n                // fix\n              });\n            }\n            return prev;\n          }\n        }\n\n        if (!noSortAlphabetically && currentPropName < prevPropName) {\n          if (!propsNotSortedSeen.has(curr)) {\n            propsNotSortedSeen.add(curr);\n            report(context, messages.propsNotSorted, 'propsNotSorted', {\n              node: curr,\n            // fix\n            });\n          }\n          return prev;\n        }\n\n        return curr;\n      }, declarations[0]);\n    }\n\n    function checkNode(node) {\n      switch (node && node.type) {\n        case 'ObjectExpression':\n          checkSorted(node.properties);\n          break;\n        case 'Identifier': {\n          const propTypesObject = variableUtil.findVariableByName(context, node.name);\n          if (propTypesObject && propTypesObject.properties) {\n            checkSorted(propTypesObject.properties);\n          }\n          break;\n        }\n        case 'CallExpression': {\n          const innerNode = node.arguments && node.arguments[0];\n          if (propWrapperUtil.isPropWrapperFunction(context, node.callee.name) && innerNode) {\n            checkNode(innerNode);\n          }\n          break;\n        }\n        default:\n          break;\n      }\n    }\n\n    return {\n      CallExpression(node) {\n        if (!sortShapeProp || !isShapeProp(node) || !(node.arguments && node.arguments[0])) {\n          return;\n        }\n\n        const firstArg = node.arguments[0];\n        if (firstArg.properties) {\n          checkSorted(firstArg.properties);\n        } else if (firstArg.type === 'Identifier') {\n          const variable = variableUtil.findVariableByName(context, firstArg.name);\n          if (variable && variable.properties) {\n            checkSorted(variable.properties);\n          }\n        }\n      },\n\n      'ClassProperty, PropertyDefinition'(node) {\n        if (!propsUtil.isPropTypesDeclaration(node)) {\n          return;\n        }\n        checkNode(node.value);\n      },\n\n      MemberExpression(node) {\n        if (!propsUtil.isPropTypesDeclaration(node)) {\n          return;\n        }\n\n        checkNode(node.parent.right);\n      },\n\n      ObjectExpression(node) {\n        node.properties.forEach((property) => {\n          if (!property.key) {\n            return;\n          }\n\n          if (!propsUtil.isPropTypesDeclaration(property)) {\n            return;\n          }\n          if (property.value.type === 'ObjectExpression') {\n            checkSorted(property.value.properties);\n          }\n        });\n      },\n\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}