{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'restrict-template-expressions',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Enforce template literal expressions to be of `string` type',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    messages: {\n      invalidType: 'Invalid type \"{{type}}\" of template literal expression.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowNumber: {\n          description: 'Whether to allow `number` typed values in template expressions.',\n          type: 'boolean'\n        },\n        allowBoolean: {\n          description: 'Whether to allow `boolean` typed values in template expressions.',\n          type: 'boolean'\n        },\n        allowAny: {\n          description: 'Whether to allow `any` typed values in template expressions.',\n          type: 'boolean'\n        },\n        allowNullish: {\n          description: 'Whether to allow `nullish` typed values in template expressions.',\n          type: 'boolean'\n        },\n        allowRegExp: {\n          description: 'Whether to allow `regexp` typed values in template expressions.',\n          type: 'boolean'\n        }\n      }\n    }]\n  },\n  defaultOptions: [{\n    allowNumber: true\n  }],\n\n  create(context, _ref) {\n    let [options] = _ref;\n    const service = util.getParserServices(context);\n    const typeChecker = service.program.getTypeChecker();\n\n    function isUnderlyingTypePrimitive(type) {\n      if (util.isTypeFlagSet(type, ts.TypeFlags.StringLike)) {\n        return true;\n      }\n\n      if (options.allowNumber && util.isTypeFlagSet(type, ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike)) {\n        return true;\n      }\n\n      if (options.allowBoolean && util.isTypeFlagSet(type, ts.TypeFlags.BooleanLike)) {\n        return true;\n      }\n\n      if (options.allowAny && util.isTypeAnyType(type)) {\n        return true;\n      }\n\n      if (options.allowRegExp && util.getTypeName(typeChecker, type) === 'RegExp') {\n        return true;\n      }\n\n      if (options.allowNullish && util.isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return {\n      TemplateLiteral(node) {\n        // don't check tagged template literals\n        if (node.parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression) {\n          return;\n        }\n\n        for (const expression of node.expressions) {\n          const expressionType = util.getConstrainedTypeAtLocation(typeChecker, service.esTreeNodeToTSNodeMap.get(expression));\n\n          if (!isInnerUnionOrIntersectionConformingTo(expressionType, isUnderlyingTypePrimitive)) {\n            context.report({\n              node: expression,\n              messageId: 'invalidType',\n              data: {\n                type: typeChecker.typeToString(expressionType)\n              }\n            });\n          }\n        }\n      }\n\n    };\n\n    function isInnerUnionOrIntersectionConformingTo(type, predicate) {\n      return rec(type);\n\n      function rec(innerType) {\n        if (innerType.isUnion()) {\n          return innerType.types.every(rec);\n        }\n\n        if (innerType.isIntersection()) {\n          return innerType.types.some(rec);\n        }\n\n        return predicate(innerType);\n      }\n    }\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","messages","invalidType","schema","properties","allowNumber","allowBoolean","allowAny","allowNullish","allowRegExp","defaultOptions","create","context","options","service","getParserServices","typeChecker","program","getTypeChecker","isUnderlyingTypePrimitive","isTypeFlagSet","ts","TypeFlags","StringLike","NumberLike","BigIntLike","BooleanLike","isTypeAnyType","getTypeName","Null","Undefined","TemplateLiteral","node","parent","utils_1","TaggedTemplateExpression","expression","expressions","expressionType","getConstrainedTypeAtLocation","esTreeNodeToTSNodeMap","get","isInnerUnionOrIntersectionConformingTo","report","messageId","data","typeToString","predicate","rec","innerType","isUnion","types","every","isIntersection","some"],"sources":["../../src/rules/restrict-template-expressions.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}