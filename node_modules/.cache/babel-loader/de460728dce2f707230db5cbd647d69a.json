{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst typescript_1 = require(\"typescript\");\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'consistent-type-exports',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Enforce consistent usage of type exports',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    messages: {\n      typeOverValue: 'All exports in the declaration are only used as types. Use `export type`.',\n      singleExportIsType: 'Type export {{exportNames}} is not a value and should be exported using `export type`.',\n      multipleExportsAreTypes: 'Type exports {{exportNames}} are not values and should be exported using `export type`.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        fixMixedExportsWithInlineTypeSpecifier: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: 'code'\n  },\n  defaultOptions: [{\n    fixMixedExportsWithInlineTypeSpecifier: false\n  }],\n\n  create(context, _ref) {\n    let [{\n      fixMixedExportsWithInlineTypeSpecifier\n    }] = _ref;\n    const sourceCode = context.getSourceCode();\n    const sourceExportsMap = {};\n    const parserServices = util.getParserServices(context);\n    return {\n      ExportNamedDeclaration(node) {\n        var _a; // Coerce the source into a string for use as a lookup entry.\n\n\n        const source = (_a = getSourceFromExport(node)) !== null && _a !== void 0 ? _a : 'undefined';\n        const sourceExports = sourceExportsMap[source] || (sourceExportsMap[source] = {\n          source,\n          reportValueExports: [],\n          typeOnlyNamedExport: null,\n          valueOnlyNamedExport: null\n        }); // Cache the first encountered exports for the package. We will need to come\n        // back to these later when fixing the problems.\n\n        if (node.exportKind === 'type') {\n          if (sourceExports.typeOnlyNamedExport == null) {\n            // The export is a type export\n            sourceExports.typeOnlyNamedExport = node;\n          }\n        } else if (sourceExports.valueOnlyNamedExport == null) {\n          // The export is a value export\n          sourceExports.valueOnlyNamedExport = node;\n        } // Next for the current export, we will separate type/value specifiers.\n\n\n        const typeBasedSpecifiers = [];\n        const inlineTypeSpecifiers = [];\n        const valueSpecifiers = []; // Note: it is valid to export values as types. We will avoid reporting errors\n        // when this is encountered.\n\n        if (node.exportKind !== 'type') {\n          for (const specifier of node.specifiers) {\n            if (specifier.exportKind === 'type') {\n              inlineTypeSpecifiers.push(specifier);\n              continue;\n            }\n\n            const isTypeBased = isSpecifierTypeBased(parserServices, specifier);\n\n            if (isTypeBased === true) {\n              typeBasedSpecifiers.push(specifier);\n            } else if (isTypeBased === false) {\n              // When isTypeBased is undefined, we should avoid reporting them.\n              valueSpecifiers.push(specifier);\n            }\n          }\n        }\n\n        if (node.exportKind === 'value' && typeBasedSpecifiers.length || node.exportKind === 'type' && valueSpecifiers.length) {\n          sourceExports.reportValueExports.push({\n            node,\n            typeBasedSpecifiers,\n            valueSpecifiers,\n            inlineTypeSpecifiers\n          });\n        }\n      },\n\n      'Program:exit'() {\n        for (const sourceExports of Object.values(sourceExportsMap)) {\n          // If this export has no issues, move on.\n          if (sourceExports.reportValueExports.length === 0) {\n            continue;\n          }\n\n          for (const report of sourceExports.reportValueExports) {\n            if (report.valueSpecifiers.length === 0) {\n              // Export is all type-only with no type specifiers; convert the entire export to `export type`.\n              context.report({\n                node: report.node,\n                messageId: 'typeOverValue',\n\n                *fix(fixer) {\n                  yield* fixExportInsertType(fixer, sourceCode, report.node);\n                }\n\n              });\n              continue;\n            } // We have both type and value violations.\n\n\n            const allExportNames = report.typeBasedSpecifiers.map(specifier => `${specifier.local.name}`);\n\n            if (allExportNames.length === 1) {\n              const exportNames = allExportNames[0];\n              context.report({\n                node: report.node,\n                messageId: 'singleExportIsType',\n                data: {\n                  exportNames\n                },\n\n                *fix(fixer) {\n                  if (fixMixedExportsWithInlineTypeSpecifier) {\n                    yield* fixAddTypeSpecifierToNamedExports(fixer, report);\n                  } else {\n                    yield* fixSeparateNamedExports(fixer, sourceCode, report);\n                  }\n                }\n\n              });\n            } else {\n              const exportNames = util.formatWordList(allExportNames);\n              context.report({\n                node: report.node,\n                messageId: 'multipleExportsAreTypes',\n                data: {\n                  exportNames\n                },\n\n                *fix(fixer) {\n                  if (fixMixedExportsWithInlineTypeSpecifier) {\n                    yield* fixAddTypeSpecifierToNamedExports(fixer, report);\n                  } else {\n                    yield* fixSeparateNamedExports(fixer, sourceCode, report);\n                  }\n                }\n\n              });\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n});\n/**\n * Helper for identifying if an export specifier resolves to a\n * JavaScript value or a TypeScript type.\n *\n * @returns True/false if is a type or not, or undefined if the specifier\n * can't be resolved.\n */\n\nfunction isSpecifierTypeBased(parserServices, specifier) {\n  const checker = parserServices.program.getTypeChecker();\n  const node = parserServices.esTreeNodeToTSNodeMap.get(specifier.exported);\n  const symbol = checker.getSymbolAtLocation(node);\n  const aliasedSymbol = checker.getAliasedSymbol(symbol);\n\n  if (!aliasedSymbol || aliasedSymbol.escapedName === 'unknown') {\n    return undefined;\n  }\n\n  return !(aliasedSymbol.flags & typescript_1.SymbolFlags.Value);\n}\n/**\n * Inserts \"type\" into an export.\n *\n * Example:\n *\n * export type { Foo } from 'foo';\n *        ^^^^\n */\n\n\nfunction* fixExportInsertType(fixer, sourceCode, node) {\n  const exportToken = util.nullThrows(sourceCode.getFirstToken(node), util.NullThrowsReasons.MissingToken('export', node.type));\n  yield fixer.insertTextAfter(exportToken, ' type');\n\n  for (const specifier of node.specifiers) {\n    if (specifier.exportKind === 'type') {\n      const kindToken = util.nullThrows(sourceCode.getFirstToken(specifier), util.NullThrowsReasons.MissingToken('export', specifier.type));\n      const firstTokenAfter = util.nullThrows(sourceCode.getTokenAfter(kindToken, {\n        includeComments: true\n      }), 'Missing token following the export kind.');\n      yield fixer.removeRange([kindToken.range[0], firstTokenAfter.range[0]]);\n    }\n  }\n}\n/**\n * Separates the exports which mismatch the kind of export the given\n * node represents. For example, a type export's named specifiers which\n * represent values will be inserted in a separate `export` statement.\n */\n\n\nfunction* fixSeparateNamedExports(fixer, sourceCode, report) {\n  const {\n    node,\n    typeBasedSpecifiers,\n    inlineTypeSpecifiers,\n    valueSpecifiers\n  } = report;\n  const typeSpecifiers = typeBasedSpecifiers.concat(inlineTypeSpecifiers);\n  const source = getSourceFromExport(node);\n  const specifierNames = typeSpecifiers.map(getSpecifierText).join(', ');\n  const exportToken = util.nullThrows(sourceCode.getFirstToken(node), util.NullThrowsReasons.MissingToken('export', node.type)); // Filter the bad exports from the current line.\n\n  const filteredSpecifierNames = valueSpecifiers.map(getSpecifierText).join(', ');\n  const openToken = util.nullThrows(sourceCode.getFirstToken(node, util.isOpeningBraceToken), util.NullThrowsReasons.MissingToken('{', node.type));\n  const closeToken = util.nullThrows(sourceCode.getLastToken(node, util.isClosingBraceToken), util.NullThrowsReasons.MissingToken('}', node.type)); // Remove exports from the current line which we're going to re-insert.\n\n  yield fixer.replaceTextRange([openToken.range[1], closeToken.range[0]], ` ${filteredSpecifierNames} `); // Insert the bad exports into a new export line above.\n\n  yield fixer.insertTextBefore(exportToken, `export type { ${specifierNames} }${source ? ` from '${source}'` : ''};\\n`);\n}\n\nfunction* fixAddTypeSpecifierToNamedExports(fixer, report) {\n  if (report.node.exportKind === 'type') {\n    return;\n  }\n\n  for (const specifier of report.typeBasedSpecifiers) {\n    yield fixer.insertTextBefore(specifier, 'type ');\n  }\n}\n/**\n * Returns the source of the export, or undefined if the named export has no source.\n */\n\n\nfunction getSourceFromExport(node) {\n  var _a;\n\n  if (((_a = node.source) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.Literal && typeof node.source.value === 'string') {\n    return node.source.value;\n  }\n\n  return undefined;\n}\n/**\n * Returns the specifier text for the export. If it is aliased, we take care to return\n * the proper formatting.\n */\n\n\nfunction getSpecifierText(specifier) {\n  return `${specifier.local.name}${specifier.exported.name !== specifier.local.name ? ` as ${specifier.exported.name}` : ''}`;\n}","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","messages","typeOverValue","singleExportIsType","multipleExportsAreTypes","schema","properties","fixMixedExportsWithInlineTypeSpecifier","additionalProperties","fixable","defaultOptions","create","context","sourceCode","getSourceCode","sourceExportsMap","parserServices","getParserServices","ExportNamedDeclaration","node","source","_a","sourceExports","reportValueExports","typeOnlyNamedExport","valueOnlyNamedExport","exportKind","typeBasedSpecifiers","inlineTypeSpecifiers","valueSpecifiers","specifier","specifiers","push","isTypeBased","isSpecifierTypeBased","length","Object","values","report","messageId","fix","fixer","fixExportInsertType","allExportNames","map","local","exportNames","data","fixAddTypeSpecifierToNamedExports","fixSeparateNamedExports","formatWordList","checker","program","getTypeChecker","esTreeNodeToTSNodeMap","get","exported","symbol","getSymbolAtLocation","aliasedSymbol","getAliasedSymbol","escapedName","undefined","flags","typescript_1","Value","exportToken","nullThrows","getFirstToken","NullThrowsReasons","MissingToken","insertTextAfter","kindToken","firstTokenAfter","getTokenAfter","includeComments","removeRange","range","typeSpecifiers","concat","getSourceFromExport","specifierNames","getSpecifierText","join","filteredSpecifierNames","openToken","isOpeningBraceToken","closeToken","getLastToken","isClosingBraceToken","replaceTextRange","insertTextBefore","utils_1","Literal","value"],"sources":["../../src/rules/consistent-type-exports.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}