{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.getExportSpecifierName = getExportSpecifierName;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _helperHoistVariables = require(\"@babel/helper-hoist-variables\");\n\nvar _core = require(\"@babel/core\");\n\nvar _utils = require(\"babel-plugin-dynamic-import-node/utils\");\n\nvar _helperModuleTransforms = require(\"@babel/helper-module-transforms\");\n\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\n\nconst buildTemplate = _core.template.statement(`\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: EXECUTE,\n    };\n  });\n`);\n\nconst buildExportAll = _core.template.statement(`\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n`);\n\nconst MISSING_PLUGIN_WARNING = `\\\nWARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n`;\nconst MISSING_PLUGIN_ERROR = `\\\nERROR: Dynamic import() transformation must be enabled using the\n       @babel/plugin-proposal-dynamic-import plugin. Babel 8\n       no longer transforms import() without using that plugin.\n`;\n\nfunction getExportSpecifierName(node, stringSpecifiers) {\n  if (node.type === \"Identifier\") {\n    return node.name;\n  } else if (node.type === \"StringLiteral\") {\n    const stringValue = node.value;\n\n    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n\n    return stringValue;\n  } else {\n    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${node.type}`);\n  }\n}\n\nfunction constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget, stringSpecifiers) {\n  const statements = [];\n\n  if (!exportStarTarget) {\n    if (exportNames.length === 1) {\n      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.stringLiteral(exportNames[0]), exportValues[0]])));\n    } else {\n      const objectProperties = [];\n\n      for (let i = 0; i < exportNames.length; i++) {\n        const exportName = exportNames[i];\n        const exportValue = exportValues[i];\n        objectProperties.push(_core.types.objectProperty(stringSpecifiers.has(exportName) ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), exportValue));\n      }\n\n      statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.objectExpression(objectProperties)])));\n    }\n  } else {\n    const exportObj = path.scope.generateUid(\"exportObj\");\n    statements.push(_core.types.variableDeclaration(\"var\", [_core.types.variableDeclarator(_core.types.identifier(exportObj), _core.types.objectExpression([]))]));\n    statements.push(buildExportAll({\n      KEY: path.scope.generateUidIdentifier(\"key\"),\n      EXPORT_OBJ: _core.types.identifier(exportObj),\n      TARGET: exportStarTarget\n    }));\n\n    for (let i = 0; i < exportNames.length; i++) {\n      const exportName = exportNames[i];\n      const exportValue = exportValues[i];\n      statements.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(_core.types.identifier(exportObj), _core.types.identifier(exportName)), exportValue)));\n    }\n\n    statements.push(_core.types.expressionStatement(_core.types.callExpression(exportIdent, [_core.types.identifier(exportObj)])));\n  }\n\n  return statements;\n}\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  api.assertVersion(7);\n  const {\n    systemGlobal = \"System\",\n    allowTopLevelThis = false\n  } = options;\n  const reassignmentVisited = new WeakSet();\n  const reassignmentVisitor = {\n    \"AssignmentExpression|UpdateExpression\"(path) {\n      if (reassignmentVisited.has(path.node)) return;\n      reassignmentVisited.add(path.node);\n      const arg = path.isAssignmentExpression() ? path.get(\"left\") : path.get(\"argument\");\n\n      if (arg.isObjectPattern() || arg.isArrayPattern()) {\n        const exprs = [path.node];\n\n        for (const name of Object.keys(arg.getBindingIdentifiers())) {\n          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {\n            return;\n          }\n\n          const exportedNames = this.exports[name];\n          if (!exportedNames) continue;\n\n          for (const exportedName of exportedNames) {\n            exprs.push(this.buildCall(exportedName, _core.types.identifier(name)).expression);\n          }\n        }\n\n        path.replaceWith(_core.types.sequenceExpression(exprs));\n        return;\n      }\n\n      if (!arg.isIdentifier()) return;\n      const name = arg.node.name;\n      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;\n      const exportedNames = this.exports[name];\n      if (!exportedNames) return;\n      let node = path.node;\n\n      const isPostUpdateExpression = _core.types.isUpdateExpression(node, {\n        prefix: false\n      });\n\n      if (isPostUpdateExpression) {\n        node = _core.types.binaryExpression(node.operator[0], _core.types.unaryExpression(\"+\", _core.types.cloneNode(node.argument)), _core.types.numericLiteral(1));\n      }\n\n      for (const exportedName of exportedNames) {\n        node = this.buildCall(exportedName, node).expression;\n      }\n\n      if (isPostUpdateExpression) {\n        node = _core.types.sequenceExpression([node, path.node]);\n      }\n\n      path.replaceWith(node);\n    }\n\n  };\n  return {\n    name: \"transform-modules-systemjs\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"systemjs\");\n    },\n\n    visitor: {\n      CallExpression(path, state) {\n        if (_core.types.isImport(path.node.callee)) {\n          if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) {\n            {\n              console.warn(MISSING_PLUGIN_WARNING);\n            }\n          }\n\n          path.replaceWith(_core.types.callExpression(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"import\")), [(0, _utils.getImportSource)(_core.types, path.node)]));\n        }\n      },\n\n      MetaProperty(path, state) {\n        if (path.node.meta.name === \"import\" && path.node.property.name === \"meta\") {\n          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"meta\")));\n        }\n      },\n\n      ReferencedIdentifier(path, state) {\n        if (path.node.name === \"__moduleName\" && !path.scope.hasBinding(\"__moduleName\")) {\n          path.replaceWith(_core.types.memberExpression(_core.types.identifier(state.contextIdent), _core.types.identifier(\"id\")));\n        }\n      },\n\n      Program: {\n        enter(path, state) {\n          state.contextIdent = path.scope.generateUid(\"context\");\n          state.stringSpecifiers = new Set();\n\n          if (!allowTopLevelThis) {\n            (0, _helperModuleTransforms.rewriteThis)(path);\n          }\n        },\n\n        exit(path, state) {\n          const scope = path.scope;\n          const exportIdent = scope.generateUid(\"export\");\n          const {\n            contextIdent,\n            stringSpecifiers\n          } = state;\n          const exportMap = Object.create(null);\n          const modules = [];\n          const beforeBody = [];\n          const setters = [];\n          const sources = [];\n          const variableIds = [];\n          const removedPaths = [];\n\n          function addExportName(key, val) {\n            exportMap[key] = exportMap[key] || [];\n            exportMap[key].push(val);\n          }\n\n          function pushModule(source, key, specifiers) {\n            let module;\n            modules.forEach(function (m) {\n              if (m.key === source) {\n                module = m;\n              }\n            });\n\n            if (!module) {\n              modules.push(module = {\n                key: source,\n                imports: [],\n                exports: []\n              });\n            }\n\n            module[key] = module[key].concat(specifiers);\n          }\n\n          function buildExportCall(name, val) {\n            return _core.types.expressionStatement(_core.types.callExpression(_core.types.identifier(exportIdent), [_core.types.stringLiteral(name), val]));\n          }\n\n          const exportNames = [];\n          const exportValues = [];\n          const body = path.get(\"body\");\n\n          for (const path of body) {\n            if (path.isFunctionDeclaration()) {\n              beforeBody.push(path.node);\n              removedPaths.push(path);\n            } else if (path.isClassDeclaration()) {\n              variableIds.push(_core.types.cloneNode(path.node.id));\n              path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(path.node.id), _core.types.toExpression(path.node))));\n            } else if (path.isVariableDeclaration()) {\n              path.node.kind = \"var\";\n            } else if (path.isImportDeclaration()) {\n              const source = path.node.source.value;\n              pushModule(source, \"imports\", path.node.specifiers);\n\n              for (const name of Object.keys(path.getBindingIdentifiers())) {\n                scope.removeBinding(name);\n                variableIds.push(_core.types.identifier(name));\n              }\n\n              path.remove();\n            } else if (path.isExportAllDeclaration()) {\n              pushModule(path.node.source.value, \"exports\", path.node);\n              path.remove();\n            } else if (path.isExportDefaultDeclaration()) {\n              const declar = path.node.declaration;\n\n              if (_core.types.isClassDeclaration(declar)) {\n                const id = declar.id;\n\n                if (id) {\n                  exportNames.push(\"default\");\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(_core.types.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(id), _core.types.toExpression(declar))));\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.toExpression(declar));\n                  removedPaths.push(path);\n                }\n              } else if (_core.types.isFunctionDeclaration(declar)) {\n                const id = declar.id;\n\n                if (id) {\n                  beforeBody.push(declar);\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(_core.types.toExpression(declar));\n                }\n\n                removedPaths.push(path);\n              } else {\n                path.replaceWith(buildExportCall(\"default\", declar));\n              }\n            } else if (path.isExportNamedDeclaration()) {\n              const declar = path.node.declaration;\n\n              if (declar) {\n                path.replaceWith(declar);\n\n                if (_core.types.isFunction(declar)) {\n                  const name = declar.id.name;\n                  addExportName(name, name);\n                  beforeBody.push(declar);\n                  exportNames.push(name);\n                  exportValues.push(_core.types.cloneNode(declar.id));\n                  removedPaths.push(path);\n                } else if (_core.types.isClass(declar)) {\n                  const name = declar.id.name;\n                  exportNames.push(name);\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(_core.types.cloneNode(declar.id));\n                  path.replaceWith(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(declar.id), _core.types.toExpression(declar))));\n                  addExportName(name, name);\n                } else {\n                  if (_core.types.isVariableDeclaration(declar)) {\n                    declar.kind = \"var\";\n                  }\n\n                  for (const name of Object.keys(_core.types.getBindingIdentifiers(declar))) {\n                    addExportName(name, name);\n                  }\n                }\n              } else {\n                const specifiers = path.node.specifiers;\n\n                if (specifiers != null && specifiers.length) {\n                  if (path.node.source) {\n                    pushModule(path.node.source.value, \"exports\", specifiers);\n                    path.remove();\n                  } else {\n                    const nodes = [];\n\n                    for (const specifier of specifiers) {\n                      const {\n                        local,\n                        exported\n                      } = specifier;\n                      const binding = scope.getBinding(local.name);\n                      const exportedName = getExportSpecifierName(exported, stringSpecifiers);\n\n                      if (binding && _core.types.isFunctionDeclaration(binding.path.node)) {\n                        exportNames.push(exportedName);\n                        exportValues.push(_core.types.cloneNode(local));\n                      } else if (!binding) {\n                        nodes.push(buildExportCall(exportedName, local));\n                      }\n\n                      addExportName(local.name, exportedName);\n                    }\n\n                    path.replaceWithMultiple(nodes);\n                  }\n                } else {\n                  path.remove();\n                }\n              }\n            }\n          }\n\n          modules.forEach(function (specifiers) {\n            const setterBody = [];\n            const target = scope.generateUid(specifiers.key);\n\n            for (let specifier of specifiers.imports) {\n              if (_core.types.isImportNamespaceSpecifier(specifier)) {\n                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", specifier.local, _core.types.identifier(target))));\n              } else if (_core.types.isImportDefaultSpecifier(specifier)) {\n                specifier = _core.types.importSpecifier(specifier.local, _core.types.identifier(\"default\"));\n              }\n\n              if (_core.types.isImportSpecifier(specifier)) {\n                const {\n                  imported\n                } = specifier;\n                setterBody.push(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", specifier.local, _core.types.memberExpression(_core.types.identifier(target), specifier.imported, imported.type === \"StringLiteral\"))));\n              }\n            }\n\n            if (specifiers.exports.length) {\n              const exportNames = [];\n              const exportValues = [];\n              let hasExportStar = false;\n\n              for (const node of specifiers.exports) {\n                if (_core.types.isExportAllDeclaration(node)) {\n                  hasExportStar = true;\n                } else if (_core.types.isExportSpecifier(node)) {\n                  const exportedName = getExportSpecifierName(node.exported, stringSpecifiers);\n                  exportNames.push(exportedName);\n                  exportValues.push(_core.types.memberExpression(_core.types.identifier(target), node.local, _core.types.isStringLiteral(node.local)));\n                } else {}\n              }\n\n              setterBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, hasExportStar ? _core.types.identifier(target) : null, stringSpecifiers));\n            }\n\n            sources.push(_core.types.stringLiteral(specifiers.key));\n            setters.push(_core.types.functionExpression(null, [_core.types.identifier(target)], _core.types.blockStatement(setterBody)));\n          });\n          let moduleName = (0, _helperModuleTransforms.getModuleName)(this.file.opts, options);\n          if (moduleName) moduleName = _core.types.stringLiteral(moduleName);\n          (0, _helperHoistVariables.default)(path, (id, name, hasInit) => {\n            variableIds.push(id);\n\n            if (!hasInit && name in exportMap) {\n              for (const exported of exportMap[name]) {\n                exportNames.push(exported);\n                exportValues.push(scope.buildUndefinedNode());\n              }\n            }\n          });\n\n          if (variableIds.length) {\n            beforeBody.unshift(_core.types.variableDeclaration(\"var\", variableIds.map(id => _core.types.variableDeclarator(id))));\n          }\n\n          if (exportNames.length) {\n            beforeBody.push(...constructExportCall(path, _core.types.identifier(exportIdent), exportNames, exportValues, null, stringSpecifiers));\n          }\n\n          path.traverse(reassignmentVisitor, {\n            exports: exportMap,\n            buildCall: buildExportCall,\n            scope\n          });\n\n          for (const path of removedPaths) {\n            path.remove();\n          }\n\n          let hasTLA = false;\n          path.traverse({\n            AwaitExpression(path) {\n              hasTLA = true;\n              path.stop();\n            },\n\n            Function(path) {\n              path.skip();\n            },\n\n            noScope: true\n          });\n          path.node.body = [buildTemplate({\n            SYSTEM_REGISTER: _core.types.memberExpression(_core.types.identifier(systemGlobal), _core.types.identifier(\"register\")),\n            BEFORE_BODY: beforeBody,\n            MODULE_NAME: moduleName,\n            SETTERS: _core.types.arrayExpression(setters),\n            EXECUTE: _core.types.functionExpression(null, [], _core.types.blockStatement(path.node.body), false, hasTLA),\n            SOURCES: _core.types.arrayExpression(sources),\n            EXPORT_IDENTIFIER: _core.types.identifier(exportIdent),\n            CONTEXT_IDENTIFIER: _core.types.identifier(contextIdent)\n          })];\n        }\n\n      }\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["buildTemplate","template","statement","buildExportAll","MISSING_PLUGIN_WARNING","MISSING_PLUGIN_ERROR","getExportSpecifierName","node","stringSpecifiers","type","name","stringValue","value","add","Error","constructExportCall","path","exportIdent","exportNames","exportValues","exportStarTarget","statements","length","push","t","expressionStatement","callExpression","stringLiteral","objectProperties","i","exportName","exportValue","objectProperty","has","identifier","objectExpression","exportObj","scope","generateUid","variableDeclaration","variableDeclarator","KEY","generateUidIdentifier","EXPORT_OBJ","TARGET","assignmentExpression","memberExpression","api","options","assertVersion","systemGlobal","allowTopLevelThis","reassignmentVisited","WeakSet","reassignmentVisitor","arg","isAssignmentExpression","get","isObjectPattern","isArrayPattern","exprs","Object","keys","getBindingIdentifiers","getBinding","exportedNames","exports","exportedName","buildCall","expression","replaceWith","sequenceExpression","isIdentifier","isPostUpdateExpression","isUpdateExpression","prefix","binaryExpression","operator","unaryExpression","cloneNode","argument","numericLiteral","pre","file","set","visitor","CallExpression","state","isImport","callee","console","warn","contextIdent","MetaProperty","meta","property","ReferencedIdentifier","hasBinding","Program","enter","Set","exit","exportMap","create","modules","beforeBody","setters","sources","variableIds","removedPaths","addExportName","key","val","pushModule","source","specifiers","module","forEach","m","imports","concat","buildExportCall","body","isFunctionDeclaration","isClassDeclaration","id","toExpression","isVariableDeclaration","kind","isImportDeclaration","removeBinding","remove","isExportAllDeclaration","isExportDefaultDeclaration","declar","declaration","buildUndefinedNode","isExportNamedDeclaration","isFunction","isClass","nodes","specifier","local","exported","binding","replaceWithMultiple","setterBody","target","isImportNamespaceSpecifier","isImportDefaultSpecifier","importSpecifier","isImportSpecifier","imported","hasExportStar","isExportSpecifier","isStringLiteral","functionExpression","blockStatement","moduleName","opts","hasInit","unshift","map","traverse","hasTLA","AwaitExpression","stop","Function","skip","noScope","SYSTEM_REGISTER","BEFORE_BODY","MODULE_NAME","SETTERS","arrayExpression","EXECUTE","SOURCES","EXPORT_IDENTIFIER","CONTEXT_IDENTIFIER"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-transform-modules-systemjs\\src\\index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport hoistVariables from \"@babel/helper-hoist-variables\";\nimport { template, types as t } from \"@babel/core\";\nimport { getImportSource } from \"babel-plugin-dynamic-import-node/utils\";\nimport { rewriteThis, getModuleName } from \"@babel/helper-module-transforms\";\nimport type { PluginOptions } from \"@babel/helper-module-transforms\";\nimport { isIdentifierName } from \"@babel/helper-validator-identifier\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\n\nconst buildTemplate = template.statement(`\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: EXECUTE,\n    };\n  });\n`);\n\nconst buildExportAll = template.statement(`\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n`);\n\nconst MISSING_PLUGIN_WARNING = `\\\nWARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n`;\n\nconst MISSING_PLUGIN_ERROR = `\\\nERROR: Dynamic import() transformation must be enabled using the\n       @babel/plugin-proposal-dynamic-import plugin. Babel 8\n       no longer transforms import() without using that plugin.\n`;\n\n//todo: use getExportSpecifierName in `helper-module-transforms` when this library is refactored to NodePath usage.\n\nexport function getExportSpecifierName(\n  node: t.Node,\n  stringSpecifiers: Set<string>,\n): string {\n  if (node.type === \"Identifier\") {\n    return node.name;\n  } else if (node.type === \"StringLiteral\") {\n    const stringValue = node.value;\n    // add specifier value to `stringSpecifiers` only when it can not be converted to an identifier name\n    // i.e In `import { \"foo\" as bar }`\n    // we do not consider `\"foo\"` to be a `stringSpecifier` because we can treat it as\n    // `import { foo as bar }`\n    // This helps minimize the size of `stringSpecifiers` and reduce overhead of checking valid identifier names\n    // when building transpiled code from metadata\n    if (!isIdentifierName(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(\n      `Expected export specifier to be either Identifier or StringLiteral, got ${node.type}`,\n    );\n  }\n}\n\ntype PluginState = {\n  contextIdent: string;\n  // List of names that should only be printed as string literals.\n  // i.e. `import { \"any unicode\" as foo } from \"some-module\"`\n  // `stringSpecifiers` is Set(1) [\"any unicode\"]\n  // In most cases `stringSpecifiers` is an empty Set\n  stringSpecifiers: Set<string>;\n};\n\ntype ModuleMetadata = {\n  key: string;\n  imports: any[];\n  exports: any[];\n};\n\nfunction constructExportCall(\n  path: NodePath<t.Program>,\n  exportIdent: t.Identifier,\n  exportNames: string[],\n  exportValues: t.Expression[],\n  exportStarTarget: t.Identifier | null,\n  stringSpecifiers: Set<string>,\n) {\n  const statements = [];\n  if (!exportStarTarget) {\n    if (exportNames.length === 1) {\n      statements.push(\n        t.expressionStatement(\n          t.callExpression(exportIdent, [\n            t.stringLiteral(exportNames[0]),\n            exportValues[0],\n          ]),\n        ),\n      );\n    } else {\n      const objectProperties = [];\n      for (let i = 0; i < exportNames.length; i++) {\n        const exportName = exportNames[i];\n        const exportValue = exportValues[i];\n        objectProperties.push(\n          t.objectProperty(\n            stringSpecifiers.has(exportName)\n              ? t.stringLiteral(exportName)\n              : t.identifier(exportName),\n            exportValue,\n          ),\n        );\n      }\n      statements.push(\n        t.expressionStatement(\n          t.callExpression(exportIdent, [t.objectExpression(objectProperties)]),\n        ),\n      );\n    }\n  } else {\n    const exportObj = path.scope.generateUid(\"exportObj\");\n\n    statements.push(\n      t.variableDeclaration(\"var\", [\n        t.variableDeclarator(t.identifier(exportObj), t.objectExpression([])),\n      ]),\n    );\n\n    statements.push(\n      buildExportAll({\n        KEY: path.scope.generateUidIdentifier(\"key\"),\n        EXPORT_OBJ: t.identifier(exportObj),\n        TARGET: exportStarTarget,\n      }),\n    );\n\n    for (let i = 0; i < exportNames.length; i++) {\n      const exportName = exportNames[i];\n      const exportValue = exportValues[i];\n\n      statements.push(\n        t.expressionStatement(\n          t.assignmentExpression(\n            \"=\",\n            t.memberExpression(\n              t.identifier(exportObj),\n              t.identifier(exportName),\n            ),\n            exportValue,\n          ),\n        ),\n      );\n    }\n\n    statements.push(\n      t.expressionStatement(\n        t.callExpression(exportIdent, [t.identifier(exportObj)]),\n      ),\n    );\n  }\n  return statements;\n}\n\nexport interface Options extends PluginOptions {\n  allowTopLevelThis?: boolean;\n  systemGlobal?: string;\n}\n\ntype ReassignmentVisitorState = {\n  scope: Scope;\n  exports: any;\n  buildCall: (name: string, value: t.Expression) => t.ExpressionStatement;\n};\n\nexport default declare<PluginState>((api, options: Options) => {\n  api.assertVersion(7);\n\n  const { systemGlobal = \"System\", allowTopLevelThis = false } = options;\n  const reassignmentVisited = new WeakSet();\n\n  const reassignmentVisitor: Visitor<ReassignmentVisitorState> = {\n    \"AssignmentExpression|UpdateExpression\"(\n      path: NodePath<t.AssignmentExpression | t.UpdateExpression>,\n    ) {\n      if (reassignmentVisited.has(path.node)) return;\n      reassignmentVisited.add(path.node);\n\n      const arg = path.isAssignmentExpression()\n        ? path.get(\"left\")\n        : path.get(\"argument\");\n\n      if (arg.isObjectPattern() || arg.isArrayPattern()) {\n        const exprs: t.SequenceExpression[\"expressions\"] = [path.node];\n        for (const name of Object.keys(arg.getBindingIdentifiers())) {\n          if (this.scope.getBinding(name) !== path.scope.getBinding(name)) {\n            return;\n          }\n          const exportedNames = this.exports[name];\n          if (!exportedNames) continue;\n          for (const exportedName of exportedNames) {\n            exprs.push(\n              this.buildCall(exportedName, t.identifier(name)).expression,\n            );\n          }\n        }\n        path.replaceWith(t.sequenceExpression(exprs));\n        return;\n      }\n\n      if (!arg.isIdentifier()) return;\n\n      const name = arg.node.name;\n\n      // redeclared in this scope\n      if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;\n\n      const exportedNames = this.exports[name];\n      if (!exportedNames) return;\n\n      let node: t.Expression = path.node;\n\n      // if it is a non-prefix update expression (x++ etc)\n      // then we must replace with the expression (_export('x', x + 1), x++)\n      // in order to ensure the same update expression value\n      const isPostUpdateExpression = t.isUpdateExpression(node, {\n        prefix: false,\n      });\n      if (isPostUpdateExpression) {\n        node = t.binaryExpression(\n          // @ts-expect-error The operator of a post-update expression must be \"++\" | \"--\"\n          node.operator[0],\n          t.unaryExpression(\n            \"+\",\n            t.cloneNode(\n              // @ts-expect-error node is UpdateExpression\n              node.argument,\n            ),\n          ),\n          t.numericLiteral(1),\n        );\n      }\n\n      for (const exportedName of exportedNames) {\n        node = this.buildCall(exportedName, node).expression;\n      }\n\n      if (isPostUpdateExpression) {\n        node = t.sequenceExpression([node, path.node]);\n      }\n\n      path.replaceWith(node);\n    },\n  };\n\n  return {\n    name: \"transform-modules-systemjs\",\n\n    pre() {\n      this.file.set(\"@babel/plugin-transform-modules-*\", \"systemjs\");\n    },\n\n    visitor: {\n      CallExpression(path, state: PluginState) {\n        if (t.isImport(path.node.callee)) {\n          if (!this.file.has(\"@babel/plugin-proposal-dynamic-import\")) {\n            if (process.env.BABEL_8_BREAKING) {\n              throw new Error(MISSING_PLUGIN_ERROR);\n            } else {\n              console.warn(MISSING_PLUGIN_WARNING);\n            }\n          }\n\n          path.replaceWith(\n            t.callExpression(\n              t.memberExpression(\n                t.identifier(state.contextIdent),\n                t.identifier(\"import\"),\n              ),\n              [getImportSource(t, path.node)],\n            ),\n          );\n        }\n      },\n\n      MetaProperty(path, state: PluginState) {\n        if (\n          path.node.meta.name === \"import\" &&\n          path.node.property.name === \"meta\"\n        ) {\n          path.replaceWith(\n            t.memberExpression(\n              t.identifier(state.contextIdent),\n              t.identifier(\"meta\"),\n            ),\n          );\n        }\n      },\n\n      ReferencedIdentifier(path, state) {\n        if (\n          path.node.name === \"__moduleName\" &&\n          !path.scope.hasBinding(\"__moduleName\")\n        ) {\n          path.replaceWith(\n            t.memberExpression(\n              t.identifier(state.contextIdent),\n              t.identifier(\"id\"),\n            ),\n          );\n        }\n      },\n\n      Program: {\n        enter(path, state) {\n          state.contextIdent = path.scope.generateUid(\"context\");\n          state.stringSpecifiers = new Set();\n          if (!allowTopLevelThis) {\n            rewriteThis(path);\n          }\n        },\n        exit(path, state) {\n          const scope = path.scope;\n          const exportIdent = scope.generateUid(\"export\");\n          const { contextIdent, stringSpecifiers } = state;\n\n          const exportMap: Record<string, string[]> = Object.create(null);\n          const modules: ModuleMetadata[] = [];\n\n          const beforeBody = [];\n          const setters: t.Expression[] = [];\n          const sources: t.StringLiteral[] = [];\n          const variableIds = [];\n          const removedPaths = [];\n\n          function addExportName(key: string, val: string) {\n            exportMap[key] = exportMap[key] || [];\n            exportMap[key].push(val);\n          }\n\n          function pushModule(\n            source: string,\n            key: \"imports\" | \"exports\",\n            specifiers: t.ModuleSpecifier[] | t.ExportAllDeclaration,\n          ) {\n            let module: ModuleMetadata;\n            modules.forEach(function (m) {\n              if (m.key === source) {\n                module = m;\n              }\n            });\n            if (!module) {\n              modules.push(\n                (module = { key: source, imports: [], exports: [] }),\n              );\n            }\n            module[key] = module[key].concat(specifiers);\n          }\n\n          function buildExportCall(name: string, val: t.Expression) {\n            return t.expressionStatement(\n              t.callExpression(t.identifier(exportIdent), [\n                t.stringLiteral(name),\n                val,\n              ]),\n            );\n          }\n\n          const exportNames = [];\n          const exportValues: t.Expression[] = [];\n\n          const body = path.get(\"body\");\n\n          for (const path of body) {\n            if (path.isFunctionDeclaration()) {\n              beforeBody.push(path.node);\n              removedPaths.push(path);\n            } else if (path.isClassDeclaration()) {\n              variableIds.push(t.cloneNode(path.node.id));\n              path.replaceWith(\n                t.expressionStatement(\n                  t.assignmentExpression(\n                    \"=\",\n                    t.cloneNode(path.node.id),\n                    t.toExpression(path.node),\n                  ),\n                ),\n              );\n            } else if (path.isVariableDeclaration()) {\n              // Convert top-level variable declarations to \"var\",\n              // because they must be hoisted\n              path.node.kind = \"var\";\n            } else if (path.isImportDeclaration()) {\n              const source = path.node.source.value;\n              pushModule(source, \"imports\", path.node.specifiers);\n              for (const name of Object.keys(path.getBindingIdentifiers())) {\n                scope.removeBinding(name);\n                variableIds.push(t.identifier(name));\n              }\n              path.remove();\n            } else if (path.isExportAllDeclaration()) {\n              pushModule(path.node.source.value, \"exports\", path.node);\n              path.remove();\n            } else if (path.isExportDefaultDeclaration()) {\n              const declar = path.node.declaration;\n              if (t.isClassDeclaration(declar)) {\n                const id = declar.id;\n                if (id) {\n                  exportNames.push(\"default\");\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(t.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                  path.replaceWith(\n                    t.expressionStatement(\n                      t.assignmentExpression(\n                        \"=\",\n                        t.cloneNode(id),\n                        t.toExpression(declar),\n                      ),\n                    ),\n                  );\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(t.toExpression(declar));\n                  removedPaths.push(path);\n                }\n              } else if (t.isFunctionDeclaration(declar)) {\n                const id = declar.id;\n                if (id) {\n                  beforeBody.push(declar);\n                  exportNames.push(\"default\");\n                  exportValues.push(t.cloneNode(id));\n                  addExportName(id.name, \"default\");\n                } else {\n                  exportNames.push(\"default\");\n                  exportValues.push(t.toExpression(declar));\n                }\n                removedPaths.push(path);\n              } else {\n                // @ts-expect-error TSDeclareFunction is not expected here\n                path.replaceWith(buildExportCall(\"default\", declar));\n              }\n            } else if (path.isExportNamedDeclaration()) {\n              const declar = path.node.declaration;\n\n              if (declar) {\n                path.replaceWith(declar);\n\n                if (t.isFunction(declar)) {\n                  const name = declar.id.name;\n                  addExportName(name, name);\n                  beforeBody.push(declar);\n                  exportNames.push(name);\n                  exportValues.push(t.cloneNode(declar.id));\n                  removedPaths.push(path);\n                } else if (t.isClass(declar)) {\n                  const name = declar.id.name;\n                  exportNames.push(name);\n                  exportValues.push(scope.buildUndefinedNode());\n                  variableIds.push(t.cloneNode(declar.id));\n                  path.replaceWith(\n                    t.expressionStatement(\n                      t.assignmentExpression(\n                        \"=\",\n                        t.cloneNode(declar.id),\n                        t.toExpression(declar),\n                      ),\n                    ),\n                  );\n                  addExportName(name, name);\n                } else {\n                  if (t.isVariableDeclaration(declar)) {\n                    // Convert top-level variable declarations to \"var\",\n                    // because they must be hoisted\n                    declar.kind = \"var\";\n                  }\n                  for (const name of Object.keys(\n                    t.getBindingIdentifiers(declar),\n                  )) {\n                    addExportName(name, name);\n                  }\n                }\n              } else {\n                const specifiers = path.node.specifiers;\n                if (specifiers?.length) {\n                  if (path.node.source) {\n                    pushModule(path.node.source.value, \"exports\", specifiers);\n                    path.remove();\n                  } else {\n                    const nodes = [];\n\n                    for (const specifier of specifiers) {\n                      // @ts-expect-error This isn't an \"export ... from\" declaration\n                      // because path.node.source is falsy, so the local specifier exists.\n                      const { local, exported } = specifier;\n\n                      const binding = scope.getBinding(local.name);\n                      const exportedName = getExportSpecifierName(\n                        exported,\n                        stringSpecifiers,\n                      );\n                      // hoisted function export\n                      if (\n                        binding &&\n                        t.isFunctionDeclaration(binding.path.node)\n                      ) {\n                        exportNames.push(exportedName);\n                        exportValues.push(t.cloneNode(local));\n                      }\n                      // only globals also exported this way\n                      else if (!binding) {\n                        nodes.push(buildExportCall(exportedName, local));\n                      }\n                      addExportName(local.name, exportedName);\n                    }\n\n                    path.replaceWithMultiple(nodes);\n                  }\n                } else {\n                  path.remove();\n                }\n              }\n            }\n          }\n\n          modules.forEach(function (specifiers) {\n            const setterBody = [];\n            const target = scope.generateUid(specifiers.key);\n\n            for (let specifier of specifiers.imports) {\n              if (t.isImportNamespaceSpecifier(specifier)) {\n                setterBody.push(\n                  t.expressionStatement(\n                    t.assignmentExpression(\n                      \"=\",\n                      specifier.local,\n                      t.identifier(target),\n                    ),\n                  ),\n                );\n              } else if (t.isImportDefaultSpecifier(specifier)) {\n                specifier = t.importSpecifier(\n                  specifier.local,\n                  t.identifier(\"default\"),\n                );\n              }\n\n              if (t.isImportSpecifier(specifier)) {\n                const { imported } = specifier;\n                setterBody.push(\n                  t.expressionStatement(\n                    t.assignmentExpression(\n                      \"=\",\n                      specifier.local,\n                      t.memberExpression(\n                        t.identifier(target),\n                        specifier.imported,\n                        /* computed */ imported.type === \"StringLiteral\",\n                      ),\n                    ),\n                  ),\n                );\n              }\n            }\n\n            if (specifiers.exports.length) {\n              const exportNames = [];\n              const exportValues = [];\n              let hasExportStar = false;\n\n              for (const node of specifiers.exports) {\n                if (t.isExportAllDeclaration(node)) {\n                  hasExportStar = true;\n                } else if (t.isExportSpecifier(node)) {\n                  const exportedName = getExportSpecifierName(\n                    node.exported,\n                    stringSpecifiers,\n                  );\n                  exportNames.push(exportedName);\n                  exportValues.push(\n                    t.memberExpression(\n                      t.identifier(target),\n                      node.local,\n                      t.isStringLiteral(node.local),\n                    ),\n                  );\n                } else {\n                  // todo\n                }\n              }\n\n              setterBody.push(\n                ...constructExportCall(\n                  path,\n                  t.identifier(exportIdent),\n                  exportNames,\n                  exportValues,\n                  hasExportStar ? t.identifier(target) : null,\n                  stringSpecifiers,\n                ),\n              );\n            }\n\n            sources.push(t.stringLiteral(specifiers.key));\n            setters.push(\n              t.functionExpression(\n                null,\n                [t.identifier(target)],\n                t.blockStatement(setterBody),\n              ),\n            );\n          });\n\n          let moduleName = getModuleName(this.file.opts, options);\n          // @ts-expect-error todo(flow->ts): do not reuse variables\n          if (moduleName) moduleName = t.stringLiteral(moduleName);\n\n          hoistVariables(path, (id, name, hasInit) => {\n            variableIds.push(id);\n            if (!hasInit && name in exportMap) {\n              for (const exported of exportMap[name]) {\n                exportNames.push(exported);\n                exportValues.push(scope.buildUndefinedNode());\n              }\n            }\n          });\n\n          if (variableIds.length) {\n            beforeBody.unshift(\n              t.variableDeclaration(\n                \"var\",\n                variableIds.map(id => t.variableDeclarator(id)),\n              ),\n            );\n          }\n\n          if (exportNames.length) {\n            beforeBody.push(\n              ...constructExportCall(\n                path,\n                t.identifier(exportIdent),\n                exportNames,\n                exportValues,\n                null,\n                stringSpecifiers,\n              ),\n            );\n          }\n\n          path.traverse(reassignmentVisitor, {\n            exports: exportMap,\n            buildCall: buildExportCall,\n            scope,\n          });\n\n          for (const path of removedPaths) {\n            path.remove();\n          }\n\n          let hasTLA = false;\n          path.traverse({\n            AwaitExpression(path) {\n              hasTLA = true;\n              path.stop();\n            },\n            Function(path) {\n              path.skip();\n            },\n            // @ts-expect-error - todo: add noScope to type definitions\n            noScope: true,\n          });\n\n          path.node.body = [\n            buildTemplate({\n              SYSTEM_REGISTER: t.memberExpression(\n                t.identifier(systemGlobal),\n                t.identifier(\"register\"),\n              ),\n              BEFORE_BODY: beforeBody,\n              MODULE_NAME: moduleName,\n              SETTERS: t.arrayExpression(setters),\n              EXECUTE: t.functionExpression(\n                null,\n                [],\n                t.blockStatement(path.node.body),\n                false,\n                hasTLA,\n              ),\n              SOURCES: t.arrayExpression(sources),\n              EXPORT_IDENTIFIER: t.identifier(exportIdent),\n              CONTEXT_IDENTIFIER: t.identifier(contextIdent),\n            }),\n          ];\n        },\n      },\n    },\n  };\n});\n"]},"metadata":{},"sourceType":"script"}