{"ast":null,"code":"const topologicalSort = require(\"./topologicalSort\");\n\nconst matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/;\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/;\nconst VISITED_MARKER = 1;\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\n\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + \"_\" + \"siblings\";\n  const visitedId = parentId + \"_\" + importId;\n\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) {\n      visited[siblingsId] = [];\n    }\n\n    const siblings = visited[siblingsId];\n\n    if (Array.isArray(graph[importId])) {\n      graph[importId] = graph[importId].concat(siblings);\n    } else {\n      graph[importId] = siblings.slice();\n    }\n\n    visited[visitedId] = VISITED_MARKER;\n    siblings.push(importId);\n  }\n}\n\nmodule.exports = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let importIndex = 0;\n  const createImportedName = typeof options.createImportedName !== \"function\" ? (importName\n  /*, path*/\n  ) => `i__imported_${importName.replace(/\\W/g, \"_\")}_${importIndex++}` : options.createImportedName;\n  const failOnWrongOrder = options.failOnWrongOrder;\n  return {\n    postcssPlugin: \"postcss-modules-extract-imports\",\n\n    prepare() {\n      const graph = {};\n      const visited = {};\n      const existingImports = {};\n      const importDecls = {};\n      const imports = {};\n      return {\n        Once(root, postcss) {\n          // Check the existing imports order and save refs\n          root.walkRules(rule => {\n            const matches = icssImport.exec(rule.selector);\n\n            if (matches) {\n              const [,\n              /*match*/\n              doubleQuotePath, singleQuotePath] = matches;\n              const importPath = doubleQuotePath || singleQuotePath;\n              addImportToGraph(importPath, \"root\", graph, visited);\n              existingImports[importPath] = rule;\n            }\n          });\n          root.walkDecls(/^composes$/, declaration => {\n            const matches = declaration.value.match(matchImports);\n\n            if (!matches) {\n              return;\n            }\n\n            let tmpSymbols;\n            let [,\n            /*match*/\n            symbols, doubleQuotePath, singleQuotePath, global] = matches;\n\n            if (global) {\n              // Composing globals simply means changing these classes to wrap them in global(name)\n              tmpSymbols = symbols.split(/\\s+/).map(s => `global(${s})`);\n            } else {\n              const importPath = doubleQuotePath || singleQuotePath;\n              let parent = declaration.parent;\n              let parentIndexes = \"\";\n\n              while (parent.type !== \"root\") {\n                parentIndexes = parent.parent.index(parent) + \"_\" + parentIndexes;\n                parent = parent.parent;\n              }\n\n              const {\n                selector\n              } = declaration.parent;\n              const parentRule = `_${parentIndexes}${selector}`;\n              addImportToGraph(importPath, parentRule, graph, visited);\n              importDecls[importPath] = declaration;\n              imports[importPath] = imports[importPath] || {};\n              tmpSymbols = symbols.split(/\\s+/).map(s => {\n                if (!imports[importPath][s]) {\n                  imports[importPath][s] = createImportedName(s, importPath);\n                }\n\n                return imports[importPath][s];\n              });\n            }\n\n            declaration.value = tmpSymbols.join(\" \");\n          });\n          const importsOrder = topologicalSort(graph, failOnWrongOrder);\n\n          if (importsOrder instanceof Error) {\n            const importPath = importsOrder.nodes.find(importPath => // eslint-disable-next-line no-prototype-builtins\n            importDecls.hasOwnProperty(importPath));\n            const decl = importDecls[importPath];\n            throw decl.error(\"Failed to resolve order of composed modules \" + importsOrder.nodes.map(importPath => \"`\" + importPath + \"`\").join(\", \") + \".\", {\n              plugin: \"postcss-modules-extract-imports\",\n              word: \"composes\"\n            });\n          }\n\n          let lastImportRule;\n          importsOrder.forEach(path => {\n            const importedSymbols = imports[path];\n            let rule = existingImports[path];\n\n            if (!rule && importedSymbols) {\n              rule = postcss.rule({\n                selector: `:import(\"${path}\")`,\n                raws: {\n                  after: \"\\n\"\n                }\n              });\n\n              if (lastImportRule) {\n                root.insertAfter(lastImportRule, rule);\n              } else {\n                root.prepend(rule);\n              }\n            }\n\n            lastImportRule = rule;\n\n            if (!importedSymbols) {\n              return;\n            }\n\n            Object.keys(importedSymbols).forEach(importedSymbol => {\n              rule.append(postcss.decl({\n                value: importedSymbol,\n                prop: importedSymbols[importedSymbol],\n                raws: {\n                  before: \"\\n  \"\n                }\n              }));\n            });\n          });\n        }\n\n      };\n    }\n\n  };\n};\n\nmodule.exports.postcss = true;","map":{"version":3,"names":["topologicalSort","require","matchImports","icssImport","VISITED_MARKER","addImportToGraph","importId","parentId","graph","visited","siblingsId","visitedId","Array","isArray","siblings","concat","slice","push","module","exports","options","importIndex","createImportedName","importName","replace","failOnWrongOrder","postcssPlugin","prepare","existingImports","importDecls","imports","Once","root","postcss","walkRules","rule","matches","exec","selector","doubleQuotePath","singleQuotePath","importPath","walkDecls","declaration","value","match","tmpSymbols","symbols","global","split","map","s","parent","parentIndexes","type","index","parentRule","join","importsOrder","Error","nodes","find","hasOwnProperty","decl","error","plugin","word","lastImportRule","forEach","path","importedSymbols","raws","after","insertAfter","prepend","Object","keys","importedSymbol","append","prop","before"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-modules-extract-imports/src/index.js"],"sourcesContent":["const topologicalSort = require(\"./topologicalSort\");\n\nconst matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/;\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/;\n\nconst VISITED_MARKER = 1;\n\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + \"_\" + \"siblings\";\n  const visitedId = parentId + \"_\" + importId;\n\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) {\n      visited[siblingsId] = [];\n    }\n\n    const siblings = visited[siblingsId];\n\n    if (Array.isArray(graph[importId])) {\n      graph[importId] = graph[importId].concat(siblings);\n    } else {\n      graph[importId] = siblings.slice();\n    }\n\n    visited[visitedId] = VISITED_MARKER;\n\n    siblings.push(importId);\n  }\n}\n\nmodule.exports = (options = {}) => {\n  let importIndex = 0;\n  const createImportedName =\n    typeof options.createImportedName !== \"function\"\n      ? (importName /*, path*/) =>\n          `i__imported_${importName.replace(/\\W/g, \"_\")}_${importIndex++}`\n      : options.createImportedName;\n  const failOnWrongOrder = options.failOnWrongOrder;\n\n  return {\n    postcssPlugin: \"postcss-modules-extract-imports\",\n    prepare() {\n      const graph = {};\n      const visited = {};\n      const existingImports = {};\n      const importDecls = {};\n      const imports = {};\n\n      return {\n        Once(root, postcss) {\n          // Check the existing imports order and save refs\n          root.walkRules((rule) => {\n            const matches = icssImport.exec(rule.selector);\n\n            if (matches) {\n              const [, /*match*/ doubleQuotePath, singleQuotePath] = matches;\n              const importPath = doubleQuotePath || singleQuotePath;\n\n              addImportToGraph(importPath, \"root\", graph, visited);\n\n              existingImports[importPath] = rule;\n            }\n          });\n\n          root.walkDecls(/^composes$/, (declaration) => {\n            const matches = declaration.value.match(matchImports);\n\n            if (!matches) {\n              return;\n            }\n\n            let tmpSymbols;\n            let [\n              ,\n              /*match*/ symbols,\n              doubleQuotePath,\n              singleQuotePath,\n              global,\n            ] = matches;\n\n            if (global) {\n              // Composing globals simply means changing these classes to wrap them in global(name)\n              tmpSymbols = symbols.split(/\\s+/).map((s) => `global(${s})`);\n            } else {\n              const importPath = doubleQuotePath || singleQuotePath;\n\n              let parent = declaration.parent;\n              let parentIndexes = \"\";\n\n              while (parent.type !== \"root\") {\n                parentIndexes =\n                  parent.parent.index(parent) + \"_\" + parentIndexes;\n                parent = parent.parent;\n              }\n\n              const { selector } = declaration.parent;\n              const parentRule = `_${parentIndexes}${selector}`;\n\n              addImportToGraph(importPath, parentRule, graph, visited);\n\n              importDecls[importPath] = declaration;\n              imports[importPath] = imports[importPath] || {};\n\n              tmpSymbols = symbols.split(/\\s+/).map((s) => {\n                if (!imports[importPath][s]) {\n                  imports[importPath][s] = createImportedName(s, importPath);\n                }\n\n                return imports[importPath][s];\n              });\n            }\n\n            declaration.value = tmpSymbols.join(\" \");\n          });\n\n          const importsOrder = topologicalSort(graph, failOnWrongOrder);\n\n          if (importsOrder instanceof Error) {\n            const importPath = importsOrder.nodes.find((importPath) =>\n              // eslint-disable-next-line no-prototype-builtins\n              importDecls.hasOwnProperty(importPath)\n            );\n            const decl = importDecls[importPath];\n\n            throw decl.error(\n              \"Failed to resolve order of composed modules \" +\n                importsOrder.nodes\n                  .map((importPath) => \"`\" + importPath + \"`\")\n                  .join(\", \") +\n                \".\",\n              {\n                plugin: \"postcss-modules-extract-imports\",\n                word: \"composes\",\n              }\n            );\n          }\n\n          let lastImportRule;\n\n          importsOrder.forEach((path) => {\n            const importedSymbols = imports[path];\n            let rule = existingImports[path];\n\n            if (!rule && importedSymbols) {\n              rule = postcss.rule({\n                selector: `:import(\"${path}\")`,\n                raws: { after: \"\\n\" },\n              });\n\n              if (lastImportRule) {\n                root.insertAfter(lastImportRule, rule);\n              } else {\n                root.prepend(rule);\n              }\n            }\n\n            lastImportRule = rule;\n\n            if (!importedSymbols) {\n              return;\n            }\n\n            Object.keys(importedSymbols).forEach((importedSymbol) => {\n              rule.append(\n                postcss.decl({\n                  value: importedSymbol,\n                  prop: importedSymbols[importedSymbol],\n                  raws: { before: \"\\n  \" },\n                })\n              );\n            });\n          });\n        },\n      };\n    },\n  };\n};\n\nmodule.exports.postcss = true;\n"],"mappings":"AAAA,MAAMA,eAAe,GAAGC,OAAO,CAAC,mBAAD,CAA/B;;AAEA,MAAMC,YAAY,GAAG,mDAArB;AACA,MAAMC,UAAU,GAAG,qCAAnB;AAEA,MAAMC,cAAc,GAAG,CAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,gBAAT,CAA0BC,QAA1B,EAAoCC,QAApC,EAA8CC,KAA9C,EAAqDC,OAArD,EAA8D;EAC5D,MAAMC,UAAU,GAAGH,QAAQ,GAAG,GAAX,GAAiB,UAApC;EACA,MAAMI,SAAS,GAAGJ,QAAQ,GAAG,GAAX,GAAiBD,QAAnC;;EAEA,IAAIG,OAAO,CAACE,SAAD,CAAP,KAAuBP,cAA3B,EAA2C;IACzC,IAAI,CAACQ,KAAK,CAACC,OAAN,CAAcJ,OAAO,CAACC,UAAD,CAArB,CAAL,EAAyC;MACvCD,OAAO,CAACC,UAAD,CAAP,GAAsB,EAAtB;IACD;;IAED,MAAMI,QAAQ,GAAGL,OAAO,CAACC,UAAD,CAAxB;;IAEA,IAAIE,KAAK,CAACC,OAAN,CAAcL,KAAK,CAACF,QAAD,CAAnB,CAAJ,EAAoC;MAClCE,KAAK,CAACF,QAAD,CAAL,GAAkBE,KAAK,CAACF,QAAD,CAAL,CAAgBS,MAAhB,CAAuBD,QAAvB,CAAlB;IACD,CAFD,MAEO;MACLN,KAAK,CAACF,QAAD,CAAL,GAAkBQ,QAAQ,CAACE,KAAT,EAAlB;IACD;;IAEDP,OAAO,CAACE,SAAD,CAAP,GAAqBP,cAArB;IAEAU,QAAQ,CAACG,IAAT,CAAcX,QAAd;EACD;AACF;;AAEDY,MAAM,CAACC,OAAP,GAAiB,YAAkB;EAAA,IAAjBC,OAAiB,uEAAP,EAAO;EACjC,IAAIC,WAAW,GAAG,CAAlB;EACA,MAAMC,kBAAkB,GACtB,OAAOF,OAAO,CAACE,kBAAf,KAAsC,UAAtC,GACI,CAACC;EAAW;EAAZ,KACG,eAAcA,UAAU,CAACC,OAAX,CAAmB,KAAnB,EAA0B,GAA1B,CAA+B,IAAGH,WAAW,EAAG,EAFrE,GAGID,OAAO,CAACE,kBAJd;EAKA,MAAMG,gBAAgB,GAAGL,OAAO,CAACK,gBAAjC;EAEA,OAAO;IACLC,aAAa,EAAE,iCADV;;IAELC,OAAO,GAAG;MACR,MAAMnB,KAAK,GAAG,EAAd;MACA,MAAMC,OAAO,GAAG,EAAhB;MACA,MAAMmB,eAAe,GAAG,EAAxB;MACA,MAAMC,WAAW,GAAG,EAApB;MACA,MAAMC,OAAO,GAAG,EAAhB;MAEA,OAAO;QACLC,IAAI,CAACC,IAAD,EAAOC,OAAP,EAAgB;UAClB;UACAD,IAAI,CAACE,SAAL,CAAgBC,IAAD,IAAU;YACvB,MAAMC,OAAO,GAAGjC,UAAU,CAACkC,IAAX,CAAgBF,IAAI,CAACG,QAArB,CAAhB;;YAEA,IAAIF,OAAJ,EAAa;cACX,MAAM;cAAG;cAAUG,eAAb,EAA8BC,eAA9B,IAAiDJ,OAAvD;cACA,MAAMK,UAAU,GAAGF,eAAe,IAAIC,eAAtC;cAEAnC,gBAAgB,CAACoC,UAAD,EAAa,MAAb,EAAqBjC,KAArB,EAA4BC,OAA5B,CAAhB;cAEAmB,eAAe,CAACa,UAAD,CAAf,GAA8BN,IAA9B;YACD;UACF,CAXD;UAaAH,IAAI,CAACU,SAAL,CAAe,YAAf,EAA8BC,WAAD,IAAiB;YAC5C,MAAMP,OAAO,GAAGO,WAAW,CAACC,KAAZ,CAAkBC,KAAlB,CAAwB3C,YAAxB,CAAhB;;YAEA,IAAI,CAACkC,OAAL,EAAc;cACZ;YACD;;YAED,IAAIU,UAAJ;YACA,IAAI;YAEF;YAAUC,OAFR,EAGFR,eAHE,EAIFC,eAJE,EAKFQ,MALE,IAMAZ,OANJ;;YAQA,IAAIY,MAAJ,EAAY;cACV;cACAF,UAAU,GAAGC,OAAO,CAACE,KAAR,CAAc,KAAd,EAAqBC,GAArB,CAA0BC,CAAD,IAAQ,UAASA,CAAE,GAA5C,CAAb;YACD,CAHD,MAGO;cACL,MAAMV,UAAU,GAAGF,eAAe,IAAIC,eAAtC;cAEA,IAAIY,MAAM,GAAGT,WAAW,CAACS,MAAzB;cACA,IAAIC,aAAa,GAAG,EAApB;;cAEA,OAAOD,MAAM,CAACE,IAAP,KAAgB,MAAvB,EAA+B;gBAC7BD,aAAa,GACXD,MAAM,CAACA,MAAP,CAAcG,KAAd,CAAoBH,MAApB,IAA8B,GAA9B,GAAoCC,aADtC;gBAEAD,MAAM,GAAGA,MAAM,CAACA,MAAhB;cACD;;cAED,MAAM;gBAAEd;cAAF,IAAeK,WAAW,CAACS,MAAjC;cACA,MAAMI,UAAU,GAAI,IAAGH,aAAc,GAAEf,QAAS,EAAhD;cAEAjC,gBAAgB,CAACoC,UAAD,EAAae,UAAb,EAAyBhD,KAAzB,EAAgCC,OAAhC,CAAhB;cAEAoB,WAAW,CAACY,UAAD,CAAX,GAA0BE,WAA1B;cACAb,OAAO,CAACW,UAAD,CAAP,GAAsBX,OAAO,CAACW,UAAD,CAAP,IAAuB,EAA7C;cAEAK,UAAU,GAAGC,OAAO,CAACE,KAAR,CAAc,KAAd,EAAqBC,GAArB,CAA0BC,CAAD,IAAO;gBAC3C,IAAI,CAACrB,OAAO,CAACW,UAAD,CAAP,CAAoBU,CAApB,CAAL,EAA6B;kBAC3BrB,OAAO,CAACW,UAAD,CAAP,CAAoBU,CAApB,IAAyB7B,kBAAkB,CAAC6B,CAAD,EAAIV,UAAJ,CAA3C;gBACD;;gBAED,OAAOX,OAAO,CAACW,UAAD,CAAP,CAAoBU,CAApB,CAAP;cACD,CANY,CAAb;YAOD;;YAEDR,WAAW,CAACC,KAAZ,GAAoBE,UAAU,CAACW,IAAX,CAAgB,GAAhB,CAApB;UACD,CAjDD;UAmDA,MAAMC,YAAY,GAAG1D,eAAe,CAACQ,KAAD,EAAQiB,gBAAR,CAApC;;UAEA,IAAIiC,YAAY,YAAYC,KAA5B,EAAmC;YACjC,MAAMlB,UAAU,GAAGiB,YAAY,CAACE,KAAb,CAAmBC,IAAnB,CAAyBpB,UAAD,IACzC;YACAZ,WAAW,CAACiC,cAAZ,CAA2BrB,UAA3B,CAFiB,CAAnB;YAIA,MAAMsB,IAAI,GAAGlC,WAAW,CAACY,UAAD,CAAxB;YAEA,MAAMsB,IAAI,CAACC,KAAL,CACJ,iDACEN,YAAY,CAACE,KAAb,CACGV,GADH,CACQT,UAAD,IAAgB,MAAMA,UAAN,GAAmB,GAD1C,EAEGgB,IAFH,CAEQ,IAFR,CADF,GAIE,GALE,EAMJ;cACEQ,MAAM,EAAE,iCADV;cAEEC,IAAI,EAAE;YAFR,CANI,CAAN;UAWD;;UAED,IAAIC,cAAJ;UAEAT,YAAY,CAACU,OAAb,CAAsBC,IAAD,IAAU;YAC7B,MAAMC,eAAe,GAAGxC,OAAO,CAACuC,IAAD,CAA/B;YACA,IAAIlC,IAAI,GAAGP,eAAe,CAACyC,IAAD,CAA1B;;YAEA,IAAI,CAAClC,IAAD,IAASmC,eAAb,EAA8B;cAC5BnC,IAAI,GAAGF,OAAO,CAACE,IAAR,CAAa;gBAClBG,QAAQ,EAAG,YAAW+B,IAAK,IADT;gBAElBE,IAAI,EAAE;kBAAEC,KAAK,EAAE;gBAAT;cAFY,CAAb,CAAP;;cAKA,IAAIL,cAAJ,EAAoB;gBAClBnC,IAAI,CAACyC,WAAL,CAAiBN,cAAjB,EAAiChC,IAAjC;cACD,CAFD,MAEO;gBACLH,IAAI,CAAC0C,OAAL,CAAavC,IAAb;cACD;YACF;;YAEDgC,cAAc,GAAGhC,IAAjB;;YAEA,IAAI,CAACmC,eAAL,EAAsB;cACpB;YACD;;YAEDK,MAAM,CAACC,IAAP,CAAYN,eAAZ,EAA6BF,OAA7B,CAAsCS,cAAD,IAAoB;cACvD1C,IAAI,CAAC2C,MAAL,CACE7C,OAAO,CAAC8B,IAAR,CAAa;gBACXnB,KAAK,EAAEiC,cADI;gBAEXE,IAAI,EAAET,eAAe,CAACO,cAAD,CAFV;gBAGXN,IAAI,EAAE;kBAAES,MAAM,EAAE;gBAAV;cAHK,CAAb,CADF;YAOD,CARD;UASD,CAhCD;QAiCD;;MA5HI,CAAP;IA8HD;;EAvII,CAAP;AAyID,CAlJD;;AAoJA9D,MAAM,CAACC,OAAP,CAAec,OAAf,GAAyB,IAAzB"},"metadata":{},"sourceType":"script"}