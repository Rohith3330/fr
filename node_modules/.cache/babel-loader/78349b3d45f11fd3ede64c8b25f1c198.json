{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.merge = merge;\nexports.verify = verify;\n\nvar virtualTypes = require(\"./path/lib/virtual-types\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  DEPRECATED_KEYS,\n  FLIPPED_ALIAS_KEYS,\n  TYPES\n} = _t;\n\nfunction isVirtualType(type) {\n  return type in virtualTypes;\n}\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    if (!isVirtualType(nodeType)) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(nodeType, fns[type]);\n    }\n\n    delete visitor[nodeType];\n    const types = virtualTypes[nodeType];\n\n    if (types !== null) {\n      for (const type of types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors) {\n  let states = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let wrapper = arguments.length > 2 ? arguments[2] : undefined;\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] || (rootVisitor[type] = {});\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(nodeType, fn) {\n  const newFn = function (path) {\n    if (path[`is${nodeType}`]()) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","map":{"version":3,"mappings":"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","names":["DEPRECATED_KEYS","FLIPPED_ALIAS_KEYS","TYPES","isVirtualType","type","virtualTypes","explode","visitor","_exploded","nodeType","Object","keys","shouldIgnoreKey","parts","split","length","fns","part","verify","__esModule","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","types","mergePair","aliases","deprecatedKey","console","trace","alias","existing","_verified","Error","validateVisitorMethods","indexOf","visitors","visitorKey","path","val","concat","fn","TypeError","merge","states","wrapper","rootVisitor","i","state","visitorType","wrapWithStateOrWrapper","nodeVisitor","oldVisitor","newVisitor","key","Array","isArray","map","newFn","call","toString","obj","enter","exit","apply","arguments","dest","src"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\visitors.ts"],"sourcesContent":["import * as virtualTypes from \"./path/lib/virtual-types\";\nimport { DEPRECATED_KEYS, FLIPPED_ALIAS_KEYS, TYPES } from \"@babel/types\";\nimport type { NodePath, Visitor } from \"./index\";\n\ntype VIRTUAL_TYPES = keyof typeof virtualTypes;\nfunction isVirtualType(type: string): type is VIRTUAL_TYPES {\n  return type in virtualTypes;\n}\n\n/**\n * explode() will take a visitor object with all of the various shorthands\n * that we support, and validates & normalizes it into a common format, ready\n * to be used in traversal\n *\n * The various shorthands are:\n * * `Identifier() { ... }` -> `Identifier: { enter() { ... } }`\n * * `\"Identifier|NumericLiteral\": { ... }` -> `Identifier: { ... }, NumericLiteral: { ... }`\n * * Aliases in `@babel/types`: e.g. `Property: { ... }` -> `ObjectProperty: { ... }, ClassProperty: { ... }`\n *\n * Other normalizations are:\n * * Visitors of virtual types are wrapped, so that they are only visited when\n *   their dynamic check passes\n * * `enter` and `exit` functions are wrapped in arrays, to ease merging of\n *   visitors\n */\nexport function explode(visitor: Visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  // normalise pipes\n  for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    const parts: Array<string> = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      // @ts-expect-error part will be verified by `verify` later\n      visitor[part] = fns;\n    }\n  }\n\n  // verify data structure\n  verify(visitor);\n\n  // make sure there's no __esModule type since this is because we're using loose mode\n  // and it sets __esModule to be enumerable on all modules :(\n  // @ts-expect-error ESModule interop\n  delete visitor.__esModule;\n\n  // ensure visitors are objects\n  ensureEntranceObjects(visitor);\n\n  // ensure enter/exit callbacks are arrays\n  ensureCallbackArrays(visitor);\n\n  // add type wrappers\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (!isVirtualType(nodeType)) continue;\n\n    // wrap all the functions\n    const fns = visitor[nodeType];\n    for (const type of Object.keys(fns)) {\n      // @ts-expect-error manipulating visitors\n      fns[type] = wrapCheck(nodeType, fns[type]);\n    }\n\n    // clear it from the visitor\n    delete visitor[nodeType];\n\n    const types = virtualTypes[nodeType];\n    if (types !== null) {\n      for (const type of types) {\n        // merge the visitor if necessary or just put it back in\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          // @ts-expect-error Expression produces too complex union\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  // add aliases\n  for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    const fns = visitor[nodeType];\n\n    let aliases = FLIPPED_ALIAS_KEYS[nodeType];\n\n    const deprecatedKey = DEPRECATED_KEYS[nodeType];\n    if (deprecatedKey) {\n      console.trace(\n        `Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`,\n      );\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n\n    // clear it from the visitor\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        // @ts-expect-error Expression produces a union type that is too complex to represent.\n        visitor[alias] = { ...fns };\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    ensureCallbackArrays(\n      // @ts-expect-error nodeType must present in visitor after previous validations\n      visitor[nodeType],\n    );\n  }\n\n  return visitor;\n}\n\nexport function verify(visitor: Visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\n      \"You passed `traverse()` a function when it expected a visitor object, \" +\n        \"are you sure you didn't mean `{ enter: Function }`?\",\n    );\n  }\n\n  for (const nodeType of Object.keys(visitor) as (keyof Visitor)[]) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (TYPES.indexOf(nodeType) < 0) {\n      throw new Error(\n        `You gave us a visitor for the node type ${nodeType} but it's not a valid type`,\n      );\n    }\n\n    const visitors = visitor[nodeType];\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          // verify that it just contains functions\n          validateVisitorMethods(\n            `${nodeType}.${visitorKey}`,\n            visitors[visitorKey],\n          );\n        } else {\n          throw new Error(\n            \"You passed `traverse()` a visitor object with the property \" +\n              `${nodeType} that has the invalid property ${visitorKey}`,\n          );\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(\n  path: string,\n  val: any,\n): asserts val is Function | Function[] {\n  const fns = [].concat(val);\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(\n        `Non-function found defined in ${path} with type ${typeof fn}`,\n      );\n    }\n  }\n}\n\nexport function merge<State>(visitors: Visitor<State>[]): Visitor<State>;\nexport function merge(\n  visitors: Visitor<unknown>[],\n  states?: any[],\n  wrapper?: Function | null,\n): Visitor<unknown>;\nexport function merge(\n  visitors: any[],\n  states: any[] = [],\n  wrapper?: Function | null,\n) {\n  const rootVisitor: Visitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n\n    explode(visitor);\n\n    for (const type of Object.keys(visitor) as (keyof Visitor)[]) {\n      let visitorType = visitor[type];\n\n      // if we have state or wrapper then overload the callbacks to take it\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      // @ts-expect-error: Expression produces a union type that is too complex to represent.\n      const nodeVisitor = (rootVisitor[type] ||= {});\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper<State>(\n  oldVisitor: Visitor<State>,\n  state: State,\n  wrapper?: Function | null,\n) {\n  const newVisitor: Visitor = {};\n\n  for (const key of Object.keys(oldVisitor) as (keyof Visitor<State>)[]) {\n    let fns = oldVisitor[key];\n\n    // not an enter/exit array of callbacks\n    if (!Array.isArray(fns)) continue;\n\n    // @ts-expect-error manipulating visitors\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path: NodePath) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        // @ts-expect-error Fixme: document state.key\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      // Override toString in case this function is printed, we want to print the wrapped function, same as we do in `wrapCheck`\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n\n    // @ts-expect-error: Expression produces a union type that is too complex to represent.\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj: Visitor) {\n  for (const key of Object.keys(obj) as (keyof Visitor)[]) {\n    if (shouldIgnoreKey(key)) continue;\n\n    const fns = obj[key];\n    if (typeof fns === \"function\") {\n      // @ts-expect-error: Expression produces a union type that is too complex to represent.\n      obj[key] = { enter: fns };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj: Visitor) {\n  // @ts-expect-error normalizing enter property\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  // @ts-expect-error normalizing exit property\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(nodeType: VIRTUAL_TYPES, fn: Function) {\n  const newFn = function (this: unknown, path: NodePath) {\n    if (path[`is${nodeType}`]()) {\n      return fn.apply(this, arguments);\n    }\n  };\n  newFn.toString = () => fn.toString();\n  return newFn;\n}\n\nfunction shouldIgnoreKey(\n  key: string,\n): key is\n  | \"enter\"\n  | \"exit\"\n  | \"shouldSkip\"\n  | \"denylist\"\n  | \"noScope\"\n  | \"skipKeys\"\n  | \"blacklist\" {\n  // internal/hidden key\n  if (key[0] === \"_\") return true;\n\n  // ignore function keys\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  // ignore other options\n  if (\n    key === \"denylist\" ||\n    key === \"noScope\" ||\n    key === \"skipKeys\" ||\n    // TODO: Remove in Babel 8\n    key === \"blacklist\"\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest: any, src: any) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}