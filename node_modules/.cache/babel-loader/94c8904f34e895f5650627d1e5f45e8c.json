{"ast":null,"code":"/**\n * @fileoverview Enforce or disallow spaces inside of curly braces in JSX attributes.\n * @author Jamund Ferguson\n * @author Brandyn Bennett\n * @author Michael Ficarra\n * @author Vignesh Anand\n * @author Jamund Ferguson\n * @author Yannick Croissant\n * @author Erik Wendel\n */\n'use strict';\n\nconst has = require('object.hasown/polyfill')();\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst SPACING = {\n  always: 'always',\n  never: 'never'\n};\nconst SPACING_VALUES = [SPACING.always, SPACING.never];\nconst messages = {\n  noNewlineAfter: 'There should be no newline after \\'{{token}}\\'',\n  noNewlineBefore: 'There should be no newline before \\'{{token}}\\'',\n  noSpaceAfter: 'There should be no space after \\'{{token}}\\'',\n  noSpaceBefore: 'There should be no space before \\'{{token}}\\'',\n  spaceNeededAfter: 'A space is required after \\'{{token}}\\'',\n  spaceNeededBefore: 'A space is required before \\'{{token}}\\''\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce or disallow spaces inside of curly braces in JSX attributes and expressions',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-curly-spacing')\n    },\n    fixable: 'code',\n    messages,\n    schema: {\n      definitions: {\n        basicConfig: {\n          type: 'object',\n          properties: {\n            when: {\n              enum: SPACING_VALUES\n            },\n            allowMultiline: {\n              type: 'boolean'\n            },\n            spacing: {\n              type: 'object',\n              properties: {\n                objectLiterals: {\n                  enum: SPACING_VALUES\n                }\n              }\n            }\n          }\n        },\n        basicConfigOrBoolean: {\n          oneOf: [{\n            $ref: '#/definitions/basicConfig'\n          }, {\n            type: 'boolean'\n          }]\n        }\n      },\n      type: 'array',\n      items: [{\n        oneOf: [{\n          allOf: [{\n            $ref: '#/definitions/basicConfig'\n          }, {\n            type: 'object',\n            properties: {\n              attributes: {\n                $ref: '#/definitions/basicConfigOrBoolean'\n              },\n              children: {\n                $ref: '#/definitions/basicConfigOrBoolean'\n              }\n            }\n          }]\n        }, {\n          enum: SPACING_VALUES\n        }]\n      }, {\n        type: 'object',\n        properties: {\n          allowMultiline: {\n            type: 'boolean'\n          },\n          spacing: {\n            type: 'object',\n            properties: {\n              objectLiterals: {\n                enum: SPACING_VALUES\n              }\n            }\n          }\n        },\n        additionalProperties: false\n      }]\n    }\n  },\n\n  create(context) {\n    function normalizeConfig(configOrTrue, defaults, lastPass) {\n      const config = configOrTrue === true ? {} : configOrTrue;\n      const when = config.when || defaults.when;\n      const allowMultiline = has(config, 'allowMultiline') ? config.allowMultiline : defaults.allowMultiline;\n      const spacing = config.spacing || {};\n      let objectLiteralSpaces = spacing.objectLiterals || defaults.objectLiteralSpaces;\n\n      if (lastPass) {\n        // On the final pass assign the values that should be derived from others if they are still undefined\n        objectLiteralSpaces = objectLiteralSpaces || when;\n      }\n\n      return {\n        when,\n        allowMultiline,\n        objectLiteralSpaces\n      };\n    }\n\n    const DEFAULT_WHEN = SPACING.never;\n    const DEFAULT_ALLOW_MULTILINE = true;\n    const DEFAULT_ATTRIBUTES = true;\n    const DEFAULT_CHILDREN = false;\n    let originalConfig = context.options[0] || {};\n\n    if (SPACING_VALUES.indexOf(originalConfig) !== -1) {\n      originalConfig = Object.assign({\n        when: context.options[0]\n      }, context.options[1]);\n    }\n\n    const defaultConfig = normalizeConfig(originalConfig, {\n      when: DEFAULT_WHEN,\n      allowMultiline: DEFAULT_ALLOW_MULTILINE\n    });\n    const attributes = has(originalConfig, 'attributes') ? originalConfig.attributes : DEFAULT_ATTRIBUTES;\n    const attributesConfig = attributes ? normalizeConfig(attributes, defaultConfig, true) : null;\n    const children = has(originalConfig, 'children') ? originalConfig.children : DEFAULT_CHILDREN;\n    const childrenConfig = children ? normalizeConfig(children, defaultConfig, true) : null; // --------------------------------------------------------------------------\n    // Helpers\n    // --------------------------------------------------------------------------\n\n    /**\n     * Determines whether two adjacent tokens have a newline between them.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not there is a newline between the tokens.\n     */\n\n    function isMultiline(left, right) {\n      return left.loc.end.line !== right.loc.start.line;\n    }\n    /**\n     * Trims text of whitespace between two ranges\n     * @param {Fixer} fixer - the eslint fixer object\n     * @param {number} fromLoc - the start location\n     * @param {number} toLoc - the end location\n     * @param {string} mode - either 'start' or 'end'\n     * @param {string=} spacing - a spacing value that will optionally add a space to the removed text\n     * @returns {Object|*|{range, text}}\n     */\n\n\n    function fixByTrimmingWhitespace(fixer, fromLoc, toLoc, mode, spacing) {\n      let replacementText = context.getSourceCode().text.slice(fromLoc, toLoc);\n\n      if (mode === 'start') {\n        replacementText = replacementText.replace(/^\\s+/gm, '');\n      } else {\n        replacementText = replacementText.replace(/\\s+$/gm, '');\n      }\n\n      if (spacing === SPACING.always) {\n        if (mode === 'start') {\n          replacementText += ' ';\n        } else {\n          replacementText = ` ${replacementText}`;\n        }\n      }\n\n      return fixer.replaceTextRange([fromLoc, toLoc], replacementText);\n    }\n    /**\n    * Reports that there shouldn't be a newline after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @param {string} spacing\n    * @returns {void}\n    */\n\n\n    function reportNoBeginningNewline(node, token, spacing) {\n      report(context, messages.noNewlineAfter, 'noNewlineAfter', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value\n        },\n\n        fix(fixer) {\n          const nextToken = context.getSourceCode().getTokenAfter(token);\n          return fixByTrimmingWhitespace(fixer, token.range[1], nextToken.range[0], 'start', spacing);\n        }\n\n      });\n    }\n    /**\n    * Reports that there shouldn't be a newline before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @param {string} spacing\n    * @returns {void}\n    */\n\n\n    function reportNoEndingNewline(node, token, spacing) {\n      report(context, messages.noNewlineBefore, 'noNewlineBefore', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value\n        },\n\n        fix(fixer) {\n          const previousToken = context.getSourceCode().getTokenBefore(token);\n          return fixByTrimmingWhitespace(fixer, previousToken.range[1], token.range[0], 'end', spacing);\n        }\n\n      });\n    }\n    /**\n    * Reports that there shouldn't be a space after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n\n\n    function reportNoBeginningSpace(node, token) {\n      report(context, messages.noSpaceAfter, 'noSpaceAfter', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value\n        },\n\n        fix(fixer) {\n          const sourceCode = context.getSourceCode();\n          const nextToken = sourceCode.getTokenAfter(token);\n          let nextComment; // eslint >=4.x\n\n          if (sourceCode.getCommentsAfter) {\n            nextComment = sourceCode.getCommentsAfter(token); // eslint 3.x\n          } else {\n            const potentialComment = sourceCode.getTokenAfter(token, {\n              includeComments: true\n            });\n            nextComment = nextToken === potentialComment ? [] : [potentialComment];\n          } // Take comments into consideration to narrow the fix range to what is actually affected. (See #1414)\n\n\n          if (nextComment.length > 0) {\n            return fixByTrimmingWhitespace(fixer, token.range[1], Math.min(nextToken.range[0], nextComment[0].range[0]), 'start');\n          }\n\n          return fixByTrimmingWhitespace(fixer, token.range[1], nextToken.range[0], 'start');\n        }\n\n      });\n    }\n    /**\n    * Reports that there shouldn't be a space before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n\n\n    function reportNoEndingSpace(node, token) {\n      report(context, messages.noSpaceBefore, 'noSpaceBefore', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value\n        },\n\n        fix(fixer) {\n          const sourceCode = context.getSourceCode();\n          const previousToken = sourceCode.getTokenBefore(token);\n          let previousComment; // eslint >=4.x\n\n          if (sourceCode.getCommentsBefore) {\n            previousComment = sourceCode.getCommentsBefore(token); // eslint 3.x\n          } else {\n            const potentialComment = sourceCode.getTokenBefore(token, {\n              includeComments: true\n            });\n            previousComment = previousToken === potentialComment ? [] : [potentialComment];\n          } // Take comments into consideration to narrow the fix range to what is actually affected. (See #1414)\n\n\n          if (previousComment.length > 0) {\n            return fixByTrimmingWhitespace(fixer, Math.max(previousToken.range[1], previousComment[0].range[1]), token.range[0], 'end');\n          }\n\n          return fixByTrimmingWhitespace(fixer, previousToken.range[1], token.range[0], 'end');\n        }\n\n      });\n    }\n    /**\n    * Reports that there should be a space after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n\n\n    function reportRequiredBeginningSpace(node, token) {\n      report(context, messages.spaceNeededAfter, 'spaceNeededAfter', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value\n        },\n\n        fix(fixer) {\n          return fixer.insertTextAfter(token, ' ');\n        }\n\n      });\n    }\n    /**\n    * Reports that there should be a space before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n\n\n    function reportRequiredEndingSpace(node, token) {\n      report(context, messages.spaceNeededBefore, 'spaceNeededBefore', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value\n        },\n\n        fix(fixer) {\n          return fixer.insertTextBefore(token, ' ');\n        }\n\n      });\n    }\n    /**\n     * Determines if spacing in curly braces is valid.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     */\n\n\n    function validateBraceSpacing(node) {\n      let config;\n\n      switch (node.parent.type) {\n        case 'JSXAttribute':\n        case 'JSXOpeningElement':\n          config = attributesConfig;\n          break;\n\n        case 'JSXElement':\n        case 'JSXFragment':\n          config = childrenConfig;\n          break;\n\n        default:\n          return;\n      }\n\n      if (config === null) {\n        return;\n      }\n\n      const sourceCode = context.getSourceCode();\n      const first = sourceCode.getFirstToken(node);\n      const last = sourceCode.getLastToken(node);\n      let second = sourceCode.getTokenAfter(first, {\n        includeComments: true\n      });\n      let penultimate = sourceCode.getTokenBefore(last, {\n        includeComments: true\n      });\n\n      if (!second) {\n        second = sourceCode.getTokenAfter(first);\n        const leadingComments = sourceCode.getNodeByRangeIndex(second.range[0]).leadingComments;\n        second = leadingComments ? leadingComments[0] : second;\n      }\n\n      if (!penultimate) {\n        penultimate = sourceCode.getTokenBefore(last);\n        const trailingComments = sourceCode.getNodeByRangeIndex(penultimate.range[0]).trailingComments;\n        penultimate = trailingComments ? trailingComments[trailingComments.length - 1] : penultimate;\n      }\n\n      const isObjectLiteral = first.value === second.value;\n      const spacing = isObjectLiteral ? config.objectLiteralSpaces : config.when;\n\n      if (spacing === SPACING.always) {\n        if (!sourceCode.isSpaceBetweenTokens(first, second)) {\n          reportRequiredBeginningSpace(node, first);\n        } else if (!config.allowMultiline && isMultiline(first, second)) {\n          reportNoBeginningNewline(node, first, spacing);\n        }\n\n        if (!sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n          reportRequiredEndingSpace(node, last);\n        } else if (!config.allowMultiline && isMultiline(penultimate, last)) {\n          reportNoEndingNewline(node, last, spacing);\n        }\n      } else if (spacing === SPACING.never) {\n        if (isMultiline(first, second)) {\n          if (!config.allowMultiline) {\n            reportNoBeginningNewline(node, first, spacing);\n          }\n        } else if (sourceCode.isSpaceBetweenTokens(first, second)) {\n          reportNoBeginningSpace(node, first);\n        }\n\n        if (isMultiline(penultimate, last)) {\n          if (!config.allowMultiline) {\n            reportNoEndingNewline(node, last, spacing);\n          }\n        } else if (sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n          reportNoEndingSpace(node, last);\n        }\n      }\n    } // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n\n    return {\n      JSXExpressionContainer: validateBraceSpacing,\n      JSXSpreadAttribute: validateBraceSpacing\n    };\n  }\n\n};","map":{"version":3,"names":["has","require","docsUrl","report","SPACING","always","never","SPACING_VALUES","messages","noNewlineAfter","noNewlineBefore","noSpaceAfter","noSpaceBefore","spaceNeededAfter","spaceNeededBefore","module","exports","meta","docs","description","category","recommended","url","fixable","schema","definitions","basicConfig","type","properties","when","enum","allowMultiline","spacing","objectLiterals","basicConfigOrBoolean","oneOf","$ref","items","allOf","attributes","children","additionalProperties","create","context","normalizeConfig","configOrTrue","defaults","lastPass","config","objectLiteralSpaces","DEFAULT_WHEN","DEFAULT_ALLOW_MULTILINE","DEFAULT_ATTRIBUTES","DEFAULT_CHILDREN","originalConfig","options","indexOf","Object","assign","defaultConfig","attributesConfig","childrenConfig","isMultiline","left","right","loc","end","line","start","fixByTrimmingWhitespace","fixer","fromLoc","toLoc","mode","replacementText","getSourceCode","text","slice","replace","replaceTextRange","reportNoBeginningNewline","node","token","data","value","fix","nextToken","getTokenAfter","range","reportNoEndingNewline","previousToken","getTokenBefore","reportNoBeginningSpace","sourceCode","nextComment","getCommentsAfter","potentialComment","includeComments","length","Math","min","reportNoEndingSpace","previousComment","getCommentsBefore","max","reportRequiredBeginningSpace","insertTextAfter","reportRequiredEndingSpace","insertTextBefore","validateBraceSpacing","parent","first","getFirstToken","last","getLastToken","second","penultimate","leadingComments","getNodeByRangeIndex","trailingComments","isObjectLiteral","isSpaceBetweenTokens","JSXExpressionContainer","JSXSpreadAttribute"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-curly-spacing.js"],"sourcesContent":["/**\n * @fileoverview Enforce or disallow spaces inside of curly braces in JSX attributes.\n * @author Jamund Ferguson\n * @author Brandyn Bennett\n * @author Michael Ficarra\n * @author Vignesh Anand\n * @author Jamund Ferguson\n * @author Yannick Croissant\n * @author Erik Wendel\n */\n\n'use strict';\n\nconst has = require('object.hasown/polyfill')();\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst SPACING = {\n  always: 'always',\n  never: 'never',\n};\nconst SPACING_VALUES = [SPACING.always, SPACING.never];\n\nconst messages = {\n  noNewlineAfter: 'There should be no newline after \\'{{token}}\\'',\n  noNewlineBefore: 'There should be no newline before \\'{{token}}\\'',\n  noSpaceAfter: 'There should be no space after \\'{{token}}\\'',\n  noSpaceBefore: 'There should be no space before \\'{{token}}\\'',\n  spaceNeededAfter: 'A space is required after \\'{{token}}\\'',\n  spaceNeededBefore: 'A space is required before \\'{{token}}\\'',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce or disallow spaces inside of curly braces in JSX attributes and expressions',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-curly-spacing'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: {\n      definitions: {\n        basicConfig: {\n          type: 'object',\n          properties: {\n            when: {\n              enum: SPACING_VALUES,\n            },\n            allowMultiline: {\n              type: 'boolean',\n            },\n            spacing: {\n              type: 'object',\n              properties: {\n                objectLiterals: {\n                  enum: SPACING_VALUES,\n                },\n              },\n            },\n          },\n        },\n        basicConfigOrBoolean: {\n          oneOf: [{\n            $ref: '#/definitions/basicConfig',\n          }, {\n            type: 'boolean',\n          }],\n        },\n      },\n      type: 'array',\n      items: [{\n        oneOf: [{\n          allOf: [{\n            $ref: '#/definitions/basicConfig',\n          }, {\n            type: 'object',\n            properties: {\n              attributes: {\n                $ref: '#/definitions/basicConfigOrBoolean',\n              },\n              children: {\n                $ref: '#/definitions/basicConfigOrBoolean',\n              },\n            },\n          }],\n        }, {\n          enum: SPACING_VALUES,\n        }],\n      }, {\n        type: 'object',\n        properties: {\n          allowMultiline: {\n            type: 'boolean',\n          },\n          spacing: {\n            type: 'object',\n            properties: {\n              objectLiterals: {\n                enum: SPACING_VALUES,\n              },\n            },\n          },\n        },\n        additionalProperties: false,\n      }],\n    },\n  },\n\n  create(context) {\n    function normalizeConfig(configOrTrue, defaults, lastPass) {\n      const config = configOrTrue === true ? {} : configOrTrue;\n      const when = config.when || defaults.when;\n      const allowMultiline = has(config, 'allowMultiline') ? config.allowMultiline : defaults.allowMultiline;\n      const spacing = config.spacing || {};\n      let objectLiteralSpaces = spacing.objectLiterals || defaults.objectLiteralSpaces;\n      if (lastPass) {\n        // On the final pass assign the values that should be derived from others if they are still undefined\n        objectLiteralSpaces = objectLiteralSpaces || when;\n      }\n\n      return {\n        when,\n        allowMultiline,\n        objectLiteralSpaces,\n      };\n    }\n\n    const DEFAULT_WHEN = SPACING.never;\n    const DEFAULT_ALLOW_MULTILINE = true;\n    const DEFAULT_ATTRIBUTES = true;\n    const DEFAULT_CHILDREN = false;\n\n    let originalConfig = context.options[0] || {};\n    if (SPACING_VALUES.indexOf(originalConfig) !== -1) {\n      originalConfig = Object.assign({ when: context.options[0] }, context.options[1]);\n    }\n    const defaultConfig = normalizeConfig(originalConfig, {\n      when: DEFAULT_WHEN,\n      allowMultiline: DEFAULT_ALLOW_MULTILINE,\n    });\n    const attributes = has(originalConfig, 'attributes') ? originalConfig.attributes : DEFAULT_ATTRIBUTES;\n    const attributesConfig = attributes ? normalizeConfig(attributes, defaultConfig, true) : null;\n    const children = has(originalConfig, 'children') ? originalConfig.children : DEFAULT_CHILDREN;\n    const childrenConfig = children ? normalizeConfig(children, defaultConfig, true) : null;\n\n    // --------------------------------------------------------------------------\n    // Helpers\n    // --------------------------------------------------------------------------\n\n    /**\n     * Determines whether two adjacent tokens have a newline between them.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not there is a newline between the tokens.\n     */\n    function isMultiline(left, right) {\n      return left.loc.end.line !== right.loc.start.line;\n    }\n\n    /**\n     * Trims text of whitespace between two ranges\n     * @param {Fixer} fixer - the eslint fixer object\n     * @param {number} fromLoc - the start location\n     * @param {number} toLoc - the end location\n     * @param {string} mode - either 'start' or 'end'\n     * @param {string=} spacing - a spacing value that will optionally add a space to the removed text\n     * @returns {Object|*|{range, text}}\n     */\n    function fixByTrimmingWhitespace(fixer, fromLoc, toLoc, mode, spacing) {\n      let replacementText = context.getSourceCode().text.slice(fromLoc, toLoc);\n      if (mode === 'start') {\n        replacementText = replacementText.replace(/^\\s+/gm, '');\n      } else {\n        replacementText = replacementText.replace(/\\s+$/gm, '');\n      }\n      if (spacing === SPACING.always) {\n        if (mode === 'start') {\n          replacementText += ' ';\n        } else {\n          replacementText = ` ${replacementText}`;\n        }\n      }\n      return fixer.replaceTextRange([fromLoc, toLoc], replacementText);\n    }\n\n    /**\n    * Reports that there shouldn't be a newline after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @param {string} spacing\n    * @returns {void}\n    */\n    function reportNoBeginningNewline(node, token, spacing) {\n      report(context, messages.noNewlineAfter, 'noNewlineAfter', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value,\n        },\n        fix(fixer) {\n          const nextToken = context.getSourceCode().getTokenAfter(token);\n          return fixByTrimmingWhitespace(fixer, token.range[1], nextToken.range[0], 'start', spacing);\n        },\n      });\n    }\n\n    /**\n    * Reports that there shouldn't be a newline before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @param {string} spacing\n    * @returns {void}\n    */\n    function reportNoEndingNewline(node, token, spacing) {\n      report(context, messages.noNewlineBefore, 'noNewlineBefore', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value,\n        },\n        fix(fixer) {\n          const previousToken = context.getSourceCode().getTokenBefore(token);\n          return fixByTrimmingWhitespace(fixer, previousToken.range[1], token.range[0], 'end', spacing);\n        },\n      });\n    }\n\n    /**\n    * Reports that there shouldn't be a space after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportNoBeginningSpace(node, token) {\n      report(context, messages.noSpaceAfter, 'noSpaceAfter', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value,\n        },\n        fix(fixer) {\n          const sourceCode = context.getSourceCode();\n          const nextToken = sourceCode.getTokenAfter(token);\n          let nextComment;\n\n          // eslint >=4.x\n          if (sourceCode.getCommentsAfter) {\n            nextComment = sourceCode.getCommentsAfter(token);\n          // eslint 3.x\n          } else {\n            const potentialComment = sourceCode.getTokenAfter(token, { includeComments: true });\n            nextComment = nextToken === potentialComment ? [] : [potentialComment];\n          }\n\n          // Take comments into consideration to narrow the fix range to what is actually affected. (See #1414)\n          if (nextComment.length > 0) {\n            return fixByTrimmingWhitespace(fixer, token.range[1], Math.min(nextToken.range[0], nextComment[0].range[0]), 'start');\n          }\n\n          return fixByTrimmingWhitespace(fixer, token.range[1], nextToken.range[0], 'start');\n        },\n      });\n    }\n\n    /**\n    * Reports that there shouldn't be a space before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportNoEndingSpace(node, token) {\n      report(context, messages.noSpaceBefore, 'noSpaceBefore', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value,\n        },\n        fix(fixer) {\n          const sourceCode = context.getSourceCode();\n          const previousToken = sourceCode.getTokenBefore(token);\n          let previousComment;\n\n          // eslint >=4.x\n          if (sourceCode.getCommentsBefore) {\n            previousComment = sourceCode.getCommentsBefore(token);\n          // eslint 3.x\n          } else {\n            const potentialComment = sourceCode.getTokenBefore(token, { includeComments: true });\n            previousComment = previousToken === potentialComment ? [] : [potentialComment];\n          }\n\n          // Take comments into consideration to narrow the fix range to what is actually affected. (See #1414)\n          if (previousComment.length > 0) {\n            return fixByTrimmingWhitespace(fixer, Math.max(previousToken.range[1], previousComment[0].range[1]), token.range[0], 'end');\n          }\n\n          return fixByTrimmingWhitespace(fixer, previousToken.range[1], token.range[0], 'end');\n        },\n      });\n    }\n\n    /**\n    * Reports that there should be a space after the first token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportRequiredBeginningSpace(node, token) {\n      report(context, messages.spaceNeededAfter, 'spaceNeededAfter', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value,\n        },\n        fix(fixer) {\n          return fixer.insertTextAfter(token, ' ');\n        },\n      });\n    }\n\n    /**\n    * Reports that there should be a space before the last token\n    * @param {ASTNode} node - The node to report in the event of an error.\n    * @param {Token} token - The token to use for the report.\n    * @returns {void}\n    */\n    function reportRequiredEndingSpace(node, token) {\n      report(context, messages.spaceNeededBefore, 'spaceNeededBefore', {\n        node,\n        loc: token.loc.start,\n        data: {\n          token: token.value,\n        },\n        fix(fixer) {\n          return fixer.insertTextBefore(token, ' ');\n        },\n      });\n    }\n\n    /**\n     * Determines if spacing in curly braces is valid.\n     * @param {ASTNode} node The AST node to check.\n     * @returns {void}\n     */\n    function validateBraceSpacing(node) {\n      let config;\n      switch (node.parent.type) {\n        case 'JSXAttribute':\n        case 'JSXOpeningElement':\n          config = attributesConfig;\n          break;\n\n        case 'JSXElement':\n        case 'JSXFragment':\n          config = childrenConfig;\n          break;\n\n        default:\n          return;\n      }\n      if (config === null) {\n        return;\n      }\n\n      const sourceCode = context.getSourceCode();\n      const first = sourceCode.getFirstToken(node);\n      const last = sourceCode.getLastToken(node);\n      let second = sourceCode.getTokenAfter(first, { includeComments: true });\n      let penultimate = sourceCode.getTokenBefore(last, { includeComments: true });\n\n      if (!second) {\n        second = sourceCode.getTokenAfter(first);\n        const leadingComments = sourceCode.getNodeByRangeIndex(second.range[0]).leadingComments;\n        second = leadingComments ? leadingComments[0] : second;\n      }\n      if (!penultimate) {\n        penultimate = sourceCode.getTokenBefore(last);\n        const trailingComments = sourceCode.getNodeByRangeIndex(penultimate.range[0]).trailingComments;\n        penultimate = trailingComments ? trailingComments[trailingComments.length - 1] : penultimate;\n      }\n\n      const isObjectLiteral = first.value === second.value;\n      const spacing = isObjectLiteral ? config.objectLiteralSpaces : config.when;\n      if (spacing === SPACING.always) {\n        if (!sourceCode.isSpaceBetweenTokens(first, second)) {\n          reportRequiredBeginningSpace(node, first);\n        } else if (!config.allowMultiline && isMultiline(first, second)) {\n          reportNoBeginningNewline(node, first, spacing);\n        }\n        if (!sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n          reportRequiredEndingSpace(node, last);\n        } else if (!config.allowMultiline && isMultiline(penultimate, last)) {\n          reportNoEndingNewline(node, last, spacing);\n        }\n      } else if (spacing === SPACING.never) {\n        if (isMultiline(first, second)) {\n          if (!config.allowMultiline) {\n            reportNoBeginningNewline(node, first, spacing);\n          }\n        } else if (sourceCode.isSpaceBetweenTokens(first, second)) {\n          reportNoBeginningSpace(node, first);\n        }\n        if (isMultiline(penultimate, last)) {\n          if (!config.allowMultiline) {\n            reportNoEndingNewline(node, last, spacing);\n          }\n        } else if (sourceCode.isSpaceBetweenTokens(penultimate, last)) {\n          reportNoEndingSpace(node, last);\n        }\n      }\n    }\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    return {\n      JSXExpressionContainer: validateBraceSpacing,\n      JSXSpreadAttribute: validateBraceSpacing,\n    };\n  },\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,wBAAD,CAAP,EAAZ;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,iBAAD,CAAvB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,gBAAD,CAAtB,C,CAEA;AACA;AACA;;;AAEA,MAAMG,OAAO,GAAG;EACdC,MAAM,EAAE,QADM;EAEdC,KAAK,EAAE;AAFO,CAAhB;AAIA,MAAMC,cAAc,GAAG,CAACH,OAAO,CAACC,MAAT,EAAiBD,OAAO,CAACE,KAAzB,CAAvB;AAEA,MAAME,QAAQ,GAAG;EACfC,cAAc,EAAE,gDADD;EAEfC,eAAe,EAAE,iDAFF;EAGfC,YAAY,EAAE,8CAHC;EAIfC,aAAa,EAAE,+CAJA;EAKfC,gBAAgB,EAAE,yCALH;EAMfC,iBAAiB,EAAE;AANJ,CAAjB;AASAC,MAAM,CAACC,OAAP,GAAiB;EACfC,IAAI,EAAE;IACJC,IAAI,EAAE;MACJC,WAAW,EAAE,qFADT;MAEJC,QAAQ,EAAE,kBAFN;MAGJC,WAAW,EAAE,KAHT;MAIJC,GAAG,EAAEpB,OAAO,CAAC,mBAAD;IAJR,CADF;IAOJqB,OAAO,EAAE,MAPL;IASJf,QATI;IAWJgB,MAAM,EAAE;MACNC,WAAW,EAAE;QACXC,WAAW,EAAE;UACXC,IAAI,EAAE,QADK;UAEXC,UAAU,EAAE;YACVC,IAAI,EAAE;cACJC,IAAI,EAAEvB;YADF,CADI;YAIVwB,cAAc,EAAE;cACdJ,IAAI,EAAE;YADQ,CAJN;YAOVK,OAAO,EAAE;cACPL,IAAI,EAAE,QADC;cAEPC,UAAU,EAAE;gBACVK,cAAc,EAAE;kBACdH,IAAI,EAAEvB;gBADQ;cADN;YAFL;UAPC;QAFD,CADF;QAoBX2B,oBAAoB,EAAE;UACpBC,KAAK,EAAE,CAAC;YACNC,IAAI,EAAE;UADA,CAAD,EAEJ;YACDT,IAAI,EAAE;UADL,CAFI;QADa;MApBX,CADP;MA6BNA,IAAI,EAAE,OA7BA;MA8BNU,KAAK,EAAE,CAAC;QACNF,KAAK,EAAE,CAAC;UACNG,KAAK,EAAE,CAAC;YACNF,IAAI,EAAE;UADA,CAAD,EAEJ;YACDT,IAAI,EAAE,QADL;YAEDC,UAAU,EAAE;cACVW,UAAU,EAAE;gBACVH,IAAI,EAAE;cADI,CADF;cAIVI,QAAQ,EAAE;gBACRJ,IAAI,EAAE;cADE;YAJA;UAFX,CAFI;QADD,CAAD,EAcJ;UACDN,IAAI,EAAEvB;QADL,CAdI;MADD,CAAD,EAkBJ;QACDoB,IAAI,EAAE,QADL;QAEDC,UAAU,EAAE;UACVG,cAAc,EAAE;YACdJ,IAAI,EAAE;UADQ,CADN;UAIVK,OAAO,EAAE;YACPL,IAAI,EAAE,QADC;YAEPC,UAAU,EAAE;cACVK,cAAc,EAAE;gBACdH,IAAI,EAAEvB;cADQ;YADN;UAFL;QAJC,CAFX;QAeDkC,oBAAoB,EAAE;MAfrB,CAlBI;IA9BD;EAXJ,CADS;;EAgFfC,MAAM,CAACC,OAAD,EAAU;IACd,SAASC,eAAT,CAAyBC,YAAzB,EAAuCC,QAAvC,EAAiDC,QAAjD,EAA2D;MACzD,MAAMC,MAAM,GAAGH,YAAY,KAAK,IAAjB,GAAwB,EAAxB,GAA6BA,YAA5C;MACA,MAAMhB,IAAI,GAAGmB,MAAM,CAACnB,IAAP,IAAeiB,QAAQ,CAACjB,IAArC;MACA,MAAME,cAAc,GAAG/B,GAAG,CAACgD,MAAD,EAAS,gBAAT,CAAH,GAAgCA,MAAM,CAACjB,cAAvC,GAAwDe,QAAQ,CAACf,cAAxF;MACA,MAAMC,OAAO,GAAGgB,MAAM,CAAChB,OAAP,IAAkB,EAAlC;MACA,IAAIiB,mBAAmB,GAAGjB,OAAO,CAACC,cAAR,IAA0Ba,QAAQ,CAACG,mBAA7D;;MACA,IAAIF,QAAJ,EAAc;QACZ;QACAE,mBAAmB,GAAGA,mBAAmB,IAAIpB,IAA7C;MACD;;MAED,OAAO;QACLA,IADK;QAELE,cAFK;QAGLkB;MAHK,CAAP;IAKD;;IAED,MAAMC,YAAY,GAAG9C,OAAO,CAACE,KAA7B;IACA,MAAM6C,uBAAuB,GAAG,IAAhC;IACA,MAAMC,kBAAkB,GAAG,IAA3B;IACA,MAAMC,gBAAgB,GAAG,KAAzB;IAEA,IAAIC,cAAc,GAAGX,OAAO,CAACY,OAAR,CAAgB,CAAhB,KAAsB,EAA3C;;IACA,IAAIhD,cAAc,CAACiD,OAAf,CAAuBF,cAAvB,MAA2C,CAAC,CAAhD,EAAmD;MACjDA,cAAc,GAAGG,MAAM,CAACC,MAAP,CAAc;QAAE7B,IAAI,EAAEc,OAAO,CAACY,OAAR,CAAgB,CAAhB;MAAR,CAAd,EAA4CZ,OAAO,CAACY,OAAR,CAAgB,CAAhB,CAA5C,CAAjB;IACD;;IACD,MAAMI,aAAa,GAAGf,eAAe,CAACU,cAAD,EAAiB;MACpDzB,IAAI,EAAEqB,YAD8C;MAEpDnB,cAAc,EAAEoB;IAFoC,CAAjB,CAArC;IAIA,MAAMZ,UAAU,GAAGvC,GAAG,CAACsD,cAAD,EAAiB,YAAjB,CAAH,GAAoCA,cAAc,CAACf,UAAnD,GAAgEa,kBAAnF;IACA,MAAMQ,gBAAgB,GAAGrB,UAAU,GAAGK,eAAe,CAACL,UAAD,EAAaoB,aAAb,EAA4B,IAA5B,CAAlB,GAAsD,IAAzF;IACA,MAAMnB,QAAQ,GAAGxC,GAAG,CAACsD,cAAD,EAAiB,UAAjB,CAAH,GAAkCA,cAAc,CAACd,QAAjD,GAA4Da,gBAA7E;IACA,MAAMQ,cAAc,GAAGrB,QAAQ,GAAGI,eAAe,CAACJ,QAAD,EAAWmB,aAAX,EAA0B,IAA1B,CAAlB,GAAoD,IAAnF,CAnCc,CAqCd;IACA;IACA;;IAEA;AACJ;AACA;AACA;AACA;AACA;;IACI,SAASG,WAAT,CAAqBC,IAArB,EAA2BC,KAA3B,EAAkC;MAChC,OAAOD,IAAI,CAACE,GAAL,CAASC,GAAT,CAAaC,IAAb,KAAsBH,KAAK,CAACC,GAAN,CAAUG,KAAV,CAAgBD,IAA7C;IACD;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACI,SAASE,uBAAT,CAAiCC,KAAjC,EAAwCC,OAAxC,EAAiDC,KAAjD,EAAwDC,IAAxD,EAA8DzC,OAA9D,EAAuE;MACrE,IAAI0C,eAAe,GAAG/B,OAAO,CAACgC,aAAR,GAAwBC,IAAxB,CAA6BC,KAA7B,CAAmCN,OAAnC,EAA4CC,KAA5C,CAAtB;;MACA,IAAIC,IAAI,KAAK,OAAb,EAAsB;QACpBC,eAAe,GAAGA,eAAe,CAACI,OAAhB,CAAwB,QAAxB,EAAkC,EAAlC,CAAlB;MACD,CAFD,MAEO;QACLJ,eAAe,GAAGA,eAAe,CAACI,OAAhB,CAAwB,QAAxB,EAAkC,EAAlC,CAAlB;MACD;;MACD,IAAI9C,OAAO,KAAK5B,OAAO,CAACC,MAAxB,EAAgC;QAC9B,IAAIoE,IAAI,KAAK,OAAb,EAAsB;UACpBC,eAAe,IAAI,GAAnB;QACD,CAFD,MAEO;UACLA,eAAe,GAAI,IAAGA,eAAgB,EAAtC;QACD;MACF;;MACD,OAAOJ,KAAK,CAACS,gBAAN,CAAuB,CAACR,OAAD,EAAUC,KAAV,CAAvB,EAAyCE,eAAzC,CAAP;IACD;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;IACI,SAASM,wBAAT,CAAkCC,IAAlC,EAAwCC,KAAxC,EAA+ClD,OAA/C,EAAwD;MACtD7B,MAAM,CAACwC,OAAD,EAAUnC,QAAQ,CAACC,cAAnB,EAAmC,gBAAnC,EAAqD;QACzDwE,IADyD;QAEzDhB,GAAG,EAAEiB,KAAK,CAACjB,GAAN,CAAUG,KAF0C;QAGzDe,IAAI,EAAE;UACJD,KAAK,EAAEA,KAAK,CAACE;QADT,CAHmD;;QAMzDC,GAAG,CAACf,KAAD,EAAQ;UACT,MAAMgB,SAAS,GAAG3C,OAAO,CAACgC,aAAR,GAAwBY,aAAxB,CAAsCL,KAAtC,CAAlB;UACA,OAAOb,uBAAuB,CAACC,KAAD,EAAQY,KAAK,CAACM,KAAN,CAAY,CAAZ,CAAR,EAAwBF,SAAS,CAACE,KAAV,CAAgB,CAAhB,CAAxB,EAA4C,OAA5C,EAAqDxD,OAArD,CAA9B;QACD;;MATwD,CAArD,CAAN;IAWD;IAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;IACI,SAASyD,qBAAT,CAA+BR,IAA/B,EAAqCC,KAArC,EAA4ClD,OAA5C,EAAqD;MACnD7B,MAAM,CAACwC,OAAD,EAAUnC,QAAQ,CAACE,eAAnB,EAAoC,iBAApC,EAAuD;QAC3DuE,IAD2D;QAE3DhB,GAAG,EAAEiB,KAAK,CAACjB,GAAN,CAAUG,KAF4C;QAG3De,IAAI,EAAE;UACJD,KAAK,EAAEA,KAAK,CAACE;QADT,CAHqD;;QAM3DC,GAAG,CAACf,KAAD,EAAQ;UACT,MAAMoB,aAAa,GAAG/C,OAAO,CAACgC,aAAR,GAAwBgB,cAAxB,CAAuCT,KAAvC,CAAtB;UACA,OAAOb,uBAAuB,CAACC,KAAD,EAAQoB,aAAa,CAACF,KAAd,CAAoB,CAApB,CAAR,EAAgCN,KAAK,CAACM,KAAN,CAAY,CAAZ,CAAhC,EAAgD,KAAhD,EAAuDxD,OAAvD,CAA9B;QACD;;MAT0D,CAAvD,CAAN;IAWD;IAED;AACJ;AACA;AACA;AACA;AACA;;;IACI,SAAS4D,sBAAT,CAAgCX,IAAhC,EAAsCC,KAAtC,EAA6C;MAC3C/E,MAAM,CAACwC,OAAD,EAAUnC,QAAQ,CAACG,YAAnB,EAAiC,cAAjC,EAAiD;QACrDsE,IADqD;QAErDhB,GAAG,EAAEiB,KAAK,CAACjB,GAAN,CAAUG,KAFsC;QAGrDe,IAAI,EAAE;UACJD,KAAK,EAAEA,KAAK,CAACE;QADT,CAH+C;;QAMrDC,GAAG,CAACf,KAAD,EAAQ;UACT,MAAMuB,UAAU,GAAGlD,OAAO,CAACgC,aAAR,EAAnB;UACA,MAAMW,SAAS,GAAGO,UAAU,CAACN,aAAX,CAAyBL,KAAzB,CAAlB;UACA,IAAIY,WAAJ,CAHS,CAKT;;UACA,IAAID,UAAU,CAACE,gBAAf,EAAiC;YAC/BD,WAAW,GAAGD,UAAU,CAACE,gBAAX,CAA4Bb,KAA5B,CAAd,CAD+B,CAEjC;UACC,CAHD,MAGO;YACL,MAAMc,gBAAgB,GAAGH,UAAU,CAACN,aAAX,CAAyBL,KAAzB,EAAgC;cAAEe,eAAe,EAAE;YAAnB,CAAhC,CAAzB;YACAH,WAAW,GAAGR,SAAS,KAAKU,gBAAd,GAAiC,EAAjC,GAAsC,CAACA,gBAAD,CAApD;UACD,CAZQ,CAcT;;;UACA,IAAIF,WAAW,CAACI,MAAZ,GAAqB,CAAzB,EAA4B;YAC1B,OAAO7B,uBAAuB,CAACC,KAAD,EAAQY,KAAK,CAACM,KAAN,CAAY,CAAZ,CAAR,EAAwBW,IAAI,CAACC,GAAL,CAASd,SAAS,CAACE,KAAV,CAAgB,CAAhB,CAAT,EAA6BM,WAAW,CAAC,CAAD,CAAX,CAAeN,KAAf,CAAqB,CAArB,CAA7B,CAAxB,EAA+E,OAA/E,CAA9B;UACD;;UAED,OAAOnB,uBAAuB,CAACC,KAAD,EAAQY,KAAK,CAACM,KAAN,CAAY,CAAZ,CAAR,EAAwBF,SAAS,CAACE,KAAV,CAAgB,CAAhB,CAAxB,EAA4C,OAA5C,CAA9B;QACD;;MA1BoD,CAAjD,CAAN;IA4BD;IAED;AACJ;AACA;AACA;AACA;AACA;;;IACI,SAASa,mBAAT,CAA6BpB,IAA7B,EAAmCC,KAAnC,EAA0C;MACxC/E,MAAM,CAACwC,OAAD,EAAUnC,QAAQ,CAACI,aAAnB,EAAkC,eAAlC,EAAmD;QACvDqE,IADuD;QAEvDhB,GAAG,EAAEiB,KAAK,CAACjB,GAAN,CAAUG,KAFwC;QAGvDe,IAAI,EAAE;UACJD,KAAK,EAAEA,KAAK,CAACE;QADT,CAHiD;;QAMvDC,GAAG,CAACf,KAAD,EAAQ;UACT,MAAMuB,UAAU,GAAGlD,OAAO,CAACgC,aAAR,EAAnB;UACA,MAAMe,aAAa,GAAGG,UAAU,CAACF,cAAX,CAA0BT,KAA1B,CAAtB;UACA,IAAIoB,eAAJ,CAHS,CAKT;;UACA,IAAIT,UAAU,CAACU,iBAAf,EAAkC;YAChCD,eAAe,GAAGT,UAAU,CAACU,iBAAX,CAA6BrB,KAA7B,CAAlB,CADgC,CAElC;UACC,CAHD,MAGO;YACL,MAAMc,gBAAgB,GAAGH,UAAU,CAACF,cAAX,CAA0BT,KAA1B,EAAiC;cAAEe,eAAe,EAAE;YAAnB,CAAjC,CAAzB;YACAK,eAAe,GAAGZ,aAAa,KAAKM,gBAAlB,GAAqC,EAArC,GAA0C,CAACA,gBAAD,CAA5D;UACD,CAZQ,CAcT;;;UACA,IAAIM,eAAe,CAACJ,MAAhB,GAAyB,CAA7B,EAAgC;YAC9B,OAAO7B,uBAAuB,CAACC,KAAD,EAAQ6B,IAAI,CAACK,GAAL,CAASd,aAAa,CAACF,KAAd,CAAoB,CAApB,CAAT,EAAiCc,eAAe,CAAC,CAAD,CAAf,CAAmBd,KAAnB,CAAyB,CAAzB,CAAjC,CAAR,EAAuEN,KAAK,CAACM,KAAN,CAAY,CAAZ,CAAvE,EAAuF,KAAvF,CAA9B;UACD;;UAED,OAAOnB,uBAAuB,CAACC,KAAD,EAAQoB,aAAa,CAACF,KAAd,CAAoB,CAApB,CAAR,EAAgCN,KAAK,CAACM,KAAN,CAAY,CAAZ,CAAhC,EAAgD,KAAhD,CAA9B;QACD;;MA1BsD,CAAnD,CAAN;IA4BD;IAED;AACJ;AACA;AACA;AACA;AACA;;;IACI,SAASiB,4BAAT,CAAsCxB,IAAtC,EAA4CC,KAA5C,EAAmD;MACjD/E,MAAM,CAACwC,OAAD,EAAUnC,QAAQ,CAACK,gBAAnB,EAAqC,kBAArC,EAAyD;QAC7DoE,IAD6D;QAE7DhB,GAAG,EAAEiB,KAAK,CAACjB,GAAN,CAAUG,KAF8C;QAG7De,IAAI,EAAE;UACJD,KAAK,EAAEA,KAAK,CAACE;QADT,CAHuD;;QAM7DC,GAAG,CAACf,KAAD,EAAQ;UACT,OAAOA,KAAK,CAACoC,eAAN,CAAsBxB,KAAtB,EAA6B,GAA7B,CAAP;QACD;;MAR4D,CAAzD,CAAN;IAUD;IAED;AACJ;AACA;AACA;AACA;AACA;;;IACI,SAASyB,yBAAT,CAAmC1B,IAAnC,EAAyCC,KAAzC,EAAgD;MAC9C/E,MAAM,CAACwC,OAAD,EAAUnC,QAAQ,CAACM,iBAAnB,EAAsC,mBAAtC,EAA2D;QAC/DmE,IAD+D;QAE/DhB,GAAG,EAAEiB,KAAK,CAACjB,GAAN,CAAUG,KAFgD;QAG/De,IAAI,EAAE;UACJD,KAAK,EAAEA,KAAK,CAACE;QADT,CAHyD;;QAM/DC,GAAG,CAACf,KAAD,EAAQ;UACT,OAAOA,KAAK,CAACsC,gBAAN,CAAuB1B,KAAvB,EAA8B,GAA9B,CAAP;QACD;;MAR8D,CAA3D,CAAN;IAUD;IAED;AACJ;AACA;AACA;AACA;;;IACI,SAAS2B,oBAAT,CAA8B5B,IAA9B,EAAoC;MAClC,IAAIjC,MAAJ;;MACA,QAAQiC,IAAI,CAAC6B,MAAL,CAAYnF,IAApB;QACE,KAAK,cAAL;QACA,KAAK,mBAAL;UACEqB,MAAM,GAAGY,gBAAT;UACA;;QAEF,KAAK,YAAL;QACA,KAAK,aAAL;UACEZ,MAAM,GAAGa,cAAT;UACA;;QAEF;UACE;MAZJ;;MAcA,IAAIb,MAAM,KAAK,IAAf,EAAqB;QACnB;MACD;;MAED,MAAM6C,UAAU,GAAGlD,OAAO,CAACgC,aAAR,EAAnB;MACA,MAAMoC,KAAK,GAAGlB,UAAU,CAACmB,aAAX,CAAyB/B,IAAzB,CAAd;MACA,MAAMgC,IAAI,GAAGpB,UAAU,CAACqB,YAAX,CAAwBjC,IAAxB,CAAb;MACA,IAAIkC,MAAM,GAAGtB,UAAU,CAACN,aAAX,CAAyBwB,KAAzB,EAAgC;QAAEd,eAAe,EAAE;MAAnB,CAAhC,CAAb;MACA,IAAImB,WAAW,GAAGvB,UAAU,CAACF,cAAX,CAA0BsB,IAA1B,EAAgC;QAAEhB,eAAe,EAAE;MAAnB,CAAhC,CAAlB;;MAEA,IAAI,CAACkB,MAAL,EAAa;QACXA,MAAM,GAAGtB,UAAU,CAACN,aAAX,CAAyBwB,KAAzB,CAAT;QACA,MAAMM,eAAe,GAAGxB,UAAU,CAACyB,mBAAX,CAA+BH,MAAM,CAAC3B,KAAP,CAAa,CAAb,CAA/B,EAAgD6B,eAAxE;QACAF,MAAM,GAAGE,eAAe,GAAGA,eAAe,CAAC,CAAD,CAAlB,GAAwBF,MAAhD;MACD;;MACD,IAAI,CAACC,WAAL,EAAkB;QAChBA,WAAW,GAAGvB,UAAU,CAACF,cAAX,CAA0BsB,IAA1B,CAAd;QACA,MAAMM,gBAAgB,GAAG1B,UAAU,CAACyB,mBAAX,CAA+BF,WAAW,CAAC5B,KAAZ,CAAkB,CAAlB,CAA/B,EAAqD+B,gBAA9E;QACAH,WAAW,GAAGG,gBAAgB,GAAGA,gBAAgB,CAACA,gBAAgB,CAACrB,MAAjB,GAA0B,CAA3B,CAAnB,GAAmDkB,WAAjF;MACD;;MAED,MAAMI,eAAe,GAAGT,KAAK,CAAC3B,KAAN,KAAgB+B,MAAM,CAAC/B,KAA/C;MACA,MAAMpD,OAAO,GAAGwF,eAAe,GAAGxE,MAAM,CAACC,mBAAV,GAAgCD,MAAM,CAACnB,IAAtE;;MACA,IAAIG,OAAO,KAAK5B,OAAO,CAACC,MAAxB,EAAgC;QAC9B,IAAI,CAACwF,UAAU,CAAC4B,oBAAX,CAAgCV,KAAhC,EAAuCI,MAAvC,CAAL,EAAqD;UACnDV,4BAA4B,CAACxB,IAAD,EAAO8B,KAAP,CAA5B;QACD,CAFD,MAEO,IAAI,CAAC/D,MAAM,CAACjB,cAAR,IAA0B+B,WAAW,CAACiD,KAAD,EAAQI,MAAR,CAAzC,EAA0D;UAC/DnC,wBAAwB,CAACC,IAAD,EAAO8B,KAAP,EAAc/E,OAAd,CAAxB;QACD;;QACD,IAAI,CAAC6D,UAAU,CAAC4B,oBAAX,CAAgCL,WAAhC,EAA6CH,IAA7C,CAAL,EAAyD;UACvDN,yBAAyB,CAAC1B,IAAD,EAAOgC,IAAP,CAAzB;QACD,CAFD,MAEO,IAAI,CAACjE,MAAM,CAACjB,cAAR,IAA0B+B,WAAW,CAACsD,WAAD,EAAcH,IAAd,CAAzC,EAA8D;UACnExB,qBAAqB,CAACR,IAAD,EAAOgC,IAAP,EAAajF,OAAb,CAArB;QACD;MACF,CAXD,MAWO,IAAIA,OAAO,KAAK5B,OAAO,CAACE,KAAxB,EAA+B;QACpC,IAAIwD,WAAW,CAACiD,KAAD,EAAQI,MAAR,CAAf,EAAgC;UAC9B,IAAI,CAACnE,MAAM,CAACjB,cAAZ,EAA4B;YAC1BiD,wBAAwB,CAACC,IAAD,EAAO8B,KAAP,EAAc/E,OAAd,CAAxB;UACD;QACF,CAJD,MAIO,IAAI6D,UAAU,CAAC4B,oBAAX,CAAgCV,KAAhC,EAAuCI,MAAvC,CAAJ,EAAoD;UACzDvB,sBAAsB,CAACX,IAAD,EAAO8B,KAAP,CAAtB;QACD;;QACD,IAAIjD,WAAW,CAACsD,WAAD,EAAcH,IAAd,CAAf,EAAoC;UAClC,IAAI,CAACjE,MAAM,CAACjB,cAAZ,EAA4B;YAC1B0D,qBAAqB,CAACR,IAAD,EAAOgC,IAAP,EAAajF,OAAb,CAArB;UACD;QACF,CAJD,MAIO,IAAI6D,UAAU,CAAC4B,oBAAX,CAAgCL,WAAhC,EAA6CH,IAA7C,CAAJ,EAAwD;UAC7DZ,mBAAmB,CAACpB,IAAD,EAAOgC,IAAP,CAAnB;QACD;MACF;IACF,CA9Sa,CAgTd;IACA;IACA;;;IAEA,OAAO;MACLS,sBAAsB,EAAEb,oBADnB;MAELc,kBAAkB,EAAEd;IAFf,CAAP;EAID;;AAxYc,CAAjB"},"metadata":{},"sourceType":"script"}