{"ast":null,"code":"/**\n * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\n * @author Annie Zhang, Henry Zhu\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst radixMap = new Map([[2, {\n  system: \"binary\",\n  literalPrefix: \"0b\"\n}], [8, {\n  system: \"octal\",\n  literalPrefix: \"0o\"\n}], [16, {\n  system: \"hexadecimal\",\n  literalPrefix: \"0x\"\n}]]);\n/**\n * Checks to see if a CallExpression's callee node is `parseInt` or\n * `Number.parseInt`.\n * @param {ASTNode} calleeNode The callee node to evaluate.\n * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,\n * false otherwise.\n */\n\nfunction isParseInt(calleeNode) {\n  return astUtils.isSpecificId(calleeNode, \"parseInt\") || astUtils.isSpecificMemberAccess(calleeNode, \"Number\", \"parseInt\");\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-numeric-literals\"\n    },\n    schema: [],\n    messages: {\n      useLiteral: \"Use {{system}} literals instead of {{functionName}}().\"\n    },\n    fixable: \"code\"\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      \"CallExpression[arguments.length=2]\"(node) {\n        const [strNode, radixNode] = node.arguments,\n              str = astUtils.getStaticStringValue(strNode),\n              radix = radixNode.value;\n\n        if (str !== null && astUtils.isStringLiteral(strNode) && radixNode.type === \"Literal\" && typeof radix === \"number\" && radixMap.has(radix) && isParseInt(node.callee)) {\n          const {\n            system,\n            literalPrefix\n          } = radixMap.get(radix);\n          context.report({\n            node,\n            messageId: \"useLiteral\",\n            data: {\n              system,\n              functionName: sourceCode.getText(node.callee)\n            },\n\n            fix(fixer) {\n              if (sourceCode.getCommentsInside(node).length) {\n                return null;\n              }\n\n              const replacement = `${literalPrefix}${str}`;\n\n              if (+replacement !== parseInt(str, radix)) {\n                /*\n                 * If the newly-produced literal would be invalid, (e.g. 0b1234),\n                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.\n                 *\n                 * If `str` had numeric separators, `+replacement` will evaluate to `NaN` because unary `+`\n                 * per the specification doesn't support numeric separators. Thus, the above condition will be `true`\n                 * (`NaN !== anything` is always `true`) regardless of the `parseInt(str, radix)` value.\n                 * Consequently, no autofixes will be made. This is correct behavior because `parseInt` also\n                 * doesn't support numeric separators, but it does parse part of the string before the first `_`,\n                 * so the autofix would be invalid:\n                 *\n                 *   parseInt(\"1_1\", 2) // === 1\n                 *   0b1_1 // === 3\n                 */\n                return null;\n              }\n\n              const tokenBefore = sourceCode.getTokenBefore(node),\n                    tokenAfter = sourceCode.getTokenAfter(node);\n              let prefix = \"\",\n                  suffix = \"\";\n\n              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {\n                prefix = \" \";\n              }\n\n              if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(replacement, tokenAfter)) {\n                suffix = \" \";\n              }\n\n              return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","radixMap","Map","system","literalPrefix","isParseInt","calleeNode","isSpecificId","isSpecificMemberAccess","module","exports","meta","type","docs","description","recommended","url","schema","messages","useLiteral","fixable","create","context","sourceCode","getSourceCode","node","strNode","radixNode","arguments","str","getStaticStringValue","radix","value","isStringLiteral","has","callee","get","report","messageId","data","functionName","getText","fix","fixer","getCommentsInside","length","replacement","parseInt","tokenBefore","getTokenBefore","tokenAfter","getTokenAfter","prefix","suffix","range","canTokensBeAdjacent","replaceText"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/prefer-numeric-literals.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\n * @author Annie Zhang, Henry Zhu\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst radixMap = new Map([\n    [2, { system: \"binary\", literalPrefix: \"0b\" }],\n    [8, { system: \"octal\", literalPrefix: \"0o\" }],\n    [16, { system: \"hexadecimal\", literalPrefix: \"0x\" }]\n]);\n\n/**\n * Checks to see if a CallExpression's callee node is `parseInt` or\n * `Number.parseInt`.\n * @param {ASTNode} calleeNode The callee node to evaluate.\n * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,\n * false otherwise.\n */\nfunction isParseInt(calleeNode) {\n    return (\n        astUtils.isSpecificId(calleeNode, \"parseInt\") ||\n        astUtils.isSpecificMemberAccess(calleeNode, \"Number\", \"parseInt\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/prefer-numeric-literals\"\n        },\n\n        schema: [],\n\n        messages: {\n            useLiteral: \"Use {{system}} literals instead of {{functionName}}().\"\n        },\n\n        fixable: \"code\"\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        //----------------------------------------------------------------------\n        // Public\n        //----------------------------------------------------------------------\n\n        return {\n\n            \"CallExpression[arguments.length=2]\"(node) {\n                const [strNode, radixNode] = node.arguments,\n                    str = astUtils.getStaticStringValue(strNode),\n                    radix = radixNode.value;\n\n                if (\n                    str !== null &&\n                    astUtils.isStringLiteral(strNode) &&\n                    radixNode.type === \"Literal\" &&\n                    typeof radix === \"number\" &&\n                    radixMap.has(radix) &&\n                    isParseInt(node.callee)\n                ) {\n\n                    const { system, literalPrefix } = radixMap.get(radix);\n\n                    context.report({\n                        node,\n                        messageId: \"useLiteral\",\n                        data: {\n                            system,\n                            functionName: sourceCode.getText(node.callee)\n                        },\n                        fix(fixer) {\n                            if (sourceCode.getCommentsInside(node).length) {\n                                return null;\n                            }\n\n                            const replacement = `${literalPrefix}${str}`;\n\n                            if (+replacement !== parseInt(str, radix)) {\n\n                                /*\n                                 * If the newly-produced literal would be invalid, (e.g. 0b1234),\n                                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.\n                                 *\n                                 * If `str` had numeric separators, `+replacement` will evaluate to `NaN` because unary `+`\n                                 * per the specification doesn't support numeric separators. Thus, the above condition will be `true`\n                                 * (`NaN !== anything` is always `true`) regardless of the `parseInt(str, radix)` value.\n                                 * Consequently, no autofixes will be made. This is correct behavior because `parseInt` also\n                                 * doesn't support numeric separators, but it does parse part of the string before the first `_`,\n                                 * so the autofix would be invalid:\n                                 *\n                                 *   parseInt(\"1_1\", 2) // === 1\n                                 *   0b1_1 // === 3\n                                 */\n                                return null;\n                            }\n\n                            const tokenBefore = sourceCode.getTokenBefore(node),\n                                tokenAfter = sourceCode.getTokenAfter(node);\n                            let prefix = \"\",\n                                suffix = \"\";\n\n                            if (\n                                tokenBefore &&\n                                tokenBefore.range[1] === node.range[0] &&\n                                !astUtils.canTokensBeAdjacent(tokenBefore, replacement)\n                            ) {\n                                prefix = \" \";\n                            }\n\n                            if (\n                                tokenAfter &&\n                                node.range[1] === tokenAfter.range[0] &&\n                                !astUtils.canTokensBeAdjacent(replacement, tokenAfter)\n                            ) {\n                                suffix = \" \";\n                            }\n\n                            return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}