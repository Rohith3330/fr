{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/;\n/**\n * Parses a given value as options.\n */\n\nfunction parseOptions(options) {\n  let functions = true;\n  let classes = true;\n  let enums = true;\n  let variables = true;\n  let typedefs = true;\n  let ignoreTypeReferences = true;\n  let allowNamedExports = false;\n\n  if (typeof options === 'string') {\n    functions = options !== 'nofunc';\n  } else if (typeof options === 'object' && options !== null) {\n    functions = options.functions !== false;\n    classes = options.classes !== false;\n    enums = options.enums !== false;\n    variables = options.variables !== false;\n    typedefs = options.typedefs !== false;\n    ignoreTypeReferences = options.ignoreTypeReferences !== false;\n    allowNamedExports = options.allowNamedExports !== false;\n  }\n\n  return {\n    functions,\n    classes,\n    enums,\n    variables,\n    typedefs,\n    ignoreTypeReferences,\n    allowNamedExports\n  };\n}\n/**\n * Checks whether or not a given variable is a function declaration.\n */\n\n\nfunction isFunction(variable) {\n  return variable.defs[0].type === scope_manager_1.DefinitionType.FunctionName;\n}\n/**\n * Checks whether or not a given variable is a type declaration.\n */\n\n\nfunction isTypedef(variable) {\n  return variable.defs[0].type === scope_manager_1.DefinitionType.Type;\n}\n/**\n * Checks whether or not a given variable is a enum declaration.\n */\n\n\nfunction isOuterEnum(variable, reference) {\n  return variable.defs[0].type == scope_manager_1.DefinitionType.TSEnumName && variable.scope.variableScope !== reference.from.variableScope;\n}\n/**\n * Checks whether or not a given variable is a class declaration in an upper function scope.\n */\n\n\nfunction isOuterClass(variable, reference) {\n  return variable.defs[0].type === scope_manager_1.DefinitionType.ClassName && variable.scope.variableScope !== reference.from.variableScope;\n}\n/**\n * Checks whether or not a given variable is a variable declaration in an upper function scope.\n */\n\n\nfunction isOuterVariable(variable, reference) {\n  return variable.defs[0].type === scope_manager_1.DefinitionType.Variable && variable.scope.variableScope !== reference.from.variableScope;\n}\n/**\n * Checks whether or not a given reference is a export reference.\n */\n\n\nfunction isNamedExports(reference) {\n  var _a;\n\n  const {\n    identifier\n  } = reference;\n  return ((_a = identifier.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ExportSpecifier && identifier.parent.local === identifier;\n}\n/**\n * Recursively checks whether or not a given reference has a type query declaration among it's parents\n */\n\n\nfunction referenceContainsTypeQuery(node) {\n  switch (node.type) {\n    case utils_1.AST_NODE_TYPES.TSTypeQuery:\n      return true;\n\n    case utils_1.AST_NODE_TYPES.TSQualifiedName:\n    case utils_1.AST_NODE_TYPES.Identifier:\n      if (!node.parent) {\n        return false;\n      }\n\n      return referenceContainsTypeQuery(node.parent);\n\n    default:\n      // if we find a different node, there's no chance that we're in a TSTypeQuery\n      return false;\n  }\n}\n/**\n * Checks whether or not a given reference is a type reference.\n */\n\n\nfunction isTypeReference(reference) {\n  return reference.isTypeReference || referenceContainsTypeQuery(reference.identifier);\n}\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n */\n\n\nfunction isInRange(node, location) {\n  return !!node && node.range[0] <= location && location <= node.range[1];\n}\n/**\n * Decorators are transpiled such that the decorator is placed after the class declaration\n * So it is considered safe\n */\n\n\nfunction isClassRefInClassDecorator(variable, reference) {\n  if (variable.defs[0].type !== scope_manager_1.DefinitionType.ClassName) {\n    return false;\n  }\n\n  if (!variable.defs[0].node.decorators || variable.defs[0].node.decorators.length === 0) {\n    return false;\n  }\n\n  for (const deco of variable.defs[0].node.decorators) {\n    if (reference.identifier.range[0] >= deco.range[0] && reference.identifier.range[1] <= deco.range[1]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Checks whether or not a given reference is inside of the initializers of a given variable.\n *\n * @returns `true` in the following cases:\n * - var a = a\n * - var [a = a] = list\n * - var {a = a} = obj\n * - for (var a in a) {}\n * - for (var a of a) {}\n */\n\n\nfunction isInInitializer(variable, reference) {\n  var _a;\n\n  if (variable.scope !== reference.from) {\n    return false;\n  }\n\n  let node = variable.identifiers[0].parent;\n  const location = reference.identifier.range[1];\n\n  while (node) {\n    if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {\n      if (isInRange(node.init, location)) {\n        return true;\n      }\n\n      if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) && (node.parent.parent.type === utils_1.AST_NODE_TYPES.ForInStatement || node.parent.parent.type === utils_1.AST_NODE_TYPES.ForOfStatement) && isInRange(node.parent.parent.right, location)) {\n        return true;\n      }\n\n      break;\n    } else if (node.type === utils_1.AST_NODE_TYPES.AssignmentPattern) {\n      if (isInRange(node.right, location)) {\n        return true;\n      }\n    } else if (SENTINEL_TYPE.test(node.type)) {\n      break;\n    }\n\n    node = node.parent;\n  }\n\n  return false;\n}\n\nexports.default = util.createRule({\n  name: 'no-use-before-define',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow the use of variables before they are defined',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    messages: {\n      noUseBeforeDefine: \"'{{name}}' was used before it was defined.\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: ['nofunc']\n      }, {\n        type: 'object',\n        properties: {\n          functions: {\n            type: 'boolean'\n          },\n          classes: {\n            type: 'boolean'\n          },\n          enums: {\n            type: 'boolean'\n          },\n          variables: {\n            type: 'boolean'\n          },\n          typedefs: {\n            type: 'boolean'\n          },\n          ignoreTypeReferences: {\n            type: 'boolean'\n          },\n          allowNamedExports: {\n            type: 'boolean'\n          }\n        },\n        additionalProperties: false\n      }]\n    }]\n  },\n  defaultOptions: [{\n    functions: true,\n    classes: true,\n    enums: true,\n    variables: true,\n    typedefs: true,\n    ignoreTypeReferences: true,\n    allowNamedExports: false\n  }],\n\n  create(context, optionsWithDefault) {\n    const options = parseOptions(optionsWithDefault[0]);\n    /**\n     * Determines whether a given use-before-define case should be reported according to the options.\n     * @param variable The variable that gets used before being defined\n     * @param reference The reference to the variable\n     */\n\n    function isForbidden(variable, reference) {\n      if (options.ignoreTypeReferences && isTypeReference(reference)) {\n        return false;\n      }\n\n      if (isFunction(variable)) {\n        return options.functions;\n      }\n\n      if (isOuterClass(variable, reference)) {\n        return options.classes;\n      }\n\n      if (isOuterVariable(variable, reference)) {\n        return options.variables;\n      }\n\n      if (isOuterEnum(variable, reference)) {\n        return options.enums;\n      }\n\n      if (isTypedef(variable)) {\n        return options.typedefs;\n      }\n\n      return true;\n    }\n\n    function isDefinedBeforeUse(variable, reference) {\n      return variable.identifiers[0].range[1] <= reference.identifier.range[1] && !isInInitializer(variable, reference);\n    }\n    /**\n     * Finds and validates all variables in a given scope.\n     */\n\n\n    function findVariablesInScope(scope) {\n      scope.references.forEach(reference => {\n        const variable = reference.resolved;\n\n        function report() {\n          context.report({\n            node: reference.identifier,\n            messageId: 'noUseBeforeDefine',\n            data: {\n              name: reference.identifier.name\n            }\n          });\n        } // Skips when the reference is:\n        // - initializations.\n        // - referring to an undefined variable.\n        // - referring to a global environment variable (there're no identifiers).\n        // - located preceded by the variable (except in initializers).\n        // - allowed by options.\n\n\n        if (reference.init) {\n          return;\n        }\n\n        if (!options.allowNamedExports && isNamedExports(reference)) {\n          if (!variable || !isDefinedBeforeUse(variable, reference)) {\n            report();\n          }\n\n          return;\n        }\n\n        if (!variable) {\n          return;\n        }\n\n        if (variable.identifiers.length === 0 || isDefinedBeforeUse(variable, reference) || !isForbidden(variable, reference) || isClassRefInClassDecorator(variable, reference) || reference.from.type === utils_1.TSESLint.Scope.ScopeType.functionType) {\n          return;\n        } // Reports.\n\n\n        report();\n      });\n      scope.childScopes.forEach(findVariablesInScope);\n    }\n\n    return {\n      Program() {\n        findVariablesInScope(context.getScope());\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["SENTINEL_TYPE","parseOptions","options","functions","classes","enums","variables","typedefs","ignoreTypeReferences","allowNamedExports","isFunction","variable","defs","type","scope_manager_1","FunctionName","isTypedef","Type","isOuterEnum","reference","TSEnumName","scope","variableScope","from","isOuterClass","ClassName","isOuterVariable","Variable","isNamedExports","identifier","parent","_a","utils_1","ExportSpecifier","local","referenceContainsTypeQuery","node","TSTypeQuery","TSQualifiedName","Identifier","isTypeReference","isInRange","location","range","isClassRefInClassDecorator","decorators","length","deco","isInInitializer","identifiers","VariableDeclarator","init","ForInStatement","ForOfStatement","right","AssignmentPattern","test","exports","util","createRule","name","meta","docs","description","recommended","extendsBaseRule","messages","noUseBeforeDefine","schema","oneOf","enum","properties","additionalProperties","defaultOptions","create","context","optionsWithDefault","isForbidden","isDefinedBeforeUse","findVariablesInScope","references","forEach","resolved","report","messageId","data","Scope","ScopeType","functionType","childScopes","Program","getScope"],"sources":["../../src/rules/no-use-before-define.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}