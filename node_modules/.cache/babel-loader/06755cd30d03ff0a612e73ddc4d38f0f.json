{"ast":null,"code":"/*! js-yaml 3.14.1 https://github.com/nodeca/js-yaml */\n(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.jsyaml = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function () {\n    function r(e, n, t) {\n      function o(i, f) {\n        if (!n[i]) {\n          if (!e[i]) {\n            var c = \"function\" == typeof require && require;\n            if (!f && c) return c(i, !0);\n            if (u) return u(i, !0);\n            var a = new Error(\"Cannot find module '\" + i + \"'\");\n            throw a.code = \"MODULE_NOT_FOUND\", a;\n          }\n\n          var p = n[i] = {\n            exports: {}\n          };\n          e[i][0].call(p.exports, function (r) {\n            var n = e[i][1][r];\n            return o(n || r);\n          }, p, p.exports, r, e, n, t);\n        }\n\n        return n[i].exports;\n      }\n\n      for (var u = \"function\" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);\n\n      return o;\n    }\n\n    return r;\n  }()({\n    1: [function (require, module, exports) {\n      'use strict';\n\n      var loader = require('./js-yaml/loader');\n\n      var dumper = require('./js-yaml/dumper');\n\n      function deprecated(name) {\n        return function () {\n          throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n        };\n      }\n\n      module.exports.Type = require('./js-yaml/type');\n      module.exports.Schema = require('./js-yaml/schema');\n      module.exports.FAILSAFE_SCHEMA = require('./js-yaml/schema/failsafe');\n      module.exports.JSON_SCHEMA = require('./js-yaml/schema/json');\n      module.exports.CORE_SCHEMA = require('./js-yaml/schema/core');\n      module.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\n      module.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');\n      module.exports.load = loader.load;\n      module.exports.loadAll = loader.loadAll;\n      module.exports.safeLoad = loader.safeLoad;\n      module.exports.safeLoadAll = loader.safeLoadAll;\n      module.exports.dump = dumper.dump;\n      module.exports.safeDump = dumper.safeDump;\n      module.exports.YAMLException = require('./js-yaml/exception'); // Deprecated schema names from JS-YAML 2.0.x\n\n      module.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');\n      module.exports.SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\n      module.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full'); // Deprecated functions from JS-YAML 1.x.x\n\n      module.exports.scan = deprecated('scan');\n      module.exports.parse = deprecated('parse');\n      module.exports.compose = deprecated('compose');\n      module.exports.addConstructor = deprecated('addConstructor');\n    }, {\n      \"./js-yaml/dumper\": 3,\n      \"./js-yaml/exception\": 4,\n      \"./js-yaml/loader\": 5,\n      \"./js-yaml/schema\": 7,\n      \"./js-yaml/schema/core\": 8,\n      \"./js-yaml/schema/default_full\": 9,\n      \"./js-yaml/schema/default_safe\": 10,\n      \"./js-yaml/schema/failsafe\": 11,\n      \"./js-yaml/schema/json\": 12,\n      \"./js-yaml/type\": 13\n    }],\n    2: [function (require, module, exports) {\n      'use strict';\n\n      function isNothing(subject) {\n        return typeof subject === 'undefined' || subject === null;\n      }\n\n      function isObject(subject) {\n        return typeof subject === 'object' && subject !== null;\n      }\n\n      function toArray(sequence) {\n        if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];\n        return [sequence];\n      }\n\n      function extend(target, source) {\n        var index, length, key, sourceKeys;\n\n        if (source) {\n          sourceKeys = Object.keys(source);\n\n          for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n            key = sourceKeys[index];\n            target[key] = source[key];\n          }\n        }\n\n        return target;\n      }\n\n      function repeat(string, count) {\n        var result = '',\n            cycle;\n\n        for (cycle = 0; cycle < count; cycle += 1) {\n          result += string;\n        }\n\n        return result;\n      }\n\n      function isNegativeZero(number) {\n        return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;\n      }\n\n      module.exports.isNothing = isNothing;\n      module.exports.isObject = isObject;\n      module.exports.toArray = toArray;\n      module.exports.repeat = repeat;\n      module.exports.isNegativeZero = isNegativeZero;\n      module.exports.extend = extend;\n    }, {}],\n    3: [function (require, module, exports) {\n      'use strict';\n      /*eslint-disable no-use-before-define*/\n\n      var common = require('./common');\n\n      var YAMLException = require('./exception');\n\n      var DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\n      var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\n      var _toString = Object.prototype.toString;\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n      var CHAR_TAB = 0x09;\n      /* Tab */\n\n      var CHAR_LINE_FEED = 0x0A;\n      /* LF */\n\n      var CHAR_CARRIAGE_RETURN = 0x0D;\n      /* CR */\n\n      var CHAR_SPACE = 0x20;\n      /* Space */\n\n      var CHAR_EXCLAMATION = 0x21;\n      /* ! */\n\n      var CHAR_DOUBLE_QUOTE = 0x22;\n      /* \" */\n\n      var CHAR_SHARP = 0x23;\n      /* # */\n\n      var CHAR_PERCENT = 0x25;\n      /* % */\n\n      var CHAR_AMPERSAND = 0x26;\n      /* & */\n\n      var CHAR_SINGLE_QUOTE = 0x27;\n      /* ' */\n\n      var CHAR_ASTERISK = 0x2A;\n      /* * */\n\n      var CHAR_COMMA = 0x2C;\n      /* , */\n\n      var CHAR_MINUS = 0x2D;\n      /* - */\n\n      var CHAR_COLON = 0x3A;\n      /* : */\n\n      var CHAR_EQUALS = 0x3D;\n      /* = */\n\n      var CHAR_GREATER_THAN = 0x3E;\n      /* > */\n\n      var CHAR_QUESTION = 0x3F;\n      /* ? */\n\n      var CHAR_COMMERCIAL_AT = 0x40;\n      /* @ */\n\n      var CHAR_LEFT_SQUARE_BRACKET = 0x5B;\n      /* [ */\n\n      var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;\n      /* ] */\n\n      var CHAR_GRAVE_ACCENT = 0x60;\n      /* ` */\n\n      var CHAR_LEFT_CURLY_BRACKET = 0x7B;\n      /* { */\n\n      var CHAR_VERTICAL_LINE = 0x7C;\n      /* | */\n\n      var CHAR_RIGHT_CURLY_BRACKET = 0x7D;\n      /* } */\n\n      var ESCAPE_SEQUENCES = {};\n      ESCAPE_SEQUENCES[0x00] = '\\\\0';\n      ESCAPE_SEQUENCES[0x07] = '\\\\a';\n      ESCAPE_SEQUENCES[0x08] = '\\\\b';\n      ESCAPE_SEQUENCES[0x09] = '\\\\t';\n      ESCAPE_SEQUENCES[0x0A] = '\\\\n';\n      ESCAPE_SEQUENCES[0x0B] = '\\\\v';\n      ESCAPE_SEQUENCES[0x0C] = '\\\\f';\n      ESCAPE_SEQUENCES[0x0D] = '\\\\r';\n      ESCAPE_SEQUENCES[0x1B] = '\\\\e';\n      ESCAPE_SEQUENCES[0x22] = '\\\\\"';\n      ESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\n      ESCAPE_SEQUENCES[0x85] = '\\\\N';\n      ESCAPE_SEQUENCES[0xA0] = '\\\\_';\n      ESCAPE_SEQUENCES[0x2028] = '\\\\L';\n      ESCAPE_SEQUENCES[0x2029] = '\\\\P';\n      var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];\n\n      function compileStyleMap(schema, map) {\n        var result, keys, index, length, tag, style, type;\n        if (map === null) return {};\n        result = {};\n        keys = Object.keys(map);\n\n        for (index = 0, length = keys.length; index < length; index += 1) {\n          tag = keys[index];\n          style = String(map[tag]);\n\n          if (tag.slice(0, 2) === '!!') {\n            tag = 'tag:yaml.org,2002:' + tag.slice(2);\n          }\n\n          type = schema.compiledTypeMap['fallback'][tag];\n\n          if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n            style = type.styleAliases[style];\n          }\n\n          result[tag] = style;\n        }\n\n        return result;\n      }\n\n      function encodeHex(character) {\n        var string, handle, length;\n        string = character.toString(16).toUpperCase();\n\n        if (character <= 0xFF) {\n          handle = 'x';\n          length = 2;\n        } else if (character <= 0xFFFF) {\n          handle = 'u';\n          length = 4;\n        } else if (character <= 0xFFFFFFFF) {\n          handle = 'U';\n          length = 8;\n        } else {\n          throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n        }\n\n        return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n      }\n\n      function State(options) {\n        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n        this.indent = Math.max(1, options['indent'] || 2);\n        this.noArrayIndent = options['noArrayIndent'] || false;\n        this.skipInvalid = options['skipInvalid'] || false;\n        this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];\n        this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n        this.sortKeys = options['sortKeys'] || false;\n        this.lineWidth = options['lineWidth'] || 80;\n        this.noRefs = options['noRefs'] || false;\n        this.noCompatMode = options['noCompatMode'] || false;\n        this.condenseFlow = options['condenseFlow'] || false;\n        this.implicitTypes = this.schema.compiledImplicit;\n        this.explicitTypes = this.schema.compiledExplicit;\n        this.tag = null;\n        this.result = '';\n        this.duplicates = [];\n        this.usedDuplicates = null;\n      } // Indents every line in a string. Empty lines (\\n only) are not indented.\n\n\n      function indentString(string, spaces) {\n        var ind = common.repeat(' ', spaces),\n            position = 0,\n            next = -1,\n            result = '',\n            line,\n            length = string.length;\n\n        while (position < length) {\n          next = string.indexOf('\\n', position);\n\n          if (next === -1) {\n            line = string.slice(position);\n            position = length;\n          } else {\n            line = string.slice(position, next + 1);\n            position = next + 1;\n          }\n\n          if (line.length && line !== '\\n') result += ind;\n          result += line;\n        }\n\n        return result;\n      }\n\n      function generateNextLine(state, level) {\n        return '\\n' + common.repeat(' ', state.indent * level);\n      }\n\n      function testImplicitResolving(state, str) {\n        var index, length, type;\n\n        for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n          type = state.implicitTypes[index];\n\n          if (type.resolve(str)) {\n            return true;\n          }\n        }\n\n        return false;\n      } // [33] s-white ::= s-space | s-tab\n\n\n      function isWhitespace(c) {\n        return c === CHAR_SPACE || c === CHAR_TAB;\n      } // Returns true if the character can be printed without escaping.\n      // From YAML 1.2: \"any allowed characters known to be non-printable\n      // should also be escaped. [However,] This isn’t mandatory\"\n      // Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\n\n\n      function isPrintable(c) {\n        return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF\n        /* BOM */\n        || 0x10000 <= c && c <= 0x10FFFF;\n      } // [34] ns-char ::= nb-char - s-white\n      // [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n      // [26] b-char  ::= b-line-feed | b-carriage-return\n      // [24] b-line-feed       ::=     #xA    /* LF */\n      // [25] b-carriage-return ::=     #xD    /* CR */\n      // [3]  c-byte-order-mark ::=     #xFEFF\n\n\n      function isNsChar(c) {\n        return isPrintable(c) && !isWhitespace(c) // byte-order-mark\n        && c !== 0xFEFF // b-char\n        && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;\n      } // Simplified test for values allowed after the first character in plain style.\n\n\n      function isPlainSafe(c, prev) {\n        // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n        // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n        return isPrintable(c) && c !== 0xFEFF // - c-flow-indicator\n        && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // - \":\" - \"#\"\n        // /* An ns-char preceding */ \"#\"\n        && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));\n      } // Simplified test for values allowed as the first character in plain style.\n\n\n      function isPlainSafeFirst(c) {\n        // Uses a subset of ns-char - c-indicator\n        // where ns-char = nb-char - s-white.\n        return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white\n        // - (c-indicator ::=\n        // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n        && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n        && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE // | “%” | “@” | “`”)\n        && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n      } // Determines whether block indentation indicator is required.\n\n\n      function needIndentIndicator(string) {\n        var leadingSpaceRe = /^\\n* /;\n        return leadingSpaceRe.test(string);\n      }\n\n      var STYLE_PLAIN = 1,\n          STYLE_SINGLE = 2,\n          STYLE_LITERAL = 3,\n          STYLE_FOLDED = 4,\n          STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.\n      // lineWidth = -1 => no limit.\n      // Pre-conditions: str.length > 0.\n      // Post-conditions:\n      //    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n      //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n      //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\n\n      function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n        var i;\n        var char, prev_char;\n        var hasLineBreak = false;\n        var hasFoldableLine = false; // only checked if shouldTrackWidth\n\n        var shouldTrackWidth = lineWidth !== -1;\n        var previousLineBreak = -1; // count the first line correctly\n\n        var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));\n\n        if (singleLineOnly) {\n          // Case: no block styles.\n          // Check for disallowed characters to rule out plain and single.\n          for (i = 0; i < string.length; i++) {\n            char = string.charCodeAt(i);\n\n            if (!isPrintable(char)) {\n              return STYLE_DOUBLE;\n            }\n\n            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n            plain = plain && isPlainSafe(char, prev_char);\n          }\n        } else {\n          // Case: block styles permitted.\n          for (i = 0; i < string.length; i++) {\n            char = string.charCodeAt(i);\n\n            if (char === CHAR_LINE_FEED) {\n              hasLineBreak = true; // Check if any line can be folded.\n\n              if (shouldTrackWidth) {\n                hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.\n                i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n                previousLineBreak = i;\n              }\n            } else if (!isPrintable(char)) {\n              return STYLE_DOUBLE;\n            }\n\n            prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n            plain = plain && isPlainSafe(char, prev_char);\n          } // in case the end is missing a \\n\n\n\n          hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n        } // Although every style can represent \\n without escaping, prefer block styles\n        // for multiline, since they're more readable and they don't add empty lines.\n        // Also prefer folding a super-long line.\n\n\n        if (!hasLineBreak && !hasFoldableLine) {\n          // Strings interpretable as another type have to be quoted;\n          // e.g. the string 'true' vs. the boolean true.\n          return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;\n        } // Edge case: block indentation indicator can only have one digit.\n\n\n        if (indentPerLevel > 9 && needIndentIndicator(string)) {\n          return STYLE_DOUBLE;\n        } // At this point we know block styles are valid.\n        // Prefer literal style unless we want to fold.\n\n\n        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n      } // Note: line breaking/folding is implemented for only the folded style.\n      // NB. We drop the last trailing newline (if any) of a returned block scalar\n      //  since the dumper adds its own newline. This always works:\n      //    • No ending newline => unaffected; already using strip \"-\" chomping.\n      //    • Ending newline    => removed then restored.\n      //  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\n\n\n      function writeScalar(state, string, level, iskey) {\n        state.dump = function () {\n          if (string.length === 0) {\n            return \"''\";\n          }\n\n          if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n            return \"'\" + string + \"'\";\n          }\n\n          var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n          // As indentation gets deeper, let the width decrease monotonically\n          // to the lower bound min(state.lineWidth, 40).\n          // Note that this implies\n          //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n          //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n          // This behaves better than a constant minimum width which disallows narrower options,\n          // or an indent threshold which causes the width to suddenly increase.\n\n          var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent); // Without knowing if keys are implicit/explicit, assume implicit for safety.\n\n          var singleLineOnly = iskey // No block styles in flow mode.\n          || state.flowLevel > -1 && level >= state.flowLevel;\n\n          function testAmbiguity(string) {\n            return testImplicitResolving(state, string);\n          }\n\n          switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n            case STYLE_PLAIN:\n              return string;\n\n            case STYLE_SINGLE:\n              return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n\n            case STYLE_LITERAL:\n              return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n\n            case STYLE_FOLDED:\n              return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n\n            case STYLE_DOUBLE:\n              return '\"' + escapeString(string, lineWidth) + '\"';\n\n            default:\n              throw new YAMLException('impossible error: invalid scalar style');\n          }\n        }();\n      } // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\n\n\n      function blockHeader(string, indentPerLevel) {\n        var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : ''; // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n\n        var clip = string[string.length - 1] === '\\n';\n        var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n        var chomp = keep ? '+' : clip ? '' : '-';\n        return indentIndicator + chomp + '\\n';\n      } // (See the note for writeScalar.)\n\n\n      function dropEndingNewline(string) {\n        return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n      } // Note: a long line without a suitable break point will exceed the width limit.\n      // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\n\n\n      function foldString(string, width) {\n        // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n        // unless they're before or after a more-indented line, or at the very\n        // beginning or end, in which case $k$ maps to $k$.\n        // Therefore, parse each chunk as newline(s) followed by a content line.\n        var lineRe = /(\\n+)([^\\n]*)/g; // first line (possibly an empty line)\n\n        var result = function () {\n          var nextLF = string.indexOf('\\n');\n          nextLF = nextLF !== -1 ? nextLF : string.length;\n          lineRe.lastIndex = nextLF;\n          return foldLine(string.slice(0, nextLF), width);\n        }(); // If we haven't reached the first content line yet, don't add an extra \\n.\n\n\n        var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n        var moreIndented; // rest of the lines\n\n        var match;\n\n        while (match = lineRe.exec(string)) {\n          var prefix = match[1],\n              line = match[2];\n          moreIndented = line[0] === ' ';\n          result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\\n' : '') + foldLine(line, width);\n          prevMoreIndented = moreIndented;\n        }\n\n        return result;\n      } // Greedy line breaking.\n      // Picks the longest line under the limit each time,\n      // otherwise settles for the shortest line over the limit.\n      // NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\n\n\n      function foldLine(line, width) {\n        if (line === '' || line[0] === ' ') return line; // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n\n        var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n\n        var match; // start is an inclusive index. end, curr, and next are exclusive.\n\n        var start = 0,\n            end,\n            curr = 0,\n            next = 0;\n        var result = ''; // Invariants: 0 <= start <= length-1.\n        //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n        // Inside the loop:\n        //   A match implies length >= 2, so curr and next are <= length-2.\n\n        while (match = breakRe.exec(line)) {\n          next = match.index; // maintain invariant: curr - start <= width\n\n          if (next - start > width) {\n            end = curr > start ? curr : next; // derive end <= length-2\n\n            result += '\\n' + line.slice(start, end); // skip the space that was output as \\n\n\n            start = end + 1; // derive start <= length-1\n          }\n\n          curr = next;\n        } // By the invariants, start <= length-1, so there is something left over.\n        // It is either the whole string or a part starting from non-whitespace.\n\n\n        result += '\\n'; // Insert a break if the remainder is too long and there is a break available.\n\n        if (line.length - start > width && curr > start) {\n          result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n        } else {\n          result += line.slice(start);\n        }\n\n        return result.slice(1); // drop extra \\n joiner\n      } // Escapes a double-quoted string.\n\n\n      function escapeString(string) {\n        var result = '';\n        var char, nextChar;\n        var escapeSeq;\n\n        for (var i = 0; i < string.length; i++) {\n          char = string.charCodeAt(i); // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n\n          if (char >= 0xD800 && char <= 0xDBFF\n          /* high surrogate */\n          ) {\n            nextChar = string.charCodeAt(i + 1);\n\n            if (nextChar >= 0xDC00 && nextChar <= 0xDFFF\n            /* low surrogate */\n            ) {\n              // Combine the surrogate pair and store it escaped.\n              result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000); // Advance index one extra since we already used that char here.\n\n              i++;\n              continue;\n            }\n          }\n\n          escapeSeq = ESCAPE_SEQUENCES[char];\n          result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);\n        }\n\n        return result;\n      }\n\n      function writeFlowSequence(state, level, object) {\n        var _result = '',\n            _tag = state.tag,\n            index,\n            length;\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          // Write only valid elements.\n          if (writeNode(state, level, object[index], false, false)) {\n            if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n            _result += state.dump;\n          }\n        }\n\n        state.tag = _tag;\n        state.dump = '[' + _result + ']';\n      }\n\n      function writeBlockSequence(state, level, object, compact) {\n        var _result = '',\n            _tag = state.tag,\n            index,\n            length;\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          // Write only valid elements.\n          if (writeNode(state, level + 1, object[index], true, true)) {\n            if (!compact || index !== 0) {\n              _result += generateNextLine(state, level);\n            }\n\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n              _result += '-';\n            } else {\n              _result += '- ';\n            }\n\n            _result += state.dump;\n          }\n        }\n\n        state.tag = _tag;\n        state.dump = _result || '[]'; // Empty sequence if no valid values.\n      }\n\n      function writeFlowMapping(state, level, object) {\n        var _result = '',\n            _tag = state.tag,\n            objectKeyList = Object.keys(object),\n            index,\n            length,\n            objectKey,\n            objectValue,\n            pairBuffer;\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          pairBuffer = '';\n          if (index !== 0) pairBuffer += ', ';\n          if (state.condenseFlow) pairBuffer += '\"';\n          objectKey = objectKeyList[index];\n          objectValue = object[objectKey];\n\n          if (!writeNode(state, level, objectKey, false, false)) {\n            continue; // Skip this pair because of invalid key;\n          }\n\n          if (state.dump.length > 1024) pairBuffer += '? ';\n          pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n          if (!writeNode(state, level, objectValue, false, false)) {\n            continue; // Skip this pair because of invalid value.\n          }\n\n          pairBuffer += state.dump; // Both key and value are valid.\n\n          _result += pairBuffer;\n        }\n\n        state.tag = _tag;\n        state.dump = '{' + _result + '}';\n      }\n\n      function writeBlockMapping(state, level, object, compact) {\n        var _result = '',\n            _tag = state.tag,\n            objectKeyList = Object.keys(object),\n            index,\n            length,\n            objectKey,\n            objectValue,\n            explicitPair,\n            pairBuffer; // Allow sorting keys so that the output file is deterministic\n\n        if (state.sortKeys === true) {\n          // Default sorting\n          objectKeyList.sort();\n        } else if (typeof state.sortKeys === 'function') {\n          // Custom sort function\n          objectKeyList.sort(state.sortKeys);\n        } else if (state.sortKeys) {\n          // Something is wrong\n          throw new YAMLException('sortKeys must be a boolean or a function');\n        }\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          pairBuffer = '';\n\n          if (!compact || index !== 0) {\n            pairBuffer += generateNextLine(state, level);\n          }\n\n          objectKey = objectKeyList[index];\n          objectValue = object[objectKey];\n\n          if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n            continue; // Skip this pair because of invalid key.\n          }\n\n          explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;\n\n          if (explicitPair) {\n            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n              pairBuffer += '?';\n            } else {\n              pairBuffer += '? ';\n            }\n          }\n\n          pairBuffer += state.dump;\n\n          if (explicitPair) {\n            pairBuffer += generateNextLine(state, level);\n          }\n\n          if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n            continue; // Skip this pair because of invalid value.\n          }\n\n          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n            pairBuffer += ':';\n          } else {\n            pairBuffer += ': ';\n          }\n\n          pairBuffer += state.dump; // Both key and value are valid.\n\n          _result += pairBuffer;\n        }\n\n        state.tag = _tag;\n        state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n      }\n\n      function detectType(state, object, explicit) {\n        var _result, typeList, index, length, type, style;\n\n        typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n        for (index = 0, length = typeList.length; index < length; index += 1) {\n          type = typeList[index];\n\n          if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n            state.tag = explicit ? type.tag : '?';\n\n            if (type.represent) {\n              style = state.styleMap[type.tag] || type.defaultStyle;\n\n              if (_toString.call(type.represent) === '[object Function]') {\n                _result = type.represent(object, style);\n              } else if (_hasOwnProperty.call(type.represent, style)) {\n                _result = type.represent[style](object, style);\n              } else {\n                throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n              }\n\n              state.dump = _result;\n            }\n\n            return true;\n          }\n        }\n\n        return false;\n      } // Serializes `object` and writes it to global `result`.\n      // Returns true on success, or false on invalid object.\n      //\n\n\n      function writeNode(state, level, object, block, compact, iskey) {\n        state.tag = null;\n        state.dump = object;\n\n        if (!detectType(state, object, false)) {\n          detectType(state, object, true);\n        }\n\n        var type = _toString.call(state.dump);\n\n        if (block) {\n          block = state.flowLevel < 0 || state.flowLevel > level;\n        }\n\n        var objectOrArray = type === '[object Object]' || type === '[object Array]',\n            duplicateIndex,\n            duplicate;\n\n        if (objectOrArray) {\n          duplicateIndex = state.duplicates.indexOf(object);\n          duplicate = duplicateIndex !== -1;\n        }\n\n        if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {\n          compact = false;\n        }\n\n        if (duplicate && state.usedDuplicates[duplicateIndex]) {\n          state.dump = '*ref_' + duplicateIndex;\n        } else {\n          if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n            state.usedDuplicates[duplicateIndex] = true;\n          }\n\n          if (type === '[object Object]') {\n            if (block && Object.keys(state.dump).length !== 0) {\n              writeBlockMapping(state, level, state.dump, compact);\n\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + state.dump;\n              }\n            } else {\n              writeFlowMapping(state, level, state.dump);\n\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n              }\n            }\n          } else if (type === '[object Array]') {\n            var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;\n\n            if (block && state.dump.length !== 0) {\n              writeBlockSequence(state, arrayLevel, state.dump, compact);\n\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + state.dump;\n              }\n            } else {\n              writeFlowSequence(state, arrayLevel, state.dump);\n\n              if (duplicate) {\n                state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n              }\n            }\n          } else if (type === '[object String]') {\n            if (state.tag !== '?') {\n              writeScalar(state, state.dump, level, iskey);\n            }\n          } else {\n            if (state.skipInvalid) return false;\n            throw new YAMLException('unacceptable kind of an object to dump ' + type);\n          }\n\n          if (state.tag !== null && state.tag !== '?') {\n            state.dump = '!<' + state.tag + '> ' + state.dump;\n          }\n        }\n\n        return true;\n      }\n\n      function getDuplicateReferences(object, state) {\n        var objects = [],\n            duplicatesIndexes = [],\n            index,\n            length;\n        inspectNode(object, objects, duplicatesIndexes);\n\n        for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n          state.duplicates.push(objects[duplicatesIndexes[index]]);\n        }\n\n        state.usedDuplicates = new Array(length);\n      }\n\n      function inspectNode(object, objects, duplicatesIndexes) {\n        var objectKeyList, index, length;\n\n        if (object !== null && typeof object === 'object') {\n          index = objects.indexOf(object);\n\n          if (index !== -1) {\n            if (duplicatesIndexes.indexOf(index) === -1) {\n              duplicatesIndexes.push(index);\n            }\n          } else {\n            objects.push(object);\n\n            if (Array.isArray(object)) {\n              for (index = 0, length = object.length; index < length; index += 1) {\n                inspectNode(object[index], objects, duplicatesIndexes);\n              }\n            } else {\n              objectKeyList = Object.keys(object);\n\n              for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n                inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n              }\n            }\n          }\n        }\n      }\n\n      function dump(input, options) {\n        options = options || {};\n        var state = new State(options);\n        if (!state.noRefs) getDuplicateReferences(input, state);\n        if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n        return '';\n      }\n\n      function safeDump(input, options) {\n        return dump(input, common.extend({\n          schema: DEFAULT_SAFE_SCHEMA\n        }, options));\n      }\n\n      module.exports.dump = dump;\n      module.exports.safeDump = safeDump;\n    }, {\n      \"./common\": 2,\n      \"./exception\": 4,\n      \"./schema/default_full\": 9,\n      \"./schema/default_safe\": 10\n    }],\n    4: [function (require, module, exports) {\n      // YAML error class. http://stackoverflow.com/questions/8458984\n      //\n      'use strict';\n\n      function YAMLException(reason, mark) {\n        // Super constructor\n        Error.call(this);\n        this.name = 'YAMLException';\n        this.reason = reason;\n        this.mark = mark;\n        this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : ''); // Include stack trace in error object\n\n        if (Error.captureStackTrace) {\n          // Chrome and NodeJS\n          Error.captureStackTrace(this, this.constructor);\n        } else {\n          // FF, IE 10+ and Safari 6+. Fallback for others\n          this.stack = new Error().stack || '';\n        }\n      } // Inherit from Error\n\n\n      YAMLException.prototype = Object.create(Error.prototype);\n      YAMLException.prototype.constructor = YAMLException;\n\n      YAMLException.prototype.toString = function toString(compact) {\n        var result = this.name + ': ';\n        result += this.reason || '(unknown reason)';\n\n        if (!compact && this.mark) {\n          result += ' ' + this.mark.toString();\n        }\n\n        return result;\n      };\n\n      module.exports = YAMLException;\n    }, {}],\n    5: [function (require, module, exports) {\n      'use strict';\n      /*eslint-disable max-len,no-use-before-define*/\n\n      var common = require('./common');\n\n      var YAMLException = require('./exception');\n\n      var Mark = require('./mark');\n\n      var DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\n      var DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n      var CONTEXT_FLOW_IN = 1;\n      var CONTEXT_FLOW_OUT = 2;\n      var CONTEXT_BLOCK_IN = 3;\n      var CONTEXT_BLOCK_OUT = 4;\n      var CHOMPING_CLIP = 1;\n      var CHOMPING_STRIP = 2;\n      var CHOMPING_KEEP = 3;\n      var PATTERN_NON_PRINTABLE = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n      var PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\n      var PATTERN_FLOW_INDICATORS = /[,\\[\\]\\{\\}]/;\n      var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\\-]+!)$/i;\n      var PATTERN_TAG_URI = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n      function _class(obj) {\n        return Object.prototype.toString.call(obj);\n      }\n\n      function is_EOL(c) {\n        return c === 0x0A\n        /* LF */\n        || c === 0x0D\n        /* CR */\n        ;\n      }\n\n      function is_WHITE_SPACE(c) {\n        return c === 0x09\n        /* Tab */\n        || c === 0x20\n        /* Space */\n        ;\n      }\n\n      function is_WS_OR_EOL(c) {\n        return c === 0x09\n        /* Tab */\n        || c === 0x20\n        /* Space */\n        || c === 0x0A\n        /* LF */\n        || c === 0x0D\n        /* CR */\n        ;\n      }\n\n      function is_FLOW_INDICATOR(c) {\n        return c === 0x2C\n        /* , */\n        || c === 0x5B\n        /* [ */\n        || c === 0x5D\n        /* ] */\n        || c === 0x7B\n        /* { */\n        || c === 0x7D\n        /* } */\n        ;\n      }\n\n      function fromHexCode(c) {\n        var lc;\n\n        if (0x30\n        /* 0 */\n        <= c && c <= 0x39\n        /* 9 */\n        ) {\n          return c - 0x30;\n        }\n        /*eslint-disable no-bitwise*/\n\n\n        lc = c | 0x20;\n\n        if (0x61\n        /* a */\n        <= lc && lc <= 0x66\n        /* f */\n        ) {\n          return lc - 0x61 + 10;\n        }\n\n        return -1;\n      }\n\n      function escapedHexLen(c) {\n        if (c === 0x78\n        /* x */\n        ) {\n          return 2;\n        }\n\n        if (c === 0x75\n        /* u */\n        ) {\n          return 4;\n        }\n\n        if (c === 0x55\n        /* U */\n        ) {\n          return 8;\n        }\n\n        return 0;\n      }\n\n      function fromDecimalCode(c) {\n        if (0x30\n        /* 0 */\n        <= c && c <= 0x39\n        /* 9 */\n        ) {\n          return c - 0x30;\n        }\n\n        return -1;\n      }\n\n      function simpleEscapeSequence(c) {\n        /* eslint-disable indent */\n        return c === 0x30\n        /* 0 */\n        ? '\\x00' : c === 0x61\n        /* a */\n        ? '\\x07' : c === 0x62\n        /* b */\n        ? '\\x08' : c === 0x74\n        /* t */\n        ? '\\x09' : c === 0x09\n        /* Tab */\n        ? '\\x09' : c === 0x6E\n        /* n */\n        ? '\\x0A' : c === 0x76\n        /* v */\n        ? '\\x0B' : c === 0x66\n        /* f */\n        ? '\\x0C' : c === 0x72\n        /* r */\n        ? '\\x0D' : c === 0x65\n        /* e */\n        ? '\\x1B' : c === 0x20\n        /* Space */\n        ? ' ' : c === 0x22\n        /* \" */\n        ? '\\x22' : c === 0x2F\n        /* / */\n        ? '/' : c === 0x5C\n        /* \\ */\n        ? '\\x5C' : c === 0x4E\n        /* N */\n        ? '\\x85' : c === 0x5F\n        /* _ */\n        ? '\\xA0' : c === 0x4C\n        /* L */\n        ? '\\u2028' : c === 0x50\n        /* P */\n        ? '\\u2029' : '';\n      }\n\n      function charFromCodepoint(c) {\n        if (c <= 0xFFFF) {\n          return String.fromCharCode(c);\n        } // Encode UTF-16 surrogate pair\n        // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n\n\n        return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);\n      }\n\n      var simpleEscapeCheck = new Array(256); // integer, for fast access\n\n      var simpleEscapeMap = new Array(256);\n\n      for (var i = 0; i < 256; i++) {\n        simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n        simpleEscapeMap[i] = simpleEscapeSequence(i);\n      }\n\n      function State(input, options) {\n        this.input = input;\n        this.filename = options['filename'] || null;\n        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n        this.onWarning = options['onWarning'] || null;\n        this.legacy = options['legacy'] || false;\n        this.json = options['json'] || false;\n        this.listener = options['listener'] || null;\n        this.implicitTypes = this.schema.compiledImplicit;\n        this.typeMap = this.schema.compiledTypeMap;\n        this.length = input.length;\n        this.position = 0;\n        this.line = 0;\n        this.lineStart = 0;\n        this.lineIndent = 0;\n        this.documents = [];\n        /*\n        this.version;\n        this.checkLineBreaks;\n        this.tagMap;\n        this.anchorMap;\n        this.tag;\n        this.anchor;\n        this.kind;\n        this.result;*/\n      }\n\n      function generateError(state, message) {\n        return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));\n      }\n\n      function throwError(state, message) {\n        throw generateError(state, message);\n      }\n\n      function throwWarning(state, message) {\n        if (state.onWarning) {\n          state.onWarning.call(null, generateError(state, message));\n        }\n      }\n\n      var directiveHandlers = {\n        YAML: function handleYamlDirective(state, name, args) {\n          var match, major, minor;\n\n          if (state.version !== null) {\n            throwError(state, 'duplication of %YAML directive');\n          }\n\n          if (args.length !== 1) {\n            throwError(state, 'YAML directive accepts exactly one argument');\n          }\n\n          match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n          if (match === null) {\n            throwError(state, 'ill-formed argument of the YAML directive');\n          }\n\n          major = parseInt(match[1], 10);\n          minor = parseInt(match[2], 10);\n\n          if (major !== 1) {\n            throwError(state, 'unacceptable YAML version of the document');\n          }\n\n          state.version = args[0];\n          state.checkLineBreaks = minor < 2;\n\n          if (minor !== 1 && minor !== 2) {\n            throwWarning(state, 'unsupported YAML version of the document');\n          }\n        },\n        TAG: function handleTagDirective(state, name, args) {\n          var handle, prefix;\n\n          if (args.length !== 2) {\n            throwError(state, 'TAG directive accepts exactly two arguments');\n          }\n\n          handle = args[0];\n          prefix = args[1];\n\n          if (!PATTERN_TAG_HANDLE.test(handle)) {\n            throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n          }\n\n          if (_hasOwnProperty.call(state.tagMap, handle)) {\n            throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n          }\n\n          if (!PATTERN_TAG_URI.test(prefix)) {\n            throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n          }\n\n          state.tagMap[handle] = prefix;\n        }\n      };\n\n      function captureSegment(state, start, end, checkJson) {\n        var _position, _length, _character, _result;\n\n        if (start < end) {\n          _result = state.input.slice(start, end);\n\n          if (checkJson) {\n            for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n              _character = _result.charCodeAt(_position);\n\n              if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {\n                throwError(state, 'expected valid JSON character');\n              }\n            }\n          } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n            throwError(state, 'the stream contains non-printable characters');\n          }\n\n          state.result += _result;\n        }\n      }\n\n      function mergeMappings(state, destination, source, overridableKeys) {\n        var sourceKeys, key, index, quantity;\n\n        if (!common.isObject(source)) {\n          throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n        }\n\n        sourceKeys = Object.keys(source);\n\n        for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n          key = sourceKeys[index];\n\n          if (!_hasOwnProperty.call(destination, key)) {\n            destination[key] = source[key];\n            overridableKeys[key] = true;\n          }\n        }\n      }\n\n      function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n        var index, quantity; // The output is a plain object here, so keys can only be strings.\n        // We need to convert keyNode to a string, but doing so can hang the process\n        // (deeply nested arrays that explode exponentially using aliases).\n\n        if (Array.isArray(keyNode)) {\n          keyNode = Array.prototype.slice.call(keyNode);\n\n          for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n            if (Array.isArray(keyNode[index])) {\n              throwError(state, 'nested arrays are not supported inside keys');\n            }\n\n            if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n              keyNode[index] = '[object Object]';\n            }\n          }\n        } // Avoid code execution in load() via toString property\n        // (still use its own toString for arrays, timestamps,\n        // and whatever user schema extensions happen to have @@toStringTag)\n\n\n        if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n          keyNode = '[object Object]';\n        }\n\n        keyNode = String(keyNode);\n\n        if (_result === null) {\n          _result = {};\n        }\n\n        if (keyTag === 'tag:yaml.org,2002:merge') {\n          if (Array.isArray(valueNode)) {\n            for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n              mergeMappings(state, _result, valueNode[index], overridableKeys);\n            }\n          } else {\n            mergeMappings(state, _result, valueNode, overridableKeys);\n          }\n        } else {\n          if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {\n            state.line = startLine || state.line;\n            state.position = startPos || state.position;\n            throwError(state, 'duplicated mapping key');\n          }\n\n          _result[keyNode] = valueNode;\n          delete overridableKeys[keyNode];\n        }\n\n        return _result;\n      }\n\n      function readLineBreak(state) {\n        var ch;\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch === 0x0A\n        /* LF */\n        ) {\n          state.position++;\n        } else if (ch === 0x0D\n        /* CR */\n        ) {\n          state.position++;\n\n          if (state.input.charCodeAt(state.position) === 0x0A\n          /* LF */\n          ) {\n            state.position++;\n          }\n        } else {\n          throwError(state, 'a line break is expected');\n        }\n\n        state.line += 1;\n        state.lineStart = state.position;\n      }\n\n      function skipSeparationSpace(state, allowComments, checkIndent) {\n        var lineBreaks = 0,\n            ch = state.input.charCodeAt(state.position);\n\n        while (ch !== 0) {\n          while (is_WHITE_SPACE(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          if (allowComments && ch === 0x23\n          /* # */\n          ) {\n            do {\n              ch = state.input.charCodeAt(++state.position);\n            } while (ch !== 0x0A\n            /* LF */\n            && ch !== 0x0D\n            /* CR */\n            && ch !== 0);\n          }\n\n          if (is_EOL(ch)) {\n            readLineBreak(state);\n            ch = state.input.charCodeAt(state.position);\n            lineBreaks++;\n            state.lineIndent = 0;\n\n            while (ch === 0x20\n            /* Space */\n            ) {\n              state.lineIndent++;\n              ch = state.input.charCodeAt(++state.position);\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n          throwWarning(state, 'deficient indentation');\n        }\n\n        return lineBreaks;\n      }\n\n      function testDocumentSeparator(state) {\n        var _position = state.position,\n            ch;\n        ch = state.input.charCodeAt(_position); // Condition state.position === state.lineStart is tested\n        // in parent on each call, for efficiency. No needs to test here again.\n\n        if ((ch === 0x2D\n        /* - */\n        || ch === 0x2E\n        /* . */\n        ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {\n          _position += 3;\n          ch = state.input.charCodeAt(_position);\n\n          if (ch === 0 || is_WS_OR_EOL(ch)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      function writeFoldedLines(state, count) {\n        if (count === 1) {\n          state.result += ' ';\n        } else if (count > 1) {\n          state.result += common.repeat('\\n', count - 1);\n        }\n      }\n\n      function readPlainScalar(state, nodeIndent, withinFlowCollection) {\n        var preceding,\n            following,\n            captureStart,\n            captureEnd,\n            hasPendingContent,\n            _line,\n            _lineStart,\n            _lineIndent,\n            _kind = state.kind,\n            _result = state.result,\n            ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23\n        /* # */\n        || ch === 0x26\n        /* & */\n        || ch === 0x2A\n        /* * */\n        || ch === 0x21\n        /* ! */\n        || ch === 0x7C\n        /* | */\n        || ch === 0x3E\n        /* > */\n        || ch === 0x27\n        /* ' */\n        || ch === 0x22\n        /* \" */\n        || ch === 0x25\n        /* % */\n        || ch === 0x40\n        /* @ */\n        || ch === 0x60\n        /* ` */\n        ) {\n          return false;\n        }\n\n        if (ch === 0x3F\n        /* ? */\n        || ch === 0x2D\n        /* - */\n        ) {\n          following = state.input.charCodeAt(state.position + 1);\n\n          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n            return false;\n          }\n        }\n\n        state.kind = 'scalar';\n        state.result = '';\n        captureStart = captureEnd = state.position;\n        hasPendingContent = false;\n\n        while (ch !== 0) {\n          if (ch === 0x3A\n          /* : */\n          ) {\n            following = state.input.charCodeAt(state.position + 1);\n\n            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {\n              break;\n            }\n          } else if (ch === 0x23\n          /* # */\n          ) {\n            preceding = state.input.charCodeAt(state.position - 1);\n\n            if (is_WS_OR_EOL(preceding)) {\n              break;\n            }\n          } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n            break;\n          } else if (is_EOL(ch)) {\n            _line = state.line;\n            _lineStart = state.lineStart;\n            _lineIndent = state.lineIndent;\n            skipSeparationSpace(state, false, -1);\n\n            if (state.lineIndent >= nodeIndent) {\n              hasPendingContent = true;\n              ch = state.input.charCodeAt(state.position);\n              continue;\n            } else {\n              state.position = captureEnd;\n              state.line = _line;\n              state.lineStart = _lineStart;\n              state.lineIndent = _lineIndent;\n              break;\n            }\n          }\n\n          if (hasPendingContent) {\n            captureSegment(state, captureStart, captureEnd, false);\n            writeFoldedLines(state, state.line - _line);\n            captureStart = captureEnd = state.position;\n            hasPendingContent = false;\n          }\n\n          if (!is_WHITE_SPACE(ch)) {\n            captureEnd = state.position + 1;\n          }\n\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        captureSegment(state, captureStart, captureEnd, false);\n\n        if (state.result) {\n          return true;\n        }\n\n        state.kind = _kind;\n        state.result = _result;\n        return false;\n      }\n\n      function readSingleQuotedScalar(state, nodeIndent) {\n        var ch, captureStart, captureEnd;\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x27\n        /* ' */\n        ) {\n          return false;\n        }\n\n        state.kind = 'scalar';\n        state.result = '';\n        state.position++;\n        captureStart = captureEnd = state.position;\n\n        while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n          if (ch === 0x27\n          /* ' */\n          ) {\n            captureSegment(state, captureStart, state.position, true);\n            ch = state.input.charCodeAt(++state.position);\n\n            if (ch === 0x27\n            /* ' */\n            ) {\n              captureStart = state.position;\n              state.position++;\n              captureEnd = state.position;\n            } else {\n              return true;\n            }\n          } else if (is_EOL(ch)) {\n            captureSegment(state, captureStart, captureEnd, true);\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n            captureStart = captureEnd = state.position;\n          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            throwError(state, 'unexpected end of the document within a single quoted scalar');\n          } else {\n            state.position++;\n            captureEnd = state.position;\n          }\n        }\n\n        throwError(state, 'unexpected end of the stream within a single quoted scalar');\n      }\n\n      function readDoubleQuotedScalar(state, nodeIndent) {\n        var captureStart, captureEnd, hexLength, hexResult, tmp, ch;\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch !== 0x22\n        /* \" */\n        ) {\n          return false;\n        }\n\n        state.kind = 'scalar';\n        state.result = '';\n        state.position++;\n        captureStart = captureEnd = state.position;\n\n        while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n          if (ch === 0x22\n          /* \" */\n          ) {\n            captureSegment(state, captureStart, state.position, true);\n            state.position++;\n            return true;\n          } else if (ch === 0x5C\n          /* \\ */\n          ) {\n            captureSegment(state, captureStart, state.position, true);\n            ch = state.input.charCodeAt(++state.position);\n\n            if (is_EOL(ch)) {\n              skipSeparationSpace(state, false, nodeIndent); // TODO: rework to inline fn with no type cast?\n            } else if (ch < 256 && simpleEscapeCheck[ch]) {\n              state.result += simpleEscapeMap[ch];\n              state.position++;\n            } else if ((tmp = escapedHexLen(ch)) > 0) {\n              hexLength = tmp;\n              hexResult = 0;\n\n              for (; hexLength > 0; hexLength--) {\n                ch = state.input.charCodeAt(++state.position);\n\n                if ((tmp = fromHexCode(ch)) >= 0) {\n                  hexResult = (hexResult << 4) + tmp;\n                } else {\n                  throwError(state, 'expected hexadecimal character');\n                }\n              }\n\n              state.result += charFromCodepoint(hexResult);\n              state.position++;\n            } else {\n              throwError(state, 'unknown escape sequence');\n            }\n\n            captureStart = captureEnd = state.position;\n          } else if (is_EOL(ch)) {\n            captureSegment(state, captureStart, captureEnd, true);\n            writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n            captureStart = captureEnd = state.position;\n          } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n            throwError(state, 'unexpected end of the document within a double quoted scalar');\n          } else {\n            state.position++;\n            captureEnd = state.position;\n          }\n        }\n\n        throwError(state, 'unexpected end of the stream within a double quoted scalar');\n      }\n\n      function readFlowCollection(state, nodeIndent) {\n        var readNext = true,\n            _line,\n            _tag = state.tag,\n            _result,\n            _anchor = state.anchor,\n            following,\n            terminator,\n            isPair,\n            isExplicitPair,\n            isMapping,\n            overridableKeys = {},\n            keyNode,\n            keyTag,\n            valueNode,\n            ch;\n\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch === 0x5B\n        /* [ */\n        ) {\n          terminator = 0x5D;\n          /* ] */\n\n          isMapping = false;\n          _result = [];\n        } else if (ch === 0x7B\n        /* { */\n        ) {\n          terminator = 0x7D;\n          /* } */\n\n          isMapping = true;\n          _result = {};\n        } else {\n          return false;\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = _result;\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n\n        while (ch !== 0) {\n          skipSeparationSpace(state, true, nodeIndent);\n          ch = state.input.charCodeAt(state.position);\n\n          if (ch === terminator) {\n            state.position++;\n            state.tag = _tag;\n            state.anchor = _anchor;\n            state.kind = isMapping ? 'mapping' : 'sequence';\n            state.result = _result;\n            return true;\n          } else if (!readNext) {\n            throwError(state, 'missed comma between flow collection entries');\n          }\n\n          keyTag = keyNode = valueNode = null;\n          isPair = isExplicitPair = false;\n\n          if (ch === 0x3F\n          /* ? */\n          ) {\n            following = state.input.charCodeAt(state.position + 1);\n\n            if (is_WS_OR_EOL(following)) {\n              isPair = isExplicitPair = true;\n              state.position++;\n              skipSeparationSpace(state, true, nodeIndent);\n            }\n          }\n\n          _line = state.line;\n          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n          keyTag = state.tag;\n          keyNode = state.result;\n          skipSeparationSpace(state, true, nodeIndent);\n          ch = state.input.charCodeAt(state.position);\n\n          if ((isExplicitPair || state.line === _line) && ch === 0x3A\n          /* : */\n          ) {\n            isPair = true;\n            ch = state.input.charCodeAt(++state.position);\n            skipSeparationSpace(state, true, nodeIndent);\n            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n            valueNode = state.result;\n          }\n\n          if (isMapping) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n          } else if (isPair) {\n            _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n          } else {\n            _result.push(keyNode);\n          }\n\n          skipSeparationSpace(state, true, nodeIndent);\n          ch = state.input.charCodeAt(state.position);\n\n          if (ch === 0x2C\n          /* , */\n          ) {\n            readNext = true;\n            ch = state.input.charCodeAt(++state.position);\n          } else {\n            readNext = false;\n          }\n        }\n\n        throwError(state, 'unexpected end of the stream within a flow collection');\n      }\n\n      function readBlockScalar(state, nodeIndent) {\n        var captureStart,\n            folding,\n            chomping = CHOMPING_CLIP,\n            didReadContent = false,\n            detectedIndent = false,\n            textIndent = nodeIndent,\n            emptyLines = 0,\n            atMoreIndented = false,\n            tmp,\n            ch;\n        ch = state.input.charCodeAt(state.position);\n\n        if (ch === 0x7C\n        /* | */\n        ) {\n          folding = false;\n        } else if (ch === 0x3E\n        /* > */\n        ) {\n          folding = true;\n        } else {\n          return false;\n        }\n\n        state.kind = 'scalar';\n        state.result = '';\n\n        while (ch !== 0) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (ch === 0x2B\n          /* + */\n          || ch === 0x2D\n          /* - */\n          ) {\n            if (CHOMPING_CLIP === chomping) {\n              chomping = ch === 0x2B\n              /* + */\n              ? CHOMPING_KEEP : CHOMPING_STRIP;\n            } else {\n              throwError(state, 'repeat of a chomping mode identifier');\n            }\n          } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n            if (tmp === 0) {\n              throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n            } else if (!detectedIndent) {\n              textIndent = nodeIndent + tmp - 1;\n              detectedIndent = true;\n            } else {\n              throwError(state, 'repeat of an indentation width identifier');\n            }\n          } else {\n            break;\n          }\n        }\n\n        if (is_WHITE_SPACE(ch)) {\n          do {\n            ch = state.input.charCodeAt(++state.position);\n          } while (is_WHITE_SPACE(ch));\n\n          if (ch === 0x23\n          /* # */\n          ) {\n            do {\n              ch = state.input.charCodeAt(++state.position);\n            } while (!is_EOL(ch) && ch !== 0);\n          }\n        }\n\n        while (ch !== 0) {\n          readLineBreak(state);\n          state.lineIndent = 0;\n          ch = state.input.charCodeAt(state.position);\n\n          while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20\n          /* Space */\n          ) {\n            state.lineIndent++;\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          if (!detectedIndent && state.lineIndent > textIndent) {\n            textIndent = state.lineIndent;\n          }\n\n          if (is_EOL(ch)) {\n            emptyLines++;\n            continue;\n          } // End of the scalar.\n\n\n          if (state.lineIndent < textIndent) {\n            // Perform the chomping.\n            if (chomping === CHOMPING_KEEP) {\n              state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n            } else if (chomping === CHOMPING_CLIP) {\n              if (didReadContent) {\n                // i.e. only if the scalar is not empty.\n                state.result += '\\n';\n              }\n            } // Break this `while` cycle and go to the funciton's epilogue.\n\n\n            break;\n          } // Folded style: use fancy rules to handle line breaks.\n\n\n          if (folding) {\n            // Lines starting with white space characters (more-indented lines) are not folded.\n            if (is_WHITE_SPACE(ch)) {\n              atMoreIndented = true; // except for the first content line (cf. Example 8.1)\n\n              state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines); // End of more-indented block.\n            } else if (atMoreIndented) {\n              atMoreIndented = false;\n              state.result += common.repeat('\\n', emptyLines + 1); // Just one line break - perceive as the same line.\n            } else if (emptyLines === 0) {\n              if (didReadContent) {\n                // i.e. only if we have already read some scalar content.\n                state.result += ' ';\n              } // Several line breaks - perceive as different lines.\n\n            } else {\n              state.result += common.repeat('\\n', emptyLines);\n            } // Literal style: just add exact number of line breaks between content lines.\n\n          } else {\n            // Keep all line breaks except the header line break.\n            state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n          }\n\n          didReadContent = true;\n          detectedIndent = true;\n          emptyLines = 0;\n          captureStart = state.position;\n\n          while (!is_EOL(ch) && ch !== 0) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          captureSegment(state, captureStart, state.position, false);\n        }\n\n        return true;\n      }\n\n      function readBlockSequence(state, nodeIndent) {\n        var _line,\n            _tag = state.tag,\n            _anchor = state.anchor,\n            _result = [],\n            following,\n            detected = false,\n            ch;\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = _result;\n        }\n\n        ch = state.input.charCodeAt(state.position);\n\n        while (ch !== 0) {\n          if (ch !== 0x2D\n          /* - */\n          ) {\n            break;\n          }\n\n          following = state.input.charCodeAt(state.position + 1);\n\n          if (!is_WS_OR_EOL(following)) {\n            break;\n          }\n\n          detected = true;\n          state.position++;\n\n          if (skipSeparationSpace(state, true, -1)) {\n            if (state.lineIndent <= nodeIndent) {\n              _result.push(null);\n\n              ch = state.input.charCodeAt(state.position);\n              continue;\n            }\n          }\n\n          _line = state.line;\n          composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n\n          _result.push(state.result);\n\n          skipSeparationSpace(state, true, -1);\n          ch = state.input.charCodeAt(state.position);\n\n          if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {\n            throwError(state, 'bad indentation of a sequence entry');\n          } else if (state.lineIndent < nodeIndent) {\n            break;\n          }\n        }\n\n        if (detected) {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          state.kind = 'sequence';\n          state.result = _result;\n          return true;\n        }\n\n        return false;\n      }\n\n      function readBlockMapping(state, nodeIndent, flowIndent) {\n        var following,\n            allowCompact,\n            _line,\n            _pos,\n            _tag = state.tag,\n            _anchor = state.anchor,\n            _result = {},\n            overridableKeys = {},\n            keyTag = null,\n            keyNode = null,\n            valueNode = null,\n            atExplicitKey = false,\n            detected = false,\n            ch;\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = _result;\n        }\n\n        ch = state.input.charCodeAt(state.position);\n\n        while (ch !== 0) {\n          following = state.input.charCodeAt(state.position + 1);\n          _line = state.line; // Save the current line.\n\n          _pos = state.position; //\n          // Explicit notation case. There are two separate blocks:\n          // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n          //\n\n          if ((ch === 0x3F\n          /* ? */\n          || ch === 0x3A\n          /* : */\n          ) && is_WS_OR_EOL(following)) {\n            if (ch === 0x3F\n            /* ? */\n            ) {\n              if (atExplicitKey) {\n                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n                keyTag = keyNode = valueNode = null;\n              }\n\n              detected = true;\n              atExplicitKey = true;\n              allowCompact = true;\n            } else if (atExplicitKey) {\n              // i.e. 0x3A/* : */ === character after the explicit key.\n              atExplicitKey = false;\n              allowCompact = true;\n            } else {\n              throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n            }\n\n            state.position += 1;\n            ch = following; //\n            // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n            //\n          } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n            if (state.line === _line) {\n              ch = state.input.charCodeAt(state.position);\n\n              while (is_WHITE_SPACE(ch)) {\n                ch = state.input.charCodeAt(++state.position);\n              }\n\n              if (ch === 0x3A\n              /* : */\n              ) {\n                ch = state.input.charCodeAt(++state.position);\n\n                if (!is_WS_OR_EOL(ch)) {\n                  throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n                }\n\n                if (atExplicitKey) {\n                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n                  keyTag = keyNode = valueNode = null;\n                }\n\n                detected = true;\n                atExplicitKey = false;\n                allowCompact = false;\n                keyTag = state.tag;\n                keyNode = state.result;\n              } else if (detected) {\n                throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n              } else {\n                state.tag = _tag;\n                state.anchor = _anchor;\n                return true; // Keep the result of `composeNode`.\n              }\n            } else if (detected) {\n              throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n            } else {\n              state.tag = _tag;\n              state.anchor = _anchor;\n              return true; // Keep the result of `composeNode`.\n            }\n          } else {\n            break; // Reading is done. Go to the epilogue.\n          } //\n          // Common reading code for both explicit and implicit notations.\n          //\n\n\n          if (state.line === _line || state.lineIndent > nodeIndent) {\n            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n              if (atExplicitKey) {\n                keyNode = state.result;\n              } else {\n                valueNode = state.result;\n              }\n            }\n\n            if (!atExplicitKey) {\n              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n              keyTag = keyNode = valueNode = null;\n            }\n\n            skipSeparationSpace(state, true, -1);\n            ch = state.input.charCodeAt(state.position);\n          }\n\n          if (state.lineIndent > nodeIndent && ch !== 0) {\n            throwError(state, 'bad indentation of a mapping entry');\n          } else if (state.lineIndent < nodeIndent) {\n            break;\n          }\n        } //\n        // Epilogue.\n        //\n        // Special case: last mapping's node contains only the key in explicit notation.\n\n\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n        } // Expose the resulting mapping.\n\n\n        if (detected) {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          state.kind = 'mapping';\n          state.result = _result;\n        }\n\n        return detected;\n      }\n\n      function readTagProperty(state) {\n        var _position,\n            isVerbatim = false,\n            isNamed = false,\n            tagHandle,\n            tagName,\n            ch;\n\n        ch = state.input.charCodeAt(state.position);\n        if (ch !== 0x21\n        /* ! */\n        ) return false;\n\n        if (state.tag !== null) {\n          throwError(state, 'duplication of a tag property');\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n\n        if (ch === 0x3C\n        /* < */\n        ) {\n          isVerbatim = true;\n          ch = state.input.charCodeAt(++state.position);\n        } else if (ch === 0x21\n        /* ! */\n        ) {\n          isNamed = true;\n          tagHandle = '!!';\n          ch = state.input.charCodeAt(++state.position);\n        } else {\n          tagHandle = '!';\n        }\n\n        _position = state.position;\n\n        if (isVerbatim) {\n          do {\n            ch = state.input.charCodeAt(++state.position);\n          } while (ch !== 0 && ch !== 0x3E\n          /* > */\n          );\n\n          if (state.position < state.length) {\n            tagName = state.input.slice(_position, state.position);\n            ch = state.input.charCodeAt(++state.position);\n          } else {\n            throwError(state, 'unexpected end of the stream within a verbatim tag');\n          }\n        } else {\n          while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n            if (ch === 0x21\n            /* ! */\n            ) {\n              if (!isNamed) {\n                tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n                if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n                  throwError(state, 'named tag handle cannot contain such characters');\n                }\n\n                isNamed = true;\n                _position = state.position + 1;\n              } else {\n                throwError(state, 'tag suffix cannot contain exclamation marks');\n              }\n            }\n\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          tagName = state.input.slice(_position, state.position);\n\n          if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n            throwError(state, 'tag suffix cannot contain flow indicator characters');\n          }\n        }\n\n        if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n          throwError(state, 'tag name cannot contain such characters: ' + tagName);\n        }\n\n        if (isVerbatim) {\n          state.tag = tagName;\n        } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n          state.tag = state.tagMap[tagHandle] + tagName;\n        } else if (tagHandle === '!') {\n          state.tag = '!' + tagName;\n        } else if (tagHandle === '!!') {\n          state.tag = 'tag:yaml.org,2002:' + tagName;\n        } else {\n          throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n        }\n\n        return true;\n      }\n\n      function readAnchorProperty(state) {\n        var _position, ch;\n\n        ch = state.input.charCodeAt(state.position);\n        if (ch !== 0x26\n        /* & */\n        ) return false;\n\n        if (state.anchor !== null) {\n          throwError(state, 'duplication of an anchor property');\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n        _position = state.position;\n\n        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (state.position === _position) {\n          throwError(state, 'name of an anchor node must contain at least one character');\n        }\n\n        state.anchor = state.input.slice(_position, state.position);\n        return true;\n      }\n\n      function readAlias(state) {\n        var _position, alias, ch;\n\n        ch = state.input.charCodeAt(state.position);\n        if (ch !== 0x2A\n        /* * */\n        ) return false;\n        ch = state.input.charCodeAt(++state.position);\n        _position = state.position;\n\n        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (state.position === _position) {\n          throwError(state, 'name of an alias node must contain at least one character');\n        }\n\n        alias = state.input.slice(_position, state.position);\n\n        if (!_hasOwnProperty.call(state.anchorMap, alias)) {\n          throwError(state, 'unidentified alias \"' + alias + '\"');\n        }\n\n        state.result = state.anchorMap[alias];\n        skipSeparationSpace(state, true, -1);\n        return true;\n      }\n\n      function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n        var allowBlockStyles,\n            allowBlockScalars,\n            allowBlockCollections,\n            indentStatus = 1,\n            // 1: this>parent, 0: this=parent, -1: this<parent\n        atNewLine = false,\n            hasContent = false,\n            typeIndex,\n            typeQuantity,\n            type,\n            flowIndent,\n            blockIndent;\n\n        if (state.listener !== null) {\n          state.listener('open', state);\n        }\n\n        state.tag = null;\n        state.anchor = null;\n        state.kind = null;\n        state.result = null;\n        allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;\n\n        if (allowToSeek) {\n          if (skipSeparationSpace(state, true, -1)) {\n            atNewLine = true;\n\n            if (state.lineIndent > parentIndent) {\n              indentStatus = 1;\n            } else if (state.lineIndent === parentIndent) {\n              indentStatus = 0;\n            } else if (state.lineIndent < parentIndent) {\n              indentStatus = -1;\n            }\n          }\n        }\n\n        if (indentStatus === 1) {\n          while (readTagProperty(state) || readAnchorProperty(state)) {\n            if (skipSeparationSpace(state, true, -1)) {\n              atNewLine = true;\n              allowBlockCollections = allowBlockStyles;\n\n              if (state.lineIndent > parentIndent) {\n                indentStatus = 1;\n              } else if (state.lineIndent === parentIndent) {\n                indentStatus = 0;\n              } else if (state.lineIndent < parentIndent) {\n                indentStatus = -1;\n              }\n            } else {\n              allowBlockCollections = false;\n            }\n          }\n        }\n\n        if (allowBlockCollections) {\n          allowBlockCollections = atNewLine || allowCompact;\n        }\n\n        if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n          if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n            flowIndent = parentIndent;\n          } else {\n            flowIndent = parentIndent + 1;\n          }\n\n          blockIndent = state.position - state.lineStart;\n\n          if (indentStatus === 1) {\n            if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {\n              hasContent = true;\n            } else {\n              if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {\n                hasContent = true;\n              } else if (readAlias(state)) {\n                hasContent = true;\n\n                if (state.tag !== null || state.anchor !== null) {\n                  throwError(state, 'alias node should not have any properties');\n                }\n              } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n                hasContent = true;\n\n                if (state.tag === null) {\n                  state.tag = '?';\n                }\n              }\n\n              if (state.anchor !== null) {\n                state.anchorMap[state.anchor] = state.result;\n              }\n            }\n          } else if (indentStatus === 0) {\n            // Special case: block sequences are allowed to have same indentation level as the parent.\n            // http://www.yaml.org/spec/1.2/spec.html#id2799784\n            hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n          }\n        }\n\n        if (state.tag !== null && state.tag !== '!') {\n          if (state.tag === '?') {\n            // Implicit resolving is not allowed for non-scalar types, and '?'\n            // non-specific tag is only automatically assigned to plain scalars.\n            //\n            // We only need to check kind conformity in case user explicitly assigns '?'\n            // tag, for example like this: \"!<?> [0]\"\n            //\n            if (state.result !== null && state.kind !== 'scalar') {\n              throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n            }\n\n            for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n              type = state.implicitTypes[typeIndex];\n\n              if (type.resolve(state.result)) {\n                // `state.result` updated in resolver if matched\n                state.result = type.construct(state.result);\n                state.tag = type.tag;\n\n                if (state.anchor !== null) {\n                  state.anchorMap[state.anchor] = state.result;\n                }\n\n                break;\n              }\n            }\n          } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n            type = state.typeMap[state.kind || 'fallback'][state.tag];\n\n            if (state.result !== null && type.kind !== state.kind) {\n              throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n            }\n\n            if (!type.resolve(state.result)) {\n              // `state.result` updated in resolver if matched\n              throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n            } else {\n              state.result = type.construct(state.result);\n\n              if (state.anchor !== null) {\n                state.anchorMap[state.anchor] = state.result;\n              }\n            }\n          } else {\n            throwError(state, 'unknown tag !<' + state.tag + '>');\n          }\n        }\n\n        if (state.listener !== null) {\n          state.listener('close', state);\n        }\n\n        return state.tag !== null || state.anchor !== null || hasContent;\n      }\n\n      function readDocument(state) {\n        var documentStart = state.position,\n            _position,\n            directiveName,\n            directiveArgs,\n            hasDirectives = false,\n            ch;\n\n        state.version = null;\n        state.checkLineBreaks = state.legacy;\n        state.tagMap = {};\n        state.anchorMap = {};\n\n        while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n          skipSeparationSpace(state, true, -1);\n          ch = state.input.charCodeAt(state.position);\n\n          if (state.lineIndent > 0 || ch !== 0x25\n          /* % */\n          ) {\n            break;\n          }\n\n          hasDirectives = true;\n          ch = state.input.charCodeAt(++state.position);\n          _position = state.position;\n\n          while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          directiveName = state.input.slice(_position, state.position);\n          directiveArgs = [];\n\n          if (directiveName.length < 1) {\n            throwError(state, 'directive name must not be less than one character in length');\n          }\n\n          while (ch !== 0) {\n            while (is_WHITE_SPACE(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n\n            if (ch === 0x23\n            /* # */\n            ) {\n              do {\n                ch = state.input.charCodeAt(++state.position);\n              } while (ch !== 0 && !is_EOL(ch));\n\n              break;\n            }\n\n            if (is_EOL(ch)) break;\n            _position = state.position;\n\n            while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n              ch = state.input.charCodeAt(++state.position);\n            }\n\n            directiveArgs.push(state.input.slice(_position, state.position));\n          }\n\n          if (ch !== 0) readLineBreak(state);\n\n          if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n            directiveHandlers[directiveName](state, directiveName, directiveArgs);\n          } else {\n            throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n          }\n        }\n\n        skipSeparationSpace(state, true, -1);\n\n        if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D\n        /* - */\n        && state.input.charCodeAt(state.position + 1) === 0x2D\n        /* - */\n        && state.input.charCodeAt(state.position + 2) === 0x2D\n        /* - */\n        ) {\n          state.position += 3;\n          skipSeparationSpace(state, true, -1);\n        } else if (hasDirectives) {\n          throwError(state, 'directives end mark is expected');\n        }\n\n        composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n        skipSeparationSpace(state, true, -1);\n\n        if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n          throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n        }\n\n        state.documents.push(state.result);\n\n        if (state.position === state.lineStart && testDocumentSeparator(state)) {\n          if (state.input.charCodeAt(state.position) === 0x2E\n          /* . */\n          ) {\n            state.position += 3;\n            skipSeparationSpace(state, true, -1);\n          }\n\n          return;\n        }\n\n        if (state.position < state.length - 1) {\n          throwError(state, 'end of the stream or a document separator is expected');\n        } else {\n          return;\n        }\n      }\n\n      function loadDocuments(input, options) {\n        input = String(input);\n        options = options || {};\n\n        if (input.length !== 0) {\n          // Add tailing `\\n` if not exists\n          if (input.charCodeAt(input.length - 1) !== 0x0A\n          /* LF */\n          && input.charCodeAt(input.length - 1) !== 0x0D\n          /* CR */\n          ) {\n            input += '\\n';\n          } // Strip BOM\n\n\n          if (input.charCodeAt(0) === 0xFEFF) {\n            input = input.slice(1);\n          }\n        }\n\n        var state = new State(input, options);\n        var nullpos = input.indexOf('\\0');\n\n        if (nullpos !== -1) {\n          state.position = nullpos;\n          throwError(state, 'null byte is not allowed in input');\n        } // Use 0 as string terminator. That significantly simplifies bounds check.\n\n\n        state.input += '\\0';\n\n        while (state.input.charCodeAt(state.position) === 0x20\n        /* Space */\n        ) {\n          state.lineIndent += 1;\n          state.position += 1;\n        }\n\n        while (state.position < state.length - 1) {\n          readDocument(state);\n        }\n\n        return state.documents;\n      }\n\n      function loadAll(input, iterator, options) {\n        if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n          options = iterator;\n          iterator = null;\n        }\n\n        var documents = loadDocuments(input, options);\n\n        if (typeof iterator !== 'function') {\n          return documents;\n        }\n\n        for (var index = 0, length = documents.length; index < length; index += 1) {\n          iterator(documents[index]);\n        }\n      }\n\n      function load(input, options) {\n        var documents = loadDocuments(input, options);\n\n        if (documents.length === 0) {\n          /*eslint-disable no-undefined*/\n          return undefined;\n        } else if (documents.length === 1) {\n          return documents[0];\n        }\n\n        throw new YAMLException('expected a single document in the stream, but found more');\n      }\n\n      function safeLoadAll(input, iterator, options) {\n        if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {\n          options = iterator;\n          iterator = null;\n        }\n\n        return loadAll(input, iterator, common.extend({\n          schema: DEFAULT_SAFE_SCHEMA\n        }, options));\n      }\n\n      function safeLoad(input, options) {\n        return load(input, common.extend({\n          schema: DEFAULT_SAFE_SCHEMA\n        }, options));\n      }\n\n      module.exports.loadAll = loadAll;\n      module.exports.load = load;\n      module.exports.safeLoadAll = safeLoadAll;\n      module.exports.safeLoad = safeLoad;\n    }, {\n      \"./common\": 2,\n      \"./exception\": 4,\n      \"./mark\": 6,\n      \"./schema/default_full\": 9,\n      \"./schema/default_safe\": 10\n    }],\n    6: [function (require, module, exports) {\n      'use strict';\n\n      var common = require('./common');\n\n      function Mark(name, buffer, position, line, column) {\n        this.name = name;\n        this.buffer = buffer;\n        this.position = position;\n        this.line = line;\n        this.column = column;\n      }\n\n      Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n        var head, start, tail, end, snippet;\n        if (!this.buffer) return null;\n        indent = indent || 4;\n        maxLength = maxLength || 75;\n        head = '';\n        start = this.position;\n\n        while (start > 0 && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {\n          start -= 1;\n\n          if (this.position - start > maxLength / 2 - 1) {\n            head = ' ... ';\n            start += 5;\n            break;\n          }\n        }\n\n        tail = '';\n        end = this.position;\n\n        while (end < this.buffer.length && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end)) === -1) {\n          end += 1;\n\n          if (end - this.position > maxLength / 2 - 1) {\n            tail = ' ... ';\n            end -= 5;\n            break;\n          }\n        }\n\n        snippet = this.buffer.slice(start, end);\n        return common.repeat(' ', indent) + head + snippet + tail + '\\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';\n      };\n\n      Mark.prototype.toString = function toString(compact) {\n        var snippet,\n            where = '';\n\n        if (this.name) {\n          where += 'in \"' + this.name + '\" ';\n        }\n\n        where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n\n        if (!compact) {\n          snippet = this.getSnippet();\n\n          if (snippet) {\n            where += ':\\n' + snippet;\n          }\n        }\n\n        return where;\n      };\n\n      module.exports = Mark;\n    }, {\n      \"./common\": 2\n    }],\n    7: [function (require, module, exports) {\n      'use strict';\n      /*eslint-disable max-len*/\n\n      var common = require('./common');\n\n      var YAMLException = require('./exception');\n\n      var Type = require('./type');\n\n      function compileList(schema, name, result) {\n        var exclude = [];\n        schema.include.forEach(function (includedSchema) {\n          result = compileList(includedSchema, name, result);\n        });\n        schema[name].forEach(function (currentType) {\n          result.forEach(function (previousType, previousIndex) {\n            if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n              exclude.push(previousIndex);\n            }\n          });\n          result.push(currentType);\n        });\n        return result.filter(function (type, index) {\n          return exclude.indexOf(index) === -1;\n        });\n      }\n\n      function\n        /* lists... */\n      compileMap() {\n        var result = {\n          scalar: {},\n          sequence: {},\n          mapping: {},\n          fallback: {}\n        },\n            index,\n            length;\n\n        function collectType(type) {\n          result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n        }\n\n        for (index = 0, length = arguments.length; index < length; index += 1) {\n          arguments[index].forEach(collectType);\n        }\n\n        return result;\n      }\n\n      function Schema(definition) {\n        this.include = definition.include || [];\n        this.implicit = definition.implicit || [];\n        this.explicit = definition.explicit || [];\n        this.implicit.forEach(function (type) {\n          if (type.loadKind && type.loadKind !== 'scalar') {\n            throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n          }\n        });\n        this.compiledImplicit = compileList(this, 'implicit', []);\n        this.compiledExplicit = compileList(this, 'explicit', []);\n        this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);\n      }\n\n      Schema.DEFAULT = null;\n\n      Schema.create = function createSchema() {\n        var schemas, types;\n\n        switch (arguments.length) {\n          case 1:\n            schemas = Schema.DEFAULT;\n            types = arguments[0];\n            break;\n\n          case 2:\n            schemas = arguments[0];\n            types = arguments[1];\n            break;\n\n          default:\n            throw new YAMLException('Wrong number of arguments for Schema.create function');\n        }\n\n        schemas = common.toArray(schemas);\n        types = common.toArray(types);\n\n        if (!schemas.every(function (schema) {\n          return schema instanceof Schema;\n        })) {\n          throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n        }\n\n        if (!types.every(function (type) {\n          return type instanceof Type;\n        })) {\n          throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n        }\n\n        return new Schema({\n          include: schemas,\n          explicit: types\n        });\n      };\n\n      module.exports = Schema;\n    }, {\n      \"./common\": 2,\n      \"./exception\": 4,\n      \"./type\": 13\n    }],\n    8: [function (require, module, exports) {\n      // Standard YAML's Core schema.\n      // http://www.yaml.org/spec/1.2/spec.html#id2804923\n      //\n      // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n      // So, Core schema has no distinctions from JSON schema is JS-YAML.\n      'use strict';\n\n      var Schema = require('../schema');\n\n      module.exports = new Schema({\n        include: [require('./json')]\n      });\n    }, {\n      \"../schema\": 7,\n      \"./json\": 12\n    }],\n    9: [function (require, module, exports) {\n      // JS-YAML's default schema for `load` function.\n      // It is not described in the YAML specification.\n      //\n      // This schema is based on JS-YAML's default safe schema and includes\n      // JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.\n      //\n      // Also this schema is used as default base schema at `Schema.create` function.\n      'use strict';\n\n      var Schema = require('../schema');\n\n      module.exports = Schema.DEFAULT = new Schema({\n        include: [require('./default_safe')],\n        explicit: [require('../type/js/undefined'), require('../type/js/regexp'), require('../type/js/function')]\n      });\n    }, {\n      \"../schema\": 7,\n      \"../type/js/function\": 18,\n      \"../type/js/regexp\": 19,\n      \"../type/js/undefined\": 20,\n      \"./default_safe\": 10\n    }],\n    10: [function (require, module, exports) {\n      // JS-YAML's default schema for `safeLoad` function.\n      // It is not described in the YAML specification.\n      //\n      // This schema is based on standard YAML's Core schema and includes most of\n      // extra types described at YAML tag repository. (http://yaml.org/type/)\n      'use strict';\n\n      var Schema = require('../schema');\n\n      module.exports = new Schema({\n        include: [require('./core')],\n        implicit: [require('../type/timestamp'), require('../type/merge')],\n        explicit: [require('../type/binary'), require('../type/omap'), require('../type/pairs'), require('../type/set')]\n      });\n    }, {\n      \"../schema\": 7,\n      \"../type/binary\": 14,\n      \"../type/merge\": 22,\n      \"../type/omap\": 24,\n      \"../type/pairs\": 25,\n      \"../type/set\": 27,\n      \"../type/timestamp\": 29,\n      \"./core\": 8\n    }],\n    11: [function (require, module, exports) {\n      // Standard YAML's Failsafe schema.\n      // http://www.yaml.org/spec/1.2/spec.html#id2802346\n      'use strict';\n\n      var Schema = require('../schema');\n\n      module.exports = new Schema({\n        explicit: [require('../type/str'), require('../type/seq'), require('../type/map')]\n      });\n    }, {\n      \"../schema\": 7,\n      \"../type/map\": 21,\n      \"../type/seq\": 26,\n      \"../type/str\": 28\n    }],\n    12: [function (require, module, exports) {\n      // Standard YAML's JSON schema.\n      // http://www.yaml.org/spec/1.2/spec.html#id2803231\n      //\n      // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n      // So, this schema is not such strict as defined in the YAML specification.\n      // It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n      'use strict';\n\n      var Schema = require('../schema');\n\n      module.exports = new Schema({\n        include: [require('./failsafe')],\n        implicit: [require('../type/null'), require('../type/bool'), require('../type/int'), require('../type/float')]\n      });\n    }, {\n      \"../schema\": 7,\n      \"../type/bool\": 15,\n      \"../type/float\": 16,\n      \"../type/int\": 17,\n      \"../type/null\": 23,\n      \"./failsafe\": 11\n    }],\n    13: [function (require, module, exports) {\n      'use strict';\n\n      var YAMLException = require('./exception');\n\n      var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];\n      var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];\n\n      function compileStyleAliases(map) {\n        var result = {};\n\n        if (map !== null) {\n          Object.keys(map).forEach(function (style) {\n            map[style].forEach(function (alias) {\n              result[String(alias)] = style;\n            });\n          });\n        }\n\n        return result;\n      }\n\n      function Type(tag, options) {\n        options = options || {};\n        Object.keys(options).forEach(function (name) {\n          if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n            throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n          }\n        }); // TODO: Add tag format check.\n\n        this.tag = tag;\n        this.kind = options['kind'] || null;\n\n        this.resolve = options['resolve'] || function () {\n          return true;\n        };\n\n        this.construct = options['construct'] || function (data) {\n          return data;\n        };\n\n        this.instanceOf = options['instanceOf'] || null;\n        this.predicate = options['predicate'] || null;\n        this.represent = options['represent'] || null;\n        this.defaultStyle = options['defaultStyle'] || null;\n        this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n        if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n          throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n        }\n      }\n\n      module.exports = Type;\n    }, {\n      \"./exception\": 4\n    }],\n    14: [function (require, module, exports) {\n      'use strict';\n      /*eslint-disable no-bitwise*/\n\n      var NodeBuffer;\n\n      try {\n        // A trick for browserified version, to not include `Buffer` shim\n        var _require = require;\n        NodeBuffer = _require('buffer').Buffer;\n      } catch (__) {}\n\n      var Type = require('../type'); // [ 64, 65, 66 ] -> [ padding, CR, LF ]\n\n\n      var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n      function resolveYamlBinary(data) {\n        if (data === null) return false;\n        var code,\n            idx,\n            bitlen = 0,\n            max = data.length,\n            map = BASE64_MAP; // Convert one by one.\n\n        for (idx = 0; idx < max; idx++) {\n          code = map.indexOf(data.charAt(idx)); // Skip CR/LF\n\n          if (code > 64) continue; // Fail on illegal characters\n\n          if (code < 0) return false;\n          bitlen += 6;\n        } // If there are any bits left, source was corrupted\n\n\n        return bitlen % 8 === 0;\n      }\n\n      function constructYamlBinary(data) {\n        var idx,\n            tailbits,\n            input = data.replace(/[\\r\\n=]/g, ''),\n            // remove CR/LF & padding to simplify scan\n        max = input.length,\n            map = BASE64_MAP,\n            bits = 0,\n            result = []; // Collect by 6*4 bits (3 bytes)\n\n        for (idx = 0; idx < max; idx++) {\n          if (idx % 4 === 0 && idx) {\n            result.push(bits >> 16 & 0xFF);\n            result.push(bits >> 8 & 0xFF);\n            result.push(bits & 0xFF);\n          }\n\n          bits = bits << 6 | map.indexOf(input.charAt(idx));\n        } // Dump tail\n\n\n        tailbits = max % 4 * 6;\n\n        if (tailbits === 0) {\n          result.push(bits >> 16 & 0xFF);\n          result.push(bits >> 8 & 0xFF);\n          result.push(bits & 0xFF);\n        } else if (tailbits === 18) {\n          result.push(bits >> 10 & 0xFF);\n          result.push(bits >> 2 & 0xFF);\n        } else if (tailbits === 12) {\n          result.push(bits >> 4 & 0xFF);\n        } // Wrap into Buffer for NodeJS and leave Array for browser\n\n\n        if (NodeBuffer) {\n          // Support node 6.+ Buffer API when available\n          return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n        }\n\n        return result;\n      }\n\n      function representYamlBinary(object\n      /*, style*/\n      ) {\n        var result = '',\n            bits = 0,\n            idx,\n            tail,\n            max = object.length,\n            map = BASE64_MAP; // Convert every three bytes to 4 ASCII characters.\n\n        for (idx = 0; idx < max; idx++) {\n          if (idx % 3 === 0 && idx) {\n            result += map[bits >> 18 & 0x3F];\n            result += map[bits >> 12 & 0x3F];\n            result += map[bits >> 6 & 0x3F];\n            result += map[bits & 0x3F];\n          }\n\n          bits = (bits << 8) + object[idx];\n        } // Dump tail\n\n\n        tail = max % 3;\n\n        if (tail === 0) {\n          result += map[bits >> 18 & 0x3F];\n          result += map[bits >> 12 & 0x3F];\n          result += map[bits >> 6 & 0x3F];\n          result += map[bits & 0x3F];\n        } else if (tail === 2) {\n          result += map[bits >> 10 & 0x3F];\n          result += map[bits >> 4 & 0x3F];\n          result += map[bits << 2 & 0x3F];\n          result += map[64];\n        } else if (tail === 1) {\n          result += map[bits >> 2 & 0x3F];\n          result += map[bits << 4 & 0x3F];\n          result += map[64];\n          result += map[64];\n        }\n\n        return result;\n      }\n\n      function isBinary(object) {\n        return NodeBuffer && NodeBuffer.isBuffer(object);\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:binary', {\n        kind: 'scalar',\n        resolve: resolveYamlBinary,\n        construct: constructYamlBinary,\n        predicate: isBinary,\n        represent: representYamlBinary\n      });\n    }, {\n      \"../type\": 13\n    }],\n    15: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      function resolveYamlBoolean(data) {\n        if (data === null) return false;\n        var max = data.length;\n        return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');\n      }\n\n      function constructYamlBoolean(data) {\n        return data === 'true' || data === 'True' || data === 'TRUE';\n      }\n\n      function isBoolean(object) {\n        return Object.prototype.toString.call(object) === '[object Boolean]';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:bool', {\n        kind: 'scalar',\n        resolve: resolveYamlBoolean,\n        construct: constructYamlBoolean,\n        predicate: isBoolean,\n        represent: {\n          lowercase: function (object) {\n            return object ? 'true' : 'false';\n          },\n          uppercase: function (object) {\n            return object ? 'TRUE' : 'FALSE';\n          },\n          camelcase: function (object) {\n            return object ? 'True' : 'False';\n          }\n        },\n        defaultStyle: 'lowercase'\n      });\n    }, {\n      \"../type\": 13\n    }],\n    16: [function (require, module, exports) {\n      'use strict';\n\n      var common = require('../common');\n\n      var Type = require('../type');\n\n      var YAML_FLOAT_PATTERN = new RegExp( // 2.5e4, 2.5 and integers\n      '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + // .2e4, .2\n      // special case, seems not from spec\n      '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + // 20:59\n      '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' + // .inf\n      '|[-+]?\\\\.(?:inf|Inf|INF)' + // .nan\n      '|\\\\.(?:nan|NaN|NAN))$');\n\n      function resolveYamlFloat(data) {\n        if (data === null) return false;\n\n        if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`\n        // Probably should update regexp & check speed\n        data[data.length - 1] === '_') {\n          return false;\n        }\n\n        return true;\n      }\n\n      function constructYamlFloat(data) {\n        var value, sign, base, digits;\n        value = data.replace(/_/g, '').toLowerCase();\n        sign = value[0] === '-' ? -1 : 1;\n        digits = [];\n\n        if ('+-'.indexOf(value[0]) >= 0) {\n          value = value.slice(1);\n        }\n\n        if (value === '.inf') {\n          return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n        } else if (value === '.nan') {\n          return NaN;\n        } else if (value.indexOf(':') >= 0) {\n          value.split(':').forEach(function (v) {\n            digits.unshift(parseFloat(v, 10));\n          });\n          value = 0.0;\n          base = 1;\n          digits.forEach(function (d) {\n            value += d * base;\n            base *= 60;\n          });\n          return sign * value;\n        }\n\n        return sign * parseFloat(value, 10);\n      }\n\n      var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\n      function representYamlFloat(object, style) {\n        var res;\n\n        if (isNaN(object)) {\n          switch (style) {\n            case 'lowercase':\n              return '.nan';\n\n            case 'uppercase':\n              return '.NAN';\n\n            case 'camelcase':\n              return '.NaN';\n          }\n        } else if (Number.POSITIVE_INFINITY === object) {\n          switch (style) {\n            case 'lowercase':\n              return '.inf';\n\n            case 'uppercase':\n              return '.INF';\n\n            case 'camelcase':\n              return '.Inf';\n          }\n        } else if (Number.NEGATIVE_INFINITY === object) {\n          switch (style) {\n            case 'lowercase':\n              return '-.inf';\n\n            case 'uppercase':\n              return '-.INF';\n\n            case 'camelcase':\n              return '-.Inf';\n          }\n        } else if (common.isNegativeZero(object)) {\n          return '-0.0';\n        }\n\n        res = object.toString(10); // JS stringifier can build scientific format without dots: 5e-100,\n        // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n        return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n      }\n\n      function isFloat(object) {\n        return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:float', {\n        kind: 'scalar',\n        resolve: resolveYamlFloat,\n        construct: constructYamlFloat,\n        predicate: isFloat,\n        represent: representYamlFloat,\n        defaultStyle: 'lowercase'\n      });\n    }, {\n      \"../common\": 2,\n      \"../type\": 13\n    }],\n    17: [function (require, module, exports) {\n      'use strict';\n\n      var common = require('../common');\n\n      var Type = require('../type');\n\n      function isHexCode(c) {\n        return 0x30\n        /* 0 */\n        <= c && c <= 0x39\n        /* 9 */\n        || 0x41\n        /* A */\n        <= c && c <= 0x46\n        /* F */\n        || 0x61\n        /* a */\n        <= c && c <= 0x66\n        /* f */\n        ;\n      }\n\n      function isOctCode(c) {\n        return 0x30\n        /* 0 */\n        <= c && c <= 0x37\n        /* 7 */\n        ;\n      }\n\n      function isDecCode(c) {\n        return 0x30\n        /* 0 */\n        <= c && c <= 0x39\n        /* 9 */\n        ;\n      }\n\n      function resolveYamlInteger(data) {\n        if (data === null) return false;\n        var max = data.length,\n            index = 0,\n            hasDigits = false,\n            ch;\n        if (!max) return false;\n        ch = data[index]; // sign\n\n        if (ch === '-' || ch === '+') {\n          ch = data[++index];\n        }\n\n        if (ch === '0') {\n          // 0\n          if (index + 1 === max) return true;\n          ch = data[++index]; // base 2, base 8, base 16\n\n          if (ch === 'b') {\n            // base 2\n            index++;\n\n            for (; index < max; index++) {\n              ch = data[index];\n              if (ch === '_') continue;\n              if (ch !== '0' && ch !== '1') return false;\n              hasDigits = true;\n            }\n\n            return hasDigits && ch !== '_';\n          }\n\n          if (ch === 'x') {\n            // base 16\n            index++;\n\n            for (; index < max; index++) {\n              ch = data[index];\n              if (ch === '_') continue;\n              if (!isHexCode(data.charCodeAt(index))) return false;\n              hasDigits = true;\n            }\n\n            return hasDigits && ch !== '_';\n          } // base 8\n\n\n          for (; index < max; index++) {\n            ch = data[index];\n            if (ch === '_') continue;\n            if (!isOctCode(data.charCodeAt(index))) return false;\n            hasDigits = true;\n          }\n\n          return hasDigits && ch !== '_';\n        } // base 10 (except 0) or base 60\n        // value should not start with `_`;\n\n\n        if (ch === '_') return false;\n\n        for (; index < max; index++) {\n          ch = data[index];\n          if (ch === '_') continue;\n          if (ch === ':') break;\n\n          if (!isDecCode(data.charCodeAt(index))) {\n            return false;\n          }\n\n          hasDigits = true;\n        } // Should have digits and should not end with `_`\n\n\n        if (!hasDigits || ch === '_') return false; // if !base60 - done;\n\n        if (ch !== ':') return true; // base60 almost not used, no needs to optimize\n\n        return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n      }\n\n      function constructYamlInteger(data) {\n        var value = data,\n            sign = 1,\n            ch,\n            base,\n            digits = [];\n\n        if (value.indexOf('_') !== -1) {\n          value = value.replace(/_/g, '');\n        }\n\n        ch = value[0];\n\n        if (ch === '-' || ch === '+') {\n          if (ch === '-') sign = -1;\n          value = value.slice(1);\n          ch = value[0];\n        }\n\n        if (value === '0') return 0;\n\n        if (ch === '0') {\n          if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n          if (value[1] === 'x') return sign * parseInt(value, 16);\n          return sign * parseInt(value, 8);\n        }\n\n        if (value.indexOf(':') !== -1) {\n          value.split(':').forEach(function (v) {\n            digits.unshift(parseInt(v, 10));\n          });\n          value = 0;\n          base = 1;\n          digits.forEach(function (d) {\n            value += d * base;\n            base *= 60;\n          });\n          return sign * value;\n        }\n\n        return sign * parseInt(value, 10);\n      }\n\n      function isInteger(object) {\n        return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:int', {\n        kind: 'scalar',\n        resolve: resolveYamlInteger,\n        construct: constructYamlInteger,\n        predicate: isInteger,\n        represent: {\n          binary: function (obj) {\n            return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);\n          },\n          octal: function (obj) {\n            return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);\n          },\n          decimal: function (obj) {\n            return obj.toString(10);\n          },\n\n          /* eslint-disable max-len */\n          hexadecimal: function (obj) {\n            return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);\n          }\n        },\n        defaultStyle: 'decimal',\n        styleAliases: {\n          binary: [2, 'bin'],\n          octal: [8, 'oct'],\n          decimal: [10, 'dec'],\n          hexadecimal: [16, 'hex']\n        }\n      });\n    }, {\n      \"../common\": 2,\n      \"../type\": 13\n    }],\n    18: [function (require, module, exports) {\n      'use strict';\n\n      var esprima; // Browserified version does not have esprima\n      //\n      // 1. For node.js just require module as deps\n      // 2. For browser try to require mudule via external AMD system.\n      //    If not found - try to fallback to window.esprima. If not\n      //    found too - then fail to parse.\n      //\n\n      try {\n        // workaround to exclude package from browserify list.\n        var _require = require;\n        esprima = _require('esprima');\n      } catch (_) {\n        /* eslint-disable no-redeclare */\n\n        /* global window */\n        if (typeof window !== 'undefined') esprima = window.esprima;\n      }\n\n      var Type = require('../../type');\n\n      function resolveJavascriptFunction(data) {\n        if (data === null) return false;\n\n        try {\n          var source = '(' + data + ')',\n              ast = esprima.parse(source, {\n            range: true\n          });\n\n          if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {\n            return false;\n          }\n\n          return true;\n        } catch (err) {\n          return false;\n        }\n      }\n\n      function constructJavascriptFunction(data) {\n        /*jslint evil:true*/\n        var source = '(' + data + ')',\n            ast = esprima.parse(source, {\n          range: true\n        }),\n            params = [],\n            body;\n\n        if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {\n          throw new Error('Failed to resolve function');\n        }\n\n        ast.body[0].expression.params.forEach(function (param) {\n          params.push(param.name);\n        });\n        body = ast.body[0].expression.body.range; // Esprima's ranges include the first '{' and the last '}' characters on\n        // function expressions. So cut them out.\n\n        if (ast.body[0].expression.body.type === 'BlockStatement') {\n          /*eslint-disable no-new-func*/\n          return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n        } // ES6 arrow functions can omit the BlockStatement. In that case, just return\n        // the body.\n\n        /*eslint-disable no-new-func*/\n\n\n        return new Function(params, 'return ' + source.slice(body[0], body[1]));\n      }\n\n      function representJavascriptFunction(object\n      /*, style*/\n      ) {\n        return object.toString();\n      }\n\n      function isFunction(object) {\n        return Object.prototype.toString.call(object) === '[object Function]';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:js/function', {\n        kind: 'scalar',\n        resolve: resolveJavascriptFunction,\n        construct: constructJavascriptFunction,\n        predicate: isFunction,\n        represent: representJavascriptFunction\n      });\n    }, {\n      \"../../type\": 13\n    }],\n    19: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../../type');\n\n      function resolveJavascriptRegExp(data) {\n        if (data === null) return false;\n        if (data.length === 0) return false;\n        var regexp = data,\n            tail = /\\/([gim]*)$/.exec(data),\n            modifiers = ''; // if regexp starts with '/' it can have modifiers and must be properly closed\n        // `/foo/gim` - modifiers tail can be maximum 3 chars\n\n        if (regexp[0] === '/') {\n          if (tail) modifiers = tail[1];\n          if (modifiers.length > 3) return false; // if expression starts with /, is should be properly terminated\n\n          if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n        }\n\n        return true;\n      }\n\n      function constructJavascriptRegExp(data) {\n        var regexp = data,\n            tail = /\\/([gim]*)$/.exec(data),\n            modifiers = ''; // `/foo/gim` - tail can be maximum 4 chars\n\n        if (regexp[0] === '/') {\n          if (tail) modifiers = tail[1];\n          regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n        }\n\n        return new RegExp(regexp, modifiers);\n      }\n\n      function representJavascriptRegExp(object\n      /*, style*/\n      ) {\n        var result = '/' + object.source + '/';\n        if (object.global) result += 'g';\n        if (object.multiline) result += 'm';\n        if (object.ignoreCase) result += 'i';\n        return result;\n      }\n\n      function isRegExp(object) {\n        return Object.prototype.toString.call(object) === '[object RegExp]';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:js/regexp', {\n        kind: 'scalar',\n        resolve: resolveJavascriptRegExp,\n        construct: constructJavascriptRegExp,\n        predicate: isRegExp,\n        represent: representJavascriptRegExp\n      });\n    }, {\n      \"../../type\": 13\n    }],\n    20: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../../type');\n\n      function resolveJavascriptUndefined() {\n        return true;\n      }\n\n      function constructJavascriptUndefined() {\n        /*eslint-disable no-undefined*/\n        return undefined;\n      }\n\n      function representJavascriptUndefined() {\n        return '';\n      }\n\n      function isUndefined(object) {\n        return typeof object === 'undefined';\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:js/undefined', {\n        kind: 'scalar',\n        resolve: resolveJavascriptUndefined,\n        construct: constructJavascriptUndefined,\n        predicate: isUndefined,\n        represent: representJavascriptUndefined\n      });\n    }, {\n      \"../../type\": 13\n    }],\n    21: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      module.exports = new Type('tag:yaml.org,2002:map', {\n        kind: 'mapping',\n        construct: function (data) {\n          return data !== null ? data : {};\n        }\n      });\n    }, {\n      \"../type\": 13\n    }],\n    22: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      function resolveYamlMerge(data) {\n        return data === '<<' || data === null;\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:merge', {\n        kind: 'scalar',\n        resolve: resolveYamlMerge\n      });\n    }, {\n      \"../type\": 13\n    }],\n    23: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      function resolveYamlNull(data) {\n        if (data === null) return true;\n        var max = data.length;\n        return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');\n      }\n\n      function constructYamlNull() {\n        return null;\n      }\n\n      function isNull(object) {\n        return object === null;\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:null', {\n        kind: 'scalar',\n        resolve: resolveYamlNull,\n        construct: constructYamlNull,\n        predicate: isNull,\n        represent: {\n          canonical: function () {\n            return '~';\n          },\n          lowercase: function () {\n            return 'null';\n          },\n          uppercase: function () {\n            return 'NULL';\n          },\n          camelcase: function () {\n            return 'Null';\n          }\n        },\n        defaultStyle: 'lowercase'\n      });\n    }, {\n      \"../type\": 13\n    }],\n    24: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n      var _toString = Object.prototype.toString;\n\n      function resolveYamlOmap(data) {\n        if (data === null) return true;\n        var objectKeys = [],\n            index,\n            length,\n            pair,\n            pairKey,\n            pairHasKey,\n            object = data;\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          pair = object[index];\n          pairHasKey = false;\n          if (_toString.call(pair) !== '[object Object]') return false;\n\n          for (pairKey in pair) {\n            if (_hasOwnProperty.call(pair, pairKey)) {\n              if (!pairHasKey) pairHasKey = true;else return false;\n            }\n          }\n\n          if (!pairHasKey) return false;\n          if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;\n        }\n\n        return true;\n      }\n\n      function constructYamlOmap(data) {\n        return data !== null ? data : [];\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:omap', {\n        kind: 'sequence',\n        resolve: resolveYamlOmap,\n        construct: constructYamlOmap\n      });\n    }, {\n      \"../type\": 13\n    }],\n    25: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var _toString = Object.prototype.toString;\n\n      function resolveYamlPairs(data) {\n        if (data === null) return true;\n        var index,\n            length,\n            pair,\n            keys,\n            result,\n            object = data;\n        result = new Array(object.length);\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          pair = object[index];\n          if (_toString.call(pair) !== '[object Object]') return false;\n          keys = Object.keys(pair);\n          if (keys.length !== 1) return false;\n          result[index] = [keys[0], pair[keys[0]]];\n        }\n\n        return true;\n      }\n\n      function constructYamlPairs(data) {\n        if (data === null) return [];\n        var index,\n            length,\n            pair,\n            keys,\n            result,\n            object = data;\n        result = new Array(object.length);\n\n        for (index = 0, length = object.length; index < length; index += 1) {\n          pair = object[index];\n          keys = Object.keys(pair);\n          result[index] = [keys[0], pair[keys[0]]];\n        }\n\n        return result;\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:pairs', {\n        kind: 'sequence',\n        resolve: resolveYamlPairs,\n        construct: constructYamlPairs\n      });\n    }, {\n      \"../type\": 13\n    }],\n    26: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      module.exports = new Type('tag:yaml.org,2002:seq', {\n        kind: 'sequence',\n        construct: function (data) {\n          return data !== null ? data : [];\n        }\n      });\n    }, {\n      \"../type\": 13\n    }],\n    27: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n      function resolveYamlSet(data) {\n        if (data === null) return true;\n        var key,\n            object = data;\n\n        for (key in object) {\n          if (_hasOwnProperty.call(object, key)) {\n            if (object[key] !== null) return false;\n          }\n        }\n\n        return true;\n      }\n\n      function constructYamlSet(data) {\n        return data !== null ? data : {};\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:set', {\n        kind: 'mapping',\n        resolve: resolveYamlSet,\n        construct: constructYamlSet\n      });\n    }, {\n      \"../type\": 13\n    }],\n    28: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      module.exports = new Type('tag:yaml.org,2002:str', {\n        kind: 'scalar',\n        construct: function (data) {\n          return data !== null ? data : '';\n        }\n      });\n    }, {\n      \"../type\": 13\n    }],\n    29: [function (require, module, exports) {\n      'use strict';\n\n      var Type = require('../type');\n\n      var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year\n      '-([0-9][0-9])' + // [2] month\n      '-([0-9][0-9])$'); // [3] day\n\n      var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year\n      '-([0-9][0-9]?)' + // [2] month\n      '-([0-9][0-9]?)' + // [3] day\n      '(?:[Tt]|[ \\\\t]+)' + // ...\n      '([0-9][0-9]?)' + // [4] hour\n      ':([0-9][0-9])' + // [5] minute\n      ':([0-9][0-9])' + // [6] second\n      '(?:\\\\.([0-9]*))?' + // [7] fraction\n      '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n      '(?::([0-9][0-9]))?))?$'); // [11] tz_minute\n\n      function resolveYamlTimestamp(data) {\n        if (data === null) return false;\n        if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n        if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n        return false;\n      }\n\n      function constructYamlTimestamp(data) {\n        var match,\n            year,\n            month,\n            day,\n            hour,\n            minute,\n            second,\n            fraction = 0,\n            delta = null,\n            tz_hour,\n            tz_minute,\n            date;\n        match = YAML_DATE_REGEXP.exec(data);\n        if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n        if (match === null) throw new Error('Date resolve error'); // match: [1] year [2] month [3] day\n\n        year = +match[1];\n        month = +match[2] - 1; // JS month starts with 0\n\n        day = +match[3];\n\n        if (!match[4]) {\n          // no hour\n          return new Date(Date.UTC(year, month, day));\n        } // match: [4] hour [5] minute [6] second [7] fraction\n\n\n        hour = +match[4];\n        minute = +match[5];\n        second = +match[6];\n\n        if (match[7]) {\n          fraction = match[7].slice(0, 3);\n\n          while (fraction.length < 3) {\n            // milli-seconds\n            fraction += '0';\n          }\n\n          fraction = +fraction;\n        } // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n\n        if (match[9]) {\n          tz_hour = +match[10];\n          tz_minute = +(match[11] || 0);\n          delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n\n          if (match[9] === '-') delta = -delta;\n        }\n\n        date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n        if (delta) date.setTime(date.getTime() - delta);\n        return date;\n      }\n\n      function representYamlTimestamp(object\n      /*, style*/\n      ) {\n        return object.toISOString();\n      }\n\n      module.exports = new Type('tag:yaml.org,2002:timestamp', {\n        kind: 'scalar',\n        resolve: resolveYamlTimestamp,\n        construct: constructYamlTimestamp,\n        instanceOf: Date,\n        represent: representYamlTimestamp\n      });\n    }, {\n      \"../type\": 13\n    }],\n    \"/\": [function (require, module, exports) {\n      'use strict';\n\n      var yaml = require('./lib/js-yaml.js');\n\n      module.exports = yaml;\n    }, {\n      \"./lib/js-yaml.js\": 1\n    }]\n  }, {}, [])(\"/\");\n});","map":{"version":3,"names":["f","exports","module","define","amd","g","window","global","self","jsyaml","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","loader","dumper","deprecated","name","Type","Schema","FAILSAFE_SCHEMA","JSON_SCHEMA","CORE_SCHEMA","DEFAULT_SAFE_SCHEMA","DEFAULT_FULL_SCHEMA","load","loadAll","safeLoad","safeLoadAll","dump","safeDump","YAMLException","MINIMAL_SCHEMA","SAFE_SCHEMA","DEFAULT_SCHEMA","scan","parse","compose","addConstructor","isNothing","subject","isObject","toArray","sequence","Array","isArray","extend","target","source","index","key","sourceKeys","Object","keys","repeat","string","count","result","cycle","isNegativeZero","number","Number","NEGATIVE_INFINITY","common","_toString","prototype","toString","_hasOwnProperty","hasOwnProperty","CHAR_TAB","CHAR_LINE_FEED","CHAR_CARRIAGE_RETURN","CHAR_SPACE","CHAR_EXCLAMATION","CHAR_DOUBLE_QUOTE","CHAR_SHARP","CHAR_PERCENT","CHAR_AMPERSAND","CHAR_SINGLE_QUOTE","CHAR_ASTERISK","CHAR_COMMA","CHAR_MINUS","CHAR_COLON","CHAR_EQUALS","CHAR_GREATER_THAN","CHAR_QUESTION","CHAR_COMMERCIAL_AT","CHAR_LEFT_SQUARE_BRACKET","CHAR_RIGHT_SQUARE_BRACKET","CHAR_GRAVE_ACCENT","CHAR_LEFT_CURLY_BRACKET","CHAR_VERTICAL_LINE","CHAR_RIGHT_CURLY_BRACKET","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","compileStyleMap","schema","map","tag","style","type","String","slice","compiledTypeMap","styleAliases","encodeHex","character","handle","toUpperCase","State","options","indent","Math","max","noArrayIndent","skipInvalid","flowLevel","styleMap","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","implicitTypes","compiledImplicit","explicitTypes","compiledExplicit","duplicates","usedDuplicates","indentString","spaces","ind","position","next","line","indexOf","generateNextLine","state","level","testImplicitResolving","str","resolve","isWhitespace","isPrintable","isNsChar","isPlainSafe","prev","isPlainSafeFirst","needIndentIndicator","leadingSpaceRe","test","STYLE_PLAIN","STYLE_SINGLE","STYLE_LITERAL","STYLE_FOLDED","STYLE_DOUBLE","chooseScalarStyle","singleLineOnly","indentPerLevel","testAmbiguousType","char","prev_char","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","charCodeAt","writeScalar","iskey","min","testAmbiguity","replace","blockHeader","dropEndingNewline","foldString","escapeString","indentIndicator","clip","keep","chomp","width","lineRe","nextLF","lastIndex","foldLine","prevMoreIndented","moreIndented","match","exec","prefix","breakRe","start","end","curr","nextChar","escapeSeq","writeFlowSequence","object","_result","_tag","writeNode","writeBlockSequence","compact","writeFlowMapping","objectKeyList","objectKey","objectValue","pairBuffer","writeBlockMapping","explicitPair","sort","detectType","explicit","typeList","instanceOf","predicate","represent","defaultStyle","block","objectOrArray","duplicateIndex","duplicate","arrayLevel","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","push","input","reason","mark","message","captureStackTrace","constructor","stack","create","Mark","CONTEXT_FLOW_IN","CONTEXT_FLOW_OUT","CONTEXT_BLOCK_IN","CONTEXT_BLOCK_OUT","CHOMPING_CLIP","CHOMPING_STRIP","CHOMPING_KEEP","PATTERN_NON_PRINTABLE","PATTERN_NON_ASCII_LINE_BREAKS","PATTERN_FLOW_INDICATORS","PATTERN_TAG_HANDLE","PATTERN_TAG_URI","_class","obj","is_EOL","is_WHITE_SPACE","is_WS_OR_EOL","is_FLOW_INDICATOR","fromHexCode","lc","escapedHexLen","fromDecimalCode","simpleEscapeSequence","charFromCodepoint","fromCharCode","simpleEscapeCheck","simpleEscapeMap","filename","onWarning","legacy","json","listener","typeMap","lineStart","lineIndent","documents","generateError","throwError","throwWarning","directiveHandlers","YAML","handleYamlDirective","args","major","minor","version","parseInt","checkLineBreaks","TAG","handleTagDirective","tagMap","captureSegment","checkJson","_position","_length","_character","mergeMappings","destination","overridableKeys","quantity","storeMappingPair","keyTag","keyNode","valueNode","startLine","startPos","readLineBreak","ch","skipSeparationSpace","allowComments","checkIndent","lineBreaks","testDocumentSeparator","writeFoldedLines","readPlainScalar","nodeIndent","withinFlowCollection","preceding","following","captureStart","captureEnd","hasPendingContent","_line","_lineStart","_lineIndent","_kind","kind","readSingleQuotedScalar","readDoubleQuotedScalar","hexLength","hexResult","tmp","readFlowCollection","readNext","_anchor","anchor","terminator","isPair","isExplicitPair","isMapping","anchorMap","composeNode","readBlockScalar","folding","chomping","didReadContent","detectedIndent","textIndent","emptyLines","atMoreIndented","readBlockSequence","detected","readBlockMapping","flowIndent","allowCompact","_pos","atExplicitKey","readTagProperty","isVerbatim","isNamed","tagHandle","tagName","readAnchorProperty","readAlias","alias","parentIndent","nodeContext","allowToSeek","allowBlockStyles","allowBlockScalars","allowBlockCollections","indentStatus","atNewLine","hasContent","typeIndex","typeQuantity","blockIndent","construct","readDocument","documentStart","directiveName","directiveArgs","hasDirectives","loadDocuments","nullpos","iterator","undefined","buffer","column","getSnippet","maxLength","head","tail","snippet","charAt","where","compileList","exclude","include","forEach","includedSchema","currentType","previousType","previousIndex","filter","compileMap","scalar","mapping","fallback","collectType","arguments","definition","implicit","loadKind","DEFAULT","createSchema","schemas","types","every","TYPE_CONSTRUCTOR_OPTIONS","YAML_NODE_KINDS","compileStyleAliases","data","NodeBuffer","_require","Buffer","__","BASE64_MAP","resolveYamlBinary","idx","bitlen","constructYamlBinary","tailbits","bits","from","representYamlBinary","isBinary","isBuffer","resolveYamlBoolean","constructYamlBoolean","isBoolean","lowercase","uppercase","camelcase","YAML_FLOAT_PATTERN","RegExp","resolveYamlFloat","constructYamlFloat","value","sign","base","digits","toLowerCase","POSITIVE_INFINITY","NaN","split","v","unshift","parseFloat","d","SCIENTIFIC_WITHOUT_DOT","representYamlFloat","res","isNaN","isFloat","isHexCode","isOctCode","isDecCode","resolveYamlInteger","hasDigits","constructYamlInteger","isInteger","binary","octal","decimal","hexadecimal","esprima","_","resolveJavascriptFunction","ast","range","body","expression","err","constructJavascriptFunction","params","param","Function","representJavascriptFunction","isFunction","resolveJavascriptRegExp","regexp","modifiers","constructJavascriptRegExp","representJavascriptRegExp","multiline","ignoreCase","isRegExp","resolveJavascriptUndefined","constructJavascriptUndefined","representJavascriptUndefined","isUndefined","resolveYamlMerge","resolveYamlNull","constructYamlNull","isNull","canonical","resolveYamlOmap","objectKeys","pair","pairKey","pairHasKey","constructYamlOmap","resolveYamlPairs","constructYamlPairs","resolveYamlSet","constructYamlSet","YAML_DATE_REGEXP","YAML_TIMESTAMP_REGEXP","resolveYamlTimestamp","constructYamlTimestamp","year","month","day","hour","minute","second","fraction","delta","tz_hour","tz_minute","date","Date","UTC","setTime","getTime","representYamlTimestamp","toISOString","yaml"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/js-yaml/dist/js-yaml.js"],"sourcesContent":["/*! js-yaml 3.14.1 https://github.com/nodeca/js-yaml */(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.jsyaml = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\n\n\nvar loader = require('./js-yaml/loader');\nvar dumper = require('./js-yaml/dumper');\n\n\nfunction deprecated(name) {\n  return function () {\n    throw new Error('Function ' + name + ' is deprecated and cannot be used.');\n  };\n}\n\n\nmodule.exports.Type                = require('./js-yaml/type');\nmodule.exports.Schema              = require('./js-yaml/schema');\nmodule.exports.FAILSAFE_SCHEMA     = require('./js-yaml/schema/failsafe');\nmodule.exports.JSON_SCHEMA         = require('./js-yaml/schema/json');\nmodule.exports.CORE_SCHEMA         = require('./js-yaml/schema/core');\nmodule.exports.DEFAULT_SAFE_SCHEMA = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_FULL_SCHEMA = require('./js-yaml/schema/default_full');\nmodule.exports.load                = loader.load;\nmodule.exports.loadAll             = loader.loadAll;\nmodule.exports.safeLoad            = loader.safeLoad;\nmodule.exports.safeLoadAll         = loader.safeLoadAll;\nmodule.exports.dump                = dumper.dump;\nmodule.exports.safeDump            = dumper.safeDump;\nmodule.exports.YAMLException       = require('./js-yaml/exception');\n\n// Deprecated schema names from JS-YAML 2.0.x\nmodule.exports.MINIMAL_SCHEMA = require('./js-yaml/schema/failsafe');\nmodule.exports.SAFE_SCHEMA    = require('./js-yaml/schema/default_safe');\nmodule.exports.DEFAULT_SCHEMA = require('./js-yaml/schema/default_full');\n\n// Deprecated functions from JS-YAML 1.x.x\nmodule.exports.scan           = deprecated('scan');\nmodule.exports.parse          = deprecated('parse');\nmodule.exports.compose        = deprecated('compose');\nmodule.exports.addConstructor = deprecated('addConstructor');\n\n},{\"./js-yaml/dumper\":3,\"./js-yaml/exception\":4,\"./js-yaml/loader\":5,\"./js-yaml/schema\":7,\"./js-yaml/schema/core\":8,\"./js-yaml/schema/default_full\":9,\"./js-yaml/schema/default_safe\":10,\"./js-yaml/schema/failsafe\":11,\"./js-yaml/schema/json\":12,\"./js-yaml/type\":13}],2:[function(require,module,exports){\n'use strict';\n\n\nfunction isNothing(subject) {\n  return (typeof subject === 'undefined') || (subject === null);\n}\n\n\nfunction isObject(subject) {\n  return (typeof subject === 'object') && (subject !== null);\n}\n\n\nfunction toArray(sequence) {\n  if (Array.isArray(sequence)) return sequence;\n  else if (isNothing(sequence)) return [];\n\n  return [ sequence ];\n}\n\n\nfunction extend(target, source) {\n  var index, length, key, sourceKeys;\n\n  if (source) {\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n      key = sourceKeys[index];\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n\nfunction repeat(string, count) {\n  var result = '', cycle;\n\n  for (cycle = 0; cycle < count; cycle += 1) {\n    result += string;\n  }\n\n  return result;\n}\n\n\nfunction isNegativeZero(number) {\n  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n}\n\n\nmodule.exports.isNothing      = isNothing;\nmodule.exports.isObject       = isObject;\nmodule.exports.toArray        = toArray;\nmodule.exports.repeat         = repeat;\nmodule.exports.isNegativeZero = isNegativeZero;\nmodule.exports.extend         = extend;\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// [24] b-line-feed       ::=     #xA    /* LF */\n// [25] b-carriage-return ::=     #xD    /* CR */\n// [3]  c-byte-order-mark ::=     #xFEFF\nfunction isNsChar(c) {\n  return isPrintable(c) && !isWhitespace(c)\n    // byte-order-mark\n    && c !== 0xFEFF\n    // b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// Simplified test for values allowed after the first character in plain style.\nfunction isPlainSafe(c, prev) {\n  // Uses a subset of nb-char - c-flow-indicator - \":\" - \"#\"\n  // where nb-char ::= c-printable - b-char - c-byte-order-mark.\n  return isPrintable(c) && c !== 0xFEFF\n    // - c-flow-indicator\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // - \":\" - \"#\"\n    // /* An ns-char preceding */ \"#\"\n    && c !== CHAR_COLON\n    && ((c !== CHAR_SHARP) || (prev && isNsChar(prev)));\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  return isPrintable(c) && c !== 0xFEFF\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {\n  var i;\n  var char, prev_char;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(string.charCodeAt(0))\n          && !isWhitespace(string.charCodeAt(string.length - 1));\n\n  if (singleLineOnly) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; i++) {\n      char = string.charCodeAt(i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      prev_char = i > 0 ? string.charCodeAt(i - 1) : null;\n      plain = plain && isPlainSafe(char, prev_char);\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    return plain && !testAmbiguousType(string)\n      ? STYLE_PLAIN : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return \"''\";\n    }\n    if (!state.noCompatMode &&\n        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {\n      return \"'\" + string + \"'\";\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char, nextChar;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; i++) {\n    char = string.charCodeAt(i);\n    // Check for surrogate pairs (reference Unicode 3.0 section \"3.7 Surrogates\").\n    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {\n      nextChar = string.charCodeAt(i + 1);\n      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {\n        // Combine the surrogate pair and store it escaped.\n        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);\n        // Advance index one extra since we already used that char here.\n        i++; continue;\n      }\n    }\n    escapeSeq = ESCAPE_SEQUENCES[char];\n    result += !escapeSeq && isPrintable(char)\n      ? string[i]\n      : escapeSeq || encodeHex(char);\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || index !== 0) {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (index !== 0) pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || index !== 0) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;\n      if (block && (state.dump.length !== 0)) {\n        writeBlockSequence(state, arrayLevel, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, arrayLevel, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey);\n      }\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  if (writeNode(state, 0, input, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\nmodule.exports.dump     = dump;\nmodule.exports.safeDump = safeDump;\n\n},{\"./common\":2,\"./exception\":4,\"./schema/default_full\":9,\"./schema/default_safe\":10}],4:[function(require,module,exports){\n// YAML error class. http://stackoverflow.com/questions/8458984\n//\n'use strict';\n\nfunction YAMLException(reason, mark) {\n  // Super constructor\n  Error.call(this);\n\n  this.name = 'YAMLException';\n  this.reason = reason;\n  this.mark = mark;\n  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');\n\n  // Include stack trace in error object\n  if (Error.captureStackTrace) {\n    // Chrome and NodeJS\n    Error.captureStackTrace(this, this.constructor);\n  } else {\n    // FF, IE 10+ and Safari 6+. Fallback for others\n    this.stack = (new Error()).stack || '';\n  }\n}\n\n\n// Inherit from Error\nYAMLException.prototype = Object.create(Error.prototype);\nYAMLException.prototype.constructor = YAMLException;\n\n\nYAMLException.prototype.toString = function toString(compact) {\n  var result = this.name + ': ';\n\n  result += this.reason || '(unknown reason)';\n\n  if (!compact && this.mark) {\n    result += ' ' + this.mark.toString();\n  }\n\n  return result;\n};\n\n\nmodule.exports = YAMLException;\n\n},{}],5:[function(require,module,exports){\n'use strict';\n\n/*eslint-disable max-len,no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar Mark                = require('./mark');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\n\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\nvar CONTEXT_FLOW_IN   = 1;\nvar CONTEXT_FLOW_OUT  = 2;\nvar CONTEXT_BLOCK_IN  = 3;\nvar CONTEXT_BLOCK_OUT = 4;\n\n\nvar CHOMPING_CLIP  = 1;\nvar CHOMPING_STRIP = 2;\nvar CHOMPING_KEEP  = 3;\n\n\nvar PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\nvar PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\nvar PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\nvar PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\nvar PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\nfunction _class(obj) { return Object.prototype.toString.call(obj); }\n\nfunction is_EOL(c) {\n  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n}\n\nfunction is_WHITE_SPACE(c) {\n  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n}\n\nfunction is_WS_OR_EOL(c) {\n  return (c === 0x09/* Tab */) ||\n         (c === 0x20/* Space */) ||\n         (c === 0x0A/* LF */) ||\n         (c === 0x0D/* CR */);\n}\n\nfunction is_FLOW_INDICATOR(c) {\n  return c === 0x2C/* , */ ||\n         c === 0x5B/* [ */ ||\n         c === 0x5D/* ] */ ||\n         c === 0x7B/* { */ ||\n         c === 0x7D/* } */;\n}\n\nfunction fromHexCode(c) {\n  var lc;\n\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  /*eslint-disable no-bitwise*/\n  lc = c | 0x20;\n\n  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n    return lc - 0x61 + 10;\n  }\n\n  return -1;\n}\n\nfunction escapedHexLen(c) {\n  if (c === 0x78/* x */) { return 2; }\n  if (c === 0x75/* u */) { return 4; }\n  if (c === 0x55/* U */) { return 8; }\n  return 0;\n}\n\nfunction fromDecimalCode(c) {\n  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n    return c - 0x30;\n  }\n\n  return -1;\n}\n\nfunction simpleEscapeSequence(c) {\n  /* eslint-disable indent */\n  return (c === 0x30/* 0 */) ? '\\x00' :\n        (c === 0x61/* a */) ? '\\x07' :\n        (c === 0x62/* b */) ? '\\x08' :\n        (c === 0x74/* t */) ? '\\x09' :\n        (c === 0x09/* Tab */) ? '\\x09' :\n        (c === 0x6E/* n */) ? '\\x0A' :\n        (c === 0x76/* v */) ? '\\x0B' :\n        (c === 0x66/* f */) ? '\\x0C' :\n        (c === 0x72/* r */) ? '\\x0D' :\n        (c === 0x65/* e */) ? '\\x1B' :\n        (c === 0x20/* Space */) ? ' ' :\n        (c === 0x22/* \" */) ? '\\x22' :\n        (c === 0x2F/* / */) ? '/' :\n        (c === 0x5C/* \\ */) ? '\\x5C' :\n        (c === 0x4E/* N */) ? '\\x85' :\n        (c === 0x5F/* _ */) ? '\\xA0' :\n        (c === 0x4C/* L */) ? '\\u2028' :\n        (c === 0x50/* P */) ? '\\u2029' : '';\n}\n\nfunction charFromCodepoint(c) {\n  if (c <= 0xFFFF) {\n    return String.fromCharCode(c);\n  }\n  // Encode UTF-16 surrogate pair\n  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n  return String.fromCharCode(\n    ((c - 0x010000) >> 10) + 0xD800,\n    ((c - 0x010000) & 0x03FF) + 0xDC00\n  );\n}\n\nvar simpleEscapeCheck = new Array(256); // integer, for fast access\nvar simpleEscapeMap = new Array(256);\nfor (var i = 0; i < 256; i++) {\n  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n  simpleEscapeMap[i] = simpleEscapeSequence(i);\n}\n\n\nfunction State(input, options) {\n  this.input = input;\n\n  this.filename  = options['filename']  || null;\n  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;\n  this.onWarning = options['onWarning'] || null;\n  this.legacy    = options['legacy']    || false;\n  this.json      = options['json']      || false;\n  this.listener  = options['listener']  || null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.typeMap       = this.schema.compiledTypeMap;\n\n  this.length     = input.length;\n  this.position   = 0;\n  this.line       = 0;\n  this.lineStart  = 0;\n  this.lineIndent = 0;\n\n  this.documents = [];\n\n  /*\n  this.version;\n  this.checkLineBreaks;\n  this.tagMap;\n  this.anchorMap;\n  this.tag;\n  this.anchor;\n  this.kind;\n  this.result;*/\n\n}\n\n\nfunction generateError(state, message) {\n  return new YAMLException(\n    message,\n    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));\n}\n\nfunction throwError(state, message) {\n  throw generateError(state, message);\n}\n\nfunction throwWarning(state, message) {\n  if (state.onWarning) {\n    state.onWarning.call(null, generateError(state, message));\n  }\n}\n\n\nvar directiveHandlers = {\n\n  YAML: function handleYamlDirective(state, name, args) {\n\n    var match, major, minor;\n\n    if (state.version !== null) {\n      throwError(state, 'duplication of %YAML directive');\n    }\n\n    if (args.length !== 1) {\n      throwError(state, 'YAML directive accepts exactly one argument');\n    }\n\n    match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n    if (match === null) {\n      throwError(state, 'ill-formed argument of the YAML directive');\n    }\n\n    major = parseInt(match[1], 10);\n    minor = parseInt(match[2], 10);\n\n    if (major !== 1) {\n      throwError(state, 'unacceptable YAML version of the document');\n    }\n\n    state.version = args[0];\n    state.checkLineBreaks = (minor < 2);\n\n    if (minor !== 1 && minor !== 2) {\n      throwWarning(state, 'unsupported YAML version of the document');\n    }\n  },\n\n  TAG: function handleTagDirective(state, name, args) {\n\n    var handle, prefix;\n\n    if (args.length !== 2) {\n      throwError(state, 'TAG directive accepts exactly two arguments');\n    }\n\n    handle = args[0];\n    prefix = args[1];\n\n    if (!PATTERN_TAG_HANDLE.test(handle)) {\n      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n    }\n\n    if (_hasOwnProperty.call(state.tagMap, handle)) {\n      throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n    }\n\n    if (!PATTERN_TAG_URI.test(prefix)) {\n      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n    }\n\n    state.tagMap[handle] = prefix;\n  }\n};\n\n\nfunction captureSegment(state, start, end, checkJson) {\n  var _position, _length, _character, _result;\n\n  if (start < end) {\n    _result = state.input.slice(start, end);\n\n    if (checkJson) {\n      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n        _character = _result.charCodeAt(_position);\n        if (!(_character === 0x09 ||\n              (0x20 <= _character && _character <= 0x10FFFF))) {\n          throwError(state, 'expected valid JSON character');\n        }\n      }\n    } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n      throwError(state, 'the stream contains non-printable characters');\n    }\n\n    state.result += _result;\n  }\n}\n\nfunction mergeMappings(state, destination, source, overridableKeys) {\n  var sourceKeys, key, index, quantity;\n\n  if (!common.isObject(source)) {\n    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n  }\n\n  sourceKeys = Object.keys(source);\n\n  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n    key = sourceKeys[index];\n\n    if (!_hasOwnProperty.call(destination, key)) {\n      destination[key] = source[key];\n      overridableKeys[key] = true;\n    }\n  }\n}\n\nfunction storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {\n  var index, quantity;\n\n  // The output is a plain object here, so keys can only be strings.\n  // We need to convert keyNode to a string, but doing so can hang the process\n  // (deeply nested arrays that explode exponentially using aliases).\n  if (Array.isArray(keyNode)) {\n    keyNode = Array.prototype.slice.call(keyNode);\n\n    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n      if (Array.isArray(keyNode[index])) {\n        throwError(state, 'nested arrays are not supported inside keys');\n      }\n\n      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n        keyNode[index] = '[object Object]';\n      }\n    }\n  }\n\n  // Avoid code execution in load() via toString property\n  // (still use its own toString for arrays, timestamps,\n  // and whatever user schema extensions happen to have @@toStringTag)\n  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n    keyNode = '[object Object]';\n  }\n\n\n  keyNode = String(keyNode);\n\n  if (_result === null) {\n    _result = {};\n  }\n\n  if (keyTag === 'tag:yaml.org,2002:merge') {\n    if (Array.isArray(valueNode)) {\n      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n        mergeMappings(state, _result, valueNode[index], overridableKeys);\n      }\n    } else {\n      mergeMappings(state, _result, valueNode, overridableKeys);\n    }\n  } else {\n    if (!state.json &&\n        !_hasOwnProperty.call(overridableKeys, keyNode) &&\n        _hasOwnProperty.call(_result, keyNode)) {\n      state.line = startLine || state.line;\n      state.position = startPos || state.position;\n      throwError(state, 'duplicated mapping key');\n    }\n    _result[keyNode] = valueNode;\n    delete overridableKeys[keyNode];\n  }\n\n  return _result;\n}\n\nfunction readLineBreak(state) {\n  var ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x0A/* LF */) {\n    state.position++;\n  } else if (ch === 0x0D/* CR */) {\n    state.position++;\n    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n      state.position++;\n    }\n  } else {\n    throwError(state, 'a line break is expected');\n  }\n\n  state.line += 1;\n  state.lineStart = state.position;\n}\n\nfunction skipSeparationSpace(state, allowComments, checkIndent) {\n  var lineBreaks = 0,\n      ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    while (is_WHITE_SPACE(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (allowComments && ch === 0x23/* # */) {\n      do {\n        ch = state.input.charCodeAt(++state.position);\n      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n    }\n\n    if (is_EOL(ch)) {\n      readLineBreak(state);\n\n      ch = state.input.charCodeAt(state.position);\n      lineBreaks++;\n      state.lineIndent = 0;\n\n      while (ch === 0x20/* Space */) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n    throwWarning(state, 'deficient indentation');\n  }\n\n  return lineBreaks;\n}\n\nfunction testDocumentSeparator(state) {\n  var _position = state.position,\n      ch;\n\n  ch = state.input.charCodeAt(_position);\n\n  // Condition state.position === state.lineStart is tested\n  // in parent on each call, for efficiency. No needs to test here again.\n  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n      ch === state.input.charCodeAt(_position + 1) &&\n      ch === state.input.charCodeAt(_position + 2)) {\n\n    _position += 3;\n\n    ch = state.input.charCodeAt(_position);\n\n    if (ch === 0 || is_WS_OR_EOL(ch)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction writeFoldedLines(state, count) {\n  if (count === 1) {\n    state.result += ' ';\n  } else if (count > 1) {\n    state.result += common.repeat('\\n', count - 1);\n  }\n}\n\n\nfunction readPlainScalar(state, nodeIndent, withinFlowCollection) {\n  var preceding,\n      following,\n      captureStart,\n      captureEnd,\n      hasPendingContent,\n      _line,\n      _lineStart,\n      _lineIndent,\n      _kind = state.kind,\n      _result = state.result,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (is_WS_OR_EOL(ch)      ||\n      is_FLOW_INDICATOR(ch) ||\n      ch === 0x23/* # */    ||\n      ch === 0x26/* & */    ||\n      ch === 0x2A/* * */    ||\n      ch === 0x21/* ! */    ||\n      ch === 0x7C/* | */    ||\n      ch === 0x3E/* > */    ||\n      ch === 0x27/* ' */    ||\n      ch === 0x22/* \" */    ||\n      ch === 0x25/* % */    ||\n      ch === 0x40/* @ */    ||\n      ch === 0x60/* ` */) {\n    return false;\n  }\n\n  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (is_WS_OR_EOL(following) ||\n        withinFlowCollection && is_FLOW_INDICATOR(following)) {\n      return false;\n    }\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  captureStart = captureEnd = state.position;\n  hasPendingContent = false;\n\n  while (ch !== 0) {\n    if (ch === 0x3A/* : */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        break;\n      }\n\n    } else if (ch === 0x23/* # */) {\n      preceding = state.input.charCodeAt(state.position - 1);\n\n      if (is_WS_OR_EOL(preceding)) {\n        break;\n      }\n\n    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n               withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n      break;\n\n    } else if (is_EOL(ch)) {\n      _line = state.line;\n      _lineStart = state.lineStart;\n      _lineIndent = state.lineIndent;\n      skipSeparationSpace(state, false, -1);\n\n      if (state.lineIndent >= nodeIndent) {\n        hasPendingContent = true;\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      } else {\n        state.position = captureEnd;\n        state.line = _line;\n        state.lineStart = _lineStart;\n        state.lineIndent = _lineIndent;\n        break;\n      }\n    }\n\n    if (hasPendingContent) {\n      captureSegment(state, captureStart, captureEnd, false);\n      writeFoldedLines(state, state.line - _line);\n      captureStart = captureEnd = state.position;\n      hasPendingContent = false;\n    }\n\n    if (!is_WHITE_SPACE(ch)) {\n      captureEnd = state.position + 1;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  captureSegment(state, captureStart, captureEnd, false);\n\n  if (state.result) {\n    return true;\n  }\n\n  state.kind = _kind;\n  state.result = _result;\n  return false;\n}\n\nfunction readSingleQuotedScalar(state, nodeIndent) {\n  var ch,\n      captureStart, captureEnd;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x27/* ' */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x27/* ' */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x27/* ' */) {\n        captureStart = state.position;\n        state.position++;\n        captureEnd = state.position;\n      } else {\n        return true;\n      }\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a single quoted scalar');\n}\n\nfunction readDoubleQuotedScalar(state, nodeIndent) {\n  var captureStart,\n      captureEnd,\n      hexLength,\n      hexResult,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x22/* \" */) {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n  state.position++;\n  captureStart = captureEnd = state.position;\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    if (ch === 0x22/* \" */) {\n      captureSegment(state, captureStart, state.position, true);\n      state.position++;\n      return true;\n\n    } else if (ch === 0x5C/* \\ */) {\n      captureSegment(state, captureStart, state.position, true);\n      ch = state.input.charCodeAt(++state.position);\n\n      if (is_EOL(ch)) {\n        skipSeparationSpace(state, false, nodeIndent);\n\n        // TODO: rework to inline fn with no type cast?\n      } else if (ch < 256 && simpleEscapeCheck[ch]) {\n        state.result += simpleEscapeMap[ch];\n        state.position++;\n\n      } else if ((tmp = escapedHexLen(ch)) > 0) {\n        hexLength = tmp;\n        hexResult = 0;\n\n        for (; hexLength > 0; hexLength--) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if ((tmp = fromHexCode(ch)) >= 0) {\n            hexResult = (hexResult << 4) + tmp;\n\n          } else {\n            throwError(state, 'expected hexadecimal character');\n          }\n        }\n\n        state.result += charFromCodepoint(hexResult);\n\n        state.position++;\n\n      } else {\n        throwError(state, 'unknown escape sequence');\n      }\n\n      captureStart = captureEnd = state.position;\n\n    } else if (is_EOL(ch)) {\n      captureSegment(state, captureStart, captureEnd, true);\n      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n      captureStart = captureEnd = state.position;\n\n    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n      throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n    } else {\n      state.position++;\n      captureEnd = state.position;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a double quoted scalar');\n}\n\nfunction readFlowCollection(state, nodeIndent) {\n  var readNext = true,\n      _line,\n      _tag     = state.tag,\n      _result,\n      _anchor  = state.anchor,\n      following,\n      terminator,\n      isPair,\n      isExplicitPair,\n      isMapping,\n      overridableKeys = {},\n      keyNode,\n      keyTag,\n      valueNode,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x5B/* [ */) {\n    terminator = 0x5D;/* ] */\n    isMapping = false;\n    _result = [];\n  } else if (ch === 0x7B/* { */) {\n    terminator = 0x7D;/* } */\n    isMapping = true;\n    _result = {};\n  } else {\n    return false;\n  }\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  while (ch !== 0) {\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === terminator) {\n      state.position++;\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = isMapping ? 'mapping' : 'sequence';\n      state.result = _result;\n      return true;\n    } else if (!readNext) {\n      throwError(state, 'missed comma between flow collection entries');\n    }\n\n    keyTag = keyNode = valueNode = null;\n    isPair = isExplicitPair = false;\n\n    if (ch === 0x3F/* ? */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following)) {\n        isPair = isExplicitPair = true;\n        state.position++;\n        skipSeparationSpace(state, true, nodeIndent);\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n    keyTag = state.tag;\n    keyNode = state.result;\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n      isPair = true;\n      ch = state.input.charCodeAt(++state.position);\n      skipSeparationSpace(state, true, nodeIndent);\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      valueNode = state.result;\n    }\n\n    if (isMapping) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);\n    } else if (isPair) {\n      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));\n    } else {\n      _result.push(keyNode);\n    }\n\n    skipSeparationSpace(state, true, nodeIndent);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x2C/* , */) {\n      readNext = true;\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      readNext = false;\n    }\n  }\n\n  throwError(state, 'unexpected end of the stream within a flow collection');\n}\n\nfunction readBlockScalar(state, nodeIndent) {\n  var captureStart,\n      folding,\n      chomping       = CHOMPING_CLIP,\n      didReadContent = false,\n      detectedIndent = false,\n      textIndent     = nodeIndent,\n      emptyLines     = 0,\n      atMoreIndented = false,\n      tmp,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch === 0x7C/* | */) {\n    folding = false;\n  } else if (ch === 0x3E/* > */) {\n    folding = true;\n  } else {\n    return false;\n  }\n\n  state.kind = 'scalar';\n  state.result = '';\n\n  while (ch !== 0) {\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      if (CHOMPING_CLIP === chomping) {\n        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n      } else {\n        throwError(state, 'repeat of a chomping mode identifier');\n      }\n\n    } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n      if (tmp === 0) {\n        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n      } else if (!detectedIndent) {\n        textIndent = nodeIndent + tmp - 1;\n        detectedIndent = true;\n      } else {\n        throwError(state, 'repeat of an indentation width identifier');\n      }\n\n    } else {\n      break;\n    }\n  }\n\n  if (is_WHITE_SPACE(ch)) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (is_WHITE_SPACE(ch));\n\n    if (ch === 0x23/* # */) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (!is_EOL(ch) && (ch !== 0));\n    }\n  }\n\n  while (ch !== 0) {\n    readLineBreak(state);\n    state.lineIndent = 0;\n\n    ch = state.input.charCodeAt(state.position);\n\n    while ((!detectedIndent || state.lineIndent < textIndent) &&\n           (ch === 0x20/* Space */)) {\n      state.lineIndent++;\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (!detectedIndent && state.lineIndent > textIndent) {\n      textIndent = state.lineIndent;\n    }\n\n    if (is_EOL(ch)) {\n      emptyLines++;\n      continue;\n    }\n\n    // End of the scalar.\n    if (state.lineIndent < textIndent) {\n\n      // Perform the chomping.\n      if (chomping === CHOMPING_KEEP) {\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      } else if (chomping === CHOMPING_CLIP) {\n        if (didReadContent) { // i.e. only if the scalar is not empty.\n          state.result += '\\n';\n        }\n      }\n\n      // Break this `while` cycle and go to the funciton's epilogue.\n      break;\n    }\n\n    // Folded style: use fancy rules to handle line breaks.\n    if (folding) {\n\n      // Lines starting with white space characters (more-indented lines) are not folded.\n      if (is_WHITE_SPACE(ch)) {\n        atMoreIndented = true;\n        // except for the first content line (cf. Example 8.1)\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n      // End of more-indented block.\n      } else if (atMoreIndented) {\n        atMoreIndented = false;\n        state.result += common.repeat('\\n', emptyLines + 1);\n\n      // Just one line break - perceive as the same line.\n      } else if (emptyLines === 0) {\n        if (didReadContent) { // i.e. only if we have already read some scalar content.\n          state.result += ' ';\n        }\n\n      // Several line breaks - perceive as different lines.\n      } else {\n        state.result += common.repeat('\\n', emptyLines);\n      }\n\n    // Literal style: just add exact number of line breaks between content lines.\n    } else {\n      // Keep all line breaks except the header line break.\n      state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n    }\n\n    didReadContent = true;\n    detectedIndent = true;\n    emptyLines = 0;\n    captureStart = state.position;\n\n    while (!is_EOL(ch) && (ch !== 0)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, state.position, false);\n  }\n\n  return true;\n}\n\nfunction readBlockSequence(state, nodeIndent) {\n  var _line,\n      _tag      = state.tag,\n      _anchor   = state.anchor,\n      _result   = [],\n      following,\n      detected  = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n\n    if (ch !== 0x2D/* - */) {\n      break;\n    }\n\n    following = state.input.charCodeAt(state.position + 1);\n\n    if (!is_WS_OR_EOL(following)) {\n      break;\n    }\n\n    detected = true;\n    state.position++;\n\n    if (skipSeparationSpace(state, true, -1)) {\n      if (state.lineIndent <= nodeIndent) {\n        _result.push(null);\n        ch = state.input.charCodeAt(state.position);\n        continue;\n      }\n    }\n\n    _line = state.line;\n    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n    _result.push(state.result);\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n      throwError(state, 'bad indentation of a sequence entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'sequence';\n    state.result = _result;\n    return true;\n  }\n  return false;\n}\n\nfunction readBlockMapping(state, nodeIndent, flowIndent) {\n  var following,\n      allowCompact,\n      _line,\n      _pos,\n      _tag          = state.tag,\n      _anchor       = state.anchor,\n      _result       = {},\n      overridableKeys = {},\n      keyTag        = null,\n      keyNode       = null,\n      valueNode     = null,\n      atExplicitKey = false,\n      detected      = false,\n      ch;\n\n  if (state.anchor !== null) {\n    state.anchorMap[state.anchor] = _result;\n  }\n\n  ch = state.input.charCodeAt(state.position);\n\n  while (ch !== 0) {\n    following = state.input.charCodeAt(state.position + 1);\n    _line = state.line; // Save the current line.\n    _pos = state.position;\n\n    //\n    // Explicit notation case. There are two separate blocks:\n    // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n    //\n    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n      if (ch === 0x3F/* ? */) {\n        if (atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        detected = true;\n        atExplicitKey = true;\n        allowCompact = true;\n\n      } else if (atExplicitKey) {\n        // i.e. 0x3A/* : */ === character after the explicit key.\n        atExplicitKey = false;\n        allowCompact = true;\n\n      } else {\n        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n      }\n\n      state.position += 1;\n      ch = following;\n\n    //\n    // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n    //\n    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n\n      if (state.line === _line) {\n        ch = state.input.charCodeAt(state.position);\n\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x3A/* : */) {\n          ch = state.input.charCodeAt(++state.position);\n\n          if (!is_WS_OR_EOL(ch)) {\n            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n          }\n\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = false;\n          allowCompact = false;\n          keyTag = state.tag;\n          keyNode = state.result;\n\n        } else if (detected) {\n          throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n\n      } else if (detected) {\n        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n      } else {\n        state.tag = _tag;\n        state.anchor = _anchor;\n        return true; // Keep the result of `composeNode`.\n      }\n\n    } else {\n      break; // Reading is done. Go to the epilogue.\n    }\n\n    //\n    // Common reading code for both explicit and implicit notations.\n    //\n    if (state.line === _line || state.lineIndent > nodeIndent) {\n      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n        if (atExplicitKey) {\n          keyNode = state.result;\n        } else {\n          valueNode = state.result;\n        }\n      }\n\n      if (!atExplicitKey) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);\n        keyTag = keyNode = valueNode = null;\n      }\n\n      skipSeparationSpace(state, true, -1);\n      ch = state.input.charCodeAt(state.position);\n    }\n\n    if (state.lineIndent > nodeIndent && (ch !== 0)) {\n      throwError(state, 'bad indentation of a mapping entry');\n    } else if (state.lineIndent < nodeIndent) {\n      break;\n    }\n  }\n\n  //\n  // Epilogue.\n  //\n\n  // Special case: last mapping's node contains only the key in explicit notation.\n  if (atExplicitKey) {\n    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);\n  }\n\n  // Expose the resulting mapping.\n  if (detected) {\n    state.tag = _tag;\n    state.anchor = _anchor;\n    state.kind = 'mapping';\n    state.result = _result;\n  }\n\n  return detected;\n}\n\nfunction readTagProperty(state) {\n  var _position,\n      isVerbatim = false,\n      isNamed    = false,\n      tagHandle,\n      tagName,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x21/* ! */) return false;\n\n  if (state.tag !== null) {\n    throwError(state, 'duplication of a tag property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n\n  if (ch === 0x3C/* < */) {\n    isVerbatim = true;\n    ch = state.input.charCodeAt(++state.position);\n\n  } else if (ch === 0x21/* ! */) {\n    isNamed = true;\n    tagHandle = '!!';\n    ch = state.input.charCodeAt(++state.position);\n\n  } else {\n    tagHandle = '!';\n  }\n\n  _position = state.position;\n\n  if (isVerbatim) {\n    do { ch = state.input.charCodeAt(++state.position); }\n    while (ch !== 0 && ch !== 0x3E/* > */);\n\n    if (state.position < state.length) {\n      tagName = state.input.slice(_position, state.position);\n      ch = state.input.charCodeAt(++state.position);\n    } else {\n      throwError(state, 'unexpected end of the stream within a verbatim tag');\n    }\n  } else {\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n      if (ch === 0x21/* ! */) {\n        if (!isNamed) {\n          tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n            throwError(state, 'named tag handle cannot contain such characters');\n          }\n\n          isNamed = true;\n          _position = state.position + 1;\n        } else {\n          throwError(state, 'tag suffix cannot contain exclamation marks');\n        }\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    tagName = state.input.slice(_position, state.position);\n\n    if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n      throwError(state, 'tag suffix cannot contain flow indicator characters');\n    }\n  }\n\n  if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n    throwError(state, 'tag name cannot contain such characters: ' + tagName);\n  }\n\n  if (isVerbatim) {\n    state.tag = tagName;\n\n  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {\n    state.tag = state.tagMap[tagHandle] + tagName;\n\n  } else if (tagHandle === '!') {\n    state.tag = '!' + tagName;\n\n  } else if (tagHandle === '!!') {\n    state.tag = 'tag:yaml.org,2002:' + tagName;\n\n  } else {\n    throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n  }\n\n  return true;\n}\n\nfunction readAnchorProperty(state) {\n  var _position,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x26/* & */) return false;\n\n  if (state.anchor !== null) {\n    throwError(state, 'duplication of an anchor property');\n  }\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an anchor node must contain at least one character');\n  }\n\n  state.anchor = state.input.slice(_position, state.position);\n  return true;\n}\n\nfunction readAlias(state) {\n  var _position, alias,\n      ch;\n\n  ch = state.input.charCodeAt(state.position);\n\n  if (ch !== 0x2A/* * */) return false;\n\n  ch = state.input.charCodeAt(++state.position);\n  _position = state.position;\n\n  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n    ch = state.input.charCodeAt(++state.position);\n  }\n\n  if (state.position === _position) {\n    throwError(state, 'name of an alias node must contain at least one character');\n  }\n\n  alias = state.input.slice(_position, state.position);\n\n  if (!_hasOwnProperty.call(state.anchorMap, alias)) {\n    throwError(state, 'unidentified alias \"' + alias + '\"');\n  }\n\n  state.result = state.anchorMap[alias];\n  skipSeparationSpace(state, true, -1);\n  return true;\n}\n\nfunction composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n  var allowBlockStyles,\n      allowBlockScalars,\n      allowBlockCollections,\n      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n      atNewLine  = false,\n      hasContent = false,\n      typeIndex,\n      typeQuantity,\n      type,\n      flowIndent,\n      blockIndent;\n\n  if (state.listener !== null) {\n    state.listener('open', state);\n  }\n\n  state.tag    = null;\n  state.anchor = null;\n  state.kind   = null;\n  state.result = null;\n\n  allowBlockStyles = allowBlockScalars = allowBlockCollections =\n    CONTEXT_BLOCK_OUT === nodeContext ||\n    CONTEXT_BLOCK_IN  === nodeContext;\n\n  if (allowToSeek) {\n    if (skipSeparationSpace(state, true, -1)) {\n      atNewLine = true;\n\n      if (state.lineIndent > parentIndent) {\n        indentStatus = 1;\n      } else if (state.lineIndent === parentIndent) {\n        indentStatus = 0;\n      } else if (state.lineIndent < parentIndent) {\n        indentStatus = -1;\n      }\n    }\n  }\n\n  if (indentStatus === 1) {\n    while (readTagProperty(state) || readAnchorProperty(state)) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n        allowBlockCollections = allowBlockStyles;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      } else {\n        allowBlockCollections = false;\n      }\n    }\n  }\n\n  if (allowBlockCollections) {\n    allowBlockCollections = atNewLine || allowCompact;\n  }\n\n  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n      flowIndent = parentIndent;\n    } else {\n      flowIndent = parentIndent + 1;\n    }\n\n    blockIndent = state.position - state.lineStart;\n\n    if (indentStatus === 1) {\n      if (allowBlockCollections &&\n          (readBlockSequence(state, blockIndent) ||\n           readBlockMapping(state, blockIndent, flowIndent)) ||\n          readFlowCollection(state, flowIndent)) {\n        hasContent = true;\n      } else {\n        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n            readSingleQuotedScalar(state, flowIndent) ||\n            readDoubleQuotedScalar(state, flowIndent)) {\n          hasContent = true;\n\n        } else if (readAlias(state)) {\n          hasContent = true;\n\n          if (state.tag !== null || state.anchor !== null) {\n            throwError(state, 'alias node should not have any properties');\n          }\n\n        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n          hasContent = true;\n\n          if (state.tag === null) {\n            state.tag = '?';\n          }\n        }\n\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else if (indentStatus === 0) {\n      // Special case: block sequences are allowed to have same indentation level as the parent.\n      // http://www.yaml.org/spec/1.2/spec.html#id2799784\n      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n    }\n  }\n\n  if (state.tag !== null && state.tag !== '!') {\n    if (state.tag === '?') {\n      // Implicit resolving is not allowed for non-scalar types, and '?'\n      // non-specific tag is only automatically assigned to plain scalars.\n      //\n      // We only need to check kind conformity in case user explicitly assigns '?'\n      // tag, for example like this: \"!<?> [0]\"\n      //\n      if (state.result !== null && state.kind !== 'scalar') {\n        throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n      }\n\n      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n        type = state.implicitTypes[typeIndex];\n\n        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n          state.result = type.construct(state.result);\n          state.tag = type.tag;\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n          break;\n        }\n      }\n    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n      type = state.typeMap[state.kind || 'fallback'][state.tag];\n\n      if (state.result !== null && type.kind !== state.kind) {\n        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n      }\n\n      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched\n        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n      } else {\n        state.result = type.construct(state.result);\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    } else {\n      throwError(state, 'unknown tag !<' + state.tag + '>');\n    }\n  }\n\n  if (state.listener !== null) {\n    state.listener('close', state);\n  }\n  return state.tag !== null ||  state.anchor !== null || hasContent;\n}\n\nfunction readDocument(state) {\n  var documentStart = state.position,\n      _position,\n      directiveName,\n      directiveArgs,\n      hasDirectives = false,\n      ch;\n\n  state.version = null;\n  state.checkLineBreaks = state.legacy;\n  state.tagMap = {};\n  state.anchorMap = {};\n\n  while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n    skipSeparationSpace(state, true, -1);\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n      break;\n    }\n\n    hasDirectives = true;\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    directiveName = state.input.slice(_position, state.position);\n    directiveArgs = [];\n\n    if (directiveName.length < 1) {\n      throwError(state, 'directive name must not be less than one character in length');\n    }\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (ch !== 0 && !is_EOL(ch));\n        break;\n      }\n\n      if (is_EOL(ch)) break;\n\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveArgs.push(state.input.slice(_position, state.position));\n    }\n\n    if (ch !== 0) readLineBreak(state);\n\n    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {\n      directiveHandlers[directiveName](state, directiveName, directiveArgs);\n    } else {\n      throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n    }\n  }\n\n  skipSeparationSpace(state, true, -1);\n\n  if (state.lineIndent === 0 &&\n      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n    state.position += 3;\n    skipSeparationSpace(state, true, -1);\n\n  } else if (hasDirectives) {\n    throwError(state, 'directives end mark is expected');\n  }\n\n  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n  skipSeparationSpace(state, true, -1);\n\n  if (state.checkLineBreaks &&\n      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n    throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n  }\n\n  state.documents.push(state.result);\n\n  if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n    }\n    return;\n  }\n\n  if (state.position < (state.length - 1)) {\n    throwError(state, 'end of the stream or a document separator is expected');\n  } else {\n    return;\n  }\n}\n\n\nfunction loadDocuments(input, options) {\n  input = String(input);\n  options = options || {};\n\n  if (input.length !== 0) {\n\n    // Add tailing `\\n` if not exists\n    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n      input += '\\n';\n    }\n\n    // Strip BOM\n    if (input.charCodeAt(0) === 0xFEFF) {\n      input = input.slice(1);\n    }\n  }\n\n  var state = new State(input, options);\n\n  var nullpos = input.indexOf('\\0');\n\n  if (nullpos !== -1) {\n    state.position = nullpos;\n    throwError(state, 'null byte is not allowed in input');\n  }\n\n  // Use 0 as string terminator. That significantly simplifies bounds check.\n  state.input += '\\0';\n\n  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n    state.lineIndent += 1;\n    state.position += 1;\n  }\n\n  while (state.position < (state.length - 1)) {\n    readDocument(state);\n  }\n\n  return state.documents;\n}\n\n\nfunction loadAll(input, iterator, options) {\n  if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  var documents = loadDocuments(input, options);\n\n  if (typeof iterator !== 'function') {\n    return documents;\n  }\n\n  for (var index = 0, length = documents.length; index < length; index += 1) {\n    iterator(documents[index]);\n  }\n}\n\n\nfunction load(input, options) {\n  var documents = loadDocuments(input, options);\n\n  if (documents.length === 0) {\n    /*eslint-disable no-undefined*/\n    return undefined;\n  } else if (documents.length === 1) {\n    return documents[0];\n  }\n  throw new YAMLException('expected a single document in the stream, but found more');\n}\n\n\nfunction safeLoadAll(input, iterator, options) {\n  if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {\n    options = iterator;\n    iterator = null;\n  }\n\n  return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\n\nfunction safeLoad(input, options) {\n  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\n\nmodule.exports.loadAll     = loadAll;\nmodule.exports.load        = load;\nmodule.exports.safeLoadAll = safeLoadAll;\nmodule.exports.safeLoad    = safeLoad;\n\n},{\"./common\":2,\"./exception\":4,\"./mark\":6,\"./schema/default_full\":9,\"./schema/default_safe\":10}],6:[function(require,module,exports){\n'use strict';\n\n\nvar common = require('./common');\n\n\nfunction Mark(name, buffer, position, line, column) {\n  this.name     = name;\n  this.buffer   = buffer;\n  this.position = position;\n  this.line     = line;\n  this.column   = column;\n}\n\n\nMark.prototype.getSnippet = function getSnippet(indent, maxLength) {\n  var head, start, tail, end, snippet;\n\n  if (!this.buffer) return null;\n\n  indent = indent || 4;\n  maxLength = maxLength || 75;\n\n  head = '';\n  start = this.position;\n\n  while (start > 0 && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {\n    start -= 1;\n    if (this.position - start > (maxLength / 2 - 1)) {\n      head = ' ... ';\n      start += 5;\n      break;\n    }\n  }\n\n  tail = '';\n  end = this.position;\n\n  while (end < this.buffer.length && '\\x00\\r\\n\\x85\\u2028\\u2029'.indexOf(this.buffer.charAt(end)) === -1) {\n    end += 1;\n    if (end - this.position > (maxLength / 2 - 1)) {\n      tail = ' ... ';\n      end -= 5;\n      break;\n    }\n  }\n\n  snippet = this.buffer.slice(start, end);\n\n  return common.repeat(' ', indent) + head + snippet + tail + '\\n' +\n         common.repeat(' ', indent + this.position - start + head.length) + '^';\n};\n\n\nMark.prototype.toString = function toString(compact) {\n  var snippet, where = '';\n\n  if (this.name) {\n    where += 'in \"' + this.name + '\" ';\n  }\n\n  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);\n\n  if (!compact) {\n    snippet = this.getSnippet();\n\n    if (snippet) {\n      where += ':\\n' + snippet;\n    }\n  }\n\n  return where;\n};\n\n\nmodule.exports = Mark;\n\n},{\"./common\":2}],7:[function(require,module,exports){\n'use strict';\n\n/*eslint-disable max-len*/\n\nvar common        = require('./common');\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name, result) {\n  var exclude = [];\n\n  schema.include.forEach(function (includedSchema) {\n    result = compileList(includedSchema, name, result);\n  });\n\n  schema[name].forEach(function (currentType) {\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {\n        exclude.push(previousIndex);\n      }\n    });\n\n    result.push(currentType);\n  });\n\n  return result.filter(function (type, index) {\n    return exclude.indexOf(index) === -1;\n  });\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {}\n      }, index, length;\n\n  function collectType(type) {\n    result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  this.include  = definition.include  || [];\n  this.implicit = definition.implicit || [];\n  this.explicit = definition.explicit || [];\n\n  this.implicit.forEach(function (type) {\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n  });\n\n  this.compiledImplicit = compileList(this, 'implicit', []);\n  this.compiledExplicit = compileList(this, 'explicit', []);\n  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);\n}\n\n\nSchema.DEFAULT = null;\n\n\nSchema.create = function createSchema() {\n  var schemas, types;\n\n  switch (arguments.length) {\n    case 1:\n      schemas = Schema.DEFAULT;\n      types = arguments[0];\n      break;\n\n    case 2:\n      schemas = arguments[0];\n      types = arguments[1];\n      break;\n\n    default:\n      throw new YAMLException('Wrong number of arguments for Schema.create function');\n  }\n\n  schemas = common.toArray(schemas);\n  types = common.toArray(types);\n\n  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {\n    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');\n  }\n\n  if (!types.every(function (type) { return type instanceof Type; })) {\n    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n  }\n\n  return new Schema({\n    include: schemas,\n    explicit: types\n  });\n};\n\n\nmodule.exports = Schema;\n\n},{\"./common\":2,\"./exception\":4,\"./type\":13}],8:[function(require,module,exports){\n// Standard YAML's Core schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2804923\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, Core schema has no distinctions from JSON schema is JS-YAML.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./json')\n  ]\n});\n\n},{\"../schema\":7,\"./json\":12}],9:[function(require,module,exports){\n// JS-YAML's default schema for `load` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on JS-YAML's default safe schema and includes\n// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.\n//\n// Also this schema is used as default base schema at `Schema.create` function.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = Schema.DEFAULT = new Schema({\n  include: [\n    require('./default_safe')\n  ],\n  explicit: [\n    require('../type/js/undefined'),\n    require('../type/js/regexp'),\n    require('../type/js/function')\n  ]\n});\n\n},{\"../schema\":7,\"../type/js/function\":18,\"../type/js/regexp\":19,\"../type/js/undefined\":20,\"./default_safe\":10}],10:[function(require,module,exports){\n// JS-YAML's default schema for `safeLoad` function.\n// It is not described in the YAML specification.\n//\n// This schema is based on standard YAML's Core schema and includes most of\n// extra types described at YAML tag repository. (http://yaml.org/type/)\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./core')\n  ],\n  implicit: [\n    require('../type/timestamp'),\n    require('../type/merge')\n  ],\n  explicit: [\n    require('../type/binary'),\n    require('../type/omap'),\n    require('../type/pairs'),\n    require('../type/set')\n  ]\n});\n\n},{\"../schema\":7,\"../type/binary\":14,\"../type/merge\":22,\"../type/omap\":24,\"../type/pairs\":25,\"../type/set\":27,\"../type/timestamp\":29,\"./core\":8}],11:[function(require,module,exports){\n// Standard YAML's Failsafe schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2802346\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  explicit: [\n    require('../type/str'),\n    require('../type/seq'),\n    require('../type/map')\n  ]\n});\n\n},{\"../schema\":7,\"../type/map\":21,\"../type/seq\":26,\"../type/str\":28}],12:[function(require,module,exports){\n// Standard YAML's JSON schema.\n// http://www.yaml.org/spec/1.2/spec.html#id2803231\n//\n// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.\n// So, this schema is not such strict as defined in the YAML specification.\n// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.\n\n\n'use strict';\n\n\nvar Schema = require('../schema');\n\n\nmodule.exports = new Schema({\n  include: [\n    require('./failsafe')\n  ],\n  implicit: [\n    require('../type/null'),\n    require('../type/bool'),\n    require('../type/int'),\n    require('../type/float')\n  ]\n});\n\n},{\"../schema\":7,\"../type/bool\":15,\"../type/float\":16,\"../type/int\":17,\"../type/null\":23,\"./failsafe\":11}],13:[function(require,module,exports){\n'use strict';\n\nvar YAMLException = require('./exception');\n\nvar TYPE_CONSTRUCTOR_OPTIONS = [\n  'kind',\n  'resolve',\n  'construct',\n  'instanceOf',\n  'predicate',\n  'represent',\n  'defaultStyle',\n  'styleAliases'\n];\n\nvar YAML_NODE_KINDS = [\n  'scalar',\n  'sequence',\n  'mapping'\n];\n\nfunction compileStyleAliases(map) {\n  var result = {};\n\n  if (map !== null) {\n    Object.keys(map).forEach(function (style) {\n      map[style].forEach(function (alias) {\n        result[String(alias)] = style;\n      });\n    });\n  }\n\n  return result;\n}\n\nfunction Type(tag, options) {\n  options = options || {};\n\n  Object.keys(options).forEach(function (name) {\n    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n      throw new YAMLException('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n    }\n  });\n\n  // TODO: Add tag format check.\n  this.tag          = tag;\n  this.kind         = options['kind']         || null;\n  this.resolve      = options['resolve']      || function () { return true; };\n  this.construct    = options['construct']    || function (data) { return data; };\n  this.instanceOf   = options['instanceOf']   || null;\n  this.predicate    = options['predicate']    || null;\n  this.represent    = options['represent']    || null;\n  this.defaultStyle = options['defaultStyle'] || null;\n  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);\n\n  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n    throw new YAMLException('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n  }\n}\n\nmodule.exports = Type;\n\n},{\"./exception\":4}],14:[function(require,module,exports){\n'use strict';\n\n/*eslint-disable no-bitwise*/\n\nvar NodeBuffer;\n\ntry {\n  // A trick for browserified version, to not include `Buffer` shim\n  var _require = require;\n  NodeBuffer = _require('buffer').Buffer;\n} catch (__) {}\n\nvar Type       = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (data === null) return false;\n\n  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) continue;\n\n    // Fail on illegal characters\n    if (code < 0) return false;\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  // Wrap into Buffer for NodeJS and leave Array for browser\n  if (NodeBuffer) {\n    // Support node 6.+ Buffer API when available\n    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n\n},{\"../type\":13}],15:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlBoolean(data) {\n  if (data === null) return false;\n\n  var max = data.length;\n\n  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n}\n\nfunction constructYamlBoolean(data) {\n  return data === 'true' ||\n         data === 'True' ||\n         data === 'TRUE';\n}\n\nfunction isBoolean(object) {\n  return Object.prototype.toString.call(object) === '[object Boolean]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:bool', {\n  kind: 'scalar',\n  resolve: resolveYamlBoolean,\n  construct: constructYamlBoolean,\n  predicate: isBoolean,\n  represent: {\n    lowercase: function (object) { return object ? 'true' : 'false'; },\n    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n    camelcase: function (object) { return object ? 'True' : 'False'; }\n  },\n  defaultStyle: 'lowercase'\n});\n\n},{\"../type\":13}],16:[function(require,module,exports){\n'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nvar YAML_FLOAT_PATTERN = new RegExp(\n  // 2.5e4, 2.5 and integers\n  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n  // .2e4, .2\n  // special case, seems not from spec\n  '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n  // 20:59\n  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*' +\n  // .inf\n  '|[-+]?\\\\.(?:inf|Inf|INF)' +\n  // .nan\n  '|\\\\.(?:nan|NaN|NAN))$');\n\nfunction resolveYamlFloat(data) {\n  if (data === null) return false;\n\n  if (!YAML_FLOAT_PATTERN.test(data) ||\n      // Quick hack to not allow integers end with `_`\n      // Probably should update regexp & check speed\n      data[data.length - 1] === '_') {\n    return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlFloat(data) {\n  var value, sign, base, digits;\n\n  value  = data.replace(/_/g, '').toLowerCase();\n  sign   = value[0] === '-' ? -1 : 1;\n  digits = [];\n\n  if ('+-'.indexOf(value[0]) >= 0) {\n    value = value.slice(1);\n  }\n\n  if (value === '.inf') {\n    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n  } else if (value === '.nan') {\n    return NaN;\n\n  } else if (value.indexOf(':') >= 0) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseFloat(v, 10));\n    });\n\n    value = 0.0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += d * base;\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n  return sign * parseFloat(value, 10);\n}\n\n\nvar SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\nfunction representYamlFloat(object, style) {\n  var res;\n\n  if (isNaN(object)) {\n    switch (style) {\n      case 'lowercase': return '.nan';\n      case 'uppercase': return '.NAN';\n      case 'camelcase': return '.NaN';\n    }\n  } else if (Number.POSITIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '.inf';\n      case 'uppercase': return '.INF';\n      case 'camelcase': return '.Inf';\n    }\n  } else if (Number.NEGATIVE_INFINITY === object) {\n    switch (style) {\n      case 'lowercase': return '-.inf';\n      case 'uppercase': return '-.INF';\n      case 'camelcase': return '-.Inf';\n    }\n  } else if (common.isNegativeZero(object)) {\n    return '-0.0';\n  }\n\n  res = object.toString(10);\n\n  // JS stringifier can build scientific format without dots: 5e-100,\n  // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n}\n\nfunction isFloat(object) {\n  return (Object.prototype.toString.call(object) === '[object Number]') &&\n         (object % 1 !== 0 || common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:float', {\n  kind: 'scalar',\n  resolve: resolveYamlFloat,\n  construct: constructYamlFloat,\n  predicate: isFloat,\n  represent: representYamlFloat,\n  defaultStyle: 'lowercase'\n});\n\n},{\"../common\":2,\"../type\":13}],17:[function(require,module,exports){\n'use strict';\n\nvar common = require('../common');\nvar Type   = require('../type');\n\nfunction isHexCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n         ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n}\n\nfunction isOctCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n}\n\nfunction isDecCode(c) {\n  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n}\n\nfunction resolveYamlInteger(data) {\n  if (data === null) return false;\n\n  var max = data.length,\n      index = 0,\n      hasDigits = false,\n      ch;\n\n  if (!max) return false;\n\n  ch = data[index];\n\n  // sign\n  if (ch === '-' || ch === '+') {\n    ch = data[++index];\n  }\n\n  if (ch === '0') {\n    // 0\n    if (index + 1 === max) return true;\n    ch = data[++index];\n\n    // base 2, base 8, base 16\n\n    if (ch === 'b') {\n      // base 2\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (ch !== '0' && ch !== '1') return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n\n    if (ch === 'x') {\n      // base 16\n      index++;\n\n      for (; index < max; index++) {\n        ch = data[index];\n        if (ch === '_') continue;\n        if (!isHexCode(data.charCodeAt(index))) return false;\n        hasDigits = true;\n      }\n      return hasDigits && ch !== '_';\n    }\n\n    // base 8\n    for (; index < max; index++) {\n      ch = data[index];\n      if (ch === '_') continue;\n      if (!isOctCode(data.charCodeAt(index))) return false;\n      hasDigits = true;\n    }\n    return hasDigits && ch !== '_';\n  }\n\n  // base 10 (except 0) or base 60\n\n  // value should not start with `_`;\n  if (ch === '_') return false;\n\n  for (; index < max; index++) {\n    ch = data[index];\n    if (ch === '_') continue;\n    if (ch === ':') break;\n    if (!isDecCode(data.charCodeAt(index))) {\n      return false;\n    }\n    hasDigits = true;\n  }\n\n  // Should have digits and should not end with `_`\n  if (!hasDigits || ch === '_') return false;\n\n  // if !base60 - done;\n  if (ch !== ':') return true;\n\n  // base60 almost not used, no needs to optimize\n  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));\n}\n\nfunction constructYamlInteger(data) {\n  var value = data, sign = 1, ch, base, digits = [];\n\n  if (value.indexOf('_') !== -1) {\n    value = value.replace(/_/g, '');\n  }\n\n  ch = value[0];\n\n  if (ch === '-' || ch === '+') {\n    if (ch === '-') sign = -1;\n    value = value.slice(1);\n    ch = value[0];\n  }\n\n  if (value === '0') return 0;\n\n  if (ch === '0') {\n    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n    if (value[1] === 'x') return sign * parseInt(value, 16);\n    return sign * parseInt(value, 8);\n  }\n\n  if (value.indexOf(':') !== -1) {\n    value.split(':').forEach(function (v) {\n      digits.unshift(parseInt(v, 10));\n    });\n\n    value = 0;\n    base = 1;\n\n    digits.forEach(function (d) {\n      value += (d * base);\n      base *= 60;\n    });\n\n    return sign * value;\n\n  }\n\n  return sign * parseInt(value, 10);\n}\n\nfunction isInteger(object) {\n  return (Object.prototype.toString.call(object)) === '[object Number]' &&\n         (object % 1 === 0 && !common.isNegativeZero(object));\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:int', {\n  kind: 'scalar',\n  resolve: resolveYamlInteger,\n  construct: constructYamlInteger,\n  predicate: isInteger,\n  represent: {\n    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },\n    decimal:     function (obj) { return obj.toString(10); },\n    /* eslint-disable max-len */\n    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n  },\n  defaultStyle: 'decimal',\n  styleAliases: {\n    binary:      [ 2,  'bin' ],\n    octal:       [ 8,  'oct' ],\n    decimal:     [ 10, 'dec' ],\n    hexadecimal: [ 16, 'hex' ]\n  }\n});\n\n},{\"../common\":2,\"../type\":13}],18:[function(require,module,exports){\n'use strict';\n\nvar esprima;\n\n// Browserified version does not have esprima\n//\n// 1. For node.js just require module as deps\n// 2. For browser try to require mudule via external AMD system.\n//    If not found - try to fallback to window.esprima. If not\n//    found too - then fail to parse.\n//\ntry {\n  // workaround to exclude package from browserify list.\n  var _require = require;\n  esprima = _require('esprima');\n} catch (_) {\n  /* eslint-disable no-redeclare */\n  /* global window */\n  if (typeof window !== 'undefined') esprima = window.esprima;\n}\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptFunction(data) {\n  if (data === null) return false;\n\n  try {\n    var source = '(' + data + ')',\n        ast    = esprima.parse(source, { range: true });\n\n    if (ast.type                    !== 'Program'             ||\n        ast.body.length             !== 1                     ||\n        ast.body[0].type            !== 'ExpressionStatement' ||\n        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n          ast.body[0].expression.type !== 'FunctionExpression')) {\n      return false;\n    }\n\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nfunction constructJavascriptFunction(data) {\n  /*jslint evil:true*/\n\n  var source = '(' + data + ')',\n      ast    = esprima.parse(source, { range: true }),\n      params = [],\n      body;\n\n  if (ast.type                    !== 'Program'             ||\n      ast.body.length             !== 1                     ||\n      ast.body[0].type            !== 'ExpressionStatement' ||\n      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&\n        ast.body[0].expression.type !== 'FunctionExpression')) {\n    throw new Error('Failed to resolve function');\n  }\n\n  ast.body[0].expression.params.forEach(function (param) {\n    params.push(param.name);\n  });\n\n  body = ast.body[0].expression.body.range;\n\n  // Esprima's ranges include the first '{' and the last '}' characters on\n  // function expressions. So cut them out.\n  if (ast.body[0].expression.body.type === 'BlockStatement') {\n    /*eslint-disable no-new-func*/\n    return new Function(params, source.slice(body[0] + 1, body[1] - 1));\n  }\n  // ES6 arrow functions can omit the BlockStatement. In that case, just return\n  // the body.\n  /*eslint-disable no-new-func*/\n  return new Function(params, 'return ' + source.slice(body[0], body[1]));\n}\n\nfunction representJavascriptFunction(object /*, style*/) {\n  return object.toString();\n}\n\nfunction isFunction(object) {\n  return Object.prototype.toString.call(object) === '[object Function]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/function', {\n  kind: 'scalar',\n  resolve: resolveJavascriptFunction,\n  construct: constructJavascriptFunction,\n  predicate: isFunction,\n  represent: representJavascriptFunction\n});\n\n},{\"../../type\":13}],19:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptRegExp(data) {\n  if (data === null) return false;\n  if (data.length === 0) return false;\n\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // if regexp starts with '/' it can have modifiers and must be properly closed\n  // `/foo/gim` - modifiers tail can be maximum 3 chars\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n\n    if (modifiers.length > 3) return false;\n    // if expression starts with /, is should be properly terminated\n    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;\n  }\n\n  return true;\n}\n\nfunction constructJavascriptRegExp(data) {\n  var regexp = data,\n      tail   = /\\/([gim]*)$/.exec(data),\n      modifiers = '';\n\n  // `/foo/gim` - tail can be maximum 4 chars\n  if (regexp[0] === '/') {\n    if (tail) modifiers = tail[1];\n    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);\n  }\n\n  return new RegExp(regexp, modifiers);\n}\n\nfunction representJavascriptRegExp(object /*, style*/) {\n  var result = '/' + object.source + '/';\n\n  if (object.global) result += 'g';\n  if (object.multiline) result += 'm';\n  if (object.ignoreCase) result += 'i';\n\n  return result;\n}\n\nfunction isRegExp(object) {\n  return Object.prototype.toString.call(object) === '[object RegExp]';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/regexp', {\n  kind: 'scalar',\n  resolve: resolveJavascriptRegExp,\n  construct: constructJavascriptRegExp,\n  predicate: isRegExp,\n  represent: representJavascriptRegExp\n});\n\n},{\"../../type\":13}],20:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../../type');\n\nfunction resolveJavascriptUndefined() {\n  return true;\n}\n\nfunction constructJavascriptUndefined() {\n  /*eslint-disable no-undefined*/\n  return undefined;\n}\n\nfunction representJavascriptUndefined() {\n  return '';\n}\n\nfunction isUndefined(object) {\n  return typeof object === 'undefined';\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:js/undefined', {\n  kind: 'scalar',\n  resolve: resolveJavascriptUndefined,\n  construct: constructJavascriptUndefined,\n  predicate: isUndefined,\n  represent: representJavascriptUndefined\n});\n\n},{\"../../type\":13}],21:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:map', {\n  kind: 'mapping',\n  construct: function (data) { return data !== null ? data : {}; }\n});\n\n},{\"../type\":13}],22:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlMerge(data) {\n  return data === '<<' || data === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:merge', {\n  kind: 'scalar',\n  resolve: resolveYamlMerge\n});\n\n},{\"../type\":13}],23:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nfunction resolveYamlNull(data) {\n  if (data === null) return true;\n\n  var max = data.length;\n\n  return (max === 1 && data === '~') ||\n         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n}\n\nfunction constructYamlNull() {\n  return null;\n}\n\nfunction isNull(object) {\n  return object === null;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:null', {\n  kind: 'scalar',\n  resolve: resolveYamlNull,\n  construct: constructYamlNull,\n  predicate: isNull,\n  represent: {\n    canonical: function () { return '~';    },\n    lowercase: function () { return 'null'; },\n    uppercase: function () { return 'NULL'; },\n    camelcase: function () { return 'Null'; }\n  },\n  defaultStyle: 'lowercase'\n});\n\n},{\"../type\":13}],24:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar _toString       = Object.prototype.toString;\n\nfunction resolveYamlOmap(data) {\n  if (data === null) return true;\n\n  var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n      object = data;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n    pairHasKey = false;\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    for (pairKey in pair) {\n      if (_hasOwnProperty.call(pair, pairKey)) {\n        if (!pairHasKey) pairHasKey = true;\n        else return false;\n      }\n    }\n\n    if (!pairHasKey) return false;\n\n    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n    else return false;\n  }\n\n  return true;\n}\n\nfunction constructYamlOmap(data) {\n  return data !== null ? data : [];\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:omap', {\n  kind: 'sequence',\n  resolve: resolveYamlOmap,\n  construct: constructYamlOmap\n});\n\n},{\"../type\":13}],25:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nvar _toString = Object.prototype.toString;\n\nfunction resolveYamlPairs(data) {\n  if (data === null) return true;\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    if (_toString.call(pair) !== '[object Object]') return false;\n\n    keys = Object.keys(pair);\n\n    if (keys.length !== 1) return false;\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return true;\n}\n\nfunction constructYamlPairs(data) {\n  if (data === null) return [];\n\n  var index, length, pair, keys, result,\n      object = data;\n\n  result = new Array(object.length);\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    pair = object[index];\n\n    keys = Object.keys(pair);\n\n    result[index] = [ keys[0], pair[keys[0]] ];\n  }\n\n  return result;\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:pairs', {\n  kind: 'sequence',\n  resolve: resolveYamlPairs,\n  construct: constructYamlPairs\n});\n\n},{\"../type\":13}],26:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:seq', {\n  kind: 'sequence',\n  construct: function (data) { return data !== null ? data : []; }\n});\n\n},{\"../type\":13}],27:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction resolveYamlSet(data) {\n  if (data === null) return true;\n\n  var key, object = data;\n\n  for (key in object) {\n    if (_hasOwnProperty.call(object, key)) {\n      if (object[key] !== null) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction constructYamlSet(data) {\n  return data !== null ? data : {};\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:set', {\n  kind: 'mapping',\n  resolve: resolveYamlSet,\n  construct: constructYamlSet\n});\n\n},{\"../type\":13}],28:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nmodule.exports = new Type('tag:yaml.org,2002:str', {\n  kind: 'scalar',\n  construct: function (data) { return data !== null ? data : ''; }\n});\n\n},{\"../type\":13}],29:[function(require,module,exports){\n'use strict';\n\nvar Type = require('../type');\n\nvar YAML_DATE_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9])'                    + // [2] month\n  '-([0-9][0-9])$');                   // [3] day\n\nvar YAML_TIMESTAMP_REGEXP = new RegExp(\n  '^([0-9][0-9][0-9][0-9])'          + // [1] year\n  '-([0-9][0-9]?)'                   + // [2] month\n  '-([0-9][0-9]?)'                   + // [3] day\n  '(?:[Tt]|[ \\\\t]+)'                 + // ...\n  '([0-9][0-9]?)'                    + // [4] hour\n  ':([0-9][0-9])'                    + // [5] minute\n  ':([0-9][0-9])'                    + // [6] second\n  '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n  '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\nfunction resolveYamlTimestamp(data) {\n  if (data === null) return false;\n  if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n  return false;\n}\n\nfunction constructYamlTimestamp(data) {\n  var match, year, month, day, hour, minute, second, fraction = 0,\n      delta = null, tz_hour, tz_minute, date;\n\n  match = YAML_DATE_REGEXP.exec(data);\n  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n  if (match === null) throw new Error('Date resolve error');\n\n  // match: [1] year [2] month [3] day\n\n  year = +(match[1]);\n  month = +(match[2]) - 1; // JS month starts with 0\n  day = +(match[3]);\n\n  if (!match[4]) { // no hour\n    return new Date(Date.UTC(year, month, day));\n  }\n\n  // match: [4] hour [5] minute [6] second [7] fraction\n\n  hour = +(match[4]);\n  minute = +(match[5]);\n  second = +(match[6]);\n\n  if (match[7]) {\n    fraction = match[7].slice(0, 3);\n    while (fraction.length < 3) { // milli-seconds\n      fraction += '0';\n    }\n    fraction = +fraction;\n  }\n\n  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n  if (match[9]) {\n    tz_hour = +(match[10]);\n    tz_minute = +(match[11] || 0);\n    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n    if (match[9] === '-') delta = -delta;\n  }\n\n  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n  if (delta) date.setTime(date.getTime() - delta);\n\n  return date;\n}\n\nfunction representYamlTimestamp(object /*, style*/) {\n  return object.toISOString();\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:timestamp', {\n  kind: 'scalar',\n  resolve: resolveYamlTimestamp,\n  construct: constructYamlTimestamp,\n  instanceOf: Date,\n  represent: representYamlTimestamp\n});\n\n},{\"../type\":13}],\"/\":[function(require,module,exports){\n'use strict';\n\n\nvar yaml = require('./lib/js-yaml.js');\n\n\nmodule.exports = yaml;\n\n},{\"./lib/js-yaml.js\":1}]},{},[])(\"/\")\n});\n"],"mappings":"AAAA;AAAuD,CAAC,UAASA,CAAT,EAAW;EAAC,IAAG,OAAOC,OAAP,KAAiB,QAAjB,IAA2B,OAAOC,MAAP,KAAgB,WAA9C,EAA0D;IAACA,MAAM,CAACD,OAAP,GAAeD,CAAC,EAAhB;EAAmB,CAA9E,MAAmF,IAAG,OAAOG,MAAP,KAAgB,UAAhB,IAA4BA,MAAM,CAACC,GAAtC,EAA0C;IAACD,MAAM,CAAC,EAAD,EAAIH,CAAJ,CAAN;EAAa,CAAxD,MAA4D;IAAC,IAAIK,CAAJ;;IAAM,IAAG,OAAOC,MAAP,KAAgB,WAAnB,EAA+B;MAACD,CAAC,GAACC,MAAF;IAAS,CAAzC,MAA8C,IAAG,OAAOC,MAAP,KAAgB,WAAnB,EAA+B;MAACF,CAAC,GAACE,MAAF;IAAS,CAAzC,MAA8C,IAAG,OAAOC,IAAP,KAAc,WAAjB,EAA6B;MAACH,CAAC,GAACG,IAAF;IAAO,CAArC,MAAyC;MAACH,CAAC,GAAC,IAAF;IAAO;;IAAAA,CAAC,CAACI,MAAF,GAAWT,CAAC,EAAZ;EAAe;AAAC,CAAhU,EAAkU,YAAU;EAAC,IAAIG,MAAJ,EAAWD,MAAX,EAAkBD,OAAlB;EAA0B,OAAQ,YAAU;IAAC,SAASS,CAAT,CAAWC,CAAX,EAAaC,CAAb,EAAeC,CAAf,EAAiB;MAAC,SAASC,CAAT,CAAWC,CAAX,EAAaf,CAAb,EAAe;QAAC,IAAG,CAACY,CAAC,CAACG,CAAD,CAAL,EAAS;UAAC,IAAG,CAACJ,CAAC,CAACI,CAAD,CAAL,EAAS;YAAC,IAAIC,CAAC,GAAC,cAAY,OAAOC,OAAnB,IAA4BA,OAAlC;YAA0C,IAAG,CAACjB,CAAD,IAAIgB,CAAP,EAAS,OAAOA,CAAC,CAACD,CAAD,EAAG,CAAC,CAAJ,CAAR;YAAe,IAAGG,CAAH,EAAK,OAAOA,CAAC,CAACH,CAAD,EAAG,CAAC,CAAJ,CAAR;YAAe,IAAII,CAAC,GAAC,IAAIC,KAAJ,CAAU,yBAAuBL,CAAvB,GAAyB,GAAnC,CAAN;YAA8C,MAAMI,CAAC,CAACE,IAAF,GAAO,kBAAP,EAA0BF,CAAhC;UAAkC;;UAAA,IAAIG,CAAC,GAACV,CAAC,CAACG,CAAD,CAAD,GAAK;YAACd,OAAO,EAAC;UAAT,CAAX;UAAwBU,CAAC,CAACI,CAAD,CAAD,CAAK,CAAL,EAAQQ,IAAR,CAAaD,CAAC,CAACrB,OAAf,EAAuB,UAASS,CAAT,EAAW;YAAC,IAAIE,CAAC,GAACD,CAAC,CAACI,CAAD,CAAD,CAAK,CAAL,EAAQL,CAAR,CAAN;YAAiB,OAAOI,CAAC,CAACF,CAAC,IAAEF,CAAJ,CAAR;UAAe,CAAnE,EAAoEY,CAApE,EAAsEA,CAAC,CAACrB,OAAxE,EAAgFS,CAAhF,EAAkFC,CAAlF,EAAoFC,CAApF,EAAsFC,CAAtF;QAAyF;;QAAA,OAAOD,CAAC,CAACG,CAAD,CAAD,CAAKd,OAAZ;MAAoB;;MAAA,KAAI,IAAIiB,CAAC,GAAC,cAAY,OAAOD,OAAnB,IAA4BA,OAAlC,EAA0CF,CAAC,GAAC,CAAhD,EAAkDA,CAAC,GAACF,CAAC,CAACW,MAAtD,EAA6DT,CAAC,EAA9D,EAAiED,CAAC,CAACD,CAAC,CAACE,CAAD,CAAF,CAAD;;MAAQ,OAAOD,CAAP;IAAS;;IAAA,OAAOJ,CAAP;EAAS,CAAxc,GAA4c;IAAC,GAAE,CAAC,UAASO,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACr5B;;MAGA,IAAIwB,MAAM,GAAGR,OAAO,CAAC,kBAAD,CAApB;;MACA,IAAIS,MAAM,GAAGT,OAAO,CAAC,kBAAD,CAApB;;MAGA,SAASU,UAAT,CAAoBC,IAApB,EAA0B;QACxB,OAAO,YAAY;UACjB,MAAM,IAAIR,KAAJ,CAAU,cAAcQ,IAAd,GAAqB,oCAA/B,CAAN;QACD,CAFD;MAGD;;MAGD1B,MAAM,CAACD,OAAP,CAAe4B,IAAf,GAAqCZ,OAAO,CAAC,gBAAD,CAA5C;MACAf,MAAM,CAACD,OAAP,CAAe6B,MAAf,GAAqCb,OAAO,CAAC,kBAAD,CAA5C;MACAf,MAAM,CAACD,OAAP,CAAe8B,eAAf,GAAqCd,OAAO,CAAC,2BAAD,CAA5C;MACAf,MAAM,CAACD,OAAP,CAAe+B,WAAf,GAAqCf,OAAO,CAAC,uBAAD,CAA5C;MACAf,MAAM,CAACD,OAAP,CAAegC,WAAf,GAAqChB,OAAO,CAAC,uBAAD,CAA5C;MACAf,MAAM,CAACD,OAAP,CAAeiC,mBAAf,GAAqCjB,OAAO,CAAC,+BAAD,CAA5C;MACAf,MAAM,CAACD,OAAP,CAAekC,mBAAf,GAAqClB,OAAO,CAAC,+BAAD,CAA5C;MACAf,MAAM,CAACD,OAAP,CAAemC,IAAf,GAAqCX,MAAM,CAACW,IAA5C;MACAlC,MAAM,CAACD,OAAP,CAAeoC,OAAf,GAAqCZ,MAAM,CAACY,OAA5C;MACAnC,MAAM,CAACD,OAAP,CAAeqC,QAAf,GAAqCb,MAAM,CAACa,QAA5C;MACApC,MAAM,CAACD,OAAP,CAAesC,WAAf,GAAqCd,MAAM,CAACc,WAA5C;MACArC,MAAM,CAACD,OAAP,CAAeuC,IAAf,GAAqCd,MAAM,CAACc,IAA5C;MACAtC,MAAM,CAACD,OAAP,CAAewC,QAAf,GAAqCf,MAAM,CAACe,QAA5C;MACAvC,MAAM,CAACD,OAAP,CAAeyC,aAAf,GAAqCzB,OAAO,CAAC,qBAAD,CAA5C,CA5Bq5B,CA8Br5B;;MACAf,MAAM,CAACD,OAAP,CAAe0C,cAAf,GAAgC1B,OAAO,CAAC,2BAAD,CAAvC;MACAf,MAAM,CAACD,OAAP,CAAe2C,WAAf,GAAgC3B,OAAO,CAAC,+BAAD,CAAvC;MACAf,MAAM,CAACD,OAAP,CAAe4C,cAAf,GAAgC5B,OAAO,CAAC,+BAAD,CAAvC,CAjCq5B,CAmCr5B;;MACAf,MAAM,CAACD,OAAP,CAAe6C,IAAf,GAAgCnB,UAAU,CAAC,MAAD,CAA1C;MACAzB,MAAM,CAACD,OAAP,CAAe8C,KAAf,GAAgCpB,UAAU,CAAC,OAAD,CAA1C;MACAzB,MAAM,CAACD,OAAP,CAAe+C,OAAf,GAAgCrB,UAAU,CAAC,SAAD,CAA1C;MACAzB,MAAM,CAACD,OAAP,CAAegD,cAAf,GAAgCtB,UAAU,CAAC,gBAAD,CAA1C;IAEC,CAzCm3B,EAyCl3B;MAAC,oBAAmB,CAApB;MAAsB,uBAAsB,CAA5C;MAA8C,oBAAmB,CAAjE;MAAmE,oBAAmB,CAAtF;MAAwF,yBAAwB,CAAhH;MAAkH,iCAAgC,CAAlJ;MAAoJ,iCAAgC,EAApL;MAAuL,6BAA4B,EAAnN;MAAsN,yBAAwB,EAA9O;MAAiP,kBAAiB;IAAlQ,CAzCk3B,CAAH;IAyCxmB,GAAE,CAAC,UAASV,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MAC5S;;MAGA,SAASiD,SAAT,CAAmBC,OAAnB,EAA4B;QAC1B,OAAQ,OAAOA,OAAP,KAAmB,WAApB,IAAqCA,OAAO,KAAK,IAAxD;MACD;;MAGD,SAASC,QAAT,CAAkBD,OAAlB,EAA2B;QACzB,OAAQ,OAAOA,OAAP,KAAmB,QAApB,IAAkCA,OAAO,KAAK,IAArD;MACD;;MAGD,SAASE,OAAT,CAAiBC,QAAjB,EAA2B;QACzB,IAAIC,KAAK,CAACC,OAAN,CAAcF,QAAd,CAAJ,EAA6B,OAAOA,QAAP,CAA7B,KACK,IAAIJ,SAAS,CAACI,QAAD,CAAb,EAAyB,OAAO,EAAP;QAE9B,OAAO,CAAEA,QAAF,CAAP;MACD;;MAGD,SAASG,MAAT,CAAgBC,MAAhB,EAAwBC,MAAxB,EAAgC;QAC9B,IAAIC,KAAJ,EAAWpC,MAAX,EAAmBqC,GAAnB,EAAwBC,UAAxB;;QAEA,IAAIH,MAAJ,EAAY;UACVG,UAAU,GAAGC,MAAM,CAACC,IAAP,CAAYL,MAAZ,CAAb;;UAEA,KAAKC,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAGsC,UAAU,CAACtC,MAApC,EAA4CoC,KAAK,GAAGpC,MAApD,EAA4DoC,KAAK,IAAI,CAArE,EAAwE;YACtEC,GAAG,GAAGC,UAAU,CAACF,KAAD,CAAhB;YACAF,MAAM,CAACG,GAAD,CAAN,GAAcF,MAAM,CAACE,GAAD,CAApB;UACD;QACF;;QAED,OAAOH,MAAP;MACD;;MAGD,SAASO,MAAT,CAAgBC,MAAhB,EAAwBC,KAAxB,EAA+B;QAC7B,IAAIC,MAAM,GAAG,EAAb;QAAA,IAAiBC,KAAjB;;QAEA,KAAKA,KAAK,GAAG,CAAb,EAAgBA,KAAK,GAAGF,KAAxB,EAA+BE,KAAK,IAAI,CAAxC,EAA2C;UACzCD,MAAM,IAAIF,MAAV;QACD;;QAED,OAAOE,MAAP;MACD;;MAGD,SAASE,cAAT,CAAwBC,MAAxB,EAAgC;QAC9B,OAAQA,MAAM,KAAK,CAAZ,IAAmBC,MAAM,CAACC,iBAAP,KAA6B,IAAIF,MAA3D;MACD;;MAGDrE,MAAM,CAACD,OAAP,CAAeiD,SAAf,GAAgCA,SAAhC;MACAhD,MAAM,CAACD,OAAP,CAAemD,QAAf,GAAgCA,QAAhC;MACAlD,MAAM,CAACD,OAAP,CAAeoD,OAAf,GAAgCA,OAAhC;MACAnD,MAAM,CAACD,OAAP,CAAegE,MAAf,GAAgCA,MAAhC;MACA/D,MAAM,CAACD,OAAP,CAAeqE,cAAf,GAAgCA,cAAhC;MACApE,MAAM,CAACD,OAAP,CAAewD,MAAf,GAAgCA,MAAhC;IAEC,CA7D0Q,EA6DzQ,EA7DyQ,CAzCsmB;IAsG32B,GAAE,CAAC,UAASxC,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACzC;MAEA;;MAEA,IAAIyE,MAAM,GAAgBzD,OAAO,CAAC,UAAD,CAAjC;;MACA,IAAIyB,aAAa,GAASzB,OAAO,CAAC,aAAD,CAAjC;;MACA,IAAIkB,mBAAmB,GAAGlB,OAAO,CAAC,uBAAD,CAAjC;;MACA,IAAIiB,mBAAmB,GAAGjB,OAAO,CAAC,uBAAD,CAAjC;;MAEA,IAAI0D,SAAS,GAASZ,MAAM,CAACa,SAAP,CAAiBC,QAAvC;MACA,IAAIC,eAAe,GAAGf,MAAM,CAACa,SAAP,CAAiBG,cAAvC;MAEA,IAAIC,QAAQ,GAAoB,IAAhC;MAAsC;;MACtC,IAAIC,cAAc,GAAc,IAAhC;MAAsC;;MACtC,IAAIC,oBAAoB,GAAQ,IAAhC;MAAsC;;MACtC,IAAIC,UAAU,GAAkB,IAAhC;MAAsC;;MACtC,IAAIC,gBAAgB,GAAY,IAAhC;MAAsC;;MACtC,IAAIC,iBAAiB,GAAW,IAAhC;MAAsC;;MACtC,IAAIC,UAAU,GAAkB,IAAhC;MAAsC;;MACtC,IAAIC,YAAY,GAAgB,IAAhC;MAAsC;;MACtC,IAAIC,cAAc,GAAc,IAAhC;MAAsC;;MACtC,IAAIC,iBAAiB,GAAW,IAAhC;MAAsC;;MACtC,IAAIC,aAAa,GAAe,IAAhC;MAAsC;;MACtC,IAAIC,UAAU,GAAkB,IAAhC;MAAsC;;MACtC,IAAIC,UAAU,GAAkB,IAAhC;MAAsC;;MACtC,IAAIC,UAAU,GAAkB,IAAhC;MAAsC;;MACtC,IAAIC,WAAW,GAAiB,IAAhC;MAAsC;;MACtC,IAAIC,iBAAiB,GAAW,IAAhC;MAAsC;;MACtC,IAAIC,aAAa,GAAe,IAAhC;MAAsC;;MACtC,IAAIC,kBAAkB,GAAU,IAAhC;MAAsC;;MACtC,IAAIC,wBAAwB,GAAI,IAAhC;MAAsC;;MACtC,IAAIC,yBAAyB,GAAG,IAAhC;MAAsC;;MACtC,IAAIC,iBAAiB,GAAW,IAAhC;MAAsC;;MACtC,IAAIC,uBAAuB,GAAK,IAAhC;MAAsC;;MACtC,IAAIC,kBAAkB,GAAU,IAAhC;MAAsC;;MACtC,IAAIC,wBAAwB,GAAI,IAAhC;MAAsC;;MAEtC,IAAIC,gBAAgB,GAAG,EAAvB;MAEAA,gBAAgB,CAAC,IAAD,CAAhB,GAA2B,KAA3B;MACAA,gBAAgB,CAAC,IAAD,CAAhB,GAA2B,KAA3B;MACAA,gBAAgB,CAAC,IAAD,CAAhB,GAA2B,KAA3B;MACAA,gBAAgB,CAAC,IAAD,CAAhB,GAA2B,KAA3B;MACAA,gBAAgB,CAAC,IAAD,CAAhB,GAA2B,KAA3B;MACAA,gBAAgB,CAAC,IAAD,CAAhB,GAA2B,KAA3B;MACAA,gBAAgB,CAAC,IAAD,CAAhB,GAA2B,KAA3B;MACAA,gBAAgB,CAAC,IAAD,CAAhB,GAA2B,KAA3B;MACAA,gBAAgB,CAAC,IAAD,CAAhB,GAA2B,KAA3B;MACAA,gBAAgB,CAAC,IAAD,CAAhB,GAA2B,KAA3B;MACAA,gBAAgB,CAAC,IAAD,CAAhB,GAA2B,MAA3B;MACAA,gBAAgB,CAAC,IAAD,CAAhB,GAA2B,KAA3B;MACAA,gBAAgB,CAAC,IAAD,CAAhB,GAA2B,KAA3B;MACAA,gBAAgB,CAAC,MAAD,CAAhB,GAA2B,KAA3B;MACAA,gBAAgB,CAAC,MAAD,CAAhB,GAA2B,KAA3B;MAEA,IAAIC,0BAA0B,GAAG,CAC/B,GAD+B,EAC1B,GAD0B,EACrB,KADqB,EACd,KADc,EACP,KADO,EACA,IADA,EACM,IADN,EACY,IADZ,EAE/B,GAF+B,EAE1B,GAF0B,EAErB,IAFqB,EAEf,IAFe,EAET,IAFS,EAEH,KAFG,EAEI,KAFJ,EAEW,KAFX,CAAjC;;MAKA,SAASC,eAAT,CAAyBC,MAAzB,EAAiCC,GAAjC,EAAsC;QACpC,IAAIxC,MAAJ,EAAYJ,IAAZ,EAAkBJ,KAAlB,EAAyBpC,MAAzB,EAAiCqF,GAAjC,EAAsCC,KAAtC,EAA6CC,IAA7C;QAEA,IAAIH,GAAG,KAAK,IAAZ,EAAkB,OAAO,EAAP;QAElBxC,MAAM,GAAG,EAAT;QACAJ,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAY4C,GAAZ,CAAP;;QAEA,KAAKhD,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAGwC,IAAI,CAACxC,MAA9B,EAAsCoC,KAAK,GAAGpC,MAA9C,EAAsDoC,KAAK,IAAI,CAA/D,EAAkE;UAChEiD,GAAG,GAAG7C,IAAI,CAACJ,KAAD,CAAV;UACAkD,KAAK,GAAGE,MAAM,CAACJ,GAAG,CAACC,GAAD,CAAJ,CAAd;;UAEA,IAAIA,GAAG,CAACI,KAAJ,CAAU,CAAV,EAAa,CAAb,MAAoB,IAAxB,EAA8B;YAC5BJ,GAAG,GAAG,uBAAuBA,GAAG,CAACI,KAAJ,CAAU,CAAV,CAA7B;UACD;;UACDF,IAAI,GAAGJ,MAAM,CAACO,eAAP,CAAuB,UAAvB,EAAmCL,GAAnC,CAAP;;UAEA,IAAIE,IAAI,IAAIjC,eAAe,CAACvD,IAAhB,CAAqBwF,IAAI,CAACI,YAA1B,EAAwCL,KAAxC,CAAZ,EAA4D;YAC1DA,KAAK,GAAGC,IAAI,CAACI,YAAL,CAAkBL,KAAlB,CAAR;UACD;;UAED1C,MAAM,CAACyC,GAAD,CAAN,GAAcC,KAAd;QACD;;QAED,OAAO1C,MAAP;MACD;;MAED,SAASgD,SAAT,CAAmBC,SAAnB,EAA8B;QAC5B,IAAInD,MAAJ,EAAYoD,MAAZ,EAAoB9F,MAApB;QAEA0C,MAAM,GAAGmD,SAAS,CAACxC,QAAV,CAAmB,EAAnB,EAAuB0C,WAAvB,EAAT;;QAEA,IAAIF,SAAS,IAAI,IAAjB,EAAuB;UACrBC,MAAM,GAAG,GAAT;UACA9F,MAAM,GAAG,CAAT;QACD,CAHD,MAGO,IAAI6F,SAAS,IAAI,MAAjB,EAAyB;UAC9BC,MAAM,GAAG,GAAT;UACA9F,MAAM,GAAG,CAAT;QACD,CAHM,MAGA,IAAI6F,SAAS,IAAI,UAAjB,EAA6B;UAClCC,MAAM,GAAG,GAAT;UACA9F,MAAM,GAAG,CAAT;QACD,CAHM,MAGA;UACL,MAAM,IAAIkB,aAAJ,CAAkB,+DAAlB,CAAN;QACD;;QAED,OAAO,OAAO4E,MAAP,GAAgB5C,MAAM,CAACT,MAAP,CAAc,GAAd,EAAmBzC,MAAM,GAAG0C,MAAM,CAAC1C,MAAnC,CAAhB,GAA6D0C,MAApE;MACD;;MAED,SAASsD,KAAT,CAAeC,OAAf,EAAwB;QACtB,KAAKd,MAAL,GAAqBc,OAAO,CAAC,QAAD,CAAP,IAAqBtF,mBAA1C;QACA,KAAKuF,MAAL,GAAqBC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAaH,OAAO,CAAC,QAAD,CAAP,IAAqB,CAAlC,CAArB;QACA,KAAKI,aAAL,GAAqBJ,OAAO,CAAC,eAAD,CAAP,IAA4B,KAAjD;QACA,KAAKK,WAAL,GAAqBL,OAAO,CAAC,aAAD,CAAP,IAA0B,KAA/C;QACA,KAAKM,SAAL,GAAsBrD,MAAM,CAACxB,SAAP,CAAiBuE,OAAO,CAAC,WAAD,CAAxB,IAAyC,CAAC,CAA1C,GAA8CA,OAAO,CAAC,WAAD,CAA3E;QACA,KAAKO,QAAL,GAAqBtB,eAAe,CAAC,KAAKC,MAAN,EAAcc,OAAO,CAAC,QAAD,CAAP,IAAqB,IAAnC,CAApC;QACA,KAAKQ,QAAL,GAAqBR,OAAO,CAAC,UAAD,CAAP,IAAuB,KAA5C;QACA,KAAKS,SAAL,GAAqBT,OAAO,CAAC,WAAD,CAAP,IAAwB,EAA7C;QACA,KAAKU,MAAL,GAAqBV,OAAO,CAAC,QAAD,CAAP,IAAqB,KAA1C;QACA,KAAKW,YAAL,GAAqBX,OAAO,CAAC,cAAD,CAAP,IAA2B,KAAhD;QACA,KAAKY,YAAL,GAAqBZ,OAAO,CAAC,cAAD,CAAP,IAA2B,KAAhD;QAEA,KAAKa,aAAL,GAAqB,KAAK3B,MAAL,CAAY4B,gBAAjC;QACA,KAAKC,aAAL,GAAqB,KAAK7B,MAAL,CAAY8B,gBAAjC;QAEA,KAAK5B,GAAL,GAAW,IAAX;QACA,KAAKzC,MAAL,GAAc,EAAd;QAEA,KAAKsE,UAAL,GAAkB,EAAlB;QACA,KAAKC,cAAL,GAAsB,IAAtB;MACD,CAlIwC,CAoIzC;;;MACA,SAASC,YAAT,CAAsB1E,MAAtB,EAA8B2E,MAA9B,EAAsC;QACpC,IAAIC,GAAG,GAAGpE,MAAM,CAACT,MAAP,CAAc,GAAd,EAAmB4E,MAAnB,CAAV;QAAA,IACIE,QAAQ,GAAG,CADf;QAAA,IAEIC,IAAI,GAAG,CAAC,CAFZ;QAAA,IAGI5E,MAAM,GAAG,EAHb;QAAA,IAII6E,IAJJ;QAAA,IAKIzH,MAAM,GAAG0C,MAAM,CAAC1C,MALpB;;QAOA,OAAOuH,QAAQ,GAAGvH,MAAlB,EAA0B;UACxBwH,IAAI,GAAG9E,MAAM,CAACgF,OAAP,CAAe,IAAf,EAAqBH,QAArB,CAAP;;UACA,IAAIC,IAAI,KAAK,CAAC,CAAd,EAAiB;YACfC,IAAI,GAAG/E,MAAM,CAAC+C,KAAP,CAAa8B,QAAb,CAAP;YACAA,QAAQ,GAAGvH,MAAX;UACD,CAHD,MAGO;YACLyH,IAAI,GAAG/E,MAAM,CAAC+C,KAAP,CAAa8B,QAAb,EAAuBC,IAAI,GAAG,CAA9B,CAAP;YACAD,QAAQ,GAAGC,IAAI,GAAG,CAAlB;UACD;;UAED,IAAIC,IAAI,CAACzH,MAAL,IAAeyH,IAAI,KAAK,IAA5B,EAAkC7E,MAAM,IAAI0E,GAAV;UAElC1E,MAAM,IAAI6E,IAAV;QACD;;QAED,OAAO7E,MAAP;MACD;;MAED,SAAS+E,gBAAT,CAA0BC,KAA1B,EAAiCC,KAAjC,EAAwC;QACtC,OAAO,OAAO3E,MAAM,CAACT,MAAP,CAAc,GAAd,EAAmBmF,KAAK,CAAC1B,MAAN,GAAe2B,KAAlC,CAAd;MACD;;MAED,SAASC,qBAAT,CAA+BF,KAA/B,EAAsCG,GAAtC,EAA2C;QACzC,IAAI3F,KAAJ,EAAWpC,MAAX,EAAmBuF,IAAnB;;QAEA,KAAKnD,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAG4H,KAAK,CAACd,aAAN,CAAoB9G,MAA7C,EAAqDoC,KAAK,GAAGpC,MAA7D,EAAqEoC,KAAK,IAAI,CAA9E,EAAiF;UAC/EmD,IAAI,GAAGqC,KAAK,CAACd,aAAN,CAAoB1E,KAApB,CAAP;;UAEA,IAAImD,IAAI,CAACyC,OAAL,CAAaD,GAAb,CAAJ,EAAuB;YACrB,OAAO,IAAP;UACD;QACF;;QAED,OAAO,KAAP;MACD,CA/KwC,CAiLzC;;;MACA,SAASE,YAAT,CAAsBzI,CAAtB,EAAyB;QACvB,OAAOA,CAAC,KAAKmE,UAAN,IAAoBnE,CAAC,KAAKgE,QAAjC;MACD,CApLwC,CAsLzC;MACA;MACA;MACA;;;MACA,SAAS0E,WAAT,CAAqB1I,CAArB,EAAwB;QACtB,OAAS,WAAWA,CAAX,IAAgBA,CAAC,IAAI,QAAtB,IACC,WAAWA,CAAX,IAAgBA,CAAC,IAAI,QAAtB,IAAmCA,CAAC,KAAK,MAAzC,IAAmDA,CAAC,KAAK,MADzD,IAEC,WAAWA,CAAX,IAAgBA,CAAC,IAAI,QAAtB,IAAmCA,CAAC,KAAK;QAAO;QAFhD,GAGC,WAAWA,CAAX,IAAgBA,CAAC,IAAI,QAH9B;MAID,CA/LwC,CAiMzC;MACA;MACA;MACA;MACA;MACA;;;MACA,SAAS2I,QAAT,CAAkB3I,CAAlB,EAAqB;QACnB,OAAO0I,WAAW,CAAC1I,CAAD,CAAX,IAAkB,CAACyI,YAAY,CAACzI,CAAD,CAA/B,CACL;QADK,GAEFA,CAAC,KAAK,MAFJ,CAGL;QAHK,GAIFA,CAAC,KAAKkE,oBAJJ,IAKFlE,CAAC,KAAKiE,cALX;MAMD,CA9MwC,CAgNzC;;;MACA,SAAS2E,WAAT,CAAqB5I,CAArB,EAAwB6I,IAAxB,EAA8B;QAC5B;QACA;QACA,OAAOH,WAAW,CAAC1I,CAAD,CAAX,IAAkBA,CAAC,KAAK,MAAxB,CACL;QADK,GAEFA,CAAC,KAAK2E,UAFJ,IAGF3E,CAAC,KAAKkF,wBAHJ,IAIFlF,CAAC,KAAKmF,yBAJJ,IAKFnF,CAAC,KAAKqF,uBALJ,IAMFrF,CAAC,KAAKuF,wBANJ,CAOL;QACA;QARK,GASFvF,CAAC,KAAK6E,UATJ,KAUA7E,CAAC,KAAKsE,UAAP,IAAuBuE,IAAI,IAAIF,QAAQ,CAACE,IAAD,CAVtC,CAAP;MAWD,CA/NwC,CAiOzC;;;MACA,SAASC,gBAAT,CAA0B9I,CAA1B,EAA6B;QAC3B;QACA;QACA,OAAO0I,WAAW,CAAC1I,CAAD,CAAX,IAAkBA,CAAC,KAAK,MAAxB,IACF,CAACyI,YAAY,CAACzI,CAAD,CADX,CACe;QACpB;QACA;QAHK,GAIFA,CAAC,KAAK4E,UAJJ,IAKF5E,CAAC,KAAKgF,aALJ,IAMFhF,CAAC,KAAK6E,UANJ,IAOF7E,CAAC,KAAK2E,UAPJ,IAQF3E,CAAC,KAAKkF,wBARJ,IASFlF,CAAC,KAAKmF,yBATJ,IAUFnF,CAAC,KAAKqF,uBAVJ,IAWFrF,CAAC,KAAKuF,wBAXJ,CAYL;QAZK,GAaFvF,CAAC,KAAKsE,UAbJ,IAcFtE,CAAC,KAAKwE,cAdJ,IAeFxE,CAAC,KAAK0E,aAfJ,IAgBF1E,CAAC,KAAKoE,gBAhBJ,IAiBFpE,CAAC,KAAKsF,kBAjBJ,IAkBFtF,CAAC,KAAK8E,WAlBJ,IAmBF9E,CAAC,KAAK+E,iBAnBJ,IAoBF/E,CAAC,KAAKyE,iBApBJ,IAqBFzE,CAAC,KAAKqE,iBArBJ,CAsBL;QAtBK,GAuBFrE,CAAC,KAAKuE,YAvBJ,IAwBFvE,CAAC,KAAKiF,kBAxBJ,IAyBFjF,CAAC,KAAKoF,iBAzBX;MA0BD,CA/PwC,CAiQzC;;;MACA,SAAS2D,mBAAT,CAA6B7F,MAA7B,EAAqC;QACnC,IAAI8F,cAAc,GAAG,OAArB;QACA,OAAOA,cAAc,CAACC,IAAf,CAAoB/F,MAApB,CAAP;MACD;;MAED,IAAIgG,WAAW,GAAK,CAApB;MAAA,IACIC,YAAY,GAAI,CADpB;MAAA,IAEIC,aAAa,GAAG,CAFpB;MAAA,IAGIC,YAAY,GAAI,CAHpB;MAAA,IAIIC,YAAY,GAAI,CAJpB,CAvQyC,CA6QzC;MACA;MACA;MACA;MACA;MACA;MACA;;MACA,SAASC,iBAAT,CAA2BrG,MAA3B,EAAmCsG,cAAnC,EAAmDC,cAAnD,EAAmEvC,SAAnE,EAA8EwC,iBAA9E,EAAiG;QAC/F,IAAI3J,CAAJ;QACA,IAAI4J,IAAJ,EAAUC,SAAV;QACA,IAAIC,YAAY,GAAG,KAAnB;QACA,IAAIC,eAAe,GAAG,KAAtB,CAJ+F,CAIlE;;QAC7B,IAAIC,gBAAgB,GAAG7C,SAAS,KAAK,CAAC,CAAtC;QACA,IAAI8C,iBAAiB,GAAG,CAAC,CAAzB,CAN+F,CAMnE;;QAC5B,IAAIC,KAAK,GAAGnB,gBAAgB,CAAC5F,MAAM,CAACgH,UAAP,CAAkB,CAAlB,CAAD,CAAhB,IACD,CAACzB,YAAY,CAACvF,MAAM,CAACgH,UAAP,CAAkBhH,MAAM,CAAC1C,MAAP,GAAgB,CAAlC,CAAD,CADxB;;QAGA,IAAIgJ,cAAJ,EAAoB;UAClB;UACA;UACA,KAAKzJ,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGmD,MAAM,CAAC1C,MAAvB,EAA+BT,CAAC,EAAhC,EAAoC;YAClC4J,IAAI,GAAGzG,MAAM,CAACgH,UAAP,CAAkBnK,CAAlB,CAAP;;YACA,IAAI,CAAC2I,WAAW,CAACiB,IAAD,CAAhB,EAAwB;cACtB,OAAOL,YAAP;YACD;;YACDM,SAAS,GAAG7J,CAAC,GAAG,CAAJ,GAAQmD,MAAM,CAACgH,UAAP,CAAkBnK,CAAC,GAAG,CAAtB,CAAR,GAAmC,IAA/C;YACAkK,KAAK,GAAGA,KAAK,IAAIrB,WAAW,CAACe,IAAD,EAAOC,SAAP,CAA5B;UACD;QACF,CAXD,MAWO;UACL;UACA,KAAK7J,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGmD,MAAM,CAAC1C,MAAvB,EAA+BT,CAAC,EAAhC,EAAoC;YAClC4J,IAAI,GAAGzG,MAAM,CAACgH,UAAP,CAAkBnK,CAAlB,CAAP;;YACA,IAAI4J,IAAI,KAAK1F,cAAb,EAA6B;cAC3B4F,YAAY,GAAG,IAAf,CAD2B,CAE3B;;cACA,IAAIE,gBAAJ,EAAsB;gBACpBD,eAAe,GAAGA,eAAe,IAC/B;gBACC/J,CAAC,GAAGiK,iBAAJ,GAAwB,CAAxB,GAA4B9C,SAA5B,IACAhE,MAAM,CAAC8G,iBAAiB,GAAG,CAArB,CAAN,KAAkC,GAHrC;gBAIAA,iBAAiB,GAAGjK,CAApB;cACD;YACF,CAVD,MAUO,IAAI,CAAC2I,WAAW,CAACiB,IAAD,CAAhB,EAAwB;cAC7B,OAAOL,YAAP;YACD;;YACDM,SAAS,GAAG7J,CAAC,GAAG,CAAJ,GAAQmD,MAAM,CAACgH,UAAP,CAAkBnK,CAAC,GAAG,CAAtB,CAAR,GAAmC,IAA/C;YACAkK,KAAK,GAAGA,KAAK,IAAIrB,WAAW,CAACe,IAAD,EAAOC,SAAP,CAA5B;UACD,CAnBI,CAoBL;;;UACAE,eAAe,GAAGA,eAAe,IAAKC,gBAAgB,IACnDhK,CAAC,GAAGiK,iBAAJ,GAAwB,CAAxB,GAA4B9C,SAA5B,IACAhE,MAAM,CAAC8G,iBAAiB,GAAG,CAArB,CAAN,KAAkC,GAFrC;QAGD,CA7C8F,CA8C/F;QACA;QACA;;;QACA,IAAI,CAACH,YAAD,IAAiB,CAACC,eAAtB,EAAuC;UACrC;UACA;UACA,OAAOG,KAAK,IAAI,CAACP,iBAAiB,CAACxG,MAAD,CAA3B,GACHgG,WADG,GACWC,YADlB;QAED,CAtD8F,CAuD/F;;;QACA,IAAIM,cAAc,GAAG,CAAjB,IAAsBV,mBAAmB,CAAC7F,MAAD,CAA7C,EAAuD;UACrD,OAAOoG,YAAP;QACD,CA1D8F,CA2D/F;QACA;;;QACA,OAAOQ,eAAe,GAAGT,YAAH,GAAkBD,aAAxC;MACD,CAlVwC,CAoVzC;MACA;MACA;MACA;MACA;MACA;;;MACA,SAASe,WAAT,CAAqB/B,KAArB,EAA4BlF,MAA5B,EAAoCmF,KAApC,EAA2C+B,KAA3C,EAAkD;QAChDhC,KAAK,CAAC5G,IAAN,GAAc,YAAY;UACxB,IAAI0B,MAAM,CAAC1C,MAAP,KAAkB,CAAtB,EAAyB;YACvB,OAAO,IAAP;UACD;;UACD,IAAI,CAAC4H,KAAK,CAAChB,YAAP,IACA3B,0BAA0B,CAACyC,OAA3B,CAAmChF,MAAnC,MAA+C,CAAC,CADpD,EACuD;YACrD,OAAO,MAAMA,MAAN,GAAe,GAAtB;UACD;;UAED,IAAIwD,MAAM,GAAG0B,KAAK,CAAC1B,MAAN,GAAeC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYyB,KAAZ,CAA5B,CATwB,CASwB;UAChD;UACA;UACA;UACA;UACA;UACA;UACA;;UACA,IAAInB,SAAS,GAAGkB,KAAK,CAAClB,SAAN,KAAoB,CAAC,CAArB,GACZ,CAAC,CADW,GACPP,IAAI,CAACC,GAAL,CAASD,IAAI,CAAC0D,GAAL,CAASjC,KAAK,CAAClB,SAAf,EAA0B,EAA1B,CAAT,EAAwCkB,KAAK,CAAClB,SAAN,GAAkBR,MAA1D,CADT,CAjBwB,CAoBxB;;UACA,IAAI8C,cAAc,GAAGY,KAAK,CACxB;UADwB,GAEpBhC,KAAK,CAACrB,SAAN,GAAkB,CAAC,CAAnB,IAAwBsB,KAAK,IAAID,KAAK,CAACrB,SAF7C;;UAGA,SAASuD,aAAT,CAAuBpH,MAAvB,EAA+B;YAC7B,OAAOoF,qBAAqB,CAACF,KAAD,EAAQlF,MAAR,CAA5B;UACD;;UAED,QAAQqG,iBAAiB,CAACrG,MAAD,EAASsG,cAAT,EAAyBpB,KAAK,CAAC1B,MAA/B,EAAuCQ,SAAvC,EAAkDoD,aAAlD,CAAzB;YACE,KAAKpB,WAAL;cACE,OAAOhG,MAAP;;YACF,KAAKiG,YAAL;cACE,OAAO,MAAMjG,MAAM,CAACqH,OAAP,CAAe,IAAf,EAAqB,IAArB,CAAN,GAAmC,GAA1C;;YACF,KAAKnB,aAAL;cACE,OAAO,MAAMoB,WAAW,CAACtH,MAAD,EAASkF,KAAK,CAAC1B,MAAf,CAAjB,GACH+D,iBAAiB,CAAC7C,YAAY,CAAC1E,MAAD,EAASwD,MAAT,CAAb,CADrB;;YAEF,KAAK2C,YAAL;cACE,OAAO,MAAMmB,WAAW,CAACtH,MAAD,EAASkF,KAAK,CAAC1B,MAAf,CAAjB,GACH+D,iBAAiB,CAAC7C,YAAY,CAAC8C,UAAU,CAACxH,MAAD,EAASgE,SAAT,CAAX,EAAgCR,MAAhC,CAAb,CADrB;;YAEF,KAAK4C,YAAL;cACE,OAAO,MAAMqB,YAAY,CAACzH,MAAD,EAASgE,SAAT,CAAlB,GAAwC,GAA/C;;YACF;cACE,MAAM,IAAIxF,aAAJ,CAAkB,wCAAlB,CAAN;UAdJ;QAgBD,CA5Ca,EAAd;MA6CD,CAxYwC,CA0YzC;;;MACA,SAAS8I,WAAT,CAAqBtH,MAArB,EAA6BuG,cAA7B,EAA6C;QAC3C,IAAImB,eAAe,GAAG7B,mBAAmB,CAAC7F,MAAD,CAAnB,GAA8B8C,MAAM,CAACyD,cAAD,CAApC,GAAuD,EAA7E,CAD2C,CAG3C;;QACA,IAAIoB,IAAI,GAAY3H,MAAM,CAACA,MAAM,CAAC1C,MAAP,GAAgB,CAAjB,CAAN,KAA8B,IAAlD;QACA,IAAIsK,IAAI,GAAGD,IAAI,KAAK3H,MAAM,CAACA,MAAM,CAAC1C,MAAP,GAAgB,CAAjB,CAAN,KAA8B,IAA9B,IAAsC0C,MAAM,KAAK,IAAtD,CAAf;QACA,IAAI6H,KAAK,GAAGD,IAAI,GAAG,GAAH,GAAUD,IAAI,GAAG,EAAH,GAAQ,GAAtC;QAEA,OAAOD,eAAe,GAAGG,KAAlB,GAA0B,IAAjC;MACD,CApZwC,CAsZzC;;;MACA,SAASN,iBAAT,CAA2BvH,MAA3B,EAAmC;QACjC,OAAOA,MAAM,CAACA,MAAM,CAAC1C,MAAP,GAAgB,CAAjB,CAAN,KAA8B,IAA9B,GAAqC0C,MAAM,CAAC+C,KAAP,CAAa,CAAb,EAAgB,CAAC,CAAjB,CAArC,GAA2D/C,MAAlE;MACD,CAzZwC,CA2ZzC;MACA;;;MACA,SAASwH,UAAT,CAAoBxH,MAApB,EAA4B8H,KAA5B,EAAmC;QACjC;QACA;QACA;QACA;QACA,IAAIC,MAAM,GAAG,gBAAb,CALiC,CAOjC;;QACA,IAAI7H,MAAM,GAAI,YAAY;UACxB,IAAI8H,MAAM,GAAGhI,MAAM,CAACgF,OAAP,CAAe,IAAf,CAAb;UACAgD,MAAM,GAAGA,MAAM,KAAK,CAAC,CAAZ,GAAgBA,MAAhB,GAAyBhI,MAAM,CAAC1C,MAAzC;UACAyK,MAAM,CAACE,SAAP,GAAmBD,MAAnB;UACA,OAAOE,QAAQ,CAAClI,MAAM,CAAC+C,KAAP,CAAa,CAAb,EAAgBiF,MAAhB,CAAD,EAA0BF,KAA1B,CAAf;QACD,CALa,EAAd,CARiC,CAcjC;;;QACA,IAAIK,gBAAgB,GAAGnI,MAAM,CAAC,CAAD,CAAN,KAAc,IAAd,IAAsBA,MAAM,CAAC,CAAD,CAAN,KAAc,GAA3D;QACA,IAAIoI,YAAJ,CAhBiC,CAkBjC;;QACA,IAAIC,KAAJ;;QACA,OAAQA,KAAK,GAAGN,MAAM,CAACO,IAAP,CAAYtI,MAAZ,CAAhB,EAAsC;UACpC,IAAIuI,MAAM,GAAGF,KAAK,CAAC,CAAD,CAAlB;UAAA,IAAuBtD,IAAI,GAAGsD,KAAK,CAAC,CAAD,CAAnC;UACAD,YAAY,GAAIrD,IAAI,CAAC,CAAD,CAAJ,KAAY,GAA5B;UACA7E,MAAM,IAAIqI,MAAM,IACX,CAACJ,gBAAD,IAAqB,CAACC,YAAtB,IAAsCrD,IAAI,KAAK,EAA/C,GACC,IADD,GACQ,EAFG,CAAN,GAGNmD,QAAQ,CAACnD,IAAD,EAAO+C,KAAP,CAHZ;UAIAK,gBAAgB,GAAGC,YAAnB;QACD;;QAED,OAAOlI,MAAP;MACD,CA5bwC,CA8bzC;MACA;MACA;MACA;;;MACA,SAASgI,QAAT,CAAkBnD,IAAlB,EAAwB+C,KAAxB,EAA+B;QAC7B,IAAI/C,IAAI,KAAK,EAAT,IAAeA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAA/B,EAAoC,OAAOA,IAAP,CADP,CAG7B;;QACA,IAAIyD,OAAO,GAAG,QAAd,CAJ6B,CAIL;;QACxB,IAAIH,KAAJ,CAL6B,CAM7B;;QACA,IAAII,KAAK,GAAG,CAAZ;QAAA,IAAeC,GAAf;QAAA,IAAoBC,IAAI,GAAG,CAA3B;QAAA,IAA8B7D,IAAI,GAAG,CAArC;QACA,IAAI5E,MAAM,GAAG,EAAb,CAR6B,CAU7B;QACA;QACA;QACA;;QACA,OAAQmI,KAAK,GAAGG,OAAO,CAACF,IAAR,CAAavD,IAAb,CAAhB,EAAqC;UACnCD,IAAI,GAAGuD,KAAK,CAAC3I,KAAb,CADmC,CAEnC;;UACA,IAAIoF,IAAI,GAAG2D,KAAP,GAAeX,KAAnB,EAA0B;YACxBY,GAAG,GAAIC,IAAI,GAAGF,KAAR,GAAiBE,IAAjB,GAAwB7D,IAA9B,CADwB,CACY;;YACpC5E,MAAM,IAAI,OAAO6E,IAAI,CAAChC,KAAL,CAAW0F,KAAX,EAAkBC,GAAlB,CAAjB,CAFwB,CAGxB;;YACAD,KAAK,GAAGC,GAAG,GAAG,CAAd,CAJwB,CAIY;UACrC;;UACDC,IAAI,GAAG7D,IAAP;QACD,CAxB4B,CA0B7B;QACA;;;QACA5E,MAAM,IAAI,IAAV,CA5B6B,CA6B7B;;QACA,IAAI6E,IAAI,CAACzH,MAAL,GAAcmL,KAAd,GAAsBX,KAAtB,IAA+Ba,IAAI,GAAGF,KAA1C,EAAiD;UAC/CvI,MAAM,IAAI6E,IAAI,CAAChC,KAAL,CAAW0F,KAAX,EAAkBE,IAAlB,IAA0B,IAA1B,GAAiC5D,IAAI,CAAChC,KAAL,CAAW4F,IAAI,GAAG,CAAlB,CAA3C;QACD,CAFD,MAEO;UACLzI,MAAM,IAAI6E,IAAI,CAAChC,KAAL,CAAW0F,KAAX,CAAV;QACD;;QAED,OAAOvI,MAAM,CAAC6C,KAAP,CAAa,CAAb,CAAP,CApC6B,CAoCL;MACzB,CAvewC,CAyezC;;;MACA,SAAS0E,YAAT,CAAsBzH,MAAtB,EAA8B;QAC5B,IAAIE,MAAM,GAAG,EAAb;QACA,IAAIuG,IAAJ,EAAUmC,QAAV;QACA,IAAIC,SAAJ;;QAEA,KAAK,IAAIhM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmD,MAAM,CAAC1C,MAA3B,EAAmCT,CAAC,EAApC,EAAwC;UACtC4J,IAAI,GAAGzG,MAAM,CAACgH,UAAP,CAAkBnK,CAAlB,CAAP,CADsC,CAEtC;;UACA,IAAI4J,IAAI,IAAI,MAAR,IAAkBA,IAAI,IAAI;UAAM;UAApC,EAA0D;YACxDmC,QAAQ,GAAG5I,MAAM,CAACgH,UAAP,CAAkBnK,CAAC,GAAG,CAAtB,CAAX;;YACA,IAAI+L,QAAQ,IAAI,MAAZ,IAAsBA,QAAQ,IAAI;YAAM;YAA5C,EAAiE;cAC/D;cACA1I,MAAM,IAAIgD,SAAS,CAAC,CAACuD,IAAI,GAAG,MAAR,IAAkB,KAAlB,GAA0BmC,QAA1B,GAAqC,MAArC,GAA8C,OAA/C,CAAnB,CAF+D,CAG/D;;cACA/L,CAAC;cAAI;YACN;UACF;;UACDgM,SAAS,GAAGvG,gBAAgB,CAACmE,IAAD,CAA5B;UACAvG,MAAM,IAAI,CAAC2I,SAAD,IAAcrD,WAAW,CAACiB,IAAD,CAAzB,GACNzG,MAAM,CAACnD,CAAD,CADA,GAENgM,SAAS,IAAI3F,SAAS,CAACuD,IAAD,CAF1B;QAGD;;QAED,OAAOvG,MAAP;MACD;;MAED,SAAS4I,iBAAT,CAA2B5D,KAA3B,EAAkCC,KAAlC,EAAyC4D,MAAzC,EAAiD;QAC/C,IAAIC,OAAO,GAAG,EAAd;QAAA,IACIC,IAAI,GAAM/D,KAAK,CAACvC,GADpB;QAAA,IAEIjD,KAFJ;QAAA,IAGIpC,MAHJ;;QAKA,KAAKoC,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAGyL,MAAM,CAACzL,MAAhC,EAAwCoC,KAAK,GAAGpC,MAAhD,EAAwDoC,KAAK,IAAI,CAAjE,EAAoE;UAClE;UACA,IAAIwJ,SAAS,CAAChE,KAAD,EAAQC,KAAR,EAAe4D,MAAM,CAACrJ,KAAD,CAArB,EAA8B,KAA9B,EAAqC,KAArC,CAAb,EAA0D;YACxD,IAAIA,KAAK,KAAK,CAAd,EAAiBsJ,OAAO,IAAI,OAAO,CAAC9D,KAAK,CAACf,YAAP,GAAsB,GAAtB,GAA4B,EAAnC,CAAX;YACjB6E,OAAO,IAAI9D,KAAK,CAAC5G,IAAjB;UACD;QACF;;QAED4G,KAAK,CAACvC,GAAN,GAAYsG,IAAZ;QACA/D,KAAK,CAAC5G,IAAN,GAAa,MAAM0K,OAAN,GAAgB,GAA7B;MACD;;MAED,SAASG,kBAAT,CAA4BjE,KAA5B,EAAmCC,KAAnC,EAA0C4D,MAA1C,EAAkDK,OAAlD,EAA2D;QACzD,IAAIJ,OAAO,GAAG,EAAd;QAAA,IACIC,IAAI,GAAM/D,KAAK,CAACvC,GADpB;QAAA,IAEIjD,KAFJ;QAAA,IAGIpC,MAHJ;;QAKA,KAAKoC,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAGyL,MAAM,CAACzL,MAAhC,EAAwCoC,KAAK,GAAGpC,MAAhD,EAAwDoC,KAAK,IAAI,CAAjE,EAAoE;UAClE;UACA,IAAIwJ,SAAS,CAAChE,KAAD,EAAQC,KAAK,GAAG,CAAhB,EAAmB4D,MAAM,CAACrJ,KAAD,CAAzB,EAAkC,IAAlC,EAAwC,IAAxC,CAAb,EAA4D;YAC1D,IAAI,CAAC0J,OAAD,IAAY1J,KAAK,KAAK,CAA1B,EAA6B;cAC3BsJ,OAAO,IAAI/D,gBAAgB,CAACC,KAAD,EAAQC,KAAR,CAA3B;YACD;;YAED,IAAID,KAAK,CAAC5G,IAAN,IAAcyC,cAAc,KAAKmE,KAAK,CAAC5G,IAAN,CAAW0I,UAAX,CAAsB,CAAtB,CAArC,EAA+D;cAC7DgC,OAAO,IAAI,GAAX;YACD,CAFD,MAEO;cACLA,OAAO,IAAI,IAAX;YACD;;YAEDA,OAAO,IAAI9D,KAAK,CAAC5G,IAAjB;UACD;QACF;;QAED4G,KAAK,CAACvC,GAAN,GAAYsG,IAAZ;QACA/D,KAAK,CAAC5G,IAAN,GAAa0K,OAAO,IAAI,IAAxB,CAxByD,CAwB3B;MAC/B;;MAED,SAASK,gBAAT,CAA0BnE,KAA1B,EAAiCC,KAAjC,EAAwC4D,MAAxC,EAAgD;QAC9C,IAAIC,OAAO,GAAS,EAApB;QAAA,IACIC,IAAI,GAAY/D,KAAK,CAACvC,GAD1B;QAAA,IAEI2G,aAAa,GAAGzJ,MAAM,CAACC,IAAP,CAAYiJ,MAAZ,CAFpB;QAAA,IAGIrJ,KAHJ;QAAA,IAIIpC,MAJJ;QAAA,IAKIiM,SALJ;QAAA,IAMIC,WANJ;QAAA,IAOIC,UAPJ;;QASA,KAAK/J,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAGgM,aAAa,CAAChM,MAAvC,EAA+CoC,KAAK,GAAGpC,MAAvD,EAA+DoC,KAAK,IAAI,CAAxE,EAA2E;UAEzE+J,UAAU,GAAG,EAAb;UACA,IAAI/J,KAAK,KAAK,CAAd,EAAiB+J,UAAU,IAAI,IAAd;UAEjB,IAAIvE,KAAK,CAACf,YAAV,EAAwBsF,UAAU,IAAI,GAAd;UAExBF,SAAS,GAAGD,aAAa,CAAC5J,KAAD,CAAzB;UACA8J,WAAW,GAAGT,MAAM,CAACQ,SAAD,CAApB;;UAEA,IAAI,CAACL,SAAS,CAAChE,KAAD,EAAQC,KAAR,EAAeoE,SAAf,EAA0B,KAA1B,EAAiC,KAAjC,CAAd,EAAuD;YACrD,SADqD,CAC3C;UACX;;UAED,IAAIrE,KAAK,CAAC5G,IAAN,CAAWhB,MAAX,GAAoB,IAAxB,EAA8BmM,UAAU,IAAI,IAAd;UAE9BA,UAAU,IAAIvE,KAAK,CAAC5G,IAAN,IAAc4G,KAAK,CAACf,YAAN,GAAqB,GAArB,GAA2B,EAAzC,IAA+C,GAA/C,IAAsDe,KAAK,CAACf,YAAN,GAAqB,EAArB,GAA0B,GAAhF,CAAd;;UAEA,IAAI,CAAC+E,SAAS,CAAChE,KAAD,EAAQC,KAAR,EAAeqE,WAAf,EAA4B,KAA5B,EAAmC,KAAnC,CAAd,EAAyD;YACvD,SADuD,CAC7C;UACX;;UAEDC,UAAU,IAAIvE,KAAK,CAAC5G,IAApB,CAtByE,CAwBzE;;UACA0K,OAAO,IAAIS,UAAX;QACD;;QAEDvE,KAAK,CAACvC,GAAN,GAAYsG,IAAZ;QACA/D,KAAK,CAAC5G,IAAN,GAAa,MAAM0K,OAAN,GAAgB,GAA7B;MACD;;MAED,SAASU,iBAAT,CAA2BxE,KAA3B,EAAkCC,KAAlC,EAAyC4D,MAAzC,EAAiDK,OAAjD,EAA0D;QACxD,IAAIJ,OAAO,GAAS,EAApB;QAAA,IACIC,IAAI,GAAY/D,KAAK,CAACvC,GAD1B;QAAA,IAEI2G,aAAa,GAAGzJ,MAAM,CAACC,IAAP,CAAYiJ,MAAZ,CAFpB;QAAA,IAGIrJ,KAHJ;QAAA,IAIIpC,MAJJ;QAAA,IAKIiM,SALJ;QAAA,IAMIC,WANJ;QAAA,IAOIG,YAPJ;QAAA,IAQIF,UARJ,CADwD,CAWxD;;QACA,IAAIvE,KAAK,CAACnB,QAAN,KAAmB,IAAvB,EAA6B;UAC3B;UACAuF,aAAa,CAACM,IAAd;QACD,CAHD,MAGO,IAAI,OAAO1E,KAAK,CAACnB,QAAb,KAA0B,UAA9B,EAA0C;UAC/C;UACAuF,aAAa,CAACM,IAAd,CAAmB1E,KAAK,CAACnB,QAAzB;QACD,CAHM,MAGA,IAAImB,KAAK,CAACnB,QAAV,EAAoB;UACzB;UACA,MAAM,IAAIvF,aAAJ,CAAkB,0CAAlB,CAAN;QACD;;QAED,KAAKkB,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAGgM,aAAa,CAAChM,MAAvC,EAA+CoC,KAAK,GAAGpC,MAAvD,EAA+DoC,KAAK,IAAI,CAAxE,EAA2E;UACzE+J,UAAU,GAAG,EAAb;;UAEA,IAAI,CAACL,OAAD,IAAY1J,KAAK,KAAK,CAA1B,EAA6B;YAC3B+J,UAAU,IAAIxE,gBAAgB,CAACC,KAAD,EAAQC,KAAR,CAA9B;UACD;;UAEDoE,SAAS,GAAGD,aAAa,CAAC5J,KAAD,CAAzB;UACA8J,WAAW,GAAGT,MAAM,CAACQ,SAAD,CAApB;;UAEA,IAAI,CAACL,SAAS,CAAChE,KAAD,EAAQC,KAAK,GAAG,CAAhB,EAAmBoE,SAAnB,EAA8B,IAA9B,EAAoC,IAApC,EAA0C,IAA1C,CAAd,EAA+D;YAC7D,SAD6D,CACnD;UACX;;UAEDI,YAAY,GAAIzE,KAAK,CAACvC,GAAN,KAAc,IAAd,IAAsBuC,KAAK,CAACvC,GAAN,KAAc,GAArC,IACCuC,KAAK,CAAC5G,IAAN,IAAc4G,KAAK,CAAC5G,IAAN,CAAWhB,MAAX,GAAoB,IADlD;;UAGA,IAAIqM,YAAJ,EAAkB;YAChB,IAAIzE,KAAK,CAAC5G,IAAN,IAAcyC,cAAc,KAAKmE,KAAK,CAAC5G,IAAN,CAAW0I,UAAX,CAAsB,CAAtB,CAArC,EAA+D;cAC7DyC,UAAU,IAAI,GAAd;YACD,CAFD,MAEO;cACLA,UAAU,IAAI,IAAd;YACD;UACF;;UAEDA,UAAU,IAAIvE,KAAK,CAAC5G,IAApB;;UAEA,IAAIqL,YAAJ,EAAkB;YAChBF,UAAU,IAAIxE,gBAAgB,CAACC,KAAD,EAAQC,KAAR,CAA9B;UACD;;UAED,IAAI,CAAC+D,SAAS,CAAChE,KAAD,EAAQC,KAAK,GAAG,CAAhB,EAAmBqE,WAAnB,EAAgC,IAAhC,EAAsCG,YAAtC,CAAd,EAAmE;YACjE,SADiE,CACvD;UACX;;UAED,IAAIzE,KAAK,CAAC5G,IAAN,IAAcyC,cAAc,KAAKmE,KAAK,CAAC5G,IAAN,CAAW0I,UAAX,CAAsB,CAAtB,CAArC,EAA+D;YAC7DyC,UAAU,IAAI,GAAd;UACD,CAFD,MAEO;YACLA,UAAU,IAAI,IAAd;UACD;;UAEDA,UAAU,IAAIvE,KAAK,CAAC5G,IAApB,CAzCyE,CA2CzE;;UACA0K,OAAO,IAAIS,UAAX;QACD;;QAEDvE,KAAK,CAACvC,GAAN,GAAYsG,IAAZ;QACA/D,KAAK,CAAC5G,IAAN,GAAa0K,OAAO,IAAI,IAAxB,CAvEwD,CAuE1B;MAC/B;;MAED,SAASa,UAAT,CAAoB3E,KAApB,EAA2B6D,MAA3B,EAAmCe,QAAnC,EAA6C;QAC3C,IAAId,OAAJ,EAAae,QAAb,EAAuBrK,KAAvB,EAA8BpC,MAA9B,EAAsCuF,IAAtC,EAA4CD,KAA5C;;QAEAmH,QAAQ,GAAGD,QAAQ,GAAG5E,KAAK,CAACZ,aAAT,GAAyBY,KAAK,CAACd,aAAlD;;QAEA,KAAK1E,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAGyM,QAAQ,CAACzM,MAAlC,EAA0CoC,KAAK,GAAGpC,MAAlD,EAA0DoC,KAAK,IAAI,CAAnE,EAAsE;UACpEmD,IAAI,GAAGkH,QAAQ,CAACrK,KAAD,CAAf;;UAEA,IAAI,CAACmD,IAAI,CAACmH,UAAL,IAAoBnH,IAAI,CAACoH,SAA1B,MACC,CAACpH,IAAI,CAACmH,UAAN,IAAsB,OAAOjB,MAAP,KAAkB,QAAnB,IAAiCA,MAAM,YAAYlG,IAAI,CAACmH,UAD9E,MAEC,CAACnH,IAAI,CAACoH,SAAN,IAAoBpH,IAAI,CAACoH,SAAL,CAAelB,MAAf,CAFrB,CAAJ,EAEkD;YAEhD7D,KAAK,CAACvC,GAAN,GAAYmH,QAAQ,GAAGjH,IAAI,CAACF,GAAR,GAAc,GAAlC;;YAEA,IAAIE,IAAI,CAACqH,SAAT,EAAoB;cAClBtH,KAAK,GAAGsC,KAAK,CAACpB,QAAN,CAAejB,IAAI,CAACF,GAApB,KAA4BE,IAAI,CAACsH,YAAzC;;cAEA,IAAI1J,SAAS,CAACpD,IAAV,CAAewF,IAAI,CAACqH,SAApB,MAAmC,mBAAvC,EAA4D;gBAC1DlB,OAAO,GAAGnG,IAAI,CAACqH,SAAL,CAAenB,MAAf,EAAuBnG,KAAvB,CAAV;cACD,CAFD,MAEO,IAAIhC,eAAe,CAACvD,IAAhB,CAAqBwF,IAAI,CAACqH,SAA1B,EAAqCtH,KAArC,CAAJ,EAAiD;gBACtDoG,OAAO,GAAGnG,IAAI,CAACqH,SAAL,CAAetH,KAAf,EAAsBmG,MAAtB,EAA8BnG,KAA9B,CAAV;cACD,CAFM,MAEA;gBACL,MAAM,IAAIpE,aAAJ,CAAkB,OAAOqE,IAAI,CAACF,GAAZ,GAAkB,8BAAlB,GAAmDC,KAAnD,GAA2D,SAA7E,CAAN;cACD;;cAEDsC,KAAK,CAAC5G,IAAN,GAAa0K,OAAb;YACD;;YAED,OAAO,IAAP;UACD;QACF;;QAED,OAAO,KAAP;MACD,CAtsBwC,CAwsBzC;MACA;MACA;;;MACA,SAASE,SAAT,CAAmBhE,KAAnB,EAA0BC,KAA1B,EAAiC4D,MAAjC,EAAyCqB,KAAzC,EAAgDhB,OAAhD,EAAyDlC,KAAzD,EAAgE;QAC9DhC,KAAK,CAACvC,GAAN,GAAY,IAAZ;QACAuC,KAAK,CAAC5G,IAAN,GAAayK,MAAb;;QAEA,IAAI,CAACc,UAAU,CAAC3E,KAAD,EAAQ6D,MAAR,EAAgB,KAAhB,CAAf,EAAuC;UACrCc,UAAU,CAAC3E,KAAD,EAAQ6D,MAAR,EAAgB,IAAhB,CAAV;QACD;;QAED,IAAIlG,IAAI,GAAGpC,SAAS,CAACpD,IAAV,CAAe6H,KAAK,CAAC5G,IAArB,CAAX;;QAEA,IAAI8L,KAAJ,EAAW;UACTA,KAAK,GAAIlF,KAAK,CAACrB,SAAN,GAAkB,CAAlB,IAAuBqB,KAAK,CAACrB,SAAN,GAAkBsB,KAAlD;QACD;;QAED,IAAIkF,aAAa,GAAGxH,IAAI,KAAK,iBAAT,IAA8BA,IAAI,KAAK,gBAA3D;QAAA,IACIyH,cADJ;QAAA,IAEIC,SAFJ;;QAIA,IAAIF,aAAJ,EAAmB;UACjBC,cAAc,GAAGpF,KAAK,CAACV,UAAN,CAAiBQ,OAAjB,CAAyB+D,MAAzB,CAAjB;UACAwB,SAAS,GAAGD,cAAc,KAAK,CAAC,CAAhC;QACD;;QAED,IAAKpF,KAAK,CAACvC,GAAN,KAAc,IAAd,IAAsBuC,KAAK,CAACvC,GAAN,KAAc,GAArC,IAA6C4H,SAA7C,IAA2DrF,KAAK,CAAC1B,MAAN,KAAiB,CAAjB,IAAsB2B,KAAK,GAAG,CAA7F,EAAiG;UAC/FiE,OAAO,GAAG,KAAV;QACD;;QAED,IAAImB,SAAS,IAAIrF,KAAK,CAACT,cAAN,CAAqB6F,cAArB,CAAjB,EAAuD;UACrDpF,KAAK,CAAC5G,IAAN,GAAa,UAAUgM,cAAvB;QACD,CAFD,MAEO;UACL,IAAID,aAAa,IAAIE,SAAjB,IAA8B,CAACrF,KAAK,CAACT,cAAN,CAAqB6F,cAArB,CAAnC,EAAyE;YACvEpF,KAAK,CAACT,cAAN,CAAqB6F,cAArB,IAAuC,IAAvC;UACD;;UACD,IAAIzH,IAAI,KAAK,iBAAb,EAAgC;YAC9B,IAAIuH,KAAK,IAAKvK,MAAM,CAACC,IAAP,CAAYoF,KAAK,CAAC5G,IAAlB,EAAwBhB,MAAxB,KAAmC,CAAjD,EAAqD;cACnDoM,iBAAiB,CAACxE,KAAD,EAAQC,KAAR,EAAeD,KAAK,CAAC5G,IAArB,EAA2B8K,OAA3B,CAAjB;;cACA,IAAImB,SAAJ,EAAe;gBACbrF,KAAK,CAAC5G,IAAN,GAAa,UAAUgM,cAAV,GAA2BpF,KAAK,CAAC5G,IAA9C;cACD;YACF,CALD,MAKO;cACL+K,gBAAgB,CAACnE,KAAD,EAAQC,KAAR,EAAeD,KAAK,CAAC5G,IAArB,CAAhB;;cACA,IAAIiM,SAAJ,EAAe;gBACbrF,KAAK,CAAC5G,IAAN,GAAa,UAAUgM,cAAV,GAA2B,GAA3B,GAAiCpF,KAAK,CAAC5G,IAApD;cACD;YACF;UACF,CAZD,MAYO,IAAIuE,IAAI,KAAK,gBAAb,EAA+B;YACpC,IAAI2H,UAAU,GAAItF,KAAK,CAACvB,aAAN,IAAwBwB,KAAK,GAAG,CAAjC,GAAuCA,KAAK,GAAG,CAA/C,GAAmDA,KAApE;;YACA,IAAIiF,KAAK,IAAKlF,KAAK,CAAC5G,IAAN,CAAWhB,MAAX,KAAsB,CAApC,EAAwC;cACtC6L,kBAAkB,CAACjE,KAAD,EAAQsF,UAAR,EAAoBtF,KAAK,CAAC5G,IAA1B,EAAgC8K,OAAhC,CAAlB;;cACA,IAAImB,SAAJ,EAAe;gBACbrF,KAAK,CAAC5G,IAAN,GAAa,UAAUgM,cAAV,GAA2BpF,KAAK,CAAC5G,IAA9C;cACD;YACF,CALD,MAKO;cACLwK,iBAAiB,CAAC5D,KAAD,EAAQsF,UAAR,EAAoBtF,KAAK,CAAC5G,IAA1B,CAAjB;;cACA,IAAIiM,SAAJ,EAAe;gBACbrF,KAAK,CAAC5G,IAAN,GAAa,UAAUgM,cAAV,GAA2B,GAA3B,GAAiCpF,KAAK,CAAC5G,IAApD;cACD;YACF;UACF,CAbM,MAaA,IAAIuE,IAAI,KAAK,iBAAb,EAAgC;YACrC,IAAIqC,KAAK,CAACvC,GAAN,KAAc,GAAlB,EAAuB;cACrBsE,WAAW,CAAC/B,KAAD,EAAQA,KAAK,CAAC5G,IAAd,EAAoB6G,KAApB,EAA2B+B,KAA3B,CAAX;YACD;UACF,CAJM,MAIA;YACL,IAAIhC,KAAK,CAACtB,WAAV,EAAuB,OAAO,KAAP;YACvB,MAAM,IAAIpF,aAAJ,CAAkB,4CAA4CqE,IAA9D,CAAN;UACD;;UAED,IAAIqC,KAAK,CAACvC,GAAN,KAAc,IAAd,IAAsBuC,KAAK,CAACvC,GAAN,KAAc,GAAxC,EAA6C;YAC3CuC,KAAK,CAAC5G,IAAN,GAAa,OAAO4G,KAAK,CAACvC,GAAb,GAAmB,IAAnB,GAA0BuC,KAAK,CAAC5G,IAA7C;UACD;QACF;;QAED,OAAO,IAAP;MACD;;MAED,SAASmM,sBAAT,CAAgC1B,MAAhC,EAAwC7D,KAAxC,EAA+C;QAC7C,IAAIwF,OAAO,GAAG,EAAd;QAAA,IACIC,iBAAiB,GAAG,EADxB;QAAA,IAEIjL,KAFJ;QAAA,IAGIpC,MAHJ;QAKAsN,WAAW,CAAC7B,MAAD,EAAS2B,OAAT,EAAkBC,iBAAlB,CAAX;;QAEA,KAAKjL,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAGqN,iBAAiB,CAACrN,MAA3C,EAAmDoC,KAAK,GAAGpC,MAA3D,EAAmEoC,KAAK,IAAI,CAA5E,EAA+E;UAC7EwF,KAAK,CAACV,UAAN,CAAiBqG,IAAjB,CAAsBH,OAAO,CAACC,iBAAiB,CAACjL,KAAD,CAAlB,CAA7B;QACD;;QACDwF,KAAK,CAACT,cAAN,GAAuB,IAAIpF,KAAJ,CAAU/B,MAAV,CAAvB;MACD;;MAED,SAASsN,WAAT,CAAqB7B,MAArB,EAA6B2B,OAA7B,EAAsCC,iBAAtC,EAAyD;QACvD,IAAIrB,aAAJ,EACI5J,KADJ,EAEIpC,MAFJ;;QAIA,IAAIyL,MAAM,KAAK,IAAX,IAAmB,OAAOA,MAAP,KAAkB,QAAzC,EAAmD;UACjDrJ,KAAK,GAAGgL,OAAO,CAAC1F,OAAR,CAAgB+D,MAAhB,CAAR;;UACA,IAAIrJ,KAAK,KAAK,CAAC,CAAf,EAAkB;YAChB,IAAIiL,iBAAiB,CAAC3F,OAAlB,CAA0BtF,KAA1B,MAAqC,CAAC,CAA1C,EAA6C;cAC3CiL,iBAAiB,CAACE,IAAlB,CAAuBnL,KAAvB;YACD;UACF,CAJD,MAIO;YACLgL,OAAO,CAACG,IAAR,CAAa9B,MAAb;;YAEA,IAAI1J,KAAK,CAACC,OAAN,CAAcyJ,MAAd,CAAJ,EAA2B;cACzB,KAAKrJ,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAGyL,MAAM,CAACzL,MAAhC,EAAwCoC,KAAK,GAAGpC,MAAhD,EAAwDoC,KAAK,IAAI,CAAjE,EAAoE;gBAClEkL,WAAW,CAAC7B,MAAM,CAACrJ,KAAD,CAAP,EAAgBgL,OAAhB,EAAyBC,iBAAzB,CAAX;cACD;YACF,CAJD,MAIO;cACLrB,aAAa,GAAGzJ,MAAM,CAACC,IAAP,CAAYiJ,MAAZ,CAAhB;;cAEA,KAAKrJ,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAGgM,aAAa,CAAChM,MAAvC,EAA+CoC,KAAK,GAAGpC,MAAvD,EAA+DoC,KAAK,IAAI,CAAxE,EAA2E;gBACzEkL,WAAW,CAAC7B,MAAM,CAACO,aAAa,CAAC5J,KAAD,CAAd,CAAP,EAA+BgL,OAA/B,EAAwCC,iBAAxC,CAAX;cACD;YACF;UACF;QACF;MACF;;MAED,SAASrM,IAAT,CAAcwM,KAAd,EAAqBvH,OAArB,EAA8B;QAC5BA,OAAO,GAAGA,OAAO,IAAI,EAArB;QAEA,IAAI2B,KAAK,GAAG,IAAI5B,KAAJ,CAAUC,OAAV,CAAZ;QAEA,IAAI,CAAC2B,KAAK,CAACjB,MAAX,EAAmBwG,sBAAsB,CAACK,KAAD,EAAQ5F,KAAR,CAAtB;QAEnB,IAAIgE,SAAS,CAAChE,KAAD,EAAQ,CAAR,EAAW4F,KAAX,EAAkB,IAAlB,EAAwB,IAAxB,CAAb,EAA4C,OAAO5F,KAAK,CAAC5G,IAAN,GAAa,IAApB;QAE5C,OAAO,EAAP;MACD;;MAED,SAASC,QAAT,CAAkBuM,KAAlB,EAAyBvH,OAAzB,EAAkC;QAChC,OAAOjF,IAAI,CAACwM,KAAD,EAAQtK,MAAM,CAACjB,MAAP,CAAc;UAAEkD,MAAM,EAAEzE;QAAV,CAAd,EAA+CuF,OAA/C,CAAR,CAAX;MACD;;MAEDvH,MAAM,CAACD,OAAP,CAAeuC,IAAf,GAA0BA,IAA1B;MACAtC,MAAM,CAACD,OAAP,CAAewC,QAAf,GAA0BA,QAA1B;IAEC,CAp1BO,EAo1BN;MAAC,YAAW,CAAZ;MAAc,eAAc,CAA5B;MAA8B,yBAAwB,CAAtD;MAAwD,yBAAwB;IAAhF,CAp1BM,CAtGy2B;IA07B1xB,GAAE,CAAC,UAASxB,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MAC1H;MACA;MACA;;MAEA,SAASyC,aAAT,CAAuBuM,MAAvB,EAA+BC,IAA/B,EAAqC;QACnC;QACA9N,KAAK,CAACG,IAAN,CAAW,IAAX;QAEA,KAAKK,IAAL,GAAY,eAAZ;QACA,KAAKqN,MAAL,GAAcA,MAAd;QACA,KAAKC,IAAL,GAAYA,IAAZ;QACA,KAAKC,OAAL,GAAe,CAAC,KAAKF,MAAL,IAAe,kBAAhB,KAAuC,KAAKC,IAAL,GAAY,MAAM,KAAKA,IAAL,CAAUrK,QAAV,EAAlB,GAAyC,EAAhF,CAAf,CAPmC,CASnC;;QACA,IAAIzD,KAAK,CAACgO,iBAAV,EAA6B;UAC3B;UACAhO,KAAK,CAACgO,iBAAN,CAAwB,IAAxB,EAA8B,KAAKC,WAAnC;QACD,CAHD,MAGO;UACL;UACA,KAAKC,KAAL,GAAc,IAAIlO,KAAJ,EAAD,CAAckO,KAAd,IAAuB,EAApC;QACD;MACF,CAtByH,CAyB1H;;;MACA5M,aAAa,CAACkC,SAAd,GAA0Bb,MAAM,CAACwL,MAAP,CAAcnO,KAAK,CAACwD,SAApB,CAA1B;MACAlC,aAAa,CAACkC,SAAd,CAAwByK,WAAxB,GAAsC3M,aAAtC;;MAGAA,aAAa,CAACkC,SAAd,CAAwBC,QAAxB,GAAmC,SAASA,QAAT,CAAkByI,OAAlB,EAA2B;QAC5D,IAAIlJ,MAAM,GAAG,KAAKxC,IAAL,GAAY,IAAzB;QAEAwC,MAAM,IAAI,KAAK6K,MAAL,IAAe,kBAAzB;;QAEA,IAAI,CAAC3B,OAAD,IAAY,KAAK4B,IAArB,EAA2B;UACzB9K,MAAM,IAAI,MAAM,KAAK8K,IAAL,CAAUrK,QAAV,EAAhB;QACD;;QAED,OAAOT,MAAP;MACD,CAVD;;MAaAlE,MAAM,CAACD,OAAP,GAAiByC,aAAjB;IAEC,CA7CwF,EA6CvF,EA7CuF,CA17BwxB;IAu+B32B,GAAE,CAAC,UAASzB,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACzC;MAEA;;MAEA,IAAIyE,MAAM,GAAgBzD,OAAO,CAAC,UAAD,CAAjC;;MACA,IAAIyB,aAAa,GAASzB,OAAO,CAAC,aAAD,CAAjC;;MACA,IAAIuO,IAAI,GAAkBvO,OAAO,CAAC,QAAD,CAAjC;;MACA,IAAIiB,mBAAmB,GAAGjB,OAAO,CAAC,uBAAD,CAAjC;;MACA,IAAIkB,mBAAmB,GAAGlB,OAAO,CAAC,uBAAD,CAAjC;;MAGA,IAAI6D,eAAe,GAAGf,MAAM,CAACa,SAAP,CAAiBG,cAAvC;MAGA,IAAI0K,eAAe,GAAK,CAAxB;MACA,IAAIC,gBAAgB,GAAI,CAAxB;MACA,IAAIC,gBAAgB,GAAI,CAAxB;MACA,IAAIC,iBAAiB,GAAG,CAAxB;MAGA,IAAIC,aAAa,GAAI,CAArB;MACA,IAAIC,cAAc,GAAG,CAArB;MACA,IAAIC,aAAa,GAAI,CAArB;MAGA,IAAIC,qBAAqB,GAAW,qIAApC;MACA,IAAIC,6BAA6B,GAAG,oBAApC;MACA,IAAIC,uBAAuB,GAAS,aAApC;MACA,IAAIC,kBAAkB,GAAc,wBAApC;MACA,IAAIC,eAAe,GAAiB,kFAApC;;MAGA,SAASC,MAAT,CAAgBC,GAAhB,EAAqB;QAAE,OAAOvM,MAAM,CAACa,SAAP,CAAiBC,QAAjB,CAA0BtD,IAA1B,CAA+B+O,GAA/B,CAAP;MAA6C;;MAEpE,SAASC,MAAT,CAAgBvP,CAAhB,EAAmB;QACjB,OAAQA,CAAC,KAAK;QAAI;QAAX,GAAyBA,CAAC,KAAK;QAAI;QAA1C;MACD;;MAED,SAASwP,cAAT,CAAwBxP,CAAxB,EAA2B;QACzB,OAAQA,CAAC,KAAK;QAAI;QAAX,GAA0BA,CAAC,KAAK;QAAI;QAA3C;MACD;;MAED,SAASyP,YAAT,CAAsBzP,CAAtB,EAAyB;QACvB,OAAQA,CAAC,KAAK;QAAI;QAAX,GACCA,CAAC,KAAK;QAAI;QADX,GAECA,CAAC,KAAK;QAAI;QAFX,GAGCA,CAAC,KAAK;QAAI;QAHlB;MAID;;MAED,SAAS0P,iBAAT,CAA2B1P,CAA3B,EAA8B;QAC5B,OAAOA,CAAC,KAAK;QAAI;QAAV,GACAA,CAAC,KAAK;QAAI;QADV,GAEAA,CAAC,KAAK;QAAI;QAFV,GAGAA,CAAC,KAAK;QAAI;QAHV,GAIAA,CAAC,KAAK;QAAI;QAJjB;MAKD;;MAED,SAAS2P,WAAT,CAAqB3P,CAArB,EAAwB;QACtB,IAAI4P,EAAJ;;QAEA,IAAK;QAAI;QAAJ,GAAe5P,CAAhB,IAAuBA,CAAC,IAAI;QAAI;QAApC,EAA8C;UAC5C,OAAOA,CAAC,GAAG,IAAX;QACD;QAED;;;QACA4P,EAAE,GAAG5P,CAAC,GAAG,IAAT;;QAEA,IAAK;QAAI;QAAJ,GAAe4P,EAAhB,IAAwBA,EAAE,IAAI;QAAI;QAAtC,EAAgD;UAC9C,OAAOA,EAAE,GAAG,IAAL,GAAY,EAAnB;QACD;;QAED,OAAO,CAAC,CAAR;MACD;;MAED,SAASC,aAAT,CAAuB7P,CAAvB,EAA0B;QACxB,IAAIA,CAAC,KAAK;QAAI;QAAd,EAAuB;UAAE,OAAO,CAAP;QAAW;;QACpC,IAAIA,CAAC,KAAK;QAAI;QAAd,EAAuB;UAAE,OAAO,CAAP;QAAW;;QACpC,IAAIA,CAAC,KAAK;QAAI;QAAd,EAAuB;UAAE,OAAO,CAAP;QAAW;;QACpC,OAAO,CAAP;MACD;;MAED,SAAS8P,eAAT,CAAyB9P,CAAzB,EAA4B;QAC1B,IAAK;QAAI;QAAJ,GAAeA,CAAhB,IAAuBA,CAAC,IAAI;QAAI;QAApC,EAA8C;UAC5C,OAAOA,CAAC,GAAG,IAAX;QACD;;QAED,OAAO,CAAC,CAAR;MACD;;MAED,SAAS+P,oBAAT,CAA8B/P,CAA9B,EAAiC;QAC/B;QACA,OAAQA,CAAC,KAAK;QAAI;QAAX,EAAsB,MAAtB,GACAA,CAAC,KAAK;QAAI;QAAX,EAAsB,MAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,MAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,MAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAwB,MAAxB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,MAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,MAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,MAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,MAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,MAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAA0B,GAA1B,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,MAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,GAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,MAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,MAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,MAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,QAAtB,GACCA,CAAC,KAAK;QAAI;QAAX,EAAsB,QAAtB,GAAiC,EAjBvC;MAkBD;;MAED,SAASgQ,iBAAT,CAA2BhQ,CAA3B,EAA8B;QAC5B,IAAIA,CAAC,IAAI,MAAT,EAAiB;UACf,OAAOgG,MAAM,CAACiK,YAAP,CAAoBjQ,CAApB,CAAP;QACD,CAH2B,CAI5B;QACA;;;QACA,OAAOgG,MAAM,CAACiK,YAAP,CACL,CAAEjQ,CAAC,GAAG,QAAL,IAAkB,EAAnB,IAAyB,MADpB,EAEL,CAAEA,CAAC,GAAG,QAAL,GAAiB,MAAlB,IAA4B,MAFvB,CAAP;MAID;;MAED,IAAIkQ,iBAAiB,GAAG,IAAI3N,KAAJ,CAAU,GAAV,CAAxB,CA5HyC,CA4HD;;MACxC,IAAI4N,eAAe,GAAG,IAAI5N,KAAJ,CAAU,GAAV,CAAtB;;MACA,KAAK,IAAIxC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,GAApB,EAAyBA,CAAC,EAA1B,EAA8B;QAC5BmQ,iBAAiB,CAACnQ,CAAD,CAAjB,GAAuBgQ,oBAAoB,CAAChQ,CAAD,CAApB,GAA0B,CAA1B,GAA8B,CAArD;QACAoQ,eAAe,CAACpQ,CAAD,CAAf,GAAqBgQ,oBAAoB,CAAChQ,CAAD,CAAzC;MACD;;MAGD,SAASyG,KAAT,CAAewH,KAAf,EAAsBvH,OAAtB,EAA+B;QAC7B,KAAKuH,KAAL,GAAaA,KAAb;QAEA,KAAKoC,QAAL,GAAiB3J,OAAO,CAAC,UAAD,CAAP,IAAwB,IAAzC;QACA,KAAKd,MAAL,GAAiBc,OAAO,CAAC,QAAD,CAAP,IAAwBtF,mBAAzC;QACA,KAAKkP,SAAL,GAAiB5J,OAAO,CAAC,WAAD,CAAP,IAAwB,IAAzC;QACA,KAAK6J,MAAL,GAAiB7J,OAAO,CAAC,QAAD,CAAP,IAAwB,KAAzC;QACA,KAAK8J,IAAL,GAAiB9J,OAAO,CAAC,MAAD,CAAP,IAAwB,KAAzC;QACA,KAAK+J,QAAL,GAAiB/J,OAAO,CAAC,UAAD,CAAP,IAAwB,IAAzC;QAEA,KAAKa,aAAL,GAAqB,KAAK3B,MAAL,CAAY4B,gBAAjC;QACA,KAAKkJ,OAAL,GAAqB,KAAK9K,MAAL,CAAYO,eAAjC;QAEA,KAAK1F,MAAL,GAAkBwN,KAAK,CAACxN,MAAxB;QACA,KAAKuH,QAAL,GAAkB,CAAlB;QACA,KAAKE,IAAL,GAAkB,CAAlB;QACA,KAAKyI,SAAL,GAAkB,CAAlB;QACA,KAAKC,UAAL,GAAkB,CAAlB;QAEA,KAAKC,SAAL,GAAiB,EAAjB;QAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MAEC;;MAGD,SAASC,aAAT,CAAuBzI,KAAvB,EAA8B+F,OAA9B,EAAuC;QACrC,OAAO,IAAIzM,aAAJ,CACLyM,OADK,EAEL,IAAIK,IAAJ,CAASpG,KAAK,CAACgI,QAAf,EAAyBhI,KAAK,CAAC4F,KAA/B,EAAsC5F,KAAK,CAACL,QAA5C,EAAsDK,KAAK,CAACH,IAA5D,EAAmEG,KAAK,CAACL,QAAN,GAAiBK,KAAK,CAACsI,SAA1F,CAFK,CAAP;MAGD;;MAED,SAASI,UAAT,CAAoB1I,KAApB,EAA2B+F,OAA3B,EAAoC;QAClC,MAAM0C,aAAa,CAACzI,KAAD,EAAQ+F,OAAR,CAAnB;MACD;;MAED,SAAS4C,YAAT,CAAsB3I,KAAtB,EAA6B+F,OAA7B,EAAsC;QACpC,IAAI/F,KAAK,CAACiI,SAAV,EAAqB;UACnBjI,KAAK,CAACiI,SAAN,CAAgB9P,IAAhB,CAAqB,IAArB,EAA2BsQ,aAAa,CAACzI,KAAD,EAAQ+F,OAAR,CAAxC;QACD;MACF;;MAGD,IAAI6C,iBAAiB,GAAG;QAEtBC,IAAI,EAAE,SAASC,mBAAT,CAA6B9I,KAA7B,EAAoCxH,IAApC,EAA0CuQ,IAA1C,EAAgD;UAEpD,IAAI5F,KAAJ,EAAW6F,KAAX,EAAkBC,KAAlB;;UAEA,IAAIjJ,KAAK,CAACkJ,OAAN,KAAkB,IAAtB,EAA4B;YAC1BR,UAAU,CAAC1I,KAAD,EAAQ,gCAAR,CAAV;UACD;;UAED,IAAI+I,IAAI,CAAC3Q,MAAL,KAAgB,CAApB,EAAuB;YACrBsQ,UAAU,CAAC1I,KAAD,EAAQ,6CAAR,CAAV;UACD;;UAEDmD,KAAK,GAAG,uBAAuBC,IAAvB,CAA4B2F,IAAI,CAAC,CAAD,CAAhC,CAAR;;UAEA,IAAI5F,KAAK,KAAK,IAAd,EAAoB;YAClBuF,UAAU,CAAC1I,KAAD,EAAQ,2CAAR,CAAV;UACD;;UAEDgJ,KAAK,GAAGG,QAAQ,CAAChG,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAhB;UACA8F,KAAK,GAAGE,QAAQ,CAAChG,KAAK,CAAC,CAAD,CAAN,EAAW,EAAX,CAAhB;;UAEA,IAAI6F,KAAK,KAAK,CAAd,EAAiB;YACfN,UAAU,CAAC1I,KAAD,EAAQ,2CAAR,CAAV;UACD;;UAEDA,KAAK,CAACkJ,OAAN,GAAgBH,IAAI,CAAC,CAAD,CAApB;UACA/I,KAAK,CAACoJ,eAAN,GAAyBH,KAAK,GAAG,CAAjC;;UAEA,IAAIA,KAAK,KAAK,CAAV,IAAeA,KAAK,KAAK,CAA7B,EAAgC;YAC9BN,YAAY,CAAC3I,KAAD,EAAQ,0CAAR,CAAZ;UACD;QACF,CAjCqB;QAmCtBqJ,GAAG,EAAE,SAASC,kBAAT,CAA4BtJ,KAA5B,EAAmCxH,IAAnC,EAAyCuQ,IAAzC,EAA+C;UAElD,IAAI7K,MAAJ,EAAYmF,MAAZ;;UAEA,IAAI0F,IAAI,CAAC3Q,MAAL,KAAgB,CAApB,EAAuB;YACrBsQ,UAAU,CAAC1I,KAAD,EAAQ,6CAAR,CAAV;UACD;;UAED9B,MAAM,GAAG6K,IAAI,CAAC,CAAD,CAAb;UACA1F,MAAM,GAAG0F,IAAI,CAAC,CAAD,CAAb;;UAEA,IAAI,CAAChC,kBAAkB,CAAClG,IAAnB,CAAwB3C,MAAxB,CAAL,EAAsC;YACpCwK,UAAU,CAAC1I,KAAD,EAAQ,6DAAR,CAAV;UACD;;UAED,IAAItE,eAAe,CAACvD,IAAhB,CAAqB6H,KAAK,CAACuJ,MAA3B,EAAmCrL,MAAnC,CAAJ,EAAgD;YAC9CwK,UAAU,CAAC1I,KAAD,EAAQ,gDAAgD9B,MAAhD,GAAyD,cAAjE,CAAV;UACD;;UAED,IAAI,CAAC8I,eAAe,CAACnG,IAAhB,CAAqBwC,MAArB,CAAL,EAAmC;YACjCqF,UAAU,CAAC1I,KAAD,EAAQ,8DAAR,CAAV;UACD;;UAEDA,KAAK,CAACuJ,MAAN,CAAarL,MAAb,IAAuBmF,MAAvB;QACD;MA3DqB,CAAxB;;MA+DA,SAASmG,cAAT,CAAwBxJ,KAAxB,EAA+BuD,KAA/B,EAAsCC,GAAtC,EAA2CiG,SAA3C,EAAsD;QACpD,IAAIC,SAAJ,EAAeC,OAAf,EAAwBC,UAAxB,EAAoC9F,OAApC;;QAEA,IAAIP,KAAK,GAAGC,GAAZ,EAAiB;UACfM,OAAO,GAAG9D,KAAK,CAAC4F,KAAN,CAAY/H,KAAZ,CAAkB0F,KAAlB,EAAyBC,GAAzB,CAAV;;UAEA,IAAIiG,SAAJ,EAAe;YACb,KAAKC,SAAS,GAAG,CAAZ,EAAeC,OAAO,GAAG7F,OAAO,CAAC1L,MAAtC,EAA8CsR,SAAS,GAAGC,OAA1D,EAAmED,SAAS,IAAI,CAAhF,EAAmF;cACjFE,UAAU,GAAG9F,OAAO,CAAChC,UAAR,CAAmB4H,SAAnB,CAAb;;cACA,IAAI,EAAEE,UAAU,KAAK,IAAf,IACC,QAAQA,UAAR,IAAsBA,UAAU,IAAI,QADvC,CAAJ,EACuD;gBACrDlB,UAAU,CAAC1I,KAAD,EAAQ,+BAAR,CAAV;cACD;YACF;UACF,CARD,MAQO,IAAI4G,qBAAqB,CAAC/F,IAAtB,CAA2BiD,OAA3B,CAAJ,EAAyC;YAC9C4E,UAAU,CAAC1I,KAAD,EAAQ,8CAAR,CAAV;UACD;;UAEDA,KAAK,CAAChF,MAAN,IAAgB8I,OAAhB;QACD;MACF;;MAED,SAAS+F,aAAT,CAAuB7J,KAAvB,EAA8B8J,WAA9B,EAA2CvP,MAA3C,EAAmDwP,eAAnD,EAAoE;QAClE,IAAIrP,UAAJ,EAAgBD,GAAhB,EAAqBD,KAArB,EAA4BwP,QAA5B;;QAEA,IAAI,CAAC1O,MAAM,CAACtB,QAAP,CAAgBO,MAAhB,CAAL,EAA8B;UAC5BmO,UAAU,CAAC1I,KAAD,EAAQ,mEAAR,CAAV;QACD;;QAEDtF,UAAU,GAAGC,MAAM,CAACC,IAAP,CAAYL,MAAZ,CAAb;;QAEA,KAAKC,KAAK,GAAG,CAAR,EAAWwP,QAAQ,GAAGtP,UAAU,CAACtC,MAAtC,EAA8CoC,KAAK,GAAGwP,QAAtD,EAAgExP,KAAK,IAAI,CAAzE,EAA4E;UAC1EC,GAAG,GAAGC,UAAU,CAACF,KAAD,CAAhB;;UAEA,IAAI,CAACkB,eAAe,CAACvD,IAAhB,CAAqB2R,WAArB,EAAkCrP,GAAlC,CAAL,EAA6C;YAC3CqP,WAAW,CAACrP,GAAD,CAAX,GAAmBF,MAAM,CAACE,GAAD,CAAzB;YACAsP,eAAe,CAACtP,GAAD,CAAf,GAAuB,IAAvB;UACD;QACF;MACF;;MAED,SAASwP,gBAAT,CAA0BjK,KAA1B,EAAiC8D,OAAjC,EAA0CiG,eAA1C,EAA2DG,MAA3D,EAAmEC,OAAnE,EAA4EC,SAA5E,EAAuFC,SAAvF,EAAkGC,QAAlG,EAA4G;QAC1G,IAAI9P,KAAJ,EAAWwP,QAAX,CAD0G,CAG1G;QACA;QACA;;QACA,IAAI7P,KAAK,CAACC,OAAN,CAAc+P,OAAd,CAAJ,EAA4B;UAC1BA,OAAO,GAAGhQ,KAAK,CAACqB,SAAN,CAAgBqC,KAAhB,CAAsB1F,IAAtB,CAA2BgS,OAA3B,CAAV;;UAEA,KAAK3P,KAAK,GAAG,CAAR,EAAWwP,QAAQ,GAAGG,OAAO,CAAC/R,MAAnC,EAA2CoC,KAAK,GAAGwP,QAAnD,EAA6DxP,KAAK,IAAI,CAAtE,EAAyE;YACvE,IAAIL,KAAK,CAACC,OAAN,CAAc+P,OAAO,CAAC3P,KAAD,CAArB,CAAJ,EAAmC;cACjCkO,UAAU,CAAC1I,KAAD,EAAQ,6CAAR,CAAV;YACD;;YAED,IAAI,OAAOmK,OAAP,KAAmB,QAAnB,IAA+BlD,MAAM,CAACkD,OAAO,CAAC3P,KAAD,CAAR,CAAN,KAA2B,iBAA9D,EAAiF;cAC/E2P,OAAO,CAAC3P,KAAD,CAAP,GAAiB,iBAAjB;YACD;UACF;QACF,CAlByG,CAoB1G;QACA;QACA;;;QACA,IAAI,OAAO2P,OAAP,KAAmB,QAAnB,IAA+BlD,MAAM,CAACkD,OAAD,CAAN,KAAoB,iBAAvD,EAA0E;UACxEA,OAAO,GAAG,iBAAV;QACD;;QAGDA,OAAO,GAAGvM,MAAM,CAACuM,OAAD,CAAhB;;QAEA,IAAIrG,OAAO,KAAK,IAAhB,EAAsB;UACpBA,OAAO,GAAG,EAAV;QACD;;QAED,IAAIoG,MAAM,KAAK,yBAAf,EAA0C;UACxC,IAAI/P,KAAK,CAACC,OAAN,CAAcgQ,SAAd,CAAJ,EAA8B;YAC5B,KAAK5P,KAAK,GAAG,CAAR,EAAWwP,QAAQ,GAAGI,SAAS,CAAChS,MAArC,EAA6CoC,KAAK,GAAGwP,QAArD,EAA+DxP,KAAK,IAAI,CAAxE,EAA2E;cACzEqP,aAAa,CAAC7J,KAAD,EAAQ8D,OAAR,EAAiBsG,SAAS,CAAC5P,KAAD,CAA1B,EAAmCuP,eAAnC,CAAb;YACD;UACF,CAJD,MAIO;YACLF,aAAa,CAAC7J,KAAD,EAAQ8D,OAAR,EAAiBsG,SAAjB,EAA4BL,eAA5B,CAAb;UACD;QACF,CARD,MAQO;UACL,IAAI,CAAC/J,KAAK,CAACmI,IAAP,IACA,CAACzM,eAAe,CAACvD,IAAhB,CAAqB4R,eAArB,EAAsCI,OAAtC,CADD,IAEAzO,eAAe,CAACvD,IAAhB,CAAqB2L,OAArB,EAA8BqG,OAA9B,CAFJ,EAE4C;YAC1CnK,KAAK,CAACH,IAAN,GAAawK,SAAS,IAAIrK,KAAK,CAACH,IAAhC;YACAG,KAAK,CAACL,QAAN,GAAiB2K,QAAQ,IAAItK,KAAK,CAACL,QAAnC;YACA+I,UAAU,CAAC1I,KAAD,EAAQ,wBAAR,CAAV;UACD;;UACD8D,OAAO,CAACqG,OAAD,CAAP,GAAmBC,SAAnB;UACA,OAAOL,eAAe,CAACI,OAAD,CAAtB;QACD;;QAED,OAAOrG,OAAP;MACD;;MAED,SAASyG,aAAT,CAAuBvK,KAAvB,EAA8B;QAC5B,IAAIwK,EAAJ;QAEAA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;QAEA,IAAI6K,EAAE,KAAK;QAAI;QAAf,EAAyB;UACvBxK,KAAK,CAACL,QAAN;QACD,CAFD,MAEO,IAAI6K,EAAE,KAAK;QAAI;QAAf,EAAyB;UAC9BxK,KAAK,CAACL,QAAN;;UACA,IAAIK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,MAA2C;UAAI;UAAnD,EAA6D;YAC3DK,KAAK,CAACL,QAAN;UACD;QACF,CALM,MAKA;UACL+I,UAAU,CAAC1I,KAAD,EAAQ,0BAAR,CAAV;QACD;;QAEDA,KAAK,CAACH,IAAN,IAAc,CAAd;QACAG,KAAK,CAACsI,SAAN,GAAkBtI,KAAK,CAACL,QAAxB;MACD;;MAED,SAAS8K,mBAAT,CAA6BzK,KAA7B,EAAoC0K,aAApC,EAAmDC,WAAnD,EAAgE;QAC9D,IAAIC,UAAU,GAAG,CAAjB;QAAA,IACIJ,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CADT;;QAGA,OAAO6K,EAAE,KAAK,CAAd,EAAiB;UACf,OAAOpD,cAAc,CAACoD,EAAD,CAArB,EAA2B;YACzBA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;UACD;;UAED,IAAI+K,aAAa,IAAIF,EAAE,KAAK;UAAI;UAAhC,EAAyC;YACvC,GAAG;cACDA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;YACD,CAFD,QAES6K,EAAE,KAAK;YAAI;YAAX,GAAuBA,EAAE,KAAK;YAAI;YAAlC,GAA8CA,EAAE,KAAK,CAF9D;UAGD;;UAED,IAAIrD,MAAM,CAACqD,EAAD,CAAV,EAAgB;YACdD,aAAa,CAACvK,KAAD,CAAb;YAEAwK,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;YACAiL,UAAU;YACV5K,KAAK,CAACuI,UAAN,GAAmB,CAAnB;;YAEA,OAAOiC,EAAE,KAAK;YAAI;YAAlB,EAA+B;cAC7BxK,KAAK,CAACuI,UAAN;cACAiC,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;YACD;UACF,CAXD,MAWO;YACL;UACD;QACF;;QAED,IAAIgL,WAAW,KAAK,CAAC,CAAjB,IAAsBC,UAAU,KAAK,CAArC,IAA0C5K,KAAK,CAACuI,UAAN,GAAmBoC,WAAjE,EAA8E;UAC5EhC,YAAY,CAAC3I,KAAD,EAAQ,uBAAR,CAAZ;QACD;;QAED,OAAO4K,UAAP;MACD;;MAED,SAASC,qBAAT,CAA+B7K,KAA/B,EAAsC;QACpC,IAAI0J,SAAS,GAAG1J,KAAK,CAACL,QAAtB;QAAA,IACI6K,EADJ;QAGAA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB4H,SAAvB,CAAL,CAJoC,CAMpC;QACA;;QACA,IAAI,CAACc,EAAE,KAAK;QAAI;QAAX,GAAsBA,EAAE,KAAK;QAAI;QAAlC,KACAA,EAAE,KAAKxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB4H,SAAS,GAAG,CAAnC,CADP,IAEAc,EAAE,KAAKxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB4H,SAAS,GAAG,CAAnC,CAFX,EAEkD;UAEhDA,SAAS,IAAI,CAAb;UAEAc,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB4H,SAAvB,CAAL;;UAEA,IAAIc,EAAE,KAAK,CAAP,IAAYnD,YAAY,CAACmD,EAAD,CAA5B,EAAkC;YAChC,OAAO,IAAP;UACD;QACF;;QAED,OAAO,KAAP;MACD;;MAED,SAASM,gBAAT,CAA0B9K,KAA1B,EAAiCjF,KAAjC,EAAwC;QACtC,IAAIA,KAAK,KAAK,CAAd,EAAiB;UACfiF,KAAK,CAAChF,MAAN,IAAgB,GAAhB;QACD,CAFD,MAEO,IAAID,KAAK,GAAG,CAAZ,EAAe;UACpBiF,KAAK,CAAChF,MAAN,IAAgBM,MAAM,CAACT,MAAP,CAAc,IAAd,EAAoBE,KAAK,GAAG,CAA5B,CAAhB;QACD;MACF;;MAGD,SAASgQ,eAAT,CAAyB/K,KAAzB,EAAgCgL,UAAhC,EAA4CC,oBAA5C,EAAkE;QAChE,IAAIC,SAAJ;QAAA,IACIC,SADJ;QAAA,IAEIC,YAFJ;QAAA,IAGIC,UAHJ;QAAA,IAIIC,iBAJJ;QAAA,IAKIC,KALJ;QAAA,IAMIC,UANJ;QAAA,IAOIC,WAPJ;QAAA,IAQIC,KAAK,GAAG1L,KAAK,CAAC2L,IARlB;QAAA,IASI7H,OAAO,GAAG9D,KAAK,CAAChF,MATpB;QAAA,IAUIwP,EAVJ;;QAYAA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;QAEA,IAAI0H,YAAY,CAACmD,EAAD,CAAZ,IACAlD,iBAAiB,CAACkD,EAAD,CADjB,IAEAA,EAAE,KAAK;QAAI;QAFX,GAGAA,EAAE,KAAK;QAAI;QAHX,GAIAA,EAAE,KAAK;QAAI;QAJX,GAKAA,EAAE,KAAK;QAAI;QALX,GAMAA,EAAE,KAAK;QAAI;QANX,GAOAA,EAAE,KAAK;QAAI;QAPX,GAQAA,EAAE,KAAK;QAAI;QARX,GASAA,EAAE,KAAK;QAAI;QATX,GAUAA,EAAE,KAAK;QAAI;QAVX,GAWAA,EAAE,KAAK;QAAI;QAXX,GAYAA,EAAE,KAAK;QAAI;QAZf,EAYwB;UACtB,OAAO,KAAP;QACD;;QAED,IAAIA,EAAE,KAAK;QAAI;QAAX,GAAsBA,EAAE,KAAK;QAAI;QAArC,EAA8C;UAC5CW,SAAS,GAAGnL,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAAN,GAAiB,CAAxC,CAAZ;;UAEA,IAAI0H,YAAY,CAAC8D,SAAD,CAAZ,IACAF,oBAAoB,IAAI3D,iBAAiB,CAAC6D,SAAD,CAD7C,EAC0D;YACxD,OAAO,KAAP;UACD;QACF;;QAEDnL,KAAK,CAAC2L,IAAN,GAAa,QAAb;QACA3L,KAAK,CAAChF,MAAN,GAAe,EAAf;QACAoQ,YAAY,GAAGC,UAAU,GAAGrL,KAAK,CAACL,QAAlC;QACA2L,iBAAiB,GAAG,KAApB;;QAEA,OAAOd,EAAE,KAAK,CAAd,EAAiB;UACf,IAAIA,EAAE,KAAK;UAAI;UAAf,EAAwB;YACtBW,SAAS,GAAGnL,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAAN,GAAiB,CAAxC,CAAZ;;YAEA,IAAI0H,YAAY,CAAC8D,SAAD,CAAZ,IACAF,oBAAoB,IAAI3D,iBAAiB,CAAC6D,SAAD,CAD7C,EAC0D;cACxD;YACD;UAEF,CARD,MAQO,IAAIX,EAAE,KAAK;UAAI;UAAf,EAAwB;YAC7BU,SAAS,GAAGlL,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAAN,GAAiB,CAAxC,CAAZ;;YAEA,IAAI0H,YAAY,CAAC6D,SAAD,CAAhB,EAA6B;cAC3B;YACD;UAEF,CAPM,MAOA,IAAKlL,KAAK,CAACL,QAAN,KAAmBK,KAAK,CAACsI,SAAzB,IAAsCuC,qBAAqB,CAAC7K,KAAD,CAA5D,IACAiL,oBAAoB,IAAI3D,iBAAiB,CAACkD,EAAD,CAD7C,EACmD;YACxD;UAED,CAJM,MAIA,IAAIrD,MAAM,CAACqD,EAAD,CAAV,EAAgB;YACrBe,KAAK,GAAGvL,KAAK,CAACH,IAAd;YACA2L,UAAU,GAAGxL,KAAK,CAACsI,SAAnB;YACAmD,WAAW,GAAGzL,KAAK,CAACuI,UAApB;YACAkC,mBAAmB,CAACzK,KAAD,EAAQ,KAAR,EAAe,CAAC,CAAhB,CAAnB;;YAEA,IAAIA,KAAK,CAACuI,UAAN,IAAoByC,UAAxB,EAAoC;cAClCM,iBAAiB,GAAG,IAApB;cACAd,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;cACA;YACD,CAJD,MAIO;cACLK,KAAK,CAACL,QAAN,GAAiB0L,UAAjB;cACArL,KAAK,CAACH,IAAN,GAAa0L,KAAb;cACAvL,KAAK,CAACsI,SAAN,GAAkBkD,UAAlB;cACAxL,KAAK,CAACuI,UAAN,GAAmBkD,WAAnB;cACA;YACD;UACF;;UAED,IAAIH,iBAAJ,EAAuB;YACrB9B,cAAc,CAACxJ,KAAD,EAAQoL,YAAR,EAAsBC,UAAtB,EAAkC,KAAlC,CAAd;YACAP,gBAAgB,CAAC9K,KAAD,EAAQA,KAAK,CAACH,IAAN,GAAa0L,KAArB,CAAhB;YACAH,YAAY,GAAGC,UAAU,GAAGrL,KAAK,CAACL,QAAlC;YACA2L,iBAAiB,GAAG,KAApB;UACD;;UAED,IAAI,CAAClE,cAAc,CAACoD,EAAD,CAAnB,EAAyB;YACvBa,UAAU,GAAGrL,KAAK,CAACL,QAAN,GAAiB,CAA9B;UACD;;UAED6K,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;QACD;;QAED6J,cAAc,CAACxJ,KAAD,EAAQoL,YAAR,EAAsBC,UAAtB,EAAkC,KAAlC,CAAd;;QAEA,IAAIrL,KAAK,CAAChF,MAAV,EAAkB;UAChB,OAAO,IAAP;QACD;;QAEDgF,KAAK,CAAC2L,IAAN,GAAaD,KAAb;QACA1L,KAAK,CAAChF,MAAN,GAAe8I,OAAf;QACA,OAAO,KAAP;MACD;;MAED,SAAS8H,sBAAT,CAAgC5L,KAAhC,EAAuCgL,UAAvC,EAAmD;QACjD,IAAIR,EAAJ,EACIY,YADJ,EACkBC,UADlB;QAGAb,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;QAEA,IAAI6K,EAAE,KAAK;QAAI;QAAf,EAAwB;UACtB,OAAO,KAAP;QACD;;QAEDxK,KAAK,CAAC2L,IAAN,GAAa,QAAb;QACA3L,KAAK,CAAChF,MAAN,GAAe,EAAf;QACAgF,KAAK,CAACL,QAAN;QACAyL,YAAY,GAAGC,UAAU,GAAGrL,KAAK,CAACL,QAAlC;;QAEA,OAAO,CAAC6K,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAN,MAAkD,CAAzD,EAA4D;UAC1D,IAAI6K,EAAE,KAAK;UAAI;UAAf,EAAwB;YACtBhB,cAAc,CAACxJ,KAAD,EAAQoL,YAAR,EAAsBpL,KAAK,CAACL,QAA5B,EAAsC,IAAtC,CAAd;YACA6K,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;;YAEA,IAAI6K,EAAE,KAAK;YAAI;YAAf,EAAwB;cACtBY,YAAY,GAAGpL,KAAK,CAACL,QAArB;cACAK,KAAK,CAACL,QAAN;cACA0L,UAAU,GAAGrL,KAAK,CAACL,QAAnB;YACD,CAJD,MAIO;cACL,OAAO,IAAP;YACD;UAEF,CAZD,MAYO,IAAIwH,MAAM,CAACqD,EAAD,CAAV,EAAgB;YACrBhB,cAAc,CAACxJ,KAAD,EAAQoL,YAAR,EAAsBC,UAAtB,EAAkC,IAAlC,CAAd;YACAP,gBAAgB,CAAC9K,KAAD,EAAQyK,mBAAmB,CAACzK,KAAD,EAAQ,KAAR,EAAegL,UAAf,CAA3B,CAAhB;YACAI,YAAY,GAAGC,UAAU,GAAGrL,KAAK,CAACL,QAAlC;UAED,CALM,MAKA,IAAIK,KAAK,CAACL,QAAN,KAAmBK,KAAK,CAACsI,SAAzB,IAAsCuC,qBAAqB,CAAC7K,KAAD,CAA/D,EAAwE;YAC7E0I,UAAU,CAAC1I,KAAD,EAAQ,8DAAR,CAAV;UAED,CAHM,MAGA;YACLA,KAAK,CAACL,QAAN;YACA0L,UAAU,GAAGrL,KAAK,CAACL,QAAnB;UACD;QACF;;QAED+I,UAAU,CAAC1I,KAAD,EAAQ,4DAAR,CAAV;MACD;;MAED,SAAS6L,sBAAT,CAAgC7L,KAAhC,EAAuCgL,UAAvC,EAAmD;QACjD,IAAII,YAAJ,EACIC,UADJ,EAEIS,SAFJ,EAGIC,SAHJ,EAIIC,GAJJ,EAKIxB,EALJ;QAOAA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;QAEA,IAAI6K,EAAE,KAAK;QAAI;QAAf,EAAwB;UACtB,OAAO,KAAP;QACD;;QAEDxK,KAAK,CAAC2L,IAAN,GAAa,QAAb;QACA3L,KAAK,CAAChF,MAAN,GAAe,EAAf;QACAgF,KAAK,CAACL,QAAN;QACAyL,YAAY,GAAGC,UAAU,GAAGrL,KAAK,CAACL,QAAlC;;QAEA,OAAO,CAAC6K,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAN,MAAkD,CAAzD,EAA4D;UAC1D,IAAI6K,EAAE,KAAK;UAAI;UAAf,EAAwB;YACtBhB,cAAc,CAACxJ,KAAD,EAAQoL,YAAR,EAAsBpL,KAAK,CAACL,QAA5B,EAAsC,IAAtC,CAAd;YACAK,KAAK,CAACL,QAAN;YACA,OAAO,IAAP;UAED,CALD,MAKO,IAAI6K,EAAE,KAAK;UAAI;UAAf,EAAwB;YAC7BhB,cAAc,CAACxJ,KAAD,EAAQoL,YAAR,EAAsBpL,KAAK,CAACL,QAA5B,EAAsC,IAAtC,CAAd;YACA6K,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;;YAEA,IAAIwH,MAAM,CAACqD,EAAD,CAAV,EAAgB;cACdC,mBAAmB,CAACzK,KAAD,EAAQ,KAAR,EAAegL,UAAf,CAAnB,CADc,CAGd;YACD,CAJD,MAIO,IAAIR,EAAE,GAAG,GAAL,IAAY1C,iBAAiB,CAAC0C,EAAD,CAAjC,EAAuC;cAC5CxK,KAAK,CAAChF,MAAN,IAAgB+M,eAAe,CAACyC,EAAD,CAA/B;cACAxK,KAAK,CAACL,QAAN;YAED,CAJM,MAIA,IAAI,CAACqM,GAAG,GAAGvE,aAAa,CAAC+C,EAAD,CAApB,IAA4B,CAAhC,EAAmC;cACxCsB,SAAS,GAAGE,GAAZ;cACAD,SAAS,GAAG,CAAZ;;cAEA,OAAOD,SAAS,GAAG,CAAnB,EAAsBA,SAAS,EAA/B,EAAmC;gBACjCtB,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;;gBAEA,IAAI,CAACqM,GAAG,GAAGzE,WAAW,CAACiD,EAAD,CAAlB,KAA2B,CAA/B,EAAkC;kBAChCuB,SAAS,GAAG,CAACA,SAAS,IAAI,CAAd,IAAmBC,GAA/B;gBAED,CAHD,MAGO;kBACLtD,UAAU,CAAC1I,KAAD,EAAQ,gCAAR,CAAV;gBACD;cACF;;cAEDA,KAAK,CAAChF,MAAN,IAAgB4M,iBAAiB,CAACmE,SAAD,CAAjC;cAEA/L,KAAK,CAACL,QAAN;YAED,CAnBM,MAmBA;cACL+I,UAAU,CAAC1I,KAAD,EAAQ,yBAAR,CAAV;YACD;;YAEDoL,YAAY,GAAGC,UAAU,GAAGrL,KAAK,CAACL,QAAlC;UAED,CArCM,MAqCA,IAAIwH,MAAM,CAACqD,EAAD,CAAV,EAAgB;YACrBhB,cAAc,CAACxJ,KAAD,EAAQoL,YAAR,EAAsBC,UAAtB,EAAkC,IAAlC,CAAd;YACAP,gBAAgB,CAAC9K,KAAD,EAAQyK,mBAAmB,CAACzK,KAAD,EAAQ,KAAR,EAAegL,UAAf,CAA3B,CAAhB;YACAI,YAAY,GAAGC,UAAU,GAAGrL,KAAK,CAACL,QAAlC;UAED,CALM,MAKA,IAAIK,KAAK,CAACL,QAAN,KAAmBK,KAAK,CAACsI,SAAzB,IAAsCuC,qBAAqB,CAAC7K,KAAD,CAA/D,EAAwE;YAC7E0I,UAAU,CAAC1I,KAAD,EAAQ,8DAAR,CAAV;UAED,CAHM,MAGA;YACLA,KAAK,CAACL,QAAN;YACA0L,UAAU,GAAGrL,KAAK,CAACL,QAAnB;UACD;QACF;;QAED+I,UAAU,CAAC1I,KAAD,EAAQ,4DAAR,CAAV;MACD;;MAED,SAASiM,kBAAT,CAA4BjM,KAA5B,EAAmCgL,UAAnC,EAA+C;QAC7C,IAAIkB,QAAQ,GAAG,IAAf;QAAA,IACIX,KADJ;QAAA,IAEIxH,IAAI,GAAO/D,KAAK,CAACvC,GAFrB;QAAA,IAGIqG,OAHJ;QAAA,IAIIqI,OAAO,GAAInM,KAAK,CAACoM,MAJrB;QAAA,IAKIjB,SALJ;QAAA,IAMIkB,UANJ;QAAA,IAOIC,MAPJ;QAAA,IAQIC,cARJ;QAAA,IASIC,SATJ;QAAA,IAUIzC,eAAe,GAAG,EAVtB;QAAA,IAWII,OAXJ;QAAA,IAYID,MAZJ;QAAA,IAaIE,SAbJ;QAAA,IAcII,EAdJ;;QAgBAA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;QAEA,IAAI6K,EAAE,KAAK;QAAI;QAAf,EAAwB;UACtB6B,UAAU,GAAG,IAAb;UAAkB;;UAClBG,SAAS,GAAG,KAAZ;UACA1I,OAAO,GAAG,EAAV;QACD,CAJD,MAIO,IAAI0G,EAAE,KAAK;QAAI;QAAf,EAAwB;UAC7B6B,UAAU,GAAG,IAAb;UAAkB;;UAClBG,SAAS,GAAG,IAAZ;UACA1I,OAAO,GAAG,EAAV;QACD,CAJM,MAIA;UACL,OAAO,KAAP;QACD;;QAED,IAAI9D,KAAK,CAACoM,MAAN,KAAiB,IAArB,EAA2B;UACzBpM,KAAK,CAACyM,SAAN,CAAgBzM,KAAK,CAACoM,MAAtB,IAAgCtI,OAAhC;QACD;;QAED0G,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;;QAEA,OAAO6K,EAAE,KAAK,CAAd,EAAiB;UACfC,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAcgL,UAAd,CAAnB;UAEAR,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;UAEA,IAAI6K,EAAE,KAAK6B,UAAX,EAAuB;YACrBrM,KAAK,CAACL,QAAN;YACAK,KAAK,CAACvC,GAAN,GAAYsG,IAAZ;YACA/D,KAAK,CAACoM,MAAN,GAAeD,OAAf;YACAnM,KAAK,CAAC2L,IAAN,GAAaa,SAAS,GAAG,SAAH,GAAe,UAArC;YACAxM,KAAK,CAAChF,MAAN,GAAe8I,OAAf;YACA,OAAO,IAAP;UACD,CAPD,MAOO,IAAI,CAACoI,QAAL,EAAe;YACpBxD,UAAU,CAAC1I,KAAD,EAAQ,8CAAR,CAAV;UACD;;UAEDkK,MAAM,GAAGC,OAAO,GAAGC,SAAS,GAAG,IAA/B;UACAkC,MAAM,GAAGC,cAAc,GAAG,KAA1B;;UAEA,IAAI/B,EAAE,KAAK;UAAI;UAAf,EAAwB;YACtBW,SAAS,GAAGnL,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAAN,GAAiB,CAAxC,CAAZ;;YAEA,IAAI0H,YAAY,CAAC8D,SAAD,CAAhB,EAA6B;cAC3BmB,MAAM,GAAGC,cAAc,GAAG,IAA1B;cACAvM,KAAK,CAACL,QAAN;cACA8K,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAcgL,UAAd,CAAnB;YACD;UACF;;UAEDO,KAAK,GAAGvL,KAAK,CAACH,IAAd;UACA6M,WAAW,CAAC1M,KAAD,EAAQgL,UAAR,EAAoB3E,eAApB,EAAqC,KAArC,EAA4C,IAA5C,CAAX;UACA6D,MAAM,GAAGlK,KAAK,CAACvC,GAAf;UACA0M,OAAO,GAAGnK,KAAK,CAAChF,MAAhB;UACAyP,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAcgL,UAAd,CAAnB;UAEAR,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;UAEA,IAAI,CAAC4M,cAAc,IAAIvM,KAAK,CAACH,IAAN,KAAe0L,KAAlC,KAA4Cf,EAAE,KAAK;UAAI;UAA3D,EAAoE;YAClE8B,MAAM,GAAG,IAAT;YACA9B,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;YACA8K,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAcgL,UAAd,CAAnB;YACA0B,WAAW,CAAC1M,KAAD,EAAQgL,UAAR,EAAoB3E,eAApB,EAAqC,KAArC,EAA4C,IAA5C,CAAX;YACA+D,SAAS,GAAGpK,KAAK,CAAChF,MAAlB;UACD;;UAED,IAAIwR,SAAJ,EAAe;YACbvC,gBAAgB,CAACjK,KAAD,EAAQ8D,OAAR,EAAiBiG,eAAjB,EAAkCG,MAAlC,EAA0CC,OAA1C,EAAmDC,SAAnD,CAAhB;UACD,CAFD,MAEO,IAAIkC,MAAJ,EAAY;YACjBxI,OAAO,CAAC6B,IAAR,CAAasE,gBAAgB,CAACjK,KAAD,EAAQ,IAAR,EAAc+J,eAAd,EAA+BG,MAA/B,EAAuCC,OAAvC,EAAgDC,SAAhD,CAA7B;UACD,CAFM,MAEA;YACLtG,OAAO,CAAC6B,IAAR,CAAawE,OAAb;UACD;;UAEDM,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAcgL,UAAd,CAAnB;UAEAR,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;UAEA,IAAI6K,EAAE,KAAK;UAAI;UAAf,EAAwB;YACtB0B,QAAQ,GAAG,IAAX;YACA1B,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;UACD,CAHD,MAGO;YACLuM,QAAQ,GAAG,KAAX;UACD;QACF;;QAEDxD,UAAU,CAAC1I,KAAD,EAAQ,uDAAR,CAAV;MACD;;MAED,SAAS2M,eAAT,CAAyB3M,KAAzB,EAAgCgL,UAAhC,EAA4C;QAC1C,IAAII,YAAJ;QAAA,IACIwB,OADJ;QAAA,IAEIC,QAAQ,GAASpG,aAFrB;QAAA,IAGIqG,cAAc,GAAG,KAHrB;QAAA,IAIIC,cAAc,GAAG,KAJrB;QAAA,IAKIC,UAAU,GAAOhC,UALrB;QAAA,IAMIiC,UAAU,GAAO,CANrB;QAAA,IAOIC,cAAc,GAAG,KAPrB;QAAA,IAQIlB,GARJ;QAAA,IASIxB,EATJ;QAWAA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;QAEA,IAAI6K,EAAE,KAAK;QAAI;QAAf,EAAwB;UACtBoC,OAAO,GAAG,KAAV;QACD,CAFD,MAEO,IAAIpC,EAAE,KAAK;QAAI;QAAf,EAAwB;UAC7BoC,OAAO,GAAG,IAAV;QACD,CAFM,MAEA;UACL,OAAO,KAAP;QACD;;QAED5M,KAAK,CAAC2L,IAAN,GAAa,QAAb;QACA3L,KAAK,CAAChF,MAAN,GAAe,EAAf;;QAEA,OAAOwP,EAAE,KAAK,CAAd,EAAiB;UACfA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;;UAEA,IAAI6K,EAAE,KAAK;UAAI;UAAX,GAAsBA,EAAE,KAAK;UAAI;UAArC,EAA8C;YAC5C,IAAI/D,aAAa,KAAKoG,QAAtB,EAAgC;cAC9BA,QAAQ,GAAIrC,EAAE,KAAK;cAAI;cAAZ,EAAuB7D,aAAvB,GAAuCD,cAAlD;YACD,CAFD,MAEO;cACLgC,UAAU,CAAC1I,KAAD,EAAQ,sCAAR,CAAV;YACD;UAEF,CAPD,MAOO,IAAI,CAACgM,GAAG,GAAGtE,eAAe,CAAC8C,EAAD,CAAtB,KAA+B,CAAnC,EAAsC;YAC3C,IAAIwB,GAAG,KAAK,CAAZ,EAAe;cACbtD,UAAU,CAAC1I,KAAD,EAAQ,8EAAR,CAAV;YACD,CAFD,MAEO,IAAI,CAAC+M,cAAL,EAAqB;cAC1BC,UAAU,GAAGhC,UAAU,GAAGgB,GAAb,GAAmB,CAAhC;cACAe,cAAc,GAAG,IAAjB;YACD,CAHM,MAGA;cACLrE,UAAU,CAAC1I,KAAD,EAAQ,2CAAR,CAAV;YACD;UAEF,CAVM,MAUA;YACL;UACD;QACF;;QAED,IAAIoH,cAAc,CAACoD,EAAD,CAAlB,EAAwB;UACtB,GAAG;YAAEA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;UAAgD,CAArD,QACOyH,cAAc,CAACoD,EAAD,CADrB;;UAGA,IAAIA,EAAE,KAAK;UAAI;UAAf,EAAwB;YACtB,GAAG;cAAEA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;YAAgD,CAArD,QACO,CAACwH,MAAM,CAACqD,EAAD,CAAP,IAAgBA,EAAE,KAAK,CAD9B;UAED;QACF;;QAED,OAAOA,EAAE,KAAK,CAAd,EAAiB;UACfD,aAAa,CAACvK,KAAD,CAAb;UACAA,KAAK,CAACuI,UAAN,GAAmB,CAAnB;UAEAiC,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;UAEA,OAAO,CAAC,CAACoN,cAAD,IAAmB/M,KAAK,CAACuI,UAAN,GAAmByE,UAAvC,KACCxC,EAAE,KAAK;UAAI;UADnB,EACiC;YAC/BxK,KAAK,CAACuI,UAAN;YACAiC,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;UACD;;UAED,IAAI,CAACoN,cAAD,IAAmB/M,KAAK,CAACuI,UAAN,GAAmByE,UAA1C,EAAsD;YACpDA,UAAU,GAAGhN,KAAK,CAACuI,UAAnB;UACD;;UAED,IAAIpB,MAAM,CAACqD,EAAD,CAAV,EAAgB;YACdyC,UAAU;YACV;UACD,CAnBc,CAqBf;;;UACA,IAAIjN,KAAK,CAACuI,UAAN,GAAmByE,UAAvB,EAAmC;YAEjC;YACA,IAAIH,QAAQ,KAAKlG,aAAjB,EAAgC;cAC9B3G,KAAK,CAAChF,MAAN,IAAgBM,MAAM,CAACT,MAAP,CAAc,IAAd,EAAoBiS,cAAc,GAAG,IAAIG,UAAP,GAAoBA,UAAtD,CAAhB;YACD,CAFD,MAEO,IAAIJ,QAAQ,KAAKpG,aAAjB,EAAgC;cACrC,IAAIqG,cAAJ,EAAoB;gBAAE;gBACpB9M,KAAK,CAAChF,MAAN,IAAgB,IAAhB;cACD;YACF,CATgC,CAWjC;;;YACA;UACD,CAnCc,CAqCf;;;UACA,IAAI4R,OAAJ,EAAa;YAEX;YACA,IAAIxF,cAAc,CAACoD,EAAD,CAAlB,EAAwB;cACtB0C,cAAc,GAAG,IAAjB,CADsB,CAEtB;;cACAlN,KAAK,CAAChF,MAAN,IAAgBM,MAAM,CAACT,MAAP,CAAc,IAAd,EAAoBiS,cAAc,GAAG,IAAIG,UAAP,GAAoBA,UAAtD,CAAhB,CAHsB,CAKxB;YACC,CAND,MAMO,IAAIC,cAAJ,EAAoB;cACzBA,cAAc,GAAG,KAAjB;cACAlN,KAAK,CAAChF,MAAN,IAAgBM,MAAM,CAACT,MAAP,CAAc,IAAd,EAAoBoS,UAAU,GAAG,CAAjC,CAAhB,CAFyB,CAI3B;YACC,CALM,MAKA,IAAIA,UAAU,KAAK,CAAnB,EAAsB;cAC3B,IAAIH,cAAJ,EAAoB;gBAAE;gBACpB9M,KAAK,CAAChF,MAAN,IAAgB,GAAhB;cACD,CAH0B,CAK7B;;YACC,CANM,MAMA;cACLgF,KAAK,CAAChF,MAAN,IAAgBM,MAAM,CAACT,MAAP,CAAc,IAAd,EAAoBoS,UAApB,CAAhB;YACD,CAtBU,CAwBb;;UACC,CAzBD,MAyBO;YACL;YACAjN,KAAK,CAAChF,MAAN,IAAgBM,MAAM,CAACT,MAAP,CAAc,IAAd,EAAoBiS,cAAc,GAAG,IAAIG,UAAP,GAAoBA,UAAtD,CAAhB;UACD;;UAEDH,cAAc,GAAG,IAAjB;UACAC,cAAc,GAAG,IAAjB;UACAE,UAAU,GAAG,CAAb;UACA7B,YAAY,GAAGpL,KAAK,CAACL,QAArB;;UAEA,OAAO,CAACwH,MAAM,CAACqD,EAAD,CAAP,IAAgBA,EAAE,KAAK,CAA9B,EAAkC;YAChCA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;UACD;;UAED6J,cAAc,CAACxJ,KAAD,EAAQoL,YAAR,EAAsBpL,KAAK,CAACL,QAA5B,EAAsC,KAAtC,CAAd;QACD;;QAED,OAAO,IAAP;MACD;;MAED,SAASwN,iBAAT,CAA2BnN,KAA3B,EAAkCgL,UAAlC,EAA8C;QAC5C,IAAIO,KAAJ;QAAA,IACIxH,IAAI,GAAQ/D,KAAK,CAACvC,GADtB;QAAA,IAEI0O,OAAO,GAAKnM,KAAK,CAACoM,MAFtB;QAAA,IAGItI,OAAO,GAAK,EAHhB;QAAA,IAIIqH,SAJJ;QAAA,IAKIiC,QAAQ,GAAI,KALhB;QAAA,IAMI5C,EANJ;;QAQA,IAAIxK,KAAK,CAACoM,MAAN,KAAiB,IAArB,EAA2B;UACzBpM,KAAK,CAACyM,SAAN,CAAgBzM,KAAK,CAACoM,MAAtB,IAAgCtI,OAAhC;QACD;;QAED0G,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;QAEA,OAAO6K,EAAE,KAAK,CAAd,EAAiB;UAEf,IAAIA,EAAE,KAAK;UAAI;UAAf,EAAwB;YACtB;UACD;;UAEDW,SAAS,GAAGnL,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAAN,GAAiB,CAAxC,CAAZ;;UAEA,IAAI,CAAC0H,YAAY,CAAC8D,SAAD,CAAjB,EAA8B;YAC5B;UACD;;UAEDiC,QAAQ,GAAG,IAAX;UACApN,KAAK,CAACL,QAAN;;UAEA,IAAI8K,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAc,CAAC,CAAf,CAAvB,EAA0C;YACxC,IAAIA,KAAK,CAACuI,UAAN,IAAoByC,UAAxB,EAAoC;cAClClH,OAAO,CAAC6B,IAAR,CAAa,IAAb;;cACA6E,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;cACA;YACD;UACF;;UAED4L,KAAK,GAAGvL,KAAK,CAACH,IAAd;UACA6M,WAAW,CAAC1M,KAAD,EAAQgL,UAAR,EAAoBzE,gBAApB,EAAsC,KAAtC,EAA6C,IAA7C,CAAX;;UACAzC,OAAO,CAAC6B,IAAR,CAAa3F,KAAK,CAAChF,MAAnB;;UACAyP,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAc,CAAC,CAAf,CAAnB;UAEAwK,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;UAEA,IAAI,CAACK,KAAK,CAACH,IAAN,KAAe0L,KAAf,IAAwBvL,KAAK,CAACuI,UAAN,GAAmByC,UAA5C,KAA4DR,EAAE,KAAK,CAAvE,EAA2E;YACzE9B,UAAU,CAAC1I,KAAD,EAAQ,qCAAR,CAAV;UACD,CAFD,MAEO,IAAIA,KAAK,CAACuI,UAAN,GAAmByC,UAAvB,EAAmC;YACxC;UACD;QACF;;QAED,IAAIoC,QAAJ,EAAc;UACZpN,KAAK,CAACvC,GAAN,GAAYsG,IAAZ;UACA/D,KAAK,CAACoM,MAAN,GAAeD,OAAf;UACAnM,KAAK,CAAC2L,IAAN,GAAa,UAAb;UACA3L,KAAK,CAAChF,MAAN,GAAe8I,OAAf;UACA,OAAO,IAAP;QACD;;QACD,OAAO,KAAP;MACD;;MAED,SAASuJ,gBAAT,CAA0BrN,KAA1B,EAAiCgL,UAAjC,EAA6CsC,UAA7C,EAAyD;QACvD,IAAInC,SAAJ;QAAA,IACIoC,YADJ;QAAA,IAEIhC,KAFJ;QAAA,IAGIiC,IAHJ;QAAA,IAIIzJ,IAAI,GAAY/D,KAAK,CAACvC,GAJ1B;QAAA,IAKI0O,OAAO,GAASnM,KAAK,CAACoM,MAL1B;QAAA,IAMItI,OAAO,GAAS,EANpB;QAAA,IAOIiG,eAAe,GAAG,EAPtB;QAAA,IAQIG,MAAM,GAAU,IARpB;QAAA,IASIC,OAAO,GAAS,IATpB;QAAA,IAUIC,SAAS,GAAO,IAVpB;QAAA,IAWIqD,aAAa,GAAG,KAXpB;QAAA,IAYIL,QAAQ,GAAQ,KAZpB;QAAA,IAaI5C,EAbJ;;QAeA,IAAIxK,KAAK,CAACoM,MAAN,KAAiB,IAArB,EAA2B;UACzBpM,KAAK,CAACyM,SAAN,CAAgBzM,KAAK,CAACoM,MAAtB,IAAgCtI,OAAhC;QACD;;QAED0G,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;QAEA,OAAO6K,EAAE,KAAK,CAAd,EAAiB;UACfW,SAAS,GAAGnL,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAAN,GAAiB,CAAxC,CAAZ;UACA4L,KAAK,GAAGvL,KAAK,CAACH,IAAd,CAFe,CAEK;;UACpB2N,IAAI,GAAGxN,KAAK,CAACL,QAAb,CAHe,CAKf;UACA;UACA;UACA;;UACA,IAAI,CAAC6K,EAAE,KAAK;UAAI;UAAX,GAAsBA,EAAE,KAAK;UAAI;UAAlC,KAA8CnD,YAAY,CAAC8D,SAAD,CAA9D,EAA2E;YAEzE,IAAIX,EAAE,KAAK;YAAI;YAAf,EAAwB;cACtB,IAAIiD,aAAJ,EAAmB;gBACjBxD,gBAAgB,CAACjK,KAAD,EAAQ8D,OAAR,EAAiBiG,eAAjB,EAAkCG,MAAlC,EAA0CC,OAA1C,EAAmD,IAAnD,CAAhB;gBACAD,MAAM,GAAGC,OAAO,GAAGC,SAAS,GAAG,IAA/B;cACD;;cAEDgD,QAAQ,GAAG,IAAX;cACAK,aAAa,GAAG,IAAhB;cACAF,YAAY,GAAG,IAAf;YAED,CAVD,MAUO,IAAIE,aAAJ,EAAmB;cACxB;cACAA,aAAa,GAAG,KAAhB;cACAF,YAAY,GAAG,IAAf;YAED,CALM,MAKA;cACL7E,UAAU,CAAC1I,KAAD,EAAQ,mGAAR,CAAV;YACD;;YAEDA,KAAK,CAACL,QAAN,IAAkB,CAAlB;YACA6K,EAAE,GAAGW,SAAL,CAtByE,CAwB3E;YACA;YACA;UACC,CA3BD,MA2BO,IAAIuB,WAAW,CAAC1M,KAAD,EAAQsN,UAAR,EAAoBhH,gBAApB,EAAsC,KAAtC,EAA6C,IAA7C,CAAf,EAAmE;YAExE,IAAItG,KAAK,CAACH,IAAN,KAAe0L,KAAnB,EAA0B;cACxBf,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;cAEA,OAAOyH,cAAc,CAACoD,EAAD,CAArB,EAA2B;gBACzBA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;cACD;;cAED,IAAI6K,EAAE,KAAK;cAAI;cAAf,EAAwB;gBACtBA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;;gBAEA,IAAI,CAAC0H,YAAY,CAACmD,EAAD,CAAjB,EAAuB;kBACrB9B,UAAU,CAAC1I,KAAD,EAAQ,yFAAR,CAAV;gBACD;;gBAED,IAAIyN,aAAJ,EAAmB;kBACjBxD,gBAAgB,CAACjK,KAAD,EAAQ8D,OAAR,EAAiBiG,eAAjB,EAAkCG,MAAlC,EAA0CC,OAA1C,EAAmD,IAAnD,CAAhB;kBACAD,MAAM,GAAGC,OAAO,GAAGC,SAAS,GAAG,IAA/B;gBACD;;gBAEDgD,QAAQ,GAAG,IAAX;gBACAK,aAAa,GAAG,KAAhB;gBACAF,YAAY,GAAG,KAAf;gBACArD,MAAM,GAAGlK,KAAK,CAACvC,GAAf;gBACA0M,OAAO,GAAGnK,KAAK,CAAChF,MAAhB;cAED,CAlBD,MAkBO,IAAIoS,QAAJ,EAAc;gBACnB1E,UAAU,CAAC1I,KAAD,EAAQ,0DAAR,CAAV;cAED,CAHM,MAGA;gBACLA,KAAK,CAACvC,GAAN,GAAYsG,IAAZ;gBACA/D,KAAK,CAACoM,MAAN,GAAeD,OAAf;gBACA,OAAO,IAAP,CAHK,CAGQ;cACd;YAEF,CAlCD,MAkCO,IAAIiB,QAAJ,EAAc;cACnB1E,UAAU,CAAC1I,KAAD,EAAQ,gFAAR,CAAV;YAED,CAHM,MAGA;cACLA,KAAK,CAACvC,GAAN,GAAYsG,IAAZ;cACA/D,KAAK,CAACoM,MAAN,GAAeD,OAAf;cACA,OAAO,IAAP,CAHK,CAGQ;YACd;UAEF,CA7CM,MA6CA;YACL,MADK,CACE;UACR,CAnFc,CAqFf;UACA;UACA;;;UACA,IAAInM,KAAK,CAACH,IAAN,KAAe0L,KAAf,IAAwBvL,KAAK,CAACuI,UAAN,GAAmByC,UAA/C,EAA2D;YACzD,IAAI0B,WAAW,CAAC1M,KAAD,EAAQgL,UAAR,EAAoBxE,iBAApB,EAAuC,IAAvC,EAA6C+G,YAA7C,CAAf,EAA2E;cACzE,IAAIE,aAAJ,EAAmB;gBACjBtD,OAAO,GAAGnK,KAAK,CAAChF,MAAhB;cACD,CAFD,MAEO;gBACLoP,SAAS,GAAGpK,KAAK,CAAChF,MAAlB;cACD;YACF;;YAED,IAAI,CAACyS,aAAL,EAAoB;cAClBxD,gBAAgB,CAACjK,KAAD,EAAQ8D,OAAR,EAAiBiG,eAAjB,EAAkCG,MAAlC,EAA0CC,OAA1C,EAAmDC,SAAnD,EAA8DmB,KAA9D,EAAqEiC,IAArE,CAAhB;cACAtD,MAAM,GAAGC,OAAO,GAAGC,SAAS,GAAG,IAA/B;YACD;;YAEDK,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAc,CAAC,CAAf,CAAnB;YACAwK,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;UACD;;UAED,IAAIK,KAAK,CAACuI,UAAN,GAAmByC,UAAnB,IAAkCR,EAAE,KAAK,CAA7C,EAAiD;YAC/C9B,UAAU,CAAC1I,KAAD,EAAQ,oCAAR,CAAV;UACD,CAFD,MAEO,IAAIA,KAAK,CAACuI,UAAN,GAAmByC,UAAvB,EAAmC;YACxC;UACD;QACF,CArIsD,CAuIvD;QACA;QACA;QAEA;;;QACA,IAAIyC,aAAJ,EAAmB;UACjBxD,gBAAgB,CAACjK,KAAD,EAAQ8D,OAAR,EAAiBiG,eAAjB,EAAkCG,MAAlC,EAA0CC,OAA1C,EAAmD,IAAnD,CAAhB;QACD,CA9IsD,CAgJvD;;;QACA,IAAIiD,QAAJ,EAAc;UACZpN,KAAK,CAACvC,GAAN,GAAYsG,IAAZ;UACA/D,KAAK,CAACoM,MAAN,GAAeD,OAAf;UACAnM,KAAK,CAAC2L,IAAN,GAAa,SAAb;UACA3L,KAAK,CAAChF,MAAN,GAAe8I,OAAf;QACD;;QAED,OAAOsJ,QAAP;MACD;;MAED,SAASM,eAAT,CAAyB1N,KAAzB,EAAgC;QAC9B,IAAI0J,SAAJ;QAAA,IACIiE,UAAU,GAAG,KADjB;QAAA,IAEIC,OAAO,GAAM,KAFjB;QAAA,IAGIC,SAHJ;QAAA,IAIIC,OAJJ;QAAA,IAKItD,EALJ;;QAOAA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;QAEA,IAAI6K,EAAE,KAAK;QAAI;QAAf,EAAwB,OAAO,KAAP;;QAExB,IAAIxK,KAAK,CAACvC,GAAN,KAAc,IAAlB,EAAwB;UACtBiL,UAAU,CAAC1I,KAAD,EAAQ,+BAAR,CAAV;QACD;;QAEDwK,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;;QAEA,IAAI6K,EAAE,KAAK;QAAI;QAAf,EAAwB;UACtBmD,UAAU,GAAG,IAAb;UACAnD,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;QAED,CAJD,MAIO,IAAI6K,EAAE,KAAK;QAAI;QAAf,EAAwB;UAC7BoD,OAAO,GAAG,IAAV;UACAC,SAAS,GAAG,IAAZ;UACArD,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;QAED,CALM,MAKA;UACLkO,SAAS,GAAG,GAAZ;QACD;;QAEDnE,SAAS,GAAG1J,KAAK,CAACL,QAAlB;;QAEA,IAAIgO,UAAJ,EAAgB;UACd,GAAG;YAAEnD,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;UAAgD,CAArD,QACO6K,EAAE,KAAK,CAAP,IAAYA,EAAE,KAAK;UAAI;UAD9B;;UAGA,IAAIxK,KAAK,CAACL,QAAN,GAAiBK,KAAK,CAAC5H,MAA3B,EAAmC;YACjC0V,OAAO,GAAG9N,KAAK,CAAC4F,KAAN,CAAY/H,KAAZ,CAAkB6L,SAAlB,EAA6B1J,KAAK,CAACL,QAAnC,CAAV;YACA6K,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;UACD,CAHD,MAGO;YACL+I,UAAU,CAAC1I,KAAD,EAAQ,oDAAR,CAAV;UACD;QACF,CAVD,MAUO;UACL,OAAOwK,EAAE,KAAK,CAAP,IAAY,CAACnD,YAAY,CAACmD,EAAD,CAAhC,EAAsC;YAEpC,IAAIA,EAAE,KAAK;YAAI;YAAf,EAAwB;cACtB,IAAI,CAACoD,OAAL,EAAc;gBACZC,SAAS,GAAG7N,KAAK,CAAC4F,KAAN,CAAY/H,KAAZ,CAAkB6L,SAAS,GAAG,CAA9B,EAAiC1J,KAAK,CAACL,QAAN,GAAiB,CAAlD,CAAZ;;gBAEA,IAAI,CAACoH,kBAAkB,CAAClG,IAAnB,CAAwBgN,SAAxB,CAAL,EAAyC;kBACvCnF,UAAU,CAAC1I,KAAD,EAAQ,iDAAR,CAAV;gBACD;;gBAED4N,OAAO,GAAG,IAAV;gBACAlE,SAAS,GAAG1J,KAAK,CAACL,QAAN,GAAiB,CAA7B;cACD,CATD,MASO;gBACL+I,UAAU,CAAC1I,KAAD,EAAQ,6CAAR,CAAV;cACD;YACF;;YAEDwK,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;UACD;;UAEDmO,OAAO,GAAG9N,KAAK,CAAC4F,KAAN,CAAY/H,KAAZ,CAAkB6L,SAAlB,EAA6B1J,KAAK,CAACL,QAAnC,CAAV;;UAEA,IAAImH,uBAAuB,CAACjG,IAAxB,CAA6BiN,OAA7B,CAAJ,EAA2C;YACzCpF,UAAU,CAAC1I,KAAD,EAAQ,qDAAR,CAAV;UACD;QACF;;QAED,IAAI8N,OAAO,IAAI,CAAC9G,eAAe,CAACnG,IAAhB,CAAqBiN,OAArB,CAAhB,EAA+C;UAC7CpF,UAAU,CAAC1I,KAAD,EAAQ,8CAA8C8N,OAAtD,CAAV;QACD;;QAED,IAAIH,UAAJ,EAAgB;UACd3N,KAAK,CAACvC,GAAN,GAAYqQ,OAAZ;QAED,CAHD,MAGO,IAAIpS,eAAe,CAACvD,IAAhB,CAAqB6H,KAAK,CAACuJ,MAA3B,EAAmCsE,SAAnC,CAAJ,EAAmD;UACxD7N,KAAK,CAACvC,GAAN,GAAYuC,KAAK,CAACuJ,MAAN,CAAasE,SAAb,IAA0BC,OAAtC;QAED,CAHM,MAGA,IAAID,SAAS,KAAK,GAAlB,EAAuB;UAC5B7N,KAAK,CAACvC,GAAN,GAAY,MAAMqQ,OAAlB;QAED,CAHM,MAGA,IAAID,SAAS,KAAK,IAAlB,EAAwB;UAC7B7N,KAAK,CAACvC,GAAN,GAAY,uBAAuBqQ,OAAnC;QAED,CAHM,MAGA;UACLpF,UAAU,CAAC1I,KAAD,EAAQ,4BAA4B6N,SAA5B,GAAwC,GAAhD,CAAV;QACD;;QAED,OAAO,IAAP;MACD;;MAED,SAASE,kBAAT,CAA4B/N,KAA5B,EAAmC;QACjC,IAAI0J,SAAJ,EACIc,EADJ;;QAGAA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;QAEA,IAAI6K,EAAE,KAAK;QAAI;QAAf,EAAwB,OAAO,KAAP;;QAExB,IAAIxK,KAAK,CAACoM,MAAN,KAAiB,IAArB,EAA2B;UACzB1D,UAAU,CAAC1I,KAAD,EAAQ,mCAAR,CAAV;QACD;;QAEDwK,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;QACA+J,SAAS,GAAG1J,KAAK,CAACL,QAAlB;;QAEA,OAAO6K,EAAE,KAAK,CAAP,IAAY,CAACnD,YAAY,CAACmD,EAAD,CAAzB,IAAiC,CAAClD,iBAAiB,CAACkD,EAAD,CAA1D,EAAgE;UAC9DA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;QACD;;QAED,IAAIK,KAAK,CAACL,QAAN,KAAmB+J,SAAvB,EAAkC;UAChChB,UAAU,CAAC1I,KAAD,EAAQ,4DAAR,CAAV;QACD;;QAEDA,KAAK,CAACoM,MAAN,GAAepM,KAAK,CAAC4F,KAAN,CAAY/H,KAAZ,CAAkB6L,SAAlB,EAA6B1J,KAAK,CAACL,QAAnC,CAAf;QACA,OAAO,IAAP;MACD;;MAED,SAASqO,SAAT,CAAmBhO,KAAnB,EAA0B;QACxB,IAAI0J,SAAJ,EAAeuE,KAAf,EACIzD,EADJ;;QAGAA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;QAEA,IAAI6K,EAAE,KAAK;QAAI;QAAf,EAAwB,OAAO,KAAP;QAExBA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;QACA+J,SAAS,GAAG1J,KAAK,CAACL,QAAlB;;QAEA,OAAO6K,EAAE,KAAK,CAAP,IAAY,CAACnD,YAAY,CAACmD,EAAD,CAAzB,IAAiC,CAAClD,iBAAiB,CAACkD,EAAD,CAA1D,EAAgE;UAC9DA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;QACD;;QAED,IAAIK,KAAK,CAACL,QAAN,KAAmB+J,SAAvB,EAAkC;UAChChB,UAAU,CAAC1I,KAAD,EAAQ,2DAAR,CAAV;QACD;;QAEDiO,KAAK,GAAGjO,KAAK,CAAC4F,KAAN,CAAY/H,KAAZ,CAAkB6L,SAAlB,EAA6B1J,KAAK,CAACL,QAAnC,CAAR;;QAEA,IAAI,CAACjE,eAAe,CAACvD,IAAhB,CAAqB6H,KAAK,CAACyM,SAA3B,EAAsCwB,KAAtC,CAAL,EAAmD;UACjDvF,UAAU,CAAC1I,KAAD,EAAQ,yBAAyBiO,KAAzB,GAAiC,GAAzC,CAAV;QACD;;QAEDjO,KAAK,CAAChF,MAAN,GAAegF,KAAK,CAACyM,SAAN,CAAgBwB,KAAhB,CAAf;QACAxD,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAc,CAAC,CAAf,CAAnB;QACA,OAAO,IAAP;MACD;;MAED,SAAS0M,WAAT,CAAqB1M,KAArB,EAA4BkO,YAA5B,EAA0CC,WAA1C,EAAuDC,WAAvD,EAAoEb,YAApE,EAAkF;QAChF,IAAIc,gBAAJ;QAAA,IACIC,iBADJ;QAAA,IAEIC,qBAFJ;QAAA,IAGIC,YAAY,GAAG,CAHnB;QAAA,IAGsB;QAClBC,SAAS,GAAI,KAJjB;QAAA,IAKIC,UAAU,GAAG,KALjB;QAAA,IAMIC,SANJ;QAAA,IAOIC,YAPJ;QAAA,IAQIjR,IARJ;QAAA,IASI2P,UATJ;QAAA,IAUIuB,WAVJ;;QAYA,IAAI7O,KAAK,CAACoI,QAAN,KAAmB,IAAvB,EAA6B;UAC3BpI,KAAK,CAACoI,QAAN,CAAe,MAAf,EAAuBpI,KAAvB;QACD;;QAEDA,KAAK,CAACvC,GAAN,GAAe,IAAf;QACAuC,KAAK,CAACoM,MAAN,GAAe,IAAf;QACApM,KAAK,CAAC2L,IAAN,GAAe,IAAf;QACA3L,KAAK,CAAChF,MAAN,GAAe,IAAf;QAEAqT,gBAAgB,GAAGC,iBAAiB,GAAGC,qBAAqB,GAC1D/H,iBAAiB,KAAK2H,WAAtB,IACA5H,gBAAgB,KAAM4H,WAFxB;;QAIA,IAAIC,WAAJ,EAAiB;UACf,IAAI3D,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAc,CAAC,CAAf,CAAvB,EAA0C;YACxCyO,SAAS,GAAG,IAAZ;;YAEA,IAAIzO,KAAK,CAACuI,UAAN,GAAmB2F,YAAvB,EAAqC;cACnCM,YAAY,GAAG,CAAf;YACD,CAFD,MAEO,IAAIxO,KAAK,CAACuI,UAAN,KAAqB2F,YAAzB,EAAuC;cAC5CM,YAAY,GAAG,CAAf;YACD,CAFM,MAEA,IAAIxO,KAAK,CAACuI,UAAN,GAAmB2F,YAAvB,EAAqC;cAC1CM,YAAY,GAAG,CAAC,CAAhB;YACD;UACF;QACF;;QAED,IAAIA,YAAY,KAAK,CAArB,EAAwB;UACtB,OAAOd,eAAe,CAAC1N,KAAD,CAAf,IAA0B+N,kBAAkB,CAAC/N,KAAD,CAAnD,EAA4D;YAC1D,IAAIyK,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAc,CAAC,CAAf,CAAvB,EAA0C;cACxCyO,SAAS,GAAG,IAAZ;cACAF,qBAAqB,GAAGF,gBAAxB;;cAEA,IAAIrO,KAAK,CAACuI,UAAN,GAAmB2F,YAAvB,EAAqC;gBACnCM,YAAY,GAAG,CAAf;cACD,CAFD,MAEO,IAAIxO,KAAK,CAACuI,UAAN,KAAqB2F,YAAzB,EAAuC;gBAC5CM,YAAY,GAAG,CAAf;cACD,CAFM,MAEA,IAAIxO,KAAK,CAACuI,UAAN,GAAmB2F,YAAvB,EAAqC;gBAC1CM,YAAY,GAAG,CAAC,CAAhB;cACD;YACF,CAXD,MAWO;cACLD,qBAAqB,GAAG,KAAxB;YACD;UACF;QACF;;QAED,IAAIA,qBAAJ,EAA2B;UACzBA,qBAAqB,GAAGE,SAAS,IAAIlB,YAArC;QACD;;QAED,IAAIiB,YAAY,KAAK,CAAjB,IAAsBhI,iBAAiB,KAAK2H,WAAhD,EAA6D;UAC3D,IAAI9H,eAAe,KAAK8H,WAApB,IAAmC7H,gBAAgB,KAAK6H,WAA5D,EAAyE;YACvEb,UAAU,GAAGY,YAAb;UACD,CAFD,MAEO;YACLZ,UAAU,GAAGY,YAAY,GAAG,CAA5B;UACD;;UAEDW,WAAW,GAAG7O,KAAK,CAACL,QAAN,GAAiBK,KAAK,CAACsI,SAArC;;UAEA,IAAIkG,YAAY,KAAK,CAArB,EAAwB;YACtB,IAAID,qBAAqB,KACpBpB,iBAAiB,CAACnN,KAAD,EAAQ6O,WAAR,CAAjB,IACAxB,gBAAgB,CAACrN,KAAD,EAAQ6O,WAAR,EAAqBvB,UAArB,CAFI,CAArB,IAGArB,kBAAkB,CAACjM,KAAD,EAAQsN,UAAR,CAHtB,EAG2C;cACzCoB,UAAU,GAAG,IAAb;YACD,CALD,MAKO;cACL,IAAKJ,iBAAiB,IAAI3B,eAAe,CAAC3M,KAAD,EAAQsN,UAAR,CAArC,IACA1B,sBAAsB,CAAC5L,KAAD,EAAQsN,UAAR,CADtB,IAEAzB,sBAAsB,CAAC7L,KAAD,EAAQsN,UAAR,CAF1B,EAE+C;gBAC7CoB,UAAU,GAAG,IAAb;cAED,CALD,MAKO,IAAIV,SAAS,CAAChO,KAAD,CAAb,EAAsB;gBAC3B0O,UAAU,GAAG,IAAb;;gBAEA,IAAI1O,KAAK,CAACvC,GAAN,KAAc,IAAd,IAAsBuC,KAAK,CAACoM,MAAN,KAAiB,IAA3C,EAAiD;kBAC/C1D,UAAU,CAAC1I,KAAD,EAAQ,2CAAR,CAAV;gBACD;cAEF,CAPM,MAOA,IAAI+K,eAAe,CAAC/K,KAAD,EAAQsN,UAAR,EAAoBjH,eAAe,KAAK8H,WAAxC,CAAnB,EAAyE;gBAC9EO,UAAU,GAAG,IAAb;;gBAEA,IAAI1O,KAAK,CAACvC,GAAN,KAAc,IAAlB,EAAwB;kBACtBuC,KAAK,CAACvC,GAAN,GAAY,GAAZ;gBACD;cACF;;cAED,IAAIuC,KAAK,CAACoM,MAAN,KAAiB,IAArB,EAA2B;gBACzBpM,KAAK,CAACyM,SAAN,CAAgBzM,KAAK,CAACoM,MAAtB,IAAgCpM,KAAK,CAAChF,MAAtC;cACD;YACF;UACF,CA/BD,MA+BO,IAAIwT,YAAY,KAAK,CAArB,EAAwB;YAC7B;YACA;YACAE,UAAU,GAAGH,qBAAqB,IAAIpB,iBAAiB,CAACnN,KAAD,EAAQ6O,WAAR,CAAvD;UACD;QACF;;QAED,IAAI7O,KAAK,CAACvC,GAAN,KAAc,IAAd,IAAsBuC,KAAK,CAACvC,GAAN,KAAc,GAAxC,EAA6C;UAC3C,IAAIuC,KAAK,CAACvC,GAAN,KAAc,GAAlB,EAAuB;YACrB;YACA;YACA;YACA;YACA;YACA;YACA,IAAIuC,KAAK,CAAChF,MAAN,KAAiB,IAAjB,IAAyBgF,KAAK,CAAC2L,IAAN,KAAe,QAA5C,EAAsD;cACpDjD,UAAU,CAAC1I,KAAD,EAAQ,sEAAsEA,KAAK,CAAC2L,IAA5E,GAAmF,GAA3F,CAAV;YACD;;YAED,KAAKgD,SAAS,GAAG,CAAZ,EAAeC,YAAY,GAAG5O,KAAK,CAACd,aAAN,CAAoB9G,MAAvD,EAA+DuW,SAAS,GAAGC,YAA3E,EAAyFD,SAAS,IAAI,CAAtG,EAAyG;cACvGhR,IAAI,GAAGqC,KAAK,CAACd,aAAN,CAAoByP,SAApB,CAAP;;cAEA,IAAIhR,IAAI,CAACyC,OAAL,CAAaJ,KAAK,CAAChF,MAAnB,CAAJ,EAAgC;gBAAE;gBAChCgF,KAAK,CAAChF,MAAN,GAAe2C,IAAI,CAACmR,SAAL,CAAe9O,KAAK,CAAChF,MAArB,CAAf;gBACAgF,KAAK,CAACvC,GAAN,GAAYE,IAAI,CAACF,GAAjB;;gBACA,IAAIuC,KAAK,CAACoM,MAAN,KAAiB,IAArB,EAA2B;kBACzBpM,KAAK,CAACyM,SAAN,CAAgBzM,KAAK,CAACoM,MAAtB,IAAgCpM,KAAK,CAAChF,MAAtC;gBACD;;gBACD;cACD;YACF;UACF,CAvBD,MAuBO,IAAIU,eAAe,CAACvD,IAAhB,CAAqB6H,KAAK,CAACqI,OAAN,CAAcrI,KAAK,CAAC2L,IAAN,IAAc,UAA5B,CAArB,EAA8D3L,KAAK,CAACvC,GAApE,CAAJ,EAA8E;YACnFE,IAAI,GAAGqC,KAAK,CAACqI,OAAN,CAAcrI,KAAK,CAAC2L,IAAN,IAAc,UAA5B,EAAwC3L,KAAK,CAACvC,GAA9C,CAAP;;YAEA,IAAIuC,KAAK,CAAChF,MAAN,KAAiB,IAAjB,IAAyB2C,IAAI,CAACgO,IAAL,KAAc3L,KAAK,CAAC2L,IAAjD,EAAuD;cACrDjD,UAAU,CAAC1I,KAAD,EAAQ,kCAAkCA,KAAK,CAACvC,GAAxC,GAA8C,uBAA9C,GAAwEE,IAAI,CAACgO,IAA7E,GAAoF,UAApF,GAAiG3L,KAAK,CAAC2L,IAAvG,GAA8G,GAAtH,CAAV;YACD;;YAED,IAAI,CAAChO,IAAI,CAACyC,OAAL,CAAaJ,KAAK,CAAChF,MAAnB,CAAL,EAAiC;cAAE;cACjC0N,UAAU,CAAC1I,KAAD,EAAQ,kCAAkCA,KAAK,CAACvC,GAAxC,GAA8C,gBAAtD,CAAV;YACD,CAFD,MAEO;cACLuC,KAAK,CAAChF,MAAN,GAAe2C,IAAI,CAACmR,SAAL,CAAe9O,KAAK,CAAChF,MAArB,CAAf;;cACA,IAAIgF,KAAK,CAACoM,MAAN,KAAiB,IAArB,EAA2B;gBACzBpM,KAAK,CAACyM,SAAN,CAAgBzM,KAAK,CAACoM,MAAtB,IAAgCpM,KAAK,CAAChF,MAAtC;cACD;YACF;UACF,CAfM,MAeA;YACL0N,UAAU,CAAC1I,KAAD,EAAQ,mBAAmBA,KAAK,CAACvC,GAAzB,GAA+B,GAAvC,CAAV;UACD;QACF;;QAED,IAAIuC,KAAK,CAACoI,QAAN,KAAmB,IAAvB,EAA6B;UAC3BpI,KAAK,CAACoI,QAAN,CAAe,OAAf,EAAwBpI,KAAxB;QACD;;QACD,OAAOA,KAAK,CAACvC,GAAN,KAAc,IAAd,IAAuBuC,KAAK,CAACoM,MAAN,KAAiB,IAAxC,IAAgDsC,UAAvD;MACD;;MAED,SAASK,YAAT,CAAsB/O,KAAtB,EAA6B;QAC3B,IAAIgP,aAAa,GAAGhP,KAAK,CAACL,QAA1B;QAAA,IACI+J,SADJ;QAAA,IAEIuF,aAFJ;QAAA,IAGIC,aAHJ;QAAA,IAIIC,aAAa,GAAG,KAJpB;QAAA,IAKI3E,EALJ;;QAOAxK,KAAK,CAACkJ,OAAN,GAAgB,IAAhB;QACAlJ,KAAK,CAACoJ,eAAN,GAAwBpJ,KAAK,CAACkI,MAA9B;QACAlI,KAAK,CAACuJ,MAAN,GAAe,EAAf;QACAvJ,KAAK,CAACyM,SAAN,GAAkB,EAAlB;;QAEA,OAAO,CAACjC,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAN,MAAkD,CAAzD,EAA4D;UAC1D8K,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAc,CAAC,CAAf,CAAnB;UAEAwK,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,CAAL;;UAEA,IAAIK,KAAK,CAACuI,UAAN,GAAmB,CAAnB,IAAwBiC,EAAE,KAAK;UAAI;UAAvC,EAAgD;YAC9C;UACD;;UAED2E,aAAa,GAAG,IAAhB;UACA3E,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;UACA+J,SAAS,GAAG1J,KAAK,CAACL,QAAlB;;UAEA,OAAO6K,EAAE,KAAK,CAAP,IAAY,CAACnD,YAAY,CAACmD,EAAD,CAAhC,EAAsC;YACpCA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;UACD;;UAEDsP,aAAa,GAAGjP,KAAK,CAAC4F,KAAN,CAAY/H,KAAZ,CAAkB6L,SAAlB,EAA6B1J,KAAK,CAACL,QAAnC,CAAhB;UACAuP,aAAa,GAAG,EAAhB;;UAEA,IAAID,aAAa,CAAC7W,MAAd,GAAuB,CAA3B,EAA8B;YAC5BsQ,UAAU,CAAC1I,KAAD,EAAQ,8DAAR,CAAV;UACD;;UAED,OAAOwK,EAAE,KAAK,CAAd,EAAiB;YACf,OAAOpD,cAAc,CAACoD,EAAD,CAArB,EAA2B;cACzBA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;YACD;;YAED,IAAI6K,EAAE,KAAK;YAAI;YAAf,EAAwB;cACtB,GAAG;gBAAEA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;cAAgD,CAArD,QACO6K,EAAE,KAAK,CAAP,IAAY,CAACrD,MAAM,CAACqD,EAAD,CAD1B;;cAEA;YACD;;YAED,IAAIrD,MAAM,CAACqD,EAAD,CAAV,EAAgB;YAEhBd,SAAS,GAAG1J,KAAK,CAACL,QAAlB;;YAEA,OAAO6K,EAAE,KAAK,CAAP,IAAY,CAACnD,YAAY,CAACmD,EAAD,CAAhC,EAAsC;cACpCA,EAAE,GAAGxK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB,EAAE9B,KAAK,CAACL,QAA/B,CAAL;YACD;;YAEDuP,aAAa,CAACvJ,IAAd,CAAmB3F,KAAK,CAAC4F,KAAN,CAAY/H,KAAZ,CAAkB6L,SAAlB,EAA6B1J,KAAK,CAACL,QAAnC,CAAnB;UACD;;UAED,IAAI6K,EAAE,KAAK,CAAX,EAAcD,aAAa,CAACvK,KAAD,CAAb;;UAEd,IAAItE,eAAe,CAACvD,IAAhB,CAAqByQ,iBAArB,EAAwCqG,aAAxC,CAAJ,EAA4D;YAC1DrG,iBAAiB,CAACqG,aAAD,CAAjB,CAAiCjP,KAAjC,EAAwCiP,aAAxC,EAAuDC,aAAvD;UACD,CAFD,MAEO;YACLvG,YAAY,CAAC3I,KAAD,EAAQ,iCAAiCiP,aAAjC,GAAiD,GAAzD,CAAZ;UACD;QACF;;QAEDxE,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAc,CAAC,CAAf,CAAnB;;QAEA,IAAIA,KAAK,CAACuI,UAAN,KAAqB,CAArB,IACAvI,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,MAA+C;QAAI;QADnD,GAEAK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAAN,GAAiB,CAAxC,MAA+C;QAAI;QAFnD,GAGAK,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAAN,GAAiB,CAAxC,MAA+C;QAAI;QAHvD,EAGgE;UAC9DK,KAAK,CAACL,QAAN,IAAkB,CAAlB;UACA8K,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAc,CAAC,CAAf,CAAnB;QAED,CAPD,MAOO,IAAImP,aAAJ,EAAmB;UACxBzG,UAAU,CAAC1I,KAAD,EAAQ,iCAAR,CAAV;QACD;;QAED0M,WAAW,CAAC1M,KAAD,EAAQA,KAAK,CAACuI,UAAN,GAAmB,CAA3B,EAA8B/B,iBAA9B,EAAiD,KAAjD,EAAwD,IAAxD,CAAX;QACAiE,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAc,CAAC,CAAf,CAAnB;;QAEA,IAAIA,KAAK,CAACoJ,eAAN,IACAvC,6BAA6B,CAAChG,IAA9B,CAAmCb,KAAK,CAAC4F,KAAN,CAAY/H,KAAZ,CAAkBmR,aAAlB,EAAiChP,KAAK,CAACL,QAAvC,CAAnC,CADJ,EAC0F;UACxFgJ,YAAY,CAAC3I,KAAD,EAAQ,kDAAR,CAAZ;QACD;;QAEDA,KAAK,CAACwI,SAAN,CAAgB7C,IAAhB,CAAqB3F,KAAK,CAAChF,MAA3B;;QAEA,IAAIgF,KAAK,CAACL,QAAN,KAAmBK,KAAK,CAACsI,SAAzB,IAAsCuC,qBAAqB,CAAC7K,KAAD,CAA/D,EAAwE;UAEtE,IAAIA,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,MAA2C;UAAI;UAAnD,EAA4D;YAC1DK,KAAK,CAACL,QAAN,IAAkB,CAAlB;YACA8K,mBAAmB,CAACzK,KAAD,EAAQ,IAAR,EAAc,CAAC,CAAf,CAAnB;UACD;;UACD;QACD;;QAED,IAAIA,KAAK,CAACL,QAAN,GAAkBK,KAAK,CAAC5H,MAAN,GAAe,CAArC,EAAyC;UACvCsQ,UAAU,CAAC1I,KAAD,EAAQ,uDAAR,CAAV;QACD,CAFD,MAEO;UACL;QACD;MACF;;MAGD,SAASoP,aAAT,CAAuBxJ,KAAvB,EAA8BvH,OAA9B,EAAuC;QACrCuH,KAAK,GAAGhI,MAAM,CAACgI,KAAD,CAAd;QACAvH,OAAO,GAAGA,OAAO,IAAI,EAArB;;QAEA,IAAIuH,KAAK,CAACxN,MAAN,KAAiB,CAArB,EAAwB;UAEtB;UACA,IAAIwN,KAAK,CAAC9D,UAAN,CAAiB8D,KAAK,CAACxN,MAAN,GAAe,CAAhC,MAAuC;UAAI;UAA3C,GACAwN,KAAK,CAAC9D,UAAN,CAAiB8D,KAAK,CAACxN,MAAN,GAAe,CAAhC,MAAuC;UAAI;UAD/C,EACyD;YACvDwN,KAAK,IAAI,IAAT;UACD,CANqB,CAQtB;;;UACA,IAAIA,KAAK,CAAC9D,UAAN,CAAiB,CAAjB,MAAwB,MAA5B,EAAoC;YAClC8D,KAAK,GAAGA,KAAK,CAAC/H,KAAN,CAAY,CAAZ,CAAR;UACD;QACF;;QAED,IAAImC,KAAK,GAAG,IAAI5B,KAAJ,CAAUwH,KAAV,EAAiBvH,OAAjB,CAAZ;QAEA,IAAIgR,OAAO,GAAGzJ,KAAK,CAAC9F,OAAN,CAAc,IAAd,CAAd;;QAEA,IAAIuP,OAAO,KAAK,CAAC,CAAjB,EAAoB;UAClBrP,KAAK,CAACL,QAAN,GAAiB0P,OAAjB;UACA3G,UAAU,CAAC1I,KAAD,EAAQ,mCAAR,CAAV;QACD,CAzBoC,CA2BrC;;;QACAA,KAAK,CAAC4F,KAAN,IAAe,IAAf;;QAEA,OAAO5F,KAAK,CAAC4F,KAAN,CAAY9D,UAAZ,CAAuB9B,KAAK,CAACL,QAA7B,MAA2C;QAAI;QAAtD,EAAmE;UACjEK,KAAK,CAACuI,UAAN,IAAoB,CAApB;UACAvI,KAAK,CAACL,QAAN,IAAkB,CAAlB;QACD;;QAED,OAAOK,KAAK,CAACL,QAAN,GAAkBK,KAAK,CAAC5H,MAAN,GAAe,CAAxC,EAA4C;UAC1C2W,YAAY,CAAC/O,KAAD,CAAZ;QACD;;QAED,OAAOA,KAAK,CAACwI,SAAb;MACD;;MAGD,SAASvP,OAAT,CAAiB2M,KAAjB,EAAwB0J,QAAxB,EAAkCjR,OAAlC,EAA2C;QACzC,IAAIiR,QAAQ,KAAK,IAAb,IAAqB,OAAOA,QAAP,KAAoB,QAAzC,IAAqD,OAAOjR,OAAP,KAAmB,WAA5E,EAAyF;UACvFA,OAAO,GAAGiR,QAAV;UACAA,QAAQ,GAAG,IAAX;QACD;;QAED,IAAI9G,SAAS,GAAG4G,aAAa,CAACxJ,KAAD,EAAQvH,OAAR,CAA7B;;QAEA,IAAI,OAAOiR,QAAP,KAAoB,UAAxB,EAAoC;UAClC,OAAO9G,SAAP;QACD;;QAED,KAAK,IAAIhO,KAAK,GAAG,CAAZ,EAAepC,MAAM,GAAGoQ,SAAS,CAACpQ,MAAvC,EAA+CoC,KAAK,GAAGpC,MAAvD,EAA+DoC,KAAK,IAAI,CAAxE,EAA2E;UACzE8U,QAAQ,CAAC9G,SAAS,CAAChO,KAAD,CAAV,CAAR;QACD;MACF;;MAGD,SAASxB,IAAT,CAAc4M,KAAd,EAAqBvH,OAArB,EAA8B;QAC5B,IAAImK,SAAS,GAAG4G,aAAa,CAACxJ,KAAD,EAAQvH,OAAR,CAA7B;;QAEA,IAAImK,SAAS,CAACpQ,MAAV,KAAqB,CAAzB,EAA4B;UAC1B;UACA,OAAOmX,SAAP;QACD,CAHD,MAGO,IAAI/G,SAAS,CAACpQ,MAAV,KAAqB,CAAzB,EAA4B;UACjC,OAAOoQ,SAAS,CAAC,CAAD,CAAhB;QACD;;QACD,MAAM,IAAIlP,aAAJ,CAAkB,0DAAlB,CAAN;MACD;;MAGD,SAASH,WAAT,CAAqByM,KAArB,EAA4B0J,QAA5B,EAAsCjR,OAAtC,EAA+C;QAC7C,IAAI,OAAOiR,QAAP,KAAoB,QAApB,IAAgCA,QAAQ,KAAK,IAA7C,IAAqD,OAAOjR,OAAP,KAAmB,WAA5E,EAAyF;UACvFA,OAAO,GAAGiR,QAAV;UACAA,QAAQ,GAAG,IAAX;QACD;;QAED,OAAOrW,OAAO,CAAC2M,KAAD,EAAQ0J,QAAR,EAAkBhU,MAAM,CAACjB,MAAP,CAAc;UAAEkD,MAAM,EAAEzE;QAAV,CAAd,EAA+CuF,OAA/C,CAAlB,CAAd;MACD;;MAGD,SAASnF,QAAT,CAAkB0M,KAAlB,EAAyBvH,OAAzB,EAAkC;QAChC,OAAOrF,IAAI,CAAC4M,KAAD,EAAQtK,MAAM,CAACjB,MAAP,CAAc;UAAEkD,MAAM,EAAEzE;QAAV,CAAd,EAA+CuF,OAA/C,CAAR,CAAX;MACD;;MAGDvH,MAAM,CAACD,OAAP,CAAeoC,OAAf,GAA6BA,OAA7B;MACAnC,MAAM,CAACD,OAAP,CAAemC,IAAf,GAA6BA,IAA7B;MACAlC,MAAM,CAACD,OAAP,CAAesC,WAAf,GAA6BA,WAA7B;MACArC,MAAM,CAACD,OAAP,CAAeqC,QAAf,GAA6BA,QAA7B;IAEC,CA9mDO,EA8mDN;MAAC,YAAW,CAAZ;MAAc,eAAc,CAA5B;MAA8B,UAAS,CAAvC;MAAyC,yBAAwB,CAAjE;MAAmE,yBAAwB;IAA3F,CA9mDM,CAv+By2B;IAqlF/wB,GAAE,CAAC,UAASrB,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACrI;;MAGA,IAAIyE,MAAM,GAAGzD,OAAO,CAAC,UAAD,CAApB;;MAGA,SAASuO,IAAT,CAAc5N,IAAd,EAAoBgX,MAApB,EAA4B7P,QAA5B,EAAsCE,IAAtC,EAA4C4P,MAA5C,EAAoD;QAClD,KAAKjX,IAAL,GAAgBA,IAAhB;QACA,KAAKgX,MAAL,GAAgBA,MAAhB;QACA,KAAK7P,QAAL,GAAgBA,QAAhB;QACA,KAAKE,IAAL,GAAgBA,IAAhB;QACA,KAAK4P,MAAL,GAAgBA,MAAhB;MACD;;MAGDrJ,IAAI,CAAC5K,SAAL,CAAekU,UAAf,GAA4B,SAASA,UAAT,CAAoBpR,MAApB,EAA4BqR,SAA5B,EAAuC;QACjE,IAAIC,IAAJ,EAAUrM,KAAV,EAAiBsM,IAAjB,EAAuBrM,GAAvB,EAA4BsM,OAA5B;QAEA,IAAI,CAAC,KAAKN,MAAV,EAAkB,OAAO,IAAP;QAElBlR,MAAM,GAAGA,MAAM,IAAI,CAAnB;QACAqR,SAAS,GAAGA,SAAS,IAAI,EAAzB;QAEAC,IAAI,GAAG,EAAP;QACArM,KAAK,GAAG,KAAK5D,QAAb;;QAEA,OAAO4D,KAAK,GAAG,CAAR,IAAa,2BAA2BzD,OAA3B,CAAmC,KAAK0P,MAAL,CAAYO,MAAZ,CAAmBxM,KAAK,GAAG,CAA3B,CAAnC,MAAsE,CAAC,CAA3F,EAA8F;UAC5FA,KAAK,IAAI,CAAT;;UACA,IAAI,KAAK5D,QAAL,GAAgB4D,KAAhB,GAAyBoM,SAAS,GAAG,CAAZ,GAAgB,CAA7C,EAAiD;YAC/CC,IAAI,GAAG,OAAP;YACArM,KAAK,IAAI,CAAT;YACA;UACD;QACF;;QAEDsM,IAAI,GAAG,EAAP;QACArM,GAAG,GAAG,KAAK7D,QAAX;;QAEA,OAAO6D,GAAG,GAAG,KAAKgM,MAAL,CAAYpX,MAAlB,IAA4B,2BAA2B0H,OAA3B,CAAmC,KAAK0P,MAAL,CAAYO,MAAZ,CAAmBvM,GAAnB,CAAnC,MAAgE,CAAC,CAApG,EAAuG;UACrGA,GAAG,IAAI,CAAP;;UACA,IAAIA,GAAG,GAAG,KAAK7D,QAAX,GAAuBgQ,SAAS,GAAG,CAAZ,GAAgB,CAA3C,EAA+C;YAC7CE,IAAI,GAAG,OAAP;YACArM,GAAG,IAAI,CAAP;YACA;UACD;QACF;;QAEDsM,OAAO,GAAG,KAAKN,MAAL,CAAY3R,KAAZ,CAAkB0F,KAAlB,EAAyBC,GAAzB,CAAV;QAEA,OAAOlI,MAAM,CAACT,MAAP,CAAc,GAAd,EAAmByD,MAAnB,IAA6BsR,IAA7B,GAAoCE,OAApC,GAA8CD,IAA9C,GAAqD,IAArD,GACAvU,MAAM,CAACT,MAAP,CAAc,GAAd,EAAmByD,MAAM,GAAG,KAAKqB,QAAd,GAAyB4D,KAAzB,GAAiCqM,IAAI,CAACxX,MAAzD,CADA,GACmE,GAD1E;MAED,CApCD;;MAuCAgO,IAAI,CAAC5K,SAAL,CAAeC,QAAf,GAA0B,SAASA,QAAT,CAAkByI,OAAlB,EAA2B;QACnD,IAAI4L,OAAJ;QAAA,IAAaE,KAAK,GAAG,EAArB;;QAEA,IAAI,KAAKxX,IAAT,EAAe;UACbwX,KAAK,IAAI,SAAS,KAAKxX,IAAd,GAAqB,IAA9B;QACD;;QAEDwX,KAAK,IAAI,cAAc,KAAKnQ,IAAL,GAAY,CAA1B,IAA+B,WAA/B,IAA8C,KAAK4P,MAAL,GAAc,CAA5D,CAAT;;QAEA,IAAI,CAACvL,OAAL,EAAc;UACZ4L,OAAO,GAAG,KAAKJ,UAAL,EAAV;;UAEA,IAAII,OAAJ,EAAa;YACXE,KAAK,IAAI,QAAQF,OAAjB;UACD;QACF;;QAED,OAAOE,KAAP;MACD,CAlBD;;MAqBAlZ,MAAM,CAACD,OAAP,GAAiBuP,IAAjB;IAEC,CA9EmG,EA8ElG;MAAC,YAAW;IAAZ,CA9EkG,CArlF6wB;IAmqF/1B,GAAE,CAAC,UAASvO,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACrD;MAEA;;MAEA,IAAIyE,MAAM,GAAUzD,OAAO,CAAC,UAAD,CAA3B;;MACA,IAAIyB,aAAa,GAAGzB,OAAO,CAAC,aAAD,CAA3B;;MACA,IAAIY,IAAI,GAAYZ,OAAO,CAAC,QAAD,CAA3B;;MAGA,SAASoY,WAAT,CAAqB1S,MAArB,EAA6B/E,IAA7B,EAAmCwC,MAAnC,EAA2C;QACzC,IAAIkV,OAAO,GAAG,EAAd;QAEA3S,MAAM,CAAC4S,OAAP,CAAeC,OAAf,CAAuB,UAAUC,cAAV,EAA0B;UAC/CrV,MAAM,GAAGiV,WAAW,CAACI,cAAD,EAAiB7X,IAAjB,EAAuBwC,MAAvB,CAApB;QACD,CAFD;QAIAuC,MAAM,CAAC/E,IAAD,CAAN,CAAa4X,OAAb,CAAqB,UAAUE,WAAV,EAAuB;UAC1CtV,MAAM,CAACoV,OAAP,CAAe,UAAUG,YAAV,EAAwBC,aAAxB,EAAuC;YACpD,IAAID,YAAY,CAAC9S,GAAb,KAAqB6S,WAAW,CAAC7S,GAAjC,IAAwC8S,YAAY,CAAC5E,IAAb,KAAsB2E,WAAW,CAAC3E,IAA9E,EAAoF;cAClFuE,OAAO,CAACvK,IAAR,CAAa6K,aAAb;YACD;UACF,CAJD;UAMAxV,MAAM,CAAC2K,IAAP,CAAY2K,WAAZ;QACD,CARD;QAUA,OAAOtV,MAAM,CAACyV,MAAP,CAAc,UAAU9S,IAAV,EAAgBnD,KAAhB,EAAuB;UAC1C,OAAO0V,OAAO,CAACpQ,OAAR,CAAgBtF,KAAhB,MAA2B,CAAC,CAAnC;QACD,CAFM,CAAP;MAGD;;MAGD;QAAoB;MAAXkW,UAAT,GAAoC;QAClC,IAAI1V,MAAM,GAAG;UACP2V,MAAM,EAAE,EADD;UAEPzW,QAAQ,EAAE,EAFH;UAGP0W,OAAO,EAAE,EAHF;UAIPC,QAAQ,EAAE;QAJH,CAAb;QAAA,IAKOrW,KALP;QAAA,IAKcpC,MALd;;QAOA,SAAS0Y,WAAT,CAAqBnT,IAArB,EAA2B;UACzB3C,MAAM,CAAC2C,IAAI,CAACgO,IAAN,CAAN,CAAkBhO,IAAI,CAACF,GAAvB,IAA8BzC,MAAM,CAAC,UAAD,CAAN,CAAmB2C,IAAI,CAACF,GAAxB,IAA+BE,IAA7D;QACD;;QAED,KAAKnD,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAG2Y,SAAS,CAAC3Y,MAAnC,EAA2CoC,KAAK,GAAGpC,MAAnD,EAA2DoC,KAAK,IAAI,CAApE,EAAuE;UACrEuW,SAAS,CAACvW,KAAD,CAAT,CAAiB4V,OAAjB,CAAyBU,WAAzB;QACD;;QACD,OAAO9V,MAAP;MACD;;MAGD,SAAStC,MAAT,CAAgBsY,UAAhB,EAA4B;QAC1B,KAAKb,OAAL,GAAgBa,UAAU,CAACb,OAAX,IAAuB,EAAvC;QACA,KAAKc,QAAL,GAAgBD,UAAU,CAACC,QAAX,IAAuB,EAAvC;QACA,KAAKrM,QAAL,GAAgBoM,UAAU,CAACpM,QAAX,IAAuB,EAAvC;QAEA,KAAKqM,QAAL,CAAcb,OAAd,CAAsB,UAAUzS,IAAV,EAAgB;UACpC,IAAIA,IAAI,CAACuT,QAAL,IAAiBvT,IAAI,CAACuT,QAAL,KAAkB,QAAvC,EAAiD;YAC/C,MAAM,IAAI5X,aAAJ,CAAkB,iHAAlB,CAAN;UACD;QACF,CAJD;QAMA,KAAK6F,gBAAL,GAAwB8Q,WAAW,CAAC,IAAD,EAAO,UAAP,EAAmB,EAAnB,CAAnC;QACA,KAAK5Q,gBAAL,GAAwB4Q,WAAW,CAAC,IAAD,EAAO,UAAP,EAAmB,EAAnB,CAAnC;QACA,KAAKnS,eAAL,GAAwB4S,UAAU,CAAC,KAAKvR,gBAAN,EAAwB,KAAKE,gBAA7B,CAAlC;MACD;;MAGD3G,MAAM,CAACyY,OAAP,GAAiB,IAAjB;;MAGAzY,MAAM,CAACyN,MAAP,GAAgB,SAASiL,YAAT,GAAwB;QACtC,IAAIC,OAAJ,EAAaC,KAAb;;QAEA,QAAQP,SAAS,CAAC3Y,MAAlB;UACE,KAAK,CAAL;YACEiZ,OAAO,GAAG3Y,MAAM,CAACyY,OAAjB;YACAG,KAAK,GAAGP,SAAS,CAAC,CAAD,CAAjB;YACA;;UAEF,KAAK,CAAL;YACEM,OAAO,GAAGN,SAAS,CAAC,CAAD,CAAnB;YACAO,KAAK,GAAGP,SAAS,CAAC,CAAD,CAAjB;YACA;;UAEF;YACE,MAAM,IAAIzX,aAAJ,CAAkB,sDAAlB,CAAN;QAZJ;;QAeA+X,OAAO,GAAG/V,MAAM,CAACrB,OAAP,CAAeoX,OAAf,CAAV;QACAC,KAAK,GAAGhW,MAAM,CAACrB,OAAP,CAAeqX,KAAf,CAAR;;QAEA,IAAI,CAACD,OAAO,CAACE,KAAR,CAAc,UAAUhU,MAAV,EAAkB;UAAE,OAAOA,MAAM,YAAY7E,MAAzB;QAAkC,CAApE,CAAL,EAA4E;UAC1E,MAAM,IAAIY,aAAJ,CAAkB,2FAAlB,CAAN;QACD;;QAED,IAAI,CAACgY,KAAK,CAACC,KAAN,CAAY,UAAU5T,IAAV,EAAgB;UAAE,OAAOA,IAAI,YAAYlF,IAAvB;QAA8B,CAA5D,CAAL,EAAoE;UAClE,MAAM,IAAIa,aAAJ,CAAkB,oFAAlB,CAAN;QACD;;QAED,OAAO,IAAIZ,MAAJ,CAAW;UAChByX,OAAO,EAAEkB,OADO;UAEhBzM,QAAQ,EAAE0M;QAFM,CAAX,CAAP;MAID,CAjCD;;MAoCAxa,MAAM,CAACD,OAAP,GAAiB6B,MAAjB;IAEC,CA9GmB,EA8GlB;MAAC,YAAW,CAAZ;MAAc,eAAc,CAA5B;MAA8B,UAAS;IAAvC,CA9GkB,CAnqF61B;IAixFn0B,GAAE,CAAC,UAASb,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACjF;MACA;MACA;MACA;MACA;MAGA;;MAGA,IAAI6B,MAAM,GAAGb,OAAO,CAAC,WAAD,CAApB;;MAGAf,MAAM,CAACD,OAAP,GAAiB,IAAI6B,MAAJ,CAAW;QAC1ByX,OAAO,EAAE,CACPtY,OAAO,CAAC,QAAD,CADA;MADiB,CAAX,CAAjB;IAMC,CApB+C,EAoB9C;MAAC,aAAY,CAAb;MAAe,UAAS;IAAxB,CApB8C,CAjxFi0B;IAqyFl1B,GAAE,CAAC,UAASA,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MAClE;MACA;MACA;MACA;MACA;MACA;MACA;MAGA;;MAGA,IAAI6B,MAAM,GAAGb,OAAO,CAAC,WAAD,CAApB;;MAGAf,MAAM,CAACD,OAAP,GAAiB6B,MAAM,CAACyY,OAAP,GAAiB,IAAIzY,MAAJ,CAAW;QAC3CyX,OAAO,EAAE,CACPtY,OAAO,CAAC,gBAAD,CADA,CADkC;QAI3C+M,QAAQ,EAAE,CACR/M,OAAO,CAAC,sBAAD,CADC,EAERA,OAAO,CAAC,mBAAD,CAFC,EAGRA,OAAO,CAAC,qBAAD,CAHC;MAJiC,CAAX,CAAlC;IAWC,CA3BgC,EA2B/B;MAAC,aAAY,CAAb;MAAe,uBAAsB,EAArC;MAAwC,qBAAoB,EAA5D;MAA+D,wBAAuB,EAAtF;MAAyF,kBAAiB;IAA1G,CA3B+B,CAryFg1B;IAg0FhwB,IAAG,CAAC,UAASA,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACrJ;MACA;MACA;MACA;MACA;MAGA;;MAGA,IAAI6B,MAAM,GAAGb,OAAO,CAAC,WAAD,CAApB;;MAGAf,MAAM,CAACD,OAAP,GAAiB,IAAI6B,MAAJ,CAAW;QAC1ByX,OAAO,EAAE,CACPtY,OAAO,CAAC,QAAD,CADA,CADiB;QAI1BoZ,QAAQ,EAAE,CACRpZ,OAAO,CAAC,mBAAD,CADC,EAERA,OAAO,CAAC,eAAD,CAFC,CAJgB;QAQ1B+M,QAAQ,EAAE,CACR/M,OAAO,CAAC,gBAAD,CADC,EAERA,OAAO,CAAC,cAAD,CAFC,EAGRA,OAAO,CAAC,eAAD,CAHC,EAIRA,OAAO,CAAC,aAAD,CAJC;MARgB,CAAX,CAAjB;IAgBC,CA9BmH,EA8BlH;MAAC,aAAY,CAAb;MAAe,kBAAiB,EAAhC;MAAmC,iBAAgB,EAAnD;MAAsD,gBAAe,EAArE;MAAwE,iBAAgB,EAAxF;MAA2F,eAAc,EAAzG;MAA4G,qBAAoB,EAAhI;MAAmI,UAAS;IAA5I,CA9BkH,CAh0F6vB;IA81F/tB,IAAG,CAAC,UAASA,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACtL;MACA;MAGA;;MAGA,IAAI6B,MAAM,GAAGb,OAAO,CAAC,WAAD,CAApB;;MAGAf,MAAM,CAACD,OAAP,GAAiB,IAAI6B,MAAJ,CAAW;QAC1BkM,QAAQ,EAAE,CACR/M,OAAO,CAAC,aAAD,CADC,EAERA,OAAO,CAAC,aAAD,CAFC,EAGRA,OAAO,CAAC,aAAD,CAHC;MADgB,CAAX,CAAjB;IAQC,CAnBoJ,EAmBnJ;MAAC,aAAY,CAAb;MAAe,eAAc,EAA7B;MAAgC,eAAc,EAA9C;MAAiD,eAAc;IAA/D,CAnBmJ,CA91F4tB;IAi3F3yB,IAAG,CAAC,UAASA,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MAC1G;MACA;MACA;MACA;MACA;MACA;MAGA;;MAGA,IAAI6B,MAAM,GAAGb,OAAO,CAAC,WAAD,CAApB;;MAGAf,MAAM,CAACD,OAAP,GAAiB,IAAI6B,MAAJ,CAAW;QAC1ByX,OAAO,EAAE,CACPtY,OAAO,CAAC,YAAD,CADA,CADiB;QAI1BoZ,QAAQ,EAAE,CACRpZ,OAAO,CAAC,cAAD,CADC,EAERA,OAAO,CAAC,cAAD,CAFC,EAGRA,OAAO,CAAC,aAAD,CAHC,EAIRA,OAAO,CAAC,eAAD,CAJC;MAJgB,CAAX,CAAjB;IAYC,CA3BwE,EA2BvE;MAAC,aAAY,CAAb;MAAe,gBAAe,EAA9B;MAAiC,iBAAgB,EAAjD;MAAoD,eAAc,EAAlE;MAAqE,gBAAe,EAApF;MAAuF,cAAa;IAApG,CA3BuE,CAj3FwyB;IA44FtwB,IAAG,CAAC,UAASA,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MAC/I;;MAEA,IAAIyC,aAAa,GAAGzB,OAAO,CAAC,aAAD,CAA3B;;MAEA,IAAI2Z,wBAAwB,GAAG,CAC7B,MAD6B,EAE7B,SAF6B,EAG7B,WAH6B,EAI7B,YAJ6B,EAK7B,WAL6B,EAM7B,WAN6B,EAO7B,cAP6B,EAQ7B,cAR6B,CAA/B;MAWA,IAAIC,eAAe,GAAG,CACpB,QADoB,EAEpB,UAFoB,EAGpB,SAHoB,CAAtB;;MAMA,SAASC,mBAAT,CAA6BlU,GAA7B,EAAkC;QAChC,IAAIxC,MAAM,GAAG,EAAb;;QAEA,IAAIwC,GAAG,KAAK,IAAZ,EAAkB;UAChB7C,MAAM,CAACC,IAAP,CAAY4C,GAAZ,EAAiB4S,OAAjB,CAAyB,UAAU1S,KAAV,EAAiB;YACxCF,GAAG,CAACE,KAAD,CAAH,CAAW0S,OAAX,CAAmB,UAAUnC,KAAV,EAAiB;cAClCjT,MAAM,CAAC4C,MAAM,CAACqQ,KAAD,CAAP,CAAN,GAAwBvQ,KAAxB;YACD,CAFD;UAGD,CAJD;QAKD;;QAED,OAAO1C,MAAP;MACD;;MAED,SAASvC,IAAT,CAAcgF,GAAd,EAAmBY,OAAnB,EAA4B;QAC1BA,OAAO,GAAGA,OAAO,IAAI,EAArB;QAEA1D,MAAM,CAACC,IAAP,CAAYyD,OAAZ,EAAqB+R,OAArB,CAA6B,UAAU5X,IAAV,EAAgB;UAC3C,IAAIgZ,wBAAwB,CAAC1R,OAAzB,CAAiCtH,IAAjC,MAA2C,CAAC,CAAhD,EAAmD;YACjD,MAAM,IAAIc,aAAJ,CAAkB,qBAAqBd,IAArB,GAA4B,6BAA5B,GAA4DiF,GAA5D,GAAkE,cAApF,CAAN;UACD;QACF,CAJD,EAH0B,CAS1B;;QACA,KAAKA,GAAL,GAAoBA,GAApB;QACA,KAAKkO,IAAL,GAAoBtN,OAAO,CAAC,MAAD,CAAP,IAA2B,IAA/C;;QACA,KAAK+B,OAAL,GAAoB/B,OAAO,CAAC,SAAD,CAAP,IAA2B,YAAY;UAAE,OAAO,IAAP;QAAc,CAA3E;;QACA,KAAKyQ,SAAL,GAAoBzQ,OAAO,CAAC,WAAD,CAAP,IAA2B,UAAUsT,IAAV,EAAgB;UAAE,OAAOA,IAAP;QAAc,CAA/E;;QACA,KAAK7M,UAAL,GAAoBzG,OAAO,CAAC,YAAD,CAAP,IAA2B,IAA/C;QACA,KAAK0G,SAAL,GAAoB1G,OAAO,CAAC,WAAD,CAAP,IAA2B,IAA/C;QACA,KAAK2G,SAAL,GAAoB3G,OAAO,CAAC,WAAD,CAAP,IAA2B,IAA/C;QACA,KAAK4G,YAAL,GAAoB5G,OAAO,CAAC,cAAD,CAAP,IAA2B,IAA/C;QACA,KAAKN,YAAL,GAAoB2T,mBAAmB,CAACrT,OAAO,CAAC,cAAD,CAAP,IAA2B,IAA5B,CAAvC;;QAEA,IAAIoT,eAAe,CAAC3R,OAAhB,CAAwB,KAAK6L,IAA7B,MAAuC,CAAC,CAA5C,EAA+C;UAC7C,MAAM,IAAIrS,aAAJ,CAAkB,mBAAmB,KAAKqS,IAAxB,GAA+B,sBAA/B,GAAwDlO,GAAxD,GAA8D,cAAhF,CAAN;QACD;MACF;;MAED3G,MAAM,CAACD,OAAP,GAAiB4B,IAAjB;IAEC,CA/D6G,EA+D5G;MAAC,eAAc;IAAf,CA/D4G,CA54FmwB;IA28F51B,IAAG,CAAC,UAASZ,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACzD;MAEA;;MAEA,IAAI+a,UAAJ;;MAEA,IAAI;QACF;QACA,IAAIC,QAAQ,GAAGha,OAAf;QACA+Z,UAAU,GAAGC,QAAQ,CAAC,QAAD,CAAR,CAAmBC,MAAhC;MACD,CAJD,CAIE,OAAOC,EAAP,EAAW,CAAE;;MAEf,IAAItZ,IAAI,GAASZ,OAAO,CAAC,SAAD,CAAxB,CAbyD,CAgBzD;;;MACA,IAAIma,UAAU,GAAG,uEAAjB;;MAGA,SAASC,iBAAT,CAA2BN,IAA3B,EAAiC;QAC/B,IAAIA,IAAI,KAAK,IAAb,EAAmB,OAAO,KAAP;QAEnB,IAAI1Z,IAAJ;QAAA,IAAUia,GAAV;QAAA,IAAeC,MAAM,GAAG,CAAxB;QAAA,IAA2B3T,GAAG,GAAGmT,IAAI,CAACvZ,MAAtC;QAAA,IAA8CoF,GAAG,GAAGwU,UAApD,CAH+B,CAK/B;;QACA,KAAKE,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAG1T,GAApB,EAAyB0T,GAAG,EAA5B,EAAgC;UAC9Bja,IAAI,GAAGuF,GAAG,CAACsC,OAAJ,CAAY6R,IAAI,CAAC5B,MAAL,CAAYmC,GAAZ,CAAZ,CAAP,CAD8B,CAG9B;;UACA,IAAIja,IAAI,GAAG,EAAX,EAAe,SAJe,CAM9B;;UACA,IAAIA,IAAI,GAAG,CAAX,EAAc,OAAO,KAAP;UAEdka,MAAM,IAAI,CAAV;QACD,CAhB8B,CAkB/B;;;QACA,OAAQA,MAAM,GAAG,CAAV,KAAiB,CAAxB;MACD;;MAED,SAASC,mBAAT,CAA6BT,IAA7B,EAAmC;QACjC,IAAIO,GAAJ;QAAA,IAASG,QAAT;QAAA,IACIzM,KAAK,GAAG+L,IAAI,CAACxP,OAAL,CAAa,UAAb,EAAyB,EAAzB,CADZ;QAAA,IAC0C;QACtC3D,GAAG,GAAGoH,KAAK,CAACxN,MAFhB;QAAA,IAGIoF,GAAG,GAAGwU,UAHV;QAAA,IAIIM,IAAI,GAAG,CAJX;QAAA,IAKItX,MAAM,GAAG,EALb,CADiC,CAQjC;;QAEA,KAAKkX,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAG1T,GAApB,EAAyB0T,GAAG,EAA5B,EAAgC;UAC9B,IAAKA,GAAG,GAAG,CAAN,KAAY,CAAb,IAAmBA,GAAvB,EAA4B;YAC1BlX,MAAM,CAAC2K,IAAP,CAAa2M,IAAI,IAAI,EAAT,GAAe,IAA3B;YACAtX,MAAM,CAAC2K,IAAP,CAAa2M,IAAI,IAAI,CAAT,GAAc,IAA1B;YACAtX,MAAM,CAAC2K,IAAP,CAAY2M,IAAI,GAAG,IAAnB;UACD;;UAEDA,IAAI,GAAIA,IAAI,IAAI,CAAT,GAAc9U,GAAG,CAACsC,OAAJ,CAAY8F,KAAK,CAACmK,MAAN,CAAamC,GAAb,CAAZ,CAArB;QACD,CAlBgC,CAoBjC;;;QAEAG,QAAQ,GAAI7T,GAAG,GAAG,CAAP,GAAY,CAAvB;;QAEA,IAAI6T,QAAQ,KAAK,CAAjB,EAAoB;UAClBrX,MAAM,CAAC2K,IAAP,CAAa2M,IAAI,IAAI,EAAT,GAAe,IAA3B;UACAtX,MAAM,CAAC2K,IAAP,CAAa2M,IAAI,IAAI,CAAT,GAAc,IAA1B;UACAtX,MAAM,CAAC2K,IAAP,CAAY2M,IAAI,GAAG,IAAnB;QACD,CAJD,MAIO,IAAID,QAAQ,KAAK,EAAjB,EAAqB;UAC1BrX,MAAM,CAAC2K,IAAP,CAAa2M,IAAI,IAAI,EAAT,GAAe,IAA3B;UACAtX,MAAM,CAAC2K,IAAP,CAAa2M,IAAI,IAAI,CAAT,GAAc,IAA1B;QACD,CAHM,MAGA,IAAID,QAAQ,KAAK,EAAjB,EAAqB;UAC1BrX,MAAM,CAAC2K,IAAP,CAAa2M,IAAI,IAAI,CAAT,GAAc,IAA1B;QACD,CAjCgC,CAmCjC;;;QACA,IAAIV,UAAJ,EAAgB;UACd;UACA,OAAOA,UAAU,CAACW,IAAX,GAAkBX,UAAU,CAACW,IAAX,CAAgBvX,MAAhB,CAAlB,GAA4C,IAAI4W,UAAJ,CAAe5W,MAAf,CAAnD;QACD;;QAED,OAAOA,MAAP;MACD;;MAED,SAASwX,mBAAT,CAA6B3O;MAAO;MAApC,EAAiD;QAC/C,IAAI7I,MAAM,GAAG,EAAb;QAAA,IAAiBsX,IAAI,GAAG,CAAxB;QAAA,IAA2BJ,GAA3B;QAAA,IAAgCrC,IAAhC;QAAA,IACIrR,GAAG,GAAGqF,MAAM,CAACzL,MADjB;QAAA,IAEIoF,GAAG,GAAGwU,UAFV,CAD+C,CAK/C;;QAEA,KAAKE,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAG1T,GAApB,EAAyB0T,GAAG,EAA5B,EAAgC;UAC9B,IAAKA,GAAG,GAAG,CAAN,KAAY,CAAb,IAAmBA,GAAvB,EAA4B;YAC1BlX,MAAM,IAAIwC,GAAG,CAAE8U,IAAI,IAAI,EAAT,GAAe,IAAhB,CAAb;YACAtX,MAAM,IAAIwC,GAAG,CAAE8U,IAAI,IAAI,EAAT,GAAe,IAAhB,CAAb;YACAtX,MAAM,IAAIwC,GAAG,CAAE8U,IAAI,IAAI,CAAT,GAAc,IAAf,CAAb;YACAtX,MAAM,IAAIwC,GAAG,CAAC8U,IAAI,GAAG,IAAR,CAAb;UACD;;UAEDA,IAAI,GAAG,CAACA,IAAI,IAAI,CAAT,IAAczO,MAAM,CAACqO,GAAD,CAA3B;QACD,CAhB8C,CAkB/C;;;QAEArC,IAAI,GAAGrR,GAAG,GAAG,CAAb;;QAEA,IAAIqR,IAAI,KAAK,CAAb,EAAgB;UACd7U,MAAM,IAAIwC,GAAG,CAAE8U,IAAI,IAAI,EAAT,GAAe,IAAhB,CAAb;UACAtX,MAAM,IAAIwC,GAAG,CAAE8U,IAAI,IAAI,EAAT,GAAe,IAAhB,CAAb;UACAtX,MAAM,IAAIwC,GAAG,CAAE8U,IAAI,IAAI,CAAT,GAAc,IAAf,CAAb;UACAtX,MAAM,IAAIwC,GAAG,CAAC8U,IAAI,GAAG,IAAR,CAAb;QACD,CALD,MAKO,IAAIzC,IAAI,KAAK,CAAb,EAAgB;UACrB7U,MAAM,IAAIwC,GAAG,CAAE8U,IAAI,IAAI,EAAT,GAAe,IAAhB,CAAb;UACAtX,MAAM,IAAIwC,GAAG,CAAE8U,IAAI,IAAI,CAAT,GAAc,IAAf,CAAb;UACAtX,MAAM,IAAIwC,GAAG,CAAE8U,IAAI,IAAI,CAAT,GAAc,IAAf,CAAb;UACAtX,MAAM,IAAIwC,GAAG,CAAC,EAAD,CAAb;QACD,CALM,MAKA,IAAIqS,IAAI,KAAK,CAAb,EAAgB;UACrB7U,MAAM,IAAIwC,GAAG,CAAE8U,IAAI,IAAI,CAAT,GAAc,IAAf,CAAb;UACAtX,MAAM,IAAIwC,GAAG,CAAE8U,IAAI,IAAI,CAAT,GAAc,IAAf,CAAb;UACAtX,MAAM,IAAIwC,GAAG,CAAC,EAAD,CAAb;UACAxC,MAAM,IAAIwC,GAAG,CAAC,EAAD,CAAb;QACD;;QAED,OAAOxC,MAAP;MACD;;MAED,SAASyX,QAAT,CAAkB5O,MAAlB,EAA0B;QACxB,OAAO+N,UAAU,IAAIA,UAAU,CAACc,QAAX,CAAoB7O,MAApB,CAArB;MACD;;MAED/M,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,0BAAT,EAAqC;QACpDkT,IAAI,EAAE,QAD8C;QAEpDvL,OAAO,EAAE6R,iBAF2C;QAGpDnD,SAAS,EAAEsD,mBAHyC;QAIpDrN,SAAS,EAAE0N,QAJyC;QAKpDzN,SAAS,EAAEwN;MALyC,CAArC,CAAjB;IAQC,CA5IuB,EA4ItB;MAAC,WAAU;IAAX,CA5IsB,CA38Fy1B;IAulG/1B,IAAG,CAAC,UAAS3a,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACtD;;MAEA,IAAI4B,IAAI,GAAGZ,OAAO,CAAC,SAAD,CAAlB;;MAEA,SAAS8a,kBAAT,CAA4BhB,IAA5B,EAAkC;QAChC,IAAIA,IAAI,KAAK,IAAb,EAAmB,OAAO,KAAP;QAEnB,IAAInT,GAAG,GAAGmT,IAAI,CAACvZ,MAAf;QAEA,OAAQoG,GAAG,KAAK,CAAR,KAAcmT,IAAI,KAAK,MAAT,IAAmBA,IAAI,KAAK,MAA5B,IAAsCA,IAAI,KAAK,MAA7D,CAAD,IACCnT,GAAG,KAAK,CAAR,KAAcmT,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,OAA7B,IAAwCA,IAAI,KAAK,OAA/D,CADR;MAED;;MAED,SAASiB,oBAAT,CAA8BjB,IAA9B,EAAoC;QAClC,OAAOA,IAAI,KAAK,MAAT,IACAA,IAAI,KAAK,MADT,IAEAA,IAAI,KAAK,MAFhB;MAGD;;MAED,SAASkB,SAAT,CAAmBhP,MAAnB,EAA2B;QACzB,OAAOlJ,MAAM,CAACa,SAAP,CAAiBC,QAAjB,CAA0BtD,IAA1B,CAA+B0L,MAA/B,MAA2C,kBAAlD;MACD;;MAED/M,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,wBAAT,EAAmC;QAClDkT,IAAI,EAAE,QAD4C;QAElDvL,OAAO,EAAEuS,kBAFyC;QAGlD7D,SAAS,EAAE8D,oBAHuC;QAIlD7N,SAAS,EAAE8N,SAJuC;QAKlD7N,SAAS,EAAE;UACT8N,SAAS,EAAE,UAAUjP,MAAV,EAAkB;YAAE,OAAOA,MAAM,GAAG,MAAH,GAAY,OAAzB;UAAmC,CADzD;UAETkP,SAAS,EAAE,UAAUlP,MAAV,EAAkB;YAAE,OAAOA,MAAM,GAAG,MAAH,GAAY,OAAzB;UAAmC,CAFzD;UAGTmP,SAAS,EAAE,UAAUnP,MAAV,EAAkB;YAAE,OAAOA,MAAM,GAAG,MAAH,GAAY,OAAzB;UAAmC;QAHzD,CALuC;QAUlDoB,YAAY,EAAE;MAVoC,CAAnC,CAAjB;IAaC,CArCoB,EAqCnB;MAAC,WAAU;IAAX,CArCmB,CAvlG41B;IA4nG/1B,IAAG,CAAC,UAASpN,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACtD;;MAEA,IAAIyE,MAAM,GAAGzD,OAAO,CAAC,WAAD,CAApB;;MACA,IAAIY,IAAI,GAAKZ,OAAO,CAAC,SAAD,CAApB;;MAEA,IAAIob,kBAAkB,GAAG,IAAIC,MAAJ,EACvB;MACA,mEACA;MACA;MACA,iCAHA,GAIA;MACA,+CALA,GAMA;MACA,0BAPA,GAQA;MACA,uBAXuB,CAAzB;;MAaA,SAASC,gBAAT,CAA0BxB,IAA1B,EAAgC;QAC9B,IAAIA,IAAI,KAAK,IAAb,EAAmB,OAAO,KAAP;;QAEnB,IAAI,CAACsB,kBAAkB,CAACpS,IAAnB,CAAwB8Q,IAAxB,CAAD,IACA;QACA;QACAA,IAAI,CAACA,IAAI,CAACvZ,MAAL,GAAc,CAAf,CAAJ,KAA0B,GAH9B,EAGmC;UACjC,OAAO,KAAP;QACD;;QAED,OAAO,IAAP;MACD;;MAED,SAASgb,kBAAT,CAA4BzB,IAA5B,EAAkC;QAChC,IAAI0B,KAAJ,EAAWC,IAAX,EAAiBC,IAAjB,EAAuBC,MAAvB;QAEAH,KAAK,GAAI1B,IAAI,CAACxP,OAAL,CAAa,IAAb,EAAmB,EAAnB,EAAuBsR,WAAvB,EAAT;QACAH,IAAI,GAAKD,KAAK,CAAC,CAAD,CAAL,KAAa,GAAb,GAAmB,CAAC,CAApB,GAAwB,CAAjC;QACAG,MAAM,GAAG,EAAT;;QAEA,IAAI,KAAK1T,OAAL,CAAauT,KAAK,CAAC,CAAD,CAAlB,KAA0B,CAA9B,EAAiC;UAC/BA,KAAK,GAAGA,KAAK,CAACxV,KAAN,CAAY,CAAZ,CAAR;QACD;;QAED,IAAIwV,KAAK,KAAK,MAAd,EAAsB;UACpB,OAAQC,IAAI,KAAK,CAAV,GAAelY,MAAM,CAACsY,iBAAtB,GAA0CtY,MAAM,CAACC,iBAAxD;QAED,CAHD,MAGO,IAAIgY,KAAK,KAAK,MAAd,EAAsB;UAC3B,OAAOM,GAAP;QAED,CAHM,MAGA,IAAIN,KAAK,CAACvT,OAAN,CAAc,GAAd,KAAsB,CAA1B,EAA6B;UAClCuT,KAAK,CAACO,KAAN,CAAY,GAAZ,EAAiBxD,OAAjB,CAAyB,UAAUyD,CAAV,EAAa;YACpCL,MAAM,CAACM,OAAP,CAAeC,UAAU,CAACF,CAAD,EAAI,EAAJ,CAAzB;UACD,CAFD;UAIAR,KAAK,GAAG,GAAR;UACAE,IAAI,GAAG,CAAP;UAEAC,MAAM,CAACpD,OAAP,CAAe,UAAU4D,CAAV,EAAa;YAC1BX,KAAK,IAAIW,CAAC,GAAGT,IAAb;YACAA,IAAI,IAAI,EAAR;UACD,CAHD;UAKA,OAAOD,IAAI,GAAGD,KAAd;QAED;;QACD,OAAOC,IAAI,GAAGS,UAAU,CAACV,KAAD,EAAQ,EAAR,CAAxB;MACD;;MAGD,IAAIY,sBAAsB,GAAG,eAA7B;;MAEA,SAASC,kBAAT,CAA4BrQ,MAA5B,EAAoCnG,KAApC,EAA2C;QACzC,IAAIyW,GAAJ;;QAEA,IAAIC,KAAK,CAACvQ,MAAD,CAAT,EAAmB;UACjB,QAAQnG,KAAR;YACE,KAAK,WAAL;cAAkB,OAAO,MAAP;;YAClB,KAAK,WAAL;cAAkB,OAAO,MAAP;;YAClB,KAAK,WAAL;cAAkB,OAAO,MAAP;UAHpB;QAKD,CAND,MAMO,IAAItC,MAAM,CAACsY,iBAAP,KAA6B7P,MAAjC,EAAyC;UAC9C,QAAQnG,KAAR;YACE,KAAK,WAAL;cAAkB,OAAO,MAAP;;YAClB,KAAK,WAAL;cAAkB,OAAO,MAAP;;YAClB,KAAK,WAAL;cAAkB,OAAO,MAAP;UAHpB;QAKD,CANM,MAMA,IAAItC,MAAM,CAACC,iBAAP,KAA6BwI,MAAjC,EAAyC;UAC9C,QAAQnG,KAAR;YACE,KAAK,WAAL;cAAkB,OAAO,OAAP;;YAClB,KAAK,WAAL;cAAkB,OAAO,OAAP;;YAClB,KAAK,WAAL;cAAkB,OAAO,OAAP;UAHpB;QAKD,CANM,MAMA,IAAIpC,MAAM,CAACJ,cAAP,CAAsB2I,MAAtB,CAAJ,EAAmC;UACxC,OAAO,MAAP;QACD;;QAEDsQ,GAAG,GAAGtQ,MAAM,CAACpI,QAAP,CAAgB,EAAhB,CAAN,CAzByC,CA2BzC;QACA;;QAEA,OAAOwY,sBAAsB,CAACpT,IAAvB,CAA4BsT,GAA5B,IAAmCA,GAAG,CAAChS,OAAJ,CAAY,GAAZ,EAAiB,IAAjB,CAAnC,GAA4DgS,GAAnE;MACD;;MAED,SAASE,OAAT,CAAiBxQ,MAAjB,EAAyB;QACvB,OAAQlJ,MAAM,CAACa,SAAP,CAAiBC,QAAjB,CAA0BtD,IAA1B,CAA+B0L,MAA/B,MAA2C,iBAA5C,KACCA,MAAM,GAAG,CAAT,KAAe,CAAf,IAAoBvI,MAAM,CAACJ,cAAP,CAAsB2I,MAAtB,CADrB,CAAP;MAED;;MAED/M,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,yBAAT,EAAoC;QACnDkT,IAAI,EAAE,QAD6C;QAEnDvL,OAAO,EAAE+S,gBAF0C;QAGnDrE,SAAS,EAAEsE,kBAHwC;QAInDrO,SAAS,EAAEsP,OAJwC;QAKnDrP,SAAS,EAAEkP,kBALwC;QAMnDjP,YAAY,EAAE;MANqC,CAApC,CAAjB;IASC,CAtHoB,EAsHnB;MAAC,aAAY,CAAb;MAAe,WAAU;IAAzB,CAtHmB,CA5nG41B;IAkvGj1B,IAAG,CAAC,UAASpN,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACpE;;MAEA,IAAIyE,MAAM,GAAGzD,OAAO,CAAC,WAAD,CAApB;;MACA,IAAIY,IAAI,GAAKZ,OAAO,CAAC,SAAD,CAApB;;MAEA,SAASyc,SAAT,CAAmB1c,CAAnB,EAAsB;QACpB,OAAS;QAAI;QAAJ,GAAeA,CAAhB,IAAuBA,CAAC,IAAI;QAAI;QAAjC,GACE;QAAI;QAAJ,GAAeA,CAAhB,IAAuBA,CAAC,IAAI;QAAI;QADjC,GAEE;QAAI;QAAJ,GAAeA,CAAhB,IAAuBA,CAAC,IAAI;QAAI;QAFxC;MAGD;;MAED,SAAS2c,SAAT,CAAmB3c,CAAnB,EAAsB;QACpB,OAAS;QAAI;QAAJ,GAAeA,CAAhB,IAAuBA,CAAC,IAAI;QAAI;QAAxC;MACD;;MAED,SAAS4c,SAAT,CAAmB5c,CAAnB,EAAsB;QACpB,OAAS;QAAI;QAAJ,GAAeA,CAAhB,IAAuBA,CAAC,IAAI;QAAI;QAAxC;MACD;;MAED,SAAS6c,kBAAT,CAA4B9C,IAA5B,EAAkC;QAChC,IAAIA,IAAI,KAAK,IAAb,EAAmB,OAAO,KAAP;QAEnB,IAAInT,GAAG,GAAGmT,IAAI,CAACvZ,MAAf;QAAA,IACIoC,KAAK,GAAG,CADZ;QAAA,IAEIka,SAAS,GAAG,KAFhB;QAAA,IAGIlK,EAHJ;QAKA,IAAI,CAAChM,GAAL,EAAU,OAAO,KAAP;QAEVgM,EAAE,GAAGmH,IAAI,CAACnX,KAAD,CAAT,CAVgC,CAYhC;;QACA,IAAIgQ,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAAzB,EAA8B;UAC5BA,EAAE,GAAGmH,IAAI,CAAC,EAAEnX,KAAH,CAAT;QACD;;QAED,IAAIgQ,EAAE,KAAK,GAAX,EAAgB;UACd;UACA,IAAIhQ,KAAK,GAAG,CAAR,KAAcgE,GAAlB,EAAuB,OAAO,IAAP;UACvBgM,EAAE,GAAGmH,IAAI,CAAC,EAAEnX,KAAH,CAAT,CAHc,CAKd;;UAEA,IAAIgQ,EAAE,KAAK,GAAX,EAAgB;YACd;YACAhQ,KAAK;;YAEL,OAAOA,KAAK,GAAGgE,GAAf,EAAoBhE,KAAK,EAAzB,EAA6B;cAC3BgQ,EAAE,GAAGmH,IAAI,CAACnX,KAAD,CAAT;cACA,IAAIgQ,EAAE,KAAK,GAAX,EAAgB;cAChB,IAAIA,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAAzB,EAA8B,OAAO,KAAP;cAC9BkK,SAAS,GAAG,IAAZ;YACD;;YACD,OAAOA,SAAS,IAAIlK,EAAE,KAAK,GAA3B;UACD;;UAGD,IAAIA,EAAE,KAAK,GAAX,EAAgB;YACd;YACAhQ,KAAK;;YAEL,OAAOA,KAAK,GAAGgE,GAAf,EAAoBhE,KAAK,EAAzB,EAA6B;cAC3BgQ,EAAE,GAAGmH,IAAI,CAACnX,KAAD,CAAT;cACA,IAAIgQ,EAAE,KAAK,GAAX,EAAgB;cAChB,IAAI,CAAC8J,SAAS,CAAC3C,IAAI,CAAC7P,UAAL,CAAgBtH,KAAhB,CAAD,CAAd,EAAwC,OAAO,KAAP;cACxCka,SAAS,GAAG,IAAZ;YACD;;YACD,OAAOA,SAAS,IAAIlK,EAAE,KAAK,GAA3B;UACD,CAhCa,CAkCd;;;UACA,OAAOhQ,KAAK,GAAGgE,GAAf,EAAoBhE,KAAK,EAAzB,EAA6B;YAC3BgQ,EAAE,GAAGmH,IAAI,CAACnX,KAAD,CAAT;YACA,IAAIgQ,EAAE,KAAK,GAAX,EAAgB;YAChB,IAAI,CAAC+J,SAAS,CAAC5C,IAAI,CAAC7P,UAAL,CAAgBtH,KAAhB,CAAD,CAAd,EAAwC,OAAO,KAAP;YACxCka,SAAS,GAAG,IAAZ;UACD;;UACD,OAAOA,SAAS,IAAIlK,EAAE,KAAK,GAA3B;QACD,CA3D+B,CA6DhC;QAEA;;;QACA,IAAIA,EAAE,KAAK,GAAX,EAAgB,OAAO,KAAP;;QAEhB,OAAOhQ,KAAK,GAAGgE,GAAf,EAAoBhE,KAAK,EAAzB,EAA6B;UAC3BgQ,EAAE,GAAGmH,IAAI,CAACnX,KAAD,CAAT;UACA,IAAIgQ,EAAE,KAAK,GAAX,EAAgB;UAChB,IAAIA,EAAE,KAAK,GAAX,EAAgB;;UAChB,IAAI,CAACgK,SAAS,CAAC7C,IAAI,CAAC7P,UAAL,CAAgBtH,KAAhB,CAAD,CAAd,EAAwC;YACtC,OAAO,KAAP;UACD;;UACDka,SAAS,GAAG,IAAZ;QACD,CA1E+B,CA4EhC;;;QACA,IAAI,CAACA,SAAD,IAAclK,EAAE,KAAK,GAAzB,EAA8B,OAAO,KAAP,CA7EE,CA+EhC;;QACA,IAAIA,EAAE,KAAK,GAAX,EAAgB,OAAO,IAAP,CAhFgB,CAkFhC;;QACA,OAAO,oBAAoB3J,IAApB,CAAyB8Q,IAAI,CAAC9T,KAAL,CAAWrD,KAAX,CAAzB,CAAP;MACD;;MAED,SAASma,oBAAT,CAA8BhD,IAA9B,EAAoC;QAClC,IAAI0B,KAAK,GAAG1B,IAAZ;QAAA,IAAkB2B,IAAI,GAAG,CAAzB;QAAA,IAA4B9I,EAA5B;QAAA,IAAgC+I,IAAhC;QAAA,IAAsCC,MAAM,GAAG,EAA/C;;QAEA,IAAIH,KAAK,CAACvT,OAAN,CAAc,GAAd,MAAuB,CAAC,CAA5B,EAA+B;UAC7BuT,KAAK,GAAGA,KAAK,CAAClR,OAAN,CAAc,IAAd,EAAoB,EAApB,CAAR;QACD;;QAEDqI,EAAE,GAAG6I,KAAK,CAAC,CAAD,CAAV;;QAEA,IAAI7I,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAAzB,EAA8B;UAC5B,IAAIA,EAAE,KAAK,GAAX,EAAgB8I,IAAI,GAAG,CAAC,CAAR;UAChBD,KAAK,GAAGA,KAAK,CAACxV,KAAN,CAAY,CAAZ,CAAR;UACA2M,EAAE,GAAG6I,KAAK,CAAC,CAAD,CAAV;QACD;;QAED,IAAIA,KAAK,KAAK,GAAd,EAAmB,OAAO,CAAP;;QAEnB,IAAI7I,EAAE,KAAK,GAAX,EAAgB;UACd,IAAI6I,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsB,OAAOC,IAAI,GAAGnK,QAAQ,CAACkK,KAAK,CAACxV,KAAN,CAAY,CAAZ,CAAD,EAAiB,CAAjB,CAAtB;UACtB,IAAIwV,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsB,OAAOC,IAAI,GAAGnK,QAAQ,CAACkK,KAAD,EAAQ,EAAR,CAAtB;UACtB,OAAOC,IAAI,GAAGnK,QAAQ,CAACkK,KAAD,EAAQ,CAAR,CAAtB;QACD;;QAED,IAAIA,KAAK,CAACvT,OAAN,CAAc,GAAd,MAAuB,CAAC,CAA5B,EAA+B;UAC7BuT,KAAK,CAACO,KAAN,CAAY,GAAZ,EAAiBxD,OAAjB,CAAyB,UAAUyD,CAAV,EAAa;YACpCL,MAAM,CAACM,OAAP,CAAe3K,QAAQ,CAAC0K,CAAD,EAAI,EAAJ,CAAvB;UACD,CAFD;UAIAR,KAAK,GAAG,CAAR;UACAE,IAAI,GAAG,CAAP;UAEAC,MAAM,CAACpD,OAAP,CAAe,UAAU4D,CAAV,EAAa;YAC1BX,KAAK,IAAKW,CAAC,GAAGT,IAAd;YACAA,IAAI,IAAI,EAAR;UACD,CAHD;UAKA,OAAOD,IAAI,GAAGD,KAAd;QAED;;QAED,OAAOC,IAAI,GAAGnK,QAAQ,CAACkK,KAAD,EAAQ,EAAR,CAAtB;MACD;;MAED,SAASuB,SAAT,CAAmB/Q,MAAnB,EAA2B;QACzB,OAAQlJ,MAAM,CAACa,SAAP,CAAiBC,QAAjB,CAA0BtD,IAA1B,CAA+B0L,MAA/B,CAAD,KAA6C,iBAA7C,IACCA,MAAM,GAAG,CAAT,KAAe,CAAf,IAAoB,CAACvI,MAAM,CAACJ,cAAP,CAAsB2I,MAAtB,CAD7B;MAED;;MAED/M,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,uBAAT,EAAkC;QACjDkT,IAAI,EAAE,QAD2C;QAEjDvL,OAAO,EAAEqU,kBAFwC;QAGjD3F,SAAS,EAAE6F,oBAHsC;QAIjD5P,SAAS,EAAE6P,SAJsC;QAKjD5P,SAAS,EAAE;UACT6P,MAAM,EAAO,UAAU3N,GAAV,EAAe;YAAE,OAAOA,GAAG,IAAI,CAAP,GAAW,OAAOA,GAAG,CAACzL,QAAJ,CAAa,CAAb,CAAlB,GAAoC,QAAQyL,GAAG,CAACzL,QAAJ,CAAa,CAAb,EAAgBoC,KAAhB,CAAsB,CAAtB,CAAnD;UAA8E,CADnG;UAETiX,KAAK,EAAQ,UAAU5N,GAAV,EAAe;YAAE,OAAOA,GAAG,IAAI,CAAP,GAAW,MAAOA,GAAG,CAACzL,QAAJ,CAAa,CAAb,CAAlB,GAAoC,OAAQyL,GAAG,CAACzL,QAAJ,CAAa,CAAb,EAAgBoC,KAAhB,CAAsB,CAAtB,CAAnD;UAA8E,CAFnG;UAGTkX,OAAO,EAAM,UAAU7N,GAAV,EAAe;YAAE,OAAOA,GAAG,CAACzL,QAAJ,CAAa,EAAb,CAAP;UAA0B,CAH/C;;UAIT;UACAuZ,WAAW,EAAE,UAAU9N,GAAV,EAAe;YAAE,OAAOA,GAAG,IAAI,CAAP,GAAW,OAAOA,GAAG,CAACzL,QAAJ,CAAa,EAAb,EAAiB0C,WAAjB,EAAlB,GAAoD,QAAQ+I,GAAG,CAACzL,QAAJ,CAAa,EAAb,EAAiB0C,WAAjB,GAA+BN,KAA/B,CAAqC,CAArC,CAAnE;UAA6G;QALlI,CALsC;QAYjDoH,YAAY,EAAE,SAZmC;QAajDlH,YAAY,EAAE;UACZ8W,MAAM,EAAO,CAAE,CAAF,EAAM,KAAN,CADD;UAEZC,KAAK,EAAQ,CAAE,CAAF,EAAM,KAAN,CAFD;UAGZC,OAAO,EAAM,CAAE,EAAF,EAAM,KAAN,CAHD;UAIZC,WAAW,EAAE,CAAE,EAAF,EAAM,KAAN;QAJD;MAbmC,CAAlC,CAAjB;IAqBC,CA/KkC,EA+KjC;MAAC,aAAY,CAAb;MAAe,WAAU;IAAzB,CA/KiC,CAlvG80B;IAi6Gj1B,IAAG,CAAC,UAASnd,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACpE;;MAEA,IAAIoe,OAAJ,CAHoE,CAKpE;MACA;MACA;MACA;MACA;MACA;MACA;;MACA,IAAI;QACF;QACA,IAAIpD,QAAQ,GAAGha,OAAf;QACAod,OAAO,GAAGpD,QAAQ,CAAC,SAAD,CAAlB;MACD,CAJD,CAIE,OAAOqD,CAAP,EAAU;QACV;;QACA;QACA,IAAI,OAAOhe,MAAP,KAAkB,WAAtB,EAAmC+d,OAAO,GAAG/d,MAAM,CAAC+d,OAAjB;MACpC;;MAED,IAAIxc,IAAI,GAAGZ,OAAO,CAAC,YAAD,CAAlB;;MAEA,SAASsd,yBAAT,CAAmCxD,IAAnC,EAAyC;QACvC,IAAIA,IAAI,KAAK,IAAb,EAAmB,OAAO,KAAP;;QAEnB,IAAI;UACF,IAAIpX,MAAM,GAAG,MAAMoX,IAAN,GAAa,GAA1B;UAAA,IACIyD,GAAG,GAAMH,OAAO,CAACtb,KAAR,CAAcY,MAAd,EAAsB;YAAE8a,KAAK,EAAE;UAAT,CAAtB,CADb;;UAGA,IAAID,GAAG,CAACzX,IAAJ,KAAgC,SAAhC,IACAyX,GAAG,CAACE,IAAJ,CAASld,MAAT,KAAgC,CADhC,IAEAgd,GAAG,CAACE,IAAJ,CAAS,CAAT,EAAY3X,IAAZ,KAAgC,qBAFhC,IAGCyX,GAAG,CAACE,IAAJ,CAAS,CAAT,EAAYC,UAAZ,CAAuB5X,IAAvB,KAAgC,yBAAhC,IACCyX,GAAG,CAACE,IAAJ,CAAS,CAAT,EAAYC,UAAZ,CAAuB5X,IAAvB,KAAgC,oBAJtC,EAI6D;YAC3D,OAAO,KAAP;UACD;;UAED,OAAO,IAAP;QACD,CAbD,CAaE,OAAO6X,GAAP,EAAY;UACZ,OAAO,KAAP;QACD;MACF;;MAED,SAASC,2BAAT,CAAqC9D,IAArC,EAA2C;QACzC;QAEA,IAAIpX,MAAM,GAAG,MAAMoX,IAAN,GAAa,GAA1B;QAAA,IACIyD,GAAG,GAAMH,OAAO,CAACtb,KAAR,CAAcY,MAAd,EAAsB;UAAE8a,KAAK,EAAE;QAAT,CAAtB,CADb;QAAA,IAEIK,MAAM,GAAG,EAFb;QAAA,IAGIJ,IAHJ;;QAKA,IAAIF,GAAG,CAACzX,IAAJ,KAAgC,SAAhC,IACAyX,GAAG,CAACE,IAAJ,CAASld,MAAT,KAAgC,CADhC,IAEAgd,GAAG,CAACE,IAAJ,CAAS,CAAT,EAAY3X,IAAZ,KAAgC,qBAFhC,IAGCyX,GAAG,CAACE,IAAJ,CAAS,CAAT,EAAYC,UAAZ,CAAuB5X,IAAvB,KAAgC,yBAAhC,IACCyX,GAAG,CAACE,IAAJ,CAAS,CAAT,EAAYC,UAAZ,CAAuB5X,IAAvB,KAAgC,oBAJtC,EAI6D;UAC3D,MAAM,IAAI3F,KAAJ,CAAU,4BAAV,CAAN;QACD;;QAEDod,GAAG,CAACE,IAAJ,CAAS,CAAT,EAAYC,UAAZ,CAAuBG,MAAvB,CAA8BtF,OAA9B,CAAsC,UAAUuF,KAAV,EAAiB;UACrDD,MAAM,CAAC/P,IAAP,CAAYgQ,KAAK,CAACnd,IAAlB;QACD,CAFD;QAIA8c,IAAI,GAAGF,GAAG,CAACE,IAAJ,CAAS,CAAT,EAAYC,UAAZ,CAAuBD,IAAvB,CAA4BD,KAAnC,CApByC,CAsBzC;QACA;;QACA,IAAID,GAAG,CAACE,IAAJ,CAAS,CAAT,EAAYC,UAAZ,CAAuBD,IAAvB,CAA4B3X,IAA5B,KAAqC,gBAAzC,EAA2D;UACzD;UACA,OAAO,IAAIiY,QAAJ,CAAaF,MAAb,EAAqBnb,MAAM,CAACsD,KAAP,CAAayX,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAvB,EAA0BA,IAAI,CAAC,CAAD,CAAJ,GAAU,CAApC,CAArB,CAAP;QACD,CA3BwC,CA4BzC;QACA;;QACA;;;QACA,OAAO,IAAIM,QAAJ,CAAaF,MAAb,EAAqB,YAAYnb,MAAM,CAACsD,KAAP,CAAayX,IAAI,CAAC,CAAD,CAAjB,EAAsBA,IAAI,CAAC,CAAD,CAA1B,CAAjC,CAAP;MACD;;MAED,SAASO,2BAAT,CAAqChS;MAAO;MAA5C,EAAyD;QACvD,OAAOA,MAAM,CAACpI,QAAP,EAAP;MACD;;MAED,SAASqa,UAAT,CAAoBjS,MAApB,EAA4B;QAC1B,OAAOlJ,MAAM,CAACa,SAAP,CAAiBC,QAAjB,CAA0BtD,IAA1B,CAA+B0L,MAA/B,MAA2C,mBAAlD;MACD;;MAED/M,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,+BAAT,EAA0C;QACzDkT,IAAI,EAAE,QADmD;QAEzDvL,OAAO,EAAE+U,yBAFgD;QAGzDrG,SAAS,EAAE2G,2BAH8C;QAIzD1Q,SAAS,EAAE+Q,UAJ8C;QAKzD9Q,SAAS,EAAE6Q;MAL8C,CAA1C,CAAjB;IAQC,CA/FkC,EA+FjC;MAAC,cAAa;IAAd,CA/FiC,CAj6G80B;IAggH51B,IAAG,CAAC,UAAShe,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACzD;;MAEA,IAAI4B,IAAI,GAAGZ,OAAO,CAAC,YAAD,CAAlB;;MAEA,SAASke,uBAAT,CAAiCpE,IAAjC,EAAuC;QACrC,IAAIA,IAAI,KAAK,IAAb,EAAmB,OAAO,KAAP;QACnB,IAAIA,IAAI,CAACvZ,MAAL,KAAgB,CAApB,EAAuB,OAAO,KAAP;QAEvB,IAAI4d,MAAM,GAAGrE,IAAb;QAAA,IACI9B,IAAI,GAAK,cAAczM,IAAd,CAAmBuO,IAAnB,CADb;QAAA,IAEIsE,SAAS,GAAG,EAFhB,CAJqC,CAQrC;QACA;;QACA,IAAID,MAAM,CAAC,CAAD,CAAN,KAAc,GAAlB,EAAuB;UACrB,IAAInG,IAAJ,EAAUoG,SAAS,GAAGpG,IAAI,CAAC,CAAD,CAAhB;UAEV,IAAIoG,SAAS,CAAC7d,MAAV,GAAmB,CAAvB,EAA0B,OAAO,KAAP,CAHL,CAIrB;;UACA,IAAI4d,MAAM,CAACA,MAAM,CAAC5d,MAAP,GAAgB6d,SAAS,CAAC7d,MAA1B,GAAmC,CAApC,CAAN,KAAiD,GAArD,EAA0D,OAAO,KAAP;QAC3D;;QAED,OAAO,IAAP;MACD;;MAED,SAAS8d,yBAAT,CAAmCvE,IAAnC,EAAyC;QACvC,IAAIqE,MAAM,GAAGrE,IAAb;QAAA,IACI9B,IAAI,GAAK,cAAczM,IAAd,CAAmBuO,IAAnB,CADb;QAAA,IAEIsE,SAAS,GAAG,EAFhB,CADuC,CAKvC;;QACA,IAAID,MAAM,CAAC,CAAD,CAAN,KAAc,GAAlB,EAAuB;UACrB,IAAInG,IAAJ,EAAUoG,SAAS,GAAGpG,IAAI,CAAC,CAAD,CAAhB;UACVmG,MAAM,GAAGA,MAAM,CAACnY,KAAP,CAAa,CAAb,EAAgBmY,MAAM,CAAC5d,MAAP,GAAgB6d,SAAS,CAAC7d,MAA1B,GAAmC,CAAnD,CAAT;QACD;;QAED,OAAO,IAAI8a,MAAJ,CAAW8C,MAAX,EAAmBC,SAAnB,CAAP;MACD;;MAED,SAASE,yBAAT,CAAmCtS;MAAO;MAA1C,EAAuD;QACrD,IAAI7I,MAAM,GAAG,MAAM6I,MAAM,CAACtJ,MAAb,GAAsB,GAAnC;QAEA,IAAIsJ,MAAM,CAAC1M,MAAX,EAAmB6D,MAAM,IAAI,GAAV;QACnB,IAAI6I,MAAM,CAACuS,SAAX,EAAsBpb,MAAM,IAAI,GAAV;QACtB,IAAI6I,MAAM,CAACwS,UAAX,EAAuBrb,MAAM,IAAI,GAAV;QAEvB,OAAOA,MAAP;MACD;;MAED,SAASsb,QAAT,CAAkBzS,MAAlB,EAA0B;QACxB,OAAOlJ,MAAM,CAACa,SAAP,CAAiBC,QAAjB,CAA0BtD,IAA1B,CAA+B0L,MAA/B,MAA2C,iBAAlD;MACD;;MAED/M,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,6BAAT,EAAwC;QACvDkT,IAAI,EAAE,QADiD;QAEvDvL,OAAO,EAAE2V,uBAF8C;QAGvDjH,SAAS,EAAEoH,yBAH4C;QAIvDnR,SAAS,EAAEuR,QAJ4C;QAKvDtR,SAAS,EAAEmR;MAL4C,CAAxC,CAAjB;IAQC,CA9DuB,EA8DtB;MAAC,cAAa;IAAd,CA9DsB,CAhgHy1B;IA8jH51B,IAAG,CAAC,UAASte,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACzD;;MAEA,IAAI4B,IAAI,GAAGZ,OAAO,CAAC,YAAD,CAAlB;;MAEA,SAAS0e,0BAAT,GAAsC;QACpC,OAAO,IAAP;MACD;;MAED,SAASC,4BAAT,GAAwC;QACtC;QACA,OAAOjH,SAAP;MACD;;MAED,SAASkH,4BAAT,GAAwC;QACtC,OAAO,EAAP;MACD;;MAED,SAASC,WAAT,CAAqB7S,MAArB,EAA6B;QAC3B,OAAO,OAAOA,MAAP,KAAkB,WAAzB;MACD;;MAED/M,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,gCAAT,EAA2C;QAC1DkT,IAAI,EAAE,QADoD;QAE1DvL,OAAO,EAAEmW,0BAFiD;QAG1DzH,SAAS,EAAE0H,4BAH+C;QAI1DzR,SAAS,EAAE2R,WAJ+C;QAK1D1R,SAAS,EAAEyR;MAL+C,CAA3C,CAAjB;IAQC,CA9BuB,EA8BtB;MAAC,cAAa;IAAd,CA9BsB,CA9jHy1B;IA4lH51B,IAAG,CAAC,UAAS5e,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACzD;;MAEA,IAAI4B,IAAI,GAAGZ,OAAO,CAAC,SAAD,CAAlB;;MAEAf,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,uBAAT,EAAkC;QACjDkT,IAAI,EAAE,SAD2C;QAEjDmD,SAAS,EAAE,UAAU6C,IAAV,EAAgB;UAAE,OAAOA,IAAI,KAAK,IAAT,GAAgBA,IAAhB,GAAuB,EAA9B;QAAmC;MAFf,CAAlC,CAAjB;IAKC,CAVuB,EAUtB;MAAC,WAAU;IAAX,CAVsB,CA5lHy1B;IAsmH/1B,IAAG,CAAC,UAAS9Z,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACtD;;MAEA,IAAI4B,IAAI,GAAGZ,OAAO,CAAC,SAAD,CAAlB;;MAEA,SAAS8e,gBAAT,CAA0BhF,IAA1B,EAAgC;QAC9B,OAAOA,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAK,IAAjC;MACD;;MAED7a,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,yBAAT,EAAoC;QACnDkT,IAAI,EAAE,QAD6C;QAEnDvL,OAAO,EAAEuW;MAF0C,CAApC,CAAjB;IAKC,CAdoB,EAcnB;MAAC,WAAU;IAAX,CAdmB,CAtmH41B;IAonH/1B,IAAG,CAAC,UAAS9e,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACtD;;MAEA,IAAI4B,IAAI,GAAGZ,OAAO,CAAC,SAAD,CAAlB;;MAEA,SAAS+e,eAAT,CAAyBjF,IAAzB,EAA+B;QAC7B,IAAIA,IAAI,KAAK,IAAb,EAAmB,OAAO,IAAP;QAEnB,IAAInT,GAAG,GAAGmT,IAAI,CAACvZ,MAAf;QAEA,OAAQoG,GAAG,KAAK,CAAR,IAAamT,IAAI,KAAK,GAAvB,IACCnT,GAAG,KAAK,CAAR,KAAcmT,IAAI,KAAK,MAAT,IAAmBA,IAAI,KAAK,MAA5B,IAAsCA,IAAI,KAAK,MAA7D,CADR;MAED;;MAED,SAASkF,iBAAT,GAA6B;QAC3B,OAAO,IAAP;MACD;;MAED,SAASC,MAAT,CAAgBjT,MAAhB,EAAwB;QACtB,OAAOA,MAAM,KAAK,IAAlB;MACD;;MAED/M,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,wBAAT,EAAmC;QAClDkT,IAAI,EAAE,QAD4C;QAElDvL,OAAO,EAAEwW,eAFyC;QAGlD9H,SAAS,EAAE+H,iBAHuC;QAIlD9R,SAAS,EAAE+R,MAJuC;QAKlD9R,SAAS,EAAE;UACT+R,SAAS,EAAE,YAAY;YAAE,OAAO,GAAP;UAAgB,CADhC;UAETjE,SAAS,EAAE,YAAY;YAAE,OAAO,MAAP;UAAgB,CAFhC;UAGTC,SAAS,EAAE,YAAY;YAAE,OAAO,MAAP;UAAgB,CAHhC;UAITC,SAAS,EAAE,YAAY;YAAE,OAAO,MAAP;UAAgB;QAJhC,CALuC;QAWlD/N,YAAY,EAAE;MAXoC,CAAnC,CAAjB;IAcC,CApCoB,EAoCnB;MAAC,WAAU;IAAX,CApCmB,CApnH41B;IAwpH/1B,IAAG,CAAC,UAASpN,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACtD;;MAEA,IAAI4B,IAAI,GAAGZ,OAAO,CAAC,SAAD,CAAlB;;MAEA,IAAI6D,eAAe,GAAGf,MAAM,CAACa,SAAP,CAAiBG,cAAvC;MACA,IAAIJ,SAAS,GAASZ,MAAM,CAACa,SAAP,CAAiBC,QAAvC;;MAEA,SAASub,eAAT,CAAyBrF,IAAzB,EAA+B;QAC7B,IAAIA,IAAI,KAAK,IAAb,EAAmB,OAAO,IAAP;QAEnB,IAAIsF,UAAU,GAAG,EAAjB;QAAA,IAAqBzc,KAArB;QAAA,IAA4BpC,MAA5B;QAAA,IAAoC8e,IAApC;QAAA,IAA0CC,OAA1C;QAAA,IAAmDC,UAAnD;QAAA,IACIvT,MAAM,GAAG8N,IADb;;QAGA,KAAKnX,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAGyL,MAAM,CAACzL,MAAhC,EAAwCoC,KAAK,GAAGpC,MAAhD,EAAwDoC,KAAK,IAAI,CAAjE,EAAoE;UAClE0c,IAAI,GAAGrT,MAAM,CAACrJ,KAAD,CAAb;UACA4c,UAAU,GAAG,KAAb;UAEA,IAAI7b,SAAS,CAACpD,IAAV,CAAe+e,IAAf,MAAyB,iBAA7B,EAAgD,OAAO,KAAP;;UAEhD,KAAKC,OAAL,IAAgBD,IAAhB,EAAsB;YACpB,IAAIxb,eAAe,CAACvD,IAAhB,CAAqB+e,IAArB,EAA2BC,OAA3B,CAAJ,EAAyC;cACvC,IAAI,CAACC,UAAL,EAAiBA,UAAU,GAAG,IAAb,CAAjB,KACK,OAAO,KAAP;YACN;UACF;;UAED,IAAI,CAACA,UAAL,EAAiB,OAAO,KAAP;UAEjB,IAAIH,UAAU,CAACnX,OAAX,CAAmBqX,OAAnB,MAAgC,CAAC,CAArC,EAAwCF,UAAU,CAACtR,IAAX,CAAgBwR,OAAhB,EAAxC,KACK,OAAO,KAAP;QACN;;QAED,OAAO,IAAP;MACD;;MAED,SAASE,iBAAT,CAA2B1F,IAA3B,EAAiC;QAC/B,OAAOA,IAAI,KAAK,IAAT,GAAgBA,IAAhB,GAAuB,EAA9B;MACD;;MAED7a,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,wBAAT,EAAmC;QAClDkT,IAAI,EAAE,UAD4C;QAElDvL,OAAO,EAAE4W,eAFyC;QAGlDlI,SAAS,EAAEuI;MAHuC,CAAnC,CAAjB;IAMC,CA9CoB,EA8CnB;MAAC,WAAU;IAAX,CA9CmB,CAxpH41B;IAssH/1B,IAAG,CAAC,UAASxf,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACtD;;MAEA,IAAI4B,IAAI,GAAGZ,OAAO,CAAC,SAAD,CAAlB;;MAEA,IAAI0D,SAAS,GAAGZ,MAAM,CAACa,SAAP,CAAiBC,QAAjC;;MAEA,SAAS6b,gBAAT,CAA0B3F,IAA1B,EAAgC;QAC9B,IAAIA,IAAI,KAAK,IAAb,EAAmB,OAAO,IAAP;QAEnB,IAAInX,KAAJ;QAAA,IAAWpC,MAAX;QAAA,IAAmB8e,IAAnB;QAAA,IAAyBtc,IAAzB;QAAA,IAA+BI,MAA/B;QAAA,IACI6I,MAAM,GAAG8N,IADb;QAGA3W,MAAM,GAAG,IAAIb,KAAJ,CAAU0J,MAAM,CAACzL,MAAjB,CAAT;;QAEA,KAAKoC,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAGyL,MAAM,CAACzL,MAAhC,EAAwCoC,KAAK,GAAGpC,MAAhD,EAAwDoC,KAAK,IAAI,CAAjE,EAAoE;UAClE0c,IAAI,GAAGrT,MAAM,CAACrJ,KAAD,CAAb;UAEA,IAAIe,SAAS,CAACpD,IAAV,CAAe+e,IAAf,MAAyB,iBAA7B,EAAgD,OAAO,KAAP;UAEhDtc,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAYsc,IAAZ,CAAP;UAEA,IAAItc,IAAI,CAACxC,MAAL,KAAgB,CAApB,EAAuB,OAAO,KAAP;UAEvB4C,MAAM,CAACR,KAAD,CAAN,GAAgB,CAAEI,IAAI,CAAC,CAAD,CAAN,EAAWsc,IAAI,CAACtc,IAAI,CAAC,CAAD,CAAL,CAAf,CAAhB;QACD;;QAED,OAAO,IAAP;MACD;;MAED,SAAS2c,kBAAT,CAA4B5F,IAA5B,EAAkC;QAChC,IAAIA,IAAI,KAAK,IAAb,EAAmB,OAAO,EAAP;QAEnB,IAAInX,KAAJ;QAAA,IAAWpC,MAAX;QAAA,IAAmB8e,IAAnB;QAAA,IAAyBtc,IAAzB;QAAA,IAA+BI,MAA/B;QAAA,IACI6I,MAAM,GAAG8N,IADb;QAGA3W,MAAM,GAAG,IAAIb,KAAJ,CAAU0J,MAAM,CAACzL,MAAjB,CAAT;;QAEA,KAAKoC,KAAK,GAAG,CAAR,EAAWpC,MAAM,GAAGyL,MAAM,CAACzL,MAAhC,EAAwCoC,KAAK,GAAGpC,MAAhD,EAAwDoC,KAAK,IAAI,CAAjE,EAAoE;UAClE0c,IAAI,GAAGrT,MAAM,CAACrJ,KAAD,CAAb;UAEAI,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAYsc,IAAZ,CAAP;UAEAlc,MAAM,CAACR,KAAD,CAAN,GAAgB,CAAEI,IAAI,CAAC,CAAD,CAAN,EAAWsc,IAAI,CAACtc,IAAI,CAAC,CAAD,CAAL,CAAf,CAAhB;QACD;;QAED,OAAOI,MAAP;MACD;;MAEDlE,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,yBAAT,EAAoC;QACnDkT,IAAI,EAAE,UAD6C;QAEnDvL,OAAO,EAAEkX,gBAF0C;QAGnDxI,SAAS,EAAEyI;MAHwC,CAApC,CAAjB;IAMC,CAvDoB,EAuDnB;MAAC,WAAU;IAAX,CAvDmB,CAtsH41B;IA6vH/1B,IAAG,CAAC,UAAS1f,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACtD;;MAEA,IAAI4B,IAAI,GAAGZ,OAAO,CAAC,SAAD,CAAlB;;MAEAf,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,uBAAT,EAAkC;QACjDkT,IAAI,EAAE,UAD2C;QAEjDmD,SAAS,EAAE,UAAU6C,IAAV,EAAgB;UAAE,OAAOA,IAAI,KAAK,IAAT,GAAgBA,IAAhB,GAAuB,EAA9B;QAAmC;MAFf,CAAlC,CAAjB;IAKC,CAVoB,EAUnB;MAAC,WAAU;IAAX,CAVmB,CA7vH41B;IAuwH/1B,IAAG,CAAC,UAAS9Z,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACtD;;MAEA,IAAI4B,IAAI,GAAGZ,OAAO,CAAC,SAAD,CAAlB;;MAEA,IAAI6D,eAAe,GAAGf,MAAM,CAACa,SAAP,CAAiBG,cAAvC;;MAEA,SAAS6b,cAAT,CAAwB7F,IAAxB,EAA8B;QAC5B,IAAIA,IAAI,KAAK,IAAb,EAAmB,OAAO,IAAP;QAEnB,IAAIlX,GAAJ;QAAA,IAASoJ,MAAM,GAAG8N,IAAlB;;QAEA,KAAKlX,GAAL,IAAYoJ,MAAZ,EAAoB;UAClB,IAAInI,eAAe,CAACvD,IAAhB,CAAqB0L,MAArB,EAA6BpJ,GAA7B,CAAJ,EAAuC;YACrC,IAAIoJ,MAAM,CAACpJ,GAAD,CAAN,KAAgB,IAApB,EAA0B,OAAO,KAAP;UAC3B;QACF;;QAED,OAAO,IAAP;MACD;;MAED,SAASgd,gBAAT,CAA0B9F,IAA1B,EAAgC;QAC9B,OAAOA,IAAI,KAAK,IAAT,GAAgBA,IAAhB,GAAuB,EAA9B;MACD;;MAED7a,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,uBAAT,EAAkC;QACjDkT,IAAI,EAAE,SAD2C;QAEjDvL,OAAO,EAAEoX,cAFwC;QAGjD1I,SAAS,EAAE2I;MAHsC,CAAlC,CAAjB;IAMC,CA/BoB,EA+BnB;MAAC,WAAU;IAAX,CA/BmB,CAvwH41B;IAsyH/1B,IAAG,CAAC,UAAS5f,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACtD;;MAEA,IAAI4B,IAAI,GAAGZ,OAAO,CAAC,SAAD,CAAlB;;MAEAf,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,uBAAT,EAAkC;QACjDkT,IAAI,EAAE,QAD2C;QAEjDmD,SAAS,EAAE,UAAU6C,IAAV,EAAgB;UAAE,OAAOA,IAAI,KAAK,IAAT,GAAgBA,IAAhB,GAAuB,EAA9B;QAAmC;MAFf,CAAlC,CAAjB;IAKC,CAVoB,EAUnB;MAAC,WAAU;IAAX,CAVmB,CAtyH41B;IAgzH/1B,IAAG,CAAC,UAAS9Z,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACtD;;MAEA,IAAI4B,IAAI,GAAGZ,OAAO,CAAC,SAAD,CAAlB;;MAEA,IAAI6f,gBAAgB,GAAG,IAAIxE,MAAJ,CACrB,4BAAqC;MACrC,eADA,GACqC;MACrC,gBAHqB,CAAvB,CALsD,CAQf;;MAEvC,IAAIyE,qBAAqB,GAAG,IAAIzE,MAAJ,CAC1B,4BAAqC;MACrC,gBADA,GACqC;MACrC,gBAFA,GAEqC;MACrC,kBAHA,GAGqC;MACrC,eAJA,GAIqC;MACrC,eALA,GAKqC;MACrC,eANA,GAMqC;MACrC,kBAPA,GAOqC;MACrC,kCARA,GAQqC;MACrC,wBAV0B,CAA5B,CAVsD,CAoBf;;MAEvC,SAAS0E,oBAAT,CAA8BjG,IAA9B,EAAoC;QAClC,IAAIA,IAAI,KAAK,IAAb,EAAmB,OAAO,KAAP;QACnB,IAAI+F,gBAAgB,CAACtU,IAAjB,CAAsBuO,IAAtB,MAAgC,IAApC,EAA0C,OAAO,IAAP;QAC1C,IAAIgG,qBAAqB,CAACvU,IAAtB,CAA2BuO,IAA3B,MAAqC,IAAzC,EAA+C,OAAO,IAAP;QAC/C,OAAO,KAAP;MACD;;MAED,SAASkG,sBAAT,CAAgClG,IAAhC,EAAsC;QACpC,IAAIxO,KAAJ;QAAA,IAAW2U,IAAX;QAAA,IAAiBC,KAAjB;QAAA,IAAwBC,GAAxB;QAAA,IAA6BC,IAA7B;QAAA,IAAmCC,MAAnC;QAAA,IAA2CC,MAA3C;QAAA,IAAmDC,QAAQ,GAAG,CAA9D;QAAA,IACIC,KAAK,GAAG,IADZ;QAAA,IACkBC,OADlB;QAAA,IAC2BC,SAD3B;QAAA,IACsCC,IADtC;QAGArV,KAAK,GAAGuU,gBAAgB,CAACtU,IAAjB,CAAsBuO,IAAtB,CAAR;QACA,IAAIxO,KAAK,KAAK,IAAd,EAAoBA,KAAK,GAAGwU,qBAAqB,CAACvU,IAAtB,CAA2BuO,IAA3B,CAAR;QAEpB,IAAIxO,KAAK,KAAK,IAAd,EAAoB,MAAM,IAAInL,KAAJ,CAAU,oBAAV,CAAN,CAPgB,CASpC;;QAEA8f,IAAI,GAAG,CAAE3U,KAAK,CAAC,CAAD,CAAd;QACA4U,KAAK,GAAG,CAAE5U,KAAK,CAAC,CAAD,CAAP,GAAc,CAAtB,CAZoC,CAYX;;QACzB6U,GAAG,GAAG,CAAE7U,KAAK,CAAC,CAAD,CAAb;;QAEA,IAAI,CAACA,KAAK,CAAC,CAAD,CAAV,EAAe;UAAE;UACf,OAAO,IAAIsV,IAAJ,CAASA,IAAI,CAACC,GAAL,CAASZ,IAAT,EAAeC,KAAf,EAAsBC,GAAtB,CAAT,CAAP;QACD,CAjBmC,CAmBpC;;;QAEAC,IAAI,GAAG,CAAE9U,KAAK,CAAC,CAAD,CAAd;QACA+U,MAAM,GAAG,CAAE/U,KAAK,CAAC,CAAD,CAAhB;QACAgV,MAAM,GAAG,CAAEhV,KAAK,CAAC,CAAD,CAAhB;;QAEA,IAAIA,KAAK,CAAC,CAAD,CAAT,EAAc;UACZiV,QAAQ,GAAGjV,KAAK,CAAC,CAAD,CAAL,CAAStF,KAAT,CAAe,CAAf,EAAkB,CAAlB,CAAX;;UACA,OAAOua,QAAQ,CAAChgB,MAAT,GAAkB,CAAzB,EAA4B;YAAE;YAC5BggB,QAAQ,IAAI,GAAZ;UACD;;UACDA,QAAQ,GAAG,CAACA,QAAZ;QACD,CA/BmC,CAiCpC;;;QAEA,IAAIjV,KAAK,CAAC,CAAD,CAAT,EAAc;UACZmV,OAAO,GAAG,CAAEnV,KAAK,CAAC,EAAD,CAAjB;UACAoV,SAAS,GAAG,EAAEpV,KAAK,CAAC,EAAD,CAAL,IAAa,CAAf,CAAZ;UACAkV,KAAK,GAAG,CAACC,OAAO,GAAG,EAAV,GAAeC,SAAhB,IAA6B,KAArC,CAHY,CAGgC;;UAC5C,IAAIpV,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsBkV,KAAK,GAAG,CAACA,KAAT;QACvB;;QAEDG,IAAI,GAAG,IAAIC,IAAJ,CAASA,IAAI,CAACC,GAAL,CAASZ,IAAT,EAAeC,KAAf,EAAsBC,GAAtB,EAA2BC,IAA3B,EAAiCC,MAAjC,EAAyCC,MAAzC,EAAiDC,QAAjD,CAAT,CAAP;QAEA,IAAIC,KAAJ,EAAWG,IAAI,CAACG,OAAL,CAAaH,IAAI,CAACI,OAAL,KAAiBP,KAA9B;QAEX,OAAOG,IAAP;MACD;;MAED,SAASK,sBAAT,CAAgChV;MAAO;MAAvC,EAAoD;QAClD,OAAOA,MAAM,CAACiV,WAAP,EAAP;MACD;;MAEDhiB,MAAM,CAACD,OAAP,GAAiB,IAAI4B,IAAJ,CAAS,6BAAT,EAAwC;QACvDkT,IAAI,EAAE,QADiD;QAEvDvL,OAAO,EAAEwX,oBAF8C;QAGvD9I,SAAS,EAAE+I,sBAH4C;QAIvD/S,UAAU,EAAE2T,IAJ2C;QAKvDzT,SAAS,EAAE6T;MAL4C,CAAxC,CAAjB;IAQC,CA1FoB,EA0FnB;MAAC,WAAU;IAAX,CA1FmB,CAhzH41B;IA04H/1B,KAAI,CAAC,UAAShhB,OAAT,EAAiBf,MAAjB,EAAwBD,OAAxB,EAAgC;MACvD;;MAGA,IAAIkiB,IAAI,GAAGlhB,OAAO,CAAC,kBAAD,CAAlB;;MAGAf,MAAM,CAACD,OAAP,GAAiBkiB,IAAjB;IAEC,CATqB,EASpB;MAAC,oBAAmB;IAApB,CAToB;EA14H21B,CAA5c,EAm5H1Y,EAn5H0Y,EAm5HvY,EAn5HuY,EAm5HnY,GAn5HmY,CAAP;AAo5H7Z,CAp5HsD"},"metadata":{},"sourceType":"script"}