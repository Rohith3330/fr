{"ast":null,"code":"/**\n * @fileoverview Flat config schema\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //-----------------------------------------------------------------------------\n// Type Definitions\n//-----------------------------------------------------------------------------\n\n/**\n * @typedef ObjectPropertySchema\n * @property {Function|string} merge The function or name of the function to call\n *      to merge multiple objects with this property.\n * @property {Function|string} validate The function or name of the function to call\n *      to validate the value of this property.\n */\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst ruleSeverities = new Map([[0, 0], [\"off\", 0], [1, 1], [\"warn\", 1], [2, 2], [\"error\", 2]]);\nconst globalVariablesValues = new Set([true, \"true\", \"writable\", \"writeable\", false, \"false\", \"readonly\", \"readable\", null, \"off\"]);\n/**\n * Check if a value is a non-null object.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\n\nfunction isNonNullObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\n/**\n * Check if a value is undefined.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is undefined.\n */\n\n\nfunction isUndefined(value) {\n  return typeof value === \"undefined\";\n}\n/**\n * Deeply merges two objects.\n * @param {Object} first The base object.\n * @param {Object} second The overrides object.\n * @returns {Object} An object with properties from both first and second.\n */\n\n\nfunction deepMerge() {\n  let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /*\n   * If the second value is an array, just return it. We don't merge\n   * arrays because order matters and we can't know the correct order.\n   */\n  if (Array.isArray(second)) {\n    return second;\n  }\n  /*\n   * First create a result object where properties from the second object\n   * overwrite properties from the first. This sets up a baseline to use\n   * later rather than needing to inspect and change every property\n   * individually.\n   */\n\n\n  const result = { ...first,\n    ...second\n  };\n\n  for (const key of Object.keys(second)) {\n    // avoid hairy edge case\n    if (key === \"__proto__\") {\n      continue;\n    }\n\n    const firstValue = first[key];\n    const secondValue = second[key];\n\n    if (isNonNullObject(firstValue)) {\n      result[key] = deepMerge(firstValue, secondValue);\n    } else if (isUndefined(firstValue)) {\n      if (isNonNullObject(secondValue)) {\n        result[key] = deepMerge(Array.isArray(secondValue) ? [] : {}, secondValue);\n      } else if (!isUndefined(secondValue)) {\n        result[key] = secondValue;\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Normalizes the rule options config for a given rule by ensuring that\n * it is an array and that the first item is 0, 1, or 2.\n * @param {Array|string|number} ruleOptions The rule options config.\n * @returns {Array} An array of rule options.\n */\n\n\nfunction normalizeRuleOptions(ruleOptions) {\n  const finalOptions = Array.isArray(ruleOptions) ? ruleOptions.slice(0) : [ruleOptions];\n  finalOptions[0] = ruleSeverities.get(finalOptions[0]);\n  return finalOptions;\n} //-----------------------------------------------------------------------------\n// Assertions\n//-----------------------------------------------------------------------------\n\n/**\n * Validates that a value is a valid rule options entry.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {TypeError} If the value isn't a valid rule options.\n */\n\n\nfunction assertIsRuleOptions(value) {\n  if (typeof value !== \"string\" && typeof value !== \"number\" && !Array.isArray(value)) {\n    throw new TypeError(\"Expected a string, number, or array.\");\n  }\n}\n/**\n * Validates that a value is valid rule severity.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {TypeError} If the value isn't a valid rule severity.\n */\n\n\nfunction assertIsRuleSeverity(value) {\n  const severity = typeof value === \"string\" ? ruleSeverities.get(value.toLowerCase()) : ruleSeverities.get(value);\n\n  if (typeof severity === \"undefined\") {\n    throw new TypeError(\"Expected severity of \\\"off\\\", 0, \\\"warn\\\", 1, \\\"error\\\", or 2.\");\n  }\n}\n/**\n * Validates that a given string is the form pluginName/objectName.\n * @param {string} value The string to check.\n * @returns {void}\n * @throws {TypeError} If the string isn't in the correct format.\n */\n\n\nfunction assertIsPluginMemberName(value) {\n  if (!/[@a-z0-9-_$]+(?:\\/(?:[a-z0-9-_$]+))+$/iu.test(value)) {\n    throw new TypeError(`Expected string in the form \"pluginName/objectName\" but found \"${value}\".`);\n  }\n}\n/**\n * Validates that a value is an object.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {TypeError} If the value isn't an object.\n */\n\n\nfunction assertIsObject(value) {\n  if (!isNonNullObject(value)) {\n    throw new TypeError(\"Expected an object.\");\n  }\n}\n/**\n * Validates that a value is an object or a string.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {TypeError} If the value isn't an object or a string.\n */\n\n\nfunction assertIsObjectOrString(value) {\n  if ((!value || typeof value !== \"object\") && typeof value !== \"string\") {\n    throw new TypeError(\"Expected an object or string.\");\n  }\n} //-----------------------------------------------------------------------------\n// Low-Level Schemas\n//-----------------------------------------------------------------------------\n\n/** @type {ObjectPropertySchema} */\n\n\nconst booleanSchema = {\n  merge: \"replace\",\n  validate: \"boolean\"\n};\n/** @type {ObjectPropertySchema} */\n\nconst deepObjectAssignSchema = {\n  merge() {\n    let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return deepMerge(first, second);\n  },\n\n  validate: \"object\"\n}; //-----------------------------------------------------------------------------\n// High-Level Schemas\n//-----------------------------------------------------------------------------\n\n/** @type {ObjectPropertySchema} */\n\nconst globalsSchema = {\n  merge: \"assign\",\n\n  validate(value) {\n    assertIsObject(value);\n\n    for (const key of Object.keys(value)) {\n      // avoid hairy edge case\n      if (key === \"__proto__\") {\n        continue;\n      }\n\n      if (key !== key.trim()) {\n        throw new TypeError(`Global \"${key}\" has leading or trailing whitespace.`);\n      }\n\n      if (!globalVariablesValues.has(value[key])) {\n        throw new TypeError(`Key \"${key}\": Expected \"readonly\", \"writable\", or \"off\".`);\n      }\n    }\n  }\n\n};\n/** @type {ObjectPropertySchema} */\n\nconst parserSchema = {\n  merge: \"replace\",\n\n  validate(value) {\n    assertIsObjectOrString(value);\n\n    if (typeof value === \"object\" && typeof value.parse !== \"function\" && typeof value.parseForESLint !== \"function\") {\n      throw new TypeError(\"Expected object to have a parse() or parseForESLint() method.\");\n    }\n\n    if (typeof value === \"string\") {\n      assertIsPluginMemberName(value);\n    }\n  }\n\n};\n/** @type {ObjectPropertySchema} */\n\nconst pluginsSchema = {\n  merge() {\n    let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const keys = new Set([...Object.keys(first), ...Object.keys(second)]);\n    const result = {}; // manually validate that plugins are not redefined\n\n    for (const key of keys) {\n      // avoid hairy edge case\n      if (key === \"__proto__\") {\n        continue;\n      }\n\n      if (key in first && key in second && first[key] !== second[key]) {\n        throw new TypeError(`Cannot redefine plugin \"${key}\".`);\n      }\n\n      result[key] = second[key] || first[key];\n    }\n\n    return result;\n  },\n\n  validate(value) {\n    // first check the value to be sure it's an object\n    if (value === null || typeof value !== \"object\") {\n      throw new TypeError(\"Expected an object.\");\n    } // second check the keys to make sure they are objects\n\n\n    for (const key of Object.keys(value)) {\n      // avoid hairy edge case\n      if (key === \"__proto__\") {\n        continue;\n      }\n\n      if (value[key] === null || typeof value[key] !== \"object\") {\n        throw new TypeError(`Key \"${key}\": Expected an object.`);\n      }\n    }\n  }\n\n};\n/** @type {ObjectPropertySchema} */\n\nconst processorSchema = {\n  merge: \"replace\",\n\n  validate(value) {\n    if (typeof value === \"string\") {\n      assertIsPluginMemberName(value);\n    } else if (value && typeof value === \"object\") {\n      if (typeof value.preprocess !== \"function\" || typeof value.postprocess !== \"function\") {\n        throw new TypeError(\"Object must have a preprocess() and a postprocess() method.\");\n      }\n    } else {\n      throw new TypeError(\"Expected an object or a string.\");\n    }\n  }\n\n};\n/** @type {ObjectPropertySchema} */\n\nconst rulesSchema = {\n  merge() {\n    let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const result = { ...first,\n      ...second\n    };\n\n    for (const ruleId of Object.keys(result)) {\n      // avoid hairy edge case\n      if (ruleId === \"__proto__\") {\n        /* eslint-disable-next-line no-proto -- Though deprecated, may still be present */\n        delete result.__proto__;\n        continue;\n      }\n\n      result[ruleId] = normalizeRuleOptions(result[ruleId]);\n      /*\n       * If either rule config is missing, then the correct\n       * config is already present and we just need to normalize\n       * the severity.\n       */\n\n      if (!(ruleId in first) || !(ruleId in second)) {\n        continue;\n      }\n\n      const firstRuleOptions = normalizeRuleOptions(first[ruleId]);\n      const secondRuleOptions = normalizeRuleOptions(second[ruleId]);\n      /*\n       * If the second rule config only has a severity (length of 1),\n       * then use that severity and keep the rest of the options from\n       * the first rule config.\n       */\n\n      if (secondRuleOptions.length === 1) {\n        result[ruleId] = [secondRuleOptions[0], ...firstRuleOptions.slice(1)];\n        continue;\n      }\n      /*\n       * In any other situation, then the second rule config takes\n       * precedence. That means the value at `result[ruleId]` is\n       * already correct and no further work is necessary.\n       */\n\n    }\n\n    return result;\n  },\n\n  validate(value) {\n    assertIsObject(value);\n    let lastRuleId; // Performance: One try-catch has less overhead than one per loop iteration\n\n    try {\n      /*\n       * We are not checking the rule schema here because there is no\n       * guarantee that the rule definition is present at this point. Instead\n       * we wait and check the rule schema during the finalization step\n       * of calculating a config.\n       */\n      for (const ruleId of Object.keys(value)) {\n        // avoid hairy edge case\n        if (ruleId === \"__proto__\") {\n          continue;\n        }\n\n        lastRuleId = ruleId;\n        const ruleOptions = value[ruleId];\n        assertIsRuleOptions(ruleOptions);\n\n        if (Array.isArray(ruleOptions)) {\n          assertIsRuleSeverity(ruleOptions[0]);\n        } else {\n          assertIsRuleSeverity(ruleOptions);\n        }\n      }\n    } catch (error) {\n      error.message = `Key \"${lastRuleId}\": ${error.message}`;\n      throw error;\n    }\n  }\n\n};\n/** @type {ObjectPropertySchema} */\n\nconst ecmaVersionSchema = {\n  merge: \"replace\",\n\n  validate(value) {\n    if (typeof value === \"number\" || value === \"latest\") {\n      return;\n    }\n\n    throw new TypeError(\"Expected a number or \\\"latest\\\".\");\n  }\n\n};\n/** @type {ObjectPropertySchema} */\n\nconst sourceTypeSchema = {\n  merge: \"replace\",\n\n  validate(value) {\n    if (typeof value !== \"string\" || !/^(?:script|module|commonjs)$/u.test(value)) {\n      throw new TypeError(\"Expected \\\"script\\\", \\\"module\\\", or \\\"commonjs\\\".\");\n    }\n  }\n\n}; //-----------------------------------------------------------------------------\n// Full schema\n//-----------------------------------------------------------------------------\n\nexports.flatConfigSchema = {\n  settings: deepObjectAssignSchema,\n  linterOptions: {\n    schema: {\n      noInlineConfig: booleanSchema,\n      reportUnusedDisableDirectives: booleanSchema\n    }\n  },\n  languageOptions: {\n    schema: {\n      ecmaVersion: ecmaVersionSchema,\n      sourceType: sourceTypeSchema,\n      globals: globalsSchema,\n      parser: parserSchema,\n      parserOptions: deepObjectAssignSchema\n    }\n  },\n  processor: processorSchema,\n  plugins: pluginsSchema,\n  rules: rulesSchema\n};","map":{"version":3,"names":["ruleSeverities","Map","globalVariablesValues","Set","isNonNullObject","value","isUndefined","deepMerge","first","second","Array","isArray","result","key","Object","keys","firstValue","secondValue","normalizeRuleOptions","ruleOptions","finalOptions","slice","get","assertIsRuleOptions","TypeError","assertIsRuleSeverity","severity","toLowerCase","assertIsPluginMemberName","test","assertIsObject","assertIsObjectOrString","booleanSchema","merge","validate","deepObjectAssignSchema","globalsSchema","trim","has","parserSchema","parse","parseForESLint","pluginsSchema","processorSchema","preprocess","postprocess","rulesSchema","ruleId","__proto__","firstRuleOptions","secondRuleOptions","length","lastRuleId","error","message","ecmaVersionSchema","sourceTypeSchema","exports","flatConfigSchema","settings","linterOptions","schema","noInlineConfig","reportUnusedDisableDirectives","languageOptions","ecmaVersion","sourceType","globals","parser","parserOptions","processor","plugins","rules"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/config/flat-config-schema.js"],"sourcesContent":["/**\n * @fileoverview Flat config schema\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Type Definitions\n//-----------------------------------------------------------------------------\n\n/**\n * @typedef ObjectPropertySchema\n * @property {Function|string} merge The function or name of the function to call\n *      to merge multiple objects with this property.\n * @property {Function|string} validate The function or name of the function to call\n *      to validate the value of this property.\n */\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst ruleSeverities = new Map([\n    [0, 0], [\"off\", 0],\n    [1, 1], [\"warn\", 1],\n    [2, 2], [\"error\", 2]\n]);\n\nconst globalVariablesValues = new Set([\n    true, \"true\", \"writable\", \"writeable\",\n    false, \"false\", \"readonly\", \"readable\", null,\n    \"off\"\n]);\n\n/**\n * Check if a value is a non-null object.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is a non-null object.\n */\nfunction isNonNullObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\n\n/**\n * Check if a value is undefined.\n * @param {any} value The value to check.\n * @returns {boolean} `true` if the value is undefined.\n */\nfunction isUndefined(value) {\n    return typeof value === \"undefined\";\n}\n\n/**\n * Deeply merges two objects.\n * @param {Object} first The base object.\n * @param {Object} second The overrides object.\n * @returns {Object} An object with properties from both first and second.\n */\nfunction deepMerge(first = {}, second = {}) {\n\n    /*\n     * If the second value is an array, just return it. We don't merge\n     * arrays because order matters and we can't know the correct order.\n     */\n    if (Array.isArray(second)) {\n        return second;\n    }\n\n    /*\n     * First create a result object where properties from the second object\n     * overwrite properties from the first. This sets up a baseline to use\n     * later rather than needing to inspect and change every property\n     * individually.\n     */\n    const result = {\n        ...first,\n        ...second\n    };\n\n    for (const key of Object.keys(second)) {\n\n        // avoid hairy edge case\n        if (key === \"__proto__\") {\n            continue;\n        }\n\n        const firstValue = first[key];\n        const secondValue = second[key];\n\n        if (isNonNullObject(firstValue)) {\n            result[key] = deepMerge(firstValue, secondValue);\n        } else if (isUndefined(firstValue)) {\n            if (isNonNullObject(secondValue)) {\n                result[key] = deepMerge(\n                    Array.isArray(secondValue) ? [] : {},\n                    secondValue\n                );\n            } else if (!isUndefined(secondValue)) {\n                result[key] = secondValue;\n            }\n        }\n    }\n\n    return result;\n\n}\n\n/**\n * Normalizes the rule options config for a given rule by ensuring that\n * it is an array and that the first item is 0, 1, or 2.\n * @param {Array|string|number} ruleOptions The rule options config.\n * @returns {Array} An array of rule options.\n */\nfunction normalizeRuleOptions(ruleOptions) {\n\n    const finalOptions = Array.isArray(ruleOptions)\n        ? ruleOptions.slice(0)\n        : [ruleOptions];\n\n    finalOptions[0] = ruleSeverities.get(finalOptions[0]);\n    return finalOptions;\n}\n\n//-----------------------------------------------------------------------------\n// Assertions\n//-----------------------------------------------------------------------------\n\n/**\n * Validates that a value is a valid rule options entry.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {TypeError} If the value isn't a valid rule options.\n */\nfunction assertIsRuleOptions(value) {\n\n    if (typeof value !== \"string\" && typeof value !== \"number\" && !Array.isArray(value)) {\n        throw new TypeError(\"Expected a string, number, or array.\");\n    }\n}\n\n/**\n * Validates that a value is valid rule severity.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {TypeError} If the value isn't a valid rule severity.\n */\nfunction assertIsRuleSeverity(value) {\n    const severity = typeof value === \"string\"\n        ? ruleSeverities.get(value.toLowerCase())\n        : ruleSeverities.get(value);\n\n    if (typeof severity === \"undefined\") {\n        throw new TypeError(\"Expected severity of \\\"off\\\", 0, \\\"warn\\\", 1, \\\"error\\\", or 2.\");\n    }\n}\n\n/**\n * Validates that a given string is the form pluginName/objectName.\n * @param {string} value The string to check.\n * @returns {void}\n * @throws {TypeError} If the string isn't in the correct format.\n */\nfunction assertIsPluginMemberName(value) {\n    if (!/[@a-z0-9-_$]+(?:\\/(?:[a-z0-9-_$]+))+$/iu.test(value)) {\n        throw new TypeError(`Expected string in the form \"pluginName/objectName\" but found \"${value}\".`);\n    }\n}\n\n/**\n * Validates that a value is an object.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {TypeError} If the value isn't an object.\n */\nfunction assertIsObject(value) {\n    if (!isNonNullObject(value)) {\n        throw new TypeError(\"Expected an object.\");\n    }\n}\n\n/**\n * Validates that a value is an object or a string.\n * @param {any} value The value to check.\n * @returns {void}\n * @throws {TypeError} If the value isn't an object or a string.\n */\nfunction assertIsObjectOrString(value) {\n    if ((!value || typeof value !== \"object\") && typeof value !== \"string\") {\n        throw new TypeError(\"Expected an object or string.\");\n    }\n}\n\n//-----------------------------------------------------------------------------\n// Low-Level Schemas\n//-----------------------------------------------------------------------------\n\n/** @type {ObjectPropertySchema} */\nconst booleanSchema = {\n    merge: \"replace\",\n    validate: \"boolean\"\n};\n\n/** @type {ObjectPropertySchema} */\nconst deepObjectAssignSchema = {\n    merge(first = {}, second = {}) {\n        return deepMerge(first, second);\n    },\n    validate: \"object\"\n};\n\n//-----------------------------------------------------------------------------\n// High-Level Schemas\n//-----------------------------------------------------------------------------\n\n/** @type {ObjectPropertySchema} */\nconst globalsSchema = {\n    merge: \"assign\",\n    validate(value) {\n\n        assertIsObject(value);\n\n        for (const key of Object.keys(value)) {\n\n            // avoid hairy edge case\n            if (key === \"__proto__\") {\n                continue;\n            }\n\n            if (key !== key.trim()) {\n                throw new TypeError(`Global \"${key}\" has leading or trailing whitespace.`);\n            }\n\n            if (!globalVariablesValues.has(value[key])) {\n                throw new TypeError(`Key \"${key}\": Expected \"readonly\", \"writable\", or \"off\".`);\n            }\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst parserSchema = {\n    merge: \"replace\",\n    validate(value) {\n        assertIsObjectOrString(value);\n\n        if (typeof value === \"object\" && typeof value.parse !== \"function\" && typeof value.parseForESLint !== \"function\") {\n            throw new TypeError(\"Expected object to have a parse() or parseForESLint() method.\");\n        }\n\n        if (typeof value === \"string\") {\n            assertIsPluginMemberName(value);\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst pluginsSchema = {\n    merge(first = {}, second = {}) {\n        const keys = new Set([...Object.keys(first), ...Object.keys(second)]);\n        const result = {};\n\n        // manually validate that plugins are not redefined\n        for (const key of keys) {\n\n            // avoid hairy edge case\n            if (key === \"__proto__\") {\n                continue;\n            }\n\n            if (key in first && key in second && first[key] !== second[key]) {\n                throw new TypeError(`Cannot redefine plugin \"${key}\".`);\n            }\n\n            result[key] = second[key] || first[key];\n        }\n\n        return result;\n    },\n    validate(value) {\n\n        // first check the value to be sure it's an object\n        if (value === null || typeof value !== \"object\") {\n            throw new TypeError(\"Expected an object.\");\n        }\n\n        // second check the keys to make sure they are objects\n        for (const key of Object.keys(value)) {\n\n            // avoid hairy edge case\n            if (key === \"__proto__\") {\n                continue;\n            }\n\n            if (value[key] === null || typeof value[key] !== \"object\") {\n                throw new TypeError(`Key \"${key}\": Expected an object.`);\n            }\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst processorSchema = {\n    merge: \"replace\",\n    validate(value) {\n        if (typeof value === \"string\") {\n            assertIsPluginMemberName(value);\n        } else if (value && typeof value === \"object\") {\n            if (typeof value.preprocess !== \"function\" || typeof value.postprocess !== \"function\") {\n                throw new TypeError(\"Object must have a preprocess() and a postprocess() method.\");\n            }\n        } else {\n            throw new TypeError(\"Expected an object or a string.\");\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst rulesSchema = {\n    merge(first = {}, second = {}) {\n\n        const result = {\n            ...first,\n            ...second\n        };\n\n        for (const ruleId of Object.keys(result)) {\n\n            // avoid hairy edge case\n            if (ruleId === \"__proto__\") {\n\n                /* eslint-disable-next-line no-proto -- Though deprecated, may still be present */\n                delete result.__proto__;\n                continue;\n            }\n\n            result[ruleId] = normalizeRuleOptions(result[ruleId]);\n\n            /*\n             * If either rule config is missing, then the correct\n             * config is already present and we just need to normalize\n             * the severity.\n             */\n            if (!(ruleId in first) || !(ruleId in second)) {\n                continue;\n            }\n\n            const firstRuleOptions = normalizeRuleOptions(first[ruleId]);\n            const secondRuleOptions = normalizeRuleOptions(second[ruleId]);\n\n            /*\n             * If the second rule config only has a severity (length of 1),\n             * then use that severity and keep the rest of the options from\n             * the first rule config.\n             */\n            if (secondRuleOptions.length === 1) {\n                result[ruleId] = [secondRuleOptions[0], ...firstRuleOptions.slice(1)];\n                continue;\n            }\n\n            /*\n             * In any other situation, then the second rule config takes\n             * precedence. That means the value at `result[ruleId]` is\n             * already correct and no further work is necessary.\n             */\n        }\n\n        return result;\n    },\n\n    validate(value) {\n        assertIsObject(value);\n\n        let lastRuleId;\n\n        // Performance: One try-catch has less overhead than one per loop iteration\n        try {\n\n            /*\n             * We are not checking the rule schema here because there is no\n             * guarantee that the rule definition is present at this point. Instead\n             * we wait and check the rule schema during the finalization step\n             * of calculating a config.\n             */\n            for (const ruleId of Object.keys(value)) {\n\n                // avoid hairy edge case\n                if (ruleId === \"__proto__\") {\n                    continue;\n                }\n\n                lastRuleId = ruleId;\n\n                const ruleOptions = value[ruleId];\n\n                assertIsRuleOptions(ruleOptions);\n\n                if (Array.isArray(ruleOptions)) {\n                    assertIsRuleSeverity(ruleOptions[0]);\n                } else {\n                    assertIsRuleSeverity(ruleOptions);\n                }\n            }\n        } catch (error) {\n            error.message = `Key \"${lastRuleId}\": ${error.message}`;\n            throw error;\n        }\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst ecmaVersionSchema = {\n    merge: \"replace\",\n    validate(value) {\n        if (typeof value === \"number\" || value === \"latest\") {\n            return;\n        }\n\n        throw new TypeError(\"Expected a number or \\\"latest\\\".\");\n    }\n};\n\n/** @type {ObjectPropertySchema} */\nconst sourceTypeSchema = {\n    merge: \"replace\",\n    validate(value) {\n        if (typeof value !== \"string\" || !/^(?:script|module|commonjs)$/u.test(value)) {\n            throw new TypeError(\"Expected \\\"script\\\", \\\"module\\\", or \\\"commonjs\\\".\");\n        }\n    }\n};\n\n//-----------------------------------------------------------------------------\n// Full schema\n//-----------------------------------------------------------------------------\n\nexports.flatConfigSchema = {\n    settings: deepObjectAssignSchema,\n    linterOptions: {\n        schema: {\n            noInlineConfig: booleanSchema,\n            reportUnusedDisableDirectives: booleanSchema\n        }\n    },\n    languageOptions: {\n        schema: {\n            ecmaVersion: ecmaVersionSchema,\n            sourceType: sourceTypeSchema,\n            globals: globalsSchema,\n            parser: parserSchema,\n            parserOptions: deepObjectAssignSchema\n        }\n    },\n    processor: processorSchema,\n    plugins: pluginsSchema,\n    rules: rulesSchema\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}