{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAbsoluteMappingEntries = void 0;\n\nvar path = require(\"path\");\n/**\n * Converts an absolute baseUrl and paths to an array of absolute mapping entries.\n * The array is sorted by longest prefix.\n * Having an array with entries allows us to keep a sorting order rather than\n * sort by keys each time we use the mappings.\n * @param absoluteBaseUrl\n * @param paths\n * @param addMatchAll\n */\n\n\nfunction getAbsoluteMappingEntries(absoluteBaseUrl, paths, addMatchAll) {\n  // Resolve all paths to absolute form once here, and sort them by\n  // longest prefix once here, this saves time on each request later.\n  // We need to put them in an array to preserve the sorting order.\n  var sortedKeys = sortByLongestPrefix(Object.keys(paths));\n  var absolutePaths = [];\n\n  for (var _i = 0, sortedKeys_1 = sortedKeys; _i < sortedKeys_1.length; _i++) {\n    var key = sortedKeys_1[_i];\n    absolutePaths.push({\n      pattern: key,\n      paths: paths[key].map(function (pathToResolve) {\n        return path.join(absoluteBaseUrl, pathToResolve);\n      })\n    });\n  } // If there is no match-all path specified in the paths section of tsconfig, then try to match\n  // all paths relative to baseUrl, this is how typescript works.\n\n\n  if (!paths[\"*\"] && addMatchAll) {\n    absolutePaths.push({\n      pattern: \"*\",\n      paths: [\"\".concat(absoluteBaseUrl.replace(/\\/$/, \"\"), \"/*\")]\n    });\n  }\n\n  return absolutePaths;\n}\n\nexports.getAbsoluteMappingEntries = getAbsoluteMappingEntries;\n/**\n * Sort path patterns.\n * If a module name can be matched with multiple patterns then pattern with the longest prefix will be picked.\n */\n\nfunction sortByLongestPrefix(arr) {\n  return arr.concat().sort(function (a, b) {\n    return getPrefixLength(b) - getPrefixLength(a);\n  });\n}\n\nfunction getPrefixLength(pattern) {\n  var prefixLength = pattern.indexOf(\"*\");\n  return pattern.substr(0, prefixLength).length;\n}","map":{"version":3,"mappings":";;;;;;;AAAA;AAWA;;;;;;;;;;;AASA,SAAgBA,yBAAhB,CACEC,eADF,EAEEC,KAFF,EAGEC,WAHF,EAGsB;EAEpB;EACA;EACA;EACA,IAAMC,UAAU,GAAGC,mBAAmB,CAACC,MAAM,CAACC,IAAP,CAAYL,KAAZ,CAAD,CAAtC;EACA,IAAMM,aAAa,GAAwB,EAA3C;;EACA,KAAkB,qCAAlB,EAAkBC,wBAAlB,EAAkBA,IAAlB,EAA8B;IAAzB,IAAMC,GAAG,mBAAT;IACHF,aAAa,CAACG,IAAd,CAAmB;MACjBC,OAAO,EAAEF,GADQ;MAEjBR,KAAK,EAAEA,KAAK,CAACQ,GAAD,CAAL,CAAWG,GAAX,CAAe,UAACC,aAAD,EAAc;QAClC,WAAI,CAACC,IAAL,CAAUd,eAAV,EAA2Ba,aAA3B;MAAyC,CADpC;IAFU,CAAnB;EAMD,CAdmB,CAepB;EACA;;;EACA,IAAI,CAACZ,KAAK,CAAC,GAAD,CAAN,IAAeC,WAAnB,EAAgC;IAC9BK,aAAa,CAACG,IAAd,CAAmB;MACjBC,OAAO,EAAE,GADQ;MAEjBV,KAAK,EAAE,CAAC,UAAGD,eAAe,CAACe,OAAhB,CAAwB,KAAxB,EAA+B,EAA/B,CAAH,EAAqC,IAArC,CAAD;IAFU,CAAnB;EAID;;EAED,OAAOR,aAAP;AACD;;AA5BDS;AA8BA;;;;;AAIA,SAASZ,mBAAT,CAA6Ba,GAA7B,EAA+C;EAC7C,OAAOA,GAAG,CACPC,MADI,GAEJC,IAFI,CAEC,UAACC,CAAD,EAAYC,CAAZ,EAAqB;IAAK,sBAAe,CAACA,CAAD,CAAf,GAAqBC,eAAe,CAACF,CAAD,CAApC;EAAuC,CAFlE,CAAP;AAGD;;AAED,SAASE,eAAT,CAAyBX,OAAzB,EAAwC;EACtC,IAAMY,YAAY,GAAGZ,OAAO,CAACa,OAAR,CAAgB,GAAhB,CAArB;EACA,OAAOb,OAAO,CAACc,MAAR,CAAe,CAAf,EAAkBF,YAAlB,EAAgCG,MAAvC;AACD","names":["getAbsoluteMappingEntries","absoluteBaseUrl","paths","addMatchAll","sortedKeys","sortByLongestPrefix","Object","keys","absolutePaths","_i","key","push","pattern","map","pathToResolve","join","replace","exports","arr","concat","sort","a","b","getPrefixLength","prefixLength","indexOf","substr","length"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\tsconfig-paths\\src\\mapping-entry.ts"],"sourcesContent":["import * as path from \"path\";\n\nexport interface MappingEntry {\n  readonly pattern: string;\n  readonly paths: ReadonlyArray<string>;\n}\n\nexport interface Paths {\n  readonly [key: string]: ReadonlyArray<string>;\n}\n\n/**\n * Converts an absolute baseUrl and paths to an array of absolute mapping entries.\n * The array is sorted by longest prefix.\n * Having an array with entries allows us to keep a sorting order rather than\n * sort by keys each time we use the mappings.\n * @param absoluteBaseUrl\n * @param paths\n * @param addMatchAll\n */\nexport function getAbsoluteMappingEntries(\n  absoluteBaseUrl: string,\n  paths: Paths,\n  addMatchAll: boolean\n): ReadonlyArray<MappingEntry> {\n  // Resolve all paths to absolute form once here, and sort them by\n  // longest prefix once here, this saves time on each request later.\n  // We need to put them in an array to preserve the sorting order.\n  const sortedKeys = sortByLongestPrefix(Object.keys(paths));\n  const absolutePaths: Array<MappingEntry> = [];\n  for (const key of sortedKeys) {\n    absolutePaths.push({\n      pattern: key,\n      paths: paths[key].map((pathToResolve) =>\n        path.join(absoluteBaseUrl, pathToResolve)\n      ),\n    });\n  }\n  // If there is no match-all path specified in the paths section of tsconfig, then try to match\n  // all paths relative to baseUrl, this is how typescript works.\n  if (!paths[\"*\"] && addMatchAll) {\n    absolutePaths.push({\n      pattern: \"*\",\n      paths: [`${absoluteBaseUrl.replace(/\\/$/, \"\")}/*`],\n    });\n  }\n\n  return absolutePaths;\n}\n\n/**\n * Sort path patterns.\n * If a module name can be matched with multiple patterns then pattern with the longest prefix will be picked.\n */\nfunction sortByLongestPrefix(arr: Array<string>): Array<string> {\n  return arr\n    .concat()\n    .sort((a: string, b: string) => getPrefixLength(b) - getPrefixLength(a));\n}\n\nfunction getPrefixLength(pattern: string): number {\n  const prefixLength = pattern.indexOf(\"*\");\n  return pattern.substr(0, prefixLength).length;\n}\n"]},"metadata":{},"sourceType":"script"}