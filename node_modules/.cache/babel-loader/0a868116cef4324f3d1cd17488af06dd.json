{"ast":null,"code":"// Copyright 2012 The Obvious Corporation.\n\n/*\n * leb: LEB128 utilities.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _long = _interopRequireDefault(require(\"@xtuc/long\"));\n\nvar bits = _interopRequireWildcard(require(\"./bits\"));\n\nvar bufs = _interopRequireWildcard(require(\"./bufs\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*\n * Module variables\n */\n\n/** The minimum possible 32-bit signed int. */\n\n\nvar MIN_INT32 = -0x80000000;\n/** The maximum possible 32-bit signed int. */\n\nvar MAX_INT32 = 0x7fffffff;\n/** The maximum possible 32-bit unsigned int. */\n\nvar MAX_UINT32 = 0xffffffff;\n/** The minimum possible 64-bit signed int. */\n// const MIN_INT64 = -0x8000000000000000;\n\n/**\n * The maximum possible 64-bit signed int that is representable as a\n * JavaScript number.\n */\n// const MAX_INT64 = 0x7ffffffffffffc00;\n\n/**\n * The maximum possible 64-bit unsigned int that is representable as a\n * JavaScript number.\n */\n// const MAX_UINT64 = 0xfffffffffffff800;\n\n/*\n * Helper functions\n */\n\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as a signed value. The buffer is\n * taken to represent a signed number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order non-sign-matching bit, plus two. For example:\n *\n *   11111011 01110101\n *   high          low\n *\n * The sign bit here is 1 (that is, it's a negative number). The highest\n * bit number that doesn't match the sign is bit #10 (where the lowest-order\n * bit is bit #0). So, we have to encode at least 12 bits total.\n *\n * As a special degenerate case, the numbers 0 and -1 each require just one bit.\n */\n\nfunction signedBitCount(buffer) {\n  return bits.highOrder(bits.getSign(buffer) ^ 1, buffer) + 2;\n}\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as an unsigned value. The buffer is\n * taken to represent an unsigned number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order 1 bit, plus one. For example:\n *\n *   00011000 01010011\n *   high          low\n *\n * The highest-order 1 bit here is bit #12 (where the lowest-order bit\n * is bit #0). So, we have to encode at least 13 bits total.\n *\n * As a special degenerate case, the number 0 requires 1 bit.\n */\n\n\nfunction unsignedBitCount(buffer) {\n  var result = bits.highOrder(1, buffer) + 1;\n  return result ? result : 1;\n}\n/**\n * Common encoder for both signed and unsigned ints. This takes a\n * bigint-ish buffer, returning an LEB128-encoded buffer.\n */\n\n\nfunction encodeBufferCommon(buffer, signed) {\n  var signBit;\n  var bitCount;\n\n  if (signed) {\n    signBit = bits.getSign(buffer);\n    bitCount = signedBitCount(buffer);\n  } else {\n    signBit = 0;\n    bitCount = unsignedBitCount(buffer);\n  }\n\n  var byteCount = Math.ceil(bitCount / 7);\n  var result = bufs.alloc(byteCount);\n\n  for (var i = 0; i < byteCount; i++) {\n    var payload = bits.extract(buffer, i * 7, 7, signBit);\n    result[i] = payload | 0x80;\n  } // Mask off the top bit of the last byte, to indicate the end of the\n  // encoding.\n\n\n  result[byteCount - 1] &= 0x7f;\n  return result;\n}\n/**\n * Gets the byte-length of the value encoded in the given buffer at\n * the given index.\n */\n\n\nfunction encodedLength(encodedBuffer, index) {\n  var result = 0;\n\n  while (encodedBuffer[index + result] >= 0x80) {\n    result++;\n  }\n\n  result++; // to account for the last byte\n\n  if (index + result > encodedBuffer.length) {// FIXME(sven): seems to cause false positives\n    // throw new Error(\"integer representation too long\");\n  }\n\n  return result;\n}\n/**\n * Common decoder for both signed and unsigned ints. This takes an\n * LEB128-encoded buffer, returning a bigint-ish buffer.\n */\n\n\nfunction decodeBufferCommon(encodedBuffer, index, signed) {\n  index = index === undefined ? 0 : index;\n  var length = encodedLength(encodedBuffer, index);\n  var bitLength = length * 7;\n  var byteLength = Math.ceil(bitLength / 8);\n  var result = bufs.alloc(byteLength);\n  var outIndex = 0;\n\n  while (length > 0) {\n    bits.inject(result, outIndex, 7, encodedBuffer[index]);\n    outIndex += 7;\n    index++;\n    length--;\n  }\n\n  var signBit;\n  var signByte;\n\n  if (signed) {\n    // Sign-extend the last byte.\n    var lastByte = result[byteLength - 1];\n    var endBit = outIndex % 8;\n\n    if (endBit !== 0) {\n      var shift = 32 - endBit; // 32 because JS bit ops work on 32-bit ints.\n\n      lastByte = result[byteLength - 1] = lastByte << shift >> shift & 0xff;\n    }\n\n    signBit = lastByte >> 7;\n    signByte = signBit * 0xff;\n  } else {\n    signBit = 0;\n    signByte = 0;\n  } // Slice off any superfluous bytes, that is, ones that add no meaningful\n  // bits (because the value would be the same if they were removed).\n\n\n  while (byteLength > 1 && result[byteLength - 1] === signByte && (!signed || result[byteLength - 2] >> 7 === signBit)) {\n    byteLength--;\n  }\n\n  result = bufs.resize(result, byteLength);\n  return {\n    value: result,\n    nextIndex: index\n  };\n}\n/*\n * Exported bindings\n */\n\n\nfunction encodeIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, true);\n}\n\nfunction decodeIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, true);\n}\n\nfunction encodeInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeInt32LE(num, 0);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt32(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value < MIN_INT32 || value > MAX_INT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeInt64(num, buf);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt64(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n\n  var value = _long.default.fromBytesLE(result.value, false);\n\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nfunction encodeUIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, false);\n}\n\nfunction decodeUIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, false);\n}\n\nfunction encodeUInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeUInt32LE(num, 0);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt32(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readUInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value > MAX_UINT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeUInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeUInt64(num, buf);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt64(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n\n  var value = _long.default.fromBytesLE(result.value, true);\n\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nvar _default = {\n  decodeInt32: decodeInt32,\n  decodeInt64: decodeInt64,\n  decodeIntBuffer: decodeIntBuffer,\n  decodeUInt32: decodeUInt32,\n  decodeUInt64: decodeUInt64,\n  decodeUIntBuffer: decodeUIntBuffer,\n  encodeInt32: encodeInt32,\n  encodeInt64: encodeInt64,\n  encodeIntBuffer: encodeIntBuffer,\n  encodeUInt32: encodeUInt32,\n  encodeUInt64: encodeUInt64,\n  encodeUIntBuffer: encodeUIntBuffer\n};\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_long","_interopRequireDefault","require","bits","_interopRequireWildcard","bufs","obj","__esModule","newObj","key","prototype","hasOwnProperty","call","desc","getOwnPropertyDescriptor","get","set","MIN_INT32","MAX_INT32","MAX_UINT32","signedBitCount","buffer","highOrder","getSign","unsignedBitCount","result","encodeBufferCommon","signed","signBit","bitCount","byteCount","Math","ceil","alloc","i","payload","extract","encodedLength","encodedBuffer","index","length","decodeBufferCommon","undefined","bitLength","byteLength","outIndex","inject","signByte","lastByte","endBit","shift","resize","nextIndex","encodeIntBuffer","decodeIntBuffer","encodeInt32","num","buf","writeInt32LE","free","decodeInt32","parsed","readInt","Error","encodeInt64","writeInt64","decodeInt64","fromBytesLE","lossy","encodeUIntBuffer","decodeUIntBuffer","encodeUInt32","writeUInt32LE","decodeUInt32","readUInt","encodeUInt64","writeUInt64","decodeUInt64","_default"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@webassemblyjs/leb128/lib/leb.js"],"sourcesContent":["// Copyright 2012 The Obvious Corporation.\n\n/*\n * leb: LEB128 utilities.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _long = _interopRequireDefault(require(\"@xtuc/long\"));\n\nvar bits = _interopRequireWildcard(require(\"./bits\"));\n\nvar bufs = _interopRequireWildcard(require(\"./bufs\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * Module variables\n */\n\n/** The minimum possible 32-bit signed int. */\nvar MIN_INT32 = -0x80000000;\n/** The maximum possible 32-bit signed int. */\n\nvar MAX_INT32 = 0x7fffffff;\n/** The maximum possible 32-bit unsigned int. */\n\nvar MAX_UINT32 = 0xffffffff;\n/** The minimum possible 64-bit signed int. */\n// const MIN_INT64 = -0x8000000000000000;\n\n/**\n * The maximum possible 64-bit signed int that is representable as a\n * JavaScript number.\n */\n// const MAX_INT64 = 0x7ffffffffffffc00;\n\n/**\n * The maximum possible 64-bit unsigned int that is representable as a\n * JavaScript number.\n */\n// const MAX_UINT64 = 0xfffffffffffff800;\n\n/*\n * Helper functions\n */\n\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as a signed value. The buffer is\n * taken to represent a signed number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order non-sign-matching bit, plus two. For example:\n *\n *   11111011 01110101\n *   high          low\n *\n * The sign bit here is 1 (that is, it's a negative number). The highest\n * bit number that doesn't match the sign is bit #10 (where the lowest-order\n * bit is bit #0). So, we have to encode at least 12 bits total.\n *\n * As a special degenerate case, the numbers 0 and -1 each require just one bit.\n */\n\nfunction signedBitCount(buffer) {\n  return bits.highOrder(bits.getSign(buffer) ^ 1, buffer) + 2;\n}\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as an unsigned value. The buffer is\n * taken to represent an unsigned number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order 1 bit, plus one. For example:\n *\n *   00011000 01010011\n *   high          low\n *\n * The highest-order 1 bit here is bit #12 (where the lowest-order bit\n * is bit #0). So, we have to encode at least 13 bits total.\n *\n * As a special degenerate case, the number 0 requires 1 bit.\n */\n\n\nfunction unsignedBitCount(buffer) {\n  var result = bits.highOrder(1, buffer) + 1;\n  return result ? result : 1;\n}\n/**\n * Common encoder for both signed and unsigned ints. This takes a\n * bigint-ish buffer, returning an LEB128-encoded buffer.\n */\n\n\nfunction encodeBufferCommon(buffer, signed) {\n  var signBit;\n  var bitCount;\n\n  if (signed) {\n    signBit = bits.getSign(buffer);\n    bitCount = signedBitCount(buffer);\n  } else {\n    signBit = 0;\n    bitCount = unsignedBitCount(buffer);\n  }\n\n  var byteCount = Math.ceil(bitCount / 7);\n  var result = bufs.alloc(byteCount);\n\n  for (var i = 0; i < byteCount; i++) {\n    var payload = bits.extract(buffer, i * 7, 7, signBit);\n    result[i] = payload | 0x80;\n  } // Mask off the top bit of the last byte, to indicate the end of the\n  // encoding.\n\n\n  result[byteCount - 1] &= 0x7f;\n  return result;\n}\n/**\n * Gets the byte-length of the value encoded in the given buffer at\n * the given index.\n */\n\n\nfunction encodedLength(encodedBuffer, index) {\n  var result = 0;\n\n  while (encodedBuffer[index + result] >= 0x80) {\n    result++;\n  }\n\n  result++; // to account for the last byte\n\n  if (index + result > encodedBuffer.length) {// FIXME(sven): seems to cause false positives\n    // throw new Error(\"integer representation too long\");\n  }\n\n  return result;\n}\n/**\n * Common decoder for both signed and unsigned ints. This takes an\n * LEB128-encoded buffer, returning a bigint-ish buffer.\n */\n\n\nfunction decodeBufferCommon(encodedBuffer, index, signed) {\n  index = index === undefined ? 0 : index;\n  var length = encodedLength(encodedBuffer, index);\n  var bitLength = length * 7;\n  var byteLength = Math.ceil(bitLength / 8);\n  var result = bufs.alloc(byteLength);\n  var outIndex = 0;\n\n  while (length > 0) {\n    bits.inject(result, outIndex, 7, encodedBuffer[index]);\n    outIndex += 7;\n    index++;\n    length--;\n  }\n\n  var signBit;\n  var signByte;\n\n  if (signed) {\n    // Sign-extend the last byte.\n    var lastByte = result[byteLength - 1];\n    var endBit = outIndex % 8;\n\n    if (endBit !== 0) {\n      var shift = 32 - endBit; // 32 because JS bit ops work on 32-bit ints.\n\n      lastByte = result[byteLength - 1] = lastByte << shift >> shift & 0xff;\n    }\n\n    signBit = lastByte >> 7;\n    signByte = signBit * 0xff;\n  } else {\n    signBit = 0;\n    signByte = 0;\n  } // Slice off any superfluous bytes, that is, ones that add no meaningful\n  // bits (because the value would be the same if they were removed).\n\n\n  while (byteLength > 1 && result[byteLength - 1] === signByte && (!signed || result[byteLength - 2] >> 7 === signBit)) {\n    byteLength--;\n  }\n\n  result = bufs.resize(result, byteLength);\n  return {\n    value: result,\n    nextIndex: index\n  };\n}\n/*\n * Exported bindings\n */\n\n\nfunction encodeIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, true);\n}\n\nfunction decodeIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, true);\n}\n\nfunction encodeInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeInt32LE(num, 0);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt32(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value < MIN_INT32 || value > MAX_INT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeInt64(num, buf);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt64(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n\n  var value = _long.default.fromBytesLE(result.value, false);\n\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nfunction encodeUIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, false);\n}\n\nfunction decodeUIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, false);\n}\n\nfunction encodeUInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeUInt32LE(num, 0);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt32(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readUInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value > MAX_UINT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeUInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeUInt64(num, buf);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt64(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n\n  var value = _long.default.fromBytesLE(result.value, true);\n\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nvar _default = {\n  decodeInt32: decodeInt32,\n  decodeInt64: decodeInt64,\n  decodeIntBuffer: decodeIntBuffer,\n  decodeUInt32: decodeUInt32,\n  decodeUInt64: decodeUInt64,\n  decodeUIntBuffer: decodeUIntBuffer,\n  encodeInt32: encodeInt32,\n  encodeInt64: encodeInt64,\n  encodeIntBuffer: encodeIntBuffer,\n  encodeUInt32: encodeUInt32,\n  encodeUInt64: encodeUInt64,\n  encodeUIntBuffer: encodeUIntBuffer\n};\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}