{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _UnusedVarsVisitor_scopeManager;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectUnusedVariables = void 0;\n\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\n\nconst Visitor_1 = require(\"@typescript-eslint/scope-manager/dist/referencer/Visitor\");\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nclass UnusedVarsVisitor extends Visitor_1.Visitor {\n  // readonly #unusedVariables = new Set<TSESLint.Scope.Variable>();\n  constructor(context) {\n    super({\n      visitChildrenEvenIfSelectorExists: true\n    });\n\n    _UnusedVarsVisitor_scopeManager.set(this, void 0); //#endregion HELPERS\n    //#region VISITORS\n    // NOTE - This is a simple visitor - meaning it does not support selectors\n\n\n    this.ClassDeclaration = this.visitClass;\n    this.ClassExpression = this.visitClass;\n    this.FunctionDeclaration = this.visitFunction;\n    this.FunctionExpression = this.visitFunction;\n    this.MethodDefinition = this.visitSetter;\n    this.Property = this.visitSetter;\n    this.TSCallSignatureDeclaration = this.visitFunctionTypeSignature;\n    this.TSConstructorType = this.visitFunctionTypeSignature;\n    this.TSConstructSignatureDeclaration = this.visitFunctionTypeSignature;\n    this.TSDeclareFunction = this.visitFunctionTypeSignature;\n    this.TSEmptyBodyFunctionExpression = this.visitFunctionTypeSignature;\n    this.TSFunctionType = this.visitFunctionTypeSignature;\n    this.TSMethodSignature = this.visitFunctionTypeSignature;\n\n    __classPrivateFieldSet(this, _UnusedVarsVisitor_scopeManager, utils_1.ESLintUtils.nullThrows(context.getSourceCode().scopeManager, 'Missing required scope manager'), \"f\");\n  }\n\n  static collectUnusedVariables(context) {\n    const program = context.getSourceCode().ast;\n    const cached = this.RESULTS_CACHE.get(program);\n\n    if (cached) {\n      return cached;\n    }\n\n    const visitor = new this(context);\n    visitor.visit(program);\n    const unusedVars = visitor.collectUnusedVariables(visitor.getScope(program));\n    this.RESULTS_CACHE.set(program, unusedVars);\n    return unusedVars;\n  }\n\n  collectUnusedVariables(scope) {\n    let unusedVariables = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n\n    for (const variable of scope.variables) {\n      if ( // skip function expression names,\n      scope.functionExpressionScope || // variables marked with markVariableAsUsed(),\n      variable.eslintUsed || // implicit lib variables (from @typescript-eslint/scope-manager),\n      variable instanceof scope_manager_1.ImplicitLibVariable || // basic exported variables\n      isExported(variable) || // variables implicitly exported via a merged declaration\n      isMergableExported(variable) || // used variables\n      isUsedVariable(variable)) {\n        continue;\n      }\n\n      unusedVariables.add(variable);\n    }\n\n    for (const childScope of scope.childScopes) {\n      this.collectUnusedVariables(childScope, unusedVariables);\n    }\n\n    return unusedVariables;\n  } //#region HELPERS\n\n\n  getScope(currentNode) {\n    // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\n    const inner = currentNode.type !== utils_1.AST_NODE_TYPES.Program;\n    let node = currentNode;\n\n    while (node) {\n      const scope = __classPrivateFieldGet(this, _UnusedVarsVisitor_scopeManager, \"f\").acquire(node, inner);\n\n      if (scope) {\n        if (scope.type === 'function-expression-name') {\n          return scope.childScopes[0];\n        }\n\n        return scope;\n      }\n\n      node = node.parent;\n    }\n\n    return __classPrivateFieldGet(this, _UnusedVarsVisitor_scopeManager, \"f\").scopes[0];\n  }\n\n  markVariableAsUsed(variableOrIdentifierOrName, parent) {\n    if (typeof variableOrIdentifierOrName !== 'string' && !('type' in variableOrIdentifierOrName)) {\n      variableOrIdentifierOrName.eslintUsed = true;\n      return;\n    }\n\n    let name;\n    let node;\n\n    if (typeof variableOrIdentifierOrName === 'string') {\n      name = variableOrIdentifierOrName;\n      node = parent;\n    } else {\n      name = variableOrIdentifierOrName.name;\n      node = variableOrIdentifierOrName;\n    }\n\n    let currentScope = this.getScope(node);\n\n    while (currentScope) {\n      const variable = currentScope.variables.find(scopeVar => scopeVar.name === name);\n\n      if (variable) {\n        variable.eslintUsed = true;\n        return;\n      }\n\n      currentScope = currentScope.upper;\n    }\n  }\n\n  visitClass(node) {\n    // skip a variable of class itself name in the class scope\n    const scope = this.getScope(node);\n\n    for (const variable of scope.variables) {\n      if (variable.identifiers[0] === scope.block.id) {\n        this.markVariableAsUsed(variable);\n        return;\n      }\n    }\n  }\n\n  visitFunction(node) {\n    const scope = this.getScope(node); // skip implicit \"arguments\" variable\n\n    const variable = scope.set.get('arguments');\n\n    if ((variable === null || variable === void 0 ? void 0 : variable.defs.length) === 0) {\n      this.markVariableAsUsed(variable);\n    }\n  }\n\n  visitFunctionTypeSignature(node) {\n    // function type signature params create variables because they can be referenced within the signature,\n    // but they obviously aren't unused variables for the purposes of this rule.\n    for (const param of node.params) {\n      this.visitPattern(param, name => {\n        this.markVariableAsUsed(name);\n      });\n    }\n  }\n\n  visitSetter(node) {\n    if (node.kind === 'set') {\n      // ignore setter parameters because they're syntactically required to exist\n      for (const param of node.value.params) {\n        this.visitPattern(param, id => {\n          this.markVariableAsUsed(id);\n        });\n      }\n    }\n  }\n\n  ForInStatement(node) {\n    /**\n     * (Brad Zacher): I hate that this has to exist.\n     * But it is required for compat with the base ESLint rule.\n     *\n     * In 2015, ESLint decided to add an exception for these two specific cases\n     * ```\n     * for (var key in object) return;\n     *\n     * var key;\n     * for (key in object) return;\n     * ```\n     *\n     * I disagree with it, but what are you going to do...\n     *\n     * https://github.com/eslint/eslint/issues/2342\n     */\n    let idOrVariable;\n\n    if (node.left.type === utils_1.AST_NODE_TYPES.VariableDeclaration) {\n      const variable = __classPrivateFieldGet(this, _UnusedVarsVisitor_scopeManager, \"f\").getDeclaredVariables(node.left)[0];\n\n      if (!variable) {\n        return;\n      }\n\n      idOrVariable = variable;\n    }\n\n    if (node.left.type === utils_1.AST_NODE_TYPES.Identifier) {\n      idOrVariable = node.left;\n    }\n\n    if (idOrVariable == null) {\n      return;\n    }\n\n    let body = node.body;\n\n    if (node.body.type === utils_1.AST_NODE_TYPES.BlockStatement) {\n      if (node.body.body.length !== 1) {\n        return;\n      }\n\n      body = node.body.body[0];\n    }\n\n    if (body.type !== utils_1.AST_NODE_TYPES.ReturnStatement) {\n      return;\n    }\n\n    this.markVariableAsUsed(idOrVariable);\n  }\n\n  Identifier(node) {\n    const scope = this.getScope(node);\n\n    if (scope.type === utils_1.TSESLint.Scope.ScopeType.function && node.name === 'this') {\n      // this parameters should always be considered used as they're pseudo-parameters\n      if ('params' in scope.block && scope.block.params.includes(node)) {\n        this.markVariableAsUsed(node);\n      }\n    }\n  }\n\n  TSEnumDeclaration(node) {\n    // enum members create variables because they can be referenced within the enum,\n    // but they obviously aren't unused variables for the purposes of this rule.\n    const scope = this.getScope(node);\n\n    for (const variable of scope.variables) {\n      this.markVariableAsUsed(variable);\n    }\n  }\n\n  TSMappedType(node) {\n    // mapped types create a variable for their type name, but it's not necessary to reference it,\n    // so we shouldn't consider it as unused for the purpose of this rule.\n    this.markVariableAsUsed(node.typeParameter.name);\n  }\n\n  TSModuleDeclaration(node) {\n    // -- global augmentation can be in any file, and they do not need exports\n    if (node.global === true) {\n      this.markVariableAsUsed('global', node.parent);\n    }\n  }\n\n  TSParameterProperty(node) {\n    let identifier = null;\n\n    switch (node.parameter.type) {\n      case utils_1.AST_NODE_TYPES.AssignmentPattern:\n        if (node.parameter.left.type === utils_1.AST_NODE_TYPES.Identifier) {\n          identifier = node.parameter.left;\n        }\n\n        break;\n\n      case utils_1.AST_NODE_TYPES.Identifier:\n        identifier = node.parameter;\n        break;\n    }\n\n    if (identifier) {\n      this.markVariableAsUsed(identifier);\n    }\n  }\n\n}\n\n_UnusedVarsVisitor_scopeManager = new WeakMap();\nUnusedVarsVisitor.RESULTS_CACHE = new WeakMap(); //#region private helpers\n\n/**\n * Checks the position of given nodes.\n * @param inner A node which is expected as inside.\n * @param outer A node which is expected as outside.\n * @returns `true` if the `inner` node exists in the `outer` node.\n */\n\nfunction isInside(inner, outer) {\n  return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];\n}\n/**\n * Determine if an identifier is referencing an enclosing name.\n * This only applies to declarations that create their own scope (modules, functions, classes)\n * @param ref The reference to check.\n * @param nodes The candidate function nodes.\n * @returns True if it's a self-reference, false if not.\n */\n\n\nfunction isSelfReference(ref, nodes) {\n  let scope = ref.from;\n\n  while (scope) {\n    if (nodes.has(scope.block)) {\n      return true;\n    }\n\n    scope = scope.upper;\n  }\n\n  return false;\n}\n\nconst MERGABLE_TYPES = new Set([utils_1.AST_NODE_TYPES.TSInterfaceDeclaration, utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration, utils_1.AST_NODE_TYPES.TSModuleDeclaration, utils_1.AST_NODE_TYPES.ClassDeclaration, utils_1.AST_NODE_TYPES.FunctionDeclaration]);\n/**\n * Determine if the variable is directly exported\n * @param variable the variable to check\n * @param target the type of node that is expected to be exported\n */\n\nfunction isMergableExported(variable) {\n  var _a, _b; // If all of the merged things are of the same type, TS will error if not all of them are exported - so we only need to find one\n\n\n  for (const def of variable.defs) {\n    // parameters can never be exported.\n    // their `node` prop points to the function decl, which can be exported\n    // so we need to special case them\n    if (def.type === utils_1.TSESLint.Scope.DefinitionType.Parameter) {\n      continue;\n    }\n\n    if (MERGABLE_TYPES.has(def.node.type) && ((_a = def.node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.ExportNamedDeclaration || ((_b = def.node.parent) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Determines if a given variable is being exported from a module.\n * @param variable eslint-scope variable object.\n * @returns True if the variable is exported, false if not.\n */\n\n\nfunction isExported(variable) {\n  const definition = variable.defs[0];\n\n  if (definition) {\n    let node = definition.node;\n\n    if (node.type === utils_1.AST_NODE_TYPES.VariableDeclarator) {\n      node = node.parent;\n    } else if (definition.type === utils_1.TSESLint.Scope.DefinitionType.Parameter) {\n      return false;\n    }\n\n    return node.parent.type.indexOf('Export') === 0;\n  }\n\n  return false;\n}\n/**\n * Determines if the variable is used.\n * @param variable The variable to check.\n * @returns True if the variable is used\n */\n\n\nfunction isUsedVariable(variable) {\n  /**\n   * Gets a list of function definitions for a specified variable.\n   * @param variable eslint-scope variable object.\n   * @returns Function nodes.\n   */\n  function getFunctionDefinitions(variable) {\n    const functionDefinitions = new Set();\n    variable.defs.forEach(def => {\n      var _a, _b; // FunctionDeclarations\n\n\n      if (def.type === utils_1.TSESLint.Scope.DefinitionType.FunctionName) {\n        functionDefinitions.add(def.node);\n      } // FunctionExpressions\n\n\n      if (def.type === utils_1.TSESLint.Scope.DefinitionType.Variable && (((_a = def.node.init) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.FunctionExpression || ((_b = def.node.init) === null || _b === void 0 ? void 0 : _b.type) === utils_1.AST_NODE_TYPES.ArrowFunctionExpression)) {\n        functionDefinitions.add(def.node.init);\n      }\n    });\n    return functionDefinitions;\n  }\n\n  function getTypeDeclarations(variable) {\n    const nodes = new Set();\n    variable.defs.forEach(def => {\n      if (def.node.type === utils_1.AST_NODE_TYPES.TSInterfaceDeclaration || def.node.type === utils_1.AST_NODE_TYPES.TSTypeAliasDeclaration) {\n        nodes.add(def.node);\n      }\n    });\n    return nodes;\n  }\n\n  function getModuleDeclarations(variable) {\n    const nodes = new Set();\n    variable.defs.forEach(def => {\n      if (def.node.type === utils_1.AST_NODE_TYPES.TSModuleDeclaration) {\n        nodes.add(def.node);\n      }\n    });\n    return nodes;\n  }\n  /**\n   * Checks if the ref is contained within one of the given nodes\n   */\n\n\n  function isInsideOneOf(ref, nodes) {\n    for (const node of nodes) {\n      if (isInside(ref.identifier, node)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * If a given reference is left-hand side of an assignment, this gets\n   * the right-hand side node of the assignment.\n   *\n   * In the following cases, this returns null.\n   *\n   * - The reference is not the LHS of an assignment expression.\n   * - The reference is inside of a loop.\n   * - The reference is inside of a function scope which is different from\n   *   the declaration.\n   * @param ref A reference to check.\n   * @param prevRhsNode The previous RHS node.\n   * @returns The RHS node or null.\n   */\n\n\n  function getRhsNode(ref, prevRhsNode) {\n    /**\n     * Checks whether the given node is in a loop or not.\n     * @param node The node to check.\n     * @returns `true` if the node is in a loop.\n     */\n    function isInLoop(node) {\n      let currentNode = node;\n\n      while (currentNode) {\n        if (utils_1.ASTUtils.isFunction(currentNode)) {\n          break;\n        }\n\n        if (utils_1.ASTUtils.isLoop(currentNode)) {\n          return true;\n        }\n\n        currentNode = currentNode.parent;\n      }\n\n      return false;\n    }\n\n    const id = ref.identifier;\n    const parent = id.parent;\n    const grandparent = parent.parent;\n    const refScope = ref.from.variableScope;\n    const varScope = ref.resolved.scope.variableScope;\n    const canBeUsedLater = refScope !== varScope || isInLoop(id);\n    /*\n     * Inherits the previous node if this reference is in the node.\n     * This is for `a = a + a`-like code.\n     */\n\n    if (prevRhsNode && isInside(id, prevRhsNode)) {\n      return prevRhsNode;\n    }\n\n    if (parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression && grandparent.type === utils_1.AST_NODE_TYPES.ExpressionStatement && id === parent.left && !canBeUsedLater) {\n      return parent.right;\n    }\n\n    return null;\n  }\n  /**\n   * Checks whether a given reference is a read to update itself or not.\n   * @param ref A reference to check.\n   * @param rhsNode The RHS node of the previous assignment.\n   * @returns The reference is a read to update itself.\n   */\n\n\n  function isReadForItself(ref, rhsNode) {\n    /**\n     * Checks whether a given Identifier node exists inside of a function node which can be used later.\n     *\n     * \"can be used later\" means:\n     * - the function is assigned to a variable.\n     * - the function is bound to a property and the object can be used later.\n     * - the function is bound as an argument of a function call.\n     *\n     * If a reference exists in a function which can be used later, the reference is read when the function is called.\n     * @param id An Identifier node to check.\n     * @param rhsNode The RHS node of the previous assignment.\n     * @returns `true` if the `id` node exists inside of a function node which can be used later.\n     */\n    function isInsideOfStorableFunction(id, rhsNode) {\n      /**\n       * Finds a function node from ancestors of a node.\n       * @param node A start node to find.\n       * @returns A found function node.\n       */\n      function getUpperFunction(node) {\n        let currentNode = node;\n\n        while (currentNode) {\n          if (utils_1.ASTUtils.isFunction(currentNode)) {\n            return currentNode;\n          }\n\n          currentNode = currentNode.parent;\n        }\n\n        return null;\n      }\n      /**\n       * Checks whether a given function node is stored to somewhere or not.\n       * If the function node is stored, the function can be used later.\n       * @param funcNode A function node to check.\n       * @param rhsNode The RHS node of the previous assignment.\n       * @returns `true` if under the following conditions:\n       *      - the funcNode is assigned to a variable.\n       *      - the funcNode is bound as an argument of a function call.\n       *      - the function is bound to a property and the object satisfies above conditions.\n       */\n\n\n      function isStorableFunction(funcNode, rhsNode) {\n        let node = funcNode;\n        let parent = funcNode.parent;\n\n        while (parent && isInside(parent, rhsNode)) {\n          switch (parent.type) {\n            case utils_1.AST_NODE_TYPES.SequenceExpression:\n              if (parent.expressions[parent.expressions.length - 1] !== node) {\n                return false;\n              }\n\n              break;\n\n            case utils_1.AST_NODE_TYPES.CallExpression:\n            case utils_1.AST_NODE_TYPES.NewExpression:\n              return parent.callee !== node;\n\n            case utils_1.AST_NODE_TYPES.AssignmentExpression:\n            case utils_1.AST_NODE_TYPES.TaggedTemplateExpression:\n            case utils_1.AST_NODE_TYPES.YieldExpression:\n              return true;\n\n            default:\n              if (parent.type.endsWith('Statement') || parent.type.endsWith('Declaration')) {\n                /*\n                 * If it encountered statements, this is a complex pattern.\n                 * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\n                 */\n                return true;\n              }\n\n          }\n\n          node = parent;\n          parent = parent.parent;\n        }\n\n        return false;\n      }\n\n      const funcNode = getUpperFunction(id);\n      return !!funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);\n    }\n\n    const id = ref.identifier;\n    const parent = id.parent;\n    const grandparent = parent.parent;\n    return ref.isRead() && ( // in RHS of an assignment for itself. e.g. `a = a + 1`\n    // self update. e.g. `a += 1`, `a++`\n    parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression && grandparent.type === utils_1.AST_NODE_TYPES.ExpressionStatement && parent.left === id || parent.type === utils_1.AST_NODE_TYPES.UpdateExpression && grandparent.type === utils_1.AST_NODE_TYPES.ExpressionStatement || !!rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));\n  }\n\n  const functionNodes = getFunctionDefinitions(variable);\n  const isFunctionDefinition = functionNodes.size > 0;\n  const typeDeclNodes = getTypeDeclarations(variable);\n  const isTypeDecl = typeDeclNodes.size > 0;\n  const moduleDeclNodes = getModuleDeclarations(variable);\n  const isModuleDecl = moduleDeclNodes.size > 0;\n  let rhsNode = null;\n  return variable.references.some(ref => {\n    const forItself = isReadForItself(ref, rhsNode);\n    rhsNode = getRhsNode(ref, rhsNode);\n    return ref.isRead() && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes)) && !(isTypeDecl && isInsideOneOf(ref, typeDeclNodes)) && !(isModuleDecl && isSelfReference(ref, moduleDeclNodes));\n  });\n} //#endregion private helpers\n\n/**\n * Collects the set of unused variables for a given context.\n *\n * Due to complexity, this does not take into consideration:\n * - variables within declaration files\n * - variables within ambient module declarations\n */\n\n\nfunction collectUnusedVariables(context) {\n  return UnusedVarsVisitor.collectUnusedVariables(context);\n}\n\nexports.collectUnusedVariables = collectUnusedVariables;","map":{"version":3,"mappings":"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","names":["UnusedVarsVisitor","Visitor_1","constructor","context","visitChildrenEvenIfSelectorExists","_UnusedVarsVisitor_scopeManager","visitClass","visitFunction","visitSetter","visitFunctionTypeSignature","__classPrivateFieldSet","utils_1","nullThrows","getSourceCode","scopeManager","collectUnusedVariables","program","ast","cached","RESULTS_CACHE","get","visitor","visit","unusedVars","getScope","set","scope","unusedVariables","Set","variable","variables","functionExpressionScope","eslintUsed","scope_manager_1","isExported","isMergableExported","isUsedVariable","add","childScope","childScopes","currentNode","inner","type","Program","node","__classPrivateFieldGet","acquire","parent","scopes","markVariableAsUsed","variableOrIdentifierOrName","name","currentScope","find","scopeVar","upper","identifiers","block","id","defs","length","param","params","visitPattern","kind","value","ForInStatement","idOrVariable","left","VariableDeclaration","getDeclaredVariables","Identifier","body","BlockStatement","ReturnStatement","Scope","ScopeType","function","includes","TSEnumDeclaration","TSMappedType","typeParameter","TSModuleDeclaration","global","TSParameterProperty","identifier","parameter","AssignmentPattern","WeakMap","isInside","outer","range","isSelfReference","ref","nodes","from","has","MERGABLE_TYPES","TSInterfaceDeclaration","TSTypeAliasDeclaration","ClassDeclaration","FunctionDeclaration","def","DefinitionType","Parameter","_a","ExportNamedDeclaration","_b","ExportDefaultDeclaration","definition","VariableDeclarator","indexOf","getFunctionDefinitions","functionDefinitions","forEach","FunctionName","Variable","init","FunctionExpression","ArrowFunctionExpression","getTypeDeclarations","getModuleDeclarations","isInsideOneOf","getRhsNode","prevRhsNode","isInLoop","isFunction","isLoop","grandparent","refScope","variableScope","varScope","resolved","canBeUsedLater","AssignmentExpression","ExpressionStatement","right","isReadForItself","rhsNode","isInsideOfStorableFunction","getUpperFunction","isStorableFunction","funcNode","SequenceExpression","expressions","CallExpression","NewExpression","callee","TaggedTemplateExpression","YieldExpression","endsWith","isRead","UpdateExpression","functionNodes","isFunctionDefinition","size","typeDeclNodes","isTypeDecl","moduleDeclNodes","isModuleDecl","references","some","forItself","exports"],"sources":["../../src/util/collectUnusedVariables.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}