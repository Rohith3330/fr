{"ast":null,"code":"/* eslint-env mocha */\nimport assert from 'assert';\nimport entries from 'object.entries';\nimport fromEntries from 'object.fromentries';\nimport { getOpeningElement, setParserName, fallbackToBabylon } from '../helper';\nimport getProp from '../../src/getProp';\nconst literal = {\n  source: '<div {...{ id: \"foo\" }} />',\n  target: '<div id=\"foo\" />',\n  offset: {\n    keyOffset: -6,\n    valueOffset: -7\n  }\n};\nconst expression1 = {\n  source: '<div {...{ id }} />',\n  target: '<div id={id} />',\n  offset: {\n    keyOffset: -6,\n    valueOffset: -2\n  }\n};\nconst expression2 = {\n  source: '<div {...{ id: `foo${bar}baz` }} />',\n  // eslint-disable-line no-template-curly-in-string\n  target: '<div id={`foo${bar}baz`} />',\n  // eslint-disable-line no-template-curly-in-string\n  offset: {\n    keyOffset: -6,\n    valueOffset: -6\n  }\n};\ndescribe('getProp', () => {\n  it('should create the correct AST for literal with flow parser', () => {\n    actualTest('flow', literal);\n  });\n  it('should create the correct AST for literal with babel parser', () => {\n    actualTest('babel', literal);\n  });\n  it('should create the correct AST for expression with flow parser (1)', () => {\n    actualTest('flow', expression1);\n  });\n  it('should create the correct AST for expression with babel parser (1)', () => {\n    actualTest('babel', expression1);\n  });\n  it('should create the correct AST for expression with flow parser (2)', () => {\n    actualTest('flow', expression2);\n  });\n  it('should create the correct AST for expression with babel parser (2)', () => {\n    actualTest('babel', expression2);\n  });\n});\n\nfunction actualTest(parserName, test) {\n  setParserName(parserName);\n  const {\n    source,\n    target,\n    offset\n  } = test;\n  const sourceProps = stripConstructors(getOpeningElement(source).attributes);\n  const targetProps = stripConstructors(getOpeningElement(target).attributes);\n  const prop = 'id';\n  const sourceResult = getProp(sourceProps, prop);\n  const targetResult = getProp(targetProps, prop);\n\n  if (fallbackToBabylon && parserName === 'babel' && test === literal) {\n    // Babylon (node < 6) adds an `extra: null` prop to a literal if it is parsed from a\n    // JSXAttribute, other literals don't get this.\n    sourceResult.value.extra = null;\n  }\n\n  assert.deepStrictEqual(adjustLocations(sourceResult, offset), adjustRange(targetResult));\n}\n\nfunction adjustRange(_ref) {\n  let {\n    name,\n    value: {\n      expression,\n      ...value\n    },\n    ...node\n  } = _ref;\n  return { ...adjustNodeRange(node),\n    name: adjustNodeRange(name),\n    value: { ...adjustNodeRange(value),\n      ...(expression ? {\n        expression: adjustNodeRangeRecursively(expression)\n      } : {})\n    }\n  };\n}\n\nfunction adjustNodeRange(node) {\n  if (!node.loc) {\n    return node;\n  }\n\n  const [start, end] = node.range || [node.start, node.end];\n  return { ...node,\n    end: undefined,\n    range: [start, end],\n    start: undefined\n  };\n}\n\nfunction adjustNodeRangeRecursively(node) {\n  if (Array.isArray(node)) {\n    return node.map(adjustNodeRangeRecursively);\n  }\n\n  if (node && typeof node === 'object') {\n    return adjustNodeRange(mapValues(node, adjustNodeRangeRecursively));\n  }\n\n  return node;\n}\n\nfunction stripConstructors(value) {\n  return JSON.parse(JSON.stringify(value));\n}\n\nfunction adjustLocations(node, _ref2) {\n  let {\n    keyOffset,\n    valueOffset\n  } = _ref2;\n  const hasExpression = !!node.value.expression;\n  return { ...adjustNodeLocations(node, {\n      startOffset: keyOffset,\n      endOffset: valueOffset + (hasExpression ? 1 : 0)\n    }),\n    name: adjustNodeLocations(node.name, {\n      startOffset: keyOffset,\n      endOffset: keyOffset\n    }),\n    value: { ...adjustNodeLocations(node.value, {\n        startOffset: valueOffset - (hasExpression ? 1 : 0),\n        endOffset: valueOffset + (hasExpression ? 1 : 0)\n      }),\n      ...(hasExpression ? {\n        expression: adjustLocationsRecursively(node.value.expression, {\n          startOffset: valueOffset,\n          endOffset: valueOffset\n        })\n      } : {})\n    }\n  };\n}\n\nfunction adjustNodeLocations(node, _ref3) {\n  let {\n    startOffset,\n    endOffset\n  } = _ref3;\n\n  if (!node.loc) {\n    return node;\n  }\n\n  const [start, end] = node.range || [];\n  return { ...node,\n    end: undefined,\n    loc: { ...node.loc,\n      start: { ...node.loc.start,\n        column: node.loc.start.column + startOffset\n      },\n      end: { ...node.loc.end,\n        column: node.loc.end.column + endOffset\n      }\n    },\n    range: [start + startOffset, end + endOffset],\n    start: undefined\n  };\n}\n\nfunction adjustLocationsRecursively(node, _ref4) {\n  let {\n    startOffset,\n    endOffset\n  } = _ref4;\n\n  if (Array.isArray(node)) {\n    return node.map(x => adjustLocationsRecursively(x, {\n      startOffset,\n      endOffset\n    }));\n  }\n\n  if (node && typeof node === 'object') {\n    return adjustNodeLocations(mapValues(node, x => adjustLocationsRecursively(x, {\n      startOffset,\n      endOffset\n    })), {\n      startOffset,\n      endOffset\n    });\n  }\n\n  return node;\n}\n\nfunction mapValues(o, f) {\n  return fromEntries(entries(o).map(_ref5 => {\n    let [k, v] = _ref5;\n    return [k, f(v)];\n  }));\n}","map":{"version":3,"names":["assert","entries","fromEntries","getOpeningElement","setParserName","fallbackToBabylon","getProp","literal","source","target","offset","keyOffset","valueOffset","expression1","expression2","describe","it","actualTest","parserName","test","sourceProps","stripConstructors","attributes","targetProps","prop","sourceResult","targetResult","value","extra","deepStrictEqual","adjustLocations","adjustRange","name","expression","node","adjustNodeRange","adjustNodeRangeRecursively","loc","start","end","range","undefined","Array","isArray","map","mapValues","JSON","parse","stringify","hasExpression","adjustNodeLocations","startOffset","endOffset","adjustLocationsRecursively","column","x","o","f","k","v"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jsx-ast-utils/__tests__/src/getProp-parser-test.js"],"sourcesContent":["/* eslint-env mocha */\nimport assert from 'assert';\nimport entries from 'object.entries';\nimport fromEntries from 'object.fromentries';\nimport { getOpeningElement, setParserName, fallbackToBabylon } from '../helper';\nimport getProp from '../../src/getProp';\n\nconst literal = {\n  source: '<div {...{ id: \"foo\" }} />',\n  target: '<div id=\"foo\" />',\n  offset: { keyOffset: -6, valueOffset: -7 },\n};\n\nconst expression1 = {\n  source: '<div {...{ id }} />',\n  target: '<div id={id} />',\n  offset: { keyOffset: -6, valueOffset: -2 },\n};\n\nconst expression2 = {\n  source: '<div {...{ id: `foo${bar}baz` }} />', // eslint-disable-line no-template-curly-in-string\n  target: '<div id={`foo${bar}baz`} />', // eslint-disable-line no-template-curly-in-string\n  offset: { keyOffset: -6, valueOffset: -6 },\n};\n\ndescribe('getProp', () => {\n  it('should create the correct AST for literal with flow parser', () => {\n    actualTest('flow', literal);\n  });\n  it('should create the correct AST for literal with babel parser', () => {\n    actualTest('babel', literal);\n  });\n  it('should create the correct AST for expression with flow parser (1)', () => {\n    actualTest('flow', expression1);\n  });\n  it('should create the correct AST for expression with babel parser (1)', () => {\n    actualTest('babel', expression1);\n  });\n  it('should create the correct AST for expression with flow parser (2)', () => {\n    actualTest('flow', expression2);\n  });\n  it('should create the correct AST for expression with babel parser (2)', () => {\n    actualTest('babel', expression2);\n  });\n});\n\nfunction actualTest(parserName, test) {\n  setParserName(parserName);\n  const { source, target, offset } = test;\n  const sourceProps = stripConstructors(getOpeningElement(source).attributes);\n  const targetProps = stripConstructors(getOpeningElement(target).attributes);\n  const prop = 'id';\n  const sourceResult = getProp(sourceProps, prop);\n  const targetResult = getProp(targetProps, prop);\n\n  if (fallbackToBabylon && parserName === 'babel' && test === literal) {\n    // Babylon (node < 6) adds an `extra: null` prop to a literal if it is parsed from a\n    // JSXAttribute, other literals don't get this.\n    sourceResult.value.extra = null;\n  }\n\n  assert.deepStrictEqual(\n    adjustLocations(sourceResult, offset),\n    adjustRange(targetResult),\n  );\n}\n\nfunction adjustRange({ name, value: { expression, ...value }, ...node }) {\n  return {\n    ...adjustNodeRange(node),\n    name: adjustNodeRange(name),\n    value: {\n      ...adjustNodeRange(value),\n      ...(expression ? { expression: adjustNodeRangeRecursively(expression) } : {}),\n    },\n  };\n}\n\nfunction adjustNodeRange(node) {\n  if (!node.loc) {\n    return node;\n  }\n\n  const [start, end] = node.range || [node.start, node.end];\n  return {\n    ...node,\n    end: undefined,\n    range: [start, end],\n    start: undefined,\n  };\n}\n\nfunction adjustNodeRangeRecursively(node) {\n  if (Array.isArray(node)) {\n    return node.map(adjustNodeRangeRecursively);\n  }\n\n  if (node && typeof node === 'object') {\n    return adjustNodeRange(mapValues(node, adjustNodeRangeRecursively));\n  }\n\n  return node;\n}\n\nfunction stripConstructors(value) {\n  return JSON.parse(JSON.stringify(value));\n}\n\nfunction adjustLocations(node, { keyOffset, valueOffset }) {\n  const hasExpression = !!node.value.expression;\n  return {\n    ...adjustNodeLocations(node, {\n      startOffset: keyOffset,\n      endOffset: valueOffset + (hasExpression ? 1 : 0),\n    }),\n    name: adjustNodeLocations(node.name, { startOffset: keyOffset, endOffset: keyOffset }),\n    value: {\n      ...adjustNodeLocations(node.value, {\n        startOffset: valueOffset - (hasExpression ? 1 : 0),\n        endOffset: valueOffset + (hasExpression ? 1 : 0),\n      }),\n      ...(hasExpression\n        ? {\n          expression: adjustLocationsRecursively(\n            node.value.expression,\n            { startOffset: valueOffset, endOffset: valueOffset },\n          ),\n        }\n        : {}\n      ),\n    },\n  };\n}\n\nfunction adjustNodeLocations(node, { startOffset, endOffset }) {\n  if (!node.loc) {\n    return node;\n  }\n\n  const [start, end] = node.range || [];\n  return {\n    ...node,\n    end: undefined,\n    loc: {\n      ...node.loc,\n      start: {\n        ...node.loc.start,\n        column: node.loc.start.column + startOffset,\n      },\n      end: {\n        ...node.loc.end,\n        column: node.loc.end.column + endOffset,\n      },\n    },\n    range: [start + startOffset, end + endOffset],\n    start: undefined,\n  };\n}\n\nfunction adjustLocationsRecursively(node, { startOffset, endOffset }) {\n  if (Array.isArray(node)) {\n    return node.map((x) => adjustLocationsRecursively(x, { startOffset, endOffset }));\n  }\n  if (node && typeof node === 'object') {\n    return adjustNodeLocations(\n      mapValues(node, (x) => adjustLocationsRecursively(x, { startOffset, endOffset })),\n      { startOffset, endOffset },\n    );\n  }\n\n  return node;\n}\n\nfunction mapValues(o, f) {\n  return fromEntries(entries(o).map(([k, v]) => [k, f(v)]));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}