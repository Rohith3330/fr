{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nconst getESLintCoreRule_1 = require(\"../util/getESLintCoreRule\");\n\nconst baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-loop-func');\nexports.default = util.createRule({\n  name: 'no-loop-func',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Disallow function declarations that contain unsafe references inside loop statements',\n      recommended: false,\n      extendsBaseRule: true\n    },\n    hasSuggestions: baseRule.meta.hasSuggestions,\n    schema: [],\n    messages: baseRule.meta.messages\n  },\n  defaultOptions: [],\n\n  create(context) {\n    /**\n     * Reports functions which match the following condition:\n     * - has a loop node in ancestors.\n     * - has any references which refers to an unsafe variable.\n     *\n     * @param node The AST node to check.\n     * @returns Whether or not the node is within a loop.\n     */\n    function checkForLoops(node) {\n      const loopNode = getContainingLoopNode(node);\n\n      if (!loopNode) {\n        return;\n      }\n\n      const references = context.getScope().through;\n      const unsafeRefs = references.filter(r => !isSafe(loopNode, r)).map(r => r.identifier.name);\n\n      if (unsafeRefs.length > 0) {\n        context.report({\n          node,\n          messageId: 'unsafeRefs',\n          data: {\n            varNames: `'${unsafeRefs.join(\"', '\")}'`\n          }\n        });\n      }\n    }\n\n    return {\n      ArrowFunctionExpression: checkForLoops,\n      FunctionExpression: checkForLoops,\n      FunctionDeclaration: checkForLoops\n    };\n  }\n\n});\n/**\n * Gets the containing loop node of a specified node.\n *\n * We don't need to check nested functions, so this ignores those.\n * `Scope.through` contains references of nested functions.\n *\n * @param node An AST node to get.\n * @returns The containing loop node of the specified node, or `null`.\n */\n\nfunction getContainingLoopNode(node) {\n  for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {\n    const parent = currentNode.parent;\n\n    switch (parent.type) {\n      case utils_1.AST_NODE_TYPES.WhileStatement:\n      case utils_1.AST_NODE_TYPES.DoWhileStatement:\n        return parent;\n\n      case utils_1.AST_NODE_TYPES.ForStatement:\n        // `init` is outside of the loop.\n        if (parent.init !== currentNode) {\n          return parent;\n        }\n\n        break;\n\n      case utils_1.AST_NODE_TYPES.ForInStatement:\n      case utils_1.AST_NODE_TYPES.ForOfStatement:\n        // `right` is outside of the loop.\n        if (parent.right !== currentNode) {\n          return parent;\n        }\n\n        break;\n\n      case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:\n      case utils_1.AST_NODE_TYPES.FunctionExpression:\n      case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n        // We don't need to check nested functions.\n        return null;\n\n      default:\n        break;\n    }\n  }\n\n  return null;\n}\n/**\n * Gets the containing loop node of a given node.\n * If the loop was nested, this returns the most outer loop.\n * @param node A node to get. This is a loop node.\n * @param excludedNode A node that the result node should not include.\n * @returns The most outer loop node.\n */\n\n\nfunction getTopLoopNode(node, excludedNode) {\n  const border = excludedNode ? excludedNode.range[1] : 0;\n  let retv = node;\n  let containingLoopNode = node;\n\n  while (containingLoopNode && containingLoopNode.range[0] >= border) {\n    retv = containingLoopNode;\n    containingLoopNode = getContainingLoopNode(containingLoopNode);\n  }\n\n  return retv;\n}\n/**\n * Checks whether a given reference which refers to an upper scope's variable is\n * safe or not.\n * @param loopNode A containing loop node.\n * @param reference A reference to check.\n * @returns `true` if the reference is safe or not.\n */\n\n\nfunction isSafe(loopNode, reference) {\n  var _a;\n\n  const variable = reference.resolved;\n  const definition = variable === null || variable === void 0 ? void 0 : variable.defs[0];\n  const declaration = definition === null || definition === void 0 ? void 0 : definition.parent;\n  const kind = (declaration === null || declaration === void 0 ? void 0 : declaration.type) === utils_1.AST_NODE_TYPES.VariableDeclaration ? declaration.kind : ''; // type references are all safe\n  // this only really matters for global types that haven't been configured\n\n  if (reference.isTypeReference) {\n    return true;\n  } // Variables which are declared by `const` is safe.\n\n\n  if (kind === 'const') {\n    return true;\n  }\n  /*\n   * Variables which are declared by `let` in the loop is safe.\n   * It's a different instance from the next loop step's.\n   */\n\n\n  if (kind === 'let' && declaration && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {\n    return true;\n  }\n  /*\n   * WriteReferences which exist after this border are unsafe because those\n   * can modify the variable.\n   */\n\n\n  const border = getTopLoopNode(loopNode, kind === 'let' ? declaration : null).range[0];\n  /**\n   * Checks whether a given reference is safe or not.\n   * The reference is every reference of the upper scope's variable we are\n   * looking now.\n   *\n   * It's safe if the reference matches one of the following condition.\n   * - is readonly.\n   * - doesn't exist inside a local function and after the border.\n   *\n   * @param upperRef A reference to check.\n   * @returns `true` if the reference is safe.\n   */\n\n  function isSafeReference(upperRef) {\n    var _a;\n\n    const id = upperRef.identifier;\n    return !upperRef.isWrite() || ((_a = variable === null || variable === void 0 ? void 0 : variable.scope) === null || _a === void 0 ? void 0 : _a.variableScope) === upperRef.from.variableScope && id.range[0] < border;\n  }\n\n  return (_a = variable === null || variable === void 0 ? void 0 : variable.references.every(isSafeReference)) !== null && _a !== void 0 ? _a : false;\n}","map":{"version":3,"mappings":"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","names":["baseRule","exports","util","createRule","name","meta","type","docs","description","recommended","extendsBaseRule","hasSuggestions","schema","messages","defaultOptions","create","context","checkForLoops","node","loopNode","getContainingLoopNode","references","getScope","through","unsafeRefs","filter","r","isSafe","map","identifier","length","report","messageId","data","varNames","join","ArrowFunctionExpression","FunctionExpression","FunctionDeclaration","currentNode","parent","utils_1","WhileStatement","DoWhileStatement","ForStatement","init","ForInStatement","ForOfStatement","right","getTopLoopNode","excludedNode","border","range","retv","containingLoopNode","reference","variable","resolved","definition","defs","declaration","kind","VariableDeclaration","isTypeReference","isSafeReference","upperRef","id","isWrite","scope","_a","variableScope","from","every"],"sources":["../../src/rules/no-loop-func.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}