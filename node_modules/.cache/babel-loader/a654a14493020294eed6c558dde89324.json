{"ast":null,"code":"/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nvar os = require('os'),\n    path = require('path'),\n    postcss = require('postcss');\n\nvar fileProtocol = require('../file-protocol');\n\nvar algerbra = require('../position-algerbra');\n\nvar ORPHAN_CR_REGEX = /\\r(?!\\n)(.|\\n)?/g;\n/**\n * Process the given CSS content into reworked CSS content.\n *\n * @param {string} sourceFile The absolute path of the file being processed\n * @param {string} sourceContent CSS content without source-map\n * @param {{outputSourceMap: boolean, transformDeclaration:function, absSourceMap:object,\n *        sourceMapConsumer:object, removeCR:boolean}} params Named parameters\n * @return {{content: string, map: object}} Reworked CSS and optional source-map\n */\n\nfunction process(sourceFile, sourceContent, params) {\n  // #107 libsass emits orphan CR not considered newline, postcss does consider newline (content vs source-map mismatch)\n  var correctedContent = params.removeCR && os.EOL !== '\\r' ? sourceContent.replace(ORPHAN_CR_REGEX, ' $1') : sourceContent; // prepend file protocol to all sources to avoid problems with source map\n\n  return postcss([postcss.plugin('postcss-resolve-url', postcssPlugin)]).process(correctedContent, {\n    from: fileProtocol.prepend(sourceFile),\n    map: params.outputSourceMap && {\n      prev: !!params.absSourceMap && fileProtocol.prepend(params.absSourceMap),\n      inline: false,\n      annotation: false,\n      sourcesContent: true // #98 sourcesContent missing from output map\n\n    }\n  }).then(result => ({\n    content: result.css,\n    map: params.outputSourceMap ? fileProtocol.remove(result.map.toJSON()) : null\n  }));\n  /**\n   * Plugin for postcss that follows SASS transpilation.\n   */\n\n  function postcssPlugin() {\n    return function applyPlugin(styles) {\n      styles.walkDecls(eachDeclaration);\n    };\n    /**\n     * Process a declaration from the syntax tree.\n     * @param declaration\n     */\n\n    function eachDeclaration(declaration) {\n      var prefix,\n          isValid = declaration.value && declaration.value.indexOf('url') >= 0;\n\n      if (isValid) {\n        prefix = declaration.prop + declaration.raws.between;\n        declaration.value = params.transformDeclaration(declaration.value, getPathsAtChar);\n      }\n      /**\n       * Create a hash of base path strings.\n       *\n       * Position in the declaration is supported by postcss at the position of the url() statement.\n       *\n       * @param {number} index Index in the declaration value at which to evaluate\n       * @throws Error on invalid source map\n       * @returns {{subString:string, value:string, property:string, selector:string}} Hash of base path strings\n       */\n\n\n      function getPathsAtChar(index) {\n        var subString = declaration.value.slice(0, index),\n            posSelector = algerbra.sanitise(declaration.parent.source.start),\n            posProperty = algerbra.sanitise(declaration.source.start),\n            posValue = algerbra.add([posProperty, algerbra.strToOffset(prefix)]),\n            posSubString = algerbra.add([posValue, algerbra.strToOffset(subString)]);\n        var result = {\n          subString: positionToOriginalDirectory(posSubString),\n          value: positionToOriginalDirectory(posValue),\n          property: positionToOriginalDirectory(posProperty),\n          selector: positionToOriginalDirectory(posSelector)\n        };\n        var isValid = [result.subString, result.value, result.property, result.selector].every(Boolean);\n\n        if (isValid) {\n          return result;\n        } else if (params.sourceMapConsumer) {\n          throw new Error('source-map information is not available at url() declaration ' + (ORPHAN_CR_REGEX.test(sourceContent) ? '(found orphan CR, try removeCR option)' : '(no orphan CR found)'));\n        } else {\n          throw new Error('a valid source-map is not present (ensure preceding loaders output a source-map)');\n        }\n      }\n    }\n  }\n  /**\n   * Given an apparent position find the directory of the original file.\n   *\n   * @param startPosApparent {{line: number, column: number}}\n   * @returns {false|string} Directory of original file or false on invalid\n   */\n\n\n  function positionToOriginalDirectory(startPosApparent) {\n    // reverse the original source-map to find the original source file before transpilation\n    var startPosOriginal = !!params.sourceMapConsumer && params.sourceMapConsumer.originalPositionFor(startPosApparent); // we require a valid directory for the specified file\n\n    var directory = !!startPosOriginal && !!startPosOriginal.source && fileProtocol.remove(path.dirname(startPosOriginal.source));\n    return directory;\n  }\n}\n\nmodule.exports = process;","map":{"version":3,"names":["os","require","path","postcss","fileProtocol","algerbra","ORPHAN_CR_REGEX","process","sourceFile","sourceContent","params","correctedContent","removeCR","EOL","replace","plugin","postcssPlugin","from","prepend","map","outputSourceMap","prev","absSourceMap","inline","annotation","sourcesContent","then","result","content","css","remove","toJSON","applyPlugin","styles","walkDecls","eachDeclaration","declaration","prefix","isValid","value","indexOf","prop","raws","between","transformDeclaration","getPathsAtChar","index","subString","slice","posSelector","sanitise","parent","source","start","posProperty","posValue","add","strToOffset","posSubString","positionToOriginalDirectory","property","selector","every","Boolean","sourceMapConsumer","Error","test","startPosApparent","startPosOriginal","originalPositionFor","directory","dirname","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/resolve-url-loader/lib/engine/postcss.js"],"sourcesContent":["/*\n * MIT License http://opensource.org/licenses/MIT\n * Author: Ben Holloway @bholloway\n */\n'use strict';\n\nvar os      = require('os'),\n    path    = require('path'),\n    postcss = require('postcss');\n\nvar fileProtocol = require('../file-protocol');\nvar algerbra     = require('../position-algerbra');\n\nvar ORPHAN_CR_REGEX = /\\r(?!\\n)(.|\\n)?/g;\n\n/**\n * Process the given CSS content into reworked CSS content.\n *\n * @param {string} sourceFile The absolute path of the file being processed\n * @param {string} sourceContent CSS content without source-map\n * @param {{outputSourceMap: boolean, transformDeclaration:function, absSourceMap:object,\n *        sourceMapConsumer:object, removeCR:boolean}} params Named parameters\n * @return {{content: string, map: object}} Reworked CSS and optional source-map\n */\nfunction process(sourceFile, sourceContent, params) {\n  // #107 libsass emits orphan CR not considered newline, postcss does consider newline (content vs source-map mismatch)\n  var correctedContent = params.removeCR && (os.EOL !== '\\r') ?\n    sourceContent.replace(ORPHAN_CR_REGEX, ' $1') :\n    sourceContent;\n\n  // prepend file protocol to all sources to avoid problems with source map\n  return postcss([\n    postcss.plugin('postcss-resolve-url', postcssPlugin)\n  ])\n    .process(correctedContent, {\n      from: fileProtocol.prepend(sourceFile),\n      map : params.outputSourceMap && {\n        prev          : !!params.absSourceMap && fileProtocol.prepend(params.absSourceMap),\n        inline        : false,\n        annotation    : false,\n        sourcesContent: true  // #98 sourcesContent missing from output map\n      }\n    })\n    .then(result => ({\n      content: result.css,\n      map    : params.outputSourceMap ? fileProtocol.remove(result.map.toJSON()) : null\n    }));\n\n  /**\n   * Plugin for postcss that follows SASS transpilation.\n   */\n  function postcssPlugin() {\n    return function applyPlugin(styles) {\n      styles.walkDecls(eachDeclaration);\n    };\n\n    /**\n     * Process a declaration from the syntax tree.\n     * @param declaration\n     */\n    function eachDeclaration(declaration) {\n      var prefix,\n          isValid = declaration.value && (declaration.value.indexOf('url') >= 0);\n      if (isValid) {\n        prefix = declaration.prop + declaration.raws.between;\n        declaration.value = params.transformDeclaration(declaration.value, getPathsAtChar);\n      }\n\n      /**\n       * Create a hash of base path strings.\n       *\n       * Position in the declaration is supported by postcss at the position of the url() statement.\n       *\n       * @param {number} index Index in the declaration value at which to evaluate\n       * @throws Error on invalid source map\n       * @returns {{subString:string, value:string, property:string, selector:string}} Hash of base path strings\n       */\n      function getPathsAtChar(index) {\n        var subString    = declaration.value.slice(0, index),\n            posSelector  = algerbra.sanitise(declaration.parent.source.start),\n            posProperty  = algerbra.sanitise(declaration.source.start),\n            posValue     = algerbra.add([posProperty, algerbra.strToOffset(prefix)]),\n            posSubString = algerbra.add([posValue, algerbra.strToOffset(subString)]);\n\n        var result = {\n          subString: positionToOriginalDirectory(posSubString),\n          value    : positionToOriginalDirectory(posValue),\n          property : positionToOriginalDirectory(posProperty),\n          selector : positionToOriginalDirectory(posSelector)\n        };\n\n        var isValid = [result.subString, result.value, result.property, result.selector].every(Boolean);\n        if (isValid) {\n          return result;\n        }\n        else if (params.sourceMapConsumer) {\n          throw new Error(\n            'source-map information is not available at url() declaration ' +\n            (ORPHAN_CR_REGEX.test(sourceContent) ? '(found orphan CR, try removeCR option)' : '(no orphan CR found)')\n          );\n        } else {\n          throw new Error('a valid source-map is not present (ensure preceding loaders output a source-map)');\n        }\n      }\n    }\n  }\n\n  /**\n   * Given an apparent position find the directory of the original file.\n   *\n   * @param startPosApparent {{line: number, column: number}}\n   * @returns {false|string} Directory of original file or false on invalid\n   */\n  function positionToOriginalDirectory(startPosApparent) {\n    // reverse the original source-map to find the original source file before transpilation\n    var startPosOriginal =\n      !!params.sourceMapConsumer &&\n      params.sourceMapConsumer.originalPositionFor(startPosApparent);\n\n    // we require a valid directory for the specified file\n    var directory =\n      !!startPosOriginal &&\n      !!startPosOriginal.source &&\n      fileProtocol.remove(path.dirname(startPosOriginal.source));\n\n    return directory;\n  }\n}\n\nmodule.exports = process;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}