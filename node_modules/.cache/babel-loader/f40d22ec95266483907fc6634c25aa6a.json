{"ast":null,"code":"import { flagEnabled } from '../featureFlags';\nimport * as regex from './regex';\nexport function defaultExtractor(context) {\n  let patterns = Array.from(buildRegExps(context));\n  /**\n   * @param {string} content\n   */\n\n  return content => {\n    /** @type {(string|string)[]} */\n    let results = [];\n\n    for (let pattern of patterns) {\n      results = [...results, ...(content.match(pattern) ?? [])];\n    }\n\n    return results.filter(v => v !== undefined).map(clipAtBalancedParens);\n  };\n}\n\nfunction* buildRegExps(context) {\n  let separator = context.tailwindConfig.separator;\n  let variantGroupingEnabled = flagEnabled(context.tailwindConfig, 'variantGrouping');\n  let prefix = context.tailwindConfig.prefix !== '' ? regex.optional(regex.pattern([/-?/, regex.escape(context.tailwindConfig.prefix)])) : '';\n  let utility = regex.any([// Arbitrary properties\n  /\\[[^\\s:'\"`]+:[^\\s\\]]+\\]/, // Utilities\n  regex.pattern([// Utility Name / Group Name\n  /-?(?:\\w+)/, // Normal/Arbitrary values\n  regex.optional(regex.any([regex.pattern([// Arbitrary values\n  /-(?:\\w+-)*\\[[^\\s:]+\\]/, // Not immediately followed by an `{[(`\n  /(?![{([]])/, // optionally followed by an opacity modifier\n  /(?:\\/[^\\s'\"`\\\\><$]*)?/]), regex.pattern([// Arbitrary values\n  /-(?:\\w+-)*\\[[^\\s]+\\]/, // Not immediately followed by an `{[(`\n  /(?![{([]])/, // optionally followed by an opacity modifier\n  /(?:\\/[^\\s'\"`\\\\$]*)?/]), // Normal values w/o quotes — may include an opacity modifier\n  /[-\\/][^\\s'\"`\\\\$={><]*/]))])]);\n  let variantPatterns = [// Without quotes\n  regex.any([regex.pattern([/([^\\s\"'`\\[\\\\]+-)?\\[[^\\s\"'`]+\\]/, separator]), regex.pattern([/[^\\s\"'`\\[\\\\]+/, separator])]), // With quotes allowed\n  regex.any([regex.pattern([/([^\\s\"'`\\[\\\\]+-)?\\[[^\\s`]+\\]/, separator]), regex.pattern([/[^\\s`\\[\\\\]+/, separator])])];\n\n  for (const variantPattern of variantPatterns) {\n    yield regex.pattern([// Variants\n    '((?=((', variantPattern, ')+))\\\\2)?', // Important (optional)\n    /!?/, prefix, variantGroupingEnabled ? regex.any([// Or any of those things but grouped separated by commas\n    regex.pattern([/\\(/, utility, regex.zeroOrMore([/,/, utility]), /\\)/]), // Arbitrary properties, constrained utilities, arbitrary values, etc…\n    utility]) : utility]);\n  } // 5. Inner matches\n\n\n  yield /[^<>\"'`\\s.(){}[\\]#=%$]*[^<>\"'`\\s.(){}[\\]#=%:$]/g;\n} // We want to capture any \"special\" characters\n// AND the characters immediately following them (if there is one)\n\n\nlet SPECIALS = /([\\[\\]'\"`])([^\\[\\]'\"`])?/g;\nlet ALLOWED_CLASS_CHARACTERS = /[^\"'`\\s<>\\]]+/;\n/**\n * Clips a string ensuring that parentheses, quotes, etc… are balanced\n * Used for arbitrary values only\n *\n * We will go past the end of the balanced parens until we find a non-class character\n *\n * Depth matching behavior:\n * w-[calc(100%-theme('spacing[some_key][1.5]'))]']\n *   ┬    ┬          ┬┬       ┬        ┬┬   ┬┬┬┬┬┬┬\n *   1    2          3        4        34   3 210 END\n *   ╰────┴──────────┴────────┴────────┴┴───┴─┴┴┴\n *\n * @param {string} input\n */\n\nfunction clipAtBalancedParens(input) {\n  // We are care about this for arbitrary values\n  if (!input.includes('-[')) {\n    return input;\n  }\n\n  let depth = 0;\n  let openStringTypes = []; // Find all parens, brackets, quotes, etc\n  // Stop when we end at a balanced pair\n  // This is naive and will treat mismatched parens as balanced\n  // This shouldn't be a problem in practice though\n\n  let matches = input.matchAll(SPECIALS); // We can't use lookbehind assertions because we have to support Safari\n  // So, instead, we've emulated it using capture groups and we'll re-work the matches to accommodate\n\n  matches = Array.from(matches).flatMap(match => {\n    const [, ...groups] = match;\n    return groups.map((group, idx) => Object.assign([], match, {\n      index: match.index + idx,\n      0: group\n    }));\n  });\n\n  for (let match of matches) {\n    let char = match[0];\n    let inStringType = openStringTypes[openStringTypes.length - 1];\n\n    if (char === inStringType) {\n      openStringTypes.pop();\n    } else if (char === \"'\" || char === '\"' || char === '`') {\n      openStringTypes.push(char);\n    }\n\n    if (inStringType) {\n      continue;\n    } else if (char === '[') {\n      depth++;\n      continue;\n    } else if (char === ']') {\n      depth--;\n      continue;\n    } // We've gone one character past the point where we should stop\n    // This means that there was an extra closing `]`\n    // We'll clip to just before it\n\n\n    if (depth < 0) {\n      return input.substring(0, match.index);\n    } // We've finished balancing the brackets but there still may be characters that can be included\n    // For example in the class `text-[#336699]/[.35]`\n    // The depth goes to `0` at the closing `]` but goes up again at the `[`\n    // If we're at zero and encounter a non-class character then we clip the class there\n\n\n    if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char)) {\n      return input.substring(0, match.index);\n    }\n  }\n\n  return input;\n} // Regular utilities\n// {{modifier}:}*{namespace}{-{suffix}}*{/{opacityModifier}}?\n// Arbitrary values\n// {{modifier}:}*{namespace}-[{arbitraryValue}]{/{opacityModifier}}?\n// arbitraryValue: no whitespace, balanced quotes unless within quotes, balanced brackets unless within quotes\n// Arbitrary properties\n// {{modifier}:}*[{validCssPropertyName}:{arbitraryValue}]","map":{"version":3,"names":["flagEnabled","regex","defaultExtractor","context","patterns","Array","from","buildRegExps","content","results","pattern","match","filter","v","undefined","map","clipAtBalancedParens","separator","tailwindConfig","variantGroupingEnabled","prefix","optional","escape","utility","any","variantPatterns","variantPattern","zeroOrMore","SPECIALS","ALLOWED_CLASS_CHARACTERS","input","includes","depth","openStringTypes","matches","matchAll","flatMap","groups","group","idx","Object","assign","index","char","inStringType","length","pop","push","substring","test"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/src/lib/defaultExtractor.js"],"sourcesContent":["import { flagEnabled } from '../featureFlags'\nimport * as regex from './regex'\n\nexport function defaultExtractor(context) {\n  let patterns = Array.from(buildRegExps(context))\n\n  /**\n   * @param {string} content\n   */\n  return (content) => {\n    /** @type {(string|string)[]} */\n    let results = []\n\n    for (let pattern of patterns) {\n      results = [...results, ...(content.match(pattern) ?? [])]\n    }\n\n    return results.filter((v) => v !== undefined).map(clipAtBalancedParens)\n  }\n}\n\nfunction* buildRegExps(context) {\n  let separator = context.tailwindConfig.separator\n  let variantGroupingEnabled = flagEnabled(context.tailwindConfig, 'variantGrouping')\n  let prefix =\n    context.tailwindConfig.prefix !== ''\n      ? regex.optional(regex.pattern([/-?/, regex.escape(context.tailwindConfig.prefix)]))\n      : ''\n\n  let utility = regex.any([\n    // Arbitrary properties\n    /\\[[^\\s:'\"`]+:[^\\s\\]]+\\]/,\n\n    // Utilities\n    regex.pattern([\n      // Utility Name / Group Name\n      /-?(?:\\w+)/,\n\n      // Normal/Arbitrary values\n      regex.optional(\n        regex.any([\n          regex.pattern([\n            // Arbitrary values\n            /-(?:\\w+-)*\\[[^\\s:]+\\]/,\n\n            // Not immediately followed by an `{[(`\n            /(?![{([]])/,\n\n            // optionally followed by an opacity modifier\n            /(?:\\/[^\\s'\"`\\\\><$]*)?/,\n          ]),\n\n          regex.pattern([\n            // Arbitrary values\n            /-(?:\\w+-)*\\[[^\\s]+\\]/,\n\n            // Not immediately followed by an `{[(`\n            /(?![{([]])/,\n\n            // optionally followed by an opacity modifier\n            /(?:\\/[^\\s'\"`\\\\$]*)?/,\n          ]),\n\n          // Normal values w/o quotes — may include an opacity modifier\n          /[-\\/][^\\s'\"`\\\\$={><]*/,\n        ])\n      ),\n    ]),\n  ])\n\n  let variantPatterns = [\n    // Without quotes\n    regex.any([\n      regex.pattern([/([^\\s\"'`\\[\\\\]+-)?\\[[^\\s\"'`]+\\]/, separator]),\n      regex.pattern([/[^\\s\"'`\\[\\\\]+/, separator]),\n    ]),\n\n    // With quotes allowed\n    regex.any([\n      regex.pattern([/([^\\s\"'`\\[\\\\]+-)?\\[[^\\s`]+\\]/, separator]),\n      regex.pattern([/[^\\s`\\[\\\\]+/, separator]),\n    ]),\n  ]\n\n  for (const variantPattern of variantPatterns) {\n    yield regex.pattern([\n      // Variants\n      '((?=((',\n      variantPattern,\n      ')+))\\\\2)?',\n\n      // Important (optional)\n      /!?/,\n\n      prefix,\n\n      variantGroupingEnabled\n        ? regex.any([\n            // Or any of those things but grouped separated by commas\n            regex.pattern([/\\(/, utility, regex.zeroOrMore([/,/, utility]), /\\)/]),\n\n            // Arbitrary properties, constrained utilities, arbitrary values, etc…\n            utility,\n          ])\n        : utility,\n    ])\n  }\n\n  // 5. Inner matches\n  yield /[^<>\"'`\\s.(){}[\\]#=%$]*[^<>\"'`\\s.(){}[\\]#=%:$]/g\n}\n\n// We want to capture any \"special\" characters\n// AND the characters immediately following them (if there is one)\nlet SPECIALS = /([\\[\\]'\"`])([^\\[\\]'\"`])?/g\nlet ALLOWED_CLASS_CHARACTERS = /[^\"'`\\s<>\\]]+/\n\n/**\n * Clips a string ensuring that parentheses, quotes, etc… are balanced\n * Used for arbitrary values only\n *\n * We will go past the end of the balanced parens until we find a non-class character\n *\n * Depth matching behavior:\n * w-[calc(100%-theme('spacing[some_key][1.5]'))]']\n *   ┬    ┬          ┬┬       ┬        ┬┬   ┬┬┬┬┬┬┬\n *   1    2          3        4        34   3 210 END\n *   ╰────┴──────────┴────────┴────────┴┴───┴─┴┴┴\n *\n * @param {string} input\n */\nfunction clipAtBalancedParens(input) {\n  // We are care about this for arbitrary values\n  if (!input.includes('-[')) {\n    return input\n  }\n\n  let depth = 0\n  let openStringTypes = []\n\n  // Find all parens, brackets, quotes, etc\n  // Stop when we end at a balanced pair\n  // This is naive and will treat mismatched parens as balanced\n  // This shouldn't be a problem in practice though\n  let matches = input.matchAll(SPECIALS)\n\n  // We can't use lookbehind assertions because we have to support Safari\n  // So, instead, we've emulated it using capture groups and we'll re-work the matches to accommodate\n  matches = Array.from(matches).flatMap((match) => {\n    const [, ...groups] = match\n\n    return groups.map((group, idx) =>\n      Object.assign([], match, {\n        index: match.index + idx,\n        0: group,\n      })\n    )\n  })\n\n  for (let match of matches) {\n    let char = match[0]\n    let inStringType = openStringTypes[openStringTypes.length - 1]\n\n    if (char === inStringType) {\n      openStringTypes.pop()\n    } else if (char === \"'\" || char === '\"' || char === '`') {\n      openStringTypes.push(char)\n    }\n\n    if (inStringType) {\n      continue\n    } else if (char === '[') {\n      depth++\n      continue\n    } else if (char === ']') {\n      depth--\n      continue\n    }\n\n    // We've gone one character past the point where we should stop\n    // This means that there was an extra closing `]`\n    // We'll clip to just before it\n    if (depth < 0) {\n      return input.substring(0, match.index)\n    }\n\n    // We've finished balancing the brackets but there still may be characters that can be included\n    // For example in the class `text-[#336699]/[.35]`\n    // The depth goes to `0` at the closing `]` but goes up again at the `[`\n\n    // If we're at zero and encounter a non-class character then we clip the class there\n    if (depth === 0 && !ALLOWED_CLASS_CHARACTERS.test(char)) {\n      return input.substring(0, match.index)\n    }\n  }\n\n  return input\n}\n\n// Regular utilities\n// {{modifier}:}*{namespace}{-{suffix}}*{/{opacityModifier}}?\n\n// Arbitrary values\n// {{modifier}:}*{namespace}-[{arbitraryValue}]{/{opacityModifier}}?\n// arbitraryValue: no whitespace, balanced quotes unless within quotes, balanced brackets unless within quotes\n\n// Arbitrary properties\n// {{modifier}:}*[{validCssPropertyName}:{arbitraryValue}]\n"],"mappings":"AAAA,SAASA,WAAT,QAA4B,iBAA5B;AACA,OAAO,KAAKC,KAAZ,MAAuB,SAAvB;AAEA,OAAO,SAASC,gBAAT,CAA0BC,OAA1B,EAAmC;EACxC,IAAIC,QAAQ,GAAGC,KAAK,CAACC,IAAN,CAAWC,YAAY,CAACJ,OAAD,CAAvB,CAAf;EAEA;AACF;AACA;;EACE,OAAQK,OAAD,IAAa;IAClB;IACA,IAAIC,OAAO,GAAG,EAAd;;IAEA,KAAK,IAAIC,OAAT,IAAoBN,QAApB,EAA8B;MAC5BK,OAAO,GAAG,CAAC,GAAGA,OAAJ,EAAa,IAAID,OAAO,CAACG,KAAR,CAAcD,OAAd,KAA0B,EAA9B,CAAb,CAAV;IACD;;IAED,OAAOD,OAAO,CAACG,MAAR,CAAgBC,CAAD,IAAOA,CAAC,KAAKC,SAA5B,EAAuCC,GAAvC,CAA2CC,oBAA3C,CAAP;EACD,CATD;AAUD;;AAED,UAAUT,YAAV,CAAuBJ,OAAvB,EAAgC;EAC9B,IAAIc,SAAS,GAAGd,OAAO,CAACe,cAAR,CAAuBD,SAAvC;EACA,IAAIE,sBAAsB,GAAGnB,WAAW,CAACG,OAAO,CAACe,cAAT,EAAyB,iBAAzB,CAAxC;EACA,IAAIE,MAAM,GACRjB,OAAO,CAACe,cAAR,CAAuBE,MAAvB,KAAkC,EAAlC,GACInB,KAAK,CAACoB,QAAN,CAAepB,KAAK,CAACS,OAAN,CAAc,CAAC,IAAD,EAAOT,KAAK,CAACqB,MAAN,CAAanB,OAAO,CAACe,cAAR,CAAuBE,MAApC,CAAP,CAAd,CAAf,CADJ,GAEI,EAHN;EAKA,IAAIG,OAAO,GAAGtB,KAAK,CAACuB,GAAN,CAAU,CACtB;EACA,yBAFsB,EAItB;EACAvB,KAAK,CAACS,OAAN,CAAc,CACZ;EACA,WAFY,EAIZ;EACAT,KAAK,CAACoB,QAAN,CACEpB,KAAK,CAACuB,GAAN,CAAU,CACRvB,KAAK,CAACS,OAAN,CAAc,CACZ;EACA,uBAFY,EAIZ;EACA,YALY,EAOZ;EACA,uBARY,CAAd,CADQ,EAYRT,KAAK,CAACS,OAAN,CAAc,CACZ;EACA,sBAFY,EAIZ;EACA,YALY,EAOZ;EACA,qBARY,CAAd,CAZQ,EAuBR;EACA,uBAxBQ,CAAV,CADF,CALY,CAAd,CALsB,CAAV,CAAd;EAyCA,IAAIe,eAAe,GAAG,CACpB;EACAxB,KAAK,CAACuB,GAAN,CAAU,CACRvB,KAAK,CAACS,OAAN,CAAc,CAAC,gCAAD,EAAmCO,SAAnC,CAAd,CADQ,EAERhB,KAAK,CAACS,OAAN,CAAc,CAAC,eAAD,EAAkBO,SAAlB,CAAd,CAFQ,CAAV,CAFoB,EAOpB;EACAhB,KAAK,CAACuB,GAAN,CAAU,CACRvB,KAAK,CAACS,OAAN,CAAc,CAAC,8BAAD,EAAiCO,SAAjC,CAAd,CADQ,EAERhB,KAAK,CAACS,OAAN,CAAc,CAAC,aAAD,EAAgBO,SAAhB,CAAd,CAFQ,CAAV,CARoB,CAAtB;;EAcA,KAAK,MAAMS,cAAX,IAA6BD,eAA7B,EAA8C;IAC5C,MAAMxB,KAAK,CAACS,OAAN,CAAc,CAClB;IACA,QAFkB,EAGlBgB,cAHkB,EAIlB,WAJkB,EAMlB;IACA,IAPkB,EASlBN,MATkB,EAWlBD,sBAAsB,GAClBlB,KAAK,CAACuB,GAAN,CAAU,CACR;IACAvB,KAAK,CAACS,OAAN,CAAc,CAAC,IAAD,EAAOa,OAAP,EAAgBtB,KAAK,CAAC0B,UAAN,CAAiB,CAAC,GAAD,EAAMJ,OAAN,CAAjB,CAAhB,EAAkD,IAAlD,CAAd,CAFQ,EAIR;IACAA,OALQ,CAAV,CADkB,GAQlBA,OAnBc,CAAd,CAAN;EAqBD,CArF6B,CAuF9B;;;EACA,MAAM,iDAAN;AACD,C,CAED;AACA;;;AACA,IAAIK,QAAQ,GAAG,2BAAf;AACA,IAAIC,wBAAwB,GAAG,eAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASb,oBAAT,CAA8Bc,KAA9B,EAAqC;EACnC;EACA,IAAI,CAACA,KAAK,CAACC,QAAN,CAAe,IAAf,CAAL,EAA2B;IACzB,OAAOD,KAAP;EACD;;EAED,IAAIE,KAAK,GAAG,CAAZ;EACA,IAAIC,eAAe,GAAG,EAAtB,CAPmC,CASnC;EACA;EACA;EACA;;EACA,IAAIC,OAAO,GAAGJ,KAAK,CAACK,QAAN,CAAeP,QAAf,CAAd,CAbmC,CAenC;EACA;;EACAM,OAAO,GAAG7B,KAAK,CAACC,IAAN,CAAW4B,OAAX,EAAoBE,OAApB,CAA6BzB,KAAD,IAAW;IAC/C,MAAM,GAAG,GAAG0B,MAAN,IAAgB1B,KAAtB;IAEA,OAAO0B,MAAM,CAACtB,GAAP,CAAW,CAACuB,KAAD,EAAQC,GAAR,KAChBC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB9B,KAAlB,EAAyB;MACvB+B,KAAK,EAAE/B,KAAK,CAAC+B,KAAN,GAAcH,GADE;MAEvB,GAAGD;IAFoB,CAAzB,CADK,CAAP;EAMD,CATS,CAAV;;EAWA,KAAK,IAAI3B,KAAT,IAAkBuB,OAAlB,EAA2B;IACzB,IAAIS,IAAI,GAAGhC,KAAK,CAAC,CAAD,CAAhB;IACA,IAAIiC,YAAY,GAAGX,eAAe,CAACA,eAAe,CAACY,MAAhB,GAAyB,CAA1B,CAAlC;;IAEA,IAAIF,IAAI,KAAKC,YAAb,EAA2B;MACzBX,eAAe,CAACa,GAAhB;IACD,CAFD,MAEO,IAAIH,IAAI,KAAK,GAAT,IAAgBA,IAAI,KAAK,GAAzB,IAAgCA,IAAI,KAAK,GAA7C,EAAkD;MACvDV,eAAe,CAACc,IAAhB,CAAqBJ,IAArB;IACD;;IAED,IAAIC,YAAJ,EAAkB;MAChB;IACD,CAFD,MAEO,IAAID,IAAI,KAAK,GAAb,EAAkB;MACvBX,KAAK;MACL;IACD,CAHM,MAGA,IAAIW,IAAI,KAAK,GAAb,EAAkB;MACvBX,KAAK;MACL;IACD,CAlBwB,CAoBzB;IACA;IACA;;;IACA,IAAIA,KAAK,GAAG,CAAZ,EAAe;MACb,OAAOF,KAAK,CAACkB,SAAN,CAAgB,CAAhB,EAAmBrC,KAAK,CAAC+B,KAAzB,CAAP;IACD,CAzBwB,CA2BzB;IACA;IACA;IAEA;;;IACA,IAAIV,KAAK,KAAK,CAAV,IAAe,CAACH,wBAAwB,CAACoB,IAAzB,CAA8BN,IAA9B,CAApB,EAAyD;MACvD,OAAOb,KAAK,CAACkB,SAAN,CAAgB,CAAhB,EAAmBrC,KAAK,CAAC+B,KAAzB,CAAP;IACD;EACF;;EAED,OAAOZ,KAAP;AACD,C,CAED;AACA;AAEA;AACA;AACA;AAEA;AACA"},"metadata":{},"sourceType":"module"}