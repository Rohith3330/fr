{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = pathToPattern;\n\nfunction _path() {\n  var data = require(\"path\");\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nvar sep = \"\\\\\".concat(_path().sep);\nvar endSep = \"(?:\".concat(sep, \"|$)\");\nvar substitution = \"[^\".concat(sep, \"]+\");\nvar starPat = \"(?:\".concat(substitution).concat(sep, \")\");\nvar starPatLast = \"(?:\".concat(substitution).concat(endSep, \")\");\nvar starStarPat = \"\".concat(starPat, \"*?\");\nvar starStarPatLast = \"\".concat(starPat, \"*?\").concat(starPatLast, \"?\");\n\nfunction escapeRegExp(string) {\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n}\n\nfunction pathToPattern(pattern, dirname) {\n  var parts = _path().resolve(dirname, pattern).split(_path().sep);\n\n  return new RegExp([\"^\"].concat(_toConsumableArray(parts.map(function (part, i) {\n    var last = i === parts.length - 1;\n    if (part === \"**\") return last ? starStarPatLast : starStarPat;\n    if (part === \"*\") return last ? starPatLast : starPat;\n\n    if (part.indexOf(\"*.\") === 0) {\n      return substitution + escapeRegExp(part.slice(1)) + (last ? endSep : sep);\n    }\n\n    return escapeRegExp(part) + (last ? endSep : sep);\n  }))).join(\"\"));\n}\n\n0 && 0;","map":{"version":3,"mappings":";;;;;;;;;AAAA;EAAA;;EAAAA;IAAA;EAAA;;EAAA;AAAA;;AAEA,IAAMC,GAAG,eAAQC,QAAKD,GAAb,CAAT;AACA,IAAME,MAAM,gBAASF,GAAT,QAAZ;AAEA,IAAMG,YAAY,eAAQH,GAAR,OAAlB;AAEA,IAAMI,OAAO,gBAASD,YAAT,SAAwBH,GAAxB,MAAb;AACA,IAAMK,WAAW,gBAASF,YAAT,SAAwBD,MAAxB,MAAjB;AAEA,IAAMI,WAAW,aAAMF,OAAN,OAAjB;AACA,IAAMG,eAAe,aAAMH,OAAN,eAAkBC,WAAlB,MAArB;;AAEA,SAASG,YAAT,CAAsBC,MAAtB,EAAsC;EACpC,OAAOA,MAAM,CAACC,OAAPD,CAAe,qBAAfA,EAAsC,MAAtCA,CAAP;AACD;;AAOc,SAASE,aAAT,CACbC,OADa,EAEbC,OAFa,EAGL;EACR,IAAMC,KAAK,GAAGb,QAAKc,OAALd,CAAaY,OAAbZ,EAAsBW,OAAtBX,EAA+Be,KAA/Bf,CAAqCA,QAAKD,GAA1CC,CAAd;;EAEA,OAAO,IAAIgB,MAAJ,CACL,CACE,GADF,4BAEKH,KAAK,CAACI,GAANJ,CAAU,UAACK,IAAD,EAAOC,CAAP,EAAa;IACxB,IAAMC,IAAI,GAAGD,CAAC,KAAKN,KAAK,CAACQ,MAANR,GAAe,CAAlC;IAGA,IAAIK,IAAI,KAAK,IAAb,EAAmB,OAAOE,IAAI,GAAGd,eAAH,GAAqBD,WAAhC;IAGnB,IAAIa,IAAI,KAAK,GAAb,EAAkB,OAAOE,IAAI,GAAGhB,WAAH,GAAiBD,OAA5B;;IAGlB,IAAIe,IAAI,CAACI,OAALJ,CAAa,IAAbA,MAAuB,CAA3B,EAA8B;MAC5B,OACEhB,YAAY,GAAGK,YAAY,CAACW,IAAI,CAACK,KAALL,CAAW,CAAXA,CAAD,CAA3BhB,IAA8CkB,IAAI,GAAGnB,MAAH,GAAYF,GAA9DG,CADF;IAGD;;IAGD,OAAOK,YAAY,CAACW,IAAD,CAAZX,IAAsBa,IAAI,GAAGnB,MAAH,GAAYF,GAAtCQ,CAAP;EAjBC,EAFL,GAqBEiB,IArBF,CAqBO,EArBP,CADK,CAAP;AAwBD","names":["_path","sep","path","endSep","substitution","starPat","starPatLast","starStarPat","starStarPatLast","escapeRegExp","string","replace","pathToPattern","pattern","dirname","parts","resolve","split","RegExp","map","part","i","last","length","indexOf","slice","join"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\pattern-to-regex.ts"],"sourcesContent":["import path from \"path\";\n\nconst sep = `\\\\${path.sep}`;\nconst endSep = `(?:${sep}|$)`;\n\nconst substitution = `[^${sep}]+`;\n\nconst starPat = `(?:${substitution}${sep})`;\nconst starPatLast = `(?:${substitution}${endSep})`;\n\nconst starStarPat = `${starPat}*?`;\nconst starStarPatLast = `${starPat}*?${starPatLast}?`;\n\nfunction escapeRegExp(string: string) {\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\");\n}\n\n/**\n * Implement basic pattern matching that will allow users to do the simple\n * tests with * and **. If users want full complex pattern matching, then can\n * always use regex matching, or function validation.\n */\nexport default function pathToPattern(\n  pattern: string,\n  dirname: string,\n): RegExp {\n  const parts = path.resolve(dirname, pattern).split(path.sep);\n\n  return new RegExp(\n    [\n      \"^\",\n      ...parts.map((part, i) => {\n        const last = i === parts.length - 1;\n\n        // ** matches 0 or more path parts.\n        if (part === \"**\") return last ? starStarPatLast : starStarPat;\n\n        // * matches 1 path part.\n        if (part === \"*\") return last ? starPatLast : starPat;\n\n        // *.ext matches a wildcard with an extension.\n        if (part.indexOf(\"*.\") === 0) {\n          return (\n            substitution + escapeRegExp(part.slice(1)) + (last ? endSep : sep)\n          );\n        }\n\n        // Otherwise match the pattern text.\n        return escapeRegExp(part) + (last ? endSep : sep);\n      }),\n    ].join(\"\"),\n  );\n}\n"]},"metadata":{},"sourceType":"script"}