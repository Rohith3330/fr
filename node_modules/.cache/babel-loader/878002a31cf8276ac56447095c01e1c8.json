{"ast":null,"code":"/**\n * @fileoverview Utility functions for AST\n */\n'use strict';\n\nconst estraverse = require('estraverse'); // const pragmaUtil = require('./pragma');\n\n/**\n * Wrapper for estraverse.traverse\n *\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Object} visitor Visitor Object for estraverse\n */\n\n\nfunction traverse(ASTnode, visitor) {\n  const opts = Object.assign({}, {\n    fallback(node) {\n      return Object.keys(node).filter(key => key === 'children' || key === 'argument');\n    }\n\n  }, visitor);\n  opts.keys = Object.assign({}, visitor.keys, {\n    JSXElement: ['children'],\n    JSXFragment: ['children']\n  });\n  estraverse.traverse(ASTnode, opts);\n}\n\nfunction loopNodes(nodes) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    if (nodes[i].type === 'ReturnStatement') {\n      return nodes[i];\n    }\n\n    if (nodes[i].type === 'SwitchStatement') {\n      const j = nodes[i].cases.length - 1;\n\n      if (j >= 0) {\n        return loopNodes(nodes[i].cases[j].consequent);\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * Find a return statement in the current node\n *\n * @param {ASTNode} node The AST node being checked\n * @returns {ASTNode | false}\n */\n\n\nfunction findReturnStatement(node) {\n  if ((!node.value || !node.value.body || !node.value.body.body) && (!node.body || !node.body.body)) {\n    return false;\n  }\n\n  const bodyNodes = node.value ? node.value.body.body : node.body.body;\n  return loopNodes(bodyNodes);\n} // eslint-disable-next-line valid-jsdoc -- valid-jsdoc cannot parse function types.\n\n/**\n * Helper function for traversing \"returns\" (return statements or the\n * returned expression in the case of an arrow function) of a function\n *\n * @param {ASTNode} ASTNode The AST node being checked\n * @param {Context} context The context of `ASTNode`.\n * @param {(returnValue: ASTNode, breakTraverse: () => void) => void} onReturn\n *   Function to execute for each returnStatement found\n * @returns {undefined}\n */\n\n\nfunction traverseReturns(ASTNode, context, onReturn) {\n  const nodeType = ASTNode.type;\n\n  if (nodeType === 'ReturnStatement') {\n    onReturn(ASTNode.argument, () => {});\n    return;\n  }\n\n  if (nodeType === 'ArrowFunctionExpression' && ASTNode.expression) {\n    onReturn(ASTNode.body, () => {});\n    return;\n  }\n  /* TODO: properly warn on React.forwardRefs having typo properties\n  if (nodeType === 'CallExpression') {\n    const callee = ASTNode.callee;\n    const pragma = pragmaUtil.getFromContext(context);\n    if (\n      callee.type === 'MemberExpression'\n      && callee.object.type === 'Identifier'\n      && callee.object.name === pragma\n      && callee.property.type === 'Identifier'\n      && callee.property.name === 'forwardRef'\n      && ASTNode.arguments.length > 0\n    ) {\n      return enterFunc(ASTNode.arguments[0]);\n    }\n    return;\n  }\n  */\n\n\n  if (nodeType !== 'FunctionExpression' && nodeType !== 'FunctionDeclaration' && nodeType !== 'ArrowFunctionExpression' && nodeType !== 'MethodDefinition') {\n    return;\n  }\n\n  traverse(ASTNode.body, {\n    enter(node) {\n      const breakTraverse = () => {\n        this.break();\n      };\n\n      switch (node.type) {\n        case 'ReturnStatement':\n          this.skip();\n          onReturn(node.argument, breakTraverse);\n          return;\n\n        case 'BlockStatement':\n        case 'IfStatement':\n        case 'ForStatement':\n        case 'WhileStatement':\n        case 'SwitchStatement':\n        case 'SwitchCase':\n          return;\n\n        default:\n          this.skip();\n      }\n    }\n\n  });\n}\n/**\n * Get node with property's name\n * @param {Object} node - Property.\n * @returns {Object} Property name node.\n */\n\n\nfunction getPropertyNameNode(node) {\n  if (node.key || ['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {\n    return node.key;\n  }\n\n  if (node.type === 'MemberExpression') {\n    return node.property;\n  }\n\n  return null;\n}\n/**\n * Get properties name\n * @param {Object} node - Property.\n * @returns {String} Property name.\n */\n\n\nfunction getPropertyName(node) {\n  const nameNode = getPropertyNameNode(node);\n  return nameNode ? nameNode.name : '';\n}\n/**\n * Get properties for a given AST node\n * @param {ASTNode} node The AST node being checked.\n * @returns {Array} Properties array.\n */\n\n\nfunction getComponentProperties(node) {\n  switch (node.type) {\n    case 'ClassDeclaration':\n    case 'ClassExpression':\n      return node.body.body;\n\n    case 'ObjectExpression':\n      return node.properties;\n\n    default:\n      return [];\n  }\n}\n/**\n * Gets the first node in a line from the initial node, excluding whitespace.\n * @param {Object} context The node to check\n * @param {ASTNode} node The node to check\n * @return {ASTNode} the first node in the line\n */\n\n\nfunction getFirstNodeInLine(context, node) {\n  const sourceCode = context.getSourceCode();\n  let token = node;\n  let lines;\n\n  do {\n    token = sourceCode.getTokenBefore(token);\n    lines = token.type === 'JSXText' ? token.value.split('\\n') : null;\n  } while (token.type === 'JSXText' && /^\\s*$/.test(lines[lines.length - 1]));\n\n  return token;\n}\n/**\n * Checks if the node is the first in its line, excluding whitespace.\n * @param {Object} context The node to check\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's the first node in its line\n */\n\n\nfunction isNodeFirstInLine(context, node) {\n  const token = getFirstNodeInLine(context, node);\n  const startLine = node.loc.start.line;\n  const endLine = token ? token.loc.end.line : -1;\n  return startLine !== endLine;\n}\n/**\n * Checks if the node is a function or arrow function expression.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a function-like expression\n */\n\n\nfunction isFunctionLikeExpression(node) {\n  return node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';\n}\n/**\n * Checks if the node is a function.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a function\n */\n\n\nfunction isFunction(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\n/**\n * Checks if node is a function declaration or expression or arrow function.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a function-like\n */\n\n\nfunction isFunctionLike(node) {\n  return node.type === 'FunctionDeclaration' || isFunctionLikeExpression(node);\n}\n/**\n * Checks if the node is a class.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a class\n */\n\n\nfunction isClass(node) {\n  return node.type === 'ClassDeclaration' || node.type === 'ClassExpression';\n}\n/**\n * Check if we are in a class constructor\n * @param {Context} context\n * @return {boolean}\n */\n\n\nfunction inConstructor(context) {\n  let scope = context.getScope();\n\n  while (scope) {\n    // @ts-ignore\n    if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {\n      return true;\n    }\n\n    scope = scope.upper;\n  }\n\n  return false;\n}\n/**\n * Removes quotes from around an identifier.\n * @param {string} string the identifier to strip\n * @returns {string}\n */\n\n\nfunction stripQuotes(string) {\n  return string.replace(/^'|'$/g, '');\n}\n/**\n * Retrieve the name of a key node\n * @param {Context} context The AST node with the key.\n * @param {any} node The AST node with the key.\n * @return {string | undefined} the name of the key\n */\n\n\nfunction getKeyValue(context, node) {\n  if (node.type === 'ObjectTypeProperty') {\n    const tokens = context.getSourceCode().getFirstTokens(node, 2);\n    return tokens[0].value === '+' || tokens[0].value === '-' ? tokens[1].value : stripQuotes(tokens[0].value);\n  }\n\n  if (node.type === 'GenericTypeAnnotation') {\n    return node.id.name;\n  }\n\n  if (node.type === 'ObjectTypeAnnotation') {\n    return;\n  }\n\n  const key = node.key || node.argument;\n\n  if (!key) {\n    return;\n  }\n\n  return key.type === 'Identifier' ? key.name : key.value;\n}\n/**\n * Checks if a node is surrounded by parenthesis.\n *\n * @param {object} context - Context from the rule\n * @param {ASTNode} node - Node to be checked\n * @returns {boolean}\n */\n\n\nfunction isParenthesized(context, node) {\n  const sourceCode = context.getSourceCode();\n  const previousToken = sourceCode.getTokenBefore(node);\n  const nextToken = sourceCode.getTokenAfter(node);\n  return !!previousToken && !!nextToken && previousToken.value === '(' && previousToken.range[1] <= node.range[0] && nextToken.value === ')' && nextToken.range[0] >= node.range[1];\n}\n/**\n * Checks if a node is being assigned a value: props.bar = 'bar'\n * @param {ASTNode} node The AST node being checked.\n * @returns {Boolean}\n */\n\n\nfunction isAssignmentLHS(node) {\n  return node.parent && node.parent.type === 'AssignmentExpression' && node.parent.left === node;\n}\n/**\n * Extracts the expression node that is wrapped inside a TS type assertion\n *\n * @param {ASTNode} node - potential TS node\n * @returns {ASTNode} - unwrapped expression node\n */\n\n\nfunction unwrapTSAsExpression(node) {\n  if (node && node.type === 'TSAsExpression') return node.expression;\n  return node;\n}\n\nfunction isTSTypeReference(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeReference';\n}\n\nfunction isTSTypeAnnotation(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeAnnotation';\n}\n\nfunction isTSTypeLiteral(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeLiteral';\n}\n\nfunction isTSIntersectionType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSIntersectionType';\n}\n\nfunction isTSInterfaceHeritage(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSInterfaceHeritage';\n}\n\nfunction isTSInterfaceDeclaration(node) {\n  if (!node) return false;\n  let nodeType = node.type;\n\n  if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n    nodeType = node.declaration.type;\n  }\n\n  return nodeType === 'TSInterfaceDeclaration';\n}\n\nfunction isTSTypeDeclaration(node) {\n  if (!node) return false;\n  let nodeType = node.type;\n  let nodeKind = node.kind;\n\n  if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n    nodeType = node.declaration.type;\n    nodeKind = node.declaration.kind;\n  }\n\n  return nodeType === 'VariableDeclaration' && nodeKind === 'type';\n}\n\nfunction isTSTypeAliasDeclaration(node) {\n  if (!node) return false;\n  let nodeType = node.type;\n\n  if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n    nodeType = node.declaration.type;\n    return nodeType === 'TSTypeAliasDeclaration' && node.exportKind === 'type';\n  }\n\n  return nodeType === 'TSTypeAliasDeclaration';\n}\n\nfunction isTSParenthesizedType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeAliasDeclaration';\n}\n\nfunction isTSFunctionType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSFunctionType';\n}\n\nfunction isTSTypeQuery(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeQuery';\n}\n\nfunction isTSTypeParameterInstantiation(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeParameterInstantiation';\n}\n\nmodule.exports = {\n  traverse,\n  findReturnStatement,\n  getFirstNodeInLine,\n  getPropertyName,\n  getPropertyNameNode,\n  getComponentProperties,\n  getKeyValue,\n  isParenthesized,\n  isAssignmentLHS,\n  isClass,\n  isFunction,\n  isFunctionLikeExpression,\n  isFunctionLike,\n  inConstructor,\n  isNodeFirstInLine,\n  unwrapTSAsExpression,\n  traverseReturns,\n  isTSTypeReference,\n  isTSTypeAnnotation,\n  isTSTypeLiteral,\n  isTSIntersectionType,\n  isTSInterfaceHeritage,\n  isTSInterfaceDeclaration,\n  isTSTypeAliasDeclaration,\n  isTSParenthesizedType,\n  isTSFunctionType,\n  isTSTypeQuery,\n  isTSTypeParameterInstantiation,\n  isTSTypeDeclaration\n};","map":{"version":3,"names":["estraverse","require","traverse","ASTnode","visitor","opts","Object","assign","fallback","node","keys","filter","key","JSXElement","JSXFragment","loopNodes","nodes","i","length","type","j","cases","consequent","findReturnStatement","value","body","bodyNodes","traverseReturns","ASTNode","context","onReturn","nodeType","argument","expression","enter","breakTraverse","break","skip","getPropertyNameNode","indexOf","property","getPropertyName","nameNode","name","getComponentProperties","properties","getFirstNodeInLine","sourceCode","getSourceCode","token","lines","getTokenBefore","split","test","isNodeFirstInLine","startLine","loc","start","line","endLine","end","isFunctionLikeExpression","isFunction","isFunctionLike","isClass","inConstructor","scope","getScope","block","parent","kind","upper","stripQuotes","string","replace","getKeyValue","tokens","getFirstTokens","id","isParenthesized","previousToken","nextToken","getTokenAfter","range","isAssignmentLHS","left","unwrapTSAsExpression","isTSTypeReference","isTSTypeAnnotation","isTSTypeLiteral","isTSIntersectionType","isTSInterfaceHeritage","isTSInterfaceDeclaration","declaration","isTSTypeDeclaration","nodeKind","isTSTypeAliasDeclaration","exportKind","isTSParenthesizedType","isTSFunctionType","isTSTypeQuery","isTSTypeParameterInstantiation","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/util/ast.js"],"sourcesContent":["/**\n * @fileoverview Utility functions for AST\n */\n\n'use strict';\n\nconst estraverse = require('estraverse');\n// const pragmaUtil = require('./pragma');\n\n/**\n * Wrapper for estraverse.traverse\n *\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Object} visitor Visitor Object for estraverse\n */\nfunction traverse(ASTnode, visitor) {\n  const opts = Object.assign({}, {\n    fallback(node) {\n      return Object.keys(node).filter((key) => key === 'children' || key === 'argument');\n    },\n  }, visitor);\n\n  opts.keys = Object.assign({}, visitor.keys, {\n    JSXElement: ['children'],\n    JSXFragment: ['children'],\n  });\n\n  estraverse.traverse(ASTnode, opts);\n}\n\nfunction loopNodes(nodes) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    if (nodes[i].type === 'ReturnStatement') {\n      return nodes[i];\n    }\n    if (nodes[i].type === 'SwitchStatement') {\n      const j = nodes[i].cases.length - 1;\n      if (j >= 0) {\n        return loopNodes(nodes[i].cases[j].consequent);\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Find a return statement in the current node\n *\n * @param {ASTNode} node The AST node being checked\n * @returns {ASTNode | false}\n */\nfunction findReturnStatement(node) {\n  if (\n    (!node.value || !node.value.body || !node.value.body.body)\n    && (!node.body || !node.body.body)\n  ) {\n    return false;\n  }\n\n  const bodyNodes = node.value ? node.value.body.body : node.body.body;\n\n  return loopNodes(bodyNodes);\n}\n\n// eslint-disable-next-line valid-jsdoc -- valid-jsdoc cannot parse function types.\n/**\n * Helper function for traversing \"returns\" (return statements or the\n * returned expression in the case of an arrow function) of a function\n *\n * @param {ASTNode} ASTNode The AST node being checked\n * @param {Context} context The context of `ASTNode`.\n * @param {(returnValue: ASTNode, breakTraverse: () => void) => void} onReturn\n *   Function to execute for each returnStatement found\n * @returns {undefined}\n */\nfunction traverseReturns(ASTNode, context, onReturn) {\n  const nodeType = ASTNode.type;\n\n  if (nodeType === 'ReturnStatement') {\n    onReturn(ASTNode.argument, () => {});\n    return;\n  }\n\n  if (nodeType === 'ArrowFunctionExpression' && ASTNode.expression) {\n    onReturn(ASTNode.body, () => {});\n    return;\n  }\n\n  /* TODO: properly warn on React.forwardRefs having typo properties\n  if (nodeType === 'CallExpression') {\n    const callee = ASTNode.callee;\n    const pragma = pragmaUtil.getFromContext(context);\n    if (\n      callee.type === 'MemberExpression'\n      && callee.object.type === 'Identifier'\n      && callee.object.name === pragma\n      && callee.property.type === 'Identifier'\n      && callee.property.name === 'forwardRef'\n      && ASTNode.arguments.length > 0\n    ) {\n      return enterFunc(ASTNode.arguments[0]);\n    }\n    return;\n  }\n  */\n\n  if (\n    nodeType !== 'FunctionExpression'\n    && nodeType !== 'FunctionDeclaration'\n    && nodeType !== 'ArrowFunctionExpression'\n    && nodeType !== 'MethodDefinition'\n  ) {\n    return;\n  }\n\n  traverse(ASTNode.body, {\n    enter(node) {\n      const breakTraverse = () => {\n        this.break();\n      };\n      switch (node.type) {\n        case 'ReturnStatement':\n          this.skip();\n          onReturn(node.argument, breakTraverse);\n          return;\n        case 'BlockStatement':\n        case 'IfStatement':\n        case 'ForStatement':\n        case 'WhileStatement':\n        case 'SwitchStatement':\n        case 'SwitchCase':\n          return;\n        default:\n          this.skip();\n      }\n    },\n  });\n}\n\n/**\n * Get node with property's name\n * @param {Object} node - Property.\n * @returns {Object} Property name node.\n */\nfunction getPropertyNameNode(node) {\n  if (node.key || ['MethodDefinition', 'Property'].indexOf(node.type) !== -1) {\n    return node.key;\n  }\n  if (node.type === 'MemberExpression') {\n    return node.property;\n  }\n  return null;\n}\n\n/**\n * Get properties name\n * @param {Object} node - Property.\n * @returns {String} Property name.\n */\nfunction getPropertyName(node) {\n  const nameNode = getPropertyNameNode(node);\n  return nameNode ? nameNode.name : '';\n}\n\n/**\n * Get properties for a given AST node\n * @param {ASTNode} node The AST node being checked.\n * @returns {Array} Properties array.\n */\nfunction getComponentProperties(node) {\n  switch (node.type) {\n    case 'ClassDeclaration':\n    case 'ClassExpression':\n      return node.body.body;\n    case 'ObjectExpression':\n      return node.properties;\n    default:\n      return [];\n  }\n}\n\n/**\n * Gets the first node in a line from the initial node, excluding whitespace.\n * @param {Object} context The node to check\n * @param {ASTNode} node The node to check\n * @return {ASTNode} the first node in the line\n */\nfunction getFirstNodeInLine(context, node) {\n  const sourceCode = context.getSourceCode();\n  let token = node;\n  let lines;\n  do {\n    token = sourceCode.getTokenBefore(token);\n    lines = token.type === 'JSXText'\n      ? token.value.split('\\n')\n      : null;\n  } while (\n    token.type === 'JSXText'\n        && /^\\s*$/.test(lines[lines.length - 1])\n  );\n  return token;\n}\n\n/**\n * Checks if the node is the first in its line, excluding whitespace.\n * @param {Object} context The node to check\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's the first node in its line\n */\nfunction isNodeFirstInLine(context, node) {\n  const token = getFirstNodeInLine(context, node);\n  const startLine = node.loc.start.line;\n  const endLine = token ? token.loc.end.line : -1;\n  return startLine !== endLine;\n}\n\n/**\n * Checks if the node is a function or arrow function expression.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a function-like expression\n */\nfunction isFunctionLikeExpression(node) {\n  return node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';\n}\n\n/**\n * Checks if the node is a function.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a function\n */\nfunction isFunction(node) {\n  return node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\n\n/**\n * Checks if node is a function declaration or expression or arrow function.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a function-like\n */\nfunction isFunctionLike(node) {\n  return node.type === 'FunctionDeclaration' || isFunctionLikeExpression(node);\n}\n\n/**\n * Checks if the node is a class.\n * @param {ASTNode} node The node to check\n * @return {Boolean} true if it's a class\n */\nfunction isClass(node) {\n  return node.type === 'ClassDeclaration' || node.type === 'ClassExpression';\n}\n\n/**\n * Check if we are in a class constructor\n * @param {Context} context\n * @return {boolean}\n */\nfunction inConstructor(context) {\n  let scope = context.getScope();\n  while (scope) {\n    // @ts-ignore\n    if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') {\n      return true;\n    }\n    scope = scope.upper;\n  }\n  return false;\n}\n\n/**\n * Removes quotes from around an identifier.\n * @param {string} string the identifier to strip\n * @returns {string}\n */\nfunction stripQuotes(string) {\n  return string.replace(/^'|'$/g, '');\n}\n\n/**\n * Retrieve the name of a key node\n * @param {Context} context The AST node with the key.\n * @param {any} node The AST node with the key.\n * @return {string | undefined} the name of the key\n */\nfunction getKeyValue(context, node) {\n  if (node.type === 'ObjectTypeProperty') {\n    const tokens = context.getSourceCode().getFirstTokens(node, 2);\n    return (tokens[0].value === '+' || tokens[0].value === '-'\n      ? tokens[1].value\n      : stripQuotes(tokens[0].value)\n    );\n  }\n  if (node.type === 'GenericTypeAnnotation') {\n    return node.id.name;\n  }\n  if (node.type === 'ObjectTypeAnnotation') {\n    return;\n  }\n  const key = node.key || node.argument;\n  if (!key) {\n    return;\n  }\n  return key.type === 'Identifier' ? key.name : key.value;\n}\n\n/**\n * Checks if a node is surrounded by parenthesis.\n *\n * @param {object} context - Context from the rule\n * @param {ASTNode} node - Node to be checked\n * @returns {boolean}\n */\nfunction isParenthesized(context, node) {\n  const sourceCode = context.getSourceCode();\n  const previousToken = sourceCode.getTokenBefore(node);\n  const nextToken = sourceCode.getTokenAfter(node);\n\n  return !!previousToken && !!nextToken\n    && previousToken.value === '(' && previousToken.range[1] <= node.range[0]\n    && nextToken.value === ')' && nextToken.range[0] >= node.range[1];\n}\n\n/**\n * Checks if a node is being assigned a value: props.bar = 'bar'\n * @param {ASTNode} node The AST node being checked.\n * @returns {Boolean}\n */\nfunction isAssignmentLHS(node) {\n  return (\n    node.parent\n    && node.parent.type === 'AssignmentExpression'\n    && node.parent.left === node\n  );\n}\n\n/**\n * Extracts the expression node that is wrapped inside a TS type assertion\n *\n * @param {ASTNode} node - potential TS node\n * @returns {ASTNode} - unwrapped expression node\n */\nfunction unwrapTSAsExpression(node) {\n  if (node && node.type === 'TSAsExpression') return node.expression;\n  return node;\n}\n\nfunction isTSTypeReference(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeReference';\n}\n\nfunction isTSTypeAnnotation(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeAnnotation';\n}\n\nfunction isTSTypeLiteral(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeLiteral';\n}\n\nfunction isTSIntersectionType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSIntersectionType';\n}\n\nfunction isTSInterfaceHeritage(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSInterfaceHeritage';\n}\n\nfunction isTSInterfaceDeclaration(node) {\n  if (!node) return false;\n  let nodeType = node.type;\n  if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n    nodeType = node.declaration.type;\n  }\n  return nodeType === 'TSInterfaceDeclaration';\n}\n\nfunction isTSTypeDeclaration(node) {\n  if (!node) return false;\n  let nodeType = node.type;\n  let nodeKind = node.kind;\n  if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n    nodeType = node.declaration.type;\n    nodeKind = node.declaration.kind;\n  }\n  return nodeType === 'VariableDeclaration' && nodeKind === 'type';\n}\n\nfunction isTSTypeAliasDeclaration(node) {\n  if (!node) return false;\n  let nodeType = node.type;\n  if (node.type === 'ExportNamedDeclaration' && node.declaration) {\n    nodeType = node.declaration.type;\n    return nodeType === 'TSTypeAliasDeclaration' && node.exportKind === 'type';\n  }\n  return nodeType === 'TSTypeAliasDeclaration';\n}\n\nfunction isTSParenthesizedType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeAliasDeclaration';\n}\n\nfunction isTSFunctionType(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSFunctionType';\n}\n\nfunction isTSTypeQuery(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeQuery';\n}\n\nfunction isTSTypeParameterInstantiation(node) {\n  if (!node) return false;\n  const nodeType = node.type;\n  return nodeType === 'TSTypeParameterInstantiation';\n}\n\nmodule.exports = {\n  traverse,\n  findReturnStatement,\n  getFirstNodeInLine,\n  getPropertyName,\n  getPropertyNameNode,\n  getComponentProperties,\n  getKeyValue,\n  isParenthesized,\n  isAssignmentLHS,\n  isClass,\n  isFunction,\n  isFunctionLikeExpression,\n  isFunctionLike,\n  inConstructor,\n  isNodeFirstInLine,\n  unwrapTSAsExpression,\n  traverseReturns,\n  isTSTypeReference,\n  isTSTypeAnnotation,\n  isTSTypeLiteral,\n  isTSIntersectionType,\n  isTSInterfaceHeritage,\n  isTSInterfaceDeclaration,\n  isTSTypeAliasDeclaration,\n  isTSParenthesizedType,\n  isTSFunctionType,\n  isTSTypeQuery,\n  isTSTypeParameterInstantiation,\n  isTSTypeDeclaration,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}