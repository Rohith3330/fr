{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\nimport { AST_Accessor, AST_Array, AST_Assign, AST_Await, AST_Binary, AST_Block, AST_Call, AST_Case, AST_Chain, AST_Class, AST_ClassStaticBlock, AST_ClassExpression, AST_Conditional, AST_Default, AST_Defun, AST_Destructuring, AST_Do, AST_Exit, AST_Expansion, AST_For, AST_ForIn, AST_If, AST_LabeledStatement, AST_Lambda, AST_New, AST_Node, AST_Number, AST_ObjectKeyVal, AST_PropAccess, AST_Sequence, AST_SimpleStatement, AST_Symbol, AST_SymbolCatch, AST_SymbolConst, AST_SymbolDefun, AST_SymbolFunarg, AST_SymbolLambda, AST_SymbolRef, AST_This, AST_Toplevel, AST_Try, AST_Unary, AST_UnaryPrefix, AST_Undefined, AST_VarDef, AST_While, AST_Yield, walk, walk_body, _INLINE, _NOINLINE, _PURE } from \"../ast.js\";\nimport { HOP, make_node, noop } from \"../utils/index.js\";\nimport { lazy_op, is_modified } from \"./inference.js\";\nimport { INLINED, clear_flag } from \"./compressor-flags.js\";\nimport { read_property, has_break_or_continue, is_recursive_ref } from \"./common.js\"; // Define the method AST_Node#reduce_vars, which goes through the AST in\n// execution order to perform basic flow analysis\n\nfunction def_reduce_vars(node, func) {\n  node.DEFMETHOD(\"reduce_vars\", func);\n}\n\ndef_reduce_vars(AST_Node, noop);\n\nfunction reset_def(compressor, def) {\n  def.assignments = 0;\n  def.chained = false;\n  def.direct_access = false;\n  def.escaped = 0;\n  def.recursive_refs = 0;\n  def.references = [];\n  def.single_use = undefined;\n\n  if (def.scope.pinned()) {\n    def.fixed = false;\n  } else if (def.orig[0] instanceof AST_SymbolConst || !compressor.exposed(def)) {\n    def.fixed = def.init;\n  } else {\n    def.fixed = false;\n  }\n}\n\nfunction reset_variables(tw, compressor, node) {\n  node.variables.forEach(function (def) {\n    reset_def(compressor, def);\n\n    if (def.fixed === null) {\n      tw.defs_to_safe_ids.set(def.id, tw.safe_ids);\n      mark(tw, def, true);\n    } else if (def.fixed) {\n      tw.loop_ids.set(def.id, tw.in_loop);\n      mark(tw, def, true);\n    }\n  });\n}\n\nfunction reset_block_variables(compressor, node) {\n  if (node.block_scope) node.block_scope.variables.forEach(def => {\n    reset_def(compressor, def);\n  });\n}\n\nfunction push(tw) {\n  tw.safe_ids = Object.create(tw.safe_ids);\n}\n\nfunction pop(tw) {\n  tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);\n}\n\nfunction mark(tw, def, safe) {\n  tw.safe_ids[def.id] = safe;\n}\n\nfunction safe_to_read(tw, def) {\n  if (def.single_use == \"m\") return false;\n\n  if (tw.safe_ids[def.id]) {\n    if (def.fixed == null) {\n      var orig = def.orig[0];\n      if (orig instanceof AST_SymbolFunarg || orig.name == \"arguments\") return false;\n      def.fixed = make_node(AST_Undefined, orig);\n    }\n\n    return true;\n  }\n\n  return def.fixed instanceof AST_Defun;\n}\n\nfunction safe_to_assign(tw, def, scope, value) {\n  if (def.fixed === undefined) return true;\n  let def_safe_ids;\n\n  if (def.fixed === null && (def_safe_ids = tw.defs_to_safe_ids.get(def.id))) {\n    def_safe_ids[def.id] = false;\n    tw.defs_to_safe_ids.delete(def.id);\n    return true;\n  }\n\n  if (!HOP(tw.safe_ids, def.id)) return false;\n  if (!safe_to_read(tw, def)) return false;\n  if (def.fixed === false) return false;\n  if (def.fixed != null && (!value || def.references.length > def.assignments)) return false;\n\n  if (def.fixed instanceof AST_Defun) {\n    return value instanceof AST_Node && def.fixed.parent_scope === scope;\n  }\n\n  return def.orig.every(sym => {\n    return !(sym instanceof AST_SymbolConst || sym instanceof AST_SymbolDefun || sym instanceof AST_SymbolLambda);\n  });\n}\n\nfunction ref_once(tw, compressor, def) {\n  return compressor.option(\"unused\") && !def.scope.pinned() && def.references.length - def.recursive_refs == 1 && tw.loop_ids.get(def.id) === tw.in_loop;\n}\n\nfunction is_immutable(value) {\n  if (!value) return false;\n  return value.is_constant() || value instanceof AST_Lambda || value instanceof AST_This;\n} // A definition \"escapes\" when its value can leave the point of use.\n// Example: `a = b || c`\n// In this example, \"b\" and \"c\" are escaping, because they're going into \"a\"\n//\n// def.escaped is != 0 when it escapes.\n//\n// When greater than 1, it means that N chained properties will be read off\n// of that def before an escape occurs. This is useful for evaluating\n// property accesses, where you need to know when to stop.\n\n\nfunction mark_escaped(tw, d, scope, node, value) {\n  let level = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  let depth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;\n  var parent = tw.parent(level);\n\n  if (value) {\n    if (value.is_constant()) return;\n    if (value instanceof AST_ClassExpression) return;\n  }\n\n  if (parent instanceof AST_Assign && (parent.operator === \"=\" || parent.logical) && node === parent.right || parent instanceof AST_Call && (node !== parent.expression || parent instanceof AST_New) || parent instanceof AST_Exit && node === parent.value && node.scope !== d.scope || parent instanceof AST_VarDef && node === parent.value || parent instanceof AST_Yield && node === parent.value && node.scope !== d.scope) {\n    if (depth > 1 && !(value && value.is_constant_expression(scope))) depth = 1;\n    if (!d.escaped || d.escaped > depth) d.escaped = depth;\n    return;\n  } else if (parent instanceof AST_Array || parent instanceof AST_Await || parent instanceof AST_Binary && lazy_op.has(parent.operator) || parent instanceof AST_Conditional && node !== parent.condition || parent instanceof AST_Expansion || parent instanceof AST_Sequence && node === parent.tail_node()) {\n    mark_escaped(tw, d, scope, parent, parent, level + 1, depth);\n  } else if (parent instanceof AST_ObjectKeyVal && node === parent.value) {\n    var obj = tw.parent(level + 1);\n    mark_escaped(tw, d, scope, obj, obj, level + 2, depth);\n  } else if (parent instanceof AST_PropAccess && node === parent.expression) {\n    value = read_property(value, parent.property);\n    mark_escaped(tw, d, scope, parent, value, level + 1, depth + 1);\n    if (value) return;\n  }\n\n  if (level > 0) return;\n  if (parent instanceof AST_Sequence && node !== parent.tail_node()) return;\n  if (parent instanceof AST_SimpleStatement) return;\n  d.direct_access = true;\n}\n\nconst suppress = node => walk(node, node => {\n  if (!(node instanceof AST_Symbol)) return;\n  var d = node.definition();\n  if (!d) return;\n  if (node instanceof AST_SymbolRef) d.references.push(node);\n  d.fixed = false;\n});\n\ndef_reduce_vars(AST_Accessor, function (tw, descend, compressor) {\n  push(tw);\n  reset_variables(tw, compressor, this);\n  descend();\n  pop(tw);\n  return true;\n});\ndef_reduce_vars(AST_Assign, function (tw, descend, compressor) {\n  var node = this;\n\n  if (node.left instanceof AST_Destructuring) {\n    suppress(node.left);\n    return;\n  }\n\n  const finish_walk = () => {\n    if (node.logical) {\n      node.left.walk(tw);\n      push(tw);\n      node.right.walk(tw);\n      pop(tw);\n      return true;\n    }\n  };\n\n  var sym = node.left;\n  if (!(sym instanceof AST_SymbolRef)) return finish_walk();\n  var def = sym.definition();\n  var safe = safe_to_assign(tw, def, sym.scope, node.right);\n  def.assignments++;\n  if (!safe) return finish_walk();\n  var fixed = def.fixed;\n  if (!fixed && node.operator != \"=\" && !node.logical) return finish_walk();\n  var eq = node.operator == \"=\";\n  var value = eq ? node.right : node;\n  if (is_modified(compressor, tw, node, value, 0)) return finish_walk();\n  def.references.push(sym);\n\n  if (!node.logical) {\n    if (!eq) def.chained = true;\n    def.fixed = eq ? function () {\n      return node.right;\n    } : function () {\n      return make_node(AST_Binary, node, {\n        operator: node.operator.slice(0, -1),\n        left: fixed instanceof AST_Node ? fixed : fixed(),\n        right: node.right\n      });\n    };\n  }\n\n  if (node.logical) {\n    mark(tw, def, false);\n    push(tw);\n    node.right.walk(tw);\n    pop(tw);\n    return true;\n  }\n\n  mark(tw, def, false);\n  node.right.walk(tw);\n  mark(tw, def, true);\n  mark_escaped(tw, def, sym.scope, node, value, 0, 1);\n  return true;\n});\ndef_reduce_vars(AST_Binary, function (tw) {\n  if (!lazy_op.has(this.operator)) return;\n  this.left.walk(tw);\n  push(tw);\n  this.right.walk(tw);\n  pop(tw);\n  return true;\n});\ndef_reduce_vars(AST_Block, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n});\ndef_reduce_vars(AST_Case, function (tw) {\n  push(tw);\n  this.expression.walk(tw);\n  pop(tw);\n  push(tw);\n  walk_body(this, tw);\n  pop(tw);\n  return true;\n});\ndef_reduce_vars(AST_Class, function (tw, descend) {\n  clear_flag(this, INLINED);\n  push(tw);\n  descend();\n  pop(tw);\n  return true;\n});\ndef_reduce_vars(AST_ClassStaticBlock, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n});\ndef_reduce_vars(AST_Conditional, function (tw) {\n  this.condition.walk(tw);\n  push(tw);\n  this.consequent.walk(tw);\n  pop(tw);\n  push(tw);\n  this.alternative.walk(tw);\n  pop(tw);\n  return true;\n});\ndef_reduce_vars(AST_Chain, function (tw, descend) {\n  // Chains' conditions apply left-to-right, cumulatively.\n  // If we walk normally we don't go in that order because we would pop before pushing again\n  // Solution: AST_PropAccess and AST_Call push when they are optional, and never pop.\n  // Then we pop everything when they are done being walked.\n  const safe_ids = tw.safe_ids;\n  descend(); // Unroll back to start\n\n  tw.safe_ids = safe_ids;\n  return true;\n});\ndef_reduce_vars(AST_Call, function (tw) {\n  this.expression.walk(tw);\n\n  if (this.optional) {\n    // Never pop -- it's popped at AST_Chain above\n    push(tw);\n  }\n\n  for (const arg of this.args) arg.walk(tw);\n\n  return true;\n});\ndef_reduce_vars(AST_PropAccess, function (tw) {\n  if (!this.optional) return;\n  this.expression.walk(tw); // Never pop -- it's popped at AST_Chain above\n\n  push(tw);\n  if (this.property instanceof AST_Node) this.property.walk(tw);\n  return true;\n});\ndef_reduce_vars(AST_Default, function (tw, descend) {\n  push(tw);\n  descend();\n  pop(tw);\n  return true;\n});\n\nfunction mark_lambda(tw, descend, compressor) {\n  clear_flag(this, INLINED);\n  push(tw);\n  reset_variables(tw, compressor, this);\n\n  if (this.uses_arguments) {\n    descend();\n    pop(tw);\n    return;\n  }\n\n  var iife;\n\n  if (!this.name && (iife = tw.parent()) instanceof AST_Call && iife.expression === this && !iife.args.some(arg => arg instanceof AST_Expansion) && this.argnames.every(arg_name => arg_name instanceof AST_Symbol)) {\n    // Virtually turn IIFE parameters into variable definitions:\n    //   (function(a,b) {...})(c,d) => (function() {var a=c,b=d; ...})()\n    // So existing transformation rules can work on them.\n    this.argnames.forEach((arg, i) => {\n      if (!arg.definition) return;\n      var d = arg.definition(); // Avoid setting fixed when there's more than one origin for a variable value\n\n      if (d.orig.length > 1) return;\n\n      if (d.fixed === undefined && (!this.uses_arguments || tw.has_directive(\"use strict\"))) {\n        d.fixed = function () {\n          return iife.args[i] || make_node(AST_Undefined, iife);\n        };\n\n        tw.loop_ids.set(d.id, tw.in_loop);\n        mark(tw, d, true);\n      } else {\n        d.fixed = false;\n      }\n    });\n  }\n\n  descend();\n  pop(tw);\n  return true;\n}\n\ndef_reduce_vars(AST_Lambda, mark_lambda);\ndef_reduce_vars(AST_Do, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n  const saved_loop = tw.in_loop;\n  tw.in_loop = this;\n  push(tw);\n  this.body.walk(tw);\n\n  if (has_break_or_continue(this)) {\n    pop(tw);\n    push(tw);\n  }\n\n  this.condition.walk(tw);\n  pop(tw);\n  tw.in_loop = saved_loop;\n  return true;\n});\ndef_reduce_vars(AST_For, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n  if (this.init) this.init.walk(tw);\n  const saved_loop = tw.in_loop;\n  tw.in_loop = this;\n  push(tw);\n  if (this.condition) this.condition.walk(tw);\n  this.body.walk(tw);\n\n  if (this.step) {\n    if (has_break_or_continue(this)) {\n      pop(tw);\n      push(tw);\n    }\n\n    this.step.walk(tw);\n  }\n\n  pop(tw);\n  tw.in_loop = saved_loop;\n  return true;\n});\ndef_reduce_vars(AST_ForIn, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n  suppress(this.init);\n  this.object.walk(tw);\n  const saved_loop = tw.in_loop;\n  tw.in_loop = this;\n  push(tw);\n  this.body.walk(tw);\n  pop(tw);\n  tw.in_loop = saved_loop;\n  return true;\n});\ndef_reduce_vars(AST_If, function (tw) {\n  this.condition.walk(tw);\n  push(tw);\n  this.body.walk(tw);\n  pop(tw);\n\n  if (this.alternative) {\n    push(tw);\n    this.alternative.walk(tw);\n    pop(tw);\n  }\n\n  return true;\n});\ndef_reduce_vars(AST_LabeledStatement, function (tw) {\n  push(tw);\n  this.body.walk(tw);\n  pop(tw);\n  return true;\n});\ndef_reduce_vars(AST_SymbolCatch, function () {\n  this.definition().fixed = false;\n});\ndef_reduce_vars(AST_SymbolRef, function (tw, descend, compressor) {\n  var d = this.definition();\n  d.references.push(this);\n\n  if (d.references.length == 1 && !d.fixed && d.orig[0] instanceof AST_SymbolDefun) {\n    tw.loop_ids.set(d.id, tw.in_loop);\n  }\n\n  var fixed_value;\n\n  if (d.fixed === undefined || !safe_to_read(tw, d)) {\n    d.fixed = false;\n  } else if (d.fixed) {\n    fixed_value = this.fixed_value();\n\n    if (fixed_value instanceof AST_Lambda && is_recursive_ref(tw, d)) {\n      d.recursive_refs++;\n    } else if (fixed_value && !compressor.exposed(d) && ref_once(tw, compressor, d)) {\n      d.single_use = fixed_value instanceof AST_Lambda && !fixed_value.pinned() || fixed_value instanceof AST_Class || d.scope === this.scope && fixed_value.is_constant_expression();\n    } else {\n      d.single_use = false;\n    }\n\n    if (is_modified(compressor, tw, this, fixed_value, 0, is_immutable(fixed_value))) {\n      if (d.single_use) {\n        d.single_use = \"m\";\n      } else {\n        d.fixed = false;\n      }\n    }\n  }\n\n  mark_escaped(tw, d, this.scope, this, fixed_value, 0, 1);\n});\ndef_reduce_vars(AST_Toplevel, function (tw, descend, compressor) {\n  this.globals.forEach(function (def) {\n    reset_def(compressor, def);\n  });\n  reset_variables(tw, compressor, this);\n});\ndef_reduce_vars(AST_Try, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n  push(tw);\n  walk_body(this, tw);\n  pop(tw);\n\n  if (this.bcatch) {\n    push(tw);\n    this.bcatch.walk(tw);\n    pop(tw);\n  }\n\n  if (this.bfinally) this.bfinally.walk(tw);\n  return true;\n});\ndef_reduce_vars(AST_Unary, function (tw) {\n  var node = this;\n  if (node.operator !== \"++\" && node.operator !== \"--\") return;\n  var exp = node.expression;\n  if (!(exp instanceof AST_SymbolRef)) return;\n  var def = exp.definition();\n  var safe = safe_to_assign(tw, def, exp.scope, true);\n  def.assignments++;\n  if (!safe) return;\n  var fixed = def.fixed;\n  if (!fixed) return;\n  def.references.push(exp);\n  def.chained = true;\n\n  def.fixed = function () {\n    return make_node(AST_Binary, node, {\n      operator: node.operator.slice(0, -1),\n      left: make_node(AST_UnaryPrefix, node, {\n        operator: \"+\",\n        expression: fixed instanceof AST_Node ? fixed : fixed()\n      }),\n      right: make_node(AST_Number, node, {\n        value: 1\n      })\n    });\n  };\n\n  mark(tw, def, true);\n  return true;\n});\ndef_reduce_vars(AST_VarDef, function (tw, descend) {\n  var node = this;\n\n  if (node.name instanceof AST_Destructuring) {\n    suppress(node.name);\n    return;\n  }\n\n  var d = node.name.definition();\n\n  if (node.value) {\n    if (safe_to_assign(tw, d, node.name.scope, node.value)) {\n      d.fixed = function () {\n        return node.value;\n      };\n\n      tw.loop_ids.set(d.id, tw.in_loop);\n      mark(tw, d, false);\n      descend();\n      mark(tw, d, true);\n      return true;\n    } else {\n      d.fixed = false;\n    }\n  }\n});\ndef_reduce_vars(AST_While, function (tw, descend, compressor) {\n  reset_block_variables(compressor, this);\n  const saved_loop = tw.in_loop;\n  tw.in_loop = this;\n  push(tw);\n  descend();\n  pop(tw);\n  tw.in_loop = saved_loop;\n  return true;\n});","map":{"version":3,"names":["AST_Accessor","AST_Array","AST_Assign","AST_Await","AST_Binary","AST_Block","AST_Call","AST_Case","AST_Chain","AST_Class","AST_ClassStaticBlock","AST_ClassExpression","AST_Conditional","AST_Default","AST_Defun","AST_Destructuring","AST_Do","AST_Exit","AST_Expansion","AST_For","AST_ForIn","AST_If","AST_LabeledStatement","AST_Lambda","AST_New","AST_Node","AST_Number","AST_ObjectKeyVal","AST_PropAccess","AST_Sequence","AST_SimpleStatement","AST_Symbol","AST_SymbolCatch","AST_SymbolConst","AST_SymbolDefun","AST_SymbolFunarg","AST_SymbolLambda","AST_SymbolRef","AST_This","AST_Toplevel","AST_Try","AST_Unary","AST_UnaryPrefix","AST_Undefined","AST_VarDef","AST_While","AST_Yield","walk","walk_body","_INLINE","_NOINLINE","_PURE","HOP","make_node","noop","lazy_op","is_modified","INLINED","clear_flag","read_property","has_break_or_continue","is_recursive_ref","def_reduce_vars","node","func","DEFMETHOD","reset_def","compressor","def","assignments","chained","direct_access","escaped","recursive_refs","references","single_use","undefined","scope","pinned","fixed","orig","exposed","init","reset_variables","tw","variables","forEach","defs_to_safe_ids","set","id","safe_ids","mark","loop_ids","in_loop","reset_block_variables","block_scope","push","Object","create","pop","getPrototypeOf","safe","safe_to_read","name","safe_to_assign","value","def_safe_ids","get","delete","length","parent_scope","every","sym","ref_once","option","is_immutable","is_constant","mark_escaped","d","level","depth","parent","operator","logical","right","expression","is_constant_expression","has","condition","tail_node","obj","property","suppress","definition","descend","left","finish_walk","eq","slice","consequent","alternative","optional","arg","args","mark_lambda","uses_arguments","iife","some","argnames","arg_name","i","has_directive","saved_loop","body","step","object","fixed_value","globals","bcatch","bfinally","exp"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/terser/lib/compress/reduce-vars.js"],"sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nimport {\n    AST_Accessor,\n    AST_Array,\n    AST_Assign,\n    AST_Await,\n    AST_Binary,\n    AST_Block,\n    AST_Call,\n    AST_Case,\n    AST_Chain,\n    AST_Class,\n    AST_ClassStaticBlock,\n    AST_ClassExpression,\n    AST_Conditional,\n    AST_Default,\n    AST_Defun,\n    AST_Destructuring,\n    AST_Do,\n    AST_Exit,\n    AST_Expansion,\n    AST_For,\n    AST_ForIn,\n    AST_If,\n    AST_LabeledStatement,\n    AST_Lambda,\n    AST_New,\n    AST_Node,\n    AST_Number,\n    AST_ObjectKeyVal,\n    AST_PropAccess,\n    AST_Sequence,\n    AST_SimpleStatement,\n    AST_Symbol,\n    AST_SymbolCatch,\n    AST_SymbolConst,\n    AST_SymbolDefun,\n    AST_SymbolFunarg,\n    AST_SymbolLambda,\n    AST_SymbolRef,\n    AST_This,\n    AST_Toplevel,\n    AST_Try,\n    AST_Unary,\n    AST_UnaryPrefix,\n    AST_Undefined,\n    AST_VarDef,\n    AST_While,\n    AST_Yield,\n\n    walk,\n    walk_body,\n\n    _INLINE,\n    _NOINLINE,\n    _PURE\n} from \"../ast.js\";\nimport { HOP, make_node, noop } from \"../utils/index.js\";\n\nimport { lazy_op, is_modified } from \"./inference.js\";\nimport { INLINED, clear_flag } from \"./compressor-flags.js\";\nimport { read_property, has_break_or_continue, is_recursive_ref } from \"./common.js\";\n\n// Define the method AST_Node#reduce_vars, which goes through the AST in\n// execution order to perform basic flow analysis\n\nfunction def_reduce_vars(node, func) {\n    node.DEFMETHOD(\"reduce_vars\", func);\n}\n\ndef_reduce_vars(AST_Node, noop);\n\nfunction reset_def(compressor, def) {\n    def.assignments = 0;\n    def.chained = false;\n    def.direct_access = false;\n    def.escaped = 0;\n    def.recursive_refs = 0;\n    def.references = [];\n    def.single_use = undefined;\n    if (def.scope.pinned()) {\n        def.fixed = false;\n    } else if (def.orig[0] instanceof AST_SymbolConst || !compressor.exposed(def)) {\n        def.fixed = def.init;\n    } else {\n        def.fixed = false;\n    }\n}\n\nfunction reset_variables(tw, compressor, node) {\n    node.variables.forEach(function(def) {\n        reset_def(compressor, def);\n        if (def.fixed === null) {\n            tw.defs_to_safe_ids.set(def.id, tw.safe_ids);\n            mark(tw, def, true);\n        } else if (def.fixed) {\n            tw.loop_ids.set(def.id, tw.in_loop);\n            mark(tw, def, true);\n        }\n    });\n}\n\nfunction reset_block_variables(compressor, node) {\n    if (node.block_scope) node.block_scope.variables.forEach((def) => {\n        reset_def(compressor, def);\n    });\n}\n\nfunction push(tw) {\n    tw.safe_ids = Object.create(tw.safe_ids);\n}\n\nfunction pop(tw) {\n    tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);\n}\n\nfunction mark(tw, def, safe) {\n    tw.safe_ids[def.id] = safe;\n}\n\nfunction safe_to_read(tw, def) {\n    if (def.single_use == \"m\") return false;\n    if (tw.safe_ids[def.id]) {\n        if (def.fixed == null) {\n            var orig = def.orig[0];\n            if (orig instanceof AST_SymbolFunarg || orig.name == \"arguments\") return false;\n            def.fixed = make_node(AST_Undefined, orig);\n        }\n        return true;\n    }\n    return def.fixed instanceof AST_Defun;\n}\n\nfunction safe_to_assign(tw, def, scope, value) {\n    if (def.fixed === undefined) return true;\n    let def_safe_ids;\n    if (def.fixed === null\n        && (def_safe_ids = tw.defs_to_safe_ids.get(def.id))\n    ) {\n        def_safe_ids[def.id] = false;\n        tw.defs_to_safe_ids.delete(def.id);\n        return true;\n    }\n    if (!HOP(tw.safe_ids, def.id)) return false;\n    if (!safe_to_read(tw, def)) return false;\n    if (def.fixed === false) return false;\n    if (def.fixed != null && (!value || def.references.length > def.assignments)) return false;\n    if (def.fixed instanceof AST_Defun) {\n        return value instanceof AST_Node && def.fixed.parent_scope === scope;\n    }\n    return def.orig.every((sym) => {\n        return !(sym instanceof AST_SymbolConst\n            || sym instanceof AST_SymbolDefun\n            || sym instanceof AST_SymbolLambda);\n    });\n}\n\nfunction ref_once(tw, compressor, def) {\n    return compressor.option(\"unused\")\n        && !def.scope.pinned()\n        && def.references.length - def.recursive_refs == 1\n        && tw.loop_ids.get(def.id) === tw.in_loop;\n}\n\nfunction is_immutable(value) {\n    if (!value) return false;\n    return value.is_constant()\n        || value instanceof AST_Lambda\n        || value instanceof AST_This;\n}\n\n// A definition \"escapes\" when its value can leave the point of use.\n// Example: `a = b || c`\n// In this example, \"b\" and \"c\" are escaping, because they're going into \"a\"\n//\n// def.escaped is != 0 when it escapes.\n//\n// When greater than 1, it means that N chained properties will be read off\n// of that def before an escape occurs. This is useful for evaluating\n// property accesses, where you need to know when to stop.\nfunction mark_escaped(tw, d, scope, node, value, level = 0, depth = 1) {\n    var parent = tw.parent(level);\n    if (value) {\n        if (value.is_constant()) return;\n        if (value instanceof AST_ClassExpression) return;\n    }\n\n    if (\n        parent instanceof AST_Assign && (parent.operator === \"=\" || parent.logical) && node === parent.right\n        || parent instanceof AST_Call && (node !== parent.expression || parent instanceof AST_New)\n        || parent instanceof AST_Exit && node === parent.value && node.scope !== d.scope\n        || parent instanceof AST_VarDef && node === parent.value\n        || parent instanceof AST_Yield && node === parent.value && node.scope !== d.scope\n    ) {\n        if (depth > 1 && !(value && value.is_constant_expression(scope))) depth = 1;\n        if (!d.escaped || d.escaped > depth) d.escaped = depth;\n        return;\n    } else if (\n        parent instanceof AST_Array\n        || parent instanceof AST_Await\n        || parent instanceof AST_Binary && lazy_op.has(parent.operator)\n        || parent instanceof AST_Conditional && node !== parent.condition\n        || parent instanceof AST_Expansion\n        || parent instanceof AST_Sequence && node === parent.tail_node()\n    ) {\n        mark_escaped(tw, d, scope, parent, parent, level + 1, depth);\n    } else if (parent instanceof AST_ObjectKeyVal && node === parent.value) {\n        var obj = tw.parent(level + 1);\n\n        mark_escaped(tw, d, scope, obj, obj, level + 2, depth);\n    } else if (parent instanceof AST_PropAccess && node === parent.expression) {\n        value = read_property(value, parent.property);\n\n        mark_escaped(tw, d, scope, parent, value, level + 1, depth + 1);\n        if (value) return;\n    }\n\n    if (level > 0) return;\n    if (parent instanceof AST_Sequence && node !== parent.tail_node()) return;\n    if (parent instanceof AST_SimpleStatement) return;\n\n    d.direct_access = true;\n}\n\nconst suppress = node => walk(node, node => {\n    if (!(node instanceof AST_Symbol)) return;\n    var d = node.definition();\n    if (!d) return;\n    if (node instanceof AST_SymbolRef) d.references.push(node);\n    d.fixed = false;\n});\n\ndef_reduce_vars(AST_Accessor, function(tw, descend, compressor) {\n    push(tw);\n    reset_variables(tw, compressor, this);\n    descend();\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Assign, function(tw, descend, compressor) {\n    var node = this;\n    if (node.left instanceof AST_Destructuring) {\n        suppress(node.left);\n        return;\n    }\n\n    const finish_walk = () => {\n        if (node.logical) {\n            node.left.walk(tw);\n\n            push(tw);\n            node.right.walk(tw);\n            pop(tw);\n\n            return true;\n        }\n    };\n\n    var sym = node.left;\n    if (!(sym instanceof AST_SymbolRef)) return finish_walk();\n\n    var def = sym.definition();\n    var safe = safe_to_assign(tw, def, sym.scope, node.right);\n    def.assignments++;\n    if (!safe) return finish_walk();\n\n    var fixed = def.fixed;\n    if (!fixed && node.operator != \"=\" && !node.logical) return finish_walk();\n\n    var eq = node.operator == \"=\";\n    var value = eq ? node.right : node;\n    if (is_modified(compressor, tw, node, value, 0)) return finish_walk();\n\n    def.references.push(sym);\n\n    if (!node.logical) {\n        if (!eq) def.chained = true;\n\n        def.fixed = eq ? function() {\n            return node.right;\n        } : function() {\n            return make_node(AST_Binary, node, {\n                operator: node.operator.slice(0, -1),\n                left: fixed instanceof AST_Node ? fixed : fixed(),\n                right: node.right\n            });\n        };\n    }\n\n    if (node.logical) {\n        mark(tw, def, false);\n        push(tw);\n        node.right.walk(tw);\n        pop(tw);\n        return true;\n    }\n\n    mark(tw, def, false);\n    node.right.walk(tw);\n    mark(tw, def, true);\n\n    mark_escaped(tw, def, sym.scope, node, value, 0, 1);\n\n    return true;\n});\n\ndef_reduce_vars(AST_Binary, function(tw) {\n    if (!lazy_op.has(this.operator)) return;\n    this.left.walk(tw);\n    push(tw);\n    this.right.walk(tw);\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Block, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n});\n\ndef_reduce_vars(AST_Case, function(tw) {\n    push(tw);\n    this.expression.walk(tw);\n    pop(tw);\n    push(tw);\n    walk_body(this, tw);\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Class, function(tw, descend) {\n    clear_flag(this, INLINED);\n    push(tw);\n    descend();\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_ClassStaticBlock, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n});\n\ndef_reduce_vars(AST_Conditional, function(tw) {\n    this.condition.walk(tw);\n    push(tw);\n    this.consequent.walk(tw);\n    pop(tw);\n    push(tw);\n    this.alternative.walk(tw);\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Chain, function(tw, descend) {\n    // Chains' conditions apply left-to-right, cumulatively.\n    // If we walk normally we don't go in that order because we would pop before pushing again\n    // Solution: AST_PropAccess and AST_Call push when they are optional, and never pop.\n    // Then we pop everything when they are done being walked.\n    const safe_ids = tw.safe_ids;\n\n    descend();\n\n    // Unroll back to start\n    tw.safe_ids = safe_ids;\n    return true;\n});\n\ndef_reduce_vars(AST_Call, function (tw) {\n    this.expression.walk(tw);\n\n    if (this.optional) {\n        // Never pop -- it's popped at AST_Chain above\n        push(tw);\n    }\n\n    for (const arg of this.args) arg.walk(tw);\n\n    return true;\n});\n\ndef_reduce_vars(AST_PropAccess, function (tw) {\n    if (!this.optional) return;\n\n    this.expression.walk(tw);\n\n    // Never pop -- it's popped at AST_Chain above\n    push(tw);\n\n    if (this.property instanceof AST_Node) this.property.walk(tw);\n\n    return true;\n});\n\ndef_reduce_vars(AST_Default, function(tw, descend) {\n    push(tw);\n    descend();\n    pop(tw);\n    return true;\n});\n\nfunction mark_lambda(tw, descend, compressor) {\n    clear_flag(this, INLINED);\n    push(tw);\n    reset_variables(tw, compressor, this);\n    if (this.uses_arguments) {\n        descend();\n        pop(tw);\n        return;\n    }\n    var iife;\n    if (!this.name\n        && (iife = tw.parent()) instanceof AST_Call\n        && iife.expression === this\n        && !iife.args.some(arg => arg instanceof AST_Expansion)\n        && this.argnames.every(arg_name => arg_name instanceof AST_Symbol)\n    ) {\n        // Virtually turn IIFE parameters into variable definitions:\n        //   (function(a,b) {...})(c,d) => (function() {var a=c,b=d; ...})()\n        // So existing transformation rules can work on them.\n        this.argnames.forEach((arg, i) => {\n            if (!arg.definition) return;\n            var d = arg.definition();\n            // Avoid setting fixed when there's more than one origin for a variable value\n            if (d.orig.length > 1) return;\n            if (d.fixed === undefined && (!this.uses_arguments || tw.has_directive(\"use strict\"))) {\n                d.fixed = function() {\n                    return iife.args[i] || make_node(AST_Undefined, iife);\n                };\n                tw.loop_ids.set(d.id, tw.in_loop);\n                mark(tw, d, true);\n            } else {\n                d.fixed = false;\n            }\n        });\n    }\n    descend();\n    pop(tw);\n    return true;\n}\n\ndef_reduce_vars(AST_Lambda, mark_lambda);\n\ndef_reduce_vars(AST_Do, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    const saved_loop = tw.in_loop;\n    tw.in_loop = this;\n    push(tw);\n    this.body.walk(tw);\n    if (has_break_or_continue(this)) {\n        pop(tw);\n        push(tw);\n    }\n    this.condition.walk(tw);\n    pop(tw);\n    tw.in_loop = saved_loop;\n    return true;\n});\n\ndef_reduce_vars(AST_For, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    if (this.init) this.init.walk(tw);\n    const saved_loop = tw.in_loop;\n    tw.in_loop = this;\n    push(tw);\n    if (this.condition) this.condition.walk(tw);\n    this.body.walk(tw);\n    if (this.step) {\n        if (has_break_or_continue(this)) {\n            pop(tw);\n            push(tw);\n        }\n        this.step.walk(tw);\n    }\n    pop(tw);\n    tw.in_loop = saved_loop;\n    return true;\n});\n\ndef_reduce_vars(AST_ForIn, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    suppress(this.init);\n    this.object.walk(tw);\n    const saved_loop = tw.in_loop;\n    tw.in_loop = this;\n    push(tw);\n    this.body.walk(tw);\n    pop(tw);\n    tw.in_loop = saved_loop;\n    return true;\n});\n\ndef_reduce_vars(AST_If, function(tw) {\n    this.condition.walk(tw);\n    push(tw);\n    this.body.walk(tw);\n    pop(tw);\n    if (this.alternative) {\n        push(tw);\n        this.alternative.walk(tw);\n        pop(tw);\n    }\n    return true;\n});\n\ndef_reduce_vars(AST_LabeledStatement, function(tw) {\n    push(tw);\n    this.body.walk(tw);\n    pop(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_SymbolCatch, function() {\n    this.definition().fixed = false;\n});\n\ndef_reduce_vars(AST_SymbolRef, function(tw, descend, compressor) {\n    var d = this.definition();\n    d.references.push(this);\n    if (d.references.length == 1\n        && !d.fixed\n        && d.orig[0] instanceof AST_SymbolDefun) {\n        tw.loop_ids.set(d.id, tw.in_loop);\n    }\n    var fixed_value;\n    if (d.fixed === undefined || !safe_to_read(tw, d)) {\n        d.fixed = false;\n    } else if (d.fixed) {\n        fixed_value = this.fixed_value();\n        if (\n            fixed_value instanceof AST_Lambda\n            && is_recursive_ref(tw, d)\n        ) {\n            d.recursive_refs++;\n        } else if (fixed_value\n            && !compressor.exposed(d)\n            && ref_once(tw, compressor, d)\n        ) {\n            d.single_use =\n                fixed_value instanceof AST_Lambda && !fixed_value.pinned()\n                || fixed_value instanceof AST_Class\n                || d.scope === this.scope && fixed_value.is_constant_expression();\n        } else {\n            d.single_use = false;\n        }\n        if (is_modified(compressor, tw, this, fixed_value, 0, is_immutable(fixed_value))) {\n            if (d.single_use) {\n                d.single_use = \"m\";\n            } else {\n                d.fixed = false;\n            }\n        }\n    }\n    mark_escaped(tw, d, this.scope, this, fixed_value, 0, 1);\n});\n\ndef_reduce_vars(AST_Toplevel, function(tw, descend, compressor) {\n    this.globals.forEach(function(def) {\n        reset_def(compressor, def);\n    });\n    reset_variables(tw, compressor, this);\n});\n\ndef_reduce_vars(AST_Try, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    push(tw);\n    walk_body(this, tw);\n    pop(tw);\n    if (this.bcatch) {\n        push(tw);\n        this.bcatch.walk(tw);\n        pop(tw);\n    }\n    if (this.bfinally) this.bfinally.walk(tw);\n    return true;\n});\n\ndef_reduce_vars(AST_Unary, function(tw) {\n    var node = this;\n    if (node.operator !== \"++\" && node.operator !== \"--\") return;\n    var exp = node.expression;\n    if (!(exp instanceof AST_SymbolRef)) return;\n    var def = exp.definition();\n    var safe = safe_to_assign(tw, def, exp.scope, true);\n    def.assignments++;\n    if (!safe) return;\n    var fixed = def.fixed;\n    if (!fixed) return;\n    def.references.push(exp);\n    def.chained = true;\n    def.fixed = function() {\n        return make_node(AST_Binary, node, {\n            operator: node.operator.slice(0, -1),\n            left: make_node(AST_UnaryPrefix, node, {\n                operator: \"+\",\n                expression: fixed instanceof AST_Node ? fixed : fixed()\n            }),\n            right: make_node(AST_Number, node, {\n                value: 1\n            })\n        });\n    };\n    mark(tw, def, true);\n    return true;\n});\n\ndef_reduce_vars(AST_VarDef, function(tw, descend) {\n    var node = this;\n    if (node.name instanceof AST_Destructuring) {\n        suppress(node.name);\n        return;\n    }\n    var d = node.name.definition();\n    if (node.value) {\n        if (safe_to_assign(tw, d, node.name.scope, node.value)) {\n            d.fixed = function() {\n                return node.value;\n            };\n            tw.loop_ids.set(d.id, tw.in_loop);\n            mark(tw, d, false);\n            descend();\n            mark(tw, d, true);\n            return true;\n        } else {\n            d.fixed = false;\n        }\n    }\n});\n\ndef_reduce_vars(AST_While, function(tw, descend, compressor) {\n    reset_block_variables(compressor, this);\n    const saved_loop = tw.in_loop;\n    tw.in_loop = this;\n    push(tw);\n    descend();\n    pop(tw);\n    tw.in_loop = saved_loop;\n    return true;\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}