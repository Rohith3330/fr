{"ast":null,"code":"import { SetArray, put } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst NO_NAME = -1;\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\n\nlet addSegment;\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\n\nlet addMapping;\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\n\nlet maybeAddSegment;\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\n\nlet maybeAddMapping;\n/**\n * Adds/removes the content of the source file to the source map.\n */\n\nlet setSourceContent;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\n\nlet toDecodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\n\nlet toEncodedMap;\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\n\nlet fromMap;\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\n\nlet allMappings; // This split declaration is only so that terser can elminiate the static initialization block.\n\nlet addSegmentInternal;\n/**\n * Provides the state to generate a sourcemap.\n */\n\nclass GenMapping {\n  constructor() {\n    let {\n      file,\n      sourceRoot\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._names = new SetArray();\n    this._sources = new SetArray();\n    this._sourcesContent = [];\n    this._mappings = [];\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n  }\n\n}\n\n(() => {\n  addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n    return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n  };\n\n  maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n    return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n  };\n\n  addMapping = (map, mapping) => {\n    return addMappingInternal(false, map, mapping);\n  };\n\n  maybeAddMapping = (map, mapping) => {\n    return addMappingInternal(true, map, mapping);\n  };\n\n  setSourceContent = (map, source, content) => {\n    const {\n      _sources: sources,\n      _sourcesContent: sourcesContent\n    } = map;\n    sourcesContent[put(sources, source)] = content;\n  };\n\n  toDecodedMap = map => {\n    const {\n      file,\n      sourceRoot,\n      _mappings: mappings,\n      _sources: sources,\n      _sourcesContent: sourcesContent,\n      _names: names\n    } = map;\n    removeEmptyFinalLines(mappings);\n    return {\n      version: 3,\n      file: file || undefined,\n      names: names.array,\n      sourceRoot: sourceRoot || undefined,\n      sources: sources.array,\n      sourcesContent,\n      mappings\n    };\n  };\n\n  toEncodedMap = map => {\n    const decoded = toDecodedMap(map);\n    return Object.assign(Object.assign({}, decoded), {\n      mappings: encode(decoded.mappings)\n    });\n  };\n\n  allMappings = map => {\n    const out = [];\n    const {\n      _mappings: mappings,\n      _sources: sources,\n      _names: names\n    } = map;\n\n    for (let i = 0; i < mappings.length; i++) {\n      const line = mappings[i];\n\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        const generated = {\n          line: i + 1,\n          column: seg[COLUMN]\n        };\n        let source = undefined;\n        let original = undefined;\n        let name = undefined;\n\n        if (seg.length !== 1) {\n          source = sources.array[seg[SOURCES_INDEX]];\n          original = {\n            line: seg[SOURCE_LINE] + 1,\n            column: seg[SOURCE_COLUMN]\n          };\n          if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n        }\n\n        out.push({\n          generated,\n          source,\n          original,\n          name\n        });\n      }\n    }\n\n    return out;\n  };\n\n  fromMap = input => {\n    const map = new TraceMap(input);\n    const gen = new GenMapping({\n      file: map.file,\n      sourceRoot: map.sourceRoot\n    });\n    putAll(gen._names, map.names);\n    putAll(gen._sources, map.sources);\n    gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n    gen._mappings = decodedMappings(map);\n    return gen;\n  }; // Internal helpers\n\n\n  addSegmentInternal = (skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n    const {\n      _mappings: mappings,\n      _sources: sources,\n      _sourcesContent: sourcesContent,\n      _names: names\n    } = map;\n    const line = getLine(mappings, genLine);\n    const index = getColumnIndex(line, genColumn);\n\n    if (!source) {\n      if (skipable && skipSourceless(line, index)) return;\n      return insert(line, index, [genColumn]);\n    }\n\n    const sourcesIndex = put(sources, source);\n    const namesIndex = name ? put(names, name) : NO_NAME;\n    if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;\n\n    if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n      return;\n    }\n\n    return insert(line, index, name ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n  };\n})();\n\nfunction getLine(mappings, index) {\n  for (let i = mappings.length; i <= index; i++) {\n    mappings[i] = [];\n  }\n\n  return mappings[index];\n}\n\nfunction getColumnIndex(line, genColumn) {\n  let index = line.length;\n\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n\n  return index;\n}\n\nfunction insert(array, index, value) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n\n  array[index] = value;\n}\n\nfunction removeEmptyFinalLines(mappings) {\n  const {\n    length\n  } = mappings;\n  let len = length;\n\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n\n  if (len < length) mappings.length = len;\n}\n\nfunction putAll(strarr, array) {\n  for (let i = 0; i < array.length; i++) put(strarr, array[i]);\n}\n\nfunction skipSourceless(line, index) {\n  // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n  // doesn't generate any useful information.\n  if (index === 0) return true;\n  const prev = line[index - 1]; // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n  // genrate any new information. Else, this segment will end the source/named segment and point to\n  // a sourceless position, which is useful.\n\n  return prev.length === 1;\n}\n\nfunction skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n  // A source/named segment at the start of a line gives position at that genColumn\n  if (index === 0) return false;\n  const prev = line[index - 1]; // If the previous segment is sourceless, then we're transitioning to a source.\n\n  if (prev.length === 1) return false; // If the previous segment maps to the exact same source position, then this segment doesn't\n  // provide any new position information.\n\n  return sourcesIndex === prev[SOURCES_INDEX] && sourceLine === prev[SOURCE_LINE] && sourceColumn === prev[SOURCE_COLUMN] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME);\n}\n\nfunction addMappingInternal(skipable, map, mapping) {\n  const {\n    generated,\n    source,\n    original,\n    name,\n    content\n  } = mapping;\n\n  if (!source) {\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n  }\n\n  const s = source;\n  return addSegmentInternal(skipable, map, generated.line - 1, generated.column, s, original.line - 1, original.column, name, content);\n}\n\nexport { GenMapping, addMapping, addSegment, allMappings, fromMap, maybeAddMapping, maybeAddSegment, setSourceContent, toDecodedMap, toEncodedMap };","map":{"version":3,"mappings":"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","names":["COLUMN","SOURCES_INDEX","SOURCE_LINE","SOURCE_COLUMN","NAMES_INDEX","NO_NAME","addSegmentInternal","GenMapping","constructor","file","sourceRoot","SetArray","_sourcesContent","_mappings","addSegment","map","genLine","genColumn","source","sourceLine","sourceColumn","name","content","maybeAddSegment","addMapping","mapping","addMappingInternal","maybeAddMapping","setSourceContent","_sources","sources","sourcesContent","put","toDecodedMap","mappings","_names","names","removeEmptyFinalLines","version","undefined","array","toEncodedMap","decoded","Object","encode","allMappings","out","i","length","line","j","seg","generated","column","original","push","fromMap","input","TraceMap","gen","putAll","decodedMappings","skipable","getLine","index","getColumnIndex","skipSourceless","insert","sourcesIndex","namesIndex","skipSource","current","value","len","strarr","prev","s"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\generator\\node_modules\\@jridgewell\\gen-mapping\\src\\sourcemap-segment.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\generator\\node_modules\\@jridgewell\\gen-mapping\\src\\gen-mapping.ts"],"sourcesContent":["type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n","import { SetArray, put } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\n\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type { SourceMapInput } from '@jridgewell/trace-mapping';\nimport type { SourceMapSegment } from './sourcemap-segment';\nimport type { DecodedSourceMap, EncodedSourceMap, Pos, Mapping } from './types';\n\nexport type { DecodedSourceMap, EncodedSourceMap, Mapping };\n\nexport type Options = {\n  file?: string | null;\n  sourceRoot?: string | null;\n};\n\nconst NO_NAME = -1;\n\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nexport let addSegment: {\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source?: null,\n    sourceLine?: null,\n    sourceColumn?: null,\n    name?: null,\n    content?: null,\n  ): void;\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source: string,\n    sourceLine: number,\n    sourceColumn: number,\n    name?: null,\n    content?: string | null,\n  ): void;\n  (\n    map: GenMapping,\n    genLine: number,\n    genColumn: number,\n    source: string,\n    sourceLine: number,\n    sourceColumn: number,\n    name: string,\n    content?: string | null,\n  ): void;\n};\n\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nexport let addMapping: {\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source?: null;\n      original?: null;\n      name?: null;\n      content?: null;\n    },\n  ): void;\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source: string;\n      original: Pos;\n      name?: null;\n      content?: string | null;\n    },\n  ): void;\n  (\n    map: GenMapping,\n    mapping: {\n      generated: Pos;\n      source: string;\n      original: Pos;\n      name: string;\n      content?: string | null;\n    },\n  ): void;\n};\n\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nexport let maybeAddSegment: typeof addSegment;\n\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nexport let maybeAddMapping: typeof addMapping;\n\n/**\n * Adds/removes the content of the source file to the source map.\n */\nexport let setSourceContent: (map: GenMapping, source: string, content: string | null) => void;\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let toDecodedMap: (map: GenMapping) => DecodedSourceMap;\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let toEncodedMap: (map: GenMapping) => EncodedSourceMap;\n\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nexport let fromMap: (input: SourceMapInput) => GenMapping;\n\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nexport let allMappings: (map: GenMapping) => Mapping[];\n\n// This split declaration is only so that terser can elminiate the static initialization block.\nlet addSegmentInternal: <S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: S,\n  sourceLine: S extends string ? number : null | undefined,\n  sourceColumn: S extends string ? number : null | undefined,\n  name: S extends string ? string | null | undefined : null | undefined,\n  content: S extends string ? string | null | undefined : null | undefined,\n) => void;\n\n/**\n * Provides the state to generate a sourcemap.\n */\nexport class GenMapping {\n  private _names = new SetArray();\n  private _sources = new SetArray();\n  private _sourcesContent: (string | null)[] = [];\n  private _mappings: SourceMapSegment[][] = [];\n  declare file: string | null | undefined;\n  declare sourceRoot: string | null | undefined;\n\n  constructor({ file, sourceRoot }: Options = {}) {\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n  }\n\n  static {\n    addSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n      return addSegmentInternal(\n        false,\n        map,\n        genLine,\n        genColumn,\n        source,\n        sourceLine,\n        sourceColumn,\n        name,\n        content,\n      );\n    };\n\n    maybeAddSegment = (\n      map,\n      genLine,\n      genColumn,\n      source,\n      sourceLine,\n      sourceColumn,\n      name,\n      content,\n    ) => {\n      return addSegmentInternal(\n        true,\n        map,\n        genLine,\n        genColumn,\n        source,\n        sourceLine,\n        sourceColumn,\n        name,\n        content,\n      );\n    };\n\n    addMapping = (map, mapping) => {\n      return addMappingInternal(false, map, mapping as Parameters<typeof addMappingInternal>[2]);\n    };\n\n    maybeAddMapping = (map, mapping) => {\n      return addMappingInternal(true, map, mapping as Parameters<typeof addMappingInternal>[2]);\n    };\n\n    setSourceContent = (map, source, content) => {\n      const { _sources: sources, _sourcesContent: sourcesContent } = map;\n      sourcesContent[put(sources, source)] = content;\n    };\n\n    toDecodedMap = (map) => {\n      const {\n        file,\n        sourceRoot,\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names,\n      } = map;\n      removeEmptyFinalLines(mappings);\n\n      return {\n        version: 3,\n        file: file || undefined,\n        names: names.array,\n        sourceRoot: sourceRoot || undefined,\n        sources: sources.array,\n        sourcesContent,\n        mappings,\n      };\n    };\n\n    toEncodedMap = (map) => {\n      const decoded = toDecodedMap(map);\n      return {\n        ...decoded,\n        mappings: encode(decoded.mappings as SourceMapSegment[][]),\n      };\n    };\n\n    allMappings = (map) => {\n      const out: Mapping[] = [];\n      const { _mappings: mappings, _sources: sources, _names: names } = map;\n\n      for (let i = 0; i < mappings.length; i++) {\n        const line = mappings[i];\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n\n          const generated = { line: i + 1, column: seg[COLUMN] };\n          let source: string | undefined = undefined;\n          let original: Pos | undefined = undefined;\n          let name: string | undefined = undefined;\n\n          if (seg.length !== 1) {\n            source = sources.array[seg[SOURCES_INDEX]];\n            original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n\n            if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n          }\n\n          out.push({ generated, source, original, name } as Mapping);\n        }\n      }\n\n      return out;\n    };\n\n    fromMap = (input) => {\n      const map = new TraceMap(input);\n      const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n\n      putAll(gen._names, map.names);\n      putAll(gen._sources, map.sources as string[]);\n      gen._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n      gen._mappings = decodedMappings(map) as GenMapping['_mappings'];\n\n      return gen;\n    };\n\n    // Internal helpers\n    addSegmentInternal = (\n      skipable,\n      map,\n      genLine,\n      genColumn,\n      source,\n      sourceLine,\n      sourceColumn,\n      name,\n      content,\n    ) => {\n      const {\n        _mappings: mappings,\n        _sources: sources,\n        _sourcesContent: sourcesContent,\n        _names: names,\n      } = map;\n      const line = getLine(mappings, genLine);\n      const index = getColumnIndex(line, genColumn);\n\n      if (!source) {\n        if (skipable && skipSourceless(line, index)) return;\n        return insert(line, index, [genColumn]);\n      }\n\n      // Sigh, TypeScript can't figure out sourceLine and sourceColumn aren't nullish if source\n      // isn't nullish.\n      assert<number>(sourceLine);\n      assert<number>(sourceColumn);\n\n      const sourcesIndex = put(sources, source);\n      const namesIndex = name ? put(names, name) : NO_NAME;\n      if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content ?? null;\n\n      if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n        return;\n      }\n\n      return insert(\n        line,\n        index,\n        name\n          ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n          : [genColumn, sourcesIndex, sourceLine, sourceColumn],\n      );\n    };\n  }\n}\n\nfunction assert<T>(_val: unknown): asserts _val is T {\n  // noop.\n}\n\nfunction getLine(mappings: SourceMapSegment[][], index: number): SourceMapSegment[] {\n  for (let i = mappings.length; i <= index; i++) {\n    mappings[i] = [];\n  }\n  return mappings[index];\n}\n\nfunction getColumnIndex(line: SourceMapSegment[], genColumn: number): number {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\nfunction removeEmptyFinalLines(mappings: SourceMapSegment[][]) {\n  const { length } = mappings;\n  let len = length;\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\n\nfunction putAll(strarr: SetArray, array: string[]) {\n  for (let i = 0; i < array.length; i++) put(strarr, array[i]);\n}\n\nfunction skipSourceless(line: SourceMapSegment[], index: number): boolean {\n  // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n  // doesn't generate any useful information.\n  if (index === 0) return true;\n\n  const prev = line[index - 1];\n  // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n  // genrate any new information. Else, this segment will end the source/named segment and point to\n  // a sourceless position, which is useful.\n  return prev.length === 1;\n}\n\nfunction skipSource(\n  line: SourceMapSegment[],\n  index: number,\n  sourcesIndex: number,\n  sourceLine: number,\n  sourceColumn: number,\n  namesIndex: number,\n): boolean {\n  // A source/named segment at the start of a line gives position at that genColumn\n  if (index === 0) return false;\n\n  const prev = line[index - 1];\n\n  // If the previous segment is sourceless, then we're transitioning to a source.\n  if (prev.length === 1) return false;\n\n  // If the previous segment maps to the exact same source position, then this segment doesn't\n  // provide any new position information.\n  return (\n    sourcesIndex === prev[SOURCES_INDEX] &&\n    sourceLine === prev[SOURCE_LINE] &&\n    sourceColumn === prev[SOURCE_COLUMN] &&\n    namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME)\n  );\n}\n\nfunction addMappingInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: S;\n    original: S extends string ? Pos : null | undefined;\n    name: S extends string ? string | null | undefined : null | undefined;\n    content: S extends string ? string | null | undefined : null | undefined;\n  },\n) {\n  const { generated, source, original, name, content } = mapping;\n  if (!source) {\n    return addSegmentInternal(\n      skipable,\n      map,\n      generated.line - 1,\n      generated.column,\n      null,\n      null,\n      null,\n      null,\n      null,\n    );\n  }\n  const s: string = source;\n  assert<Pos>(original);\n  return addSegmentInternal(\n    skipable,\n    map,\n    generated.line - 1,\n    generated.column,\n    s,\n    original.line - 1,\n    original.column,\n    name,\n    content,\n  );\n}\n"]},"metadata":{},"sourceType":"module"}