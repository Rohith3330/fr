{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'strict-boolean-expressions',\n  meta: {\n    type: 'suggestion',\n    fixable: 'code',\n    hasSuggestions: true,\n    docs: {\n      description: 'Disallow certain types in boolean expressions',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        allowString: {\n          type: 'boolean'\n        },\n        allowNumber: {\n          type: 'boolean'\n        },\n        allowNullableObject: {\n          type: 'boolean'\n        },\n        allowNullableBoolean: {\n          type: 'boolean'\n        },\n        allowNullableString: {\n          type: 'boolean'\n        },\n        allowNullableNumber: {\n          type: 'boolean'\n        },\n        allowAny: {\n          type: 'boolean'\n        },\n        allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      conditionErrorOther: 'Unexpected value in conditional. ' + 'A boolean expression is required.',\n      conditionErrorAny: 'Unexpected any value in conditional. ' + 'An explicit comparison or type cast is required.',\n      conditionErrorNullish: 'Unexpected nullish value in conditional. ' + 'The condition is always false.',\n      conditionErrorNullableBoolean: 'Unexpected nullable boolean value in conditional. ' + 'Please handle the nullish case explicitly.',\n      conditionErrorString: 'Unexpected string value in conditional. ' + 'An explicit empty string check is required.',\n      conditionErrorNullableString: 'Unexpected nullable string value in conditional. ' + 'Please handle the nullish/empty cases explicitly.',\n      conditionErrorNumber: 'Unexpected number value in conditional. ' + 'An explicit zero/NaN check is required.',\n      conditionErrorNullableNumber: 'Unexpected nullable number value in conditional. ' + 'Please handle the nullish/zero/NaN cases explicitly.',\n      conditionErrorObject: 'Unexpected object value in conditional. ' + 'The condition is always true.',\n      conditionErrorNullableObject: 'Unexpected nullable object value in conditional. ' + 'An explicit null check is required.',\n      noStrictNullCheck: 'This rule requires the `strictNullChecks` compiler option to be turned on to function correctly.',\n      conditionFixDefaultFalse: 'Explicitly treat nullish value the same as false (`value ?? false`)',\n      conditionFixDefaultEmptyString: 'Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)',\n      conditionFixDefaultZero: 'Explicitly treat nullish value the same as 0 (`value ?? 0`)',\n      conditionFixCompareNullish: 'Change condition to check for null/undefined (`value != null`)',\n      conditionFixCastBoolean: 'Explicitly cast value to a boolean (`Boolean(value)`)',\n      conditionFixCompareTrue: 'Change condition to check if true (`value === true`)',\n      conditionFixCompareFalse: 'Change condition to check if false (`value === false`)',\n      conditionFixCompareStringLength: \"Change condition to check string's length (`value.length !== 0`)\",\n      conditionFixCompareEmptyString: 'Change condition to check for empty string (`value !== \"\"`)',\n      conditionFixCompareZero: 'Change condition to check for 0 (`value !== 0`)',\n      conditionFixCompareNaN: 'Change condition to check for NaN (`!Number.isNaN(value)`)'\n    }\n  },\n  defaultOptions: [{\n    allowString: true,\n    allowNumber: true,\n    allowNullableObject: true,\n    allowNullableBoolean: false,\n    allowNullableString: false,\n    allowNullableNumber: false,\n    allowAny: false,\n    allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing: false\n  }],\n\n  create(context, _ref) {\n    let [options] = _ref;\n    const parserServices = util.getParserServices(context);\n    const typeChecker = parserServices.program.getTypeChecker();\n    const compilerOptions = parserServices.program.getCompilerOptions();\n    const sourceCode = context.getSourceCode();\n    const isStrictNullChecks = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'strictNullChecks');\n\n    if (!isStrictNullChecks && options.allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing !== true) {\n      context.report({\n        loc: {\n          start: {\n            line: 0,\n            column: 0\n          },\n          end: {\n            line: 0,\n            column: 0\n          }\n        },\n        messageId: 'noStrictNullCheck'\n      });\n    }\n\n    const traversedNodes = new Set();\n    return {\n      ConditionalExpression: traverseTestExpression,\n      DoWhileStatement: traverseTestExpression,\n      ForStatement: traverseTestExpression,\n      IfStatement: traverseTestExpression,\n      WhileStatement: traverseTestExpression,\n      'LogicalExpression[operator!=\"??\"]': traverseLogicalExpression,\n      'UnaryExpression[operator=\"!\"]': traverseUnaryLogicalExpression\n    };\n    /**\n     * Inspects condition of a test expression. (`if`, `while`, `for`, etc.)\n     */\n\n    function traverseTestExpression(node) {\n      if (node.test == null) {\n        return;\n      }\n\n      traverseNode(node.test, true);\n    }\n    /**\n     * Inspects the argument of a unary logical expression (`!`).\n     */\n\n\n    function traverseUnaryLogicalExpression(node) {\n      traverseNode(node.argument, true);\n    }\n    /**\n     * Inspects the arguments of a logical expression (`&&`, `||`).\n     *\n     * If the logical expression is a descendant of a test expression,\n     * the `isCondition` flag should be set to true.\n     * Otherwise, if the logical expression is there on it's own,\n     * it's used for control flow and is not a condition itself.\n     */\n\n\n    function traverseLogicalExpression(node) {\n      let isCondition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // left argument is always treated as a condition\n      traverseNode(node.left, true); // if the logical expression is used for control flow,\n      // then it's right argument is used for it's side effects only\n\n      traverseNode(node.right, isCondition);\n    }\n    /**\n     * Inspects any node.\n     *\n     * If it's a logical expression then it recursively traverses its arguments.\n     * If it's any other kind of node then it's type is finally checked against the rule,\n     * unless `isCondition` flag is set to false, in which case\n     * it's assumed to be used for side effects only and is skipped.\n     */\n\n\n    function traverseNode(node, isCondition) {\n      // prevent checking the same node multiple times\n      if (traversedNodes.has(node)) {\n        return;\n      }\n\n      traversedNodes.add(node); // for logical operator, we check its operands\n\n      if (node.type === utils_1.AST_NODE_TYPES.LogicalExpression && node.operator !== '??') {\n        traverseLogicalExpression(node, isCondition);\n        return;\n      } // skip if node is not a condition\n\n\n      if (!isCondition) {\n        return;\n      }\n\n      checkNode(node);\n    }\n    /**\n     * This function does the actual type check on a node.\n     * It analyzes the type of a node and checks if it is allowed in a boolean context.\n     */\n\n\n    function checkNode(node) {\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      const type = util.getConstrainedTypeAtLocation(typeChecker, tsNode);\n      const types = inspectVariantTypes(tsutils.unionTypeParts(type));\n\n      const is = function () {\n        for (var _len = arguments.length, wantedTypes = new Array(_len), _key = 0; _key < _len; _key++) {\n          wantedTypes[_key] = arguments[_key];\n        }\n\n        return types.size === wantedTypes.length && wantedTypes.every(type => types.has(type));\n      }; // boolean\n\n\n      if (is('boolean') || is('truthy boolean')) {\n        // boolean is always okay\n        return;\n      } // never\n\n\n      if (is('never')) {\n        // never is always okay\n        return;\n      } // nullish\n\n\n      if (is('nullish')) {\n        // condition is always false\n        context.report({\n          node,\n          messageId: 'conditionErrorNullish'\n        });\n        return;\n      } // Known edge case: boolean `true` and nullish values are always valid boolean expressions\n\n\n      if (is('nullish', 'truthy boolean')) {\n        return;\n      } // nullable boolean\n\n\n      if (is('nullish', 'boolean')) {\n        if (!options.allowNullableBoolean) {\n          if (isLogicalNegationExpression(node.parent)) {\n            // if (!nullableBoolean)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableBoolean',\n              suggest: [{\n                messageId: 'conditionFixDefaultFalse',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} ?? false`\n                })\n              }, {\n                messageId: 'conditionFixCompareFalse',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `${code} === false`\n                })\n              }]\n            });\n          } else {\n            // if (nullableBoolean)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableBoolean',\n              suggest: [{\n                messageId: 'conditionFixDefaultFalse',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} ?? false`\n                })\n              }, {\n                messageId: 'conditionFixCompareTrue',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} === true`\n                })\n              }]\n            });\n          }\n        }\n\n        return;\n      } // Known edge case: truthy primitives and nullish values are always valid boolean expressions\n\n\n      if (options.allowNumber && is('nullish', 'truthy number') || options.allowString && is('nullish', 'truthy string')) {\n        return;\n      } // string\n\n\n      if (is('string') || is('truthy string')) {\n        if (!options.allowString) {\n          if (isLogicalNegationExpression(node.parent)) {\n            // if (!string)\n            context.report({\n              node,\n              messageId: 'conditionErrorString',\n              suggest: [{\n                messageId: 'conditionFixCompareStringLength',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `${code}.length === 0`\n                })\n              }, {\n                messageId: 'conditionFixCompareEmptyString',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `${code} === \"\"`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `!Boolean(${code})`\n                })\n              }]\n            });\n          } else {\n            // if (string)\n            context.report({\n              node,\n              messageId: 'conditionErrorString',\n              suggest: [{\n                messageId: 'conditionFixCompareStringLength',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code}.length > 0`\n                })\n              }, {\n                messageId: 'conditionFixCompareEmptyString',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} !== \"\"`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `Boolean(${code})`\n                })\n              }]\n            });\n          }\n        }\n\n        return;\n      } // nullable string\n\n\n      if (is('nullish', 'string')) {\n        if (!options.allowNullableString) {\n          if (isLogicalNegationExpression(node.parent)) {\n            // if (!nullableString)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableString',\n              suggest: [{\n                messageId: 'conditionFixCompareNullish',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `${code} == null`\n                })\n              }, {\n                messageId: 'conditionFixDefaultEmptyString',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} ?? \"\"`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `!Boolean(${code})`\n                })\n              }]\n            });\n          } else {\n            // if (nullableString)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableString',\n              suggest: [{\n                messageId: 'conditionFixCompareNullish',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} != null`\n                })\n              }, {\n                messageId: 'conditionFixDefaultEmptyString',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} ?? \"\"`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `Boolean(${code})`\n                })\n              }]\n            });\n          }\n        }\n\n        return;\n      } // number\n\n\n      if (is('number') || is('truthy number')) {\n        if (!options.allowNumber) {\n          if (isArrayLengthExpression(node, typeChecker, parserServices)) {\n            if (isLogicalNegationExpression(node.parent)) {\n              // if (!array.length)\n              context.report({\n                node,\n                messageId: 'conditionErrorNumber',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `${code} === 0`\n                })\n              });\n            } else {\n              // if (array.length)\n              context.report({\n                node,\n                messageId: 'conditionErrorNumber',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} > 0`\n                })\n              });\n            }\n          } else if (isLogicalNegationExpression(node.parent)) {\n            // if (!number)\n            context.report({\n              node,\n              messageId: 'conditionErrorNumber',\n              suggest: [{\n                messageId: 'conditionFixCompareZero',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  // TODO: we have to compare to 0n if the type is bigint\n                  wrap: code => `${code} === 0`\n                })\n              }, {\n                // TODO: don't suggest this for bigint because it can't be NaN\n                messageId: 'conditionFixCompareNaN',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `Number.isNaN(${code})`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `!Boolean(${code})`\n                })\n              }]\n            });\n          } else {\n            // if (number)\n            context.report({\n              node,\n              messageId: 'conditionErrorNumber',\n              suggest: [{\n                messageId: 'conditionFixCompareZero',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} !== 0`\n                })\n              }, {\n                messageId: 'conditionFixCompareNaN',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `!Number.isNaN(${code})`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `Boolean(${code})`\n                })\n              }]\n            });\n          }\n        }\n\n        return;\n      } // nullable number\n\n\n      if (is('nullish', 'number')) {\n        if (!options.allowNullableNumber) {\n          if (isLogicalNegationExpression(node.parent)) {\n            // if (!nullableNumber)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableNumber',\n              suggest: [{\n                messageId: 'conditionFixCompareNullish',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `${code} == null`\n                })\n              }, {\n                messageId: 'conditionFixDefaultZero',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} ?? 0`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node: node.parent,\n                  innerNode: node,\n                  wrap: code => `!Boolean(${code})`\n                })\n              }]\n            });\n          } else {\n            // if (nullableNumber)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableNumber',\n              suggest: [{\n                messageId: 'conditionFixCompareNullish',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} != null`\n                })\n              }, {\n                messageId: 'conditionFixDefaultZero',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `${code} ?? 0`\n                })\n              }, {\n                messageId: 'conditionFixCastBoolean',\n                fix: util.getWrappingFixer({\n                  sourceCode,\n                  node,\n                  wrap: code => `Boolean(${code})`\n                })\n              }]\n            });\n          }\n        }\n\n        return;\n      } // object\n\n\n      if (is('object')) {\n        // condition is always true\n        context.report({\n          node,\n          messageId: 'conditionErrorObject'\n        });\n        return;\n      } // nullable object\n\n\n      if (is('nullish', 'object')) {\n        if (!options.allowNullableObject) {\n          if (isLogicalNegationExpression(node.parent)) {\n            // if (!nullableObject)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableObject',\n              fix: util.getWrappingFixer({\n                sourceCode,\n                node: node.parent,\n                innerNode: node,\n                wrap: code => `${code} == null`\n              })\n            });\n          } else {\n            // if (nullableObject)\n            context.report({\n              node,\n              messageId: 'conditionErrorNullableObject',\n              fix: util.getWrappingFixer({\n                sourceCode,\n                node,\n                wrap: code => `${code} != null`\n              })\n            });\n          }\n        }\n\n        return;\n      } // any\n\n\n      if (is('any')) {\n        if (!options.allowAny) {\n          context.report({\n            node,\n            messageId: 'conditionErrorAny',\n            suggest: [{\n              messageId: 'conditionFixCastBoolean',\n              fix: util.getWrappingFixer({\n                sourceCode,\n                node,\n                wrap: code => `Boolean(${code})`\n              })\n            }]\n          });\n        }\n\n        return;\n      } // other\n\n\n      context.report({\n        node,\n        messageId: 'conditionErrorOther'\n      });\n    }\n    /**\n     * Check union variants for the types we care about\n     */\n\n\n    function inspectVariantTypes(types) {\n      const variantTypes = new Set();\n\n      if (types.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike))) {\n        variantTypes.add('nullish');\n      }\n\n      const booleans = types.filter(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.BooleanLike)); // If incoming type is either \"true\" or \"false\", there will be one type\n      // object with intrinsicName set accordingly\n      // If incoming type is boolean, there will be two type objects with\n      // intrinsicName set \"true\" and \"false\" each because of tsutils.unionTypeParts()\n\n      if (booleans.length === 1) {\n        tsutils.isBooleanLiteralType(booleans[0], true) ? variantTypes.add('truthy boolean') : variantTypes.add('boolean');\n      } else if (booleans.length === 2) {\n        variantTypes.add('boolean');\n      }\n\n      const strings = types.filter(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.StringLike));\n\n      if (strings.length) {\n        if (strings.some(type => type.isStringLiteral() && type.value !== '')) {\n          variantTypes.add('truthy string');\n        } else {\n          variantTypes.add('string');\n        }\n      }\n\n      const numbers = types.filter(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike));\n\n      if (numbers.length) {\n        if (numbers.some(type => type.isNumberLiteral() && type.value !== 0)) {\n          variantTypes.add('truthy number');\n        } else {\n          variantTypes.add('number');\n        }\n      }\n\n      if (types.some(type => !tsutils.isTypeFlagSet(type, ts.TypeFlags.Null | ts.TypeFlags.Undefined | ts.TypeFlags.VoidLike | ts.TypeFlags.BooleanLike | ts.TypeFlags.StringLike | ts.TypeFlags.NumberLike | ts.TypeFlags.BigIntLike | ts.TypeFlags.TypeParameter | ts.TypeFlags.Any | ts.TypeFlags.Unknown | ts.TypeFlags.Never))) {\n        variantTypes.add('object');\n      }\n\n      if (types.some(type => util.isTypeFlagSet(type, ts.TypeFlags.TypeParameter | ts.TypeFlags.Any | ts.TypeFlags.Unknown))) {\n        variantTypes.add('any');\n      }\n\n      if (types.some(type => tsutils.isTypeFlagSet(type, ts.TypeFlags.Never))) {\n        variantTypes.add('never');\n      }\n\n      return variantTypes;\n    }\n  }\n\n});\n\nfunction isLogicalNegationExpression(node) {\n  return node.type === utils_1.AST_NODE_TYPES.UnaryExpression && node.operator === '!';\n}\n\nfunction isArrayLengthExpression(node, typeChecker, parserServices) {\n  if (node.type !== utils_1.AST_NODE_TYPES.MemberExpression) {\n    return false;\n  }\n\n  if (node.computed) {\n    return false;\n  }\n\n  if (node.property.name !== 'length') {\n    return false;\n  }\n\n  const objectTsNode = parserServices.esTreeNodeToTSNodeMap.get(node.object);\n  const objectType = util.getConstrainedTypeAtLocation(typeChecker, objectTsNode);\n  return util.isTypeArrayTypeOrUnionOfArrayTypes(objectType, typeChecker);\n}","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","fixable","hasSuggestions","docs","description","recommended","requiresTypeChecking","schema","properties","allowString","allowNumber","allowNullableObject","allowNullableBoolean","allowNullableString","allowNullableNumber","allowAny","allowRuleToRunWithoutStrictNullChecksIKnowWhatIAmDoing","additionalProperties","messages","conditionErrorOther","conditionErrorAny","conditionErrorNullish","conditionErrorNullableBoolean","conditionErrorString","conditionErrorNullableString","conditionErrorNumber","conditionErrorNullableNumber","conditionErrorObject","conditionErrorNullableObject","noStrictNullCheck","conditionFixDefaultFalse","conditionFixDefaultEmptyString","conditionFixDefaultZero","conditionFixCompareNullish","conditionFixCastBoolean","conditionFixCompareTrue","conditionFixCompareFalse","conditionFixCompareStringLength","conditionFixCompareEmptyString","conditionFixCompareZero","conditionFixCompareNaN","defaultOptions","create","context","options","parserServices","getParserServices","typeChecker","program","getTypeChecker","compilerOptions","getCompilerOptions","sourceCode","getSourceCode","isStrictNullChecks","tsutils","isStrictCompilerOptionEnabled","report","loc","start","line","column","end","messageId","traversedNodes","Set","ConditionalExpression","traverseTestExpression","DoWhileStatement","ForStatement","IfStatement","WhileStatement","traverseLogicalExpression","traverseUnaryLogicalExpression","node","test","traverseNode","argument","isCondition","left","right","has","add","utils_1","LogicalExpression","operator","checkNode","tsNode","esTreeNodeToTSNodeMap","get","getConstrainedTypeAtLocation","types","inspectVariantTypes","unionTypeParts","is","wantedTypes","size","length","every","isLogicalNegationExpression","parent","suggest","fix","getWrappingFixer","wrap","code","innerNode","isArrayLengthExpression","variantTypes","some","isTypeFlagSet","ts","TypeFlags","Null","Undefined","VoidLike","booleans","filter","BooleanLike","isBooleanLiteralType","strings","StringLike","isStringLiteral","value","numbers","NumberLike","BigIntLike","isNumberLiteral","TypeParameter","Any","Unknown","Never","UnaryExpression","MemberExpression","computed","property","objectTsNode","object","objectType","isTypeArrayTypeOrUnionOfArrayTypes"],"sources":["../../src/rules/strict-boolean-expressions.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}