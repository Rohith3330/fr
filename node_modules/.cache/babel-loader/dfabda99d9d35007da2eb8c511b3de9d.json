{"ast":null,"code":"function partitionRules(root) {\n  if (!root.walkAtRules) return;\n  let applyParents = new Set();\n  root.walkAtRules('apply', rule => {\n    applyParents.add(rule.parent);\n  });\n\n  if (applyParents.size === 0) {\n    return;\n  }\n\n  for (let rule of applyParents) {\n    let nodeGroups = [];\n    let lastGroup = [];\n\n    for (let node of rule.nodes) {\n      if (node.type === 'atrule' && node.name === 'apply') {\n        if (lastGroup.length > 0) {\n          nodeGroups.push(lastGroup);\n          lastGroup = [];\n        }\n\n        nodeGroups.push([node]);\n      } else {\n        lastGroup.push(node);\n      }\n    }\n\n    if (lastGroup.length > 0) {\n      nodeGroups.push(lastGroup);\n    }\n\n    if (nodeGroups.length === 1) {\n      continue;\n    }\n\n    for (let group of [...nodeGroups].reverse()) {\n      let clone = rule.clone({\n        nodes: []\n      });\n      clone.append(group);\n      rule.after(clone);\n    }\n\n    rule.remove();\n  }\n}\n\nexport default function expandApplyAtRules() {\n  return root => {\n    partitionRules(root);\n  };\n}","map":{"version":3,"names":["partitionRules","root","walkAtRules","applyParents","Set","rule","add","parent","size","nodeGroups","lastGroup","node","nodes","type","name","length","push","group","reverse","clone","append","after","remove","expandApplyAtRules"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/src/lib/partitionApplyAtRules.js"],"sourcesContent":["function partitionRules(root) {\n  if (!root.walkAtRules) return\n\n  let applyParents = new Set()\n\n  root.walkAtRules('apply', (rule) => {\n    applyParents.add(rule.parent)\n  })\n\n  if (applyParents.size === 0) {\n    return\n  }\n\n  for (let rule of applyParents) {\n    let nodeGroups = []\n    let lastGroup = []\n\n    for (let node of rule.nodes) {\n      if (node.type === 'atrule' && node.name === 'apply') {\n        if (lastGroup.length > 0) {\n          nodeGroups.push(lastGroup)\n          lastGroup = []\n        }\n        nodeGroups.push([node])\n      } else {\n        lastGroup.push(node)\n      }\n    }\n\n    if (lastGroup.length > 0) {\n      nodeGroups.push(lastGroup)\n    }\n\n    if (nodeGroups.length === 1) {\n      continue\n    }\n\n    for (let group of [...nodeGroups].reverse()) {\n      let clone = rule.clone({ nodes: [] })\n      clone.append(group)\n      rule.after(clone)\n    }\n\n    rule.remove()\n  }\n}\n\nexport default function expandApplyAtRules() {\n  return (root) => {\n    partitionRules(root)\n  }\n}\n"],"mappings":"AAAA,SAASA,cAAT,CAAwBC,IAAxB,EAA8B;EAC5B,IAAI,CAACA,IAAI,CAACC,WAAV,EAAuB;EAEvB,IAAIC,YAAY,GAAG,IAAIC,GAAJ,EAAnB;EAEAH,IAAI,CAACC,WAAL,CAAiB,OAAjB,EAA2BG,IAAD,IAAU;IAClCF,YAAY,CAACG,GAAb,CAAiBD,IAAI,CAACE,MAAtB;EACD,CAFD;;EAIA,IAAIJ,YAAY,CAACK,IAAb,KAAsB,CAA1B,EAA6B;IAC3B;EACD;;EAED,KAAK,IAAIH,IAAT,IAAiBF,YAAjB,EAA+B;IAC7B,IAAIM,UAAU,GAAG,EAAjB;IACA,IAAIC,SAAS,GAAG,EAAhB;;IAEA,KAAK,IAAIC,IAAT,IAAiBN,IAAI,CAACO,KAAtB,EAA6B;MAC3B,IAAID,IAAI,CAACE,IAAL,KAAc,QAAd,IAA0BF,IAAI,CAACG,IAAL,KAAc,OAA5C,EAAqD;QACnD,IAAIJ,SAAS,CAACK,MAAV,GAAmB,CAAvB,EAA0B;UACxBN,UAAU,CAACO,IAAX,CAAgBN,SAAhB;UACAA,SAAS,GAAG,EAAZ;QACD;;QACDD,UAAU,CAACO,IAAX,CAAgB,CAACL,IAAD,CAAhB;MACD,CAND,MAMO;QACLD,SAAS,CAACM,IAAV,CAAeL,IAAf;MACD;IACF;;IAED,IAAID,SAAS,CAACK,MAAV,GAAmB,CAAvB,EAA0B;MACxBN,UAAU,CAACO,IAAX,CAAgBN,SAAhB;IACD;;IAED,IAAID,UAAU,CAACM,MAAX,KAAsB,CAA1B,EAA6B;MAC3B;IACD;;IAED,KAAK,IAAIE,KAAT,IAAkB,CAAC,GAAGR,UAAJ,EAAgBS,OAAhB,EAAlB,EAA6C;MAC3C,IAAIC,KAAK,GAAGd,IAAI,CAACc,KAAL,CAAW;QAAEP,KAAK,EAAE;MAAT,CAAX,CAAZ;MACAO,KAAK,CAACC,MAAN,CAAaH,KAAb;MACAZ,IAAI,CAACgB,KAAL,CAAWF,KAAX;IACD;;IAEDd,IAAI,CAACiB,MAAL;EACD;AACF;;AAED,eAAe,SAASC,kBAAT,GAA8B;EAC3C,OAAQtB,IAAD,IAAU;IACfD,cAAc,CAACC,IAAD,CAAd;EACD,CAFD;AAGD"},"metadata":{},"sourceType":"module"}