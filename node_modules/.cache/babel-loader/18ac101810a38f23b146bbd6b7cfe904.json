{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"FEATURES\", {\n  enumerable: true,\n  get: function () {\n    return _features.FEATURES;\n  }\n});\nexports.createClassFeaturePlugin = createClassFeaturePlugin;\nObject.defineProperty(exports, \"enableFeature\", {\n  enumerable: true,\n  get: function () {\n    return _features.enableFeature;\n  }\n});\nObject.defineProperty(exports, \"injectInitialization\", {\n  enumerable: true,\n  get: function () {\n    return _misc.injectInitialization;\n  }\n});\n\nvar _core = require(\"@babel/core\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar _fields = require(\"./fields\");\n\nvar _decorators = require(\"./decorators\");\n\nvar _misc = require(\"./misc\");\n\nvar _features = require(\"./features\");\n\nvar _typescript = require(\"./typescript\");\n\nconst version = \"7.19.0\".split(\".\").reduce((v, x) => v * 1e5 + +x, 0);\nconst versionKey = \"@babel/plugin-class-features/version\";\n\nfunction createClassFeaturePlugin(_ref) {\n  let {\n    name,\n    feature,\n    loose,\n    manipulateOptions,\n    api = {\n      assumption: () => void 0\n    },\n    inherits\n  } = _ref;\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n  const privateFieldsAsProperties = api.assumption(\"privateFieldsAsProperties\");\n  const constantSuper = api.assumption(\"constantSuper\");\n  const noDocumentAll = api.assumption(\"noDocumentAll\");\n\n  if (loose === true) {\n    const explicit = [];\n\n    if (setPublicClassFields !== undefined) {\n      explicit.push(`\"setPublicClassFields\"`);\n    }\n\n    if (privateFieldsAsProperties !== undefined) {\n      explicit.push(`\"privateFieldsAsProperties\"`);\n    }\n\n    if (explicit.length !== 0) {\n      console.warn(`[${name}]: You are using the \"loose: true\" option and you are` + ` explicitly setting a value for the ${explicit.join(\" and \")}` + ` assumption${explicit.length > 1 ? \"s\" : \"\"}. The \"loose\" option` + ` can cause incompatibilities with the other class features` + ` plugins, so it's recommended that you replace it with the` + ` following top-level option:\\n` + `\\t\"assumptions\": {\\n` + `\\t\\t\"setPublicClassFields\": true,\\n` + `\\t\\t\"privateFieldsAsProperties\": true\\n` + `\\t}`);\n    }\n  }\n\n  return {\n    name,\n    manipulateOptions,\n    inherits,\n\n    pre(file) {\n      (0, _features.enableFeature)(file, feature, loose);\n\n      if (!file.get(versionKey) || file.get(versionKey) < version) {\n        file.set(versionKey, version);\n      }\n    },\n\n    visitor: {\n      Class(path, _ref2) {\n        let {\n          file\n        } = _ref2;\n        if (file.get(versionKey) !== version) return;\n        if (!(0, _features.shouldTransform)(path, file)) return;\n        if (path.isClassDeclaration()) (0, _typescript.assertFieldTransformed)(path);\n        const loose = (0, _features.isLoose)(file, feature);\n        let constructor;\n        const isDecorated = (0, _decorators.hasDecorators)(path.node);\n        const props = [];\n        const elements = [];\n        const computedPaths = [];\n        const privateNames = new Set();\n        const body = path.get(\"body\");\n\n        for (const path of body.get(\"body\")) {\n          if ((path.isClassProperty() || path.isClassMethod()) && path.node.computed) {\n            computedPaths.push(path);\n          }\n\n          if (path.isPrivate()) {\n            const {\n              name\n            } = path.node.key.id;\n            const getName = `get ${name}`;\n            const setName = `set ${name}`;\n\n            if (path.isClassPrivateMethod()) {\n              if (path.node.kind === \"get\") {\n                if (privateNames.has(getName) || privateNames.has(name) && !privateNames.has(setName)) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n\n                privateNames.add(getName).add(name);\n              } else if (path.node.kind === \"set\") {\n                if (privateNames.has(setName) || privateNames.has(name) && !privateNames.has(getName)) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n\n                privateNames.add(setName).add(name);\n              }\n            } else {\n              if (privateNames.has(name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(name) && (privateNames.has(getName) || privateNames.has(setName))) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(name);\n            }\n          }\n\n          if (path.isClassMethod({\n            kind: \"constructor\"\n          })) {\n            constructor = path;\n          } else {\n            elements.push(path);\n\n            if (path.isProperty() || path.isPrivate() || path.isStaticBlock != null && path.isStaticBlock()) {\n              props.push(path);\n            }\n          }\n        }\n\n        {\n          if (!props.length && !isDecorated) return;\n        }\n        const innerBinding = path.node.id;\n        let ref;\n\n        if (!innerBinding || path.isClassExpression()) {\n          (0, _helperFunctionName.default)(path);\n          ref = path.scope.generateUidIdentifier(\"class\");\n        } else {\n          ref = _core.types.cloneNode(path.node.id);\n        }\n\n        const privateNamesMap = (0, _fields.buildPrivateNamesMap)(props);\n        const privateNamesNodes = (0, _fields.buildPrivateNamesNodes)(privateNamesMap, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, file);\n        (0, _fields.transformPrivateNamesUsage)(ref, path, privateNamesMap, {\n          privateFieldsAsProperties: privateFieldsAsProperties != null ? privateFieldsAsProperties : loose,\n          noDocumentAll,\n          innerBinding\n        }, file);\n        let keysNodes, staticNodes, instanceNodes, pureStaticNodes, wrapClass;\n        {\n          if (isDecorated) {\n            staticNodes = pureStaticNodes = keysNodes = [];\n            ({\n              instanceNodes,\n              wrapClass\n            } = (0, _decorators.buildDecoratedClass)(ref, path, elements, file));\n          } else {\n            keysNodes = (0, _misc.extractComputedKeys)(path, computedPaths, file);\n            ({\n              staticNodes,\n              pureStaticNodes,\n              instanceNodes,\n              wrapClass\n            } = (0, _fields.buildFieldsInitNodes)(ref, path.node.superClass, props, privateNamesMap, file, setPublicClassFields != null ? setPublicClassFields : loose, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, constantSuper != null ? constantSuper : loose, innerBinding));\n          }\n        }\n\n        if (instanceNodes.length > 0) {\n          (0, _misc.injectInitialization)(path, constructor, instanceNodes, (referenceVisitor, state) => {\n            {\n              if (isDecorated) return;\n            }\n\n            for (const prop of props) {\n              if (_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node) || prop.node.static) continue;\n              prop.traverse(referenceVisitor, state);\n            }\n          });\n        }\n\n        const wrappedPath = wrapClass(path);\n        wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]);\n\n        if (staticNodes.length > 0) {\n          wrappedPath.insertAfter(staticNodes);\n        }\n\n        if (pureStaticNodes.length > 0) {\n          wrappedPath.find(parent => parent.isStatement() || parent.isDeclaration()).insertAfter(pureStaticNodes);\n        }\n      },\n\n      ExportDefaultDeclaration(path, _ref3) {\n        let {\n          file\n        } = _ref3;\n        {\n          if (file.get(versionKey) !== version) return;\n          const decl = path.get(\"declaration\");\n\n          if (decl.isClassDeclaration() && (0, _decorators.hasDecorators)(decl.node)) {\n            if (decl.node.id) {\n              (0, _helperSplitExportDeclaration.default)(path);\n            } else {\n              decl.node.type = \"ClassExpression\";\n            }\n          }\n        }\n      }\n\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["version","split","reduce","v","x","versionKey","createClassFeaturePlugin","name","feature","loose","manipulateOptions","api","assumption","inherits","setPublicClassFields","privateFieldsAsProperties","constantSuper","noDocumentAll","explicit","undefined","push","length","console","warn","join","pre","file","get","set","visitor","Class","path","isClassDeclaration","constructor","isDecorated","node","props","elements","computedPaths","privateNames","Set","body","isClassProperty","isClassMethod","computed","isPrivate","key","id","getName","setName","isClassPrivateMethod","kind","has","buildCodeFrameError","add","isProperty","isStaticBlock","innerBinding","ref","isClassExpression","scope","generateUidIdentifier","t","cloneNode","privateNamesMap","privateNamesNodes","keysNodes","staticNodes","instanceNodes","pureStaticNodes","wrapClass","superClass","referenceVisitor","state","prop","static","traverse","wrappedPath","insertBefore","insertAfter","find","parent","isStatement","isDeclaration","ExportDefaultDeclaration","decl","type"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-create-class-features-plugin\\src\\index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { PluginAPI, PluginObject } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport {\n  buildPrivateNamesNodes,\n  buildPrivateNamesMap,\n  transformPrivateNamesUsage,\n  buildFieldsInitNodes,\n} from \"./fields\";\nimport type { PropPath } from \"./fields\";\nimport { buildDecoratedClass, hasDecorators } from \"./decorators\";\nimport { injectInitialization, extractComputedKeys } from \"./misc\";\nimport { enableFeature, FEATURES, isLoose, shouldTransform } from \"./features\";\nimport { assertFieldTransformed } from \"./typescript\";\n\nexport { FEATURES, enableFeature, injectInitialization };\n\ndeclare const PACKAGE_JSON: { name: string; version: string };\n\n// Note: Versions are represented as an integer. e.g. 7.1.5 is represented\n//       as 70000100005. This method is easier than using a semver-parsing\n//       package, but it breaks if we release x.y.z where x, y or z are\n//       greater than 99_999.\nconst version = PACKAGE_JSON.version\n  .split(\".\")\n  .reduce((v, x) => v * 1e5 + +x, 0);\nconst versionKey = \"@babel/plugin-class-features/version\";\n\ninterface Options {\n  name: string;\n  feature: number;\n  loose?: boolean;\n  inherits?: PluginObject[\"inherits\"];\n  manipulateOptions?: PluginObject[\"manipulateOptions\"];\n  api?: PluginAPI;\n}\n\nexport function createClassFeaturePlugin({\n  name,\n  feature,\n  loose,\n  manipulateOptions,\n  // @ts-ignore(Babel 7 vs Babel 8) TODO(Babel 8): Remove the default value\n  api = { assumption: () => void 0 },\n  inherits,\n}: Options): PluginObject {\n  const setPublicClassFields = api.assumption(\"setPublicClassFields\");\n  const privateFieldsAsProperties = api.assumption(\"privateFieldsAsProperties\");\n  const constantSuper = api.assumption(\"constantSuper\");\n  const noDocumentAll = api.assumption(\"noDocumentAll\");\n\n  if (loose === true) {\n    const explicit = [];\n\n    if (setPublicClassFields !== undefined) {\n      explicit.push(`\"setPublicClassFields\"`);\n    }\n    if (privateFieldsAsProperties !== undefined) {\n      explicit.push(`\"privateFieldsAsProperties\"`);\n    }\n    if (explicit.length !== 0) {\n      console.warn(\n        `[${name}]: You are using the \"loose: true\" option and you are` +\n          ` explicitly setting a value for the ${explicit.join(\" and \")}` +\n          ` assumption${explicit.length > 1 ? \"s\" : \"\"}. The \"loose\" option` +\n          ` can cause incompatibilities with the other class features` +\n          ` plugins, so it's recommended that you replace it with the` +\n          ` following top-level option:\\n` +\n          `\\t\"assumptions\": {\\n` +\n          `\\t\\t\"setPublicClassFields\": true,\\n` +\n          `\\t\\t\"privateFieldsAsProperties\": true\\n` +\n          `\\t}`,\n      );\n    }\n  }\n\n  return {\n    name,\n    manipulateOptions,\n    inherits,\n\n    pre(file) {\n      enableFeature(file, feature, loose);\n\n      if (!file.get(versionKey) || file.get(versionKey) < version) {\n        file.set(versionKey, version);\n      }\n    },\n\n    visitor: {\n      Class(path, { file }) {\n        if (file.get(versionKey) !== version) return;\n\n        if (!shouldTransform(path, file)) return;\n\n        if (path.isClassDeclaration()) assertFieldTransformed(path);\n\n        const loose = isLoose(file, feature);\n\n        let constructor: NodePath<t.ClassMethod>;\n        const isDecorated = hasDecorators(path.node);\n        const props: PropPath[] = [];\n        const elements = [];\n        const computedPaths: NodePath<t.ClassProperty | t.ClassMethod>[] = [];\n        const privateNames = new Set<string>();\n        const body = path.get(\"body\");\n\n        for (const path of body.get(\"body\")) {\n          if (\n            // check path.node.computed is enough, but ts will complain\n            (path.isClassProperty() || path.isClassMethod()) &&\n            path.node.computed\n          ) {\n            computedPaths.push(path);\n          }\n\n          if (path.isPrivate()) {\n            const { name } = path.node.key.id;\n            const getName = `get ${name}`;\n            const setName = `set ${name}`;\n\n            if (path.isClassPrivateMethod()) {\n              if (path.node.kind === \"get\") {\n                if (\n                  privateNames.has(getName) ||\n                  (privateNames.has(name) && !privateNames.has(setName))\n                ) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(getName).add(name);\n              } else if (path.node.kind === \"set\") {\n                if (\n                  privateNames.has(setName) ||\n                  (privateNames.has(name) && !privateNames.has(getName))\n                ) {\n                  throw path.buildCodeFrameError(\"Duplicate private field\");\n                }\n                privateNames.add(setName).add(name);\n              }\n            } else {\n              if (\n                (privateNames.has(name) &&\n                  !privateNames.has(getName) &&\n                  !privateNames.has(setName)) ||\n                (privateNames.has(name) &&\n                  (privateNames.has(getName) || privateNames.has(setName)))\n              ) {\n                throw path.buildCodeFrameError(\"Duplicate private field\");\n              }\n\n              privateNames.add(name);\n            }\n          }\n\n          if (path.isClassMethod({ kind: \"constructor\" })) {\n            constructor = path;\n          } else {\n            elements.push(path);\n            if (\n              path.isProperty() ||\n              path.isPrivate() ||\n              path.isStaticBlock?.()\n            ) {\n              props.push(path as PropPath);\n            }\n          }\n        }\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (!props.length) return;\n        } else {\n          if (!props.length && !isDecorated) return;\n        }\n\n        const innerBinding = path.node.id;\n        let ref: t.Identifier;\n        if (!innerBinding || path.isClassExpression()) {\n          nameFunction(path);\n          ref = path.scope.generateUidIdentifier(\"class\");\n        } else {\n          ref = t.cloneNode(path.node.id);\n        }\n\n        // NODE: These three functions don't support decorators yet,\n        //       but verifyUsedFeatures throws if there are both\n        //       decorators and private fields.\n        const privateNamesMap = buildPrivateNamesMap(props);\n        const privateNamesNodes = buildPrivateNamesNodes(\n          privateNamesMap,\n          (privateFieldsAsProperties ?? loose) as boolean,\n          file,\n        );\n\n        transformPrivateNamesUsage(\n          ref,\n          path,\n          privateNamesMap,\n          {\n            privateFieldsAsProperties: privateFieldsAsProperties ?? loose,\n            noDocumentAll,\n            innerBinding,\n          },\n          file,\n        );\n\n        let keysNodes: t.Statement[],\n          staticNodes: t.Statement[],\n          instanceNodes: t.Statement[],\n          pureStaticNodes: t.FunctionDeclaration[],\n          wrapClass: (path: NodePath<t.Class>) => NodePath;\n\n        if (!process.env.BABEL_8_BREAKING) {\n          if (isDecorated) {\n            staticNodes = pureStaticNodes = keysNodes = [];\n            ({ instanceNodes, wrapClass } = buildDecoratedClass(\n              ref,\n              path,\n              elements,\n              file,\n            ));\n          } else {\n            keysNodes = extractComputedKeys(path, computedPaths, file);\n            ({ staticNodes, pureStaticNodes, instanceNodes, wrapClass } =\n              buildFieldsInitNodes(\n                ref,\n                path.node.superClass,\n                props,\n                privateNamesMap,\n                file,\n                (setPublicClassFields ?? loose) as boolean,\n                (privateFieldsAsProperties ?? loose) as boolean,\n                (constantSuper ?? loose) as boolean,\n                innerBinding,\n              ));\n          }\n        } else {\n          keysNodes = extractComputedKeys(path, computedPaths, file);\n          ({ staticNodes, pureStaticNodes, instanceNodes, wrapClass } =\n            buildFieldsInitNodes(\n              ref,\n              path.node.superClass,\n              props,\n              privateNamesMap,\n              file,\n              (setPublicClassFields ?? loose) as boolean,\n              (privateFieldsAsProperties ?? loose) as boolean,\n              (constantSuper ?? loose) as boolean,\n              innerBinding,\n            ));\n        }\n\n        if (instanceNodes.length > 0) {\n          injectInitialization(\n            path,\n            constructor,\n            instanceNodes,\n            (referenceVisitor, state) => {\n              if (!process.env.BABEL_8_BREAKING) {\n                if (isDecorated) return;\n              }\n              for (const prop of props) {\n                // @ts-expect-error: TS doesn't infer that prop.node is not a StaticBlock\n                if (t.isStaticBlock?.(prop.node) || prop.node.static) continue;\n                prop.traverse(referenceVisitor, state);\n              }\n            },\n          );\n        }\n\n        // rename to make ts happy\n        const wrappedPath = wrapClass(path);\n        wrappedPath.insertBefore([...privateNamesNodes, ...keysNodes]);\n        if (staticNodes.length > 0) {\n          wrappedPath.insertAfter(staticNodes);\n        }\n        if (pureStaticNodes.length > 0) {\n          wrappedPath\n            .find(parent => parent.isStatement() || parent.isDeclaration())\n            .insertAfter(pureStaticNodes);\n        }\n      },\n\n      ExportDefaultDeclaration(path, { file }) {\n        if (!process.env.BABEL_8_BREAKING) {\n          if (file.get(versionKey) !== version) return;\n\n          const decl = path.get(\"declaration\");\n\n          if (decl.isClassDeclaration() && hasDecorators(decl.node)) {\n            if (decl.node.id) {\n              // export default class Foo {}\n              //   -->\n              // class Foo {} export { Foo as default }\n              splitExportDeclaration(path);\n            } else {\n              // @ts-expect-error Anonymous class declarations can be\n              // transformed as if they were expressions\n              decl.node.type = \"ClassExpression\";\n            }\n          }\n        }\n      },\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"script"}