{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n/**\n * @fileOverview Ensures that no imported module imports the linted module.\n * @author Ben Mosher\n */\n\n\nvar _resolve = require('eslint-module-utils/resolve');\n\nvar _resolve2 = _interopRequireDefault(_resolve);\n\nvar _ExportMap = require('../ExportMap');\n\nvar _ExportMap2 = _interopRequireDefault(_ExportMap);\n\nvar _importType = require('../core/importType');\n\nvar _moduleVisitor = require('eslint-module-utils/moduleVisitor');\n\nvar _moduleVisitor2 = _interopRequireDefault(_moduleVisitor);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n} // todo: cache cycles / deep relationships for faster repeat evaluation\n\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: (0, _docsUrl2['default'])('no-cycle')\n    },\n    schema: [(0, _moduleVisitor.makeOptionsSchema)({\n      maxDepth: {\n        oneOf: [{\n          description: 'maximum dependency depth to traverse',\n          type: 'integer',\n          minimum: 1\n        }, {\n          'enum': ['∞'],\n          type: 'string'\n        }]\n      },\n      ignoreExternal: {\n        description: 'ignore external modules',\n        type: 'boolean',\n        'default': false\n      }\n    })]\n  },\n  create: function () {\n    function create(context) {\n      var myPath = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n      if (myPath === '<text>') return {}; // can't cycle-check a non-file\n\n      var options = context.options[0] || {};\n      var maxDepth = typeof options.maxDepth === 'number' ? options.maxDepth : Infinity;\n\n      var ignoreModule = function () {\n        function ignoreModule(name) {\n          return options.ignoreExternal && (0, _importType.isExternalModule)(name, (0, _resolve2['default'])(name, context), context);\n        }\n\n        return ignoreModule;\n      }();\n\n      function checkSourceValue(sourceNode, importer) {\n        if (ignoreModule(sourceNode.value)) {\n          return; // ignore external modules\n        }\n\n        if (importer.type === 'ImportDeclaration' && ( // import type { Foo } (TS and Flow)\n        importer.importKind === 'type' || // import { type Foo } (Flow)\n        importer.specifiers.every(function (_ref) {\n          var importKind = _ref.importKind;\n          return importKind === 'type';\n        }))) {\n          return; // ignore type imports\n        }\n\n        var imported = _ExportMap2['default'].get(sourceNode.value, context);\n\n        if (imported == null) {\n          return; // no-unresolved territory\n        }\n\n        if (imported.path === myPath) {\n          return; // no-self-import territory\n        }\n\n        var untraversed = [{\n          mget: function () {\n            function mget() {\n              return imported;\n            }\n\n            return mget;\n          }(),\n          route: []\n        }];\n        var traversed = new Set();\n\n        function detectCycle(_ref2) {\n          var mget = _ref2.mget,\n              route = _ref2.route;\n          var m = mget();\n          if (m == null) return;\n          if (traversed.has(m.path)) return;\n          traversed.add(m.path);\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = m.imports[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var _ref3 = _step.value;\n\n              var _ref4 = _slicedToArray(_ref3, 2);\n\n              var path = _ref4[0];\n              var _ref4$ = _ref4[1];\n              var getter = _ref4$.getter;\n              var declarations = _ref4$.declarations;\n              if (traversed.has(path)) continue;\n              var toTraverse = [].concat(_toConsumableArray(declarations)).filter(function (_ref5) {\n                var source = _ref5.source,\n                    isOnlyImportingTypes = _ref5.isOnlyImportingTypes;\n                return !ignoreModule(source.value) && // Ignore only type imports\n                !isOnlyImportingTypes;\n              });\n              /*\n                                             Only report as a cycle if there are any import declarations that are considered by\n                                             the rule. For example:\n                                              a.ts:\n                                             import { foo } from './b' // should not be reported as a cycle\n                                              b.ts:\n                                             import type { Bar } from './a'\n                                             */\n\n              if (path === myPath && toTraverse.length > 0) return true;\n\n              if (route.length + 1 < maxDepth) {\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                  for (var _iterator2 = toTraverse[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var _ref6 = _step2.value;\n                    var source = _ref6.source;\n                    untraversed.push({\n                      mget: getter,\n                      route: route.concat(source)\n                    });\n                  }\n                } catch (err) {\n                  _didIteratorError2 = true;\n                  _iteratorError2 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n                      _iterator2['return']();\n                    }\n                  } finally {\n                    if (_didIteratorError2) {\n                      throw _iteratorError2;\n                    }\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator['return']) {\n                _iterator['return']();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n\n        while (untraversed.length > 0) {\n          var next = untraversed.shift(); // bfs!\n\n          if (detectCycle(next)) {\n            var message = next.route.length > 0 ? 'Dependency cycle via ' + String(routeString(next.route)) : 'Dependency cycle detected.';\n            context.report(importer, message);\n            return;\n          }\n        }\n      }\n\n      return (0, _moduleVisitor2['default'])(checkSourceValue, context.options[0]);\n    }\n\n    return create;\n  }()\n};\n\nfunction routeString(route) {\n  return route.map(function (s) {\n    return String(s.value) + ':' + String(s.loc.start.line);\n  }).join('=>');\n}","map":{"version":3,"mappings":"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","names":["module","exports","meta","type","docs","url","schema","maxDepth","oneOf","description","minimum","ignoreExternal","create","context","myPath","getPhysicalFilename","getFilename","options","Infinity","ignoreModule","name","checkSourceValue","sourceNode","importer","value","importKind","specifiers","every","imported","Exports","get","path","untraversed","mget","route","traversed","Set","detectCycle","m","has","add","imports","Symbol","getter","declarations","toTraverse","filter","source","isOnlyImportingTypes","length","push","concat","_didIteratorError2","_iteratorError2","_iterator2","_didIteratorError","_iteratorError","_iterator","next","shift","message","routeString","report","map","s","loc","start","line","join"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\no-cycle.js"],"sourcesContent":["/**\n * @fileOverview Ensures that no imported module imports the linted module.\n * @author Ben Mosher\n */\n\nimport resolve from 'eslint-module-utils/resolve';\nimport Exports from '../ExportMap';\nimport { isExternalModule } from '../core/importType';\nimport moduleVisitor, { makeOptionsSchema } from 'eslint-module-utils/moduleVisitor';\nimport docsUrl from '../docsUrl';\n\n// todo: cache cycles / deep relationships for faster repeat evaluation\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: { url: docsUrl('no-cycle') },\n    schema: [makeOptionsSchema({\n      maxDepth: {\n        oneOf: [\n          {\n            description: 'maximum dependency depth to traverse',\n            type: 'integer',\n            minimum: 1,\n          },\n          {\n            enum: ['∞'],\n            type: 'string',\n          },\n        ],\n      },\n      ignoreExternal: {\n        description: 'ignore external modules',\n        type: 'boolean',\n        default: false,\n      },\n    })],\n  },\n\n  create(context) {\n    const myPath = context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename();\n    if (myPath === '<text>') return {}; // can't cycle-check a non-file\n\n    const options = context.options[0] || {};\n    const maxDepth = typeof options.maxDepth === 'number' ? options.maxDepth : Infinity;\n    const ignoreModule = (name) => options.ignoreExternal && isExternalModule(\n      name,\n      resolve(name, context),\n      context,\n    );\n\n    function checkSourceValue(sourceNode, importer) {\n      if (ignoreModule(sourceNode.value)) {\n        return; // ignore external modules\n      }\n\n      if (\n        importer.type === 'ImportDeclaration' && (\n          // import type { Foo } (TS and Flow)\n          importer.importKind === 'type' ||\n          // import { type Foo } (Flow)\n          importer.specifiers.every(({ importKind }) => importKind === 'type')\n        )\n      ) {\n        return; // ignore type imports\n      }\n\n      const imported = Exports.get(sourceNode.value, context);\n\n      if (imported == null) {\n        return;  // no-unresolved territory\n      }\n\n      if (imported.path === myPath) {\n        return;  // no-self-import territory\n      }\n\n      const untraversed = [{ mget: () => imported, route:[] }];\n      const traversed = new Set();\n      function detectCycle({ mget, route }) {\n        const m = mget();\n        if (m == null) return;\n        if (traversed.has(m.path)) return;\n        traversed.add(m.path);\n\n        for (const [path, { getter, declarations }] of m.imports) {\n          if (traversed.has(path)) continue;\n          const toTraverse = [...declarations].filter(({ source, isOnlyImportingTypes }) =>\n            !ignoreModule(source.value) &&\n            // Ignore only type imports\n            !isOnlyImportingTypes,\n          );\n          /*\n          Only report as a cycle if there are any import declarations that are considered by\n          the rule. For example:\n\n          a.ts:\n          import { foo } from './b' // should not be reported as a cycle\n\n          b.ts:\n          import type { Bar } from './a'\n          */\n          if (path === myPath && toTraverse.length > 0) return true;\n          if (route.length + 1 < maxDepth) {\n            for (const { source } of toTraverse) {\n              untraversed.push({ mget: getter, route: route.concat(source) });\n            }\n          }\n        }\n      }\n\n      while (untraversed.length > 0) {\n        const next = untraversed.shift(); // bfs!\n        if (detectCycle(next)) {\n          const message = (next.route.length > 0\n            ? `Dependency cycle via ${routeString(next.route)}`\n            : 'Dependency cycle detected.');\n          context.report(importer, message);\n          return;\n        }\n      }\n    }\n\n    return moduleVisitor(checkSourceValue, context.options[0]);\n  },\n};\n\nfunction routeString(route) {\n  return route.map(s => `${s.value}:${s.loc.start.line}`).join('=>');\n}\n"]},"metadata":{},"sourceType":"script"}