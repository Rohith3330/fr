{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;\n\nconst core_1 = require(\"./core\");\n\nconst jtd_1 = require(\"./vocabularies/jtd\");\n\nconst jtd_schema_1 = require(\"./refs/jtd-schema\");\n\nconst serialize_1 = require(\"./compile/jtd/serialize\");\n\nconst parse_1 = require(\"./compile/jtd/parse\");\n\nconst META_SCHEMA_ID = \"JTD-meta-schema\";\n\nclass Ajv extends core_1.default {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({ ...opts,\n      jtd: true\n    });\n  }\n\n  _addVocabularies() {\n    super._addVocabularies();\n\n    this.addVocabulary(jtd_1.default);\n  }\n\n  _addDefaultMetaSchema() {\n    super._addDefaultMetaSchema();\n\n    if (!this.opts.meta) return;\n    this.addMetaSchema(jtd_schema_1.default, META_SCHEMA_ID, false);\n  }\n\n  defaultMeta() {\n    return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined);\n  }\n\n  compileSerializer(schema) {\n    const sch = this._addSchema(schema);\n\n    return sch.serialize || this._compileSerializer(sch);\n  }\n\n  compileParser(schema) {\n    const sch = this._addSchema(schema);\n\n    return sch.parse || this._compileParser(sch);\n  }\n\n  _compileSerializer(sch) {\n    serialize_1.default.call(this, sch, sch.schema.definitions || {});\n    /* istanbul ignore if */\n\n    if (!sch.serialize) throw new Error(\"ajv implementation error\");\n    return sch.serialize;\n  }\n\n  _compileParser(sch) {\n    parse_1.default.call(this, sch, sch.schema.definitions || {});\n    /* istanbul ignore if */\n\n    if (!sch.parse) throw new Error(\"ajv implementation error\");\n    return sch.parse;\n  }\n\n}\n\nmodule.exports = exports = Ajv;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Ajv;\n\nvar validate_1 = require(\"./compile/validate\");\n\nObject.defineProperty(exports, \"KeywordCxt\", {\n  enumerable: true,\n  get: function () {\n    return validate_1.KeywordCxt;\n  }\n});\n\nvar codegen_1 = require(\"./compile/codegen\");\n\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.str;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.stringify;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.nil;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.Name;\n  }\n});\nObject.defineProperty(exports, \"CodeGen\", {\n  enumerable: true,\n  get: function () {\n    return codegen_1.CodeGen;\n  }\n});","map":{"version":3,"mappings":";;;;;;;AAEA;;AACA;;AACA;;AACA;;AACA;;AAGA,MAAMA,cAAc,GAAG,iBAAvB;;AA4BA,MAAMC,GAAN,SAAkBC,cAAlB,CAAyB;EACvBC,cAAiC;IAAA,IAArBC,IAAqB,uEAAF,EAAE;IAC/B,MAAM,EACJ,GAAGA,IADC;MAEJC,GAAG,EAAE;IAFD,CAAN;EAID;;EAEDC,gBAAgB;IACd,MAAMA,gBAAN;;IACA,KAAKC,aAAL,CAAmBC,aAAnB;EACD;;EAEDC,qBAAqB;IACnB,MAAMA,qBAAN;;IACA,IAAI,CAAC,KAAKL,IAAL,CAAUM,IAAf,EAAqB;IACrB,KAAKC,aAAL,CAAmBC,oBAAnB,EAAkCZ,cAAlC,EAAkD,KAAlD;EACD;;EAEDa,WAAW;IACT,OAAQ,KAAKT,IAAL,CAAUS,WAAV,GACN,MAAMA,WAAN,OAAwB,KAAKC,SAAL,CAAed,cAAf,IAAiCA,cAAjC,GAAkDe,SAA1E,CADF;EAED;;EAMDC,iBAAiB,CAAcC,MAAd,EAAkC;IACjD,MAAMC,GAAG,GAAG,KAAKC,UAAL,CAAgBF,MAAhB,CAAZ;;IACA,OAAOC,GAAG,CAACE,SAAJ,IAAiB,KAAKC,kBAAL,CAAwBH,GAAxB,CAAxB;EACD;;EAMDI,aAAa,CAAcL,MAAd,EAAkC;IAC7C,MAAMC,GAAG,GAAG,KAAKC,UAAL,CAAgBF,MAAhB,CAAZ;;IACA,OAAQC,GAAG,CAACK,KAAJ,IAAa,KAAKC,cAAL,CAAoBN,GAApB,CAArB;EACD;;EAEOG,kBAAkB,CAAIH,GAAJ,EAAkB;IAC1CO,oBAAkBC,IAAlB,CAAuB,IAAvB,EAA6BR,GAA7B,EAAmCA,GAAG,CAACD,MAAJ,CAA+BU,WAA/B,IAA8C,EAAjF;IACA;;IACA,IAAI,CAACT,GAAG,CAACE,SAAT,EAAoB,MAAM,IAAIQ,KAAJ,CAAU,0BAAV,CAAN;IACpB,OAAOV,GAAG,CAACE,SAAX;EACD;;EAEOI,cAAc,CAACN,GAAD,EAAe;IACnCW,gBAAcH,IAAd,CAAmB,IAAnB,EAAyBR,GAAzB,EAA+BA,GAAG,CAACD,MAAJ,CAA+BU,WAA/B,IAA8C,EAA7E;IACA;;IACA,IAAI,CAACT,GAAG,CAACK,KAAT,EAAgB,MAAM,IAAIK,KAAJ,CAAU,0BAAV,CAAN;IAChB,OAAOV,GAAG,CAACK,KAAX;EACD;;AAtDsB;;AAyDzBO,MAAM,CAACC,OAAP,GAAiBA,OAAO,GAAG9B,GAA3B;AACA+B,MAAM,CAACC,cAAP,CAAsBF,OAAtB,EAA+B,YAA/B,EAA6C;EAACG,KAAK,EAAE;AAAR,CAA7C;AAEAH,kBAAe9B,GAAf;;AA0BA;;AAAQ+B;EAAAG;EAAAC;IAAA;EAAU;AAAV;;AAER;;AAAQJ;EAAAG;EAAAC;IAAA;EAAC;AAAD;AAAGJ;EAAAG;EAAAC;IAAA;EAAG;AAAH;AAAKJ;EAAAG;EAAAC;IAAA;EAAS;AAAT;AAAWJ;EAAAG;EAAAC;IAAA;EAAG;AAAH;AAAKJ;EAAAG;EAAAC;IAAA;EAAI;AAAJ;AAAYJ;EAAAG;EAAAC;IAAA;EAAO;AAAP","names":["META_SCHEMA_ID","Ajv","core_1","constructor","opts","jtd","_addVocabularies","addVocabulary","jtd_1","_addDefaultMetaSchema","meta","addMetaSchema","jtd_schema_1","defaultMeta","getSchema","undefined","compileSerializer","schema","sch","_addSchema","serialize","_compileSerializer","compileParser","parse","_compileParser","serialize_1","call","definitions","Error","parse_1","module","exports","Object","defineProperty","value","enumerable","get"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\css-minimizer-webpack-plugin\\node_modules\\ajv\\lib\\jtd.ts"],"sourcesContent":["import type {AnySchemaObject, SchemaObject, JTDParser} from \"./types\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport AjvCore, {CurrentOptions} from \"./core\"\nimport jtdVocabulary from \"./vocabularies/jtd\"\nimport jtdMetaSchema from \"./refs/jtd-schema\"\nimport compileSerializer from \"./compile/jtd/serialize\"\nimport compileParser from \"./compile/jtd/parse\"\nimport {SchemaEnv} from \"./compile\"\n\nconst META_SCHEMA_ID = \"JTD-meta-schema\"\n\ntype JTDOptions = CurrentOptions & {\n  // strict mode options not supported with JTD:\n  strict?: never\n  allowMatchingProperties?: never\n  allowUnionTypes?: never\n  validateFormats?: never\n  // validation and reporting options not supported with JTD:\n  $data?: never\n  verbose?: boolean\n  $comment?: never\n  formats?: never\n  loadSchema?: never\n  // options to modify validated data:\n  useDefaults?: never\n  coerceTypes?: never\n  // advanced options:\n  next?: never\n  unevaluated?: never\n  dynamicRef?: never\n  meta?: boolean\n  defaultMeta?: never\n  inlineRefs?: boolean\n  loopRequired?: never\n  multipleOfPrecision?: never\n}\n\nclass Ajv extends AjvCore {\n  constructor(opts: JTDOptions = {}) {\n    super({\n      ...opts,\n      jtd: true,\n    })\n  }\n\n  _addVocabularies(): void {\n    super._addVocabularies()\n    this.addVocabulary(jtdVocabulary)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    this.addMetaSchema(jtdMetaSchema, META_SCHEMA_ID, false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n\n  compileSerializer<T = unknown>(schema: SchemaObject): (data: T) => string\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileSerializer<T = unknown>(schema: JTDSchemaType<T>): (data: T) => string\n  compileSerializer<T = unknown>(schema: SchemaObject): (data: T) => string {\n    const sch = this._addSchema(schema)\n    return sch.serialize || this._compileSerializer(sch)\n  }\n\n  compileParser<T = unknown>(schema: SchemaObject): JTDParser<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileParser<T = unknown>(schema: JTDSchemaType<T>): JTDParser<T>\n  compileParser<T = unknown>(schema: SchemaObject): JTDParser<T> {\n    const sch = this._addSchema(schema)\n    return (sch.parse || this._compileParser(sch)) as JTDParser<T>\n  }\n\n  private _compileSerializer<T>(sch: SchemaEnv): (data: T) => string {\n    compileSerializer.call(this, sch, (sch.schema as AnySchemaObject).definitions || {})\n    /* istanbul ignore if */\n    if (!sch.serialize) throw new Error(\"ajv implementation error\")\n    return sch.serialize\n  }\n\n  private _compileParser(sch: SchemaEnv): JTDParser {\n    compileParser.call(this, sch, (sch.schema as AnySchemaObject).definitions || {})\n    /* istanbul ignore if */\n    if (!sch.parse) throw new Error(\"ajv implementation error\")\n    return sch.parse\n  }\n}\n\nmodule.exports = exports = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n  JTDParser,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {JTDErrorObject} from \"./vocabularies/jtd\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType}\nexport {JTDOptions}\n"]},"metadata":{},"sourceType":"script"}