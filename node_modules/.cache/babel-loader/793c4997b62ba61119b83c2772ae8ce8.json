{"ast":null,"code":"/**\n * @fileoverview Rule to flag declared but unused private class members\n * @author Tim van der Lippe\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow unused private class members\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unused-private-class-members\"\n    },\n    schema: [],\n    messages: {\n      unusedPrivateClassMember: \"'{{classMemberName}}' is defined but never used.\"\n    }\n  },\n\n  create(context) {\n    const trackedClasses = [];\n    /**\n     * Check whether the current node is in a write only assignment.\n     * @param {ASTNode} privateIdentifierNode Node referring to a private identifier\n     * @returns {boolean} Whether the node is in a write only assignment\n     * @private\n     */\n\n    function isWriteOnlyAssignment(privateIdentifierNode) {\n      const parentStatement = privateIdentifierNode.parent.parent;\n      const isAssignmentExpression = parentStatement.type === \"AssignmentExpression\";\n\n      if (!isAssignmentExpression && parentStatement.type !== \"ForInStatement\" && parentStatement.type !== \"ForOfStatement\" && parentStatement.type !== \"AssignmentPattern\") {\n        return false;\n      } // It is a write-only usage, since we still allow usages on the right for reads\n\n\n      if (parentStatement.left !== privateIdentifierNode.parent) {\n        return false;\n      } // For any other operator (such as '+=') we still consider it a read operation\n\n\n      if (isAssignmentExpression && parentStatement.operator !== \"=\") {\n        /*\n         * However, if the read operation is \"discarded\" in an empty statement, then\n         * we consider it write only.\n         */\n        return parentStatement.parent.type === \"ExpressionStatement\";\n      }\n\n      return true;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      // Collect all declared members up front and assume they are all unused\n      ClassBody(classBodyNode) {\n        const privateMembers = new Map();\n        trackedClasses.unshift(privateMembers);\n\n        for (const bodyMember of classBodyNode.body) {\n          if (bodyMember.type === \"PropertyDefinition\" || bodyMember.type === \"MethodDefinition\") {\n            if (bodyMember.key.type === \"PrivateIdentifier\") {\n              privateMembers.set(bodyMember.key.name, {\n                declaredNode: bodyMember,\n                isAccessor: bodyMember.type === \"MethodDefinition\" && (bodyMember.kind === \"set\" || bodyMember.kind === \"get\")\n              });\n            }\n          }\n        }\n      },\n\n      /*\n       * Process all usages of the private identifier and remove a member from\n       * `declaredAndUnusedPrivateMembers` if we deem it used.\n       */\n      PrivateIdentifier(privateIdentifierNode) {\n        const classBody = trackedClasses.find(classProperties => classProperties.has(privateIdentifierNode.name)); // Can't happen, as it is a parser to have a missing class body, but let's code defensively here.\n\n        if (!classBody) {\n          return;\n        } // In case any other usage was already detected, we can short circuit the logic here.\n\n\n        const memberDefinition = classBody.get(privateIdentifierNode.name);\n\n        if (memberDefinition.isUsed) {\n          return;\n        } // The definition of the class member itself\n\n\n        if (privateIdentifierNode.parent.type === \"PropertyDefinition\" || privateIdentifierNode.parent.type === \"MethodDefinition\") {\n          return;\n        }\n        /*\n         * Any usage of an accessor is considered a read, as the getter/setter can have\n         * side-effects in its definition.\n         */\n\n\n        if (memberDefinition.isAccessor) {\n          memberDefinition.isUsed = true;\n          return;\n        } // Any assignments to this member, except for assignments that also read\n\n\n        if (isWriteOnlyAssignment(privateIdentifierNode)) {\n          return;\n        }\n\n        const wrappingExpressionType = privateIdentifierNode.parent.parent.type;\n        const parentOfWrappingExpressionType = privateIdentifierNode.parent.parent.parent.type; // A statement which only increments (`this.#x++;`)\n\n        if (wrappingExpressionType === \"UpdateExpression\" && parentOfWrappingExpressionType === \"ExpressionStatement\") {\n          return;\n        }\n        /*\n         * ({ x: this.#usedInDestructuring } = bar);\n         *\n         * But should treat the following as a read:\n         * ({ [this.#x]: a } = foo);\n         */\n\n\n        if (wrappingExpressionType === \"Property\" && parentOfWrappingExpressionType === \"ObjectPattern\" && privateIdentifierNode.parent.parent.value === privateIdentifierNode.parent) {\n          return;\n        } // [...this.#unusedInRestPattern] = bar;\n\n\n        if (wrappingExpressionType === \"RestElement\") {\n          return;\n        } // [this.#unusedInAssignmentPattern] = bar;\n\n\n        if (wrappingExpressionType === \"ArrayPattern\") {\n          return;\n        }\n        /*\n         * We can't delete the memberDefinition, as we need to keep track of which member we are marking as used.\n         * In the case of nested classes, we only mark the first member we encounter as used. If you were to delete\n         * the member, then any subsequent usage could incorrectly mark the member of an encapsulating parent class\n         * as used, which is incorrect.\n         */\n\n\n        memberDefinition.isUsed = true;\n      },\n\n      /*\n       * Post-process the class members and report any remaining members.\n       * Since private members can only be accessed in the current class context,\n       * we can safely assume that all usages are within the current class body.\n       */\n      \"ClassBody:exit\"() {\n        const unusedPrivateMembers = trackedClasses.shift();\n\n        for (const [classMemberName, {\n          declaredNode,\n          isUsed\n        }] of unusedPrivateMembers.entries()) {\n          if (isUsed) {\n            continue;\n          }\n\n          context.report({\n            node: declaredNode,\n            loc: declaredNode.key.loc,\n            messageId: \"unusedPrivateClassMember\",\n            data: {\n              classMemberName: `#${classMemberName}`\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","recommended","url","schema","messages","unusedPrivateClassMember","create","context","trackedClasses","isWriteOnlyAssignment","privateIdentifierNode","parentStatement","parent","isAssignmentExpression","left","operator","ClassBody","classBodyNode","privateMembers","Map","unshift","bodyMember","body","key","set","name","declaredNode","isAccessor","kind","PrivateIdentifier","classBody","find","classProperties","has","memberDefinition","get","isUsed","wrappingExpressionType","parentOfWrappingExpressionType","value","unusedPrivateMembers","shift","classMemberName","entries","report","node","loc","messageId","data"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/no-unused-private-class-members.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag declared but unused private class members\n * @author Tim van der Lippe\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow unused private class members\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-unused-private-class-members\"\n        },\n\n        schema: [],\n\n        messages: {\n            unusedPrivateClassMember: \"'{{classMemberName}}' is defined but never used.\"\n        }\n    },\n\n    create(context) {\n        const trackedClasses = [];\n\n        /**\n         * Check whether the current node is in a write only assignment.\n         * @param {ASTNode} privateIdentifierNode Node referring to a private identifier\n         * @returns {boolean} Whether the node is in a write only assignment\n         * @private\n         */\n        function isWriteOnlyAssignment(privateIdentifierNode) {\n            const parentStatement = privateIdentifierNode.parent.parent;\n            const isAssignmentExpression = parentStatement.type === \"AssignmentExpression\";\n\n            if (!isAssignmentExpression &&\n                parentStatement.type !== \"ForInStatement\" &&\n                parentStatement.type !== \"ForOfStatement\" &&\n                parentStatement.type !== \"AssignmentPattern\") {\n                return false;\n            }\n\n            // It is a write-only usage, since we still allow usages on the right for reads\n            if (parentStatement.left !== privateIdentifierNode.parent) {\n                return false;\n            }\n\n            // For any other operator (such as '+=') we still consider it a read operation\n            if (isAssignmentExpression && parentStatement.operator !== \"=\") {\n\n                /*\n                 * However, if the read operation is \"discarded\" in an empty statement, then\n                 * we consider it write only.\n                 */\n                return parentStatement.parent.type === \"ExpressionStatement\";\n            }\n\n            return true;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            // Collect all declared members up front and assume they are all unused\n            ClassBody(classBodyNode) {\n                const privateMembers = new Map();\n\n                trackedClasses.unshift(privateMembers);\n                for (const bodyMember of classBodyNode.body) {\n                    if (bodyMember.type === \"PropertyDefinition\" || bodyMember.type === \"MethodDefinition\") {\n                        if (bodyMember.key.type === \"PrivateIdentifier\") {\n                            privateMembers.set(bodyMember.key.name, {\n                                declaredNode: bodyMember,\n                                isAccessor: bodyMember.type === \"MethodDefinition\" &&\n                                    (bodyMember.kind === \"set\" || bodyMember.kind === \"get\")\n                            });\n                        }\n                    }\n                }\n            },\n\n            /*\n             * Process all usages of the private identifier and remove a member from\n             * `declaredAndUnusedPrivateMembers` if we deem it used.\n             */\n            PrivateIdentifier(privateIdentifierNode) {\n                const classBody = trackedClasses.find(classProperties => classProperties.has(privateIdentifierNode.name));\n\n                // Can't happen, as it is a parser to have a missing class body, but let's code defensively here.\n                if (!classBody) {\n                    return;\n                }\n\n                // In case any other usage was already detected, we can short circuit the logic here.\n                const memberDefinition = classBody.get(privateIdentifierNode.name);\n\n                if (memberDefinition.isUsed) {\n                    return;\n                }\n\n                // The definition of the class member itself\n                if (privateIdentifierNode.parent.type === \"PropertyDefinition\" ||\n                    privateIdentifierNode.parent.type === \"MethodDefinition\") {\n                    return;\n                }\n\n                /*\n                 * Any usage of an accessor is considered a read, as the getter/setter can have\n                 * side-effects in its definition.\n                 */\n                if (memberDefinition.isAccessor) {\n                    memberDefinition.isUsed = true;\n                    return;\n                }\n\n                // Any assignments to this member, except for assignments that also read\n                if (isWriteOnlyAssignment(privateIdentifierNode)) {\n                    return;\n                }\n\n                const wrappingExpressionType = privateIdentifierNode.parent.parent.type;\n                const parentOfWrappingExpressionType = privateIdentifierNode.parent.parent.parent.type;\n\n                // A statement which only increments (`this.#x++;`)\n                if (wrappingExpressionType === \"UpdateExpression\" &&\n                    parentOfWrappingExpressionType === \"ExpressionStatement\") {\n                    return;\n                }\n\n                /*\n                 * ({ x: this.#usedInDestructuring } = bar);\n                 *\n                 * But should treat the following as a read:\n                 * ({ [this.#x]: a } = foo);\n                 */\n                if (wrappingExpressionType === \"Property\" &&\n                    parentOfWrappingExpressionType === \"ObjectPattern\" &&\n                    privateIdentifierNode.parent.parent.value === privateIdentifierNode.parent) {\n                    return;\n                }\n\n                // [...this.#unusedInRestPattern] = bar;\n                if (wrappingExpressionType === \"RestElement\") {\n                    return;\n                }\n\n                // [this.#unusedInAssignmentPattern] = bar;\n                if (wrappingExpressionType === \"ArrayPattern\") {\n                    return;\n                }\n\n                /*\n                 * We can't delete the memberDefinition, as we need to keep track of which member we are marking as used.\n                 * In the case of nested classes, we only mark the first member we encounter as used. If you were to delete\n                 * the member, then any subsequent usage could incorrectly mark the member of an encapsulating parent class\n                 * as used, which is incorrect.\n                 */\n                memberDefinition.isUsed = true;\n            },\n\n            /*\n             * Post-process the class members and report any remaining members.\n             * Since private members can only be accessed in the current class context,\n             * we can safely assume that all usages are within the current class body.\n             */\n            \"ClassBody:exit\"() {\n                const unusedPrivateMembers = trackedClasses.shift();\n\n                for (const [classMemberName, { declaredNode, isUsed }] of unusedPrivateMembers.entries()) {\n                    if (isUsed) {\n                        continue;\n                    }\n                    context.report({\n                        node: declaredNode,\n                        loc: declaredNode.key.loc,\n                        messageId: \"unusedPrivateClassMember\",\n                        data: {\n                            classMemberName: `#${classMemberName}`\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}