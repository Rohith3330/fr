{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar leap = _interopRequireWildcard(require(\"./leap\"));\n\nvar meta = _interopRequireWildcard(require(\"./meta\"));\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction Emitter(contextId) {\n  _assert[\"default\"].ok(this instanceof Emitter);\n\n  util.getTypes().assertIdentifier(contextId); // Used to generate unique temporary names.\n\n  this.nextTempId = 0; // In order to make sure the context object does not collide with\n  // anything in the local scope, we might have to rename it, so we\n  // refer to it symbolically instead of just assuming that it will be\n  // called \"context\".\n\n  this.contextId = contextId; // An append-only list of Statements that grows each time this.emit is\n  // called.\n\n  this.listing = []; // A sparse array whose keys correspond to locations in this.listing\n  // that have been marked as branch/jump targets.\n\n  this.marked = [true];\n  this.insertedLocs = new Set(); // The last location will be marked when this.getDispatchLoop is\n  // called.\n\n  this.finalLoc = this.loc(); // A list of all leap.TryEntry statements emitted.\n\n  this.tryEntries = []; // Each time we evaluate the body of a loop, we tell this.leapManager\n  // to enter a nested loop context that determines the meaning of break\n  // and continue statements therein.\n\n  this.leapManager = new leap.LeapManager(this);\n}\n\nvar Ep = Emitter.prototype;\nexports.Emitter = Emitter; // Offsets into this.listing that could be used as targets for branches or\n// jumps are represented as numeric Literal nodes. This representation has\n// the amazingly convenient benefit of allowing the exact value of the\n// location to be determined at any time, even after generating code that\n// refers to the location.\n\nEp.loc = function () {\n  var l = util.getTypes().numericLiteral(-1);\n  this.insertedLocs.add(l);\n  return l;\n};\n\nEp.getInsertedLocs = function () {\n  return this.insertedLocs;\n};\n\nEp.getContextId = function () {\n  return util.getTypes().clone(this.contextId);\n}; // Sets the exact value of the given location to the offset of the next\n// Statement emitted.\n\n\nEp.mark = function (loc) {\n  util.getTypes().assertLiteral(loc);\n  var index = this.listing.length;\n\n  if (loc.value === -1) {\n    loc.value = index;\n  } else {\n    // Locations can be marked redundantly, but their values cannot change\n    // once set the first time.\n    _assert[\"default\"].strictEqual(loc.value, index);\n  }\n\n  this.marked[index] = true;\n  return loc;\n};\n\nEp.emit = function (node) {\n  var t = util.getTypes();\n\n  if (t.isExpression(node)) {\n    node = t.expressionStatement(node);\n  }\n\n  t.assertStatement(node);\n  this.listing.push(node);\n}; // Shorthand for emitting assignment statements. This will come in handy\n// for assignments to temporary variables.\n\n\nEp.emitAssign = function (lhs, rhs) {\n  this.emit(this.assign(lhs, rhs));\n  return lhs;\n}; // Shorthand for an assignment statement.\n\n\nEp.assign = function (lhs, rhs) {\n  var t = util.getTypes();\n  return t.expressionStatement(t.assignmentExpression(\"=\", t.cloneDeep(lhs), rhs));\n}; // Convenience function for generating expressions like context.next,\n// context.sent, and context.rval.\n\n\nEp.contextProperty = function (name, computed) {\n  var t = util.getTypes();\n  return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);\n}; // Shorthand for setting context.rval and jumping to `context.stop()`.\n\n\nEp.stop = function (rval) {\n  if (rval) {\n    this.setReturnValue(rval);\n  }\n\n  this.jump(this.finalLoc);\n};\n\nEp.setReturnValue = function (valuePath) {\n  util.getTypes().assertExpression(valuePath.value);\n  this.emitAssign(this.contextProperty(\"rval\"), this.explodeExpression(valuePath));\n};\n\nEp.clearPendingException = function (tryLoc, assignee) {\n  var t = util.getTypes();\n  t.assertLiteral(tryLoc);\n  var catchCall = t.callExpression(this.contextProperty(\"catch\", true), [t.clone(tryLoc)]);\n\n  if (assignee) {\n    this.emitAssign(assignee, catchCall);\n  } else {\n    this.emit(catchCall);\n  }\n}; // Emits code for an unconditional jump to the given location, even if the\n// exact value of the location is not yet known.\n\n\nEp.jump = function (toLoc) {\n  this.emitAssign(this.contextProperty(\"next\"), toLoc);\n  this.emit(util.getTypes().breakStatement());\n}; // Conditional jump.\n\n\nEp.jumpIf = function (test, toLoc) {\n  var t = util.getTypes();\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n  this.emit(t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n}; // Conditional jump, with the condition negated.\n\n\nEp.jumpIfNot = function (test, toLoc) {\n  var t = util.getTypes();\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n  var negatedTest;\n\n  if (t.isUnaryExpression(test) && test.operator === \"!\") {\n    // Avoid double negation.\n    negatedTest = test.argument;\n  } else {\n    negatedTest = t.unaryExpression(\"!\", test);\n  }\n\n  this.emit(t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n}; // Returns a unique MemberExpression that can be used to store and\n// retrieve temporary values. Since the object of the member expression is\n// the context object, which is presumed to coexist peacefully with all\n// other local variables, and since we just increment `nextTempId`\n// monotonically, uniqueness is assured.\n\n\nEp.makeTempVar = function () {\n  return this.contextProperty(\"t\" + this.nextTempId++);\n};\n\nEp.getContextFunction = function (id) {\n  var t = util.getTypes();\n  return t.functionExpression(id || null\n  /*Anonymous*/\n  , [this.getContextId()], t.blockStatement([this.getDispatchLoop()]), false, // Not a generator anymore!\n  false // Nor an expression.\n  );\n}; // Turns this.listing into a loop of the form\n//\n//   while (1) switch (context.next) {\n//   case 0:\n//   ...\n//   case n:\n//     return context.stop();\n//   }\n//\n// Each marked location in this.listing will correspond to one generated\n// case statement.\n\n\nEp.getDispatchLoop = function () {\n  var self = this;\n  var t = util.getTypes();\n  var cases = [];\n  var current; // If we encounter a break, continue, or return statement in a switch\n  // case, we can skip the rest of the statements until the next case.\n\n  var alreadyEnded = false;\n  self.listing.forEach(function (stmt, i) {\n    if (self.marked.hasOwnProperty(i)) {\n      cases.push(t.switchCase(t.numericLiteral(i), current = []));\n      alreadyEnded = false;\n    }\n\n    if (!alreadyEnded) {\n      current.push(stmt);\n      if (t.isCompletionStatement(stmt)) alreadyEnded = true;\n    }\n  }); // Now that we know how many statements there will be in this.listing,\n  // we can finally resolve this.finalLoc.value.\n\n  this.finalLoc.value = this.listing.length;\n  cases.push(t.switchCase(this.finalLoc, [// Intentionally fall through to the \"end\" case...\n  ]), // So that the runtime can jump to the final location without having\n  // to know its offset, we provide the \"end\" case as a synonym.\n  t.switchCase(t.stringLiteral(\"end\"), [// This will check/clear both context.thrown and context.rval.\n  t.returnStatement(t.callExpression(this.contextProperty(\"stop\"), []))]));\n  return t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression(\"=\", this.contextProperty(\"prev\"), this.contextProperty(\"next\")), cases));\n};\n\nEp.getTryLocsList = function () {\n  if (this.tryEntries.length === 0) {\n    // To avoid adding a needless [] to the majority of runtime.wrap\n    // argument lists, force the caller to handle this case specially.\n    return null;\n  }\n\n  var t = util.getTypes();\n  var lastLocValue = 0;\n  return t.arrayExpression(this.tryEntries.map(function (tryEntry) {\n    var thisLocValue = tryEntry.firstLoc.value;\n\n    _assert[\"default\"].ok(thisLocValue >= lastLocValue, \"try entries out of order\");\n\n    lastLocValue = thisLocValue;\n    var ce = tryEntry.catchEntry;\n    var fe = tryEntry.finallyEntry;\n    var locs = [tryEntry.firstLoc, // The null here makes a hole in the array.\n    ce ? ce.firstLoc : null];\n\n    if (fe) {\n      locs[2] = fe.firstLoc;\n      locs[3] = fe.afterLoc;\n    }\n\n    return t.arrayExpression(locs.map(function (loc) {\n      return loc && t.clone(loc);\n    }));\n  }));\n}; // All side effects must be realized in order.\n// If any subexpression harbors a leap, all subexpressions must be\n// neutered of side effects.\n// No destructive modification of AST nodes.\n\n\nEp.explode = function (path, ignoreResult) {\n  var t = util.getTypes();\n  var node = path.node;\n  var self = this;\n  t.assertNode(node);\n  if (t.isDeclaration(node)) throw getDeclError(node);\n  if (t.isStatement(node)) return self.explodeStatement(path);\n  if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);\n\n  switch (node.type) {\n    case \"Program\":\n      return path.get(\"body\").map(self.explodeStatement, self);\n\n    case \"VariableDeclarator\":\n      throw getDeclError(node);\n    // These node types should be handled by their parent nodes\n    // (ObjectExpression, SwitchStatement, and TryStatement, respectively).\n\n    case \"Property\":\n    case \"SwitchCase\":\n    case \"CatchClause\":\n      throw new Error(node.type + \" nodes should be handled by their parents\");\n\n    default:\n      throw new Error(\"unknown Node of type \" + JSON.stringify(node.type));\n  }\n};\n\nfunction getDeclError(node) {\n  return new Error(\"all declarations should have been transformed into \" + \"assignments before the Exploder began its work: \" + JSON.stringify(node));\n}\n\nEp.explodeStatement = function (path, labelId) {\n  var t = util.getTypes();\n  var stmt = path.node;\n  var self = this;\n  var before, after, head;\n  t.assertStatement(stmt);\n\n  if (labelId) {\n    t.assertIdentifier(labelId);\n  } else {\n    labelId = null;\n  } // Explode BlockStatement nodes even if they do not contain a yield,\n  // because we don't want or need the curly braces.\n\n\n  if (t.isBlockStatement(stmt)) {\n    path.get(\"body\").forEach(function (path) {\n      self.explodeStatement(path);\n    });\n    return;\n  }\n\n  if (!meta.containsLeap(stmt)) {\n    // Technically we should be able to avoid emitting the statement\n    // altogether if !meta.hasSideEffects(stmt), but that leads to\n    // confusing generated code (for instance, `while (true) {}` just\n    // disappears) and is probably a more appropriate job for a dedicated\n    // dead code elimination pass.\n    self.emit(stmt);\n    return;\n  }\n\n  switch (stmt.type) {\n    case \"ExpressionStatement\":\n      self.explodeExpression(path.get(\"expression\"), true);\n      break;\n\n    case \"LabeledStatement\":\n      after = this.loc(); // Did you know you can break from any labeled block statement or\n      // control structure? Well, you can! Note: when a labeled loop is\n      // encountered, the leap.LabeledEntry created here will immediately\n      // enclose a leap.LoopEntry on the leap manager's stack, and both\n      // entries will have the same label. Though this works just fine, it\n      // may seem a bit redundant. In theory, we could check here to\n      // determine if stmt knows how to handle its own label; for example,\n      // stmt happens to be a WhileStatement and so we know it's going to\n      // establish its own LoopEntry when we explode it (below). Then this\n      // LabeledEntry would be unnecessary. Alternatively, we might be\n      // tempted not to pass stmt.label down into self.explodeStatement,\n      // because we've handled the label here, but that's a mistake because\n      // labeled loops may contain labeled continue statements, which is not\n      // something we can handle in this generic case. All in all, I think a\n      // little redundancy greatly simplifies the logic of this case, since\n      // it's clear that we handle all possible LabeledStatements correctly\n      // here, regardless of whether they interact with the leap manager\n      // themselves. Also remember that labels and break/continue-to-label\n      // statements are rare, and all of this logic happens at transform\n      // time, so it has no additional runtime cost.\n\n      self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), function () {\n        self.explodeStatement(path.get(\"body\"), stmt.label);\n      });\n      self.mark(after);\n      break;\n\n    case \"WhileStatement\":\n      before = this.loc();\n      after = this.loc();\n      self.mark(before);\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.jump(before);\n      self.mark(after);\n      break;\n\n    case \"DoWhileStatement\":\n      var first = this.loc();\n      var test = this.loc();\n      after = this.loc();\n      self.mark(first);\n      self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {\n        self.explode(path.get(\"body\"));\n      });\n      self.mark(test);\n      self.jumpIf(self.explodeExpression(path.get(\"test\")), first);\n      self.mark(after);\n      break;\n\n    case \"ForStatement\":\n      head = this.loc();\n      var update = this.loc();\n      after = this.loc();\n\n      if (stmt.init) {\n        // We pass true here to indicate that if stmt.init is an expression\n        // then we do not care about its result.\n        self.explode(path.get(\"init\"), true);\n      }\n\n      self.mark(head);\n\n      if (stmt.test) {\n        self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      } else {// No test means continue unconditionally.\n      }\n\n      self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.mark(update);\n\n      if (stmt.update) {\n        // We pass true here to indicate that if stmt.update is an\n        // expression then we do not care about its result.\n        self.explode(path.get(\"update\"), true);\n      }\n\n      self.jump(head);\n      self.mark(after);\n      break;\n\n    case \"TypeCastExpression\":\n      return self.explodeExpression(path.get(\"expression\"));\n\n    case \"ForInStatement\":\n      head = this.loc();\n      after = this.loc();\n      var keyIterNextFn = self.makeTempVar();\n      self.emitAssign(keyIterNextFn, t.callExpression(util.runtimeProperty(\"keys\"), [self.explodeExpression(path.get(\"right\"))]));\n      self.mark(head);\n      var keyInfoTmpVar = self.makeTempVar();\n      self.jumpIf(t.memberExpression(t.assignmentExpression(\"=\", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier(\"done\"), false), after);\n      self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier(\"value\"), false));\n      self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.jump(head);\n      self.mark(after);\n      break;\n\n    case \"BreakStatement\":\n      self.emitAbruptCompletion({\n        type: \"break\",\n        target: self.leapManager.getBreakLoc(stmt.label)\n      });\n      break;\n\n    case \"ContinueStatement\":\n      self.emitAbruptCompletion({\n        type: \"continue\",\n        target: self.leapManager.getContinueLoc(stmt.label)\n      });\n      break;\n\n    case \"SwitchStatement\":\n      // Always save the discriminant into a temporary variable in case the\n      // test expressions overwrite values like context.sent.\n      var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get(\"discriminant\")));\n      after = this.loc();\n      var defaultLoc = this.loc();\n      var condition = defaultLoc;\n      var caseLocs = []; // If there are no cases, .cases might be undefined.\n\n      var cases = stmt.cases || [];\n\n      for (var i = cases.length - 1; i >= 0; --i) {\n        var c = cases[i];\n        t.assertSwitchCase(c);\n\n        if (c.test) {\n          condition = t.conditionalExpression(t.binaryExpression(\"===\", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition);\n        } else {\n          caseLocs[i] = defaultLoc;\n        }\n      }\n\n      var discriminant = path.get(\"discriminant\");\n      util.replaceWithOrRemove(discriminant, condition);\n      self.jump(self.explodeExpression(discriminant));\n      self.leapManager.withEntry(new leap.SwitchEntry(after), function () {\n        path.get(\"cases\").forEach(function (casePath) {\n          var i = casePath.key;\n          self.mark(caseLocs[i]);\n          casePath.get(\"consequent\").forEach(function (path) {\n            self.explodeStatement(path);\n          });\n        });\n      });\n      self.mark(after);\n\n      if (defaultLoc.value === -1) {\n        self.mark(defaultLoc);\n\n        _assert[\"default\"].strictEqual(after.value, defaultLoc.value);\n      }\n\n      break;\n\n    case \"IfStatement\":\n      var elseLoc = stmt.alternate && this.loc();\n      after = this.loc();\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), elseLoc || after);\n      self.explodeStatement(path.get(\"consequent\"));\n\n      if (elseLoc) {\n        self.jump(after);\n        self.mark(elseLoc);\n        self.explodeStatement(path.get(\"alternate\"));\n      }\n\n      self.mark(after);\n      break;\n\n    case \"ReturnStatement\":\n      self.emitAbruptCompletion({\n        type: \"return\",\n        value: self.explodeExpression(path.get(\"argument\"))\n      });\n      break;\n\n    case \"WithStatement\":\n      throw new Error(\"WithStatement not supported in generator functions.\");\n\n    case \"TryStatement\":\n      after = this.loc();\n      var handler = stmt.handler;\n      var catchLoc = handler && this.loc();\n      var catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);\n      var finallyLoc = stmt.finalizer && this.loc();\n      var finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);\n      var tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);\n      self.tryEntries.push(tryEntry);\n      self.updateContextPrevLoc(tryEntry.firstLoc);\n      self.leapManager.withEntry(tryEntry, function () {\n        self.explodeStatement(path.get(\"block\"));\n\n        if (catchLoc) {\n          if (finallyLoc) {\n            // If we have both a catch block and a finally block, then\n            // because we emit the catch block first, we need to jump over\n            // it to the finally block.\n            self.jump(finallyLoc);\n          } else {\n            // If there is no finally block, then we need to jump over the\n            // catch block to the fall-through location.\n            self.jump(after);\n          }\n\n          self.updateContextPrevLoc(self.mark(catchLoc));\n          var bodyPath = path.get(\"handler.body\");\n          var safeParam = self.makeTempVar();\n          self.clearPendingException(tryEntry.firstLoc, safeParam);\n          bodyPath.traverse(catchParamVisitor, {\n            getSafeParam: function getSafeParam() {\n              return t.cloneDeep(safeParam);\n            },\n            catchParamName: handler.param.name\n          });\n          self.leapManager.withEntry(catchEntry, function () {\n            self.explodeStatement(bodyPath);\n          });\n        }\n\n        if (finallyLoc) {\n          self.updateContextPrevLoc(self.mark(finallyLoc));\n          self.leapManager.withEntry(finallyEntry, function () {\n            self.explodeStatement(path.get(\"finalizer\"));\n          });\n          self.emit(t.returnStatement(t.callExpression(self.contextProperty(\"finish\"), [finallyEntry.firstLoc])));\n        }\n      });\n      self.mark(after);\n      break;\n\n    case \"ThrowStatement\":\n      self.emit(t.throwStatement(self.explodeExpression(path.get(\"argument\"))));\n      break;\n\n    case \"ClassDeclaration\":\n      self.emit(self.explodeClass(path));\n      break;\n\n    default:\n      throw new Error(\"unknown Statement of type \" + JSON.stringify(stmt.type));\n  }\n};\n\nvar catchParamVisitor = {\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === state.catchParamName && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getSafeParam());\n    }\n  },\n  Scope: function Scope(path, state) {\n    if (path.scope.hasOwnBinding(state.catchParamName)) {\n      // Don't descend into nested scopes that shadow the catch\n      // parameter with their own declarations.\n      path.skip();\n    }\n  }\n};\n\nEp.emitAbruptCompletion = function (record) {\n  if (!isValidCompletion(record)) {\n    _assert[\"default\"].ok(false, \"invalid completion record: \" + JSON.stringify(record));\n  }\n\n  _assert[\"default\"].notStrictEqual(record.type, \"normal\", \"normal completions are not abrupt\");\n\n  var t = util.getTypes();\n  var abruptArgs = [t.stringLiteral(record.type)];\n\n  if (record.type === \"break\" || record.type === \"continue\") {\n    t.assertLiteral(record.target);\n    abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target);\n  } else if (record.type === \"return\" || record.type === \"throw\") {\n    if (record.value) {\n      t.assertExpression(record.value);\n      abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value);\n    }\n  }\n\n  this.emit(t.returnStatement(t.callExpression(this.contextProperty(\"abrupt\"), abruptArgs)));\n};\n\nfunction isValidCompletion(record) {\n  var type = record.type;\n\n  if (type === \"normal\") {\n    return !hasOwn.call(record, \"target\");\n  }\n\n  if (type === \"break\" || type === \"continue\") {\n    return !hasOwn.call(record, \"value\") && util.getTypes().isLiteral(record.target);\n  }\n\n  if (type === \"return\" || type === \"throw\") {\n    return hasOwn.call(record, \"value\") && !hasOwn.call(record, \"target\");\n  }\n\n  return false;\n} // Not all offsets into emitter.listing are potential jump targets. For\n// example, execution typically falls into the beginning of a try block\n// without jumping directly there. This method returns the current offset\n// without marking it, so that a switch case will not necessarily be\n// generated for this offset (I say \"not necessarily\" because the same\n// location might end up being marked in the process of emitting other\n// statements). There's no logical harm in marking such locations as jump\n// targets, but minimizing the number of switch cases keeps the generated\n// code shorter.\n\n\nEp.getUnmarkedCurrentLoc = function () {\n  return util.getTypes().numericLiteral(this.listing.length);\n}; // The context.prev property takes the value of context.next whenever we\n// evaluate the switch statement discriminant, which is generally good\n// enough for tracking the last location we jumped to, but sometimes\n// context.prev needs to be more precise, such as when we fall\n// successfully out of a try block and into a finally block without\n// jumping. This method exists to update context.prev to the freshest\n// available location. If we were implementing a full interpreter, we\n// would know the location of the current instruction with complete\n// precision at all times, but we don't have that luxury here, as it would\n// be costly and verbose to set context.prev before every statement.\n\n\nEp.updateContextPrevLoc = function (loc) {\n  var t = util.getTypes();\n\n  if (loc) {\n    t.assertLiteral(loc);\n\n    if (loc.value === -1) {\n      // If an uninitialized location literal was passed in, set its value\n      // to the current this.listing.length.\n      loc.value = this.listing.length;\n    } else {\n      // Otherwise assert that the location matches the current offset.\n      _assert[\"default\"].strictEqual(loc.value, this.listing.length);\n    }\n  } else {\n    loc = this.getUnmarkedCurrentLoc();\n  } // Make sure context.prev is up to date in case we fell into this try\n  // statement without jumping to it. TODO Consider avoiding this\n  // assignment when we know control must have jumped here.\n\n\n  this.emitAssign(this.contextProperty(\"prev\"), loc);\n}; // In order to save the rest of explodeExpression from a combinatorial\n// trainwreck of special cases, explodeViaTempVar is responsible for\n// deciding when a subexpression needs to be \"exploded,\" which is my\n// very technical term for emitting the subexpression as an assignment\n// to a temporary variable and the substituting the temporary variable\n// for the original subexpression. Think of exploded view diagrams, not\n// Michael Bay movies. The point of exploding subexpressions is to\n// control the precise order in which the generated code realizes the\n// side effects of those subexpressions.\n\n\nEp.explodeViaTempVar = function (tempVar, childPath, hasLeapingChildren, ignoreChildResult) {\n  _assert[\"default\"].ok(!ignoreChildResult || !tempVar, \"Ignoring the result of a child expression but forcing it to \" + \"be assigned to a temporary variable?\");\n\n  var t = util.getTypes();\n  var result = this.explodeExpression(childPath, ignoreChildResult);\n\n  if (ignoreChildResult) {// Side effects already emitted above.\n  } else if (tempVar || hasLeapingChildren && !t.isLiteral(result)) {\n    // If tempVar was provided, then the result will always be assigned\n    // to it, even if the result does not otherwise need to be assigned\n    // to a temporary variable.  When no tempVar is provided, we have\n    // the flexibility to decide whether a temporary variable is really\n    // necessary.  Unfortunately, in general, a temporary variable is\n    // required whenever any child contains a yield expression, since it\n    // is difficult to prove (at all, let alone efficiently) whether\n    // this result would evaluate to the same value before and after the\n    // yield (see #206).  One narrow case where we can prove it doesn't\n    // matter (and thus we do not need a temporary variable) is when the\n    // result in question is a Literal value.\n    result = this.emitAssign(tempVar || this.makeTempVar(), result);\n  }\n\n  return result;\n};\n\nEp.explodeExpression = function (path, ignoreResult) {\n  var t = util.getTypes();\n  var expr = path.node;\n\n  if (expr) {\n    t.assertExpression(expr);\n  } else {\n    return expr;\n  }\n\n  var self = this;\n  var result; // Used optionally by several cases below.\n\n  var after;\n\n  function finish(expr) {\n    t.assertExpression(expr);\n\n    if (ignoreResult) {\n      self.emit(expr);\n    }\n\n    return expr;\n  } // If the expression does not contain a leap, then we either emit the\n  // expression as a standalone statement or return it whole.\n\n\n  if (!meta.containsLeap(expr)) {\n    return finish(expr);\n  } // If any child contains a leap (such as a yield or labeled continue or\n  // break statement), then any sibling subexpressions will almost\n  // certainly have to be exploded in order to maintain the order of their\n  // side effects relative to the leaping child(ren).\n\n\n  var hasLeapingChildren = meta.containsLeap.onlyChildren(expr); // If ignoreResult is true, then we must take full responsibility for\n  // emitting the expression with all its side effects, and we should not\n  // return a result.\n\n  switch (expr.type) {\n    case \"MemberExpression\":\n      return finish(t.memberExpression(self.explodeExpression(path.get(\"object\")), expr.computed ? self.explodeViaTempVar(null, path.get(\"property\"), hasLeapingChildren) : expr.property, expr.computed));\n\n    case \"CallExpression\":\n      var calleePath = path.get(\"callee\");\n      var argsPath = path.get(\"arguments\");\n      var newCallee;\n      var newArgs;\n      var hasLeapingArgs = argsPath.some(function (argPath) {\n        return meta.containsLeap(argPath.node);\n      });\n      var injectFirstArg = null;\n\n      if (t.isMemberExpression(calleePath.node)) {\n        if (hasLeapingArgs) {\n          // If the arguments of the CallExpression contained any yield\n          // expressions, then we need to be sure to evaluate the callee\n          // before evaluating the arguments, but if the callee was a member\n          // expression, then we must be careful that the object of the\n          // member expression still gets bound to `this` for the call.\n          var newObject = self.explodeViaTempVar( // Assign the exploded callee.object expression to a temporary\n          // variable so that we can use it twice without reevaluating it.\n          self.makeTempVar(), calleePath.get(\"object\"), hasLeapingChildren);\n          var newProperty = calleePath.node.computed ? self.explodeViaTempVar(null, calleePath.get(\"property\"), hasLeapingChildren) : calleePath.node.property;\n          injectFirstArg = newObject;\n          newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier(\"call\"), false);\n        } else {\n          newCallee = self.explodeExpression(calleePath);\n        }\n      } else {\n        newCallee = self.explodeViaTempVar(null, calleePath, hasLeapingChildren);\n\n        if (t.isMemberExpression(newCallee)) {\n          // If the callee was not previously a MemberExpression, then the\n          // CallExpression was \"unqualified,\" meaning its `this` object\n          // should be the global object. If the exploded expression has\n          // become a MemberExpression (e.g. a context property, probably a\n          // temporary variable), then we need to force it to be unqualified\n          // by using the (0, object.property)(...) trick; otherwise, it\n          // will receive the object of the MemberExpression as its `this`\n          // object.\n          newCallee = t.sequenceExpression([t.numericLiteral(0), t.cloneDeep(newCallee)]);\n        }\n      }\n\n      if (hasLeapingArgs) {\n        newArgs = argsPath.map(function (argPath) {\n          return self.explodeViaTempVar(null, argPath, hasLeapingChildren);\n        });\n        if (injectFirstArg) newArgs.unshift(injectFirstArg);\n        newArgs = newArgs.map(function (arg) {\n          return t.cloneDeep(arg);\n        });\n      } else {\n        newArgs = path.node.arguments;\n      }\n\n      return finish(t.callExpression(newCallee, newArgs));\n\n    case \"NewExpression\":\n      return finish(t.newExpression(self.explodeViaTempVar(null, path.get(\"callee\"), hasLeapingChildren), path.get(\"arguments\").map(function (argPath) {\n        return self.explodeViaTempVar(null, argPath, hasLeapingChildren);\n      })));\n\n    case \"ObjectExpression\":\n      return finish(t.objectExpression(path.get(\"properties\").map(function (propPath) {\n        if (propPath.isObjectProperty()) {\n          return t.objectProperty(propPath.node.key, self.explodeViaTempVar(null, propPath.get(\"value\"), hasLeapingChildren), propPath.node.computed);\n        } else {\n          return propPath.node;\n        }\n      })));\n\n    case \"ArrayExpression\":\n      return finish(t.arrayExpression(path.get(\"elements\").map(function (elemPath) {\n        if (elemPath.isSpreadElement()) {\n          return t.spreadElement(self.explodeViaTempVar(null, elemPath.get(\"argument\"), hasLeapingChildren));\n        } else {\n          return self.explodeViaTempVar(null, elemPath, hasLeapingChildren);\n        }\n      })));\n\n    case \"SequenceExpression\":\n      var lastIndex = expr.expressions.length - 1;\n      path.get(\"expressions\").forEach(function (exprPath) {\n        if (exprPath.key === lastIndex) {\n          result = self.explodeExpression(exprPath, ignoreResult);\n        } else {\n          self.explodeExpression(exprPath, true);\n        }\n      });\n      return result;\n\n    case \"LogicalExpression\":\n      after = this.loc();\n\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n\n      var left = self.explodeViaTempVar(result, path.get(\"left\"), hasLeapingChildren);\n\n      if (expr.operator === \"&&\") {\n        self.jumpIfNot(left, after);\n      } else {\n        _assert[\"default\"].strictEqual(expr.operator, \"||\");\n\n        self.jumpIf(left, after);\n      }\n\n      self.explodeViaTempVar(result, path.get(\"right\"), hasLeapingChildren, ignoreResult);\n      self.mark(after);\n      return result;\n\n    case \"ConditionalExpression\":\n      var elseLoc = this.loc();\n      after = this.loc();\n      var test = self.explodeExpression(path.get(\"test\"));\n      self.jumpIfNot(test, elseLoc);\n\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n\n      self.explodeViaTempVar(result, path.get(\"consequent\"), hasLeapingChildren, ignoreResult);\n      self.jump(after);\n      self.mark(elseLoc);\n      self.explodeViaTempVar(result, path.get(\"alternate\"), hasLeapingChildren, ignoreResult);\n      self.mark(after);\n      return result;\n\n    case \"UnaryExpression\":\n      return finish(t.unaryExpression(expr.operator, // Can't (and don't need to) break up the syntax of the argument.\n      // Think about delete a[b].\n      self.explodeExpression(path.get(\"argument\")), !!expr.prefix));\n\n    case \"BinaryExpression\":\n      return finish(t.binaryExpression(expr.operator, self.explodeViaTempVar(null, path.get(\"left\"), hasLeapingChildren), self.explodeViaTempVar(null, path.get(\"right\"), hasLeapingChildren)));\n\n    case \"AssignmentExpression\":\n      if (expr.operator === \"=\") {\n        // If this is a simple assignment, the left hand side does not need\n        // to be read before the right hand side is evaluated, so we can\n        // avoid the more complicated logic below.\n        return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get(\"left\")), self.explodeExpression(path.get(\"right\"))));\n      }\n\n      var lhs = self.explodeExpression(path.get(\"left\"));\n      var temp = self.emitAssign(self.makeTempVar(), lhs); // For example,\n      //\n      //   x += yield y\n      //\n      // becomes\n      //\n      //   context.t0 = x\n      //   x = context.t0 += yield y\n      //\n      // so that the left-hand side expression is read before the yield.\n      // Fixes https://github.com/facebook/regenerator/issues/345.\n\n      return finish(t.assignmentExpression(\"=\", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get(\"right\")))));\n\n    case \"UpdateExpression\":\n      return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get(\"argument\")), expr.prefix));\n\n    case \"YieldExpression\":\n      after = this.loc();\n      var arg = expr.argument && self.explodeExpression(path.get(\"argument\"));\n\n      if (arg && expr.delegate) {\n        var _result = self.makeTempVar();\n\n        var _ret = t.returnStatement(t.callExpression(self.contextProperty(\"delegateYield\"), [arg, t.stringLiteral(_result.property.name), after]));\n\n        _ret.loc = expr.loc;\n        self.emit(_ret);\n        self.mark(after);\n        return _result;\n      }\n\n      self.emitAssign(self.contextProperty(\"next\"), after);\n      var ret = t.returnStatement(t.cloneDeep(arg) || null); // Preserve the `yield` location so that source mappings for the statements\n      // link back to the yield properly.\n\n      ret.loc = expr.loc;\n      self.emit(ret);\n      self.mark(after);\n      return self.contextProperty(\"sent\");\n\n    case \"ClassExpression\":\n      return finish(self.explodeClass(path));\n\n    default:\n      throw new Error(\"unknown Expression of type \" + JSON.stringify(expr.type));\n  }\n};\n\nEp.explodeClass = function (path) {\n  var explodingChildren = [];\n\n  if (path.node.superClass) {\n    explodingChildren.push(path.get(\"superClass\"));\n  }\n\n  path.get(\"body.body\").forEach(function (member) {\n    if (member.node.computed) {\n      explodingChildren.push(member.get(\"key\"));\n    }\n  });\n  var hasLeapingChildren = explodingChildren.some(function (child) {\n    return meta.containsLeap(child);\n  });\n\n  for (var i = 0; i < explodingChildren.length; i++) {\n    var child = explodingChildren[i];\n    var isLast = i === explodingChildren.length - 1;\n\n    if (isLast) {\n      child.replaceWith(this.explodeExpression(child));\n    } else {\n      child.replaceWith(this.explodeViaTempVar(null, child, hasLeapingChildren));\n    }\n  }\n\n  return path.node;\n};","map":{"version":3,"names":["_interopRequireDefault","require","_assert","leap","_interopRequireWildcard","meta","util","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","hasOwn","Emitter","contextId","ok","getTypes","assertIdentifier","nextTempId","listing","marked","insertedLocs","Set","finalLoc","loc","tryEntries","leapManager","LeapManager","Ep","exports","l","numericLiteral","add","getInsertedLocs","getContextId","clone","mark","assertLiteral","index","length","value","strictEqual","emit","node","t","isExpression","expressionStatement","assertStatement","push","emitAssign","lhs","rhs","assign","assignmentExpression","cloneDeep","contextProperty","name","computed","memberExpression","stringLiteral","identifier","stop","rval","setReturnValue","jump","valuePath","assertExpression","explodeExpression","clearPendingException","tryLoc","assignee","catchCall","callExpression","toLoc","breakStatement","jumpIf","test","ifStatement","blockStatement","jumpIfNot","negatedTest","isUnaryExpression","operator","argument","unaryExpression","makeTempVar","getContextFunction","id","functionExpression","getDispatchLoop","self","cases","current","alreadyEnded","forEach","stmt","i","switchCase","isCompletionStatement","returnStatement","whileStatement","switchStatement","getTryLocsList","lastLocValue","arrayExpression","map","tryEntry","thisLocValue","firstLoc","ce","catchEntry","fe","finallyEntry","locs","afterLoc","explode","path","ignoreResult","assertNode","isDeclaration","getDeclError","isStatement","explodeStatement","type","Error","JSON","stringify","labelId","before","after","head","isBlockStatement","containsLeap","withEntry","LabeledEntry","label","LoopEntry","first","update","init","keyIterNextFn","runtimeProperty","keyInfoTmpVar","left","emitAbruptCompletion","target","getBreakLoc","getContinueLoc","disc","defaultLoc","condition","caseLocs","c","assertSwitchCase","conditionalExpression","binaryExpression","discriminant","replaceWithOrRemove","SwitchEntry","casePath","elseLoc","alternate","handler","catchLoc","CatchEntry","param","finallyLoc","finalizer","FinallyEntry","TryEntry","getUnmarkedCurrentLoc","updateContextPrevLoc","bodyPath","safeParam","traverse","catchParamVisitor","getSafeParam","catchParamName","throwStatement","explodeClass","Identifier","state","isReference","Scope","scope","hasOwnBinding","skip","record","isValidCompletion","notStrictEqual","abruptArgs","isLiteral","explodeViaTempVar","tempVar","childPath","hasLeapingChildren","ignoreChildResult","result","expr","finish","onlyChildren","property","calleePath","argsPath","newCallee","newArgs","hasLeapingArgs","some","argPath","injectFirstArg","isMemberExpression","newObject","newProperty","sequenceExpression","unshift","arg","arguments","newExpression","objectExpression","propPath","isObjectProperty","objectProperty","elemPath","isSpreadElement","spreadElement","lastIndex","expressions","exprPath","prefix","temp","updateExpression","delegate","_result","_ret","ret","explodingChildren","superClass","member","child","isLast","replaceWith"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/regenerator-transform/lib/emit.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar leap = _interopRequireWildcard(require(\"./leap\"));\n\nvar meta = _interopRequireWildcard(require(\"./meta\"));\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction Emitter(contextId) {\n  _assert[\"default\"].ok(this instanceof Emitter);\n\n  util.getTypes().assertIdentifier(contextId); // Used to generate unique temporary names.\n\n  this.nextTempId = 0; // In order to make sure the context object does not collide with\n  // anything in the local scope, we might have to rename it, so we\n  // refer to it symbolically instead of just assuming that it will be\n  // called \"context\".\n\n  this.contextId = contextId; // An append-only list of Statements that grows each time this.emit is\n  // called.\n\n  this.listing = []; // A sparse array whose keys correspond to locations in this.listing\n  // that have been marked as branch/jump targets.\n\n  this.marked = [true];\n  this.insertedLocs = new Set(); // The last location will be marked when this.getDispatchLoop is\n  // called.\n\n  this.finalLoc = this.loc(); // A list of all leap.TryEntry statements emitted.\n\n  this.tryEntries = []; // Each time we evaluate the body of a loop, we tell this.leapManager\n  // to enter a nested loop context that determines the meaning of break\n  // and continue statements therein.\n\n  this.leapManager = new leap.LeapManager(this);\n}\n\nvar Ep = Emitter.prototype;\nexports.Emitter = Emitter; // Offsets into this.listing that could be used as targets for branches or\n// jumps are represented as numeric Literal nodes. This representation has\n// the amazingly convenient benefit of allowing the exact value of the\n// location to be determined at any time, even after generating code that\n// refers to the location.\n\nEp.loc = function () {\n  var l = util.getTypes().numericLiteral(-1);\n  this.insertedLocs.add(l);\n  return l;\n};\n\nEp.getInsertedLocs = function () {\n  return this.insertedLocs;\n};\n\nEp.getContextId = function () {\n  return util.getTypes().clone(this.contextId);\n}; // Sets the exact value of the given location to the offset of the next\n// Statement emitted.\n\n\nEp.mark = function (loc) {\n  util.getTypes().assertLiteral(loc);\n  var index = this.listing.length;\n\n  if (loc.value === -1) {\n    loc.value = index;\n  } else {\n    // Locations can be marked redundantly, but their values cannot change\n    // once set the first time.\n    _assert[\"default\"].strictEqual(loc.value, index);\n  }\n\n  this.marked[index] = true;\n  return loc;\n};\n\nEp.emit = function (node) {\n  var t = util.getTypes();\n\n  if (t.isExpression(node)) {\n    node = t.expressionStatement(node);\n  }\n\n  t.assertStatement(node);\n  this.listing.push(node);\n}; // Shorthand for emitting assignment statements. This will come in handy\n// for assignments to temporary variables.\n\n\nEp.emitAssign = function (lhs, rhs) {\n  this.emit(this.assign(lhs, rhs));\n  return lhs;\n}; // Shorthand for an assignment statement.\n\n\nEp.assign = function (lhs, rhs) {\n  var t = util.getTypes();\n  return t.expressionStatement(t.assignmentExpression(\"=\", t.cloneDeep(lhs), rhs));\n}; // Convenience function for generating expressions like context.next,\n// context.sent, and context.rval.\n\n\nEp.contextProperty = function (name, computed) {\n  var t = util.getTypes();\n  return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);\n}; // Shorthand for setting context.rval and jumping to `context.stop()`.\n\n\nEp.stop = function (rval) {\n  if (rval) {\n    this.setReturnValue(rval);\n  }\n\n  this.jump(this.finalLoc);\n};\n\nEp.setReturnValue = function (valuePath) {\n  util.getTypes().assertExpression(valuePath.value);\n  this.emitAssign(this.contextProperty(\"rval\"), this.explodeExpression(valuePath));\n};\n\nEp.clearPendingException = function (tryLoc, assignee) {\n  var t = util.getTypes();\n  t.assertLiteral(tryLoc);\n  var catchCall = t.callExpression(this.contextProperty(\"catch\", true), [t.clone(tryLoc)]);\n\n  if (assignee) {\n    this.emitAssign(assignee, catchCall);\n  } else {\n    this.emit(catchCall);\n  }\n}; // Emits code for an unconditional jump to the given location, even if the\n// exact value of the location is not yet known.\n\n\nEp.jump = function (toLoc) {\n  this.emitAssign(this.contextProperty(\"next\"), toLoc);\n  this.emit(util.getTypes().breakStatement());\n}; // Conditional jump.\n\n\nEp.jumpIf = function (test, toLoc) {\n  var t = util.getTypes();\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n  this.emit(t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n}; // Conditional jump, with the condition negated.\n\n\nEp.jumpIfNot = function (test, toLoc) {\n  var t = util.getTypes();\n  t.assertExpression(test);\n  t.assertLiteral(toLoc);\n  var negatedTest;\n\n  if (t.isUnaryExpression(test) && test.operator === \"!\") {\n    // Avoid double negation.\n    negatedTest = test.argument;\n  } else {\n    negatedTest = t.unaryExpression(\"!\", test);\n  }\n\n  this.emit(t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty(\"next\"), toLoc), t.breakStatement()])));\n}; // Returns a unique MemberExpression that can be used to store and\n// retrieve temporary values. Since the object of the member expression is\n// the context object, which is presumed to coexist peacefully with all\n// other local variables, and since we just increment `nextTempId`\n// monotonically, uniqueness is assured.\n\n\nEp.makeTempVar = function () {\n  return this.contextProperty(\"t\" + this.nextTempId++);\n};\n\nEp.getContextFunction = function (id) {\n  var t = util.getTypes();\n  return t.functionExpression(id || null\n  /*Anonymous*/\n  , [this.getContextId()], t.blockStatement([this.getDispatchLoop()]), false, // Not a generator anymore!\n  false // Nor an expression.\n  );\n}; // Turns this.listing into a loop of the form\n//\n//   while (1) switch (context.next) {\n//   case 0:\n//   ...\n//   case n:\n//     return context.stop();\n//   }\n//\n// Each marked location in this.listing will correspond to one generated\n// case statement.\n\n\nEp.getDispatchLoop = function () {\n  var self = this;\n  var t = util.getTypes();\n  var cases = [];\n  var current; // If we encounter a break, continue, or return statement in a switch\n  // case, we can skip the rest of the statements until the next case.\n\n  var alreadyEnded = false;\n  self.listing.forEach(function (stmt, i) {\n    if (self.marked.hasOwnProperty(i)) {\n      cases.push(t.switchCase(t.numericLiteral(i), current = []));\n      alreadyEnded = false;\n    }\n\n    if (!alreadyEnded) {\n      current.push(stmt);\n      if (t.isCompletionStatement(stmt)) alreadyEnded = true;\n    }\n  }); // Now that we know how many statements there will be in this.listing,\n  // we can finally resolve this.finalLoc.value.\n\n  this.finalLoc.value = this.listing.length;\n  cases.push(t.switchCase(this.finalLoc, [// Intentionally fall through to the \"end\" case...\n  ]), // So that the runtime can jump to the final location without having\n  // to know its offset, we provide the \"end\" case as a synonym.\n  t.switchCase(t.stringLiteral(\"end\"), [// This will check/clear both context.thrown and context.rval.\n  t.returnStatement(t.callExpression(this.contextProperty(\"stop\"), []))]));\n  return t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression(\"=\", this.contextProperty(\"prev\"), this.contextProperty(\"next\")), cases));\n};\n\nEp.getTryLocsList = function () {\n  if (this.tryEntries.length === 0) {\n    // To avoid adding a needless [] to the majority of runtime.wrap\n    // argument lists, force the caller to handle this case specially.\n    return null;\n  }\n\n  var t = util.getTypes();\n  var lastLocValue = 0;\n  return t.arrayExpression(this.tryEntries.map(function (tryEntry) {\n    var thisLocValue = tryEntry.firstLoc.value;\n\n    _assert[\"default\"].ok(thisLocValue >= lastLocValue, \"try entries out of order\");\n\n    lastLocValue = thisLocValue;\n    var ce = tryEntry.catchEntry;\n    var fe = tryEntry.finallyEntry;\n    var locs = [tryEntry.firstLoc, // The null here makes a hole in the array.\n    ce ? ce.firstLoc : null];\n\n    if (fe) {\n      locs[2] = fe.firstLoc;\n      locs[3] = fe.afterLoc;\n    }\n\n    return t.arrayExpression(locs.map(function (loc) {\n      return loc && t.clone(loc);\n    }));\n  }));\n}; // All side effects must be realized in order.\n// If any subexpression harbors a leap, all subexpressions must be\n// neutered of side effects.\n// No destructive modification of AST nodes.\n\n\nEp.explode = function (path, ignoreResult) {\n  var t = util.getTypes();\n  var node = path.node;\n  var self = this;\n  t.assertNode(node);\n  if (t.isDeclaration(node)) throw getDeclError(node);\n  if (t.isStatement(node)) return self.explodeStatement(path);\n  if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);\n\n  switch (node.type) {\n    case \"Program\":\n      return path.get(\"body\").map(self.explodeStatement, self);\n\n    case \"VariableDeclarator\":\n      throw getDeclError(node);\n    // These node types should be handled by their parent nodes\n    // (ObjectExpression, SwitchStatement, and TryStatement, respectively).\n\n    case \"Property\":\n    case \"SwitchCase\":\n    case \"CatchClause\":\n      throw new Error(node.type + \" nodes should be handled by their parents\");\n\n    default:\n      throw new Error(\"unknown Node of type \" + JSON.stringify(node.type));\n  }\n};\n\nfunction getDeclError(node) {\n  return new Error(\"all declarations should have been transformed into \" + \"assignments before the Exploder began its work: \" + JSON.stringify(node));\n}\n\nEp.explodeStatement = function (path, labelId) {\n  var t = util.getTypes();\n  var stmt = path.node;\n  var self = this;\n  var before, after, head;\n  t.assertStatement(stmt);\n\n  if (labelId) {\n    t.assertIdentifier(labelId);\n  } else {\n    labelId = null;\n  } // Explode BlockStatement nodes even if they do not contain a yield,\n  // because we don't want or need the curly braces.\n\n\n  if (t.isBlockStatement(stmt)) {\n    path.get(\"body\").forEach(function (path) {\n      self.explodeStatement(path);\n    });\n    return;\n  }\n\n  if (!meta.containsLeap(stmt)) {\n    // Technically we should be able to avoid emitting the statement\n    // altogether if !meta.hasSideEffects(stmt), but that leads to\n    // confusing generated code (for instance, `while (true) {}` just\n    // disappears) and is probably a more appropriate job for a dedicated\n    // dead code elimination pass.\n    self.emit(stmt);\n    return;\n  }\n\n  switch (stmt.type) {\n    case \"ExpressionStatement\":\n      self.explodeExpression(path.get(\"expression\"), true);\n      break;\n\n    case \"LabeledStatement\":\n      after = this.loc(); // Did you know you can break from any labeled block statement or\n      // control structure? Well, you can! Note: when a labeled loop is\n      // encountered, the leap.LabeledEntry created here will immediately\n      // enclose a leap.LoopEntry on the leap manager's stack, and both\n      // entries will have the same label. Though this works just fine, it\n      // may seem a bit redundant. In theory, we could check here to\n      // determine if stmt knows how to handle its own label; for example,\n      // stmt happens to be a WhileStatement and so we know it's going to\n      // establish its own LoopEntry when we explode it (below). Then this\n      // LabeledEntry would be unnecessary. Alternatively, we might be\n      // tempted not to pass stmt.label down into self.explodeStatement,\n      // because we've handled the label here, but that's a mistake because\n      // labeled loops may contain labeled continue statements, which is not\n      // something we can handle in this generic case. All in all, I think a\n      // little redundancy greatly simplifies the logic of this case, since\n      // it's clear that we handle all possible LabeledStatements correctly\n      // here, regardless of whether they interact with the leap manager\n      // themselves. Also remember that labels and break/continue-to-label\n      // statements are rare, and all of this logic happens at transform\n      // time, so it has no additional runtime cost.\n\n      self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), function () {\n        self.explodeStatement(path.get(\"body\"), stmt.label);\n      });\n      self.mark(after);\n      break;\n\n    case \"WhileStatement\":\n      before = this.loc();\n      after = this.loc();\n      self.mark(before);\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.jump(before);\n      self.mark(after);\n      break;\n\n    case \"DoWhileStatement\":\n      var first = this.loc();\n      var test = this.loc();\n      after = this.loc();\n      self.mark(first);\n      self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {\n        self.explode(path.get(\"body\"));\n      });\n      self.mark(test);\n      self.jumpIf(self.explodeExpression(path.get(\"test\")), first);\n      self.mark(after);\n      break;\n\n    case \"ForStatement\":\n      head = this.loc();\n      var update = this.loc();\n      after = this.loc();\n\n      if (stmt.init) {\n        // We pass true here to indicate that if stmt.init is an expression\n        // then we do not care about its result.\n        self.explode(path.get(\"init\"), true);\n      }\n\n      self.mark(head);\n\n      if (stmt.test) {\n        self.jumpIfNot(self.explodeExpression(path.get(\"test\")), after);\n      } else {// No test means continue unconditionally.\n      }\n\n      self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.mark(update);\n\n      if (stmt.update) {\n        // We pass true here to indicate that if stmt.update is an\n        // expression then we do not care about its result.\n        self.explode(path.get(\"update\"), true);\n      }\n\n      self.jump(head);\n      self.mark(after);\n      break;\n\n    case \"TypeCastExpression\":\n      return self.explodeExpression(path.get(\"expression\"));\n\n    case \"ForInStatement\":\n      head = this.loc();\n      after = this.loc();\n      var keyIterNextFn = self.makeTempVar();\n      self.emitAssign(keyIterNextFn, t.callExpression(util.runtimeProperty(\"keys\"), [self.explodeExpression(path.get(\"right\"))]));\n      self.mark(head);\n      var keyInfoTmpVar = self.makeTempVar();\n      self.jumpIf(t.memberExpression(t.assignmentExpression(\"=\", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier(\"done\"), false), after);\n      self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier(\"value\"), false));\n      self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {\n        self.explodeStatement(path.get(\"body\"));\n      });\n      self.jump(head);\n      self.mark(after);\n      break;\n\n    case \"BreakStatement\":\n      self.emitAbruptCompletion({\n        type: \"break\",\n        target: self.leapManager.getBreakLoc(stmt.label)\n      });\n      break;\n\n    case \"ContinueStatement\":\n      self.emitAbruptCompletion({\n        type: \"continue\",\n        target: self.leapManager.getContinueLoc(stmt.label)\n      });\n      break;\n\n    case \"SwitchStatement\":\n      // Always save the discriminant into a temporary variable in case the\n      // test expressions overwrite values like context.sent.\n      var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get(\"discriminant\")));\n      after = this.loc();\n      var defaultLoc = this.loc();\n      var condition = defaultLoc;\n      var caseLocs = []; // If there are no cases, .cases might be undefined.\n\n      var cases = stmt.cases || [];\n\n      for (var i = cases.length - 1; i >= 0; --i) {\n        var c = cases[i];\n        t.assertSwitchCase(c);\n\n        if (c.test) {\n          condition = t.conditionalExpression(t.binaryExpression(\"===\", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition);\n        } else {\n          caseLocs[i] = defaultLoc;\n        }\n      }\n\n      var discriminant = path.get(\"discriminant\");\n      util.replaceWithOrRemove(discriminant, condition);\n      self.jump(self.explodeExpression(discriminant));\n      self.leapManager.withEntry(new leap.SwitchEntry(after), function () {\n        path.get(\"cases\").forEach(function (casePath) {\n          var i = casePath.key;\n          self.mark(caseLocs[i]);\n          casePath.get(\"consequent\").forEach(function (path) {\n            self.explodeStatement(path);\n          });\n        });\n      });\n      self.mark(after);\n\n      if (defaultLoc.value === -1) {\n        self.mark(defaultLoc);\n\n        _assert[\"default\"].strictEqual(after.value, defaultLoc.value);\n      }\n\n      break;\n\n    case \"IfStatement\":\n      var elseLoc = stmt.alternate && this.loc();\n      after = this.loc();\n      self.jumpIfNot(self.explodeExpression(path.get(\"test\")), elseLoc || after);\n      self.explodeStatement(path.get(\"consequent\"));\n\n      if (elseLoc) {\n        self.jump(after);\n        self.mark(elseLoc);\n        self.explodeStatement(path.get(\"alternate\"));\n      }\n\n      self.mark(after);\n      break;\n\n    case \"ReturnStatement\":\n      self.emitAbruptCompletion({\n        type: \"return\",\n        value: self.explodeExpression(path.get(\"argument\"))\n      });\n      break;\n\n    case \"WithStatement\":\n      throw new Error(\"WithStatement not supported in generator functions.\");\n\n    case \"TryStatement\":\n      after = this.loc();\n      var handler = stmt.handler;\n      var catchLoc = handler && this.loc();\n      var catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);\n      var finallyLoc = stmt.finalizer && this.loc();\n      var finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);\n      var tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);\n      self.tryEntries.push(tryEntry);\n      self.updateContextPrevLoc(tryEntry.firstLoc);\n      self.leapManager.withEntry(tryEntry, function () {\n        self.explodeStatement(path.get(\"block\"));\n\n        if (catchLoc) {\n          if (finallyLoc) {\n            // If we have both a catch block and a finally block, then\n            // because we emit the catch block first, we need to jump over\n            // it to the finally block.\n            self.jump(finallyLoc);\n          } else {\n            // If there is no finally block, then we need to jump over the\n            // catch block to the fall-through location.\n            self.jump(after);\n          }\n\n          self.updateContextPrevLoc(self.mark(catchLoc));\n          var bodyPath = path.get(\"handler.body\");\n          var safeParam = self.makeTempVar();\n          self.clearPendingException(tryEntry.firstLoc, safeParam);\n          bodyPath.traverse(catchParamVisitor, {\n            getSafeParam: function getSafeParam() {\n              return t.cloneDeep(safeParam);\n            },\n            catchParamName: handler.param.name\n          });\n          self.leapManager.withEntry(catchEntry, function () {\n            self.explodeStatement(bodyPath);\n          });\n        }\n\n        if (finallyLoc) {\n          self.updateContextPrevLoc(self.mark(finallyLoc));\n          self.leapManager.withEntry(finallyEntry, function () {\n            self.explodeStatement(path.get(\"finalizer\"));\n          });\n          self.emit(t.returnStatement(t.callExpression(self.contextProperty(\"finish\"), [finallyEntry.firstLoc])));\n        }\n      });\n      self.mark(after);\n      break;\n\n    case \"ThrowStatement\":\n      self.emit(t.throwStatement(self.explodeExpression(path.get(\"argument\"))));\n      break;\n\n    case \"ClassDeclaration\":\n      self.emit(self.explodeClass(path));\n      break;\n\n    default:\n      throw new Error(\"unknown Statement of type \" + JSON.stringify(stmt.type));\n  }\n};\n\nvar catchParamVisitor = {\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === state.catchParamName && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getSafeParam());\n    }\n  },\n  Scope: function Scope(path, state) {\n    if (path.scope.hasOwnBinding(state.catchParamName)) {\n      // Don't descend into nested scopes that shadow the catch\n      // parameter with their own declarations.\n      path.skip();\n    }\n  }\n};\n\nEp.emitAbruptCompletion = function (record) {\n  if (!isValidCompletion(record)) {\n    _assert[\"default\"].ok(false, \"invalid completion record: \" + JSON.stringify(record));\n  }\n\n  _assert[\"default\"].notStrictEqual(record.type, \"normal\", \"normal completions are not abrupt\");\n\n  var t = util.getTypes();\n  var abruptArgs = [t.stringLiteral(record.type)];\n\n  if (record.type === \"break\" || record.type === \"continue\") {\n    t.assertLiteral(record.target);\n    abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target);\n  } else if (record.type === \"return\" || record.type === \"throw\") {\n    if (record.value) {\n      t.assertExpression(record.value);\n      abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value);\n    }\n  }\n\n  this.emit(t.returnStatement(t.callExpression(this.contextProperty(\"abrupt\"), abruptArgs)));\n};\n\nfunction isValidCompletion(record) {\n  var type = record.type;\n\n  if (type === \"normal\") {\n    return !hasOwn.call(record, \"target\");\n  }\n\n  if (type === \"break\" || type === \"continue\") {\n    return !hasOwn.call(record, \"value\") && util.getTypes().isLiteral(record.target);\n  }\n\n  if (type === \"return\" || type === \"throw\") {\n    return hasOwn.call(record, \"value\") && !hasOwn.call(record, \"target\");\n  }\n\n  return false;\n} // Not all offsets into emitter.listing are potential jump targets. For\n// example, execution typically falls into the beginning of a try block\n// without jumping directly there. This method returns the current offset\n// without marking it, so that a switch case will not necessarily be\n// generated for this offset (I say \"not necessarily\" because the same\n// location might end up being marked in the process of emitting other\n// statements). There's no logical harm in marking such locations as jump\n// targets, but minimizing the number of switch cases keeps the generated\n// code shorter.\n\n\nEp.getUnmarkedCurrentLoc = function () {\n  return util.getTypes().numericLiteral(this.listing.length);\n}; // The context.prev property takes the value of context.next whenever we\n// evaluate the switch statement discriminant, which is generally good\n// enough for tracking the last location we jumped to, but sometimes\n// context.prev needs to be more precise, such as when we fall\n// successfully out of a try block and into a finally block without\n// jumping. This method exists to update context.prev to the freshest\n// available location. If we were implementing a full interpreter, we\n// would know the location of the current instruction with complete\n// precision at all times, but we don't have that luxury here, as it would\n// be costly and verbose to set context.prev before every statement.\n\n\nEp.updateContextPrevLoc = function (loc) {\n  var t = util.getTypes();\n\n  if (loc) {\n    t.assertLiteral(loc);\n\n    if (loc.value === -1) {\n      // If an uninitialized location literal was passed in, set its value\n      // to the current this.listing.length.\n      loc.value = this.listing.length;\n    } else {\n      // Otherwise assert that the location matches the current offset.\n      _assert[\"default\"].strictEqual(loc.value, this.listing.length);\n    }\n  } else {\n    loc = this.getUnmarkedCurrentLoc();\n  } // Make sure context.prev is up to date in case we fell into this try\n  // statement without jumping to it. TODO Consider avoiding this\n  // assignment when we know control must have jumped here.\n\n\n  this.emitAssign(this.contextProperty(\"prev\"), loc);\n}; // In order to save the rest of explodeExpression from a combinatorial\n// trainwreck of special cases, explodeViaTempVar is responsible for\n// deciding when a subexpression needs to be \"exploded,\" which is my\n// very technical term for emitting the subexpression as an assignment\n// to a temporary variable and the substituting the temporary variable\n// for the original subexpression. Think of exploded view diagrams, not\n// Michael Bay movies. The point of exploding subexpressions is to\n// control the precise order in which the generated code realizes the\n// side effects of those subexpressions.\n\n\nEp.explodeViaTempVar = function (tempVar, childPath, hasLeapingChildren, ignoreChildResult) {\n  _assert[\"default\"].ok(!ignoreChildResult || !tempVar, \"Ignoring the result of a child expression but forcing it to \" + \"be assigned to a temporary variable?\");\n\n  var t = util.getTypes();\n  var result = this.explodeExpression(childPath, ignoreChildResult);\n\n  if (ignoreChildResult) {// Side effects already emitted above.\n  } else if (tempVar || hasLeapingChildren && !t.isLiteral(result)) {\n    // If tempVar was provided, then the result will always be assigned\n    // to it, even if the result does not otherwise need to be assigned\n    // to a temporary variable.  When no tempVar is provided, we have\n    // the flexibility to decide whether a temporary variable is really\n    // necessary.  Unfortunately, in general, a temporary variable is\n    // required whenever any child contains a yield expression, since it\n    // is difficult to prove (at all, let alone efficiently) whether\n    // this result would evaluate to the same value before and after the\n    // yield (see #206).  One narrow case where we can prove it doesn't\n    // matter (and thus we do not need a temporary variable) is when the\n    // result in question is a Literal value.\n    result = this.emitAssign(tempVar || this.makeTempVar(), result);\n  }\n\n  return result;\n};\n\nEp.explodeExpression = function (path, ignoreResult) {\n  var t = util.getTypes();\n  var expr = path.node;\n\n  if (expr) {\n    t.assertExpression(expr);\n  } else {\n    return expr;\n  }\n\n  var self = this;\n  var result; // Used optionally by several cases below.\n\n  var after;\n\n  function finish(expr) {\n    t.assertExpression(expr);\n\n    if (ignoreResult) {\n      self.emit(expr);\n    }\n\n    return expr;\n  } // If the expression does not contain a leap, then we either emit the\n  // expression as a standalone statement or return it whole.\n\n\n  if (!meta.containsLeap(expr)) {\n    return finish(expr);\n  } // If any child contains a leap (such as a yield or labeled continue or\n  // break statement), then any sibling subexpressions will almost\n  // certainly have to be exploded in order to maintain the order of their\n  // side effects relative to the leaping child(ren).\n\n\n  var hasLeapingChildren = meta.containsLeap.onlyChildren(expr); // If ignoreResult is true, then we must take full responsibility for\n  // emitting the expression with all its side effects, and we should not\n  // return a result.\n\n  switch (expr.type) {\n    case \"MemberExpression\":\n      return finish(t.memberExpression(self.explodeExpression(path.get(\"object\")), expr.computed ? self.explodeViaTempVar(null, path.get(\"property\"), hasLeapingChildren) : expr.property, expr.computed));\n\n    case \"CallExpression\":\n      var calleePath = path.get(\"callee\");\n      var argsPath = path.get(\"arguments\");\n      var newCallee;\n      var newArgs;\n      var hasLeapingArgs = argsPath.some(function (argPath) {\n        return meta.containsLeap(argPath.node);\n      });\n      var injectFirstArg = null;\n\n      if (t.isMemberExpression(calleePath.node)) {\n        if (hasLeapingArgs) {\n          // If the arguments of the CallExpression contained any yield\n          // expressions, then we need to be sure to evaluate the callee\n          // before evaluating the arguments, but if the callee was a member\n          // expression, then we must be careful that the object of the\n          // member expression still gets bound to `this` for the call.\n          var newObject = self.explodeViaTempVar( // Assign the exploded callee.object expression to a temporary\n          // variable so that we can use it twice without reevaluating it.\n          self.makeTempVar(), calleePath.get(\"object\"), hasLeapingChildren);\n          var newProperty = calleePath.node.computed ? self.explodeViaTempVar(null, calleePath.get(\"property\"), hasLeapingChildren) : calleePath.node.property;\n          injectFirstArg = newObject;\n          newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier(\"call\"), false);\n        } else {\n          newCallee = self.explodeExpression(calleePath);\n        }\n      } else {\n        newCallee = self.explodeViaTempVar(null, calleePath, hasLeapingChildren);\n\n        if (t.isMemberExpression(newCallee)) {\n          // If the callee was not previously a MemberExpression, then the\n          // CallExpression was \"unqualified,\" meaning its `this` object\n          // should be the global object. If the exploded expression has\n          // become a MemberExpression (e.g. a context property, probably a\n          // temporary variable), then we need to force it to be unqualified\n          // by using the (0, object.property)(...) trick; otherwise, it\n          // will receive the object of the MemberExpression as its `this`\n          // object.\n          newCallee = t.sequenceExpression([t.numericLiteral(0), t.cloneDeep(newCallee)]);\n        }\n      }\n\n      if (hasLeapingArgs) {\n        newArgs = argsPath.map(function (argPath) {\n          return self.explodeViaTempVar(null, argPath, hasLeapingChildren);\n        });\n        if (injectFirstArg) newArgs.unshift(injectFirstArg);\n        newArgs = newArgs.map(function (arg) {\n          return t.cloneDeep(arg);\n        });\n      } else {\n        newArgs = path.node.arguments;\n      }\n\n      return finish(t.callExpression(newCallee, newArgs));\n\n    case \"NewExpression\":\n      return finish(t.newExpression(self.explodeViaTempVar(null, path.get(\"callee\"), hasLeapingChildren), path.get(\"arguments\").map(function (argPath) {\n        return self.explodeViaTempVar(null, argPath, hasLeapingChildren);\n      })));\n\n    case \"ObjectExpression\":\n      return finish(t.objectExpression(path.get(\"properties\").map(function (propPath) {\n        if (propPath.isObjectProperty()) {\n          return t.objectProperty(propPath.node.key, self.explodeViaTempVar(null, propPath.get(\"value\"), hasLeapingChildren), propPath.node.computed);\n        } else {\n          return propPath.node;\n        }\n      })));\n\n    case \"ArrayExpression\":\n      return finish(t.arrayExpression(path.get(\"elements\").map(function (elemPath) {\n        if (elemPath.isSpreadElement()) {\n          return t.spreadElement(self.explodeViaTempVar(null, elemPath.get(\"argument\"), hasLeapingChildren));\n        } else {\n          return self.explodeViaTempVar(null, elemPath, hasLeapingChildren);\n        }\n      })));\n\n    case \"SequenceExpression\":\n      var lastIndex = expr.expressions.length - 1;\n      path.get(\"expressions\").forEach(function (exprPath) {\n        if (exprPath.key === lastIndex) {\n          result = self.explodeExpression(exprPath, ignoreResult);\n        } else {\n          self.explodeExpression(exprPath, true);\n        }\n      });\n      return result;\n\n    case \"LogicalExpression\":\n      after = this.loc();\n\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n\n      var left = self.explodeViaTempVar(result, path.get(\"left\"), hasLeapingChildren);\n\n      if (expr.operator === \"&&\") {\n        self.jumpIfNot(left, after);\n      } else {\n        _assert[\"default\"].strictEqual(expr.operator, \"||\");\n\n        self.jumpIf(left, after);\n      }\n\n      self.explodeViaTempVar(result, path.get(\"right\"), hasLeapingChildren, ignoreResult);\n      self.mark(after);\n      return result;\n\n    case \"ConditionalExpression\":\n      var elseLoc = this.loc();\n      after = this.loc();\n      var test = self.explodeExpression(path.get(\"test\"));\n      self.jumpIfNot(test, elseLoc);\n\n      if (!ignoreResult) {\n        result = self.makeTempVar();\n      }\n\n      self.explodeViaTempVar(result, path.get(\"consequent\"), hasLeapingChildren, ignoreResult);\n      self.jump(after);\n      self.mark(elseLoc);\n      self.explodeViaTempVar(result, path.get(\"alternate\"), hasLeapingChildren, ignoreResult);\n      self.mark(after);\n      return result;\n\n    case \"UnaryExpression\":\n      return finish(t.unaryExpression(expr.operator, // Can't (and don't need to) break up the syntax of the argument.\n      // Think about delete a[b].\n      self.explodeExpression(path.get(\"argument\")), !!expr.prefix));\n\n    case \"BinaryExpression\":\n      return finish(t.binaryExpression(expr.operator, self.explodeViaTempVar(null, path.get(\"left\"), hasLeapingChildren), self.explodeViaTempVar(null, path.get(\"right\"), hasLeapingChildren)));\n\n    case \"AssignmentExpression\":\n      if (expr.operator === \"=\") {\n        // If this is a simple assignment, the left hand side does not need\n        // to be read before the right hand side is evaluated, so we can\n        // avoid the more complicated logic below.\n        return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get(\"left\")), self.explodeExpression(path.get(\"right\"))));\n      }\n\n      var lhs = self.explodeExpression(path.get(\"left\"));\n      var temp = self.emitAssign(self.makeTempVar(), lhs); // For example,\n      //\n      //   x += yield y\n      //\n      // becomes\n      //\n      //   context.t0 = x\n      //   x = context.t0 += yield y\n      //\n      // so that the left-hand side expression is read before the yield.\n      // Fixes https://github.com/facebook/regenerator/issues/345.\n\n      return finish(t.assignmentExpression(\"=\", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get(\"right\")))));\n\n    case \"UpdateExpression\":\n      return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get(\"argument\")), expr.prefix));\n\n    case \"YieldExpression\":\n      after = this.loc();\n      var arg = expr.argument && self.explodeExpression(path.get(\"argument\"));\n\n      if (arg && expr.delegate) {\n        var _result = self.makeTempVar();\n\n        var _ret = t.returnStatement(t.callExpression(self.contextProperty(\"delegateYield\"), [arg, t.stringLiteral(_result.property.name), after]));\n\n        _ret.loc = expr.loc;\n        self.emit(_ret);\n        self.mark(after);\n        return _result;\n      }\n\n      self.emitAssign(self.contextProperty(\"next\"), after);\n      var ret = t.returnStatement(t.cloneDeep(arg) || null); // Preserve the `yield` location so that source mappings for the statements\n      // link back to the yield properly.\n\n      ret.loc = expr.loc;\n      self.emit(ret);\n      self.mark(after);\n      return self.contextProperty(\"sent\");\n\n    case \"ClassExpression\":\n      return finish(self.explodeClass(path));\n\n    default:\n      throw new Error(\"unknown Expression of type \" + JSON.stringify(expr.type));\n  }\n};\n\nEp.explodeClass = function (path) {\n  var explodingChildren = [];\n\n  if (path.node.superClass) {\n    explodingChildren.push(path.get(\"superClass\"));\n  }\n\n  path.get(\"body.body\").forEach(function (member) {\n    if (member.node.computed) {\n      explodingChildren.push(member.get(\"key\"));\n    }\n  });\n  var hasLeapingChildren = explodingChildren.some(function (child) {\n    return meta.containsLeap(child);\n  });\n\n  for (var i = 0; i < explodingChildren.length; i++) {\n    var child = explodingChildren[i];\n    var isLast = i === explodingChildren.length - 1;\n\n    if (isLast) {\n      child.replaceWith(this.explodeExpression(child));\n    } else {\n      child.replaceWith(this.explodeViaTempVar(null, child, hasLeapingChildren));\n    }\n  }\n\n  return path.node;\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}