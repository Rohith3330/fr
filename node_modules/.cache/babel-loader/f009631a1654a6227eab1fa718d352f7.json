{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = require(\"./buffer\");\n\nvar n = require(\"./node\");\n\nvar generatorFunctions = require(\"./generators\");\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\nconst {\n  needsParens,\n  needsWhitespaceAfter,\n  needsWhitespaceBefore\n} = n;\n\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._indentChar = 0;\n    this._indentRepeat = 0;\n    this._insideAux = false;\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new Set();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format;\n    this._buf = new _buffer.default(map);\n    this._indentChar = format.indent.style.charCodeAt(0);\n    this._indentRepeat = format.indent.style.length;\n  }\n\n  generate(ast) {\n    this.print(ast);\n\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n\n  semicolon() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    this._maybeAddAuxComment();\n\n    if (force) {\n      this._appendChar(59);\n    } else {\n      this._queue(59);\n    }\n  }\n\n  rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n\n    this.tokenChar(125);\n  }\n\n  space() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.format.compact) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n\n      if (lastCp !== 32 && lastCp !== 10) {\n        this._space();\n      }\n    }\n  }\n\n  word(str) {\n    if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str, false);\n\n    this._endsWithWord = true;\n  }\n\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;\n  }\n\n  token(str) {\n    let maybeNewline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n\n    if (lastChar === 33 && str === \"--\" || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str, maybeNewline);\n  }\n\n  tokenChar(char) {\n    const lastChar = this.getLastChar();\n\n    if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._appendChar(char);\n  }\n\n  newline() {\n    let i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    const charBeforeNewline = this.endsWithCharAndNewline();\n    if (charBeforeNewline === 10) return;\n\n    if (charBeforeNewline === 123 || charBeforeNewline === 58) {\n      i--;\n    }\n\n    if (i <= 0) return;\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(char) {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar() {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline() {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc, cb) {\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop, loc) {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  withSource(prop, loc, cb) {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space() {\n    this._queue(32);\n  }\n\n  _newline() {\n    this._queue(10);\n  }\n\n  _append(str, maybeNewline) {\n    this._maybeAddParen(str);\n\n    this._maybeIndent(str.charCodeAt(0));\n\n    this._buf.append(str, maybeNewline);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _appendChar(char) {\n    this._maybeAddParenChar(char);\n\n    this._maybeIndent(char);\n\n    this._buf.appendChar(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _queue(char) {\n    this._maybeAddParenChar(char);\n\n    this._maybeIndent(char);\n\n    this._buf.queue(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(firstChar) {\n    if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n      this._buf.queueIndentation(this._indentChar, this._getIndent());\n    }\n  }\n\n  _maybeAddParenChar(char) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n\n    if (char === 32) {\n      return;\n    }\n\n    if (char !== 10) {\n      this._parenPushNewlineState = null;\n      return;\n    }\n\n    this.tokenChar(40);\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    const len = str.length;\n    let i;\n\n    for (i = 0; i < len && str.charCodeAt(i) === 32; i++) continue;\n\n    if (i === len) {\n      return;\n    }\n\n    const cha = str.charCodeAt(i);\n\n    if (cha !== 10) {\n      if (cha !== 47 || i + 1 === len) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str.charCodeAt(i + 1);\n\n      if (chaPost === 42) {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {\n          return;\n        }\n      } else if (chaPost !== 47) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.tokenChar(40);\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    const pos = loc ? loc[prop] : null;\n\n    if ((pos == null ? void 0 : pos.line) != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  _getIndent() {\n    return this._indentRepeat * this._indent;\n  }\n\n  printTerminatorless(node, parent, isLabel) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      this.print(node, parent);\n      this._noLineTerminator = false;\n    } else {\n      const terminatorState = {\n        printed: false\n      };\n      this._parenPushNewlineState = terminatorState;\n      this.print(node, parent);\n\n      if (terminatorState.printed) {\n        this.dedent();\n        this.newline();\n        this.tokenChar(41);\n      }\n    }\n  }\n\n  print(node, parent, noLineTerminator) {\n    if (!node) return;\n    const nodeType = node.type;\n    const format = this.format;\n    const oldConcise = format.concise;\n\n    if (node._compact) {\n      format.concise = true;\n    }\n\n    const printMethod = this[nodeType];\n\n    if (printMethod === undefined) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == undefined;\n\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let shouldPrintParens;\n\n    if (format.retainFunctionParens && nodeType === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n      shouldPrintParens = true;\n    } else {\n      shouldPrintParens = needsParens(node, parent, this._printStack);\n    }\n\n    if (shouldPrintParens) this.tokenChar(40);\n\n    this._printLeadingComments(node);\n\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n    this.withSource(\"start\", loc, printMethod.bind(this, node, parent));\n\n    if (noLineTerminator && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n\n      this._printTrailingComments(node);\n\n      this._noLineTerminator = false;\n    } else {\n      this._printTrailingComments(node);\n    }\n\n    if (shouldPrintParens) this.tokenChar(41);\n\n    this._printStack.pop();\n\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  getPossibleRaw(node) {\n    const extra = node.extra;\n\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n\n  printJoin(nodes, parent) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!(nodes != null && nodes.length)) return;\n    if (opts.indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines\n    };\n    const len = nodes.length;\n\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < len - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent) {\n    const node = parent.body;\n\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node) {\n    this._printComments(this._getComments(false, node));\n  }\n\n  _printLeadingComments(node) {\n    this._printComments(this._getComments(true, node), true);\n  }\n\n  printInnerComments(node) {\n    let indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    var _node$innerComments;\n\n    if (!((_node$innerComments = node.innerComments) != null && _node$innerComments.length)) return;\n    if (indent) this.indent();\n\n    this._printComments(node.innerComments);\n\n    if (indent) this.dedent();\n  }\n\n  printSequence(nodes, parent) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items, parent) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(leading, node, parent, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    let lines = 0;\n\n    if (this._buf.hasContent()) {\n      if (!leading) lines++;\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n      const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(Math.min(2, lines));\n  }\n\n  _getComments(leading, node) {\n    return node && (leading ? node.leadingComments : node.trailingComments) || null;\n  }\n\n  _printComment(comment, skipNewLines) {\n    if (comment.ignore) return;\n    if (this._printedComments.has(comment)) return;\n    if (!this.format.shouldPrintComment(comment.value)) return;\n\n    this._printedComments.add(comment);\n\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent()) this.newline(1);\n    const lastCharCode = this.getLastChar();\n\n    if (lastCharCode !== 91 && lastCharCode !== 123) {\n      this.space();\n    }\n\n    let val;\n    let maybeNewline = false;\n\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n\n      if (this.format.indent.adjustMultilineComment) {\n        var _comment$loc;\n\n        const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n\n        const indentSize = Math.max(this._getIndent(), this.format.retainLines ? 0 : this._buf.getCurrentColumn());\n        val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n        maybeNewline = true;\n      }\n    } else if (!this._noLineTerminator) {\n      val = `//${comment.value}\\n`;\n      maybeNewline = true;\n    } else {\n      val = `/*${comment.value}*/`;\n    }\n\n    if (this.endsWith(47)) this._space();\n    this.withSource(\"start\", comment.loc, this._append.bind(this, val, maybeNewline));\n    if (printNewLines) this.newline(1);\n  }\n\n  _printComments(comments, inlinePureAnnotation) {\n    if (!(comments != null && comments.length)) return;\n\n    if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {\n      this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(10));\n    } else {\n      for (const comment of comments) {\n        this._printComment(comment);\n      }\n    }\n  }\n\n  printAssertions(node) {\n    var _node$assertions;\n\n    if ((_node$assertions = node.assertions) != null && _node$assertions.length) {\n      this.space();\n      this.word(\"assert\");\n      this.space();\n      this.tokenChar(123);\n      this.space();\n      this.printList(node.assertions, node);\n      this.space();\n      this.tokenChar(125);\n    }\n  }\n\n}\n\nObject.assign(Printer.prototype, generatorFunctions);\n{\n  Printer.prototype.Noop = function Noop() {};\n}\nvar _default = Printer;\nexports.default = _default;\n\nfunction commaSeparator() {\n  this.tokenChar(44);\n  this.space();\n}","map":{"version":3,"mappings":"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","names":["SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","NON_DECIMAL_LITERAL","PURE_ANNOTATION_RE","needsParens","needsWhitespaceAfter","needsWhitespaceBefore","n","Printer","constructor","format","map","inForStatementInitCounter","_printStack","_indent","_indentChar","_indentRepeat","_insideAux","_parenPushNewlineState","_noLineTerminator","_printAuxAfterOnNextUserNode","_printedComments","Set","_endsWithInteger","_endsWithWord","_buf","Buffer","indent","style","charCodeAt","length","generate","ast","print","_maybeAddAuxComment","get","compact","concise","dedent","semicolon","force","_appendChar","_queue","rightBrace","minified","removeLastSemicolon","token","space","_space","hasContent","lastCp","getLastChar","word","str","endsWith","_append","number","Number","isInteger","test","maybeNewline","lastChar","strFirst","tokenChar","char","newline","i","retainLines","charBeforeNewline","endsWithCharAndNewline","j","_newline","removeTrailingNewline","exactSource","loc","cb","_catchUp","source","prop","withSource","_maybeAddParen","_maybeIndent","append","_maybeAddParenChar","appendChar","queue","firstChar","queueIndentation","_getIndent","parenPushNewlineState","printed","len","cha","chaPost","slice","pos","line","count","getCurrentLine","printTerminatorless","node","parent","isLabel","terminatorState","noLineTerminator","nodeType","type","oldConcise","_compact","printMethod","undefined","ReferenceError","JSON","stringify","name","push","oldInAux","shouldPrintParens","retainFunctionParens","extra","parenthesized","_printLeadingComments","bind","_printTrailingComments","pop","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","auxiliaryCommentBefore","_printComment","value","auxiliaryCommentAfter","getPossibleRaw","raw","rawValue","printJoin","nodes","opts","newlineOpts","addNewlines","statement","_printNewline","iterator","separator","call","printAndIndentOnComments","leadingComments","printBlock","body","_printComments","_getComments","printInnerComments","innerComments","_node$innerComments","printSequence","printList","items","commaSeparator","leading","lines","needs","Math","min","trailingComments","skipNewLines","ignore","has","shouldPrintComment","add","isBlockComment","printNewLines","lastCharCode","val","adjustMultilineComment","offset","_comment$loc","start","column","newlineRegex","RegExp","replace","indentSize","max","getCurrentColumn","repeat","comments","inlinePureAnnotation","printAssertions","assertions","_node$assertions","Object","assign","prototype","generatorFunctions","Noop"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\generator\\src\\printer.ts"],"sourcesContent":["import Buffer from \"./buffer\";\nimport type { Loc } from \"./buffer\";\nimport * as n from \"./node\";\nimport type * as t from \"@babel/types\";\nimport type {\n  RecordAndTuplePluginOptions,\n  PipelineOperatorPluginOptions,\n} from \"@babel/parser\";\nimport type { Opts as jsescOptions } from \"jsesc\";\n\nimport * as generatorFunctions from \"./generators\";\nimport type SourceMap from \"./source-map\";\nimport * as charCodes from \"charcodes\";\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\n\nconst { needsParens, needsWhitespaceAfter, needsWhitespaceBefore } = n;\n\nexport type Format = {\n  shouldPrintComment: (comment: string) => boolean;\n  retainLines: boolean;\n  retainFunctionParens: boolean;\n  comments: boolean;\n  auxiliaryCommentBefore: string;\n  auxiliaryCommentAfter: string;\n  compact: boolean | \"auto\";\n  minified: boolean;\n  concise: boolean;\n  indent: {\n    adjustMultilineComment: boolean;\n    style: string;\n    base: number;\n  };\n  recordAndTupleSyntaxType: RecordAndTuplePluginOptions[\"syntaxType\"];\n  jsescOption: jsescOptions;\n  jsonCompatibleStrings?: boolean;\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodiesâ€™ topic references.\n   */\n  topicToken?: PipelineOperatorPluginOptions[\"topicToken\"];\n  /**\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n};\n\ninterface AddNewlinesOptions {\n  addNewlines(leading: boolean, node: t.Node): number;\n}\n\ninterface PrintSequenceOptions extends Partial<AddNewlinesOptions> {\n  statement?: boolean;\n  indent?: boolean;\n}\n\ninterface PrintListOptions {\n  separator?: (this: Printer) => void;\n  statement?: boolean;\n  indent?: boolean;\n}\n\ntype PrintJoinOptions = PrintListOptions &\n  PrintSequenceOptions & {\n    iterator?: (node: t.Node, index: number) => void;\n  };\nclass Printer {\n  constructor(format: Format, map: SourceMap) {\n    this.format = format;\n    this._buf = new Buffer(map);\n\n    this._indentChar = format.indent.style.charCodeAt(0);\n    this._indentRepeat = format.indent.style.length;\n  }\n\n  declare format: Format;\n  inForStatementInitCounter: number = 0;\n\n  declare _buf: Buffer;\n  _printStack: Array<t.Node> = [];\n  _indent: number = 0;\n  _indentChar: number = 0;\n  _indentRepeat: number = 0;\n  _insideAux: boolean = false;\n  _parenPushNewlineState: { printed: boolean } | null = null;\n  _noLineTerminator: boolean = false;\n  _printAuxAfterOnNextUserNode: boolean = false;\n  _printedComments = new Set<t.Comment>();\n  _endsWithInteger = false;\n  _endsWithWord = false;\n\n  generate(ast: t.Node) {\n    this.print(ast);\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  /**\n   * Increment indent size.\n   */\n\n  indent(): void {\n    if (this.format.compact || this.format.concise) return;\n\n    this._indent++;\n  }\n\n  /**\n   * Decrement indent size.\n   */\n\n  dedent(): void {\n    if (this.format.compact || this.format.concise) return;\n\n    this._indent--;\n  }\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n\n  semicolon(force: boolean = false): void {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(charCodes.semicolon);\n    } else {\n      this._queue(charCodes.semicolon);\n    }\n  }\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  rightBrace(): void {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.token(\"}\");\n  }\n\n  /**\n   * Add a space to the buffer unless it is compact.\n   */\n\n  space(force: boolean = false): void {\n    if (this.format.compact) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== charCodes.space && lastCp !== charCodes.lineFeed) {\n        this._space();\n      }\n    }\n  }\n\n  /**\n   * Writes a token that can't be safely parsed without taking whitespace into account.\n   */\n\n  word(str: string): void {\n    // prevent concatenating words and creating // comment out of division and regex\n    if (\n      this._endsWithWord ||\n      (str.charCodeAt(0) === charCodes.slash && this.endsWith(charCodes.slash))\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._append(str, false);\n\n    this._endsWithWord = true;\n  }\n\n  /**\n   * Writes a number token so that we can validate if it is an integer.\n   */\n\n  number(str: string): void {\n    this.word(str);\n\n    // Integer tokens need special handling because they cannot have '.'s inserted\n    // immediately after them.\n    this._endsWithInteger =\n      Number.isInteger(+str) &&\n      !NON_DECIMAL_LITERAL.test(str) &&\n      !SCIENTIFIC_NOTATION.test(str) &&\n      !ZERO_DECIMAL_INTEGER.test(str) &&\n      str.charCodeAt(str.length - 1) !== charCodes.dot;\n  }\n\n  /**\n   * Writes a simple token.\n   */\n\n  token(str: string, maybeNewline = false): void {\n    // space is mandatory to avoid outputting <!--\n    // http://javascript.spec.whatwg.org/#comment-syntax\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (\n      (lastChar === charCodes.exclamationMark && str === \"--\") ||\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (strFirst === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (strFirst === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (strFirst === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._append(str, maybeNewline);\n  }\n\n  tokenChar(char: number): void {\n    // space is mandatory to avoid outputting <!--\n    // http://javascript.spec.whatwg.org/#comment-syntax\n    const lastChar = this.getLastChar();\n    if (\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (char === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (char === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (char === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._appendChar(char);\n  }\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   */\n\n  newline(i: number = 1): void {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    const charBeforeNewline = this.endsWithCharAndNewline();\n    // never allow more than two lines\n    if (charBeforeNewline === charCodes.lineFeed) return;\n\n    if (\n      charBeforeNewline === charCodes.leftCurlyBrace ||\n      charBeforeNewline === charCodes.colon\n    ) {\n      i--;\n    }\n    if (i <= 0) return;\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(char: number): boolean {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar(): number {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline(): number {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline(): void {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc: Loc | undefined, cb: () => void) {\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  withSource(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    cb: () => void,\n  ): void {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space(): void {\n    this._queue(charCodes.space);\n  }\n\n  _newline(): void {\n    this._queue(charCodes.lineFeed);\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    this._maybeAddParen(str);\n    this._maybeIndent(str.charCodeAt(0));\n\n    this._buf.append(str, maybeNewline);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _appendChar(char: number): void {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n\n    this._buf.appendChar(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _queue(char: number) {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n\n    this._buf.queue(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(firstChar: number): void {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      this._buf.queueIndentation(this._indentChar, this._getIndent());\n    }\n  }\n\n  _maybeAddParenChar(char: number): void {\n    // see startTerminatorless() instance method\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n\n    // This function does two things:\n    // - If needed, prints a parenthesis\n    // - If the currently printed string removes the need for the paren,\n    //   it resets the _parenPushNewlineState field.\n    //   Almost everything removes the need for a paren, except for\n    //   comments and whitespaces.\n\n    if (char === charCodes.space) {\n      // Whitespaces only, the parentheses might still be needed.\n      return;\n    }\n\n    // Check for newline or comment.\n    if (char !== charCodes.lineFeed) {\n      this._parenPushNewlineState = null;\n      return;\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _maybeAddParen(str: string): void {\n    // see startTerminatorless() instance method\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n\n    // This function does two things:\n    // - If needed, prints a parenthesis\n    // - If the currently printed string removes the need for the paren,\n    //   it resets the _parenPushNewlineState field.\n    //   Almost everything removes the need for a paren, except for\n    //   comments and whitespaces.\n\n    const len = str.length;\n\n    let i;\n    for (i = 0; i < len && str.charCodeAt(i) === charCodes.space; i++) continue;\n    if (i === len) {\n      // Whitespaces only, the parentheses might still be needed.\n      return;\n    }\n\n    // Check for newline or comment.\n    const cha = str.charCodeAt(i);\n    if (cha !== charCodes.lineFeed) {\n      if (\n        // This is not a comment (it doesn't start with /)\n        cha !== charCodes.slash ||\n        // This is not a comment (it's a / operator)\n        i + 1 === len\n      ) {\n        // After a normal token, the parentheses aren't needed anymore\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str.charCodeAt(i + 1);\n\n      if (chaPost === charCodes.asterisk) {\n        // This is a block comment\n\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {\n          // We avoid printing newlines after #__PURE__ comments (we treat\n          // then as unary operators), but we must keep the old\n          // parenPushNewlineState because, if a newline was forbidden, it is\n          // still forbidden after the comment.\n          return;\n        }\n\n        // NOTE: code flow continues from here to after these if/elses\n      } else if (chaPost !== charCodes.slash) {\n        // This is neither a block comment, nor a line comment.\n        // After a normal token, the parentheses aren't needed anymore\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _catchUp(prop: \"start\" | \"end\", loc?: Loc) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const pos = loc ? loc[prop] : null;\n    if (pos?.line != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  /**\n   * Get the current indent.\n   */\n\n  _getIndent(): number {\n    return this._indentRepeat * this._indent;\n  }\n\n  printTerminatorless(node: t.Node, parent: t.Node, isLabel: boolean) {\n    /**\n     * Set some state that will be modified if a newline has been inserted before any\n     * non-space characters.\n     *\n     * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n     *\n     *   return foo;\n     *\n     * returns `foo`. But if we do:\n     *\n     *   return\n     *   foo;\n     *\n     *  `undefined` will be returned and not `foo` due to the terminator.\n     */\n    if (isLabel) {\n      this._noLineTerminator = true;\n      this.print(node, parent);\n      this._noLineTerminator = false;\n    } else {\n      const terminatorState = {\n        printed: false,\n      };\n      this._parenPushNewlineState = terminatorState;\n      this.print(node, parent);\n      /**\n       * Print an ending parentheses if a starting one has been printed.\n       */\n      if (terminatorState.printed) {\n        this.dedent();\n        this.newline();\n        this.token(\")\");\n      }\n    }\n  }\n\n  print(node: t.Node | null, parent?: t.Node, noLineTerminator?: boolean) {\n    if (!node) return;\n\n    const nodeType = node.type;\n    const format = this.format;\n\n    const oldConcise = format.concise;\n    if (\n      // @ts-expect-error document _compact AST properties\n      node._compact\n    ) {\n      format.concise = true;\n    }\n\n    const printMethod =\n      this[\n        nodeType as Exclude<\n          t.Node[\"type\"],\n          // removed\n          | \"Noop\"\n          // renamed\n          | t.DeprecatedAliases[\"type\"]\n        >\n      ];\n    if (printMethod === undefined) {\n      throw new ReferenceError(\n        `unknown node of type ${JSON.stringify(\n          nodeType,\n        )} with constructor ${JSON.stringify(node.constructor.name)}`,\n      );\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == undefined;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let shouldPrintParens: boolean;\n    if (\n      format.retainFunctionParens &&\n      nodeType === \"FunctionExpression\" &&\n      node.extra &&\n      node.extra.parenthesized\n    ) {\n      shouldPrintParens = true;\n    } else {\n      shouldPrintParens = needsParens(node, parent, this._printStack);\n    }\n    if (shouldPrintParens) this.token(\"(\");\n\n    this._printLeadingComments(node);\n\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n\n    this.withSource(\"start\", loc, printMethod.bind(this, node, parent));\n\n    if (noLineTerminator && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node);\n      this._noLineTerminator = false;\n    } else {\n      this._printTrailingComments(node);\n    }\n\n    if (shouldPrintParens) this.token(\")\");\n\n    // end\n    this._printStack.pop();\n\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode?: boolean) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment,\n      });\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment,\n      });\n    }\n  }\n\n  getPossibleRaw(\n    node:\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral\n      | t.DecimalLiteral\n      | t.DirectiveLiteral\n      | t.JSXText,\n  ): string | undefined {\n    const extra = node.extra;\n    if (\n      extra &&\n      extra.raw != null &&\n      extra.rawValue != null &&\n      node.value === extra.rawValue\n    ) {\n      // @ts-expect-error: The extra.raw of these AST node types must be a string\n      return extra.raw;\n    }\n  }\n\n  printJoin(\n    nodes: Array<t.Node> | undefined | null,\n    parent: t.Node,\n    opts: PrintJoinOptions = {},\n  ) {\n    if (!nodes?.length) return;\n\n    if (opts.indent) this.indent();\n\n    const newlineOpts: AddNewlinesOptions = {\n      addNewlines: opts.addNewlines,\n    };\n\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < len - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node: t.Node, parent: t.Node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent: Extract<t.Node, { body: t.Statement }>) {\n    const node = parent.body;\n\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node: t.Node) {\n    this._printComments(this._getComments(false, node));\n  }\n\n  _printLeadingComments(node: t.Node) {\n    this._printComments(\n      this._getComments(true, node),\n      // Don't add leading/trailing new lines to #__PURE__ annotations\n      true,\n    );\n  }\n\n  printInnerComments(node: t.Node, indent = true) {\n    if (!node.innerComments?.length) return;\n    if (indent) this.indent();\n    this._printComments(node.innerComments);\n    if (indent) this.dedent();\n  }\n\n  printSequence(\n    nodes: t.Node[],\n    parent: t.Node,\n    opts: PrintSequenceOptions = {},\n  ) {\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items: t.Node[], parent: t.Node, opts: PrintListOptions = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(\n    leading: boolean,\n    node: t.Node,\n    parent: t.Node,\n    opts: AddNewlinesOptions,\n  ) {\n    // Fast path since 'this.newline' does nothing when not tracking lines.\n    if (this.format.retainLines || this.format.compact) return;\n\n    // Fast path for concise since 'this.newline' just inserts a space when\n    // concise formatting is in use.\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    let lines = 0;\n    // don't add newlines at the beginning of the file\n    if (this._buf.hasContent()) {\n      if (!leading) lines++; // always include at least a single line after\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n\n      const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(Math.min(2, lines));\n  }\n\n  _getComments(leading: boolean, node: t.Node) {\n    // Note, we use a boolean flag here instead of passing in the attribute name as it is faster\n    // because this is called extremely frequently.\n    return (\n      (node && (leading ? node.leadingComments : node.trailingComments)) || null\n    );\n  }\n\n  _printComment(comment: t.Comment, skipNewLines?: boolean) {\n    // Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,\n    // where they can't manually mutate the AST node comment lists.\n    if (comment.ignore) return;\n\n    if (this._printedComments.has(comment)) return;\n\n    if (!this.format.shouldPrintComment(comment.value)) return;\n\n    this._printedComments.add(comment);\n\n    const isBlockComment = comment.type === \"CommentBlock\";\n\n    // Add a newline before and after a block comment, unless explicitly\n    // disallowed\n    const printNewLines =\n      isBlockComment && !skipNewLines && !this._noLineTerminator;\n\n    if (printNewLines && this._buf.hasContent()) this.newline(1);\n\n    const lastCharCode = this.getLastChar();\n    if (\n      lastCharCode !== charCodes.leftSquareBracket &&\n      lastCharCode !== charCodes.leftCurlyBrace\n    ) {\n      this.space();\n    }\n\n    let val;\n    let maybeNewline = false;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        const offset = comment.loc?.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n\n        const indentSize = Math.max(\n          this._getIndent(),\n          this.format.retainLines ? 0 : this._buf.getCurrentColumn(),\n        );\n        val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n\n        maybeNewline = true;\n      }\n    } else if (!this._noLineTerminator) {\n      val = `//${comment.value}\\n`;\n      maybeNewline = true;\n    } else {\n      val = `/*${comment.value}*/`;\n    }\n\n    // Avoid creating //* comments\n    if (this.endsWith(charCodes.slash)) this._space();\n\n    this.withSource(\n      \"start\",\n      comment.loc,\n      this._append.bind(this, val, maybeNewline),\n    );\n\n    if (printNewLines) this.newline(1);\n  }\n\n  _printComments(\n    comments?: readonly t.Comment[],\n    inlinePureAnnotation?: boolean,\n  ) {\n    if (!comments?.length) return;\n\n    if (\n      inlinePureAnnotation &&\n      comments.length === 1 &&\n      PURE_ANNOTATION_RE.test(comments[0].value)\n    ) {\n      this._printComment(\n        comments[0],\n        // Keep newlines if the comment marks a standalone call\n        this._buf.hasContent() && !this.endsWith(charCodes.lineFeed),\n      );\n    } else {\n      for (const comment of comments) {\n        this._printComment(comment);\n      }\n    }\n  }\n  // todo(flow->ts): was Node\n  printAssertions(node: Extract<t.Node, { assertions?: t.ImportAttribute[] }>) {\n    if (node.assertions?.length) {\n      this.space();\n      this.word(\"assert\");\n      this.space();\n      this.token(\"{\");\n      this.space();\n      this.printList(node.assertions, node);\n      this.space();\n      this.token(\"}\");\n    }\n  }\n}\n\n// Expose the node type functions and helpers on the prototype for easy usage.\nObject.assign(Printer.prototype, generatorFunctions);\n\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-ignore(Babel 7 vs Babel 8) Babel 7 has Noop print method\n  Printer.prototype.Noop = function Noop(this: Printer) {};\n}\n\ntype GeneratorFunctions = typeof generatorFunctions;\ninterface Printer extends GeneratorFunctions {}\nexport default Printer;\n\nfunction commaSeparator(this: Printer) {\n  this.token(\",\");\n  this.space();\n}\n"]},"metadata":{},"sourceType":"script"}