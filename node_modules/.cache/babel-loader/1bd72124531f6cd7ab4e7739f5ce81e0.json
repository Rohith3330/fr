{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\n\nvar core = require('@babel/core');\n\nfunction unshiftForXStatementBody(statementPath, newStatements) {\n  statementPath.ensureBlock();\n  const {\n    scope,\n    node\n  } = statementPath;\n  const bodyScopeBindings = statementPath.get(\"body\").scope.bindings;\n  const hasShadowedBlockScopedBindings = Object.keys(bodyScopeBindings).some(name => scope.hasBinding(name));\n\n  if (hasShadowedBlockScopedBindings) {\n    node.body = core.types.blockStatement([...newStatements, node.body]);\n  } else {\n    node.body.body.unshift(...newStatements);\n  }\n}\n\nfunction hasArrayRest(pattern) {\n  return pattern.elements.some(elem => core.types.isRestElement(elem));\n}\n\nfunction hasObjectRest(pattern) {\n  return pattern.properties.some(prop => core.types.isRestElement(prop));\n}\n\nconst STOP_TRAVERSAL = {};\n\nconst arrayUnpackVisitor = (node, ancestors, state) => {\n  if (!ancestors.length) {\n    return;\n  }\n\n  if (core.types.isIdentifier(node) && core.types.isReferenced(node, ancestors[ancestors.length - 1].node) && state.bindings[node.name]) {\n    state.deopt = true;\n    throw STOP_TRAVERSAL;\n  }\n};\n\nclass DestructuringTransformer {\n  constructor(opts) {\n    this.blockHoist = void 0;\n    this.operator = void 0;\n    this.arrayRefSet = void 0;\n    this.nodes = void 0;\n    this.scope = void 0;\n    this.kind = void 0;\n    this.iterableIsArray = void 0;\n    this.arrayLikeIsIterable = void 0;\n    this.objectRestNoSymbols = void 0;\n    this.useBuiltIns = void 0;\n    this.addHelper = void 0;\n    this.blockHoist = opts.blockHoist;\n    this.operator = opts.operator;\n    this.arrayRefSet = new Set();\n    this.nodes = opts.nodes || [];\n    this.scope = opts.scope;\n    this.kind = opts.kind;\n    this.iterableIsArray = opts.iterableIsArray;\n    this.arrayLikeIsIterable = opts.arrayLikeIsIterable;\n    this.objectRestNoSymbols = opts.objectRestNoSymbols;\n    this.useBuiltIns = opts.useBuiltIns;\n    this.addHelper = opts.addHelper;\n  }\n\n  getExtendsHelper() {\n    return this.useBuiltIns ? core.types.memberExpression(core.types.identifier(\"Object\"), core.types.identifier(\"assign\")) : this.addHelper(\"extends\");\n  }\n\n  buildVariableAssignment(id, init) {\n    let op = this.operator;\n    if (core.types.isMemberExpression(id)) op = \"=\";\n    let node;\n\n    if (op) {\n      node = core.types.expressionStatement(core.types.assignmentExpression(op, id, core.types.cloneNode(init) || this.scope.buildUndefinedNode()));\n    } else {\n      let nodeInit;\n\n      if (this.kind === \"const\" && init === null) {\n        nodeInit = this.scope.buildUndefinedNode();\n      } else {\n        nodeInit = core.types.cloneNode(init);\n      }\n\n      node = core.types.variableDeclaration(this.kind, [core.types.variableDeclarator(id, nodeInit)]);\n    }\n\n    node._blockHoist = this.blockHoist;\n    return node;\n  }\n\n  buildVariableDeclaration(id, init) {\n    const declar = core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(core.types.cloneNode(id), core.types.cloneNode(init))]);\n    declar._blockHoist = this.blockHoist;\n    return declar;\n  }\n\n  push(id, _init) {\n    const init = core.types.cloneNode(_init);\n\n    if (core.types.isObjectPattern(id)) {\n      this.pushObjectPattern(id, init);\n    } else if (core.types.isArrayPattern(id)) {\n      this.pushArrayPattern(id, init);\n    } else if (core.types.isAssignmentPattern(id)) {\n      this.pushAssignmentPattern(id, init);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(id, init));\n    }\n  }\n\n  toArray(node, count) {\n    if (this.iterableIsArray || core.types.isIdentifier(node) && this.arrayRefSet.has(node.name)) {\n      return node;\n    } else {\n      return this.scope.toArray(node, count, this.arrayLikeIsIterable);\n    }\n  }\n\n  pushAssignmentPattern(_ref4, valueRef) {\n    let {\n      left,\n      right\n    } = _ref4;\n\n    if (valueRef === null) {\n      this.push(left, right);\n      return;\n    }\n\n    const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n    this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));\n    const tempConditional = core.types.conditionalExpression(core.types.binaryExpression(\"===\", core.types.cloneNode(tempId), this.scope.buildUndefinedNode()), right, core.types.cloneNode(tempId));\n\n    if (core.types.isPattern(left)) {\n      let patternId;\n      let node;\n\n      if (this.kind === \"const\" || this.kind === \"let\") {\n        patternId = this.scope.generateUidIdentifier(tempId.name);\n        node = this.buildVariableDeclaration(patternId, tempConditional);\n      } else {\n        patternId = tempId;\n        node = core.types.expressionStatement(core.types.assignmentExpression(\"=\", core.types.cloneNode(tempId), tempConditional));\n      }\n\n      this.nodes.push(node);\n      this.push(left, patternId);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n    }\n  }\n\n  pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {\n    const value = buildObjectExcludingKeys(pattern.properties.slice(0, spreadPropIndex), objRef, this.scope, name => this.addHelper(name), this.objectRestNoSymbols, this.useBuiltIns);\n    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n  }\n\n  pushObjectProperty(prop, propRef) {\n    if (core.types.isLiteral(prop.key)) prop.computed = true;\n    const pattern = prop.value;\n    const objRef = core.types.memberExpression(core.types.cloneNode(propRef), prop.key, prop.computed);\n\n    if (core.types.isPattern(pattern)) {\n      this.push(pattern, objRef);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n    }\n  }\n\n  pushObjectPattern(pattern, objRef) {\n    if (!pattern.properties.length || objRef === null) {\n      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper(\"objectDestructuringEmpty\"), objRef !== null ? [objRef] : [])));\n      return;\n    }\n\n    if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n      const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n      this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n      objRef = temp;\n    }\n\n    if (hasObjectRest(pattern)) {\n      let copiedPattern;\n\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n\n        if (core.types.isRestElement(prop)) {\n          break;\n        }\n\n        const key = prop.key;\n\n        if (prop.computed && !this.scope.isPure(key)) {\n          const name = this.scope.generateUidIdentifierBasedOnNode(key);\n          this.nodes.push(this.buildVariableDeclaration(name, key));\n\n          if (!copiedPattern) {\n            copiedPattern = pattern = Object.assign({}, pattern, {\n              properties: pattern.properties.slice()\n            });\n          }\n\n          copiedPattern.properties[i] = Object.assign({}, prop, {\n            key: name\n          });\n        }\n      }\n    }\n\n    for (let i = 0; i < pattern.properties.length; i++) {\n      const prop = pattern.properties[i];\n\n      if (core.types.isRestElement(prop)) {\n        this.pushObjectRest(pattern, objRef, prop, i);\n      } else {\n        this.pushObjectProperty(prop, objRef);\n      }\n    }\n  }\n\n  canUnpackArrayPattern(pattern, arr) {\n    if (!core.types.isArrayExpression(arr)) return false;\n    if (pattern.elements.length > arr.elements.length) return;\n\n    if (pattern.elements.length < arr.elements.length && !hasArrayRest(pattern)) {\n      return false;\n    }\n\n    for (const elem of pattern.elements) {\n      if (!elem) return false;\n      if (core.types.isMemberExpression(elem)) return false;\n    }\n\n    for (const elem of arr.elements) {\n      if (core.types.isSpreadElement(elem)) return false;\n      if (core.types.isCallExpression(elem)) return false;\n      if (core.types.isMemberExpression(elem)) return false;\n    }\n\n    const bindings = core.types.getBindingIdentifiers(pattern);\n    const state = {\n      deopt: false,\n      bindings\n    };\n\n    try {\n      core.types.traverse(arr, arrayUnpackVisitor, state);\n    } catch (e) {\n      if (e !== STOP_TRAVERSAL) throw e;\n    }\n\n    return !state.deopt;\n  }\n\n  pushUnpackedArrayPattern(pattern, arr) {\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n\n      if (core.types.isRestElement(elem)) {\n        this.push(elem.argument, core.types.arrayExpression(arr.elements.slice(i)));\n      } else {\n        this.push(elem, arr.elements[i]);\n      }\n    }\n  }\n\n  pushArrayPattern(pattern, arrayRef) {\n    if (arrayRef === null) {\n      this.nodes.push(core.types.expressionStatement(core.types.callExpression(this.addHelper(\"objectDestructuringEmpty\"), [])));\n      return;\n    }\n\n    if (!pattern.elements) return;\n\n    if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n      return this.pushUnpackedArrayPattern(pattern, arrayRef);\n    }\n\n    const count = !hasArrayRest(pattern) && pattern.elements.length;\n    const toArray = this.toArray(arrayRef, count);\n\n    if (core.types.isIdentifier(toArray)) {\n      arrayRef = toArray;\n    } else {\n      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n      this.arrayRefSet.add(arrayRef.name);\n      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n    }\n\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n      if (!elem) continue;\n      let elemRef;\n\n      if (core.types.isRestElement(elem)) {\n        elemRef = this.toArray(arrayRef);\n        elemRef = core.types.callExpression(core.types.memberExpression(elemRef, core.types.identifier(\"slice\")), [core.types.numericLiteral(i)]);\n        this.push(elem.argument, elemRef);\n      } else {\n        elemRef = core.types.memberExpression(arrayRef, core.types.numericLiteral(i), true);\n        this.push(elem, elemRef);\n      }\n    }\n  }\n\n  init(pattern, ref) {\n    if (!core.types.isArrayExpression(ref) && !core.types.isMemberExpression(ref)) {\n      const memo = this.scope.maybeGenerateMemoised(ref, true);\n\n      if (memo) {\n        this.nodes.push(this.buildVariableDeclaration(memo, core.types.cloneNode(ref)));\n        ref = memo;\n      }\n    }\n\n    this.push(pattern, ref);\n    return this.nodes;\n  }\n\n}\n\nfunction buildObjectExcludingKeys(excludedKeys, objRef, scope, addHelper, objectRestNoSymbols, useBuiltIns) {\n  const keys = [];\n  let allLiteral = true;\n  let hasTemplateLiteral = false;\n\n  for (let i = 0; i < excludedKeys.length; i++) {\n    const prop = excludedKeys[i];\n    const key = prop.key;\n\n    if (core.types.isIdentifier(key) && !prop.computed) {\n      keys.push(core.types.stringLiteral(key.name));\n    } else if (core.types.isTemplateLiteral(key)) {\n      keys.push(core.types.cloneNode(key));\n      hasTemplateLiteral = true;\n    } else if (core.types.isLiteral(key)) {\n      keys.push(core.types.stringLiteral(String(key.value)));\n    } else if (core.types.isPrivateName(key)) ;else {\n      keys.push(core.types.cloneNode(key));\n      allLiteral = false;\n    }\n  }\n\n  let value;\n\n  if (keys.length === 0) {\n    const extendsHelper = useBuiltIns ? core.types.memberExpression(core.types.identifier(\"Object\"), core.types.identifier(\"assign\")) : addHelper(\"extends\");\n    value = core.types.callExpression(extendsHelper, [core.types.objectExpression([]), core.types.cloneNode(objRef)]);\n  } else {\n    let keyExpression = core.types.arrayExpression(keys);\n\n    if (!allLiteral) {\n      keyExpression = core.types.callExpression(core.types.memberExpression(keyExpression, core.types.identifier(\"map\")), [addHelper(\"toPropertyKey\")]);\n    } else if (!hasTemplateLiteral && !core.types.isProgram(scope.block)) {\n      const programScope = scope.getProgramParent();\n      const id = programScope.generateUidIdentifier(\"excluded\");\n      programScope.push({\n        id,\n        init: keyExpression,\n        kind: \"const\"\n      });\n      keyExpression = core.types.cloneNode(id);\n    }\n\n    value = core.types.callExpression(addHelper(`objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`), [core.types.cloneNode(objRef), keyExpression]);\n  }\n\n  return value;\n}\n\nfunction convertVariableDeclaration(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {\n  const {\n    node,\n    scope\n  } = path;\n  const nodeKind = node.kind;\n  const nodeLoc = node.loc;\n  const nodes = [];\n\n  for (let i = 0; i < node.declarations.length; i++) {\n    const declar = node.declarations[i];\n    const patternId = declar.init;\n    const pattern = declar.id;\n    const destructuring = new DestructuringTransformer({\n      blockHoist: node._blockHoist,\n      nodes: nodes,\n      scope: scope,\n      kind: node.kind,\n      iterableIsArray,\n      arrayLikeIsIterable,\n      useBuiltIns,\n      objectRestNoSymbols,\n      addHelper\n    });\n\n    if (core.types.isPattern(pattern)) {\n      destructuring.init(pattern, patternId);\n\n      if (+i !== node.declarations.length - 1) {\n        core.types.inherits(nodes[nodes.length - 1], declar);\n      }\n    } else {\n      nodes.push(core.types.inherits(destructuring.buildVariableAssignment(pattern, patternId), declar));\n    }\n  }\n\n  const inForInit = core.types.isForStatement(path.parent, {\n    init: node\n  });\n  let tail = null;\n  const nodesOut = [];\n\n  for (const node of nodes) {\n    if (core.types.isVariableDeclaration(node)) {\n      if (tail !== null) {\n        tail.declarations.push(...node.declarations);\n        continue;\n      } else {\n        node.kind = nodeKind;\n        tail = node;\n      }\n    } else {\n      tail = null;\n    }\n\n    if (!node.loc) {\n      node.loc = nodeLoc;\n    }\n\n    nodesOut.push(inForInit && node.type === \"ExpressionStatement\" ? node.expression : node);\n  }\n\n  if (nodesOut.length === 1) {\n    path.replaceWith(nodesOut[0]);\n  } else {\n    path.replaceWithMultiple(nodesOut);\n  }\n\n  scope.crawl();\n}\n\nfunction convertAssignmentExpression(path, addHelper, arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns) {\n  const {\n    node,\n    scope,\n    parentPath\n  } = path;\n  const nodes = [];\n  const destructuring = new DestructuringTransformer({\n    operator: node.operator,\n    scope: scope,\n    nodes: nodes,\n    arrayLikeIsIterable,\n    iterableIsArray,\n    objectRestNoSymbols,\n    useBuiltIns,\n    addHelper\n  });\n  let ref;\n\n  if (!parentPath.isExpressionStatement() && !parentPath.isSequenceExpression() || path.isCompletionRecord()) {\n    ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n    nodes.push(core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(ref, node.right)]));\n\n    if (core.types.isArrayExpression(node.right)) {\n      destructuring.arrayRefSet.add(ref.name);\n    }\n  }\n\n  destructuring.init(node.left, ref || node.right);\n\n  if (ref) {\n    if (parentPath.isArrowFunctionExpression()) {\n      path.replaceWith(core.types.blockStatement([]));\n      nodes.push(core.types.returnStatement(core.types.cloneNode(ref)));\n    } else {\n      nodes.push(core.types.expressionStatement(core.types.cloneNode(ref)));\n    }\n  }\n\n  path.replaceWithMultiple(nodes);\n  scope.crawl();\n}\n\nfunction variableDeclarationHasPattern(node) {\n  for (const declar of node.declarations) {\n    if (core.types.isPattern(declar.id)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar index = helperPluginUtils.declare((api, options) => {\n  var _ref, _api$assumption, _ref2, _options$allowArrayLi, _ref3, _api$assumption2;\n\n  api.assertVersion(7);\n  const {\n    useBuiltIns = false\n  } = options;\n  const iterableIsArray = (_ref = (_api$assumption = api.assumption(\"iterableIsArray\")) != null ? _api$assumption : options.loose) != null ? _ref : false;\n  const arrayLikeIsIterable = (_ref2 = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption(\"arrayLikeIsIterable\")) != null ? _ref2 : false;\n  const objectRestNoSymbols = (_ref3 = (_api$assumption2 = api.assumption(\"objectRestNoSymbols\")) != null ? _api$assumption2 : options.loose) != null ? _ref3 : false;\n  return {\n    name: \"transform-destructuring\",\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers())) {\n          specifiers.push(core.types.exportSpecifier(core.types.identifier(name), core.types.identifier(name)));\n        }\n\n        path.replaceWith(declaration.node);\n        path.insertAfter(core.types.exportNamedDeclaration(null, specifiers));\n        path.scope.crawl();\n      },\n\n      ForXStatement(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const left = node.left;\n\n        if (core.types.isPattern(left)) {\n          const temp = scope.generateUidIdentifier(\"ref\");\n          node.left = core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(temp)]);\n          path.ensureBlock();\n          const statementBody = path.node.body.body;\n          const nodes = [];\n\n          if (statementBody.length === 0 && path.isCompletionRecord()) {\n            nodes.unshift(core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          nodes.unshift(core.types.expressionStatement(core.types.assignmentExpression(\"=\", left, core.types.cloneNode(temp))));\n          unshiftForXStatementBody(path, nodes);\n          scope.crawl();\n          return;\n        }\n\n        if (!core.types.isVariableDeclaration(left)) return;\n        const pattern = left.declarations[0].id;\n        if (!core.types.isPattern(pattern)) return;\n        const key = scope.generateUidIdentifier(\"ref\");\n        node.left = core.types.variableDeclaration(left.kind, [core.types.variableDeclarator(key, null)]);\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, key);\n        unshiftForXStatementBody(path, nodes);\n        scope.crawl();\n      },\n\n      CatchClause(_ref5) {\n        let {\n          node,\n          scope\n        } = _ref5;\n        const pattern = node.param;\n        if (!core.types.isPattern(pattern)) return;\n        const ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n        const nodes = [];\n        const destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name)\n        });\n        destructuring.init(pattern, ref);\n        node.body.body = [...nodes, ...node.body.body];\n        scope.crawl();\n      },\n\n      AssignmentExpression(path, state) {\n        if (!core.types.isPattern(path.node.left)) return;\n        convertAssignmentExpression(path, name => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);\n      },\n\n      VariableDeclaration(path, state) {\n        const {\n          node,\n          parent\n        } = path;\n        if (core.types.isForXStatement(parent)) return;\n        if (!parent || !path.container) return;\n        if (!variableDeclarationHasPattern(node)) return;\n        convertVariableDeclaration(path, name => state.addHelper(name), arrayLikeIsIterable, iterableIsArray, objectRestNoSymbols, useBuiltIns);\n      }\n\n    }\n  };\n});\nexports.buildObjectExcludingKeys = buildObjectExcludingKeys;\nexports[\"default\"] = index;\nexports.unshiftForXStatementBody = unshiftForXStatementBody;","map":{"version":3,"mappings":"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","names":["unshiftForXStatementBody","statementPath","newStatements","ensureBlock","scope","node","bodyScopeBindings","get","bindings","hasShadowedBlockScopedBindings","Object","keys","some","name","hasBinding","body","t","blockStatement","unshift","hasArrayRest","pattern","elements","elem","isRestElement","hasObjectRest","properties","prop","STOP_TRAVERSAL","arrayUnpackVisitor","ancestors","state","length","isIdentifier","isReferenced","deopt","DestructuringTransformer","constructor","opts","blockHoist","operator","arrayRefSet","nodes","kind","iterableIsArray","arrayLikeIsIterable","objectRestNoSymbols","useBuiltIns","addHelper","Set","getExtendsHelper","memberExpression","identifier","buildVariableAssignment","id","init","op","isMemberExpression","expressionStatement","assignmentExpression","cloneNode","buildUndefinedNode","nodeInit","variableDeclaration","variableDeclarator","_blockHoist","buildVariableDeclaration","declar","push","_init","isObjectPattern","pushObjectPattern","isArrayPattern","pushArrayPattern","isAssignmentPattern","pushAssignmentPattern","toArray","count","has","valueRef","left","right","tempId","generateUidIdentifierBasedOnNode","tempConditional","conditionalExpression","binaryExpression","isPattern","patternId","generateUidIdentifier","pushObjectRest","objRef","spreadProp","spreadPropIndex","value","buildObjectExcludingKeys","slice","argument","pushObjectProperty","propRef","isLiteral","key","computed","callExpression","isStatic","temp","copiedPattern","i","isPure","canUnpackArrayPattern","arr","isArrayExpression","isSpreadElement","isCallExpression","getBindingIdentifiers","traverse","e","pushUnpackedArrayPattern","arrayExpression","arrayRef","add","elemRef","numericLiteral","ref","memo","maybeGenerateMemoised","excludedKeys","allLiteral","hasTemplateLiteral","stringLiteral","isTemplateLiteral","String","isPrivateName","extendsHelper","objectExpression","keyExpression","isProgram","block","programScope","getProgramParent","convertVariableDeclaration","path","nodeKind","nodeLoc","loc","declarations","destructuring","inherits","inForInit","isForStatement","parent","tail","nodesOut","isVariableDeclaration","type","expression","replaceWith","replaceWithMultiple","crawl","convertAssignmentExpression","parentPath","isExpressionStatement","isSequenceExpression","isCompletionRecord","isArrowFunctionExpression","returnStatement","variableDeclarationHasPattern","declare","api","options","assertVersion","assumption","loose","allowArrayLike","visitor","ExportNamedDeclaration","declaration","specifiers","getOuterBindingIdentifiers","exportSpecifier","insertAfter","exportNamedDeclaration","ForXStatement","statementBody","CatchClause","param","AssignmentExpression","VariableDeclaration","isForXStatement","container"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-transform-destructuring\\src\\util.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-transform-destructuring\\src\\index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\nimport type { File } from \"@babel/core\";\nimport type { Scope, NodePath } from \"@babel/traverse\";\nimport type { TraversalAncestors } from \"@babel/types\";\n\nexport function unshiftForXStatementBody(\n  statementPath: NodePath<t.ForXStatement>,\n  newStatements: t.Statement[],\n) {\n  statementPath.ensureBlock();\n  const { scope, node } = statementPath;\n  const bodyScopeBindings = statementPath.get(\"body\").scope.bindings;\n  const hasShadowedBlockScopedBindings = Object.keys(bodyScopeBindings).some(\n    name => scope.hasBinding(name),\n  );\n\n  if (hasShadowedBlockScopedBindings) {\n    // handle shadowed variables referenced in computed keys:\n    // var a = 0;for (const { #x: x, [a++]: y } of z) { const a = 1; }\n    node.body = t.blockStatement([...newStatements, node.body]);\n  } else {\n    node.body.body.unshift(...newStatements);\n  }\n}\n\n/**\n * Test if an ArrayPattern's elements contain any RestElements.\n */\n\nfunction hasArrayRest(pattern: t.ArrayPattern) {\n  return pattern.elements.some(elem => t.isRestElement(elem));\n}\n\n/**\n * Test if an ObjectPattern's properties contain any RestElements.\n */\n\nfunction hasObjectRest(pattern: t.ObjectPattern) {\n  return pattern.properties.some(prop => t.isRestElement(prop));\n}\n\ninterface UnpackableArrayExpression extends t.ArrayExpression {\n  elements: (null | t.Expression)[];\n}\n\nconst STOP_TRAVERSAL = {};\n\ninterface ArrayUnpackVisitorState {\n  deopt: boolean;\n  bindings: Record<string, t.Identifier>;\n}\n\n// NOTE: This visitor is meant to be used via t.traverse\nconst arrayUnpackVisitor = (\n  node: t.Node,\n  ancestors: TraversalAncestors,\n  state: ArrayUnpackVisitorState,\n) => {\n  if (!ancestors.length) {\n    // Top-level node: this is the array literal.\n    return;\n  }\n\n  if (\n    t.isIdentifier(node) &&\n    t.isReferenced(node, ancestors[ancestors.length - 1].node) &&\n    state.bindings[node.name]\n  ) {\n    state.deopt = true;\n    throw STOP_TRAVERSAL;\n  }\n};\n\nexport type DestructuringTransformerNode =\n  | t.VariableDeclaration\n  | t.ExpressionStatement\n  | t.ReturnStatement;\n\ninterface DestructuringTransformerOption {\n  blockHoist?: number;\n  operator?: t.AssignmentExpression[\"operator\"];\n  nodes?: DestructuringTransformerNode[];\n  kind?: t.VariableDeclaration[\"kind\"];\n  scope: Scope;\n  arrayLikeIsIterable: boolean;\n  iterableIsArray: boolean;\n  objectRestNoSymbols: boolean;\n  useBuiltIns: boolean;\n  addHelper: File[\"addHelper\"];\n}\nexport class DestructuringTransformer {\n  private blockHoist: number;\n  private operator: t.AssignmentExpression[\"operator\"];\n  arrayRefSet: Set<string>;\n  private nodes: DestructuringTransformerNode[];\n  private scope: Scope;\n  private kind: t.VariableDeclaration[\"kind\"];\n  private iterableIsArray: boolean;\n  private arrayLikeIsIterable: boolean;\n  private objectRestNoSymbols: boolean;\n  private useBuiltIns: boolean;\n  private addHelper: File[\"addHelper\"];\n  constructor(opts: DestructuringTransformerOption) {\n    this.blockHoist = opts.blockHoist;\n    this.operator = opts.operator;\n    this.arrayRefSet = new Set();\n    this.nodes = opts.nodes || [];\n    this.scope = opts.scope;\n    this.kind = opts.kind;\n    this.iterableIsArray = opts.iterableIsArray;\n    this.arrayLikeIsIterable = opts.arrayLikeIsIterable;\n    this.objectRestNoSymbols = opts.objectRestNoSymbols;\n    this.useBuiltIns = opts.useBuiltIns;\n    this.addHelper = opts.addHelper;\n  }\n\n  getExtendsHelper() {\n    return this.useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : this.addHelper(\"extends\");\n  }\n\n  buildVariableAssignment(\n    id: t.AssignmentExpression[\"left\"],\n    init: t.Expression,\n  ) {\n    let op = this.operator;\n    if (t.isMemberExpression(id)) op = \"=\";\n\n    let node: t.ExpressionStatement | t.VariableDeclaration;\n\n    if (op) {\n      node = t.expressionStatement(\n        t.assignmentExpression(\n          op,\n          id,\n          t.cloneNode(init) || this.scope.buildUndefinedNode(),\n        ),\n      );\n    } else {\n      let nodeInit: t.Expression;\n\n      if (this.kind === \"const\" && init === null) {\n        nodeInit = this.scope.buildUndefinedNode();\n      } else {\n        nodeInit = t.cloneNode(init);\n      }\n\n      node = t.variableDeclaration(this.kind, [\n        t.variableDeclarator(id, nodeInit),\n      ]);\n    }\n\n    //@ts-expect-error(todo): document block hoist property\n    node._blockHoist = this.blockHoist;\n\n    return node;\n  }\n\n  buildVariableDeclaration(id: t.Identifier, init: t.Expression) {\n    const declar = t.variableDeclaration(\"var\", [\n      t.variableDeclarator(t.cloneNode(id), t.cloneNode(init)),\n    ]);\n    // @ts-expect-error todo(flow->ts): avoid mutations\n    declar._blockHoist = this.blockHoist;\n    return declar;\n  }\n\n  push(id: t.LVal, _init: t.Expression | null) {\n    const init = t.cloneNode(_init);\n    if (t.isObjectPattern(id)) {\n      this.pushObjectPattern(id, init);\n    } else if (t.isArrayPattern(id)) {\n      this.pushArrayPattern(id, init);\n    } else if (t.isAssignmentPattern(id)) {\n      this.pushAssignmentPattern(id, init);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(id, init));\n    }\n  }\n\n  toArray(node: t.Expression, count?: boolean | number) {\n    if (\n      this.iterableIsArray ||\n      (t.isIdentifier(node) && this.arrayRefSet.has(node.name))\n    ) {\n      return node;\n    } else {\n      return this.scope.toArray(node, count, this.arrayLikeIsIterable);\n    }\n  }\n\n  pushAssignmentPattern(\n    { left, right }: t.AssignmentPattern,\n    valueRef: t.Expression | null,\n  ) {\n    // handle array init hole\n    // const [x = 42] = [,];\n    // -> const x = 42;\n    if (valueRef === null) {\n      this.push(left, right);\n      return;\n    }\n\n    // we need to assign the current value of the assignment to avoid evaluating\n    // it more than once\n    const tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n\n    this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));\n\n    const tempConditional = t.conditionalExpression(\n      t.binaryExpression(\n        \"===\",\n        t.cloneNode(tempId),\n        this.scope.buildUndefinedNode(),\n      ),\n      right,\n      t.cloneNode(tempId),\n    );\n\n    if (t.isPattern(left)) {\n      let patternId;\n      let node;\n\n      if (this.kind === \"const\" || this.kind === \"let\") {\n        patternId = this.scope.generateUidIdentifier(tempId.name);\n        node = this.buildVariableDeclaration(patternId, tempConditional);\n      } else {\n        patternId = tempId;\n\n        node = t.expressionStatement(\n          t.assignmentExpression(\"=\", t.cloneNode(tempId), tempConditional),\n        );\n      }\n\n      this.nodes.push(node);\n      this.push(left, patternId);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n    }\n  }\n\n  pushObjectRest(\n    pattern: t.ObjectPattern,\n    objRef: t.Expression,\n    spreadProp: t.RestElement,\n    spreadPropIndex: number,\n  ) {\n    const value = buildObjectExcludingKeys(\n      pattern.properties.slice(0, spreadPropIndex) as t.ObjectProperty[],\n      objRef,\n      this.scope,\n      name => this.addHelper(name),\n      this.objectRestNoSymbols,\n      this.useBuiltIns,\n    );\n    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n  }\n\n  pushObjectProperty(prop: t.ObjectProperty, propRef: t.Expression) {\n    if (t.isLiteral(prop.key)) prop.computed = true;\n\n    const pattern = prop.value as t.LVal;\n    const objRef = t.memberExpression(\n      t.cloneNode(propRef),\n      prop.key,\n      prop.computed,\n    );\n\n    if (t.isPattern(pattern)) {\n      this.push(pattern, objRef);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n    }\n  }\n\n  pushObjectPattern(pattern: t.ObjectPattern, objRef: t.Expression | null) {\n    // https://github.com/babel/babel/issues/681\n\n    if (!pattern.properties.length || objRef === null) {\n      this.nodes.push(\n        t.expressionStatement(\n          t.callExpression(\n            this.addHelper(\"objectDestructuringEmpty\"),\n            objRef !== null ? [objRef] : [],\n          ),\n        ),\n      );\n      return;\n    }\n\n    // if we have more than one properties in this pattern and the objectRef is a\n    // member expression then we need to assign it to a temporary variable so it's\n    // only evaluated once\n\n    if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n      const temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n      this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n      objRef = temp;\n    }\n\n    // Replace impure computed key expressions if we have a rest parameter\n    if (hasObjectRest(pattern)) {\n      let copiedPattern: t.ObjectPattern;\n      for (let i = 0; i < pattern.properties.length; i++) {\n        const prop = pattern.properties[i];\n        if (t.isRestElement(prop)) {\n          break;\n        }\n        const key = prop.key;\n        if (prop.computed && !this.scope.isPure(key)) {\n          const name = this.scope.generateUidIdentifierBasedOnNode(key);\n          this.nodes.push(\n            //@ts-expect-error PrivateName has been handled by destructuring-private\n            this.buildVariableDeclaration(name, key),\n          );\n          if (!copiedPattern) {\n            copiedPattern = pattern = {\n              ...pattern,\n              properties: pattern.properties.slice(),\n            };\n          }\n          copiedPattern.properties[i] = {\n            ...prop,\n            key: name,\n          };\n        }\n      }\n    }\n\n    for (let i = 0; i < pattern.properties.length; i++) {\n      const prop = pattern.properties[i];\n      if (t.isRestElement(prop)) {\n        this.pushObjectRest(pattern, objRef, prop, i);\n      } else {\n        this.pushObjectProperty(prop, objRef);\n      }\n    }\n  }\n\n  canUnpackArrayPattern(\n    pattern: t.ArrayPattern,\n    arr: t.Expression,\n  ): arr is UnpackableArrayExpression {\n    // not an array so there's no way we can deal with this\n    if (!t.isArrayExpression(arr)) return false;\n\n    // pattern has less elements than the array and doesn't have a rest so some\n    // elements wont be evaluated\n    if (pattern.elements.length > arr.elements.length) return;\n    if (\n      pattern.elements.length < arr.elements.length &&\n      !hasArrayRest(pattern)\n    ) {\n      return false;\n    }\n\n    for (const elem of pattern.elements) {\n      // deopt on holes\n      if (!elem) return false;\n\n      // deopt on member expressions as they may be included in the RHS\n      if (t.isMemberExpression(elem)) return false;\n    }\n\n    for (const elem of arr.elements) {\n      // deopt on spread elements\n      if (t.isSpreadElement(elem)) return false;\n\n      // deopt call expressions as they might change values of LHS variables\n      if (t.isCallExpression(elem)) return false;\n\n      // deopt on member expressions as they may be getter/setters and have side-effects\n      if (t.isMemberExpression(elem)) return false;\n    }\n\n    // deopt on reference to left side identifiers\n    const bindings = t.getBindingIdentifiers(pattern);\n    const state: ArrayUnpackVisitorState = { deopt: false, bindings };\n\n    try {\n      t.traverse(arr, arrayUnpackVisitor, state);\n    } catch (e) {\n      if (e !== STOP_TRAVERSAL) throw e;\n    }\n\n    return !state.deopt;\n  }\n\n  pushUnpackedArrayPattern(\n    pattern: t.ArrayPattern,\n    arr: UnpackableArrayExpression,\n  ) {\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n      if (t.isRestElement(elem)) {\n        this.push(elem.argument, t.arrayExpression(arr.elements.slice(i)));\n      } else {\n        this.push(elem, arr.elements[i]);\n      }\n    }\n  }\n\n  pushArrayPattern(pattern: t.ArrayPattern, arrayRef: t.Expression | null) {\n    if (arrayRef === null) {\n      this.nodes.push(\n        t.expressionStatement(\n          t.callExpression(this.addHelper(\"objectDestructuringEmpty\"), []),\n        ),\n      );\n      return;\n    }\n    if (!pattern.elements) return;\n\n    // optimise basic array destructuring of an array expression\n    //\n    // we can't do this to a pattern of unequal size to it's right hand\n    // array expression as then there will be values that wont be evaluated\n    //\n    // eg: let [a, b] = [1, 2];\n\n    if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n      return this.pushUnpackedArrayPattern(pattern, arrayRef);\n    }\n\n    // if we have a rest then we need all the elements so don't tell\n    // `scope.toArray` to only get a certain amount\n\n    const count = !hasArrayRest(pattern) && pattern.elements.length;\n\n    // so we need to ensure that the `arrayRef` is an array, `scope.toArray` will\n    // return a locally bound identifier if it's been inferred to be an array,\n    // otherwise it'll be a call to a helper that will ensure it's one\n\n    const toArray = this.toArray(arrayRef, count);\n\n    if (t.isIdentifier(toArray)) {\n      // we've been given an identifier so it must have been inferred to be an\n      // array\n      arrayRef = toArray;\n    } else {\n      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n      this.arrayRefSet.add(arrayRef.name);\n      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n    }\n\n    //\n\n    for (let i = 0; i < pattern.elements.length; i++) {\n      const elem = pattern.elements[i];\n\n      // hole\n      if (!elem) continue;\n\n      let elemRef;\n\n      if (t.isRestElement(elem)) {\n        elemRef = this.toArray(arrayRef);\n        elemRef = t.callExpression(\n          t.memberExpression(elemRef, t.identifier(\"slice\")),\n          [t.numericLiteral(i)],\n        );\n\n        // set the element to the rest element argument since we've dealt with it\n        // being a rest already\n        this.push(elem.argument, elemRef);\n      } else {\n        elemRef = t.memberExpression(arrayRef, t.numericLiteral(i), true);\n        this.push(elem, elemRef);\n      }\n    }\n  }\n\n  init(pattern: t.LVal, ref: t.Expression) {\n    // trying to destructure a value that we can't evaluate more than once so we\n    // need to save it to a variable\n\n    if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref)) {\n      const memo = this.scope.maybeGenerateMemoised(ref, true);\n      if (memo) {\n        this.nodes.push(this.buildVariableDeclaration(memo, t.cloneNode(ref)));\n        ref = memo;\n      }\n    }\n\n    this.push(pattern, ref);\n\n    return this.nodes;\n  }\n}\n\ninterface ExcludingKey {\n  key: t.Expression | t.PrivateName;\n  computed: boolean;\n}\n\nexport function buildObjectExcludingKeys<T extends ExcludingKey>(\n  excludedKeys: T[],\n  objRef: t.Expression,\n  scope: Scope,\n  addHelper: File[\"addHelper\"],\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n): t.CallExpression {\n  // get all the keys that appear in this object before the current spread\n\n  const keys = [];\n  let allLiteral = true;\n  let hasTemplateLiteral = false;\n  for (let i = 0; i < excludedKeys.length; i++) {\n    const prop = excludedKeys[i];\n    const key = prop.key;\n    if (t.isIdentifier(key) && !prop.computed) {\n      keys.push(t.stringLiteral(key.name));\n    } else if (t.isTemplateLiteral(key)) {\n      keys.push(t.cloneNode(key));\n      hasTemplateLiteral = true;\n    } else if (t.isLiteral(key)) {\n      // @ts-expect-error todo(flow->ts) NullLiteral\n      keys.push(t.stringLiteral(String(key.value)));\n    } else if (t.isPrivateName(key)) {\n      // private key is not enumerable\n    } else {\n      keys.push(t.cloneNode(key));\n      allLiteral = false;\n    }\n  }\n\n  let value;\n  if (keys.length === 0) {\n    const extendsHelper = useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : addHelper(\"extends\");\n    value = t.callExpression(extendsHelper, [\n      t.objectExpression([]),\n      t.cloneNode(objRef),\n    ]);\n  } else {\n    let keyExpression: t.Expression = t.arrayExpression(keys);\n\n    if (!allLiteral) {\n      keyExpression = t.callExpression(\n        t.memberExpression(keyExpression, t.identifier(\"map\")),\n        [addHelper(\"toPropertyKey\")],\n      );\n    } else if (!hasTemplateLiteral && !t.isProgram(scope.block)) {\n      // Hoist definition of excluded keys, so that it's not created each time.\n      const programScope = scope.getProgramParent();\n      const id = programScope.generateUidIdentifier(\"excluded\");\n\n      programScope.push({\n        id,\n        init: keyExpression,\n        kind: \"const\",\n      });\n\n      keyExpression = t.cloneNode(id);\n    }\n\n    value = t.callExpression(\n      addHelper(`objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`),\n      [t.cloneNode(objRef), keyExpression],\n    );\n  }\n  return value;\n}\n\nexport function convertVariableDeclaration(\n  path: NodePath<t.VariableDeclaration>,\n  addHelper: File[\"addHelper\"],\n  arrayLikeIsIterable: boolean,\n  iterableIsArray: boolean,\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n) {\n  const { node, scope } = path;\n\n  const nodeKind = node.kind;\n  const nodeLoc = node.loc;\n  const nodes = [];\n\n  for (let i = 0; i < node.declarations.length; i++) {\n    const declar = node.declarations[i];\n\n    const patternId = declar.init;\n    const pattern = declar.id;\n\n    const destructuring: DestructuringTransformer =\n      new DestructuringTransformer({\n        // @ts-expect-error(todo): avoid internal properties access\n        blockHoist: node._blockHoist,\n        nodes: nodes,\n        scope: scope,\n        kind: node.kind,\n        iterableIsArray,\n        arrayLikeIsIterable,\n        useBuiltIns,\n        objectRestNoSymbols,\n        addHelper,\n      });\n\n    if (t.isPattern(pattern)) {\n      destructuring.init(pattern, patternId);\n\n      if (+i !== node.declarations.length - 1) {\n        // we aren't the last declarator so let's just make the\n        // last transformed node inherit from us\n        t.inherits(nodes[nodes.length - 1], declar);\n      }\n    } else {\n      nodes.push(\n        t.inherits(\n          destructuring.buildVariableAssignment(pattern, patternId),\n          declar,\n        ),\n      );\n    }\n  }\n\n  const inForInit = t.isForStatement(path.parent, { init: node });\n\n  let tail: t.VariableDeclaration | null = null;\n  const nodesOut = [];\n  for (const node of nodes) {\n    if (t.isVariableDeclaration(node)) {\n      if (tail !== null) {\n        // Create a single compound declarations\n        tail.declarations.push(...node.declarations);\n        continue;\n      } else {\n        // Make sure the original node kind is used for each compound declaration\n        node.kind = nodeKind;\n        tail = node;\n      }\n    } else {\n      tail = null;\n    }\n    // Propagate the original declaration node's location\n    if (!node.loc) {\n      node.loc = nodeLoc;\n    }\n    nodesOut.push(\n      inForInit && node.type === \"ExpressionStatement\" ? node.expression : node,\n    );\n  }\n\n  if (nodesOut.length === 1) {\n    path.replaceWith(nodesOut[0]);\n  } else {\n    path.replaceWithMultiple(nodesOut);\n  }\n  scope.crawl();\n}\n\nexport function convertAssignmentExpression(\n  path: NodePath<t.AssignmentExpression>,\n  addHelper: File[\"addHelper\"],\n  arrayLikeIsIterable: boolean,\n  iterableIsArray: boolean,\n  objectRestNoSymbols: boolean,\n  useBuiltIns: boolean,\n) {\n  const { node, scope, parentPath } = path;\n\n  const nodes: DestructuringTransformerNode[] = [];\n\n  const destructuring = new DestructuringTransformer({\n    operator: node.operator,\n    scope: scope,\n    nodes: nodes,\n    arrayLikeIsIterable,\n    iterableIsArray,\n    objectRestNoSymbols,\n    useBuiltIns,\n    addHelper,\n  });\n\n  let ref: t.Identifier | void;\n  if (\n    (!parentPath.isExpressionStatement() &&\n      !parentPath.isSequenceExpression()) ||\n    path.isCompletionRecord()\n  ) {\n    ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n\n    nodes.push(\n      t.variableDeclaration(\"var\", [t.variableDeclarator(ref, node.right)]),\n    );\n\n    if (t.isArrayExpression(node.right)) {\n      destructuring.arrayRefSet.add(ref.name);\n    }\n  }\n\n  destructuring.init(node.left, ref || node.right);\n\n  if (ref) {\n    if (parentPath.isArrowFunctionExpression()) {\n      path.replaceWith(t.blockStatement([]));\n      nodes.push(t.returnStatement(t.cloneNode(ref)));\n    } else {\n      nodes.push(t.expressionStatement(t.cloneNode(ref)));\n    }\n  }\n\n  path.replaceWithMultiple(nodes);\n  scope.crawl();\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\nimport {\n  DestructuringTransformer,\n  convertVariableDeclaration,\n  convertAssignmentExpression,\n  unshiftForXStatementBody,\n  type DestructuringTransformerNode,\n} from \"./util\";\nexport { buildObjectExcludingKeys, unshiftForXStatementBody } from \"./util\";\nimport type { NodePath } from \"@babel/traverse\";\n\n/**\n * Test if a VariableDeclaration's declarations contains any Patterns.\n */\n\nfunction variableDeclarationHasPattern(node: t.VariableDeclaration) {\n  for (const declar of node.declarations) {\n    if (t.isPattern(declar.id)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface Options {\n  allowArrayLike?: boolean;\n  loose?: boolean;\n  useBuiltIns?: boolean;\n}\n\nexport default declare((api, options: Options) => {\n  api.assertVersion(7);\n\n  const { useBuiltIns = false } = options;\n\n  const iterableIsArray = (api.assumption(\"iterableIsArray\") ??\n    options.loose ??\n    false) as boolean;\n  const arrayLikeIsIterable = (options.allowArrayLike ??\n    api.assumption(\"arrayLikeIsIterable\") ??\n    false) as boolean;\n  const objectRestNoSymbols = (api.assumption(\"objectRestNoSymbols\") ??\n    options.loose ??\n    false) as boolean;\n\n  return {\n    name: \"transform-destructuring\",\n\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers())) {\n          specifiers.push(\n            t.exportSpecifier(t.identifier(name), t.identifier(name)),\n          );\n        }\n\n        // Split the declaration and export list into two declarations so that the variable\n        // declaration can be split up later without needing to worry about not being a\n        // top-level statement.\n        path.replaceWith(declaration.node);\n        path.insertAfter(t.exportNamedDeclaration(null, specifiers));\n        path.scope.crawl();\n      },\n\n      ForXStatement(path: NodePath<t.ForXStatement>) {\n        const { node, scope } = path;\n        const left = node.left;\n\n        if (t.isPattern(left)) {\n          // for ({ length: k } in { abc: 3 });\n\n          const temp = scope.generateUidIdentifier(\"ref\");\n\n          node.left = t.variableDeclaration(\"var\", [\n            t.variableDeclarator(temp),\n          ]);\n\n          path.ensureBlock();\n          const statementBody = path.node.body.body;\n          const nodes = [];\n          // todo: the completion of a for statement can only be observed from\n          // a do block (or eval that we don't support),\n          // but the new do-expression proposal plans to ban iteration ends in the\n          // do block, maybe we can get rid of this\n          if (statementBody.length === 0 && path.isCompletionRecord()) {\n            nodes.unshift(t.expressionStatement(scope.buildUndefinedNode()));\n          }\n\n          nodes.unshift(\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", left, t.cloneNode(temp)),\n            ),\n          );\n\n          unshiftForXStatementBody(path, nodes);\n          scope.crawl();\n          return;\n        }\n\n        if (!t.isVariableDeclaration(left)) return;\n\n        const pattern = left.declarations[0].id;\n        if (!t.isPattern(pattern)) return;\n\n        const key = scope.generateUidIdentifier(\"ref\");\n        node.left = t.variableDeclaration(left.kind, [\n          t.variableDeclarator(key, null),\n        ]);\n\n        const nodes: DestructuringTransformerNode[] = [];\n\n        const destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name),\n        });\n\n        destructuring.init(pattern, key);\n\n        unshiftForXStatementBody(path, nodes);\n        scope.crawl();\n      },\n\n      CatchClause({ node, scope }) {\n        const pattern = node.param;\n        if (!t.isPattern(pattern)) return;\n\n        const ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n\n        const nodes: DestructuringTransformerNode[] = [];\n\n        const destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          scope: scope,\n          nodes: nodes,\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n          addHelper: name => this.addHelper(name),\n        });\n        destructuring.init(pattern, ref);\n\n        node.body.body = [...nodes, ...node.body.body];\n        scope.crawl();\n      },\n\n      AssignmentExpression(path, state) {\n        if (!t.isPattern(path.node.left)) return;\n        convertAssignmentExpression(\n          path,\n          name => state.addHelper(name),\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n        );\n      },\n\n      VariableDeclaration(path, state) {\n        const { node, parent } = path;\n        if (t.isForXStatement(parent)) return;\n        if (!parent || !path.container) return; // i don't know why this is necessary - TODO\n        if (!variableDeclarationHasPattern(node)) return;\n        convertVariableDeclaration(\n          path,\n          name => state.addHelper(name),\n          arrayLikeIsIterable,\n          iterableIsArray,\n          objectRestNoSymbols,\n          useBuiltIns,\n        );\n      },\n    },\n  };\n});\n"]},"metadata":{},"sourceType":"script"}