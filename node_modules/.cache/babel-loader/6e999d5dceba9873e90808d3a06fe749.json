{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.svgParser = {}));\n})(this, function (exports) {\n  'use strict';\n\n  function getLocator(source, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n      var end = start + line.length + 1;\n      var range = {\n        start: start,\n        end: end,\n        line: i\n      };\n      start = end;\n      return range;\n    });\n    var i = 0;\n\n    function rangeContains(range, index) {\n      return range.start <= index && index < range.end;\n    }\n\n    function getLocation(range, index) {\n      return {\n        line: offsetLine + range.line,\n        column: offsetColumn + index - range.start,\n        character: index\n      };\n    }\n\n    function locate(search, startIndex) {\n      if (typeof search === 'string') {\n        search = source.indexOf(search, startIndex || 0);\n      }\n\n      var range = lineRanges[i];\n      var d = search >= range.end ? 1 : -1;\n\n      while (range) {\n        if (rangeContains(range, search)) return getLocation(range, search);\n        i += d;\n        range = lineRanges[i];\n      }\n    }\n\n    return locate;\n  }\n\n  function locate(source, search, options) {\n    if (typeof options === 'number') {\n      throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n\n    return getLocator(source, options)(search, options && options.startIndex);\n  }\n\n  var validNameCharacters = /[a-zA-Z0-9:_-]/;\n  var whitespace = /[\\s\\t\\r\\n]/;\n  var quotemark = /['\"]/;\n\n  function repeat(str, i) {\n    var result = '';\n\n    while (i--) {\n      result += str;\n    }\n\n    return result;\n  }\n\n  function parse(source) {\n    var header = '';\n    var stack = [];\n    var state = metadata;\n    var currentElement = null;\n    var root = null;\n\n    function error(message) {\n      var ref = locate(source, i);\n      var line = ref.line;\n      var column = ref.column;\n      var before = source.slice(0, i);\n      var beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n      var after = source.slice(i);\n      var afterLine = /.*(\\n|$)/.exec(after)[0];\n      var snippet = \"\" + beforeLine + afterLine + \"\\n\" + repeat(' ', beforeLine.length) + \"^\";\n      throw new Error(message + \" (\" + line + \":\" + column + \"). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues – thanks!\\n\\n\" + snippet);\n    }\n\n    function metadata() {\n      while (i < source.length && source[i] !== '<' || !validNameCharacters.test(source[i + 1])) {\n        header += source[i++];\n      }\n\n      return neutral();\n    }\n\n    function neutral() {\n      var text = '';\n\n      while (i < source.length && source[i] !== '<') {\n        text += source[i++];\n      }\n\n      if (/\\S/.test(text)) {\n        currentElement.children.push({\n          type: 'text',\n          value: text\n        });\n      }\n\n      if (source[i] === '<') {\n        return tag;\n      }\n\n      return neutral;\n    }\n\n    function tag() {\n      var char = source[i];\n\n      if (char === '?') {\n        return neutral;\n      } // <?xml...\n\n\n      if (char === '!') {\n        if (source.slice(i + 1, i + 3) === '--') {\n          return comment;\n        }\n\n        if (source.slice(i + 1, i + 8) === '[CDATA[') {\n          return cdata;\n        }\n\n        if (/doctype/i.test(source.slice(i + 1, i + 8))) {\n          return neutral;\n        }\n      }\n\n      if (char === '/') {\n        return closingTag;\n      }\n\n      var tagName = getName();\n      var element = {\n        type: 'element',\n        tagName: tagName,\n        properties: {},\n        children: []\n      };\n\n      if (currentElement) {\n        currentElement.children.push(element);\n      } else {\n        root = element;\n      }\n\n      var attribute;\n\n      while (i < source.length && (attribute = getAttribute())) {\n        element.properties[attribute.name] = attribute.value;\n      }\n\n      var selfClosing = false;\n\n      if (source[i] === '/') {\n        i += 1;\n        selfClosing = true;\n      }\n\n      if (source[i] !== '>') {\n        error('Expected >');\n      }\n\n      if (!selfClosing) {\n        currentElement = element;\n        stack.push(element);\n      }\n\n      return neutral;\n    }\n\n    function comment() {\n      var index = source.indexOf('-->', i);\n\n      if (!~index) {\n        error('expected -->');\n      }\n\n      i = index + 2;\n      return neutral;\n    }\n\n    function cdata() {\n      var index = source.indexOf(']]>', i);\n\n      if (!~index) {\n        error('expected ]]>');\n      }\n\n      currentElement.children.push(source.slice(i + 7, index));\n      i = index + 2;\n      return neutral;\n    }\n\n    function closingTag() {\n      var tagName = getName();\n\n      if (!tagName) {\n        error('Expected tag name');\n      }\n\n      if (tagName !== currentElement.tagName) {\n        error(\"Expected closing tag </\" + tagName + \"> to match opening tag <\" + currentElement.tagName + \">\");\n      }\n\n      allowSpaces();\n\n      if (source[i] !== '>') {\n        error('Expected >');\n      }\n\n      stack.pop();\n      currentElement = stack[stack.length - 1];\n      return neutral;\n    }\n\n    function getName() {\n      var name = '';\n\n      while (i < source.length && validNameCharacters.test(source[i])) {\n        name += source[i++];\n      }\n\n      return name;\n    }\n\n    function getAttribute() {\n      if (!whitespace.test(source[i])) {\n        return null;\n      }\n\n      allowSpaces();\n      var name = getName();\n\n      if (!name) {\n        return null;\n      }\n\n      var value = true;\n      allowSpaces();\n\n      if (source[i] === '=') {\n        i += 1;\n        allowSpaces();\n        value = getAttributeValue();\n\n        if (!isNaN(value) && value.trim() !== '') {\n          value = +value;\n        } // TODO whitelist numeric attributes?\n\n      }\n\n      return {\n        name: name,\n        value: value\n      };\n    }\n\n    function getAttributeValue() {\n      return quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n    }\n\n    function getUnquotedAttributeValue() {\n      var value = '';\n\n      do {\n        var char = source[i];\n\n        if (char === ' ' || char === '>' || char === '/') {\n          return value;\n        }\n\n        value += char;\n        i += 1;\n      } while (i < source.length);\n\n      return value;\n    }\n\n    function getQuotedAttributeValue() {\n      var quotemark = source[i++];\n      var value = '';\n      var escaped = false;\n\n      while (i < source.length) {\n        var char = source[i++];\n\n        if (char === quotemark && !escaped) {\n          return value;\n        }\n\n        if (char === '\\\\' && !escaped) {\n          escaped = true;\n        }\n\n        value += escaped ? \"\\\\\" + char : char;\n        escaped = false;\n      }\n    }\n\n    function allowSpaces() {\n      while (i < source.length && whitespace.test(source[i])) {\n        i += 1;\n      }\n    }\n\n    var i = metadata.length;\n\n    while (i < source.length) {\n      if (!state) {\n        error('Unexpected character');\n      }\n\n      state = state();\n      i += 1;\n    }\n\n    if (state !== neutral) {\n      error('Unexpected end of input');\n    }\n\n    if (root.tagName === 'svg') {\n      root.metadata = header;\n    }\n\n    return {\n      type: 'root',\n      children: [root]\n    };\n  }\n\n  exports.parse = parse;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":"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","names":["getLocator","source","options","offsetLine","offsetColumn","originalLines","split","start","lineRanges","map","line","i","end","length","range","rangeContains","index","getLocation","column","character","locate","search","startIndex","indexOf","d","Error","const","validNameCharacters","whitespace","quotemark","repeat","str","let","result","parse","header","stack","state","metadata","currentElement","root","error","message","before","slice","beforeLine","exec","replace","after","afterLine","snippet","test","neutral","text","children","push","type","value","tag","char","comment","cdata","closingTag","tagName","getName","element","properties","attribute","getAttribute","name","selfClosing","allowSpaces","pop","getAttributeValue","isNaN","trim","getQuotedAttributeValue","getUnquotedAttributeValue","escaped"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\svg-parser\\node_modules\\locate-character\\dist\\locate-character.es.js","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\svg-parser\\src\\index.js"],"sourcesContent":["function getLocator(source, options) {\n    if (options === void 0) { options = {}; }\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n        var end = start + line.length + 1;\n        var range = { start: start, end: end, line: i };\n        start = end;\n        return range;\n    });\n    var i = 0;\n    function rangeContains(range, index) {\n        return range.start <= index && index < range.end;\n    }\n    function getLocation(range, index) {\n        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n    }\n    function locate(search, startIndex) {\n        if (typeof search === 'string') {\n            search = source.indexOf(search, startIndex || 0);\n        }\n        var range = lineRanges[i];\n        var d = search >= range.end ? 1 : -1;\n        while (range) {\n            if (rangeContains(range, search))\n                return getLocation(range, search);\n            i += d;\n            range = lineRanges[i];\n        }\n    }\n    ;\n    return locate;\n}\nfunction locate(source, search, options) {\n    if (typeof options === 'number') {\n        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n    return getLocator(source, options)(search, options && options.startIndex);\n}\n\nexport { getLocator, locate };","import { locate } from 'locate-character';\n\nconst validNameCharacters = /[a-zA-Z0-9:_-]/;\nconst whitespace = /[\\s\\t\\r\\n]/;\nconst quotemark = /['\"]/;\n\nfunction repeat(str, i) {\n\tlet result = '';\n\twhile (i--) result += str;\n\treturn result;\n}\n\nexport function parse(source) {\n\tlet header = '';\n\tlet stack = [];\n\n\tlet state = metadata;\n\tlet currentElement = null;\n\tlet root = null;\n\n\tfunction error(message) {\n\t\tconst { line, column } = locate(source, i);\n\t\tconst before = source.slice(0, i);\n\t\tconst beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n\t\tconst after = source.slice(i);\n\t\tconst afterLine = /.*(\\n|$)/.exec(after)[0];\n\n\t\tconst snippet = `${beforeLine}${afterLine}\\n${repeat(' ', beforeLine.length)}^`;\n\n\t\tthrow new Error(\n\t\t\t`${message} (${line}:${column}). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues – thanks!\\n\\n${snippet}`\n\t\t);\n\t}\n\n\tfunction metadata() {\n\t\twhile ((i < source.length && source[i] !== '<') || !validNameCharacters.test(source[i + 1])) {\n\t\t\theader += source[i++];\n\t\t}\n\n\t\treturn neutral();\n\t}\n\n\tfunction neutral() {\n\t\tlet text = '';\n\t\twhile (i < source.length && source[i] !== '<') text += source[i++];\n\n\t\tif (/\\S/.test(text)) {\n\t\t\tcurrentElement.children.push({ type: 'text', value: text });\n\t\t}\n\n\t\tif (source[i] === '<') {\n\t\t\treturn tag;\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction tag() {\n\t\tconst char = source[i];\n\n\t\tif (char === '?') return neutral; // <?xml...\n\n\t\tif (char === '!') {\n\t\t\tif (source.slice(i + 1, i + 3) === '--') return comment;\n\t\t\tif (source.slice(i + 1, i + 8) === '[CDATA[') return cdata;\n\t\t\tif (/doctype/i.test(source.slice(i + 1, i + 8))) return neutral;\n\t\t}\n\n\t\tif (char === '/') return closingTag;\n\n\t\tconst tagName = getName();\n\n\t\tconst element = {\n\t\t\ttype: 'element',\n\t\t\ttagName,\n\t\t\tproperties: {},\n\t\t\tchildren: []\n\t\t};\n\n\t\tif (currentElement) {\n\t\t\tcurrentElement.children.push(element);\n\t\t} else {\n\t\t\troot = element;\n\t\t}\n\n\t\tlet attribute;\n\t\twhile (i < source.length && (attribute = getAttribute())) {\n\t\t\telement.properties[attribute.name] = attribute.value;\n\t\t}\n\n\t\tlet selfClosing = false;\n\n\t\tif (source[i] === '/') {\n\t\t\ti += 1;\n\t\t\tselfClosing = true;\n\t\t}\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tif (!selfClosing) {\n\t\t\tcurrentElement = element;\n\t\t\tstack.push(element);\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction comment() {\n\t\tconst index = source.indexOf('-->', i);\n\t\tif (!~index) error('expected -->');\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction cdata() {\n\t\tconst index = source.indexOf(']]>', i);\n\t\tif (!~index) error('expected ]]>');\n\n\t\tcurrentElement.children.push(source.slice(i + 7, index));\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction closingTag() {\n\t\tconst tagName = getName();\n\n\t\tif (!tagName) error('Expected tag name');\n\n\t\tif (tagName !== currentElement.tagName) {\n\t\t\terror(`Expected closing tag </${tagName}> to match opening tag <${currentElement.tagName}>`);\n\t\t}\n\n\t\tallowSpaces();\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tstack.pop();\n\t\tcurrentElement = stack[stack.length - 1];\n\n\t\treturn neutral;\n\t}\n\n\tfunction getName() {\n\t\tlet name = '';\n\t\twhile (i < source.length && validNameCharacters.test(source[i])) name += source[i++];\n\n\t\treturn name;\n\t}\n\n\tfunction getAttribute() {\n\t\tif (!whitespace.test(source[i])) return null;\n\t\tallowSpaces();\n\n\t\tconst name = getName();\n\t\tif (!name) return null;\n\n\t\tlet value = true;\n\n\t\tallowSpaces();\n\t\tif (source[i] === '=') {\n\t\t\ti += 1;\n\t\t\tallowSpaces();\n\n\t\t\tvalue = getAttributeValue();\n\t\t\tif (!isNaN(value) && value.trim() !== '') value = +value; // TODO whitelist numeric attributes?\n\t\t}\n\n\t\treturn { name, value };\n\t}\n\n\tfunction getAttributeValue() {\n\t\treturn quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n\t}\n\n\tfunction getUnquotedAttributeValue() {\n\t\tlet value = '';\n\t\tdo {\n\t\t\tconst char = source[i];\n\t\t\tif (char === ' ' || char === '>' || char === '/') {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvalue += char;\n\t\t\ti += 1;\n\t\t} while (i < source.length);\n\n\t\treturn value;\n\t}\n\n\tfunction getQuotedAttributeValue() {\n\t\tconst quotemark = source[i++];\n\n\t\tlet value = '';\n\t\tlet escaped = false;\n\n\t\twhile (i < source.length) {\n\t\t\tconst char = source[i++];\n\t\t\tif (char === quotemark && !escaped) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (char === '\\\\' && !escaped) {\n\t\t\t\tescaped = true;\n\t\t\t}\n\n\t\t\tvalue += escaped ? `\\\\${char}` : char;\n\t\t\tescaped = false;\n\t\t}\n\t}\n\n\tfunction allowSpaces() {\n\t\twhile (i < source.length && whitespace.test(source[i])) i += 1;\n\t}\n\n\tlet i = metadata.length;\n\twhile (i < source.length) {\n\t\tif (!state) error('Unexpected character');\n\t\tstate = state();\n\t\ti += 1;\n\t}\n\n\tif (state !== neutral) {\n\t\terror('Unexpected end of input');\n\t}\n\n\tif (root.tagName === 'svg') root.metadata = header;\n\treturn {\n\t\ttype: 'root',\n\t\tchildren: [root]\n\t};\n}\n"]},"metadata":{},"sourceType":"script"}