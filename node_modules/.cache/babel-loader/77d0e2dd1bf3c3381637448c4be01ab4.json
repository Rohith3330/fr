{"ast":null,"code":"/**\n * HTTP client-side implementation that uses forge.net sockets.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc. All rights reserved.\n */\nvar forge = require('./forge');\n\nrequire('./tls');\n\nrequire('./util'); // define http namespace\n\n\nvar http = module.exports = forge.http = forge.http || {}; // logging category\n\nvar cat = 'forge.http'; // normalizes an http header field name\n\nvar _normalize = function (name) {\n  return name.toLowerCase().replace(/(^.)|(-.)/g, function (a) {\n    return a.toUpperCase();\n  });\n};\n/**\n * Gets the local storage ID for the given client.\n *\n * @param client the client to get the local storage ID for.\n *\n * @return the local storage ID to use.\n */\n\n\nvar _getStorageId = function (client) {\n  // TODO: include browser in ID to avoid sharing cookies between\n  // browsers (if this is undesirable)\n  // navigator.userAgent\n  return 'forge.http.' + client.url.protocol.slice(0, -1) + '.' + client.url.hostname + '.' + client.url.port;\n};\n/**\n * Loads persistent cookies from disk for the given client.\n *\n * @param client the client.\n */\n\n\nvar _loadCookies = function (client) {\n  if (client.persistCookies) {\n    try {\n      var cookies = forge.util.getItem(client.socketPool.flashApi, _getStorageId(client), 'cookies');\n      client.cookies = cookies || {};\n    } catch (ex) {// no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n};\n/**\n * Saves persistent cookies on disk for the given client.\n *\n * @param client the client.\n */\n\n\nvar _saveCookies = function (client) {\n  if (client.persistCookies) {\n    try {\n      forge.util.setItem(client.socketPool.flashApi, _getStorageId(client), 'cookies', client.cookies);\n    } catch (ex) {// no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  } // FIXME: remove me\n\n\n  _loadCookies(client);\n};\n/**\n * Clears persistent cookies on disk for the given client.\n *\n * @param client the client.\n */\n\n\nvar _clearCookies = function (client) {\n  if (client.persistCookies) {\n    try {\n      // only thing stored is 'cookies', so clear whole storage\n      forge.util.clearItems(client.socketPool.flashApi, _getStorageId(client));\n    } catch (ex) {// no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n};\n/**\n * Connects and sends a request.\n *\n * @param client the http client.\n * @param socket the socket to use.\n */\n\n\nvar _doRequest = function (client, socket) {\n  if (socket.isConnected()) {\n    // already connected\n    socket.options.request.connectTime = +new Date();\n    socket.connected({\n      type: 'connect',\n      id: socket.id\n    });\n  } else {\n    // connect\n    socket.options.request.connectTime = +new Date();\n    socket.connect({\n      host: client.url.hostname,\n      port: client.url.port,\n      policyPort: client.policyPort,\n      policyUrl: client.policyUrl\n    });\n  }\n};\n/**\n * Handles the next request or marks a socket as idle.\n *\n * @param client the http client.\n * @param socket the socket.\n */\n\n\nvar _handleNextRequest = function (client, socket) {\n  // clear buffer\n  socket.buffer.clear(); // get pending request\n\n  var pending = null;\n\n  while (pending === null && client.requests.length > 0) {\n    pending = client.requests.shift();\n\n    if (pending.request.aborted) {\n      pending = null;\n    }\n  } // mark socket idle if no pending requests\n\n\n  if (pending === null) {\n    if (socket.options !== null) {\n      socket.options = null;\n    }\n\n    client.idle.push(socket);\n  } else {\n    // handle pending request, allow 1 retry\n    socket.retries = 1;\n    socket.options = pending;\n\n    _doRequest(client, socket);\n  }\n};\n/**\n * Sets up a socket for use with an http client.\n *\n * @param client the parent http client.\n * @param socket the socket to set up.\n * @param tlsOptions if the socket must use TLS, the TLS options.\n */\n\n\nvar _initSocket = function (client, socket, tlsOptions) {\n  // no socket options yet\n  socket.options = null; // set up handlers\n\n  socket.connected = function (e) {\n    // socket primed by caching TLS session, handle next request\n    if (socket.options === null) {\n      _handleNextRequest(client, socket);\n    } else {\n      // socket in use\n      var request = socket.options.request;\n      request.connectTime = +new Date() - request.connectTime;\n      e.socket = socket;\n      socket.options.connected(e);\n\n      if (request.aborted) {\n        socket.close();\n      } else {\n        var out = request.toString();\n\n        if (request.body) {\n          out += request.body;\n        }\n\n        request.time = +new Date();\n        socket.send(out);\n        request.time = +new Date() - request.time;\n        socket.options.response.time = +new Date();\n        socket.sending = true;\n      }\n    }\n  };\n\n  socket.closed = function (e) {\n    if (socket.sending) {\n      socket.sending = false;\n\n      if (socket.retries > 0) {\n        --socket.retries;\n\n        _doRequest(client, socket);\n      } else {\n        // error, closed during send\n        socket.error({\n          id: socket.id,\n          type: 'ioError',\n          message: 'Connection closed during send. Broken pipe.',\n          bytesAvailable: 0\n        });\n      }\n    } else {\n      // handle unspecified content-length transfer\n      var response = socket.options.response;\n\n      if (response.readBodyUntilClose) {\n        response.time = +new Date() - response.time;\n        response.bodyReceived = true;\n        socket.options.bodyReady({\n          request: socket.options.request,\n          response: response,\n          socket: socket\n        });\n      }\n\n      socket.options.closed(e);\n\n      _handleNextRequest(client, socket);\n    }\n  };\n\n  socket.data = function (e) {\n    socket.sending = false;\n    var request = socket.options.request;\n\n    if (request.aborted) {\n      socket.close();\n    } else {\n      // receive all bytes available\n      var response = socket.options.response;\n      var bytes = socket.receive(e.bytesAvailable);\n\n      if (bytes !== null) {\n        // receive header and then body\n        socket.buffer.putBytes(bytes);\n\n        if (!response.headerReceived) {\n          response.readHeader(socket.buffer);\n\n          if (response.headerReceived) {\n            socket.options.headerReady({\n              request: socket.options.request,\n              response: response,\n              socket: socket\n            });\n          }\n        }\n\n        if (response.headerReceived && !response.bodyReceived) {\n          response.readBody(socket.buffer);\n        }\n\n        if (response.bodyReceived) {\n          socket.options.bodyReady({\n            request: socket.options.request,\n            response: response,\n            socket: socket\n          }); // close connection if requested or by default on http/1.0\n\n          var value = response.getField('Connection') || '';\n\n          if (value.indexOf('close') != -1 || response.version === 'HTTP/1.0' && response.getField('Keep-Alive') === null) {\n            socket.close();\n          } else {\n            _handleNextRequest(client, socket);\n          }\n        }\n      }\n    }\n  };\n\n  socket.error = function (e) {\n    // do error callback, include request\n    socket.options.error({\n      type: e.type,\n      message: e.message,\n      request: socket.options.request,\n      response: socket.options.response,\n      socket: socket\n    });\n    socket.close();\n  }; // wrap socket for TLS\n\n\n  if (tlsOptions) {\n    socket = forge.tls.wrapSocket({\n      sessionId: null,\n      sessionCache: {},\n      caStore: tlsOptions.caStore,\n      cipherSuites: tlsOptions.cipherSuites,\n      socket: socket,\n      virtualHost: tlsOptions.virtualHost,\n      verify: tlsOptions.verify,\n      getCertificate: tlsOptions.getCertificate,\n      getPrivateKey: tlsOptions.getPrivateKey,\n      getSignature: tlsOptions.getSignature,\n      deflate: tlsOptions.deflate || null,\n      inflate: tlsOptions.inflate || null\n    });\n    socket.options = null;\n    socket.buffer = forge.util.createBuffer();\n    client.sockets.push(socket);\n\n    if (tlsOptions.prime) {\n      // prime socket by connecting and caching TLS session, will do\n      // next request from there\n      socket.connect({\n        host: client.url.hostname,\n        port: client.url.port,\n        policyPort: client.policyPort,\n        policyUrl: client.policyUrl\n      });\n    } else {\n      // do not prime socket, just add as idle\n      client.idle.push(socket);\n    }\n  } else {\n    // no need to prime non-TLS sockets\n    socket.buffer = forge.util.createBuffer();\n    client.sockets.push(socket);\n    client.idle.push(socket);\n  }\n};\n/**\n * Checks to see if the given cookie has expired. If the cookie's max-age\n * plus its created time is less than the time now, it has expired, unless\n * its max-age is set to -1 which indicates it will never expire.\n *\n * @param cookie the cookie to check.\n *\n * @return true if it has expired, false if not.\n */\n\n\nvar _hasCookieExpired = function (cookie) {\n  var rval = false;\n\n  if (cookie.maxAge !== -1) {\n    var now = _getUtcTime(new Date());\n\n    var expires = cookie.created + cookie.maxAge;\n\n    if (expires <= now) {\n      rval = true;\n    }\n  }\n\n  return rval;\n};\n/**\n * Adds cookies in the given client to the given request.\n *\n * @param client the client.\n * @param request the request.\n */\n\n\nvar _writeCookies = function (client, request) {\n  var expired = [];\n  var url = client.url;\n  var cookies = client.cookies;\n\n  for (var name in cookies) {\n    // get cookie paths\n    var paths = cookies[name];\n\n    for (var p in paths) {\n      var cookie = paths[p];\n\n      if (_hasCookieExpired(cookie)) {\n        // store for clean up\n        expired.push(cookie);\n      } else if (request.path.indexOf(cookie.path) === 0) {\n        // path or path's ancestor must match cookie.path\n        request.addCookie(cookie);\n      }\n    }\n  } // clean up expired cookies\n\n\n  for (var i = 0; i < expired.length; ++i) {\n    var cookie = expired[i];\n    client.removeCookie(cookie.name, cookie.path);\n  }\n};\n/**\n * Gets cookies from the given response and adds the to the given client.\n *\n * @param client the client.\n * @param response the response.\n */\n\n\nvar _readCookies = function (client, response) {\n  var cookies = response.getCookies();\n\n  for (var i = 0; i < cookies.length; ++i) {\n    try {\n      client.setCookie(cookies[i]);\n    } catch (ex) {// ignore failure to add other-domain, etc. cookies\n    }\n  }\n};\n/**\n * Creates an http client that uses forge.net sockets as a backend and\n * forge.tls for security.\n *\n * @param options:\n *   url: the url to connect to (scheme://host:port).\n *   socketPool: the flash socket pool to use.\n *   policyPort: the flash policy port to use (if other than the\n *     socket pool default), use 0 for flash default.\n *   policyUrl: the flash policy file URL to use (if provided will\n *     be used instead of a policy port).\n *   connections: number of connections to use to handle requests.\n *   caCerts: an array of certificates to trust for TLS, certs may\n *     be PEM-formatted or cert objects produced via forge.pki.\n *   cipherSuites: an optional array of cipher suites to use,\n *     see forge.tls.CipherSuites.\n *   virtualHost: the virtual server name to use in a TLS SNI\n *     extension, if not provided the url host will be used.\n *   verify: a custom TLS certificate verify callback to use.\n *   getCertificate: an optional callback used to get a client-side\n *     certificate (see forge.tls for details).\n *   getPrivateKey: an optional callback used to get a client-side\n *     private key (see forge.tls for details).\n *   getSignature: an optional callback used to get a client-side\n *     signature (see forge.tls for details).\n *   persistCookies: true to use persistent cookies via flash local\n *     storage, false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on\n *     their creation so that they will cache TLS sessions for reuse.\n *\n * @return the client.\n */\n\n\nhttp.createClient = function (options) {\n  // create CA store to share with all TLS connections\n  var caStore = null;\n\n  if (options.caCerts) {\n    caStore = forge.pki.createCaStore(options.caCerts);\n  } // get scheme, host, and port from url\n\n\n  options.url = options.url || window.location.protocol + '//' + window.location.host;\n  var url;\n\n  try {\n    url = new URL(options.url);\n  } catch (e) {\n    var error = new Error('Invalid url.');\n    error.details = {\n      url: options.url\n    };\n    throw error;\n  } // default to 1 connection\n\n\n  options.connections = options.connections || 1; // create client\n\n  var sp = options.socketPool;\n  var client = {\n    // url\n    url: url,\n    // socket pool\n    socketPool: sp,\n    // the policy port to use\n    policyPort: options.policyPort,\n    // policy url to use\n    policyUrl: options.policyUrl,\n    // queue of requests to service\n    requests: [],\n    // all sockets\n    sockets: [],\n    // idle sockets\n    idle: [],\n    // whether or not the connections are secure\n    secure: url.protocol === 'https:',\n    // cookie jar (key'd off of name and then path, there is only 1 domain\n    // and one setting for secure per client so name+path is unique)\n    cookies: {},\n    // default to flash storage of cookies\n    persistCookies: typeof options.persistCookies === 'undefined' ? true : options.persistCookies\n  }; // load cookies from disk\n\n  _loadCookies(client);\n  /**\n   * A default certificate verify function that checks a certificate common\n   * name against the client's URL host.\n   *\n   * @param c the TLS connection.\n   * @param verified true if cert is verified, otherwise alert number.\n   * @param depth the chain depth.\n   * @param certs the cert chain.\n   *\n   * @return true if verified and the common name matches the host, error\n   *         otherwise.\n   */\n\n\n  var _defaultCertificateVerify = function (c, verified, depth, certs) {\n    if (depth === 0 && verified === true) {\n      // compare common name to url host\n      var cn = certs[depth].subject.getField('CN');\n\n      if (cn === null || client.url.hostname !== cn.value) {\n        verified = {\n          message: 'Certificate common name does not match url host.'\n        };\n      }\n    }\n\n    return verified;\n  }; // determine if TLS is used\n\n\n  var tlsOptions = null;\n\n  if (client.secure) {\n    tlsOptions = {\n      caStore: caStore,\n      cipherSuites: options.cipherSuites || null,\n      virtualHost: options.virtualHost || url.hostname,\n      verify: options.verify || _defaultCertificateVerify,\n      getCertificate: options.getCertificate || null,\n      getPrivateKey: options.getPrivateKey || null,\n      getSignature: options.getSignature || null,\n      prime: options.primeTlsSockets || false\n    }; // if socket pool uses a flash api, then add deflate support to TLS\n\n    if (sp.flashApi !== null) {\n      tlsOptions.deflate = function (bytes) {\n        // strip 2 byte zlib header and 4 byte trailer\n        return forge.util.deflate(sp.flashApi, bytes, true);\n      };\n\n      tlsOptions.inflate = function (bytes) {\n        return forge.util.inflate(sp.flashApi, bytes, true);\n      };\n    }\n  } // create and initialize sockets\n\n\n  for (var i = 0; i < options.connections; ++i) {\n    _initSocket(client, sp.createSocket(), tlsOptions);\n  }\n  /**\n   * Sends a request. A method 'abort' will be set on the request that\n   * can be called to attempt to abort the request.\n   *\n   * @param options:\n   *          request: the request to send.\n   *          connected: a callback for when the connection is open.\n   *          closed: a callback for when the connection is closed.\n   *          headerReady: a callback for when the response header arrives.\n   *          bodyReady: a callback for when the response body arrives.\n   *          error: a callback for if an error occurs.\n   */\n\n\n  client.send = function (options) {\n    // add host header if not set\n    if (options.request.getField('Host') === null) {\n      options.request.setField('Host', client.url.origin);\n    } // set default dummy handlers\n\n\n    var opts = {};\n    opts.request = options.request;\n\n    opts.connected = options.connected || function () {};\n\n    opts.closed = options.close || function () {};\n\n    opts.headerReady = function (e) {\n      // read cookies\n      _readCookies(client, e.response);\n\n      if (options.headerReady) {\n        options.headerReady(e);\n      }\n    };\n\n    opts.bodyReady = options.bodyReady || function () {};\n\n    opts.error = options.error || function () {}; // create response\n\n\n    opts.response = http.createResponse();\n    opts.response.time = 0;\n    opts.response.flashApi = client.socketPool.flashApi;\n    opts.request.flashApi = client.socketPool.flashApi; // create abort function\n\n    opts.request.abort = function () {\n      // set aborted, clear handlers\n      opts.request.aborted = true;\n\n      opts.connected = function () {};\n\n      opts.closed = function () {};\n\n      opts.headerReady = function () {};\n\n      opts.bodyReady = function () {};\n\n      opts.error = function () {};\n    }; // add cookies to request\n\n\n    _writeCookies(client, opts.request); // queue request options if there are no idle sockets\n\n\n    if (client.idle.length === 0) {\n      client.requests.push(opts);\n    } else {\n      // use an idle socket, prefer an idle *connected* socket first\n      var socket = null;\n      var len = client.idle.length;\n\n      for (var i = 0; socket === null && i < len; ++i) {\n        socket = client.idle[i];\n\n        if (socket.isConnected()) {\n          client.idle.splice(i, 1);\n        } else {\n          socket = null;\n        }\n      } // no connected socket available, get unconnected socket\n\n\n      if (socket === null) {\n        socket = client.idle.pop();\n      }\n\n      socket.options = opts;\n\n      _doRequest(client, socket);\n    }\n  };\n  /**\n   * Destroys this client.\n   */\n\n\n  client.destroy = function () {\n    // clear pending requests, close and destroy sockets\n    client.requests = [];\n\n    for (var i = 0; i < client.sockets.length; ++i) {\n      client.sockets[i].close();\n      client.sockets[i].destroy();\n    }\n\n    client.socketPool = null;\n    client.sockets = [];\n    client.idle = [];\n  };\n  /**\n   * Sets a cookie for use with all connections made by this client. Any\n   * cookie with the same name will be replaced. If the cookie's value\n   * is undefined, null, or the blank string, the cookie will be removed.\n   *\n   * If the cookie's domain doesn't match this client's url host or the\n   * cookie's secure flag doesn't match this client's url scheme, then\n   * setting the cookie will fail with an exception.\n   *\n   * @param cookie the cookie with parameters:\n   *   name: the name of the cookie.\n   *   value: the value of the cookie.\n   *   comment: an optional comment string.\n   *   maxAge: the age of the cookie in seconds relative to created time.\n   *   secure: true if the cookie must be sent over a secure protocol.\n   *   httpOnly: true to restrict access to the cookie from javascript\n   *     (inaffective since the cookies are stored in javascript).\n   *   path: the path for the cookie.\n   *   domain: optional domain the cookie belongs to (must start with dot).\n   *   version: optional version of the cookie.\n   *   created: creation time, in UTC seconds, of the cookie.\n   */\n\n\n  client.setCookie = function (cookie) {\n    var rval;\n\n    if (typeof cookie.name !== 'undefined') {\n      if (cookie.value === null || typeof cookie.value === 'undefined' || cookie.value === '') {\n        // remove cookie\n        rval = client.removeCookie(cookie.name, cookie.path);\n      } else {\n        // set cookie defaults\n        cookie.comment = cookie.comment || '';\n        cookie.maxAge = cookie.maxAge || 0;\n        cookie.secure = typeof cookie.secure === 'undefined' ? true : cookie.secure;\n        cookie.httpOnly = cookie.httpOnly || true;\n        cookie.path = cookie.path || '/';\n        cookie.domain = cookie.domain || null;\n        cookie.version = cookie.version || null;\n        cookie.created = _getUtcTime(new Date()); // do secure check\n\n        if (cookie.secure !== client.secure) {\n          var error = new Error('Http client url scheme is incompatible ' + 'with cookie secure flag.');\n          error.url = client.url;\n          error.cookie = cookie;\n          throw error;\n        } // make sure url host is within cookie.domain\n\n\n        if (!http.withinCookieDomain(client.url, cookie)) {\n          var error = new Error('Http client url scheme is incompatible ' + 'with cookie secure flag.');\n          error.url = client.url;\n          error.cookie = cookie;\n          throw error;\n        } // add new cookie\n\n\n        if (!(cookie.name in client.cookies)) {\n          client.cookies[cookie.name] = {};\n        }\n\n        client.cookies[cookie.name][cookie.path] = cookie;\n        rval = true; // save cookies\n\n        _saveCookies(client);\n      }\n    }\n\n    return rval;\n  };\n  /**\n   * Gets a cookie by its name.\n   *\n   * @param name the name of the cookie to retrieve.\n   * @param path an optional path for the cookie (if there are multiple\n   *          cookies with the same name but different paths).\n   *\n   * @return the cookie or null if not found.\n   */\n\n\n  client.getCookie = function (name, path) {\n    var rval = null;\n\n    if (name in client.cookies) {\n      var paths = client.cookies[name]; // get path-specific cookie\n\n      if (path) {\n        if (path in paths) {\n          rval = paths[path];\n        }\n      } else {\n        // get first cookie\n        for (var p in paths) {\n          rval = paths[p];\n          break;\n        }\n      }\n    }\n\n    return rval;\n  };\n  /**\n   * Removes a cookie.\n   *\n   * @param name the name of the cookie to remove.\n   * @param path an optional path for the cookie (if there are multiple\n   *          cookies with the same name but different paths).\n   *\n   * @return true if a cookie was removed, false if not.\n   */\n\n\n  client.removeCookie = function (name, path) {\n    var rval = false;\n\n    if (name in client.cookies) {\n      // delete the specific path\n      if (path) {\n        var paths = client.cookies[name];\n\n        if (path in paths) {\n          rval = true;\n          delete client.cookies[name][path]; // clean up entry if empty\n\n          var empty = true;\n\n          for (var i in client.cookies[name]) {\n            empty = false;\n            break;\n          }\n\n          if (empty) {\n            delete client.cookies[name];\n          }\n        }\n      } else {\n        // delete all cookies with the given name\n        rval = true;\n        delete client.cookies[name];\n      }\n    }\n\n    if (rval) {\n      // save cookies\n      _saveCookies(client);\n    }\n\n    return rval;\n  };\n  /**\n   * Clears all cookies stored in this client.\n   */\n\n\n  client.clearCookies = function () {\n    client.cookies = {};\n\n    _clearCookies(client);\n  };\n\n  if (forge.log) {\n    forge.log.debug('forge.http', 'created client', options);\n  }\n\n  return client;\n};\n/**\n * Trims the whitespace off of the beginning and end of a string.\n *\n * @param str the string to trim.\n *\n * @return the trimmed string.\n */\n\n\nvar _trimString = function (str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n};\n/**\n * Creates an http header object.\n *\n * @return the http header object.\n */\n\n\nvar _createHeader = function () {\n  var header = {\n    fields: {},\n    setField: function (name, value) {\n      // normalize field name, trim value\n      header.fields[_normalize(name)] = [_trimString('' + value)];\n    },\n    appendField: function (name, value) {\n      name = _normalize(name);\n\n      if (!(name in header.fields)) {\n        header.fields[name] = [];\n      }\n\n      header.fields[name].push(_trimString('' + value));\n    },\n    getField: function (name, index) {\n      var rval = null;\n      name = _normalize(name);\n\n      if (name in header.fields) {\n        index = index || 0;\n        rval = header.fields[name][index];\n      }\n\n      return rval;\n    }\n  };\n  return header;\n};\n/**\n * Gets the time in utc seconds given a date.\n *\n * @param d the date to use.\n *\n * @return the time in utc seconds.\n */\n\n\nvar _getUtcTime = function (d) {\n  var utc = +d + d.getTimezoneOffset() * 60000;\n  return Math.floor(+new Date() / 1000);\n};\n/**\n * Creates an http request.\n *\n * @param options:\n *          version: the version.\n *          method: the method.\n *          path: the path.\n *          body: the body.\n *          headers: custom header fields to add,\n *            eg: [{'Content-Length': 0}].\n *\n * @return the http request.\n */\n\n\nhttp.createRequest = function (options) {\n  options = options || {};\n\n  var request = _createHeader();\n\n  request.version = options.version || 'HTTP/1.1';\n  request.method = options.method || null;\n  request.path = options.path || null;\n  request.body = options.body || null;\n  request.bodyDeflated = false;\n  request.flashApi = null; // add custom headers\n\n  var headers = options.headers || [];\n\n  if (!forge.util.isArray(headers)) {\n    headers = [headers];\n  }\n\n  for (var i = 0; i < headers.length; ++i) {\n    for (var name in headers[i]) {\n      request.appendField(name, headers[i][name]);\n    }\n  }\n  /**\n   * Adds a cookie to the request 'Cookie' header.\n   *\n   * @param cookie a cookie to add.\n   */\n\n\n  request.addCookie = function (cookie) {\n    var value = '';\n    var field = request.getField('Cookie');\n\n    if (field !== null) {\n      // separate cookies by semi-colons\n      value = field + '; ';\n    } // get current time in utc seconds\n\n\n    var now = _getUtcTime(new Date()); // output cookie name and value\n\n\n    value += cookie.name + '=' + cookie.value;\n    request.setField('Cookie', value);\n  };\n  /**\n   * Converts an http request into a string that can be sent as an\n   * HTTP request. Does not include any data.\n   *\n   * @return the string representation of the request.\n   */\n\n\n  request.toString = function () {\n    /* Sample request header:\n      GET /some/path/?query HTTP/1.1\n      Host: www.someurl.com\n      Connection: close\n      Accept-Encoding: deflate\n      Accept: image/gif, text/html\n      User-Agent: Mozilla 4.0\n     */\n    // set default headers\n    if (request.getField('User-Agent') === null) {\n      request.setField('User-Agent', 'forge.http 1.0');\n    }\n\n    if (request.getField('Accept') === null) {\n      request.setField('Accept', '*/*');\n    }\n\n    if (request.getField('Connection') === null) {\n      request.setField('Connection', 'keep-alive');\n      request.setField('Keep-Alive', '115');\n    } // add Accept-Encoding if not specified\n\n\n    if (request.flashApi !== null && request.getField('Accept-Encoding') === null) {\n      request.setField('Accept-Encoding', 'deflate');\n    } // if the body isn't null, deflate it if its larger than 100 bytes\n\n\n    if (request.flashApi !== null && request.body !== null && request.getField('Content-Encoding') === null && !request.bodyDeflated && request.body.length > 100) {\n      // use flash to compress data\n      request.body = forge.util.deflate(request.flashApi, request.body);\n      request.bodyDeflated = true;\n      request.setField('Content-Encoding', 'deflate');\n      request.setField('Content-Length', request.body.length);\n    } else if (request.body !== null) {\n      // set content length for body\n      request.setField('Content-Length', request.body.length);\n    } // build start line\n\n\n    var rval = request.method.toUpperCase() + ' ' + request.path + ' ' + request.version + '\\r\\n'; // add each header\n\n    for (var name in request.fields) {\n      var fields = request.fields[name];\n\n      for (var i = 0; i < fields.length; ++i) {\n        rval += name + ': ' + fields[i] + '\\r\\n';\n      }\n    } // final terminating CRLF\n\n\n    rval += '\\r\\n';\n    return rval;\n  };\n\n  return request;\n};\n/**\n * Creates an empty http response header.\n *\n * @return the empty http response header.\n */\n\n\nhttp.createResponse = function () {\n  // private vars\n  var _first = true;\n  var _chunkSize = 0;\n  var _chunksFinished = false; // create response\n\n  var response = _createHeader();\n\n  response.version = null;\n  response.code = 0;\n  response.message = null;\n  response.body = null;\n  response.headerReceived = false;\n  response.bodyReceived = false;\n  response.flashApi = null;\n  /**\n   * Reads a line that ends in CRLF from a byte buffer.\n   *\n   * @param b the byte buffer.\n   *\n   * @return the line or null if none was found.\n   */\n\n  var _readCrlf = function (b) {\n    var line = null;\n    var i = b.data.indexOf('\\r\\n', b.read);\n\n    if (i != -1) {\n      // read line, skip CRLF\n      line = b.getBytes(i - b.read);\n      b.getBytes(2);\n    }\n\n    return line;\n  };\n  /**\n   * Parses a header field and appends it to the response.\n   *\n   * @param line the header field line.\n   */\n\n\n  var _parseHeader = function (line) {\n    var tmp = line.indexOf(':');\n    var name = line.substring(0, tmp++);\n    response.appendField(name, tmp < line.length ? line.substring(tmp) : '');\n  };\n  /**\n   * Reads an http response header from a buffer of bytes.\n   *\n   * @param b the byte buffer to parse the header from.\n   *\n   * @return true if the whole header was read, false if not.\n   */\n\n\n  response.readHeader = function (b) {\n    // read header lines (each ends in CRLF)\n    var line = '';\n\n    while (!response.headerReceived && line !== null) {\n      line = _readCrlf(b);\n\n      if (line !== null) {\n        // parse first line\n        if (_first) {\n          _first = false;\n          var tmp = line.split(' ');\n\n          if (tmp.length >= 3) {\n            response.version = tmp[0];\n            response.code = parseInt(tmp[1], 10);\n            response.message = tmp.slice(2).join(' ');\n          } else {\n            // invalid header\n            var error = new Error('Invalid http response header.');\n            error.details = {\n              'line': line\n            };\n            throw error;\n          }\n        } else if (line.length === 0) {\n          // handle final line, end of header\n          response.headerReceived = true;\n        } else {\n          _parseHeader(line);\n        }\n      }\n    }\n\n    return response.headerReceived;\n  };\n  /**\n   * Reads some chunked http response entity-body from the given buffer of\n   * bytes.\n   *\n   * @param b the byte buffer to read from.\n   *\n   * @return true if the whole body was read, false if not.\n   */\n\n\n  var _readChunkedBody = function (b) {\n    /* Chunked transfer-encoding sends data in a series of chunks,\n      followed by a set of 0-N http trailers.\n      The format is as follows:\n       chunk-size (in hex) CRLF\n      chunk data (with \"chunk-size\" many bytes) CRLF\n      ... (N many chunks)\n      chunk-size (of 0 indicating the last chunk) CRLF\n      N many http trailers followed by CRLF\n      blank line + CRLF (terminates the trailers)\n       If there are no http trailers, then after the chunk-size of 0,\n      there is still a single CRLF (indicating the blank line + CRLF\n      that terminates the trailers). In other words, you always terminate\n      the trailers with blank line + CRLF, regardless of 0-N trailers. */\n\n    /* From RFC-2616, section 3.6.1, here is the pseudo-code for\n    implementing chunked transfer-encoding:\n     length := 0\n    read chunk-size, chunk-extension (if any) and CRLF\n    while (chunk-size > 0) {\n      read chunk-data and CRLF\n      append chunk-data to entity-body\n      length := length + chunk-size\n      read chunk-size and CRLF\n    }\n    read entity-header\n    while (entity-header not empty) {\n      append entity-header to existing header fields\n      read entity-header\n    }\n    Content-Length := length\n    Remove \"chunked\" from Transfer-Encoding\n    */\n    var line = '';\n\n    while (line !== null && b.length() > 0) {\n      // if in the process of reading a chunk\n      if (_chunkSize > 0) {\n        // if there are not enough bytes to read chunk and its\n        // trailing CRLF,  we must wait for more data to be received\n        if (_chunkSize + 2 > b.length()) {\n          break;\n        } // read chunk data, skip CRLF\n\n\n        response.body += b.getBytes(_chunkSize);\n        b.getBytes(2);\n        _chunkSize = 0;\n      } else if (!_chunksFinished) {\n        // more chunks, read next chunk-size line\n        line = _readCrlf(b);\n\n        if (line !== null) {\n          // parse chunk-size (ignore any chunk extension)\n          _chunkSize = parseInt(line.split(';', 1)[0], 16);\n          _chunksFinished = _chunkSize === 0;\n        }\n      } else {\n        // chunks finished, read next trailer\n        line = _readCrlf(b);\n\n        while (line !== null) {\n          if (line.length > 0) {\n            // parse trailer\n            _parseHeader(line); // read next trailer\n\n\n            line = _readCrlf(b);\n          } else {\n            // body received\n            response.bodyReceived = true;\n            line = null;\n          }\n        }\n      }\n    }\n\n    return response.bodyReceived;\n  };\n  /**\n   * Reads an http response body from a buffer of bytes.\n   *\n   * @param b the byte buffer to read from.\n   *\n   * @return true if the whole body was read, false if not.\n   */\n\n\n  response.readBody = function (b) {\n    var contentLength = response.getField('Content-Length');\n    var transferEncoding = response.getField('Transfer-Encoding');\n\n    if (contentLength !== null) {\n      contentLength = parseInt(contentLength);\n    } // read specified length\n\n\n    if (contentLength !== null && contentLength >= 0) {\n      response.body = response.body || '';\n      response.body += b.getBytes(contentLength);\n      response.bodyReceived = response.body.length === contentLength;\n    } else if (transferEncoding !== null) {\n      // read chunked encoding\n      if (transferEncoding.indexOf('chunked') != -1) {\n        response.body = response.body || '';\n\n        _readChunkedBody(b);\n      } else {\n        var error = new Error('Unknown Transfer-Encoding.');\n        error.details = {\n          'transferEncoding': transferEncoding\n        };\n        throw error;\n      }\n    } else if (contentLength !== null && contentLength < 0 || contentLength === null && response.getField('Content-Type') !== null) {\n      // read all data in the buffer\n      response.body = response.body || '';\n      response.body += b.getBytes();\n      response.readBodyUntilClose = true;\n    } else {\n      // no body\n      response.body = null;\n      response.bodyReceived = true;\n    }\n\n    if (response.bodyReceived) {\n      response.time = +new Date() - response.time;\n    }\n\n    if (response.flashApi !== null && response.bodyReceived && response.body !== null && response.getField('Content-Encoding') === 'deflate') {\n      // inflate using flash api\n      response.body = forge.util.inflate(response.flashApi, response.body);\n    }\n\n    return response.bodyReceived;\n  };\n  /**\n   * Parses an array of cookies from the 'Set-Cookie' field, if present.\n   *\n   * @return the array of cookies.\n   */\n\n\n  response.getCookies = function () {\n    var rval = []; // get Set-Cookie field\n\n    if ('Set-Cookie' in response.fields) {\n      var field = response.fields['Set-Cookie']; // get current local time in seconds\n\n      var now = +new Date() / 1000; // regex for parsing 'name1=value1; name2=value2; name3'\n\n      var regex = /\\s*([^=]*)=?([^;]*)(;|$)/g; // examples:\n      // Set-Cookie: cookie1_name=cookie1_value; max-age=0; path=/\n      // Set-Cookie: c2=v2; expires=Thu, 21-Aug-2008 23:47:25 GMT; path=/\n\n      for (var i = 0; i < field.length; ++i) {\n        var fv = field[i];\n        var m;\n        regex.lastIndex = 0;\n        var first = true;\n        var cookie = {};\n\n        do {\n          m = regex.exec(fv);\n\n          if (m !== null) {\n            var name = _trimString(m[1]);\n\n            var value = _trimString(m[2]); // cookie_name=value\n\n\n            if (first) {\n              cookie.name = name;\n              cookie.value = value;\n              first = false;\n            } else {\n              // property_name=value\n              name = name.toLowerCase();\n\n              switch (name) {\n                case 'expires':\n                  // replace hyphens w/spaces so date will parse\n                  value = value.replace(/-/g, ' ');\n                  var secs = Date.parse(value) / 1000;\n                  cookie.maxAge = Math.max(0, secs - now);\n                  break;\n\n                case 'max-age':\n                  cookie.maxAge = parseInt(value, 10);\n                  break;\n\n                case 'secure':\n                  cookie.secure = true;\n                  break;\n\n                case 'httponly':\n                  cookie.httpOnly = true;\n                  break;\n\n                default:\n                  if (name !== '') {\n                    cookie[name] = value;\n                  }\n\n              }\n            }\n          }\n        } while (m !== null && m[0] !== '');\n\n        rval.push(cookie);\n      }\n    }\n\n    return rval;\n  };\n  /**\n   * Converts an http response into a string that can be sent as an\n   * HTTP response. Does not include any data.\n   *\n   * @return the string representation of the response.\n   */\n\n\n  response.toString = function () {\n    /* Sample response header:\n      HTTP/1.0 200 OK\n      Host: www.someurl.com\n      Connection: close\n     */\n    // build start line\n    var rval = response.version + ' ' + response.code + ' ' + response.message + '\\r\\n'; // add each header\n\n    for (var name in response.fields) {\n      var fields = response.fields[name];\n\n      for (var i = 0; i < fields.length; ++i) {\n        rval += name + ': ' + fields[i] + '\\r\\n';\n      }\n    } // final terminating CRLF\n\n\n    rval += '\\r\\n';\n    return rval;\n  };\n\n  return response;\n};\n/**\n * Returns true if the given url is within the given cookie's domain.\n *\n * @param url the url to check.\n * @param cookie the cookie or cookie domain to check.\n */\n\n\nhttp.withinCookieDomain = function (url, cookie) {\n  var rval = false; // cookie may be null, a cookie object, or a domain string\n\n  var domain = cookie === null || typeof cookie === 'string' ? cookie : cookie.domain; // any domain will do\n\n  if (domain === null) {\n    rval = true;\n  } else if (domain.charAt(0) === '.') {\n    // ensure domain starts with a '.'\n    // parse URL as necessary\n    if (typeof url === 'string') {\n      url = new URL(url);\n    } // add '.' to front of URL hostname to match against domain\n\n\n    var host = '.' + url.hostname; // if the host ends with domain then it falls within it\n\n    var idx = host.lastIndexOf(domain);\n\n    if (idx !== -1 && idx + domain.length === host.length) {\n      rval = true;\n    }\n  }\n\n  return rval;\n};","map":{"version":3,"names":["forge","require","http","module","exports","cat","_normalize","name","toLowerCase","replace","a","toUpperCase","_getStorageId","client","url","protocol","slice","hostname","port","_loadCookies","persistCookies","cookies","util","getItem","socketPool","flashApi","ex","_saveCookies","setItem","_clearCookies","clearItems","_doRequest","socket","isConnected","options","request","connectTime","Date","connected","type","id","connect","host","policyPort","policyUrl","_handleNextRequest","buffer","clear","pending","requests","length","shift","aborted","idle","push","retries","_initSocket","tlsOptions","e","close","out","toString","body","time","send","response","sending","closed","error","message","bytesAvailable","readBodyUntilClose","bodyReceived","bodyReady","data","bytes","receive","putBytes","headerReceived","readHeader","headerReady","readBody","value","getField","indexOf","version","tls","wrapSocket","sessionId","sessionCache","caStore","cipherSuites","virtualHost","verify","getCertificate","getPrivateKey","getSignature","deflate","inflate","createBuffer","sockets","prime","_hasCookieExpired","cookie","rval","maxAge","now","_getUtcTime","expires","created","_writeCookies","expired","paths","p","path","addCookie","i","removeCookie","_readCookies","getCookies","setCookie","createClient","caCerts","pki","createCaStore","window","location","URL","Error","details","connections","sp","secure","_defaultCertificateVerify","c","verified","depth","certs","cn","subject","primeTlsSockets","createSocket","setField","origin","opts","createResponse","abort","len","splice","pop","destroy","comment","httpOnly","domain","withinCookieDomain","getCookie","empty","clearCookies","log","debug","_trimString","str","_createHeader","header","fields","appendField","index","d","utc","getTimezoneOffset","Math","floor","createRequest","method","bodyDeflated","headers","isArray","field","_first","_chunkSize","_chunksFinished","code","_readCrlf","b","line","read","getBytes","_parseHeader","tmp","substring","split","parseInt","join","_readChunkedBody","contentLength","transferEncoding","regex","fv","m","lastIndex","first","exec","secs","parse","max","charAt","idx","lastIndexOf"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/node-forge/lib/http.js"],"sourcesContent":["/**\n * HTTP client-side implementation that uses forge.net sockets.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2010-2014 Digital Bazaar, Inc. All rights reserved.\n */\nvar forge = require('./forge');\nrequire('./tls');\nrequire('./util');\n\n// define http namespace\nvar http = module.exports = forge.http = forge.http || {};\n\n// logging category\nvar cat = 'forge.http';\n\n// normalizes an http header field name\nvar _normalize = function(name) {\n  return name.toLowerCase().replace(/(^.)|(-.)/g,\n    function(a) {return a.toUpperCase();});\n};\n\n/**\n * Gets the local storage ID for the given client.\n *\n * @param client the client to get the local storage ID for.\n *\n * @return the local storage ID to use.\n */\nvar _getStorageId = function(client) {\n  // TODO: include browser in ID to avoid sharing cookies between\n  // browsers (if this is undesirable)\n  // navigator.userAgent\n  return 'forge.http.' +\n    client.url.protocol.slice(0, -1) + '.' +\n    client.url.hostname + '.' +\n    client.url.port;\n};\n\n/**\n * Loads persistent cookies from disk for the given client.\n *\n * @param client the client.\n */\nvar _loadCookies = function(client) {\n  if(client.persistCookies) {\n    try {\n      var cookies = forge.util.getItem(\n        client.socketPool.flashApi,\n        _getStorageId(client), 'cookies');\n      client.cookies = cookies || {};\n    } catch(ex) {\n      // no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n};\n\n/**\n * Saves persistent cookies on disk for the given client.\n *\n * @param client the client.\n */\nvar _saveCookies = function(client) {\n  if(client.persistCookies) {\n    try {\n      forge.util.setItem(\n        client.socketPool.flashApi,\n        _getStorageId(client), 'cookies', client.cookies);\n    } catch(ex) {\n      // no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n\n  // FIXME: remove me\n  _loadCookies(client);\n};\n\n/**\n * Clears persistent cookies on disk for the given client.\n *\n * @param client the client.\n */\nvar _clearCookies = function(client) {\n  if(client.persistCookies) {\n    try {\n      // only thing stored is 'cookies', so clear whole storage\n      forge.util.clearItems(\n        client.socketPool.flashApi,\n        _getStorageId(client));\n    } catch(ex) {\n      // no flash storage available, just silently fail\n      // TODO: i assume we want this logged somewhere or\n      // should it actually generate an error\n      //forge.log.error(cat, ex);\n    }\n  }\n};\n\n/**\n * Connects and sends a request.\n *\n * @param client the http client.\n * @param socket the socket to use.\n */\nvar _doRequest = function(client, socket) {\n  if(socket.isConnected()) {\n    // already connected\n    socket.options.request.connectTime = +new Date();\n    socket.connected({\n      type: 'connect',\n      id: socket.id\n    });\n  } else {\n    // connect\n    socket.options.request.connectTime = +new Date();\n    socket.connect({\n      host: client.url.hostname,\n      port: client.url.port,\n      policyPort: client.policyPort,\n      policyUrl: client.policyUrl\n    });\n  }\n};\n\n/**\n * Handles the next request or marks a socket as idle.\n *\n * @param client the http client.\n * @param socket the socket.\n */\nvar _handleNextRequest = function(client, socket) {\n  // clear buffer\n  socket.buffer.clear();\n\n  // get pending request\n  var pending = null;\n  while(pending === null && client.requests.length > 0) {\n    pending = client.requests.shift();\n    if(pending.request.aborted) {\n      pending = null;\n    }\n  }\n\n  // mark socket idle if no pending requests\n  if(pending === null) {\n    if(socket.options !== null) {\n      socket.options = null;\n    }\n    client.idle.push(socket);\n  } else {\n    // handle pending request, allow 1 retry\n    socket.retries = 1;\n    socket.options = pending;\n    _doRequest(client, socket);\n  }\n};\n\n/**\n * Sets up a socket for use with an http client.\n *\n * @param client the parent http client.\n * @param socket the socket to set up.\n * @param tlsOptions if the socket must use TLS, the TLS options.\n */\nvar _initSocket = function(client, socket, tlsOptions) {\n  // no socket options yet\n  socket.options = null;\n\n  // set up handlers\n  socket.connected = function(e) {\n    // socket primed by caching TLS session, handle next request\n    if(socket.options === null) {\n      _handleNextRequest(client, socket);\n    } else {\n      // socket in use\n      var request = socket.options.request;\n      request.connectTime = +new Date() - request.connectTime;\n      e.socket = socket;\n      socket.options.connected(e);\n      if(request.aborted) {\n        socket.close();\n      } else {\n        var out = request.toString();\n        if(request.body) {\n          out += request.body;\n        }\n        request.time = +new Date();\n        socket.send(out);\n        request.time = +new Date() - request.time;\n        socket.options.response.time = +new Date();\n        socket.sending = true;\n      }\n    }\n  };\n  socket.closed = function(e) {\n    if(socket.sending) {\n      socket.sending = false;\n      if(socket.retries > 0) {\n        --socket.retries;\n        _doRequest(client, socket);\n      } else {\n        // error, closed during send\n        socket.error({\n          id: socket.id,\n          type: 'ioError',\n          message: 'Connection closed during send. Broken pipe.',\n          bytesAvailable: 0\n        });\n      }\n    } else {\n      // handle unspecified content-length transfer\n      var response = socket.options.response;\n      if(response.readBodyUntilClose) {\n        response.time = +new Date() - response.time;\n        response.bodyReceived = true;\n        socket.options.bodyReady({\n          request: socket.options.request,\n          response: response,\n          socket: socket\n        });\n      }\n      socket.options.closed(e);\n      _handleNextRequest(client, socket);\n    }\n  };\n  socket.data = function(e) {\n    socket.sending = false;\n    var request = socket.options.request;\n    if(request.aborted) {\n      socket.close();\n    } else {\n      // receive all bytes available\n      var response = socket.options.response;\n      var bytes = socket.receive(e.bytesAvailable);\n      if(bytes !== null) {\n        // receive header and then body\n        socket.buffer.putBytes(bytes);\n        if(!response.headerReceived) {\n          response.readHeader(socket.buffer);\n          if(response.headerReceived) {\n            socket.options.headerReady({\n              request: socket.options.request,\n              response: response,\n              socket: socket\n            });\n          }\n        }\n        if(response.headerReceived && !response.bodyReceived) {\n          response.readBody(socket.buffer);\n        }\n        if(response.bodyReceived) {\n          socket.options.bodyReady({\n            request: socket.options.request,\n            response: response,\n            socket: socket\n          });\n          // close connection if requested or by default on http/1.0\n          var value = response.getField('Connection') || '';\n          if(value.indexOf('close') != -1 ||\n            (response.version === 'HTTP/1.0' &&\n            response.getField('Keep-Alive') === null)) {\n            socket.close();\n          } else {\n            _handleNextRequest(client, socket);\n          }\n        }\n      }\n    }\n  };\n  socket.error = function(e) {\n    // do error callback, include request\n    socket.options.error({\n      type: e.type,\n      message: e.message,\n      request: socket.options.request,\n      response: socket.options.response,\n      socket: socket\n    });\n    socket.close();\n  };\n\n  // wrap socket for TLS\n  if(tlsOptions) {\n    socket = forge.tls.wrapSocket({\n      sessionId: null,\n      sessionCache: {},\n      caStore: tlsOptions.caStore,\n      cipherSuites: tlsOptions.cipherSuites,\n      socket: socket,\n      virtualHost: tlsOptions.virtualHost,\n      verify: tlsOptions.verify,\n      getCertificate: tlsOptions.getCertificate,\n      getPrivateKey: tlsOptions.getPrivateKey,\n      getSignature: tlsOptions.getSignature,\n      deflate: tlsOptions.deflate || null,\n      inflate: tlsOptions.inflate || null\n    });\n\n    socket.options = null;\n    socket.buffer = forge.util.createBuffer();\n    client.sockets.push(socket);\n    if(tlsOptions.prime) {\n      // prime socket by connecting and caching TLS session, will do\n      // next request from there\n      socket.connect({\n        host: client.url.hostname,\n        port: client.url.port,\n        policyPort: client.policyPort,\n        policyUrl: client.policyUrl\n      });\n    } else {\n      // do not prime socket, just add as idle\n      client.idle.push(socket);\n    }\n  } else {\n    // no need to prime non-TLS sockets\n    socket.buffer = forge.util.createBuffer();\n    client.sockets.push(socket);\n    client.idle.push(socket);\n  }\n};\n\n/**\n * Checks to see if the given cookie has expired. If the cookie's max-age\n * plus its created time is less than the time now, it has expired, unless\n * its max-age is set to -1 which indicates it will never expire.\n *\n * @param cookie the cookie to check.\n *\n * @return true if it has expired, false if not.\n */\nvar _hasCookieExpired = function(cookie) {\n  var rval = false;\n\n  if(cookie.maxAge !== -1) {\n    var now = _getUtcTime(new Date());\n    var expires = cookie.created + cookie.maxAge;\n    if(expires <= now) {\n      rval = true;\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Adds cookies in the given client to the given request.\n *\n * @param client the client.\n * @param request the request.\n */\nvar _writeCookies = function(client, request) {\n  var expired = [];\n  var url = client.url;\n  var cookies = client.cookies;\n  for(var name in cookies) {\n    // get cookie paths\n    var paths = cookies[name];\n    for(var p in paths) {\n      var cookie = paths[p];\n      if(_hasCookieExpired(cookie)) {\n        // store for clean up\n        expired.push(cookie);\n      } else if(request.path.indexOf(cookie.path) === 0) {\n        // path or path's ancestor must match cookie.path\n        request.addCookie(cookie);\n      }\n    }\n  }\n\n  // clean up expired cookies\n  for(var i = 0; i < expired.length; ++i) {\n    var cookie = expired[i];\n    client.removeCookie(cookie.name, cookie.path);\n  }\n};\n\n/**\n * Gets cookies from the given response and adds the to the given client.\n *\n * @param client the client.\n * @param response the response.\n */\nvar _readCookies = function(client, response) {\n  var cookies = response.getCookies();\n  for(var i = 0; i < cookies.length; ++i) {\n    try {\n      client.setCookie(cookies[i]);\n    } catch(ex) {\n      // ignore failure to add other-domain, etc. cookies\n    }\n  }\n};\n\n/**\n * Creates an http client that uses forge.net sockets as a backend and\n * forge.tls for security.\n *\n * @param options:\n *   url: the url to connect to (scheme://host:port).\n *   socketPool: the flash socket pool to use.\n *   policyPort: the flash policy port to use (if other than the\n *     socket pool default), use 0 for flash default.\n *   policyUrl: the flash policy file URL to use (if provided will\n *     be used instead of a policy port).\n *   connections: number of connections to use to handle requests.\n *   caCerts: an array of certificates to trust for TLS, certs may\n *     be PEM-formatted or cert objects produced via forge.pki.\n *   cipherSuites: an optional array of cipher suites to use,\n *     see forge.tls.CipherSuites.\n *   virtualHost: the virtual server name to use in a TLS SNI\n *     extension, if not provided the url host will be used.\n *   verify: a custom TLS certificate verify callback to use.\n *   getCertificate: an optional callback used to get a client-side\n *     certificate (see forge.tls for details).\n *   getPrivateKey: an optional callback used to get a client-side\n *     private key (see forge.tls for details).\n *   getSignature: an optional callback used to get a client-side\n *     signature (see forge.tls for details).\n *   persistCookies: true to use persistent cookies via flash local\n *     storage, false to only keep cookies in javascript.\n *   primeTlsSockets: true to immediately connect TLS sockets on\n *     their creation so that they will cache TLS sessions for reuse.\n *\n * @return the client.\n */\nhttp.createClient = function(options) {\n  // create CA store to share with all TLS connections\n  var caStore = null;\n  if(options.caCerts) {\n    caStore = forge.pki.createCaStore(options.caCerts);\n  }\n\n  // get scheme, host, and port from url\n  options.url = (options.url ||\n    window.location.protocol + '//' + window.location.host);\n  var url;\n  try {\n    url = new URL(options.url);\n  } catch(e) {\n    var error = new Error('Invalid url.');\n    error.details = {url: options.url};\n    throw error;\n  }\n\n  // default to 1 connection\n  options.connections = options.connections || 1;\n\n  // create client\n  var sp = options.socketPool;\n  var client = {\n    // url\n    url: url,\n    // socket pool\n    socketPool: sp,\n    // the policy port to use\n    policyPort: options.policyPort,\n    // policy url to use\n    policyUrl: options.policyUrl,\n    // queue of requests to service\n    requests: [],\n    // all sockets\n    sockets: [],\n    // idle sockets\n    idle: [],\n    // whether or not the connections are secure\n    secure: (url.protocol === 'https:'),\n    // cookie jar (key'd off of name and then path, there is only 1 domain\n    // and one setting for secure per client so name+path is unique)\n    cookies: {},\n    // default to flash storage of cookies\n    persistCookies: (typeof(options.persistCookies) === 'undefined') ?\n      true : options.persistCookies\n  };\n\n  // load cookies from disk\n  _loadCookies(client);\n\n  /**\n   * A default certificate verify function that checks a certificate common\n   * name against the client's URL host.\n   *\n   * @param c the TLS connection.\n   * @param verified true if cert is verified, otherwise alert number.\n   * @param depth the chain depth.\n   * @param certs the cert chain.\n   *\n   * @return true if verified and the common name matches the host, error\n   *         otherwise.\n   */\n  var _defaultCertificateVerify = function(c, verified, depth, certs) {\n    if(depth === 0 && verified === true) {\n      // compare common name to url host\n      var cn = certs[depth].subject.getField('CN');\n      if(cn === null || client.url.hostname !== cn.value) {\n        verified = {\n          message: 'Certificate common name does not match url host.'\n        };\n      }\n    }\n    return verified;\n  };\n\n  // determine if TLS is used\n  var tlsOptions = null;\n  if(client.secure) {\n    tlsOptions = {\n      caStore: caStore,\n      cipherSuites: options.cipherSuites || null,\n      virtualHost: options.virtualHost || url.hostname,\n      verify: options.verify || _defaultCertificateVerify,\n      getCertificate: options.getCertificate || null,\n      getPrivateKey: options.getPrivateKey || null,\n      getSignature: options.getSignature || null,\n      prime: options.primeTlsSockets || false\n    };\n\n    // if socket pool uses a flash api, then add deflate support to TLS\n    if(sp.flashApi !== null) {\n      tlsOptions.deflate = function(bytes) {\n        // strip 2 byte zlib header and 4 byte trailer\n        return forge.util.deflate(sp.flashApi, bytes, true);\n      };\n      tlsOptions.inflate = function(bytes) {\n        return forge.util.inflate(sp.flashApi, bytes, true);\n      };\n    }\n  }\n\n  // create and initialize sockets\n  for(var i = 0; i < options.connections; ++i) {\n    _initSocket(client, sp.createSocket(), tlsOptions);\n  }\n\n  /**\n   * Sends a request. A method 'abort' will be set on the request that\n   * can be called to attempt to abort the request.\n   *\n   * @param options:\n   *          request: the request to send.\n   *          connected: a callback for when the connection is open.\n   *          closed: a callback for when the connection is closed.\n   *          headerReady: a callback for when the response header arrives.\n   *          bodyReady: a callback for when the response body arrives.\n   *          error: a callback for if an error occurs.\n   */\n  client.send = function(options) {\n    // add host header if not set\n    if(options.request.getField('Host') === null) {\n      options.request.setField('Host', client.url.origin);\n    }\n\n    // set default dummy handlers\n    var opts = {};\n    opts.request = options.request;\n    opts.connected = options.connected || function() {};\n    opts.closed = options.close || function() {};\n    opts.headerReady = function(e) {\n      // read cookies\n      _readCookies(client, e.response);\n      if(options.headerReady) {\n        options.headerReady(e);\n      }\n    };\n    opts.bodyReady = options.bodyReady || function() {};\n    opts.error = options.error || function() {};\n\n    // create response\n    opts.response = http.createResponse();\n    opts.response.time = 0;\n    opts.response.flashApi = client.socketPool.flashApi;\n    opts.request.flashApi = client.socketPool.flashApi;\n\n    // create abort function\n    opts.request.abort = function() {\n      // set aborted, clear handlers\n      opts.request.aborted = true;\n      opts.connected = function() {};\n      opts.closed = function() {};\n      opts.headerReady = function() {};\n      opts.bodyReady = function() {};\n      opts.error = function() {};\n    };\n\n    // add cookies to request\n    _writeCookies(client, opts.request);\n\n    // queue request options if there are no idle sockets\n    if(client.idle.length === 0) {\n      client.requests.push(opts);\n    } else {\n      // use an idle socket, prefer an idle *connected* socket first\n      var socket = null;\n      var len = client.idle.length;\n      for(var i = 0; socket === null && i < len; ++i) {\n        socket = client.idle[i];\n        if(socket.isConnected()) {\n          client.idle.splice(i, 1);\n        } else {\n          socket = null;\n        }\n      }\n      // no connected socket available, get unconnected socket\n      if(socket === null) {\n        socket = client.idle.pop();\n      }\n      socket.options = opts;\n      _doRequest(client, socket);\n    }\n  };\n\n  /**\n   * Destroys this client.\n   */\n  client.destroy = function() {\n    // clear pending requests, close and destroy sockets\n    client.requests = [];\n    for(var i = 0; i < client.sockets.length; ++i) {\n      client.sockets[i].close();\n      client.sockets[i].destroy();\n    }\n    client.socketPool = null;\n    client.sockets = [];\n    client.idle = [];\n  };\n\n  /**\n   * Sets a cookie for use with all connections made by this client. Any\n   * cookie with the same name will be replaced. If the cookie's value\n   * is undefined, null, or the blank string, the cookie will be removed.\n   *\n   * If the cookie's domain doesn't match this client's url host or the\n   * cookie's secure flag doesn't match this client's url scheme, then\n   * setting the cookie will fail with an exception.\n   *\n   * @param cookie the cookie with parameters:\n   *   name: the name of the cookie.\n   *   value: the value of the cookie.\n   *   comment: an optional comment string.\n   *   maxAge: the age of the cookie in seconds relative to created time.\n   *   secure: true if the cookie must be sent over a secure protocol.\n   *   httpOnly: true to restrict access to the cookie from javascript\n   *     (inaffective since the cookies are stored in javascript).\n   *   path: the path for the cookie.\n   *   domain: optional domain the cookie belongs to (must start with dot).\n   *   version: optional version of the cookie.\n   *   created: creation time, in UTC seconds, of the cookie.\n   */\n  client.setCookie = function(cookie) {\n    var rval;\n    if(typeof(cookie.name) !== 'undefined') {\n      if(cookie.value === null || typeof(cookie.value) === 'undefined' ||\n        cookie.value === '') {\n        // remove cookie\n        rval = client.removeCookie(cookie.name, cookie.path);\n      } else {\n        // set cookie defaults\n        cookie.comment = cookie.comment || '';\n        cookie.maxAge = cookie.maxAge || 0;\n        cookie.secure = (typeof(cookie.secure) === 'undefined') ?\n          true : cookie.secure;\n        cookie.httpOnly = cookie.httpOnly || true;\n        cookie.path = cookie.path || '/';\n        cookie.domain = cookie.domain || null;\n        cookie.version = cookie.version || null;\n        cookie.created = _getUtcTime(new Date());\n\n        // do secure check\n        if(cookie.secure !== client.secure) {\n          var error = new Error('Http client url scheme is incompatible ' +\n            'with cookie secure flag.');\n          error.url = client.url;\n          error.cookie = cookie;\n          throw error;\n        }\n        // make sure url host is within cookie.domain\n        if(!http.withinCookieDomain(client.url, cookie)) {\n          var error = new Error('Http client url scheme is incompatible ' +\n            'with cookie secure flag.');\n          error.url = client.url;\n          error.cookie = cookie;\n          throw error;\n        }\n\n        // add new cookie\n        if(!(cookie.name in client.cookies)) {\n          client.cookies[cookie.name] = {};\n        }\n        client.cookies[cookie.name][cookie.path] = cookie;\n        rval = true;\n\n        // save cookies\n        _saveCookies(client);\n      }\n    }\n\n    return rval;\n  };\n\n  /**\n   * Gets a cookie by its name.\n   *\n   * @param name the name of the cookie to retrieve.\n   * @param path an optional path for the cookie (if there are multiple\n   *          cookies with the same name but different paths).\n   *\n   * @return the cookie or null if not found.\n   */\n  client.getCookie = function(name, path) {\n    var rval = null;\n    if(name in client.cookies) {\n      var paths = client.cookies[name];\n\n      // get path-specific cookie\n      if(path) {\n        if(path in paths) {\n          rval = paths[path];\n        }\n      } else {\n        // get first cookie\n        for(var p in paths) {\n          rval = paths[p];\n          break;\n        }\n      }\n    }\n    return rval;\n  };\n\n  /**\n   * Removes a cookie.\n   *\n   * @param name the name of the cookie to remove.\n   * @param path an optional path for the cookie (if there are multiple\n   *          cookies with the same name but different paths).\n   *\n   * @return true if a cookie was removed, false if not.\n   */\n  client.removeCookie = function(name, path) {\n    var rval = false;\n    if(name in client.cookies) {\n      // delete the specific path\n      if(path) {\n        var paths = client.cookies[name];\n        if(path in paths) {\n          rval = true;\n          delete client.cookies[name][path];\n          // clean up entry if empty\n          var empty = true;\n          for(var i in client.cookies[name]) {\n            empty = false;\n            break;\n          }\n          if(empty) {\n            delete client.cookies[name];\n          }\n        }\n      } else {\n        // delete all cookies with the given name\n        rval = true;\n        delete client.cookies[name];\n      }\n    }\n    if(rval) {\n      // save cookies\n      _saveCookies(client);\n    }\n    return rval;\n  };\n\n  /**\n   * Clears all cookies stored in this client.\n   */\n  client.clearCookies = function() {\n    client.cookies = {};\n    _clearCookies(client);\n  };\n\n  if(forge.log) {\n    forge.log.debug('forge.http', 'created client', options);\n  }\n\n  return client;\n};\n\n/**\n * Trims the whitespace off of the beginning and end of a string.\n *\n * @param str the string to trim.\n *\n * @return the trimmed string.\n */\nvar _trimString = function(str) {\n  return str.replace(/^\\s*/, '').replace(/\\s*$/, '');\n};\n\n/**\n * Creates an http header object.\n *\n * @return the http header object.\n */\nvar _createHeader = function() {\n  var header = {\n    fields: {},\n    setField: function(name, value) {\n      // normalize field name, trim value\n      header.fields[_normalize(name)] = [_trimString('' + value)];\n    },\n    appendField: function(name, value) {\n      name = _normalize(name);\n      if(!(name in header.fields)) {\n        header.fields[name] = [];\n      }\n      header.fields[name].push(_trimString('' + value));\n    },\n    getField: function(name, index) {\n      var rval = null;\n      name = _normalize(name);\n      if(name in header.fields) {\n        index = index || 0;\n        rval = header.fields[name][index];\n      }\n      return rval;\n    }\n  };\n  return header;\n};\n\n/**\n * Gets the time in utc seconds given a date.\n *\n * @param d the date to use.\n *\n * @return the time in utc seconds.\n */\nvar _getUtcTime = function(d) {\n  var utc = +d + d.getTimezoneOffset() * 60000;\n  return Math.floor(+new Date() / 1000);\n};\n\n/**\n * Creates an http request.\n *\n * @param options:\n *          version: the version.\n *          method: the method.\n *          path: the path.\n *          body: the body.\n *          headers: custom header fields to add,\n *            eg: [{'Content-Length': 0}].\n *\n * @return the http request.\n */\nhttp.createRequest = function(options) {\n  options = options || {};\n  var request = _createHeader();\n  request.version = options.version || 'HTTP/1.1';\n  request.method = options.method || null;\n  request.path = options.path || null;\n  request.body = options.body || null;\n  request.bodyDeflated = false;\n  request.flashApi = null;\n\n  // add custom headers\n  var headers = options.headers || [];\n  if(!forge.util.isArray(headers)) {\n    headers = [headers];\n  }\n  for(var i = 0; i < headers.length; ++i) {\n    for(var name in headers[i]) {\n      request.appendField(name, headers[i][name]);\n    }\n  }\n\n  /**\n   * Adds a cookie to the request 'Cookie' header.\n   *\n   * @param cookie a cookie to add.\n   */\n  request.addCookie = function(cookie) {\n    var value = '';\n    var field = request.getField('Cookie');\n    if(field !== null) {\n      // separate cookies by semi-colons\n      value = field + '; ';\n    }\n\n    // get current time in utc seconds\n    var now = _getUtcTime(new Date());\n\n    // output cookie name and value\n    value += cookie.name + '=' + cookie.value;\n    request.setField('Cookie', value);\n  };\n\n  /**\n   * Converts an http request into a string that can be sent as an\n   * HTTP request. Does not include any data.\n   *\n   * @return the string representation of the request.\n   */\n  request.toString = function() {\n    /* Sample request header:\n      GET /some/path/?query HTTP/1.1\n      Host: www.someurl.com\n      Connection: close\n      Accept-Encoding: deflate\n      Accept: image/gif, text/html\n      User-Agent: Mozilla 4.0\n     */\n\n    // set default headers\n    if(request.getField('User-Agent') === null) {\n      request.setField('User-Agent', 'forge.http 1.0');\n    }\n    if(request.getField('Accept') === null) {\n      request.setField('Accept', '*/*');\n    }\n    if(request.getField('Connection') === null) {\n      request.setField('Connection', 'keep-alive');\n      request.setField('Keep-Alive', '115');\n    }\n\n    // add Accept-Encoding if not specified\n    if(request.flashApi !== null &&\n      request.getField('Accept-Encoding') === null) {\n      request.setField('Accept-Encoding', 'deflate');\n    }\n\n    // if the body isn't null, deflate it if its larger than 100 bytes\n    if(request.flashApi !== null && request.body !== null &&\n      request.getField('Content-Encoding') === null &&\n      !request.bodyDeflated && request.body.length > 100) {\n      // use flash to compress data\n      request.body = forge.util.deflate(request.flashApi, request.body);\n      request.bodyDeflated = true;\n      request.setField('Content-Encoding', 'deflate');\n      request.setField('Content-Length', request.body.length);\n    } else if(request.body !== null) {\n      // set content length for body\n      request.setField('Content-Length', request.body.length);\n    }\n\n    // build start line\n    var rval =\n      request.method.toUpperCase() + ' ' + request.path + ' ' +\n      request.version + '\\r\\n';\n\n    // add each header\n    for(var name in request.fields) {\n      var fields = request.fields[name];\n      for(var i = 0; i < fields.length; ++i) {\n        rval += name + ': ' + fields[i] + '\\r\\n';\n      }\n    }\n    // final terminating CRLF\n    rval += '\\r\\n';\n\n    return rval;\n  };\n\n  return request;\n};\n\n/**\n * Creates an empty http response header.\n *\n * @return the empty http response header.\n */\nhttp.createResponse = function() {\n  // private vars\n  var _first = true;\n  var _chunkSize = 0;\n  var _chunksFinished = false;\n\n  // create response\n  var response = _createHeader();\n  response.version = null;\n  response.code = 0;\n  response.message = null;\n  response.body = null;\n  response.headerReceived = false;\n  response.bodyReceived = false;\n  response.flashApi = null;\n\n  /**\n   * Reads a line that ends in CRLF from a byte buffer.\n   *\n   * @param b the byte buffer.\n   *\n   * @return the line or null if none was found.\n   */\n  var _readCrlf = function(b) {\n    var line = null;\n    var i = b.data.indexOf('\\r\\n', b.read);\n    if(i != -1) {\n      // read line, skip CRLF\n      line = b.getBytes(i - b.read);\n      b.getBytes(2);\n    }\n    return line;\n  };\n\n  /**\n   * Parses a header field and appends it to the response.\n   *\n   * @param line the header field line.\n   */\n  var _parseHeader = function(line) {\n    var tmp = line.indexOf(':');\n    var name = line.substring(0, tmp++);\n    response.appendField(\n      name, (tmp < line.length) ? line.substring(tmp) : '');\n  };\n\n  /**\n   * Reads an http response header from a buffer of bytes.\n   *\n   * @param b the byte buffer to parse the header from.\n   *\n   * @return true if the whole header was read, false if not.\n   */\n  response.readHeader = function(b) {\n    // read header lines (each ends in CRLF)\n    var line = '';\n    while(!response.headerReceived && line !== null) {\n      line = _readCrlf(b);\n      if(line !== null) {\n        // parse first line\n        if(_first) {\n          _first = false;\n          var tmp = line.split(' ');\n          if(tmp.length >= 3) {\n            response.version = tmp[0];\n            response.code = parseInt(tmp[1], 10);\n            response.message = tmp.slice(2).join(' ');\n          } else {\n            // invalid header\n            var error = new Error('Invalid http response header.');\n            error.details = {'line': line};\n            throw error;\n          }\n        } else if(line.length === 0) {\n          // handle final line, end of header\n          response.headerReceived = true;\n        } else {\n          _parseHeader(line);\n        }\n      }\n    }\n\n    return response.headerReceived;\n  };\n\n  /**\n   * Reads some chunked http response entity-body from the given buffer of\n   * bytes.\n   *\n   * @param b the byte buffer to read from.\n   *\n   * @return true if the whole body was read, false if not.\n   */\n  var _readChunkedBody = function(b) {\n    /* Chunked transfer-encoding sends data in a series of chunks,\n      followed by a set of 0-N http trailers.\n      The format is as follows:\n\n      chunk-size (in hex) CRLF\n      chunk data (with \"chunk-size\" many bytes) CRLF\n      ... (N many chunks)\n      chunk-size (of 0 indicating the last chunk) CRLF\n      N many http trailers followed by CRLF\n      blank line + CRLF (terminates the trailers)\n\n      If there are no http trailers, then after the chunk-size of 0,\n      there is still a single CRLF (indicating the blank line + CRLF\n      that terminates the trailers). In other words, you always terminate\n      the trailers with blank line + CRLF, regardless of 0-N trailers. */\n\n      /* From RFC-2616, section 3.6.1, here is the pseudo-code for\n      implementing chunked transfer-encoding:\n\n      length := 0\n      read chunk-size, chunk-extension (if any) and CRLF\n      while (chunk-size > 0) {\n        read chunk-data and CRLF\n        append chunk-data to entity-body\n        length := length + chunk-size\n        read chunk-size and CRLF\n      }\n      read entity-header\n      while (entity-header not empty) {\n        append entity-header to existing header fields\n        read entity-header\n      }\n      Content-Length := length\n      Remove \"chunked\" from Transfer-Encoding\n    */\n\n    var line = '';\n    while(line !== null && b.length() > 0) {\n      // if in the process of reading a chunk\n      if(_chunkSize > 0) {\n        // if there are not enough bytes to read chunk and its\n        // trailing CRLF,  we must wait for more data to be received\n        if(_chunkSize + 2 > b.length()) {\n          break;\n        }\n\n        // read chunk data, skip CRLF\n        response.body += b.getBytes(_chunkSize);\n        b.getBytes(2);\n        _chunkSize = 0;\n      } else if(!_chunksFinished) {\n        // more chunks, read next chunk-size line\n        line = _readCrlf(b);\n        if(line !== null) {\n          // parse chunk-size (ignore any chunk extension)\n          _chunkSize = parseInt(line.split(';', 1)[0], 16);\n          _chunksFinished = (_chunkSize === 0);\n        }\n      } else {\n        // chunks finished, read next trailer\n        line = _readCrlf(b);\n        while(line !== null) {\n          if(line.length > 0) {\n            // parse trailer\n            _parseHeader(line);\n            // read next trailer\n            line = _readCrlf(b);\n          } else {\n            // body received\n            response.bodyReceived = true;\n            line = null;\n          }\n        }\n      }\n    }\n\n    return response.bodyReceived;\n  };\n\n  /**\n   * Reads an http response body from a buffer of bytes.\n   *\n   * @param b the byte buffer to read from.\n   *\n   * @return true if the whole body was read, false if not.\n   */\n  response.readBody = function(b) {\n    var contentLength = response.getField('Content-Length');\n    var transferEncoding = response.getField('Transfer-Encoding');\n    if(contentLength !== null) {\n      contentLength = parseInt(contentLength);\n    }\n\n    // read specified length\n    if(contentLength !== null && contentLength >= 0) {\n      response.body = response.body || '';\n      response.body += b.getBytes(contentLength);\n      response.bodyReceived = (response.body.length === contentLength);\n    } else if(transferEncoding !== null) {\n      // read chunked encoding\n      if(transferEncoding.indexOf('chunked') != -1) {\n        response.body = response.body || '';\n        _readChunkedBody(b);\n      } else {\n        var error = new Error('Unknown Transfer-Encoding.');\n        error.details = {'transferEncoding': transferEncoding};\n        throw error;\n      }\n    } else if((contentLength !== null && contentLength < 0) ||\n      (contentLength === null &&\n      response.getField('Content-Type') !== null)) {\n      // read all data in the buffer\n      response.body = response.body || '';\n      response.body += b.getBytes();\n      response.readBodyUntilClose = true;\n    } else {\n      // no body\n      response.body = null;\n      response.bodyReceived = true;\n    }\n\n    if(response.bodyReceived) {\n      response.time = +new Date() - response.time;\n    }\n\n    if(response.flashApi !== null &&\n      response.bodyReceived && response.body !== null &&\n      response.getField('Content-Encoding') === 'deflate') {\n      // inflate using flash api\n      response.body = forge.util.inflate(\n        response.flashApi, response.body);\n    }\n\n    return response.bodyReceived;\n  };\n\n   /**\n    * Parses an array of cookies from the 'Set-Cookie' field, if present.\n    *\n    * @return the array of cookies.\n    */\n   response.getCookies = function() {\n     var rval = [];\n\n     // get Set-Cookie field\n     if('Set-Cookie' in response.fields) {\n       var field = response.fields['Set-Cookie'];\n\n       // get current local time in seconds\n       var now = +new Date() / 1000;\n\n       // regex for parsing 'name1=value1; name2=value2; name3'\n       var regex = /\\s*([^=]*)=?([^;]*)(;|$)/g;\n\n       // examples:\n       // Set-Cookie: cookie1_name=cookie1_value; max-age=0; path=/\n       // Set-Cookie: c2=v2; expires=Thu, 21-Aug-2008 23:47:25 GMT; path=/\n       for(var i = 0; i < field.length; ++i) {\n         var fv = field[i];\n         var m;\n         regex.lastIndex = 0;\n         var first = true;\n         var cookie = {};\n         do {\n           m = regex.exec(fv);\n           if(m !== null) {\n             var name = _trimString(m[1]);\n             var value = _trimString(m[2]);\n\n             // cookie_name=value\n             if(first) {\n               cookie.name = name;\n               cookie.value = value;\n               first = false;\n             } else {\n               // property_name=value\n               name = name.toLowerCase();\n               switch(name) {\n               case 'expires':\n                 // replace hyphens w/spaces so date will parse\n                 value = value.replace(/-/g, ' ');\n                 var secs = Date.parse(value) / 1000;\n                 cookie.maxAge = Math.max(0, secs - now);\n                 break;\n               case 'max-age':\n                 cookie.maxAge = parseInt(value, 10);\n                 break;\n               case 'secure':\n                 cookie.secure = true;\n                 break;\n               case 'httponly':\n                 cookie.httpOnly = true;\n                 break;\n               default:\n                 if(name !== '') {\n                   cookie[name] = value;\n                 }\n               }\n             }\n           }\n         } while(m !== null && m[0] !== '');\n         rval.push(cookie);\n       }\n     }\n\n     return rval;\n  };\n\n  /**\n   * Converts an http response into a string that can be sent as an\n   * HTTP response. Does not include any data.\n   *\n   * @return the string representation of the response.\n   */\n  response.toString = function() {\n    /* Sample response header:\n      HTTP/1.0 200 OK\n      Host: www.someurl.com\n      Connection: close\n     */\n\n    // build start line\n    var rval =\n      response.version + ' ' + response.code + ' ' + response.message + '\\r\\n';\n\n    // add each header\n    for(var name in response.fields) {\n      var fields = response.fields[name];\n      for(var i = 0; i < fields.length; ++i) {\n        rval += name + ': ' + fields[i] + '\\r\\n';\n      }\n    }\n    // final terminating CRLF\n    rval += '\\r\\n';\n\n    return rval;\n  };\n\n  return response;\n};\n\n/**\n * Returns true if the given url is within the given cookie's domain.\n *\n * @param url the url to check.\n * @param cookie the cookie or cookie domain to check.\n */\nhttp.withinCookieDomain = function(url, cookie) {\n  var rval = false;\n\n  // cookie may be null, a cookie object, or a domain string\n  var domain = (cookie === null || typeof cookie === 'string') ?\n    cookie : cookie.domain;\n\n  // any domain will do\n  if(domain === null) {\n    rval = true;\n  } else if(domain.charAt(0) === '.') {\n    // ensure domain starts with a '.'\n    // parse URL as necessary\n    if(typeof url === 'string') {\n      url = new URL(url);\n    }\n\n    // add '.' to front of URL hostname to match against domain\n    var host = '.' + url.hostname;\n\n    // if the host ends with domain then it falls within it\n    var idx = host.lastIndexOf(domain);\n    if(idx !== -1 && (idx + domain.length === host.length)) {\n      rval = true;\n    }\n  }\n\n  return rval;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}