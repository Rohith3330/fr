{"ast":null,"code":"/**\n * @fileoverview Rule to flag constant comparisons and logical expressions that always/never short circuit\n * @author Jordan Eldredge <https://jordaneldredge.com>\n */\n\"use strict\";\n\nconst globals = require(\"globals\");\n\nconst {\n  isNullLiteral,\n  isConstant,\n  isReferenceToGlobalVariable,\n  isLogicalAssignmentOperator\n} = require(\"./utils/ast-utils\");\n\nconst NUMERIC_OR_STRING_BINARY_OPERATORS = new Set([\"+\", \"-\", \"*\", \"/\", \"%\", \"|\", \"^\", \"&\", \"**\", \"<<\", \">>\", \">>>\"]); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Test if an AST node has a statically knowable constant nullishness. Meaning,\n * it will always resolve to a constant value of either: `null`, `undefined`\n * or not `null` _or_ `undefined`. An expression that can vary between those\n * three states at runtime would return `false`.\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The AST node being tested.\n * @returns {boolean} Does `node` have constant nullishness?\n */\n\nfunction hasConstantNullishness(scope, node) {\n  switch (node.type) {\n    case \"ObjectExpression\": // Objects are never nullish\n\n    case \"ArrayExpression\": // Arrays are never nullish\n\n    case \"ArrowFunctionExpression\": // Functions never nullish\n\n    case \"FunctionExpression\": // Functions are never nullish\n\n    case \"ClassExpression\": // Classes are never nullish\n\n    case \"NewExpression\": // Objects are never nullish\n\n    case \"Literal\": // Nullish, or non-nullish, literals never change\n\n    case \"TemplateLiteral\": // A string is never nullish\n\n    case \"UpdateExpression\": // Numbers are never nullish\n\n    case \"BinaryExpression\":\n      // Numbers, strings, or booleans are never nullish\n      return true;\n\n    case \"CallExpression\":\n      {\n        if (node.callee.type !== \"Identifier\") {\n          return false;\n        }\n\n        const functionName = node.callee.name;\n        return (functionName === \"Boolean\" || functionName === \"String\" || functionName === \"Number\") && isReferenceToGlobalVariable(scope, node.callee);\n      }\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        return hasConstantNullishness(scope, node.right);\n      }\n      /*\n       * Handling short-circuiting assignment operators would require\n       * walking the scope. We won't attempt that (for now...) /\n       */\n\n\n      if (isLogicalAssignmentOperator(node.operator)) {\n        return false;\n      }\n      /*\n       * The remaining assignment expressions all result in a numeric or\n       * string (non-nullish) value:\n       *   \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"|=\", \"^=\", \"&=\"\n       */\n\n\n      return true;\n\n    case \"UnaryExpression\":\n      /*\n       * \"void\" Always returns `undefined`\n       * \"typeof\" All types are strings, and thus non-nullish\n       * \"!\" Boolean is never nullish\n       * \"delete\" Returns a boolean, which is never nullish\n       * Math operators always return numbers or strings, neither of which\n       * are non-nullish \"+\", \"-\", \"~\"\n       */\n      return true;\n\n    case \"SequenceExpression\":\n      {\n        const last = node.expressions[node.expressions.length - 1];\n        return hasConstantNullishness(scope, last);\n      }\n\n    case \"Identifier\":\n      return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n\n    case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n\n    case \"JSXFragment\":\n      return false;\n\n    default:\n      return false;\n  }\n}\n/**\n * Test if an AST node is a boolean value that never changes. Specifically we\n * test for:\n * 1. Literal booleans (`true` or `false`)\n * 2. Unary `!` expressions with a constant value\n * 3. Constant booleans created via the `Boolean` global function\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Is `node` guaranteed to be a boolean?\n */\n\n\nfunction isStaticBoolean(scope, node) {\n  switch (node.type) {\n    case \"Literal\":\n      return typeof node.value === \"boolean\";\n\n    case \"CallExpression\":\n      return node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\" && isReferenceToGlobalVariable(scope, node.callee) && (node.arguments.length === 0 || isConstant(scope, node.arguments[0], true));\n\n    case \"UnaryExpression\":\n      return node.operator === \"!\" && isConstant(scope, node.argument, true);\n\n    default:\n      return false;\n  }\n}\n/**\n * Test if an AST node will always give the same result when compared to a\n * boolean value. Note that comparison to boolean values is different than\n * truthiness.\n * https://262.ecma-international.org/5.1/#sec-11.9.3\n *\n * Javascript `==` operator works by converting the boolean to `1` (true) or\n * `+0` (false) and then checks the values `==` equality to that number.\n * @param {Scope} scope The scope in which node was found.\n * @param {ASTNode} node The node to test.\n * @returns {boolean} Will `node` always coerce to the same boolean value?\n */\n\n\nfunction hasConstantLooseBooleanComparison(scope, node) {\n  switch (node.type) {\n    case \"ObjectExpression\":\n    case \"ClassExpression\":\n      /**\n       * In theory objects like:\n       *\n       * `{toString: () => a}`\n       * `{valueOf: () => a}`\n       *\n       * Or a classes like:\n       *\n       * `class { static toString() { return a } }`\n       * `class { static valueOf() { return a } }`\n       *\n       * Are not constant verifiably when `inBooleanPosition` is\n       * false, but it's an edge case we've opted not to handle.\n       */\n      return true;\n\n    case \"ArrayExpression\":\n      {\n        const nonSpreadElements = node.elements.filter(e => // Elements can be `null` in sparse arrays: `[,,]`;\n        e !== null && e.type !== \"SpreadElement\");\n        /*\n         * Possible future direction if needed: We could check if the\n         * single value would result in variable boolean comparison.\n         * For now we will err on the side of caution since `[x]` could\n         * evaluate to `[0]` or `[1]`.\n         */\n\n        return node.elements.length === 0 || nonSpreadElements.length > 1;\n      }\n\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\":\n      return true;\n\n    case \"UnaryExpression\":\n      if (node.operator === \"void\" || // Always returns `undefined`\n      node.operator === \"typeof\" // All `typeof` strings, when coerced to number, are not 0 or 1.\n      ) {\n        return true;\n      }\n\n      if (node.operator === \"!\") {\n        return isConstant(scope, node.argument, true);\n      }\n      /*\n       * We won't try to reason about +, -, ~, or delete\n       * In theory, for the mathematical operators, we could look at the\n       * argument and try to determine if it coerces to a constant numeric\n       * value.\n       */\n\n\n      return false;\n\n    case \"NewExpression\":\n      // Objects might have custom `.valueOf` or `.toString`.\n      return false;\n\n    case \"CallExpression\":\n      {\n        if (node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\" && isReferenceToGlobalVariable(scope, node.callee)) {\n          return node.arguments.length === 0 || isConstant(scope, node.arguments[0], true);\n        }\n\n        return false;\n      }\n\n    case \"Literal\":\n      // True or false, literals never change\n      return true;\n\n    case \"Identifier\":\n      return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n\n    case \"TemplateLiteral\":\n      /*\n       * In theory we could try to check if the quasi are sufficient to\n       * prove that the expression will always be true, but it would be\n       * tricky to get right. For example: `000.${foo}000`\n       */\n      return node.expressions.length === 0;\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        return hasConstantLooseBooleanComparison(scope, node.right);\n      }\n      /*\n       * Handling short-circuiting assignment operators would require\n       * walking the scope. We won't attempt that (for now...)\n       *\n       * The remaining assignment expressions all result in a numeric or\n       * string (non-nullish) values which could be truthy or falsy:\n       *   \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"|=\", \"^=\", \"&=\"\n       */\n\n\n      return false;\n\n    case \"SequenceExpression\":\n      {\n        const last = node.expressions[node.expressions.length - 1];\n        return hasConstantLooseBooleanComparison(scope, last);\n      }\n\n    case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n\n    case \"JSXFragment\":\n      return false;\n\n    default:\n      return false;\n  }\n}\n/**\n * Test if an AST node will always give the same result when _strictly_ compared\n * to a boolean value. This can happen if the expression can never be boolean, or\n * if it is always the same boolean value.\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Will `node` always give the same result when compared to a\n * static boolean value?\n */\n\n\nfunction hasConstantStrictBooleanComparison(scope, node) {\n  switch (node.type) {\n    case \"ObjectExpression\": // Objects are not booleans\n\n    case \"ArrayExpression\": // Arrays are not booleans\n\n    case \"ArrowFunctionExpression\": // Functions are not booleans\n\n    case \"FunctionExpression\":\n    case \"ClassExpression\": // Classes are not booleans\n\n    case \"NewExpression\": // Objects are not booleans\n\n    case \"TemplateLiteral\": // Strings are not booleans\n\n    case \"Literal\": // True, false, or not boolean, literals never change.\n\n    case \"UpdateExpression\":\n      // Numbers are not booleans\n      return true;\n\n    case \"BinaryExpression\":\n      return NUMERIC_OR_STRING_BINARY_OPERATORS.has(node.operator);\n\n    case \"UnaryExpression\":\n      {\n        if (node.operator === \"delete\") {\n          return false;\n        }\n\n        if (node.operator === \"!\") {\n          return isConstant(scope, node.argument, true);\n        }\n        /*\n         * The remaining operators return either strings or numbers, neither\n         * of which are boolean.\n         */\n\n\n        return true;\n      }\n\n    case \"SequenceExpression\":\n      {\n        const last = node.expressions[node.expressions.length - 1];\n        return hasConstantStrictBooleanComparison(scope, last);\n      }\n\n    case \"Identifier\":\n      return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        return hasConstantStrictBooleanComparison(scope, node.right);\n      }\n      /*\n       * Handling short-circuiting assignment operators would require\n       * walking the scope. We won't attempt that (for now...)\n       */\n\n\n      if (isLogicalAssignmentOperator(node.operator)) {\n        return false;\n      }\n      /*\n       * The remaining assignment expressions all result in either a number\n       * or a string, neither of which can ever be boolean.\n       */\n\n\n      return true;\n\n    case \"CallExpression\":\n      {\n        if (node.callee.type !== \"Identifier\") {\n          return false;\n        }\n\n        const functionName = node.callee.name;\n\n        if ((functionName === \"String\" || functionName === \"Number\") && isReferenceToGlobalVariable(scope, node.callee)) {\n          return true;\n        }\n\n        if (functionName === \"Boolean\" && isReferenceToGlobalVariable(scope, node.callee)) {\n          return node.arguments.length === 0 || isConstant(scope, node.arguments[0], true);\n        }\n\n        return false;\n      }\n\n    case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n\n    case \"JSXFragment\":\n      return false;\n\n    default:\n      return false;\n  }\n}\n/**\n * Test if an AST node will always result in a newly constructed object\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Will `node` always be new?\n */\n\n\nfunction isAlwaysNew(scope, node) {\n  switch (node.type) {\n    case \"ObjectExpression\":\n    case \"ArrayExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"FunctionExpression\":\n    case \"ClassExpression\":\n      return true;\n\n    case \"NewExpression\":\n      {\n        if (node.callee.type !== \"Identifier\") {\n          return false;\n        }\n        /*\n         * All the built-in constructors are always new, but\n         * user-defined constructors could return a sentinel\n         * object.\n         *\n         * Catching these is especially useful for primitive constructures\n         * which return boxed values, a surprising gotcha' in JavaScript.\n         */\n\n\n        return Object.hasOwnProperty.call(globals.builtin, node.callee.name) && isReferenceToGlobalVariable(scope, node.callee);\n      }\n\n    case \"Literal\":\n      // Regular expressions are objects, and thus always new\n      return typeof node.regex === \"object\";\n\n    case \"SequenceExpression\":\n      {\n        const last = node.expressions[node.expressions.length - 1];\n        return isAlwaysNew(scope, last);\n      }\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        return isAlwaysNew(scope, node.right);\n      }\n\n      return false;\n\n    case \"ConditionalExpression\":\n      return isAlwaysNew(scope, node.consequent) && isAlwaysNew(scope, node.alternate);\n\n    case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n\n    case \"JSXFragment\":\n      return false;\n\n    default:\n      return false;\n  }\n}\n/**\n * Checks whether or not a node is `null` or `undefined`. Similar to the one\n * found in ast-utils.js, but this one correctly handles the edge case that\n * `undefined` has been redefined.\n * @param {Scope} scope Scope in which the expression was found.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\n\n\nfunction isNullOrUndefined(scope, node) {\n  return isNullLiteral(node) || node.type === \"Identifier\" && node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node) || node.type === \"UnaryExpression\" && node.operator === \"void\";\n}\n/**\n * Checks if one operand will cause the result to be constant.\n * @param {Scope} scope Scope in which the expression was found.\n * @param {ASTNode} a One side of the expression\n * @param {ASTNode} b The other side of the expression\n * @param {string} operator The binary expression operator\n * @returns {ASTNode | null} The node which will cause the expression to have a constant result.\n */\n\n\nfunction findBinaryExpressionConstantOperand(scope, a, b, operator) {\n  if (operator === \"==\" || operator === \"!=\") {\n    if (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b) || isStaticBoolean(scope, a) && hasConstantLooseBooleanComparison(scope, b)) {\n      return b;\n    }\n  } else if (operator === \"===\" || operator === \"!==\") {\n    if (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b) || isStaticBoolean(scope, a) && hasConstantStrictBooleanComparison(scope, b)) {\n      return b;\n    }\n  }\n\n  return null;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow expressions where the operation doesn't affect the value\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-constant-binary-expression\"\n    },\n    schema: [],\n    messages: {\n      constantBinaryOperand: \"Unexpected constant binary expression. Compares constantly with the {{otherSide}}-hand side of the `{{operator}}`.\",\n      constantShortCircuit: \"Unexpected constant {{property}} on the left-hand side of a `{{operator}}` expression.\",\n      alwaysNew: \"Unexpected comparison to newly constructed object. These two values can never be equal.\",\n      bothAlwaysNew: \"Unexpected comparison of two newly constructed objects. These two values can never be equal.\"\n    }\n  },\n\n  create(context) {\n    return {\n      LogicalExpression(node) {\n        const {\n          operator,\n          left\n        } = node;\n        const scope = context.getScope();\n\n        if ((operator === \"&&\" || operator === \"||\") && isConstant(scope, left, true)) {\n          context.report({\n            node: left,\n            messageId: \"constantShortCircuit\",\n            data: {\n              property: \"truthiness\",\n              operator\n            }\n          });\n        } else if (operator === \"??\" && hasConstantNullishness(scope, left)) {\n          context.report({\n            node: left,\n            messageId: \"constantShortCircuit\",\n            data: {\n              property: \"nullishness\",\n              operator\n            }\n          });\n        }\n      },\n\n      BinaryExpression(node) {\n        const scope = context.getScope();\n        const {\n          right,\n          left,\n          operator\n        } = node;\n        const rightConstantOperand = findBinaryExpressionConstantOperand(scope, left, right, operator);\n        const leftConstantOperand = findBinaryExpressionConstantOperand(scope, right, left, operator);\n\n        if (rightConstantOperand) {\n          context.report({\n            node: rightConstantOperand,\n            messageId: \"constantBinaryOperand\",\n            data: {\n              operator,\n              otherSide: \"left\"\n            }\n          });\n        } else if (leftConstantOperand) {\n          context.report({\n            node: leftConstantOperand,\n            messageId: \"constantBinaryOperand\",\n            data: {\n              operator,\n              otherSide: \"right\"\n            }\n          });\n        } else if (operator === \"===\" || operator === \"!==\") {\n          if (isAlwaysNew(scope, left)) {\n            context.report({\n              node: left,\n              messageId: \"alwaysNew\"\n            });\n          } else if (isAlwaysNew(scope, right)) {\n            context.report({\n              node: right,\n              messageId: \"alwaysNew\"\n            });\n          }\n        } else if (operator === \"==\" || operator === \"!=\") {\n          /*\n           * If both sides are \"new\", then both sides are objects and\n           * therefore they will be compared by reference even with `==`\n           * equality.\n           */\n          if (isAlwaysNew(scope, left) && isAlwaysNew(scope, right)) {\n            context.report({\n              node: left,\n              messageId: \"bothAlwaysNew\"\n            });\n          }\n        }\n      }\n      /*\n       * In theory we could handle short-circuiting assignment operators,\n       * for some constant values, but that would require walking the\n       * scope to find the value of the variable being assigned. This is\n       * dependant on https://github.com/eslint/eslint/issues/13776\n       *\n       * AssignmentExpression() {},\n       */\n\n\n    };\n  }\n\n};","map":{"version":3,"names":["globals","require","isNullLiteral","isConstant","isReferenceToGlobalVariable","isLogicalAssignmentOperator","NUMERIC_OR_STRING_BINARY_OPERATORS","Set","hasConstantNullishness","scope","node","type","callee","functionName","name","operator","right","last","expressions","length","isStaticBoolean","value","arguments","argument","hasConstantLooseBooleanComparison","nonSpreadElements","elements","filter","e","hasConstantStrictBooleanComparison","has","isAlwaysNew","Object","hasOwnProperty","call","builtin","regex","consequent","alternate","isNullOrUndefined","findBinaryExpressionConstantOperand","a","b","module","exports","meta","docs","description","recommended","url","schema","messages","constantBinaryOperand","constantShortCircuit","alwaysNew","bothAlwaysNew","create","context","LogicalExpression","left","getScope","report","messageId","data","property","BinaryExpression","rightConstantOperand","leftConstantOperand","otherSide"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/no-constant-binary-expression.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag constant comparisons and logical expressions that always/never short circuit\n * @author Jordan Eldredge <https://jordaneldredge.com>\n */\n\n\"use strict\";\n\nconst globals = require(\"globals\");\nconst { isNullLiteral, isConstant, isReferenceToGlobalVariable, isLogicalAssignmentOperator } = require(\"./utils/ast-utils\");\n\nconst NUMERIC_OR_STRING_BINARY_OPERATORS = new Set([\"+\", \"-\", \"*\", \"/\", \"%\", \"|\", \"^\", \"&\", \"**\", \"<<\", \">>\", \">>>\"]);\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Test if an AST node has a statically knowable constant nullishness. Meaning,\n * it will always resolve to a constant value of either: `null`, `undefined`\n * or not `null` _or_ `undefined`. An expression that can vary between those\n * three states at runtime would return `false`.\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The AST node being tested.\n * @returns {boolean} Does `node` have constant nullishness?\n */\nfunction hasConstantNullishness(scope, node) {\n    switch (node.type) {\n        case \"ObjectExpression\": // Objects are never nullish\n        case \"ArrayExpression\": // Arrays are never nullish\n        case \"ArrowFunctionExpression\": // Functions never nullish\n        case \"FunctionExpression\": // Functions are never nullish\n        case \"ClassExpression\": // Classes are never nullish\n        case \"NewExpression\": // Objects are never nullish\n        case \"Literal\": // Nullish, or non-nullish, literals never change\n        case \"TemplateLiteral\": // A string is never nullish\n        case \"UpdateExpression\": // Numbers are never nullish\n        case \"BinaryExpression\": // Numbers, strings, or booleans are never nullish\n            return true;\n        case \"CallExpression\": {\n            if (node.callee.type !== \"Identifier\") {\n                return false;\n            }\n            const functionName = node.callee.name;\n\n            return (functionName === \"Boolean\" || functionName === \"String\" || functionName === \"Number\") &&\n                isReferenceToGlobalVariable(scope, node.callee);\n        }\n        case \"AssignmentExpression\":\n            if (node.operator === \"=\") {\n                return hasConstantNullishness(scope, node.right);\n            }\n\n            /*\n             * Handling short-circuiting assignment operators would require\n             * walking the scope. We won't attempt that (for now...) /\n             */\n            if (isLogicalAssignmentOperator(node.operator)) {\n                return false;\n            }\n\n            /*\n             * The remaining assignment expressions all result in a numeric or\n             * string (non-nullish) value:\n             *   \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"|=\", \"^=\", \"&=\"\n             */\n\n            return true;\n        case \"UnaryExpression\":\n\n            /*\n             * \"void\" Always returns `undefined`\n             * \"typeof\" All types are strings, and thus non-nullish\n             * \"!\" Boolean is never nullish\n             * \"delete\" Returns a boolean, which is never nullish\n             * Math operators always return numbers or strings, neither of which\n             * are non-nullish \"+\", \"-\", \"~\"\n             */\n\n            return true;\n        case \"SequenceExpression\": {\n            const last = node.expressions[node.expressions.length - 1];\n\n            return hasConstantNullishness(scope, last);\n        }\n        case \"Identifier\":\n            return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n        case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n        case \"JSXFragment\":\n            return false;\n        default:\n            return false;\n    }\n}\n\n/**\n * Test if an AST node is a boolean value that never changes. Specifically we\n * test for:\n * 1. Literal booleans (`true` or `false`)\n * 2. Unary `!` expressions with a constant value\n * 3. Constant booleans created via the `Boolean` global function\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Is `node` guaranteed to be a boolean?\n */\nfunction isStaticBoolean(scope, node) {\n    switch (node.type) {\n        case \"Literal\":\n            return typeof node.value === \"boolean\";\n        case \"CallExpression\":\n            return node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\" &&\n              isReferenceToGlobalVariable(scope, node.callee) &&\n              (node.arguments.length === 0 || isConstant(scope, node.arguments[0], true));\n        case \"UnaryExpression\":\n            return node.operator === \"!\" && isConstant(scope, node.argument, true);\n        default:\n            return false;\n    }\n}\n\n\n/**\n * Test if an AST node will always give the same result when compared to a\n * boolean value. Note that comparison to boolean values is different than\n * truthiness.\n * https://262.ecma-international.org/5.1/#sec-11.9.3\n *\n * Javascript `==` operator works by converting the boolean to `1` (true) or\n * `+0` (false) and then checks the values `==` equality to that number.\n * @param {Scope} scope The scope in which node was found.\n * @param {ASTNode} node The node to test.\n * @returns {boolean} Will `node` always coerce to the same boolean value?\n */\nfunction hasConstantLooseBooleanComparison(scope, node) {\n    switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ClassExpression\":\n\n            /**\n             * In theory objects like:\n             *\n             * `{toString: () => a}`\n             * `{valueOf: () => a}`\n             *\n             * Or a classes like:\n             *\n             * `class { static toString() { return a } }`\n             * `class { static valueOf() { return a } }`\n             *\n             * Are not constant verifiably when `inBooleanPosition` is\n             * false, but it's an edge case we've opted not to handle.\n             */\n            return true;\n        case \"ArrayExpression\": {\n            const nonSpreadElements = node.elements.filter(e =>\n\n                // Elements can be `null` in sparse arrays: `[,,]`;\n                e !== null && e.type !== \"SpreadElement\");\n\n\n            /*\n             * Possible future direction if needed: We could check if the\n             * single value would result in variable boolean comparison.\n             * For now we will err on the side of caution since `[x]` could\n             * evaluate to `[0]` or `[1]`.\n             */\n            return node.elements.length === 0 || nonSpreadElements.length > 1;\n        }\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n            return true;\n        case \"UnaryExpression\":\n            if (node.operator === \"void\" || // Always returns `undefined`\n                node.operator === \"typeof\" // All `typeof` strings, when coerced to number, are not 0 or 1.\n            ) {\n                return true;\n            }\n            if (node.operator === \"!\") {\n                return isConstant(scope, node.argument, true);\n            }\n\n            /*\n             * We won't try to reason about +, -, ~, or delete\n             * In theory, for the mathematical operators, we could look at the\n             * argument and try to determine if it coerces to a constant numeric\n             * value.\n             */\n            return false;\n        case \"NewExpression\": // Objects might have custom `.valueOf` or `.toString`.\n            return false;\n        case \"CallExpression\": {\n            if (node.callee.type === \"Identifier\" &&\n                node.callee.name === \"Boolean\" &&\n                isReferenceToGlobalVariable(scope, node.callee)\n            ) {\n                return node.arguments.length === 0 || isConstant(scope, node.arguments[0], true);\n            }\n            return false;\n        }\n        case \"Literal\": // True or false, literals never change\n            return true;\n        case \"Identifier\":\n            return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n        case \"TemplateLiteral\":\n\n            /*\n             * In theory we could try to check if the quasi are sufficient to\n             * prove that the expression will always be true, but it would be\n             * tricky to get right. For example: `000.${foo}000`\n             */\n            return node.expressions.length === 0;\n        case \"AssignmentExpression\":\n            if (node.operator === \"=\") {\n                return hasConstantLooseBooleanComparison(scope, node.right);\n            }\n\n            /*\n             * Handling short-circuiting assignment operators would require\n             * walking the scope. We won't attempt that (for now...)\n             *\n             * The remaining assignment expressions all result in a numeric or\n             * string (non-nullish) values which could be truthy or falsy:\n             *   \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"<<=\", \">>=\", \">>>=\", \"|=\", \"^=\", \"&=\"\n             */\n            return false;\n        case \"SequenceExpression\": {\n            const last = node.expressions[node.expressions.length - 1];\n\n            return hasConstantLooseBooleanComparison(scope, last);\n        }\n        case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n        case \"JSXFragment\":\n            return false;\n        default:\n            return false;\n    }\n}\n\n\n/**\n * Test if an AST node will always give the same result when _strictly_ compared\n * to a boolean value. This can happen if the expression can never be boolean, or\n * if it is always the same boolean value.\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Will `node` always give the same result when compared to a\n * static boolean value?\n */\nfunction hasConstantStrictBooleanComparison(scope, node) {\n    switch (node.type) {\n        case \"ObjectExpression\": // Objects are not booleans\n        case \"ArrayExpression\": // Arrays are not booleans\n        case \"ArrowFunctionExpression\": // Functions are not booleans\n        case \"FunctionExpression\":\n        case \"ClassExpression\": // Classes are not booleans\n        case \"NewExpression\": // Objects are not booleans\n        case \"TemplateLiteral\": // Strings are not booleans\n        case \"Literal\": // True, false, or not boolean, literals never change.\n        case \"UpdateExpression\": // Numbers are not booleans\n            return true;\n        case \"BinaryExpression\":\n            return NUMERIC_OR_STRING_BINARY_OPERATORS.has(node.operator);\n        case \"UnaryExpression\": {\n            if (node.operator === \"delete\") {\n                return false;\n            }\n            if (node.operator === \"!\") {\n                return isConstant(scope, node.argument, true);\n            }\n\n            /*\n             * The remaining operators return either strings or numbers, neither\n             * of which are boolean.\n             */\n            return true;\n        }\n        case \"SequenceExpression\": {\n            const last = node.expressions[node.expressions.length - 1];\n\n            return hasConstantStrictBooleanComparison(scope, last);\n        }\n        case \"Identifier\":\n            return node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node);\n        case \"AssignmentExpression\":\n            if (node.operator === \"=\") {\n                return hasConstantStrictBooleanComparison(scope, node.right);\n            }\n\n            /*\n             * Handling short-circuiting assignment operators would require\n             * walking the scope. We won't attempt that (for now...)\n             */\n            if (isLogicalAssignmentOperator(node.operator)) {\n                return false;\n            }\n\n            /*\n             * The remaining assignment expressions all result in either a number\n             * or a string, neither of which can ever be boolean.\n             */\n            return true;\n        case \"CallExpression\": {\n            if (node.callee.type !== \"Identifier\") {\n                return false;\n            }\n            const functionName = node.callee.name;\n\n            if (\n                (functionName === \"String\" || functionName === \"Number\") &&\n                isReferenceToGlobalVariable(scope, node.callee)\n            ) {\n                return true;\n            }\n            if (functionName === \"Boolean\" && isReferenceToGlobalVariable(scope, node.callee)) {\n                return (\n                    node.arguments.length === 0 || isConstant(scope, node.arguments[0], true));\n            }\n            return false;\n        }\n        case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n        case \"JSXFragment\":\n            return false;\n        default:\n            return false;\n    }\n}\n\n/**\n * Test if an AST node will always result in a newly constructed object\n * @param {Scope} scope The scope in which the node was found.\n * @param {ASTNode} node The node to test\n * @returns {boolean} Will `node` always be new?\n */\nfunction isAlwaysNew(scope, node) {\n    switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ArrayExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n        case \"ClassExpression\":\n            return true;\n        case \"NewExpression\": {\n            if (node.callee.type !== \"Identifier\") {\n                return false;\n            }\n\n            /*\n             * All the built-in constructors are always new, but\n             * user-defined constructors could return a sentinel\n             * object.\n             *\n             * Catching these is especially useful for primitive constructures\n             * which return boxed values, a surprising gotcha' in JavaScript.\n             */\n            return Object.hasOwnProperty.call(globals.builtin, node.callee.name) &&\n              isReferenceToGlobalVariable(scope, node.callee);\n        }\n        case \"Literal\":\n\n            // Regular expressions are objects, and thus always new\n            return typeof node.regex === \"object\";\n        case \"SequenceExpression\": {\n            const last = node.expressions[node.expressions.length - 1];\n\n            return isAlwaysNew(scope, last);\n        }\n        case \"AssignmentExpression\":\n            if (node.operator === \"=\") {\n                return isAlwaysNew(scope, node.right);\n            }\n            return false;\n        case \"ConditionalExpression\":\n            return isAlwaysNew(scope, node.consequent) && isAlwaysNew(scope, node.alternate);\n        case \"JSXElement\": // ESLint has a policy of not assuming any specific JSX behavior.\n        case \"JSXFragment\":\n            return false;\n        default:\n            return false;\n    }\n}\n\n/**\n * Checks whether or not a node is `null` or `undefined`. Similar to the one\n * found in ast-utils.js, but this one correctly handles the edge case that\n * `undefined` has been redefined.\n * @param {Scope} scope Scope in which the expression was found.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\nfunction isNullOrUndefined(scope, node) {\n    return (\n        isNullLiteral(node) ||\n        (node.type === \"Identifier\" && node.name === \"undefined\" && isReferenceToGlobalVariable(scope, node)) ||\n        (node.type === \"UnaryExpression\" && node.operator === \"void\")\n    );\n}\n\n\n/**\n * Checks if one operand will cause the result to be constant.\n * @param {Scope} scope Scope in which the expression was found.\n * @param {ASTNode} a One side of the expression\n * @param {ASTNode} b The other side of the expression\n * @param {string} operator The binary expression operator\n * @returns {ASTNode | null} The node which will cause the expression to have a constant result.\n */\nfunction findBinaryExpressionConstantOperand(scope, a, b, operator) {\n    if (operator === \"==\" || operator === \"!=\") {\n        if (\n            (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b)) ||\n            (isStaticBoolean(scope, a) && hasConstantLooseBooleanComparison(scope, b))\n        ) {\n            return b;\n        }\n    } else if (operator === \"===\" || operator === \"!==\") {\n        if (\n            (isNullOrUndefined(scope, a) && hasConstantNullishness(scope, b)) ||\n            (isStaticBoolean(scope, a) && hasConstantStrictBooleanComparison(scope, b))\n        ) {\n            return b;\n        }\n    }\n    return null;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n        docs: {\n            description: \"Disallow expressions where the operation doesn't affect the value\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-constant-binary-expression\"\n        },\n        schema: [],\n        messages: {\n            constantBinaryOperand: \"Unexpected constant binary expression. Compares constantly with the {{otherSide}}-hand side of the `{{operator}}`.\",\n            constantShortCircuit: \"Unexpected constant {{property}} on the left-hand side of a `{{operator}}` expression.\",\n            alwaysNew: \"Unexpected comparison to newly constructed object. These two values can never be equal.\",\n            bothAlwaysNew: \"Unexpected comparison of two newly constructed objects. These two values can never be equal.\"\n        }\n    },\n\n    create(context) {\n        return {\n            LogicalExpression(node) {\n                const { operator, left } = node;\n                const scope = context.getScope();\n\n                if ((operator === \"&&\" || operator === \"||\") && isConstant(scope, left, true)) {\n                    context.report({ node: left, messageId: \"constantShortCircuit\", data: { property: \"truthiness\", operator } });\n                } else if (operator === \"??\" && hasConstantNullishness(scope, left)) {\n                    context.report({ node: left, messageId: \"constantShortCircuit\", data: { property: \"nullishness\", operator } });\n                }\n            },\n            BinaryExpression(node) {\n                const scope = context.getScope();\n                const { right, left, operator } = node;\n                const rightConstantOperand = findBinaryExpressionConstantOperand(scope, left, right, operator);\n                const leftConstantOperand = findBinaryExpressionConstantOperand(scope, right, left, operator);\n\n                if (rightConstantOperand) {\n                    context.report({ node: rightConstantOperand, messageId: \"constantBinaryOperand\", data: { operator, otherSide: \"left\" } });\n                } else if (leftConstantOperand) {\n                    context.report({ node: leftConstantOperand, messageId: \"constantBinaryOperand\", data: { operator, otherSide: \"right\" } });\n                } else if (operator === \"===\" || operator === \"!==\") {\n                    if (isAlwaysNew(scope, left)) {\n                        context.report({ node: left, messageId: \"alwaysNew\" });\n                    } else if (isAlwaysNew(scope, right)) {\n                        context.report({ node: right, messageId: \"alwaysNew\" });\n                    }\n                } else if (operator === \"==\" || operator === \"!=\") {\n\n                    /*\n                     * If both sides are \"new\", then both sides are objects and\n                     * therefore they will be compared by reference even with `==`\n                     * equality.\n                     */\n                    if (isAlwaysNew(scope, left) && isAlwaysNew(scope, right)) {\n                        context.report({ node: left, messageId: \"bothAlwaysNew\" });\n                    }\n                }\n\n            }\n\n            /*\n             * In theory we could handle short-circuiting assignment operators,\n             * for some constant values, but that would require walking the\n             * scope to find the value of the variable being assigned. This is\n             * dependant on https://github.com/eslint/eslint/issues/13776\n             *\n             * AssignmentExpression() {},\n             */\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}