{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.esquery = factory());\n})(this, function () {\n  'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n\n        var F = function () {};\n\n        return {\n          s: F,\n          n: function () {\n            if (i >= o.length) return {\n              done: true\n            };\n            return {\n              done: false,\n              value: o[i++]\n            };\n          },\n          e: function (e) {\n            throw e;\n          },\n          f: F\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true,\n        didErr = false,\n        err;\n    return {\n      s: function () {\n        it = o[Symbol.iterator]();\n      },\n      n: function () {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function (e) {\n        didErr = true;\n        err = e;\n      },\n      f: function () {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var estraverse = createCommonjsModule(function (module, exports) {\n    /*\n      Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n      Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n    \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n    \n        * Redistributions of source code must retain the above copyright\n          notice, this list of conditions and the following disclaimer.\n        * Redistributions in binary form must reproduce the above copyright\n          notice, this list of conditions and the following disclaimer in the\n          documentation and/or other materials provided with the distribution.\n    \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    */\n\n    /*jslint vars:false, bitwise:true*/\n\n    /*jshint indent:4*/\n\n    /*global exports:true*/\n    (function clone(exports) {\n      var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;\n\n      function deepCopy(obj) {\n        var ret = {},\n            key,\n            val;\n\n        for (key in obj) {\n          if (obj.hasOwnProperty(key)) {\n            val = obj[key];\n\n            if (typeof val === 'object' && val !== null) {\n              ret[key] = deepCopy(val);\n            } else {\n              ret[key] = val;\n            }\n          }\n        }\n\n        return ret;\n      } // based on LLVM libc++ upper_bound / lower_bound\n      // MIT License\n\n\n      function upperBound(array, func) {\n        var diff, len, i, current;\n        len = array.length;\n        i = 0;\n\n        while (len) {\n          diff = len >>> 1;\n          current = i + diff;\n\n          if (func(array[current])) {\n            len = diff;\n          } else {\n            i = current + 1;\n            len -= diff + 1;\n          }\n        }\n\n        return i;\n      }\n\n      Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression',\n        // CAUTION: It's deferred to ES7.\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ChainExpression: 'ChainExpression',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',\n        // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: 'ComprehensionExpression',\n        // CAUTION: It's deferred to ES7.\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',\n        // CAUTION: It's deferred to ES7.\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportExpression: 'ImportExpression',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MetaProperty: 'MetaProperty',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n      };\n      VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'body'],\n        AwaitExpression: ['argument'],\n        // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ChainExpression: ['expression'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],\n        // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],\n        // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],\n        // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportExpression: ['source'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        MetaProperty: ['meta', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        RestElement: ['argument'],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        Super: [],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handler', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n      }; // unique id\n\n      BREAK = {};\n      SKIP = {};\n      REMOVE = {};\n      VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n      };\n\n      function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n      }\n\n      Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n      };\n\n      Reference.prototype.remove = function remove() {\n        if (Array.isArray(this.parent)) {\n          this.parent.splice(this.key, 1);\n          return true;\n        } else {\n          this.replace(null);\n          return false;\n        }\n      };\n\n      function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n      }\n\n      function Controller() {} // API:\n      // return property path array from root to current node\n\n\n      Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n\n        function addToPath(result, path) {\n          if (Array.isArray(path)) {\n            for (j = 0, jz = path.length; j < jz; ++j) {\n              result.push(path[j]);\n            }\n          } else {\n            result.push(path);\n          }\n        } // root node\n\n\n        if (!this.__current.path) {\n          return null;\n        } // first node is sentinel, second node is root element\n\n\n        result = [];\n\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n          element = this.__leavelist[i];\n          addToPath(result, element.path);\n        }\n\n        addToPath(result, this.__current.path);\n        return result;\n      }; // API:\n      // return type of current node\n\n\n      Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n      }; // API:\n      // return array of parent elements\n\n\n      Controller.prototype.parents = function parents() {\n        var i, iz, result; // first node is sentinel\n\n        result = [];\n\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n          result.push(this.__leavelist[i].node);\n        }\n\n        return result;\n      }; // API:\n      // return current node\n\n\n      Controller.prototype.current = function current() {\n        return this.__current.node;\n      };\n\n      Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n        result = undefined;\n        previous = this.__current;\n        this.__current = element;\n        this.__state = null;\n\n        if (callback) {\n          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n\n        this.__current = previous;\n        return result;\n      }; // API:\n      // notify control skip / break\n\n\n      Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n      }; // API:\n      // skip child nodes of current node\n\n\n      Controller.prototype.skip = function () {\n        this.notify(SKIP);\n      }; // API:\n      // break traversals\n\n\n      Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n      }; // API:\n      // remove node\n\n\n      Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n      };\n\n      Controller.prototype.__initialize = function (root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = null;\n\n        if (visitor.fallback === 'iteration') {\n          this.__fallback = Object.keys;\n        } else if (typeof visitor.fallback === 'function') {\n          this.__fallback = visitor.fallback;\n        }\n\n        this.__keys = VisitorKeys;\n\n        if (visitor.keys) {\n          this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);\n        }\n      };\n\n      function isNode(node) {\n        if (node == null) {\n          return false;\n        }\n\n        return typeof node === 'object' && typeof node.type === 'string';\n      }\n\n      function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n      }\n\n      function candidateExistsInLeaveList(leavelist, candidate) {\n        for (var i = leavelist.length - 1; i >= 0; --i) {\n          if (leavelist[i].node === candidate) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {}; // reference\n\n        worklist = this.__worklist;\n        leavelist = this.__leavelist; // initialize\n\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n\n        while (worklist.length) {\n          element = worklist.pop();\n\n          if (element === sentinel) {\n            element = leavelist.pop();\n            ret = this.__execute(visitor.leave, element);\n\n            if (this.__state === BREAK || ret === BREAK) {\n              return;\n            }\n\n            continue;\n          }\n\n          if (element.node) {\n            ret = this.__execute(visitor.enter, element);\n\n            if (this.__state === BREAK || ret === BREAK) {\n              return;\n            }\n\n            worklist.push(sentinel);\n            leavelist.push(element);\n\n            if (this.__state === SKIP || ret === SKIP) {\n              continue;\n            }\n\n            node = element.node;\n            nodeType = node.type || element.wrap;\n            candidates = this.__keys[nodeType];\n\n            if (!candidates) {\n              if (this.__fallback) {\n                candidates = this.__fallback(node);\n              } else {\n                throw new Error('Unknown node type ' + nodeType + '.');\n              }\n            }\n\n            current = candidates.length;\n\n            while ((current -= 1) >= 0) {\n              key = candidates[current];\n              candidate = node[key];\n\n              if (!candidate) {\n                continue;\n              }\n\n              if (Array.isArray(candidate)) {\n                current2 = candidate.length;\n\n                while ((current2 -= 1) >= 0) {\n                  if (!candidate[current2]) {\n                    continue;\n                  }\n\n                  if (candidateExistsInLeaveList(leavelist, candidate[current2])) {\n                    continue;\n                  }\n\n                  if (isProperty(nodeType, candidates[current])) {\n                    element = new Element(candidate[current2], [key, current2], 'Property', null);\n                  } else if (isNode(candidate[current2])) {\n                    element = new Element(candidate[current2], [key, current2], null, null);\n                  } else {\n                    continue;\n                  }\n\n                  worklist.push(element);\n                }\n              } else if (isNode(candidate)) {\n                if (candidateExistsInLeaveList(leavelist, candidate)) {\n                  continue;\n                }\n\n                worklist.push(new Element(candidate, key, null, null));\n              }\n            }\n          }\n        }\n      };\n\n      Controller.prototype.replace = function replace(root, visitor) {\n        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;\n\n        function removeElem(element) {\n          var i, key, nextElem, parent;\n\n          if (element.ref.remove()) {\n            // When the reference is an element of an array.\n            key = element.ref.key;\n            parent = element.ref.parent; // If removed from array, then decrease following items' keys.\n\n            i = worklist.length;\n\n            while (i--) {\n              nextElem = worklist[i];\n\n              if (nextElem.ref && nextElem.ref.parent === parent) {\n                if (nextElem.ref.key < key) {\n                  break;\n                }\n\n                --nextElem.ref.key;\n              }\n            }\n          }\n        }\n\n        this.__initialize(root, visitor);\n\n        sentinel = {}; // reference\n\n        worklist = this.__worklist;\n        leavelist = this.__leavelist; // initialize\n\n        outer = {\n          root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n\n        while (worklist.length) {\n          element = worklist.pop();\n\n          if (element === sentinel) {\n            element = leavelist.pop();\n            target = this.__execute(visitor.leave, element); // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n              // replace\n              element.ref.replace(target);\n            }\n\n            if (this.__state === REMOVE || target === REMOVE) {\n              removeElem(element);\n            }\n\n            if (this.__state === BREAK || target === BREAK) {\n              return outer.root;\n            }\n\n            continue;\n          }\n\n          target = this.__execute(visitor.enter, element); // node may be replaced with null,\n          // so distinguish between undefined and null in this place\n\n          if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n            // replace\n            element.ref.replace(target);\n            element.node = target;\n          }\n\n          if (this.__state === REMOVE || target === REMOVE) {\n            removeElem(element);\n            element.node = null;\n          }\n\n          if (this.__state === BREAK || target === BREAK) {\n            return outer.root;\n          } // node may be null\n\n\n          node = element.node;\n\n          if (!node) {\n            continue;\n          }\n\n          worklist.push(sentinel);\n          leavelist.push(element);\n\n          if (this.__state === SKIP || target === SKIP) {\n            continue;\n          }\n\n          nodeType = node.type || element.wrap;\n          candidates = this.__keys[nodeType];\n\n          if (!candidates) {\n            if (this.__fallback) {\n              candidates = this.__fallback(node);\n            } else {\n              throw new Error('Unknown node type ' + nodeType + '.');\n            }\n          }\n\n          current = candidates.length;\n\n          while ((current -= 1) >= 0) {\n            key = candidates[current];\n            candidate = node[key];\n\n            if (!candidate) {\n              continue;\n            }\n\n            if (Array.isArray(candidate)) {\n              current2 = candidate.length;\n\n              while ((current2 -= 1) >= 0) {\n                if (!candidate[current2]) {\n                  continue;\n                }\n\n                if (isProperty(nodeType, candidates[current])) {\n                  element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n                } else if (isNode(candidate[current2])) {\n                  element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n                } else {\n                  continue;\n                }\n\n                worklist.push(element);\n              }\n            } else if (isNode(candidate)) {\n              worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n            }\n          }\n        }\n\n        return outer.root;\n      };\n\n      function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n      }\n\n      function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n      }\n\n      function extendCommentRange(comment, tokens) {\n        var target;\n        target = upperBound(tokens, function search(token) {\n          return token.range[0] > comment.range[0];\n        });\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n          comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n\n        if (target >= 0) {\n          comment.extendedRange[0] = tokens[target].range[1];\n        }\n\n        return comment;\n      }\n\n      function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [],\n            comment,\n            len,\n            i,\n            cursor;\n\n        if (!tree.range) {\n          throw new Error('attachComments needs range information');\n        } // tokens array is empty, we attach comments to tree as 'leadingComments'\n\n\n        if (!tokens.length) {\n          if (providedComments.length) {\n            for (i = 0, len = providedComments.length; i < len; i += 1) {\n              comment = deepCopy(providedComments[i]);\n              comment.extendedRange = [0, tree.range[0]];\n              comments.push(comment);\n            }\n\n            tree.leadingComments = comments;\n          }\n\n          return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        } // This is based on John Freeman's implementation.\n\n\n        cursor = 0;\n        traverse(tree, {\n          enter: function (node) {\n            var comment;\n\n            while (cursor < comments.length) {\n              comment = comments[cursor];\n\n              if (comment.extendedRange[1] > node.range[0]) {\n                break;\n              }\n\n              if (comment.extendedRange[1] === node.range[0]) {\n                if (!node.leadingComments) {\n                  node.leadingComments = [];\n                }\n\n                node.leadingComments.push(comment);\n                comments.splice(cursor, 1);\n              } else {\n                cursor += 1;\n              }\n            } // already out of owned node\n\n\n            if (cursor === comments.length) {\n              return VisitorOption.Break;\n            }\n\n            if (comments[cursor].extendedRange[0] > node.range[1]) {\n              return VisitorOption.Skip;\n            }\n          }\n        });\n        cursor = 0;\n        traverse(tree, {\n          leave: function (node) {\n            var comment;\n\n            while (cursor < comments.length) {\n              comment = comments[cursor];\n\n              if (node.range[1] < comment.extendedRange[0]) {\n                break;\n              }\n\n              if (node.range[1] === comment.extendedRange[0]) {\n                if (!node.trailingComments) {\n                  node.trailingComments = [];\n                }\n\n                node.trailingComments.push(comment);\n                comments.splice(cursor, 1);\n              } else {\n                cursor += 1;\n              }\n            } // already out of owned node\n\n\n            if (cursor === comments.length) {\n              return VisitorOption.Break;\n            }\n\n            if (comments[cursor].extendedRange[0] > node.range[1]) {\n              return VisitorOption.Skip;\n            }\n          }\n        });\n        return tree;\n      }\n\n      exports.Syntax = Syntax;\n      exports.traverse = traverse;\n      exports.replace = replace;\n      exports.attachComments = attachComments;\n      exports.VisitorKeys = VisitorKeys;\n      exports.VisitorOption = VisitorOption;\n      exports.Controller = Controller;\n\n      exports.cloneEnvironment = function () {\n        return clone({});\n      };\n\n      return exports;\n    })(exports);\n    /* vim: set sw=4 ts=4 et tw=80 : */\n\n  });\n  var parser = createCommonjsModule(function (module) {\n    /*\n     * Generated by PEG.js 0.10.0.\n     *\n     * http://pegjs.org/\n     */\n    (function (root, factory) {\n      if (module.exports) {\n        module.exports = factory();\n      }\n    })(commonjsGlobal, function () {\n      function peg$subclass(child, parent) {\n        function ctor() {\n          this.constructor = child;\n        }\n\n        ctor.prototype = parent.prototype;\n        child.prototype = new ctor();\n      }\n\n      function peg$SyntaxError(message, expected, found, location) {\n        this.message = message;\n        this.expected = expected;\n        this.found = found;\n        this.location = location;\n        this.name = \"SyntaxError\";\n\n        if (typeof Error.captureStackTrace === \"function\") {\n          Error.captureStackTrace(this, peg$SyntaxError);\n        }\n      }\n\n      peg$subclass(peg$SyntaxError, Error);\n\n      peg$SyntaxError.buildMessage = function (expected, found) {\n        var DESCRIBE_EXPECTATION_FNS = {\n          literal: function literal(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n          \"class\": function _class(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n          any: function any(expectation) {\n            return \"any character\";\n          },\n          end: function end(expectation) {\n            return \"end of input\";\n          },\n          other: function other(expectation) {\n            return expectation.description;\n          }\n        };\n\n        function hex(ch) {\n          return ch.charCodeAt(0).toString(16).toUpperCase();\n        }\n\n        function literalEscape(s) {\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          });\n        }\n\n        function classEscape(s) {\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\\]/g, '\\\\]').replace(/\\^/g, '\\\\^').replace(/-/g, '\\\\-').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          });\n        }\n\n        function describeExpectation(expectation) {\n          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n        }\n\n        function describeExpected(expected) {\n          var descriptions = new Array(expected.length),\n              i,\n              j;\n\n          for (i = 0; i < expected.length; i++) {\n            descriptions[i] = describeExpectation(expected[i]);\n          }\n\n          descriptions.sort();\n\n          if (descriptions.length > 0) {\n            for (i = 1, j = 1; i < descriptions.length; i++) {\n              if (descriptions[i - 1] !== descriptions[i]) {\n                descriptions[j] = descriptions[i];\n                j++;\n              }\n            }\n\n            descriptions.length = j;\n          }\n\n          switch (descriptions.length) {\n            case 1:\n              return descriptions[0];\n\n            case 2:\n              return descriptions[0] + \" or \" + descriptions[1];\n\n            default:\n              return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n          }\n        }\n\n        function describeFound(found) {\n          return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n        }\n\n        return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n      };\n\n      function peg$parse(input, options) {\n        options = options !== void 0 ? options : {};\n\n        var peg$FAILED = {},\n            peg$startRuleFunctions = {\n          start: peg$parsestart\n        },\n            peg$startRuleFunction = peg$parsestart,\n            peg$c0 = function peg$c0(ss) {\n          return ss.length === 1 ? ss[0] : {\n            type: 'matches',\n            selectors: ss\n          };\n        },\n            peg$c1 = function peg$c1() {\n          return void 0;\n        },\n            peg$c2 = \" \",\n            peg$c3 = peg$literalExpectation(\" \", false),\n            peg$c4 = /^[^ [\\],():#!=><~+.]/,\n            peg$c5 = peg$classExpectation([\" \", \"[\", \"]\", \",\", \"(\", \")\", \":\", \"#\", \"!\", \"=\", \">\", \"<\", \"~\", \"+\", \".\"], true, false),\n            peg$c6 = function peg$c6(i) {\n          return i.join('');\n        },\n            peg$c7 = \">\",\n            peg$c8 = peg$literalExpectation(\">\", false),\n            peg$c9 = function peg$c9() {\n          return 'child';\n        },\n            peg$c10 = \"~\",\n            peg$c11 = peg$literalExpectation(\"~\", false),\n            peg$c12 = function peg$c12() {\n          return 'sibling';\n        },\n            peg$c13 = \"+\",\n            peg$c14 = peg$literalExpectation(\"+\", false),\n            peg$c15 = function peg$c15() {\n          return 'adjacent';\n        },\n            peg$c16 = function peg$c16() {\n          return 'descendant';\n        },\n            peg$c17 = \",\",\n            peg$c18 = peg$literalExpectation(\",\", false),\n            peg$c19 = function peg$c19(s, ss) {\n          return [s].concat(ss.map(function (s) {\n            return s[3];\n          }));\n        },\n            peg$c20 = function peg$c20(a, ops) {\n          return ops.reduce(function (memo, rhs) {\n            return {\n              type: rhs[0],\n              left: memo,\n              right: rhs[1]\n            };\n          }, a);\n        },\n            peg$c21 = \"!\",\n            peg$c22 = peg$literalExpectation(\"!\", false),\n            peg$c23 = function peg$c23(subject, as) {\n          var b = as.length === 1 ? as[0] : {\n            type: 'compound',\n            selectors: as\n          };\n          if (subject) b.subject = true;\n          return b;\n        },\n            peg$c24 = \"*\",\n            peg$c25 = peg$literalExpectation(\"*\", false),\n            peg$c26 = function peg$c26(a) {\n          return {\n            type: 'wildcard',\n            value: a\n          };\n        },\n            peg$c27 = \"#\",\n            peg$c28 = peg$literalExpectation(\"#\", false),\n            peg$c29 = function peg$c29(i) {\n          return {\n            type: 'identifier',\n            value: i\n          };\n        },\n            peg$c30 = \"[\",\n            peg$c31 = peg$literalExpectation(\"[\", false),\n            peg$c32 = \"]\",\n            peg$c33 = peg$literalExpectation(\"]\", false),\n            peg$c34 = function peg$c34(v) {\n          return v;\n        },\n            peg$c35 = /^[><!]/,\n            peg$c36 = peg$classExpectation([\">\", \"<\", \"!\"], false, false),\n            peg$c37 = \"=\",\n            peg$c38 = peg$literalExpectation(\"=\", false),\n            peg$c39 = function peg$c39(a) {\n          return (a || '') + '=';\n        },\n            peg$c40 = /^[><]/,\n            peg$c41 = peg$classExpectation([\">\", \"<\"], false, false),\n            peg$c42 = \".\",\n            peg$c43 = peg$literalExpectation(\".\", false),\n            peg$c44 = function peg$c44(a, as) {\n          return [].concat.apply([a], as).join('');\n        },\n            peg$c45 = function peg$c45(name, op, value) {\n          return {\n            type: 'attribute',\n            name: name,\n            operator: op,\n            value: value\n          };\n        },\n            peg$c46 = function peg$c46(name) {\n          return {\n            type: 'attribute',\n            name: name\n          };\n        },\n            peg$c47 = \"\\\"\",\n            peg$c48 = peg$literalExpectation(\"\\\"\", false),\n            peg$c49 = /^[^\\\\\"]/,\n            peg$c50 = peg$classExpectation([\"\\\\\", \"\\\"\"], true, false),\n            peg$c51 = \"\\\\\",\n            peg$c52 = peg$literalExpectation(\"\\\\\", false),\n            peg$c53 = peg$anyExpectation(),\n            peg$c54 = function peg$c54(a, b) {\n          return a + b;\n        },\n            peg$c55 = function peg$c55(d) {\n          return {\n            type: 'literal',\n            value: strUnescape(d.join(''))\n          };\n        },\n            peg$c56 = \"'\",\n            peg$c57 = peg$literalExpectation(\"'\", false),\n            peg$c58 = /^[^\\\\']/,\n            peg$c59 = peg$classExpectation([\"\\\\\", \"'\"], true, false),\n            peg$c60 = /^[0-9]/,\n            peg$c61 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n            peg$c62 = function peg$c62(a, b) {\n          // Can use `a.flat().join('')` once supported\n          var leadingDecimals = a ? [].concat.apply([], a).join('') : '';\n          return {\n            type: 'literal',\n            value: parseFloat(leadingDecimals + b.join(''))\n          };\n        },\n            peg$c63 = function peg$c63(i) {\n          return {\n            type: 'literal',\n            value: i\n          };\n        },\n            peg$c64 = \"type(\",\n            peg$c65 = peg$literalExpectation(\"type(\", false),\n            peg$c66 = /^[^ )]/,\n            peg$c67 = peg$classExpectation([\" \", \")\"], true, false),\n            peg$c68 = \")\",\n            peg$c69 = peg$literalExpectation(\")\", false),\n            peg$c70 = function peg$c70(t) {\n          return {\n            type: 'type',\n            value: t.join('')\n          };\n        },\n            peg$c71 = /^[imsu]/,\n            peg$c72 = peg$classExpectation([\"i\", \"m\", \"s\", \"u\"], false, false),\n            peg$c73 = \"/\",\n            peg$c74 = peg$literalExpectation(\"/\", false),\n            peg$c75 = /^[^\\/]/,\n            peg$c76 = peg$classExpectation([\"/\"], true, false),\n            peg$c77 = function peg$c77(d, flgs) {\n          return {\n            type: 'regexp',\n            value: new RegExp(d.join(''), flgs ? flgs.join('') : '')\n          };\n        },\n            peg$c78 = function peg$c78(i, is) {\n          return {\n            type: 'field',\n            name: is.reduce(function (memo, p) {\n              return memo + p[0] + p[1];\n            }, i)\n          };\n        },\n            peg$c79 = \":not(\",\n            peg$c80 = peg$literalExpectation(\":not(\", false),\n            peg$c81 = function peg$c81(ss) {\n          return {\n            type: 'not',\n            selectors: ss\n          };\n        },\n            peg$c82 = \":matches(\",\n            peg$c83 = peg$literalExpectation(\":matches(\", false),\n            peg$c84 = function peg$c84(ss) {\n          return {\n            type: 'matches',\n            selectors: ss\n          };\n        },\n            peg$c85 = \":has(\",\n            peg$c86 = peg$literalExpectation(\":has(\", false),\n            peg$c87 = function peg$c87(ss) {\n          return {\n            type: 'has',\n            selectors: ss\n          };\n        },\n            peg$c88 = \":first-child\",\n            peg$c89 = peg$literalExpectation(\":first-child\", false),\n            peg$c90 = function peg$c90() {\n          return nth(1);\n        },\n            peg$c91 = \":last-child\",\n            peg$c92 = peg$literalExpectation(\":last-child\", false),\n            peg$c93 = function peg$c93() {\n          return nthLast(1);\n        },\n            peg$c94 = \":nth-child(\",\n            peg$c95 = peg$literalExpectation(\":nth-child(\", false),\n            peg$c96 = function peg$c96(n) {\n          return nth(parseInt(n.join(''), 10));\n        },\n            peg$c97 = \":nth-last-child(\",\n            peg$c98 = peg$literalExpectation(\":nth-last-child(\", false),\n            peg$c99 = function peg$c99(n) {\n          return nthLast(parseInt(n.join(''), 10));\n        },\n            peg$c100 = \":\",\n            peg$c101 = peg$literalExpectation(\":\", false),\n            peg$c102 = \"statement\",\n            peg$c103 = peg$literalExpectation(\"statement\", true),\n            peg$c104 = \"expression\",\n            peg$c105 = peg$literalExpectation(\"expression\", true),\n            peg$c106 = \"declaration\",\n            peg$c107 = peg$literalExpectation(\"declaration\", true),\n            peg$c108 = \"function\",\n            peg$c109 = peg$literalExpectation(\"function\", true),\n            peg$c110 = \"pattern\",\n            peg$c111 = peg$literalExpectation(\"pattern\", true),\n            peg$c112 = function peg$c112(c) {\n          return {\n            type: 'class',\n            name: c\n          };\n        },\n            peg$currPos = 0,\n            peg$posDetailsCache = [{\n          line: 1,\n          column: 1\n        }],\n            peg$maxFailPos = 0,\n            peg$maxFailExpected = [],\n            peg$resultsCache = {},\n            peg$result;\n\n        if (\"startRule\" in options) {\n          if (!(options.startRule in peg$startRuleFunctions)) {\n            throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n          }\n\n          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n        }\n\n        function peg$literalExpectation(text, ignoreCase) {\n          return {\n            type: \"literal\",\n            text: text,\n            ignoreCase: ignoreCase\n          };\n        }\n\n        function peg$classExpectation(parts, inverted, ignoreCase) {\n          return {\n            type: \"class\",\n            parts: parts,\n            inverted: inverted,\n            ignoreCase: ignoreCase\n          };\n        }\n\n        function peg$anyExpectation() {\n          return {\n            type: \"any\"\n          };\n        }\n\n        function peg$endExpectation() {\n          return {\n            type: \"end\"\n          };\n        }\n\n        function peg$computePosDetails(pos) {\n          var details = peg$posDetailsCache[pos],\n              p;\n\n          if (details) {\n            return details;\n          } else {\n            p = pos - 1;\n\n            while (!peg$posDetailsCache[p]) {\n              p--;\n            }\n\n            details = peg$posDetailsCache[p];\n            details = {\n              line: details.line,\n              column: details.column\n            };\n\n            while (p < pos) {\n              if (input.charCodeAt(p) === 10) {\n                details.line++;\n                details.column = 1;\n              } else {\n                details.column++;\n              }\n\n              p++;\n            }\n\n            peg$posDetailsCache[pos] = details;\n            return details;\n          }\n        }\n\n        function peg$computeLocation(startPos, endPos) {\n          var startPosDetails = peg$computePosDetails(startPos),\n              endPosDetails = peg$computePosDetails(endPos);\n          return {\n            start: {\n              offset: startPos,\n              line: startPosDetails.line,\n              column: startPosDetails.column\n            },\n            end: {\n              offset: endPos,\n              line: endPosDetails.line,\n              column: endPosDetails.column\n            }\n          };\n        }\n\n        function peg$fail(expected) {\n          if (peg$currPos < peg$maxFailPos) {\n            return;\n          }\n\n          if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n          }\n\n          peg$maxFailExpected.push(expected);\n        }\n\n        function peg$buildStructuredError(expected, found, location) {\n          return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n        }\n\n        function peg$parsestart() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 0,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseselectors();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c0(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n\n            if (s1 !== peg$FAILED) {\n              s1 = peg$c1();\n            }\n\n            s0 = s1;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parse_() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 1,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = [];\n\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s1 = peg$c2;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c3);\n            }\n          }\n\n          while (s1 !== peg$FAILED) {\n            s0.push(s1);\n\n            if (input.charCodeAt(peg$currPos) === 32) {\n              s1 = peg$c2;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              {\n                peg$fail(peg$c3);\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseidentifierName() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 2,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = [];\n\n          if (peg$c4.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            {\n              peg$fail(peg$c5);\n            }\n          }\n\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n\n              if (peg$c4.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                {\n                  peg$fail(peg$c5);\n                }\n              }\n            }\n          } else {\n            s1 = peg$FAILED;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c6(s1);\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsebinaryOp() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 3,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 62) {\n              s2 = peg$c7;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              {\n                peg$fail(peg$c8);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c9();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n\n            if (s1 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 126) {\n                s2 = peg$c10;\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n                {\n                  peg$fail(peg$c11);\n                }\n              }\n\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parse_();\n\n                if (s3 !== peg$FAILED) {\n                  s1 = peg$c12();\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parse_();\n\n              if (s1 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 43) {\n                  s2 = peg$c13;\n                  peg$currPos++;\n                } else {\n                  s2 = peg$FAILED;\n                  {\n                    peg$fail(peg$c14);\n                  }\n                }\n\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parse_();\n\n                  if (s3 !== peg$FAILED) {\n                    s1 = peg$c15();\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 32) {\n                  s1 = peg$c2;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  {\n                    peg$fail(peg$c3);\n                  }\n                }\n\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parse_();\n\n                  if (s2 !== peg$FAILED) {\n                    s1 = peg$c16();\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseselectors() {\n          var s0, s1, s2, s3, s4, s5, s6, s7;\n          var key = peg$currPos * 30 + 4,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseselector();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$parse_();\n\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c17;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                {\n                  peg$fail(peg$c18);\n                }\n              }\n\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parseselector();\n\n                  if (s7 !== peg$FAILED) {\n                    s4 = [s4, s5, s6, s7];\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$parse_();\n\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s5 = peg$c17;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c18);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse_();\n\n                  if (s6 !== peg$FAILED) {\n                    s7 = peg$parseselector();\n\n                    if (s7 !== peg$FAILED) {\n                      s4 = [s4, s5, s6, s7];\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c19(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseselector() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 5,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parsesequence();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$parsebinaryOp();\n\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsesequence();\n\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$parsebinaryOp();\n\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsesequence();\n\n                if (s5 !== peg$FAILED) {\n                  s4 = [s4, s5];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c20(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsesequence() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 6,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 33) {\n            s1 = peg$c21;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c22);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parseatom();\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parseatom();\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c23(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseatom() {\n          var s0;\n          var key = peg$currPos * 30 + 7,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$parsewildcard();\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseidentifier();\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseattr();\n\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsefield();\n\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsenegation();\n\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsematches();\n\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsehas();\n\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsefirstChild();\n\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parselastChild();\n\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsenthChild();\n\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parsenthLastChild();\n\n                              if (s0 === peg$FAILED) {\n                                s0 = peg$parseclass();\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsewildcard() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 8,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s1 = peg$c24;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c25);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c26(s1);\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseidentifier() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 9,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 35) {\n            s1 = peg$c27;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c28);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseidentifierName();\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c29(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattr() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 10,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s1 = peg$c30;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c31);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseattrValue();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 93) {\n                    s5 = peg$c32;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c33);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c34(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrOps() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 11,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (peg$c35.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c36);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s2 = peg$c37;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              {\n                peg$fail(peg$c38);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c39(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            if (peg$c40.test(input.charAt(peg$currPos))) {\n              s0 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              {\n                peg$fail(peg$c41);\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrEqOps() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 12,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 33) {\n            s1 = peg$c21;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c22);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s2 = peg$c37;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n              {\n                peg$fail(peg$c38);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c39(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrName() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 13,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseidentifierName();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s4 = peg$c42;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n              {\n                peg$fail(peg$c43);\n              }\n            }\n\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseidentifierName();\n\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s4 = peg$c42;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c43);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parseidentifierName();\n\n                if (s5 !== peg$FAILED) {\n                  s4 = [s4, s5];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c44(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrValue() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 14,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseattrName();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseattrEqOps();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsetype();\n\n                  if (s5 === peg$FAILED) {\n                    s5 = peg$parseregex();\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c45(s1, s3, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseattrName();\n\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parseattrOps();\n\n                if (s3 !== peg$FAILED) {\n                  s4 = peg$parse_();\n\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsestring();\n\n                    if (s5 === peg$FAILED) {\n                      s5 = peg$parsenumber();\n\n                      if (s5 === peg$FAILED) {\n                        s5 = peg$parsepath();\n                      }\n                    }\n\n                    if (s5 !== peg$FAILED) {\n                      s1 = peg$c45(s1, s3, s5);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parseattrName();\n\n              if (s1 !== peg$FAILED) {\n                s1 = peg$c46(s1);\n              }\n\n              s0 = s1;\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsestring() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 15,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s1 = peg$c47;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c48);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n\n            if (peg$c49.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c50);\n              }\n            }\n\n            if (s3 === peg$FAILED) {\n              s3 = peg$currPos;\n\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s4 = peg$c51;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c52);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c53);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s4 = peg$c54(s4, s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n\n              if (peg$c49.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c50);\n                }\n              }\n\n              if (s3 === peg$FAILED) {\n                s3 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 92) {\n                  s4 = peg$c51;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  {\n                    peg$fail(peg$c52);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s5 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c53);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s4 = peg$c54(s4, s5);\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 34) {\n                s3 = peg$c47;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c48);\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c55(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n\n            if (input.charCodeAt(peg$currPos) === 39) {\n              s1 = peg$c56;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              {\n                peg$fail(peg$c57);\n              }\n            }\n\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n\n              if (peg$c58.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c59);\n                }\n              }\n\n              if (s3 === peg$FAILED) {\n                s3 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 92) {\n                  s4 = peg$c51;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n                  {\n                    peg$fail(peg$c52);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s5 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c53);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s4 = peg$c54(s4, s5);\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n\n                if (peg$c58.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  {\n                    peg$fail(peg$c59);\n                  }\n                }\n\n                if (s3 === peg$FAILED) {\n                  s3 = peg$currPos;\n\n                  if (input.charCodeAt(peg$currPos) === 92) {\n                    s4 = peg$c51;\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    {\n                      peg$fail(peg$c52);\n                    }\n                  }\n\n                  if (s4 !== peg$FAILED) {\n                    if (input.length > peg$currPos) {\n                      s5 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s5 = peg$FAILED;\n                      {\n                        peg$fail(peg$c53);\n                      }\n                    }\n\n                    if (s5 !== peg$FAILED) {\n                      s4 = peg$c54(s4, s5);\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                }\n              }\n\n              if (s2 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 39) {\n                  s3 = peg$c56;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  {\n                    peg$fail(peg$c57);\n                  }\n                }\n\n                if (s3 !== peg$FAILED) {\n                  s1 = peg$c55(s2);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenumber() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 16,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$currPos;\n          s2 = [];\n\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            {\n              peg$fail(peg$c61);\n            }\n          }\n\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n\n            if (peg$c60.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c61);\n              }\n            }\n          }\n\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s3 = peg$c42;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c43);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              s2 = [s2, s3];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n\n            if (peg$c60.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c61);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n\n                if (peg$c60.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  {\n                    peg$fail(peg$c61);\n                  }\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c62(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsepath() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 17,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseidentifierName();\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c63(s1);\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsetype() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 18,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 5) === peg$c64) {\n            s1 = peg$c64;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c65);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n\n              if (peg$c66.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c67);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n\n                  if (peg$c66.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    {\n                      peg$fail(peg$c67);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c70(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseflags() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 19,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = [];\n\n          if (peg$c71.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c72);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            while (s1 !== peg$FAILED) {\n              s0.push(s1);\n\n              if (peg$c71.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                {\n                  peg$fail(peg$c72);\n                }\n              }\n            }\n          } else {\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseregex() {\n          var s0, s1, s2, s3, s4;\n          var key = peg$currPos * 30 + 20,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s1 = peg$c73;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c74);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n\n            if (peg$c75.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              {\n                peg$fail(peg$c76);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n\n                if (peg$c75.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n                  {\n                    peg$fail(peg$c76);\n                  }\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 47) {\n                s3 = peg$c73;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n                {\n                  peg$fail(peg$c74);\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parseflags();\n\n                if (s4 === peg$FAILED) {\n                  s4 = null;\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s1 = peg$c77(s2, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsefield() {\n          var s0, s1, s2, s3, s4, s5, s6;\n          var key = peg$currPos * 30 + 21,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s1 = peg$c42;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c43);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseidentifierName();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$currPos;\n\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s5 = peg$c42;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                {\n                  peg$fail(peg$c43);\n                }\n              }\n\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseidentifierName();\n\n                if (s6 !== peg$FAILED) {\n                  s5 = [s5, s6];\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 46) {\n                  s5 = peg$c42;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n                  {\n                    peg$fail(peg$c43);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parseidentifierName();\n\n                  if (s6 !== peg$FAILED) {\n                    s5 = [s5, s6];\n                    s4 = s5;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c78(s2, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenegation() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 22,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 5) === peg$c79) {\n            s1 = peg$c79;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c80);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c81(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsematches() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 23,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 9) === peg$c82) {\n            s1 = peg$c82;\n            peg$currPos += 9;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c83);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c84(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsehas() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 24,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 5) === peg$c85) {\n            s1 = peg$c85;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c86);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c87(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsefirstChild() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 25,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 12) === peg$c88) {\n            s1 = peg$c88;\n            peg$currPos += 12;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c89);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c90();\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parselastChild() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 26,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 11) === peg$c91) {\n            s1 = peg$c91;\n            peg$currPos += 11;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c92);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c93();\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenthChild() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 27,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 11) === peg$c94) {\n            s1 = peg$c94;\n            peg$currPos += 11;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c95);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c61);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n\n                  if (peg$c60.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    {\n                      peg$fail(peg$c61);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c96(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenthLastChild() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 28,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 16) === peg$c97) {\n            s1 = peg$c97;\n            peg$currPos += 16;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c98);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n                {\n                  peg$fail(peg$c61);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n\n                  if (peg$c60.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n                    {\n                      peg$fail(peg$c61);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c99(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseclass() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 29,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s1 = peg$c100;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            {\n              peg$fail(peg$c101);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c102) {\n              s2 = input.substr(peg$currPos, 9);\n              peg$currPos += 9;\n            } else {\n              s2 = peg$FAILED;\n              {\n                peg$fail(peg$c103);\n              }\n            }\n\n            if (s2 === peg$FAILED) {\n              if (input.substr(peg$currPos, 10).toLowerCase() === peg$c104) {\n                s2 = input.substr(peg$currPos, 10);\n                peg$currPos += 10;\n              } else {\n                s2 = peg$FAILED;\n                {\n                  peg$fail(peg$c105);\n                }\n              }\n\n              if (s2 === peg$FAILED) {\n                if (input.substr(peg$currPos, 11).toLowerCase() === peg$c106) {\n                  s2 = input.substr(peg$currPos, 11);\n                  peg$currPos += 11;\n                } else {\n                  s2 = peg$FAILED;\n                  {\n                    peg$fail(peg$c107);\n                  }\n                }\n\n                if (s2 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 8).toLowerCase() === peg$c108) {\n                    s2 = input.substr(peg$currPos, 8);\n                    peg$currPos += 8;\n                  } else {\n                    s2 = peg$FAILED;\n                    {\n                      peg$fail(peg$c109);\n                    }\n                  }\n\n                  if (s2 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c110) {\n                      s2 = input.substr(peg$currPos, 7);\n                      peg$currPos += 7;\n                    } else {\n                      s2 = peg$FAILED;\n                      {\n                        peg$fail(peg$c111);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c112(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function nth(n) {\n          return {\n            type: 'nth-child',\n            index: {\n              type: 'literal',\n              value: n\n            }\n          };\n        }\n\n        function nthLast(n) {\n          return {\n            type: 'nth-last-child',\n            index: {\n              type: 'literal',\n              value: n\n            }\n          };\n        }\n\n        function strUnescape(s) {\n          return s.replace(/\\\\(.)/g, function (match, ch) {\n            switch (ch) {\n              case 'b':\n                return '\\b';\n\n              case 'f':\n                return '\\f';\n\n              case 'n':\n                return '\\n';\n\n              case 'r':\n                return '\\r';\n\n              case 't':\n                return '\\t';\n\n              case 'v':\n                return '\\v';\n\n              default:\n                return ch;\n            }\n          });\n        }\n\n        peg$result = peg$startRuleFunction();\n\n        if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n          return peg$result;\n        } else {\n          if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n            peg$fail(peg$endExpectation());\n          }\n\n          throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n        }\n      }\n\n      return {\n        SyntaxError: peg$SyntaxError,\n        parse: peg$parse\n      };\n    });\n  });\n\n  function _objectEntries(obj) {\n    var entries = [];\n    var keys = Object.keys(obj);\n\n    for (var k = 0; k < keys.length; k++) entries.push([keys[k], obj[keys[k]]]);\n\n    return entries;\n  }\n  /**\n  * @typedef {\"LEFT_SIDE\"|\"RIGHT_SIDE\"} Side\n  */\n\n\n  var LEFT_SIDE = 'LEFT_SIDE';\n  var RIGHT_SIDE = 'RIGHT_SIDE';\n  /**\n   * @external AST\n   * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html\n   */\n\n  /**\n   * One of the rules of `grammar.pegjs`\n   * @typedef {PlainObject} SelectorAST\n   * @see grammar.pegjs\n  */\n\n  /**\n   * The `sequence` production of `grammar.pegjs`\n   * @typedef {PlainObject} SelectorSequenceAST\n  */\n\n  /**\n   * Get the value of a property which may be multiple levels down\n   * in the object.\n   * @param {?PlainObject} obj\n   * @param {string} key\n   * @returns {undefined|boolean|string|number|external:AST}\n   */\n\n  function getPath(obj, key) {\n    var keys = key.split('.');\n\n    var _iterator = _createForOfIteratorHelper(keys),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _key = _step.value;\n\n        if (obj == null) {\n          return obj;\n        }\n\n        obj = obj[_key];\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return obj;\n  }\n  /**\n   * Determine whether `node` can be reached by following `path`,\n   * starting at `ancestor`.\n   * @param {?external:AST} node\n   * @param {?external:AST} ancestor\n   * @param {string[]} path\n   * @returns {boolean}\n   */\n\n\n  function inPath(node, ancestor, path) {\n    if (path.length === 0) {\n      return node === ancestor;\n    }\n\n    if (ancestor == null) {\n      return false;\n    }\n\n    var field = ancestor[path[0]];\n    var remainingPath = path.slice(1);\n\n    if (Array.isArray(field)) {\n      var _iterator2 = _createForOfIteratorHelper(field),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var component = _step2.value;\n\n          if (inPath(node, component, remainingPath)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return false;\n    } else {\n      return inPath(node, field, remainingPath);\n    }\n  }\n  /**\n   * @callback TraverseOptionFallback\n   * @param {external:AST} node The given node.\n   * @returns {string[]} An array of visitor keys for the given node.\n   */\n\n  /**\n   * @typedef {object} ESQueryOptions\n   * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.\n   * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.\n   */\n\n  /**\n   * Given a `node` and its ancestors, determine if `node` is matched\n   * by `selector`.\n   * @param {?external:AST} node\n   * @param {?SelectorAST} selector\n   * @param {external:AST[]} [ancestry=[]]\n   * @param {ESQueryOptions} [options]\n   * @throws {Error} Unknowns (operator, class name, selector type, or\n   * selector value type)\n   * @returns {boolean}\n   */\n\n\n  function matches(node, selector, ancestry, options) {\n    if (!selector) {\n      return true;\n    }\n\n    if (!node) {\n      return false;\n    }\n\n    if (!ancestry) {\n      ancestry = [];\n    }\n\n    switch (selector.type) {\n      case 'wildcard':\n        return true;\n\n      case 'identifier':\n        return selector.value.toLowerCase() === node.type.toLowerCase();\n\n      case 'field':\n        {\n          var path = selector.name.split('.');\n          var ancestor = ancestry[path.length - 1];\n          return inPath(node, ancestor, path);\n        }\n\n      case 'matches':\n        var _iterator3 = _createForOfIteratorHelper(selector.selectors),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var sel = _step3.value;\n\n            if (matches(node, sel, ancestry, options)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        return false;\n\n      case 'compound':\n        var _iterator4 = _createForOfIteratorHelper(selector.selectors),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _sel = _step4.value;\n\n            if (!matches(node, _sel, ancestry, options)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        return true;\n\n      case 'not':\n        var _iterator5 = _createForOfIteratorHelper(selector.selectors),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _sel2 = _step5.value;\n\n            if (matches(node, _sel2, ancestry, options)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        return true;\n\n      case 'has':\n        {\n          var _ret = function () {\n            var collector = [];\n\n            var _iterator6 = _createForOfIteratorHelper(selector.selectors),\n                _step6;\n\n            try {\n              var _loop = function _loop() {\n                var sel = _step6.value;\n                var a = [];\n                estraverse.traverse(node, {\n                  enter: function enter(node, parent) {\n                    if (parent != null) {\n                      a.unshift(parent);\n                    }\n\n                    if (matches(node, sel, a, options)) {\n                      collector.push(node);\n                    }\n                  },\n                  leave: function leave() {\n                    a.shift();\n                  },\n                  keys: options && options.visitorKeys,\n                  fallback: options && options.fallback || 'iteration'\n                });\n              };\n\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                _loop();\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n\n            return {\n              v: collector.length !== 0\n            };\n          }();\n\n          if (_typeof(_ret) === \"object\") return _ret.v;\n        }\n\n      case 'child':\n        if (matches(node, selector.right, ancestry, options)) {\n          return matches(ancestry[0], selector.left, ancestry.slice(1), options);\n        }\n\n        return false;\n\n      case 'descendant':\n        if (matches(node, selector.right, ancestry, options)) {\n          for (var i = 0, l = ancestry.length; i < l; ++i) {\n            if (matches(ancestry[i], selector.left, ancestry.slice(i + 1), options)) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n\n      case 'attribute':\n        {\n          var p = getPath(node, selector.name);\n\n          switch (selector.operator) {\n            case void 0:\n              return p != null;\n\n            case '=':\n              switch (selector.value.type) {\n                case 'regexp':\n                  return typeof p === 'string' && selector.value.value.test(p);\n\n                case 'literal':\n                  return \"\".concat(selector.value.value) === \"\".concat(p);\n\n                case 'type':\n                  return selector.value.value === _typeof(p);\n              }\n\n              throw new Error(\"Unknown selector value type: \".concat(selector.value.type));\n\n            case '!=':\n              switch (selector.value.type) {\n                case 'regexp':\n                  return !selector.value.value.test(p);\n\n                case 'literal':\n                  return \"\".concat(selector.value.value) !== \"\".concat(p);\n\n                case 'type':\n                  return selector.value.value !== _typeof(p);\n              }\n\n              throw new Error(\"Unknown selector value type: \".concat(selector.value.type));\n\n            case '<=':\n              return p <= selector.value.value;\n\n            case '<':\n              return p < selector.value.value;\n\n            case '>':\n              return p > selector.value.value;\n\n            case '>=':\n              return p >= selector.value.value;\n          }\n\n          throw new Error(\"Unknown operator: \".concat(selector.operator));\n        }\n\n      case 'sibling':\n        return matches(node, selector.right, ancestry, options) && sibling(node, selector.left, ancestry, LEFT_SIDE, options) || selector.left.subject && matches(node, selector.left, ancestry, options) && sibling(node, selector.right, ancestry, RIGHT_SIDE, options);\n\n      case 'adjacent':\n        return matches(node, selector.right, ancestry, options) && adjacent(node, selector.left, ancestry, LEFT_SIDE, options) || selector.right.subject && matches(node, selector.left, ancestry, options) && adjacent(node, selector.right, ancestry, RIGHT_SIDE, options);\n\n      case 'nth-child':\n        return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function () {\n          return selector.index.value - 1;\n        }, options);\n\n      case 'nth-last-child':\n        return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function (length) {\n          return length - selector.index.value;\n        }, options);\n\n      case 'class':\n        switch (selector.name.toLowerCase()) {\n          case 'statement':\n            if (node.type.slice(-9) === 'Statement') return true;\n          // fallthrough: interface Declaration <: Statement { }\n\n          case 'declaration':\n            return node.type.slice(-11) === 'Declaration';\n\n          case 'pattern':\n            if (node.type.slice(-7) === 'Pattern') return true;\n          // fallthrough: interface Expression <: Node, Pattern { }\n\n          case 'expression':\n            return node.type.slice(-10) === 'Expression' || node.type.slice(-7) === 'Literal' || node.type === 'Identifier' && (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty') || node.type === 'MetaProperty';\n\n          case 'function':\n            return node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';\n        }\n\n        throw new Error(\"Unknown class name: \".concat(selector.name));\n    }\n\n    throw new Error(\"Unknown selector type: \".concat(selector.type));\n  }\n  /**\n   * Get visitor keys of a given node.\n   * @param {external:AST} node The AST node to get keys.\n   * @param {ESQueryOptions|undefined} options\n   * @returns {string[]} Visitor keys of the node.\n   */\n\n\n  function getVisitorKeys(node, options) {\n    var nodeType = node.type;\n\n    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {\n      return options.visitorKeys[nodeType];\n    }\n\n    if (estraverse.VisitorKeys[nodeType]) {\n      return estraverse.VisitorKeys[nodeType];\n    }\n\n    if (options && typeof options.fallback === 'function') {\n      return options.fallback(node);\n    } // 'iteration' fallback\n\n\n    return Object.keys(node).filter(function (key) {\n      return key !== 'type';\n    });\n  }\n  /**\n   * Check whether the given value is an ASTNode or not.\n   * @param {any} node The value to check.\n   * @returns {boolean} `true` if the value is an ASTNode.\n   */\n\n\n  function isNode(node) {\n    return node !== null && _typeof(node) === 'object' && typeof node.type === 'string';\n  }\n  /**\n   * Determines if the given node has a sibling that matches the\n   * given selector.\n   * @param {external:AST} node\n   * @param {SelectorSequenceAST} selector\n   * @param {external:AST[]} ancestry\n   * @param {Side} side\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n\n\n  function sibling(node, selector, ancestry, side, options) {\n    var _ancestry = _slicedToArray(ancestry, 1),\n        parent = _ancestry[0];\n\n    if (!parent) {\n      return false;\n    }\n\n    var keys = getVisitorKeys(parent, options);\n\n    var _iterator7 = _createForOfIteratorHelper(keys),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var key = _step7.value;\n        var listProp = parent[key];\n\n        if (Array.isArray(listProp)) {\n          var startIndex = listProp.indexOf(node);\n\n          if (startIndex < 0) {\n            continue;\n          }\n\n          var lowerBound = void 0,\n              upperBound = void 0;\n\n          if (side === LEFT_SIDE) {\n            lowerBound = 0;\n            upperBound = startIndex;\n          } else {\n            lowerBound = startIndex + 1;\n            upperBound = listProp.length;\n          }\n\n          for (var k = lowerBound; k < upperBound; ++k) {\n            if (isNode(listProp[k]) && matches(listProp[k], selector, ancestry, options)) {\n              return true;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    return false;\n  }\n  /**\n   * Determines if the given node has an adjacent sibling that matches\n   * the given selector.\n   * @param {external:AST} node\n   * @param {SelectorSequenceAST} selector\n   * @param {external:AST[]} ancestry\n   * @param {Side} side\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n\n\n  function adjacent(node, selector, ancestry, side, options) {\n    var _ancestry2 = _slicedToArray(ancestry, 1),\n        parent = _ancestry2[0];\n\n    if (!parent) {\n      return false;\n    }\n\n    var keys = getVisitorKeys(parent, options);\n\n    var _iterator8 = _createForOfIteratorHelper(keys),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var key = _step8.value;\n        var listProp = parent[key];\n\n        if (Array.isArray(listProp)) {\n          var idx = listProp.indexOf(node);\n\n          if (idx < 0) {\n            continue;\n          }\n\n          if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1]) && matches(listProp[idx - 1], selector, ancestry, options)) {\n            return true;\n          }\n\n          if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1]) && matches(listProp[idx + 1], selector, ancestry, options)) {\n            return true;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n\n    return false;\n  }\n  /**\n  * @callback IndexFunction\n  * @param {Integer} len Containing list's length\n  * @returns {Integer}\n  */\n\n  /**\n   * Determines if the given node is the nth child, determined by\n   * `idxFn`, which is given the containing list's length.\n   * @param {external:AST} node\n   * @param {external:AST[]} ancestry\n   * @param {IndexFunction} idxFn\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n\n\n  function nthChild(node, ancestry, idxFn, options) {\n    var _ancestry3 = _slicedToArray(ancestry, 1),\n        parent = _ancestry3[0];\n\n    if (!parent) {\n      return false;\n    }\n\n    var keys = getVisitorKeys(parent, options);\n\n    var _iterator9 = _createForOfIteratorHelper(keys),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var key = _step9.value;\n        var listProp = parent[key];\n\n        if (Array.isArray(listProp)) {\n          var idx = listProp.indexOf(node);\n\n          if (idx >= 0 && idx === idxFn(listProp.length)) {\n            return true;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    return false;\n  }\n  /**\n   * For each selector node marked as a subject, find the portion of the\n   * selector that the subject must match.\n   * @param {SelectorAST} selector\n   * @param {SelectorAST} [ancestor] Defaults to `selector`\n   * @returns {SelectorAST[]}\n   */\n\n\n  function subjects(selector, ancestor) {\n    if (selector == null || _typeof(selector) != 'object') {\n      return [];\n    }\n\n    if (ancestor == null) {\n      ancestor = selector;\n    }\n\n    var results = selector.subject ? [ancestor] : [];\n\n    for (var _i = 0, _Object$entries = _objectEntries(selector); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          p = _Object$entries$_i[0],\n          sel = _Object$entries$_i[1];\n\n      results.push.apply(results, _toConsumableArray(subjects(sel, p === 'left' ? sel : ancestor)));\n    }\n\n    return results;\n  }\n  /**\n  * @callback TraverseVisitor\n  * @param {?external:AST} node\n  * @param {?external:AST} parent\n  * @param {external:AST[]} ancestry\n  */\n\n  /**\n   * From a JS AST and a selector AST, collect all JS AST nodes that\n   * match the selector.\n   * @param {external:AST} ast\n   * @param {?SelectorAST} selector\n   * @param {TraverseVisitor} visitor\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n\n\n  function traverse(ast, selector, visitor, options) {\n    if (!selector) {\n      return;\n    }\n\n    var ancestry = [];\n    var altSubjects = subjects(selector);\n    estraverse.traverse(ast, {\n      enter: function enter(node, parent) {\n        if (parent != null) {\n          ancestry.unshift(parent);\n        }\n\n        if (matches(node, selector, ancestry, options)) {\n          if (altSubjects.length) {\n            for (var i = 0, l = altSubjects.length; i < l; ++i) {\n              if (matches(node, altSubjects[i], ancestry, options)) {\n                visitor(node, parent, ancestry);\n              }\n\n              for (var k = 0, m = ancestry.length; k < m; ++k) {\n                var succeedingAncestry = ancestry.slice(k + 1);\n\n                if (matches(ancestry[k], altSubjects[i], succeedingAncestry, options)) {\n                  visitor(ancestry[k], parent, succeedingAncestry);\n                }\n              }\n            }\n          } else {\n            visitor(node, parent, ancestry);\n          }\n        }\n      },\n      leave: function leave() {\n        ancestry.shift();\n      },\n      keys: options && options.visitorKeys,\n      fallback: options && options.fallback || 'iteration'\n    });\n  }\n  /**\n   * From a JS AST and a selector AST, collect all JS AST nodes that\n   * match the selector.\n   * @param {external:AST} ast\n   * @param {?SelectorAST} selector\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n\n\n  function match(ast, selector, options) {\n    var results = [];\n    traverse(ast, selector, function (node) {\n      results.push(node);\n    }, options);\n    return results;\n  }\n  /**\n   * Parse a selector string and return its AST.\n   * @param {string} selector\n   * @returns {SelectorAST}\n   */\n\n\n  function parse(selector) {\n    return parser.parse(selector);\n  }\n  /**\n   * Query the code AST using the selector string.\n   * @param {external:AST} ast\n   * @param {string} selector\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n\n\n  function query(ast, selector, options) {\n    return match(ast, parse(selector), options);\n  }\n\n  query.parse = parse;\n  query.match = match;\n  query.traverse = traverse;\n  query.matches = matches;\n  query.query = query;\n  return query;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","self","esquery","_typeof","obj","Symbol","iterator","constructor","prototype","_slicedToArray","arr","i","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toConsumableArray","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","Object","from","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","o","minLen","n","toString","call","slice","name","test","len","arr2","TypeError","_createForOfIteratorHelper","allowArrayLike","it","F","s","e","f","normalCompletion","didErr","step","return","commonjsGlobal","globalThis","window","createCommonjsModule","fn","estraverse","clone","Syntax","VisitorOption","VisitorKeys","BREAK","SKIP","REMOVE","deepCopy","ret","key","val","hasOwnProperty","upperBound","array","func","diff","current","AssignmentExpression","AssignmentPattern","ArrayExpression","ArrayPattern","ArrowFunctionExpression","AwaitExpression","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ChainExpression","ClassBody","ClassDeclaration","ClassExpression","ComprehensionBlock","ComprehensionExpression","ConditionalExpression","ContinueStatement","DebuggerStatement","DirectiveStatement","DoWhileStatement","EmptyStatement","ExportAllDeclaration","ExportDefaultDeclaration","ExportNamedDeclaration","ExportSpecifier","ExpressionStatement","ForStatement","ForInStatement","ForOfStatement","FunctionDeclaration","FunctionExpression","GeneratorExpression","Identifier","IfStatement","ImportExpression","ImportDeclaration","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportSpecifier","Literal","LabeledStatement","LogicalExpression","MemberExpression","MetaProperty","MethodDefinition","ModuleSpecifier","NewExpression","ObjectExpression","ObjectPattern","Program","Property","RestElement","ReturnStatement","SequenceExpression","SpreadElement","Super","SwitchStatement","SwitchCase","TaggedTemplateExpression","TemplateElement","TemplateLiteral","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","YieldExpression","Break","Skip","Remove","Reference","parent","replace","node","remove","splice","Element","path","wrap","ref","Controller","iz","j","jz","result","element","addToPath","__current","__leavelist","type","parents","__execute","callback","previous","__state","notify","flag","skip","__initialize","root","visitor","__worklist","__fallback","fallback","keys","__keys","assign","create","isNode","isProperty","nodeType","candidateExistsInLeaveList","leavelist","candidate","traverse","worklist","current2","candidates","sentinel","pop","leave","enter","Error","target","outer","removeElem","nextElem","controller","extendCommentRange","comment","tokens","search","token","range","extendedRange","attachComments","tree","providedComments","comments","cursor","leadingComments","trailingComments","cloneEnvironment","parser","peg$subclass","child","ctor","peg$SyntaxError","message","expected","found","location","captureStackTrace","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","_class","escapedParts","parts","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toUpperCase","describeExpectation","describeExpected","descriptions","sort","join","describeFound","peg$parse","input","options","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c0","ss","selectors","peg$c1","peg$c2","peg$c3","peg$literalExpectation","peg$c4","peg$c5","peg$classExpectation","peg$c6","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","peg$c19","concat","map","peg$c20","a","ops","reduce","memo","rhs","left","right","peg$c21","peg$c22","peg$c23","subject","as","b","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","v","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","apply","peg$c45","op","operator","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$anyExpectation","peg$c54","peg$c55","d","strUnescape","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","leadingDecimals","parseFloat","peg$c63","peg$c64","peg$c65","peg$c66","peg$c67","peg$c68","peg$c69","peg$c70","t","peg$c71","peg$c72","peg$c73","peg$c74","peg$c75","peg$c76","peg$c77","flgs","RegExp","peg$c78","is","p","peg$c79","peg$c80","peg$c81","peg$c82","peg$c83","peg$c84","peg$c85","peg$c86","peg$c87","peg$c88","peg$c89","peg$c90","nth","peg$c91","peg$c92","peg$c93","nthLast","peg$c94","peg$c95","peg$c96","parseInt","peg$c97","peg$c98","peg$c99","peg$c100","peg$c101","peg$c102","peg$c103","peg$c104","peg$c105","peg$c106","peg$c107","peg$c108","peg$c109","peg$c110","peg$c111","peg$c112","c","peg$currPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$resultsCache","peg$result","startRule","ignoreCase","peg$endExpectation","peg$computePosDetails","pos","details","peg$computeLocation","startPos","endPos","startPosDetails","endPosDetails","offset","peg$fail","peg$buildStructuredError","s0","s1","s2","s3","cached","nextPos","peg$parse_","peg$parseselectors","peg$parseidentifierName","charAt","peg$parsebinaryOp","s4","s5","s6","s7","peg$parseselector","peg$parsesequence","peg$parseatom","peg$parsewildcard","peg$parseidentifier","peg$parseattr","peg$parsefield","peg$parsenegation","peg$parsematches","peg$parsehas","peg$parsefirstChild","peg$parselastChild","peg$parsenthChild","peg$parsenthLastChild","peg$parseclass","peg$parseattrValue","peg$parseattrOps","peg$parseattrEqOps","peg$parseattrName","peg$parsetype","peg$parseregex","peg$parsestring","peg$parsenumber","peg$parsepath","substr","peg$parseflags","toLowerCase","index","match","SyntaxError","parse","_objectEntries","entries","k","LEFT_SIDE","RIGHT_SIDE","getPath","split","_iterator","_step","_key","inPath","ancestor","field","remainingPath","_iterator2","_step2","component","matches","selector","ancestry","_iterator3","_step3","sel","_iterator4","_step4","_sel","_iterator5","_step5","_sel2","_ret","collector","_iterator6","_step6","_loop","unshift","shift","visitorKeys","l","sibling","adjacent","nthChild","getVisitorKeys","filter","side","_ancestry","_iterator7","_step7","listProp","startIndex","indexOf","lowerBound","_ancestry2","_iterator8","_step8","idx","idxFn","_ancestry3","_iterator9","_step9","subjects","results","_Object$entries","_Object$entries$_i","ast","altSubjects","m","succeedingAncestry","query"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/esquery/dist/esquery.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = global || self, global.esquery = factory());\n}(this, (function () { 'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n\n  function _iterableToArrayLimit(arr, i) {\n    if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n\n        var F = function () {};\n\n        return {\n          s: F,\n          n: function () {\n            if (i >= o.length) return {\n              done: true\n            };\n            return {\n              done: false,\n              value: o[i++]\n            };\n          },\n          e: function (e) {\n            throw e;\n          },\n          f: F\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true,\n        didErr = false,\n        err;\n    return {\n      s: function () {\n        it = o[Symbol.iterator]();\n      },\n      n: function () {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function (e) {\n        didErr = true;\n        err = e;\n      },\n      f: function () {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n  \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n  }\n\n  var estraverse = createCommonjsModule(function (module, exports) {\n    /*\n      Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>\n      Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n    \n      Redistribution and use in source and binary forms, with or without\n      modification, are permitted provided that the following conditions are met:\n    \n        * Redistributions of source code must retain the above copyright\n          notice, this list of conditions and the following disclaimer.\n        * Redistributions in binary form must reproduce the above copyright\n          notice, this list of conditions and the following disclaimer in the\n          documentation and/or other materials provided with the distribution.\n    \n      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n    */\n\n    /*jslint vars:false, bitwise:true*/\n\n    /*jshint indent:4*/\n\n    /*global exports:true*/\n    (function clone(exports) {\n\n      var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;\n\n      function deepCopy(obj) {\n        var ret = {},\n            key,\n            val;\n\n        for (key in obj) {\n          if (obj.hasOwnProperty(key)) {\n            val = obj[key];\n\n            if (typeof val === 'object' && val !== null) {\n              ret[key] = deepCopy(val);\n            } else {\n              ret[key] = val;\n            }\n          }\n        }\n\n        return ret;\n      } // based on LLVM libc++ upper_bound / lower_bound\n      // MIT License\n\n\n      function upperBound(array, func) {\n        var diff, len, i, current;\n        len = array.length;\n        i = 0;\n\n        while (len) {\n          diff = len >>> 1;\n          current = i + diff;\n\n          if (func(array[current])) {\n            len = diff;\n          } else {\n            i = current + 1;\n            len -= diff + 1;\n          }\n        }\n\n        return i;\n      }\n\n      Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        AwaitExpression: 'AwaitExpression',\n        // CAUTION: It's deferred to ES7.\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ChainExpression: 'ChainExpression',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ComprehensionBlock: 'ComprehensionBlock',\n        // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: 'ComprehensionExpression',\n        // CAUTION: It's deferred to ES7.\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        DirectiveStatement: 'DirectiveStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        ForOfStatement: 'ForOfStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        GeneratorExpression: 'GeneratorExpression',\n        // CAUTION: It's deferred to ES7.\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportExpression: 'ImportExpression',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MetaProperty: 'MetaProperty',\n        MethodDefinition: 'MethodDefinition',\n        ModuleSpecifier: 'ModuleSpecifier',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement',\n        YieldExpression: 'YieldExpression'\n      };\n      VisitorKeys = {\n        AssignmentExpression: ['left', 'right'],\n        AssignmentPattern: ['left', 'right'],\n        ArrayExpression: ['elements'],\n        ArrayPattern: ['elements'],\n        ArrowFunctionExpression: ['params', 'body'],\n        AwaitExpression: ['argument'],\n        // CAUTION: It's deferred to ES7.\n        BlockStatement: ['body'],\n        BinaryExpression: ['left', 'right'],\n        BreakStatement: ['label'],\n        CallExpression: ['callee', 'arguments'],\n        CatchClause: ['param', 'body'],\n        ChainExpression: ['expression'],\n        ClassBody: ['body'],\n        ClassDeclaration: ['id', 'superClass', 'body'],\n        ClassExpression: ['id', 'superClass', 'body'],\n        ComprehensionBlock: ['left', 'right'],\n        // CAUTION: It's deferred to ES7.\n        ComprehensionExpression: ['blocks', 'filter', 'body'],\n        // CAUTION: It's deferred to ES7.\n        ConditionalExpression: ['test', 'consequent', 'alternate'],\n        ContinueStatement: ['label'],\n        DebuggerStatement: [],\n        DirectiveStatement: [],\n        DoWhileStatement: ['body', 'test'],\n        EmptyStatement: [],\n        ExportAllDeclaration: ['source'],\n        ExportDefaultDeclaration: ['declaration'],\n        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],\n        ExportSpecifier: ['exported', 'local'],\n        ExpressionStatement: ['expression'],\n        ForStatement: ['init', 'test', 'update', 'body'],\n        ForInStatement: ['left', 'right', 'body'],\n        ForOfStatement: ['left', 'right', 'body'],\n        FunctionDeclaration: ['id', 'params', 'body'],\n        FunctionExpression: ['id', 'params', 'body'],\n        GeneratorExpression: ['blocks', 'filter', 'body'],\n        // CAUTION: It's deferred to ES7.\n        Identifier: [],\n        IfStatement: ['test', 'consequent', 'alternate'],\n        ImportExpression: ['source'],\n        ImportDeclaration: ['specifiers', 'source'],\n        ImportDefaultSpecifier: ['local'],\n        ImportNamespaceSpecifier: ['local'],\n        ImportSpecifier: ['imported', 'local'],\n        Literal: [],\n        LabeledStatement: ['label', 'body'],\n        LogicalExpression: ['left', 'right'],\n        MemberExpression: ['object', 'property'],\n        MetaProperty: ['meta', 'property'],\n        MethodDefinition: ['key', 'value'],\n        ModuleSpecifier: [],\n        NewExpression: ['callee', 'arguments'],\n        ObjectExpression: ['properties'],\n        ObjectPattern: ['properties'],\n        Program: ['body'],\n        Property: ['key', 'value'],\n        RestElement: ['argument'],\n        ReturnStatement: ['argument'],\n        SequenceExpression: ['expressions'],\n        SpreadElement: ['argument'],\n        Super: [],\n        SwitchStatement: ['discriminant', 'cases'],\n        SwitchCase: ['test', 'consequent'],\n        TaggedTemplateExpression: ['tag', 'quasi'],\n        TemplateElement: [],\n        TemplateLiteral: ['quasis', 'expressions'],\n        ThisExpression: [],\n        ThrowStatement: ['argument'],\n        TryStatement: ['block', 'handler', 'finalizer'],\n        UnaryExpression: ['argument'],\n        UpdateExpression: ['argument'],\n        VariableDeclaration: ['declarations'],\n        VariableDeclarator: ['id', 'init'],\n        WhileStatement: ['test', 'body'],\n        WithStatement: ['object', 'body'],\n        YieldExpression: ['argument']\n      }; // unique id\n\n      BREAK = {};\n      SKIP = {};\n      REMOVE = {};\n      VisitorOption = {\n        Break: BREAK,\n        Skip: SKIP,\n        Remove: REMOVE\n      };\n\n      function Reference(parent, key) {\n        this.parent = parent;\n        this.key = key;\n      }\n\n      Reference.prototype.replace = function replace(node) {\n        this.parent[this.key] = node;\n      };\n\n      Reference.prototype.remove = function remove() {\n        if (Array.isArray(this.parent)) {\n          this.parent.splice(this.key, 1);\n          return true;\n        } else {\n          this.replace(null);\n          return false;\n        }\n      };\n\n      function Element(node, path, wrap, ref) {\n        this.node = node;\n        this.path = path;\n        this.wrap = wrap;\n        this.ref = ref;\n      }\n\n      function Controller() {} // API:\n      // return property path array from root to current node\n\n\n      Controller.prototype.path = function path() {\n        var i, iz, j, jz, result, element;\n\n        function addToPath(result, path) {\n          if (Array.isArray(path)) {\n            for (j = 0, jz = path.length; j < jz; ++j) {\n              result.push(path[j]);\n            }\n          } else {\n            result.push(path);\n          }\n        } // root node\n\n\n        if (!this.__current.path) {\n          return null;\n        } // first node is sentinel, second node is root element\n\n\n        result = [];\n\n        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {\n          element = this.__leavelist[i];\n          addToPath(result, element.path);\n        }\n\n        addToPath(result, this.__current.path);\n        return result;\n      }; // API:\n      // return type of current node\n\n\n      Controller.prototype.type = function () {\n        var node = this.current();\n        return node.type || this.__current.wrap;\n      }; // API:\n      // return array of parent elements\n\n\n      Controller.prototype.parents = function parents() {\n        var i, iz, result; // first node is sentinel\n\n        result = [];\n\n        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {\n          result.push(this.__leavelist[i].node);\n        }\n\n        return result;\n      }; // API:\n      // return current node\n\n\n      Controller.prototype.current = function current() {\n        return this.__current.node;\n      };\n\n      Controller.prototype.__execute = function __execute(callback, element) {\n        var previous, result;\n        result = undefined;\n        previous = this.__current;\n        this.__current = element;\n        this.__state = null;\n\n        if (callback) {\n          result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);\n        }\n\n        this.__current = previous;\n        return result;\n      }; // API:\n      // notify control skip / break\n\n\n      Controller.prototype.notify = function notify(flag) {\n        this.__state = flag;\n      }; // API:\n      // skip child nodes of current node\n\n\n      Controller.prototype.skip = function () {\n        this.notify(SKIP);\n      }; // API:\n      // break traversals\n\n\n      Controller.prototype['break'] = function () {\n        this.notify(BREAK);\n      }; // API:\n      // remove node\n\n\n      Controller.prototype.remove = function () {\n        this.notify(REMOVE);\n      };\n\n      Controller.prototype.__initialize = function (root, visitor) {\n        this.visitor = visitor;\n        this.root = root;\n        this.__worklist = [];\n        this.__leavelist = [];\n        this.__current = null;\n        this.__state = null;\n        this.__fallback = null;\n\n        if (visitor.fallback === 'iteration') {\n          this.__fallback = Object.keys;\n        } else if (typeof visitor.fallback === 'function') {\n          this.__fallback = visitor.fallback;\n        }\n\n        this.__keys = VisitorKeys;\n\n        if (visitor.keys) {\n          this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);\n        }\n      };\n\n      function isNode(node) {\n        if (node == null) {\n          return false;\n        }\n\n        return typeof node === 'object' && typeof node.type === 'string';\n      }\n\n      function isProperty(nodeType, key) {\n        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;\n      }\n\n      function candidateExistsInLeaveList(leavelist, candidate) {\n        for (var i = leavelist.length - 1; i >= 0; --i) {\n          if (leavelist[i].node === candidate) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      Controller.prototype.traverse = function traverse(root, visitor) {\n        var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;\n\n        this.__initialize(root, visitor);\n\n        sentinel = {}; // reference\n\n        worklist = this.__worklist;\n        leavelist = this.__leavelist; // initialize\n\n        worklist.push(new Element(root, null, null, null));\n        leavelist.push(new Element(null, null, null, null));\n\n        while (worklist.length) {\n          element = worklist.pop();\n\n          if (element === sentinel) {\n            element = leavelist.pop();\n            ret = this.__execute(visitor.leave, element);\n\n            if (this.__state === BREAK || ret === BREAK) {\n              return;\n            }\n\n            continue;\n          }\n\n          if (element.node) {\n            ret = this.__execute(visitor.enter, element);\n\n            if (this.__state === BREAK || ret === BREAK) {\n              return;\n            }\n\n            worklist.push(sentinel);\n            leavelist.push(element);\n\n            if (this.__state === SKIP || ret === SKIP) {\n              continue;\n            }\n\n            node = element.node;\n            nodeType = node.type || element.wrap;\n            candidates = this.__keys[nodeType];\n\n            if (!candidates) {\n              if (this.__fallback) {\n                candidates = this.__fallback(node);\n              } else {\n                throw new Error('Unknown node type ' + nodeType + '.');\n              }\n            }\n\n            current = candidates.length;\n\n            while ((current -= 1) >= 0) {\n              key = candidates[current];\n              candidate = node[key];\n\n              if (!candidate) {\n                continue;\n              }\n\n              if (Array.isArray(candidate)) {\n                current2 = candidate.length;\n\n                while ((current2 -= 1) >= 0) {\n                  if (!candidate[current2]) {\n                    continue;\n                  }\n\n                  if (candidateExistsInLeaveList(leavelist, candidate[current2])) {\n                    continue;\n                  }\n\n                  if (isProperty(nodeType, candidates[current])) {\n                    element = new Element(candidate[current2], [key, current2], 'Property', null);\n                  } else if (isNode(candidate[current2])) {\n                    element = new Element(candidate[current2], [key, current2], null, null);\n                  } else {\n                    continue;\n                  }\n\n                  worklist.push(element);\n                }\n              } else if (isNode(candidate)) {\n                if (candidateExistsInLeaveList(leavelist, candidate)) {\n                  continue;\n                }\n\n                worklist.push(new Element(candidate, key, null, null));\n              }\n            }\n          }\n        }\n      };\n\n      Controller.prototype.replace = function replace(root, visitor) {\n        var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;\n\n        function removeElem(element) {\n          var i, key, nextElem, parent;\n\n          if (element.ref.remove()) {\n            // When the reference is an element of an array.\n            key = element.ref.key;\n            parent = element.ref.parent; // If removed from array, then decrease following items' keys.\n\n            i = worklist.length;\n\n            while (i--) {\n              nextElem = worklist[i];\n\n              if (nextElem.ref && nextElem.ref.parent === parent) {\n                if (nextElem.ref.key < key) {\n                  break;\n                }\n\n                --nextElem.ref.key;\n              }\n            }\n          }\n        }\n\n        this.__initialize(root, visitor);\n\n        sentinel = {}; // reference\n\n        worklist = this.__worklist;\n        leavelist = this.__leavelist; // initialize\n\n        outer = {\n          root: root\n        };\n        element = new Element(root, null, null, new Reference(outer, 'root'));\n        worklist.push(element);\n        leavelist.push(element);\n\n        while (worklist.length) {\n          element = worklist.pop();\n\n          if (element === sentinel) {\n            element = leavelist.pop();\n            target = this.__execute(visitor.leave, element); // node may be replaced with null,\n            // so distinguish between undefined and null in this place\n\n            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n              // replace\n              element.ref.replace(target);\n            }\n\n            if (this.__state === REMOVE || target === REMOVE) {\n              removeElem(element);\n            }\n\n            if (this.__state === BREAK || target === BREAK) {\n              return outer.root;\n            }\n\n            continue;\n          }\n\n          target = this.__execute(visitor.enter, element); // node may be replaced with null,\n          // so distinguish between undefined and null in this place\n\n          if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {\n            // replace\n            element.ref.replace(target);\n            element.node = target;\n          }\n\n          if (this.__state === REMOVE || target === REMOVE) {\n            removeElem(element);\n            element.node = null;\n          }\n\n          if (this.__state === BREAK || target === BREAK) {\n            return outer.root;\n          } // node may be null\n\n\n          node = element.node;\n\n          if (!node) {\n            continue;\n          }\n\n          worklist.push(sentinel);\n          leavelist.push(element);\n\n          if (this.__state === SKIP || target === SKIP) {\n            continue;\n          }\n\n          nodeType = node.type || element.wrap;\n          candidates = this.__keys[nodeType];\n\n          if (!candidates) {\n            if (this.__fallback) {\n              candidates = this.__fallback(node);\n            } else {\n              throw new Error('Unknown node type ' + nodeType + '.');\n            }\n          }\n\n          current = candidates.length;\n\n          while ((current -= 1) >= 0) {\n            key = candidates[current];\n            candidate = node[key];\n\n            if (!candidate) {\n              continue;\n            }\n\n            if (Array.isArray(candidate)) {\n              current2 = candidate.length;\n\n              while ((current2 -= 1) >= 0) {\n                if (!candidate[current2]) {\n                  continue;\n                }\n\n                if (isProperty(nodeType, candidates[current])) {\n                  element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));\n                } else if (isNode(candidate[current2])) {\n                  element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));\n                } else {\n                  continue;\n                }\n\n                worklist.push(element);\n              }\n            } else if (isNode(candidate)) {\n              worklist.push(new Element(candidate, key, null, new Reference(node, key)));\n            }\n          }\n        }\n\n        return outer.root;\n      };\n\n      function traverse(root, visitor) {\n        var controller = new Controller();\n        return controller.traverse(root, visitor);\n      }\n\n      function replace(root, visitor) {\n        var controller = new Controller();\n        return controller.replace(root, visitor);\n      }\n\n      function extendCommentRange(comment, tokens) {\n        var target;\n        target = upperBound(tokens, function search(token) {\n          return token.range[0] > comment.range[0];\n        });\n        comment.extendedRange = [comment.range[0], comment.range[1]];\n\n        if (target !== tokens.length) {\n          comment.extendedRange[1] = tokens[target].range[0];\n        }\n\n        target -= 1;\n\n        if (target >= 0) {\n          comment.extendedRange[0] = tokens[target].range[1];\n        }\n\n        return comment;\n      }\n\n      function attachComments(tree, providedComments, tokens) {\n        // At first, we should calculate extended comment ranges.\n        var comments = [],\n            comment,\n            len,\n            i,\n            cursor;\n\n        if (!tree.range) {\n          throw new Error('attachComments needs range information');\n        } // tokens array is empty, we attach comments to tree as 'leadingComments'\n\n\n        if (!tokens.length) {\n          if (providedComments.length) {\n            for (i = 0, len = providedComments.length; i < len; i += 1) {\n              comment = deepCopy(providedComments[i]);\n              comment.extendedRange = [0, tree.range[0]];\n              comments.push(comment);\n            }\n\n            tree.leadingComments = comments;\n          }\n\n          return tree;\n        }\n\n        for (i = 0, len = providedComments.length; i < len; i += 1) {\n          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));\n        } // This is based on John Freeman's implementation.\n\n\n        cursor = 0;\n        traverse(tree, {\n          enter: function (node) {\n            var comment;\n\n            while (cursor < comments.length) {\n              comment = comments[cursor];\n\n              if (comment.extendedRange[1] > node.range[0]) {\n                break;\n              }\n\n              if (comment.extendedRange[1] === node.range[0]) {\n                if (!node.leadingComments) {\n                  node.leadingComments = [];\n                }\n\n                node.leadingComments.push(comment);\n                comments.splice(cursor, 1);\n              } else {\n                cursor += 1;\n              }\n            } // already out of owned node\n\n\n            if (cursor === comments.length) {\n              return VisitorOption.Break;\n            }\n\n            if (comments[cursor].extendedRange[0] > node.range[1]) {\n              return VisitorOption.Skip;\n            }\n          }\n        });\n        cursor = 0;\n        traverse(tree, {\n          leave: function (node) {\n            var comment;\n\n            while (cursor < comments.length) {\n              comment = comments[cursor];\n\n              if (node.range[1] < comment.extendedRange[0]) {\n                break;\n              }\n\n              if (node.range[1] === comment.extendedRange[0]) {\n                if (!node.trailingComments) {\n                  node.trailingComments = [];\n                }\n\n                node.trailingComments.push(comment);\n                comments.splice(cursor, 1);\n              } else {\n                cursor += 1;\n              }\n            } // already out of owned node\n\n\n            if (cursor === comments.length) {\n              return VisitorOption.Break;\n            }\n\n            if (comments[cursor].extendedRange[0] > node.range[1]) {\n              return VisitorOption.Skip;\n            }\n          }\n        });\n        return tree;\n      }\n\n      exports.Syntax = Syntax;\n      exports.traverse = traverse;\n      exports.replace = replace;\n      exports.attachComments = attachComments;\n      exports.VisitorKeys = VisitorKeys;\n      exports.VisitorOption = VisitorOption;\n      exports.Controller = Controller;\n\n      exports.cloneEnvironment = function () {\n        return clone({});\n      };\n\n      return exports;\n    })(exports);\n    /* vim: set sw=4 ts=4 et tw=80 : */\n\n  });\n\n  var parser = createCommonjsModule(function (module) {\n    /*\n     * Generated by PEG.js 0.10.0.\n     *\n     * http://pegjs.org/\n     */\n    (function (root, factory) {\n      if ( module.exports) {\n        module.exports = factory();\n      }\n    })(commonjsGlobal, function () {\n\n      function peg$subclass(child, parent) {\n        function ctor() {\n          this.constructor = child;\n        }\n\n        ctor.prototype = parent.prototype;\n        child.prototype = new ctor();\n      }\n\n      function peg$SyntaxError(message, expected, found, location) {\n        this.message = message;\n        this.expected = expected;\n        this.found = found;\n        this.location = location;\n        this.name = \"SyntaxError\";\n\n        if (typeof Error.captureStackTrace === \"function\") {\n          Error.captureStackTrace(this, peg$SyntaxError);\n        }\n      }\n\n      peg$subclass(peg$SyntaxError, Error);\n\n      peg$SyntaxError.buildMessage = function (expected, found) {\n        var DESCRIBE_EXPECTATION_FNS = {\n          literal: function literal(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n          \"class\": function _class(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n          any: function any(expectation) {\n            return \"any character\";\n          },\n          end: function end(expectation) {\n            return \"end of input\";\n          },\n          other: function other(expectation) {\n            return expectation.description;\n          }\n        };\n\n        function hex(ch) {\n          return ch.charCodeAt(0).toString(16).toUpperCase();\n        }\n\n        function literalEscape(s) {\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          });\n        }\n\n        function classEscape(s) {\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\\]/g, '\\\\]').replace(/\\^/g, '\\\\^').replace(/-/g, '\\\\-').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          });\n        }\n\n        function describeExpectation(expectation) {\n          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n        }\n\n        function describeExpected(expected) {\n          var descriptions = new Array(expected.length),\n              i,\n              j;\n\n          for (i = 0; i < expected.length; i++) {\n            descriptions[i] = describeExpectation(expected[i]);\n          }\n\n          descriptions.sort();\n\n          if (descriptions.length > 0) {\n            for (i = 1, j = 1; i < descriptions.length; i++) {\n              if (descriptions[i - 1] !== descriptions[i]) {\n                descriptions[j] = descriptions[i];\n                j++;\n              }\n            }\n\n            descriptions.length = j;\n          }\n\n          switch (descriptions.length) {\n            case 1:\n              return descriptions[0];\n\n            case 2:\n              return descriptions[0] + \" or \" + descriptions[1];\n\n            default:\n              return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n          }\n        }\n\n        function describeFound(found) {\n          return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n        }\n\n        return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n      };\n\n      function peg$parse(input, options) {\n        options = options !== void 0 ? options : {};\n\n        var peg$FAILED = {},\n            peg$startRuleFunctions = {\n          start: peg$parsestart\n        },\n            peg$startRuleFunction = peg$parsestart,\n            peg$c0 = function peg$c0(ss) {\n          return ss.length === 1 ? ss[0] : {\n            type: 'matches',\n            selectors: ss\n          };\n        },\n            peg$c1 = function peg$c1() {\n          return void 0;\n        },\n            peg$c2 = \" \",\n            peg$c3 = peg$literalExpectation(\" \", false),\n            peg$c4 = /^[^ [\\],():#!=><~+.]/,\n            peg$c5 = peg$classExpectation([\" \", \"[\", \"]\", \",\", \"(\", \")\", \":\", \"#\", \"!\", \"=\", \">\", \"<\", \"~\", \"+\", \".\"], true, false),\n            peg$c6 = function peg$c6(i) {\n          return i.join('');\n        },\n            peg$c7 = \">\",\n            peg$c8 = peg$literalExpectation(\">\", false),\n            peg$c9 = function peg$c9() {\n          return 'child';\n        },\n            peg$c10 = \"~\",\n            peg$c11 = peg$literalExpectation(\"~\", false),\n            peg$c12 = function peg$c12() {\n          return 'sibling';\n        },\n            peg$c13 = \"+\",\n            peg$c14 = peg$literalExpectation(\"+\", false),\n            peg$c15 = function peg$c15() {\n          return 'adjacent';\n        },\n            peg$c16 = function peg$c16() {\n          return 'descendant';\n        },\n            peg$c17 = \",\",\n            peg$c18 = peg$literalExpectation(\",\", false),\n            peg$c19 = function peg$c19(s, ss) {\n          return [s].concat(ss.map(function (s) {\n            return s[3];\n          }));\n        },\n            peg$c20 = function peg$c20(a, ops) {\n          return ops.reduce(function (memo, rhs) {\n            return {\n              type: rhs[0],\n              left: memo,\n              right: rhs[1]\n            };\n          }, a);\n        },\n            peg$c21 = \"!\",\n            peg$c22 = peg$literalExpectation(\"!\", false),\n            peg$c23 = function peg$c23(subject, as) {\n          var b = as.length === 1 ? as[0] : {\n            type: 'compound',\n            selectors: as\n          };\n          if (subject) b.subject = true;\n          return b;\n        },\n            peg$c24 = \"*\",\n            peg$c25 = peg$literalExpectation(\"*\", false),\n            peg$c26 = function peg$c26(a) {\n          return {\n            type: 'wildcard',\n            value: a\n          };\n        },\n            peg$c27 = \"#\",\n            peg$c28 = peg$literalExpectation(\"#\", false),\n            peg$c29 = function peg$c29(i) {\n          return {\n            type: 'identifier',\n            value: i\n          };\n        },\n            peg$c30 = \"[\",\n            peg$c31 = peg$literalExpectation(\"[\", false),\n            peg$c32 = \"]\",\n            peg$c33 = peg$literalExpectation(\"]\", false),\n            peg$c34 = function peg$c34(v) {\n          return v;\n        },\n            peg$c35 = /^[><!]/,\n            peg$c36 = peg$classExpectation([\">\", \"<\", \"!\"], false, false),\n            peg$c37 = \"=\",\n            peg$c38 = peg$literalExpectation(\"=\", false),\n            peg$c39 = function peg$c39(a) {\n          return (a || '') + '=';\n        },\n            peg$c40 = /^[><]/,\n            peg$c41 = peg$classExpectation([\">\", \"<\"], false, false),\n            peg$c42 = \".\",\n            peg$c43 = peg$literalExpectation(\".\", false),\n            peg$c44 = function peg$c44(a, as) {\n          return [].concat.apply([a], as).join('');\n        },\n            peg$c45 = function peg$c45(name, op, value) {\n          return {\n            type: 'attribute',\n            name: name,\n            operator: op,\n            value: value\n          };\n        },\n            peg$c46 = function peg$c46(name) {\n          return {\n            type: 'attribute',\n            name: name\n          };\n        },\n            peg$c47 = \"\\\"\",\n            peg$c48 = peg$literalExpectation(\"\\\"\", false),\n            peg$c49 = /^[^\\\\\"]/,\n            peg$c50 = peg$classExpectation([\"\\\\\", \"\\\"\"], true, false),\n            peg$c51 = \"\\\\\",\n            peg$c52 = peg$literalExpectation(\"\\\\\", false),\n            peg$c53 = peg$anyExpectation(),\n            peg$c54 = function peg$c54(a, b) {\n          return a + b;\n        },\n            peg$c55 = function peg$c55(d) {\n          return {\n            type: 'literal',\n            value: strUnescape(d.join(''))\n          };\n        },\n            peg$c56 = \"'\",\n            peg$c57 = peg$literalExpectation(\"'\", false),\n            peg$c58 = /^[^\\\\']/,\n            peg$c59 = peg$classExpectation([\"\\\\\", \"'\"], true, false),\n            peg$c60 = /^[0-9]/,\n            peg$c61 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n            peg$c62 = function peg$c62(a, b) {\n          // Can use `a.flat().join('')` once supported\n          var leadingDecimals = a ? [].concat.apply([], a).join('') : '';\n          return {\n            type: 'literal',\n            value: parseFloat(leadingDecimals + b.join(''))\n          };\n        },\n            peg$c63 = function peg$c63(i) {\n          return {\n            type: 'literal',\n            value: i\n          };\n        },\n            peg$c64 = \"type(\",\n            peg$c65 = peg$literalExpectation(\"type(\", false),\n            peg$c66 = /^[^ )]/,\n            peg$c67 = peg$classExpectation([\" \", \")\"], true, false),\n            peg$c68 = \")\",\n            peg$c69 = peg$literalExpectation(\")\", false),\n            peg$c70 = function peg$c70(t) {\n          return {\n            type: 'type',\n            value: t.join('')\n          };\n        },\n            peg$c71 = /^[imsu]/,\n            peg$c72 = peg$classExpectation([\"i\", \"m\", \"s\", \"u\"], false, false),\n            peg$c73 = \"/\",\n            peg$c74 = peg$literalExpectation(\"/\", false),\n            peg$c75 = /^[^\\/]/,\n            peg$c76 = peg$classExpectation([\"/\"], true, false),\n            peg$c77 = function peg$c77(d, flgs) {\n          return {\n            type: 'regexp',\n            value: new RegExp(d.join(''), flgs ? flgs.join('') : '')\n          };\n        },\n            peg$c78 = function peg$c78(i, is) {\n          return {\n            type: 'field',\n            name: is.reduce(function (memo, p) {\n              return memo + p[0] + p[1];\n            }, i)\n          };\n        },\n            peg$c79 = \":not(\",\n            peg$c80 = peg$literalExpectation(\":not(\", false),\n            peg$c81 = function peg$c81(ss) {\n          return {\n            type: 'not',\n            selectors: ss\n          };\n        },\n            peg$c82 = \":matches(\",\n            peg$c83 = peg$literalExpectation(\":matches(\", false),\n            peg$c84 = function peg$c84(ss) {\n          return {\n            type: 'matches',\n            selectors: ss\n          };\n        },\n            peg$c85 = \":has(\",\n            peg$c86 = peg$literalExpectation(\":has(\", false),\n            peg$c87 = function peg$c87(ss) {\n          return {\n            type: 'has',\n            selectors: ss\n          };\n        },\n            peg$c88 = \":first-child\",\n            peg$c89 = peg$literalExpectation(\":first-child\", false),\n            peg$c90 = function peg$c90() {\n          return nth(1);\n        },\n            peg$c91 = \":last-child\",\n            peg$c92 = peg$literalExpectation(\":last-child\", false),\n            peg$c93 = function peg$c93() {\n          return nthLast(1);\n        },\n            peg$c94 = \":nth-child(\",\n            peg$c95 = peg$literalExpectation(\":nth-child(\", false),\n            peg$c96 = function peg$c96(n) {\n          return nth(parseInt(n.join(''), 10));\n        },\n            peg$c97 = \":nth-last-child(\",\n            peg$c98 = peg$literalExpectation(\":nth-last-child(\", false),\n            peg$c99 = function peg$c99(n) {\n          return nthLast(parseInt(n.join(''), 10));\n        },\n            peg$c100 = \":\",\n            peg$c101 = peg$literalExpectation(\":\", false),\n            peg$c102 = \"statement\",\n            peg$c103 = peg$literalExpectation(\"statement\", true),\n            peg$c104 = \"expression\",\n            peg$c105 = peg$literalExpectation(\"expression\", true),\n            peg$c106 = \"declaration\",\n            peg$c107 = peg$literalExpectation(\"declaration\", true),\n            peg$c108 = \"function\",\n            peg$c109 = peg$literalExpectation(\"function\", true),\n            peg$c110 = \"pattern\",\n            peg$c111 = peg$literalExpectation(\"pattern\", true),\n            peg$c112 = function peg$c112(c) {\n          return {\n            type: 'class',\n            name: c\n          };\n        },\n            peg$currPos = 0,\n            peg$posDetailsCache = [{\n          line: 1,\n          column: 1\n        }],\n            peg$maxFailPos = 0,\n            peg$maxFailExpected = [],\n            peg$resultsCache = {},\n            peg$result;\n\n        if (\"startRule\" in options) {\n          if (!(options.startRule in peg$startRuleFunctions)) {\n            throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n          }\n\n          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n        }\n\n        function peg$literalExpectation(text, ignoreCase) {\n          return {\n            type: \"literal\",\n            text: text,\n            ignoreCase: ignoreCase\n          };\n        }\n\n        function peg$classExpectation(parts, inverted, ignoreCase) {\n          return {\n            type: \"class\",\n            parts: parts,\n            inverted: inverted,\n            ignoreCase: ignoreCase\n          };\n        }\n\n        function peg$anyExpectation() {\n          return {\n            type: \"any\"\n          };\n        }\n\n        function peg$endExpectation() {\n          return {\n            type: \"end\"\n          };\n        }\n\n        function peg$computePosDetails(pos) {\n          var details = peg$posDetailsCache[pos],\n              p;\n\n          if (details) {\n            return details;\n          } else {\n            p = pos - 1;\n\n            while (!peg$posDetailsCache[p]) {\n              p--;\n            }\n\n            details = peg$posDetailsCache[p];\n            details = {\n              line: details.line,\n              column: details.column\n            };\n\n            while (p < pos) {\n              if (input.charCodeAt(p) === 10) {\n                details.line++;\n                details.column = 1;\n              } else {\n                details.column++;\n              }\n\n              p++;\n            }\n\n            peg$posDetailsCache[pos] = details;\n            return details;\n          }\n        }\n\n        function peg$computeLocation(startPos, endPos) {\n          var startPosDetails = peg$computePosDetails(startPos),\n              endPosDetails = peg$computePosDetails(endPos);\n          return {\n            start: {\n              offset: startPos,\n              line: startPosDetails.line,\n              column: startPosDetails.column\n            },\n            end: {\n              offset: endPos,\n              line: endPosDetails.line,\n              column: endPosDetails.column\n            }\n          };\n        }\n\n        function peg$fail(expected) {\n          if (peg$currPos < peg$maxFailPos) {\n            return;\n          }\n\n          if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n          }\n\n          peg$maxFailExpected.push(expected);\n        }\n\n        function peg$buildStructuredError(expected, found, location) {\n          return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n        }\n\n        function peg$parsestart() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 0,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseselectors();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c0(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n\n            if (s1 !== peg$FAILED) {\n              s1 = peg$c1();\n            }\n\n            s0 = s1;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parse_() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 1,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = [];\n\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s1 = peg$c2;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c3);\n            }\n          }\n\n          while (s1 !== peg$FAILED) {\n            s0.push(s1);\n\n            if (input.charCodeAt(peg$currPos) === 32) {\n              s1 = peg$c2;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n\n              {\n                peg$fail(peg$c3);\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseidentifierName() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 2,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = [];\n\n          if (peg$c4.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n\n            {\n              peg$fail(peg$c5);\n            }\n          }\n\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n\n              if (peg$c4.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c5);\n                }\n              }\n            }\n          } else {\n            s1 = peg$FAILED;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c6(s1);\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsebinaryOp() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 3,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parse_();\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 62) {\n              s2 = peg$c7;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n\n              {\n                peg$fail(peg$c8);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parse_();\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c9();\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parse_();\n\n            if (s1 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 126) {\n                s2 = peg$c10;\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c11);\n                }\n              }\n\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parse_();\n\n                if (s3 !== peg$FAILED) {\n                  s1 = peg$c12();\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parse_();\n\n              if (s1 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 43) {\n                  s2 = peg$c13;\n                  peg$currPos++;\n                } else {\n                  s2 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c14);\n                  }\n                }\n\n                if (s2 !== peg$FAILED) {\n                  s3 = peg$parse_();\n\n                  if (s3 !== peg$FAILED) {\n                    s1 = peg$c15();\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 32) {\n                  s1 = peg$c2;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c3);\n                  }\n                }\n\n                if (s1 !== peg$FAILED) {\n                  s2 = peg$parse_();\n\n                  if (s2 !== peg$FAILED) {\n                    s1 = peg$c16();\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseselectors() {\n          var s0, s1, s2, s3, s4, s5, s6, s7;\n          var key = peg$currPos * 30 + 4,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseselector();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$parse_();\n\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s5 = peg$c17;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c18);\n                }\n              }\n\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n\n                if (s6 !== peg$FAILED) {\n                  s7 = peg$parseselector();\n\n                  if (s7 !== peg$FAILED) {\n                    s4 = [s4, s5, s6, s7];\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$parse_();\n\n              if (s4 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 44) {\n                  s5 = peg$c17;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c18);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parse_();\n\n                  if (s6 !== peg$FAILED) {\n                    s7 = peg$parseselector();\n\n                    if (s7 !== peg$FAILED) {\n                      s4 = [s4, s5, s6, s7];\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c19(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseselector() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 5,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parsesequence();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n            s4 = peg$parsebinaryOp();\n\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parsesequence();\n\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n              s4 = peg$parsebinaryOp();\n\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parsesequence();\n\n                if (s5 !== peg$FAILED) {\n                  s4 = [s4, s5];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c20(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsesequence() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 6,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 33) {\n            s1 = peg$c21;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c22);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parseatom();\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parseatom();\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c23(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseatom() {\n          var s0;\n          var key = peg$currPos * 30 + 7,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$parsewildcard();\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseidentifier();\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseattr();\n\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsefield();\n\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsenegation();\n\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parsematches();\n\n                    if (s0 === peg$FAILED) {\n                      s0 = peg$parsehas();\n\n                      if (s0 === peg$FAILED) {\n                        s0 = peg$parsefirstChild();\n\n                        if (s0 === peg$FAILED) {\n                          s0 = peg$parselastChild();\n\n                          if (s0 === peg$FAILED) {\n                            s0 = peg$parsenthChild();\n\n                            if (s0 === peg$FAILED) {\n                              s0 = peg$parsenthLastChild();\n\n                              if (s0 === peg$FAILED) {\n                                s0 = peg$parseclass();\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsewildcard() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 8,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s1 = peg$c24;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c25);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c26(s1);\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseidentifier() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 9,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 35) {\n            s1 = peg$c27;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c28);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseidentifierName();\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c29(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattr() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 10,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 91) {\n            s1 = peg$c30;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c31);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseattrValue();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 93) {\n                    s5 = peg$c32;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c33);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c34(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrOps() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 11,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (peg$c35.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c36);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s2 = peg$c37;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n\n              {\n                peg$fail(peg$c38);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c39(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            if (peg$c40.test(input.charAt(peg$currPos))) {\n              s0 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n\n              {\n                peg$fail(peg$c41);\n              }\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrEqOps() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 12,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 33) {\n            s1 = peg$c21;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c22);\n            }\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 61) {\n              s2 = peg$c37;\n              peg$currPos++;\n            } else {\n              s2 = peg$FAILED;\n\n              {\n                peg$fail(peg$c38);\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c39(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrName() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 13,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseidentifierName();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$currPos;\n\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s4 = peg$c42;\n              peg$currPos++;\n            } else {\n              s4 = peg$FAILED;\n\n              {\n                peg$fail(peg$c43);\n              }\n            }\n\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseidentifierName();\n\n              if (s5 !== peg$FAILED) {\n                s4 = [s4, s5];\n                s3 = s4;\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$currPos;\n\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s4 = peg$c42;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c43);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                s5 = peg$parseidentifierName();\n\n                if (s5 !== peg$FAILED) {\n                  s4 = [s4, s5];\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c44(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseattrValue() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 14,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseattrName();\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseattrEqOps();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsetype();\n\n                  if (s5 === peg$FAILED) {\n                    s5 = peg$parseregex();\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c45(s1, s3, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseattrName();\n\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parse_();\n\n              if (s2 !== peg$FAILED) {\n                s3 = peg$parseattrOps();\n\n                if (s3 !== peg$FAILED) {\n                  s4 = peg$parse_();\n\n                  if (s4 !== peg$FAILED) {\n                    s5 = peg$parsestring();\n\n                    if (s5 === peg$FAILED) {\n                      s5 = peg$parsenumber();\n\n                      if (s5 === peg$FAILED) {\n                        s5 = peg$parsepath();\n                      }\n                    }\n\n                    if (s5 !== peg$FAILED) {\n                      s1 = peg$c45(s1, s3, s5);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              s1 = peg$parseattrName();\n\n              if (s1 !== peg$FAILED) {\n                s1 = peg$c46(s1);\n              }\n\n              s0 = s1;\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsestring() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 15,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s1 = peg$c47;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c48);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n\n            if (peg$c49.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n\n              {\n                peg$fail(peg$c50);\n              }\n            }\n\n            if (s3 === peg$FAILED) {\n              s3 = peg$currPos;\n\n              if (input.charCodeAt(peg$currPos) === 92) {\n                s4 = peg$c51;\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c52);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s5 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c53);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s4 = peg$c54(s4, s5);\n                  s3 = s4;\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s3;\n                s3 = peg$FAILED;\n              }\n            }\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n\n              if (peg$c49.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c50);\n                }\n              }\n\n              if (s3 === peg$FAILED) {\n                s3 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 92) {\n                  s4 = peg$c51;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c52);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s5 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c53);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s4 = peg$c54(s4, s5);\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 34) {\n                s3 = peg$c47;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c48);\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c55(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n\n            if (input.charCodeAt(peg$currPos) === 39) {\n              s1 = peg$c56;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n\n              {\n                peg$fail(peg$c57);\n              }\n            }\n\n            if (s1 !== peg$FAILED) {\n              s2 = [];\n\n              if (peg$c58.test(input.charAt(peg$currPos))) {\n                s3 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c59);\n                }\n              }\n\n              if (s3 === peg$FAILED) {\n                s3 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 92) {\n                  s4 = peg$c51;\n                  peg$currPos++;\n                } else {\n                  s4 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c52);\n                  }\n                }\n\n                if (s4 !== peg$FAILED) {\n                  if (input.length > peg$currPos) {\n                    s5 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c53);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s4 = peg$c54(s4, s5);\n                    s3 = s4;\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s3;\n                  s3 = peg$FAILED;\n                }\n              }\n\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n\n                if (peg$c58.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c59);\n                  }\n                }\n\n                if (s3 === peg$FAILED) {\n                  s3 = peg$currPos;\n\n                  if (input.charCodeAt(peg$currPos) === 92) {\n                    s4 = peg$c51;\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c52);\n                    }\n                  }\n\n                  if (s4 !== peg$FAILED) {\n                    if (input.length > peg$currPos) {\n                      s5 = input.charAt(peg$currPos);\n                      peg$currPos++;\n                    } else {\n                      s5 = peg$FAILED;\n\n                      {\n                        peg$fail(peg$c53);\n                      }\n                    }\n\n                    if (s5 !== peg$FAILED) {\n                      s4 = peg$c54(s4, s5);\n                      s3 = s4;\n                    } else {\n                      peg$currPos = s3;\n                      s3 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s3;\n                    s3 = peg$FAILED;\n                  }\n                }\n              }\n\n              if (s2 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 39) {\n                  s3 = peg$c56;\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c57);\n                  }\n                }\n\n                if (s3 !== peg$FAILED) {\n                  s1 = peg$c55(s2);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenumber() {\n          var s0, s1, s2, s3;\n          var key = peg$currPos * 30 + 16,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$currPos;\n          s2 = [];\n\n          if (peg$c60.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n\n            {\n              peg$fail(peg$c61);\n            }\n          }\n\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n\n            if (peg$c60.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n\n              {\n                peg$fail(peg$c61);\n              }\n            }\n          }\n\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 46) {\n              s3 = peg$c42;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n\n              {\n                peg$fail(peg$c43);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              s2 = [s2, s3];\n              s1 = s2;\n            } else {\n              peg$currPos = s1;\n              s1 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n\n            if (peg$c60.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n\n              {\n                peg$fail(peg$c61);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n\n                if (peg$c60.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c61);\n                  }\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c62(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsepath() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 17,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n          s1 = peg$parseidentifierName();\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c63(s1);\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsetype() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 18,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 5) === peg$c64) {\n            s1 = peg$c64;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c65);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n\n              if (peg$c66.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c67);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n\n                  if (peg$c66.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c67);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c70(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseflags() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 19,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = [];\n\n          if (peg$c71.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c72);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            while (s1 !== peg$FAILED) {\n              s0.push(s1);\n\n              if (peg$c71.test(input.charAt(peg$currPos))) {\n                s1 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c72);\n                }\n              }\n            }\n          } else {\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseregex() {\n          var s0, s1, s2, s3, s4;\n          var key = peg$currPos * 30 + 20,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s1 = peg$c73;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c74);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n\n            if (peg$c75.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n\n              {\n                peg$fail(peg$c76);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n\n                if (peg$c75.test(input.charAt(peg$currPos))) {\n                  s3 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s3 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c76);\n                  }\n                }\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 47) {\n                s3 = peg$c73;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c74);\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parseflags();\n\n                if (s4 === peg$FAILED) {\n                  s4 = null;\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s1 = peg$c77(s2, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsefield() {\n          var s0, s1, s2, s3, s4, s5, s6;\n          var key = peg$currPos * 30 + 21,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 46) {\n            s1 = peg$c42;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c43);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseidentifierName();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$currPos;\n\n              if (input.charCodeAt(peg$currPos) === 46) {\n                s5 = peg$c42;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c43);\n                }\n              }\n\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseidentifierName();\n\n                if (s6 !== peg$FAILED) {\n                  s5 = [s5, s6];\n                  s4 = s5;\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$currPos;\n\n                if (input.charCodeAt(peg$currPos) === 46) {\n                  s5 = peg$c42;\n                  peg$currPos++;\n                } else {\n                  s5 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c43);\n                  }\n                }\n\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parseidentifierName();\n\n                  if (s6 !== peg$FAILED) {\n                    s5 = [s5, s6];\n                    s4 = s5;\n                  } else {\n                    peg$currPos = s4;\n                    s4 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s4;\n                  s4 = peg$FAILED;\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                s1 = peg$c78(s2, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenegation() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 22,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 5) === peg$c79) {\n            s1 = peg$c79;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c80);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c81(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsematches() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 23,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 9) === peg$c82) {\n            s1 = peg$c82;\n            peg$currPos += 9;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c83);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c84(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsehas() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 24,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 5) === peg$c85) {\n            s1 = peg$c85;\n            peg$currPos += 5;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c86);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseselectors();\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c87(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsefirstChild() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 25,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 12) === peg$c88) {\n            s1 = peg$c88;\n            peg$currPos += 12;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c89);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c90();\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parselastChild() {\n          var s0, s1;\n          var key = peg$currPos * 30 + 26,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 11) === peg$c91) {\n            s1 = peg$c91;\n            peg$currPos += 11;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c92);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s1 = peg$c93();\n          }\n\n          s0 = s1;\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenthChild() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 27,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 11) === peg$c94) {\n            s1 = peg$c94;\n            peg$currPos += 11;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c95);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c61);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n\n                  if (peg$c60.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c61);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c96(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parsenthLastChild() {\n          var s0, s1, s2, s3, s4, s5;\n          var key = peg$currPos * 30 + 28,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 16) === peg$c97) {\n            s1 = peg$c97;\n            peg$currPos += 16;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c98);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parse_();\n\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n\n              if (peg$c60.test(input.charAt(peg$currPos))) {\n                s4 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s4 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c61);\n                }\n              }\n\n              if (s4 !== peg$FAILED) {\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n\n                  if (peg$c60.test(input.charAt(peg$currPos))) {\n                    s4 = input.charAt(peg$currPos);\n                    peg$currPos++;\n                  } else {\n                    s4 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c61);\n                    }\n                  }\n                }\n              } else {\n                s3 = peg$FAILED;\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = peg$parse_();\n\n                if (s4 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c68;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c69);\n                    }\n                  }\n\n                  if (s5 !== peg$FAILED) {\n                    s1 = peg$c99(s3);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function peg$parseclass() {\n          var s0, s1, s2;\n          var key = peg$currPos * 30 + 29,\n              cached = peg$resultsCache[key];\n\n          if (cached) {\n            peg$currPos = cached.nextPos;\n            return cached.result;\n          }\n\n          s0 = peg$currPos;\n\n          if (input.charCodeAt(peg$currPos) === 58) {\n            s1 = peg$c100;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n\n            {\n              peg$fail(peg$c101);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 9).toLowerCase() === peg$c102) {\n              s2 = input.substr(peg$currPos, 9);\n              peg$currPos += 9;\n            } else {\n              s2 = peg$FAILED;\n\n              {\n                peg$fail(peg$c103);\n              }\n            }\n\n            if (s2 === peg$FAILED) {\n              if (input.substr(peg$currPos, 10).toLowerCase() === peg$c104) {\n                s2 = input.substr(peg$currPos, 10);\n                peg$currPos += 10;\n              } else {\n                s2 = peg$FAILED;\n\n                {\n                  peg$fail(peg$c105);\n                }\n              }\n\n              if (s2 === peg$FAILED) {\n                if (input.substr(peg$currPos, 11).toLowerCase() === peg$c106) {\n                  s2 = input.substr(peg$currPos, 11);\n                  peg$currPos += 11;\n                } else {\n                  s2 = peg$FAILED;\n\n                  {\n                    peg$fail(peg$c107);\n                  }\n                }\n\n                if (s2 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 8).toLowerCase() === peg$c108) {\n                    s2 = input.substr(peg$currPos, 8);\n                    peg$currPos += 8;\n                  } else {\n                    s2 = peg$FAILED;\n\n                    {\n                      peg$fail(peg$c109);\n                    }\n                  }\n\n                  if (s2 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 7).toLowerCase() === peg$c110) {\n                      s2 = input.substr(peg$currPos, 7);\n                      peg$currPos += 7;\n                    } else {\n                      s2 = peg$FAILED;\n\n                      {\n                        peg$fail(peg$c111);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n\n            if (s2 !== peg$FAILED) {\n              s1 = peg$c112(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          peg$resultsCache[key] = {\n            nextPos: peg$currPos,\n            result: s0\n          };\n          return s0;\n        }\n\n        function nth(n) {\n          return {\n            type: 'nth-child',\n            index: {\n              type: 'literal',\n              value: n\n            }\n          };\n        }\n\n        function nthLast(n) {\n          return {\n            type: 'nth-last-child',\n            index: {\n              type: 'literal',\n              value: n\n            }\n          };\n        }\n\n        function strUnescape(s) {\n          return s.replace(/\\\\(.)/g, function (match, ch) {\n            switch (ch) {\n              case 'b':\n                return '\\b';\n\n              case 'f':\n                return '\\f';\n\n              case 'n':\n                return '\\n';\n\n              case 'r':\n                return '\\r';\n\n              case 't':\n                return '\\t';\n\n              case 'v':\n                return '\\v';\n\n              default:\n                return ch;\n            }\n          });\n        }\n\n        peg$result = peg$startRuleFunction();\n\n        if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n          return peg$result;\n        } else {\n          if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n            peg$fail(peg$endExpectation());\n          }\n\n          throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n        }\n      }\n\n      return {\n        SyntaxError: peg$SyntaxError,\n        parse: peg$parse\n      };\n    });\n  });\n\n  function _objectEntries(obj) {\n    var entries = [];\n    var keys = Object.keys(obj);\n\n    for (var k = 0; k < keys.length; k++) entries.push([keys[k], obj[keys[k]]]);\n\n    return entries;\n  }\n  /**\n  * @typedef {\"LEFT_SIDE\"|\"RIGHT_SIDE\"} Side\n  */\n\n  var LEFT_SIDE = 'LEFT_SIDE';\n  var RIGHT_SIDE = 'RIGHT_SIDE';\n  /**\n   * @external AST\n   * @see https://esprima.readthedocs.io/en/latest/syntax-tree-format.html\n   */\n\n  /**\n   * One of the rules of `grammar.pegjs`\n   * @typedef {PlainObject} SelectorAST\n   * @see grammar.pegjs\n  */\n\n  /**\n   * The `sequence` production of `grammar.pegjs`\n   * @typedef {PlainObject} SelectorSequenceAST\n  */\n\n  /**\n   * Get the value of a property which may be multiple levels down\n   * in the object.\n   * @param {?PlainObject} obj\n   * @param {string} key\n   * @returns {undefined|boolean|string|number|external:AST}\n   */\n\n  function getPath(obj, key) {\n    var keys = key.split('.');\n\n    var _iterator = _createForOfIteratorHelper(keys),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _key = _step.value;\n\n        if (obj == null) {\n          return obj;\n        }\n\n        obj = obj[_key];\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return obj;\n  }\n  /**\n   * Determine whether `node` can be reached by following `path`,\n   * starting at `ancestor`.\n   * @param {?external:AST} node\n   * @param {?external:AST} ancestor\n   * @param {string[]} path\n   * @returns {boolean}\n   */\n\n\n  function inPath(node, ancestor, path) {\n    if (path.length === 0) {\n      return node === ancestor;\n    }\n\n    if (ancestor == null) {\n      return false;\n    }\n\n    var field = ancestor[path[0]];\n    var remainingPath = path.slice(1);\n\n    if (Array.isArray(field)) {\n      var _iterator2 = _createForOfIteratorHelper(field),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var component = _step2.value;\n\n          if (inPath(node, component, remainingPath)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return false;\n    } else {\n      return inPath(node, field, remainingPath);\n    }\n  }\n  /**\n   * @callback TraverseOptionFallback\n   * @param {external:AST} node The given node.\n   * @returns {string[]} An array of visitor keys for the given node.\n   */\n\n  /**\n   * @typedef {object} ESQueryOptions\n   * @property { { [nodeType: string]: string[] } } [visitorKeys] By passing `visitorKeys` mapping, we can extend the properties of the nodes that traverse the node.\n   * @property {TraverseOptionFallback} [fallback] By passing `fallback` option, we can control the properties of traversing nodes when encountering unknown nodes.\n   */\n\n  /**\n   * Given a `node` and its ancestors, determine if `node` is matched\n   * by `selector`.\n   * @param {?external:AST} node\n   * @param {?SelectorAST} selector\n   * @param {external:AST[]} [ancestry=[]]\n   * @param {ESQueryOptions} [options]\n   * @throws {Error} Unknowns (operator, class name, selector type, or\n   * selector value type)\n   * @returns {boolean}\n   */\n\n\n  function matches(node, selector, ancestry, options) {\n    if (!selector) {\n      return true;\n    }\n\n    if (!node) {\n      return false;\n    }\n\n    if (!ancestry) {\n      ancestry = [];\n    }\n\n    switch (selector.type) {\n      case 'wildcard':\n        return true;\n\n      case 'identifier':\n        return selector.value.toLowerCase() === node.type.toLowerCase();\n\n      case 'field':\n        {\n          var path = selector.name.split('.');\n          var ancestor = ancestry[path.length - 1];\n          return inPath(node, ancestor, path);\n        }\n\n      case 'matches':\n        var _iterator3 = _createForOfIteratorHelper(selector.selectors),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var sel = _step3.value;\n\n            if (matches(node, sel, ancestry, options)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        return false;\n\n      case 'compound':\n        var _iterator4 = _createForOfIteratorHelper(selector.selectors),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _sel = _step4.value;\n\n            if (!matches(node, _sel, ancestry, options)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        return true;\n\n      case 'not':\n        var _iterator5 = _createForOfIteratorHelper(selector.selectors),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _sel2 = _step5.value;\n\n            if (matches(node, _sel2, ancestry, options)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n\n        return true;\n\n      case 'has':\n        {\n          var _ret = function () {\n            var collector = [];\n\n            var _iterator6 = _createForOfIteratorHelper(selector.selectors),\n                _step6;\n\n            try {\n              var _loop = function _loop() {\n                var sel = _step6.value;\n                var a = [];\n                estraverse.traverse(node, {\n                  enter: function enter(node, parent) {\n                    if (parent != null) {\n                      a.unshift(parent);\n                    }\n\n                    if (matches(node, sel, a, options)) {\n                      collector.push(node);\n                    }\n                  },\n                  leave: function leave() {\n                    a.shift();\n                  },\n                  keys: options && options.visitorKeys,\n                  fallback: options && options.fallback || 'iteration'\n                });\n              };\n\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                _loop();\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n\n            return {\n              v: collector.length !== 0\n            };\n          }();\n\n          if (_typeof(_ret) === \"object\") return _ret.v;\n        }\n\n      case 'child':\n        if (matches(node, selector.right, ancestry, options)) {\n          return matches(ancestry[0], selector.left, ancestry.slice(1), options);\n        }\n\n        return false;\n\n      case 'descendant':\n        if (matches(node, selector.right, ancestry, options)) {\n          for (var i = 0, l = ancestry.length; i < l; ++i) {\n            if (matches(ancestry[i], selector.left, ancestry.slice(i + 1), options)) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n\n      case 'attribute':\n        {\n          var p = getPath(node, selector.name);\n\n          switch (selector.operator) {\n            case void 0:\n              return p != null;\n\n            case '=':\n              switch (selector.value.type) {\n                case 'regexp':\n                  return typeof p === 'string' && selector.value.value.test(p);\n\n                case 'literal':\n                  return \"\".concat(selector.value.value) === \"\".concat(p);\n\n                case 'type':\n                  return selector.value.value === _typeof(p);\n              }\n\n              throw new Error(\"Unknown selector value type: \".concat(selector.value.type));\n\n            case '!=':\n              switch (selector.value.type) {\n                case 'regexp':\n                  return !selector.value.value.test(p);\n\n                case 'literal':\n                  return \"\".concat(selector.value.value) !== \"\".concat(p);\n\n                case 'type':\n                  return selector.value.value !== _typeof(p);\n              }\n\n              throw new Error(\"Unknown selector value type: \".concat(selector.value.type));\n\n            case '<=':\n              return p <= selector.value.value;\n\n            case '<':\n              return p < selector.value.value;\n\n            case '>':\n              return p > selector.value.value;\n\n            case '>=':\n              return p >= selector.value.value;\n          }\n\n          throw new Error(\"Unknown operator: \".concat(selector.operator));\n        }\n\n      case 'sibling':\n        return matches(node, selector.right, ancestry, options) && sibling(node, selector.left, ancestry, LEFT_SIDE, options) || selector.left.subject && matches(node, selector.left, ancestry, options) && sibling(node, selector.right, ancestry, RIGHT_SIDE, options);\n\n      case 'adjacent':\n        return matches(node, selector.right, ancestry, options) && adjacent(node, selector.left, ancestry, LEFT_SIDE, options) || selector.right.subject && matches(node, selector.left, ancestry, options) && adjacent(node, selector.right, ancestry, RIGHT_SIDE, options);\n\n      case 'nth-child':\n        return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function () {\n          return selector.index.value - 1;\n        }, options);\n\n      case 'nth-last-child':\n        return matches(node, selector.right, ancestry, options) && nthChild(node, ancestry, function (length) {\n          return length - selector.index.value;\n        }, options);\n\n      case 'class':\n        switch (selector.name.toLowerCase()) {\n          case 'statement':\n            if (node.type.slice(-9) === 'Statement') return true;\n          // fallthrough: interface Declaration <: Statement { }\n\n          case 'declaration':\n            return node.type.slice(-11) === 'Declaration';\n\n          case 'pattern':\n            if (node.type.slice(-7) === 'Pattern') return true;\n          // fallthrough: interface Expression <: Node, Pattern { }\n\n          case 'expression':\n            return node.type.slice(-10) === 'Expression' || node.type.slice(-7) === 'Literal' || node.type === 'Identifier' && (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty') || node.type === 'MetaProperty';\n\n          case 'function':\n            return node.type === 'FunctionDeclaration' || node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression';\n        }\n\n        throw new Error(\"Unknown class name: \".concat(selector.name));\n    }\n\n    throw new Error(\"Unknown selector type: \".concat(selector.type));\n  }\n  /**\n   * Get visitor keys of a given node.\n   * @param {external:AST} node The AST node to get keys.\n   * @param {ESQueryOptions|undefined} options\n   * @returns {string[]} Visitor keys of the node.\n   */\n\n\n  function getVisitorKeys(node, options) {\n    var nodeType = node.type;\n\n    if (options && options.visitorKeys && options.visitorKeys[nodeType]) {\n      return options.visitorKeys[nodeType];\n    }\n\n    if (estraverse.VisitorKeys[nodeType]) {\n      return estraverse.VisitorKeys[nodeType];\n    }\n\n    if (options && typeof options.fallback === 'function') {\n      return options.fallback(node);\n    } // 'iteration' fallback\n\n\n    return Object.keys(node).filter(function (key) {\n      return key !== 'type';\n    });\n  }\n  /**\n   * Check whether the given value is an ASTNode or not.\n   * @param {any} node The value to check.\n   * @returns {boolean} `true` if the value is an ASTNode.\n   */\n\n\n  function isNode(node) {\n    return node !== null && _typeof(node) === 'object' && typeof node.type === 'string';\n  }\n  /**\n   * Determines if the given node has a sibling that matches the\n   * given selector.\n   * @param {external:AST} node\n   * @param {SelectorSequenceAST} selector\n   * @param {external:AST[]} ancestry\n   * @param {Side} side\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n\n\n  function sibling(node, selector, ancestry, side, options) {\n    var _ancestry = _slicedToArray(ancestry, 1),\n        parent = _ancestry[0];\n\n    if (!parent) {\n      return false;\n    }\n\n    var keys = getVisitorKeys(parent, options);\n\n    var _iterator7 = _createForOfIteratorHelper(keys),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var key = _step7.value;\n        var listProp = parent[key];\n\n        if (Array.isArray(listProp)) {\n          var startIndex = listProp.indexOf(node);\n\n          if (startIndex < 0) {\n            continue;\n          }\n\n          var lowerBound = void 0,\n              upperBound = void 0;\n\n          if (side === LEFT_SIDE) {\n            lowerBound = 0;\n            upperBound = startIndex;\n          } else {\n            lowerBound = startIndex + 1;\n            upperBound = listProp.length;\n          }\n\n          for (var k = lowerBound; k < upperBound; ++k) {\n            if (isNode(listProp[k]) && matches(listProp[k], selector, ancestry, options)) {\n              return true;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    return false;\n  }\n  /**\n   * Determines if the given node has an adjacent sibling that matches\n   * the given selector.\n   * @param {external:AST} node\n   * @param {SelectorSequenceAST} selector\n   * @param {external:AST[]} ancestry\n   * @param {Side} side\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n\n\n  function adjacent(node, selector, ancestry, side, options) {\n    var _ancestry2 = _slicedToArray(ancestry, 1),\n        parent = _ancestry2[0];\n\n    if (!parent) {\n      return false;\n    }\n\n    var keys = getVisitorKeys(parent, options);\n\n    var _iterator8 = _createForOfIteratorHelper(keys),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var key = _step8.value;\n        var listProp = parent[key];\n\n        if (Array.isArray(listProp)) {\n          var idx = listProp.indexOf(node);\n\n          if (idx < 0) {\n            continue;\n          }\n\n          if (side === LEFT_SIDE && idx > 0 && isNode(listProp[idx - 1]) && matches(listProp[idx - 1], selector, ancestry, options)) {\n            return true;\n          }\n\n          if (side === RIGHT_SIDE && idx < listProp.length - 1 && isNode(listProp[idx + 1]) && matches(listProp[idx + 1], selector, ancestry, options)) {\n            return true;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n\n    return false;\n  }\n  /**\n  * @callback IndexFunction\n  * @param {Integer} len Containing list's length\n  * @returns {Integer}\n  */\n\n  /**\n   * Determines if the given node is the nth child, determined by\n   * `idxFn`, which is given the containing list's length.\n   * @param {external:AST} node\n   * @param {external:AST[]} ancestry\n   * @param {IndexFunction} idxFn\n   * @param {ESQueryOptions|undefined} options\n   * @returns {boolean}\n   */\n\n\n  function nthChild(node, ancestry, idxFn, options) {\n    var _ancestry3 = _slicedToArray(ancestry, 1),\n        parent = _ancestry3[0];\n\n    if (!parent) {\n      return false;\n    }\n\n    var keys = getVisitorKeys(parent, options);\n\n    var _iterator9 = _createForOfIteratorHelper(keys),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var key = _step9.value;\n        var listProp = parent[key];\n\n        if (Array.isArray(listProp)) {\n          var idx = listProp.indexOf(node);\n\n          if (idx >= 0 && idx === idxFn(listProp.length)) {\n            return true;\n          }\n        }\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    return false;\n  }\n  /**\n   * For each selector node marked as a subject, find the portion of the\n   * selector that the subject must match.\n   * @param {SelectorAST} selector\n   * @param {SelectorAST} [ancestor] Defaults to `selector`\n   * @returns {SelectorAST[]}\n   */\n\n\n  function subjects(selector, ancestor) {\n    if (selector == null || _typeof(selector) != 'object') {\n      return [];\n    }\n\n    if (ancestor == null) {\n      ancestor = selector;\n    }\n\n    var results = selector.subject ? [ancestor] : [];\n\n    for (var _i = 0, _Object$entries = _objectEntries(selector); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          p = _Object$entries$_i[0],\n          sel = _Object$entries$_i[1];\n\n      results.push.apply(results, _toConsumableArray(subjects(sel, p === 'left' ? sel : ancestor)));\n    }\n\n    return results;\n  }\n  /**\n  * @callback TraverseVisitor\n  * @param {?external:AST} node\n  * @param {?external:AST} parent\n  * @param {external:AST[]} ancestry\n  */\n\n  /**\n   * From a JS AST and a selector AST, collect all JS AST nodes that\n   * match the selector.\n   * @param {external:AST} ast\n   * @param {?SelectorAST} selector\n   * @param {TraverseVisitor} visitor\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n\n\n  function traverse(ast, selector, visitor, options) {\n    if (!selector) {\n      return;\n    }\n\n    var ancestry = [];\n    var altSubjects = subjects(selector);\n    estraverse.traverse(ast, {\n      enter: function enter(node, parent) {\n        if (parent != null) {\n          ancestry.unshift(parent);\n        }\n\n        if (matches(node, selector, ancestry, options)) {\n          if (altSubjects.length) {\n            for (var i = 0, l = altSubjects.length; i < l; ++i) {\n              if (matches(node, altSubjects[i], ancestry, options)) {\n                visitor(node, parent, ancestry);\n              }\n\n              for (var k = 0, m = ancestry.length; k < m; ++k) {\n                var succeedingAncestry = ancestry.slice(k + 1);\n\n                if (matches(ancestry[k], altSubjects[i], succeedingAncestry, options)) {\n                  visitor(ancestry[k], parent, succeedingAncestry);\n                }\n              }\n            }\n          } else {\n            visitor(node, parent, ancestry);\n          }\n        }\n      },\n      leave: function leave() {\n        ancestry.shift();\n      },\n      keys: options && options.visitorKeys,\n      fallback: options && options.fallback || 'iteration'\n    });\n  }\n  /**\n   * From a JS AST and a selector AST, collect all JS AST nodes that\n   * match the selector.\n   * @param {external:AST} ast\n   * @param {?SelectorAST} selector\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n\n\n  function match(ast, selector, options) {\n    var results = [];\n    traverse(ast, selector, function (node) {\n      results.push(node);\n    }, options);\n    return results;\n  }\n  /**\n   * Parse a selector string and return its AST.\n   * @param {string} selector\n   * @returns {SelectorAST}\n   */\n\n\n  function parse(selector) {\n    return parser.parse(selector);\n  }\n  /**\n   * Query the code AST using the selector string.\n   * @param {external:AST} ast\n   * @param {string} selector\n   * @param {ESQueryOptions} [options]\n   * @returns {external:AST[]}\n   */\n\n\n  function query(ast, selector, options) {\n    return match(ast, parse(selector), options);\n  }\n\n  query.parse = parse;\n  query.match = match;\n  query.traverse = traverse;\n  query.matches = matches;\n  query.query = query;\n\n  return query;\n\n})));\n"],"mappings":"AAAC,WAAUA,MAAV,EAAkBC,OAAlB,EAA2B;EAC1B,OAAOC,OAAP,KAAmB,QAAnB,IAA+B,OAAOC,MAAP,KAAkB,WAAjD,GAA+DA,MAAM,CAACD,OAAP,GAAiBD,OAAO,EAAvF,GACA,OAAOG,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACC,GAAvC,GAA6CD,MAAM,CAACH,OAAD,CAAnD,IACCD,MAAM,GAAGA,MAAM,IAAIM,IAAnB,EAAyBN,MAAM,CAACO,OAAP,GAAiBN,OAAO,EADlD,CADA;AAGD,CAJA,EAIC,IAJD,EAIQ,YAAY;EAAE;;EAErB,SAASO,OAAT,CAAiBC,GAAjB,EAAsB;IACpB;;IAEA,IAAI,OAAOC,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,QAAd,KAA2B,QAA/D,EAAyE;MACvEH,OAAO,GAAG,UAAUC,GAAV,EAAe;QACvB,OAAO,OAAOA,GAAd;MACD,CAFD;IAGD,CAJD,MAIO;MACLD,OAAO,GAAG,UAAUC,GAAV,EAAe;QACvB,OAAOA,GAAG,IAAI,OAAOC,MAAP,KAAkB,UAAzB,IAAuCD,GAAG,CAACG,WAAJ,KAAoBF,MAA3D,IAAqED,GAAG,KAAKC,MAAM,CAACG,SAApF,GAAgG,QAAhG,GAA2G,OAAOJ,GAAzH;MACD,CAFD;IAGD;;IAED,OAAOD,OAAO,CAACC,GAAD,CAAd;EACD;;EAED,SAASK,cAAT,CAAwBC,GAAxB,EAA6BC,CAA7B,EAAgC;IAC9B,OAAOC,eAAe,CAACF,GAAD,CAAf,IAAwBG,qBAAqB,CAACH,GAAD,EAAMC,CAAN,CAA7C,IAAyDG,2BAA2B,CAACJ,GAAD,EAAMC,CAAN,CAApF,IAAgGI,gBAAgB,EAAvH;EACD;;EAED,SAASC,kBAAT,CAA4BN,GAA5B,EAAiC;IAC/B,OAAOO,kBAAkB,CAACP,GAAD,CAAlB,IAA2BQ,gBAAgB,CAACR,GAAD,CAA3C,IAAoDI,2BAA2B,CAACJ,GAAD,CAA/E,IAAwFS,kBAAkB,EAAjH;EACD;;EAED,SAASF,kBAAT,CAA4BP,GAA5B,EAAiC;IAC/B,IAAIU,KAAK,CAACC,OAAN,CAAcX,GAAd,CAAJ,EAAwB,OAAOY,iBAAiB,CAACZ,GAAD,CAAxB;EACzB;;EAED,SAASE,eAAT,CAAyBF,GAAzB,EAA8B;IAC5B,IAAIU,KAAK,CAACC,OAAN,CAAcX,GAAd,CAAJ,EAAwB,OAAOA,GAAP;EACzB;;EAED,SAASQ,gBAAT,CAA0BK,IAA1B,EAAgC;IAC9B,IAAI,OAAOlB,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,QAAP,IAAmBkB,MAAM,CAACD,IAAD,CAA9D,EAAsE,OAAOH,KAAK,CAACK,IAAN,CAAWF,IAAX,CAAP;EACvE;;EAED,SAASV,qBAAT,CAA+BH,GAA/B,EAAoCC,CAApC,EAAuC;IACrC,IAAI,OAAON,MAAP,KAAkB,WAAlB,IAAiC,EAAEA,MAAM,CAACC,QAAP,IAAmBkB,MAAM,CAACd,GAAD,CAA3B,CAArC,EAAwE;IACxE,IAAIgB,IAAI,GAAG,EAAX;IACA,IAAIC,EAAE,GAAG,IAAT;IACA,IAAIC,EAAE,GAAG,KAAT;IACA,IAAIC,EAAE,GAAGC,SAAT;;IAEA,IAAI;MACF,KAAK,IAAIC,EAAE,GAAGrB,GAAG,CAACL,MAAM,CAACC,QAAR,CAAH,EAAT,EAAiC0B,EAAtC,EAA0C,EAAEL,EAAE,GAAG,CAACK,EAAE,GAAGD,EAAE,CAACE,IAAH,EAAN,EAAiBC,IAAxB,CAA1C,EAAyEP,EAAE,GAAG,IAA9E,EAAoF;QAClFD,IAAI,CAACS,IAAL,CAAUH,EAAE,CAACI,KAAb;;QAEA,IAAIzB,CAAC,IAAIe,IAAI,CAACW,MAAL,KAAgB1B,CAAzB,EAA4B;MAC7B;IACF,CAND,CAME,OAAO2B,GAAP,EAAY;MACZV,EAAE,GAAG,IAAL;MACAC,EAAE,GAAGS,GAAL;IACD,CATD,SASU;MACR,IAAI;QACF,IAAI,CAACX,EAAD,IAAOI,EAAE,CAAC,QAAD,CAAF,IAAgB,IAA3B,EAAiCA,EAAE,CAAC,QAAD,CAAF;MAClC,CAFD,SAEU;QACR,IAAIH,EAAJ,EAAQ,MAAMC,EAAN;MACT;IACF;;IAED,OAAOH,IAAP;EACD;;EAED,SAASZ,2BAAT,CAAqCyB,CAArC,EAAwCC,MAAxC,EAAgD;IAC9C,IAAI,CAACD,CAAL,EAAQ;IACR,IAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B,OAAOjB,iBAAiB,CAACiB,CAAD,EAAIC,MAAJ,CAAxB;IAC3B,IAAIC,CAAC,GAAGjB,MAAM,CAAChB,SAAP,CAAiBkC,QAAjB,CAA0BC,IAA1B,CAA+BJ,CAA/B,EAAkCK,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAR;IACA,IAAIH,CAAC,KAAK,QAAN,IAAkBF,CAAC,CAAChC,WAAxB,EAAqCkC,CAAC,GAAGF,CAAC,CAAChC,WAAF,CAAcsC,IAAlB;IACrC,IAAIJ,CAAC,KAAK,KAAN,IAAeA,CAAC,KAAK,KAAzB,EAAgC,OAAOrB,KAAK,CAACK,IAAN,CAAWc,CAAX,CAAP;IAChC,IAAIE,CAAC,KAAK,WAAN,IAAqB,2CAA2CK,IAA3C,CAAgDL,CAAhD,CAAzB,EAA6E,OAAOnB,iBAAiB,CAACiB,CAAD,EAAIC,MAAJ,CAAxB;EAC9E;;EAED,SAASlB,iBAAT,CAA2BZ,GAA3B,EAAgCqC,GAAhC,EAAqC;IACnC,IAAIA,GAAG,IAAI,IAAP,IAAeA,GAAG,GAAGrC,GAAG,CAAC2B,MAA7B,EAAqCU,GAAG,GAAGrC,GAAG,CAAC2B,MAAV;;IAErC,KAAK,IAAI1B,CAAC,GAAG,CAAR,EAAWqC,IAAI,GAAG,IAAI5B,KAAJ,CAAU2B,GAAV,CAAvB,EAAuCpC,CAAC,GAAGoC,GAA3C,EAAgDpC,CAAC,EAAjD,EAAqDqC,IAAI,CAACrC,CAAD,CAAJ,GAAUD,GAAG,CAACC,CAAD,CAAb;;IAErD,OAAOqC,IAAP;EACD;;EAED,SAAS7B,kBAAT,GAA8B;IAC5B,MAAM,IAAI8B,SAAJ,CAAc,sIAAd,CAAN;EACD;;EAED,SAASlC,gBAAT,GAA4B;IAC1B,MAAM,IAAIkC,SAAJ,CAAc,2IAAd,CAAN;EACD;;EAED,SAASC,0BAAT,CAAoCX,CAApC,EAAuCY,cAAvC,EAAuD;IACrD,IAAIC,EAAJ;;IAEA,IAAI,OAAO/C,MAAP,KAAkB,WAAlB,IAAiCkC,CAAC,CAAClC,MAAM,CAACC,QAAR,CAAD,IAAsB,IAA3D,EAAiE;MAC/D,IAAIc,KAAK,CAACC,OAAN,CAAckB,CAAd,MAAqBa,EAAE,GAAGtC,2BAA2B,CAACyB,CAAD,CAArD,KAA6DY,cAAc,IAAIZ,CAAlB,IAAuB,OAAOA,CAAC,CAACF,MAAT,KAAoB,QAA5G,EAAsH;QACpH,IAAIe,EAAJ,EAAQb,CAAC,GAAGa,EAAJ;QACR,IAAIzC,CAAC,GAAG,CAAR;;QAEA,IAAI0C,CAAC,GAAG,YAAY,CAAE,CAAtB;;QAEA,OAAO;UACLC,CAAC,EAAED,CADE;UAELZ,CAAC,EAAE,YAAY;YACb,IAAI9B,CAAC,IAAI4B,CAAC,CAACF,MAAX,EAAmB,OAAO;cACxBH,IAAI,EAAE;YADkB,CAAP;YAGnB,OAAO;cACLA,IAAI,EAAE,KADD;cAELE,KAAK,EAAEG,CAAC,CAAC5B,CAAC,EAAF;YAFH,CAAP;UAID,CAVI;UAWL4C,CAAC,EAAE,UAAUA,CAAV,EAAa;YACd,MAAMA,CAAN;UACD,CAbI;UAcLC,CAAC,EAAEH;QAdE,CAAP;MAgBD;;MAED,MAAM,IAAIJ,SAAJ,CAAc,uIAAd,CAAN;IACD;;IAED,IAAIQ,gBAAgB,GAAG,IAAvB;IAAA,IACIC,MAAM,GAAG,KADb;IAAA,IAEIpB,GAFJ;IAGA,OAAO;MACLgB,CAAC,EAAE,YAAY;QACbF,EAAE,GAAGb,CAAC,CAAClC,MAAM,CAACC,QAAR,CAAD,EAAL;MACD,CAHI;MAILmC,CAAC,EAAE,YAAY;QACb,IAAIkB,IAAI,GAAGP,EAAE,CAACnB,IAAH,EAAX;QACAwB,gBAAgB,GAAGE,IAAI,CAACzB,IAAxB;QACA,OAAOyB,IAAP;MACD,CARI;MASLJ,CAAC,EAAE,UAAUA,CAAV,EAAa;QACdG,MAAM,GAAG,IAAT;QACApB,GAAG,GAAGiB,CAAN;MACD,CAZI;MAaLC,CAAC,EAAE,YAAY;QACb,IAAI;UACF,IAAI,CAACC,gBAAD,IAAqBL,EAAE,CAACQ,MAAH,IAAa,IAAtC,EAA4CR,EAAE,CAACQ,MAAH;QAC7C,CAFD,SAEU;UACR,IAAIF,MAAJ,EAAY,MAAMpB,GAAN;QACb;MACF;IAnBI,CAAP;EAqBD;;EAED,IAAIuB,cAAc,GAAG,OAAOC,UAAP,KAAsB,WAAtB,GAAoCA,UAApC,GAAiD,OAAOC,MAAP,KAAkB,WAAlB,GAAgCA,MAAhC,GAAyC,OAAOpE,MAAP,KAAkB,WAAlB,GAAgCA,MAAhC,GAAyC,OAAOM,IAAP,KAAgB,WAAhB,GAA8BA,IAA9B,GAAqC,EAA7L;;EAEA,SAAS+D,oBAAT,CAA8BC,EAA9B,EAAkCnE,MAAlC,EAA0C;IACzC,OAAOA,MAAM,GAAG;MAAED,OAAO,EAAE;IAAX,CAAT,EAA0BoE,EAAE,CAACnE,MAAD,EAASA,MAAM,CAACD,OAAhB,CAA5B,EAAsDC,MAAM,CAACD,OAApE;EACA;;EAED,IAAIqE,UAAU,GAAGF,oBAAoB,CAAC,UAAUlE,MAAV,EAAkBD,OAAlB,EAA2B;IAC/D;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEI;;IAEA;;IAEA;IACA,CAAC,SAASsE,KAAT,CAAetE,OAAf,EAAwB;MAEvB,IAAIuE,MAAJ,EAAYC,aAAZ,EAA2BC,WAA3B,EAAwCC,KAAxC,EAA+CC,IAA/C,EAAqDC,MAArD;;MAEA,SAASC,QAAT,CAAkBtE,GAAlB,EAAuB;QACrB,IAAIuE,GAAG,GAAG,EAAV;QAAA,IACIC,GADJ;QAAA,IAEIC,GAFJ;;QAIA,KAAKD,GAAL,IAAYxE,GAAZ,EAAiB;UACf,IAAIA,GAAG,CAAC0E,cAAJ,CAAmBF,GAAnB,CAAJ,EAA6B;YAC3BC,GAAG,GAAGzE,GAAG,CAACwE,GAAD,CAAT;;YAEA,IAAI,OAAOC,GAAP,KAAe,QAAf,IAA2BA,GAAG,KAAK,IAAvC,EAA6C;cAC3CF,GAAG,CAACC,GAAD,CAAH,GAAWF,QAAQ,CAACG,GAAD,CAAnB;YACD,CAFD,MAEO;cACLF,GAAG,CAACC,GAAD,CAAH,GAAWC,GAAX;YACD;UACF;QACF;;QAED,OAAOF,GAAP;MACD,CAtBsB,CAsBrB;MACF;;;MAGA,SAASI,UAAT,CAAoBC,KAApB,EAA2BC,IAA3B,EAAiC;QAC/B,IAAIC,IAAJ,EAAUnC,GAAV,EAAepC,CAAf,EAAkBwE,OAAlB;QACApC,GAAG,GAAGiC,KAAK,CAAC3C,MAAZ;QACA1B,CAAC,GAAG,CAAJ;;QAEA,OAAOoC,GAAP,EAAY;UACVmC,IAAI,GAAGnC,GAAG,KAAK,CAAf;UACAoC,OAAO,GAAGxE,CAAC,GAAGuE,IAAd;;UAEA,IAAID,IAAI,CAACD,KAAK,CAACG,OAAD,CAAN,CAAR,EAA0B;YACxBpC,GAAG,GAAGmC,IAAN;UACD,CAFD,MAEO;YACLvE,CAAC,GAAGwE,OAAO,GAAG,CAAd;YACApC,GAAG,IAAImC,IAAI,GAAG,CAAd;UACD;QACF;;QAED,OAAOvE,CAAP;MACD;;MAEDyD,MAAM,GAAG;QACPgB,oBAAoB,EAAE,sBADf;QAEPC,iBAAiB,EAAE,mBAFZ;QAGPC,eAAe,EAAE,iBAHV;QAIPC,YAAY,EAAE,cAJP;QAKPC,uBAAuB,EAAE,yBALlB;QAMPC,eAAe,EAAE,iBANV;QAOP;QACAC,cAAc,EAAE,gBART;QASPC,gBAAgB,EAAE,kBATX;QAUPC,cAAc,EAAE,gBAVT;QAWPC,cAAc,EAAE,gBAXT;QAYPC,WAAW,EAAE,aAZN;QAaPC,eAAe,EAAE,iBAbV;QAcPC,SAAS,EAAE,WAdJ;QAePC,gBAAgB,EAAE,kBAfX;QAgBPC,eAAe,EAAE,iBAhBV;QAiBPC,kBAAkB,EAAE,oBAjBb;QAkBP;QACAC,uBAAuB,EAAE,yBAnBlB;QAoBP;QACAC,qBAAqB,EAAE,uBArBhB;QAsBPC,iBAAiB,EAAE,mBAtBZ;QAuBPC,iBAAiB,EAAE,mBAvBZ;QAwBPC,kBAAkB,EAAE,oBAxBb;QAyBPC,gBAAgB,EAAE,kBAzBX;QA0BPC,cAAc,EAAE,gBA1BT;QA2BPC,oBAAoB,EAAE,sBA3Bf;QA4BPC,wBAAwB,EAAE,0BA5BnB;QA6BPC,sBAAsB,EAAE,wBA7BjB;QA8BPC,eAAe,EAAE,iBA9BV;QA+BPC,mBAAmB,EAAE,qBA/Bd;QAgCPC,YAAY,EAAE,cAhCP;QAiCPC,cAAc,EAAE,gBAjCT;QAkCPC,cAAc,EAAE,gBAlCT;QAmCPC,mBAAmB,EAAE,qBAnCd;QAoCPC,kBAAkB,EAAE,oBApCb;QAqCPC,mBAAmB,EAAE,qBArCd;QAsCP;QACAC,UAAU,EAAE,YAvCL;QAwCPC,WAAW,EAAE,aAxCN;QAyCPC,gBAAgB,EAAE,kBAzCX;QA0CPC,iBAAiB,EAAE,mBA1CZ;QA2CPC,sBAAsB,EAAE,wBA3CjB;QA4CPC,wBAAwB,EAAE,0BA5CnB;QA6CPC,eAAe,EAAE,iBA7CV;QA8CPC,OAAO,EAAE,SA9CF;QA+CPC,gBAAgB,EAAE,kBA/CX;QAgDPC,iBAAiB,EAAE,mBAhDZ;QAiDPC,gBAAgB,EAAE,kBAjDX;QAkDPC,YAAY,EAAE,cAlDP;QAmDPC,gBAAgB,EAAE,kBAnDX;QAoDPC,eAAe,EAAE,iBApDV;QAqDPC,aAAa,EAAE,eArDR;QAsDPC,gBAAgB,EAAE,kBAtDX;QAuDPC,aAAa,EAAE,eAvDR;QAwDPC,OAAO,EAAE,SAxDF;QAyDPC,QAAQ,EAAE,UAzDH;QA0DPC,WAAW,EAAE,aA1DN;QA2DPC,eAAe,EAAE,iBA3DV;QA4DPC,kBAAkB,EAAE,oBA5Db;QA6DPC,aAAa,EAAE,eA7DR;QA8DPC,KAAK,EAAE,OA9DA;QA+DPC,eAAe,EAAE,iBA/DV;QAgEPC,UAAU,EAAE,YAhEL;QAiEPC,wBAAwB,EAAE,0BAjEnB;QAkEPC,eAAe,EAAE,iBAlEV;QAmEPC,eAAe,EAAE,iBAnEV;QAoEPC,cAAc,EAAE,gBApET;QAqEPC,cAAc,EAAE,gBArET;QAsEPC,YAAY,EAAE,cAtEP;QAuEPC,eAAe,EAAE,iBAvEV;QAwEPC,gBAAgB,EAAE,kBAxEX;QAyEPC,mBAAmB,EAAE,qBAzEd;QA0EPC,kBAAkB,EAAE,oBA1Eb;QA2EPC,cAAc,EAAE,gBA3ET;QA4EPC,aAAa,EAAE,eA5ER;QA6EPC,eAAe,EAAE;MA7EV,CAAT;MA+EAtF,WAAW,GAAG;QACZc,oBAAoB,EAAE,CAAC,MAAD,EAAS,OAAT,CADV;QAEZC,iBAAiB,EAAE,CAAC,MAAD,EAAS,OAAT,CAFP;QAGZC,eAAe,EAAE,CAAC,UAAD,CAHL;QAIZC,YAAY,EAAE,CAAC,UAAD,CAJF;QAKZC,uBAAuB,EAAE,CAAC,QAAD,EAAW,MAAX,CALb;QAMZC,eAAe,EAAE,CAAC,UAAD,CANL;QAOZ;QACAC,cAAc,EAAE,CAAC,MAAD,CARJ;QASZC,gBAAgB,EAAE,CAAC,MAAD,EAAS,OAAT,CATN;QAUZC,cAAc,EAAE,CAAC,OAAD,CAVJ;QAWZC,cAAc,EAAE,CAAC,QAAD,EAAW,WAAX,CAXJ;QAYZC,WAAW,EAAE,CAAC,OAAD,EAAU,MAAV,CAZD;QAaZC,eAAe,EAAE,CAAC,YAAD,CAbL;QAcZC,SAAS,EAAE,CAAC,MAAD,CAdC;QAeZC,gBAAgB,EAAE,CAAC,IAAD,EAAO,YAAP,EAAqB,MAArB,CAfN;QAgBZC,eAAe,EAAE,CAAC,IAAD,EAAO,YAAP,EAAqB,MAArB,CAhBL;QAiBZC,kBAAkB,EAAE,CAAC,MAAD,EAAS,OAAT,CAjBR;QAkBZ;QACAC,uBAAuB,EAAE,CAAC,QAAD,EAAW,QAAX,EAAqB,MAArB,CAnBb;QAoBZ;QACAC,qBAAqB,EAAE,CAAC,MAAD,EAAS,YAAT,EAAuB,WAAvB,CArBX;QAsBZC,iBAAiB,EAAE,CAAC,OAAD,CAtBP;QAuBZC,iBAAiB,EAAE,EAvBP;QAwBZC,kBAAkB,EAAE,EAxBR;QAyBZC,gBAAgB,EAAE,CAAC,MAAD,EAAS,MAAT,CAzBN;QA0BZC,cAAc,EAAE,EA1BJ;QA2BZC,oBAAoB,EAAE,CAAC,QAAD,CA3BV;QA4BZC,wBAAwB,EAAE,CAAC,aAAD,CA5Bd;QA6BZC,sBAAsB,EAAE,CAAC,aAAD,EAAgB,YAAhB,EAA8B,QAA9B,CA7BZ;QA8BZC,eAAe,EAAE,CAAC,UAAD,EAAa,OAAb,CA9BL;QA+BZC,mBAAmB,EAAE,CAAC,YAAD,CA/BT;QAgCZC,YAAY,EAAE,CAAC,MAAD,EAAS,MAAT,EAAiB,QAAjB,EAA2B,MAA3B,CAhCF;QAiCZC,cAAc,EAAE,CAAC,MAAD,EAAS,OAAT,EAAkB,MAAlB,CAjCJ;QAkCZC,cAAc,EAAE,CAAC,MAAD,EAAS,OAAT,EAAkB,MAAlB,CAlCJ;QAmCZC,mBAAmB,EAAE,CAAC,IAAD,EAAO,QAAP,EAAiB,MAAjB,CAnCT;QAoCZC,kBAAkB,EAAE,CAAC,IAAD,EAAO,QAAP,EAAiB,MAAjB,CApCR;QAqCZC,mBAAmB,EAAE,CAAC,QAAD,EAAW,QAAX,EAAqB,MAArB,CArCT;QAsCZ;QACAC,UAAU,EAAE,EAvCA;QAwCZC,WAAW,EAAE,CAAC,MAAD,EAAS,YAAT,EAAuB,WAAvB,CAxCD;QAyCZC,gBAAgB,EAAE,CAAC,QAAD,CAzCN;QA0CZC,iBAAiB,EAAE,CAAC,YAAD,EAAe,QAAf,CA1CP;QA2CZC,sBAAsB,EAAE,CAAC,OAAD,CA3CZ;QA4CZC,wBAAwB,EAAE,CAAC,OAAD,CA5Cd;QA6CZC,eAAe,EAAE,CAAC,UAAD,EAAa,OAAb,CA7CL;QA8CZC,OAAO,EAAE,EA9CG;QA+CZC,gBAAgB,EAAE,CAAC,OAAD,EAAU,MAAV,CA/CN;QAgDZC,iBAAiB,EAAE,CAAC,MAAD,EAAS,OAAT,CAhDP;QAiDZC,gBAAgB,EAAE,CAAC,QAAD,EAAW,UAAX,CAjDN;QAkDZC,YAAY,EAAE,CAAC,MAAD,EAAS,UAAT,CAlDF;QAmDZC,gBAAgB,EAAE,CAAC,KAAD,EAAQ,OAAR,CAnDN;QAoDZC,eAAe,EAAE,EApDL;QAqDZC,aAAa,EAAE,CAAC,QAAD,EAAW,WAAX,CArDH;QAsDZC,gBAAgB,EAAE,CAAC,YAAD,CAtDN;QAuDZC,aAAa,EAAE,CAAC,YAAD,CAvDH;QAwDZC,OAAO,EAAE,CAAC,MAAD,CAxDG;QAyDZC,QAAQ,EAAE,CAAC,KAAD,EAAQ,OAAR,CAzDE;QA0DZC,WAAW,EAAE,CAAC,UAAD,CA1DD;QA2DZC,eAAe,EAAE,CAAC,UAAD,CA3DL;QA4DZC,kBAAkB,EAAE,CAAC,aAAD,CA5DR;QA6DZC,aAAa,EAAE,CAAC,UAAD,CA7DH;QA8DZC,KAAK,EAAE,EA9DK;QA+DZC,eAAe,EAAE,CAAC,cAAD,EAAiB,OAAjB,CA/DL;QAgEZC,UAAU,EAAE,CAAC,MAAD,EAAS,YAAT,CAhEA;QAiEZC,wBAAwB,EAAE,CAAC,KAAD,EAAQ,OAAR,CAjEd;QAkEZC,eAAe,EAAE,EAlEL;QAmEZC,eAAe,EAAE,CAAC,QAAD,EAAW,aAAX,CAnEL;QAoEZC,cAAc,EAAE,EApEJ;QAqEZC,cAAc,EAAE,CAAC,UAAD,CArEJ;QAsEZC,YAAY,EAAE,CAAC,OAAD,EAAU,SAAV,EAAqB,WAArB,CAtEF;QAuEZC,eAAe,EAAE,CAAC,UAAD,CAvEL;QAwEZC,gBAAgB,EAAE,CAAC,UAAD,CAxEN;QAyEZC,mBAAmB,EAAE,CAAC,cAAD,CAzET;QA0EZC,kBAAkB,EAAE,CAAC,IAAD,EAAO,MAAP,CA1ER;QA2EZC,cAAc,EAAE,CAAC,MAAD,EAAS,MAAT,CA3EJ;QA4EZC,aAAa,EAAE,CAAC,QAAD,EAAW,MAAX,CA5EH;QA6EZC,eAAe,EAAE,CAAC,UAAD;MA7EL,CAAd,CA7HuB,CA2MpB;;MAEHrF,KAAK,GAAG,EAAR;MACAC,IAAI,GAAG,EAAP;MACAC,MAAM,GAAG,EAAT;MACAJ,aAAa,GAAG;QACdwF,KAAK,EAAEtF,KADO;QAEduF,IAAI,EAAEtF,IAFQ;QAGduF,MAAM,EAAEtF;MAHM,CAAhB;;MAMA,SAASuF,SAAT,CAAmBC,MAAnB,EAA2BrF,GAA3B,EAAgC;QAC9B,KAAKqF,MAAL,GAAcA,MAAd;QACA,KAAKrF,GAAL,GAAWA,GAAX;MACD;;MAEDoF,SAAS,CAACxJ,SAAV,CAAoB0J,OAApB,GAA8B,SAASA,OAAT,CAAiBC,IAAjB,EAAuB;QACnD,KAAKF,MAAL,CAAY,KAAKrF,GAAjB,IAAwBuF,IAAxB;MACD,CAFD;;MAIAH,SAAS,CAACxJ,SAAV,CAAoB4J,MAApB,GAA6B,SAASA,MAAT,GAAkB;QAC7C,IAAIhJ,KAAK,CAACC,OAAN,CAAc,KAAK4I,MAAnB,CAAJ,EAAgC;UAC9B,KAAKA,MAAL,CAAYI,MAAZ,CAAmB,KAAKzF,GAAxB,EAA6B,CAA7B;UACA,OAAO,IAAP;QACD,CAHD,MAGO;UACL,KAAKsF,OAAL,CAAa,IAAb;UACA,OAAO,KAAP;QACD;MACF,CARD;;MAUA,SAASI,OAAT,CAAiBH,IAAjB,EAAuBI,IAAvB,EAA6BC,IAA7B,EAAmCC,GAAnC,EAAwC;QACtC,KAAKN,IAAL,GAAYA,IAAZ;QACA,KAAKI,IAAL,GAAYA,IAAZ;QACA,KAAKC,IAAL,GAAYA,IAAZ;QACA,KAAKC,GAAL,GAAWA,GAAX;MACD;;MAED,SAASC,UAAT,GAAsB,CAAE,CAhPD,CAgPE;MACzB;;;MAGAA,UAAU,CAAClK,SAAX,CAAqB+J,IAArB,GAA4B,SAASA,IAAT,GAAgB;QAC1C,IAAI5J,CAAJ,EAAOgK,EAAP,EAAWC,CAAX,EAAcC,EAAd,EAAkBC,MAAlB,EAA0BC,OAA1B;;QAEA,SAASC,SAAT,CAAmBF,MAAnB,EAA2BP,IAA3B,EAAiC;UAC/B,IAAInJ,KAAK,CAACC,OAAN,CAAckJ,IAAd,CAAJ,EAAyB;YACvB,KAAKK,CAAC,GAAG,CAAJ,EAAOC,EAAE,GAAGN,IAAI,CAAClI,MAAtB,EAA8BuI,CAAC,GAAGC,EAAlC,EAAsC,EAAED,CAAxC,EAA2C;cACzCE,MAAM,CAAC3I,IAAP,CAAYoI,IAAI,CAACK,CAAD,CAAhB;YACD;UACF,CAJD,MAIO;YACLE,MAAM,CAAC3I,IAAP,CAAYoI,IAAZ;UACD;QACF,CAXyC,CAWxC;;;QAGF,IAAI,CAAC,KAAKU,SAAL,CAAeV,IAApB,EAA0B;UACxB,OAAO,IAAP;QACD,CAhByC,CAgBxC;;;QAGFO,MAAM,GAAG,EAAT;;QAEA,KAAKnK,CAAC,GAAG,CAAJ,EAAOgK,EAAE,GAAG,KAAKO,WAAL,CAAiB7I,MAAlC,EAA0C1B,CAAC,GAAGgK,EAA9C,EAAkD,EAAEhK,CAApD,EAAuD;UACrDoK,OAAO,GAAG,KAAKG,WAAL,CAAiBvK,CAAjB,CAAV;UACAqK,SAAS,CAACF,MAAD,EAASC,OAAO,CAACR,IAAjB,CAAT;QACD;;QAEDS,SAAS,CAACF,MAAD,EAAS,KAAKG,SAAL,CAAeV,IAAxB,CAAT;QACA,OAAOO,MAAP;MACD,CA5BD,CApPuB,CAgRpB;MACH;;;MAGAJ,UAAU,CAAClK,SAAX,CAAqB2K,IAArB,GAA4B,YAAY;QACtC,IAAIhB,IAAI,GAAG,KAAKhF,OAAL,EAAX;QACA,OAAOgF,IAAI,CAACgB,IAAL,IAAa,KAAKF,SAAL,CAAeT,IAAnC;MACD,CAHD,CApRuB,CAuRpB;MACH;;;MAGAE,UAAU,CAAClK,SAAX,CAAqB4K,OAArB,GAA+B,SAASA,OAAT,GAAmB;QAChD,IAAIzK,CAAJ,EAAOgK,EAAP,EAAWG,MAAX,CADgD,CAC7B;;QAEnBA,MAAM,GAAG,EAAT;;QAEA,KAAKnK,CAAC,GAAG,CAAJ,EAAOgK,EAAE,GAAG,KAAKO,WAAL,CAAiB7I,MAAlC,EAA0C1B,CAAC,GAAGgK,EAA9C,EAAkD,EAAEhK,CAApD,EAAuD;UACrDmK,MAAM,CAAC3I,IAAP,CAAY,KAAK+I,WAAL,CAAiBvK,CAAjB,EAAoBwJ,IAAhC;QACD;;QAED,OAAOW,MAAP;MACD,CAVD,CA3RuB,CAqSpB;MACH;;;MAGAJ,UAAU,CAAClK,SAAX,CAAqB2E,OAArB,GAA+B,SAASA,OAAT,GAAmB;QAChD,OAAO,KAAK8F,SAAL,CAAed,IAAtB;MACD,CAFD;;MAIAO,UAAU,CAAClK,SAAX,CAAqB6K,SAArB,GAAiC,SAASA,SAAT,CAAmBC,QAAnB,EAA6BP,OAA7B,EAAsC;QACrE,IAAIQ,QAAJ,EAAcT,MAAd;QACAA,MAAM,GAAGhJ,SAAT;QACAyJ,QAAQ,GAAG,KAAKN,SAAhB;QACA,KAAKA,SAAL,GAAiBF,OAAjB;QACA,KAAKS,OAAL,GAAe,IAAf;;QAEA,IAAIF,QAAJ,EAAc;UACZR,MAAM,GAAGQ,QAAQ,CAAC3I,IAAT,CAAc,IAAd,EAAoBoI,OAAO,CAACZ,IAA5B,EAAkC,KAAKe,WAAL,CAAiB,KAAKA,WAAL,CAAiB7I,MAAjB,GAA0B,CAA3C,EAA8C8H,IAAhF,CAAT;QACD;;QAED,KAAKc,SAAL,GAAiBM,QAAjB;QACA,OAAOT,MAAP;MACD,CAbD,CA7SuB,CA0TpB;MACH;;;MAGAJ,UAAU,CAAClK,SAAX,CAAqBiL,MAArB,GAA8B,SAASA,MAAT,CAAgBC,IAAhB,EAAsB;QAClD,KAAKF,OAAL,GAAeE,IAAf;MACD,CAFD,CA9TuB,CAgUpB;MACH;;;MAGAhB,UAAU,CAAClK,SAAX,CAAqBmL,IAArB,GAA4B,YAAY;QACtC,KAAKF,MAAL,CAAYjH,IAAZ;MACD,CAFD,CApUuB,CAsUpB;MACH;;;MAGAkG,UAAU,CAAClK,SAAX,CAAqB,OAArB,IAAgC,YAAY;QAC1C,KAAKiL,MAAL,CAAYlH,KAAZ;MACD,CAFD,CA1UuB,CA4UpB;MACH;;;MAGAmG,UAAU,CAAClK,SAAX,CAAqB4J,MAArB,GAA8B,YAAY;QACxC,KAAKqB,MAAL,CAAYhH,MAAZ;MACD,CAFD;;MAIAiG,UAAU,CAAClK,SAAX,CAAqBoL,YAArB,GAAoC,UAAUC,IAAV,EAAgBC,OAAhB,EAAyB;QAC3D,KAAKA,OAAL,GAAeA,OAAf;QACA,KAAKD,IAAL,GAAYA,IAAZ;QACA,KAAKE,UAAL,GAAkB,EAAlB;QACA,KAAKb,WAAL,GAAmB,EAAnB;QACA,KAAKD,SAAL,GAAiB,IAAjB;QACA,KAAKO,OAAL,GAAe,IAAf;QACA,KAAKQ,UAAL,GAAkB,IAAlB;;QAEA,IAAIF,OAAO,CAACG,QAAR,KAAqB,WAAzB,EAAsC;UACpC,KAAKD,UAAL,GAAkBxK,MAAM,CAAC0K,IAAzB;QACD,CAFD,MAEO,IAAI,OAAOJ,OAAO,CAACG,QAAf,KAA4B,UAAhC,EAA4C;UACjD,KAAKD,UAAL,GAAkBF,OAAO,CAACG,QAA1B;QACD;;QAED,KAAKE,MAAL,GAAc7H,WAAd;;QAEA,IAAIwH,OAAO,CAACI,IAAZ,EAAkB;UAChB,KAAKC,MAAL,GAAc3K,MAAM,CAAC4K,MAAP,CAAc5K,MAAM,CAAC6K,MAAP,CAAc,KAAKF,MAAnB,CAAd,EAA0CL,OAAO,CAACI,IAAlD,CAAd;QACD;MACF,CApBD;;MAsBA,SAASI,MAAT,CAAgBnC,IAAhB,EAAsB;QACpB,IAAIA,IAAI,IAAI,IAAZ,EAAkB;UAChB,OAAO,KAAP;QACD;;QAED,OAAO,OAAOA,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAI,CAACgB,IAAZ,KAAqB,QAAxD;MACD;;MAED,SAASoB,UAAT,CAAoBC,QAApB,EAA8B5H,GAA9B,EAAmC;QACjC,OAAO,CAAC4H,QAAQ,KAAKpI,MAAM,CAACiE,gBAApB,IAAwCmE,QAAQ,KAAKpI,MAAM,CAACkE,aAA7D,KAA+E,iBAAiB1D,GAAvG;MACD;;MAED,SAAS6H,0BAAT,CAAoCC,SAApC,EAA+CC,SAA/C,EAA0D;QACxD,KAAK,IAAIhM,CAAC,GAAG+L,SAAS,CAACrK,MAAV,GAAmB,CAAhC,EAAmC1B,CAAC,IAAI,CAAxC,EAA2C,EAAEA,CAA7C,EAAgD;UAC9C,IAAI+L,SAAS,CAAC/L,CAAD,CAAT,CAAawJ,IAAb,KAAsBwC,SAA1B,EAAqC;YACnC,OAAO,IAAP;UACD;QACF;;QAED,OAAO,KAAP;MACD;;MAEDjC,UAAU,CAAClK,SAAX,CAAqBoM,QAArB,GAAgC,SAASA,QAAT,CAAkBf,IAAlB,EAAwBC,OAAxB,EAAiC;QAC/D,IAAIe,QAAJ,EAAcH,SAAd,EAAyB3B,OAAzB,EAAkCZ,IAAlC,EAAwCqC,QAAxC,EAAkD7H,GAAlD,EAAuDC,GAAvD,EAA4DO,OAA5D,EAAqE2H,QAArE,EAA+EC,UAA/E,EAA2FJ,SAA3F,EAAsGK,QAAtG;;QAEA,KAAKpB,YAAL,CAAkBC,IAAlB,EAAwBC,OAAxB;;QAEAkB,QAAQ,GAAG,EAAX,CAL+D,CAKhD;;QAEfH,QAAQ,GAAG,KAAKd,UAAhB;QACAW,SAAS,GAAG,KAAKxB,WAAjB,CAR+D,CAQjC;;QAE9B2B,QAAQ,CAAC1K,IAAT,CAAc,IAAImI,OAAJ,CAAYuB,IAAZ,EAAkB,IAAlB,EAAwB,IAAxB,EAA8B,IAA9B,CAAd;QACAa,SAAS,CAACvK,IAAV,CAAe,IAAImI,OAAJ,CAAY,IAAZ,EAAkB,IAAlB,EAAwB,IAAxB,EAA8B,IAA9B,CAAf;;QAEA,OAAOuC,QAAQ,CAACxK,MAAhB,EAAwB;UACtB0I,OAAO,GAAG8B,QAAQ,CAACI,GAAT,EAAV;;UAEA,IAAIlC,OAAO,KAAKiC,QAAhB,EAA0B;YACxBjC,OAAO,GAAG2B,SAAS,CAACO,GAAV,EAAV;YACAtI,GAAG,GAAG,KAAK0G,SAAL,CAAeS,OAAO,CAACoB,KAAvB,EAA8BnC,OAA9B,CAAN;;YAEA,IAAI,KAAKS,OAAL,KAAiBjH,KAAjB,IAA0BI,GAAG,KAAKJ,KAAtC,EAA6C;cAC3C;YACD;;YAED;UACD;;UAED,IAAIwG,OAAO,CAACZ,IAAZ,EAAkB;YAChBxF,GAAG,GAAG,KAAK0G,SAAL,CAAeS,OAAO,CAACqB,KAAvB,EAA8BpC,OAA9B,CAAN;;YAEA,IAAI,KAAKS,OAAL,KAAiBjH,KAAjB,IAA0BI,GAAG,KAAKJ,KAAtC,EAA6C;cAC3C;YACD;;YAEDsI,QAAQ,CAAC1K,IAAT,CAAc6K,QAAd;YACAN,SAAS,CAACvK,IAAV,CAAe4I,OAAf;;YAEA,IAAI,KAAKS,OAAL,KAAiBhH,IAAjB,IAAyBG,GAAG,KAAKH,IAArC,EAA2C;cACzC;YACD;;YAED2F,IAAI,GAAGY,OAAO,CAACZ,IAAf;YACAqC,QAAQ,GAAGrC,IAAI,CAACgB,IAAL,IAAaJ,OAAO,CAACP,IAAhC;YACAuC,UAAU,GAAG,KAAKZ,MAAL,CAAYK,QAAZ,CAAb;;YAEA,IAAI,CAACO,UAAL,EAAiB;cACf,IAAI,KAAKf,UAAT,EAAqB;gBACnBe,UAAU,GAAG,KAAKf,UAAL,CAAgB7B,IAAhB,CAAb;cACD,CAFD,MAEO;gBACL,MAAM,IAAIiD,KAAJ,CAAU,uBAAuBZ,QAAvB,GAAkC,GAA5C,CAAN;cACD;YACF;;YAEDrH,OAAO,GAAG4H,UAAU,CAAC1K,MAArB;;YAEA,OAAO,CAAC8C,OAAO,IAAI,CAAZ,KAAkB,CAAzB,EAA4B;cAC1BP,GAAG,GAAGmI,UAAU,CAAC5H,OAAD,CAAhB;cACAwH,SAAS,GAAGxC,IAAI,CAACvF,GAAD,CAAhB;;cAEA,IAAI,CAAC+H,SAAL,EAAgB;gBACd;cACD;;cAED,IAAIvL,KAAK,CAACC,OAAN,CAAcsL,SAAd,CAAJ,EAA8B;gBAC5BG,QAAQ,GAAGH,SAAS,CAACtK,MAArB;;gBAEA,OAAO,CAACyK,QAAQ,IAAI,CAAb,KAAmB,CAA1B,EAA6B;kBAC3B,IAAI,CAACH,SAAS,CAACG,QAAD,CAAd,EAA0B;oBACxB;kBACD;;kBAED,IAAIL,0BAA0B,CAACC,SAAD,EAAYC,SAAS,CAACG,QAAD,CAArB,CAA9B,EAAgE;oBAC9D;kBACD;;kBAED,IAAIP,UAAU,CAACC,QAAD,EAAWO,UAAU,CAAC5H,OAAD,CAArB,CAAd,EAA+C;oBAC7C4F,OAAO,GAAG,IAAIT,OAAJ,CAAYqC,SAAS,CAACG,QAAD,CAArB,EAAiC,CAAClI,GAAD,EAAMkI,QAAN,CAAjC,EAAkD,UAAlD,EAA8D,IAA9D,CAAV;kBACD,CAFD,MAEO,IAAIR,MAAM,CAACK,SAAS,CAACG,QAAD,CAAV,CAAV,EAAiC;oBACtC/B,OAAO,GAAG,IAAIT,OAAJ,CAAYqC,SAAS,CAACG,QAAD,CAArB,EAAiC,CAAClI,GAAD,EAAMkI,QAAN,CAAjC,EAAkD,IAAlD,EAAwD,IAAxD,CAAV;kBACD,CAFM,MAEA;oBACL;kBACD;;kBAEDD,QAAQ,CAAC1K,IAAT,CAAc4I,OAAd;gBACD;cACF,CAtBD,MAsBO,IAAIuB,MAAM,CAACK,SAAD,CAAV,EAAuB;gBAC5B,IAAIF,0BAA0B,CAACC,SAAD,EAAYC,SAAZ,CAA9B,EAAsD;kBACpD;gBACD;;gBAEDE,QAAQ,CAAC1K,IAAT,CAAc,IAAImI,OAAJ,CAAYqC,SAAZ,EAAuB/H,GAAvB,EAA4B,IAA5B,EAAkC,IAAlC,CAAd;cACD;YACF;UACF;QACF;MACF,CA/FD;;MAiGA8F,UAAU,CAAClK,SAAX,CAAqB0J,OAArB,GAA+B,SAASA,OAAT,CAAiB2B,IAAjB,EAAuBC,OAAvB,EAAgC;QAC7D,IAAIe,QAAJ,EAAcH,SAAd,EAAyBvC,IAAzB,EAA+BqC,QAA/B,EAAyCa,MAAzC,EAAiDtC,OAAjD,EAA0D5F,OAA1D,EAAmE2H,QAAnE,EAA6EC,UAA7E,EAAyFJ,SAAzF,EAAoGK,QAApG,EAA8GM,KAA9G,EAAqH1I,GAArH;;QAEA,SAAS2I,UAAT,CAAoBxC,OAApB,EAA6B;UAC3B,IAAIpK,CAAJ,EAAOiE,GAAP,EAAY4I,QAAZ,EAAsBvD,MAAtB;;UAEA,IAAIc,OAAO,CAACN,GAAR,CAAYL,MAAZ,EAAJ,EAA0B;YACxB;YACAxF,GAAG,GAAGmG,OAAO,CAACN,GAAR,CAAY7F,GAAlB;YACAqF,MAAM,GAAGc,OAAO,CAACN,GAAR,CAAYR,MAArB,CAHwB,CAGK;;YAE7BtJ,CAAC,GAAGkM,QAAQ,CAACxK,MAAb;;YAEA,OAAO1B,CAAC,EAAR,EAAY;cACV6M,QAAQ,GAAGX,QAAQ,CAAClM,CAAD,CAAnB;;cAEA,IAAI6M,QAAQ,CAAC/C,GAAT,IAAgB+C,QAAQ,CAAC/C,GAAT,CAAaR,MAAb,KAAwBA,MAA5C,EAAoD;gBAClD,IAAIuD,QAAQ,CAAC/C,GAAT,CAAa7F,GAAb,GAAmBA,GAAvB,EAA4B;kBAC1B;gBACD;;gBAED,EAAE4I,QAAQ,CAAC/C,GAAT,CAAa7F,GAAf;cACD;YACF;UACF;QACF;;QAED,KAAKgH,YAAL,CAAkBC,IAAlB,EAAwBC,OAAxB;;QAEAkB,QAAQ,GAAG,EAAX,CA7B6D,CA6B9C;;QAEfH,QAAQ,GAAG,KAAKd,UAAhB;QACAW,SAAS,GAAG,KAAKxB,WAAjB,CAhC6D,CAgC/B;;QAE9BoC,KAAK,GAAG;UACNzB,IAAI,EAAEA;QADA,CAAR;QAGAd,OAAO,GAAG,IAAIT,OAAJ,CAAYuB,IAAZ,EAAkB,IAAlB,EAAwB,IAAxB,EAA8B,IAAI7B,SAAJ,CAAcsD,KAAd,EAAqB,MAArB,CAA9B,CAAV;QACAT,QAAQ,CAAC1K,IAAT,CAAc4I,OAAd;QACA2B,SAAS,CAACvK,IAAV,CAAe4I,OAAf;;QAEA,OAAO8B,QAAQ,CAACxK,MAAhB,EAAwB;UACtB0I,OAAO,GAAG8B,QAAQ,CAACI,GAAT,EAAV;;UAEA,IAAIlC,OAAO,KAAKiC,QAAhB,EAA0B;YACxBjC,OAAO,GAAG2B,SAAS,CAACO,GAAV,EAAV;YACAI,MAAM,GAAG,KAAKhC,SAAL,CAAeS,OAAO,CAACoB,KAAvB,EAA8BnC,OAA9B,CAAT,CAFwB,CAEyB;YACjD;;YAEA,IAAIsC,MAAM,KAAKvL,SAAX,IAAwBuL,MAAM,KAAK9I,KAAnC,IAA4C8I,MAAM,KAAK7I,IAAvD,IAA+D6I,MAAM,KAAK5I,MAA9E,EAAsF;cACpF;cACAsG,OAAO,CAACN,GAAR,CAAYP,OAAZ,CAAoBmD,MAApB;YACD;;YAED,IAAI,KAAK7B,OAAL,KAAiB/G,MAAjB,IAA2B4I,MAAM,KAAK5I,MAA1C,EAAkD;cAChD8I,UAAU,CAACxC,OAAD,CAAV;YACD;;YAED,IAAI,KAAKS,OAAL,KAAiBjH,KAAjB,IAA0B8I,MAAM,KAAK9I,KAAzC,EAAgD;cAC9C,OAAO+I,KAAK,CAACzB,IAAb;YACD;;YAED;UACD;;UAEDwB,MAAM,GAAG,KAAKhC,SAAL,CAAeS,OAAO,CAACqB,KAAvB,EAA8BpC,OAA9B,CAAT,CAxBsB,CAwB2B;UACjD;;UAEA,IAAIsC,MAAM,KAAKvL,SAAX,IAAwBuL,MAAM,KAAK9I,KAAnC,IAA4C8I,MAAM,KAAK7I,IAAvD,IAA+D6I,MAAM,KAAK5I,MAA9E,EAAsF;YACpF;YACAsG,OAAO,CAACN,GAAR,CAAYP,OAAZ,CAAoBmD,MAApB;YACAtC,OAAO,CAACZ,IAAR,GAAekD,MAAf;UACD;;UAED,IAAI,KAAK7B,OAAL,KAAiB/G,MAAjB,IAA2B4I,MAAM,KAAK5I,MAA1C,EAAkD;YAChD8I,UAAU,CAACxC,OAAD,CAAV;YACAA,OAAO,CAACZ,IAAR,GAAe,IAAf;UACD;;UAED,IAAI,KAAKqB,OAAL,KAAiBjH,KAAjB,IAA0B8I,MAAM,KAAK9I,KAAzC,EAAgD;YAC9C,OAAO+I,KAAK,CAACzB,IAAb;UACD,CAxCqB,CAwCpB;;;UAGF1B,IAAI,GAAGY,OAAO,CAACZ,IAAf;;UAEA,IAAI,CAACA,IAAL,EAAW;YACT;UACD;;UAED0C,QAAQ,CAAC1K,IAAT,CAAc6K,QAAd;UACAN,SAAS,CAACvK,IAAV,CAAe4I,OAAf;;UAEA,IAAI,KAAKS,OAAL,KAAiBhH,IAAjB,IAAyB6I,MAAM,KAAK7I,IAAxC,EAA8C;YAC5C;UACD;;UAEDgI,QAAQ,GAAGrC,IAAI,CAACgB,IAAL,IAAaJ,OAAO,CAACP,IAAhC;UACAuC,UAAU,GAAG,KAAKZ,MAAL,CAAYK,QAAZ,CAAb;;UAEA,IAAI,CAACO,UAAL,EAAiB;YACf,IAAI,KAAKf,UAAT,EAAqB;cACnBe,UAAU,GAAG,KAAKf,UAAL,CAAgB7B,IAAhB,CAAb;YACD,CAFD,MAEO;cACL,MAAM,IAAIiD,KAAJ,CAAU,uBAAuBZ,QAAvB,GAAkC,GAA5C,CAAN;YACD;UACF;;UAEDrH,OAAO,GAAG4H,UAAU,CAAC1K,MAArB;;UAEA,OAAO,CAAC8C,OAAO,IAAI,CAAZ,KAAkB,CAAzB,EAA4B;YAC1BP,GAAG,GAAGmI,UAAU,CAAC5H,OAAD,CAAhB;YACAwH,SAAS,GAAGxC,IAAI,CAACvF,GAAD,CAAhB;;YAEA,IAAI,CAAC+H,SAAL,EAAgB;cACd;YACD;;YAED,IAAIvL,KAAK,CAACC,OAAN,CAAcsL,SAAd,CAAJ,EAA8B;cAC5BG,QAAQ,GAAGH,SAAS,CAACtK,MAArB;;cAEA,OAAO,CAACyK,QAAQ,IAAI,CAAb,KAAmB,CAA1B,EAA6B;gBAC3B,IAAI,CAACH,SAAS,CAACG,QAAD,CAAd,EAA0B;kBACxB;gBACD;;gBAED,IAAIP,UAAU,CAACC,QAAD,EAAWO,UAAU,CAAC5H,OAAD,CAArB,CAAd,EAA+C;kBAC7C4F,OAAO,GAAG,IAAIT,OAAJ,CAAYqC,SAAS,CAACG,QAAD,CAArB,EAAiC,CAAClI,GAAD,EAAMkI,QAAN,CAAjC,EAAkD,UAAlD,EAA8D,IAAI9C,SAAJ,CAAc2C,SAAd,EAAyBG,QAAzB,CAA9D,CAAV;gBACD,CAFD,MAEO,IAAIR,MAAM,CAACK,SAAS,CAACG,QAAD,CAAV,CAAV,EAAiC;kBACtC/B,OAAO,GAAG,IAAIT,OAAJ,CAAYqC,SAAS,CAACG,QAAD,CAArB,EAAiC,CAAClI,GAAD,EAAMkI,QAAN,CAAjC,EAAkD,IAAlD,EAAwD,IAAI9C,SAAJ,CAAc2C,SAAd,EAAyBG,QAAzB,CAAxD,CAAV;gBACD,CAFM,MAEA;kBACL;gBACD;;gBAEDD,QAAQ,CAAC1K,IAAT,CAAc4I,OAAd;cACD;YACF,CAlBD,MAkBO,IAAIuB,MAAM,CAACK,SAAD,CAAV,EAAuB;cAC5BE,QAAQ,CAAC1K,IAAT,CAAc,IAAImI,OAAJ,CAAYqC,SAAZ,EAAuB/H,GAAvB,EAA4B,IAA5B,EAAkC,IAAIoF,SAAJ,CAAcG,IAAd,EAAoBvF,GAApB,CAAlC,CAAd;YACD;UACF;QACF;;QAED,OAAO0I,KAAK,CAACzB,IAAb;MACD,CA/ID;;MAiJA,SAASe,QAAT,CAAkBf,IAAlB,EAAwBC,OAAxB,EAAiC;QAC/B,IAAI2B,UAAU,GAAG,IAAI/C,UAAJ,EAAjB;QACA,OAAO+C,UAAU,CAACb,QAAX,CAAoBf,IAApB,EAA0BC,OAA1B,CAAP;MACD;;MAED,SAAS5B,OAAT,CAAiB2B,IAAjB,EAAuBC,OAAvB,EAAgC;QAC9B,IAAI2B,UAAU,GAAG,IAAI/C,UAAJ,EAAjB;QACA,OAAO+C,UAAU,CAACvD,OAAX,CAAmB2B,IAAnB,EAAyBC,OAAzB,CAAP;MACD;;MAED,SAAS4B,kBAAT,CAA4BC,OAA5B,EAAqCC,MAArC,EAA6C;QAC3C,IAAIP,MAAJ;QACAA,MAAM,GAAGtI,UAAU,CAAC6I,MAAD,EAAS,SAASC,MAAT,CAAgBC,KAAhB,EAAuB;UACjD,OAAOA,KAAK,CAACC,KAAN,CAAY,CAAZ,IAAiBJ,OAAO,CAACI,KAAR,CAAc,CAAd,CAAxB;QACD,CAFkB,CAAnB;QAGAJ,OAAO,CAACK,aAAR,GAAwB,CAACL,OAAO,CAACI,KAAR,CAAc,CAAd,CAAD,EAAmBJ,OAAO,CAACI,KAAR,CAAc,CAAd,CAAnB,CAAxB;;QAEA,IAAIV,MAAM,KAAKO,MAAM,CAACvL,MAAtB,EAA8B;UAC5BsL,OAAO,CAACK,aAAR,CAAsB,CAAtB,IAA2BJ,MAAM,CAACP,MAAD,CAAN,CAAeU,KAAf,CAAqB,CAArB,CAA3B;QACD;;QAEDV,MAAM,IAAI,CAAV;;QAEA,IAAIA,MAAM,IAAI,CAAd,EAAiB;UACfM,OAAO,CAACK,aAAR,CAAsB,CAAtB,IAA2BJ,MAAM,CAACP,MAAD,CAAN,CAAeU,KAAf,CAAqB,CAArB,CAA3B;QACD;;QAED,OAAOJ,OAAP;MACD;;MAED,SAASM,cAAT,CAAwBC,IAAxB,EAA8BC,gBAA9B,EAAgDP,MAAhD,EAAwD;QACtD;QACA,IAAIQ,QAAQ,GAAG,EAAf;QAAA,IACIT,OADJ;QAAA,IAEI5K,GAFJ;QAAA,IAGIpC,CAHJ;QAAA,IAII0N,MAJJ;;QAMA,IAAI,CAACH,IAAI,CAACH,KAAV,EAAiB;UACf,MAAM,IAAIX,KAAJ,CAAU,wCAAV,CAAN;QACD,CAVqD,CAUpD;;;QAGF,IAAI,CAACQ,MAAM,CAACvL,MAAZ,EAAoB;UAClB,IAAI8L,gBAAgB,CAAC9L,MAArB,EAA6B;YAC3B,KAAK1B,CAAC,GAAG,CAAJ,EAAOoC,GAAG,GAAGoL,gBAAgB,CAAC9L,MAAnC,EAA2C1B,CAAC,GAAGoC,GAA/C,EAAoDpC,CAAC,IAAI,CAAzD,EAA4D;cAC1DgN,OAAO,GAAGjJ,QAAQ,CAACyJ,gBAAgB,CAACxN,CAAD,CAAjB,CAAlB;cACAgN,OAAO,CAACK,aAAR,GAAwB,CAAC,CAAD,EAAIE,IAAI,CAACH,KAAL,CAAW,CAAX,CAAJ,CAAxB;cACAK,QAAQ,CAACjM,IAAT,CAAcwL,OAAd;YACD;;YAEDO,IAAI,CAACI,eAAL,GAAuBF,QAAvB;UACD;;UAED,OAAOF,IAAP;QACD;;QAED,KAAKvN,CAAC,GAAG,CAAJ,EAAOoC,GAAG,GAAGoL,gBAAgB,CAAC9L,MAAnC,EAA2C1B,CAAC,GAAGoC,GAA/C,EAAoDpC,CAAC,IAAI,CAAzD,EAA4D;UAC1DyN,QAAQ,CAACjM,IAAT,CAAcuL,kBAAkB,CAAChJ,QAAQ,CAACyJ,gBAAgB,CAACxN,CAAD,CAAjB,CAAT,EAAgCiN,MAAhC,CAAhC;QACD,CA7BqD,CA6BpD;;;QAGFS,MAAM,GAAG,CAAT;QACAzB,QAAQ,CAACsB,IAAD,EAAO;UACbf,KAAK,EAAE,UAAUhD,IAAV,EAAgB;YACrB,IAAIwD,OAAJ;;YAEA,OAAOU,MAAM,GAAGD,QAAQ,CAAC/L,MAAzB,EAAiC;cAC/BsL,OAAO,GAAGS,QAAQ,CAACC,MAAD,CAAlB;;cAEA,IAAIV,OAAO,CAACK,aAAR,CAAsB,CAAtB,IAA2B7D,IAAI,CAAC4D,KAAL,CAAW,CAAX,CAA/B,EAA8C;gBAC5C;cACD;;cAED,IAAIJ,OAAO,CAACK,aAAR,CAAsB,CAAtB,MAA6B7D,IAAI,CAAC4D,KAAL,CAAW,CAAX,CAAjC,EAAgD;gBAC9C,IAAI,CAAC5D,IAAI,CAACmE,eAAV,EAA2B;kBACzBnE,IAAI,CAACmE,eAAL,GAAuB,EAAvB;gBACD;;gBAEDnE,IAAI,CAACmE,eAAL,CAAqBnM,IAArB,CAA0BwL,OAA1B;gBACAS,QAAQ,CAAC/D,MAAT,CAAgBgE,MAAhB,EAAwB,CAAxB;cACD,CAPD,MAOO;gBACLA,MAAM,IAAI,CAAV;cACD;YACF,CApBoB,CAoBnB;;;YAGF,IAAIA,MAAM,KAAKD,QAAQ,CAAC/L,MAAxB,EAAgC;cAC9B,OAAOgC,aAAa,CAACwF,KAArB;YACD;;YAED,IAAIuE,QAAQ,CAACC,MAAD,CAAR,CAAiBL,aAAjB,CAA+B,CAA/B,IAAoC7D,IAAI,CAAC4D,KAAL,CAAW,CAAX,CAAxC,EAAuD;cACrD,OAAO1J,aAAa,CAACyF,IAArB;YACD;UACF;QA/BY,CAAP,CAAR;QAiCAuE,MAAM,GAAG,CAAT;QACAzB,QAAQ,CAACsB,IAAD,EAAO;UACbhB,KAAK,EAAE,UAAU/C,IAAV,EAAgB;YACrB,IAAIwD,OAAJ;;YAEA,OAAOU,MAAM,GAAGD,QAAQ,CAAC/L,MAAzB,EAAiC;cAC/BsL,OAAO,GAAGS,QAAQ,CAACC,MAAD,CAAlB;;cAEA,IAAIlE,IAAI,CAAC4D,KAAL,CAAW,CAAX,IAAgBJ,OAAO,CAACK,aAAR,CAAsB,CAAtB,CAApB,EAA8C;gBAC5C;cACD;;cAED,IAAI7D,IAAI,CAAC4D,KAAL,CAAW,CAAX,MAAkBJ,OAAO,CAACK,aAAR,CAAsB,CAAtB,CAAtB,EAAgD;gBAC9C,IAAI,CAAC7D,IAAI,CAACoE,gBAAV,EAA4B;kBAC1BpE,IAAI,CAACoE,gBAAL,GAAwB,EAAxB;gBACD;;gBAEDpE,IAAI,CAACoE,gBAAL,CAAsBpM,IAAtB,CAA2BwL,OAA3B;gBACAS,QAAQ,CAAC/D,MAAT,CAAgBgE,MAAhB,EAAwB,CAAxB;cACD,CAPD,MAOO;gBACLA,MAAM,IAAI,CAAV;cACD;YACF,CApBoB,CAoBnB;;;YAGF,IAAIA,MAAM,KAAKD,QAAQ,CAAC/L,MAAxB,EAAgC;cAC9B,OAAOgC,aAAa,CAACwF,KAArB;YACD;;YAED,IAAIuE,QAAQ,CAACC,MAAD,CAAR,CAAiBL,aAAjB,CAA+B,CAA/B,IAAoC7D,IAAI,CAAC4D,KAAL,CAAW,CAAX,CAAxC,EAAuD;cACrD,OAAO1J,aAAa,CAACyF,IAArB;YACD;UACF;QA/BY,CAAP,CAAR;QAiCA,OAAOoE,IAAP;MACD;;MAEDrO,OAAO,CAACuE,MAAR,GAAiBA,MAAjB;MACAvE,OAAO,CAAC+M,QAAR,GAAmBA,QAAnB;MACA/M,OAAO,CAACqK,OAAR,GAAkBA,OAAlB;MACArK,OAAO,CAACoO,cAAR,GAAyBA,cAAzB;MACApO,OAAO,CAACyE,WAAR,GAAsBA,WAAtB;MACAzE,OAAO,CAACwE,aAAR,GAAwBA,aAAxB;MACAxE,OAAO,CAAC6K,UAAR,GAAqBA,UAArB;;MAEA7K,OAAO,CAAC2O,gBAAR,GAA2B,YAAY;QACrC,OAAOrK,KAAK,CAAC,EAAD,CAAZ;MACD,CAFD;;MAIA,OAAOtE,OAAP;IACD,CApwBD,EAowBGA,OApwBH;IAqwBA;;EAED,CAtyBoC,CAArC;EAwyBA,IAAI4O,MAAM,GAAGzK,oBAAoB,CAAC,UAAUlE,MAAV,EAAkB;IAClD;AACJ;AACA;AACA;AACA;IACI,CAAC,UAAU+L,IAAV,EAAgBjM,OAAhB,EAAyB;MACxB,IAAKE,MAAM,CAACD,OAAZ,EAAqB;QACnBC,MAAM,CAACD,OAAP,GAAiBD,OAAO,EAAxB;MACD;IACF,CAJD,EAIGiE,cAJH,EAImB,YAAY;MAE7B,SAAS6K,YAAT,CAAsBC,KAAtB,EAA6B1E,MAA7B,EAAqC;QACnC,SAAS2E,IAAT,GAAgB;UACd,KAAKrO,WAAL,GAAmBoO,KAAnB;QACD;;QAEDC,IAAI,CAACpO,SAAL,GAAiByJ,MAAM,CAACzJ,SAAxB;QACAmO,KAAK,CAACnO,SAAN,GAAkB,IAAIoO,IAAJ,EAAlB;MACD;;MAED,SAASC,eAAT,CAAyBC,OAAzB,EAAkCC,QAAlC,EAA4CC,KAA5C,EAAmDC,QAAnD,EAA6D;QAC3D,KAAKH,OAAL,GAAeA,OAAf;QACA,KAAKC,QAAL,GAAgBA,QAAhB;QACA,KAAKC,KAAL,GAAaA,KAAb;QACA,KAAKC,QAAL,GAAgBA,QAAhB;QACA,KAAKpM,IAAL,GAAY,aAAZ;;QAEA,IAAI,OAAOuK,KAAK,CAAC8B,iBAAb,KAAmC,UAAvC,EAAmD;UACjD9B,KAAK,CAAC8B,iBAAN,CAAwB,IAAxB,EAA8BL,eAA9B;QACD;MACF;;MAEDH,YAAY,CAACG,eAAD,EAAkBzB,KAAlB,CAAZ;;MAEAyB,eAAe,CAACM,YAAhB,GAA+B,UAAUJ,QAAV,EAAoBC,KAApB,EAA2B;QACxD,IAAII,wBAAwB,GAAG;UAC7BC,OAAO,EAAE,SAASA,OAAT,CAAiBC,WAAjB,EAA8B;YACrC,OAAO,OAAOC,aAAa,CAACD,WAAW,CAACE,IAAb,CAApB,GAAyC,IAAhD;UACD,CAH4B;UAI7B,SAAS,SAASC,MAAT,CAAgBH,WAAhB,EAA6B;YACpC,IAAII,YAAY,GAAG,EAAnB;YAAA,IACI/O,CADJ;;YAGA,KAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG2O,WAAW,CAACK,KAAZ,CAAkBtN,MAAlC,EAA0C1B,CAAC,EAA3C,EAA+C;cAC7C+O,YAAY,IAAIJ,WAAW,CAACK,KAAZ,CAAkBhP,CAAlB,aAAgCS,KAAhC,GAAwCwO,WAAW,CAACN,WAAW,CAACK,KAAZ,CAAkBhP,CAAlB,EAAqB,CAArB,CAAD,CAAX,GAAuC,GAAvC,GAA6CiP,WAAW,CAACN,WAAW,CAACK,KAAZ,CAAkBhP,CAAlB,EAAqB,CAArB,CAAD,CAAhG,GAA4HiP,WAAW,CAACN,WAAW,CAACK,KAAZ,CAAkBhP,CAAlB,CAAD,CAAvJ;YACD;;YAED,OAAO,OAAO2O,WAAW,CAACO,QAAZ,GAAuB,GAAvB,GAA6B,EAApC,IAA0CH,YAA1C,GAAyD,GAAhE;UACD,CAb4B;UAc7BI,GAAG,EAAE,SAASA,GAAT,CAAaR,WAAb,EAA0B;YAC7B,OAAO,eAAP;UACD,CAhB4B;UAiB7BS,GAAG,EAAE,SAASA,GAAT,CAAaT,WAAb,EAA0B;YAC7B,OAAO,cAAP;UACD,CAnB4B;UAoB7BU,KAAK,EAAE,SAASA,KAAT,CAAeV,WAAf,EAA4B;YACjC,OAAOA,WAAW,CAACW,WAAnB;UACD;QAtB4B,CAA/B;;QAyBA,SAASC,GAAT,CAAaC,EAAb,EAAiB;UACf,OAAOA,EAAE,CAACC,UAAH,CAAc,CAAd,EAAiB1N,QAAjB,CAA0B,EAA1B,EAA8B2N,WAA9B,EAAP;QACD;;QAED,SAASd,aAAT,CAAuBjM,CAAvB,EAA0B;UACxB,OAAOA,CAAC,CAAC4G,OAAF,CAAU,KAAV,EAAiB,MAAjB,EAAyBA,OAAzB,CAAiC,IAAjC,EAAuC,KAAvC,EAA8CA,OAA9C,CAAsD,KAAtD,EAA6D,KAA7D,EAAoEA,OAApE,CAA4E,KAA5E,EAAmF,KAAnF,EAA0FA,OAA1F,CAAkG,KAAlG,EAAyG,KAAzG,EAAgHA,OAAhH,CAAwH,KAAxH,EAA+H,KAA/H,EAAsIA,OAAtI,CAA8I,cAA9I,EAA8J,UAAUiG,EAAV,EAAc;YACjL,OAAO,SAASD,GAAG,CAACC,EAAD,CAAnB;UACD,CAFM,EAEJjG,OAFI,CAEI,uBAFJ,EAE6B,UAAUiG,EAAV,EAAc;YAChD,OAAO,QAAQD,GAAG,CAACC,EAAD,CAAlB;UACD,CAJM,CAAP;QAKD;;QAED,SAASP,WAAT,CAAqBtM,CAArB,EAAwB;UACtB,OAAOA,CAAC,CAAC4G,OAAF,CAAU,KAAV,EAAiB,MAAjB,EAAyBA,OAAzB,CAAiC,KAAjC,EAAwC,KAAxC,EAA+CA,OAA/C,CAAuD,KAAvD,EAA8D,KAA9D,EAAqEA,OAArE,CAA6E,IAA7E,EAAmF,KAAnF,EAA0FA,OAA1F,CAAkG,KAAlG,EAAyG,KAAzG,EAAgHA,OAAhH,CAAwH,KAAxH,EAA+H,KAA/H,EAAsIA,OAAtI,CAA8I,KAA9I,EAAqJ,KAArJ,EAA4JA,OAA5J,CAAoK,KAApK,EAA2K,KAA3K,EAAkLA,OAAlL,CAA0L,cAA1L,EAA0M,UAAUiG,EAAV,EAAc;YAC7N,OAAO,SAASD,GAAG,CAACC,EAAD,CAAnB;UACD,CAFM,EAEJjG,OAFI,CAEI,uBAFJ,EAE6B,UAAUiG,EAAV,EAAc;YAChD,OAAO,QAAQD,GAAG,CAACC,EAAD,CAAlB;UACD,CAJM,CAAP;QAKD;;QAED,SAASG,mBAAT,CAA6BhB,WAA7B,EAA0C;UACxC,OAAOF,wBAAwB,CAACE,WAAW,CAACnE,IAAb,CAAxB,CAA2CmE,WAA3C,CAAP;QACD;;QAED,SAASiB,gBAAT,CAA0BxB,QAA1B,EAAoC;UAClC,IAAIyB,YAAY,GAAG,IAAIpP,KAAJ,CAAU2N,QAAQ,CAAC1M,MAAnB,CAAnB;UAAA,IACI1B,CADJ;UAAA,IAEIiK,CAFJ;;UAIA,KAAKjK,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGoO,QAAQ,CAAC1M,MAAzB,EAAiC1B,CAAC,EAAlC,EAAsC;YACpC6P,YAAY,CAAC7P,CAAD,CAAZ,GAAkB2P,mBAAmB,CAACvB,QAAQ,CAACpO,CAAD,CAAT,CAArC;UACD;;UAED6P,YAAY,CAACC,IAAb;;UAEA,IAAID,YAAY,CAACnO,MAAb,GAAsB,CAA1B,EAA6B;YAC3B,KAAK1B,CAAC,GAAG,CAAJ,EAAOiK,CAAC,GAAG,CAAhB,EAAmBjK,CAAC,GAAG6P,YAAY,CAACnO,MAApC,EAA4C1B,CAAC,EAA7C,EAAiD;cAC/C,IAAI6P,YAAY,CAAC7P,CAAC,GAAG,CAAL,CAAZ,KAAwB6P,YAAY,CAAC7P,CAAD,CAAxC,EAA6C;gBAC3C6P,YAAY,CAAC5F,CAAD,CAAZ,GAAkB4F,YAAY,CAAC7P,CAAD,CAA9B;gBACAiK,CAAC;cACF;YACF;;YAED4F,YAAY,CAACnO,MAAb,GAAsBuI,CAAtB;UACD;;UAED,QAAQ4F,YAAY,CAACnO,MAArB;YACE,KAAK,CAAL;cACE,OAAOmO,YAAY,CAAC,CAAD,CAAnB;;YAEF,KAAK,CAAL;cACE,OAAOA,YAAY,CAAC,CAAD,CAAZ,GAAkB,MAAlB,GAA2BA,YAAY,CAAC,CAAD,CAA9C;;YAEF;cACE,OAAOA,YAAY,CAAC5N,KAAb,CAAmB,CAAnB,EAAsB,CAAC,CAAvB,EAA0B8N,IAA1B,CAA+B,IAA/B,IAAuC,OAAvC,GAAiDF,YAAY,CAACA,YAAY,CAACnO,MAAb,GAAsB,CAAvB,CAApE;UARJ;QAUD;;QAED,SAASsO,aAAT,CAAuB3B,KAAvB,EAA8B;UAC5B,OAAOA,KAAK,GAAG,OAAOO,aAAa,CAACP,KAAD,CAApB,GAA8B,IAAjC,GAAwC,cAApD;QACD;;QAED,OAAO,cAAcuB,gBAAgB,CAACxB,QAAD,CAA9B,GAA2C,OAA3C,GAAqD4B,aAAa,CAAC3B,KAAD,CAAlE,GAA4E,SAAnF;MACD,CAzFD;;MA2FA,SAAS4B,SAAT,CAAmBC,KAAnB,EAA0BC,OAA1B,EAAmC;QACjCA,OAAO,GAAGA,OAAO,KAAK,KAAK,CAAjB,GAAqBA,OAArB,GAA+B,EAAzC;;QAEA,IAAIC,UAAU,GAAG,EAAjB;QAAA,IACIC,sBAAsB,GAAG;UAC3BC,KAAK,EAAEC;QADoB,CAD7B;QAAA,IAIIC,qBAAqB,GAAGD,cAJ5B;QAAA,IAKIE,MAAM,GAAG,SAASA,MAAT,CAAgBC,EAAhB,EAAoB;UAC/B,OAAOA,EAAE,CAAChP,MAAH,KAAc,CAAd,GAAkBgP,EAAE,CAAC,CAAD,CAApB,GAA0B;YAC/BlG,IAAI,EAAE,SADyB;YAE/BmG,SAAS,EAAED;UAFoB,CAAjC;QAID,CAVD;QAAA,IAWIE,MAAM,GAAG,SAASA,MAAT,GAAkB;UAC7B,OAAO,KAAK,CAAZ;QACD,CAbD;QAAA,IAcIC,MAAM,GAAG,GAdb;QAAA,IAeIC,MAAM,GAAGC,sBAAsB,CAAC,GAAD,EAAM,KAAN,CAfnC;QAAA,IAgBIC,MAAM,GAAG,sBAhBb;QAAA,IAiBIC,MAAM,GAAGC,oBAAoB,CAAC,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B,EAA+B,GAA/B,EAAoC,GAApC,EAAyC,GAAzC,EAA8C,GAA9C,EAAmD,GAAnD,EAAwD,GAAxD,EAA6D,GAA7D,EAAkE,GAAlE,EAAuE,GAAvE,CAAD,EAA8E,IAA9E,EAAoF,KAApF,CAjBjC;QAAA,IAkBIC,MAAM,GAAG,SAASA,MAAT,CAAgBnR,CAAhB,EAAmB;UAC9B,OAAOA,CAAC,CAAC+P,IAAF,CAAO,EAAP,CAAP;QACD,CApBD;QAAA,IAqBIqB,MAAM,GAAG,GArBb;QAAA,IAsBIC,MAAM,GAAGN,sBAAsB,CAAC,GAAD,EAAM,KAAN,CAtBnC;QAAA,IAuBIO,MAAM,GAAG,SAASA,MAAT,GAAkB;UAC7B,OAAO,OAAP;QACD,CAzBD;QAAA,IA0BIC,OAAO,GAAG,GA1Bd;QAAA,IA2BIC,OAAO,GAAGT,sBAAsB,CAAC,GAAD,EAAM,KAAN,CA3BpC;QAAA,IA4BIU,OAAO,GAAG,SAASA,OAAT,GAAmB;UAC/B,OAAO,SAAP;QACD,CA9BD;QAAA,IA+BIC,OAAO,GAAG,GA/Bd;QAAA,IAgCIC,OAAO,GAAGZ,sBAAsB,CAAC,GAAD,EAAM,KAAN,CAhCpC;QAAA,IAiCIa,OAAO,GAAG,SAASA,OAAT,GAAmB;UAC/B,OAAO,UAAP;QACD,CAnCD;QAAA,IAoCIC,OAAO,GAAG,SAASA,OAAT,GAAmB;UAC/B,OAAO,YAAP;QACD,CAtCD;QAAA,IAuCIC,OAAO,GAAG,GAvCd;QAAA,IAwCIC,OAAO,GAAGhB,sBAAsB,CAAC,GAAD,EAAM,KAAN,CAxCpC;QAAA,IAyCIiB,OAAO,GAAG,SAASA,OAAT,CAAiBrP,CAAjB,EAAoB+N,EAApB,EAAwB;UACpC,OAAO,CAAC/N,CAAD,EAAIsP,MAAJ,CAAWvB,EAAE,CAACwB,GAAH,CAAO,UAAUvP,CAAV,EAAa;YACpC,OAAOA,CAAC,CAAC,CAAD,CAAR;UACD,CAFiB,CAAX,CAAP;QAGD,CA7CD;QAAA,IA8CIwP,OAAO,GAAG,SAASA,OAAT,CAAiBC,CAAjB,EAAoBC,GAApB,EAAyB;UACrC,OAAOA,GAAG,CAACC,MAAJ,CAAW,UAAUC,IAAV,EAAgBC,GAAhB,EAAqB;YACrC,OAAO;cACLhI,IAAI,EAAEgI,GAAG,CAAC,CAAD,CADJ;cAELC,IAAI,EAAEF,IAFD;cAGLG,KAAK,EAAEF,GAAG,CAAC,CAAD;YAHL,CAAP;UAKD,CANM,EAMJJ,CANI,CAAP;QAOD,CAtDD;QAAA,IAuDIO,OAAO,GAAG,GAvDd;QAAA,IAwDIC,OAAO,GAAG7B,sBAAsB,CAAC,GAAD,EAAM,KAAN,CAxDpC;QAAA,IAyDI8B,OAAO,GAAG,SAASA,OAAT,CAAiBC,OAAjB,EAA0BC,EAA1B,EAA8B;UAC1C,IAAIC,CAAC,GAAGD,EAAE,CAACrR,MAAH,KAAc,CAAd,GAAkBqR,EAAE,CAAC,CAAD,CAApB,GAA0B;YAChCvI,IAAI,EAAE,UAD0B;YAEhCmG,SAAS,EAAEoC;UAFqB,CAAlC;UAIA,IAAID,OAAJ,EAAaE,CAAC,CAACF,OAAF,GAAY,IAAZ;UACb,OAAOE,CAAP;QACD,CAhED;QAAA,IAiEIC,OAAO,GAAG,GAjEd;QAAA,IAkEIC,OAAO,GAAGnC,sBAAsB,CAAC,GAAD,EAAM,KAAN,CAlEpC;QAAA,IAmEIoC,OAAO,GAAG,SAASA,OAAT,CAAiBf,CAAjB,EAAoB;UAChC,OAAO;YACL5H,IAAI,EAAE,UADD;YAEL/I,KAAK,EAAE2Q;UAFF,CAAP;QAID,CAxED;QAAA,IAyEIgB,OAAO,GAAG,GAzEd;QAAA,IA0EIC,OAAO,GAAGtC,sBAAsB,CAAC,GAAD,EAAM,KAAN,CA1EpC;QAAA,IA2EIuC,OAAO,GAAG,SAASA,OAAT,CAAiBtT,CAAjB,EAAoB;UAChC,OAAO;YACLwK,IAAI,EAAE,YADD;YAEL/I,KAAK,EAAEzB;UAFF,CAAP;QAID,CAhFD;QAAA,IAiFIuT,OAAO,GAAG,GAjFd;QAAA,IAkFIC,OAAO,GAAGzC,sBAAsB,CAAC,GAAD,EAAM,KAAN,CAlFpC;QAAA,IAmFI0C,OAAO,GAAG,GAnFd;QAAA,IAoFIC,OAAO,GAAG3C,sBAAsB,CAAC,GAAD,EAAM,KAAN,CApFpC;QAAA,IAqFI4C,OAAO,GAAG,SAASA,OAAT,CAAiBC,CAAjB,EAAoB;UAChC,OAAOA,CAAP;QACD,CAvFD;QAAA,IAwFIC,OAAO,GAAG,QAxFd;QAAA,IAyFIC,OAAO,GAAG5C,oBAAoB,CAAC,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAD,EAAkB,KAAlB,EAAyB,KAAzB,CAzFlC;QAAA,IA0FI6C,OAAO,GAAG,GA1Fd;QAAA,IA2FIC,OAAO,GAAGjD,sBAAsB,CAAC,GAAD,EAAM,KAAN,CA3FpC;QAAA,IA4FIkD,OAAO,GAAG,SAASA,OAAT,CAAiB7B,CAAjB,EAAoB;UAChC,OAAO,CAACA,CAAC,IAAI,EAAN,IAAY,GAAnB;QACD,CA9FD;QAAA,IA+FI8B,OAAO,GAAG,OA/Fd;QAAA,IAgGIC,OAAO,GAAGjD,oBAAoB,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,KAAb,EAAoB,KAApB,CAhGlC;QAAA,IAiGIkD,OAAO,GAAG,GAjGd;QAAA,IAkGIC,OAAO,GAAGtD,sBAAsB,CAAC,GAAD,EAAM,KAAN,CAlGpC;QAAA,IAmGIuD,OAAO,GAAG,SAASA,OAAT,CAAiBlC,CAAjB,EAAoBW,EAApB,EAAwB;UACpC,OAAO,GAAGd,MAAH,CAAUsC,KAAV,CAAgB,CAACnC,CAAD,CAAhB,EAAqBW,EAArB,EAAyBhD,IAAzB,CAA8B,EAA9B,CAAP;QACD,CArGD;QAAA,IAsGIyE,OAAO,GAAG,SAASA,OAAT,CAAiBtS,IAAjB,EAAuBuS,EAAvB,EAA2BhT,KAA3B,EAAkC;UAC9C,OAAO;YACL+I,IAAI,EAAE,WADD;YAELtI,IAAI,EAAEA,IAFD;YAGLwS,QAAQ,EAAED,EAHL;YAILhT,KAAK,EAAEA;UAJF,CAAP;QAMD,CA7GD;QAAA,IA8GIkT,OAAO,GAAG,SAASA,OAAT,CAAiBzS,IAAjB,EAAuB;UACnC,OAAO;YACLsI,IAAI,EAAE,WADD;YAELtI,IAAI,EAAEA;UAFD,CAAP;QAID,CAnHD;QAAA,IAoHI0S,OAAO,GAAG,IApHd;QAAA,IAqHIC,OAAO,GAAG9D,sBAAsB,CAAC,IAAD,EAAO,KAAP,CArHpC;QAAA,IAsHI+D,OAAO,GAAG,SAtHd;QAAA,IAuHIC,OAAO,GAAG7D,oBAAoB,CAAC,CAAC,IAAD,EAAO,IAAP,CAAD,EAAe,IAAf,EAAqB,KAArB,CAvHlC;QAAA,IAwHI8D,OAAO,GAAG,IAxHd;QAAA,IAyHIC,OAAO,GAAGlE,sBAAsB,CAAC,IAAD,EAAO,KAAP,CAzHpC;QAAA,IA0HImE,OAAO,GAAGC,kBAAkB,EA1HhC;QAAA,IA2HIC,OAAO,GAAG,SAASA,OAAT,CAAiBhD,CAAjB,EAAoBY,CAApB,EAAuB;UACnC,OAAOZ,CAAC,GAAGY,CAAX;QACD,CA7HD;QAAA,IA8HIqC,OAAO,GAAG,SAASA,OAAT,CAAiBC,CAAjB,EAAoB;UAChC,OAAO;YACL9K,IAAI,EAAE,SADD;YAEL/I,KAAK,EAAE8T,WAAW,CAACD,CAAC,CAACvF,IAAF,CAAO,EAAP,CAAD;UAFb,CAAP;QAID,CAnID;QAAA,IAoIIyF,OAAO,GAAG,GApId;QAAA,IAqIIC,OAAO,GAAG1E,sBAAsB,CAAC,GAAD,EAAM,KAAN,CArIpC;QAAA,IAsII2E,OAAO,GAAG,SAtId;QAAA,IAuIIC,OAAO,GAAGzE,oBAAoB,CAAC,CAAC,IAAD,EAAO,GAAP,CAAD,EAAc,IAAd,EAAoB,KAApB,CAvIlC;QAAA,IAwII0E,OAAO,GAAG,QAxId;QAAA,IAyIIC,OAAO,GAAG3E,oBAAoB,CAAC,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,CAAD,EAAe,KAAf,EAAsB,KAAtB,CAzIlC;QAAA,IA0II4E,OAAO,GAAG,SAASA,OAAT,CAAiB1D,CAAjB,EAAoBY,CAApB,EAAuB;UACnC;UACA,IAAI+C,eAAe,GAAG3D,CAAC,GAAG,GAAGH,MAAH,CAAUsC,KAAV,CAAgB,EAAhB,EAAoBnC,CAApB,EAAuBrC,IAAvB,CAA4B,EAA5B,CAAH,GAAqC,EAA5D;UACA,OAAO;YACLvF,IAAI,EAAE,SADD;YAEL/I,KAAK,EAAEuU,UAAU,CAACD,eAAe,GAAG/C,CAAC,CAACjD,IAAF,CAAO,EAAP,CAAnB;UAFZ,CAAP;QAID,CAjJD;QAAA,IAkJIkG,OAAO,GAAG,SAASA,OAAT,CAAiBjW,CAAjB,EAAoB;UAChC,OAAO;YACLwK,IAAI,EAAE,SADD;YAEL/I,KAAK,EAAEzB;UAFF,CAAP;QAID,CAvJD;QAAA,IAwJIkW,OAAO,GAAG,OAxJd;QAAA,IAyJIC,OAAO,GAAGpF,sBAAsB,CAAC,OAAD,EAAU,KAAV,CAzJpC;QAAA,IA0JIqF,OAAO,GAAG,QA1Jd;QAAA,IA2JIC,OAAO,GAAGnF,oBAAoB,CAAC,CAAC,GAAD,EAAM,GAAN,CAAD,EAAa,IAAb,EAAmB,KAAnB,CA3JlC;QAAA,IA4JIoF,OAAO,GAAG,GA5Jd;QAAA,IA6JIC,OAAO,GAAGxF,sBAAsB,CAAC,GAAD,EAAM,KAAN,CA7JpC;QAAA,IA8JIyF,OAAO,GAAG,SAASA,OAAT,CAAiBC,CAAjB,EAAoB;UAChC,OAAO;YACLjM,IAAI,EAAE,MADD;YAEL/I,KAAK,EAAEgV,CAAC,CAAC1G,IAAF,CAAO,EAAP;UAFF,CAAP;QAID,CAnKD;QAAA,IAoKI2G,OAAO,GAAG,SApKd;QAAA,IAqKIC,OAAO,GAAGzF,oBAAoB,CAAC,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,CAAD,EAAuB,KAAvB,EAA8B,KAA9B,CArKlC;QAAA,IAsKI0F,OAAO,GAAG,GAtKd;QAAA,IAuKIC,OAAO,GAAG9F,sBAAsB,CAAC,GAAD,EAAM,KAAN,CAvKpC;QAAA,IAwKI+F,OAAO,GAAG,QAxKd;QAAA,IAyKIC,OAAO,GAAG7F,oBAAoB,CAAC,CAAC,GAAD,CAAD,EAAQ,IAAR,EAAc,KAAd,CAzKlC;QAAA,IA0KI8F,OAAO,GAAG,SAASA,OAAT,CAAiB1B,CAAjB,EAAoB2B,IAApB,EAA0B;UACtC,OAAO;YACLzM,IAAI,EAAE,QADD;YAEL/I,KAAK,EAAE,IAAIyV,MAAJ,CAAW5B,CAAC,CAACvF,IAAF,CAAO,EAAP,CAAX,EAAuBkH,IAAI,GAAGA,IAAI,CAAClH,IAAL,CAAU,EAAV,CAAH,GAAmB,EAA9C;UAFF,CAAP;QAID,CA/KD;QAAA,IAgLIoH,OAAO,GAAG,SAASA,OAAT,CAAiBnX,CAAjB,EAAoBoX,EAApB,EAAwB;UACpC,OAAO;YACL5M,IAAI,EAAE,OADD;YAELtI,IAAI,EAAEkV,EAAE,CAAC9E,MAAH,CAAU,UAAUC,IAAV,EAAgB8E,CAAhB,EAAmB;cACjC,OAAO9E,IAAI,GAAG8E,CAAC,CAAC,CAAD,CAAR,GAAcA,CAAC,CAAC,CAAD,CAAtB;YACD,CAFK,EAEHrX,CAFG;UAFD,CAAP;QAMD,CAvLD;QAAA,IAwLIsX,OAAO,GAAG,OAxLd;QAAA,IAyLIC,OAAO,GAAGxG,sBAAsB,CAAC,OAAD,EAAU,KAAV,CAzLpC;QAAA,IA0LIyG,OAAO,GAAG,SAASA,OAAT,CAAiB9G,EAAjB,EAAqB;UACjC,OAAO;YACLlG,IAAI,EAAE,KADD;YAELmG,SAAS,EAAED;UAFN,CAAP;QAID,CA/LD;QAAA,IAgMI+G,OAAO,GAAG,WAhMd;QAAA,IAiMIC,OAAO,GAAG3G,sBAAsB,CAAC,WAAD,EAAc,KAAd,CAjMpC;QAAA,IAkMI4G,OAAO,GAAG,SAASA,OAAT,CAAiBjH,EAAjB,EAAqB;UACjC,OAAO;YACLlG,IAAI,EAAE,SADD;YAELmG,SAAS,EAAED;UAFN,CAAP;QAID,CAvMD;QAAA,IAwMIkH,OAAO,GAAG,OAxMd;QAAA,IAyMIC,OAAO,GAAG9G,sBAAsB,CAAC,OAAD,EAAU,KAAV,CAzMpC;QAAA,IA0MI+G,OAAO,GAAG,SAASA,OAAT,CAAiBpH,EAAjB,EAAqB;UACjC,OAAO;YACLlG,IAAI,EAAE,KADD;YAELmG,SAAS,EAAED;UAFN,CAAP;QAID,CA/MD;QAAA,IAgNIqH,OAAO,GAAG,cAhNd;QAAA,IAiNIC,OAAO,GAAGjH,sBAAsB,CAAC,cAAD,EAAiB,KAAjB,CAjNpC;QAAA,IAkNIkH,OAAO,GAAG,SAASA,OAAT,GAAmB;UAC/B,OAAOC,GAAG,CAAC,CAAD,CAAV;QACD,CApND;QAAA,IAqNIC,OAAO,GAAG,aArNd;QAAA,IAsNIC,OAAO,GAAGrH,sBAAsB,CAAC,aAAD,EAAgB,KAAhB,CAtNpC;QAAA,IAuNIsH,OAAO,GAAG,SAASA,OAAT,GAAmB;UAC/B,OAAOC,OAAO,CAAC,CAAD,CAAd;QACD,CAzND;QAAA,IA0NIC,OAAO,GAAG,aA1Nd;QAAA,IA2NIC,OAAO,GAAGzH,sBAAsB,CAAC,aAAD,EAAgB,KAAhB,CA3NpC;QAAA,IA4NI0H,OAAO,GAAG,SAASA,OAAT,CAAiB3W,CAAjB,EAAoB;UAChC,OAAOoW,GAAG,CAACQ,QAAQ,CAAC5W,CAAC,CAACiO,IAAF,CAAO,EAAP,CAAD,EAAa,EAAb,CAAT,CAAV;QACD,CA9ND;QAAA,IA+NI4I,OAAO,GAAG,kBA/Nd;QAAA,IAgOIC,OAAO,GAAG7H,sBAAsB,CAAC,kBAAD,EAAqB,KAArB,CAhOpC;QAAA,IAiOI8H,OAAO,GAAG,SAASA,OAAT,CAAiB/W,CAAjB,EAAoB;UAChC,OAAOwW,OAAO,CAACI,QAAQ,CAAC5W,CAAC,CAACiO,IAAF,CAAO,EAAP,CAAD,EAAa,EAAb,CAAT,CAAd;QACD,CAnOD;QAAA,IAoOI+I,QAAQ,GAAG,GApOf;QAAA,IAqOIC,QAAQ,GAAGhI,sBAAsB,CAAC,GAAD,EAAM,KAAN,CArOrC;QAAA,IAsOIiI,QAAQ,GAAG,WAtOf;QAAA,IAuOIC,QAAQ,GAAGlI,sBAAsB,CAAC,WAAD,EAAc,IAAd,CAvOrC;QAAA,IAwOImI,QAAQ,GAAG,YAxOf;QAAA,IAyOIC,QAAQ,GAAGpI,sBAAsB,CAAC,YAAD,EAAe,IAAf,CAzOrC;QAAA,IA0OIqI,QAAQ,GAAG,aA1Of;QAAA,IA2OIC,QAAQ,GAAGtI,sBAAsB,CAAC,aAAD,EAAgB,IAAhB,CA3OrC;QAAA,IA4OIuI,QAAQ,GAAG,UA5Of;QAAA,IA6OIC,QAAQ,GAAGxI,sBAAsB,CAAC,UAAD,EAAa,IAAb,CA7OrC;QAAA,IA8OIyI,QAAQ,GAAG,SA9Of;QAAA,IA+OIC,QAAQ,GAAG1I,sBAAsB,CAAC,SAAD,EAAY,IAAZ,CA/OrC;QAAA,IAgPI2I,QAAQ,GAAG,SAASA,QAAT,CAAkBC,CAAlB,EAAqB;UAClC,OAAO;YACLnP,IAAI,EAAE,OADD;YAELtI,IAAI,EAAEyX;UAFD,CAAP;QAID,CArPD;QAAA,IAsPIC,WAAW,GAAG,CAtPlB;QAAA,IAuPIC,mBAAmB,GAAG,CAAC;UACzBC,IAAI,EAAE,CADmB;UAEzBC,MAAM,EAAE;QAFiB,CAAD,CAvP1B;QAAA,IA2PIC,cAAc,GAAG,CA3PrB;QAAA,IA4PIC,mBAAmB,GAAG,EA5P1B;QAAA,IA6PIC,gBAAgB,GAAG,EA7PvB;QAAA,IA8PIC,UA9PJ;;QAgQA,IAAI,eAAehK,OAAnB,EAA4B;UAC1B,IAAI,EAAEA,OAAO,CAACiK,SAAR,IAAqB/J,sBAAvB,CAAJ,EAAoD;YAClD,MAAM,IAAI5D,KAAJ,CAAU,qCAAqC0D,OAAO,CAACiK,SAA7C,GAAyD,KAAnE,CAAN;UACD;;UAED5J,qBAAqB,GAAGH,sBAAsB,CAACF,OAAO,CAACiK,SAAT,CAA9C;QACD;;QAED,SAASrJ,sBAAT,CAAgClC,IAAhC,EAAsCwL,UAAtC,EAAkD;UAChD,OAAO;YACL7P,IAAI,EAAE,SADD;YAELqE,IAAI,EAAEA,IAFD;YAGLwL,UAAU,EAAEA;UAHP,CAAP;QAKD;;QAED,SAASnJ,oBAAT,CAA8BlC,KAA9B,EAAqCE,QAArC,EAA+CmL,UAA/C,EAA2D;UACzD,OAAO;YACL7P,IAAI,EAAE,OADD;YAELwE,KAAK,EAAEA,KAFF;YAGLE,QAAQ,EAAEA,QAHL;YAILmL,UAAU,EAAEA;UAJP,CAAP;QAMD;;QAED,SAASlF,kBAAT,GAA8B;UAC5B,OAAO;YACL3K,IAAI,EAAE;UADD,CAAP;QAGD;;QAED,SAAS8P,kBAAT,GAA8B;UAC5B,OAAO;YACL9P,IAAI,EAAE;UADD,CAAP;QAGD;;QAED,SAAS+P,qBAAT,CAA+BC,GAA/B,EAAoC;UAClC,IAAIC,OAAO,GAAGZ,mBAAmB,CAACW,GAAD,CAAjC;UAAA,IACInD,CADJ;;UAGA,IAAIoD,OAAJ,EAAa;YACX,OAAOA,OAAP;UACD,CAFD,MAEO;YACLpD,CAAC,GAAGmD,GAAG,GAAG,CAAV;;YAEA,OAAO,CAACX,mBAAmB,CAACxC,CAAD,CAA3B,EAAgC;cAC9BA,CAAC;YACF;;YAEDoD,OAAO,GAAGZ,mBAAmB,CAACxC,CAAD,CAA7B;YACAoD,OAAO,GAAG;cACRX,IAAI,EAAEW,OAAO,CAACX,IADN;cAERC,MAAM,EAAEU,OAAO,CAACV;YAFR,CAAV;;YAKA,OAAO1C,CAAC,GAAGmD,GAAX,EAAgB;cACd,IAAItK,KAAK,CAACT,UAAN,CAAiB4H,CAAjB,MAAwB,EAA5B,EAAgC;gBAC9BoD,OAAO,CAACX,IAAR;gBACAW,OAAO,CAACV,MAAR,GAAiB,CAAjB;cACD,CAHD,MAGO;gBACLU,OAAO,CAACV,MAAR;cACD;;cAED1C,CAAC;YACF;;YAEDwC,mBAAmB,CAACW,GAAD,CAAnB,GAA2BC,OAA3B;YACA,OAAOA,OAAP;UACD;QACF;;QAED,SAASC,mBAAT,CAA6BC,QAA7B,EAAuCC,MAAvC,EAA+C;UAC7C,IAAIC,eAAe,GAAGN,qBAAqB,CAACI,QAAD,CAA3C;UAAA,IACIG,aAAa,GAAGP,qBAAqB,CAACK,MAAD,CADzC;UAEA,OAAO;YACLtK,KAAK,EAAE;cACLyK,MAAM,EAAEJ,QADH;cAELb,IAAI,EAAEe,eAAe,CAACf,IAFjB;cAGLC,MAAM,EAAEc,eAAe,CAACd;YAHnB,CADF;YAML3K,GAAG,EAAE;cACH2L,MAAM,EAAEH,MADL;cAEHd,IAAI,EAAEgB,aAAa,CAAChB,IAFjB;cAGHC,MAAM,EAAEe,aAAa,CAACf;YAHnB;UANA,CAAP;QAYD;;QAED,SAASiB,QAAT,CAAkB5M,QAAlB,EAA4B;UAC1B,IAAIwL,WAAW,GAAGI,cAAlB,EAAkC;YAChC;UACD;;UAED,IAAIJ,WAAW,GAAGI,cAAlB,EAAkC;YAChCA,cAAc,GAAGJ,WAAjB;YACAK,mBAAmB,GAAG,EAAtB;UACD;;UAEDA,mBAAmB,CAACzY,IAApB,CAAyB4M,QAAzB;QACD;;QAED,SAAS6M,wBAAT,CAAkC7M,QAAlC,EAA4CC,KAA5C,EAAmDC,QAAnD,EAA6D;UAC3D,OAAO,IAAIJ,eAAJ,CAAoBA,eAAe,CAACM,YAAhB,CAA6BJ,QAA7B,EAAuCC,KAAvC,CAApB,EAAmED,QAAnE,EAA6EC,KAA7E,EAAoFC,QAApF,CAAP;QACD;;QAED,SAASiC,cAAT,GAA0B;UACxB,IAAI2K,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB;UACA,IAAIpX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,CAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;UACAuB,EAAE,GAAGK,UAAU,EAAf;;UAEA,IAAIL,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAGK,kBAAkB,EAAvB;;YAEA,IAAIL,EAAE,KAAKhL,UAAX,EAAuB;cACrBiL,EAAE,GAAGG,UAAU,EAAf;;cAEA,IAAIH,EAAE,KAAKjL,UAAX,EAAuB;gBACrB+K,EAAE,GAAG1K,MAAM,CAAC2K,EAAD,CAAX;gBACAF,EAAE,GAAGC,EAAL;cACD,CAHD,MAGO;gBACLvB,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CAVD,MAUO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAjBD,MAiBO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED,IAAI8K,EAAE,KAAK9K,UAAX,EAAuB;YACrB8K,EAAE,GAAGtB,WAAL;YACAuB,EAAE,GAAGK,UAAU,EAAf;;YAEA,IAAIL,EAAE,KAAK/K,UAAX,EAAuB;cACrB+K,EAAE,GAAGvK,MAAM,EAAX;YACD;;YAEDsK,EAAE,GAAGC,EAAL;UACD;;UAEDjB,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASM,UAAT,GAAsB;UACpB,IAAIN,EAAJ,EAAQC,EAAR;UACA,IAAIlX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,CAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAG,EAAL;;UAEA,IAAIhL,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;YACxCuB,EAAE,GAAGtK,MAAL;YACA+I,WAAW;UACZ,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAAClK,MAAD,CAAR;YACD;UACF;;UAED,OAAOqK,EAAE,KAAK/K,UAAd,EAA0B;YACxB8K,EAAE,CAAC1Z,IAAH,CAAQ2Z,EAAR;;YAEA,IAAIjL,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;cACxCuB,EAAE,GAAGtK,MAAL;cACA+I,WAAW;YACZ,CAHD,MAGO;cACLuB,EAAE,GAAG/K,UAAL;cAEA;gBACE4K,QAAQ,CAAClK,MAAD,CAAR;cACD;YACF;UACF;;UAEDoJ,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASQ,uBAAT,GAAmC;UACjC,IAAIR,EAAJ,EAAQC,EAAR,EAAYC,EAAZ;UACA,IAAInX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,CAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;UACAuB,EAAE,GAAG,EAAL;;UAEA,IAAInK,MAAM,CAAC7O,IAAP,CAAY+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAZ,CAAJ,EAA4C;YAC1CwB,EAAE,GAAGlL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;YACAA,WAAW;UACZ,CAHD,MAGO;YACLwB,EAAE,GAAGhL,UAAL;YAEA;cACE4K,QAAQ,CAAC/J,MAAD,CAAR;YACD;UACF;;UAED,IAAImK,EAAE,KAAKhL,UAAX,EAAuB;YACrB,OAAOgL,EAAE,KAAKhL,UAAd,EAA0B;cACxB+K,EAAE,CAAC3Z,IAAH,CAAQ4Z,EAAR;;cAEA,IAAIpK,MAAM,CAAC7O,IAAP,CAAY+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAZ,CAAJ,EAA4C;gBAC1CwB,EAAE,GAAGlL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;gBACAA,WAAW;cACZ,CAHD,MAGO;gBACLwB,EAAE,GAAGhL,UAAL;gBAEA;kBACE4K,QAAQ,CAAC/J,MAAD,CAAR;gBACD;cACF;YACF;UACF,CAfD,MAeO;YACLkK,EAAE,GAAG/K,UAAL;UACD;;UAED,IAAI+K,EAAE,KAAK/K,UAAX,EAAuB;YACrB+K,EAAE,GAAGhK,MAAM,CAACgK,EAAD,CAAX;UACD;;UAEDD,EAAE,GAAGC,EAAL;UACAjB,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASU,iBAAT,GAA6B;UAC3B,IAAIV,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB;UACA,IAAIpX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,CAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;UACAuB,EAAE,GAAGK,UAAU,EAAf;;UAEA,IAAIL,EAAE,KAAK/K,UAAX,EAAuB;YACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;cACxCwB,EAAE,GAAGhK,MAAL;cACAwI,WAAW;YACZ,CAHD,MAGO;cACLwB,EAAE,GAAGhL,UAAL;cAEA;gBACE4K,QAAQ,CAAC3J,MAAD,CAAR;cACD;YACF;;YAED,IAAI+J,EAAE,KAAKhL,UAAX,EAAuB;cACrBiL,EAAE,GAAGG,UAAU,EAAf;;cAEA,IAAIH,EAAE,KAAKjL,UAAX,EAAuB;gBACrB+K,EAAE,GAAG7J,MAAM,EAAX;gBACA4J,EAAE,GAAGC,EAAL;cACD,CAHD,MAGO;gBACLvB,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CAVD,MAUO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CA1BD,MA0BO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED,IAAI8K,EAAE,KAAK9K,UAAX,EAAuB;YACrB8K,EAAE,GAAGtB,WAAL;YACAuB,EAAE,GAAGK,UAAU,EAAf;;YAEA,IAAIL,EAAE,KAAK/K,UAAX,EAAuB;cACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,GAAtC,EAA2C;gBACzCwB,EAAE,GAAG7J,OAAL;gBACAqI,WAAW;cACZ,CAHD,MAGO;gBACLwB,EAAE,GAAGhL,UAAL;gBAEA;kBACE4K,QAAQ,CAACxJ,OAAD,CAAR;gBACD;cACF;;cAED,IAAI4J,EAAE,KAAKhL,UAAX,EAAuB;gBACrBiL,EAAE,GAAGG,UAAU,EAAf;;gBAEA,IAAIH,EAAE,KAAKjL,UAAX,EAAuB;kBACrB+K,EAAE,GAAG1J,OAAO,EAAZ;kBACAyJ,EAAE,GAAGC,EAAL;gBACD,CAHD,MAGO;kBACLvB,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF,CAVD,MAUO;gBACLwJ,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CA1BD,MA0BO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;;YAED,IAAI8K,EAAE,KAAK9K,UAAX,EAAuB;cACrB8K,EAAE,GAAGtB,WAAL;cACAuB,EAAE,GAAGK,UAAU,EAAf;;cAEA,IAAIL,EAAE,KAAK/K,UAAX,EAAuB;gBACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;kBACxCwB,EAAE,GAAG1J,OAAL;kBACAkI,WAAW;gBACZ,CAHD,MAGO;kBACLwB,EAAE,GAAGhL,UAAL;kBAEA;oBACE4K,QAAQ,CAACrJ,OAAD,CAAR;kBACD;gBACF;;gBAED,IAAIyJ,EAAE,KAAKhL,UAAX,EAAuB;kBACrBiL,EAAE,GAAGG,UAAU,EAAf;;kBAEA,IAAIH,EAAE,KAAKjL,UAAX,EAAuB;oBACrB+K,EAAE,GAAGvJ,OAAO,EAAZ;oBACAsJ,EAAE,GAAGC,EAAL;kBACD,CAHD,MAGO;oBACLvB,WAAW,GAAGsB,EAAd;oBACAA,EAAE,GAAG9K,UAAL;kBACD;gBACF,CAVD,MAUO;kBACLwJ,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF,CA1BD,MA0BO;gBACLwJ,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;;cAED,IAAI8K,EAAE,KAAK9K,UAAX,EAAuB;gBACrB8K,EAAE,GAAGtB,WAAL;;gBAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;kBACxCuB,EAAE,GAAGtK,MAAL;kBACA+I,WAAW;gBACZ,CAHD,MAGO;kBACLuB,EAAE,GAAG/K,UAAL;kBAEA;oBACE4K,QAAQ,CAAClK,MAAD,CAAR;kBACD;gBACF;;gBAED,IAAIqK,EAAE,KAAK/K,UAAX,EAAuB;kBACrBgL,EAAE,GAAGI,UAAU,EAAf;;kBAEA,IAAIJ,EAAE,KAAKhL,UAAX,EAAuB;oBACrB+K,EAAE,GAAGtJ,OAAO,EAAZ;oBACAqJ,EAAE,GAAGC,EAAL;kBACD,CAHD,MAGO;oBACLvB,WAAW,GAAGsB,EAAd;oBACAA,EAAE,GAAG9K,UAAL;kBACD;gBACF,CAVD,MAUO;kBACLwJ,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF;YACF;UACF;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASO,kBAAT,GAA8B;UAC5B,IAAIP,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB,EAAwBC,EAAxB,EAA4BC,EAA5B,EAAgCC,EAAhC;UACA,IAAI/X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,CAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;UACAuB,EAAE,GAAGc,iBAAiB,EAAtB;;UAEA,IAAId,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAG,EAAL;YACAC,EAAE,GAAGzB,WAAL;YACAiC,EAAE,GAAGL,UAAU,EAAf;;YAEA,IAAIK,EAAE,KAAKzL,UAAX,EAAuB;cACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;gBACxCkC,EAAE,GAAGhK,OAAL;gBACA8H,WAAW;cACZ,CAHD,MAGO;gBACLkC,EAAE,GAAG1L,UAAL;gBAEA;kBACE4K,QAAQ,CAACjJ,OAAD,CAAR;gBACD;cACF;;cAED,IAAI+J,EAAE,KAAK1L,UAAX,EAAuB;gBACrB2L,EAAE,GAAGP,UAAU,EAAf;;gBAEA,IAAIO,EAAE,KAAK3L,UAAX,EAAuB;kBACrB4L,EAAE,GAAGC,iBAAiB,EAAtB;;kBAEA,IAAID,EAAE,KAAK5L,UAAX,EAAuB;oBACrByL,EAAE,GAAG,CAACA,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,CAAL;oBACAX,EAAE,GAAGQ,EAAL;kBACD,CAHD,MAGO;oBACLjC,WAAW,GAAGyB,EAAd;oBACAA,EAAE,GAAGjL,UAAL;kBACD;gBACF,CAVD,MAUO;kBACLwJ,WAAW,GAAGyB,EAAd;kBACAA,EAAE,GAAGjL,UAAL;gBACD;cACF,CAjBD,MAiBO;gBACLwJ,WAAW,GAAGyB,EAAd;gBACAA,EAAE,GAAGjL,UAAL;cACD;YACF,CAjCD,MAiCO;cACLwJ,WAAW,GAAGyB,EAAd;cACAA,EAAE,GAAGjL,UAAL;YACD;;YAED,OAAOiL,EAAE,KAAKjL,UAAd,EAA0B;cACxBgL,EAAE,CAAC5Z,IAAH,CAAQ6Z,EAAR;cACAA,EAAE,GAAGzB,WAAL;cACAiC,EAAE,GAAGL,UAAU,EAAf;;cAEA,IAAIK,EAAE,KAAKzL,UAAX,EAAuB;gBACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;kBACxCkC,EAAE,GAAGhK,OAAL;kBACA8H,WAAW;gBACZ,CAHD,MAGO;kBACLkC,EAAE,GAAG1L,UAAL;kBAEA;oBACE4K,QAAQ,CAACjJ,OAAD,CAAR;kBACD;gBACF;;gBAED,IAAI+J,EAAE,KAAK1L,UAAX,EAAuB;kBACrB2L,EAAE,GAAGP,UAAU,EAAf;;kBAEA,IAAIO,EAAE,KAAK3L,UAAX,EAAuB;oBACrB4L,EAAE,GAAGC,iBAAiB,EAAtB;;oBAEA,IAAID,EAAE,KAAK5L,UAAX,EAAuB;sBACrByL,EAAE,GAAG,CAACA,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,CAAL;sBACAX,EAAE,GAAGQ,EAAL;oBACD,CAHD,MAGO;sBACLjC,WAAW,GAAGyB,EAAd;sBACAA,EAAE,GAAGjL,UAAL;oBACD;kBACF,CAVD,MAUO;oBACLwJ,WAAW,GAAGyB,EAAd;oBACAA,EAAE,GAAGjL,UAAL;kBACD;gBACF,CAjBD,MAiBO;kBACLwJ,WAAW,GAAGyB,EAAd;kBACAA,EAAE,GAAGjL,UAAL;gBACD;cACF,CAjCD,MAiCO;gBACLwJ,WAAW,GAAGyB,EAAd;gBACAA,EAAE,GAAGjL,UAAL;cACD;YACF;;YAED,IAAIgL,EAAE,KAAKhL,UAAX,EAAuB;cACrB+K,EAAE,GAAGnJ,OAAO,CAACmJ,EAAD,EAAKC,EAAL,CAAZ;cACAF,EAAE,GAAGC,EAAL;YACD,CAHD,MAGO;cACLvB,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CA9FD,MA8FO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASe,iBAAT,GAA6B;UAC3B,IAAIf,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB,EAAwBC,EAAxB;UACA,IAAI7X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,CAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;UACAuB,EAAE,GAAGe,iBAAiB,EAAtB;;UAEA,IAAIf,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAG,EAAL;YACAC,EAAE,GAAGzB,WAAL;YACAiC,EAAE,GAAGD,iBAAiB,EAAtB;;YAEA,IAAIC,EAAE,KAAKzL,UAAX,EAAuB;cACrB0L,EAAE,GAAGI,iBAAiB,EAAtB;;cAEA,IAAIJ,EAAE,KAAK1L,UAAX,EAAuB;gBACrByL,EAAE,GAAG,CAACA,EAAD,EAAKC,EAAL,CAAL;gBACAT,EAAE,GAAGQ,EAAL;cACD,CAHD,MAGO;gBACLjC,WAAW,GAAGyB,EAAd;gBACAA,EAAE,GAAGjL,UAAL;cACD;YACF,CAVD,MAUO;cACLwJ,WAAW,GAAGyB,EAAd;cACAA,EAAE,GAAGjL,UAAL;YACD;;YAED,OAAOiL,EAAE,KAAKjL,UAAd,EAA0B;cACxBgL,EAAE,CAAC5Z,IAAH,CAAQ6Z,EAAR;cACAA,EAAE,GAAGzB,WAAL;cACAiC,EAAE,GAAGD,iBAAiB,EAAtB;;cAEA,IAAIC,EAAE,KAAKzL,UAAX,EAAuB;gBACrB0L,EAAE,GAAGI,iBAAiB,EAAtB;;gBAEA,IAAIJ,EAAE,KAAK1L,UAAX,EAAuB;kBACrByL,EAAE,GAAG,CAACA,EAAD,EAAKC,EAAL,CAAL;kBACAT,EAAE,GAAGQ,EAAL;gBACD,CAHD,MAGO;kBACLjC,WAAW,GAAGyB,EAAd;kBACAA,EAAE,GAAGjL,UAAL;gBACD;cACF,CAVD,MAUO;gBACLwJ,WAAW,GAAGyB,EAAd;gBACAA,EAAE,GAAGjL,UAAL;cACD;YACF;;YAED,IAAIgL,EAAE,KAAKhL,UAAX,EAAuB;cACrB+K,EAAE,GAAGhJ,OAAO,CAACgJ,EAAD,EAAKC,EAAL,CAAZ;cACAF,EAAE,GAAGC,EAAL;YACD,CAHD,MAGO;cACLvB,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAhDD,MAgDO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASgB,iBAAT,GAA6B;UAC3B,IAAIhB,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB;UACA,IAAIpX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,CAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;YACxCuB,EAAE,GAAGxI,OAAL;YACAiH,WAAW;UACZ,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAACpI,OAAD,CAAR;YACD;UACF;;UAED,IAAIuI,EAAE,KAAK/K,UAAX,EAAuB;YACrB+K,EAAE,GAAG,IAAL;UACD;;UAED,IAAIA,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAG,EAAL;YACAC,EAAE,GAAGc,aAAa,EAAlB;;YAEA,IAAId,EAAE,KAAKjL,UAAX,EAAuB;cACrB,OAAOiL,EAAE,KAAKjL,UAAd,EAA0B;gBACxBgL,EAAE,CAAC5Z,IAAH,CAAQ6Z,EAAR;gBACAA,EAAE,GAAGc,aAAa,EAAlB;cACD;YACF,CALD,MAKO;cACLf,EAAE,GAAGhL,UAAL;YACD;;YAED,IAAIgL,EAAE,KAAKhL,UAAX,EAAuB;cACrB+K,EAAE,GAAGtI,OAAO,CAACsI,EAAD,EAAKC,EAAL,CAAZ;cACAF,EAAE,GAAGC,EAAL;YACD,CAHD,MAGO;cACLvB,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CApBD,MAoBO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASiB,aAAT,GAAyB;UACvB,IAAIjB,EAAJ;UACA,IAAIjX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,CAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGkB,iBAAiB,EAAtB;;UAEA,IAAIlB,EAAE,KAAK9K,UAAX,EAAuB;YACrB8K,EAAE,GAAGmB,mBAAmB,EAAxB;;YAEA,IAAInB,EAAE,KAAK9K,UAAX,EAAuB;cACrB8K,EAAE,GAAGoB,aAAa,EAAlB;;cAEA,IAAIpB,EAAE,KAAK9K,UAAX,EAAuB;gBACrB8K,EAAE,GAAGqB,cAAc,EAAnB;;gBAEA,IAAIrB,EAAE,KAAK9K,UAAX,EAAuB;kBACrB8K,EAAE,GAAGsB,iBAAiB,EAAtB;;kBAEA,IAAItB,EAAE,KAAK9K,UAAX,EAAuB;oBACrB8K,EAAE,GAAGuB,gBAAgB,EAArB;;oBAEA,IAAIvB,EAAE,KAAK9K,UAAX,EAAuB;sBACrB8K,EAAE,GAAGwB,YAAY,EAAjB;;sBAEA,IAAIxB,EAAE,KAAK9K,UAAX,EAAuB;wBACrB8K,EAAE,GAAGyB,mBAAmB,EAAxB;;wBAEA,IAAIzB,EAAE,KAAK9K,UAAX,EAAuB;0BACrB8K,EAAE,GAAG0B,kBAAkB,EAAvB;;0BAEA,IAAI1B,EAAE,KAAK9K,UAAX,EAAuB;4BACrB8K,EAAE,GAAG2B,iBAAiB,EAAtB;;4BAEA,IAAI3B,EAAE,KAAK9K,UAAX,EAAuB;8BACrB8K,EAAE,GAAG4B,qBAAqB,EAA1B;;8BAEA,IAAI5B,EAAE,KAAK9K,UAAX,EAAuB;gCACrB8K,EAAE,GAAG6B,cAAc,EAAnB;8BACD;4BACF;0BACF;wBACF;sBACF;oBACF;kBACF;gBACF;cACF;YACF;UACF;;UAED7C,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASkB,iBAAT,GAA6B;UAC3B,IAAIlB,EAAJ,EAAQC,EAAR;UACA,IAAIlX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,CAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;YACxCuB,EAAE,GAAGlI,OAAL;YACA2G,WAAW;UACZ,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAAC9H,OAAD,CAAR;YACD;UACF;;UAED,IAAIiI,EAAE,KAAK/K,UAAX,EAAuB;YACrB+K,EAAE,GAAGhI,OAAO,CAACgI,EAAD,CAAZ;UACD;;UAEDD,EAAE,GAAGC,EAAL;UACAjB,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASmB,mBAAT,GAA+B;UAC7B,IAAInB,EAAJ,EAAQC,EAAR,EAAYC,EAAZ;UACA,IAAInX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,CAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;YACxCuB,EAAE,GAAG/H,OAAL;YACAwG,WAAW;UACZ,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAAC3H,OAAD,CAAR;YACD;UACF;;UAED,IAAI8H,EAAE,KAAK/K,UAAX,EAAuB;YACrB+K,EAAE,GAAG,IAAL;UACD;;UAED,IAAIA,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAGM,uBAAuB,EAA5B;;YAEA,IAAIN,EAAE,KAAKhL,UAAX,EAAuB;cACrB+K,EAAE,GAAG7H,OAAO,CAAC8H,EAAD,CAAZ;cACAF,EAAE,GAAGC,EAAL;YACD,CAHD,MAGO;cACLvB,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAVD,MAUO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASoB,aAAT,GAAyB;UACvB,IAAIpB,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB,EAAwBC,EAAxB;UACA,IAAI7X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;YACxCuB,EAAE,GAAG5H,OAAL;YACAqG,WAAW;UACZ,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAACxH,OAAD,CAAR;YACD;UACF;;UAED,IAAI2H,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAGI,UAAU,EAAf;;YAEA,IAAIJ,EAAE,KAAKhL,UAAX,EAAuB;cACrBiL,EAAE,GAAG2B,kBAAkB,EAAvB;;cAEA,IAAI3B,EAAE,KAAKjL,UAAX,EAAuB;gBACrByL,EAAE,GAAGL,UAAU,EAAf;;gBAEA,IAAIK,EAAE,KAAKzL,UAAX,EAAuB;kBACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;oBACxCkC,EAAE,GAAGrI,OAAL;oBACAmG,WAAW;kBACZ,CAHD,MAGO;oBACLkC,EAAE,GAAG1L,UAAL;oBAEA;sBACE4K,QAAQ,CAACtH,OAAD,CAAR;oBACD;kBACF;;kBAED,IAAIoI,EAAE,KAAK1L,UAAX,EAAuB;oBACrB+K,EAAE,GAAGxH,OAAO,CAAC0H,EAAD,CAAZ;oBACAH,EAAE,GAAGC,EAAL;kBACD,CAHD,MAGO;oBACLvB,WAAW,GAAGsB,EAAd;oBACAA,EAAE,GAAG9K,UAAL;kBACD;gBACF,CAnBD,MAmBO;kBACLwJ,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF,CA1BD,MA0BO;gBACLwJ,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CAjCD,MAiCO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAxCD,MAwCO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAAS+B,gBAAT,GAA4B;UAC1B,IAAI/B,EAAJ,EAAQC,EAAR,EAAYC,EAAZ;UACA,IAAInX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI/F,OAAO,CAAC1R,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;YAC3CuB,EAAE,GAAGjL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;YACAA,WAAW;UACZ,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAAClH,OAAD,CAAR;YACD;UACF;;UAED,IAAIqH,EAAE,KAAK/K,UAAX,EAAuB;YACrB+K,EAAE,GAAG,IAAL;UACD;;UAED,IAAIA,EAAE,KAAK/K,UAAX,EAAuB;YACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;cACxCwB,EAAE,GAAGrH,OAAL;cACA6F,WAAW;YACZ,CAHD,MAGO;cACLwB,EAAE,GAAGhL,UAAL;cAEA;gBACE4K,QAAQ,CAAChH,OAAD,CAAR;cACD;YACF;;YAED,IAAIoH,EAAE,KAAKhL,UAAX,EAAuB;cACrB+K,EAAE,GAAGlH,OAAO,CAACkH,EAAD,CAAZ;cACAD,EAAE,GAAGC,EAAL;YACD,CAHD,MAGO;cACLvB,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAnBD,MAmBO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED,IAAI8K,EAAE,KAAK9K,UAAX,EAAuB;YACrB,IAAI8D,OAAO,CAAC/R,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;cAC3CsB,EAAE,GAAGhL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;cACAA,WAAW;YACZ,CAHD,MAGO;cACLsB,EAAE,GAAG9K,UAAL;cAEA;gBACE4K,QAAQ,CAAC7G,OAAD,CAAR;cACD;YACF;UACF;;UAED+F,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASgC,kBAAT,GAA8B;UAC5B,IAAIhC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ;UACA,IAAInX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;YACxCuB,EAAE,GAAGxI,OAAL;YACAiH,WAAW;UACZ,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAACpI,OAAD,CAAR;YACD;UACF;;UAED,IAAIuI,EAAE,KAAK/K,UAAX,EAAuB;YACrB+K,EAAE,GAAG,IAAL;UACD;;UAED,IAAIA,EAAE,KAAK/K,UAAX,EAAuB;YACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;cACxCwB,EAAE,GAAGrH,OAAL;cACA6F,WAAW;YACZ,CAHD,MAGO;cACLwB,EAAE,GAAGhL,UAAL;cAEA;gBACE4K,QAAQ,CAAChH,OAAD,CAAR;cACD;YACF;;YAED,IAAIoH,EAAE,KAAKhL,UAAX,EAAuB;cACrB+K,EAAE,GAAGlH,OAAO,CAACkH,EAAD,CAAZ;cACAD,EAAE,GAAGC,EAAL;YACD,CAHD,MAGO;cACLvB,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAnBD,MAmBO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASiC,iBAAT,GAA6B;UAC3B,IAAIjC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB,EAAwBC,EAAxB;UACA,IAAI7X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;UACAuB,EAAE,GAAGO,uBAAuB,EAA5B;;UAEA,IAAIP,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAG,EAAL;YACAC,EAAE,GAAGzB,WAAL;;YAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;cACxCiC,EAAE,GAAGzH,OAAL;cACAwF,WAAW;YACZ,CAHD,MAGO;cACLiC,EAAE,GAAGzL,UAAL;cAEA;gBACE4K,QAAQ,CAAC3G,OAAD,CAAR;cACD;YACF;;YAED,IAAIwH,EAAE,KAAKzL,UAAX,EAAuB;cACrB0L,EAAE,GAAGJ,uBAAuB,EAA5B;;cAEA,IAAII,EAAE,KAAK1L,UAAX,EAAuB;gBACrByL,EAAE,GAAG,CAACA,EAAD,EAAKC,EAAL,CAAL;gBACAT,EAAE,GAAGQ,EAAL;cACD,CAHD,MAGO;gBACLjC,WAAW,GAAGyB,EAAd;gBACAA,EAAE,GAAGjL,UAAL;cACD;YACF,CAVD,MAUO;cACLwJ,WAAW,GAAGyB,EAAd;cACAA,EAAE,GAAGjL,UAAL;YACD;;YAED,OAAOiL,EAAE,KAAKjL,UAAd,EAA0B;cACxBgL,EAAE,CAAC5Z,IAAH,CAAQ6Z,EAAR;cACAA,EAAE,GAAGzB,WAAL;;cAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;gBACxCiC,EAAE,GAAGzH,OAAL;gBACAwF,WAAW;cACZ,CAHD,MAGO;gBACLiC,EAAE,GAAGzL,UAAL;gBAEA;kBACE4K,QAAQ,CAAC3G,OAAD,CAAR;gBACD;cACF;;cAED,IAAIwH,EAAE,KAAKzL,UAAX,EAAuB;gBACrB0L,EAAE,GAAGJ,uBAAuB,EAA5B;;gBAEA,IAAII,EAAE,KAAK1L,UAAX,EAAuB;kBACrByL,EAAE,GAAG,CAACA,EAAD,EAAKC,EAAL,CAAL;kBACAT,EAAE,GAAGQ,EAAL;gBACD,CAHD,MAGO;kBACLjC,WAAW,GAAGyB,EAAd;kBACAA,EAAE,GAAGjL,UAAL;gBACD;cACF,CAVD,MAUO;gBACLwJ,WAAW,GAAGyB,EAAd;gBACAA,EAAE,GAAGjL,UAAL;cACD;YACF;;YAED,IAAIgL,EAAE,KAAKhL,UAAX,EAAuB;cACrB+K,EAAE,GAAG7G,OAAO,CAAC6G,EAAD,EAAKC,EAAL,CAAZ;cACAF,EAAE,GAAGC,EAAL;YACD,CAHD,MAGO;cACLvB,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CApED,MAoEO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAAS8B,kBAAT,GAA8B;UAC5B,IAAI9B,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB,EAAwBC,EAAxB;UACA,IAAI7X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;UACAuB,EAAE,GAAGgC,iBAAiB,EAAtB;;UAEA,IAAIhC,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAGI,UAAU,EAAf;;YAEA,IAAIJ,EAAE,KAAKhL,UAAX,EAAuB;cACrBiL,EAAE,GAAG6B,kBAAkB,EAAvB;;cAEA,IAAI7B,EAAE,KAAKjL,UAAX,EAAuB;gBACrByL,EAAE,GAAGL,UAAU,EAAf;;gBAEA,IAAIK,EAAE,KAAKzL,UAAX,EAAuB;kBACrB0L,EAAE,GAAGsB,aAAa,EAAlB;;kBAEA,IAAItB,EAAE,KAAK1L,UAAX,EAAuB;oBACrB0L,EAAE,GAAGuB,cAAc,EAAnB;kBACD;;kBAED,IAAIvB,EAAE,KAAK1L,UAAX,EAAuB;oBACrB+K,EAAE,GAAG3G,OAAO,CAAC2G,EAAD,EAAKE,EAAL,EAASS,EAAT,CAAZ;oBACAZ,EAAE,GAAGC,EAAL;kBACD,CAHD,MAGO;oBACLvB,WAAW,GAAGsB,EAAd;oBACAA,EAAE,GAAG9K,UAAL;kBACD;gBACF,CAdD,MAcO;kBACLwJ,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF,CArBD,MAqBO;gBACLwJ,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CA5BD,MA4BO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAnCD,MAmCO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED,IAAI8K,EAAE,KAAK9K,UAAX,EAAuB;YACrB8K,EAAE,GAAGtB,WAAL;YACAuB,EAAE,GAAGgC,iBAAiB,EAAtB;;YAEA,IAAIhC,EAAE,KAAK/K,UAAX,EAAuB;cACrBgL,EAAE,GAAGI,UAAU,EAAf;;cAEA,IAAIJ,EAAE,KAAKhL,UAAX,EAAuB;gBACrBiL,EAAE,GAAG4B,gBAAgB,EAArB;;gBAEA,IAAI5B,EAAE,KAAKjL,UAAX,EAAuB;kBACrByL,EAAE,GAAGL,UAAU,EAAf;;kBAEA,IAAIK,EAAE,KAAKzL,UAAX,EAAuB;oBACrB0L,EAAE,GAAGwB,eAAe,EAApB;;oBAEA,IAAIxB,EAAE,KAAK1L,UAAX,EAAuB;sBACrB0L,EAAE,GAAGyB,eAAe,EAApB;;sBAEA,IAAIzB,EAAE,KAAK1L,UAAX,EAAuB;wBACrB0L,EAAE,GAAG0B,aAAa,EAAlB;sBACD;oBACF;;oBAED,IAAI1B,EAAE,KAAK1L,UAAX,EAAuB;sBACrB+K,EAAE,GAAG3G,OAAO,CAAC2G,EAAD,EAAKE,EAAL,EAASS,EAAT,CAAZ;sBACAZ,EAAE,GAAGC,EAAL;oBACD,CAHD,MAGO;sBACLvB,WAAW,GAAGsB,EAAd;sBACAA,EAAE,GAAG9K,UAAL;oBACD;kBACF,CAlBD,MAkBO;oBACLwJ,WAAW,GAAGsB,EAAd;oBACAA,EAAE,GAAG9K,UAAL;kBACD;gBACF,CAzBD,MAyBO;kBACLwJ,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF,CAhCD,MAgCO;gBACLwJ,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CAvCD,MAuCO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;;YAED,IAAI8K,EAAE,KAAK9K,UAAX,EAAuB;cACrB8K,EAAE,GAAGtB,WAAL;cACAuB,EAAE,GAAGgC,iBAAiB,EAAtB;;cAEA,IAAIhC,EAAE,KAAK/K,UAAX,EAAuB;gBACrB+K,EAAE,GAAGxG,OAAO,CAACwG,EAAD,CAAZ;cACD;;cAEDD,EAAE,GAAGC,EAAL;YACD;UACF;;UAEDjB,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASoC,eAAT,GAA2B;UACzB,IAAIpC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB,EAAwBC,EAAxB;UACA,IAAI7X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;YACxCuB,EAAE,GAAGvG,OAAL;YACAgF,WAAW;UACZ,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAACnG,OAAD,CAAR;YACD;UACF;;UAED,IAAIsG,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAG,EAAL;;YAEA,IAAItG,OAAO,CAAC3S,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;cAC3CyB,EAAE,GAAGnL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;cACAA,WAAW;YACZ,CAHD,MAGO;cACLyB,EAAE,GAAGjL,UAAL;cAEA;gBACE4K,QAAQ,CAACjG,OAAD,CAAR;cACD;YACF;;YAED,IAAIsG,EAAE,KAAKjL,UAAX,EAAuB;cACrBiL,EAAE,GAAGzB,WAAL;;cAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;gBACxCiC,EAAE,GAAG7G,OAAL;gBACA4E,WAAW;cACZ,CAHD,MAGO;gBACLiC,EAAE,GAAGzL,UAAL;gBAEA;kBACE4K,QAAQ,CAAC/F,OAAD,CAAR;gBACD;cACF;;cAED,IAAI4G,EAAE,KAAKzL,UAAX,EAAuB;gBACrB,IAAIF,KAAK,CAACxO,MAAN,GAAekY,WAAnB,EAAgC;kBAC9BkC,EAAE,GAAG5L,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;kBACAA,WAAW;gBACZ,CAHD,MAGO;kBACLkC,EAAE,GAAG1L,UAAL;kBAEA;oBACE4K,QAAQ,CAAC9F,OAAD,CAAR;kBACD;gBACF;;gBAED,IAAI4G,EAAE,KAAK1L,UAAX,EAAuB;kBACrByL,EAAE,GAAGzG,OAAO,CAACyG,EAAD,EAAKC,EAAL,CAAZ;kBACAT,EAAE,GAAGQ,EAAL;gBACD,CAHD,MAGO;kBACLjC,WAAW,GAAGyB,EAAd;kBACAA,EAAE,GAAGjL,UAAL;gBACD;cACF,CAnBD,MAmBO;gBACLwJ,WAAW,GAAGyB,EAAd;gBACAA,EAAE,GAAGjL,UAAL;cACD;YACF;;YAED,OAAOiL,EAAE,KAAKjL,UAAd,EAA0B;cACxBgL,EAAE,CAAC5Z,IAAH,CAAQ6Z,EAAR;;cAEA,IAAIvG,OAAO,CAAC3S,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;gBAC3CyB,EAAE,GAAGnL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;gBACAA,WAAW;cACZ,CAHD,MAGO;gBACLyB,EAAE,GAAGjL,UAAL;gBAEA;kBACE4K,QAAQ,CAACjG,OAAD,CAAR;gBACD;cACF;;cAED,IAAIsG,EAAE,KAAKjL,UAAX,EAAuB;gBACrBiL,EAAE,GAAGzB,WAAL;;gBAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;kBACxCiC,EAAE,GAAG7G,OAAL;kBACA4E,WAAW;gBACZ,CAHD,MAGO;kBACLiC,EAAE,GAAGzL,UAAL;kBAEA;oBACE4K,QAAQ,CAAC/F,OAAD,CAAR;kBACD;gBACF;;gBAED,IAAI4G,EAAE,KAAKzL,UAAX,EAAuB;kBACrB,IAAIF,KAAK,CAACxO,MAAN,GAAekY,WAAnB,EAAgC;oBAC9BkC,EAAE,GAAG5L,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;oBACAA,WAAW;kBACZ,CAHD,MAGO;oBACLkC,EAAE,GAAG1L,UAAL;oBAEA;sBACE4K,QAAQ,CAAC9F,OAAD,CAAR;oBACD;kBACF;;kBAED,IAAI4G,EAAE,KAAK1L,UAAX,EAAuB;oBACrByL,EAAE,GAAGzG,OAAO,CAACyG,EAAD,EAAKC,EAAL,CAAZ;oBACAT,EAAE,GAAGQ,EAAL;kBACD,CAHD,MAGO;oBACLjC,WAAW,GAAGyB,EAAd;oBACAA,EAAE,GAAGjL,UAAL;kBACD;gBACF,CAnBD,MAmBO;kBACLwJ,WAAW,GAAGyB,EAAd;kBACAA,EAAE,GAAGjL,UAAL;gBACD;cACF;YACF;;YAED,IAAIgL,EAAE,KAAKhL,UAAX,EAAuB;cACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;gBACxCyB,EAAE,GAAGzG,OAAL;gBACAgF,WAAW;cACZ,CAHD,MAGO;gBACLyB,EAAE,GAAGjL,UAAL;gBAEA;kBACE4K,QAAQ,CAACnG,OAAD,CAAR;gBACD;cACF;;cAED,IAAIwG,EAAE,KAAKjL,UAAX,EAAuB;gBACrB+K,EAAE,GAAG9F,OAAO,CAAC+F,EAAD,CAAZ;gBACAF,EAAE,GAAGC,EAAL;cACD,CAHD,MAGO;gBACLvB,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CAnBD,MAmBO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAlID,MAkIO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED,IAAI8K,EAAE,KAAK9K,UAAX,EAAuB;YACrB8K,EAAE,GAAGtB,WAAL;;YAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;cACxCuB,EAAE,GAAG3F,OAAL;cACAoE,WAAW;YACZ,CAHD,MAGO;cACLuB,EAAE,GAAG/K,UAAL;cAEA;gBACE4K,QAAQ,CAACvF,OAAD,CAAR;cACD;YACF;;YAED,IAAI0F,EAAE,KAAK/K,UAAX,EAAuB;cACrBgL,EAAE,GAAG,EAAL;;cAEA,IAAI1F,OAAO,CAACvT,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;gBAC3CyB,EAAE,GAAGnL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;gBACAA,WAAW;cACZ,CAHD,MAGO;gBACLyB,EAAE,GAAGjL,UAAL;gBAEA;kBACE4K,QAAQ,CAACrF,OAAD,CAAR;gBACD;cACF;;cAED,IAAI0F,EAAE,KAAKjL,UAAX,EAAuB;gBACrBiL,EAAE,GAAGzB,WAAL;;gBAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;kBACxCiC,EAAE,GAAG7G,OAAL;kBACA4E,WAAW;gBACZ,CAHD,MAGO;kBACLiC,EAAE,GAAGzL,UAAL;kBAEA;oBACE4K,QAAQ,CAAC/F,OAAD,CAAR;kBACD;gBACF;;gBAED,IAAI4G,EAAE,KAAKzL,UAAX,EAAuB;kBACrB,IAAIF,KAAK,CAACxO,MAAN,GAAekY,WAAnB,EAAgC;oBAC9BkC,EAAE,GAAG5L,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;oBACAA,WAAW;kBACZ,CAHD,MAGO;oBACLkC,EAAE,GAAG1L,UAAL;oBAEA;sBACE4K,QAAQ,CAAC9F,OAAD,CAAR;oBACD;kBACF;;kBAED,IAAI4G,EAAE,KAAK1L,UAAX,EAAuB;oBACrByL,EAAE,GAAGzG,OAAO,CAACyG,EAAD,EAAKC,EAAL,CAAZ;oBACAT,EAAE,GAAGQ,EAAL;kBACD,CAHD,MAGO;oBACLjC,WAAW,GAAGyB,EAAd;oBACAA,EAAE,GAAGjL,UAAL;kBACD;gBACF,CAnBD,MAmBO;kBACLwJ,WAAW,GAAGyB,EAAd;kBACAA,EAAE,GAAGjL,UAAL;gBACD;cACF;;cAED,OAAOiL,EAAE,KAAKjL,UAAd,EAA0B;gBACxBgL,EAAE,CAAC5Z,IAAH,CAAQ6Z,EAAR;;gBAEA,IAAI3F,OAAO,CAACvT,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;kBAC3CyB,EAAE,GAAGnL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;kBACAA,WAAW;gBACZ,CAHD,MAGO;kBACLyB,EAAE,GAAGjL,UAAL;kBAEA;oBACE4K,QAAQ,CAACrF,OAAD,CAAR;kBACD;gBACF;;gBAED,IAAI0F,EAAE,KAAKjL,UAAX,EAAuB;kBACrBiL,EAAE,GAAGzB,WAAL;;kBAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;oBACxCiC,EAAE,GAAG7G,OAAL;oBACA4E,WAAW;kBACZ,CAHD,MAGO;oBACLiC,EAAE,GAAGzL,UAAL;oBAEA;sBACE4K,QAAQ,CAAC/F,OAAD,CAAR;oBACD;kBACF;;kBAED,IAAI4G,EAAE,KAAKzL,UAAX,EAAuB;oBACrB,IAAIF,KAAK,CAACxO,MAAN,GAAekY,WAAnB,EAAgC;sBAC9BkC,EAAE,GAAG5L,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;sBACAA,WAAW;oBACZ,CAHD,MAGO;sBACLkC,EAAE,GAAG1L,UAAL;sBAEA;wBACE4K,QAAQ,CAAC9F,OAAD,CAAR;sBACD;oBACF;;oBAED,IAAI4G,EAAE,KAAK1L,UAAX,EAAuB;sBACrByL,EAAE,GAAGzG,OAAO,CAACyG,EAAD,EAAKC,EAAL,CAAZ;sBACAT,EAAE,GAAGQ,EAAL;oBACD,CAHD,MAGO;sBACLjC,WAAW,GAAGyB,EAAd;sBACAA,EAAE,GAAGjL,UAAL;oBACD;kBACF,CAnBD,MAmBO;oBACLwJ,WAAW,GAAGyB,EAAd;oBACAA,EAAE,GAAGjL,UAAL;kBACD;gBACF;cACF;;cAED,IAAIgL,EAAE,KAAKhL,UAAX,EAAuB;gBACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;kBACxCyB,EAAE,GAAG7F,OAAL;kBACAoE,WAAW;gBACZ,CAHD,MAGO;kBACLyB,EAAE,GAAGjL,UAAL;kBAEA;oBACE4K,QAAQ,CAACvF,OAAD,CAAR;kBACD;gBACF;;gBAED,IAAI4F,EAAE,KAAKjL,UAAX,EAAuB;kBACrB+K,EAAE,GAAG9F,OAAO,CAAC+F,EAAD,CAAZ;kBACAF,EAAE,GAAGC,EAAL;gBACD,CAHD,MAGO;kBACLvB,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF,CAnBD,MAmBO;gBACLwJ,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CAlID,MAkIO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASqC,eAAT,GAA2B;UACzB,IAAIrC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB;UACA,IAAIpX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;UACAuB,EAAE,GAAGvB,WAAL;UACAwB,EAAE,GAAG,EAAL;;UAEA,IAAIxF,OAAO,CAACzT,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;YAC3CyB,EAAE,GAAGnL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;YACAA,WAAW;UACZ,CAHD,MAGO;YACLyB,EAAE,GAAGjL,UAAL;YAEA;cACE4K,QAAQ,CAACnF,OAAD,CAAR;YACD;UACF;;UAED,OAAOwF,EAAE,KAAKjL,UAAd,EAA0B;YACxBgL,EAAE,CAAC5Z,IAAH,CAAQ6Z,EAAR;;YAEA,IAAIzF,OAAO,CAACzT,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;cAC3CyB,EAAE,GAAGnL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;cACAA,WAAW;YACZ,CAHD,MAGO;cACLyB,EAAE,GAAGjL,UAAL;cAEA;gBACE4K,QAAQ,CAACnF,OAAD,CAAR;cACD;YACF;UACF;;UAED,IAAIuF,EAAE,KAAKhL,UAAX,EAAuB;YACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;cACxCyB,EAAE,GAAGjH,OAAL;cACAwF,WAAW;YACZ,CAHD,MAGO;cACLyB,EAAE,GAAGjL,UAAL;cAEA;gBACE4K,QAAQ,CAAC3G,OAAD,CAAR;cACD;YACF;;YAED,IAAIgH,EAAE,KAAKjL,UAAX,EAAuB;cACrBgL,EAAE,GAAG,CAACA,EAAD,EAAKC,EAAL,CAAL;cACAF,EAAE,GAAGC,EAAL;YACD,CAHD,MAGO;cACLxB,WAAW,GAAGuB,EAAd;cACAA,EAAE,GAAG/K,UAAL;YACD;UACF,CAnBD,MAmBO;YACLwJ,WAAW,GAAGuB,EAAd;YACAA,EAAE,GAAG/K,UAAL;UACD;;UAED,IAAI+K,EAAE,KAAK/K,UAAX,EAAuB;YACrB+K,EAAE,GAAG,IAAL;UACD;;UAED,IAAIA,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAG,EAAL;;YAEA,IAAIxF,OAAO,CAACzT,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;cAC3CyB,EAAE,GAAGnL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;cACAA,WAAW;YACZ,CAHD,MAGO;cACLyB,EAAE,GAAGjL,UAAL;cAEA;gBACE4K,QAAQ,CAACnF,OAAD,CAAR;cACD;YACF;;YAED,IAAIwF,EAAE,KAAKjL,UAAX,EAAuB;cACrB,OAAOiL,EAAE,KAAKjL,UAAd,EAA0B;gBACxBgL,EAAE,CAAC5Z,IAAH,CAAQ6Z,EAAR;;gBAEA,IAAIzF,OAAO,CAACzT,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;kBAC3CyB,EAAE,GAAGnL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;kBACAA,WAAW;gBACZ,CAHD,MAGO;kBACLyB,EAAE,GAAGjL,UAAL;kBAEA;oBACE4K,QAAQ,CAACnF,OAAD,CAAR;kBACD;gBACF;cACF;YACF,CAfD,MAeO;cACLuF,EAAE,GAAGhL,UAAL;YACD;;YAED,IAAIgL,EAAE,KAAKhL,UAAX,EAAuB;cACrB+K,EAAE,GAAGrF,OAAO,CAACqF,EAAD,EAAKC,EAAL,CAAZ;cACAF,EAAE,GAAGC,EAAL;YACD,CAHD,MAGO;cACLvB,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAxCD,MAwCO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASsC,aAAT,GAAyB;UACvB,IAAItC,EAAJ,EAAQC,EAAR;UACA,IAAIlX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;UACAuB,EAAE,GAAGO,uBAAuB,EAA5B;;UAEA,IAAIP,EAAE,KAAK/K,UAAX,EAAuB;YACrB+K,EAAE,GAAGlF,OAAO,CAACkF,EAAD,CAAZ;UACD;;UAEDD,EAAE,GAAGC,EAAL;UACAjB,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASkC,aAAT,GAAyB;UACvB,IAAIlC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB,EAAwBC,EAAxB;UACA,IAAI7X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,CAA1B,MAAiC1D,OAArC,EAA8C;YAC5CiF,EAAE,GAAGjF,OAAL;YACA0D,WAAW,IAAI,CAAf;UACD,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAAC7E,OAAD,CAAR;YACD;UACF;;UAED,IAAIgF,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAGI,UAAU,EAAf;;YAEA,IAAIJ,EAAE,KAAKhL,UAAX,EAAuB;cACrBiL,EAAE,GAAG,EAAL;;cAEA,IAAIjF,OAAO,CAACjU,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;gBAC3CiC,EAAE,GAAG3L,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;gBACAA,WAAW;cACZ,CAHD,MAGO;gBACLiC,EAAE,GAAGzL,UAAL;gBAEA;kBACE4K,QAAQ,CAAC3E,OAAD,CAAR;gBACD;cACF;;cAED,IAAIwF,EAAE,KAAKzL,UAAX,EAAuB;gBACrB,OAAOyL,EAAE,KAAKzL,UAAd,EAA0B;kBACxBiL,EAAE,CAAC7Z,IAAH,CAAQqa,EAAR;;kBAEA,IAAIzF,OAAO,CAACjU,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;oBAC3CiC,EAAE,GAAG3L,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;oBACAA,WAAW;kBACZ,CAHD,MAGO;oBACLiC,EAAE,GAAGzL,UAAL;oBAEA;sBACE4K,QAAQ,CAAC3E,OAAD,CAAR;oBACD;kBACF;gBACF;cACF,CAfD,MAeO;gBACLgF,EAAE,GAAGjL,UAAL;cACD;;cAED,IAAIiL,EAAE,KAAKjL,UAAX,EAAuB;gBACrByL,EAAE,GAAGL,UAAU,EAAf;;gBAEA,IAAIK,EAAE,KAAKzL,UAAX,EAAuB;kBACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;oBACxCkC,EAAE,GAAGxF,OAAL;oBACAsD,WAAW;kBACZ,CAHD,MAGO;oBACLkC,EAAE,GAAG1L,UAAL;oBAEA;sBACE4K,QAAQ,CAACzE,OAAD,CAAR;oBACD;kBACF;;kBAED,IAAIuF,EAAE,KAAK1L,UAAX,EAAuB;oBACrB+K,EAAE,GAAG3E,OAAO,CAAC6E,EAAD,CAAZ;oBACAH,EAAE,GAAGC,EAAL;kBACD,CAHD,MAGO;oBACLvB,WAAW,GAAGsB,EAAd;oBACAA,EAAE,GAAG9K,UAAL;kBACD;gBACF,CAnBD,MAmBO;kBACLwJ,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF,CA1BD,MA0BO;gBACLwJ,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CA/DD,MA+DO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAtED,MAsEO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASwC,cAAT,GAA0B;UACxB,IAAIxC,EAAJ,EAAQC,EAAR;UACA,IAAIlX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAG,EAAL;;UAEA,IAAIxE,OAAO,CAACvU,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;YAC3CuB,EAAE,GAAGjL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;YACAA,WAAW;UACZ,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAACrE,OAAD,CAAR;YACD;UACF;;UAED,IAAIwE,EAAE,KAAK/K,UAAX,EAAuB;YACrB,OAAO+K,EAAE,KAAK/K,UAAd,EAA0B;cACxB8K,EAAE,CAAC1Z,IAAH,CAAQ2Z,EAAR;;cAEA,IAAIzE,OAAO,CAACvU,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;gBAC3CuB,EAAE,GAAGjL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;gBACAA,WAAW;cACZ,CAHD,MAGO;gBACLuB,EAAE,GAAG/K,UAAL;gBAEA;kBACE4K,QAAQ,CAACrE,OAAD,CAAR;gBACD;cACF;YACF;UACF,CAfD,MAeO;YACLuE,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASmC,cAAT,GAA0B;UACxB,IAAInC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB;UACA,IAAI5X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;YACxCuB,EAAE,GAAGvE,OAAL;YACAgD,WAAW;UACZ,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAACnE,OAAD,CAAR;YACD;UACF;;UAED,IAAIsE,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAG,EAAL;;YAEA,IAAItE,OAAO,CAAC3U,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;cAC3CyB,EAAE,GAAGnL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;cACAA,WAAW;YACZ,CAHD,MAGO;cACLyB,EAAE,GAAGjL,UAAL;cAEA;gBACE4K,QAAQ,CAACjE,OAAD,CAAR;cACD;YACF;;YAED,IAAIsE,EAAE,KAAKjL,UAAX,EAAuB;cACrB,OAAOiL,EAAE,KAAKjL,UAAd,EAA0B;gBACxBgL,EAAE,CAAC5Z,IAAH,CAAQ6Z,EAAR;;gBAEA,IAAIvE,OAAO,CAAC3U,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;kBAC3CyB,EAAE,GAAGnL,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;kBACAA,WAAW;gBACZ,CAHD,MAGO;kBACLyB,EAAE,GAAGjL,UAAL;kBAEA;oBACE4K,QAAQ,CAACjE,OAAD,CAAR;kBACD;gBACF;cACF;YACF,CAfD,MAeO;cACLqE,EAAE,GAAGhL,UAAL;YACD;;YAED,IAAIgL,EAAE,KAAKhL,UAAX,EAAuB;cACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;gBACxCyB,EAAE,GAAGzE,OAAL;gBACAgD,WAAW;cACZ,CAHD,MAGO;gBACLyB,EAAE,GAAGjL,UAAL;gBAEA;kBACE4K,QAAQ,CAACnE,OAAD,CAAR;gBACD;cACF;;cAED,IAAIwE,EAAE,KAAKjL,UAAX,EAAuB;gBACrByL,EAAE,GAAG6B,cAAc,EAAnB;;gBAEA,IAAI7B,EAAE,KAAKzL,UAAX,EAAuB;kBACrByL,EAAE,GAAG,IAAL;gBACD;;gBAED,IAAIA,EAAE,KAAKzL,UAAX,EAAuB;kBACrB+K,EAAE,GAAGnE,OAAO,CAACoE,EAAD,EAAKS,EAAL,CAAZ;kBACAX,EAAE,GAAGC,EAAL;gBACD,CAHD,MAGO;kBACLvB,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF,CAdD,MAcO;gBACLwJ,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CA9BD,MA8BO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAnED,MAmEO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASqB,cAAT,GAA0B;UACxB,IAAIrB,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB,EAAwBC,EAAxB,EAA4BC,EAA5B;UACA,IAAI9X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;YACxCuB,EAAE,GAAG/G,OAAL;YACAwF,WAAW;UACZ,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAAC3G,OAAD,CAAR;YACD;UACF;;UAED,IAAI8G,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAGM,uBAAuB,EAA5B;;YAEA,IAAIN,EAAE,KAAKhL,UAAX,EAAuB;cACrBiL,EAAE,GAAG,EAAL;cACAQ,EAAE,GAAGjC,WAAL;;cAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;gBACxCkC,EAAE,GAAG1H,OAAL;gBACAwF,WAAW;cACZ,CAHD,MAGO;gBACLkC,EAAE,GAAG1L,UAAL;gBAEA;kBACE4K,QAAQ,CAAC3G,OAAD,CAAR;gBACD;cACF;;cAED,IAAIyH,EAAE,KAAK1L,UAAX,EAAuB;gBACrB2L,EAAE,GAAGL,uBAAuB,EAA5B;;gBAEA,IAAIK,EAAE,KAAK3L,UAAX,EAAuB;kBACrB0L,EAAE,GAAG,CAACA,EAAD,EAAKC,EAAL,CAAL;kBACAF,EAAE,GAAGC,EAAL;gBACD,CAHD,MAGO;kBACLlC,WAAW,GAAGiC,EAAd;kBACAA,EAAE,GAAGzL,UAAL;gBACD;cACF,CAVD,MAUO;gBACLwJ,WAAW,GAAGiC,EAAd;gBACAA,EAAE,GAAGzL,UAAL;cACD;;cAED,OAAOyL,EAAE,KAAKzL,UAAd,EAA0B;gBACxBiL,EAAE,CAAC7Z,IAAH,CAAQqa,EAAR;gBACAA,EAAE,GAAGjC,WAAL;;gBAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;kBACxCkC,EAAE,GAAG1H,OAAL;kBACAwF,WAAW;gBACZ,CAHD,MAGO;kBACLkC,EAAE,GAAG1L,UAAL;kBAEA;oBACE4K,QAAQ,CAAC3G,OAAD,CAAR;kBACD;gBACF;;gBAED,IAAIyH,EAAE,KAAK1L,UAAX,EAAuB;kBACrB2L,EAAE,GAAGL,uBAAuB,EAA5B;;kBAEA,IAAIK,EAAE,KAAK3L,UAAX,EAAuB;oBACrB0L,EAAE,GAAG,CAACA,EAAD,EAAKC,EAAL,CAAL;oBACAF,EAAE,GAAGC,EAAL;kBACD,CAHD,MAGO;oBACLlC,WAAW,GAAGiC,EAAd;oBACAA,EAAE,GAAGzL,UAAL;kBACD;gBACF,CAVD,MAUO;kBACLwJ,WAAW,GAAGiC,EAAd;kBACAA,EAAE,GAAGzL,UAAL;gBACD;cACF;;cAED,IAAIiL,EAAE,KAAKjL,UAAX,EAAuB;gBACrB+K,EAAE,GAAGhE,OAAO,CAACiE,EAAD,EAAKC,EAAL,CAAZ;gBACAH,EAAE,GAAGC,EAAL;cACD,CAHD,MAGO;gBACLvB,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CApED,MAoEO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CA3ED,MA2EO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASsB,iBAAT,GAA6B;UAC3B,IAAItB,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB,EAAwBC,EAAxB;UACA,IAAI7X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,CAA1B,MAAiCtC,OAArC,EAA8C;YAC5C6D,EAAE,GAAG7D,OAAL;YACAsC,WAAW,IAAI,CAAf;UACD,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAACzD,OAAD,CAAR;YACD;UACF;;UAED,IAAI4D,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAGI,UAAU,EAAf;;YAEA,IAAIJ,EAAE,KAAKhL,UAAX,EAAuB;cACrBiL,EAAE,GAAGI,kBAAkB,EAAvB;;cAEA,IAAIJ,EAAE,KAAKjL,UAAX,EAAuB;gBACrByL,EAAE,GAAGL,UAAU,EAAf;;gBAEA,IAAIK,EAAE,KAAKzL,UAAX,EAAuB;kBACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;oBACxCkC,EAAE,GAAGxF,OAAL;oBACAsD,WAAW;kBACZ,CAHD,MAGO;oBACLkC,EAAE,GAAG1L,UAAL;oBAEA;sBACE4K,QAAQ,CAACzE,OAAD,CAAR;oBACD;kBACF;;kBAED,IAAIuF,EAAE,KAAK1L,UAAX,EAAuB;oBACrB+K,EAAE,GAAG3D,OAAO,CAAC6D,EAAD,CAAZ;oBACAH,EAAE,GAAGC,EAAL;kBACD,CAHD,MAGO;oBACLvB,WAAW,GAAGsB,EAAd;oBACAA,EAAE,GAAG9K,UAAL;kBACD;gBACF,CAnBD,MAmBO;kBACLwJ,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF,CA1BD,MA0BO;gBACLwJ,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CAjCD,MAiCO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAxCD,MAwCO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASuB,gBAAT,GAA4B;UAC1B,IAAIvB,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB,EAAwBC,EAAxB;UACA,IAAI7X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,CAA1B,MAAiCnC,OAArC,EAA8C;YAC5C0D,EAAE,GAAG1D,OAAL;YACAmC,WAAW,IAAI,CAAf;UACD,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAACtD,OAAD,CAAR;YACD;UACF;;UAED,IAAIyD,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAGI,UAAU,EAAf;;YAEA,IAAIJ,EAAE,KAAKhL,UAAX,EAAuB;cACrBiL,EAAE,GAAGI,kBAAkB,EAAvB;;cAEA,IAAIJ,EAAE,KAAKjL,UAAX,EAAuB;gBACrByL,EAAE,GAAGL,UAAU,EAAf;;gBAEA,IAAIK,EAAE,KAAKzL,UAAX,EAAuB;kBACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;oBACxCkC,EAAE,GAAGxF,OAAL;oBACAsD,WAAW;kBACZ,CAHD,MAGO;oBACLkC,EAAE,GAAG1L,UAAL;oBAEA;sBACE4K,QAAQ,CAACzE,OAAD,CAAR;oBACD;kBACF;;kBAED,IAAIuF,EAAE,KAAK1L,UAAX,EAAuB;oBACrB+K,EAAE,GAAGxD,OAAO,CAAC0D,EAAD,CAAZ;oBACAH,EAAE,GAAGC,EAAL;kBACD,CAHD,MAGO;oBACLvB,WAAW,GAAGsB,EAAd;oBACAA,EAAE,GAAG9K,UAAL;kBACD;gBACF,CAnBD,MAmBO;kBACLwJ,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF,CA1BD,MA0BO;gBACLwJ,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CAjCD,MAiCO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAxCD,MAwCO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASwB,YAAT,GAAwB;UACtB,IAAIxB,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB,EAAwBC,EAAxB;UACA,IAAI7X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,CAA1B,MAAiChC,OAArC,EAA8C;YAC5CuD,EAAE,GAAGvD,OAAL;YACAgC,WAAW,IAAI,CAAf;UACD,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAACnD,OAAD,CAAR;YACD;UACF;;UAED,IAAIsD,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAGI,UAAU,EAAf;;YAEA,IAAIJ,EAAE,KAAKhL,UAAX,EAAuB;cACrBiL,EAAE,GAAGI,kBAAkB,EAAvB;;cAEA,IAAIJ,EAAE,KAAKjL,UAAX,EAAuB;gBACrByL,EAAE,GAAGL,UAAU,EAAf;;gBAEA,IAAIK,EAAE,KAAKzL,UAAX,EAAuB;kBACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;oBACxCkC,EAAE,GAAGxF,OAAL;oBACAsD,WAAW;kBACZ,CAHD,MAGO;oBACLkC,EAAE,GAAG1L,UAAL;oBAEA;sBACE4K,QAAQ,CAACzE,OAAD,CAAR;oBACD;kBACF;;kBAED,IAAIuF,EAAE,KAAK1L,UAAX,EAAuB;oBACrB+K,EAAE,GAAGrD,OAAO,CAACuD,EAAD,CAAZ;oBACAH,EAAE,GAAGC,EAAL;kBACD,CAHD,MAGO;oBACLvB,WAAW,GAAGsB,EAAd;oBACAA,EAAE,GAAG9K,UAAL;kBACD;gBACF,CAnBD,MAmBO;kBACLwJ,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF,CA1BD,MA0BO;gBACLwJ,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CAjCD,MAiCO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAxCD,MAwCO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAASyB,mBAAT,GAA+B;UAC7B,IAAIzB,EAAJ,EAAQC,EAAR;UACA,IAAIlX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,EAA1B,MAAkC7B,OAAtC,EAA+C;YAC7CoD,EAAE,GAAGpD,OAAL;YACA6B,WAAW,IAAI,EAAf;UACD,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAAChD,OAAD,CAAR;YACD;UACF;;UAED,IAAImD,EAAE,KAAK/K,UAAX,EAAuB;YACrB+K,EAAE,GAAGlD,OAAO,EAAZ;UACD;;UAEDiD,EAAE,GAAGC,EAAL;UACAjB,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAAS0B,kBAAT,GAA8B;UAC5B,IAAI1B,EAAJ,EAAQC,EAAR;UACA,IAAIlX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,EAA1B,MAAkCzB,OAAtC,EAA+C;YAC7CgD,EAAE,GAAGhD,OAAL;YACAyB,WAAW,IAAI,EAAf;UACD,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAAC5C,OAAD,CAAR;YACD;UACF;;UAED,IAAI+C,EAAE,KAAK/K,UAAX,EAAuB;YACrB+K,EAAE,GAAG9C,OAAO,EAAZ;UACD;;UAED6C,EAAE,GAAGC,EAAL;UACAjB,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAAS2B,iBAAT,GAA6B;UAC3B,IAAI3B,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB,EAAwBC,EAAxB;UACA,IAAI7X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,EAA1B,MAAkCrB,OAAtC,EAA+C;YAC7C4C,EAAE,GAAG5C,OAAL;YACAqB,WAAW,IAAI,EAAf;UACD,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAACxC,OAAD,CAAR;YACD;UACF;;UAED,IAAI2C,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAGI,UAAU,EAAf;;YAEA,IAAIJ,EAAE,KAAKhL,UAAX,EAAuB;cACrBiL,EAAE,GAAG,EAAL;;cAEA,IAAIzF,OAAO,CAACzT,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;gBAC3CiC,EAAE,GAAG3L,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;gBACAA,WAAW;cACZ,CAHD,MAGO;gBACLiC,EAAE,GAAGzL,UAAL;gBAEA;kBACE4K,QAAQ,CAACnF,OAAD,CAAR;gBACD;cACF;;cAED,IAAIgG,EAAE,KAAKzL,UAAX,EAAuB;gBACrB,OAAOyL,EAAE,KAAKzL,UAAd,EAA0B;kBACxBiL,EAAE,CAAC7Z,IAAH,CAAQqa,EAAR;;kBAEA,IAAIjG,OAAO,CAACzT,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;oBAC3CiC,EAAE,GAAG3L,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;oBACAA,WAAW;kBACZ,CAHD,MAGO;oBACLiC,EAAE,GAAGzL,UAAL;oBAEA;sBACE4K,QAAQ,CAACnF,OAAD,CAAR;oBACD;kBACF;gBACF;cACF,CAfD,MAeO;gBACLwF,EAAE,GAAGjL,UAAL;cACD;;cAED,IAAIiL,EAAE,KAAKjL,UAAX,EAAuB;gBACrByL,EAAE,GAAGL,UAAU,EAAf;;gBAEA,IAAIK,EAAE,KAAKzL,UAAX,EAAuB;kBACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;oBACxCkC,EAAE,GAAGxF,OAAL;oBACAsD,WAAW;kBACZ,CAHD,MAGO;oBACLkC,EAAE,GAAG1L,UAAL;oBAEA;sBACE4K,QAAQ,CAACzE,OAAD,CAAR;oBACD;kBACF;;kBAED,IAAIuF,EAAE,KAAK1L,UAAX,EAAuB;oBACrB+K,EAAE,GAAG1C,OAAO,CAAC4C,EAAD,CAAZ;oBACAH,EAAE,GAAGC,EAAL;kBACD,CAHD,MAGO;oBACLvB,WAAW,GAAGsB,EAAd;oBACAA,EAAE,GAAG9K,UAAL;kBACD;gBACF,CAnBD,MAmBO;kBACLwJ,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF,CA1BD,MA0BO;gBACLwJ,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CA/DD,MA+DO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAtED,MAsEO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAAS4B,qBAAT,GAAiC;UAC/B,IAAI5B,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB,EAAoBQ,EAApB,EAAwBC,EAAxB;UACA,IAAI7X,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,EAA1B,MAAkCjB,OAAtC,EAA+C;YAC7CwC,EAAE,GAAGxC,OAAL;YACAiB,WAAW,IAAI,EAAf;UACD,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAACpC,OAAD,CAAR;YACD;UACF;;UAED,IAAIuC,EAAE,KAAK/K,UAAX,EAAuB;YACrBgL,EAAE,GAAGI,UAAU,EAAf;;YAEA,IAAIJ,EAAE,KAAKhL,UAAX,EAAuB;cACrBiL,EAAE,GAAG,EAAL;;cAEA,IAAIzF,OAAO,CAACzT,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;gBAC3CiC,EAAE,GAAG3L,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;gBACAA,WAAW;cACZ,CAHD,MAGO;gBACLiC,EAAE,GAAGzL,UAAL;gBAEA;kBACE4K,QAAQ,CAACnF,OAAD,CAAR;gBACD;cACF;;cAED,IAAIgG,EAAE,KAAKzL,UAAX,EAAuB;gBACrB,OAAOyL,EAAE,KAAKzL,UAAd,EAA0B;kBACxBiL,EAAE,CAAC7Z,IAAH,CAAQqa,EAAR;;kBAEA,IAAIjG,OAAO,CAACzT,IAAR,CAAa+N,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAb,CAAJ,EAA6C;oBAC3CiC,EAAE,GAAG3L,KAAK,CAACyL,MAAN,CAAa/B,WAAb,CAAL;oBACAA,WAAW;kBACZ,CAHD,MAGO;oBACLiC,EAAE,GAAGzL,UAAL;oBAEA;sBACE4K,QAAQ,CAACnF,OAAD,CAAR;oBACD;kBACF;gBACF;cACF,CAfD,MAeO;gBACLwF,EAAE,GAAGjL,UAAL;cACD;;cAED,IAAIiL,EAAE,KAAKjL,UAAX,EAAuB;gBACrByL,EAAE,GAAGL,UAAU,EAAf;;gBAEA,IAAIK,EAAE,KAAKzL,UAAX,EAAuB;kBACrB,IAAIF,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;oBACxCkC,EAAE,GAAGxF,OAAL;oBACAsD,WAAW;kBACZ,CAHD,MAGO;oBACLkC,EAAE,GAAG1L,UAAL;oBAEA;sBACE4K,QAAQ,CAACzE,OAAD,CAAR;oBACD;kBACF;;kBAED,IAAIuF,EAAE,KAAK1L,UAAX,EAAuB;oBACrB+K,EAAE,GAAGtC,OAAO,CAACwC,EAAD,CAAZ;oBACAH,EAAE,GAAGC,EAAL;kBACD,CAHD,MAGO;oBACLvB,WAAW,GAAGsB,EAAd;oBACAA,EAAE,GAAG9K,UAAL;kBACD;gBACF,CAnBD,MAmBO;kBACLwJ,WAAW,GAAGsB,EAAd;kBACAA,EAAE,GAAG9K,UAAL;gBACD;cACF,CA1BD,MA0BO;gBACLwJ,WAAW,GAAGsB,EAAd;gBACAA,EAAE,GAAG9K,UAAL;cACD;YACF,CA/DD,MA+DO;cACLwJ,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAtED,MAsEO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAAS6B,cAAT,GAA0B;UACxB,IAAI7B,EAAJ,EAAQC,EAAR,EAAYC,EAAZ;UACA,IAAInX,GAAG,GAAG2V,WAAW,GAAG,EAAd,GAAmB,EAA7B;UAAA,IACI0B,MAAM,GAAGpB,gBAAgB,CAACjW,GAAD,CAD7B;;UAGA,IAAIqX,MAAJ,EAAY;YACV1B,WAAW,GAAG0B,MAAM,CAACC,OAArB;YACA,OAAOD,MAAM,CAACnR,MAAd;UACD;;UAED+Q,EAAE,GAAGtB,WAAL;;UAEA,IAAI1J,KAAK,CAACT,UAAN,CAAiBmK,WAAjB,MAAkC,EAAtC,EAA0C;YACxCuB,EAAE,GAAGrC,QAAL;YACAc,WAAW;UACZ,CAHD,MAGO;YACLuB,EAAE,GAAG/K,UAAL;YAEA;cACE4K,QAAQ,CAACjC,QAAD,CAAR;YACD;UACF;;UAED,IAAIoC,EAAE,KAAK/K,UAAX,EAAuB;YACrB,IAAIF,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,CAA1B,EAA6B+D,WAA7B,OAA+C3E,QAAnD,EAA6D;cAC3DoC,EAAE,GAAGlL,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,CAA1B,CAAL;cACAA,WAAW,IAAI,CAAf;YACD,CAHD,MAGO;cACLwB,EAAE,GAAGhL,UAAL;cAEA;gBACE4K,QAAQ,CAAC/B,QAAD,CAAR;cACD;YACF;;YAED,IAAImC,EAAE,KAAKhL,UAAX,EAAuB;cACrB,IAAIF,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,EAA1B,EAA8B+D,WAA9B,OAAgDzE,QAApD,EAA8D;gBAC5DkC,EAAE,GAAGlL,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,EAA1B,CAAL;gBACAA,WAAW,IAAI,EAAf;cACD,CAHD,MAGO;gBACLwB,EAAE,GAAGhL,UAAL;gBAEA;kBACE4K,QAAQ,CAAC7B,QAAD,CAAR;gBACD;cACF;;cAED,IAAIiC,EAAE,KAAKhL,UAAX,EAAuB;gBACrB,IAAIF,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,EAA1B,EAA8B+D,WAA9B,OAAgDvE,QAApD,EAA8D;kBAC5DgC,EAAE,GAAGlL,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,EAA1B,CAAL;kBACAA,WAAW,IAAI,EAAf;gBACD,CAHD,MAGO;kBACLwB,EAAE,GAAGhL,UAAL;kBAEA;oBACE4K,QAAQ,CAAC3B,QAAD,CAAR;kBACD;gBACF;;gBAED,IAAI+B,EAAE,KAAKhL,UAAX,EAAuB;kBACrB,IAAIF,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,CAA1B,EAA6B+D,WAA7B,OAA+CrE,QAAnD,EAA6D;oBAC3D8B,EAAE,GAAGlL,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,CAA1B,CAAL;oBACAA,WAAW,IAAI,CAAf;kBACD,CAHD,MAGO;oBACLwB,EAAE,GAAGhL,UAAL;oBAEA;sBACE4K,QAAQ,CAACzB,QAAD,CAAR;oBACD;kBACF;;kBAED,IAAI6B,EAAE,KAAKhL,UAAX,EAAuB;oBACrB,IAAIF,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,CAA1B,EAA6B+D,WAA7B,OAA+CnE,QAAnD,EAA6D;sBAC3D4B,EAAE,GAAGlL,KAAK,CAACuN,MAAN,CAAa7D,WAAb,EAA0B,CAA1B,CAAL;sBACAA,WAAW,IAAI,CAAf;oBACD,CAHD,MAGO;sBACLwB,EAAE,GAAGhL,UAAL;sBAEA;wBACE4K,QAAQ,CAACvB,QAAD,CAAR;sBACD;oBACF;kBACF;gBACF;cACF;YACF;;YAED,IAAI2B,EAAE,KAAKhL,UAAX,EAAuB;cACrB+K,EAAE,GAAGzB,QAAQ,CAAC0B,EAAD,CAAb;cACAF,EAAE,GAAGC,EAAL;YACD,CAHD,MAGO;cACLvB,WAAW,GAAGsB,EAAd;cACAA,EAAE,GAAG9K,UAAL;YACD;UACF,CAvED,MAuEO;YACLwJ,WAAW,GAAGsB,EAAd;YACAA,EAAE,GAAG9K,UAAL;UACD;;UAED8J,gBAAgB,CAACjW,GAAD,CAAhB,GAAwB;YACtBsX,OAAO,EAAE3B,WADa;YAEtBzP,MAAM,EAAE+Q;UAFc,CAAxB;UAIA,OAAOA,EAAP;QACD;;QAED,SAAShD,GAAT,CAAapW,CAAb,EAAgB;UACd,OAAO;YACL0I,IAAI,EAAE,WADD;YAELoT,KAAK,EAAE;cACLpT,IAAI,EAAE,SADD;cAEL/I,KAAK,EAAEK;YAFF;UAFF,CAAP;QAOD;;QAED,SAASwW,OAAT,CAAiBxW,CAAjB,EAAoB;UAClB,OAAO;YACL0I,IAAI,EAAE,gBADD;YAELoT,KAAK,EAAE;cACLpT,IAAI,EAAE,SADD;cAEL/I,KAAK,EAAEK;YAFF;UAFF,CAAP;QAOD;;QAED,SAASyT,WAAT,CAAqB5S,CAArB,EAAwB;UACtB,OAAOA,CAAC,CAAC4G,OAAF,CAAU,QAAV,EAAoB,UAAUsU,KAAV,EAAiBrO,EAAjB,EAAqB;YAC9C,QAAQA,EAAR;cACE,KAAK,GAAL;gBACE,OAAO,IAAP;;cAEF,KAAK,GAAL;gBACE,OAAO,IAAP;;cAEF,KAAK,GAAL;gBACE,OAAO,IAAP;;cAEF,KAAK,GAAL;gBACE,OAAO,IAAP;;cAEF,KAAK,GAAL;gBACE,OAAO,IAAP;;cAEF,KAAK,GAAL;gBACE,OAAO,IAAP;;cAEF;gBACE,OAAOA,EAAP;YApBJ;UAsBD,CAvBM,CAAP;QAwBD;;QAED2K,UAAU,GAAG3J,qBAAqB,EAAlC;;QAEA,IAAI2J,UAAU,KAAK/J,UAAf,IAA6BwJ,WAAW,KAAK1J,KAAK,CAACxO,MAAvD,EAA+D;UAC7D,OAAOyY,UAAP;QACD,CAFD,MAEO;UACL,IAAIA,UAAU,KAAK/J,UAAf,IAA6BwJ,WAAW,GAAG1J,KAAK,CAACxO,MAArD,EAA6D;YAC3DsZ,QAAQ,CAACV,kBAAkB,EAAnB,CAAR;UACD;;UAED,MAAMW,wBAAwB,CAAChB,mBAAD,EAAsBD,cAAc,GAAG9J,KAAK,CAACxO,MAAvB,GAAgCwO,KAAK,CAACyL,MAAN,CAAa3B,cAAb,CAAhC,GAA+D,IAArF,EAA2FA,cAAc,GAAG9J,KAAK,CAACxO,MAAvB,GAAgCgZ,mBAAmB,CAACV,cAAD,EAAiBA,cAAc,GAAG,CAAlC,CAAnD,GAA0FU,mBAAmB,CAACV,cAAD,EAAiBA,cAAjB,CAAxM,CAA9B;QACD;MACF;;MAED,OAAO;QACL8D,WAAW,EAAE5P,eADR;QAEL6P,KAAK,EAAE9N;MAFF,CAAP;IAID,CAniGD;EAoiGD,CA1iGgC,CAAjC;;EA4iGA,SAAS+N,cAAT,CAAwBve,GAAxB,EAA6B;IAC3B,IAAIwe,OAAO,GAAG,EAAd;IACA,IAAI1S,IAAI,GAAG1K,MAAM,CAAC0K,IAAP,CAAY9L,GAAZ,CAAX;;IAEA,KAAK,IAAIye,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG3S,IAAI,CAAC7J,MAAzB,EAAiCwc,CAAC,EAAlC,EAAsCD,OAAO,CAACzc,IAAR,CAAa,CAAC+J,IAAI,CAAC2S,CAAD,CAAL,EAAUze,GAAG,CAAC8L,IAAI,CAAC2S,CAAD,CAAL,CAAb,CAAb;;IAEtC,OAAOD,OAAP;EACD;EACD;AACF;AACA;;;EAEE,IAAIE,SAAS,GAAG,WAAhB;EACA,IAAIC,UAAU,GAAG,YAAjB;EACA;AACF;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE,SAASC,OAAT,CAAiB5e,GAAjB,EAAsBwE,GAAtB,EAA2B;IACzB,IAAIsH,IAAI,GAAGtH,GAAG,CAACqa,KAAJ,CAAU,GAAV,CAAX;;IAEA,IAAIC,SAAS,GAAGhc,0BAA0B,CAACgJ,IAAD,CAA1C;IAAA,IACIiT,KADJ;;IAGA,IAAI;MACF,KAAKD,SAAS,CAAC5b,CAAV,EAAL,EAAoB,CAAC,CAAC6b,KAAK,GAAGD,SAAS,CAACzc,CAAV,EAAT,EAAwBP,IAA7C,GAAoD;QAClD,IAAIkd,IAAI,GAAGD,KAAK,CAAC/c,KAAjB;;QAEA,IAAIhC,GAAG,IAAI,IAAX,EAAiB;UACf,OAAOA,GAAP;QACD;;QAEDA,GAAG,GAAGA,GAAG,CAACgf,IAAD,CAAT;MACD;IACF,CAVD,CAUE,OAAO9c,GAAP,EAAY;MACZ4c,SAAS,CAAC3b,CAAV,CAAYjB,GAAZ;IACD,CAZD,SAYU;MACR4c,SAAS,CAAC1b,CAAV;IACD;;IAED,OAAOpD,GAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAASif,MAAT,CAAgBlV,IAAhB,EAAsBmV,QAAtB,EAAgC/U,IAAhC,EAAsC;IACpC,IAAIA,IAAI,CAAClI,MAAL,KAAgB,CAApB,EAAuB;MACrB,OAAO8H,IAAI,KAAKmV,QAAhB;IACD;;IAED,IAAIA,QAAQ,IAAI,IAAhB,EAAsB;MACpB,OAAO,KAAP;IACD;;IAED,IAAIC,KAAK,GAAGD,QAAQ,CAAC/U,IAAI,CAAC,CAAD,CAAL,CAApB;IACA,IAAIiV,aAAa,GAAGjV,IAAI,CAAC3H,KAAL,CAAW,CAAX,CAApB;;IAEA,IAAIxB,KAAK,CAACC,OAAN,CAAcke,KAAd,CAAJ,EAA0B;MACxB,IAAIE,UAAU,GAAGvc,0BAA0B,CAACqc,KAAD,CAA3C;MAAA,IACIG,MADJ;;MAGA,IAAI;QACF,KAAKD,UAAU,CAACnc,CAAX,EAAL,EAAqB,CAAC,CAACoc,MAAM,GAAGD,UAAU,CAAChd,CAAX,EAAV,EAA0BP,IAAhD,GAAuD;UACrD,IAAIyd,SAAS,GAAGD,MAAM,CAACtd,KAAvB;;UAEA,IAAIid,MAAM,CAAClV,IAAD,EAAOwV,SAAP,EAAkBH,aAAlB,CAAV,EAA4C;YAC1C,OAAO,IAAP;UACD;QACF;MACF,CARD,CAQE,OAAOld,GAAP,EAAY;QACZmd,UAAU,CAAClc,CAAX,CAAajB,GAAb;MACD,CAVD,SAUU;QACRmd,UAAU,CAACjc,CAAX;MACD;;MAED,OAAO,KAAP;IACD,CAnBD,MAmBO;MACL,OAAO6b,MAAM,CAAClV,IAAD,EAAOoV,KAAP,EAAcC,aAAd,CAAb;IACD;EACF;EACD;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAASI,OAAT,CAAiBzV,IAAjB,EAAuB0V,QAAvB,EAAiCC,QAAjC,EAA2ChP,OAA3C,EAAoD;IAClD,IAAI,CAAC+O,QAAL,EAAe;MACb,OAAO,IAAP;IACD;;IAED,IAAI,CAAC1V,IAAL,EAAW;MACT,OAAO,KAAP;IACD;;IAED,IAAI,CAAC2V,QAAL,EAAe;MACbA,QAAQ,GAAG,EAAX;IACD;;IAED,QAAQD,QAAQ,CAAC1U,IAAjB;MACE,KAAK,UAAL;QACE,OAAO,IAAP;;MAEF,KAAK,YAAL;QACE,OAAO0U,QAAQ,CAACzd,KAAT,CAAekc,WAAf,OAAiCnU,IAAI,CAACgB,IAAL,CAAUmT,WAAV,EAAxC;;MAEF,KAAK,OAAL;QACE;UACE,IAAI/T,IAAI,GAAGsV,QAAQ,CAAChd,IAAT,CAAcoc,KAAd,CAAoB,GAApB,CAAX;UACA,IAAIK,QAAQ,GAAGQ,QAAQ,CAACvV,IAAI,CAAClI,MAAL,GAAc,CAAf,CAAvB;UACA,OAAOgd,MAAM,CAAClV,IAAD,EAAOmV,QAAP,EAAiB/U,IAAjB,CAAb;QACD;;MAEH,KAAK,SAAL;QACE,IAAIwV,UAAU,GAAG7c,0BAA0B,CAAC2c,QAAQ,CAACvO,SAAV,CAA3C;QAAA,IACI0O,MADJ;;QAGA,IAAI;UACF,KAAKD,UAAU,CAACzc,CAAX,EAAL,EAAqB,CAAC,CAAC0c,MAAM,GAAGD,UAAU,CAACtd,CAAX,EAAV,EAA0BP,IAAhD,GAAuD;YACrD,IAAI+d,GAAG,GAAGD,MAAM,CAAC5d,KAAjB;;YAEA,IAAIwd,OAAO,CAACzV,IAAD,EAAO8V,GAAP,EAAYH,QAAZ,EAAsBhP,OAAtB,CAAX,EAA2C;cACzC,OAAO,IAAP;YACD;UACF;QACF,CARD,CAQE,OAAOxO,GAAP,EAAY;UACZyd,UAAU,CAACxc,CAAX,CAAajB,GAAb;QACD,CAVD,SAUU;UACRyd,UAAU,CAACvc,CAAX;QACD;;QAED,OAAO,KAAP;;MAEF,KAAK,UAAL;QACE,IAAI0c,UAAU,GAAGhd,0BAA0B,CAAC2c,QAAQ,CAACvO,SAAV,CAA3C;QAAA,IACI6O,MADJ;;QAGA,IAAI;UACF,KAAKD,UAAU,CAAC5c,CAAX,EAAL,EAAqB,CAAC,CAAC6c,MAAM,GAAGD,UAAU,CAACzd,CAAX,EAAV,EAA0BP,IAAhD,GAAuD;YACrD,IAAIke,IAAI,GAAGD,MAAM,CAAC/d,KAAlB;;YAEA,IAAI,CAACwd,OAAO,CAACzV,IAAD,EAAOiW,IAAP,EAAaN,QAAb,EAAuBhP,OAAvB,CAAZ,EAA6C;cAC3C,OAAO,KAAP;YACD;UACF;QACF,CARD,CAQE,OAAOxO,GAAP,EAAY;UACZ4d,UAAU,CAAC3c,CAAX,CAAajB,GAAb;QACD,CAVD,SAUU;UACR4d,UAAU,CAAC1c,CAAX;QACD;;QAED,OAAO,IAAP;;MAEF,KAAK,KAAL;QACE,IAAI6c,UAAU,GAAGnd,0BAA0B,CAAC2c,QAAQ,CAACvO,SAAV,CAA3C;QAAA,IACIgP,MADJ;;QAGA,IAAI;UACF,KAAKD,UAAU,CAAC/c,CAAX,EAAL,EAAqB,CAAC,CAACgd,MAAM,GAAGD,UAAU,CAAC5d,CAAX,EAAV,EAA0BP,IAAhD,GAAuD;YACrD,IAAIqe,KAAK,GAAGD,MAAM,CAACle,KAAnB;;YAEA,IAAIwd,OAAO,CAACzV,IAAD,EAAOoW,KAAP,EAAcT,QAAd,EAAwBhP,OAAxB,CAAX,EAA6C;cAC3C,OAAO,KAAP;YACD;UACF;QACF,CARD,CAQE,OAAOxO,GAAP,EAAY;UACZ+d,UAAU,CAAC9c,CAAX,CAAajB,GAAb;QACD,CAVD,SAUU;UACR+d,UAAU,CAAC7c,CAAX;QACD;;QAED,OAAO,IAAP;;MAEF,KAAK,KAAL;QACE;UACE,IAAIgd,IAAI,GAAG,YAAY;YACrB,IAAIC,SAAS,GAAG,EAAhB;;YAEA,IAAIC,UAAU,GAAGxd,0BAA0B,CAAC2c,QAAQ,CAACvO,SAAV,CAA3C;YAAA,IACIqP,MADJ;;YAGA,IAAI;cACF,IAAIC,KAAK,GAAG,SAASA,KAAT,GAAiB;gBAC3B,IAAIX,GAAG,GAAGU,MAAM,CAACve,KAAjB;gBACA,IAAI2Q,CAAC,GAAG,EAAR;gBACA7O,UAAU,CAAC0I,QAAX,CAAoBzC,IAApB,EAA0B;kBACxBgD,KAAK,EAAE,SAASA,KAAT,CAAehD,IAAf,EAAqBF,MAArB,EAA6B;oBAClC,IAAIA,MAAM,IAAI,IAAd,EAAoB;sBAClB8I,CAAC,CAAC8N,OAAF,CAAU5W,MAAV;oBACD;;oBAED,IAAI2V,OAAO,CAACzV,IAAD,EAAO8V,GAAP,EAAYlN,CAAZ,EAAejC,OAAf,CAAX,EAAoC;sBAClC2P,SAAS,CAACte,IAAV,CAAegI,IAAf;oBACD;kBACF,CATuB;kBAUxB+C,KAAK,EAAE,SAASA,KAAT,GAAiB;oBACtB6F,CAAC,CAAC+N,KAAF;kBACD,CAZuB;kBAaxB5U,IAAI,EAAE4E,OAAO,IAAIA,OAAO,CAACiQ,WAbD;kBAcxB9U,QAAQ,EAAE6E,OAAO,IAAIA,OAAO,CAAC7E,QAAnB,IAA+B;gBAdjB,CAA1B;cAgBD,CAnBD;;cAqBA,KAAKyU,UAAU,CAACpd,CAAX,EAAL,EAAqB,CAAC,CAACqd,MAAM,GAAGD,UAAU,CAACje,CAAX,EAAV,EAA0BP,IAAhD,GAAuD;gBACrD0e,KAAK;cACN;YACF,CAzBD,CAyBE,OAAOte,GAAP,EAAY;cACZoe,UAAU,CAACnd,CAAX,CAAajB,GAAb;YACD,CA3BD,SA2BU;cACRoe,UAAU,CAACld,CAAX;YACD;;YAED,OAAO;cACL+Q,CAAC,EAAEkM,SAAS,CAACpe,MAAV,KAAqB;YADnB,CAAP;UAGD,CAxCU,EAAX;;UA0CA,IAAIlC,OAAO,CAACqgB,IAAD,CAAP,KAAkB,QAAtB,EAAgC,OAAOA,IAAI,CAACjM,CAAZ;QACjC;;MAEH,KAAK,OAAL;QACE,IAAIqL,OAAO,CAACzV,IAAD,EAAO0V,QAAQ,CAACxM,KAAhB,EAAuByM,QAAvB,EAAiChP,OAAjC,CAAX,EAAsD;UACpD,OAAO8O,OAAO,CAACE,QAAQ,CAAC,CAAD,CAAT,EAAcD,QAAQ,CAACzM,IAAvB,EAA6B0M,QAAQ,CAACld,KAAT,CAAe,CAAf,CAA7B,EAAgDkO,OAAhD,CAAd;QACD;;QAED,OAAO,KAAP;;MAEF,KAAK,YAAL;QACE,IAAI8O,OAAO,CAACzV,IAAD,EAAO0V,QAAQ,CAACxM,KAAhB,EAAuByM,QAAvB,EAAiChP,OAAjC,CAAX,EAAsD;UACpD,KAAK,IAAInQ,CAAC,GAAG,CAAR,EAAWqgB,CAAC,GAAGlB,QAAQ,CAACzd,MAA7B,EAAqC1B,CAAC,GAAGqgB,CAAzC,EAA4C,EAAErgB,CAA9C,EAAiD;YAC/C,IAAIif,OAAO,CAACE,QAAQ,CAACnf,CAAD,CAAT,EAAckf,QAAQ,CAACzM,IAAvB,EAA6B0M,QAAQ,CAACld,KAAT,CAAejC,CAAC,GAAG,CAAnB,CAA7B,EAAoDmQ,OAApD,CAAX,EAAyE;cACvE,OAAO,IAAP;YACD;UACF;QACF;;QAED,OAAO,KAAP;;MAEF,KAAK,WAAL;QACE;UACE,IAAIkH,CAAC,GAAGgH,OAAO,CAAC7U,IAAD,EAAO0V,QAAQ,CAAChd,IAAhB,CAAf;;UAEA,QAAQgd,QAAQ,CAACxK,QAAjB;YACE,KAAK,KAAK,CAAV;cACE,OAAO2C,CAAC,IAAI,IAAZ;;YAEF,KAAK,GAAL;cACE,QAAQ6H,QAAQ,CAACzd,KAAT,CAAe+I,IAAvB;gBACE,KAAK,QAAL;kBACE,OAAO,OAAO6M,CAAP,KAAa,QAAb,IAAyB6H,QAAQ,CAACzd,KAAT,CAAeA,KAAf,CAAqBU,IAArB,CAA0BkV,CAA1B,CAAhC;;gBAEF,KAAK,SAAL;kBACE,OAAO,GAAGpF,MAAH,CAAUiN,QAAQ,CAACzd,KAAT,CAAeA,KAAzB,MAAoC,GAAGwQ,MAAH,CAAUoF,CAAV,CAA3C;;gBAEF,KAAK,MAAL;kBACE,OAAO6H,QAAQ,CAACzd,KAAT,CAAeA,KAAf,KAAyBjC,OAAO,CAAC6X,CAAD,CAAvC;cARJ;;cAWA,MAAM,IAAI5K,KAAJ,CAAU,gCAAgCwF,MAAhC,CAAuCiN,QAAQ,CAACzd,KAAT,CAAe+I,IAAtD,CAAV,CAAN;;YAEF,KAAK,IAAL;cACE,QAAQ0U,QAAQ,CAACzd,KAAT,CAAe+I,IAAvB;gBACE,KAAK,QAAL;kBACE,OAAO,CAAC0U,QAAQ,CAACzd,KAAT,CAAeA,KAAf,CAAqBU,IAArB,CAA0BkV,CAA1B,CAAR;;gBAEF,KAAK,SAAL;kBACE,OAAO,GAAGpF,MAAH,CAAUiN,QAAQ,CAACzd,KAAT,CAAeA,KAAzB,MAAoC,GAAGwQ,MAAH,CAAUoF,CAAV,CAA3C;;gBAEF,KAAK,MAAL;kBACE,OAAO6H,QAAQ,CAACzd,KAAT,CAAeA,KAAf,KAAyBjC,OAAO,CAAC6X,CAAD,CAAvC;cARJ;;cAWA,MAAM,IAAI5K,KAAJ,CAAU,gCAAgCwF,MAAhC,CAAuCiN,QAAQ,CAACzd,KAAT,CAAe+I,IAAtD,CAAV,CAAN;;YAEF,KAAK,IAAL;cACE,OAAO6M,CAAC,IAAI6H,QAAQ,CAACzd,KAAT,CAAeA,KAA3B;;YAEF,KAAK,GAAL;cACE,OAAO4V,CAAC,GAAG6H,QAAQ,CAACzd,KAAT,CAAeA,KAA1B;;YAEF,KAAK,GAAL;cACE,OAAO4V,CAAC,GAAG6H,QAAQ,CAACzd,KAAT,CAAeA,KAA1B;;YAEF,KAAK,IAAL;cACE,OAAO4V,CAAC,IAAI6H,QAAQ,CAACzd,KAAT,CAAeA,KAA3B;UA1CJ;;UA6CA,MAAM,IAAIgL,KAAJ,CAAU,qBAAqBwF,MAArB,CAA4BiN,QAAQ,CAACxK,QAArC,CAAV,CAAN;QACD;;MAEH,KAAK,SAAL;QACE,OAAOuK,OAAO,CAACzV,IAAD,EAAO0V,QAAQ,CAACxM,KAAhB,EAAuByM,QAAvB,EAAiChP,OAAjC,CAAP,IAAoDmQ,OAAO,CAAC9W,IAAD,EAAO0V,QAAQ,CAACzM,IAAhB,EAAsB0M,QAAtB,EAAgChB,SAAhC,EAA2ChO,OAA3C,CAA3D,IAAkH+O,QAAQ,CAACzM,IAAT,CAAcK,OAAd,IAAyBmM,OAAO,CAACzV,IAAD,EAAO0V,QAAQ,CAACzM,IAAhB,EAAsB0M,QAAtB,EAAgChP,OAAhC,CAAhC,IAA4EmQ,OAAO,CAAC9W,IAAD,EAAO0V,QAAQ,CAACxM,KAAhB,EAAuByM,QAAvB,EAAiCf,UAAjC,EAA6CjO,OAA7C,CAA5M;;MAEF,KAAK,UAAL;QACE,OAAO8O,OAAO,CAACzV,IAAD,EAAO0V,QAAQ,CAACxM,KAAhB,EAAuByM,QAAvB,EAAiChP,OAAjC,CAAP,IAAoDoQ,QAAQ,CAAC/W,IAAD,EAAO0V,QAAQ,CAACzM,IAAhB,EAAsB0M,QAAtB,EAAgChB,SAAhC,EAA2ChO,OAA3C,CAA5D,IAAmH+O,QAAQ,CAACxM,KAAT,CAAeI,OAAf,IAA0BmM,OAAO,CAACzV,IAAD,EAAO0V,QAAQ,CAACzM,IAAhB,EAAsB0M,QAAtB,EAAgChP,OAAhC,CAAjC,IAA6EoQ,QAAQ,CAAC/W,IAAD,EAAO0V,QAAQ,CAACxM,KAAhB,EAAuByM,QAAvB,EAAiCf,UAAjC,EAA6CjO,OAA7C,CAA/M;;MAEF,KAAK,WAAL;QACE,OAAO8O,OAAO,CAACzV,IAAD,EAAO0V,QAAQ,CAACxM,KAAhB,EAAuByM,QAAvB,EAAiChP,OAAjC,CAAP,IAAoDqQ,QAAQ,CAAChX,IAAD,EAAO2V,QAAP,EAAiB,YAAY;UAC9F,OAAOD,QAAQ,CAACtB,KAAT,CAAenc,KAAf,GAAuB,CAA9B;QACD,CAFkE,EAEhE0O,OAFgE,CAAnE;;MAIF,KAAK,gBAAL;QACE,OAAO8O,OAAO,CAACzV,IAAD,EAAO0V,QAAQ,CAACxM,KAAhB,EAAuByM,QAAvB,EAAiChP,OAAjC,CAAP,IAAoDqQ,QAAQ,CAAChX,IAAD,EAAO2V,QAAP,EAAiB,UAAUzd,MAAV,EAAkB;UACpG,OAAOA,MAAM,GAAGwd,QAAQ,CAACtB,KAAT,CAAenc,KAA/B;QACD,CAFkE,EAEhE0O,OAFgE,CAAnE;;MAIF,KAAK,OAAL;QACE,QAAQ+O,QAAQ,CAAChd,IAAT,CAAcyb,WAAd,EAAR;UACE,KAAK,WAAL;YACE,IAAInU,IAAI,CAACgB,IAAL,CAAUvI,KAAV,CAAgB,CAAC,CAAjB,MAAwB,WAA5B,EAAyC,OAAO,IAAP;UAC3C;;UAEA,KAAK,aAAL;YACE,OAAOuH,IAAI,CAACgB,IAAL,CAAUvI,KAAV,CAAgB,CAAC,EAAjB,MAAyB,aAAhC;;UAEF,KAAK,SAAL;YACE,IAAIuH,IAAI,CAACgB,IAAL,CAAUvI,KAAV,CAAgB,CAAC,CAAjB,MAAwB,SAA5B,EAAuC,OAAO,IAAP;UACzC;;UAEA,KAAK,YAAL;YACE,OAAOuH,IAAI,CAACgB,IAAL,CAAUvI,KAAV,CAAgB,CAAC,EAAjB,MAAyB,YAAzB,IAAyCuH,IAAI,CAACgB,IAAL,CAAUvI,KAAV,CAAgB,CAAC,CAAjB,MAAwB,SAAjE,IAA8EuH,IAAI,CAACgB,IAAL,KAAc,YAAd,KAA+B2U,QAAQ,CAACzd,MAAT,KAAoB,CAApB,IAAyByd,QAAQ,CAAC,CAAD,CAAR,CAAY3U,IAAZ,KAAqB,cAA7E,CAA9E,IAA8KhB,IAAI,CAACgB,IAAL,KAAc,cAAnM;;UAEF,KAAK,UAAL;YACE,OAAOhB,IAAI,CAACgB,IAAL,KAAc,qBAAd,IAAuChB,IAAI,CAACgB,IAAL,KAAc,oBAArD,IAA6EhB,IAAI,CAACgB,IAAL,KAAc,yBAAlG;QAhBJ;;QAmBA,MAAM,IAAIiC,KAAJ,CAAU,uBAAuBwF,MAAvB,CAA8BiN,QAAQ,CAAChd,IAAvC,CAAV,CAAN;IAnOJ;;IAsOA,MAAM,IAAIuK,KAAJ,CAAU,0BAA0BwF,MAA1B,CAAiCiN,QAAQ,CAAC1U,IAA1C,CAAV,CAAN;EACD;EACD;AACF;AACA;AACA;AACA;AACA;;;EAGE,SAASiW,cAAT,CAAwBjX,IAAxB,EAA8B2G,OAA9B,EAAuC;IACrC,IAAItE,QAAQ,GAAGrC,IAAI,CAACgB,IAApB;;IAEA,IAAI2F,OAAO,IAAIA,OAAO,CAACiQ,WAAnB,IAAkCjQ,OAAO,CAACiQ,WAAR,CAAoBvU,QAApB,CAAtC,EAAqE;MACnE,OAAOsE,OAAO,CAACiQ,WAAR,CAAoBvU,QAApB,CAAP;IACD;;IAED,IAAItI,UAAU,CAACI,WAAX,CAAuBkI,QAAvB,CAAJ,EAAsC;MACpC,OAAOtI,UAAU,CAACI,WAAX,CAAuBkI,QAAvB,CAAP;IACD;;IAED,IAAIsE,OAAO,IAAI,OAAOA,OAAO,CAAC7E,QAAf,KAA4B,UAA3C,EAAuD;MACrD,OAAO6E,OAAO,CAAC7E,QAAR,CAAiB9B,IAAjB,CAAP;IACD,CAboC,CAanC;;;IAGF,OAAO3I,MAAM,CAAC0K,IAAP,CAAY/B,IAAZ,EAAkBkX,MAAlB,CAAyB,UAAUzc,GAAV,EAAe;MAC7C,OAAOA,GAAG,KAAK,MAAf;IACD,CAFM,CAAP;EAGD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAAS0H,MAAT,CAAgBnC,IAAhB,EAAsB;IACpB,OAAOA,IAAI,KAAK,IAAT,IAAiBhK,OAAO,CAACgK,IAAD,CAAP,KAAkB,QAAnC,IAA+C,OAAOA,IAAI,CAACgB,IAAZ,KAAqB,QAA3E;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAAS8V,OAAT,CAAiB9W,IAAjB,EAAuB0V,QAAvB,EAAiCC,QAAjC,EAA2CwB,IAA3C,EAAiDxQ,OAAjD,EAA0D;IACxD,IAAIyQ,SAAS,GAAG9gB,cAAc,CAACqf,QAAD,EAAW,CAAX,CAA9B;IAAA,IACI7V,MAAM,GAAGsX,SAAS,CAAC,CAAD,CADtB;;IAGA,IAAI,CAACtX,MAAL,EAAa;MACX,OAAO,KAAP;IACD;;IAED,IAAIiC,IAAI,GAAGkV,cAAc,CAACnX,MAAD,EAAS6G,OAAT,CAAzB;;IAEA,IAAI0Q,UAAU,GAAGte,0BAA0B,CAACgJ,IAAD,CAA3C;IAAA,IACIuV,MADJ;;IAGA,IAAI;MACF,KAAKD,UAAU,CAACle,CAAX,EAAL,EAAqB,CAAC,CAACme,MAAM,GAAGD,UAAU,CAAC/e,CAAX,EAAV,EAA0BP,IAAhD,GAAuD;QACrD,IAAI0C,GAAG,GAAG6c,MAAM,CAACrf,KAAjB;QACA,IAAIsf,QAAQ,GAAGzX,MAAM,CAACrF,GAAD,CAArB;;QAEA,IAAIxD,KAAK,CAACC,OAAN,CAAcqgB,QAAd,CAAJ,EAA6B;UAC3B,IAAIC,UAAU,GAAGD,QAAQ,CAACE,OAAT,CAAiBzX,IAAjB,CAAjB;;UAEA,IAAIwX,UAAU,GAAG,CAAjB,EAAoB;YAClB;UACD;;UAED,IAAIE,UAAU,GAAG,KAAK,CAAtB;UAAA,IACI9c,UAAU,GAAG,KAAK,CADtB;;UAGA,IAAIuc,IAAI,KAAKxC,SAAb,EAAwB;YACtB+C,UAAU,GAAG,CAAb;YACA9c,UAAU,GAAG4c,UAAb;UACD,CAHD,MAGO;YACLE,UAAU,GAAGF,UAAU,GAAG,CAA1B;YACA5c,UAAU,GAAG2c,QAAQ,CAACrf,MAAtB;UACD;;UAED,KAAK,IAAIwc,CAAC,GAAGgD,UAAb,EAAyBhD,CAAC,GAAG9Z,UAA7B,EAAyC,EAAE8Z,CAA3C,EAA8C;YAC5C,IAAIvS,MAAM,CAACoV,QAAQ,CAAC7C,CAAD,CAAT,CAAN,IAAuBe,OAAO,CAAC8B,QAAQ,CAAC7C,CAAD,CAAT,EAAcgB,QAAd,EAAwBC,QAAxB,EAAkChP,OAAlC,CAAlC,EAA8E;cAC5E,OAAO,IAAP;YACD;UACF;QACF;MACF;IACF,CA9BD,CA8BE,OAAOxO,GAAP,EAAY;MACZkf,UAAU,CAACje,CAAX,CAAajB,GAAb;IACD,CAhCD,SAgCU;MACRkf,UAAU,CAAChe,CAAX;IACD;;IAED,OAAO,KAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAAS0d,QAAT,CAAkB/W,IAAlB,EAAwB0V,QAAxB,EAAkCC,QAAlC,EAA4CwB,IAA5C,EAAkDxQ,OAAlD,EAA2D;IACzD,IAAIgR,UAAU,GAAGrhB,cAAc,CAACqf,QAAD,EAAW,CAAX,CAA/B;IAAA,IACI7V,MAAM,GAAG6X,UAAU,CAAC,CAAD,CADvB;;IAGA,IAAI,CAAC7X,MAAL,EAAa;MACX,OAAO,KAAP;IACD;;IAED,IAAIiC,IAAI,GAAGkV,cAAc,CAACnX,MAAD,EAAS6G,OAAT,CAAzB;;IAEA,IAAIiR,UAAU,GAAG7e,0BAA0B,CAACgJ,IAAD,CAA3C;IAAA,IACI8V,MADJ;;IAGA,IAAI;MACF,KAAKD,UAAU,CAACze,CAAX,EAAL,EAAqB,CAAC,CAAC0e,MAAM,GAAGD,UAAU,CAACtf,CAAX,EAAV,EAA0BP,IAAhD,GAAuD;QACrD,IAAI0C,GAAG,GAAGod,MAAM,CAAC5f,KAAjB;QACA,IAAIsf,QAAQ,GAAGzX,MAAM,CAACrF,GAAD,CAArB;;QAEA,IAAIxD,KAAK,CAACC,OAAN,CAAcqgB,QAAd,CAAJ,EAA6B;UAC3B,IAAIO,GAAG,GAAGP,QAAQ,CAACE,OAAT,CAAiBzX,IAAjB,CAAV;;UAEA,IAAI8X,GAAG,GAAG,CAAV,EAAa;YACX;UACD;;UAED,IAAIX,IAAI,KAAKxC,SAAT,IAAsBmD,GAAG,GAAG,CAA5B,IAAiC3V,MAAM,CAACoV,QAAQ,CAACO,GAAG,GAAG,CAAP,CAAT,CAAvC,IAA8DrC,OAAO,CAAC8B,QAAQ,CAACO,GAAG,GAAG,CAAP,CAAT,EAAoBpC,QAApB,EAA8BC,QAA9B,EAAwChP,OAAxC,CAAzE,EAA2H;YACzH,OAAO,IAAP;UACD;;UAED,IAAIwQ,IAAI,KAAKvC,UAAT,IAAuBkD,GAAG,GAAGP,QAAQ,CAACrf,MAAT,GAAkB,CAA/C,IAAoDiK,MAAM,CAACoV,QAAQ,CAACO,GAAG,GAAG,CAAP,CAAT,CAA1D,IAAiFrC,OAAO,CAAC8B,QAAQ,CAACO,GAAG,GAAG,CAAP,CAAT,EAAoBpC,QAApB,EAA8BC,QAA9B,EAAwChP,OAAxC,CAA5F,EAA8I;YAC5I,OAAO,IAAP;UACD;QACF;MACF;IACF,CArBD,CAqBE,OAAOxO,GAAP,EAAY;MACZyf,UAAU,CAACxe,CAAX,CAAajB,GAAb;IACD,CAvBD,SAuBU;MACRyf,UAAU,CAACve,CAAX;IACD;;IAED,OAAO,KAAP;EACD;EACD;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAAS2d,QAAT,CAAkBhX,IAAlB,EAAwB2V,QAAxB,EAAkCoC,KAAlC,EAAyCpR,OAAzC,EAAkD;IAChD,IAAIqR,UAAU,GAAG1hB,cAAc,CAACqf,QAAD,EAAW,CAAX,CAA/B;IAAA,IACI7V,MAAM,GAAGkY,UAAU,CAAC,CAAD,CADvB;;IAGA,IAAI,CAAClY,MAAL,EAAa;MACX,OAAO,KAAP;IACD;;IAED,IAAIiC,IAAI,GAAGkV,cAAc,CAACnX,MAAD,EAAS6G,OAAT,CAAzB;;IAEA,IAAIsR,UAAU,GAAGlf,0BAA0B,CAACgJ,IAAD,CAA3C;IAAA,IACImW,MADJ;;IAGA,IAAI;MACF,KAAKD,UAAU,CAAC9e,CAAX,EAAL,EAAqB,CAAC,CAAC+e,MAAM,GAAGD,UAAU,CAAC3f,CAAX,EAAV,EAA0BP,IAAhD,GAAuD;QACrD,IAAI0C,GAAG,GAAGyd,MAAM,CAACjgB,KAAjB;QACA,IAAIsf,QAAQ,GAAGzX,MAAM,CAACrF,GAAD,CAArB;;QAEA,IAAIxD,KAAK,CAACC,OAAN,CAAcqgB,QAAd,CAAJ,EAA6B;UAC3B,IAAIO,GAAG,GAAGP,QAAQ,CAACE,OAAT,CAAiBzX,IAAjB,CAAV;;UAEA,IAAI8X,GAAG,IAAI,CAAP,IAAYA,GAAG,KAAKC,KAAK,CAACR,QAAQ,CAACrf,MAAV,CAA7B,EAAgD;YAC9C,OAAO,IAAP;UACD;QACF;MACF;IACF,CAbD,CAaE,OAAOC,GAAP,EAAY;MACZ8f,UAAU,CAAC7e,CAAX,CAAajB,GAAb;IACD,CAfD,SAeU;MACR8f,UAAU,CAAC5e,CAAX;IACD;;IAED,OAAO,KAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAAS8e,QAAT,CAAkBzC,QAAlB,EAA4BP,QAA5B,EAAsC;IACpC,IAAIO,QAAQ,IAAI,IAAZ,IAAoB1f,OAAO,CAAC0f,QAAD,CAAP,IAAqB,QAA7C,EAAuD;MACrD,OAAO,EAAP;IACD;;IAED,IAAIP,QAAQ,IAAI,IAAhB,EAAsB;MACpBA,QAAQ,GAAGO,QAAX;IACD;;IAED,IAAI0C,OAAO,GAAG1C,QAAQ,CAACpM,OAAT,GAAmB,CAAC6L,QAAD,CAAnB,GAAgC,EAA9C;;IAEA,KAAK,IAAIvd,EAAE,GAAG,CAAT,EAAYygB,eAAe,GAAG7D,cAAc,CAACkB,QAAD,CAAjD,EAA6D9d,EAAE,GAAGygB,eAAe,CAACngB,MAAlF,EAA0FN,EAAE,EAA5F,EAAgG;MAC9F,IAAI0gB,kBAAkB,GAAGhiB,cAAc,CAAC+hB,eAAe,CAACzgB,EAAD,CAAhB,EAAsB,CAAtB,CAAvC;MAAA,IACIiW,CAAC,GAAGyK,kBAAkB,CAAC,CAAD,CAD1B;MAAA,IAEIxC,GAAG,GAAGwC,kBAAkB,CAAC,CAAD,CAF5B;;MAIAF,OAAO,CAACpgB,IAAR,CAAa+S,KAAb,CAAmBqN,OAAnB,EAA4BvhB,kBAAkB,CAACshB,QAAQ,CAACrC,GAAD,EAAMjI,CAAC,KAAK,MAAN,GAAeiI,GAAf,GAAqBX,QAA3B,CAAT,CAA9C;IACD;;IAED,OAAOiD,OAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAAS3V,QAAT,CAAkB8V,GAAlB,EAAuB7C,QAAvB,EAAiC/T,OAAjC,EAA0CgF,OAA1C,EAAmD;IACjD,IAAI,CAAC+O,QAAL,EAAe;MACb;IACD;;IAED,IAAIC,QAAQ,GAAG,EAAf;IACA,IAAI6C,WAAW,GAAGL,QAAQ,CAACzC,QAAD,CAA1B;IACA3b,UAAU,CAAC0I,QAAX,CAAoB8V,GAApB,EAAyB;MACvBvV,KAAK,EAAE,SAASA,KAAT,CAAehD,IAAf,EAAqBF,MAArB,EAA6B;QAClC,IAAIA,MAAM,IAAI,IAAd,EAAoB;UAClB6V,QAAQ,CAACe,OAAT,CAAiB5W,MAAjB;QACD;;QAED,IAAI2V,OAAO,CAACzV,IAAD,EAAO0V,QAAP,EAAiBC,QAAjB,EAA2BhP,OAA3B,CAAX,EAAgD;UAC9C,IAAI6R,WAAW,CAACtgB,MAAhB,EAAwB;YACtB,KAAK,IAAI1B,CAAC,GAAG,CAAR,EAAWqgB,CAAC,GAAG2B,WAAW,CAACtgB,MAAhC,EAAwC1B,CAAC,GAAGqgB,CAA5C,EAA+C,EAAErgB,CAAjD,EAAoD;cAClD,IAAIif,OAAO,CAACzV,IAAD,EAAOwY,WAAW,CAAChiB,CAAD,CAAlB,EAAuBmf,QAAvB,EAAiChP,OAAjC,CAAX,EAAsD;gBACpDhF,OAAO,CAAC3B,IAAD,EAAOF,MAAP,EAAe6V,QAAf,CAAP;cACD;;cAED,KAAK,IAAIjB,CAAC,GAAG,CAAR,EAAW+D,CAAC,GAAG9C,QAAQ,CAACzd,MAA7B,EAAqCwc,CAAC,GAAG+D,CAAzC,EAA4C,EAAE/D,CAA9C,EAAiD;gBAC/C,IAAIgE,kBAAkB,GAAG/C,QAAQ,CAACld,KAAT,CAAeic,CAAC,GAAG,CAAnB,CAAzB;;gBAEA,IAAIe,OAAO,CAACE,QAAQ,CAACjB,CAAD,CAAT,EAAc8D,WAAW,CAAChiB,CAAD,CAAzB,EAA8BkiB,kBAA9B,EAAkD/R,OAAlD,CAAX,EAAuE;kBACrEhF,OAAO,CAACgU,QAAQ,CAACjB,CAAD,CAAT,EAAc5U,MAAd,EAAsB4Y,kBAAtB,CAAP;gBACD;cACF;YACF;UACF,CAdD,MAcO;YACL/W,OAAO,CAAC3B,IAAD,EAAOF,MAAP,EAAe6V,QAAf,CAAP;UACD;QACF;MACF,CAzBsB;MA0BvB5S,KAAK,EAAE,SAASA,KAAT,GAAiB;QACtB4S,QAAQ,CAACgB,KAAT;MACD,CA5BsB;MA6BvB5U,IAAI,EAAE4E,OAAO,IAAIA,OAAO,CAACiQ,WA7BF;MA8BvB9U,QAAQ,EAAE6E,OAAO,IAAIA,OAAO,CAAC7E,QAAnB,IAA+B;IA9BlB,CAAzB;EAgCD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAASuS,KAAT,CAAekE,GAAf,EAAoB7C,QAApB,EAA8B/O,OAA9B,EAAuC;IACrC,IAAIyR,OAAO,GAAG,EAAd;IACA3V,QAAQ,CAAC8V,GAAD,EAAM7C,QAAN,EAAgB,UAAU1V,IAAV,EAAgB;MACtCoY,OAAO,CAACpgB,IAAR,CAAagI,IAAb;IACD,CAFO,EAEL2G,OAFK,CAAR;IAGA,OAAOyR,OAAP;EACD;EACD;AACF;AACA;AACA;AACA;;;EAGE,SAAS7D,KAAT,CAAemB,QAAf,EAAyB;IACvB,OAAOpR,MAAM,CAACiQ,KAAP,CAAamB,QAAb,CAAP;EACD;EACD;AACF;AACA;AACA;AACA;AACA;AACA;;;EAGE,SAASiD,KAAT,CAAeJ,GAAf,EAAoB7C,QAApB,EAA8B/O,OAA9B,EAAuC;IACrC,OAAO0N,KAAK,CAACkE,GAAD,EAAMhE,KAAK,CAACmB,QAAD,CAAX,EAAuB/O,OAAvB,CAAZ;EACD;;EAEDgS,KAAK,CAACpE,KAAN,GAAcA,KAAd;EACAoE,KAAK,CAACtE,KAAN,GAAcA,KAAd;EACAsE,KAAK,CAAClW,QAAN,GAAiBA,QAAjB;EACAkW,KAAK,CAAClD,OAAN,GAAgBA,OAAhB;EACAkD,KAAK,CAACA,KAAN,GAAcA,KAAd;EAEA,OAAOA,KAAP;AAED,CAhsJA,CAAD"},"metadata":{},"sourceType":"script"}