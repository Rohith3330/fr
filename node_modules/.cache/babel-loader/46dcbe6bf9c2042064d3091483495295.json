{"ast":null,"code":"'use strict';\n\nvar _minimatch = require('minimatch');\n\nvar _minimatch2 = _interopRequireDefault(_minimatch);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\n * @fileoverview Rule to disallow namespace import\n * @author Radek Benkel\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: (0, _docsUrl2['default'])('no-namespace')\n    },\n    fixable: 'code',\n    schema: [{\n      type: 'object',\n      properties: {\n        ignore: {\n          type: 'array',\n          items: {\n            type: 'string'\n          },\n          uniqueItems: true\n        }\n      }\n    }]\n  },\n  create: function () {\n    function create(context) {\n      var firstOption = context.options[0] || {};\n      var ignoreGlobs = firstOption.ignore;\n      return {\n        ImportNamespaceSpecifier: function () {\n          function ImportNamespaceSpecifier(node) {\n            if (ignoreGlobs && ignoreGlobs.find(function (glob) {\n              return (0, _minimatch2['default'])(node.parent.source.value, glob, {\n                matchBase: true\n              });\n            })) {\n              return;\n            }\n\n            var scopeVariables = context.getScope().variables;\n            var namespaceVariable = scopeVariables.find(function (variable) {\n              return variable.defs[0].node === node;\n            });\n            var namespaceReferences = namespaceVariable.references;\n            var namespaceIdentifiers = namespaceReferences.map(function (reference) {\n              return reference.identifier;\n            });\n            var canFix = namespaceIdentifiers.length > 0 && !usesNamespaceAsObject(namespaceIdentifiers);\n            context.report({\n              node: node,\n              message: 'Unexpected namespace import.',\n              fix: canFix && function (fixer) {\n                var scopeManager = context.getSourceCode().scopeManager;\n                var fixes = []; // Pass 1: Collect variable names that are already in scope for each reference we want\n                // to transform, so that we can be sure that we choose non-conflicting import names\n\n                var importNameConflicts = {};\n                namespaceIdentifiers.forEach(function (identifier) {\n                  var parent = identifier.parent;\n\n                  if (parent && parent.type === 'MemberExpression') {\n                    var importName = getMemberPropertyName(parent);\n                    var localConflicts = getVariableNamesInScope(scopeManager, parent);\n\n                    if (!importNameConflicts[importName]) {\n                      importNameConflicts[importName] = localConflicts;\n                    } else {\n                      localConflicts.forEach(function (c) {\n                        return importNameConflicts[importName].add(c);\n                      });\n                    }\n                  }\n                }); // Choose new names for each import\n\n                var importNames = Object.keys(importNameConflicts);\n                var importLocalNames = generateLocalNames(importNames, importNameConflicts, namespaceVariable.name); // Replace the ImportNamespaceSpecifier with a list of ImportSpecifiers\n\n                var namedImportSpecifiers = importNames.map(function (importName) {\n                  return importName === importLocalNames[importName] ? importName : String(importName) + ' as ' + String(importLocalNames[importName]);\n                });\n                fixes.push(fixer.replaceText(node, '{ ' + String(namedImportSpecifiers.join(', ')) + ' }')); // Pass 2: Replace references to the namespace with references to the named imports\n\n                namespaceIdentifiers.forEach(function (identifier) {\n                  var parent = identifier.parent;\n\n                  if (parent && parent.type === 'MemberExpression') {\n                    var importName = getMemberPropertyName(parent);\n                    fixes.push(fixer.replaceText(parent, importLocalNames[importName]));\n                  }\n                });\n                return fixes;\n              }\n            });\n          }\n\n          return ImportNamespaceSpecifier;\n        }()\n      };\n    }\n\n    return create;\n  }()\n};\n/**\n                           * @param {Identifier[]} namespaceIdentifiers\n                           * @returns {boolean} `true` if the namespace variable is more than just a glorified constant\n                           */\n\nfunction usesNamespaceAsObject(namespaceIdentifiers) {\n  return !namespaceIdentifiers.every(function (identifier) {\n    var parent = identifier.parent; // `namespace.x` or `namespace['x']`\n\n    return parent && parent.type === 'MemberExpression' && (parent.property.type === 'Identifier' || parent.property.type === 'Literal');\n  });\n}\n/**\n   * @param {MemberExpression} memberExpression\n   * @returns {string} the name of the member in the object expression, e.g. the `x` in `namespace.x`\n   */\n\n\nfunction getMemberPropertyName(memberExpression) {\n  return memberExpression.property.type === 'Identifier' ? memberExpression.property.name : memberExpression.property.value;\n}\n/**\n   * @param {ScopeManager} scopeManager\n   * @param {ASTNode} node\n   * @return {Set<string>}\n   */\n\n\nfunction getVariableNamesInScope(scopeManager, node) {\n  var currentNode = node;\n  var scope = scopeManager.acquire(currentNode);\n\n  while (scope == null) {\n    currentNode = currentNode.parent;\n    scope = scopeManager.acquire(currentNode, true);\n  }\n\n  return new Set([].concat(_toConsumableArray(scope.variables.map(function (variable) {\n    return variable.name;\n  })), _toConsumableArray(scope.upper.variables.map(function (variable) {\n    return variable.name;\n  }))));\n}\n/**\n   *\n   * @param {*} names\n   * @param {*} nameConflicts\n   * @param {*} namespaceName\n   */\n\n\nfunction generateLocalNames(names, nameConflicts, namespaceName) {\n  var localNames = {};\n  names.forEach(function (name) {\n    var localName = void 0;\n\n    if (!nameConflicts[name].has(name)) {\n      localName = name;\n    } else if (!nameConflicts[name].has(String(namespaceName) + '_' + String(name))) {\n      localName = String(namespaceName) + '_' + String(name);\n    } else {\n      for (var i = 1; i < Infinity; i++) {\n        if (!nameConflicts[name].has(String(namespaceName) + '_' + String(name) + '_' + String(i))) {\n          localName = String(namespaceName) + '_' + String(name) + '_' + String(i);\n          break;\n        }\n      }\n    }\n\n    localNames[name] = localName;\n  });\n  return localNames;\n}","map":{"version":3,"mappings":"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","names":["module","exports","meta","type","docs","url","fixable","schema","properties","ignore","items","uniqueItems","create","context","firstOption","options","ignoreGlobs","ImportNamespaceSpecifier","node","find","parent","source","value","glob","matchBase","scopeVariables","getScope","variables","namespaceVariable","variable","defs","namespaceReferences","references","namespaceIdentifiers","map","reference","identifier","canFix","length","usesNamespaceAsObject","report","message","fix","scopeManager","getSourceCode","fixes","importNameConflicts","forEach","importName","getMemberPropertyName","localConflicts","getVariableNamesInScope","c","add","importNames","Object","keys","importLocalNames","generateLocalNames","name","namedImportSpecifiers","push","fixer","replaceText","join","every","property","memberExpression","currentNode","scope","acquire","Set","upper","names","nameConflicts","namespaceName","localNames","localName","has","i","Infinity"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\no-namespace.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow namespace import\n * @author Radek Benkel\n */\n\nimport minimatch from 'minimatch';\nimport docsUrl from '../docsUrl';\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: docsUrl('no-namespace'),\n    },\n    fixable: 'code',\n    schema: [{\n      type: 'object',\n      properties: {\n        ignore: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n          uniqueItems: true,\n        },\n      },\n    }],\n  },\n\n  create(context) {\n    const firstOption = context.options[0] || {};\n    const ignoreGlobs = firstOption.ignore;\n\n    return {\n      ImportNamespaceSpecifier(node) {\n        if (ignoreGlobs && ignoreGlobs.find(glob => minimatch(node.parent.source.value, glob, { matchBase: true }))) {\n          return;\n        }\n\n        const scopeVariables = context.getScope().variables;\n        const namespaceVariable = scopeVariables.find((variable) => variable.defs[0].node === node);\n        const namespaceReferences = namespaceVariable.references;\n        const namespaceIdentifiers = namespaceReferences.map(reference => reference.identifier);\n        const canFix = namespaceIdentifiers.length > 0 && !usesNamespaceAsObject(namespaceIdentifiers);\n\n        context.report({\n          node,\n          message: `Unexpected namespace import.`,\n          fix: canFix && (fixer => {\n            const scopeManager = context.getSourceCode().scopeManager;\n            const fixes = [];\n\n            // Pass 1: Collect variable names that are already in scope for each reference we want\n            // to transform, so that we can be sure that we choose non-conflicting import names\n            const importNameConflicts = {};\n            namespaceIdentifiers.forEach((identifier) => {\n              const parent = identifier.parent;\n              if (parent && parent.type === 'MemberExpression') {\n                const importName = getMemberPropertyName(parent);\n                const localConflicts = getVariableNamesInScope(scopeManager, parent);\n                if (!importNameConflicts[importName]) {\n                  importNameConflicts[importName] = localConflicts;\n                } else {\n                  localConflicts.forEach((c) => importNameConflicts[importName].add(c));\n                }\n              }\n            });\n\n            // Choose new names for each import\n            const importNames = Object.keys(importNameConflicts);\n            const importLocalNames = generateLocalNames(\n              importNames,\n              importNameConflicts,\n              namespaceVariable.name,\n            );\n\n            // Replace the ImportNamespaceSpecifier with a list of ImportSpecifiers\n            const namedImportSpecifiers = importNames.map((importName) => (\n              importName === importLocalNames[importName]\n                ? importName\n                : `${importName} as ${importLocalNames[importName]}`\n            ));\n            fixes.push(fixer.replaceText(node, `{ ${namedImportSpecifiers.join(', ')} }`));\n\n            // Pass 2: Replace references to the namespace with references to the named imports\n            namespaceIdentifiers.forEach((identifier) => {\n              const parent = identifier.parent;\n              if (parent && parent.type === 'MemberExpression') {\n                const importName = getMemberPropertyName(parent);\n                fixes.push(fixer.replaceText(parent, importLocalNames[importName]));\n              }\n            });\n\n            return fixes;\n          }),\n        });\n      },\n    };\n  },\n};\n\n/**\n * @param {Identifier[]} namespaceIdentifiers\n * @returns {boolean} `true` if the namespace variable is more than just a glorified constant\n */\nfunction usesNamespaceAsObject(namespaceIdentifiers) {\n  return !namespaceIdentifiers.every((identifier) => {\n    const parent = identifier.parent;\n\n    // `namespace.x` or `namespace['x']`\n    return (\n      parent && parent.type === 'MemberExpression' &&\n      (parent.property.type === 'Identifier' || parent.property.type === 'Literal')\n    );\n  });\n}\n\n/**\n * @param {MemberExpression} memberExpression\n * @returns {string} the name of the member in the object expression, e.g. the `x` in `namespace.x`\n */\nfunction getMemberPropertyName(memberExpression) {\n  return memberExpression.property.type === 'Identifier'\n    ? memberExpression.property.name\n    : memberExpression.property.value;\n}\n\n/**\n * @param {ScopeManager} scopeManager\n * @param {ASTNode} node\n * @return {Set<string>}\n */\nfunction getVariableNamesInScope(scopeManager, node) {\n  let currentNode = node;\n  let scope = scopeManager.acquire(currentNode);\n  while (scope == null) {\n    currentNode = currentNode.parent;\n    scope = scopeManager.acquire(currentNode, true);\n  }\n  return new Set([\n    ...scope.variables.map(variable => variable.name),\n    ...scope.upper.variables.map(variable => variable.name),\n  ]);\n}\n\n/**\n *\n * @param {*} names\n * @param {*} nameConflicts\n * @param {*} namespaceName\n */\nfunction generateLocalNames(names, nameConflicts, namespaceName) {\n  const localNames = {};\n  names.forEach((name) => {\n    let localName;\n    if (!nameConflicts[name].has(name)) {\n      localName = name;\n    } else if (!nameConflicts[name].has(`${namespaceName}_${name}`)) {\n      localName = `${namespaceName}_${name}`;\n    } else {\n      for (let i = 1; i < Infinity; i++) {\n        if (!nameConflicts[name].has(`${namespaceName}_${name}_${i}`)) {\n          localName = `${namespaceName}_${name}_${i}`;\n          break;\n        }\n      }\n    }\n    localNames[name] = localName;\n  });\n  return localNames;\n}\n"]},"metadata":{},"sourceType":"script"}