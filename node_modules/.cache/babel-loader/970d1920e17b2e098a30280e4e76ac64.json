{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'unified-signatures',\n  meta: {\n    docs: {\n      description: 'Disallow two overloads that could be unified into one with a union or an optional/rest parameter',\n      // too opinionated to be recommended\n      recommended: 'strict'\n    },\n    type: 'suggestion',\n    messages: {\n      omittingRestParameter: '{{failureStringStart}} with a rest parameter.',\n      omittingSingleParameter: '{{failureStringStart}} with an optional parameter.',\n      singleParameterDifference: '{{failureStringStart}} taking `{{type1}} | {{type2}}`.'\n    },\n    schema: [{\n      additionalProperties: false,\n      properties: {\n        ignoreDifferentlyNamedParameters: {\n          description: 'Whether two parameters with different names at the same index should be considered different even if their types are the same.',\n          type: 'boolean'\n        }\n      },\n      type: 'object'\n    }]\n  },\n  defaultOptions: [{\n    ignoreDifferentlyNamedParameters: false\n  }],\n\n  create(context, _ref) {\n    let [{\n      ignoreDifferentlyNamedParameters\n    }] = _ref;\n    const sourceCode = context.getSourceCode(); //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    function failureStringStart(otherLine) {\n      // For only 2 overloads we don't need to specify which is the other one.\n      const overloads = otherLine === undefined ? 'These overloads' : `This overload and the one on line ${otherLine}`;\n      return `${overloads} can be combined into one signature`;\n    }\n\n    function addFailures(failures) {\n      for (const failure of failures) {\n        const {\n          unify,\n          only2\n        } = failure;\n\n        switch (unify.kind) {\n          case 'single-parameter-difference':\n            {\n              const {\n                p0,\n                p1\n              } = unify;\n              const lineOfOtherOverload = only2 ? undefined : p0.loc.start.line;\n              const typeAnnotation0 = isTSParameterProperty(p0) ? p0.parameter.typeAnnotation : p0.typeAnnotation;\n              const typeAnnotation1 = isTSParameterProperty(p1) ? p1.parameter.typeAnnotation : p1.typeAnnotation;\n              context.report({\n                loc: p1.loc,\n                messageId: 'singleParameterDifference',\n                data: {\n                  failureStringStart: failureStringStart(lineOfOtherOverload),\n                  type1: sourceCode.getText(typeAnnotation0 === null || typeAnnotation0 === void 0 ? void 0 : typeAnnotation0.typeAnnotation),\n                  type2: sourceCode.getText(typeAnnotation1 === null || typeAnnotation1 === void 0 ? void 0 : typeAnnotation1.typeAnnotation)\n                },\n                node: p1\n              });\n              break;\n            }\n\n          case 'extra-parameter':\n            {\n              const {\n                extraParameter,\n                otherSignature\n              } = unify;\n              const lineOfOtherOverload = only2 ? undefined : otherSignature.loc.start.line;\n              context.report({\n                loc: extraParameter.loc,\n                messageId: extraParameter.type === utils_1.AST_NODE_TYPES.RestElement ? 'omittingRestParameter' : 'omittingSingleParameter',\n                data: {\n                  failureStringStart: failureStringStart(lineOfOtherOverload)\n                },\n                node: extraParameter\n              });\n            }\n        }\n      }\n    }\n\n    function checkOverloads(signatures, typeParameters) {\n      const result = [];\n      const isTypeParameter = getIsTypeParameter(typeParameters);\n\n      for (const overloads of signatures) {\n        forEachPair(overloads, (a, b) => {\n          var _a, _b;\n\n          const signature0 = (_a = a.value) !== null && _a !== void 0 ? _a : a;\n          const signature1 = (_b = b.value) !== null && _b !== void 0 ? _b : b;\n          const unify = compareSignatures(signature0, signature1, isTypeParameter);\n\n          if (unify !== undefined) {\n            result.push({\n              unify,\n              only2: overloads.length === 2\n            });\n          }\n        });\n      }\n\n      return result;\n    }\n\n    function compareSignatures(a, b, isTypeParameter) {\n      if (!signaturesCanBeUnified(a, b, isTypeParameter)) {\n        return undefined;\n      }\n\n      return a.params.length === b.params.length ? signaturesDifferBySingleParameter(a.params, b.params) : signaturesDifferByOptionalOrRestParameter(a, b);\n    }\n\n    function signaturesCanBeUnified(a, b, isTypeParameter) {\n      // Must return the same type.\n      const aTypeParams = a.typeParameters !== undefined ? a.typeParameters.params : undefined;\n      const bTypeParams = b.typeParameters !== undefined ? b.typeParameters.params : undefined;\n\n      if (ignoreDifferentlyNamedParameters && a.params.length === b.params.length) {\n        for (let i = 0; i < a.params.length; i += 1) {\n          if (a.params[i].type === b.params[i].type && getStaticParameterName(a.params[i]) !== getStaticParameterName(b.params[i])) {\n            return false;\n          }\n        }\n      }\n\n      return typesAreEqual(a.returnType, b.returnType) && // Must take the same type parameters.\n      // If one uses a type parameter (from outside) and the other doesn't, they shouldn't be joined.\n      util.arraysAreEqual(aTypeParams, bTypeParams, typeParametersAreEqual) && signatureUsesTypeParameter(a, isTypeParameter) === signatureUsesTypeParameter(b, isTypeParameter);\n    }\n    /** Detect `a(x: number, y: number, z: number)` and `a(x: number, y: string, z: number)`. */\n\n\n    function signaturesDifferBySingleParameter(types1, types2) {\n      const index = getIndexOfFirstDifference(types1, types2, parametersAreEqual);\n\n      if (index === undefined) {\n        return undefined;\n      } // If remaining arrays are equal, the signatures differ by just one parameter type\n\n\n      if (!util.arraysAreEqual(types1.slice(index + 1), types2.slice(index + 1), parametersAreEqual)) {\n        return undefined;\n      }\n\n      const a = types1[index];\n      const b = types2[index]; // Can unify `a?: string` and `b?: number`. Can't unify `...args: string[]` and `...args: number[]`.\n      // See https://github.com/Microsoft/TypeScript/issues/5077\n\n      return parametersHaveEqualSigils(a, b) && a.type !== utils_1.AST_NODE_TYPES.RestElement ? {\n        kind: 'single-parameter-difference',\n        p0: a,\n        p1: b\n      } : undefined;\n    }\n    /**\n     * Detect `a(): void` and `a(x: number): void`.\n     * Returns the parameter declaration (`x: number` in this example) that should be optional/rest, and overload it's a part of.\n     */\n\n\n    function signaturesDifferByOptionalOrRestParameter(a, b) {\n      const sig1 = a.params;\n      const sig2 = b.params;\n      const minLength = Math.min(sig1.length, sig2.length);\n      const longer = sig1.length < sig2.length ? sig2 : sig1;\n      const shorter = sig1.length < sig2.length ? sig1 : sig2;\n      const shorterSig = sig1.length < sig2.length ? a : b; // If one is has 2+ parameters more than the other, they must all be optional/rest.\n      // Differ by optional parameters: f() and f(x), f() and f(x, ?y, ...z)\n      // Not allowed: f() and f(x, y)\n\n      for (let i = minLength + 1; i < longer.length; i++) {\n        if (!parameterMayBeMissing(longer[i])) {\n          return undefined;\n        }\n      }\n\n      for (let i = 0; i < minLength; i++) {\n        const sig1i = sig1[i];\n        const sig2i = sig2[i];\n        const typeAnnotation1 = isTSParameterProperty(sig1i) ? sig1i.parameter.typeAnnotation : sig1i.typeAnnotation;\n        const typeAnnotation2 = isTSParameterProperty(sig2i) ? sig2i.parameter.typeAnnotation : sig2i.typeAnnotation;\n\n        if (!typesAreEqual(typeAnnotation1, typeAnnotation2)) {\n          return undefined;\n        }\n      }\n\n      if (minLength > 0 && shorter[minLength - 1].type === utils_1.AST_NODE_TYPES.RestElement) {\n        return undefined;\n      }\n\n      return {\n        extraParameter: longer[longer.length - 1],\n        kind: 'extra-parameter',\n        otherSignature: shorterSig\n      };\n    }\n    /** Given type parameters, returns a function to test whether a type is one of those parameters. */\n\n\n    function getIsTypeParameter(typeParameters) {\n      if (typeParameters === undefined) {\n        return () => false;\n      }\n\n      const set = new Set();\n\n      for (const t of typeParameters.params) {\n        set.add(t.name.name);\n      }\n\n      return typeName => set.has(typeName);\n    }\n    /** True if any of the outer type parameters are used in a signature. */\n\n\n    function signatureUsesTypeParameter(sig, isTypeParameter) {\n      return sig.params.some(p => typeContainsTypeParameter(isTSParameterProperty(p) ? p.parameter.typeAnnotation : p.typeAnnotation));\n\n      function typeContainsTypeParameter(type) {\n        if (!type) {\n          return false;\n        }\n\n        if (type.type === utils_1.AST_NODE_TYPES.TSTypeReference) {\n          const typeName = type.typeName;\n\n          if (isIdentifier(typeName) && isTypeParameter(typeName.name)) {\n            return true;\n          }\n        }\n\n        return typeContainsTypeParameter(type.typeAnnotation || type.elementType);\n      }\n    }\n\n    function isTSParameterProperty(node) {\n      return node.type === utils_1.AST_NODE_TYPES.TSParameterProperty;\n    }\n\n    function parametersAreEqual(a, b) {\n      const typeAnnotationA = isTSParameterProperty(a) ? a.parameter.typeAnnotation : a.typeAnnotation;\n      const typeAnnotationB = isTSParameterProperty(b) ? b.parameter.typeAnnotation : b.typeAnnotation;\n      return parametersHaveEqualSigils(a, b) && typesAreEqual(typeAnnotationA, typeAnnotationB);\n    }\n    /** True for optional/rest parameters. */\n\n\n    function parameterMayBeMissing(p) {\n      const optional = isTSParameterProperty(p) ? p.parameter.optional : p.optional;\n      return p.type === utils_1.AST_NODE_TYPES.RestElement || optional;\n    }\n    /** False if one is optional and the other isn't, or one is a rest parameter and the other isn't. */\n\n\n    function parametersHaveEqualSigils(a, b) {\n      const optionalA = isTSParameterProperty(a) ? a.parameter.optional : a.optional;\n      const optionalB = isTSParameterProperty(b) ? b.parameter.optional : b.optional;\n      return a.type === utils_1.AST_NODE_TYPES.RestElement === (b.type === utils_1.AST_NODE_TYPES.RestElement) && optionalA !== undefined === (optionalB !== undefined);\n    }\n\n    function typeParametersAreEqual(a, b) {\n      return a.name.name === b.name.name && constraintsAreEqual(a.constraint, b.constraint);\n    }\n\n    function typesAreEqual(a, b) {\n      return a === b || a !== undefined && b !== undefined && sourceCode.getText(a.typeAnnotation) === sourceCode.getText(b.typeAnnotation);\n    }\n\n    function constraintsAreEqual(a, b) {\n      return a === b || a !== undefined && b !== undefined && a.type === b.type;\n    }\n    /* Returns the first index where `a` and `b` differ. */\n\n\n    function getIndexOfFirstDifference(a, b, equal) {\n      for (let i = 0; i < a.length && i < b.length; i++) {\n        if (!equal(a[i], b[i])) {\n          return i;\n        }\n      }\n\n      return undefined;\n    }\n    /** Calls `action` for every pair of values in `values`. */\n\n\n    function forEachPair(values, action) {\n      for (let i = 0; i < values.length; i++) {\n        for (let j = i + 1; j < values.length; j++) {\n          action(values[i], values[j]);\n        }\n      }\n    }\n\n    const scopes = [];\n    let currentScope = {\n      overloads: new Map()\n    };\n\n    function createScope(parent, typeParameters) {\n      currentScope && scopes.push(currentScope);\n      currentScope = {\n        overloads: new Map(),\n        parent,\n        typeParameters\n      };\n    }\n\n    function checkScope() {\n      const failures = checkOverloads(Array.from(currentScope.overloads.values()), currentScope.typeParameters);\n      addFailures(failures);\n      currentScope = scopes.pop();\n    }\n\n    function addOverload(signature, key, containingNode) {\n      key = key !== null && key !== void 0 ? key : getOverloadKey(signature);\n\n      if (currentScope && (containingNode || signature).parent === currentScope.parent) {\n        const overloads = currentScope.overloads.get(key);\n\n        if (overloads !== undefined) {\n          overloads.push(signature);\n        } else {\n          currentScope.overloads.set(key, [signature]);\n        }\n      }\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      Program: createScope,\n      TSModuleBlock: createScope,\n\n      TSInterfaceDeclaration(node) {\n        createScope(node.body, node.typeParameters);\n      },\n\n      ClassDeclaration(node) {\n        createScope(node.body, node.typeParameters);\n      },\n\n      TSTypeLiteral: createScope,\n\n      // collect overloads\n      TSDeclareFunction(node) {\n        var _a, _b;\n\n        const exportingNode = getExportingNode(node);\n        addOverload(node, (_b = (_a = node.id) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : exportingNode === null || exportingNode === void 0 ? void 0 : exportingNode.type, exportingNode);\n      },\n\n      TSCallSignatureDeclaration: addOverload,\n      TSConstructSignatureDeclaration: addOverload,\n      TSMethodSignature: addOverload,\n\n      TSAbstractMethodDefinition(node) {\n        if (!node.value.body) {\n          addOverload(node);\n        }\n      },\n\n      MethodDefinition(node) {\n        if (!node.value.body) {\n          addOverload(node);\n        }\n      },\n\n      // validate scopes\n      'Program:exit': checkScope,\n      'TSModuleBlock:exit': checkScope,\n      'TSInterfaceDeclaration:exit': checkScope,\n      'ClassDeclaration:exit': checkScope,\n      'TSTypeLiteral:exit': checkScope\n    };\n  }\n\n});\n\nfunction getExportingNode(node) {\n  return node.parent && (node.parent.type === utils_1.AST_NODE_TYPES.ExportNamedDeclaration || node.parent.type === utils_1.AST_NODE_TYPES.ExportDefaultDeclaration) ? node.parent : undefined;\n}\n\nfunction getOverloadKey(node) {\n  const info = getOverloadInfo(node);\n  return (node.computed ? '0' : '1') + (node.static ? '0' : '1') + info;\n}\n\nfunction getOverloadInfo(node) {\n  switch (node.type) {\n    case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:\n      return 'constructor';\n\n    case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:\n      return '()';\n\n    default:\n      {\n        const {\n          key\n        } = node;\n        return isIdentifier(key) ? key.name : key.raw;\n      }\n  }\n}\n\nfunction getStaticParameterName(param) {\n  switch (param.type) {\n    case utils_1.AST_NODE_TYPES.Identifier:\n      return param.name;\n\n    case utils_1.AST_NODE_TYPES.RestElement:\n      return getStaticParameterName(param.argument);\n\n    default:\n      return undefined;\n  }\n}\n\nfunction isIdentifier(node) {\n  return node.type === utils_1.AST_NODE_TYPES.Identifier;\n}","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","docs","description","recommended","type","messages","omittingRestParameter","omittingSingleParameter","singleParameterDifference","schema","additionalProperties","properties","ignoreDifferentlyNamedParameters","defaultOptions","create","context","sourceCode","getSourceCode","failureStringStart","otherLine","overloads","undefined","addFailures","failures","failure","unify","only2","kind","p0","p1","lineOfOtherOverload","loc","start","line","typeAnnotation0","isTSParameterProperty","parameter","typeAnnotation","typeAnnotation1","report","messageId","data","type1","getText","type2","node","extraParameter","otherSignature","utils_1","RestElement","checkOverloads","signatures","typeParameters","result","isTypeParameter","getIsTypeParameter","forEachPair","a","b","signature0","value","_a","signature1","_b","compareSignatures","push","length","signaturesCanBeUnified","params","signaturesDifferBySingleParameter","signaturesDifferByOptionalOrRestParameter","aTypeParams","bTypeParams","i","getStaticParameterName","typesAreEqual","returnType","arraysAreEqual","typeParametersAreEqual","signatureUsesTypeParameter","types1","types2","index","getIndexOfFirstDifference","parametersAreEqual","slice","parametersHaveEqualSigils","sig1","sig2","minLength","Math","min","longer","shorter","shorterSig","parameterMayBeMissing","sig1i","sig2i","typeAnnotation2","set","Set","t","add","typeName","has","sig","some","p","typeContainsTypeParameter","TSTypeReference","isIdentifier","elementType","TSParameterProperty","typeAnnotationA","typeAnnotationB","optional","optionalA","optionalB","constraintsAreEqual","constraint","equal","values","action","j","scopes","currentScope","Map","createScope","parent","checkScope","Array","from","pop","addOverload","signature","key","containingNode","getOverloadKey","get","Program","TSModuleBlock","TSInterfaceDeclaration","body","ClassDeclaration","TSTypeLiteral","TSDeclareFunction","exportingNode","getExportingNode","id","TSCallSignatureDeclaration","TSConstructSignatureDeclaration","TSMethodSignature","TSAbstractMethodDefinition","MethodDefinition","ExportNamedDeclaration","ExportDefaultDeclaration","info","getOverloadInfo","computed","static","raw","param","Identifier","argument"],"sources":["../../src/rules/unified-signatures.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}