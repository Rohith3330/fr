{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst util = __importStar(require(\"../util\"));\n\nconst util_1 = require(\"../util\");\n\nexports.default = util.createRule({\n  name: 'no-unsafe-assignment',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow assigning a value with type `any` to variables and properties',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    messages: {\n      anyAssignment: 'Unsafe assignment of an `any` value.',\n      anyAssignmentThis: ['Unsafe assignment of an `any` value. `this` is typed as `any`.', 'You can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.'].join('\\n'),\n      unsafeArrayPattern: 'Unsafe array destructuring of an `any` array value.',\n      unsafeArrayPatternFromTuple: 'Unsafe array destructuring of a tuple element with an `any` value.',\n      unsafeAssignment: 'Unsafe assignment of type {{sender}} to a variable of type {{receiver}}.',\n      unsafeArraySpread: 'Unsafe spread of an `any` value in an array.'\n    },\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const {\n      program,\n      esTreeNodeToTSNodeMap\n    } = util.getParserServices(context);\n    const checker = program.getTypeChecker();\n    const compilerOptions = program.getCompilerOptions();\n    const isNoImplicitThis = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'noImplicitThis'); // returns true if the assignment reported\n\n    function checkArrayDestructureHelper(receiverNode, senderNode) {\n      if (receiverNode.type !== utils_1.AST_NODE_TYPES.ArrayPattern) {\n        return false;\n      }\n\n      const senderTsNode = esTreeNodeToTSNodeMap.get(senderNode);\n      const senderType = checker.getTypeAtLocation(senderTsNode);\n      return checkArrayDestructure(receiverNode, senderType, senderTsNode);\n    } // returns true if the assignment reported\n\n\n    function checkArrayDestructure(receiverNode, senderType, senderNode) {\n      // any array\n      // const [x] = ([] as any[]);\n      if (util.isTypeAnyArrayType(senderType, checker)) {\n        context.report({\n          node: receiverNode,\n          messageId: 'unsafeArrayPattern'\n        });\n        return false;\n      }\n\n      if (!checker.isTupleType(senderType)) {\n        return true;\n      }\n\n      const tupleElements = util.getTypeArguments(senderType, checker); // tuple with any\n      // const [x] = [1 as any];\n\n      let didReport = false;\n\n      for (let receiverIndex = 0; receiverIndex < receiverNode.elements.length; receiverIndex += 1) {\n        const receiverElement = receiverNode.elements[receiverIndex];\n\n        if (!receiverElement) {\n          continue;\n        }\n\n        if (receiverElement.type === utils_1.AST_NODE_TYPES.RestElement) {\n          // don't handle rests as they're not a 1:1 assignment\n          continue;\n        }\n\n        const senderType = tupleElements[receiverIndex];\n\n        if (!senderType) {\n          continue;\n        } // check for the any type first so we can handle [[[x]]] = [any]\n\n\n        if (util.isTypeAnyType(senderType)) {\n          context.report({\n            node: receiverElement,\n            messageId: 'unsafeArrayPatternFromTuple'\n          }); // we want to report on every invalid element in the tuple\n\n          didReport = true;\n        } else if (receiverElement.type === utils_1.AST_NODE_TYPES.ArrayPattern) {\n          didReport = checkArrayDestructure(receiverElement, senderType, senderNode);\n        } else if (receiverElement.type === utils_1.AST_NODE_TYPES.ObjectPattern) {\n          didReport = checkObjectDestructure(receiverElement, senderType, senderNode);\n        }\n      }\n\n      return didReport;\n    } // returns true if the assignment reported\n\n\n    function checkObjectDestructureHelper(receiverNode, senderNode) {\n      if (receiverNode.type !== utils_1.AST_NODE_TYPES.ObjectPattern) {\n        return false;\n      }\n\n      const senderTsNode = esTreeNodeToTSNodeMap.get(senderNode);\n      const senderType = checker.getTypeAtLocation(senderTsNode);\n      return checkObjectDestructure(receiverNode, senderType, senderTsNode);\n    } // returns true if the assignment reported\n\n\n    function checkObjectDestructure(receiverNode, senderType, senderNode) {\n      const properties = new Map(senderType.getProperties().map(property => [property.getName(), checker.getTypeOfSymbolAtLocation(property, senderNode)]));\n      let didReport = false;\n\n      for (const receiverProperty of receiverNode.properties) {\n        if (receiverProperty.type === utils_1.AST_NODE_TYPES.RestElement) {\n          // don't bother checking rest\n          continue;\n        }\n\n        let key;\n\n        if (receiverProperty.computed === false) {\n          key = receiverProperty.key.type === utils_1.AST_NODE_TYPES.Identifier ? receiverProperty.key.name : String(receiverProperty.key.value);\n        } else if (receiverProperty.key.type === utils_1.AST_NODE_TYPES.Literal) {\n          key = String(receiverProperty.key.value);\n        } else if (receiverProperty.key.type === utils_1.AST_NODE_TYPES.TemplateLiteral && receiverProperty.key.quasis.length === 1) {\n          key = String(receiverProperty.key.quasis[0].value.cooked);\n        } else {\n          // can't figure out the name, so skip it\n          continue;\n        }\n\n        const senderType = properties.get(key);\n\n        if (!senderType) {\n          continue;\n        } // check for the any type first so we can handle {x: {y: z}} = {x: any}\n\n\n        if (util.isTypeAnyType(senderType)) {\n          context.report({\n            node: receiverProperty.value,\n            messageId: 'unsafeArrayPatternFromTuple'\n          });\n          didReport = true;\n        } else if (receiverProperty.value.type === utils_1.AST_NODE_TYPES.ArrayPattern) {\n          didReport = checkArrayDestructure(receiverProperty.value, senderType, senderNode);\n        } else if (receiverProperty.value.type === utils_1.AST_NODE_TYPES.ObjectPattern) {\n          didReport = checkObjectDestructure(receiverProperty.value, senderType, senderNode);\n        }\n      }\n\n      return didReport;\n    } // returns true if the assignment reported\n\n\n    function checkAssignment(receiverNode, senderNode, reportingNode, comparisonType) {\n      var _a;\n\n      const receiverTsNode = esTreeNodeToTSNodeMap.get(receiverNode);\n      const receiverType = comparisonType === 2\n      /* ComparisonType.Contextual */\n      ? (_a = util.getContextualType(checker, receiverTsNode)) !== null && _a !== void 0 ? _a : checker.getTypeAtLocation(receiverTsNode) : checker.getTypeAtLocation(receiverTsNode);\n      const senderType = checker.getTypeAtLocation(esTreeNodeToTSNodeMap.get(senderNode));\n\n      if (util.isTypeAnyType(senderType)) {\n        // handle cases when we assign any ==> unknown.\n        if (util.isTypeUnknownType(receiverType)) {\n          return false;\n        }\n\n        let messageId = 'anyAssignment';\n\n        if (!isNoImplicitThis) {\n          // `var foo = this`\n          const thisExpression = (0, util_1.getThisExpression)(senderNode);\n\n          if (thisExpression && util.isTypeAnyType(util.getConstrainedTypeAtLocation(checker, esTreeNodeToTSNodeMap.get(thisExpression)))) {\n            messageId = 'anyAssignmentThis';\n          }\n        }\n\n        context.report({\n          node: reportingNode,\n          messageId\n        });\n        return true;\n      }\n\n      if (comparisonType === 0\n      /* ComparisonType.None */\n      ) {\n        return false;\n      }\n\n      const result = util.isUnsafeAssignment(senderType, receiverType, checker, senderNode);\n\n      if (!result) {\n        return false;\n      }\n\n      const {\n        sender,\n        receiver\n      } = result;\n      context.report({\n        node: reportingNode,\n        messageId: 'unsafeAssignment',\n        data: {\n          sender: checker.typeToString(sender),\n          receiver: checker.typeToString(receiver)\n        }\n      });\n      return true;\n    }\n\n    function getComparisonType(typeAnnotation) {\n      return typeAnnotation ? // if there's a type annotation, we can do a comparison\n      1\n      /* ComparisonType.Basic */\n      : // no type annotation means the variable's type will just be inferred, thus equal\n      0\n      /* ComparisonType.None */\n      ;\n    }\n\n    return {\n      'VariableDeclarator[init != null]'(node) {\n        const init = util.nullThrows(node.init, util.NullThrowsReasons.MissingToken(node.type, 'init'));\n        let didReport = checkAssignment(node.id, init, node, getComparisonType(node.id.typeAnnotation));\n\n        if (!didReport) {\n          didReport = checkArrayDestructureHelper(node.id, init);\n        }\n\n        if (!didReport) {\n          checkObjectDestructureHelper(node.id, init);\n        }\n      },\n\n      'PropertyDefinition[value != null]'(node) {\n        checkAssignment(node.key, node.value, node, getComparisonType(node.typeAnnotation));\n      },\n\n      'AssignmentExpression[operator = \"=\"], AssignmentPattern'(node) {\n        let didReport = checkAssignment(node.left, node.right, node, 1\n        /* ComparisonType.Basic */\n        );\n\n        if (!didReport) {\n          didReport = checkArrayDestructureHelper(node.left, node.right);\n        }\n\n        if (!didReport) {\n          checkObjectDestructureHelper(node.left, node.right);\n        }\n      },\n\n      // object pattern props are checked via assignments\n      ':not(ObjectPattern) > Property'(node) {\n        if (node.value.type === utils_1.AST_NODE_TYPES.AssignmentPattern || node.value.type === utils_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression) {\n          // handled by other selector\n          return;\n        }\n\n        checkAssignment(node.key, node.value, node, 2\n        /* ComparisonType.Contextual */\n        );\n      },\n\n      'ArrayExpression > SpreadElement'(node) {\n        const resetNode = esTreeNodeToTSNodeMap.get(node.argument);\n        const restType = checker.getTypeAtLocation(resetNode);\n\n        if (util.isTypeAnyType(restType) || util.isTypeAnyArrayType(restType, checker)) {\n          context.report({\n            node: node,\n            messageId: 'unsafeArraySpread'\n          });\n        }\n      },\n\n      'JSXAttribute[value != null]'(node) {\n        const value = util.nullThrows(node.value, util.NullThrowsReasons.MissingToken(node.type, 'value'));\n\n        if (value.type !== utils_1.AST_NODE_TYPES.JSXExpressionContainer || value.expression.type === utils_1.AST_NODE_TYPES.JSXEmptyExpression) {\n          return;\n        }\n\n        checkAssignment(node.name, value.expression, value.expression, 2\n        /* ComparisonType.Contextual */\n        );\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","messages","anyAssignment","anyAssignmentThis","join","unsafeArrayPattern","unsafeArrayPatternFromTuple","unsafeAssignment","unsafeArraySpread","schema","defaultOptions","create","context","program","esTreeNodeToTSNodeMap","getParserServices","checker","getTypeChecker","compilerOptions","getCompilerOptions","isNoImplicitThis","tsutils","isStrictCompilerOptionEnabled","checkArrayDestructureHelper","receiverNode","senderNode","utils_1","ArrayPattern","senderTsNode","get","senderType","getTypeAtLocation","checkArrayDestructure","isTypeAnyArrayType","report","node","messageId","isTupleType","tupleElements","getTypeArguments","didReport","receiverIndex","elements","length","receiverElement","RestElement","isTypeAnyType","ObjectPattern","checkObjectDestructure","checkObjectDestructureHelper","properties","Map","getProperties","map","property","getName","getTypeOfSymbolAtLocation","receiverProperty","key","computed","Identifier","String","value","Literal","TemplateLiteral","quasis","cooked","checkAssignment","reportingNode","comparisonType","receiverTsNode","receiverType","getContextualType","_a","isTypeUnknownType","thisExpression","getConstrainedTypeAtLocation","result","isUnsafeAssignment","sender","receiver","data","typeToString","getComparisonType","typeAnnotation","init","nullThrows","NullThrowsReasons","MissingToken","id","left","right","AssignmentPattern","TSEmptyBodyFunctionExpression","resetNode","argument","restType","JSXExpressionContainer","expression","JSXEmptyExpression"],"sources":["../../src/rules/no-unsafe-assignment.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}