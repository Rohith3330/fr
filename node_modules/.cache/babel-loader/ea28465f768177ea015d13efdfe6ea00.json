{"ast":null,"code":"/*\n  @license\n\tRollup.js v2.79.0\n\tWed, 31 Aug 2022 04:52:13 GMT - commit 8477f8ff1fe80086556021542b22942ad27a0a69\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\n'use strict';\n\nconst rollup = require('./rollup.js');\n\nconst require$$0$1 = require('fs');\n\nconst require$$2 = require('util');\n\nconst require$$1 = require('stream');\n\nconst require$$0$2 = require('path');\n\nconst require$$2$1 = require('os');\n\nconst require$$0$3 = require('events');\n\nvar chokidar = {};\nconst fs$3 = require$$0$1;\nconst {\n  Readable\n} = require$$1;\nconst sysPath$3 = require$$0$2;\nconst {\n  promisify: promisify$3\n} = require$$2;\nconst picomatch$1 = rollup.picomatch.exports;\nconst readdir$1 = promisify$3(fs$3.readdir);\nconst stat$3 = promisify$3(fs$3.stat);\nconst lstat$2 = promisify$3(fs$3.lstat);\nconst realpath$1 = promisify$3(fs$3.realpath);\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG$2 = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch$1(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n\n    for (const item of filter) {\n      const trimmed = item.trim();\n\n      if (trimmed.charAt(0) === BANG$2) {\n        negative.push(picomatch$1(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch$1(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n\n      return entry => !negative.some(f => f(entry.basename));\n    }\n\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n\n      /* eslint-disable no-unused-vars */\n      fileFilter: path => true,\n      directoryFilter: path => true,\n\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions,\n      ...options\n    };\n    const {\n      root,\n      type\n    } = opts;\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    const statMethod = opts.lstat ? lstat$2 : stat$3; // Use bigint stats if it's windows and stat() supports options (node 10+).\n\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, {\n        bigint: true\n      });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath$3.resolve(root);\n    this._isDirent = 'Dirent' in fs$3 && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = {\n      encoding: 'utf8',\n      withFileTypes: this._isDirent\n    }; // Launch stream with one parent, the root dir.\n\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const {\n          path,\n          depth,\n          files = []\n        } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n            const entryType = await this._getEntryType(entry);\n\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n\n    try {\n      files = await readdir$1(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n\n    return {\n      files,\n      depth,\n      path\n    };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath$3.resolve(sysPath$3.join(path, basename));\n      entry = {\n        path: sysPath$3.relative(this._root, fullPath),\n        fullPath,\n        basename\n      };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n\n    if (!stats) {\n      return;\n    }\n\n    if (stats.isFile()) {\n      return 'file';\n    }\n\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n\n      try {\n        const entryRealPath = await realpath$1(full);\n        const entryRealPathStats = await lstat$2(entryRealPath);\n\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {\n            const recursiveError = new Error(`Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`);\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n\n}\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\n\n\nconst readdirp$1 = function (root) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n\n  if (type) options.type = type;\n\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = function (root) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp$1(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n  });\n};\n\nreaddirp$1.promise = readdirpPromise;\nreaddirp$1.ReaddirpStream = ReaddirpStream;\nreaddirp$1.default = readdirp$1;\nvar readdirp_1 = readdirp$1;\nvar anymatch$2 = {\n  exports: {}\n};\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath$2 = function (path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n  var len = path.length;\n  if (len <= 1) return path; // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n\n  var prefix = '';\n\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n\n  return prefix + segs.join('/');\n};\n\nObject.defineProperty(anymatch$2.exports, \"__esModule\", {\n  value: true\n});\nconst picomatch = rollup.picomatch.exports;\nconst normalizePath$1 = normalizePath$2;\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\n\nconst BANG$1 = '!';\nconst DEFAULT_OPTIONS = {\n  returnIndex: false\n};\n\nconst arrify$1 = item => Array.isArray(item) ? item : [item];\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\n\n\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return string => matcher === string || glob(string);\n  }\n\n  if (matcher instanceof RegExp) {\n    return string => matcher.test(string);\n  }\n\n  return string => false;\n};\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\n\n\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n\n  const _path = isList ? args[0] : args;\n\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));\n  }\n\n  const path = normalizePath$1(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\n\n\nconst anymatch$1 = function (matchers, testString) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_OPTIONS;\n\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n\n  const opts = typeof options === 'boolean' ? {\n    returnIndex: options\n  } : options;\n  const returnIndex = opts.returnIndex || false; // Early cache for matchers.\n\n  const mtchers = arrify$1(matchers);\n  const negatedGlobs = mtchers.filter(item => typeof item === 'string' && item.charAt(0) === BANG$1).map(item => item.slice(1)).map(item => picomatch(item, opts));\n  const patterns = mtchers.filter(item => typeof item !== 'string' || typeof item === 'string' && item.charAt(0) !== BANG$1).map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return function (testString) {\n      let ri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    };\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch$1.default = anymatch$1;\nanymatch$2.exports = anymatch$1;\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob$1 = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n\n  while (match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str)) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nvar isExtglob = isExtglob$1;\nvar chars = {\n  '{': '}',\n  '(': ')',\n  '[': ']'\n};\n\nvar strictCheck = function (str) {\n  if (str[0] === '!') {\n    return true;\n  }\n\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n\n        backSlashIndex = str.indexOf('\\\\', index);\n\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n\n  return false;\n};\n\nvar relaxedCheck = function (str) {\n  if (str[0] === '!') {\n    return true;\n  }\n\n  var index = 0;\n\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n\n  return false;\n};\n\nvar isGlob$2 = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var check = strictCheck; // optionally relax check\n\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n\n  return check(str);\n};\n\nvar isGlob$1 = isGlob$2;\nvar pathPosixDirname = require$$0$2.posix.dirname;\nvar isWin32 = require$$2$1.platform() === 'win32';\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\n\nvar globParent$1 = function globParent(str, opts) {\n  var options = Object.assign({\n    flipBackslashes: true\n  }, opts); // flip windows path separators\n\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  } // special case for strings ending in enclosure containing path separator\n\n\n  if (enclosure.test(str)) {\n    str += slash;\n  } // preserves full path in case of trailing path separator\n\n\n  str += 'a'; // remove path parts that are globby\n\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob$1(str) || globby.test(str)); // remove escape chars and return result\n\n\n  return str.replace(escaped, '$1');\n};\n\nvar utils$3 = {};\n\n(function (exports) {\n  exports.isInteger = num => {\n    if (typeof num === 'number') {\n      return Number.isInteger(num);\n    }\n\n    if (typeof num === 'string' && num.trim() !== '') {\n      return Number.isInteger(Number(num));\n    }\n\n    return false;\n  };\n  /**\n   * Find a node of the given type\n   */\n\n\n  exports.find = (node, type) => node.nodes.find(node => node.type === type);\n  /**\n   * Find a node of the given type\n   */\n\n\n  exports.exceedsLimit = function (min, max) {\n    let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let limit = arguments.length > 3 ? arguments[3] : undefined;\n    if (limit === false) return false;\n    if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n    return (Number(max) - Number(min)) / Number(step) >= limit;\n  };\n  /**\n   * Escape the given node with '\\\\' before node.value\n   */\n\n\n  exports.escapeNode = function (block) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let type = arguments.length > 2 ? arguments[2] : undefined;\n    let node = block.nodes[n];\n    if (!node) return;\n\n    if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n      if (node.escaped !== true) {\n        node.value = '\\\\' + node.value;\n        node.escaped = true;\n      }\n    }\n  };\n  /**\n   * Returns true if the given brace node should be enclosed in literal braces\n   */\n\n\n  exports.encloseBrace = node => {\n    if (node.type !== 'brace') return false;\n\n    if (node.commas >> 0 + node.ranges >> 0 === 0) {\n      node.invalid = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if a brace node is invalid.\n   */\n\n\n  exports.isInvalidBrace = block => {\n    if (block.type !== 'brace') return false;\n    if (block.invalid === true || block.dollar) return true;\n\n    if (block.commas >> 0 + block.ranges >> 0 === 0) {\n      block.invalid = true;\n      return true;\n    }\n\n    if (block.open !== true || block.close !== true) {\n      block.invalid = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if a node is an open or close node\n   */\n\n\n  exports.isOpenOrClose = node => {\n    if (node.type === 'open' || node.type === 'close') {\n      return true;\n    }\n\n    return node.open === true || node.close === true;\n  };\n  /**\n   * Reduce an array of text nodes.\n   */\n\n\n  exports.reduce = nodes => nodes.reduce((acc, node) => {\n    if (node.type === 'text') acc.push(node.value);\n    if (node.type === 'range') node.type = 'text';\n    return acc;\n  }, []);\n  /**\n   * Flatten an array\n   */\n\n\n  exports.flatten = function () {\n    const result = [];\n\n    const flat = arr => {\n      for (let i = 0; i < arr.length; i++) {\n        let ele = arr[i];\n        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n      }\n\n      return result;\n    };\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    flat(args);\n    return result;\n  };\n})(utils$3);\n\nconst utils$2 = utils$3;\n\nvar stringify$4 = function (ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  let stringify = function (node) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let invalidBlock = options.escapeInvalid && utils$2.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils$2.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n\n    return output;\n  };\n\n  return stringify(ast);\n};\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nvar isNumber$2 = function (num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n\n  return false;\n};\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nconst isNumber$1 = isNumber$2;\n\nconst toRegexRange$1 = (min, max, options) => {\n  if (isNumber$1(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber$1(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = {\n    relaxZeros: true,\n    ...options\n  };\n\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange$1.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n\n    if (opts.capture) {\n      return `(${result})`;\n    }\n\n    if (opts.wrap === false) {\n      return result;\n    }\n\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = {\n    min,\n    max,\n    a,\n    b\n  };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange$1.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {\n      pattern: start,\n      count: [],\n      digits: 0\n    };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return {\n    pattern,\n    count: [count],\n    digits\n  };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let {\n      string\n    } = ele; // only push if _both_ are negative...\n\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    } // or _both_ are positive\n\n\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n\n  return result;\n}\n/**\n * Zip strings\n */\n\n\nfunction zip(a, b) {\n  let arr = [];\n\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - integer % Math.pow(10, zeros);\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${b - a === 1 ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n\n    case 1:\n      return relax ? '0?' : '0';\n\n    case 2:\n      return relax ? '0{0,2}' : '00';\n\n    default:\n      {\n        return relax ? `0{0,${diff}}` : `0{${diff}}`;\n      }\n  }\n}\n/**\n * Cache\n */\n\n\ntoRegexRange$1.cache = {};\n\ntoRegexRange$1.clearCache = () => toRegexRange$1.cache = {};\n/**\n * Expose `toRegexRange`\n */\n\n\nvar toRegexRange_1 = toRegexRange$1;\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nconst util = require$$2;\nconst toRegexRange = toRegexRange_1;\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || typeof value === 'string' && value !== '';\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n\n  while (value[++index] === '0');\n\n  return index > 0;\n};\n\nconst stringify$3 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');\n  }\n\n  if (toNumber === false) {\n    return String(input);\n  }\n\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n\n  while (input.length < maxLength) input = '0' + input;\n\n  return negative ? '-' + input : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, {\n      wrap: false,\n      ...options\n    });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = function () {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...arguments));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n\n  return [];\n};\n\nconst fillNumbers = function (start, end) {\n  let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  } // fix negative zero\n\n\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$3(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = {\n    negatives: [],\n    positives: []\n  };\n\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1 ? toSequence(parts, options) : toRegex(range, null, {\n      wrap: false,\n      ...options\n    });\n  }\n\n  return range;\n};\n\nconst fillLetters = function (start, end) {\n  let step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {\n    return invalidRange(start, end, options);\n  }\n\n  let format = options.transform || (val => String.fromCharCode(val));\n\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, {\n      wrap: false,\n      options\n    });\n  }\n\n  return range;\n};\n\nconst fill$2 = function (start, end, step) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill$2(start, end, 1, {\n      transform: step\n    });\n  }\n\n  if (isObject(step)) {\n    return fill$2(start, end, 0, step);\n  }\n\n  let opts = { ...options\n  };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill$2(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nvar fillRange = fill$2;\nconst fill$1 = fillRange;\nconst utils$1 = utils$3;\n\nconst compile$1 = function (ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  let walk = function (node) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let invalidBlock = utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? prefix + node.value : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? prefix + node.value : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n      let range = fill$1(...args, { ...options,\n        wrap: false,\n        toRegex: true\n      });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n\n    return output;\n  };\n\n  return walk(ast);\n};\n\nvar compile_1 = compile$1;\nconst fill = fillRange;\nconst stringify$2 = stringify$4;\nconst utils = utils$3;\n\nconst append = function () {\n  let queue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  let stash = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let enclose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let result = [];\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n  if (!stash.length) return queue;\n\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n      }\n    }\n  }\n\n  return utils.flatten(result);\n};\n\nconst expand$1 = function (ast) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = function (node) {\n    let parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    node.queue = [];\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify$2(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n\n      if (range.length === 0) {\n        range = stringify$2(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nvar expand_1 = expand$1;\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n  // Digits\n  CHAR_0: '0',\n\n  /* 0 */\n  CHAR_9: '9',\n\n  /* 9 */\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A',\n\n  /* A */\n  CHAR_LOWERCASE_A: 'a',\n\n  /* a */\n  CHAR_UPPERCASE_Z: 'Z',\n\n  /* Z */\n  CHAR_LOWERCASE_Z: 'z',\n\n  /* z */\n  CHAR_LEFT_PARENTHESES: '(',\n\n  /* ( */\n  CHAR_RIGHT_PARENTHESES: ')',\n\n  /* ) */\n  CHAR_ASTERISK: '*',\n\n  /* * */\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&',\n\n  /* & */\n  CHAR_AT: '@',\n\n  /* @ */\n  CHAR_BACKSLASH: '\\\\',\n\n  /* \\ */\n  CHAR_BACKTICK: '`',\n\n  /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r',\n\n  /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^',\n\n  /* ^ */\n  CHAR_COLON: ':',\n\n  /* : */\n  CHAR_COMMA: ',',\n\n  /* , */\n  CHAR_DOLLAR: '$',\n\n  /* . */\n  CHAR_DOT: '.',\n\n  /* . */\n  CHAR_DOUBLE_QUOTE: '\"',\n\n  /* \" */\n  CHAR_EQUAL: '=',\n\n  /* = */\n  CHAR_EXCLAMATION_MARK: '!',\n\n  /* ! */\n  CHAR_FORM_FEED: '\\f',\n\n  /* \\f */\n  CHAR_FORWARD_SLASH: '/',\n\n  /* / */\n  CHAR_HASH: '#',\n\n  /* # */\n  CHAR_HYPHEN_MINUS: '-',\n\n  /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<',\n\n  /* < */\n  CHAR_LEFT_CURLY_BRACE: '{',\n\n  /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[',\n\n  /* [ */\n  CHAR_LINE_FEED: '\\n',\n\n  /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0',\n\n  /* \\u00A0 */\n  CHAR_PERCENT: '%',\n\n  /* % */\n  CHAR_PLUS: '+',\n\n  /* + */\n  CHAR_QUESTION_MARK: '?',\n\n  /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>',\n\n  /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}',\n\n  /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']',\n\n  /* ] */\n  CHAR_SEMICOLON: ';',\n\n  /* ; */\n  CHAR_SINGLE_QUOTE: '\\'',\n\n  /* ' */\n  CHAR_SPACE: ' ',\n\n  /*   */\n  CHAR_TAB: '\\t',\n\n  /* \\t */\n  CHAR_UNDERSCORE: '_',\n\n  /* _ */\n  CHAR_VERTICAL_LINE: '|',\n\n  /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF'\n  /* \\uFEFF */\n\n};\nconst stringify$1 = stringify$4;\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH,\n\n  /* \\ */\n  CHAR_BACKTICK,\n\n  /* ` */\n  CHAR_COMMA,\n\n  /* , */\n  CHAR_DOT,\n\n  /* . */\n  CHAR_LEFT_PARENTHESES,\n\n  /* ( */\n  CHAR_RIGHT_PARENTHESES,\n\n  /* ) */\n  CHAR_LEFT_CURLY_BRACE,\n\n  /* { */\n  CHAR_RIGHT_CURLY_BRACE,\n\n  /* } */\n  CHAR_LEFT_SQUARE_BRACKET,\n\n  /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET,\n\n  /* ] */\n  CHAR_DOUBLE_QUOTE,\n\n  /* \" */\n  CHAR_SINGLE_QUOTE,\n\n  /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants$1;\n/**\n * parse\n */\n\nconst parse$1 = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = {\n    type: 'root',\n    input,\n    nodes: []\n  };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({\n    type: 'bos'\n  });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n    /**\n     * Escaped chars\n     */\n\n\n    if (value === CHAR_BACKSLASH) {\n      push({\n        type: 'text',\n        value: (options.keepEscaping ? value : '') + advance()\n      });\n      continue;\n    }\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({\n        type: 'text',\n        value: '\\\\' + value\n      });\n      continue;\n    }\n    /**\n     * Left square bracket: '['\n     */\n\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Parentheses\n     */\n\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({\n        type: 'paren',\n        nodes: []\n      });\n      stack.push(block);\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      block = stack.pop();\n      push({\n        type: 'text',\n        value\n      });\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\n     * Quotes: '|\"|`\n     */\n\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Left curly brace: '{'\n     */\n\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n      block = push(brace);\n      stack.push(block);\n      push({\n        type: 'open',\n        value\n      });\n      continue;\n    }\n    /**\n     * Right curly brace: '}'\n     */\n\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n      push({\n        type,\n        value\n      });\n      depth--;\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\n     * Comma: ','\n     */\n\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, {\n          type: 'text',\n          value: stringify$1(block)\n        }];\n      }\n\n      push({\n        type: 'comma',\n        value\n      });\n      block.commas++;\n      continue;\n    }\n    /**\n     * Dot: '.'\n     */\n\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({\n        type: 'dot',\n        value\n      });\n      continue;\n    }\n    /**\n     * Text\n     */\n\n\n    push({\n      type: 'text',\n      value\n    });\n  } // Mark imbalanced braces and brackets as invalid\n\n\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      }); // get the location of the block on parent.nodes (block's siblings)\n\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block); // replace the (invalid) block with it's nodes\n\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({\n    type: 'eos'\n  });\n  return ast;\n};\n\nvar parse_1 = parse$1;\nconst stringify = stringify$4;\nconst compile = compile_1;\nconst expand = expand_1;\nconst parse = parse_1;\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces$1 = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces$1.create(pattern, options);\n\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces$1.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n\n  return output;\n};\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\n\nbraces$1.parse = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return parse(input, options);\n};\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces$1.stringify = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof input === 'string') {\n    return stringify(braces$1.parse(input, options), options);\n  }\n\n  return stringify(input, options);\n};\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces$1.compile = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n\n  return compile(input, options);\n};\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces$1.expand = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n\n  let result = expand(input, options); // filter out empty strings if specified\n\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  } // filter out duplicates if specified\n\n\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces$1.create = function (input) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n  return options.expand !== true ? braces$1.compile(input, options) : braces$1.expand(input, options);\n};\n/**\n * Expose \"braces\"\n */\n\n\nvar braces_1 = braces$1;\nvar binaryExtensions$1 = {\n  exports: {}\n};\nconst require$$0 = [\"3dm\", \"3ds\", \"3g2\", \"3gp\", \"7z\", \"a\", \"aac\", \"adp\", \"ai\", \"aif\", \"aiff\", \"alz\", \"ape\", \"apk\", \"appimage\", \"ar\", \"arj\", \"asf\", \"au\", \"avi\", \"bak\", \"baml\", \"bh\", \"bin\", \"bk\", \"bmp\", \"btif\", \"bz2\", \"bzip2\", \"cab\", \"caf\", \"cgm\", \"class\", \"cmx\", \"cpio\", \"cr2\", \"cur\", \"dat\", \"dcm\", \"deb\", \"dex\", \"djvu\", \"dll\", \"dmg\", \"dng\", \"doc\", \"docm\", \"docx\", \"dot\", \"dotm\", \"dra\", \"DS_Store\", \"dsk\", \"dts\", \"dtshd\", \"dvb\", \"dwg\", \"dxf\", \"ecelp4800\", \"ecelp7470\", \"ecelp9600\", \"egg\", \"eol\", \"eot\", \"epub\", \"exe\", \"f4v\", \"fbs\", \"fh\", \"fla\", \"flac\", \"flatpak\", \"fli\", \"flv\", \"fpx\", \"fst\", \"fvt\", \"g3\", \"gh\", \"gif\", \"graffle\", \"gz\", \"gzip\", \"h261\", \"h263\", \"h264\", \"icns\", \"ico\", \"ief\", \"img\", \"ipa\", \"iso\", \"jar\", \"jpeg\", \"jpg\", \"jpgv\", \"jpm\", \"jxr\", \"key\", \"ktx\", \"lha\", \"lib\", \"lvp\", \"lz\", \"lzh\", \"lzma\", \"lzo\", \"m3u\", \"m4a\", \"m4v\", \"mar\", \"mdi\", \"mht\", \"mid\", \"midi\", \"mj2\", \"mka\", \"mkv\", \"mmr\", \"mng\", \"mobi\", \"mov\", \"movie\", \"mp3\", \"mp4\", \"mp4a\", \"mpeg\", \"mpg\", \"mpga\", \"mxu\", \"nef\", \"npx\", \"numbers\", \"nupkg\", \"o\", \"odp\", \"ods\", \"odt\", \"oga\", \"ogg\", \"ogv\", \"otf\", \"ott\", \"pages\", \"pbm\", \"pcx\", \"pdb\", \"pdf\", \"pea\", \"pgm\", \"pic\", \"png\", \"pnm\", \"pot\", \"potm\", \"potx\", \"ppa\", \"ppam\", \"ppm\", \"pps\", \"ppsm\", \"ppsx\", \"ppt\", \"pptm\", \"pptx\", \"psd\", \"pya\", \"pyc\", \"pyo\", \"pyv\", \"qt\", \"rar\", \"ras\", \"raw\", \"resources\", \"rgb\", \"rip\", \"rlc\", \"rmf\", \"rmvb\", \"rpm\", \"rtf\", \"rz\", \"s3m\", \"s7z\", \"scpt\", \"sgi\", \"shar\", \"snap\", \"sil\", \"sketch\", \"slk\", \"smv\", \"snk\", \"so\", \"stl\", \"suo\", \"sub\", \"swf\", \"tar\", \"tbz\", \"tbz2\", \"tga\", \"tgz\", \"thmx\", \"tif\", \"tiff\", \"tlz\", \"ttc\", \"ttf\", \"txz\", \"udf\", \"uvh\", \"uvi\", \"uvm\", \"uvp\", \"uvs\", \"uvu\", \"viv\", \"vob\", \"war\", \"wav\", \"wax\", \"wbmp\", \"wdp\", \"weba\", \"webm\", \"webp\", \"whl\", \"wim\", \"wm\", \"wma\", \"wmv\", \"wmx\", \"woff\", \"woff2\", \"wrm\", \"wvx\", \"xbm\", \"xif\", \"xla\", \"xlam\", \"xls\", \"xlsb\", \"xlsm\", \"xlsx\", \"xlt\", \"xltm\", \"xltx\", \"xm\", \"xmind\", \"xpi\", \"xpm\", \"xwd\", \"xz\", \"z\", \"zip\", \"zipx\"];\n\n(function (module) {\n  module.exports = require$$0;\n})(binaryExtensions$1);\n\nconst path = require$$0$2;\nconst binaryExtensions = binaryExtensions$1.exports;\nconst extensions = new Set(binaryExtensions);\n\nvar isBinaryPath$1 = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n\nvar constants = {};\n\n(function (exports) {\n  const {\n    sep\n  } = require$$0$2;\n  const {\n    platform\n  } = process;\n  const os = require$$2$1;\n  exports.EV_ALL = 'all';\n  exports.EV_READY = 'ready';\n  exports.EV_ADD = 'add';\n  exports.EV_CHANGE = 'change';\n  exports.EV_ADD_DIR = 'addDir';\n  exports.EV_UNLINK = 'unlink';\n  exports.EV_UNLINK_DIR = 'unlinkDir';\n  exports.EV_RAW = 'raw';\n  exports.EV_ERROR = 'error';\n  exports.STR_DATA = 'data';\n  exports.STR_END = 'end';\n  exports.STR_CLOSE = 'close';\n  exports.FSEVENT_CREATED = 'created';\n  exports.FSEVENT_MODIFIED = 'modified';\n  exports.FSEVENT_DELETED = 'deleted';\n  exports.FSEVENT_MOVED = 'moved';\n  exports.FSEVENT_CLONED = 'cloned';\n  exports.FSEVENT_UNKNOWN = 'unknown';\n  exports.FSEVENT_TYPE_FILE = 'file';\n  exports.FSEVENT_TYPE_DIRECTORY = 'directory';\n  exports.FSEVENT_TYPE_SYMLINK = 'symlink';\n  exports.KEY_LISTENERS = 'listeners';\n  exports.KEY_ERR = 'errHandlers';\n  exports.KEY_RAW = 'rawEmitters';\n  exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n  exports.DOT_SLASH = `.${sep}`;\n  exports.BACK_SLASH_RE = /\\\\/g;\n  exports.DOUBLE_SLASH_RE = /\\/\\//;\n  exports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\n  exports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n  exports.REPLACER_RE = /^\\.[/\\\\]/;\n  exports.SLASH = '/';\n  exports.SLASH_SLASH = '//';\n  exports.BRACE_START = '{';\n  exports.BANG = '!';\n  exports.ONE_DOT = '.';\n  exports.TWO_DOTS = '..';\n  exports.STAR = '*';\n  exports.GLOBSTAR = '**';\n  exports.ROOT_GLOBSTAR = '/**/*';\n  exports.SLASH_GLOBSTAR = '/**';\n  exports.DIR_SUFFIX = 'Dir';\n  exports.ANYMATCH_OPTS = {\n    dot: true\n  };\n  exports.STRING_TYPE = 'string';\n  exports.FUNCTION_TYPE = 'function';\n  exports.EMPTY_STR = '';\n\n  exports.EMPTY_FN = () => {};\n\n  exports.IDENTITY_FN = val => val;\n\n  exports.isWindows = platform === 'win32';\n  exports.isMacos = platform === 'darwin';\n  exports.isLinux = platform === 'linux';\n  exports.isIBMi = os.type() === 'OS400';\n})(constants);\n\nconst fs$2 = require$$0$1;\nconst sysPath$2 = require$$0$2;\nconst {\n  promisify: promisify$2\n} = require$$2;\nconst isBinaryPath = isBinaryPath$1;\nconst {\n  isWindows: isWindows$1,\n  isLinux,\n  EMPTY_FN: EMPTY_FN$2,\n  EMPTY_STR: EMPTY_STR$1,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE: EV_CHANGE$2,\n  EV_ADD: EV_ADD$2,\n  EV_ADD_DIR: EV_ADD_DIR$2,\n  EV_ERROR: EV_ERROR$2,\n  STR_DATA: STR_DATA$1,\n  STR_END: STR_END$2,\n  BRACE_START: BRACE_START$1,\n  STAR\n} = constants;\nconst THROTTLE_MODE_WATCH = 'watch';\nconst open = promisify$2(fs$2.open);\nconst stat$2 = promisify$2(fs$2.stat);\nconst lstat$1 = promisify$2(fs$2.lstat);\nconst close = promisify$2(fs$2.close);\nconst fsrealpath = promisify$2(fs$2.realpath);\nconst statMethods$1 = {\n  lstat: lstat$1,\n  stat: stat$2\n}; // TODO: emit errors properly. Example: EMFILE on Macos.\n\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = val => val instanceof Set ? val.size === 0 : !val;\n/**\n * @typedef {String} Path\n */\n// fs_watch helpers\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\n\n\nconst FsWatchInstances = new Map();\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\n\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {\n      watchedPath: path\n    }); // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(sysPath$2.resolve(path, evPath), KEY_LISTENERS, sysPath$2.join(path, evPath));\n    }\n  };\n\n  try {\n    return fs$2.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\n\n\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], listener => {\n    listener(val1, val2, val3);\n  });\n};\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\n\n\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    errHandler,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n  /** @type {fs.FSWatcher=} */\n\n  let watcher;\n\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n    return watcher.close.bind(watcher);\n  }\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here\n    fsWatchBroadcast.bind(null, fullPath, KEY_RAW));\n    if (!watcher) return;\n    watcher.on(EV_ERROR$2, async error => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n\n      if (isWindows$1 && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  } // const index = cont.listeners.indexOf(listener);\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n\n\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close(); // }\n\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n}; // fs_watchFile helpers\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\n\n\nconst FsWatchFileInstances = new Map();\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\n\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n  const copts = cont && cont.options;\n\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    fs$2.unwatchFile(fullPath);\n    cont = undefined;\n  }\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs$2.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, rawEmitter => {\n          rawEmitter(EV_CHANGE$2, fullPath, {\n            curr,\n            prev\n          });\n        });\n        const currmtime = curr.mtimeMs;\n\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, listener => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  } // const index = cont.listeners.indexOf(listener);\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n\n\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs$2.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n/**\n * @mixin\n */\n\n\nclass NodeFsHandler$1 {\n  /**\n   * @param {import(\"../index\").FSWatcher} fsW\n   */\n  constructor(fsW) {\n    this.fsw = fsW;\n\n    this._boundHandleError = error => fsW._handleError(error);\n  }\n  /**\n   * Watch file for changes with fs_watchFile or fs_watch.\n   * @param {String} path to file or dir\n   * @param {Function} listener on fs change\n   * @returns {Function} closer for the watcher instance\n   */\n\n\n  _watchWithNodeFs(path, listener) {\n    const opts = this.fsw.options;\n    const directory = sysPath$2.dirname(path);\n    const basename = sysPath$2.basename(path);\n\n    const parent = this.fsw._getWatchedDir(directory);\n\n    parent.add(basename);\n    const absolutePath = sysPath$2.resolve(path);\n    const options = {\n      persistent: opts.persistent\n    };\n    if (!listener) listener = EMPTY_FN$2;\n    let closer;\n\n    if (opts.usePolling) {\n      options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;\n      closer = setFsWatchFileListener(path, absolutePath, options, {\n        listener,\n        rawEmitter: this.fsw._emitRaw\n      });\n    } else {\n      closer = setFsWatchListener(path, absolutePath, options, {\n        listener,\n        errHandler: this._boundHandleError,\n        rawEmitter: this.fsw._emitRaw\n      });\n    }\n\n    return closer;\n  }\n  /**\n   * Watch a file and emit add event if warranted.\n   * @param {Path} file Path\n   * @param {fs.Stats} stats result of fs_stat\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @returns {Function} closer for the watcher instance\n   */\n\n\n  _handleFile(file, stats, initialAdd) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const dirname = sysPath$2.dirname(file);\n    const basename = sysPath$2.basename(file);\n\n    const parent = this.fsw._getWatchedDir(dirname); // stats is always present\n\n\n    let prevStats = stats; // if the file is already being watched, do nothing\n\n    if (parent.has(basename)) return;\n\n    const listener = async (path, newStats) => {\n      if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n\n      if (!newStats || newStats.mtimeMs === 0) {\n        try {\n          const newStats = await stat$2(file);\n          if (this.fsw.closed) return; // Check that change event was not fired because of changed only accessTime.\n\n          const at = newStats.atimeMs;\n          const mt = newStats.mtimeMs;\n\n          if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n            this.fsw._emit(EV_CHANGE$2, file, newStats);\n          }\n\n          if (isLinux && prevStats.ino !== newStats.ino) {\n            this.fsw._closeFile(path);\n\n            prevStats = newStats;\n\n            this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n          } else {\n            prevStats = newStats;\n          }\n        } catch (error) {\n          // Fix issues where mtime is null but file is still present\n          this.fsw._remove(dirname, basename);\n        } // add is about to be emitted if file not already tracked in parent\n\n      } else if (parent.has(basename)) {\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE$2, file, newStats);\n        }\n\n        prevStats = newStats;\n      }\n    }; // kick off the watcher\n\n\n    const closer = this._watchWithNodeFs(file, listener); // emit an add event if we're supposed to\n\n\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n      if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;\n\n      this.fsw._emit(EV_ADD$2, file, stats);\n    }\n\n    return closer;\n  }\n  /**\n   * Handle symlinks encountered while reading a dir.\n   * @param {Object} entry returned by readdirp\n   * @param {String} directory path of dir being read\n   * @param {String} path of this item\n   * @param {String} item basename of this item\n   * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n   */\n\n\n  async _handleSymlink(entry, directory, path, item) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const full = entry.fullPath;\n\n    const dir = this.fsw._getWatchedDir(directory);\n\n    if (!this.fsw.options.followSymlinks) {\n      // watch symlink directly (don't follow) and detect changes\n      this.fsw._incrReadyCount();\n\n      let linkPath;\n\n      try {\n        linkPath = await fsrealpath(path);\n      } catch (e) {\n        this.fsw._emitReady();\n\n        return true;\n      }\n\n      if (this.fsw.closed) return;\n\n      if (dir.has(item)) {\n        if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n          this.fsw._symlinkPaths.set(full, linkPath);\n\n          this.fsw._emit(EV_CHANGE$2, path, entry.stats);\n        }\n      } else {\n        dir.add(item);\n\n        this.fsw._symlinkPaths.set(full, linkPath);\n\n        this.fsw._emit(EV_ADD$2, path, entry.stats);\n      }\n\n      this.fsw._emitReady();\n\n      return true;\n    } // don't follow the same symlink more than once\n\n\n    if (this.fsw._symlinkPaths.has(full)) {\n      return true;\n    }\n\n    this.fsw._symlinkPaths.set(full, true);\n  }\n\n  _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n    // Normalize the directory name on Windows\n    directory = sysPath$2.join(directory, EMPTY_STR$1);\n\n    if (!wh.hasGlob) {\n      throttler = this.fsw._throttle('readdir', directory, 1000);\n      if (!throttler) return;\n    }\n\n    const previous = this.fsw._getWatchedDir(wh.path);\n\n    const current = new Set();\n\n    let stream = this.fsw._readdirp(directory, {\n      fileFilter: entry => wh.filterPath(entry),\n      directoryFilter: entry => wh.filterDir(entry),\n      depth: 0\n    }).on(STR_DATA$1, async entry => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n\n      const item = entry.path;\n      let path = sysPath$2.join(directory, item);\n      current.add(item);\n\n      if (entry.stats.isSymbolicLink() && (await this._handleSymlink(entry, directory, path, item))) {\n        return;\n      }\n\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      } // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n\n\n      if (item === target || !target && !previous.has(item)) {\n        this.fsw._incrReadyCount(); // ensure relativeness of path is preserved in case of watcher reuse\n\n\n        path = sysPath$2.join(dir, sysPath$2.relative(dir, path));\n\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }).on(EV_ERROR$2, this._boundHandleError);\n\n    return new Promise(resolve => stream.once(STR_END$2, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n\n      const wasThrottled = throttler ? throttler.clear() : false;\n      resolve(); // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n\n      previous.getChildren().filter(item => {\n        return item !== directory && !current.has(item) && ( // in case of intersecting globs;\n        // a path may have been filtered out of this readdir, but\n        // shouldn't be removed because it matches a different glob\n        !wh.hasGlob || wh.filterPath({\n          fullPath: sysPath$2.resolve(directory, item)\n        }));\n      }).forEach(item => {\n        this.fsw._remove(directory, item);\n      });\n      stream = undefined; // one more time for any missed in case changes came in extremely quickly\n\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    }));\n  }\n  /**\n   * Read directory to add / remove files from `@watched` list and re-read it on change.\n   * @param {String} dir fs path\n   * @param {fs.Stats} stats\n   * @param {Boolean} initialAdd\n   * @param {Number} depth relative to user-supplied path\n   * @param {String} target child path targeted for watch\n   * @param {Object} wh Common watch helpers for this path\n   * @param {String} realpath\n   * @returns {Promise<Function>} closer for the watcher instance.\n   */\n\n\n  async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n    const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));\n\n    const tracked = parentDir.has(sysPath$2.basename(dir));\n\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n      if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);\n    } // ensure dir is tracked (harmless if redundant)\n\n\n    parentDir.add(sysPath$2.basename(dir));\n\n    this.fsw._getWatchedDir(dir);\n\n    let throttler;\n    let closer;\n    const oDepth = this.fsw.options.depth;\n\n    if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n      if (!target) {\n        await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n        if (this.fsw.closed) return;\n      }\n\n      closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n        // if current directory is removed, do nothing\n        if (stats && stats.mtimeMs === 0) return;\n\n        this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n      });\n    }\n\n    return closer;\n  }\n  /**\n   * Handle added file, directory, or glob pattern.\n   * Delegates call to _handleFile / _handleDir after checks.\n   * @param {String} path to file or ir\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @param {Object} priorWh depth relative to user-supplied path\n   * @param {Number} depth Child path actually targeted for watch\n   * @param {String=} target Child path actually targeted for watch\n   * @returns {Promise}\n   */\n\n\n  async _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n    const ready = this.fsw._emitReady;\n\n    if (this.fsw._isIgnored(path) || this.fsw.closed) {\n      ready();\n      return false;\n    }\n\n    const wh = this.fsw._getWatchHelpers(path, depth);\n\n    if (!wh.hasGlob && priorWh) {\n      wh.hasGlob = priorWh.hasGlob;\n      wh.globFilter = priorWh.globFilter;\n\n      wh.filterPath = entry => priorWh.filterPath(entry);\n\n      wh.filterDir = entry => priorWh.filterDir(entry);\n    } // evaluate what is at the path we're being asked to watch\n\n\n    try {\n      const stats = await statMethods$1[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        ready();\n        return false;\n      }\n\n      const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START$1);\n      let closer;\n\n      if (stats.isDirectory()) {\n        const absPath = sysPath$2.resolve(path);\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n        if (this.fsw.closed) return; // preserve this symlink's target path\n\n        if (absPath !== targetPath && targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(absPath, targetPath);\n        }\n      } else if (stats.isSymbolicLink()) {\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        const parent = sysPath$2.dirname(wh.watchPath);\n\n        this.fsw._getWatchedDir(parent).add(wh.watchPath);\n\n        this.fsw._emit(EV_ADD$2, wh.watchPath, stats);\n\n        closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n        if (this.fsw.closed) return; // preserve this symlink's target path\n\n        if (targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(sysPath$2.resolve(path), targetPath);\n        }\n      } else {\n        closer = this._handleFile(wh.watchPath, stats, initialAdd);\n      }\n\n      ready();\n\n      this.fsw._addPathCloser(path, closer);\n\n      return false;\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        ready();\n        return path;\n      }\n    }\n  }\n\n}\n\nvar nodefsHandler = NodeFsHandler$1;\nvar fseventsHandler = {\n  exports: {}\n};\nconst require$$3 = /*@__PURE__*/rollup.getAugmentedNamespace(rollup.fseventsImporter);\nconst fs$1 = require$$0$1;\nconst sysPath$1 = require$$0$2;\nconst {\n  promisify: promisify$1\n} = require$$2;\nlet fsevents;\n\ntry {\n  fsevents = require$$3.getFsEvents();\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD: EV_ADD$1,\n  EV_CHANGE: EV_CHANGE$1,\n  EV_ADD_DIR: EV_ADD_DIR$1,\n  EV_UNLINK: EV_UNLINK$1,\n  EV_ERROR: EV_ERROR$1,\n  STR_DATA,\n  STR_END: STR_END$1,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE: FUNCTION_TYPE$1,\n  EMPTY_FN: EMPTY_FN$1,\n  IDENTITY_FN\n} = constants;\n\nconst Depth = value => isNaN(value) ? {} : {\n  depth: value\n};\n\nconst stat$1 = promisify$1(fs$1.stat);\nconst lstat = promisify$1(fs$1.lstat);\nconst realpath = promisify$1(fs$1.realpath);\nconst statMethods = {\n  stat: stat$1,\n  lstat\n};\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n// fsevents instance helper functions\n\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\n\nconst FSEventsWatchers = new Map(); // Threshold of duplicate path prefixes at which to start\n// consolidating going forward\n\nconst consolidateThreshhold = 10;\nconst wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\n\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {\n    stop\n  };\n};\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\n\n\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;\n  const parentPath = sysPath$1.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath); // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath$1.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep)) listener(fullPath, flags, info);\n  }; // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n\n\n  let watchedParent = false;\n\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  } // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n\n\n  return () => {\n    const lst = cont.listeners;\n    lst.delete(filteredListener);\n\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n} // Decide whether or not we should start a new higher-level\n// parent watcher\n\n\nconst couldConsolidate = path => {\n  let count = 0;\n\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // returns boolean indicating whether fsevents can be used\n\n\nconst canUse = () => fsevents && FSEventsWatchers.size < 128; // determines subdirectory traversal levels from root to path\n\n\nconst calcDepth = (path, root) => {\n  let i = 0;\n\n  while (!path.indexOf(root) && (path = sysPath$1.dirname(path)) !== root) i++;\n\n  return i;\n}; // returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\n\n\nconst sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();\n/**\n * @mixin\n */\n\n\nclass FsEventsHandler$1 {\n  /**\n   * @param {import('../index').FSWatcher} fsw\n   */\n  constructor(fsw) {\n    this.fsw = fsw;\n  }\n\n  checkIgnored(path, stats) {\n    const ipaths = this.fsw._ignoredPaths;\n\n    if (this.fsw._isIgnored(path, stats)) {\n      ipaths.add(path);\n\n      if (stats && stats.isDirectory()) {\n        ipaths.add(path + ROOT_GLOBSTAR);\n      }\n\n      return true;\n    }\n\n    ipaths.delete(path);\n    ipaths.delete(path + ROOT_GLOBSTAR);\n  }\n\n  addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;\n    this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n  }\n\n  async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    try {\n      const stats = await stat$1(path);\n      if (this.fsw.closed) return;\n\n      if (sameTypes(info, stats)) {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } catch (error) {\n      if (error.code === 'EACCES') {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  }\n\n  handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    if (this.fsw.closed || this.checkIgnored(path)) return;\n\n    if (event === EV_UNLINK$1) {\n      const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY; // suppress unlink events on never before seen files\n\n      if (isDirectory || watchedDir.has(item)) {\n        this.fsw._remove(parent, item, isDirectory);\n      }\n    } else {\n      if (event === EV_ADD$1) {\n        // track new directories\n        if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n        if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n          // push symlinks back to the top of the stack to get handled\n          const curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;\n          return this._addToFsEvents(path, false, true, curDepth);\n        } // track new paths\n        // (other than symlinks being followed, which will be tracked soon)\n\n\n        this.fsw._getWatchedDir(parent).add(item);\n      }\n      /**\n       * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n       */\n\n\n      const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n\n      this.fsw._emit(eventName, path);\n\n      if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);\n    }\n  }\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} watchPath  - file/dir path to be watched with fsevents\n   * @param {String} realPath   - real path (in case of symlinks)\n   * @param {Function} transform  - path transformer\n   * @param {Function} globFilter - path filter in case a glob pattern was provided\n   * @returns {Function} closer for the watcher instance\n  */\n\n\n  _watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n    if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n    const opts = this.fsw.options;\n\n    const watchCallback = async (fullPath, flags, info) => {\n      if (this.fsw.closed) return;\n      if (opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth) return;\n      const path = transform(sysPath$1.join(watchPath, sysPath$1.relative(watchPath, fullPath)));\n      if (globFilter && !globFilter(path)) return; // ensure directories are tracked\n\n      const parent = sysPath$1.dirname(path);\n      const item = sysPath$1.basename(path);\n\n      const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent); // correct for wrong events emitted\n\n\n      if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n        if (typeof opts.ignored === FUNCTION_TYPE$1) {\n          let stats;\n\n          try {\n            stats = await stat$1(path);\n          } catch (error) {}\n\n          if (this.fsw.closed) return;\n          if (this.checkIgnored(path, stats)) return;\n\n          if (sameTypes(info, stats)) {\n            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          } else {\n            this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          }\n        } else {\n          this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        switch (info.event) {\n          case FSEVENT_CREATED:\n          case FSEVENT_MODIFIED:\n            return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\n          case FSEVENT_DELETED:\n          case FSEVENT_MOVED:\n            return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      }\n    };\n\n    const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);\n\n    this.fsw._emitReady();\n\n    return closer;\n  }\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} linkPath path to symlink\n   * @param {String} fullPath absolute path to the symlink\n   * @param {Function} transform pre-existing path transformer\n   * @param {Number} curDepth level of subdirectories traversed to where symlink is\n   * @returns {Promise<void>}\n   */\n\n\n  async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n    // don't follow the same symlink more than once\n    if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n    this.fsw._symlinkPaths.set(fullPath, true);\n\n    this.fsw._incrReadyCount();\n\n    try {\n      const linkTarget = await realpath(linkPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(linkTarget)) {\n        return this.fsw._emitReady();\n      }\n\n      this.fsw._incrReadyCount(); // add the linkTarget for watching with a wrapper for transform\n      // that causes emitted paths to incorporate the link's path\n\n\n      this._addToFsEvents(linkTarget || linkPath, path => {\n        let aliasedPath = linkPath;\n\n        if (linkTarget && linkTarget !== DOT_SLASH) {\n          aliasedPath = path.replace(linkTarget, linkPath);\n        } else if (path !== DOT_SLASH) {\n          aliasedPath = sysPath$1.join(linkPath, path);\n        }\n\n        return transform(aliasedPath);\n      }, false, curDepth);\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        return this.fsw._emitReady();\n      }\n    }\n  }\n  /**\n   *\n   * @param {Path} newPath\n   * @param {fs.Stats} stats\n   */\n\n\n  emitAdd(newPath, stats, processPath, opts, forceAdd) {\n    const pp = processPath(newPath);\n    const isDir = stats.isDirectory();\n\n    const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));\n\n    const base = sysPath$1.basename(pp); // ensure empty dirs get tracked\n\n    if (isDir) this.fsw._getWatchedDir(pp);\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n\n    if (!opts.ignoreInitial || forceAdd === true) {\n      this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);\n    }\n  }\n\n  initWatch(realPath, path, wh, processPath) {\n    if (this.fsw.closed) return;\n\n    const closer = this._watchWithFsEvents(wh.watchPath, sysPath$1.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n\n    this.fsw._addPathCloser(path, closer);\n  }\n  /**\n   * Handle added path with fsevents\n   * @param {String} path file/dir path or glob pattern\n   * @param {Function|Boolean=} transform converts working path to what the user expects\n   * @param {Boolean=} forceAdd ensure add is emitted\n   * @param {Number=} priorDepth Level of subdirectories already traversed.\n   * @returns {Promise<void>}\n   */\n\n\n  async _addToFsEvents(path, transform, forceAdd, priorDepth) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const opts = this.fsw.options;\n    const processPath = typeof transform === FUNCTION_TYPE$1 ? transform : IDENTITY_FN;\n\n    const wh = this.fsw._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch\n\n\n    try {\n      const stats = await statMethods[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        throw null;\n      }\n\n      if (stats.isDirectory()) {\n        // emit addDir unless this is a glob parent\n        if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd); // don't recurse further if it would exceed depth setting\n\n        if (priorDepth && priorDepth > opts.depth) return; // scan the contents of the dir\n\n        this.fsw._readdirp(wh.watchPath, {\n          fileFilter: entry => wh.filterPath(entry),\n          directoryFilter: entry => wh.filterDir(entry),\n          ...Depth(opts.depth - (priorDepth || 0))\n        }).on(STR_DATA, entry => {\n          // need to check filterPath on dirs b/c filterDir is less restrictive\n          if (this.fsw.closed) {\n            return;\n          }\n\n          if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n          const joinedPath = sysPath$1.join(wh.watchPath, entry.path);\n          const {\n            fullPath\n          } = entry;\n\n          if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n            // preserve the current depth here since it can't be derived from\n            // real paths past the symlink\n            const curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;\n\n            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n          } else {\n            this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n          }\n        }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {\n          this.fsw._emitReady();\n        });\n      } else {\n        this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n\n        this.fsw._emitReady();\n      }\n    } catch (error) {\n      if (!error || this.fsw._handleError(error)) {\n        // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n        this.fsw._emitReady();\n\n        this.fsw._emitReady();\n      }\n    }\n\n    if (opts.persistent && forceAdd !== true) {\n      if (typeof transform === FUNCTION_TYPE$1) {\n        // realpath has already been resolved\n        this.initWatch(undefined, path, wh, processPath);\n      } else {\n        let realPath;\n\n        try {\n          realPath = await realpath(wh.watchPath);\n        } catch (e) {}\n\n        this.initWatch(realPath, path, wh, processPath);\n      }\n    }\n  }\n\n}\n\nfseventsHandler.exports = FsEventsHandler$1;\nfseventsHandler.exports.canUse = canUse;\nconst {\n  EventEmitter\n} = require$$0$3;\nconst fs = require$$0$1;\nconst sysPath = require$$0$2;\nconst {\n  promisify\n} = require$$2;\nconst readdirp = readdirp_1;\nconst anymatch = anymatch$2.exports.default;\nconst globParent = globParent$1;\nconst isGlob = isGlob$2;\nconst braces = braces_1;\nconst normalizePath = normalizePath$2;\nconst NodeFsHandler = nodefsHandler;\nconst FsEventsHandler = fseventsHandler.exports;\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n  STR_CLOSE,\n  STR_END,\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n  isWindows,\n  isMacos,\n  isIBMi\n} = constants;\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = function () {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return Array.isArray(value) ? value : [value];\n};\n\nconst flatten = function (list) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = paths_ => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n\n  return paths.map(normalizePathToUnix);\n}; // If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\n\n\nconst toUnix = string => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n\n  if (prepend) {\n    str = SLASH + str;\n  }\n\n  return str;\n}; // Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\n\n\nconst normalizePathToUnix = path => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = function () {\n  let cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_STR;\n  return path => {\n    if (typeof path !== STRING_TYPE) return path;\n    return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n  };\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\n\n\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n    const dir = this.path;\n\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return items.has(item);\n  }\n  /**\n   * @returns {Array<String>}\n   */\n\n\n  getChildren() {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\n\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach(parts => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {\n        realPath: entry.fullParentDir,\n        linkPath: this.fullWatchPath\n      };\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));\n  }\n\n  filterPath(entry) {\n    const {\n      stats\n    } = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;\n    return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach(path => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some(parts => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n\n}\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\n\n\nclass FSWatcher extends EventEmitter {\n  // Not indenting methods for history sake; for now.\n  constructor(_opts) {\n    var _this;\n\n    super();\n    _this = this;\n    const opts = {};\n    if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n    /** @type {Map<String, DirEntry>} */\n\n    this._watched = new Map();\n    /** @type {Map<String, Array>} */\n\n    this._closers = new Map();\n    /** @type {Set<String>} */\n\n    this._ignoredPaths = new Set();\n    /** @type {Map<ThrottleType, Map>} */\n\n    this._throttled = new Map();\n    /** @type {Map<Path, String|Boolean>} */\n\n    this._symlinkPaths = new Map();\n    this._streams = new Set();\n    this.closed = false; // Set up default options.\n\n    if (undef(opts, 'persistent')) opts.persistent = true;\n    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n    if (undef(opts, 'interval')) opts.interval = 100;\n    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.\n\n    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.\n\n    const canUseFsEvents = FsEventsHandler.canUse();\n    if (!canUseFsEvents) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.\n    // Other platforms use non-polling fs_watch.\n\n    if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n      opts.usePolling = isMacos;\n    } // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n\n\n    if (isIBMi) {\n      opts.usePolling = true;\n    } // Global override (useful for end-developers that need to force polling for all\n    // instances of chokidar, regardless of usage/dependency depth)\n\n\n    const envPoll = process.env.CHOKIDAR_USEPOLLING;\n\n    if (envPoll !== undefined) {\n      const envLower = envPoll.toLowerCase();\n\n      if (envLower === 'false' || envLower === '0') {\n        opts.usePolling = false;\n      } else if (envLower === 'true' || envLower === '1') {\n        opts.usePolling = true;\n      } else {\n        opts.usePolling = !!envLower;\n      }\n    }\n\n    const envInterval = process.env.CHOKIDAR_INTERVAL;\n\n    if (envInterval) {\n      opts.interval = Number.parseInt(envInterval, 10);\n    } // Editor atomic write normalization enabled by default with fs.watch\n\n\n    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n    if (opts.atomic) this._pendingUnlinks = new Map();\n    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n    const awf = opts.awaitWriteFinish;\n\n    if (awf) {\n      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n      if (!awf.pollInterval) awf.pollInterval = 100;\n      this._pendingWrites = new Map();\n    }\n\n    if (opts.ignored) opts.ignored = arrify(opts.ignored);\n    let readyCalls = 0;\n\n    this._emitReady = () => {\n      readyCalls++;\n\n      if (readyCalls >= this._readyCount) {\n        this._emitReady = EMPTY_FN;\n        this._readyEmitted = true; // use process.nextTick to allow time for listener to be bound\n\n        process.nextTick(() => this.emit(EV_READY));\n      }\n    };\n\n    this._emitRaw = function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return _this.emit(EV_RAW, ...args);\n    };\n\n    this._readyEmitted = false;\n    this.options = opts; // Initialize with proper watcher.\n\n    if (opts.useFsEvents) {\n      this._fsEventsHandler = new FsEventsHandler(this);\n    } else {\n      this._nodeFsHandler = new NodeFsHandler(this);\n    } // You’re frozen when your heart’s not open.\n\n\n    Object.freeze(opts);\n  } // Public methods\n\n  /**\n   * Adds paths to be watched on an existing FSWatcher instance\n   * @param {Path|Array<Path>} paths_\n   * @param {String=} _origAdd private; for handling non-existent paths to be watched\n   * @param {Boolean=} _internal private; indicates a non-user add\n   * @returns {FSWatcher} for chaining\n   */\n\n\n  add(paths_, _origAdd, _internal) {\n    const {\n      cwd,\n      disableGlobbing\n    } = this.options;\n    this.closed = false;\n    let paths = unifyPaths(paths_);\n\n    if (cwd) {\n      paths = paths.map(path => {\n        const absPath = getAbsolutePath(path, cwd); // Check `path` instead of `absPath` because the cwd portion can't be a glob\n\n        if (disableGlobbing || !isGlob(path)) {\n          return absPath;\n        }\n\n        return normalizePath(absPath);\n      });\n    } // set aside negated glob strings\n\n\n    paths = paths.filter(path => {\n      if (path.startsWith(BANG)) {\n        this._ignoredPaths.add(path.slice(1));\n\n        return false;\n      } // if a path is being added that was previously ignored, stop ignoring it\n\n\n      this._ignoredPaths.delete(path);\n\n      this._ignoredPaths.delete(path + SLASH_GLOBSTAR); // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n\n\n      this._userIgnored = undefined;\n      return true;\n    });\n\n    if (this.options.useFsEvents && this._fsEventsHandler) {\n      if (!this._readyCount) this._readyCount = paths.length;\n      if (this.options.persistent) this._readyCount *= 2;\n      paths.forEach(path => this._fsEventsHandler._addToFsEvents(path));\n    } else {\n      if (!this._readyCount) this._readyCount = 0;\n      this._readyCount += paths.length;\n      Promise.all(paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })).then(results => {\n        if (this.closed) return;\n        results.filter(item => item).forEach(item => {\n          this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n        });\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Close watchers or start ignoring events from specified paths.\n   * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n   * @returns {FSWatcher} for chaining\n  */\n\n\n  unwatch(paths_) {\n    if (this.closed) return this;\n    const paths = unifyPaths(paths_);\n    const {\n      cwd\n    } = this.options;\n    paths.forEach(path => {\n      // convert to absolute path unless relative path already matches\n      if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n        if (cwd) path = sysPath.join(cwd, path);\n        path = sysPath.resolve(path);\n      }\n\n      this._closePath(path);\n\n      this._ignoredPaths.add(path);\n\n      if (this._watched.has(path)) {\n        this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n      } // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n\n\n      this._userIgnored = undefined;\n    });\n    return this;\n  }\n  /**\n   * Close watchers and remove all listeners from watched paths.\n   * @returns {Promise<void>}.\n  */\n\n\n  close() {\n    if (this.closed) return this._closePromise;\n    this.closed = true; // Memory management.\n\n    this.removeAllListeners();\n    const closers = [];\n\n    this._closers.forEach(closerList => closerList.forEach(closer => {\n      const promise = closer();\n      if (promise instanceof Promise) closers.push(promise);\n    }));\n\n    this._streams.forEach(stream => stream.destroy());\n\n    this._userIgnored = undefined;\n    this._readyCount = 0;\n    this._readyEmitted = false;\n\n    this._watched.forEach(dirent => dirent.dispose());\n\n    ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n      this[`_${key}`].clear();\n    });\n    this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n    return this._closePromise;\n  }\n  /**\n   * Expose list of watched paths\n   * @returns {Object} for chaining\n  */\n\n\n  getWatched() {\n    const watchList = {};\n\n    this._watched.forEach((entry, dir) => {\n      const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n      watchList[key || ONE_DOT] = entry.getChildren().sort();\n    });\n\n    return watchList;\n  }\n\n  emitWithAll(event, args) {\n    this.emit(...args);\n    if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n  } // Common helpers\n  // --------------\n\n  /**\n   * Normalize and emit events.\n   * Calling _emit DOES NOT MEAN emit() would be called!\n   * @param {EventName} event Type of event\n   * @param {Path} path File or directory path\n   * @param {*=} val1 arguments to be passed with event\n   * @param {*=} val2\n   * @param {*=} val3\n   * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n\n\n  async _emit(event, path, val1, val2, val3) {\n    if (this.closed) return;\n    const opts = this.options;\n    if (isWindows) path = sysPath.normalize(path);\n    if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n    /** @type Array<any> */\n\n    const args = [event, path];\n    if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n    const awf = opts.awaitWriteFinish;\n    let pw;\n\n    if (awf && (pw = this._pendingWrites.get(path))) {\n      pw.lastChange = new Date();\n      return this;\n    }\n\n    if (opts.atomic) {\n      if (event === EV_UNLINK) {\n        this._pendingUnlinks.set(path, args);\n\n        setTimeout(() => {\n          this._pendingUnlinks.forEach((entry, path) => {\n            this.emit(...entry);\n            this.emit(EV_ALL, ...entry);\n\n            this._pendingUnlinks.delete(path);\n          });\n        }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n        return this;\n      }\n\n      if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n        event = args[0] = EV_CHANGE;\n\n        this._pendingUnlinks.delete(path);\n      }\n    }\n\n    if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n      const awfEmit = (err, stats) => {\n        if (err) {\n          event = args[0] = EV_ERROR;\n          args[1] = err;\n          this.emitWithAll(event, args);\n        } else if (stats) {\n          // if stats doesn't exist the file must have been deleted\n          if (args.length > 2) {\n            args[2] = stats;\n          } else {\n            args.push(stats);\n          }\n\n          this.emitWithAll(event, args);\n        }\n      };\n\n      this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n\n      return this;\n    }\n\n    if (event === EV_CHANGE) {\n      const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n      if (isThrottled) return this;\n    }\n\n    if (opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {\n      const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n      let stats;\n\n      try {\n        stats = await stat(fullPath);\n      } catch (err) {} // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n\n\n      if (!stats || this.closed) return;\n      args.push(stats);\n    }\n\n    this.emitWithAll(event, args);\n    return this;\n  }\n  /**\n   * Common handler for errors\n   * @param {Error} error\n   * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n\n\n  _handleError(error) {\n    const code = error && error.code;\n\n    if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {\n      this.emit(EV_ERROR, error);\n    }\n\n    return error || this.closed;\n  }\n  /**\n   * Helper utility for throttling\n   * @param {ThrottleType} actionType type being throttled\n   * @param {Path} path being acted upon\n   * @param {Number} timeout duration of time to suppress duplicate actions\n   * @returns {Object|false} tracking object or false if action should be suppressed\n   */\n\n\n  _throttle(actionType, path, timeout) {\n    if (!this._throttled.has(actionType)) {\n      this._throttled.set(actionType, new Map());\n    }\n    /** @type {Map<Path, Object>} */\n\n\n    const action = this._throttled.get(actionType);\n    /** @type {Object} */\n\n\n    const actionPath = action.get(path);\n\n    if (actionPath) {\n      actionPath.count++;\n      return false;\n    }\n\n    let timeoutObject;\n\n    const clear = () => {\n      const item = action.get(path);\n      const count = item ? item.count : 0;\n      action.delete(path);\n      clearTimeout(timeoutObject);\n      if (item) clearTimeout(item.timeoutObject);\n      return count;\n    };\n\n    timeoutObject = setTimeout(clear, timeout);\n    const thr = {\n      timeoutObject,\n      clear,\n      count: 0\n    };\n    action.set(path, thr);\n    return thr;\n  }\n\n  _incrReadyCount() {\n    return this._readyCount++;\n  }\n  /**\n   * Awaits write operation to finish.\n   * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n   * @param {Path} path being acted upon\n   * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n   * @param {EventName} event\n   * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n   */\n\n\n  _awaitWriteFinish(path, threshold, event, awfEmit) {\n    let timeoutHandler;\n    let fullPath = path;\n\n    if (this.options.cwd && !sysPath.isAbsolute(path)) {\n      fullPath = sysPath.join(this.options.cwd, path);\n    }\n\n    const now = new Date();\n\n    const awaitWriteFinish = prevStat => {\n      fs.stat(fullPath, (err, curStat) => {\n        if (err || !this._pendingWrites.has(path)) {\n          if (err && err.code !== 'ENOENT') awfEmit(err);\n          return;\n        }\n\n        const now = Number(new Date());\n\n        if (prevStat && curStat.size !== prevStat.size) {\n          this._pendingWrites.get(path).lastChange = now;\n        }\n\n        const pw = this._pendingWrites.get(path);\n\n        const df = now - pw.lastChange;\n\n        if (df >= threshold) {\n          this._pendingWrites.delete(path);\n\n          awfEmit(undefined, curStat);\n        } else {\n          timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);\n        }\n      });\n    };\n\n    if (!this._pendingWrites.has(path)) {\n      this._pendingWrites.set(path, {\n        lastChange: now,\n        cancelWait: () => {\n          this._pendingWrites.delete(path);\n\n          clearTimeout(timeoutHandler);\n          return event;\n        }\n      });\n\n      timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);\n    }\n  }\n\n  _getGlobIgnored() {\n    return [...this._ignoredPaths.values()];\n  }\n  /**\n   * Determines whether user has asked to ignore this path.\n   * @param {Path} path filepath or dir\n   * @param {fs.Stats=} stats result of fs.stat\n   * @returns {Boolean}\n   */\n\n\n  _isIgnored(path, stats) {\n    if (this.options.atomic && DOT_RE.test(path)) return true;\n\n    if (!this._userIgnored) {\n      const {\n        cwd\n      } = this.options;\n      const ign = this.options.ignored;\n      const ignored = ign && ign.map(normalizeIgnored(cwd));\n      const paths = arrify(ignored).filter(path => typeof path === STRING_TYPE && !isGlob(path)).map(path => path + SLASH_GLOBSTAR);\n\n      const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n\n      this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n    }\n\n    return this._userIgnored([path, stats]);\n  }\n\n  _isntIgnored(path, stat) {\n    return !this._isIgnored(path, stat);\n  }\n  /**\n   * Provides a set of common helpers and properties relating to symlink and glob handling.\n   * @param {Path} path file, directory, or glob pattern being watched\n   * @param {Number=} depth at any depth > 0, this isn't a glob\n   * @returns {WatchHelper} object containing helpers for this path\n   */\n\n\n  _getWatchHelpers(path, depth) {\n    const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n    const follow = this.options.followSymlinks;\n    return new WatchHelper(path, watchPath, follow, this);\n  } // Directory helpers\n  // -----------------\n\n  /**\n   * Provides directory tracking objects\n   * @param {String} directory path of the directory\n   * @returns {DirEntry} the directory's tracking object\n   */\n\n\n  _getWatchedDir(directory) {\n    if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n    const dir = sysPath.resolve(directory);\n    if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n    return this._watched.get(dir);\n  } // File helpers\n  // ------------\n\n  /**\n   * Check for read permissions.\n   * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n   * @param {fs.Stats} stats - object, result of fs_stat\n   * @returns {Boolean} indicates whether the file can be read\n  */\n\n\n  _hasReadPermissions(stats) {\n    if (this.options.ignorePermissionErrors) return true; // stats.mode may be bigint\n\n    const md = stats && Number.parseInt(stats.mode, 10);\n    const st = md & 0o777;\n    const it = Number.parseInt(st.toString(8)[0], 10);\n    return Boolean(4 & it);\n  }\n  /**\n   * Handles emitting unlink events for\n   * files and directories, and via recursion, for\n   * files and directories within directories that are unlinked\n   * @param {String} directory within which the following item is located\n   * @param {String} item      base path of item/directory\n   * @returns {void}\n  */\n\n\n  _remove(directory, item, isDirectory) {\n    // if what is being deleted is a directory, get that directory's paths\n    // for recursive deleting and cleaning of watched object\n    // if it is not a directory, nestedDirectoryChildren will be empty array\n    const path = sysPath.join(directory, item);\n    const fullPath = sysPath.resolve(path);\n    isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath); // prevent duplicate handling in case of arriving here nearly simultaneously\n    // via multiple paths (such as _handleFile and _handleDir)\n\n    if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return\n\n    if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n      this.add(directory, item, true);\n    } // This will create a new entry in the watched object in either case\n    // so we got to do the directory check beforehand\n\n\n    const wp = this._getWatchedDir(path);\n\n    const nestedDirectoryChildren = wp.getChildren(); // Recursively remove children directories / files.\n\n    nestedDirectoryChildren.forEach(nested => this._remove(path, nested)); // Check if item was on the watched list and remove it\n\n    const parent = this._getWatchedDir(directory);\n\n    const wasTracked = parent.has(item);\n    parent.remove(item); // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n    // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n    // but never removed from the map in case the path was deleted.\n    // This leads to an incorrect state if the path was recreated:\n    // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n\n    if (this._symlinkPaths.has(fullPath)) {\n      this._symlinkPaths.delete(fullPath);\n    } // If we wait for this file to be fully written, cancel the wait.\n\n\n    let relPath = path;\n    if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n\n    if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n      const event = this._pendingWrites.get(relPath).cancelWait();\n\n      if (event === EV_ADD) return;\n    } // The Entry will either be a directory that just got removed\n    // or a bogus entry to a file, in either case we have to remove it\n\n\n    this._watched.delete(path);\n\n    this._watched.delete(fullPath);\n\n    const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n    if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name\n\n    if (!this.options.useFsEvents) {\n      this._closePath(path);\n    }\n  }\n  /**\n   * Closes all watchers for a path\n   * @param {Path} path\n   */\n\n\n  _closePath(path) {\n    this._closeFile(path);\n\n    const dir = sysPath.dirname(path);\n\n    this._getWatchedDir(dir).remove(sysPath.basename(path));\n  }\n  /**\n   * Closes only file-specific watchers\n   * @param {Path} path\n   */\n\n\n  _closeFile(path) {\n    const closers = this._closers.get(path);\n\n    if (!closers) return;\n    closers.forEach(closer => closer());\n\n    this._closers.delete(path);\n  }\n  /**\n   *\n   * @param {Path} path\n   * @param {Function} closer\n   */\n\n\n  _addPathCloser(path, closer) {\n    if (!closer) return;\n\n    let list = this._closers.get(path);\n\n    if (!list) {\n      list = [];\n\n      this._closers.set(path, list);\n    }\n\n    list.push(closer);\n  }\n\n  _readdirp(root, opts) {\n    if (this.closed) return;\n    const options = {\n      type: EV_ALL,\n      alwaysStat: true,\n      lstat: true,\n      ...opts\n    };\n    let stream = readdirp(root, options);\n\n    this._streams.add(stream);\n\n    stream.once(STR_CLOSE, () => {\n      stream = undefined;\n    });\n    stream.once(STR_END, () => {\n      if (stream) {\n        this._streams.delete(stream);\n\n        stream = undefined;\n      }\n    });\n    return stream;\n  }\n\n} // Export FSWatcher class\n\n\nchokidar.FSWatcher = FSWatcher;\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\n\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nchokidar.watch = watch;\nexports.chokidar = chokidar;","map":{"version":3,"names":["rollup","require","require$$0$1","require$$2","require$$1","require$$0$2","require$$2$1","require$$0$3","chokidar","fs$3","Readable","sysPath$3","promisify","promisify$3","picomatch$1","picomatch","exports","readdir$1","readdir","stat$3","stat","lstat$2","lstat","realpath$1","realpath","BANG$2","RECURSIVE_ERROR_CODE","NORMAL_FLOW_ERRORS","Set","FILE_TYPE","DIR_TYPE","FILE_DIR_TYPE","EVERYTHING_TYPE","ALL_TYPES","isNormalFlowError","error","has","code","maj","min","process","versions","node","split","slice","map","n","Number","parseInt","wantBigintFsStats","platform","normalizeFilter","filter","undefined","glob","trim","entry","basename","Array","isArray","positive","negative","item","trimmed","charAt","push","length","some","f","ReaddirpStream","defaultOptions","root","fileFilter","path","directoryFilter","type","depth","alwaysStat","constructor","options","objectMode","autoDestroy","highWaterMark","opts","_fileFilter","_directoryFilter","statMethod","_stat","bigint","_maxDepth","_wantsDir","includes","_wantsFile","_wantsEverything","_root","resolve","_isDirent","_statsProp","_rdOptions","encoding","withFileTypes","parents","_exploreDir","reading","parent","_read","batch","destroyed","files","splice","dirent","_formatEntry","Promise","all","entryType","_getEntryType","fullPath","_includeAsFile","pop","destroy","_onError","name","join","relative","err","emit","stats","isFile","isDirectory","isSymbolicLink","full","entryRealPath","entryRealPathStats","len","startsWith","substr","sep","recursiveError","Error","readdirp$1","TypeError","readdirpPromise","reject","on","promise","default","readdirp_1","anymatch$2","normalizePath$2","stripTrailing","prefix","ch","segs","Object","defineProperty","value","normalizePath$1","BANG$1","DEFAULT_OPTIONS","returnIndex","arrify$1","createPattern","matcher","string","RegExp","test","matchPatterns","patterns","negPatterns","args","isList","_path","prototype","toString","call","index","nglob","applied","concat","pattern","anymatch$1","matchers","testString","mtchers","negatedGlobs","ri","isExtglob$1","isExtglob","str","match","exec","chars","strictCheck","pipeIndex","closeSquareIndex","closeCurlyIndex","closeParenIndex","backSlashIndex","indexOf","open","close","relaxedCheck","isGlob$2","isGlob","check","strict","isGlob$1","pathPosixDirname","posix","dirname","isWin32","slash","backslash","enclosure","globby","escaped","globParent$1","globParent","assign","flipBackslashes","replace","utils$3","isInteger","num","find","nodes","exceedsLimit","max","step","limit","escapeNode","block","encloseBrace","commas","ranges","invalid","isInvalidBrace","dollar","isOpenOrClose","reduce","acc","flatten","result","flat","arr","i","ele","utils$2","stringify$4","ast","stringify","invalidBlock","escapeInvalid","invalidNode","output","child","isNumber$2","isFinite","isNumber$1","toRegexRange$1","String","relaxZeros","strictZeros","relax","shorthand","capture","wrap","cacheKey","cache","hasOwnProperty","a","Math","b","abs","isPadded","hasPadding","state","positives","negatives","maxLen","newMin","splitToPatterns","collatePatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","subpatterns","splitToRanges","nines","zeros","stop","countNines","stops","add","countZeros","sort","compare","rangeToPattern","start","count","digits","zipped","zip","startDigit","stopDigit","toCharacterClass","tok","tokens","prev","obj","toQuantifier","padZeros","comparison","intersection","contains","key","val","repeat","integer","pow","diff","clearCache","toRegexRange_1","util","toRegexRange","isObject","transform","toNumber","isValidValue","isNumber","input","stringify$3","end","pad","maxLength","dash","padStart","toMaxLen","toSequence","parts","toRange","isNumbers","fromCharCode","toRegex","rangeError","RangeError","inspect","invalidRange","strictRanges","invalidStep","fillNumbers","descending","startString","endString","stepString","padded","format","range","fillLetters","charCodeAt","fill$2","fillRange","fill$1","utils$1","compile$1","walk","isOpen","isClose","compile_1","fill","stringify$2","utils","append","queue","stash","enclose","expand$1","rangeLimit","p","q","expand_1","constants$1","MAX_LENGTH","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKSLASH","CHAR_BACKTICK","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_COMMA","CHAR_DOLLAR","CHAR_DOT","CHAR_DOUBLE_QUOTE","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LEFT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_LINE_FEED","CHAR_NO_BREAK_SPACE","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_RIGHT_CURLY_BRACE","CHAR_RIGHT_SQUARE_BRACKET","CHAR_SEMICOLON","CHAR_SINGLE_QUOTE","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","stringify$1","parse$1","SyntaxError","stack","brackets","advance","keepEscaping","next","keepQuotes","brace","shift","siblings","before","forEach","parse_1","compile","expand","parse","braces$1","create","nodupes","noempty","Boolean","braces_1","binaryExtensions$1","require$$0","module","binaryExtensions","extensions","isBinaryPath$1","filePath","extname","toLowerCase","constants","os","EV_ALL","EV_READY","EV_ADD","EV_CHANGE","EV_ADD_DIR","EV_UNLINK","EV_UNLINK_DIR","EV_RAW","EV_ERROR","STR_DATA","STR_END","STR_CLOSE","FSEVENT_CREATED","FSEVENT_MODIFIED","FSEVENT_DELETED","FSEVENT_MOVED","FSEVENT_CLONED","FSEVENT_UNKNOWN","FSEVENT_TYPE_FILE","FSEVENT_TYPE_DIRECTORY","FSEVENT_TYPE_SYMLINK","KEY_LISTENERS","KEY_ERR","KEY_RAW","HANDLER_KEYS","DOT_SLASH","BACK_SLASH_RE","DOUBLE_SLASH_RE","SLASH_OR_BACK_SLASH_RE","DOT_RE","REPLACER_RE","SLASH","SLASH_SLASH","BRACE_START","BANG","ONE_DOT","TWO_DOTS","STAR","GLOBSTAR","ROOT_GLOBSTAR","SLASH_GLOBSTAR","DIR_SUFFIX","ANYMATCH_OPTS","dot","STRING_TYPE","FUNCTION_TYPE","EMPTY_STR","EMPTY_FN","IDENTITY_FN","isWindows","isMacos","isLinux","isIBMi","fs$2","sysPath$2","promisify$2","isBinaryPath","isWindows$1","EMPTY_FN$2","EMPTY_STR$1","EV_CHANGE$2","EV_ADD$2","EV_ADD_DIR$2","EV_ERROR$2","STR_DATA$1","STR_END$2","BRACE_START$1","THROTTLE_MODE_WATCH","stat$2","lstat$1","fsrealpath","statMethods$1","foreach","fn","addAndConvert","main","prop","container","clearItem","cont","set","clear","delFromSet","delete","isEmptySet","size","FsWatchInstances","Map","createFsWatchInstance","listener","errHandler","emitRaw","handleEvent","rawEvent","evPath","watchedPath","fsWatchBroadcast","watch","val1","val2","val3","get","setFsWatchListener","handlers","rawEmitter","watcher","persistent","bind","broadcastErr","watcherUnusable","fd","listeners","errHandlers","rawEmitters","freeze","FsWatchFileInstances","setFsWatchFileListener","copts","interval","unwatchFile","watchFile","curr","currmtime","mtimeMs","NodeFsHandler$1","fsW","fsw","_boundHandleError","_handleError","_watchWithNodeFs","directory","_getWatchedDir","absolutePath","closer","usePolling","enableBinaryInterval","binaryInterval","_emitRaw","_handleFile","file","initialAdd","closed","prevStats","newStats","_throttle","at","atimeMs","mt","_emit","ino","_closeFile","_addPathCloser","_remove","ignoreInitial","_isntIgnored","_handleSymlink","dir","followSymlinks","_incrReadyCount","linkPath","e","_emitReady","_symlinkPaths","_handleRead","wh","target","throttler","hasGlob","previous","current","stream","_readdirp","filterPath","filterDir","_addToNodeFs","once","wasThrottled","getChildren","_handleDir","parentDir","tracked","globFilter","oDepth","dirPath","priorWh","ready","_isIgnored","_getWatchHelpers","watchPath","follow","absPath","targetPath","nodefsHandler","fseventsHandler","require$$3","getAugmentedNamespace","fseventsImporter","fs$1","sysPath$1","promisify$1","fsevents","getFsEvents","env","CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR","console","mtch","version","EV_ADD$1","EV_CHANGE$1","EV_ADD_DIR$1","EV_UNLINK$1","EV_ERROR$1","STR_END$1","FUNCTION_TYPE$1","EMPTY_FN$1","Depth","isNaN","stat$1","statMethods","FSEventsWatchers","consolidateThreshhold","wrongEventFlags","createFSEventsInstance","callback","setFSEventsListener","realPath","parentPath","couldConsolidate","resolvedPath","hasSymlink","filteredListener","flags","info","watchedParent","keys","getInfo","list","event","lst","then","canUse","calcDepth","sameTypes","FsEventsHandler$1","checkIgnored","ipaths","_ignoredPaths","addOrChange","watchedDir","checkExists","curDepth","_addToFsEvents","eventName","_watchWithFsEvents","watchCallback","ignored","_handleFsEventsSymlink","linkTarget","aliasedPath","emitAdd","newPath","processPath","forceAdd","pp","isDir","dirObj","base","initWatch","priorDepth","joinedPath","EventEmitter","fs","sysPath","readdirp","anymatch","braces","normalizePath","NodeFsHandler","FsEventsHandler","arrify","unifyPaths","paths_","paths","every","normalizePathToUnix","toUnix","prepend","normalize","normalizeIgnored","cwd","isAbsolute","getAbsolutePath","undef","DirEntry","removeWatcher","_removeWatcher","items","remove","values","dispose","STAT_METHOD_F","STAT_METHOD_L","WatchHelper","fullWatchPath","globSymlink","dirParts","getDirParts","checkGlobSymlink","fullParentDir","entryPath","matchesGlob","_hasReadPermissions","expandedPath","entryParts","globstar","unmatchedGlob","part","FSWatcher","_opts","_watched","_closers","_throttled","_streams","ignorePermissionErrors","disableGlobbing","useFsEvents","canUseFsEvents","envPoll","CHOKIDAR_USEPOLLING","envLower","envInterval","CHOKIDAR_INTERVAL","atomic","_pendingUnlinks","awaitWriteFinish","awf","stabilityThreshold","pollInterval","_pendingWrites","readyCalls","_readyCount","_readyEmitted","nextTick","_fsEventsHandler","_nodeFsHandler","_origAdd","_internal","_userIgnored","res","results","unwatch","_closePath","_closePromise","removeAllListeners","closers","closerList","getWatched","watchList","emitWithAll","pw","lastChange","Date","setTimeout","awfEmit","_awaitWriteFinish","isThrottled","actionType","timeout","action","actionPath","timeoutObject","clearTimeout","thr","threshold","timeoutHandler","now","prevStat","curStat","df","cancelWait","_getGlobIgnored","ign","_boundRemove","md","mode","st","it","wp","nestedDirectoryChildren","nested","wasTracked","relPath"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/rollup/dist/shared/index.js"],"sourcesContent":["/*\n  @license\n\tRollup.js v2.79.0\n\tWed, 31 Aug 2022 04:52:13 GMT - commit 8477f8ff1fe80086556021542b22942ad27a0a69\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\n'use strict';\n\nconst rollup = require('./rollup.js');\nconst require$$0$1 = require('fs');\nconst require$$2 = require('util');\nconst require$$1 = require('stream');\nconst require$$0$2 = require('path');\nconst require$$2$1 = require('os');\nconst require$$0$3 = require('events');\n\nvar chokidar = {};\n\nconst fs$3 = require$$0$1;\nconst { Readable } = require$$1;\nconst sysPath$3 = require$$0$2;\nconst { promisify: promisify$3 } = require$$2;\nconst picomatch$1 = rollup.picomatch.exports;\n\nconst readdir$1 = promisify$3(fs$3.readdir);\nconst stat$3 = promisify$3(fs$3.stat);\nconst lstat$2 = promisify$3(fs$3.lstat);\nconst realpath$1 = promisify$3(fs$3.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG$2 = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || (maj === 10 && min >= 5));\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch$1(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG$2) {\n        negative.push(picomatch$1(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch$1(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat$2 : stat$3;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath$3.resolve(root);\n    this._isDirent = ('Dirent' in fs$3) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir$1(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return { files, depth, path };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath$3.resolve(sysPath$3.join(path, basename));\n      entry = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      const full = entry.fullPath;\n      try {\n        const entryRealPath = await realpath$1(full);\n        const entryRealPathStats = await lstat$2(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          const len = entryRealPath.length;\n          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {\n            const recursiveError = new Error(\n              `Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`\n            );\n            recursiveError.code = RECURSIVE_ERROR_CODE;\n            return this._onError(recursiveError);\n          }\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp$1 = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp$1(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp$1.promise = readdirpPromise;\nreaddirp$1.ReaddirpStream = ReaddirpStream;\nreaddirp$1.default = readdirp$1;\n\nvar readdirp_1 = readdirp$1;\n\nvar anymatch$2 = {exports: {}};\n\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath$2 = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n\nObject.defineProperty(anymatch$2.exports, \"__esModule\", { value: true });\n\nconst picomatch = rollup.picomatch.exports;\nconst normalizePath$1 = normalizePath$2;\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG$1 = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify$1 = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath$1(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch$1 = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify$1(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG$1)\n    .map(item => item.slice(1))\n    .map(item => picomatch(item, opts));\n  const patterns = mtchers\n    .filter(item => typeof item !== 'string' || (typeof item === 'string' && item.charAt(0) !== BANG$1))\n    .map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch$1.default = anymatch$1;\nanymatch$2.exports = anymatch$1;\n\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob$1 = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isExtglob = isExtglob$1;\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  var pipeIndex = -2;\n  var closeSquareIndex = -2;\n  var closeCurlyIndex = -2;\n  var closeParenIndex = -2;\n  var backSlashIndex = -2;\n  while (index < str.length) {\n    if (str[index] === '*') {\n      return true;\n    }\n\n    if (str[index + 1] === '?' && /[\\].+)]/.test(str[index])) {\n      return true;\n    }\n\n    if (closeSquareIndex !== -1 && str[index] === '[' && str[index + 1] !== ']') {\n      if (closeSquareIndex < index) {\n        closeSquareIndex = str.indexOf(']', index);\n      }\n      if (closeSquareIndex > index) {\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeCurlyIndex !== -1 && str[index] === '{' && str[index + 1] !== '}') {\n      closeCurlyIndex = str.indexOf('}', index);\n      if (closeCurlyIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (closeParenIndex !== -1 && str[index] === '(' && str[index + 1] === '?' && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ')') {\n      closeParenIndex = str.indexOf(')', index);\n      if (closeParenIndex > index) {\n        backSlashIndex = str.indexOf('\\\\', index);\n        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n          return true;\n        }\n      }\n    }\n\n    if (pipeIndex !== -1 && str[index] === '(' && str[index + 1] !== '|') {\n      if (pipeIndex < index) {\n        pipeIndex = str.indexOf('|', index);\n      }\n      if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {\n        closeParenIndex = str.indexOf(')', pipeIndex);\n        if (closeParenIndex > pipeIndex) {\n          backSlashIndex = str.indexOf('\\\\', pipeIndex);\n          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {\n            return true;\n          }\n        }\n      }\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar relaxedCheck = function(str) {\n  if (str[0] === '!') {\n    return true;\n  }\n  var index = 0;\n  while (index < str.length) {\n    if (/[*?{}()[\\]]/.test(str[index])) {\n      return true;\n    }\n\n    if (str[index] === '\\\\') {\n      var open = str[index + 1];\n      index += 2;\n      var close = chars[open];\n\n      if (close) {\n        var n = str.indexOf(close, index);\n        if (n !== -1) {\n          index = n + 1;\n        }\n      }\n\n      if (str[index] === '!') {\n        return true;\n      }\n    } else {\n      index++;\n    }\n  }\n  return false;\n};\n\nvar isGlob$2 = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var check = strictCheck;\n\n  // optionally relax check\n  if (options && options.strict === false) {\n    check = relaxedCheck;\n  }\n\n  return check(str);\n};\n\nvar isGlob$1 = isGlob$2;\nvar pathPosixDirname = require$$0$2.posix.dirname;\nvar isWin32 = require$$2$1.platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n * @returns {string}\n */\nvar globParent$1 = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob$1(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n\nvar utils$3 = {};\n\n(function (exports) {\n\n\texports.isInteger = num => {\n\t  if (typeof num === 'number') {\n\t    return Number.isInteger(num);\n\t  }\n\t  if (typeof num === 'string' && num.trim() !== '') {\n\t    return Number.isInteger(Number(num));\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Find a node of the given type\n\t */\n\n\texports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n\t/**\n\t * Find a node of the given type\n\t */\n\n\texports.exceedsLimit = (min, max, step = 1, limit) => {\n\t  if (limit === false) return false;\n\t  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n\t  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n\t};\n\n\t/**\n\t * Escape the given node with '\\\\' before node.value\n\t */\n\n\texports.escapeNode = (block, n = 0, type) => {\n\t  let node = block.nodes[n];\n\t  if (!node) return;\n\n\t  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n\t    if (node.escaped !== true) {\n\t      node.value = '\\\\' + node.value;\n\t      node.escaped = true;\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Returns true if the given brace node should be enclosed in literal braces\n\t */\n\n\texports.encloseBrace = node => {\n\t  if (node.type !== 'brace') return false;\n\t  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n\t    node.invalid = true;\n\t    return true;\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Returns true if a brace node is invalid.\n\t */\n\n\texports.isInvalidBrace = block => {\n\t  if (block.type !== 'brace') return false;\n\t  if (block.invalid === true || block.dollar) return true;\n\t  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n\t    block.invalid = true;\n\t    return true;\n\t  }\n\t  if (block.open !== true || block.close !== true) {\n\t    block.invalid = true;\n\t    return true;\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Returns true if a node is an open or close node\n\t */\n\n\texports.isOpenOrClose = node => {\n\t  if (node.type === 'open' || node.type === 'close') {\n\t    return true;\n\t  }\n\t  return node.open === true || node.close === true;\n\t};\n\n\t/**\n\t * Reduce an array of text nodes.\n\t */\n\n\texports.reduce = nodes => nodes.reduce((acc, node) => {\n\t  if (node.type === 'text') acc.push(node.value);\n\t  if (node.type === 'range') node.type = 'text';\n\t  return acc;\n\t}, []);\n\n\t/**\n\t * Flatten an array\n\t */\n\n\texports.flatten = (...args) => {\n\t  const result = [];\n\t  const flat = arr => {\n\t    for (let i = 0; i < arr.length; i++) {\n\t      let ele = arr[i];\n\t      Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n\t    }\n\t    return result;\n\t  };\n\t  flat(args);\n\t  return result;\n\t};\n} (utils$3));\n\nconst utils$2 = utils$3;\n\nvar stringify$4 = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils$2.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils$2.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isNumber$2 = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n\n/*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nconst isNumber$1 = isNumber$2;\n\nconst toRegexRange$1 = (min, max, options) => {\n  if (isNumber$1(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber$1(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange$1.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange$1.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange$1.cache = {};\ntoRegexRange$1.clearCache = () => (toRegexRange$1.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nvar toRegexRange_1 = toRegexRange$1;\n\n/*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nconst util = require$$2;\nconst toRegexRange = toRegexRange_1;\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify$3 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$3(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill$2 = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill$2(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill$2(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill$2(start, end, 1, step);\n  }\n\n  if (isNumber(start) && isNumber(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nvar fillRange = fill$2;\n\nconst fill$1 = fillRange;\nconst utils$1 = utils$3;\n\nconst compile$1 = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n      let range = fill$1(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nvar compile_1 = compile$1;\n\nconst fill = fillRange;\nconst stringify$2 = stringify$4;\nconst utils = utils$3;\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand$1 = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify$2(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fill(...args, options);\n      if (range.length === 0) {\n        range = stringify$2(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nvar expand_1 = expand$1;\n\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n\nconst stringify$1 = stringify$4;\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants$1;\n\n/**\n * parse\n */\n\nconst parse$1 = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify$1(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nvar parse_1 = parse$1;\n\nconst stringify = stringify$4;\nconst compile = compile_1;\nconst expand = expand_1;\nconst parse = parse_1;\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces$1 = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces$1.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces$1.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces$1.parse = (input, options = {}) => parse(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces$1.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n  return compile(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces$1.parse(input, options);\n  }\n\n  let result = expand(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces$1.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces$1.compile(input, options)\n    : braces$1.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nvar braces_1 = braces$1;\n\nvar binaryExtensions$1 = {exports: {}};\n\nconst require$$0 = [\n\t\"3dm\",\n\t\"3ds\",\n\t\"3g2\",\n\t\"3gp\",\n\t\"7z\",\n\t\"a\",\n\t\"aac\",\n\t\"adp\",\n\t\"ai\",\n\t\"aif\",\n\t\"aiff\",\n\t\"alz\",\n\t\"ape\",\n\t\"apk\",\n\t\"appimage\",\n\t\"ar\",\n\t\"arj\",\n\t\"asf\",\n\t\"au\",\n\t\"avi\",\n\t\"bak\",\n\t\"baml\",\n\t\"bh\",\n\t\"bin\",\n\t\"bk\",\n\t\"bmp\",\n\t\"btif\",\n\t\"bz2\",\n\t\"bzip2\",\n\t\"cab\",\n\t\"caf\",\n\t\"cgm\",\n\t\"class\",\n\t\"cmx\",\n\t\"cpio\",\n\t\"cr2\",\n\t\"cur\",\n\t\"dat\",\n\t\"dcm\",\n\t\"deb\",\n\t\"dex\",\n\t\"djvu\",\n\t\"dll\",\n\t\"dmg\",\n\t\"dng\",\n\t\"doc\",\n\t\"docm\",\n\t\"docx\",\n\t\"dot\",\n\t\"dotm\",\n\t\"dra\",\n\t\"DS_Store\",\n\t\"dsk\",\n\t\"dts\",\n\t\"dtshd\",\n\t\"dvb\",\n\t\"dwg\",\n\t\"dxf\",\n\t\"ecelp4800\",\n\t\"ecelp7470\",\n\t\"ecelp9600\",\n\t\"egg\",\n\t\"eol\",\n\t\"eot\",\n\t\"epub\",\n\t\"exe\",\n\t\"f4v\",\n\t\"fbs\",\n\t\"fh\",\n\t\"fla\",\n\t\"flac\",\n\t\"flatpak\",\n\t\"fli\",\n\t\"flv\",\n\t\"fpx\",\n\t\"fst\",\n\t\"fvt\",\n\t\"g3\",\n\t\"gh\",\n\t\"gif\",\n\t\"graffle\",\n\t\"gz\",\n\t\"gzip\",\n\t\"h261\",\n\t\"h263\",\n\t\"h264\",\n\t\"icns\",\n\t\"ico\",\n\t\"ief\",\n\t\"img\",\n\t\"ipa\",\n\t\"iso\",\n\t\"jar\",\n\t\"jpeg\",\n\t\"jpg\",\n\t\"jpgv\",\n\t\"jpm\",\n\t\"jxr\",\n\t\"key\",\n\t\"ktx\",\n\t\"lha\",\n\t\"lib\",\n\t\"lvp\",\n\t\"lz\",\n\t\"lzh\",\n\t\"lzma\",\n\t\"lzo\",\n\t\"m3u\",\n\t\"m4a\",\n\t\"m4v\",\n\t\"mar\",\n\t\"mdi\",\n\t\"mht\",\n\t\"mid\",\n\t\"midi\",\n\t\"mj2\",\n\t\"mka\",\n\t\"mkv\",\n\t\"mmr\",\n\t\"mng\",\n\t\"mobi\",\n\t\"mov\",\n\t\"movie\",\n\t\"mp3\",\n\t\"mp4\",\n\t\"mp4a\",\n\t\"mpeg\",\n\t\"mpg\",\n\t\"mpga\",\n\t\"mxu\",\n\t\"nef\",\n\t\"npx\",\n\t\"numbers\",\n\t\"nupkg\",\n\t\"o\",\n\t\"odp\",\n\t\"ods\",\n\t\"odt\",\n\t\"oga\",\n\t\"ogg\",\n\t\"ogv\",\n\t\"otf\",\n\t\"ott\",\n\t\"pages\",\n\t\"pbm\",\n\t\"pcx\",\n\t\"pdb\",\n\t\"pdf\",\n\t\"pea\",\n\t\"pgm\",\n\t\"pic\",\n\t\"png\",\n\t\"pnm\",\n\t\"pot\",\n\t\"potm\",\n\t\"potx\",\n\t\"ppa\",\n\t\"ppam\",\n\t\"ppm\",\n\t\"pps\",\n\t\"ppsm\",\n\t\"ppsx\",\n\t\"ppt\",\n\t\"pptm\",\n\t\"pptx\",\n\t\"psd\",\n\t\"pya\",\n\t\"pyc\",\n\t\"pyo\",\n\t\"pyv\",\n\t\"qt\",\n\t\"rar\",\n\t\"ras\",\n\t\"raw\",\n\t\"resources\",\n\t\"rgb\",\n\t\"rip\",\n\t\"rlc\",\n\t\"rmf\",\n\t\"rmvb\",\n\t\"rpm\",\n\t\"rtf\",\n\t\"rz\",\n\t\"s3m\",\n\t\"s7z\",\n\t\"scpt\",\n\t\"sgi\",\n\t\"shar\",\n\t\"snap\",\n\t\"sil\",\n\t\"sketch\",\n\t\"slk\",\n\t\"smv\",\n\t\"snk\",\n\t\"so\",\n\t\"stl\",\n\t\"suo\",\n\t\"sub\",\n\t\"swf\",\n\t\"tar\",\n\t\"tbz\",\n\t\"tbz2\",\n\t\"tga\",\n\t\"tgz\",\n\t\"thmx\",\n\t\"tif\",\n\t\"tiff\",\n\t\"tlz\",\n\t\"ttc\",\n\t\"ttf\",\n\t\"txz\",\n\t\"udf\",\n\t\"uvh\",\n\t\"uvi\",\n\t\"uvm\",\n\t\"uvp\",\n\t\"uvs\",\n\t\"uvu\",\n\t\"viv\",\n\t\"vob\",\n\t\"war\",\n\t\"wav\",\n\t\"wax\",\n\t\"wbmp\",\n\t\"wdp\",\n\t\"weba\",\n\t\"webm\",\n\t\"webp\",\n\t\"whl\",\n\t\"wim\",\n\t\"wm\",\n\t\"wma\",\n\t\"wmv\",\n\t\"wmx\",\n\t\"woff\",\n\t\"woff2\",\n\t\"wrm\",\n\t\"wvx\",\n\t\"xbm\",\n\t\"xif\",\n\t\"xla\",\n\t\"xlam\",\n\t\"xls\",\n\t\"xlsb\",\n\t\"xlsm\",\n\t\"xlsx\",\n\t\"xlt\",\n\t\"xltm\",\n\t\"xltx\",\n\t\"xm\",\n\t\"xmind\",\n\t\"xpi\",\n\t\"xpm\",\n\t\"xwd\",\n\t\"xz\",\n\t\"z\",\n\t\"zip\",\n\t\"zipx\"\n];\n\n(function (module) {\n\tmodule.exports = require$$0;\n} (binaryExtensions$1));\n\nconst path = require$$0$2;\nconst binaryExtensions = binaryExtensions$1.exports;\n\nconst extensions = new Set(binaryExtensions);\n\nvar isBinaryPath$1 = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n\nvar constants = {};\n\n(function (exports) {\n\n\tconst {sep} = require$$0$2;\n\tconst {platform} = process;\n\tconst os = require$$2$1;\n\n\texports.EV_ALL = 'all';\n\texports.EV_READY = 'ready';\n\texports.EV_ADD = 'add';\n\texports.EV_CHANGE = 'change';\n\texports.EV_ADD_DIR = 'addDir';\n\texports.EV_UNLINK = 'unlink';\n\texports.EV_UNLINK_DIR = 'unlinkDir';\n\texports.EV_RAW = 'raw';\n\texports.EV_ERROR = 'error';\n\n\texports.STR_DATA = 'data';\n\texports.STR_END = 'end';\n\texports.STR_CLOSE = 'close';\n\n\texports.FSEVENT_CREATED = 'created';\n\texports.FSEVENT_MODIFIED = 'modified';\n\texports.FSEVENT_DELETED = 'deleted';\n\texports.FSEVENT_MOVED = 'moved';\n\texports.FSEVENT_CLONED = 'cloned';\n\texports.FSEVENT_UNKNOWN = 'unknown';\n\texports.FSEVENT_TYPE_FILE = 'file';\n\texports.FSEVENT_TYPE_DIRECTORY = 'directory';\n\texports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\n\texports.KEY_LISTENERS = 'listeners';\n\texports.KEY_ERR = 'errHandlers';\n\texports.KEY_RAW = 'rawEmitters';\n\texports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\n\texports.DOT_SLASH = `.${sep}`;\n\n\texports.BACK_SLASH_RE = /\\\\/g;\n\texports.DOUBLE_SLASH_RE = /\\/\\//;\n\texports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\n\texports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n\texports.REPLACER_RE = /^\\.[/\\\\]/;\n\n\texports.SLASH = '/';\n\texports.SLASH_SLASH = '//';\n\texports.BRACE_START = '{';\n\texports.BANG = '!';\n\texports.ONE_DOT = '.';\n\texports.TWO_DOTS = '..';\n\texports.STAR = '*';\n\texports.GLOBSTAR = '**';\n\texports.ROOT_GLOBSTAR = '/**/*';\n\texports.SLASH_GLOBSTAR = '/**';\n\texports.DIR_SUFFIX = 'Dir';\n\texports.ANYMATCH_OPTS = {dot: true};\n\texports.STRING_TYPE = 'string';\n\texports.FUNCTION_TYPE = 'function';\n\texports.EMPTY_STR = '';\n\texports.EMPTY_FN = () => {};\n\texports.IDENTITY_FN = val => val;\n\n\texports.isWindows = platform === 'win32';\n\texports.isMacos = platform === 'darwin';\n\texports.isLinux = platform === 'linux';\n\texports.isIBMi = os.type() === 'OS400';\n} (constants));\n\nconst fs$2 = require$$0$1;\nconst sysPath$2 = require$$0$2;\nconst { promisify: promisify$2 } = require$$2;\nconst isBinaryPath = isBinaryPath$1;\nconst {\n  isWindows: isWindows$1,\n  isLinux,\n  EMPTY_FN: EMPTY_FN$2,\n  EMPTY_STR: EMPTY_STR$1,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE: EV_CHANGE$2,\n  EV_ADD: EV_ADD$2,\n  EV_ADD_DIR: EV_ADD_DIR$2,\n  EV_ERROR: EV_ERROR$2,\n  STR_DATA: STR_DATA$1,\n  STR_END: STR_END$2,\n  BRACE_START: BRACE_START$1,\n  STAR\n} = constants;\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify$2(fs$2.open);\nconst stat$2 = promisify$2(fs$2.stat);\nconst lstat$1 = promisify$2(fs$2.lstat);\nconst close = promisify$2(fs$2.close);\nconst fsrealpath = promisify$2(fs$2.realpath);\n\nconst statMethods$1 = { lstat: lstat$1, stat: stat$2 };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath$2.resolve(path, evPath), KEY_LISTENERS, sysPath$2.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs$2.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR$2, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows$1 && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    fs$2.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs$2.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE$2, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs$2.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nclass NodeFsHandler$1 {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path, listener) {\n  const opts = this.fsw.options;\n  const directory = sysPath$2.dirname(path);\n  const basename = sysPath$2.basename(path);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = sysPath$2.resolve(path);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN$2;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = sysPath$2.dirname(file);\n  const basename = sysPath$2.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  const listener = async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat$2(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE$2, file, newStats);\n        }\n        if (isLinux && prevStats.ino !== newStats.ino) {\n          this.fsw._closeFile(path);\n          prevStats = newStats;\n          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n        } else {\n          prevStats = newStats;\n        }\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n      // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE$2, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  };\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, listener);\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;\n    this.fsw._emit(EV_ADD$2, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n\n    let linkPath;\n    try {\n      linkPath = await fsrealpath(path);\n    } catch (e) {\n      this.fsw._emitReady();\n      return true;\n    }\n\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE$2, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD$2, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = sysPath$2.join(directory, EMPTY_STR$1);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA$1, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path = sysPath$2.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path = sysPath$2.join(dir, sysPath$2.relative(dir, path));\n\n      this._addToNodeFs(path, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR$2, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END$2, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath$2.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));\n  const tracked = parentDir.has(sysPath$2.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath$2.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods$1[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path.includes(STAR) && !path.includes(BRACE_START$1);\n    let closer;\n    if (stats.isDirectory()) {\n      const absPath = sysPath$2.resolve(path);\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (absPath !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(absPath, targetPath);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path) : path;\n      if (this.fsw.closed) return;\n      const parent = sysPath$2.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD$2, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(sysPath$2.resolve(path), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path;\n    }\n  }\n}\n\n}\n\nvar nodefsHandler = NodeFsHandler$1;\n\nvar fseventsHandler = {exports: {}};\n\nconst require$$3 = /*@__PURE__*/rollup.getAugmentedNamespace(rollup.fseventsImporter);\n\nconst fs$1 = require$$0$1;\nconst sysPath$1 = require$$0$2;\nconst { promisify: promisify$1 } = require$$2;\n\nlet fsevents;\ntry {\n  fsevents = require$$3.getFsEvents();\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD: EV_ADD$1,\n  EV_CHANGE: EV_CHANGE$1,\n  EV_ADD_DIR: EV_ADD_DIR$1,\n  EV_UNLINK: EV_UNLINK$1,\n  EV_ERROR: EV_ERROR$1,\n  STR_DATA,\n  STR_END: STR_END$1,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE: FUNCTION_TYPE$1,\n  EMPTY_FN: EMPTY_FN$1,\n  IDENTITY_FN\n} = constants;\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat$1 = promisify$1(fs$1.stat);\nconst lstat = promisify$1(fs$1.lstat);\nconst realpath = promisify$1(fs$1.realpath);\n\nconst statMethods = { stat: stat$1, lstat };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;\n\n  const parentPath = sysPath$1.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath$1.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath$1.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path, root) => {\n  let i = 0;\n  while (!path.indexOf(root) && (path = sysPath$1.dirname(path)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n);\n\n/**\n * @mixin\n */\nclass FsEventsHandler$1 {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat$1(path);\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK$1) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD$1) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path = transform(sysPath$1.join(\n      watchPath, sysPath$1.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    const parent = sysPath$1.dirname(path);\n    const item = sysPath$1.basename(path);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE$1) {\n        let stats;\n        try {\n          stats = await stat$1(path);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK$1, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== DOT_SLASH) {\n        aliasedPath = sysPath$1.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));\n  const base = sysPath$1.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);\n  }\n}\n\ninitWatch(realPath, path, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    sysPath$1.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE$1 ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = sysPath$1.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE$1) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path, wh, processPath);\n    }\n  }\n}\n\n}\n\nfseventsHandler.exports = FsEventsHandler$1;\nfseventsHandler.exports.canUse = canUse;\n\nconst { EventEmitter } = require$$0$3;\nconst fs = require$$0$1;\nconst sysPath = require$$0$2;\nconst { promisify } = require$$2;\nconst readdirp = readdirp_1;\nconst anymatch = anymatch$2.exports.default;\nconst globParent = globParent$1;\nconst isGlob = isGlob$2;\nconst braces = braces_1;\nconst normalizePath = normalizePath$2;\n\nconst NodeFsHandler = nodefsHandler;\nconst FsEventsHandler = fseventsHandler.exports;\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos,\n  isIBMi\n} = constants;\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n  if(isIBMi) {\n    opts.usePolling = true;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // You’re frozen when your heart’s not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n  // but never removed from the map in case the path was deleted.\n  // This leads to an incorrect state if the path was recreated:\n  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n  if (this._symlinkPaths.has(fullPath)) {\n    this._symlinkPaths.delete(fullPath);\n  }\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path);\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nchokidar.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nchokidar.watch = watch;\n\nexports.chokidar = chokidar;\n//# sourceMappingURL=index.js.map\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}