{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileConstEnum;\n\nvar _enum = require(\"./enum\");\n\nfunction transpileConstEnum(path, t) {\n  const {\n    name\n  } = path.node.id;\n  const parentIsExport = path.parentPath.isExportNamedDeclaration();\n  let isExported = parentIsExport;\n\n  if (!isExported && t.isProgram(path.parent)) {\n    isExported = path.parent.body.some(stmt => t.isExportNamedDeclaration(stmt) && stmt.exportKind !== \"type\" && !stmt.source && stmt.specifiers.some(spec => t.isExportSpecifier(spec) && spec.exportKind !== \"type\" && spec.local.name === name));\n  }\n\n  const entries = (0, _enum.translateEnumValues)(path, t);\n\n  if (isExported) {\n    const obj = t.objectExpression(entries.map(_ref => {\n      let [name, value] = _ref;\n      return t.objectProperty(t.isValidIdentifier(name) ? t.identifier(name) : t.stringLiteral(name), value);\n    }));\n\n    if (path.scope.hasOwnBinding(name)) {\n      (parentIsExport ? path.parentPath : path).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")), [path.node.id, obj])));\n    } else {\n      path.replaceWith(t.variableDeclaration(\"var\", [t.variableDeclarator(path.node.id, obj)]));\n      path.scope.registerDeclaration(path);\n    }\n\n    return;\n  }\n\n  const entriesMap = new Map(entries);\n  path.scope.path.traverse({\n    Scope(path) {\n      if (path.scope.hasOwnBinding(name)) path.skip();\n    },\n\n    MemberExpression(path) {\n      if (!t.isIdentifier(path.node.object, {\n        name\n      })) return;\n      let key;\n\n      if (path.node.computed) {\n        if (t.isStringLiteral(path.node.property)) {\n          key = path.node.property.value;\n        } else {\n          return;\n        }\n      } else if (t.isIdentifier(path.node.property)) {\n        key = path.node.property.name;\n      } else {\n        return;\n      }\n\n      if (!entriesMap.has(key)) return;\n      path.replaceWith(t.cloneNode(entriesMap.get(key)));\n    }\n\n  });\n  path.remove();\n}","map":{"version":3,"mappings":";;;;;;;AAGA;;AAGe,SAASA,kBAAT,CACbC,IADa,EAEbC,CAFa,EAGb;EACA,MAAM;IAAEC;EAAF,IAAWF,IAAI,CAACG,IAALH,CAAUI,EAA3B;EAEA,MAAMC,cAAc,GAAGL,IAAI,CAACM,UAALN,CAAgBO,wBAAhBP,EAAvB;EACA,IAAIQ,UAAU,GAAGH,cAAjB;;EACA,IAAI,CAACG,UAAD,IAAeP,CAAC,CAACQ,SAAFR,CAAYD,IAAI,CAACU,MAAjBT,CAAnB,EAA6C;IAC3CO,UAAU,GAAGR,IAAI,CAACU,MAALV,CAAYW,IAAZX,CAAiBY,IAAjBZ,CACXa,IAAI,IACFZ,CAAC,CAACM,wBAAFN,CAA2BY,IAA3BZ,KACAY,IAAI,CAACC,UAALD,KAAoB,MADpBZ,IAEA,CAACY,IAAI,CAACE,MAFNd,IAGAY,IAAI,CAACG,UAALH,CAAgBD,IAAhBC,CACEI,IAAI,IACFhB,CAAC,CAACiB,iBAAFjB,CAAoBgB,IAApBhB,KACAgB,IAAI,CAACH,UAALG,KAAoB,MADpBhB,IAEAgB,IAAI,CAACE,KAALF,CAAWf,IAAXe,KAAoBf,IAJxBW,CALSb,CAAbQ;EAYD;;EAED,MAAMY,OAAO,GAAG,+BAAoBpB,IAApB,EAA0BC,CAA1B,CAAhB;;EAEA,IAAIO,UAAJ,EAAgB;IACd,MAAMa,GAAG,GAAGpB,CAAC,CAACqB,gBAAFrB,CACVmB,OAAO,CAACG,GAARH,CAAY;MAAA,IAAC,CAAClB,IAAD,EAAOsB,KAAP,CAAD;MAAA,OACVvB,CAAC,CAACwB,cAAFxB,CACEA,CAAC,CAACyB,iBAAFzB,CAAoBC,IAApBD,IACIA,CAAC,CAAC0B,UAAF1B,CAAaC,IAAbD,CADJA,GAEIA,CAAC,CAAC2B,aAAF3B,CAAgBC,IAAhBD,CAHNA,EAIEuB,KAJFvB,CADU;IAAA,CAAZmB,CADUnB,CAAZ;;IAWA,IAAID,IAAI,CAAC6B,KAAL7B,CAAW8B,aAAX9B,CAAyBE,IAAzBF,CAAJ,EAAoC;MAClC,CAACK,cAAc,GAAGL,IAAI,CAACM,UAAR,GAAqBN,IAApC,EAA0C+B,WAA1C,CACE9B,CAAC,CAAC+B,mBAAF/B,CACEA,CAAC,CAACgC,cAAFhC,CACEA,CAAC,CAACiC,gBAAFjC,CAAmBA,CAAC,CAAC0B,UAAF1B,CAAa,QAAbA,CAAnBA,EAA2CA,CAAC,CAAC0B,UAAF1B,CAAa,QAAbA,CAA3CA,CADFA,EAEE,CAACD,IAAI,CAACG,IAALH,CAAUI,EAAX,EAAeiB,GAAf,CAFFpB,CADFA,CADF;IADF,OASO;MACLD,IAAI,CAAC+B,WAAL/B,CACEC,CAAC,CAACkC,mBAAFlC,CAAsB,KAAtBA,EAA6B,CAACA,CAAC,CAACmC,kBAAFnC,CAAqBD,IAAI,CAACG,IAALH,CAAUI,EAA/BH,EAAmCoB,GAAnCpB,CAAD,CAA7BA,CADFD;MAGAA,IAAI,CAAC6B,KAAL7B,CAAWqC,mBAAXrC,CAA+BA,IAA/BA;IACD;;IAED;EACD;;EAED,MAAMsC,UAAU,GAAG,IAAIC,GAAJ,CAAQnB,OAAR,CAAnB;EAKApB,IAAI,CAAC6B,KAAL7B,CAAWA,IAAXA,CAAgBwC,QAAhBxC,CAAyB;IACvByC,KAAK,CAACzC,IAAD,EAAO;MACV,IAAIA,IAAI,CAAC6B,KAAL7B,CAAW8B,aAAX9B,CAAyBE,IAAzBF,CAAJ,EAAoCA,IAAI,CAAC0C,IAAL1C;IAFf;;IAIvB2C,gBAAgB,CAAC3C,IAAD,EAAO;MACrB,IAAI,CAACC,CAAC,CAAC2C,YAAF3C,CAAeD,IAAI,CAACG,IAALH,CAAU6C,MAAzB5C,EAAiC;QAAEC;MAAF,CAAjCD,CAAL,EAAiD;MAEjD,IAAI6C,GAAJ;;MACA,IAAI9C,IAAI,CAACG,IAALH,CAAU+C,QAAd,EAAwB;QACtB,IAAI9C,CAAC,CAAC+C,eAAF/C,CAAkBD,IAAI,CAACG,IAALH,CAAUiD,QAA5BhD,CAAJ,EAA2C;UACzC6C,GAAG,GAAG9C,IAAI,CAACG,IAALH,CAAUiD,QAAVjD,CAAmBwB,KAAzBsB;QADF,OAEO;UACL;QACD;MALH,OAMO,IAAI7C,CAAC,CAAC2C,YAAF3C,CAAeD,IAAI,CAACG,IAALH,CAAUiD,QAAzBhD,CAAJ,EAAwC;QAC7C6C,GAAG,GAAG9C,IAAI,CAACG,IAALH,CAAUiD,QAAVjD,CAAmBE,IAAzB4C;MADK,OAEA;QACL;MACD;;MACD,IAAI,CAACR,UAAU,CAACY,GAAXZ,CAAeQ,GAAfR,CAAL,EAA0B;MAE1BtC,IAAI,CAAC+B,WAAL/B,CAAiBC,CAAC,CAACkD,SAAFlD,CAAYqC,UAAU,CAACc,GAAXd,CAAeQ,GAAfR,CAAZrC,CAAjBD;IACD;;EAtBsB,CAAzBA;EAyBAA,IAAI,CAACqD,MAALrD;AACD","names":["transpileConstEnum","path","t","name","node","id","parentIsExport","parentPath","isExportNamedDeclaration","isExported","isProgram","parent","body","some","stmt","exportKind","source","specifiers","spec","isExportSpecifier","local","entries","obj","objectExpression","map","value","objectProperty","isValidIdentifier","identifier","stringLiteral","scope","hasOwnBinding","replaceWith","expressionStatement","callExpression","memberExpression","variableDeclaration","variableDeclarator","registerDeclaration","entriesMap","Map","traverse","Scope","skip","MemberExpression","isIdentifier","object","key","computed","isStringLiteral","property","has","cloneNode","get","remove"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-transform-typescript\\src\\const-enum.ts"],"sourcesContent":["import type * as t from \"@babel/types\";\nimport type { NodePath } from \"@babel/traverse\";\n\nimport { translateEnumValues } from \"./enum\";\n\nexport type NodePathConstEnum = NodePath<t.TSEnumDeclaration & { const: true }>;\nexport default function transpileConstEnum(\n  path: NodePathConstEnum,\n  t: typeof import(\"@babel/types\"),\n) {\n  const { name } = path.node.id;\n\n  const parentIsExport = path.parentPath.isExportNamedDeclaration();\n  let isExported = parentIsExport;\n  if (!isExported && t.isProgram(path.parent)) {\n    isExported = path.parent.body.some(\n      stmt =>\n        t.isExportNamedDeclaration(stmt) &&\n        stmt.exportKind !== \"type\" &&\n        !stmt.source &&\n        stmt.specifiers.some(\n          spec =>\n            t.isExportSpecifier(spec) &&\n            spec.exportKind !== \"type\" &&\n            spec.local.name === name,\n        ),\n    );\n  }\n\n  const entries = translateEnumValues(path, t);\n\n  if (isExported) {\n    const obj = t.objectExpression(\n      entries.map(([name, value]) =>\n        t.objectProperty(\n          t.isValidIdentifier(name)\n            ? t.identifier(name)\n            : t.stringLiteral(name),\n          value,\n        ),\n      ),\n    );\n\n    if (path.scope.hasOwnBinding(name)) {\n      (parentIsExport ? path.parentPath : path).replaceWith(\n        t.expressionStatement(\n          t.callExpression(\n            t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\")),\n            [path.node.id, obj],\n          ),\n        ),\n      );\n    } else {\n      path.replaceWith(\n        t.variableDeclaration(\"var\", [t.variableDeclarator(path.node.id, obj)]),\n      );\n      path.scope.registerDeclaration(path);\n    }\n\n    return;\n  }\n\n  const entriesMap = new Map(entries);\n\n  // TODO: After fixing https://github.com/babel/babel/pull/11065, we can\n  // use path.scope.getBinding(name).referencePaths rather than doing\n  // a full traversal.\n  path.scope.path.traverse({\n    Scope(path) {\n      if (path.scope.hasOwnBinding(name)) path.skip();\n    },\n    MemberExpression(path) {\n      if (!t.isIdentifier(path.node.object, { name })) return;\n\n      let key: string;\n      if (path.node.computed) {\n        if (t.isStringLiteral(path.node.property)) {\n          key = path.node.property.value;\n        } else {\n          return;\n        }\n      } else if (t.isIdentifier(path.node.property)) {\n        key = path.node.property.name;\n      } else {\n        return;\n      }\n      if (!entriesMap.has(key)) return;\n\n      path.replaceWith(t.cloneNode(entriesMap.get(key)));\n    },\n  });\n\n  path.remove();\n}\n"]},"metadata":{},"sourceType":"script"}