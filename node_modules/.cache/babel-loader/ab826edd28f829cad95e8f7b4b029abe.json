{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildFieldsInitNodes = buildFieldsInitNodes;\nexports.buildPrivateNamesMap = buildPrivateNamesMap;\nexports.buildPrivateNamesNodes = buildPrivateNamesNodes;\nexports.transformPrivateNamesUsage = transformPrivateNamesUsage;\n\nvar _core = require(\"@babel/core\");\n\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nvar _helperMemberExpressionToFunctions = require(\"@babel/helper-member-expression-to-functions\");\n\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nvar ts = require(\"./typescript\");\n\nfunction buildPrivateNamesMap(props) {\n  const privateNamesMap = new Map();\n\n  for (const prop of props) {\n    if (prop.isPrivate()) {\n      const {\n        name\n      } = prop.node.key.id;\n      const update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {\n        id: prop.scope.generateUidIdentifier(name),\n        static: prop.node.static,\n        method: !prop.isProperty()\n      };\n\n      if (prop.isClassPrivateMethod()) {\n        if (prop.node.kind === \"get\") {\n          update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n        } else if (prop.node.kind === \"set\") {\n          update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n        } else if (prop.node.kind === \"method\") {\n          update.methodId = prop.scope.generateUidIdentifier(name);\n        }\n      }\n\n      privateNamesMap.set(name, update);\n    }\n  }\n\n  return privateNamesMap;\n}\n\nfunction buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties, state) {\n  const initNodes = [];\n\n  for (const [name, value] of privateNamesMap) {\n    const {\n      static: isStatic,\n      method: isMethod,\n      getId,\n      setId\n    } = value;\n    const isAccessor = getId || setId;\n\n    const id = _core.types.cloneNode(value.id);\n\n    let init;\n\n    if (privateFieldsAsProperties) {\n      init = _core.types.callExpression(state.addHelper(\"classPrivateFieldLooseKey\"), [_core.types.stringLiteral(name)]);\n    } else if (!isStatic) {\n      init = _core.types.newExpression(_core.types.identifier(!isMethod || isAccessor ? \"WeakMap\" : \"WeakSet\"), []);\n    }\n\n    if (init) {\n      (0, _helperAnnotateAsPure.default)(init);\n      initNodes.push(_core.template.statement.ast`var ${id} = ${init}`);\n    }\n  }\n\n  return initNodes;\n}\n\nfunction privateNameVisitorFactory(visitor) {\n  const privateNameVisitor = Object.assign({}, visitor, {\n    Class(path) {\n      const {\n        privateNamesMap\n      } = this;\n      const body = path.get(\"body.body\");\n      const visiblePrivateNames = new Map(privateNamesMap);\n      const redeclared = [];\n\n      for (const prop of body) {\n        if (!prop.isPrivate()) continue;\n        const {\n          name\n        } = prop.node.key.id;\n        visiblePrivateNames.delete(name);\n        redeclared.push(name);\n      }\n\n      if (!redeclared.length) {\n        return;\n      }\n\n      path.get(\"body\").traverse(nestedVisitor, Object.assign({}, this, {\n        redeclared\n      }));\n      path.traverse(privateNameVisitor, Object.assign({}, this, {\n        privateNamesMap: visiblePrivateNames\n      }));\n      path.skipKey(\"body\");\n    }\n\n  });\n\n  const nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperEnvironmentVisitor.default]);\n\n  return privateNameVisitor;\n}\n\nconst privateNameVisitor = privateNameVisitorFactory({\n  PrivateName(path, _ref) {\n    let {\n      noDocumentAll\n    } = _ref;\n    const {\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      node,\n      parentPath\n    } = path;\n\n    if (!parentPath.isMemberExpression({\n      property: node\n    }) && !parentPath.isOptionalMemberExpression({\n      property: node\n    })) {\n      return;\n    }\n\n    const {\n      name\n    } = node.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n    this.handle(parentPath, noDocumentAll);\n  }\n\n});\n\nfunction unshadow(name, scope, innerBinding) {\n  while ((_scope = scope) != null && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding)) {\n    var _scope;\n\n    scope.rename(name);\n    scope = scope.parent;\n  }\n}\n\nconst privateInVisitor = privateNameVisitorFactory({\n  BinaryExpression(path) {\n    const {\n      operator,\n      left,\n      right\n    } = path.node;\n    if (operator !== \"in\") return;\n    if (!_core.types.isPrivateName(left)) return;\n    const {\n      privateFieldsAsProperties,\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      name\n    } = left.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n    unshadow(this.classRef.name, path.scope, this.innerBinding);\n\n    if (privateFieldsAsProperties) {\n      const {\n        id\n      } = privateNamesMap.get(name);\n      path.replaceWith(_core.template.expression.ast`\n        Object.prototype.hasOwnProperty.call(${right}, ${_core.types.cloneNode(id)})\n      `);\n      return;\n    }\n\n    const {\n      id,\n      static: isStatic\n    } = privateNamesMap.get(name);\n\n    if (isStatic) {\n      path.replaceWith(_core.template.expression.ast`${right} === ${this.classRef}`);\n      return;\n    }\n\n    path.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${right})`);\n  }\n\n});\nconst privateNameHandlerSpec = {\n  memoise(member, count) {\n    const {\n      scope\n    } = member;\n    const {\n      object\n    } = member.node;\n    const memo = scope.maybeGenerateMemoised(object);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(object, memo, count);\n  },\n\n  receiver(member) {\n    const {\n      object\n    } = member.node;\n\n    if (this.memoiser.has(object)) {\n      return _core.types.cloneNode(this.memoiser.get(object));\n    }\n\n    return _core.types.cloneNode(object);\n  },\n\n  get(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file,\n      innerBinding\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      methodId,\n      getId,\n      setId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodGet\" : \"classStaticPrivateFieldSpecGet\";\n      unshadow(classRef.name, member.scope, innerBinding);\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);\n    }\n\n    if (isMethod) {\n      if (isAccessor) {\n        if (!getId && setId) {\n          if (file.availableHelper(\"writeOnlyError\")) {\n            return _core.types.sequenceExpression([this.receiver(member), _core.types.callExpression(file.addHelper(\"writeOnlyError\"), [_core.types.stringLiteral(`#${name}`)])]);\n          }\n\n          console.warn(`@babel/helpers is outdated, update it to silence this warning.`);\n        }\n\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n      }\n\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodGet\"), [this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n  },\n\n  boundGet(member) {\n    this.memoise(member, 1);\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [this.receiver(member)]);\n  },\n\n  set(member, value) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      setId,\n      getId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodSet\" : \"classStaticPrivateFieldSpecSet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value]);\n    }\n\n    if (isMethod) {\n      if (setId) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n      }\n\n      return _core.types.sequenceExpression([this.receiver(member), value, _core.types.callExpression(file.addHelper(\"readOnlyError\"), [_core.types.stringLiteral(`#${name}`)])]);\n    }\n\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n  },\n\n  destructureSet(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic\n    } = privateNamesMap.get(name);\n\n    if (isStatic) {\n      try {\n        var helper = file.addHelper(\"classStaticPrivateFieldDestructureSet\");\n      } catch (_unused) {\n        throw new Error(\"Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \\n\" + \"please update @babel/helpers to the latest version.\");\n      }\n\n      return _core.types.memberExpression(_core.types.callExpression(helper, [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]), _core.types.identifier(\"value\"));\n    }\n\n    return _core.types.memberExpression(_core.types.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [this.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier(\"value\"));\n  },\n\n  call(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, false);\n  },\n\n  optionalCall(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, true);\n  }\n\n};\nconst privateNameHandlerLoose = {\n  get(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      object\n    } = member.node;\n    const {\n      name\n    } = member.node.property.id;\n    return _core.template.expression`BASE(REF, PROP)[PROP]`({\n      BASE: file.addHelper(\"classPrivateFieldLooseBase\"),\n      REF: _core.types.cloneNode(object),\n      PROP: _core.types.cloneNode(privateNamesMap.get(name).id)\n    });\n  },\n\n  set() {\n    throw new Error(\"private name handler with loose = true don't need set()\");\n  },\n\n  boundGet(member) {\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [_core.types.cloneNode(member.node.object)]);\n  },\n\n  simpleSet(member) {\n    return this.get(member);\n  },\n\n  destructureSet(member) {\n    return this.get(member);\n  },\n\n  call(member, args) {\n    return _core.types.callExpression(this.get(member), args);\n  },\n\n  optionalCall(member, args) {\n    return _core.types.optionalCallExpression(this.get(member), args, true);\n  }\n\n};\n\nfunction transformPrivateNamesUsage(ref, path, privateNamesMap, _ref2, state) {\n  let {\n    privateFieldsAsProperties,\n    noDocumentAll,\n    innerBinding\n  } = _ref2;\n  if (!privateNamesMap.size) return;\n  const body = path.get(\"body\");\n  const handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;\n  (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({\n    privateNamesMap,\n    classRef: ref,\n    file: state\n  }, handler, {\n    noDocumentAll,\n    innerBinding\n  }));\n  body.traverse(privateInVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    privateFieldsAsProperties,\n    innerBinding\n  });\n}\n\nfunction buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    });\n  `;\n}\n\nfunction buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap, state) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  {\n    if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n      return _core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {\n        // configurable is always false for private elements\n        // enumerable is always false for private elements\n        writable: true,\n        value: ${value},\n      })`;\n    }\n  }\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return _core.template.statement.ast`${helper}(\n    ${_core.types.thisExpression()},\n    ${_core.types.cloneNode(id)},\n    {\n      writable: true,\n      value: ${value}\n    },\n  )`;\n}\n\nfunction buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  const isAccessor = getId || setId;\n  if (!prop.isProperty() && (initAdded || !isAccessor)) return;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      var ${_core.types.cloneNode(id)} = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      }\n    `;\n  }\n\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.template.statement.ast`\n    var ${_core.types.cloneNode(id)} = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    };\n  `;\n}\n\nfunction buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    methodId,\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n\n  if (methodId) {\n    return _core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      `;\n  }\n\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n}\n\nfunction buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap, state) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    return buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state);\n  }\n\n  return buildPrivateInstanceMethodInitalization(ref, prop, privateNamesMap, state);\n}\n\nfunction buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId\n  } = privateName;\n  privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n    initAdded: true\n  }));\n  {\n    if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n      return _core.template.statement.ast`\n      ${id}.set(${ref}, {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n    }\n  }\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return _core.template.statement.ast`${helper}(\n    ${_core.types.thisExpression()},\n    ${_core.types.cloneNode(id)},\n    {\n      get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n      set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n    },\n  )`;\n}\n\nfunction buildPrivateInstanceMethodInitalization(ref, prop, privateNamesMap, state) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id\n  } = privateName;\n  {\n    if (!state.availableHelper(\"classPrivateMethodInitSpec\")) {\n      return _core.template.statement.ast`${id}.add(${ref})`;\n    }\n  }\n  const helper = state.addHelper(\"classPrivateMethodInitSpec\");\n  return _core.template.statement.ast`${helper}(\n    ${_core.types.thisExpression()},\n    ${_core.types.cloneNode(id)}\n  )`;\n}\n\nfunction buildPublicFieldInitLoose(ref, prop) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value));\n}\n\nfunction buildPublicFieldInitSpec(ref, prop, state) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return _core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineProperty\"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value]));\n}\n\nfunction buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return _core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      })\n    `;\n  }\n\n  return _core.template.statement.ast`\n    Object.defineProperty(${ref}, ${id}, {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ${methodId.name}\n    });\n  `;\n}\n\nfunction buildPrivateMethodDeclaration(prop, privateNamesMap) {\n  let privateFieldsAsProperties = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic\n  } = privateName;\n  const {\n    params,\n    body,\n    generator,\n    async\n  } = prop.node;\n  const isGetter = getId && !getterDeclared && params.length === 0;\n  const isSetter = setId && !setterDeclared && params.length > 0;\n  let declId = methodId;\n\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      getterDeclared: true\n    }));\n    declId = getId;\n  } else if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      setterDeclared: true\n    }));\n    declId = setId;\n  } else if (isStatic && !privateFieldsAsProperties) {\n    declId = id;\n  }\n\n  return _core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async);\n}\n\nconst thisContextVisitor = _core.traverse.visitors.merge([{\n  ThisExpression(path, state) {\n    state.needsClassRef = true;\n    path.replaceWith(_core.types.cloneNode(state.classRef));\n  },\n\n  MetaProperty(path) {\n    const meta = path.get(\"meta\");\n    const property = path.get(\"property\");\n    const {\n      scope\n    } = path;\n\n    if (meta.isIdentifier({\n      name: \"new\"\n    }) && property.isIdentifier({\n      name: \"target\"\n    })) {\n      path.replaceWith(scope.buildUndefinedNode());\n    }\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nconst innerReferencesVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)) {\n      state.needsClassRef = true;\n      path.node.name = state.classRef.name;\n    }\n  }\n\n};\n\nfunction replaceThisContext(path, ref, getSuperRef, file, isStaticBlock, constantSuper, innerBindingRef) {\n  var _state$classRef;\n\n  const state = {\n    classRef: ref,\n    needsClassRef: false,\n    innerBinding: innerBindingRef\n  };\n  const replacer = new _helperReplaceSupers.default({\n    methodPath: path,\n    constantSuper,\n    file,\n    refToPreserve: ref,\n    getSuperRef,\n\n    getObjectRef() {\n      state.needsClassRef = true;\n      return _core.types.isStaticBlock != null && _core.types.isStaticBlock(path.node) || path.node.static ? ref : _core.types.memberExpression(ref, _core.types.identifier(\"prototype\"));\n    }\n\n  });\n  replacer.replace();\n\n  if (isStaticBlock || path.isProperty()) {\n    path.traverse(thisContextVisitor, state);\n  }\n\n  if (innerBindingRef != null && (_state$classRef = state.classRef) != null && _state$classRef.name && state.classRef.name !== (innerBindingRef == null ? void 0 : innerBindingRef.name)) {\n    path.traverse(innerReferencesVisitor, state);\n  }\n\n  return state.needsClassRef;\n}\n\nfunction isNameOrLength(_ref3) {\n  let {\n    key,\n    computed\n  } = _ref3;\n\n  if (key.type === \"Identifier\") {\n    return !computed && (key.name === \"name\" || key.name === \"length\");\n  }\n\n  if (key.type === \"StringLiteral\") {\n    return key.value === \"name\" || key.value === \"length\";\n  }\n\n  return false;\n}\n\nfunction buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, setPublicClassFields, privateFieldsAsProperties, constantSuper, innerBindingRef) {\n  let needsClassRef = false;\n  let injectSuperRef;\n  const staticNodes = [];\n  const instanceNodes = [];\n  const pureStaticNodes = [];\n  const getSuperRef = _core.types.isIdentifier(superRef) ? () => superRef : () => {\n    var _injectSuperRef;\n\n    (_injectSuperRef = injectSuperRef) != null ? _injectSuperRef : injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef);\n    return injectSuperRef;\n  };\n\n  for (const prop of props) {\n    prop.isClassProperty() && ts.assertFieldTransformed(prop);\n    const isStatic = !(_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node)) && prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n    const isStaticBlock = prop.isStaticBlock == null ? void 0 : prop.isStaticBlock();\n\n    if (isStatic || isMethod && isPrivate || isStaticBlock) {\n      const replaced = replaceThisContext(prop, ref, getSuperRef, state, isStaticBlock, constantSuper, innerBindingRef);\n      needsClassRef = needsClassRef || replaced;\n    }\n\n    switch (true) {\n      case isStaticBlock:\n        {\n          const blockBody = prop.node.body;\n\n          if (blockBody.length === 1 && _core.types.isExpressionStatement(blockBody[0])) {\n            staticNodes.push(blockBody[0]);\n          } else {\n            staticNodes.push(_core.template.statement.ast`(() => { ${blockBody} })()`);\n          }\n\n          break;\n        }\n\n      case isStatic && isPrivate && isField && privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));\n        break;\n\n      case isStatic && isPrivate && isField && !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        break;\n\n      case isStatic && isPublic && isField && setPublicClassFields:\n        if (!isNameOrLength(prop.node)) {\n          needsClassRef = true;\n          staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));\n          break;\n        }\n\n      case isStatic && isPublic && isField && !setPublicClassFields:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));\n        break;\n\n      case isInstance && isPrivate && isField && privateFieldsAsProperties:\n        instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n\n      case isInstance && isPrivate && isField && !privateFieldsAsProperties:\n        instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state));\n        break;\n\n      case isInstance && isPrivate && isMethod && privateFieldsAsProperties:\n        instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n\n      case isInstance && isPrivate && isMethod && !privateFieldsAsProperties:\n        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n\n      case isStatic && isPrivate && isMethod && !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n\n      case isStatic && isPrivate && isMethod && privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n\n      case isInstance && isPublic && isField && setPublicClassFields:\n        instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));\n        break;\n\n      case isInstance && isPublic && isField && !setPublicClassFields:\n        instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));\n        break;\n\n      default:\n        throw new Error(\"Unreachable.\");\n    }\n  }\n\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n    pureStaticNodes: pureStaticNodes.filter(Boolean),\n\n    wrapClass(path) {\n      for (const prop of props) {\n        prop.remove();\n      }\n\n      if (injectSuperRef) {\n        path.scope.push({\n          id: _core.types.cloneNode(injectSuperRef)\n        });\n        path.set(\"superClass\", _core.types.assignmentExpression(\"=\", injectSuperRef, path.node.superClass));\n      }\n\n      if (!needsClassRef) return path;\n\n      if (path.isClassExpression()) {\n        path.scope.push({\n          id: ref\n        });\n        path.replaceWith(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), path.node));\n      } else if (!path.node.id) {\n        path.node.id = ref;\n      }\n\n      return path;\n    }\n\n  };\n}","map":{"version":3,"mappings":"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","names":["buildPrivateNamesMap","props","privateNamesMap","Map","prop","isPrivate","name","node","key","id","update","has","get","scope","generateUidIdentifier","static","method","isProperty","isClassPrivateMethod","kind","getId","setId","methodId","set","buildPrivateNamesNodes","privateFieldsAsProperties","state","initNodes","value","isStatic","isMethod","isAccessor","t","cloneNode","init","callExpression","addHelper","stringLiteral","newExpression","identifier","push","template","statement","ast","privateNameVisitorFactory","visitor","privateNameVisitor","Class","path","body","visiblePrivateNames","redeclared","delete","length","traverse","nestedVisitor","skipKey","visitors","merge","environmentVisitor","PrivateName","noDocumentAll","parentPath","isMemberExpression","property","isOptionalMemberExpression","includes","handle","unshadow","innerBinding","hasBinding","bindingIdentifierEquals","rename","parent","privateInVisitor","BinaryExpression","operator","left","right","isPrivateName","classRef","replaceWith","expression","privateNameHandlerSpec","memoise","member","count","object","memo","maybeGenerateMemoised","memoiser","receiver","file","helperName","availableHelper","sequenceExpression","console","warn","boundGet","memberExpression","destructureSet","helper","Error","call","args","optionalCall","privateNameHandlerLoose","BASE","REF","PROP","simpleSet","optionalCallExpression","transformPrivateNamesUsage","ref","size","handler","buildPrivateFieldInitLoose","buildUndefinedNode","buildPrivateInstanceFieldInitSpec","thisExpression","buildPrivateStaticFieldInitSpec","privateName","initAdded","buildPrivateMethodInitLoose","buildPrivateInstanceMethodInitSpec","buildPrivateAccessorInitialization","buildPrivateInstanceMethodInitalization","buildPublicFieldInitLoose","computed","expressionStatement","assignmentExpression","isLiteral","buildPublicFieldInitSpec","buildPrivateStaticMethodInitLoose","buildPrivateMethodDeclaration","getterDeclared","setterDeclared","params","generator","async","isGetter","isSetter","declId","functionDeclaration","thisContextVisitor","ThisExpression","needsClassRef","MetaProperty","meta","isIdentifier","innerReferencesVisitor","ReferencedIdentifier","replaceThisContext","getSuperRef","isStaticBlock","constantSuper","innerBindingRef","replacer","ReplaceSupers","methodPath","refToPreserve","getObjectRef","replace","_state$classRef","isNameOrLength","type","buildFieldsInitNodes","superRef","setPublicClassFields","injectSuperRef","staticNodes","instanceNodes","pureStaticNodes","generateUidIdentifierBasedOnNode","isClassProperty","ts","assertFieldTransformed","isInstance","isPublic","isField","replaced","blockBody","isExpressionStatement","unshift","filter","Boolean","wrapClass","remove","superClass","isClassExpression"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-create-class-features-plugin\\src\\fields.ts"],"sourcesContent":["import { template, traverse, types as t } from \"@babel/core\";\nimport type { File } from \"@babel/core\";\nimport type { NodePath, Visitor, Scope } from \"@babel/traverse\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport memberExpressionToFunctions from \"@babel/helper-member-expression-to-functions\";\nimport type {\n  Handler,\n  HandlerState,\n} from \"@babel/helper-member-expression-to-functions\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\n\nimport * as ts from \"./typescript\";\n\ninterface PrivateNameMetadata {\n  id: t.Identifier;\n  static: boolean;\n  method: boolean;\n  getId?: t.Identifier;\n  setId?: t.Identifier;\n  methodId?: t.Identifier;\n  initAdded?: boolean;\n  getterDeclared?: boolean;\n  setterDeclared?: boolean;\n}\n\ntype PrivateNamesMap = Map<string, PrivateNameMetadata>;\n\nexport function buildPrivateNamesMap(props: PropPath[]) {\n  const privateNamesMap: PrivateNamesMap = new Map();\n  for (const prop of props) {\n    if (prop.isPrivate()) {\n      const { name } = prop.node.key.id;\n      const update: PrivateNameMetadata = privateNamesMap.has(name)\n        ? privateNamesMap.get(name)\n        : {\n            id: prop.scope.generateUidIdentifier(name),\n            static: prop.node.static,\n            method: !prop.isProperty(),\n          };\n      if (prop.isClassPrivateMethod()) {\n        if (prop.node.kind === \"get\") {\n          update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n        } else if (prop.node.kind === \"set\") {\n          update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n        } else if (prop.node.kind === \"method\") {\n          update.methodId = prop.scope.generateUidIdentifier(name);\n        }\n      }\n      privateNamesMap.set(name, update);\n    }\n  }\n  return privateNamesMap;\n}\n\nexport function buildPrivateNamesNodes(\n  privateNamesMap: PrivateNamesMap,\n  privateFieldsAsProperties: boolean,\n  state: File,\n) {\n  const initNodes: t.Statement[] = [];\n\n  for (const [name, value] of privateNamesMap) {\n    // When the privateFieldsAsProperties assumption is enabled,\n    // both static and instance fields are transpiled using a\n    // secret non-enumerable property. Hence, we also need to generate that\n    // key (using the classPrivateFieldLooseKey helper).\n    // In spec mode, only instance fields need a \"private name\" initializer\n    // because static fields are directly assigned to a variable in the\n    // buildPrivateStaticFieldInitSpec function.\n    const { static: isStatic, method: isMethod, getId, setId } = value;\n    const isAccessor = getId || setId;\n    const id = t.cloneNode(value.id);\n\n    let init: t.Expression;\n\n    if (privateFieldsAsProperties) {\n      init = t.callExpression(state.addHelper(\"classPrivateFieldLooseKey\"), [\n        t.stringLiteral(name),\n      ]);\n    } else if (!isStatic) {\n      init = t.newExpression(\n        t.identifier(!isMethod || isAccessor ? \"WeakMap\" : \"WeakSet\"),\n        [],\n      );\n    }\n\n    if (init) {\n      annotateAsPure(init);\n      initNodes.push(template.statement.ast`var ${id} = ${init}`);\n    }\n  }\n\n  return initNodes;\n}\n\ninterface PrivateNameVisitorState {\n  privateNamesMap: PrivateNamesMap;\n  privateFieldsAsProperties: boolean;\n  redeclared?: string[];\n}\n\n// Traverses the class scope, handling private name references. If an inner\n// class redeclares the same private name, it will hand off traversal to the\n// restricted visitor (which doesn't traverse the inner class's inner scope).\nfunction privateNameVisitorFactory<S>(\n  visitor: Visitor<PrivateNameVisitorState & S>,\n) {\n  const privateNameVisitor: Visitor<PrivateNameVisitorState & S> = {\n    ...visitor,\n\n    Class(path) {\n      const { privateNamesMap } = this;\n      const body = path.get(\"body.body\");\n\n      const visiblePrivateNames = new Map(privateNamesMap);\n      const redeclared = [];\n      for (const prop of body) {\n        if (!prop.isPrivate()) continue;\n        const { name } = prop.node.key.id;\n        visiblePrivateNames.delete(name);\n        redeclared.push(name);\n      }\n\n      // If the class doesn't redeclare any private fields, we can continue with\n      // our overall traversal.\n      if (!redeclared.length) {\n        return;\n      }\n\n      // This class redeclares some private field. We need to process the outer\n      // environment with access to all the outer privates, then we can process\n      // the inner environment with only the still-visible outer privates.\n      path.get(\"body\").traverse(nestedVisitor, {\n        ...this,\n        redeclared,\n      });\n      path.traverse(privateNameVisitor, {\n        ...this,\n        privateNamesMap: visiblePrivateNames,\n      });\n\n      // We'll eventually hit this class node again with the overall Class\n      // Features visitor, which'll process the redeclared privates.\n      path.skipKey(\"body\");\n    },\n  };\n\n  // Traverses the outer portion of a class, without touching the class's inner\n  // scope, for private names.\n  const nestedVisitor = traverse.visitors.merge([\n    {\n      ...visitor,\n    },\n    environmentVisitor,\n  ]);\n\n  return privateNameVisitor;\n}\n\ninterface PrivateNameState {\n  privateNamesMap: PrivateNamesMap;\n  classRef: t.Identifier;\n  file: File;\n  noDocumentAll: boolean;\n  innerBinding?: t.Identifier;\n}\n\nconst privateNameVisitor = privateNameVisitorFactory<\n  HandlerState<PrivateNameState> & PrivateNameState\n>({\n  PrivateName(path, { noDocumentAll }) {\n    const { privateNamesMap, redeclared } = this;\n    const { node, parentPath } = path;\n\n    if (\n      !parentPath.isMemberExpression({ property: node }) &&\n      !parentPath.isOptionalMemberExpression({ property: node })\n    ) {\n      return;\n    }\n    const { name } = node.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n\n    this.handle(parentPath, noDocumentAll);\n  },\n});\n\n// rename all bindings that shadows innerBinding\nfunction unshadow(\n  name: string,\n  scope: Scope,\n  innerBinding: t.Identifier | undefined,\n) {\n  // in some cases, scope.getBinding(name) === undefined\n  // so we check hasBinding to avoid keeping looping\n  // see: https://github.com/babel/babel/pull/13656#discussion_r686030715\n  while (\n    scope?.hasBinding(name) &&\n    !scope.bindingIdentifierEquals(name, innerBinding)\n  ) {\n    scope.rename(name);\n    scope = scope.parent;\n  }\n}\n\nconst privateInVisitor = privateNameVisitorFactory<{\n  classRef: t.Identifier;\n  file: File;\n  innerBinding?: t.Identifier;\n}>({\n  BinaryExpression(path) {\n    const { operator, left, right } = path.node;\n    if (operator !== \"in\") return;\n    if (!t.isPrivateName(left)) return;\n\n    const { privateFieldsAsProperties, privateNamesMap, redeclared } = this;\n\n    const { name } = left.id;\n\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n\n    // if there are any local variable shadowing classRef, unshadow it\n    // see #12960\n    unshadow(this.classRef.name, path.scope, this.innerBinding);\n\n    if (privateFieldsAsProperties) {\n      const { id } = privateNamesMap.get(name);\n      path.replaceWith(template.expression.ast`\n        Object.prototype.hasOwnProperty.call(${right}, ${t.cloneNode(id)})\n      `);\n      return;\n    }\n\n    const { id, static: isStatic } = privateNamesMap.get(name);\n\n    if (isStatic) {\n      path.replaceWith(template.expression.ast`${right} === ${this.classRef}`);\n      return;\n    }\n\n    path.replaceWith(template.expression.ast`${t.cloneNode(id)}.has(${right})`);\n  },\n});\n\ninterface Receiver {\n  receiver(\n    this: HandlerState<PrivateNameState> & PrivateNameState,\n    member: NodePath<t.MemberExpression | t.OptionalMemberExpression>,\n  ): t.Expression;\n}\n\nconst privateNameHandlerSpec: Handler<PrivateNameState & Receiver> & Receiver =\n  {\n    memoise(member, count) {\n      const { scope } = member;\n      const { object } = member.node as { object: t.Expression };\n\n      const memo = scope.maybeGenerateMemoised(object);\n      if (!memo) {\n        return;\n      }\n\n      this.memoiser.set(object, memo, count);\n    },\n\n    receiver(member) {\n      const { object } = member.node as { object: t.Expression };\n\n      if (this.memoiser.has(object)) {\n        return t.cloneNode(this.memoiser.get(object));\n      }\n\n      return t.cloneNode(object);\n    },\n\n    get(member) {\n      const { classRef, privateNamesMap, file, innerBinding } = this;\n      const { name } = (member.node.property as t.PrivateName).id;\n      const {\n        id,\n        static: isStatic,\n        method: isMethod,\n        methodId,\n        getId,\n        setId,\n      } = privateNamesMap.get(name);\n      const isAccessor = getId || setId;\n\n      if (isStatic) {\n        const helperName =\n          isMethod && !isAccessor\n            ? \"classStaticPrivateMethodGet\"\n            : \"classStaticPrivateFieldSpecGet\";\n\n        // if there are any local variable shadowing classRef, unshadow it\n        // see #12960\n        unshadow(classRef.name, member.scope, innerBinding);\n\n        return t.callExpression(file.addHelper(helperName), [\n          this.receiver(member),\n          t.cloneNode(classRef),\n          t.cloneNode(id),\n        ]);\n      }\n\n      if (isMethod) {\n        if (isAccessor) {\n          if (!getId && setId) {\n            if (file.availableHelper(\"writeOnlyError\")) {\n              return t.sequenceExpression([\n                this.receiver(member),\n                t.callExpression(file.addHelper(\"writeOnlyError\"), [\n                  t.stringLiteral(`#${name}`),\n                ]),\n              ]);\n            }\n            console.warn(\n              `@babel/helpers is outdated, update it to silence this warning.`,\n            );\n          }\n          return t.callExpression(file.addHelper(\"classPrivateFieldGet\"), [\n            this.receiver(member),\n            t.cloneNode(id),\n          ]);\n        }\n        return t.callExpression(file.addHelper(\"classPrivateMethodGet\"), [\n          this.receiver(member),\n          t.cloneNode(id),\n          t.cloneNode(methodId),\n        ]);\n      }\n      return t.callExpression(file.addHelper(\"classPrivateFieldGet\"), [\n        this.receiver(member),\n        t.cloneNode(id),\n      ]);\n    },\n\n    boundGet(member) {\n      this.memoise(member, 1);\n\n      return t.callExpression(\n        t.memberExpression(this.get(member), t.identifier(\"bind\")),\n        [this.receiver(member)],\n      );\n    },\n\n    set(member, value) {\n      const { classRef, privateNamesMap, file } = this;\n      const { name } = (member.node.property as t.PrivateName).id;\n      const {\n        id,\n        static: isStatic,\n        method: isMethod,\n        setId,\n        getId,\n      } = privateNamesMap.get(name);\n      const isAccessor = getId || setId;\n\n      if (isStatic) {\n        const helperName =\n          isMethod && !isAccessor\n            ? \"classStaticPrivateMethodSet\"\n            : \"classStaticPrivateFieldSpecSet\";\n\n        return t.callExpression(file.addHelper(helperName), [\n          this.receiver(member),\n          t.cloneNode(classRef),\n          t.cloneNode(id),\n          value,\n        ]);\n      }\n      if (isMethod) {\n        if (setId) {\n          return t.callExpression(file.addHelper(\"classPrivateFieldSet\"), [\n            this.receiver(member),\n            t.cloneNode(id),\n            value,\n          ]);\n        }\n        return t.sequenceExpression([\n          this.receiver(member),\n          value,\n          t.callExpression(file.addHelper(\"readOnlyError\"), [\n            t.stringLiteral(`#${name}`),\n          ]),\n        ]);\n      }\n      return t.callExpression(file.addHelper(\"classPrivateFieldSet\"), [\n        this.receiver(member),\n        t.cloneNode(id),\n        value,\n      ]);\n    },\n\n    destructureSet(member) {\n      const { classRef, privateNamesMap, file } = this;\n      const { name } = (member.node.property as t.PrivateName).id;\n      const { id, static: isStatic } = privateNamesMap.get(name);\n      if (isStatic) {\n        try {\n          // classStaticPrivateFieldDestructureSet was introduced in 7.13.10\n          // eslint-disable-next-line no-var\n          var helper = file.addHelper(\"classStaticPrivateFieldDestructureSet\");\n        } catch {\n          throw new Error(\n            \"Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \\n\" +\n              \"please update @babel/helpers to the latest version.\",\n          );\n        }\n        return t.memberExpression(\n          t.callExpression(helper, [\n            this.receiver(member),\n            t.cloneNode(classRef),\n            t.cloneNode(id),\n          ]),\n          t.identifier(\"value\"),\n        );\n      }\n\n      return t.memberExpression(\n        t.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [\n          this.receiver(member),\n          t.cloneNode(id),\n        ]),\n        t.identifier(\"value\"),\n      );\n    },\n\n    call(member, args: (t.Expression | t.SpreadElement)[]) {\n      // The first access (the get) should do the memo assignment.\n      this.memoise(member, 1);\n\n      return optimiseCall(this.get(member), this.receiver(member), args, false);\n    },\n\n    optionalCall(member, args: (t.Expression | t.SpreadElement)[]) {\n      this.memoise(member, 1);\n\n      return optimiseCall(this.get(member), this.receiver(member), args, true);\n    },\n  };\n\nconst privateNameHandlerLoose: Handler<PrivateNameState> = {\n  get(member) {\n    const { privateNamesMap, file } = this;\n    const { object } = member.node;\n    const { name } = (member.node.property as t.PrivateName).id;\n\n    return template.expression`BASE(REF, PROP)[PROP]`({\n      BASE: file.addHelper(\"classPrivateFieldLooseBase\"),\n      REF: t.cloneNode(object),\n      PROP: t.cloneNode(privateNamesMap.get(name).id),\n    });\n  },\n\n  set() {\n    // noop\n    throw new Error(\"private name handler with loose = true don't need set()\");\n  },\n\n  boundGet(member) {\n    return t.callExpression(\n      t.memberExpression(this.get(member), t.identifier(\"bind\")),\n      [t.cloneNode(member.node.object as t.Expression)],\n    );\n  },\n\n  simpleSet(member) {\n    return this.get(member);\n  },\n\n  destructureSet(member) {\n    return this.get(member);\n  },\n\n  call(member, args) {\n    return t.callExpression(this.get(member), args);\n  },\n\n  optionalCall(member, args) {\n    return t.optionalCallExpression(this.get(member), args, true);\n  },\n};\n\nexport function transformPrivateNamesUsage(\n  ref: t.Identifier,\n  path: NodePath<t.Class>,\n  privateNamesMap: PrivateNamesMap,\n  {\n    privateFieldsAsProperties,\n    noDocumentAll,\n    innerBinding,\n  }: {\n    privateFieldsAsProperties: boolean;\n    noDocumentAll: boolean;\n    innerBinding: t.Identifier;\n  },\n  state: File,\n) {\n  if (!privateNamesMap.size) return;\n\n  const body = path.get(\"body\");\n  const handler = privateFieldsAsProperties\n    ? privateNameHandlerLoose\n    : privateNameHandlerSpec;\n\n  memberExpressionToFunctions<PrivateNameState>(body, privateNameVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    ...handler,\n    noDocumentAll,\n    innerBinding,\n  });\n  body.traverse(privateInVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    privateFieldsAsProperties,\n    innerBinding,\n  });\n}\n\nfunction buildPrivateFieldInitLoose(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateProperty>,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const { id } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  return template.statement.ast`\n    Object.defineProperty(${ref}, ${t.cloneNode(id)}, {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    });\n  `;\n}\n\nfunction buildPrivateInstanceFieldInitSpec(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateProperty>,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const { id } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n      return template.statement.ast`${t.cloneNode(id)}.set(${ref}, {\n        // configurable is always false for private elements\n        // enumerable is always false for private elements\n        writable: true,\n        value: ${value},\n      })`;\n    }\n  }\n\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return template.statement.ast`${helper}(\n    ${t.thisExpression()},\n    ${t.cloneNode(id)},\n    {\n      writable: true,\n      value: ${value}\n    },\n  )`;\n}\n\nfunction buildPrivateStaticFieldInitSpec(\n  prop: NodePath<t.ClassPrivateProperty>,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id, getId, setId, initAdded } = privateName;\n  const isAccessor = getId || setId;\n\n  if (!prop.isProperty() && (initAdded || !isAccessor)) return;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      initAdded: true,\n    });\n\n    return template.statement.ast`\n      var ${t.cloneNode(id)} = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      }\n    `;\n  }\n\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return template.statement.ast`\n    var ${t.cloneNode(id)} = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ${value}\n    };\n  `;\n}\n\nfunction buildPrivateMethodInitLoose(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { methodId, id, getId, setId, initAdded } = privateName;\n  if (initAdded) return;\n\n  if (methodId) {\n    return template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      `;\n  }\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      initAdded: true,\n    });\n\n    return template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n  }\n}\n\nfunction buildPrivateInstanceMethodInitSpec(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { getId, setId, initAdded } = privateName;\n\n  if (initAdded) return;\n\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    return buildPrivateAccessorInitialization(\n      ref,\n      prop,\n      privateNamesMap,\n      state,\n    );\n  }\n\n  return buildPrivateInstanceMethodInitalization(\n    ref,\n    prop,\n    privateNamesMap,\n    state,\n  );\n}\n\nfunction buildPrivateAccessorInitialization(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id, getId, setId } = privateName;\n\n  privateNamesMap.set(prop.node.key.id.name, {\n    ...privateName,\n    initAdded: true,\n  });\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n      return template.statement.ast`\n      ${id}.set(${ref}, {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      });\n    `;\n    }\n  }\n\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return template.statement.ast`${helper}(\n    ${t.thisExpression()},\n    ${t.cloneNode(id)},\n    {\n      get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n      set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n    },\n  )`;\n}\n\nfunction buildPrivateInstanceMethodInitalization(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id } = privateName;\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (!state.availableHelper(\"classPrivateMethodInitSpec\")) {\n      return template.statement.ast`${id}.add(${ref})`;\n    }\n  }\n\n  const helper = state.addHelper(\"classPrivateMethodInitSpec\");\n  return template.statement.ast`${helper}(\n    ${t.thisExpression()},\n    ${t.cloneNode(id)}\n  )`;\n}\n\nfunction buildPublicFieldInitLoose(\n  ref: t.Expression,\n  prop: NodePath<t.ClassProperty>,\n) {\n  const { key, computed } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  return t.expressionStatement(\n    t.assignmentExpression(\n      \"=\",\n      t.memberExpression(ref, key, computed || t.isLiteral(key)),\n      value,\n    ),\n  );\n}\n\nfunction buildPublicFieldInitSpec(\n  ref: t.Expression,\n  prop: NodePath<t.ClassProperty>,\n  state: File,\n) {\n  const { key, computed } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  return t.expressionStatement(\n    t.callExpression(state.addHelper(\"defineProperty\"), [\n      ref,\n      computed || t.isLiteral(key)\n        ? key\n        : t.stringLiteral((key as t.Identifier).name),\n      value,\n    ]),\n  );\n}\n\nfunction buildPrivateStaticMethodInitLoose(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  state: File,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id, methodId, getId, setId, initAdded } = privateName;\n\n  if (initAdded) return;\n\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      initAdded: true,\n    });\n\n    return template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      })\n    `;\n  }\n\n  return template.statement.ast`\n    Object.defineProperty(${ref}, ${id}, {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ${methodId.name}\n    });\n  `;\n}\n\nfunction buildPrivateMethodDeclaration(\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n  privateFieldsAsProperties = false,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic,\n  } = privateName;\n  const { params, body, generator, async } = prop.node;\n  const isGetter = getId && !getterDeclared && params.length === 0;\n  const isSetter = setId && !setterDeclared && params.length > 0;\n\n  let declId = methodId;\n\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      getterDeclared: true,\n    });\n    declId = getId;\n  } else if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      setterDeclared: true,\n    });\n    declId = setId;\n  } else if (isStatic && !privateFieldsAsProperties) {\n    declId = id;\n  }\n\n  return t.functionDeclaration(\n    t.cloneNode(declId),\n    // @ts-expect-error params for ClassMethod has TSParameterProperty\n    params,\n    body,\n    generator,\n    async,\n  );\n}\n\ntype ReplaceThisState = {\n  classRef: t.Identifier;\n  needsClassRef: boolean;\n  innerBinding: t.Identifier | null;\n};\n\nconst thisContextVisitor = traverse.visitors.merge<ReplaceThisState>([\n  {\n    ThisExpression(path, state) {\n      state.needsClassRef = true;\n      path.replaceWith(t.cloneNode(state.classRef));\n    },\n    MetaProperty(path) {\n      const meta = path.get(\"meta\");\n      const property = path.get(\"property\");\n      const { scope } = path;\n      // if there are `new.target` in static field\n      // we should replace it with `undefined`\n      if (\n        meta.isIdentifier({ name: \"new\" }) &&\n        property.isIdentifier({ name: \"target\" })\n      ) {\n        path.replaceWith(scope.buildUndefinedNode());\n      }\n    },\n  },\n  environmentVisitor,\n]);\n\nconst innerReferencesVisitor: Visitor<ReplaceThisState> = {\n  ReferencedIdentifier(path, state) {\n    if (\n      path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)\n    ) {\n      state.needsClassRef = true;\n      path.node.name = state.classRef.name;\n    }\n  },\n};\n\nfunction replaceThisContext(\n  path: PropPath,\n  ref: t.Identifier,\n  getSuperRef: () => t.Identifier,\n  file: File,\n  isStaticBlock: boolean,\n  constantSuper: boolean,\n  innerBindingRef: t.Identifier | null,\n) {\n  const state: ReplaceThisState = {\n    classRef: ref,\n    needsClassRef: false,\n    innerBinding: innerBindingRef,\n  };\n\n  const replacer = new ReplaceSupers({\n    methodPath: path,\n    constantSuper,\n    file,\n    refToPreserve: ref,\n    getSuperRef,\n    getObjectRef() {\n      state.needsClassRef = true;\n      // @ts-expect-error: TS doesn't infer that path.node is not a StaticBlock\n      return t.isStaticBlock?.(path.node) || path.node.static\n        ? ref\n        : t.memberExpression(ref, t.identifier(\"prototype\"));\n    },\n  });\n  replacer.replace();\n  if (isStaticBlock || path.isProperty()) {\n    path.traverse(thisContextVisitor, state);\n  }\n\n  // todo: use innerBinding.referencePaths to avoid full traversal\n  if (\n    innerBindingRef != null &&\n    state.classRef?.name &&\n    state.classRef.name !== innerBindingRef?.name\n  ) {\n    path.traverse(innerReferencesVisitor, state);\n  }\n\n  return state.needsClassRef;\n}\n\nexport type PropNode =\n  | t.ClassProperty\n  | t.ClassPrivateMethod\n  | t.ClassPrivateProperty\n  | t.StaticBlock;\nexport type PropPath = NodePath<PropNode>;\n\nfunction isNameOrLength({ key, computed }: t.ClassProperty) {\n  if (key.type === \"Identifier\") {\n    return !computed && (key.name === \"name\" || key.name === \"length\");\n  }\n  if (key.type === \"StringLiteral\") {\n    return key.value === \"name\" || key.value === \"length\";\n  }\n  return false;\n}\n\nexport function buildFieldsInitNodes(\n  ref: t.Identifier,\n  superRef: t.Expression | undefined,\n  props: PropPath[],\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n  setPublicClassFields: boolean,\n  privateFieldsAsProperties: boolean,\n  constantSuper: boolean,\n  innerBindingRef: t.Identifier,\n) {\n  let needsClassRef = false;\n  let injectSuperRef: t.Identifier;\n  const staticNodes: t.Statement[] = [];\n  const instanceNodes: t.Statement[] = [];\n  // These nodes are pure and can be moved to the closest statement position\n  const pureStaticNodes: t.FunctionDeclaration[] = [];\n\n  const getSuperRef = t.isIdentifier(superRef)\n    ? () => superRef\n    : () => {\n        injectSuperRef ??=\n          props[0].scope.generateUidIdentifierBasedOnNode(superRef);\n        return injectSuperRef;\n      };\n\n  for (const prop of props) {\n    prop.isClassProperty() && ts.assertFieldTransformed(prop);\n\n    // @ts-expect-error: TS doesn't infer that prop.node is not a StaticBlock\n    const isStatic = !t.isStaticBlock?.(prop.node) && prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n    const isStaticBlock = prop.isStaticBlock?.();\n\n    if (isStatic || (isMethod && isPrivate) || isStaticBlock) {\n      const replaced = replaceThisContext(\n        prop,\n        ref,\n        getSuperRef,\n        state,\n        isStaticBlock,\n        constantSuper,\n        innerBindingRef,\n      );\n      needsClassRef = needsClassRef || replaced;\n    }\n\n    // TODO(ts): there are so many `ts-expect-error` inside cases since\n    // ts can not infer type from pre-computed values (or a case test)\n    // even change `isStaticBlock` to `t.isStaticBlock(prop)` will not make prop\n    // a `NodePath<t.StaticBlock>`\n    // this maybe a bug for ts\n    switch (true) {\n      case isStaticBlock: {\n        const blockBody = (prop.node as t.StaticBlock).body;\n        // We special-case the single expression case to avoid the iife, since\n        // it's common.\n        if (blockBody.length === 1 && t.isExpressionStatement(blockBody[0])) {\n          staticNodes.push(blockBody[0] as t.ExpressionStatement);\n        } else {\n          staticNodes.push(template.statement.ast`(() => { ${blockBody} })()`);\n        }\n        break;\n      }\n      case isStatic && isPrivate && isField && privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(\n          // @ts-expect-error checked in switch\n          buildPrivateFieldInitLoose(t.cloneNode(ref), prop, privateNamesMap),\n        );\n        break;\n      case isStatic && isPrivate && isField && !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(\n          // @ts-expect-error checked in switch\n          buildPrivateStaticFieldInitSpec(prop, privateNamesMap),\n        );\n        break;\n      case isStatic && isPublic && isField && setPublicClassFields:\n        // Functions always have non-writable .name and .length properties,\n        // so we must always use [[Define]] for them.\n        // It might still be possible to a computed static fields whose resulting\n        // key is \"name\" or \"length\", but the assumption is telling us that it's\n        // not going to happen.\n        // @ts-expect-error checked in switch\n        if (!isNameOrLength(prop.node)) {\n          needsClassRef = true;\n          // @ts-expect-error checked in switch\n          staticNodes.push(buildPublicFieldInitLoose(t.cloneNode(ref), prop));\n          break;\n        }\n      // falls through\n      case isStatic && isPublic && isField && !setPublicClassFields:\n        needsClassRef = true;\n        staticNodes.push(\n          // @ts-expect-error checked in switch\n          buildPublicFieldInitSpec(t.cloneNode(ref), prop, state),\n        );\n        break;\n      case isInstance && isPrivate && isField && privateFieldsAsProperties:\n        instanceNodes.push(\n          // @ts-expect-error checked in switch\n          buildPrivateFieldInitLoose(t.thisExpression(), prop, privateNamesMap),\n        );\n        break;\n      case isInstance && isPrivate && isField && !privateFieldsAsProperties:\n        instanceNodes.push(\n          buildPrivateInstanceFieldInitSpec(\n            t.thisExpression(),\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            state,\n          ),\n        );\n        break;\n      case isInstance && isPrivate && isMethod && privateFieldsAsProperties:\n        instanceNodes.unshift(\n          buildPrivateMethodInitLoose(\n            t.thisExpression(),\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n          ),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            privateFieldsAsProperties,\n          ),\n        );\n        break;\n      case isInstance && isPrivate && isMethod && !privateFieldsAsProperties:\n        instanceNodes.unshift(\n          buildPrivateInstanceMethodInitSpec(\n            t.thisExpression(),\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            state,\n          ),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            privateFieldsAsProperties,\n          ),\n        );\n        break;\n      case isStatic && isPrivate && isMethod && !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(\n          // @ts-expect-error checked in switch\n          buildPrivateStaticFieldInitSpec(prop, privateNamesMap),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            privateFieldsAsProperties,\n          ),\n        );\n        break;\n      case isStatic && isPrivate && isMethod && privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(\n          buildPrivateStaticMethodInitLoose(\n            t.cloneNode(ref),\n            // @ts-expect-error checked in switch\n            prop,\n            state,\n            privateNamesMap,\n          ),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            privateFieldsAsProperties,\n          ),\n        );\n        break;\n      case isInstance && isPublic && isField && setPublicClassFields:\n        // @ts-expect-error checked in switch\n        instanceNodes.push(buildPublicFieldInitLoose(t.thisExpression(), prop));\n        break;\n      case isInstance && isPublic && isField && !setPublicClassFields:\n        instanceNodes.push(\n          // @ts-expect-error checked in switch\n          buildPublicFieldInitSpec(t.thisExpression(), prop, state),\n        );\n        break;\n      default:\n        throw new Error(\"Unreachable.\");\n    }\n  }\n\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n    pureStaticNodes: pureStaticNodes.filter(Boolean),\n    wrapClass(path: NodePath<t.Class>) {\n      for (const prop of props) {\n        prop.remove();\n      }\n\n      if (injectSuperRef) {\n        path.scope.push({ id: t.cloneNode(injectSuperRef) });\n        path.set(\n          \"superClass\",\n          t.assignmentExpression(\"=\", injectSuperRef, path.node.superClass),\n        );\n      }\n\n      if (!needsClassRef) return path;\n\n      if (path.isClassExpression()) {\n        path.scope.push({ id: ref });\n        path.replaceWith(\n          t.assignmentExpression(\"=\", t.cloneNode(ref), path.node),\n        );\n      } else if (!path.node.id) {\n        // Anonymous class declaration\n        path.node.id = ref;\n      }\n\n      return path;\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"script"}