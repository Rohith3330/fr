{"ast":null,"code":"/* eslint-disable global-require, import/no-dynamic-require */\n// import generate from 'babel-generator';\n// console.log(generate(node).code);\nimport isAnnotatedForRemoval from './isAnnotatedForRemoval';\nimport isStatelessComponent from './isStatelessComponent';\nimport remove from './remove';\n\nfunction isPathReactClass(path, globalOptions) {\n  const node = path.node;\n  const matchers = globalOptions.classNameMatchers;\n\n  if (path.matchesPattern('React.Component') || path.matchesPattern('React.PureComponent')) {\n    return true;\n  }\n\n  if (node && (node.name === 'Component' || node.name === 'PureComponent')) {\n    return true;\n  }\n\n  if (node && matchers && matchers.test(node.name)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isReactClass(superClass, scope, globalOptions) {\n  if (!superClass.node) {\n    return false;\n  }\n\n  let answer = false;\n\n  if (isPathReactClass(superClass, globalOptions)) {\n    answer = true;\n  } else if (superClass.node.name) {\n    // Check for inheritance\n    const className = superClass.node.name;\n    const binding = scope.getBinding(className);\n\n    if (!binding) {\n      answer = false;\n    } else {\n      const bindingSuperClass = binding.path.get('superClass');\n\n      if (isPathReactClass(bindingSuperClass, globalOptions)) {\n        answer = true;\n      }\n    }\n  }\n\n  return answer;\n}\n\nfunction areSetsEqual(set1, set2) {\n  if (set1 === set2) {\n    return true;\n  }\n\n  if (set1.size !== set2.size) {\n    return false;\n  }\n\n  return !Array.from(set1).some(item => !set2.has(item));\n}\n\nfunction memberExpressionRootIdentifier(path) {\n  // Traverse up to the parent before the topmost member expression, and then\n  // traverse back down to find the topmost identifier. It seems like there\n  // might be a better way to do this.\n  const parent = path.findParent(p => !p.isMemberExpression());\n  const {\n    type\n  } = parent.node;\n  let memberExpression;\n\n  if (type === 'ObjectProperty') {\n    // The topmost MemberExpression's parent is an object property, so the\n    // topmost MemberExpression should be the value.\n    memberExpression = parent.get('value');\n  }\n\n  if (!memberExpression || memberExpression.type !== 'MemberExpression') {\n    // This case is currently unhandled by this plugin.\n    return null;\n  } // We have a topmost MemberExpression now, so we want to traverse down the\n  // left half untli we no longer see MemberExpressions. This node will give us\n  // our leftmost identifier.\n\n\n  while (memberExpression.node.object.type === 'MemberExpression') {\n    memberExpression = memberExpression.get('object');\n  }\n\n  return memberExpression.get('object');\n}\n\nexport default function (api) {\n  const {\n    template,\n    types,\n    traverse\n  } = api;\n  const nestedIdentifiers = new Set();\n  const removedPaths = new WeakSet();\n  const collectNestedIdentifiers = {\n    Identifier(path) {\n      if (path.parent.type === 'MemberExpression') {\n        // foo.bar\n        const root = memberExpressionRootIdentifier(path);\n\n        if (root) {\n          nestedIdentifiers.add(root.node.name);\n        }\n\n        return;\n      }\n\n      if (path.parent.type === 'ObjectProperty' && (path.parent.key === path.node || path.parent.shorthand)) {\n        // { foo: 'bar' }\n        // { foo }\n        return;\n      }\n\n      nestedIdentifiers.add(path.node.name);\n    }\n\n  };\n  return {\n    visitor: {\n      Program(programPath, state) {\n        let ignoreFilenames;\n        let classNameMatchers;\n\n        if (state.opts.ignoreFilenames) {\n          ignoreFilenames = new RegExp(state.opts.ignoreFilenames.join('|'), 'i');\n        } else {\n          ignoreFilenames = undefined;\n        }\n\n        if (state.opts.classNameMatchers) {\n          classNameMatchers = new RegExp(state.opts.classNameMatchers.join('|'));\n        } else {\n          classNameMatchers = undefined;\n        }\n\n        const globalOptions = {\n          visitedKey: `transform-react-remove-prop-types${Date.now()}`,\n          unsafeWrapTemplate: template(`\n              if (process.env.NODE_ENV !== \"production\") {\n                NODE;\n              }\n            `, {\n            placeholderPattern: /^NODE$/\n          }),\n          wrapTemplate: function (_ref) {\n            let {\n              LEFT,\n              RIGHT\n            } = _ref;\n            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            const {\n              as = 'assignmentExpression'\n            } = options;\n            const right = template.expression(`\n                process.env.NODE_ENV !== \"production\" ? RIGHT : {}\n              `, {\n              placeholderPattern: /^(LEFT|RIGHT)$/\n            })({\n              RIGHT\n            });\n\n            switch (as) {\n              case 'variableDeclarator':\n                return types.variableDeclarator(LEFT, right);\n\n              case 'assignmentExpression':\n                return types.assignmentExpression('=', LEFT, right);\n\n              default:\n                throw new Error(`unrecognized template type ${as}`);\n            }\n          },\n          mode: state.opts.mode || 'remove',\n          ignoreFilenames,\n          types,\n          removeImport: state.opts.removeImport || false,\n          libraries: (state.opts.additionalLibraries || []).concat('prop-types'),\n          classNameMatchers,\n          createReactClassName: state.opts.createReactClassName || 'createReactClass'\n        };\n\n        if (state.opts.plugins) {\n          const pluginsState = state;\n          const pluginsVisitors = state.opts.plugins.map(pluginOpts => {\n            const pluginName = typeof pluginOpts === 'string' ? pluginOpts : pluginOpts[0];\n\n            if (typeof pluginOpts !== 'string') {\n              pluginsState.opts = { ...pluginsState.opts,\n                ...pluginOpts[1]\n              };\n            }\n\n            let plugin = require(pluginName);\n\n            if (typeof plugin !== 'function') {\n              plugin = plugin.default;\n            }\n\n            return plugin(api).visitor;\n          });\n          traverse(programPath.parent, traverse.visitors.merge(pluginsVisitors), programPath.scope, pluginsState, programPath.parentPath);\n        } // On program start, do an explicit traversal up front for this plugin.\n\n\n        programPath.traverse({\n          ObjectProperty: {\n            exit(path) {\n              const node = path.node;\n\n              if (node.computed || node.key.name !== 'propTypes') {\n                return;\n              }\n\n              const parent = path.findParent(currentNode => {\n                if (currentNode.type !== 'CallExpression') {\n                  return false;\n                }\n\n                return currentNode.get('callee').node.name === globalOptions.createReactClassName || currentNode.get('callee').node.property && currentNode.get('callee').node.property.name === 'createClass';\n              });\n\n              if (parent) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                remove(path, globalOptions, {\n                  type: 'createClass'\n                });\n              }\n            }\n\n          },\n\n          // Here to support stage-1 transform-class-properties.\n          ClassProperty(path) {\n            const {\n              node,\n              scope\n            } = path;\n\n            if (node.key.name === 'propTypes') {\n              const pathClassDeclaration = scope.path;\n\n              if (isReactClass(pathClassDeclaration.get('superClass'), scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                remove(path, globalOptions, {\n                  type: 'class static',\n                  pathClassDeclaration\n                });\n              }\n            }\n          },\n\n          AssignmentExpression(path) {\n            const {\n              node,\n              scope\n            } = path;\n\n            if (node.left.computed || !node.left.property || node.left.property.name !== 'propTypes') {\n              return;\n            }\n\n            const forceRemoval = isAnnotatedForRemoval(path.node.left);\n\n            if (forceRemoval) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              remove(path, globalOptions, {\n                type: 'assign'\n              });\n              return;\n            }\n\n            const className = node.left.object.name;\n            const binding = scope.getBinding(className);\n\n            if (!binding) {\n              return;\n            }\n\n            if (binding.path.isClassDeclaration()) {\n              const superClass = binding.path.get('superClass');\n\n              if (isReactClass(superClass, scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers);\n                removedPaths.add(path);\n                remove(path, globalOptions, {\n                  type: 'assign'\n                });\n              }\n            } else if (isStatelessComponent(binding.path)) {\n              path.traverse(collectNestedIdentifiers);\n              removedPaths.add(path);\n              remove(path, globalOptions, {\n                type: 'assign'\n              });\n            }\n          }\n\n        });\n        let skippedIdentifiers = 0;\n        const removeNewlyUnusedIdentifiers = {\n          VariableDeclarator(path) {\n            // Only consider the top level scope.\n            if (path.scope.block.type !== 'Program') {\n              return;\n            }\n\n            if (['ObjectPattern', 'ArrayPattern'].includes(path.node.id.type)) {\n              // Object or Array destructuring, so we will want to capture all\n              // the names created by the destructuring. This currently doesn't\n              // work, but would be good to improve. All of the names for\n              // ObjectPattern can be collected like:\n              //\n              //   path.node.id.properties.map(prop => prop.value.name);\n              return;\n            }\n\n            const {\n              name\n            } = path.node.id;\n\n            if (!nestedIdentifiers.has(name)) {\n              return;\n            }\n\n            const {\n              referencePaths\n            } = path.scope.getBinding(name); // Count the number of referencePaths that are not in the\n            // removedPaths Set. We need to do this in order to support the wrap\n            // option, which doesn't actually remove the references.\n\n            const hasRemainingReferencePaths = referencePaths.some(referencePath => {\n              const found = referencePath.find(path2 => removedPaths.has(path2));\n              return !found;\n            });\n\n            if (hasRemainingReferencePaths) {\n              // There are still references to this identifier, so we need to\n              // skip over it for now.\n              skippedIdentifiers += 1;\n              return;\n            }\n\n            removedPaths.add(path);\n            nestedIdentifiers.delete(name);\n            path.get('init').traverse(collectNestedIdentifiers);\n            remove(path, globalOptions, {\n              type: 'declarator'\n            });\n          }\n\n        };\n        let lastNestedIdentifiers = new Set();\n\n        while (!areSetsEqual(nestedIdentifiers, lastNestedIdentifiers) && nestedIdentifiers.size > 0 && skippedIdentifiers < nestedIdentifiers.size) {\n          lastNestedIdentifiers = new Set(nestedIdentifiers);\n          skippedIdentifiers = 0;\n          programPath.scope.crawl();\n          programPath.traverse(removeNewlyUnusedIdentifiers);\n        }\n\n        if (globalOptions.removeImport) {\n          if (globalOptions.mode === 'remove') {\n            programPath.scope.crawl();\n            programPath.traverse({\n              ImportDeclaration(path) {\n                const {\n                  source,\n                  specifiers\n                } = path.node;\n                const found = globalOptions.libraries.some(library => {\n                  if (library instanceof RegExp) {\n                    return library.test(source.value);\n                  }\n\n                  return source.value === library;\n                });\n\n                if (!found) {\n                  return;\n                }\n\n                const haveUsedSpecifiers = specifiers.some(specifier => {\n                  const importedIdentifierName = specifier.local.name;\n                  const {\n                    referencePaths\n                  } = path.scope.getBinding(importedIdentifierName);\n                  return referencePaths.length > 0;\n                });\n\n                if (!haveUsedSpecifiers) {\n                  path.remove();\n                }\n              }\n\n            });\n          } else {\n            throw new Error('transform-react-remove-prop-type: removeImport = true and mode != \"remove\" can not be used at the same time.');\n          }\n        }\n      }\n\n    }\n  };\n}","map":{"version":3,"names":["isAnnotatedForRemoval","isStatelessComponent","remove","isPathReactClass","path","globalOptions","node","matchers","classNameMatchers","matchesPattern","name","test","isReactClass","superClass","scope","answer","className","binding","getBinding","bindingSuperClass","get","areSetsEqual","set1","set2","size","Array","from","some","item","has","memberExpressionRootIdentifier","parent","findParent","p","isMemberExpression","type","memberExpression","object","api","template","types","traverse","nestedIdentifiers","Set","removedPaths","WeakSet","collectNestedIdentifiers","Identifier","root","add","key","shorthand","visitor","Program","programPath","state","ignoreFilenames","opts","RegExp","join","undefined","visitedKey","Date","now","unsafeWrapTemplate","placeholderPattern","wrapTemplate","LEFT","RIGHT","options","as","right","expression","variableDeclarator","assignmentExpression","Error","mode","removeImport","libraries","additionalLibraries","concat","createReactClassName","plugins","pluginsState","pluginsVisitors","map","pluginOpts","pluginName","plugin","require","default","visitors","merge","parentPath","ObjectProperty","exit","computed","currentNode","property","ClassProperty","pathClassDeclaration","AssignmentExpression","left","forceRemoval","isClassDeclaration","skippedIdentifiers","removeNewlyUnusedIdentifiers","VariableDeclarator","block","includes","id","referencePaths","hasRemainingReferencePaths","referencePath","found","find","path2","delete","lastNestedIdentifiers","crawl","ImportDeclaration","source","specifiers","library","value","haveUsedSpecifiers","specifier","importedIdentifierName","local","length"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/babel-plugin-transform-react-remove-prop-types/src/index.js"],"sourcesContent":["/* eslint-disable global-require, import/no-dynamic-require */\n\n// import generate from 'babel-generator';\n// console.log(generate(node).code);\nimport isAnnotatedForRemoval from './isAnnotatedForRemoval'\nimport isStatelessComponent from './isStatelessComponent'\nimport remove from './remove'\n\nfunction isPathReactClass(path, globalOptions) {\n  const node = path.node\n  const matchers = globalOptions.classNameMatchers\n\n  if (path.matchesPattern('React.Component') || path.matchesPattern('React.PureComponent')) {\n    return true\n  }\n\n  if (node && (node.name === 'Component' || node.name === 'PureComponent')) {\n    return true\n  }\n\n  if (node && matchers && matchers.test(node.name)) {\n    return true\n  }\n\n  return false\n}\n\nfunction isReactClass(superClass, scope, globalOptions) {\n  if (!superClass.node) {\n    return false\n  }\n\n  let answer = false\n\n  if (isPathReactClass(superClass, globalOptions)) {\n    answer = true\n  } else if (superClass.node.name) {\n    // Check for inheritance\n    const className = superClass.node.name\n    const binding = scope.getBinding(className)\n    if (!binding) {\n      answer = false\n    } else {\n      const bindingSuperClass = binding.path.get('superClass')\n\n      if (isPathReactClass(bindingSuperClass, globalOptions)) {\n        answer = true\n      }\n    }\n  }\n\n  return answer\n}\n\nfunction areSetsEqual(set1, set2) {\n  if (set1 === set2) {\n    return true\n  }\n\n  if (set1.size !== set2.size) {\n    return false\n  }\n\n  return !Array.from(set1).some(item => !set2.has(item))\n}\n\nfunction memberExpressionRootIdentifier(path) {\n  // Traverse up to the parent before the topmost member expression, and then\n  // traverse back down to find the topmost identifier. It seems like there\n  // might be a better way to do this.\n  const parent = path.findParent(p => !p.isMemberExpression())\n  const { type } = parent.node\n\n  let memberExpression\n  if (type === 'ObjectProperty') {\n    // The topmost MemberExpression's parent is an object property, so the\n    // topmost MemberExpression should be the value.\n    memberExpression = parent.get('value')\n  }\n\n  if (!memberExpression || memberExpression.type !== 'MemberExpression') {\n    // This case is currently unhandled by this plugin.\n    return null\n  }\n\n  // We have a topmost MemberExpression now, so we want to traverse down the\n  // left half untli we no longer see MemberExpressions. This node will give us\n  // our leftmost identifier.\n  while (memberExpression.node.object.type === 'MemberExpression') {\n    memberExpression = memberExpression.get('object')\n  }\n\n  return memberExpression.get('object')\n}\n\nexport default function(api) {\n  const { template, types, traverse } = api\n\n  const nestedIdentifiers = new Set()\n  const removedPaths = new WeakSet()\n  const collectNestedIdentifiers = {\n    Identifier(path) {\n      if (path.parent.type === 'MemberExpression') {\n        // foo.bar\n\n        const root = memberExpressionRootIdentifier(path)\n        if (root) {\n          nestedIdentifiers.add(root.node.name)\n        }\n\n        return\n      }\n\n      if (\n        path.parent.type === 'ObjectProperty' &&\n        (path.parent.key === path.node || path.parent.shorthand)\n      ) {\n        // { foo: 'bar' }\n        // { foo }\n        return\n      }\n\n      nestedIdentifiers.add(path.node.name)\n    },\n  }\n\n  return {\n    visitor: {\n      Program(programPath, state) {\n        let ignoreFilenames\n        let classNameMatchers\n\n        if (state.opts.ignoreFilenames) {\n          ignoreFilenames = new RegExp(state.opts.ignoreFilenames.join('|'), 'i')\n        } else {\n          ignoreFilenames = undefined\n        }\n\n        if (state.opts.classNameMatchers) {\n          classNameMatchers = new RegExp(state.opts.classNameMatchers.join('|'))\n        } else {\n          classNameMatchers = undefined\n        }\n\n        const globalOptions = {\n          visitedKey: `transform-react-remove-prop-types${Date.now()}`,\n          unsafeWrapTemplate: template(\n            `\n              if (process.env.NODE_ENV !== \"production\") {\n                NODE;\n              }\n            `,\n            { placeholderPattern: /^NODE$/ }\n          ),\n          wrapTemplate: ({ LEFT, RIGHT }, options = {}) => {\n            const { as = 'assignmentExpression' } = options\n            const right = template.expression(\n              `\n                process.env.NODE_ENV !== \"production\" ? RIGHT : {}\n              `,\n              { placeholderPattern: /^(LEFT|RIGHT)$/ }\n            )({ RIGHT })\n            switch (as) {\n              case 'variableDeclarator':\n                return types.variableDeclarator(LEFT, right)\n              case 'assignmentExpression':\n                return types.assignmentExpression('=', LEFT, right)\n              default:\n                throw new Error(`unrecognized template type ${as}`)\n            }\n          },\n          mode: state.opts.mode || 'remove',\n          ignoreFilenames,\n          types,\n          removeImport: state.opts.removeImport || false,\n          libraries: (state.opts.additionalLibraries || []).concat('prop-types'),\n          classNameMatchers,\n          createReactClassName: state.opts.createReactClassName || 'createReactClass',\n        }\n\n        if (state.opts.plugins) {\n          const pluginsState = state\n          const pluginsVisitors = state.opts.plugins.map(pluginOpts => {\n            const pluginName = typeof pluginOpts === 'string' ? pluginOpts : pluginOpts[0]\n\n            if (typeof pluginOpts !== 'string') {\n              pluginsState.opts = {\n                ...pluginsState.opts,\n                ...pluginOpts[1],\n              }\n            }\n\n            let plugin = require(pluginName)\n            if (typeof plugin !== 'function') {\n              plugin = plugin.default\n            }\n\n            return plugin(api).visitor\n          })\n\n          traverse(\n            programPath.parent,\n            traverse.visitors.merge(pluginsVisitors),\n            programPath.scope,\n            pluginsState,\n            programPath.parentPath\n          )\n        }\n\n        // On program start, do an explicit traversal up front for this plugin.\n        programPath.traverse({\n          ObjectProperty: {\n            exit(path) {\n              const node = path.node\n\n              if (node.computed || node.key.name !== 'propTypes') {\n                return\n              }\n\n              const parent = path.findParent(currentNode => {\n                if (currentNode.type !== 'CallExpression') {\n                  return false\n                }\n\n                return (\n                  currentNode.get('callee').node.name === globalOptions.createReactClassName ||\n                  (currentNode.get('callee').node.property &&\n                    currentNode.get('callee').node.property.name === 'createClass')\n                )\n              })\n\n              if (parent) {\n                path.traverse(collectNestedIdentifiers)\n                removedPaths.add(path)\n                remove(path, globalOptions, {\n                  type: 'createClass',\n                })\n              }\n            },\n          },\n\n          // Here to support stage-1 transform-class-properties.\n          ClassProperty(path) {\n            const { node, scope } = path\n\n            if (node.key.name === 'propTypes') {\n              const pathClassDeclaration = scope.path\n\n              if (isReactClass(pathClassDeclaration.get('superClass'), scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers)\n                removedPaths.add(path)\n                remove(path, globalOptions, {\n                  type: 'class static',\n                  pathClassDeclaration,\n                })\n              }\n            }\n          },\n\n          AssignmentExpression(path) {\n            const { node, scope } = path\n\n            if (\n              node.left.computed ||\n              !node.left.property ||\n              node.left.property.name !== 'propTypes'\n            ) {\n              return\n            }\n\n            const forceRemoval = isAnnotatedForRemoval(path.node.left)\n\n            if (forceRemoval) {\n              path.traverse(collectNestedIdentifiers)\n              removedPaths.add(path)\n              remove(path, globalOptions, { type: 'assign' })\n              return\n            }\n\n            const className = node.left.object.name\n            const binding = scope.getBinding(className)\n\n            if (!binding) {\n              return\n            }\n\n            if (binding.path.isClassDeclaration()) {\n              const superClass = binding.path.get('superClass')\n\n              if (isReactClass(superClass, scope, globalOptions)) {\n                path.traverse(collectNestedIdentifiers)\n                removedPaths.add(path)\n                remove(path, globalOptions, { type: 'assign' })\n              }\n            } else if (isStatelessComponent(binding.path)) {\n              path.traverse(collectNestedIdentifiers)\n              removedPaths.add(path)\n              remove(path, globalOptions, { type: 'assign' })\n            }\n          },\n        })\n\n        let skippedIdentifiers = 0\n        const removeNewlyUnusedIdentifiers = {\n          VariableDeclarator(path) {\n            // Only consider the top level scope.\n            if (path.scope.block.type !== 'Program') {\n              return\n            }\n\n            if (['ObjectPattern', 'ArrayPattern'].includes(path.node.id.type)) {\n              // Object or Array destructuring, so we will want to capture all\n              // the names created by the destructuring. This currently doesn't\n              // work, but would be good to improve. All of the names for\n              // ObjectPattern can be collected like:\n              //\n              //   path.node.id.properties.map(prop => prop.value.name);\n              return\n            }\n            const { name } = path.node.id\n\n            if (!nestedIdentifiers.has(name)) {\n              return\n            }\n\n            const { referencePaths } = path.scope.getBinding(name)\n\n            // Count the number of referencePaths that are not in the\n            // removedPaths Set. We need to do this in order to support the wrap\n            // option, which doesn't actually remove the references.\n            const hasRemainingReferencePaths = referencePaths.some(referencePath => {\n              const found = referencePath.find(path2 => removedPaths.has(path2))\n              return !found\n            })\n\n            if (hasRemainingReferencePaths) {\n              // There are still references to this identifier, so we need to\n              // skip over it for now.\n              skippedIdentifiers += 1\n              return\n            }\n\n            removedPaths.add(path)\n            nestedIdentifiers.delete(name)\n            path.get('init').traverse(collectNestedIdentifiers)\n            remove(path, globalOptions, { type: 'declarator' })\n          },\n        }\n\n        let lastNestedIdentifiers = new Set()\n        while (\n          !areSetsEqual(nestedIdentifiers, lastNestedIdentifiers) &&\n          nestedIdentifiers.size > 0 &&\n          skippedIdentifiers < nestedIdentifiers.size\n        ) {\n          lastNestedIdentifiers = new Set(nestedIdentifiers)\n          skippedIdentifiers = 0\n          programPath.scope.crawl()\n          programPath.traverse(removeNewlyUnusedIdentifiers)\n        }\n\n        if (globalOptions.removeImport) {\n          if (globalOptions.mode === 'remove') {\n            programPath.scope.crawl()\n\n            programPath.traverse({\n              ImportDeclaration(path) {\n                const { source, specifiers } = path.node\n\n                const found = globalOptions.libraries.some(library => {\n                  if (library instanceof RegExp) {\n                    return library.test(source.value)\n                  }\n\n                  return source.value === library\n                })\n\n                if (!found) {\n                  return\n                }\n\n                const haveUsedSpecifiers = specifiers.some(specifier => {\n                  const importedIdentifierName = specifier.local.name\n                  const { referencePaths } = path.scope.getBinding(importedIdentifierName)\n                  return referencePaths.length > 0\n                })\n\n                if (!haveUsedSpecifiers) {\n                  path.remove()\n                }\n              },\n            })\n          } else {\n            throw new Error(\n              'transform-react-remove-prop-type: removeImport = true and mode != \"remove\" can not be used at the same time.'\n            )\n          }\n        }\n      },\n    },\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}