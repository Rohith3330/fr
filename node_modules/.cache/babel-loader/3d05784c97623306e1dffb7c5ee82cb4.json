{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'adjacent-overload-signatures',\n  meta: {\n    type: 'suggestion',\n    docs: {\n      description: 'Require that member overloads be consecutive',\n      recommended: 'error'\n    },\n    schema: [],\n    messages: {\n      adjacentSignature: 'All {{name}} signatures should be adjacent.'\n    }\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\n     * Gets the name and attribute of the member being processed.\n     * @param member the member being processed.\n     * @returns the name and attribute of the member or null if it's a member not relevant to the rule.\n     */\n\n    function getMemberMethod(member) {\n      var _a, _b;\n\n      if (!member) {\n        return null;\n      }\n\n      const isStatic = 'static' in member && !!member.static;\n\n      switch (member.type) {\n        case utils_1.AST_NODE_TYPES.ExportDefaultDeclaration:\n        case utils_1.AST_NODE_TYPES.ExportNamedDeclaration:\n          {\n            // export statements (e.g. export { a };)\n            // have no declarations, so ignore them\n            if (!member.declaration) {\n              return null;\n            }\n\n            return getMemberMethod(member.declaration);\n          }\n\n        case utils_1.AST_NODE_TYPES.TSDeclareFunction:\n        case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n          {\n            const name = (_b = (_a = member.id) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : null;\n\n            if (name === null) {\n              return null;\n            }\n\n            return {\n              name,\n              static: isStatic,\n              callSignature: false,\n              type: util.MemberNameType.Normal\n            };\n          }\n\n        case utils_1.AST_NODE_TYPES.TSMethodSignature:\n          return Object.assign(Object.assign({}, util.getNameFromMember(member, sourceCode)), {\n            static: isStatic,\n            callSignature: false\n          });\n\n        case utils_1.AST_NODE_TYPES.TSCallSignatureDeclaration:\n          return {\n            name: 'call',\n            static: isStatic,\n            callSignature: true,\n            type: util.MemberNameType.Normal\n          };\n\n        case utils_1.AST_NODE_TYPES.TSConstructSignatureDeclaration:\n          return {\n            name: 'new',\n            static: isStatic,\n            callSignature: false,\n            type: util.MemberNameType.Normal\n          };\n\n        case utils_1.AST_NODE_TYPES.MethodDefinition:\n          return Object.assign(Object.assign({}, util.getNameFromMember(member, sourceCode)), {\n            static: isStatic,\n            callSignature: false\n          });\n      }\n\n      return null;\n    }\n\n    function isSameMethod(method1, method2) {\n      return !!method2 && method1.name === method2.name && method1.static === method2.static && method1.callSignature === method2.callSignature && method1.type === method2.type;\n    }\n\n    function getMembers(node) {\n      switch (node.type) {\n        case utils_1.AST_NODE_TYPES.ClassBody:\n        case utils_1.AST_NODE_TYPES.Program:\n        case utils_1.AST_NODE_TYPES.TSModuleBlock:\n        case utils_1.AST_NODE_TYPES.TSInterfaceBody:\n          return node.body;\n\n        case utils_1.AST_NODE_TYPES.TSTypeLiteral:\n          return node.members;\n      }\n    }\n    /**\n     * Check the body for overload methods.\n     * @param {ASTNode} node the body to be inspected.\n     */\n\n\n    function checkBodyForOverloadMethods(node) {\n      const members = getMembers(node);\n\n      if (members) {\n        let lastMethod = null;\n        const seenMethods = [];\n        members.forEach(member => {\n          const method = getMemberMethod(member);\n\n          if (method === null) {\n            lastMethod = null;\n            return;\n          }\n\n          const index = seenMethods.findIndex(seenMethod => isSameMethod(method, seenMethod));\n\n          if (index > -1 && !isSameMethod(method, lastMethod)) {\n            context.report({\n              node: member,\n              messageId: 'adjacentSignature',\n              data: {\n                name: `${method.static ? 'static ' : ''}${method.name}`\n              }\n            });\n          } else if (index === -1) {\n            seenMethods.push(method);\n          }\n\n          lastMethod = method;\n        });\n      }\n    }\n\n    return {\n      ClassBody: checkBodyForOverloadMethods,\n      Program: checkBodyForOverloadMethods,\n      TSModuleBlock: checkBodyForOverloadMethods,\n      TSTypeLiteral: checkBodyForOverloadMethods,\n      TSInterfaceBody: checkBodyForOverloadMethods\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","schema","messages","adjacentSignature","defaultOptions","create","context","sourceCode","getSourceCode","getMemberMethod","member","isStatic","static","utils_1","ExportDefaultDeclaration","ExportNamedDeclaration","declaration","TSDeclareFunction","FunctionDeclaration","id","_a","_b","callSignature","MemberNameType","Normal","TSMethodSignature","getNameFromMember","TSCallSignatureDeclaration","TSConstructSignatureDeclaration","MethodDefinition","isSameMethod","method1","method2","getMembers","node","ClassBody","Program","TSModuleBlock","TSInterfaceBody","body","TSTypeLiteral","members","checkBodyForOverloadMethods","lastMethod","seenMethods","forEach","method","index","findIndex","seenMethod","report","messageId","data","push"],"sources":["../../src/rules/adjacent-overload-signatures.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}