{"ast":null,"code":"/**\n * @fileoverview The factory of `ConfigArray` objects.\n *\n * This class provides methods to create `ConfigArray` instance.\n *\n * - `create(configData, options)`\n *     Create a `ConfigArray` instance from a config data. This is to handle CLI\n *     options except `--config`.\n * - `loadFile(filePath, options)`\n *     Create a `ConfigArray` instance from a config file. This is to handle\n *     `--config` option. If the file was not found, throws the following error:\n *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.\n *      - If the filename was `package.json`, an IO error or an\n *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.\n *      - Otherwise, an IO error such as `ENOENT`.\n * - `loadInDirectory(directoryPath, options)`\n *     Create a `ConfigArray` instance from a config file which is on a given\n *     directory. This tries to load `.eslintrc.*` or `package.json`. If not\n *     found, returns an empty `ConfigArray`.\n * - `loadESLintIgnore(filePath)`\n *     Create a `ConfigArray` instance from a config file that is `.eslintignore`\n *     format. This is to handle `--ignore-path` option.\n * - `loadDefaultESLintIgnore()`\n *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in\n *     the current working directory.\n *\n * `ConfigArrayFactory` class has the responsibility that loads configuration\n * files, including loading `extends`, `parser`, and `plugins`. The created\n * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.\n *\n * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class\n * handles cascading and hierarchy.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\nimport debugOrig from \"debug\";\nimport fs from \"fs\";\nimport importFresh from \"import-fresh\";\nimport { createRequire } from \"module\";\nimport path from \"path\";\nimport stripComments from \"strip-json-comments\";\nimport { ConfigArray, ConfigDependency, IgnorePattern, OverrideTester } from \"./config-array/index.js\";\nimport ConfigValidator from \"./shared/config-validator.js\";\nimport * as naming from \"./shared/naming.js\";\nimport * as ModuleResolver from \"./shared/relative-module-resolver.js\";\n\nconst require = createRequire(import.meta.url);\n\nconst debug = debugOrig(\"eslintrc:config-array-factory\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst configFilenames = [\".eslintrc.js\", \".eslintrc.cjs\", \".eslintrc.yaml\", \".eslintrc.yml\", \".eslintrc.json\", \".eslintrc\", \"package.json\"]; // Define types for VSCode IntelliSense.\n\n/** @typedef {import(\"./shared/types\").ConfigData} ConfigData */\n\n/** @typedef {import(\"./shared/types\").OverrideConfigData} OverrideConfigData */\n\n/** @typedef {import(\"./shared/types\").Parser} Parser */\n\n/** @typedef {import(\"./shared/types\").Plugin} Plugin */\n\n/** @typedef {import(\"./shared/types\").Rule} Rule */\n\n/** @typedef {import(\"./config-array/config-dependency\").DependentParser} DependentParser */\n\n/** @typedef {import(\"./config-array/config-dependency\").DependentPlugin} DependentPlugin */\n\n/** @typedef {ConfigArray[0]} ConfigArrayElement */\n\n/**\n * @typedef {Object} ConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {string} [cwd] The path to the current working directory.\n * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryInternalSlots\n * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cwd The path to the current working directory.\n * @property {string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {string} pluginBasePath The base path to resolve plugins.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */\n\nconst internalSlotsMap = new WeakMap();\n/** @type {WeakMap<object, Plugin>} */\n\nconst normalizedPlugins = new WeakMap();\n/**\n * Check if a given string is a file path.\n * @param {string} nameOrPath A module name or file path.\n * @returns {boolean} `true` if the `nameOrPath` is a file path.\n */\n\nfunction isFilePath(nameOrPath) {\n  return /^\\.{1,2}[/\\\\]/u.test(nameOrPath) || path.isAbsolute(nameOrPath);\n}\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents, with the BOM removed.\n * @private\n */\n\n\nfunction readFile(filePath) {\n  return fs.readFileSync(filePath, \"utf8\").replace(/^\\ufeff/u, \"\");\n}\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadYAMLConfigFile(filePath) {\n  debug(`Loading YAML config file: ${filePath}`); // lazy load YAML to improve performance when not used\n\n  const yaml = require(\"js-yaml\");\n\n  try {\n    // empty YAML file can be null, so always use\n    return yaml.load(readFile(filePath)) || {};\n  } catch (e) {\n    debug(`Error reading YAML file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadJSONConfigFile(filePath) {\n  debug(`Loading JSON config file: ${filePath}`);\n\n  try {\n    return JSON.parse(stripComments(readFile(filePath)));\n  } catch (e) {\n    debug(`Error reading JSON file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    e.messageTemplate = \"failed-to-read-json\";\n    e.messageData = {\n      path: filePath,\n      message: e.message\n    };\n    throw e;\n  }\n}\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadLegacyConfigFile(filePath) {\n  debug(`Loading legacy config file: ${filePath}`); // lazy load YAML to improve performance when not used\n\n  const yaml = require(\"js-yaml\");\n\n  try {\n    return yaml.load(stripComments(readFile(filePath))) ||\n    /* istanbul ignore next */\n    {};\n  } catch (e) {\n    debug(\"Error reading YAML file: %s\\n%o\", filePath, e);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadJSConfigFile(filePath) {\n  debug(`Loading JS config file: ${filePath}`);\n\n  try {\n    return importFresh(filePath);\n  } catch (e) {\n    debug(`Error reading JavaScript file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\n\n\nfunction loadPackageJSONConfigFile(filePath) {\n  debug(`Loading package.json config file: ${filePath}`);\n\n  try {\n    const packageData = loadJSONConfigFile(filePath);\n\n    if (!Object.hasOwnProperty.call(packageData, \"eslintConfig\")) {\n      throw Object.assign(new Error(\"package.json file doesn't have 'eslintConfig' field.\"), {\n        code: \"ESLINT_CONFIG_FIELD_NOT_FOUND\"\n      });\n    }\n\n    return packageData.eslintConfig;\n  } catch (e) {\n    debug(`Error reading package.json file: ${filePath}`);\n    e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Loads a `.eslintignore` from a file.\n * @param {string} filePath The filename to load.\n * @returns {string[]} The ignore patterns from the file.\n * @private\n */\n\n\nfunction loadESLintIgnoreFile(filePath) {\n  debug(`Loading .eslintignore file: ${filePath}`);\n\n  try {\n    return readFile(filePath).split(/\\r?\\n/gu).filter(line => line.trim() !== \"\" && !line.startsWith(\"#\"));\n  } catch (e) {\n    debug(`Error reading .eslintignore file: ${filePath}`);\n    e.message = `Cannot read .eslintignore file: ${filePath}\\nError: ${e.message}`;\n    throw e;\n  }\n}\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @param {string} importerName The name of the config that imported the missing config\n * @param {string} messageTemplate The text template to source error strings from.\n * @returns {Error} The error object to throw\n * @private\n */\n\n\nfunction configInvalidError(configName, importerName, messageTemplate) {\n  return Object.assign(new Error(`Failed to load config \"${configName}\" to extend from.`), {\n    messageTemplate,\n    messageData: {\n      configName,\n      importerName\n    }\n  });\n}\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {string} filePath The path to the configuration.\n * @returns {ConfigData|null} The configuration information.\n * @private\n */\n\n\nfunction loadConfigFile(filePath) {\n  switch (path.extname(filePath)) {\n    case \".js\":\n    case \".cjs\":\n      return loadJSConfigFile(filePath);\n\n    case \".json\":\n      if (path.basename(filePath) === \"package.json\") {\n        return loadPackageJSONConfigFile(filePath);\n      }\n\n      return loadJSONConfigFile(filePath);\n\n    case \".yaml\":\n    case \".yml\":\n      return loadYAMLConfigFile(filePath);\n\n    default:\n      return loadLegacyConfigFile(filePath);\n  }\n}\n/**\n * Write debug log.\n * @param {string} request The requested module name.\n * @param {string} relativeTo The file path to resolve the request relative to.\n * @param {string} filePath The resolved file path.\n * @returns {void}\n */\n\n\nfunction writeDebugLogForLoading(request, relativeTo, filePath) {\n  /* istanbul ignore next */\n  if (debug.enabled) {\n    let nameAndVersion = null;\n\n    try {\n      const packageJsonPath = ModuleResolver.resolve(`${request}/package.json`, relativeTo);\n\n      const {\n        version = \"unknown\"\n      } = require(packageJsonPath);\n\n      nameAndVersion = `${request}@${version}`;\n    } catch (error) {\n      debug(\"package.json was not found:\", error.message);\n      nameAndVersion = request;\n    }\n\n    debug(\"Loaded: %s (%s)\", nameAndVersion, filePath);\n  }\n}\n/**\n * Create a new context with default values.\n * @param {ConfigArrayFactoryInternalSlots} slots The internal slots.\n * @param {\"config\" | \"ignore\" | \"implicit-processor\" | undefined} providedType The type of the current configuration. Default is `\"config\"`.\n * @param {string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`.\n * @param {string | undefined} providedFilePath The path to the current configuration. Default is empty string.\n * @param {string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`.\n * @returns {ConfigArrayFactoryLoadingContext} The created context.\n */\n\n\nfunction createContext(_ref, providedType, providedName, providedFilePath, providedMatchBasePath) {\n  let {\n    cwd,\n    resolvePluginsRelativeTo\n  } = _ref;\n  const filePath = providedFilePath ? path.resolve(cwd, providedFilePath) : \"\";\n  const matchBasePath = providedMatchBasePath && path.resolve(cwd, providedMatchBasePath) || filePath && path.dirname(filePath) || cwd;\n  const name = providedName || filePath && path.relative(cwd, filePath) || \"\";\n  const pluginBasePath = resolvePluginsRelativeTo || filePath && path.dirname(filePath) || cwd;\n  const type = providedType || \"config\";\n  return {\n    filePath,\n    matchBasePath,\n    name,\n    pluginBasePath,\n    type\n  };\n}\n/**\n * Normalize a given plugin.\n * - Ensure the object to have four properties: configs, environments, processors, and rules.\n * - Ensure the object to not have other properties.\n * @param {Plugin} plugin The plugin to normalize.\n * @returns {Plugin} The normalized plugin.\n */\n\n\nfunction normalizePlugin(plugin) {\n  // first check the cache\n  let normalizedPlugin = normalizedPlugins.get(plugin);\n\n  if (normalizedPlugin) {\n    return normalizedPlugin;\n  }\n\n  normalizedPlugin = {\n    configs: plugin.configs || {},\n    environments: plugin.environments || {},\n    processors: plugin.processors || {},\n    rules: plugin.rules || {}\n  }; // save the reference for later\n\n  normalizedPlugins.set(plugin, normalizedPlugin);\n  return normalizedPlugin;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The factory of `ConfigArray` objects.\n */\n\n\nclass ConfigArrayFactory {\n  /**\n   * Initialize this instance.\n   * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.\n   */\n  constructor() {\n    let {\n      additionalPluginPool = new Map(),\n      cwd = process.cwd(),\n      resolvePluginsRelativeTo,\n      builtInRules,\n      resolver = ModuleResolver,\n      eslintAllPath,\n      getEslintAllConfig,\n      eslintRecommendedPath,\n      getEslintRecommendedConfig\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    internalSlotsMap.set(this, {\n      additionalPluginPool,\n      cwd,\n      resolvePluginsRelativeTo: resolvePluginsRelativeTo && path.resolve(cwd, resolvePluginsRelativeTo),\n      builtInRules,\n      resolver,\n      eslintAllPath,\n      getEslintAllConfig,\n      eslintRecommendedPath,\n      getEslintRecommendedConfig\n    });\n  }\n  /**\n   * Create `ConfigArray` instance from a config data.\n   * @param {ConfigData|null} configData The config data to create.\n   * @param {Object} [options] The options.\n   * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n   * @param {string} [options.filePath] The path to this config data.\n   * @param {string} [options.name] The config name.\n   * @returns {ConfigArray} Loaded config.\n   */\n\n\n  create(configData) {\n    let {\n      basePath,\n      filePath,\n      name\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!configData) {\n      return new ConfigArray();\n    }\n\n    const slots = internalSlotsMap.get(this);\n    const ctx = createContext(slots, \"config\", name, filePath, basePath);\n\n    const elements = this._normalizeConfigData(configData, ctx);\n\n    return new ConfigArray(...elements);\n  }\n  /**\n   * Load a config file.\n   * @param {string} filePath The path to a config file.\n   * @param {Object} [options] The options.\n   * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n   * @param {string} [options.name] The config name.\n   * @returns {ConfigArray} Loaded config.\n   */\n\n\n  loadFile(filePath) {\n    let {\n      basePath,\n      name\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const slots = internalSlotsMap.get(this);\n    const ctx = createContext(slots, \"config\", name, filePath, basePath);\n    return new ConfigArray(...this._loadConfigData(ctx));\n  }\n  /**\n   * Load the config file on a given directory if exists.\n   * @param {string} directoryPath The path to a directory.\n   * @param {Object} [options] The options.\n   * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n   * @param {string} [options.name] The config name.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n\n\n  loadInDirectory(directoryPath) {\n    let {\n      basePath,\n      name\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const slots = internalSlotsMap.get(this);\n\n    for (const filename of configFilenames) {\n      const ctx = createContext(slots, \"config\", name, path.join(directoryPath, filename), basePath);\n\n      if (fs.existsSync(ctx.filePath) && fs.statSync(ctx.filePath).isFile()) {\n        let configData;\n\n        try {\n          configData = loadConfigFile(ctx.filePath);\n        } catch (error) {\n          if (!error || error.code !== \"ESLINT_CONFIG_FIELD_NOT_FOUND\") {\n            throw error;\n          }\n        }\n\n        if (configData) {\n          debug(`Config file found: ${ctx.filePath}`);\n          return new ConfigArray(...this._normalizeConfigData(configData, ctx));\n        }\n      }\n    }\n\n    debug(`Config file not found on ${directoryPath}`);\n    return new ConfigArray();\n  }\n  /**\n   * Check if a config file on a given directory exists or not.\n   * @param {string} directoryPath The path to a directory.\n   * @returns {string | null} The path to the found config file. If not found then null.\n   */\n\n\n  static getPathToConfigFileInDirectory(directoryPath) {\n    for (const filename of configFilenames) {\n      const filePath = path.join(directoryPath, filename);\n\n      if (fs.existsSync(filePath)) {\n        if (filename === \"package.json\") {\n          try {\n            loadPackageJSONConfigFile(filePath);\n            return filePath;\n          } catch {\n            /* ignore */\n          }\n        } else {\n          return filePath;\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Load `.eslintignore` file.\n   * @param {string} filePath The path to a `.eslintignore` file to load.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n\n\n  loadESLintIgnore(filePath) {\n    const slots = internalSlotsMap.get(this);\n    const ctx = createContext(slots, \"ignore\", void 0, filePath, slots.cwd);\n    const ignorePatterns = loadESLintIgnoreFile(ctx.filePath);\n    return new ConfigArray(...this._normalizeESLintIgnoreData(ignorePatterns, ctx));\n  }\n  /**\n   * Load `.eslintignore` file in the current working directory.\n   * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n   */\n\n\n  loadDefaultESLintIgnore() {\n    const slots = internalSlotsMap.get(this);\n    const eslintIgnorePath = path.resolve(slots.cwd, \".eslintignore\");\n    const packageJsonPath = path.resolve(slots.cwd, \"package.json\");\n\n    if (fs.existsSync(eslintIgnorePath)) {\n      return this.loadESLintIgnore(eslintIgnorePath);\n    }\n\n    if (fs.existsSync(packageJsonPath)) {\n      const data = loadJSONConfigFile(packageJsonPath);\n\n      if (Object.hasOwnProperty.call(data, \"eslintIgnore\")) {\n        if (!Array.isArray(data.eslintIgnore)) {\n          throw new Error(\"Package.json eslintIgnore property requires an array of paths\");\n        }\n\n        const ctx = createContext(slots, \"ignore\", \"eslintIgnore in package.json\", packageJsonPath, slots.cwd);\n        return new ConfigArray(...this._normalizeESLintIgnoreData(data.eslintIgnore, ctx));\n      }\n    }\n\n    return new ConfigArray();\n  }\n  /**\n   * Load a given config file.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} Loaded config.\n   * @private\n   */\n\n\n  _loadConfigData(ctx) {\n    return this._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);\n  }\n  /**\n   * Normalize a given `.eslintignore` data to config array elements.\n   * @param {string[]} ignorePatterns The patterns to ignore files.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  *_normalizeESLintIgnoreData(ignorePatterns, ctx) {\n    const elements = this._normalizeObjectConfigData({\n      ignorePatterns\n    }, ctx); // Set `ignorePattern.loose` flag for backward compatibility.\n\n\n    for (const element of elements) {\n      if (element.ignorePattern) {\n        element.ignorePattern.loose = true;\n      }\n\n      yield element;\n    }\n  }\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData} configData The config data to normalize.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _normalizeConfigData(configData, ctx) {\n    const validator = new ConfigValidator();\n    validator.validateConfigSchema(configData, ctx.name || ctx.filePath);\n    return this._normalizeObjectConfigData(configData, ctx);\n  }\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData|OverrideConfigData} configData The config data to normalize.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  *_normalizeObjectConfigData(configData, ctx) {\n    const {\n      files,\n      excludedFiles,\n      ...configBody\n    } = configData;\n    const criteria = OverrideTester.create(files, excludedFiles, ctx.matchBasePath);\n\n    const elements = this._normalizeObjectConfigDataBody(configBody, ctx); // Apply the criteria to every element.\n\n\n    for (const element of elements) {\n      /*\n       * Merge the criteria.\n       * This is for the `overrides` entries that came from the\n       * configurations of `overrides[].extends`.\n       */\n      element.criteria = OverrideTester.and(criteria, element.criteria);\n      /*\n       * Remove `root` property to ignore `root` settings which came from\n       * `extends` in `overrides`.\n       */\n\n      if (element.criteria) {\n        element.root = void 0;\n      }\n\n      yield element;\n    }\n  }\n  /**\n   * Normalize a given config to an array.\n   * @param {ConfigData} configData The config data to normalize.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  *_normalizeObjectConfigDataBody(_ref2, ctx) {\n    let {\n      env,\n      extends: extend,\n      globals,\n      ignorePatterns,\n      noInlineConfig,\n      parser: parserName,\n      parserOptions,\n      plugins: pluginList,\n      processor,\n      reportUnusedDisableDirectives,\n      root,\n      rules,\n      settings,\n      overrides: overrideList = []\n    } = _ref2;\n    const extendList = Array.isArray(extend) ? extend : [extend];\n    const ignorePattern = ignorePatterns && new IgnorePattern(Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns], ctx.matchBasePath); // Flatten `extends`.\n\n    for (const extendName of extendList.filter(Boolean)) {\n      yield* this._loadExtends(extendName, ctx);\n    } // Load parser & plugins.\n\n\n    const parser = parserName && this._loadParser(parserName, ctx);\n\n    const plugins = pluginList && this._loadPlugins(pluginList, ctx); // Yield pseudo config data for file extension processors.\n\n\n    if (plugins) {\n      yield* this._takeFileExtensionProcessors(plugins, ctx);\n    } // Yield the config data except `extends` and `overrides`.\n\n\n    yield {\n      // Debug information.\n      type: ctx.type,\n      name: ctx.name,\n      filePath: ctx.filePath,\n      // Config data.\n      criteria: null,\n      env,\n      globals,\n      ignorePattern,\n      noInlineConfig,\n      parser,\n      parserOptions,\n      plugins,\n      processor,\n      reportUnusedDisableDirectives,\n      root,\n      rules,\n      settings\n    }; // Flatten `overries`.\n\n    for (let i = 0; i < overrideList.length; ++i) {\n      yield* this._normalizeObjectConfigData(overrideList[i], { ...ctx,\n        name: `${ctx.name}#overrides[${i}]`\n      });\n    }\n  }\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _loadExtends(extendName, ctx) {\n    debug(\"Loading {extends:%j} relative to %s\", extendName, ctx.filePath);\n\n    try {\n      if (extendName.startsWith(\"eslint:\")) {\n        return this._loadExtendedBuiltInConfig(extendName, ctx);\n      }\n\n      if (extendName.startsWith(\"plugin:\")) {\n        return this._loadExtendedPluginConfig(extendName, ctx);\n      }\n\n      return this._loadExtendedShareableConfig(extendName, ctx);\n    } catch (error) {\n      error.message += `\\nReferenced from: ${ctx.filePath || ctx.name}`;\n      throw error;\n    }\n  }\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _loadExtendedBuiltInConfig(extendName, ctx) {\n    const {\n      eslintAllPath,\n      getEslintAllConfig,\n      eslintRecommendedPath,\n      getEslintRecommendedConfig\n    } = internalSlotsMap.get(this);\n\n    if (extendName === \"eslint:recommended\") {\n      const name = `${ctx.name} » ${extendName}`;\n\n      if (getEslintRecommendedConfig) {\n        if (typeof getEslintRecommendedConfig !== \"function\") {\n          throw new Error(`getEslintRecommendedConfig must be a function instead of '${getEslintRecommendedConfig}'`);\n        }\n\n        return this._normalizeConfigData(getEslintRecommendedConfig(), { ...ctx,\n          name,\n          filePath: \"\"\n        });\n      }\n\n      return this._loadConfigData({ ...ctx,\n        name,\n        filePath: eslintRecommendedPath\n      });\n    }\n\n    if (extendName === \"eslint:all\") {\n      const name = `${ctx.name} » ${extendName}`;\n\n      if (getEslintAllConfig) {\n        if (typeof getEslintAllConfig !== \"function\") {\n          throw new Error(`getEslintAllConfig must be a function instead of '${getEslintAllConfig}'`);\n        }\n\n        return this._normalizeConfigData(getEslintAllConfig(), { ...ctx,\n          name,\n          filePath: \"\"\n        });\n      }\n\n      return this._loadConfigData({ ...ctx,\n        name,\n        filePath: eslintAllPath\n      });\n    }\n\n    throw configInvalidError(extendName, ctx.name, \"extend-config-missing\");\n  }\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _loadExtendedPluginConfig(extendName, ctx) {\n    const slashIndex = extendName.lastIndexOf(\"/\");\n\n    if (slashIndex === -1) {\n      throw configInvalidError(extendName, ctx.filePath, \"plugin-invalid\");\n    }\n\n    const pluginName = extendName.slice(\"plugin:\".length, slashIndex);\n    const configName = extendName.slice(slashIndex + 1);\n\n    if (isFilePath(pluginName)) {\n      throw new Error(\"'extends' cannot use a file path for plugins.\");\n    }\n\n    const plugin = this._loadPlugin(pluginName, ctx);\n\n    const configData = plugin.definition && plugin.definition.configs[configName];\n\n    if (configData) {\n      return this._normalizeConfigData(configData, { ...ctx,\n        filePath: plugin.filePath || ctx.filePath,\n        name: `${ctx.name} » plugin:${plugin.id}/${configName}`\n      });\n    }\n\n    throw plugin.error || configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n  }\n  /**\n   * Load configs of an element in `extends`.\n   * @param {string} extendName The name of a base config.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n   * @private\n   */\n\n\n  _loadExtendedShareableConfig(extendName, ctx) {\n    const {\n      cwd,\n      resolver\n    } = internalSlotsMap.get(this);\n    const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n    let request;\n\n    if (isFilePath(extendName)) {\n      request = extendName;\n    } else if (extendName.startsWith(\".\")) {\n      request = `./${extendName}`; // For backward compatibility. A ton of tests depended on this behavior.\n    } else {\n      request = naming.normalizePackageName(extendName, \"eslint-config\");\n    }\n\n    let filePath;\n\n    try {\n      filePath = resolver.resolve(request, relativeTo);\n    } catch (error) {\n      /* istanbul ignore else */\n      if (error && error.code === \"MODULE_NOT_FOUND\") {\n        throw configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n      }\n\n      throw error;\n    }\n\n    writeDebugLogForLoading(request, relativeTo, filePath);\n    return this._loadConfigData({ ...ctx,\n      filePath,\n      name: `${ctx.name} » ${request}`\n    });\n  }\n  /**\n   * Load given plugins.\n   * @param {string[]} names The plugin names to load.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {Record<string,DependentPlugin>} The loaded parser.\n   * @private\n   */\n\n\n  _loadPlugins(names, ctx) {\n    return names.reduce((map, name) => {\n      if (isFilePath(name)) {\n        throw new Error(\"Plugins array cannot includes file paths.\");\n      }\n\n      const plugin = this._loadPlugin(name, ctx);\n\n      map[plugin.id] = plugin;\n      return map;\n    }, {});\n  }\n  /**\n   * Load a given parser.\n   * @param {string} nameOrPath The package name or the path to a parser file.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {DependentParser} The loaded parser.\n   */\n\n\n  _loadParser(nameOrPath, ctx) {\n    debug(\"Loading parser %j from %s\", nameOrPath, ctx.filePath);\n    const {\n      cwd,\n      resolver\n    } = internalSlotsMap.get(this);\n    const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n\n    try {\n      const filePath = resolver.resolve(nameOrPath, relativeTo);\n      writeDebugLogForLoading(nameOrPath, relativeTo, filePath);\n      return new ConfigDependency({\n        definition: require(filePath),\n        filePath,\n        id: nameOrPath,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    } catch (error) {\n      // If the parser name is \"espree\", load the espree of ESLint.\n      if (nameOrPath === \"espree\") {\n        debug(\"Fallback espree.\");\n        return new ConfigDependency({\n          definition: require(\"espree\"),\n          filePath: require.resolve(\"espree\"),\n          id: nameOrPath,\n          importerName: ctx.name,\n          importerPath: ctx.filePath\n        });\n      }\n\n      debug(\"Failed to load parser '%s' declared in '%s'.\", nameOrPath, ctx.name);\n      error.message = `Failed to load parser '${nameOrPath}' declared in '${ctx.name}': ${error.message}`;\n      return new ConfigDependency({\n        error,\n        id: nameOrPath,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    }\n  }\n  /**\n   * Load a given plugin.\n   * @param {string} name The plugin name to load.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {DependentPlugin} The loaded plugin.\n   * @private\n   */\n\n\n  _loadPlugin(name, ctx) {\n    debug(\"Loading plugin %j from %s\", name, ctx.filePath);\n    const {\n      additionalPluginPool,\n      resolver\n    } = internalSlotsMap.get(this);\n    const request = naming.normalizePackageName(name, \"eslint-plugin\");\n    const id = naming.getShorthandName(request, \"eslint-plugin\");\n    const relativeTo = path.join(ctx.pluginBasePath, \"__placeholder__.js\");\n\n    if (name.match(/\\s+/u)) {\n      const error = Object.assign(new Error(`Whitespace found in plugin name '${name}'`), {\n        messageTemplate: \"whitespace-found\",\n        messageData: {\n          pluginName: request\n        }\n      });\n      return new ConfigDependency({\n        error,\n        id,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    } // Check for additional pool.\n\n\n    const plugin = additionalPluginPool.get(request) || additionalPluginPool.get(id);\n\n    if (plugin) {\n      return new ConfigDependency({\n        definition: normalizePlugin(plugin),\n        filePath: \"\",\n        // It's unknown where the plugin came from.\n        id,\n        importerName: ctx.name,\n        importerPath: ctx.filePath\n      });\n    }\n\n    let filePath;\n    let error;\n\n    try {\n      filePath = resolver.resolve(request, relativeTo);\n    } catch (resolveError) {\n      error = resolveError;\n      /* istanbul ignore else */\n\n      if (error && error.code === \"MODULE_NOT_FOUND\") {\n        error.messageTemplate = \"plugin-missing\";\n        error.messageData = {\n          pluginName: request,\n          resolvePluginsRelativeTo: ctx.pluginBasePath,\n          importerName: ctx.name\n        };\n      }\n    }\n\n    if (filePath) {\n      try {\n        writeDebugLogForLoading(request, relativeTo, filePath);\n        const startTime = Date.now();\n\n        const pluginDefinition = require(filePath);\n\n        debug(`Plugin ${filePath} loaded in: ${Date.now() - startTime}ms`);\n        return new ConfigDependency({\n          definition: normalizePlugin(pluginDefinition),\n          filePath,\n          id,\n          importerName: ctx.name,\n          importerPath: ctx.filePath\n        });\n      } catch (loadError) {\n        error = loadError;\n      }\n    }\n\n    debug(\"Failed to load plugin '%s' declared in '%s'.\", name, ctx.name);\n    error.message = `Failed to load plugin '${name}' declared in '${ctx.name}': ${error.message}`;\n    return new ConfigDependency({\n      error,\n      id,\n      importerName: ctx.name,\n      importerPath: ctx.filePath\n    });\n  }\n  /**\n   * Take file expression processors as config array elements.\n   * @param {Record<string,DependentPlugin>} plugins The plugin definitions.\n   * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n   * @returns {IterableIterator<ConfigArrayElement>} The config array elements of file expression processors.\n   * @private\n   */\n\n\n  *_takeFileExtensionProcessors(plugins, ctx) {\n    for (const pluginId of Object.keys(plugins)) {\n      const processors = plugins[pluginId] && plugins[pluginId].definition && plugins[pluginId].definition.processors;\n\n      if (!processors) {\n        continue;\n      }\n\n      for (const processorId of Object.keys(processors)) {\n        if (processorId.startsWith(\".\")) {\n          yield* this._normalizeObjectConfigData({\n            files: [`*${processorId}`],\n            processor: `${pluginId}/${processorId}`\n          }, { ...ctx,\n            type: \"implicit-processor\",\n            name: `${ctx.name}#processors[\"${pluginId}/${processorId}\"]`\n          });\n        }\n      }\n    }\n  }\n\n}\n\nexport { ConfigArrayFactory, createContext };","map":{"version":3,"names":["debugOrig","fs","importFresh","createRequire","path","stripComments","ConfigArray","ConfigDependency","IgnorePattern","OverrideTester","ConfigValidator","naming","ModuleResolver","require","import","meta","url","debug","configFilenames","internalSlotsMap","WeakMap","normalizedPlugins","isFilePath","nameOrPath","test","isAbsolute","readFile","filePath","readFileSync","replace","loadYAMLConfigFile","yaml","load","e","message","loadJSONConfigFile","JSON","parse","messageTemplate","messageData","loadLegacyConfigFile","loadJSConfigFile","loadPackageJSONConfigFile","packageData","Object","hasOwnProperty","call","assign","Error","code","eslintConfig","loadESLintIgnoreFile","split","filter","line","trim","startsWith","configInvalidError","configName","importerName","loadConfigFile","extname","basename","writeDebugLogForLoading","request","relativeTo","enabled","nameAndVersion","packageJsonPath","resolve","version","error","createContext","providedType","providedName","providedFilePath","providedMatchBasePath","cwd","resolvePluginsRelativeTo","matchBasePath","dirname","name","relative","pluginBasePath","type","normalizePlugin","plugin","normalizedPlugin","get","configs","environments","processors","rules","set","ConfigArrayFactory","constructor","additionalPluginPool","Map","process","builtInRules","resolver","eslintAllPath","getEslintAllConfig","eslintRecommendedPath","getEslintRecommendedConfig","create","configData","basePath","slots","ctx","elements","_normalizeConfigData","loadFile","_loadConfigData","loadInDirectory","directoryPath","filename","join","existsSync","statSync","isFile","getPathToConfigFileInDirectory","loadESLintIgnore","ignorePatterns","_normalizeESLintIgnoreData","loadDefaultESLintIgnore","eslintIgnorePath","data","Array","isArray","eslintIgnore","_normalizeObjectConfigData","element","ignorePattern","loose","validator","validateConfigSchema","files","excludedFiles","configBody","criteria","_normalizeObjectConfigDataBody","and","root","env","extends","extend","globals","noInlineConfig","parser","parserName","parserOptions","plugins","pluginList","processor","reportUnusedDisableDirectives","settings","overrides","overrideList","extendList","extendName","Boolean","_loadExtends","_loadParser","_loadPlugins","_takeFileExtensionProcessors","i","length","_loadExtendedBuiltInConfig","_loadExtendedPluginConfig","_loadExtendedShareableConfig","slashIndex","lastIndexOf","pluginName","slice","_loadPlugin","definition","id","normalizePackageName","names","reduce","map","importerPath","getShorthandName","match","resolveError","startTime","Date","now","pluginDefinition","loadError","pluginId","keys","processorId"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@eslint/eslintrc/lib/config-array-factory.js"],"sourcesContent":["/**\n * @fileoverview The factory of `ConfigArray` objects.\n *\n * This class provides methods to create `ConfigArray` instance.\n *\n * - `create(configData, options)`\n *     Create a `ConfigArray` instance from a config data. This is to handle CLI\n *     options except `--config`.\n * - `loadFile(filePath, options)`\n *     Create a `ConfigArray` instance from a config file. This is to handle\n *     `--config` option. If the file was not found, throws the following error:\n *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.\n *      - If the filename was `package.json`, an IO error or an\n *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.\n *      - Otherwise, an IO error such as `ENOENT`.\n * - `loadInDirectory(directoryPath, options)`\n *     Create a `ConfigArray` instance from a config file which is on a given\n *     directory. This tries to load `.eslintrc.*` or `package.json`. If not\n *     found, returns an empty `ConfigArray`.\n * - `loadESLintIgnore(filePath)`\n *     Create a `ConfigArray` instance from a config file that is `.eslintignore`\n *     format. This is to handle `--ignore-path` option.\n * - `loadDefaultESLintIgnore()`\n *     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in\n *     the current working directory.\n *\n * `ConfigArrayFactory` class has the responsibility that loads configuration\n * files, including loading `extends`, `parser`, and `plugins`. The created\n * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.\n *\n * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class\n * handles cascading and hierarchy.\n *\n * @author Toru Nagashima <https://github.com/mysticatea>\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport debugOrig from \"debug\";\nimport fs from \"fs\";\nimport importFresh from \"import-fresh\";\nimport { createRequire } from \"module\";\nimport path from \"path\";\nimport stripComments from \"strip-json-comments\";\n\nimport {\n    ConfigArray,\n    ConfigDependency,\n    IgnorePattern,\n    OverrideTester\n} from \"./config-array/index.js\";\nimport ConfigValidator from \"./shared/config-validator.js\";\nimport * as naming from \"./shared/naming.js\";\nimport * as ModuleResolver from \"./shared/relative-module-resolver.js\";\n\nconst require = createRequire(import.meta.url);\n\nconst debug = debugOrig(\"eslintrc:config-array-factory\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst configFilenames = [\n    \".eslintrc.js\",\n    \".eslintrc.cjs\",\n    \".eslintrc.yaml\",\n    \".eslintrc.yml\",\n    \".eslintrc.json\",\n    \".eslintrc\",\n    \"package.json\"\n];\n\n// Define types for VSCode IntelliSense.\n/** @typedef {import(\"./shared/types\").ConfigData} ConfigData */\n/** @typedef {import(\"./shared/types\").OverrideConfigData} OverrideConfigData */\n/** @typedef {import(\"./shared/types\").Parser} Parser */\n/** @typedef {import(\"./shared/types\").Plugin} Plugin */\n/** @typedef {import(\"./shared/types\").Rule} Rule */\n/** @typedef {import(\"./config-array/config-dependency\").DependentParser} DependentParser */\n/** @typedef {import(\"./config-array/config-dependency\").DependentPlugin} DependentPlugin */\n/** @typedef {ConfigArray[0]} ConfigArrayElement */\n\n/**\n * @typedef {Object} ConfigArrayFactoryOptions\n * @property {Map<string,Plugin>} [additionalPluginPool] The map for additional plugins.\n * @property {string} [cwd] The path to the current working directory.\n * @property {string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryInternalSlots\n * @property {Map<string,Plugin>} additionalPluginPool The map for additional plugins.\n * @property {string} cwd The path to the current working directory.\n * @property {string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.\n * @property {Map<string,Rule>} builtInRules The rules that are built in to ESLint.\n * @property {Object} [resolver=ModuleResolver] The module resolver object.\n * @property {string} eslintAllPath The path to the definitions for eslint:all.\n * @property {Function} getEslintAllConfig Returns the config data for eslint:all.\n * @property {string} eslintRecommendedPath The path to the definitions for eslint:recommended.\n * @property {Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {string} pluginBasePath The base path to resolve plugins.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/**\n * @typedef {Object} ConfigArrayFactoryLoadingContext\n * @property {string} filePath The path to the current configuration.\n * @property {string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n * @property {string} name The name of the current configuration.\n * @property {\"config\" | \"ignore\" | \"implicit-processor\"} type The type of the current configuration. This is `\"config\"` in normal. This is `\"ignore\"` if it came from `.eslintignore`. This is `\"implicit-processor\"` if it came from legacy file-extension processors.\n */\n\n/** @type {WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>} */\nconst internalSlotsMap = new WeakMap();\n\n/** @type {WeakMap<object, Plugin>} */\nconst normalizedPlugins = new WeakMap();\n\n/**\n * Check if a given string is a file path.\n * @param {string} nameOrPath A module name or file path.\n * @returns {boolean} `true` if the `nameOrPath` is a file path.\n */\nfunction isFilePath(nameOrPath) {\n    return (\n        /^\\.{1,2}[/\\\\]/u.test(nameOrPath) ||\n        path.isAbsolute(nameOrPath)\n    );\n}\n\n/**\n * Convenience wrapper for synchronously reading file contents.\n * @param {string} filePath The filename to read.\n * @returns {string} The file contents, with the BOM removed.\n * @private\n */\nfunction readFile(filePath) {\n    return fs.readFileSync(filePath, \"utf8\").replace(/^\\ufeff/u, \"\");\n}\n\n/**\n * Loads a YAML configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadYAMLConfigFile(filePath) {\n    debug(`Loading YAML config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n\n        // empty YAML file can be null, so always use\n        return yaml.load(readFile(filePath)) || {};\n    } catch (e) {\n        debug(`Error reading YAML file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JSON configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSONConfigFile(filePath) {\n    debug(`Loading JSON config file: ${filePath}`);\n\n    try {\n        return JSON.parse(stripComments(readFile(filePath)));\n    } catch (e) {\n        debug(`Error reading JSON file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        e.messageTemplate = \"failed-to-read-json\";\n        e.messageData = {\n            path: filePath,\n            message: e.message\n        };\n        throw e;\n    }\n}\n\n/**\n * Loads a legacy (.eslintrc) configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadLegacyConfigFile(filePath) {\n    debug(`Loading legacy config file: ${filePath}`);\n\n    // lazy load YAML to improve performance when not used\n    const yaml = require(\"js-yaml\");\n\n    try {\n        return yaml.load(stripComments(readFile(filePath))) || /* istanbul ignore next */ {};\n    } catch (e) {\n        debug(\"Error reading YAML file: %s\\n%o\", filePath, e);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a JavaScript configuration from a file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadJSConfigFile(filePath) {\n    debug(`Loading JS config file: ${filePath}`);\n    try {\n        return importFresh(filePath);\n    } catch (e) {\n        debug(`Error reading JavaScript file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a configuration from a package.json file.\n * @param {string} filePath The filename to load.\n * @returns {ConfigData} The configuration object from the file.\n * @throws {Error} If the file cannot be read.\n * @private\n */\nfunction loadPackageJSONConfigFile(filePath) {\n    debug(`Loading package.json config file: ${filePath}`);\n    try {\n        const packageData = loadJSONConfigFile(filePath);\n\n        if (!Object.hasOwnProperty.call(packageData, \"eslintConfig\")) {\n            throw Object.assign(\n                new Error(\"package.json file doesn't have 'eslintConfig' field.\"),\n                { code: \"ESLINT_CONFIG_FIELD_NOT_FOUND\" }\n            );\n        }\n\n        return packageData.eslintConfig;\n    } catch (e) {\n        debug(`Error reading package.json file: ${filePath}`);\n        e.message = `Cannot read config file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Loads a `.eslintignore` from a file.\n * @param {string} filePath The filename to load.\n * @returns {string[]} The ignore patterns from the file.\n * @private\n */\nfunction loadESLintIgnoreFile(filePath) {\n    debug(`Loading .eslintignore file: ${filePath}`);\n\n    try {\n        return readFile(filePath)\n            .split(/\\r?\\n/gu)\n            .filter(line => line.trim() !== \"\" && !line.startsWith(\"#\"));\n    } catch (e) {\n        debug(`Error reading .eslintignore file: ${filePath}`);\n        e.message = `Cannot read .eslintignore file: ${filePath}\\nError: ${e.message}`;\n        throw e;\n    }\n}\n\n/**\n * Creates an error to notify about a missing config to extend from.\n * @param {string} configName The name of the missing config.\n * @param {string} importerName The name of the config that imported the missing config\n * @param {string} messageTemplate The text template to source error strings from.\n * @returns {Error} The error object to throw\n * @private\n */\nfunction configInvalidError(configName, importerName, messageTemplate) {\n    return Object.assign(\n        new Error(`Failed to load config \"${configName}\" to extend from.`),\n        {\n            messageTemplate,\n            messageData: { configName, importerName }\n        }\n    );\n}\n\n/**\n * Loads a configuration file regardless of the source. Inspects the file path\n * to determine the correctly way to load the config file.\n * @param {string} filePath The path to the configuration.\n * @returns {ConfigData|null} The configuration information.\n * @private\n */\nfunction loadConfigFile(filePath) {\n    switch (path.extname(filePath)) {\n        case \".js\":\n        case \".cjs\":\n            return loadJSConfigFile(filePath);\n\n        case \".json\":\n            if (path.basename(filePath) === \"package.json\") {\n                return loadPackageJSONConfigFile(filePath);\n            }\n            return loadJSONConfigFile(filePath);\n\n        case \".yaml\":\n        case \".yml\":\n            return loadYAMLConfigFile(filePath);\n\n        default:\n            return loadLegacyConfigFile(filePath);\n    }\n}\n\n/**\n * Write debug log.\n * @param {string} request The requested module name.\n * @param {string} relativeTo The file path to resolve the request relative to.\n * @param {string} filePath The resolved file path.\n * @returns {void}\n */\nfunction writeDebugLogForLoading(request, relativeTo, filePath) {\n    /* istanbul ignore next */\n    if (debug.enabled) {\n        let nameAndVersion = null;\n\n        try {\n            const packageJsonPath = ModuleResolver.resolve(\n                `${request}/package.json`,\n                relativeTo\n            );\n            const { version = \"unknown\" } = require(packageJsonPath);\n\n            nameAndVersion = `${request}@${version}`;\n        } catch (error) {\n            debug(\"package.json was not found:\", error.message);\n            nameAndVersion = request;\n        }\n\n        debug(\"Loaded: %s (%s)\", nameAndVersion, filePath);\n    }\n}\n\n/**\n * Create a new context with default values.\n * @param {ConfigArrayFactoryInternalSlots} slots The internal slots.\n * @param {\"config\" | \"ignore\" | \"implicit-processor\" | undefined} providedType The type of the current configuration. Default is `\"config\"`.\n * @param {string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`.\n * @param {string | undefined} providedFilePath The path to the current configuration. Default is empty string.\n * @param {string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`.\n * @returns {ConfigArrayFactoryLoadingContext} The created context.\n */\nfunction createContext(\n    { cwd, resolvePluginsRelativeTo },\n    providedType,\n    providedName,\n    providedFilePath,\n    providedMatchBasePath\n) {\n    const filePath = providedFilePath\n        ? path.resolve(cwd, providedFilePath)\n        : \"\";\n    const matchBasePath =\n        (providedMatchBasePath && path.resolve(cwd, providedMatchBasePath)) ||\n        (filePath && path.dirname(filePath)) ||\n        cwd;\n    const name =\n        providedName ||\n        (filePath && path.relative(cwd, filePath)) ||\n        \"\";\n    const pluginBasePath =\n        resolvePluginsRelativeTo ||\n        (filePath && path.dirname(filePath)) ||\n        cwd;\n    const type = providedType || \"config\";\n\n    return { filePath, matchBasePath, name, pluginBasePath, type };\n}\n\n/**\n * Normalize a given plugin.\n * - Ensure the object to have four properties: configs, environments, processors, and rules.\n * - Ensure the object to not have other properties.\n * @param {Plugin} plugin The plugin to normalize.\n * @returns {Plugin} The normalized plugin.\n */\nfunction normalizePlugin(plugin) {\n\n    // first check the cache\n    let normalizedPlugin = normalizedPlugins.get(plugin);\n\n    if (normalizedPlugin) {\n        return normalizedPlugin;\n    }\n\n    normalizedPlugin = {\n        configs: plugin.configs || {},\n        environments: plugin.environments || {},\n        processors: plugin.processors || {},\n        rules: plugin.rules || {}\n    };\n\n    // save the reference for later\n    normalizedPlugins.set(plugin, normalizedPlugin);\n\n    return normalizedPlugin;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The factory of `ConfigArray` objects.\n */\nclass ConfigArrayFactory {\n\n    /**\n     * Initialize this instance.\n     * @param {ConfigArrayFactoryOptions} [options] The map for additional plugins.\n     */\n    constructor({\n        additionalPluginPool = new Map(),\n        cwd = process.cwd(),\n        resolvePluginsRelativeTo,\n        builtInRules,\n        resolver = ModuleResolver,\n        eslintAllPath,\n        getEslintAllConfig,\n        eslintRecommendedPath,\n        getEslintRecommendedConfig\n    } = {}) {\n        internalSlotsMap.set(this, {\n            additionalPluginPool,\n            cwd,\n            resolvePluginsRelativeTo:\n                resolvePluginsRelativeTo &&\n                path.resolve(cwd, resolvePluginsRelativeTo),\n            builtInRules,\n            resolver,\n            eslintAllPath,\n            getEslintAllConfig,\n            eslintRecommendedPath,\n            getEslintRecommendedConfig\n        });\n    }\n\n    /**\n     * Create `ConfigArray` instance from a config data.\n     * @param {ConfigData|null} configData The config data to create.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.filePath] The path to this config data.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config.\n     */\n    create(configData, { basePath, filePath, name } = {}) {\n        if (!configData) {\n            return new ConfigArray();\n        }\n\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(slots, \"config\", name, filePath, basePath);\n        const elements = this._normalizeConfigData(configData, ctx);\n\n        return new ConfigArray(...elements);\n    }\n\n    /**\n     * Load a config file.\n     * @param {string} filePath The path to a config file.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config.\n     */\n    loadFile(filePath, { basePath, name } = {}) {\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(slots, \"config\", name, filePath, basePath);\n\n        return new ConfigArray(...this._loadConfigData(ctx));\n    }\n\n    /**\n     * Load the config file on a given directory if exists.\n     * @param {string} directoryPath The path to a directory.\n     * @param {Object} [options] The options.\n     * @param {string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.\n     * @param {string} [options.name] The config name.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadInDirectory(directoryPath, { basePath, name } = {}) {\n        const slots = internalSlotsMap.get(this);\n\n        for (const filename of configFilenames) {\n            const ctx = createContext(\n                slots,\n                \"config\",\n                name,\n                path.join(directoryPath, filename),\n                basePath\n            );\n\n            if (fs.existsSync(ctx.filePath) && fs.statSync(ctx.filePath).isFile()) {\n                let configData;\n\n                try {\n                    configData = loadConfigFile(ctx.filePath);\n                } catch (error) {\n                    if (!error || error.code !== \"ESLINT_CONFIG_FIELD_NOT_FOUND\") {\n                        throw error;\n                    }\n                }\n\n                if (configData) {\n                    debug(`Config file found: ${ctx.filePath}`);\n                    return new ConfigArray(\n                        ...this._normalizeConfigData(configData, ctx)\n                    );\n                }\n            }\n        }\n\n        debug(`Config file not found on ${directoryPath}`);\n        return new ConfigArray();\n    }\n\n    /**\n     * Check if a config file on a given directory exists or not.\n     * @param {string} directoryPath The path to a directory.\n     * @returns {string | null} The path to the found config file. If not found then null.\n     */\n    static getPathToConfigFileInDirectory(directoryPath) {\n        for (const filename of configFilenames) {\n            const filePath = path.join(directoryPath, filename);\n\n            if (fs.existsSync(filePath)) {\n                if (filename === \"package.json\") {\n                    try {\n                        loadPackageJSONConfigFile(filePath);\n                        return filePath;\n                    } catch { /* ignore */ }\n                } else {\n                    return filePath;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Load `.eslintignore` file.\n     * @param {string} filePath The path to a `.eslintignore` file to load.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadESLintIgnore(filePath) {\n        const slots = internalSlotsMap.get(this);\n        const ctx = createContext(\n            slots,\n            \"ignore\",\n            void 0,\n            filePath,\n            slots.cwd\n        );\n        const ignorePatterns = loadESLintIgnoreFile(ctx.filePath);\n\n        return new ConfigArray(\n            ...this._normalizeESLintIgnoreData(ignorePatterns, ctx)\n        );\n    }\n\n    /**\n     * Load `.eslintignore` file in the current working directory.\n     * @returns {ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.\n     */\n    loadDefaultESLintIgnore() {\n        const slots = internalSlotsMap.get(this);\n        const eslintIgnorePath = path.resolve(slots.cwd, \".eslintignore\");\n        const packageJsonPath = path.resolve(slots.cwd, \"package.json\");\n\n        if (fs.existsSync(eslintIgnorePath)) {\n            return this.loadESLintIgnore(eslintIgnorePath);\n        }\n        if (fs.existsSync(packageJsonPath)) {\n            const data = loadJSONConfigFile(packageJsonPath);\n\n            if (Object.hasOwnProperty.call(data, \"eslintIgnore\")) {\n                if (!Array.isArray(data.eslintIgnore)) {\n                    throw new Error(\"Package.json eslintIgnore property requires an array of paths\");\n                }\n                const ctx = createContext(\n                    slots,\n                    \"ignore\",\n                    \"eslintIgnore in package.json\",\n                    packageJsonPath,\n                    slots.cwd\n                );\n\n                return new ConfigArray(\n                    ...this._normalizeESLintIgnoreData(data.eslintIgnore, ctx)\n                );\n            }\n        }\n\n        return new ConfigArray();\n    }\n\n    /**\n     * Load a given config file.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} Loaded config.\n     * @private\n     */\n    _loadConfigData(ctx) {\n        return this._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);\n    }\n\n    /**\n     * Normalize a given `.eslintignore` data to config array elements.\n     * @param {string[]} ignorePatterns The patterns to ignore files.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeESLintIgnoreData(ignorePatterns, ctx) {\n        const elements = this._normalizeObjectConfigData(\n            { ignorePatterns },\n            ctx\n        );\n\n        // Set `ignorePattern.loose` flag for backward compatibility.\n        for (const element of elements) {\n            if (element.ignorePattern) {\n                element.ignorePattern.loose = true;\n            }\n            yield element;\n        }\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _normalizeConfigData(configData, ctx) {\n        const validator = new ConfigValidator();\n\n        validator.validateConfigSchema(configData, ctx.name || ctx.filePath);\n        return this._normalizeObjectConfigData(configData, ctx);\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData|OverrideConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeObjectConfigData(configData, ctx) {\n        const { files, excludedFiles, ...configBody } = configData;\n        const criteria = OverrideTester.create(\n            files,\n            excludedFiles,\n            ctx.matchBasePath\n        );\n        const elements = this._normalizeObjectConfigDataBody(configBody, ctx);\n\n        // Apply the criteria to every element.\n        for (const element of elements) {\n\n            /*\n             * Merge the criteria.\n             * This is for the `overrides` entries that came from the\n             * configurations of `overrides[].extends`.\n             */\n            element.criteria = OverrideTester.and(criteria, element.criteria);\n\n            /*\n             * Remove `root` property to ignore `root` settings which came from\n             * `extends` in `overrides`.\n             */\n            if (element.criteria) {\n                element.root = void 0;\n            }\n\n            yield element;\n        }\n    }\n\n    /**\n     * Normalize a given config to an array.\n     * @param {ConfigData} configData The config data to normalize.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    *_normalizeObjectConfigDataBody(\n        {\n            env,\n            extends: extend,\n            globals,\n            ignorePatterns,\n            noInlineConfig,\n            parser: parserName,\n            parserOptions,\n            plugins: pluginList,\n            processor,\n            reportUnusedDisableDirectives,\n            root,\n            rules,\n            settings,\n            overrides: overrideList = []\n        },\n        ctx\n    ) {\n        const extendList = Array.isArray(extend) ? extend : [extend];\n        const ignorePattern = ignorePatterns && new IgnorePattern(\n            Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns],\n            ctx.matchBasePath\n        );\n\n        // Flatten `extends`.\n        for (const extendName of extendList.filter(Boolean)) {\n            yield* this._loadExtends(extendName, ctx);\n        }\n\n        // Load parser & plugins.\n        const parser = parserName && this._loadParser(parserName, ctx);\n        const plugins = pluginList && this._loadPlugins(pluginList, ctx);\n\n        // Yield pseudo config data for file extension processors.\n        if (plugins) {\n            yield* this._takeFileExtensionProcessors(plugins, ctx);\n        }\n\n        // Yield the config data except `extends` and `overrides`.\n        yield {\n\n            // Debug information.\n            type: ctx.type,\n            name: ctx.name,\n            filePath: ctx.filePath,\n\n            // Config data.\n            criteria: null,\n            env,\n            globals,\n            ignorePattern,\n            noInlineConfig,\n            parser,\n            parserOptions,\n            plugins,\n            processor,\n            reportUnusedDisableDirectives,\n            root,\n            rules,\n            settings\n        };\n\n        // Flatten `overries`.\n        for (let i = 0; i < overrideList.length; ++i) {\n            yield* this._normalizeObjectConfigData(\n                overrideList[i],\n                { ...ctx, name: `${ctx.name}#overrides[${i}]` }\n            );\n        }\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtends(extendName, ctx) {\n        debug(\"Loading {extends:%j} relative to %s\", extendName, ctx.filePath);\n        try {\n            if (extendName.startsWith(\"eslint:\")) {\n                return this._loadExtendedBuiltInConfig(extendName, ctx);\n            }\n            if (extendName.startsWith(\"plugin:\")) {\n                return this._loadExtendedPluginConfig(extendName, ctx);\n            }\n            return this._loadExtendedShareableConfig(extendName, ctx);\n        } catch (error) {\n            error.message += `\\nReferenced from: ${ctx.filePath || ctx.name}`;\n            throw error;\n        }\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedBuiltInConfig(extendName, ctx) {\n        const {\n            eslintAllPath,\n            getEslintAllConfig,\n            eslintRecommendedPath,\n            getEslintRecommendedConfig\n        } = internalSlotsMap.get(this);\n\n        if (extendName === \"eslint:recommended\") {\n            const name = `${ctx.name} » ${extendName}`;\n\n            if (getEslintRecommendedConfig) {\n                if (typeof getEslintRecommendedConfig !== \"function\") {\n                    throw new Error(`getEslintRecommendedConfig must be a function instead of '${getEslintRecommendedConfig}'`);\n                }\n                return this._normalizeConfigData(getEslintRecommendedConfig(), { ...ctx, name, filePath: \"\" });\n            }\n            return this._loadConfigData({\n                ...ctx,\n                name,\n                filePath: eslintRecommendedPath\n            });\n        }\n        if (extendName === \"eslint:all\") {\n            const name = `${ctx.name} » ${extendName}`;\n\n            if (getEslintAllConfig) {\n                if (typeof getEslintAllConfig !== \"function\") {\n                    throw new Error(`getEslintAllConfig must be a function instead of '${getEslintAllConfig}'`);\n                }\n                return this._normalizeConfigData(getEslintAllConfig(), { ...ctx, name, filePath: \"\" });\n            }\n            return this._loadConfigData({\n                ...ctx,\n                name,\n                filePath: eslintAllPath\n            });\n        }\n\n        throw configInvalidError(extendName, ctx.name, \"extend-config-missing\");\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedPluginConfig(extendName, ctx) {\n        const slashIndex = extendName.lastIndexOf(\"/\");\n\n        if (slashIndex === -1) {\n            throw configInvalidError(extendName, ctx.filePath, \"plugin-invalid\");\n        }\n\n        const pluginName = extendName.slice(\"plugin:\".length, slashIndex);\n        const configName = extendName.slice(slashIndex + 1);\n\n        if (isFilePath(pluginName)) {\n            throw new Error(\"'extends' cannot use a file path for plugins.\");\n        }\n\n        const plugin = this._loadPlugin(pluginName, ctx);\n        const configData =\n            plugin.definition &&\n            plugin.definition.configs[configName];\n\n        if (configData) {\n            return this._normalizeConfigData(configData, {\n                ...ctx,\n                filePath: plugin.filePath || ctx.filePath,\n                name: `${ctx.name} » plugin:${plugin.id}/${configName}`\n            });\n        }\n\n        throw plugin.error || configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n    }\n\n    /**\n     * Load configs of an element in `extends`.\n     * @param {string} extendName The name of a base config.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The normalized config.\n     * @private\n     */\n    _loadExtendedShareableConfig(extendName, ctx) {\n        const { cwd, resolver } = internalSlotsMap.get(this);\n        const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n        let request;\n\n        if (isFilePath(extendName)) {\n            request = extendName;\n        } else if (extendName.startsWith(\".\")) {\n            request = `./${extendName}`; // For backward compatibility. A ton of tests depended on this behavior.\n        } else {\n            request = naming.normalizePackageName(\n                extendName,\n                \"eslint-config\"\n            );\n        }\n\n        let filePath;\n\n        try {\n            filePath = resolver.resolve(request, relativeTo);\n        } catch (error) {\n            /* istanbul ignore else */\n            if (error && error.code === \"MODULE_NOT_FOUND\") {\n                throw configInvalidError(extendName, ctx.filePath, \"extend-config-missing\");\n            }\n            throw error;\n        }\n\n        writeDebugLogForLoading(request, relativeTo, filePath);\n        return this._loadConfigData({\n            ...ctx,\n            filePath,\n            name: `${ctx.name} » ${request}`\n        });\n    }\n\n    /**\n     * Load given plugins.\n     * @param {string[]} names The plugin names to load.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {Record<string,DependentPlugin>} The loaded parser.\n     * @private\n     */\n    _loadPlugins(names, ctx) {\n        return names.reduce((map, name) => {\n            if (isFilePath(name)) {\n                throw new Error(\"Plugins array cannot includes file paths.\");\n            }\n            const plugin = this._loadPlugin(name, ctx);\n\n            map[plugin.id] = plugin;\n\n            return map;\n        }, {});\n    }\n\n    /**\n     * Load a given parser.\n     * @param {string} nameOrPath The package name or the path to a parser file.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {DependentParser} The loaded parser.\n     */\n    _loadParser(nameOrPath, ctx) {\n        debug(\"Loading parser %j from %s\", nameOrPath, ctx.filePath);\n\n        const { cwd, resolver } = internalSlotsMap.get(this);\n        const relativeTo = ctx.filePath || path.join(cwd, \"__placeholder__.js\");\n\n        try {\n            const filePath = resolver.resolve(nameOrPath, relativeTo);\n\n            writeDebugLogForLoading(nameOrPath, relativeTo, filePath);\n\n            return new ConfigDependency({\n                definition: require(filePath),\n                filePath,\n                id: nameOrPath,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        } catch (error) {\n\n            // If the parser name is \"espree\", load the espree of ESLint.\n            if (nameOrPath === \"espree\") {\n                debug(\"Fallback espree.\");\n                return new ConfigDependency({\n                    definition: require(\"espree\"),\n                    filePath: require.resolve(\"espree\"),\n                    id: nameOrPath,\n                    importerName: ctx.name,\n                    importerPath: ctx.filePath\n                });\n            }\n\n            debug(\"Failed to load parser '%s' declared in '%s'.\", nameOrPath, ctx.name);\n            error.message = `Failed to load parser '${nameOrPath}' declared in '${ctx.name}': ${error.message}`;\n\n            return new ConfigDependency({\n                error,\n                id: nameOrPath,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n    }\n\n    /**\n     * Load a given plugin.\n     * @param {string} name The plugin name to load.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {DependentPlugin} The loaded plugin.\n     * @private\n     */\n    _loadPlugin(name, ctx) {\n        debug(\"Loading plugin %j from %s\", name, ctx.filePath);\n\n        const { additionalPluginPool, resolver } = internalSlotsMap.get(this);\n        const request = naming.normalizePackageName(name, \"eslint-plugin\");\n        const id = naming.getShorthandName(request, \"eslint-plugin\");\n        const relativeTo = path.join(ctx.pluginBasePath, \"__placeholder__.js\");\n\n        if (name.match(/\\s+/u)) {\n            const error = Object.assign(\n                new Error(`Whitespace found in plugin name '${name}'`),\n                {\n                    messageTemplate: \"whitespace-found\",\n                    messageData: { pluginName: request }\n                }\n            );\n\n            return new ConfigDependency({\n                error,\n                id,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n\n        // Check for additional pool.\n        const plugin =\n            additionalPluginPool.get(request) ||\n            additionalPluginPool.get(id);\n\n        if (plugin) {\n            return new ConfigDependency({\n                definition: normalizePlugin(plugin),\n                filePath: \"\", // It's unknown where the plugin came from.\n                id,\n                importerName: ctx.name,\n                importerPath: ctx.filePath\n            });\n        }\n\n        let filePath;\n        let error;\n\n        try {\n            filePath = resolver.resolve(request, relativeTo);\n        } catch (resolveError) {\n            error = resolveError;\n            /* istanbul ignore else */\n            if (error && error.code === \"MODULE_NOT_FOUND\") {\n                error.messageTemplate = \"plugin-missing\";\n                error.messageData = {\n                    pluginName: request,\n                    resolvePluginsRelativeTo: ctx.pluginBasePath,\n                    importerName: ctx.name\n                };\n            }\n        }\n\n        if (filePath) {\n            try {\n                writeDebugLogForLoading(request, relativeTo, filePath);\n\n                const startTime = Date.now();\n                const pluginDefinition = require(filePath);\n\n                debug(`Plugin ${filePath} loaded in: ${Date.now() - startTime}ms`);\n\n                return new ConfigDependency({\n                    definition: normalizePlugin(pluginDefinition),\n                    filePath,\n                    id,\n                    importerName: ctx.name,\n                    importerPath: ctx.filePath\n                });\n            } catch (loadError) {\n                error = loadError;\n            }\n        }\n\n        debug(\"Failed to load plugin '%s' declared in '%s'.\", name, ctx.name);\n        error.message = `Failed to load plugin '${name}' declared in '${ctx.name}': ${error.message}`;\n        return new ConfigDependency({\n            error,\n            id,\n            importerName: ctx.name,\n            importerPath: ctx.filePath\n        });\n    }\n\n    /**\n     * Take file expression processors as config array elements.\n     * @param {Record<string,DependentPlugin>} plugins The plugin definitions.\n     * @param {ConfigArrayFactoryLoadingContext} ctx The loading context.\n     * @returns {IterableIterator<ConfigArrayElement>} The config array elements of file expression processors.\n     * @private\n     */\n    *_takeFileExtensionProcessors(plugins, ctx) {\n        for (const pluginId of Object.keys(plugins)) {\n            const processors =\n                plugins[pluginId] &&\n                plugins[pluginId].definition &&\n                plugins[pluginId].definition.processors;\n\n            if (!processors) {\n                continue;\n            }\n\n            for (const processorId of Object.keys(processors)) {\n                if (processorId.startsWith(\".\")) {\n                    yield* this._normalizeObjectConfigData(\n                        {\n                            files: [`*${processorId}`],\n                            processor: `${pluginId}/${processorId}`\n                        },\n                        {\n                            ...ctx,\n                            type: \"implicit-processor\",\n                            name: `${ctx.name}#processors[\"${pluginId}/${processorId}\"]`\n                        }\n                    );\n                }\n            }\n        }\n    }\n}\n\nexport { ConfigArrayFactory, createContext };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA,OAAOA,SAAP,MAAsB,OAAtB;AACA,OAAOC,EAAP,MAAe,IAAf;AACA,OAAOC,WAAP,MAAwB,cAAxB;AACA,SAASC,aAAT,QAA8B,QAA9B;AACA,OAAOC,IAAP,MAAiB,MAAjB;AACA,OAAOC,aAAP,MAA0B,qBAA1B;AAEA,SACIC,WADJ,EAEIC,gBAFJ,EAGIC,aAHJ,EAIIC,cAJJ,QAKO,yBALP;AAMA,OAAOC,eAAP,MAA4B,8BAA5B;AACA,OAAO,KAAKC,MAAZ,MAAwB,oBAAxB;AACA,OAAO,KAAKC,cAAZ,MAAgC,sCAAhC;;AAEA,MAAMC,OAAO,GAAGV,aAAa,CAACW,MAAM,CAACC,IAAP,CAAYC,GAAb,CAA7B;;AAEA,MAAMC,KAAK,GAAGjB,SAAS,CAAC,+BAAD,CAAvB,C,CAEA;AACA;AACA;;AAEA,MAAMkB,eAAe,GAAG,CACpB,cADoB,EAEpB,eAFoB,EAGpB,gBAHoB,EAIpB,eAJoB,EAKpB,gBALoB,EAMpB,WANoB,EAOpB,cAPoB,CAAxB,C,CAUA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA,MAAMC,gBAAgB,GAAG,IAAIC,OAAJ,EAAzB;AAEA;;AACA,MAAMC,iBAAiB,GAAG,IAAID,OAAJ,EAA1B;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASE,UAAT,CAAoBC,UAApB,EAAgC;EAC5B,OACI,iBAAiBC,IAAjB,CAAsBD,UAAtB,KACAnB,IAAI,CAACqB,UAAL,CAAgBF,UAAhB,CAFJ;AAIH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,QAAT,CAAkBC,QAAlB,EAA4B;EACxB,OAAO1B,EAAE,CAAC2B,YAAH,CAAgBD,QAAhB,EAA0B,MAA1B,EAAkCE,OAAlC,CAA0C,UAA1C,EAAsD,EAAtD,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,kBAAT,CAA4BH,QAA5B,EAAsC;EAClCV,KAAK,CAAE,6BAA4BU,QAAS,EAAvC,CAAL,CADkC,CAGlC;;EACA,MAAMI,IAAI,GAAGlB,OAAO,CAAC,SAAD,CAApB;;EAEA,IAAI;IAEA;IACA,OAAOkB,IAAI,CAACC,IAAL,CAAUN,QAAQ,CAACC,QAAD,CAAlB,KAAiC,EAAxC;EACH,CAJD,CAIE,OAAOM,CAAP,EAAU;IACRhB,KAAK,CAAE,4BAA2BU,QAAS,EAAtC,CAAL;IACAM,CAAC,CAACC,OAAF,GAAa,4BAA2BP,QAAS,YAAWM,CAAC,CAACC,OAAQ,EAAtE;IACA,MAAMD,CAAN;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,kBAAT,CAA4BR,QAA5B,EAAsC;EAClCV,KAAK,CAAE,6BAA4BU,QAAS,EAAvC,CAAL;;EAEA,IAAI;IACA,OAAOS,IAAI,CAACC,KAAL,CAAWhC,aAAa,CAACqB,QAAQ,CAACC,QAAD,CAAT,CAAxB,CAAP;EACH,CAFD,CAEE,OAAOM,CAAP,EAAU;IACRhB,KAAK,CAAE,4BAA2BU,QAAS,EAAtC,CAAL;IACAM,CAAC,CAACC,OAAF,GAAa,4BAA2BP,QAAS,YAAWM,CAAC,CAACC,OAAQ,EAAtE;IACAD,CAAC,CAACK,eAAF,GAAoB,qBAApB;IACAL,CAAC,CAACM,WAAF,GAAgB;MACZnC,IAAI,EAAEuB,QADM;MAEZO,OAAO,EAAED,CAAC,CAACC;IAFC,CAAhB;IAIA,MAAMD,CAAN;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASO,oBAAT,CAA8Bb,QAA9B,EAAwC;EACpCV,KAAK,CAAE,+BAA8BU,QAAS,EAAzC,CAAL,CADoC,CAGpC;;EACA,MAAMI,IAAI,GAAGlB,OAAO,CAAC,SAAD,CAApB;;EAEA,IAAI;IACA,OAAOkB,IAAI,CAACC,IAAL,CAAU3B,aAAa,CAACqB,QAAQ,CAACC,QAAD,CAAT,CAAvB;IAAgD;IAA2B,EAAlF;EACH,CAFD,CAEE,OAAOM,CAAP,EAAU;IACRhB,KAAK,CAAC,iCAAD,EAAoCU,QAApC,EAA8CM,CAA9C,CAAL;IACAA,CAAC,CAACC,OAAF,GAAa,4BAA2BP,QAAS,YAAWM,CAAC,CAACC,OAAQ,EAAtE;IACA,MAAMD,CAAN;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,gBAAT,CAA0Bd,QAA1B,EAAoC;EAChCV,KAAK,CAAE,2BAA0BU,QAAS,EAArC,CAAL;;EACA,IAAI;IACA,OAAOzB,WAAW,CAACyB,QAAD,CAAlB;EACH,CAFD,CAEE,OAAOM,CAAP,EAAU;IACRhB,KAAK,CAAE,kCAAiCU,QAAS,EAA5C,CAAL;IACAM,CAAC,CAACC,OAAF,GAAa,4BAA2BP,QAAS,YAAWM,CAAC,CAACC,OAAQ,EAAtE;IACA,MAAMD,CAAN;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASS,yBAAT,CAAmCf,QAAnC,EAA6C;EACzCV,KAAK,CAAE,qCAAoCU,QAAS,EAA/C,CAAL;;EACA,IAAI;IACA,MAAMgB,WAAW,GAAGR,kBAAkB,CAACR,QAAD,CAAtC;;IAEA,IAAI,CAACiB,MAAM,CAACC,cAAP,CAAsBC,IAAtB,CAA2BH,WAA3B,EAAwC,cAAxC,CAAL,EAA8D;MAC1D,MAAMC,MAAM,CAACG,MAAP,CACF,IAAIC,KAAJ,CAAU,sDAAV,CADE,EAEF;QAAEC,IAAI,EAAE;MAAR,CAFE,CAAN;IAIH;;IAED,OAAON,WAAW,CAACO,YAAnB;EACH,CAXD,CAWE,OAAOjB,CAAP,EAAU;IACRhB,KAAK,CAAE,oCAAmCU,QAAS,EAA9C,CAAL;IACAM,CAAC,CAACC,OAAF,GAAa,4BAA2BP,QAAS,YAAWM,CAAC,CAACC,OAAQ,EAAtE;IACA,MAAMD,CAAN;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASkB,oBAAT,CAA8BxB,QAA9B,EAAwC;EACpCV,KAAK,CAAE,+BAA8BU,QAAS,EAAzC,CAAL;;EAEA,IAAI;IACA,OAAOD,QAAQ,CAACC,QAAD,CAAR,CACFyB,KADE,CACI,SADJ,EAEFC,MAFE,CAEKC,IAAI,IAAIA,IAAI,CAACC,IAAL,OAAgB,EAAhB,IAAsB,CAACD,IAAI,CAACE,UAAL,CAAgB,GAAhB,CAFpC,CAAP;EAGH,CAJD,CAIE,OAAOvB,CAAP,EAAU;IACRhB,KAAK,CAAE,qCAAoCU,QAAS,EAA/C,CAAL;IACAM,CAAC,CAACC,OAAF,GAAa,mCAAkCP,QAAS,YAAWM,CAAC,CAACC,OAAQ,EAA7E;IACA,MAAMD,CAAN;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASwB,kBAAT,CAA4BC,UAA5B,EAAwCC,YAAxC,EAAsDrB,eAAtD,EAAuE;EACnE,OAAOM,MAAM,CAACG,MAAP,CACH,IAAIC,KAAJ,CAAW,0BAAyBU,UAAW,mBAA/C,CADG,EAEH;IACIpB,eADJ;IAEIC,WAAW,EAAE;MAAEmB,UAAF;MAAcC;IAAd;EAFjB,CAFG,CAAP;AAOH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,cAAT,CAAwBjC,QAAxB,EAAkC;EAC9B,QAAQvB,IAAI,CAACyD,OAAL,CAAalC,QAAb,CAAR;IACI,KAAK,KAAL;IACA,KAAK,MAAL;MACI,OAAOc,gBAAgB,CAACd,QAAD,CAAvB;;IAEJ,KAAK,OAAL;MACI,IAAIvB,IAAI,CAAC0D,QAAL,CAAcnC,QAAd,MAA4B,cAAhC,EAAgD;QAC5C,OAAOe,yBAAyB,CAACf,QAAD,CAAhC;MACH;;MACD,OAAOQ,kBAAkB,CAACR,QAAD,CAAzB;;IAEJ,KAAK,OAAL;IACA,KAAK,MAAL;MACI,OAAOG,kBAAkB,CAACH,QAAD,CAAzB;;IAEJ;MACI,OAAOa,oBAAoB,CAACb,QAAD,CAA3B;EAhBR;AAkBH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASoC,uBAAT,CAAiCC,OAAjC,EAA0CC,UAA1C,EAAsDtC,QAAtD,EAAgE;EAC5D;EACA,IAAIV,KAAK,CAACiD,OAAV,EAAmB;IACf,IAAIC,cAAc,GAAG,IAArB;;IAEA,IAAI;MACA,MAAMC,eAAe,GAAGxD,cAAc,CAACyD,OAAf,CACnB,GAAEL,OAAQ,eADS,EAEpBC,UAFoB,CAAxB;;MAIA,MAAM;QAAEK,OAAO,GAAG;MAAZ,IAA0BzD,OAAO,CAACuD,eAAD,CAAvC;;MAEAD,cAAc,GAAI,GAAEH,OAAQ,IAAGM,OAAQ,EAAvC;IACH,CARD,CAQE,OAAOC,KAAP,EAAc;MACZtD,KAAK,CAAC,6BAAD,EAAgCsD,KAAK,CAACrC,OAAtC,CAAL;MACAiC,cAAc,GAAGH,OAAjB;IACH;;IAED/C,KAAK,CAAC,iBAAD,EAAoBkD,cAApB,EAAoCxC,QAApC,CAAL;EACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS6C,aAAT,OAEIC,YAFJ,EAGIC,YAHJ,EAIIC,gBAJJ,EAKIC,qBALJ,EAME;EAAA,IALE;IAAEC,GAAF;IAAOC;EAAP,CAKF;EACE,MAAMnD,QAAQ,GAAGgD,gBAAgB,GAC3BvE,IAAI,CAACiE,OAAL,CAAaQ,GAAb,EAAkBF,gBAAlB,CAD2B,GAE3B,EAFN;EAGA,MAAMI,aAAa,GACdH,qBAAqB,IAAIxE,IAAI,CAACiE,OAAL,CAAaQ,GAAb,EAAkBD,qBAAlB,CAA1B,IACCjD,QAAQ,IAAIvB,IAAI,CAAC4E,OAAL,CAAarD,QAAb,CADb,IAEAkD,GAHJ;EAIA,MAAMI,IAAI,GACNP,YAAY,IACX/C,QAAQ,IAAIvB,IAAI,CAAC8E,QAAL,CAAcL,GAAd,EAAmBlD,QAAnB,CADb,IAEA,EAHJ;EAIA,MAAMwD,cAAc,GAChBL,wBAAwB,IACvBnD,QAAQ,IAAIvB,IAAI,CAAC4E,OAAL,CAAarD,QAAb,CADb,IAEAkD,GAHJ;EAIA,MAAMO,IAAI,GAAGX,YAAY,IAAI,QAA7B;EAEA,OAAO;IAAE9C,QAAF;IAAYoD,aAAZ;IAA2BE,IAA3B;IAAiCE,cAAjC;IAAiDC;EAAjD,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,eAAT,CAAyBC,MAAzB,EAAiC;EAE7B;EACA,IAAIC,gBAAgB,GAAGlE,iBAAiB,CAACmE,GAAlB,CAAsBF,MAAtB,CAAvB;;EAEA,IAAIC,gBAAJ,EAAsB;IAClB,OAAOA,gBAAP;EACH;;EAEDA,gBAAgB,GAAG;IACfE,OAAO,EAAEH,MAAM,CAACG,OAAP,IAAkB,EADZ;IAEfC,YAAY,EAAEJ,MAAM,CAACI,YAAP,IAAuB,EAFtB;IAGfC,UAAU,EAAEL,MAAM,CAACK,UAAP,IAAqB,EAHlB;IAIfC,KAAK,EAAEN,MAAM,CAACM,KAAP,IAAgB;EAJR,CAAnB,CAT6B,CAgB7B;;EACAvE,iBAAiB,CAACwE,GAAlB,CAAsBP,MAAtB,EAA8BC,gBAA9B;EAEA,OAAOA,gBAAP;AACH,C,CAED;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMO,kBAAN,CAAyB;EAErB;AACJ;AACA;AACA;EACIC,WAAW,GAUH;IAAA,IAVI;MACRC,oBAAoB,GAAG,IAAIC,GAAJ,EADf;MAERpB,GAAG,GAAGqB,OAAO,CAACrB,GAAR,EAFE;MAGRC,wBAHQ;MAIRqB,YAJQ;MAKRC,QAAQ,GAAGxF,cALH;MAMRyF,aANQ;MAORC,kBAPQ;MAQRC,qBARQ;MASRC;IATQ,CAUJ,uEAAJ,EAAI;IACJrF,gBAAgB,CAAC0E,GAAjB,CAAqB,IAArB,EAA2B;MACvBG,oBADuB;MAEvBnB,GAFuB;MAGvBC,wBAAwB,EACpBA,wBAAwB,IACxB1E,IAAI,CAACiE,OAAL,CAAaQ,GAAb,EAAkBC,wBAAlB,CALmB;MAMvBqB,YANuB;MAOvBC,QAPuB;MAQvBC,aARuB;MASvBC,kBATuB;MAUvBC,qBAVuB;MAWvBC;IAXuB,CAA3B;EAaH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,MAAM,CAACC,UAAD,EAAgD;IAAA,IAAnC;MAAEC,QAAF;MAAYhF,QAAZ;MAAsBsD;IAAtB,CAAmC,uEAAJ,EAAI;;IAClD,IAAI,CAACyB,UAAL,EAAiB;MACb,OAAO,IAAIpG,WAAJ,EAAP;IACH;;IAED,MAAMsG,KAAK,GAAGzF,gBAAgB,CAACqE,GAAjB,CAAqB,IAArB,CAAd;IACA,MAAMqB,GAAG,GAAGrC,aAAa,CAACoC,KAAD,EAAQ,QAAR,EAAkB3B,IAAlB,EAAwBtD,QAAxB,EAAkCgF,QAAlC,CAAzB;;IACA,MAAMG,QAAQ,GAAG,KAAKC,oBAAL,CAA0BL,UAA1B,EAAsCG,GAAtC,CAAjB;;IAEA,OAAO,IAAIvG,WAAJ,CAAgB,GAAGwG,QAAnB,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIE,QAAQ,CAACrF,QAAD,EAAoC;IAAA,IAAzB;MAAEgF,QAAF;MAAY1B;IAAZ,CAAyB,uEAAJ,EAAI;IACxC,MAAM2B,KAAK,GAAGzF,gBAAgB,CAACqE,GAAjB,CAAqB,IAArB,CAAd;IACA,MAAMqB,GAAG,GAAGrC,aAAa,CAACoC,KAAD,EAAQ,QAAR,EAAkB3B,IAAlB,EAAwBtD,QAAxB,EAAkCgF,QAAlC,CAAzB;IAEA,OAAO,IAAIrG,WAAJ,CAAgB,GAAG,KAAK2G,eAAL,CAAqBJ,GAArB,CAAnB,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIK,eAAe,CAACC,aAAD,EAAyC;IAAA,IAAzB;MAAER,QAAF;MAAY1B;IAAZ,CAAyB,uEAAJ,EAAI;IACpD,MAAM2B,KAAK,GAAGzF,gBAAgB,CAACqE,GAAjB,CAAqB,IAArB,CAAd;;IAEA,KAAK,MAAM4B,QAAX,IAAuBlG,eAAvB,EAAwC;MACpC,MAAM2F,GAAG,GAAGrC,aAAa,CACrBoC,KADqB,EAErB,QAFqB,EAGrB3B,IAHqB,EAIrB7E,IAAI,CAACiH,IAAL,CAAUF,aAAV,EAAyBC,QAAzB,CAJqB,EAKrBT,QALqB,CAAzB;;MAQA,IAAI1G,EAAE,CAACqH,UAAH,CAAcT,GAAG,CAAClF,QAAlB,KAA+B1B,EAAE,CAACsH,QAAH,CAAYV,GAAG,CAAClF,QAAhB,EAA0B6F,MAA1B,EAAnC,EAAuE;QACnE,IAAId,UAAJ;;QAEA,IAAI;UACAA,UAAU,GAAG9C,cAAc,CAACiD,GAAG,CAAClF,QAAL,CAA3B;QACH,CAFD,CAEE,OAAO4C,KAAP,EAAc;UACZ,IAAI,CAACA,KAAD,IAAUA,KAAK,CAACtB,IAAN,KAAe,+BAA7B,EAA8D;YAC1D,MAAMsB,KAAN;UACH;QACJ;;QAED,IAAImC,UAAJ,EAAgB;UACZzF,KAAK,CAAE,sBAAqB4F,GAAG,CAAClF,QAAS,EAApC,CAAL;UACA,OAAO,IAAIrB,WAAJ,CACH,GAAG,KAAKyG,oBAAL,CAA0BL,UAA1B,EAAsCG,GAAtC,CADA,CAAP;QAGH;MACJ;IACJ;;IAED5F,KAAK,CAAE,4BAA2BkG,aAAc,EAA3C,CAAL;IACA,OAAO,IAAI7G,WAAJ,EAAP;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACyC,OAA9BmH,8BAA8B,CAACN,aAAD,EAAgB;IACjD,KAAK,MAAMC,QAAX,IAAuBlG,eAAvB,EAAwC;MACpC,MAAMS,QAAQ,GAAGvB,IAAI,CAACiH,IAAL,CAAUF,aAAV,EAAyBC,QAAzB,CAAjB;;MAEA,IAAInH,EAAE,CAACqH,UAAH,CAAc3F,QAAd,CAAJ,EAA6B;QACzB,IAAIyF,QAAQ,KAAK,cAAjB,EAAiC;UAC7B,IAAI;YACA1E,yBAAyB,CAACf,QAAD,CAAzB;YACA,OAAOA,QAAP;UACH,CAHD,CAGE,MAAM;YAAE;UAAc;QAC3B,CALD,MAKO;UACH,OAAOA,QAAP;QACH;MACJ;IACJ;;IACD,OAAO,IAAP;EACH;EAED;AACJ;AACA;AACA;AACA;;;EACI+F,gBAAgB,CAAC/F,QAAD,EAAW;IACvB,MAAMiF,KAAK,GAAGzF,gBAAgB,CAACqE,GAAjB,CAAqB,IAArB,CAAd;IACA,MAAMqB,GAAG,GAAGrC,aAAa,CACrBoC,KADqB,EAErB,QAFqB,EAGrB,KAAK,CAHgB,EAIrBjF,QAJqB,EAKrBiF,KAAK,CAAC/B,GALe,CAAzB;IAOA,MAAM8C,cAAc,GAAGxE,oBAAoB,CAAC0D,GAAG,CAAClF,QAAL,CAA3C;IAEA,OAAO,IAAIrB,WAAJ,CACH,GAAG,KAAKsH,0BAAL,CAAgCD,cAAhC,EAAgDd,GAAhD,CADA,CAAP;EAGH;EAED;AACJ;AACA;AACA;;;EACIgB,uBAAuB,GAAG;IACtB,MAAMjB,KAAK,GAAGzF,gBAAgB,CAACqE,GAAjB,CAAqB,IAArB,CAAd;IACA,MAAMsC,gBAAgB,GAAG1H,IAAI,CAACiE,OAAL,CAAauC,KAAK,CAAC/B,GAAnB,EAAwB,eAAxB,CAAzB;IACA,MAAMT,eAAe,GAAGhE,IAAI,CAACiE,OAAL,CAAauC,KAAK,CAAC/B,GAAnB,EAAwB,cAAxB,CAAxB;;IAEA,IAAI5E,EAAE,CAACqH,UAAH,CAAcQ,gBAAd,CAAJ,EAAqC;MACjC,OAAO,KAAKJ,gBAAL,CAAsBI,gBAAtB,CAAP;IACH;;IACD,IAAI7H,EAAE,CAACqH,UAAH,CAAclD,eAAd,CAAJ,EAAoC;MAChC,MAAM2D,IAAI,GAAG5F,kBAAkB,CAACiC,eAAD,CAA/B;;MAEA,IAAIxB,MAAM,CAACC,cAAP,CAAsBC,IAAtB,CAA2BiF,IAA3B,EAAiC,cAAjC,CAAJ,EAAsD;QAClD,IAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAI,CAACG,YAAnB,CAAL,EAAuC;UACnC,MAAM,IAAIlF,KAAJ,CAAU,+DAAV,CAAN;QACH;;QACD,MAAM6D,GAAG,GAAGrC,aAAa,CACrBoC,KADqB,EAErB,QAFqB,EAGrB,8BAHqB,EAIrBxC,eAJqB,EAKrBwC,KAAK,CAAC/B,GALe,CAAzB;QAQA,OAAO,IAAIvE,WAAJ,CACH,GAAG,KAAKsH,0BAAL,CAAgCG,IAAI,CAACG,YAArC,EAAmDrB,GAAnD,CADA,CAAP;MAGH;IACJ;;IAED,OAAO,IAAIvG,WAAJ,EAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACI2G,eAAe,CAACJ,GAAD,EAAM;IACjB,OAAO,KAAKE,oBAAL,CAA0BnD,cAAc,CAACiD,GAAG,CAAClF,QAAL,CAAxC,EAAwDkF,GAAxD,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EAC+B,CAA1Be,0BAA0B,CAACD,cAAD,EAAiBd,GAAjB,EAAsB;IAC7C,MAAMC,QAAQ,GAAG,KAAKqB,0BAAL,CACb;MAAER;IAAF,CADa,EAEbd,GAFa,CAAjB,CAD6C,CAM7C;;;IACA,KAAK,MAAMuB,OAAX,IAAsBtB,QAAtB,EAAgC;MAC5B,IAAIsB,OAAO,CAACC,aAAZ,EAA2B;QACvBD,OAAO,CAACC,aAAR,CAAsBC,KAAtB,GAA8B,IAA9B;MACH;;MACD,MAAMF,OAAN;IACH;EACJ;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIrB,oBAAoB,CAACL,UAAD,EAAaG,GAAb,EAAkB;IAClC,MAAM0B,SAAS,GAAG,IAAI7H,eAAJ,EAAlB;IAEA6H,SAAS,CAACC,oBAAV,CAA+B9B,UAA/B,EAA2CG,GAAG,CAAC5B,IAAJ,IAAY4B,GAAG,CAAClF,QAA3D;IACA,OAAO,KAAKwG,0BAAL,CAAgCzB,UAAhC,EAA4CG,GAA5C,CAAP;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EAC+B,CAA1BsB,0BAA0B,CAACzB,UAAD,EAAaG,GAAb,EAAkB;IACzC,MAAM;MAAE4B,KAAF;MAASC,aAAT;MAAwB,GAAGC;IAA3B,IAA0CjC,UAAhD;IACA,MAAMkC,QAAQ,GAAGnI,cAAc,CAACgG,MAAf,CACbgC,KADa,EAEbC,aAFa,EAGb7B,GAAG,CAAC9B,aAHS,CAAjB;;IAKA,MAAM+B,QAAQ,GAAG,KAAK+B,8BAAL,CAAoCF,UAApC,EAAgD9B,GAAhD,CAAjB,CAPyC,CASzC;;;IACA,KAAK,MAAMuB,OAAX,IAAsBtB,QAAtB,EAAgC;MAE5B;AACZ;AACA;AACA;AACA;MACYsB,OAAO,CAACQ,QAAR,GAAmBnI,cAAc,CAACqI,GAAf,CAAmBF,QAAnB,EAA6BR,OAAO,CAACQ,QAArC,CAAnB;MAEA;AACZ;AACA;AACA;;MACY,IAAIR,OAAO,CAACQ,QAAZ,EAAsB;QAClBR,OAAO,CAACW,IAAR,GAAe,KAAK,CAApB;MACH;;MAED,MAAMX,OAAN;IACH;EACJ;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACmC,CAA9BS,8BAA8B,QAiB3BhC,GAjB2B,EAkB7B;IAAA,IAjBE;MACImC,GADJ;MAEIC,OAAO,EAAEC,MAFb;MAGIC,OAHJ;MAIIxB,cAJJ;MAKIyB,cALJ;MAMIC,MAAM,EAAEC,UANZ;MAOIC,aAPJ;MAQIC,OAAO,EAAEC,UARb;MASIC,SATJ;MAUIC,6BAVJ;MAWIZ,IAXJ;MAYInD,KAZJ;MAaIgE,QAbJ;MAcIC,SAAS,EAAEC,YAAY,GAAG;IAd9B,CAiBF;IACE,MAAMC,UAAU,GAAG/B,KAAK,CAACC,OAAN,CAAciB,MAAd,IAAwBA,MAAxB,GAAiC,CAACA,MAAD,CAApD;IACA,MAAMb,aAAa,GAAGV,cAAc,IAAI,IAAInH,aAAJ,CACpCwH,KAAK,CAACC,OAAN,CAAcN,cAAd,IAAgCA,cAAhC,GAAiD,CAACA,cAAD,CADb,EAEpCd,GAAG,CAAC9B,aAFgC,CAAxC,CAFF,CAOE;;IACA,KAAK,MAAMiF,UAAX,IAAyBD,UAAU,CAAC1G,MAAX,CAAkB4G,OAAlB,CAAzB,EAAqD;MACjD,OAAO,KAAKC,YAAL,CAAkBF,UAAlB,EAA8BnD,GAA9B,CAAP;IACH,CAVH,CAYE;;;IACA,MAAMwC,MAAM,GAAGC,UAAU,IAAI,KAAKa,WAAL,CAAiBb,UAAjB,EAA6BzC,GAA7B,CAA7B;;IACA,MAAM2C,OAAO,GAAGC,UAAU,IAAI,KAAKW,YAAL,CAAkBX,UAAlB,EAA8B5C,GAA9B,CAA9B,CAdF,CAgBE;;;IACA,IAAI2C,OAAJ,EAAa;MACT,OAAO,KAAKa,4BAAL,CAAkCb,OAAlC,EAA2C3C,GAA3C,CAAP;IACH,CAnBH,CAqBE;;;IACA,MAAM;MAEF;MACAzB,IAAI,EAAEyB,GAAG,CAACzB,IAHR;MAIFH,IAAI,EAAE4B,GAAG,CAAC5B,IAJR;MAKFtD,QAAQ,EAAEkF,GAAG,CAAClF,QALZ;MAOF;MACAiH,QAAQ,EAAE,IARR;MASFI,GATE;MAUFG,OAVE;MAWFd,aAXE;MAYFe,cAZE;MAaFC,MAbE;MAcFE,aAdE;MAeFC,OAfE;MAgBFE,SAhBE;MAiBFC,6BAjBE;MAkBFZ,IAlBE;MAmBFnD,KAnBE;MAoBFgE;IApBE,CAAN,CAtBF,CA6CE;;IACA,KAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,YAAY,CAACS,MAAjC,EAAyC,EAAED,CAA3C,EAA8C;MAC1C,OAAO,KAAKnC,0BAAL,CACH2B,YAAY,CAACQ,CAAD,CADT,EAEH,EAAE,GAAGzD,GAAL;QAAU5B,IAAI,EAAG,GAAE4B,GAAG,CAAC5B,IAAK,cAAaqF,CAAE;MAA3C,CAFG,CAAP;IAIH;EACJ;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIJ,YAAY,CAACF,UAAD,EAAanD,GAAb,EAAkB;IAC1B5F,KAAK,CAAC,qCAAD,EAAwC+I,UAAxC,EAAoDnD,GAAG,CAAClF,QAAxD,CAAL;;IACA,IAAI;MACA,IAAIqI,UAAU,CAACxG,UAAX,CAAsB,SAAtB,CAAJ,EAAsC;QAClC,OAAO,KAAKgH,0BAAL,CAAgCR,UAAhC,EAA4CnD,GAA5C,CAAP;MACH;;MACD,IAAImD,UAAU,CAACxG,UAAX,CAAsB,SAAtB,CAAJ,EAAsC;QAClC,OAAO,KAAKiH,yBAAL,CAA+BT,UAA/B,EAA2CnD,GAA3C,CAAP;MACH;;MACD,OAAO,KAAK6D,4BAAL,CAAkCV,UAAlC,EAA8CnD,GAA9C,CAAP;IACH,CARD,CAQE,OAAOtC,KAAP,EAAc;MACZA,KAAK,CAACrC,OAAN,IAAkB,sBAAqB2E,GAAG,CAAClF,QAAJ,IAAgBkF,GAAG,CAAC5B,IAAK,EAAhE;MACA,MAAMV,KAAN;IACH;EACJ;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIiG,0BAA0B,CAACR,UAAD,EAAanD,GAAb,EAAkB;IACxC,MAAM;MACFR,aADE;MAEFC,kBAFE;MAGFC,qBAHE;MAIFC;IAJE,IAKFrF,gBAAgB,CAACqE,GAAjB,CAAqB,IAArB,CALJ;;IAOA,IAAIwE,UAAU,KAAK,oBAAnB,EAAyC;MACrC,MAAM/E,IAAI,GAAI,GAAE4B,GAAG,CAAC5B,IAAK,MAAK+E,UAAW,EAAzC;;MAEA,IAAIxD,0BAAJ,EAAgC;QAC5B,IAAI,OAAOA,0BAAP,KAAsC,UAA1C,EAAsD;UAClD,MAAM,IAAIxD,KAAJ,CAAW,6DAA4DwD,0BAA2B,GAAlG,CAAN;QACH;;QACD,OAAO,KAAKO,oBAAL,CAA0BP,0BAA0B,EAApD,EAAwD,EAAE,GAAGK,GAAL;UAAU5B,IAAV;UAAgBtD,QAAQ,EAAE;QAA1B,CAAxD,CAAP;MACH;;MACD,OAAO,KAAKsF,eAAL,CAAqB,EACxB,GAAGJ,GADqB;QAExB5B,IAFwB;QAGxBtD,QAAQ,EAAE4E;MAHc,CAArB,CAAP;IAKH;;IACD,IAAIyD,UAAU,KAAK,YAAnB,EAAiC;MAC7B,MAAM/E,IAAI,GAAI,GAAE4B,GAAG,CAAC5B,IAAK,MAAK+E,UAAW,EAAzC;;MAEA,IAAI1D,kBAAJ,EAAwB;QACpB,IAAI,OAAOA,kBAAP,KAA8B,UAAlC,EAA8C;UAC1C,MAAM,IAAItD,KAAJ,CAAW,qDAAoDsD,kBAAmB,GAAlF,CAAN;QACH;;QACD,OAAO,KAAKS,oBAAL,CAA0BT,kBAAkB,EAA5C,EAAgD,EAAE,GAAGO,GAAL;UAAU5B,IAAV;UAAgBtD,QAAQ,EAAE;QAA1B,CAAhD,CAAP;MACH;;MACD,OAAO,KAAKsF,eAAL,CAAqB,EACxB,GAAGJ,GADqB;QAExB5B,IAFwB;QAGxBtD,QAAQ,EAAE0E;MAHc,CAArB,CAAP;IAKH;;IAED,MAAM5C,kBAAkB,CAACuG,UAAD,EAAanD,GAAG,CAAC5B,IAAjB,EAAuB,uBAAvB,CAAxB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIwF,yBAAyB,CAACT,UAAD,EAAanD,GAAb,EAAkB;IACvC,MAAM8D,UAAU,GAAGX,UAAU,CAACY,WAAX,CAAuB,GAAvB,CAAnB;;IAEA,IAAID,UAAU,KAAK,CAAC,CAApB,EAAuB;MACnB,MAAMlH,kBAAkB,CAACuG,UAAD,EAAanD,GAAG,CAAClF,QAAjB,EAA2B,gBAA3B,CAAxB;IACH;;IAED,MAAMkJ,UAAU,GAAGb,UAAU,CAACc,KAAX,CAAiB,UAAUP,MAA3B,EAAmCI,UAAnC,CAAnB;IACA,MAAMjH,UAAU,GAAGsG,UAAU,CAACc,KAAX,CAAiBH,UAAU,GAAG,CAA9B,CAAnB;;IAEA,IAAIrJ,UAAU,CAACuJ,UAAD,CAAd,EAA4B;MACxB,MAAM,IAAI7H,KAAJ,CAAU,+CAAV,CAAN;IACH;;IAED,MAAMsC,MAAM,GAAG,KAAKyF,WAAL,CAAiBF,UAAjB,EAA6BhE,GAA7B,CAAf;;IACA,MAAMH,UAAU,GACZpB,MAAM,CAAC0F,UAAP,IACA1F,MAAM,CAAC0F,UAAP,CAAkBvF,OAAlB,CAA0B/B,UAA1B,CAFJ;;IAIA,IAAIgD,UAAJ,EAAgB;MACZ,OAAO,KAAKK,oBAAL,CAA0BL,UAA1B,EAAsC,EACzC,GAAGG,GADsC;QAEzClF,QAAQ,EAAE2D,MAAM,CAAC3D,QAAP,IAAmBkF,GAAG,CAAClF,QAFQ;QAGzCsD,IAAI,EAAG,GAAE4B,GAAG,CAAC5B,IAAK,aAAYK,MAAM,CAAC2F,EAAG,IAAGvH,UAAW;MAHb,CAAtC,CAAP;IAKH;;IAED,MAAM4B,MAAM,CAACf,KAAP,IAAgBd,kBAAkB,CAACuG,UAAD,EAAanD,GAAG,CAAClF,QAAjB,EAA2B,uBAA3B,CAAxC;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACI+I,4BAA4B,CAACV,UAAD,EAAanD,GAAb,EAAkB;IAC1C,MAAM;MAAEhC,GAAF;MAAOuB;IAAP,IAAoBjF,gBAAgB,CAACqE,GAAjB,CAAqB,IAArB,CAA1B;IACA,MAAMvB,UAAU,GAAG4C,GAAG,CAAClF,QAAJ,IAAgBvB,IAAI,CAACiH,IAAL,CAAUxC,GAAV,EAAe,oBAAf,CAAnC;IACA,IAAIb,OAAJ;;IAEA,IAAI1C,UAAU,CAAC0I,UAAD,CAAd,EAA4B;MACxBhG,OAAO,GAAGgG,UAAV;IACH,CAFD,MAEO,IAAIA,UAAU,CAACxG,UAAX,CAAsB,GAAtB,CAAJ,EAAgC;MACnCQ,OAAO,GAAI,KAAIgG,UAAW,EAA1B,CADmC,CACN;IAChC,CAFM,MAEA;MACHhG,OAAO,GAAGrD,MAAM,CAACuK,oBAAP,CACNlB,UADM,EAEN,eAFM,CAAV;IAIH;;IAED,IAAIrI,QAAJ;;IAEA,IAAI;MACAA,QAAQ,GAAGyE,QAAQ,CAAC/B,OAAT,CAAiBL,OAAjB,EAA0BC,UAA1B,CAAX;IACH,CAFD,CAEE,OAAOM,KAAP,EAAc;MACZ;MACA,IAAIA,KAAK,IAAIA,KAAK,CAACtB,IAAN,KAAe,kBAA5B,EAAgD;QAC5C,MAAMQ,kBAAkB,CAACuG,UAAD,EAAanD,GAAG,CAAClF,QAAjB,EAA2B,uBAA3B,CAAxB;MACH;;MACD,MAAM4C,KAAN;IACH;;IAEDR,uBAAuB,CAACC,OAAD,EAAUC,UAAV,EAAsBtC,QAAtB,CAAvB;IACA,OAAO,KAAKsF,eAAL,CAAqB,EACxB,GAAGJ,GADqB;MAExBlF,QAFwB;MAGxBsD,IAAI,EAAG,GAAE4B,GAAG,CAAC5B,IAAK,MAAKjB,OAAQ;IAHP,CAArB,CAAP;EAKH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIoG,YAAY,CAACe,KAAD,EAAQtE,GAAR,EAAa;IACrB,OAAOsE,KAAK,CAACC,MAAN,CAAa,CAACC,GAAD,EAAMpG,IAAN,KAAe;MAC/B,IAAI3D,UAAU,CAAC2D,IAAD,CAAd,EAAsB;QAClB,MAAM,IAAIjC,KAAJ,CAAU,2CAAV,CAAN;MACH;;MACD,MAAMsC,MAAM,GAAG,KAAKyF,WAAL,CAAiB9F,IAAjB,EAAuB4B,GAAvB,CAAf;;MAEAwE,GAAG,CAAC/F,MAAM,CAAC2F,EAAR,CAAH,GAAiB3F,MAAjB;MAEA,OAAO+F,GAAP;IACH,CATM,EASJ,EATI,CAAP;EAUH;EAED;AACJ;AACA;AACA;AACA;AACA;;;EACIlB,WAAW,CAAC5I,UAAD,EAAasF,GAAb,EAAkB;IACzB5F,KAAK,CAAC,2BAAD,EAA8BM,UAA9B,EAA0CsF,GAAG,CAAClF,QAA9C,CAAL;IAEA,MAAM;MAAEkD,GAAF;MAAOuB;IAAP,IAAoBjF,gBAAgB,CAACqE,GAAjB,CAAqB,IAArB,CAA1B;IACA,MAAMvB,UAAU,GAAG4C,GAAG,CAAClF,QAAJ,IAAgBvB,IAAI,CAACiH,IAAL,CAAUxC,GAAV,EAAe,oBAAf,CAAnC;;IAEA,IAAI;MACA,MAAMlD,QAAQ,GAAGyE,QAAQ,CAAC/B,OAAT,CAAiB9C,UAAjB,EAA6B0C,UAA7B,CAAjB;MAEAF,uBAAuB,CAACxC,UAAD,EAAa0C,UAAb,EAAyBtC,QAAzB,CAAvB;MAEA,OAAO,IAAIpB,gBAAJ,CAAqB;QACxByK,UAAU,EAAEnK,OAAO,CAACc,QAAD,CADK;QAExBA,QAFwB;QAGxBsJ,EAAE,EAAE1J,UAHoB;QAIxBoC,YAAY,EAAEkD,GAAG,CAAC5B,IAJM;QAKxBqG,YAAY,EAAEzE,GAAG,CAAClF;MALM,CAArB,CAAP;IAOH,CAZD,CAYE,OAAO4C,KAAP,EAAc;MAEZ;MACA,IAAIhD,UAAU,KAAK,QAAnB,EAA6B;QACzBN,KAAK,CAAC,kBAAD,CAAL;QACA,OAAO,IAAIV,gBAAJ,CAAqB;UACxByK,UAAU,EAAEnK,OAAO,CAAC,QAAD,CADK;UAExBc,QAAQ,EAAEd,OAAO,CAACwD,OAAR,CAAgB,QAAhB,CAFc;UAGxB4G,EAAE,EAAE1J,UAHoB;UAIxBoC,YAAY,EAAEkD,GAAG,CAAC5B,IAJM;UAKxBqG,YAAY,EAAEzE,GAAG,CAAClF;QALM,CAArB,CAAP;MAOH;;MAEDV,KAAK,CAAC,8CAAD,EAAiDM,UAAjD,EAA6DsF,GAAG,CAAC5B,IAAjE,CAAL;MACAV,KAAK,CAACrC,OAAN,GAAiB,0BAAyBX,UAAW,kBAAiBsF,GAAG,CAAC5B,IAAK,MAAKV,KAAK,CAACrC,OAAQ,EAAlG;MAEA,OAAO,IAAI3B,gBAAJ,CAAqB;QACxBgE,KADwB;QAExB0G,EAAE,EAAE1J,UAFoB;QAGxBoC,YAAY,EAAEkD,GAAG,CAAC5B,IAHM;QAIxBqG,YAAY,EAAEzE,GAAG,CAAClF;MAJM,CAArB,CAAP;IAMH;EACJ;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACIoJ,WAAW,CAAC9F,IAAD,EAAO4B,GAAP,EAAY;IACnB5F,KAAK,CAAC,2BAAD,EAA8BgE,IAA9B,EAAoC4B,GAAG,CAAClF,QAAxC,CAAL;IAEA,MAAM;MAAEqE,oBAAF;MAAwBI;IAAxB,IAAqCjF,gBAAgB,CAACqE,GAAjB,CAAqB,IAArB,CAA3C;IACA,MAAMxB,OAAO,GAAGrD,MAAM,CAACuK,oBAAP,CAA4BjG,IAA5B,EAAkC,eAAlC,CAAhB;IACA,MAAMgG,EAAE,GAAGtK,MAAM,CAAC4K,gBAAP,CAAwBvH,OAAxB,EAAiC,eAAjC,CAAX;IACA,MAAMC,UAAU,GAAG7D,IAAI,CAACiH,IAAL,CAAUR,GAAG,CAAC1B,cAAd,EAA8B,oBAA9B,CAAnB;;IAEA,IAAIF,IAAI,CAACuG,KAAL,CAAW,MAAX,CAAJ,EAAwB;MACpB,MAAMjH,KAAK,GAAG3B,MAAM,CAACG,MAAP,CACV,IAAIC,KAAJ,CAAW,oCAAmCiC,IAAK,GAAnD,CADU,EAEV;QACI3C,eAAe,EAAE,kBADrB;QAEIC,WAAW,EAAE;UAAEsI,UAAU,EAAE7G;QAAd;MAFjB,CAFU,CAAd;MAQA,OAAO,IAAIzD,gBAAJ,CAAqB;QACxBgE,KADwB;QAExB0G,EAFwB;QAGxBtH,YAAY,EAAEkD,GAAG,CAAC5B,IAHM;QAIxBqG,YAAY,EAAEzE,GAAG,CAAClF;MAJM,CAArB,CAAP;IAMH,CAvBkB,CAyBnB;;;IACA,MAAM2D,MAAM,GACRU,oBAAoB,CAACR,GAArB,CAAyBxB,OAAzB,KACAgC,oBAAoB,CAACR,GAArB,CAAyByF,EAAzB,CAFJ;;IAIA,IAAI3F,MAAJ,EAAY;MACR,OAAO,IAAI/E,gBAAJ,CAAqB;QACxByK,UAAU,EAAE3F,eAAe,CAACC,MAAD,CADH;QAExB3D,QAAQ,EAAE,EAFc;QAEV;QACdsJ,EAHwB;QAIxBtH,YAAY,EAAEkD,GAAG,CAAC5B,IAJM;QAKxBqG,YAAY,EAAEzE,GAAG,CAAClF;MALM,CAArB,CAAP;IAOH;;IAED,IAAIA,QAAJ;IACA,IAAI4C,KAAJ;;IAEA,IAAI;MACA5C,QAAQ,GAAGyE,QAAQ,CAAC/B,OAAT,CAAiBL,OAAjB,EAA0BC,UAA1B,CAAX;IACH,CAFD,CAEE,OAAOwH,YAAP,EAAqB;MACnBlH,KAAK,GAAGkH,YAAR;MACA;;MACA,IAAIlH,KAAK,IAAIA,KAAK,CAACtB,IAAN,KAAe,kBAA5B,EAAgD;QAC5CsB,KAAK,CAACjC,eAAN,GAAwB,gBAAxB;QACAiC,KAAK,CAAChC,WAAN,GAAoB;UAChBsI,UAAU,EAAE7G,OADI;UAEhBc,wBAAwB,EAAE+B,GAAG,CAAC1B,cAFd;UAGhBxB,YAAY,EAAEkD,GAAG,CAAC5B;QAHF,CAApB;MAKH;IACJ;;IAED,IAAItD,QAAJ,EAAc;MACV,IAAI;QACAoC,uBAAuB,CAACC,OAAD,EAAUC,UAAV,EAAsBtC,QAAtB,CAAvB;QAEA,MAAM+J,SAAS,GAAGC,IAAI,CAACC,GAAL,EAAlB;;QACA,MAAMC,gBAAgB,GAAGhL,OAAO,CAACc,QAAD,CAAhC;;QAEAV,KAAK,CAAE,UAASU,QAAS,eAAcgK,IAAI,CAACC,GAAL,KAAaF,SAAU,IAAzD,CAAL;QAEA,OAAO,IAAInL,gBAAJ,CAAqB;UACxByK,UAAU,EAAE3F,eAAe,CAACwG,gBAAD,CADH;UAExBlK,QAFwB;UAGxBsJ,EAHwB;UAIxBtH,YAAY,EAAEkD,GAAG,CAAC5B,IAJM;UAKxBqG,YAAY,EAAEzE,GAAG,CAAClF;QALM,CAArB,CAAP;MAOH,CAfD,CAeE,OAAOmK,SAAP,EAAkB;QAChBvH,KAAK,GAAGuH,SAAR;MACH;IACJ;;IAED7K,KAAK,CAAC,8CAAD,EAAiDgE,IAAjD,EAAuD4B,GAAG,CAAC5B,IAA3D,CAAL;IACAV,KAAK,CAACrC,OAAN,GAAiB,0BAAyB+C,IAAK,kBAAiB4B,GAAG,CAAC5B,IAAK,MAAKV,KAAK,CAACrC,OAAQ,EAA5F;IACA,OAAO,IAAI3B,gBAAJ,CAAqB;MACxBgE,KADwB;MAExB0G,EAFwB;MAGxBtH,YAAY,EAAEkD,GAAG,CAAC5B,IAHM;MAIxBqG,YAAY,EAAEzE,GAAG,CAAClF;IAJM,CAArB,CAAP;EAMH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;EACiC,CAA5B0I,4BAA4B,CAACb,OAAD,EAAU3C,GAAV,EAAe;IACxC,KAAK,MAAMkF,QAAX,IAAuBnJ,MAAM,CAACoJ,IAAP,CAAYxC,OAAZ,CAAvB,EAA6C;MACzC,MAAM7D,UAAU,GACZ6D,OAAO,CAACuC,QAAD,CAAP,IACAvC,OAAO,CAACuC,QAAD,CAAP,CAAkBf,UADlB,IAEAxB,OAAO,CAACuC,QAAD,CAAP,CAAkBf,UAAlB,CAA6BrF,UAHjC;;MAKA,IAAI,CAACA,UAAL,EAAiB;QACb;MACH;;MAED,KAAK,MAAMsG,WAAX,IAA0BrJ,MAAM,CAACoJ,IAAP,CAAYrG,UAAZ,CAA1B,EAAmD;QAC/C,IAAIsG,WAAW,CAACzI,UAAZ,CAAuB,GAAvB,CAAJ,EAAiC;UAC7B,OAAO,KAAK2E,0BAAL,CACH;YACIM,KAAK,EAAE,CAAE,IAAGwD,WAAY,EAAjB,CADX;YAEIvC,SAAS,EAAG,GAAEqC,QAAS,IAAGE,WAAY;UAF1C,CADG,EAKH,EACI,GAAGpF,GADP;YAEIzB,IAAI,EAAE,oBAFV;YAGIH,IAAI,EAAG,GAAE4B,GAAG,CAAC5B,IAAK,gBAAe8G,QAAS,IAAGE,WAAY;UAH7D,CALG,CAAP;QAWH;MACJ;IACJ;EACJ;;AAnsBoB;;AAssBzB,SAASnG,kBAAT,EAA6BtB,aAA7B"},"metadata":{},"sourceType":"module"}