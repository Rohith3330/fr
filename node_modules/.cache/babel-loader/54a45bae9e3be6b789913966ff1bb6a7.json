{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst isBooleanLiteral = node => node.type === _experimentalUtils.AST_NODE_TYPES.Literal && typeof node.value === 'boolean';\n/**\n * Checks if the given `ParsedExpectMatcher` is a call to one of the equality matchers,\n * with a boolean literal as the sole argument.\n *\n * @example javascript\n * toBe(true);\n * toEqual(false);\n *\n * @param {ParsedExpectMatcher} matcher\n *\n * @return {matcher is ParsedBooleanEqualityMatcher}\n */\n\n\nconst isBooleanEqualityMatcher = matcher => (0, _utils.isParsedEqualityMatcherCall)(matcher) && isBooleanLiteral((0, _utils.followTypeAssertionChain)(matcher.arguments[0]));\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Suggest using the built-in equality matchers',\n      recommended: false,\n      suggestion: true\n    },\n    messages: {\n      useEqualityMatcher: 'Prefer using one of the equality matchers instead',\n      suggestEqualityMatcher: 'Use `{{ equalityMatcher }}`'\n    },\n    hasSuggestions: true,\n    type: 'suggestion',\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        if (!(0, _utils.isExpectCall)(node)) {\n          return;\n        }\n\n        const {\n          expect: {\n            arguments: [comparison],\n            range: [, expectCallEnd]\n          },\n          matcher,\n          modifier\n        } = (0, _utils.parseExpectCall)(node);\n\n        if (!matcher || (comparison === null || comparison === void 0 ? void 0 : comparison.type) !== _experimentalUtils.AST_NODE_TYPES.BinaryExpression || comparison.operator !== '===' && comparison.operator !== '!==' || !isBooleanEqualityMatcher(matcher)) {\n          return;\n        }\n\n        const matcherValue = (0, _utils.followTypeAssertionChain)(matcher.arguments[0]).value; // we need to negate the expectation if the current expected\n        // value is itself negated by the \"not\" modifier\n\n        const addNotModifier = (comparison.operator === '!==' ? !matcherValue : matcherValue) === !!modifier;\n\n        const buildFixer = equalityMatcher => fixer => {\n          const sourceCode = context.getSourceCode();\n          return [// replace the comparison argument with the left-hand side of the comparison\n          fixer.replaceText(comparison, sourceCode.getText(comparison.left)), // replace the current matcher & modifier with the preferred matcher\n          fixer.replaceTextRange([expectCallEnd, matcher.node.range[1]], addNotModifier ? `.${_utils.ModifierName.not}.${equalityMatcher}` : `.${equalityMatcher}`), // replace the matcher argument with the right-hand side of the comparison\n          fixer.replaceText(matcher.arguments[0], sourceCode.getText(comparison.right))];\n        };\n\n        context.report({\n          messageId: 'useEqualityMatcher',\n          suggest: ['toBe', 'toEqual', 'toStrictEqual'].map(equalityMatcher => ({\n            messageId: 'suggestEqualityMatcher',\n            data: {\n              equalityMatcher\n            },\n            fix: buildFixer(equalityMatcher)\n          })),\n          node: (modifier || matcher).node.property\n        });\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_experimentalUtils","require","_utils","isBooleanLiteral","node","type","AST_NODE_TYPES","Literal","isBooleanEqualityMatcher","matcher","isParsedEqualityMatcherCall","followTypeAssertionChain","arguments","_default","createRule","name","__filename","meta","docs","category","description","recommended","suggestion","messages","useEqualityMatcher","suggestEqualityMatcher","hasSuggestions","schema","defaultOptions","create","context","CallExpression","isExpectCall","expect","comparison","range","expectCallEnd","modifier","parseExpectCall","BinaryExpression","operator","matcherValue","addNotModifier","buildFixer","equalityMatcher","fixer","sourceCode","getSourceCode","replaceText","getText","left","replaceTextRange","ModifierName","not","right","report","messageId","suggest","map","data","fix","property"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-jest/lib/rules/prefer-equality-matcher.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst isBooleanLiteral = node => node.type === _experimentalUtils.AST_NODE_TYPES.Literal && typeof node.value === 'boolean';\n\n/**\n * Checks if the given `ParsedExpectMatcher` is a call to one of the equality matchers,\n * with a boolean literal as the sole argument.\n *\n * @example javascript\n * toBe(true);\n * toEqual(false);\n *\n * @param {ParsedExpectMatcher} matcher\n *\n * @return {matcher is ParsedBooleanEqualityMatcher}\n */\nconst isBooleanEqualityMatcher = matcher => (0, _utils.isParsedEqualityMatcherCall)(matcher) && isBooleanLiteral((0, _utils.followTypeAssertionChain)(matcher.arguments[0]));\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Suggest using the built-in equality matchers',\n      recommended: false,\n      suggestion: true\n    },\n    messages: {\n      useEqualityMatcher: 'Prefer using one of the equality matchers instead',\n      suggestEqualityMatcher: 'Use `{{ equalityMatcher }}`'\n    },\n    hasSuggestions: true,\n    type: 'suggestion',\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        if (!(0, _utils.isExpectCall)(node)) {\n          return;\n        }\n\n        const {\n          expect: {\n            arguments: [comparison],\n            range: [, expectCallEnd]\n          },\n          matcher,\n          modifier\n        } = (0, _utils.parseExpectCall)(node);\n\n        if (!matcher || (comparison === null || comparison === void 0 ? void 0 : comparison.type) !== _experimentalUtils.AST_NODE_TYPES.BinaryExpression || comparison.operator !== '===' && comparison.operator !== '!==' || !isBooleanEqualityMatcher(matcher)) {\n          return;\n        }\n\n        const matcherValue = (0, _utils.followTypeAssertionChain)(matcher.arguments[0]).value; // we need to negate the expectation if the current expected\n        // value is itself negated by the \"not\" modifier\n\n        const addNotModifier = (comparison.operator === '!==' ? !matcherValue : matcherValue) === !!modifier;\n\n        const buildFixer = equalityMatcher => fixer => {\n          const sourceCode = context.getSourceCode();\n          return [// replace the comparison argument with the left-hand side of the comparison\n          fixer.replaceText(comparison, sourceCode.getText(comparison.left)), // replace the current matcher & modifier with the preferred matcher\n          fixer.replaceTextRange([expectCallEnd, matcher.node.range[1]], addNotModifier ? `.${_utils.ModifierName.not}.${equalityMatcher}` : `.${equalityMatcher}`), // replace the matcher argument with the right-hand side of the comparison\n          fixer.replaceText(matcher.arguments[0], sourceCode.getText(comparison.right))];\n        };\n\n        context.report({\n          messageId: 'useEqualityMatcher',\n          suggest: ['toBe', 'toEqual', 'toStrictEqual'].map(equalityMatcher => ({\n            messageId: 'suggestEqualityMatcher',\n            data: {\n              equalityMatcher\n            },\n            fix: buildFixer(equalityMatcher)\n          })),\n          node: (modifier || matcher).node.property\n        });\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}