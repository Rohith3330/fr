{"ast":null,"code":"/**\n * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.\n * @author Kai Cataldo\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Disallow renaming import, export, and destructured assignments to the same name\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-rename\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreImport: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreExport: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unnecessarilyRenamed: \"{{type}} {{name}} unnecessarily renamed.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(),\n          options = context.options[0] || {},\n          ignoreDestructuring = options.ignoreDestructuring === true,\n          ignoreImport = options.ignoreImport === true,\n          ignoreExport = options.ignoreExport === true; //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Reports error for unnecessarily renamed assignments\n     * @param {ASTNode} node node to report\n     * @param {ASTNode} initial node with initial name value\n     * @param {string} type the type of the offending node\n     * @returns {void}\n     */\n\n    function reportError(node, initial, type) {\n      const name = initial.type === \"Identifier\" ? initial.name : initial.value;\n      return context.report({\n        node,\n        messageId: \"unnecessarilyRenamed\",\n        data: {\n          name,\n          type\n        },\n\n        fix(fixer) {\n          const replacementNode = node.type === \"Property\" ? node.value : node.local;\n\n          if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(replacementNode).length) {\n            return null;\n          } // Don't autofix code such as `({foo: (foo) = a} = obj);`, parens are not allowed in shorthand properties.\n\n\n          if (replacementNode.type === \"AssignmentPattern\" && astUtils.isParenthesised(sourceCode, replacementNode.left)) {\n            return null;\n          }\n\n          return fixer.replaceText(node, sourceCode.getText(replacementNode));\n        }\n\n      });\n    }\n    /**\n     * Checks whether a destructured assignment is unnecessarily renamed\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n\n\n    function checkDestructured(node) {\n      if (ignoreDestructuring) {\n        return;\n      }\n\n      for (const property of node.properties) {\n        /**\n         * Properties using shorthand syntax and rest elements can not be renamed.\n         * If the property is computed, we have no idea if a rename is useless or not.\n         */\n        if (property.type !== \"Property\" || property.shorthand || property.computed) {\n          continue;\n        }\n\n        const key = property.key.type === \"Identifier\" && property.key.name || property.key.type === \"Literal\" && property.key.value;\n        const renamedKey = property.value.type === \"AssignmentPattern\" ? property.value.left.name : property.value.name;\n\n        if (key === renamedKey) {\n          reportError(property, property.key, \"Destructuring assignment\");\n        }\n      }\n    }\n    /**\n     * Checks whether an import is unnecessarily renamed\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n\n\n    function checkImport(node) {\n      if (ignoreImport) {\n        return;\n      }\n\n      if (node.imported.range[0] !== node.local.range[0] && astUtils.getModuleExportName(node.imported) === node.local.name) {\n        reportError(node, node.imported, \"Import\");\n      }\n    }\n    /**\n     * Checks whether an export is unnecessarily renamed\n     * @param {ASTNode} node node to check\n     * @returns {void}\n     */\n\n\n    function checkExport(node) {\n      if (ignoreExport) {\n        return;\n      }\n\n      if (node.local.range[0] !== node.exported.range[0] && astUtils.getModuleExportName(node.local) === astUtils.getModuleExportName(node.exported)) {\n        reportError(node, node.local, \"Export\");\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      ObjectPattern: checkDestructured,\n      ImportSpecifier: checkImport,\n      ExportSpecifier: checkExport\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","properties","ignoreDestructuring","default","ignoreImport","ignoreExport","additionalProperties","messages","unnecessarilyRenamed","create","context","sourceCode","getSourceCode","options","reportError","node","initial","name","value","report","messageId","data","fix","fixer","replacementNode","local","getCommentsInside","length","isParenthesised","left","replaceText","getText","checkDestructured","property","shorthand","computed","key","renamedKey","checkImport","imported","range","getModuleExportName","checkExport","exported","ObjectPattern","ImportSpecifier","ExportSpecifier"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/no-useless-rename.js"],"sourcesContent":["/**\n * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.\n * @author Kai Cataldo\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Disallow renaming import, export, and destructured assignments to the same name\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-useless-rename\"\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreDestructuring: { type: \"boolean\", default: false },\n                    ignoreImport: { type: \"boolean\", default: false },\n                    ignoreExport: { type: \"boolean\", default: false }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            unnecessarilyRenamed: \"{{type}} {{name}} unnecessarily renamed.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode(),\n            options = context.options[0] || {},\n            ignoreDestructuring = options.ignoreDestructuring === true,\n            ignoreImport = options.ignoreImport === true,\n            ignoreExport = options.ignoreExport === true;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Reports error for unnecessarily renamed assignments\n         * @param {ASTNode} node node to report\n         * @param {ASTNode} initial node with initial name value\n         * @param {string} type the type of the offending node\n         * @returns {void}\n         */\n        function reportError(node, initial, type) {\n            const name = initial.type === \"Identifier\" ? initial.name : initial.value;\n\n            return context.report({\n                node,\n                messageId: \"unnecessarilyRenamed\",\n                data: {\n                    name,\n                    type\n                },\n                fix(fixer) {\n                    const replacementNode = node.type === \"Property\" ? node.value : node.local;\n\n                    if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(replacementNode).length) {\n                        return null;\n                    }\n\n                    // Don't autofix code such as `({foo: (foo) = a} = obj);`, parens are not allowed in shorthand properties.\n                    if (\n                        replacementNode.type === \"AssignmentPattern\" &&\n                        astUtils.isParenthesised(sourceCode, replacementNode.left)\n                    ) {\n                        return null;\n                    }\n\n                    return fixer.replaceText(node, sourceCode.getText(replacementNode));\n                }\n            });\n        }\n\n        /**\n         * Checks whether a destructured assignment is unnecessarily renamed\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkDestructured(node) {\n            if (ignoreDestructuring) {\n                return;\n            }\n\n            for (const property of node.properties) {\n\n                /**\n                 * Properties using shorthand syntax and rest elements can not be renamed.\n                 * If the property is computed, we have no idea if a rename is useless or not.\n                 */\n                if (property.type !== \"Property\" || property.shorthand || property.computed) {\n                    continue;\n                }\n\n                const key = (property.key.type === \"Identifier\" && property.key.name) || (property.key.type === \"Literal\" && property.key.value);\n                const renamedKey = property.value.type === \"AssignmentPattern\" ? property.value.left.name : property.value.name;\n\n                if (key === renamedKey) {\n                    reportError(property, property.key, \"Destructuring assignment\");\n                }\n            }\n        }\n\n        /**\n         * Checks whether an import is unnecessarily renamed\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkImport(node) {\n            if (ignoreImport) {\n                return;\n            }\n\n            if (\n                node.imported.range[0] !== node.local.range[0] &&\n                astUtils.getModuleExportName(node.imported) === node.local.name\n            ) {\n                reportError(node, node.imported, \"Import\");\n            }\n        }\n\n        /**\n         * Checks whether an export is unnecessarily renamed\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function checkExport(node) {\n            if (ignoreExport) {\n                return;\n            }\n\n            if (\n                node.local.range[0] !== node.exported.range[0] &&\n                astUtils.getModuleExportName(node.local) === astUtils.getModuleExportName(node.exported)\n            ) {\n                reportError(node, node.local, \"Export\");\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ObjectPattern: checkDestructured,\n            ImportSpecifier: checkImport,\n            ExportSpecifier: checkExport\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}