{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _minimatch = require('minimatch');\n\nvar _minimatch2 = _interopRequireDefault(_minimatch);\n\nvar _importType = require('../core/importType');\n\nvar _importType2 = _interopRequireDefault(_importType);\n\nvar _staticRequire = require('../core/staticRequire');\n\nvar _staticRequire2 = _interopRequireDefault(_staticRequire);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar defaultGroups = ['builtin', 'external', 'parent', 'sibling', 'index']; // REPORTING AND FIXING\n\nfunction reverse(array) {\n  return array.map(function (v) {\n    return Object.assign({}, v, {\n      rank: -v.rank\n    });\n  }).reverse();\n}\n\nfunction getTokensOrCommentsAfter(sourceCode, node, count) {\n  var currentNodeOrToken = node;\n  var result = [];\n\n  for (var i = 0; i < count; i++) {\n    currentNodeOrToken = sourceCode.getTokenOrCommentAfter(currentNodeOrToken);\n\n    if (currentNodeOrToken == null) {\n      break;\n    }\n\n    result.push(currentNodeOrToken);\n  }\n\n  return result;\n}\n\nfunction getTokensOrCommentsBefore(sourceCode, node, count) {\n  var currentNodeOrToken = node;\n  var result = [];\n\n  for (var i = 0; i < count; i++) {\n    currentNodeOrToken = sourceCode.getTokenOrCommentBefore(currentNodeOrToken);\n\n    if (currentNodeOrToken == null) {\n      break;\n    }\n\n    result.push(currentNodeOrToken);\n  }\n\n  return result.reverse();\n}\n\nfunction takeTokensAfterWhile(sourceCode, node, condition) {\n  var tokens = getTokensOrCommentsAfter(sourceCode, node, 100);\n  var result = [];\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (condition(tokens[i])) {\n      result.push(tokens[i]);\n    } else {\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction takeTokensBeforeWhile(sourceCode, node, condition) {\n  var tokens = getTokensOrCommentsBefore(sourceCode, node, 100);\n  var result = [];\n\n  for (var i = tokens.length - 1; i >= 0; i--) {\n    if (condition(tokens[i])) {\n      result.push(tokens[i]);\n    } else {\n      break;\n    }\n  }\n\n  return result.reverse();\n}\n\nfunction findOutOfOrder(imported) {\n  if (imported.length === 0) {\n    return [];\n  }\n\n  var maxSeenRankNode = imported[0];\n  return imported.filter(function (importedModule) {\n    var res = importedModule.rank < maxSeenRankNode.rank;\n\n    if (maxSeenRankNode.rank < importedModule.rank) {\n      maxSeenRankNode = importedModule;\n    }\n\n    return res;\n  });\n}\n\nfunction findRootNode(node) {\n  var parent = node;\n\n  while (parent.parent != null && parent.parent.body == null) {\n    parent = parent.parent;\n  }\n\n  return parent;\n}\n\nfunction findEndOfLineWithComments(sourceCode, node) {\n  var tokensToEndOfLine = takeTokensAfterWhile(sourceCode, node, commentOnSameLineAs(node));\n  var endOfTokens = tokensToEndOfLine.length > 0 ? tokensToEndOfLine[tokensToEndOfLine.length - 1].range[1] : node.range[1];\n  var result = endOfTokens;\n\n  for (var i = endOfTokens; i < sourceCode.text.length; i++) {\n    if (sourceCode.text[i] === '\\n') {\n      result = i + 1;\n      break;\n    }\n\n    if (sourceCode.text[i] !== ' ' && sourceCode.text[i] !== '\\t' && sourceCode.text[i] !== '\\r') {\n      break;\n    }\n\n    result = i + 1;\n  }\n\n  return result;\n}\n\nfunction commentOnSameLineAs(node) {\n  return function (token) {\n    return (token.type === 'Block' || token.type === 'Line') && token.loc.start.line === token.loc.end.line && token.loc.end.line === node.loc.end.line;\n  };\n}\n\nfunction findStartOfLineWithComments(sourceCode, node) {\n  var tokensToEndOfLine = takeTokensBeforeWhile(sourceCode, node, commentOnSameLineAs(node));\n  var startOfTokens = tokensToEndOfLine.length > 0 ? tokensToEndOfLine[0].range[0] : node.range[0];\n  var result = startOfTokens;\n\n  for (var i = startOfTokens - 1; i > 0; i--) {\n    if (sourceCode.text[i] !== ' ' && sourceCode.text[i] !== '\\t') {\n      break;\n    }\n\n    result = i;\n  }\n\n  return result;\n}\n\nfunction isPlainRequireModule(node) {\n  if (node.type !== 'VariableDeclaration') {\n    return false;\n  }\n\n  if (node.declarations.length !== 1) {\n    return false;\n  }\n\n  var decl = node.declarations[0];\n  var result = decl.id && (decl.id.type === 'Identifier' || decl.id.type === 'ObjectPattern') && decl.init != null && decl.init.type === 'CallExpression' && decl.init.callee != null && decl.init.callee.name === 'require' && decl.init.arguments != null && decl.init.arguments.length === 1 && decl.init.arguments[0].type === 'Literal';\n  return result;\n}\n\nfunction isPlainImportModule(node) {\n  return node.type === 'ImportDeclaration' && node.specifiers != null && node.specifiers.length > 0;\n}\n\nfunction isPlainImportEquals(node) {\n  return node.type === 'TSImportEqualsDeclaration' && node.moduleReference.expression;\n}\n\nfunction canCrossNodeWhileReorder(node) {\n  return isPlainRequireModule(node) || isPlainImportModule(node) || isPlainImportEquals(node);\n}\n\nfunction canReorderItems(firstNode, secondNode) {\n  var parent = firstNode.parent;\n\n  var _sort = [parent.body.indexOf(firstNode), parent.body.indexOf(secondNode)].sort(),\n      _sort2 = _slicedToArray(_sort, 2),\n      firstIndex = _sort2[0],\n      secondIndex = _sort2[1];\n\n  var nodesBetween = parent.body.slice(firstIndex, secondIndex + 1);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = nodesBetween[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var nodeBetween = _step.value;\n\n      if (!canCrossNodeWhileReorder(nodeBetween)) {\n        return false;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator['return']) {\n        _iterator['return']();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction fixOutOfOrder(context, firstNode, secondNode, order) {\n  var sourceCode = context.getSourceCode();\n  var firstRoot = findRootNode(firstNode.node);\n  var firstRootStart = findStartOfLineWithComments(sourceCode, firstRoot);\n  var firstRootEnd = findEndOfLineWithComments(sourceCode, firstRoot);\n  var secondRoot = findRootNode(secondNode.node);\n  var secondRootStart = findStartOfLineWithComments(sourceCode, secondRoot);\n  var secondRootEnd = findEndOfLineWithComments(sourceCode, secondRoot);\n  var canFix = canReorderItems(firstRoot, secondRoot);\n  var newCode = sourceCode.text.substring(secondRootStart, secondRootEnd);\n\n  if (newCode[newCode.length - 1] !== '\\n') {\n    newCode = newCode + '\\n';\n  }\n\n  var message = '`' + String(secondNode.displayName) + '` import should occur ' + String(order) + ' import of `' + String(firstNode.displayName) + '`';\n\n  if (order === 'before') {\n    context.report({\n      node: secondNode.node,\n      message: message,\n      fix: canFix && function (fixer) {\n        return fixer.replaceTextRange([firstRootStart, secondRootEnd], newCode + sourceCode.text.substring(firstRootStart, secondRootStart));\n      }\n    });\n  } else if (order === 'after') {\n    context.report({\n      node: secondNode.node,\n      message: message,\n      fix: canFix && function (fixer) {\n        return fixer.replaceTextRange([secondRootStart, firstRootEnd], sourceCode.text.substring(secondRootEnd, firstRootEnd) + newCode);\n      }\n    });\n  }\n}\n\nfunction reportOutOfOrder(context, imported, outOfOrder, order) {\n  outOfOrder.forEach(function (imp) {\n    var found = imported.find(function () {\n      function hasHigherRank(importedItem) {\n        return importedItem.rank > imp.rank;\n      }\n\n      return hasHigherRank;\n    }());\n    fixOutOfOrder(context, found, imp, order);\n  });\n}\n\nfunction makeOutOfOrderReport(context, imported) {\n  var outOfOrder = findOutOfOrder(imported);\n\n  if (!outOfOrder.length) {\n    return;\n  } // There are things to report. Try to minimize the number of reported errors.\n\n\n  var reversedImported = reverse(imported);\n  var reversedOrder = findOutOfOrder(reversedImported);\n\n  if (reversedOrder.length < outOfOrder.length) {\n    reportOutOfOrder(context, reversedImported, reversedOrder, 'after');\n    return;\n  }\n\n  reportOutOfOrder(context, imported, outOfOrder, 'before');\n}\n\nfunction getSorter(ascending) {\n  var multiplier = ascending ? 1 : -1;\n  return function () {\n    function importsSorter(importA, importB) {\n      var result = void 0;\n\n      if (importA < importB) {\n        result = -1;\n      } else if (importA > importB) {\n        result = 1;\n      } else {\n        result = 0;\n      }\n\n      return result * multiplier;\n    }\n\n    return importsSorter;\n  }();\n}\n\nfunction mutateRanksToAlphabetize(imported, alphabetizeOptions) {\n  var groupedByRanks = imported.reduce(function (acc, importedItem) {\n    if (!Array.isArray(acc[importedItem.rank])) {\n      acc[importedItem.rank] = [];\n    }\n\n    acc[importedItem.rank].push(importedItem);\n    return acc;\n  }, {});\n  var groupRanks = Object.keys(groupedByRanks);\n  var sorterFn = getSorter(alphabetizeOptions.order === 'asc');\n  var comparator = alphabetizeOptions.caseInsensitive ? function (a, b) {\n    return sorterFn(String(a.value).toLowerCase(), String(b.value).toLowerCase());\n  } : function (a, b) {\n    return sorterFn(a.value, b.value);\n  }; // sort imports locally within their group\n\n  groupRanks.forEach(function (groupRank) {\n    groupedByRanks[groupRank].sort(comparator);\n  }); // assign globally unique rank to each import\n\n  var newRank = 0;\n  var alphabetizedRanks = groupRanks.sort().reduce(function (acc, groupRank) {\n    groupedByRanks[groupRank].forEach(function (importedItem) {\n      acc[String(importedItem.value) + '|' + String(importedItem.node.importKind)] = parseInt(groupRank, 10) + newRank;\n      newRank += 1;\n    });\n    return acc;\n  }, {}); // mutate the original group-rank with alphabetized-rank\n\n  imported.forEach(function (importedItem) {\n    importedItem.rank = alphabetizedRanks[String(importedItem.value) + '|' + String(importedItem.node.importKind)];\n  });\n} // DETECTING\n\n\nfunction computePathRank(ranks, pathGroups, path, maxPosition) {\n  for (var i = 0, l = pathGroups.length; i < l; i++) {\n    var _pathGroups$i = pathGroups[i],\n        pattern = _pathGroups$i.pattern,\n        patternOptions = _pathGroups$i.patternOptions,\n        group = _pathGroups$i.group,\n        _pathGroups$i$positio = _pathGroups$i.position,\n        position = _pathGroups$i$positio === undefined ? 1 : _pathGroups$i$positio;\n\n    if ((0, _minimatch2['default'])(path, pattern, patternOptions || {\n      nocomment: true\n    })) {\n      return ranks[group] + position / maxPosition;\n    }\n  }\n}\n\nfunction computeRank(context, ranks, importEntry, excludedImportTypes) {\n  var impType = void 0;\n  var rank = void 0;\n\n  if (importEntry.type === 'import:object') {\n    impType = 'object';\n  } else if (importEntry.node.importKind === 'type' && ranks.omittedTypes.indexOf('type') === -1) {\n    impType = 'type';\n  } else {\n    impType = (0, _importType2['default'])(importEntry.value, context);\n  }\n\n  if (!excludedImportTypes.has(impType)) {\n    rank = computePathRank(ranks.groups, ranks.pathGroups, importEntry.value, ranks.maxPosition);\n  }\n\n  if (typeof rank === 'undefined') {\n    rank = ranks.groups[impType];\n  }\n\n  if (importEntry.type !== 'import' && !importEntry.type.startsWith('import:')) {\n    rank += 100;\n  }\n\n  return rank;\n}\n\nfunction registerNode(context, importEntry, ranks, imported, excludedImportTypes) {\n  var rank = computeRank(context, ranks, importEntry, excludedImportTypes);\n\n  if (rank !== -1) {\n    imported.push(Object.assign({}, importEntry, {\n      rank: rank\n    }));\n  }\n}\n\nfunction getRequireBlock(node) {\n  var n = node; // Handle cases like `const baz = require('foo').bar.baz`\n  // and `const foo = require('foo')()`\n\n  while (n.parent.type === 'MemberExpression' && n.parent.object === n || n.parent.type === 'CallExpression' && n.parent.callee === n) {\n    n = n.parent;\n  }\n\n  if (n.parent.type === 'VariableDeclarator' && n.parent.parent.type === 'VariableDeclaration' && n.parent.parent.parent.type === 'Program') {\n    return n.parent.parent.parent;\n  }\n}\n\nvar types = ['builtin', 'external', 'internal', 'unknown', 'parent', 'sibling', 'index', 'object', 'type']; // Creates an object with type-rank pairs.\n// Example: { index: 0, sibling: 1, parent: 1, external: 1, builtin: 2, internal: 2 }\n// Will throw an error if it contains a type that does not exist, or has a duplicate\n\nfunction convertGroupsToRanks(groups) {\n  var rankObject = groups.reduce(function (res, group, index) {\n    if (typeof group === 'string') {\n      group = [group];\n    }\n\n    group.forEach(function (groupItem) {\n      if (types.indexOf(groupItem) === -1) {\n        throw new Error('Incorrect configuration of the rule: Unknown type `' + JSON.stringify(groupItem) + '`');\n      }\n\n      if (res[groupItem] !== undefined) {\n        throw new Error('Incorrect configuration of the rule: `' + groupItem + '` is duplicated');\n      }\n\n      res[groupItem] = index;\n    });\n    return res;\n  }, {});\n  var omittedTypes = types.filter(function (type) {\n    return rankObject[type] === undefined;\n  });\n  var ranks = omittedTypes.reduce(function (res, type) {\n    res[type] = groups.length;\n    return res;\n  }, rankObject);\n  return {\n    groups: ranks,\n    omittedTypes: omittedTypes\n  };\n}\n\nfunction convertPathGroupsForRanks(pathGroups) {\n  var after = {};\n  var before = {};\n  var transformed = pathGroups.map(function (pathGroup, index) {\n    var group = pathGroup.group,\n        positionString = pathGroup.position;\n    var position = 0;\n\n    if (positionString === 'after') {\n      if (!after[group]) {\n        after[group] = 1;\n      }\n\n      position = after[group]++;\n    } else if (positionString === 'before') {\n      if (!before[group]) {\n        before[group] = [];\n      }\n\n      before[group].push(index);\n    }\n\n    return Object.assign({}, pathGroup, {\n      position: position\n    });\n  });\n  var maxPosition = 1;\n  Object.keys(before).forEach(function (group) {\n    var groupLength = before[group].length;\n    before[group].forEach(function (groupIndex, index) {\n      transformed[groupIndex].position = -1 * (groupLength - index);\n    });\n    maxPosition = Math.max(maxPosition, groupLength);\n  });\n  Object.keys(after).forEach(function (key) {\n    var groupNextPosition = after[key];\n    maxPosition = Math.max(maxPosition, groupNextPosition - 1);\n  });\n  return {\n    pathGroups: transformed,\n    maxPosition: maxPosition > 10 ? Math.pow(10, Math.ceil(Math.log10(maxPosition))) : 10\n  };\n}\n\nfunction fixNewLineAfterImport(context, previousImport) {\n  var prevRoot = findRootNode(previousImport.node);\n  var tokensToEndOfLine = takeTokensAfterWhile(context.getSourceCode(), prevRoot, commentOnSameLineAs(prevRoot));\n  var endOfLine = prevRoot.range[1];\n\n  if (tokensToEndOfLine.length > 0) {\n    endOfLine = tokensToEndOfLine[tokensToEndOfLine.length - 1].range[1];\n  }\n\n  return function (fixer) {\n    return fixer.insertTextAfterRange([prevRoot.range[0], endOfLine], '\\n');\n  };\n}\n\nfunction removeNewLineAfterImport(context, currentImport, previousImport) {\n  var sourceCode = context.getSourceCode();\n  var prevRoot = findRootNode(previousImport.node);\n  var currRoot = findRootNode(currentImport.node);\n  var rangeToRemove = [findEndOfLineWithComments(sourceCode, prevRoot), findStartOfLineWithComments(sourceCode, currRoot)];\n\n  if (/^\\s*$/.test(sourceCode.text.substring(rangeToRemove[0], rangeToRemove[1]))) {\n    return function (fixer) {\n      return fixer.removeRange(rangeToRemove);\n    };\n  }\n\n  return undefined;\n}\n\nfunction makeNewlinesBetweenReport(context, imported, newlinesBetweenImports) {\n  var getNumberOfEmptyLinesBetween = function getNumberOfEmptyLinesBetween(currentImport, previousImport) {\n    var linesBetweenImports = context.getSourceCode().lines.slice(previousImport.node.loc.end.line, currentImport.node.loc.start.line - 1);\n    return linesBetweenImports.filter(function (line) {\n      return !line.trim().length;\n    }).length;\n  };\n\n  var previousImport = imported[0];\n  imported.slice(1).forEach(function (currentImport) {\n    var emptyLinesBetween = getNumberOfEmptyLinesBetween(currentImport, previousImport);\n\n    if (newlinesBetweenImports === 'always' || newlinesBetweenImports === 'always-and-inside-groups') {\n      if (currentImport.rank !== previousImport.rank && emptyLinesBetween === 0) {\n        context.report({\n          node: previousImport.node,\n          message: 'There should be at least one empty line between import groups',\n          fix: fixNewLineAfterImport(context, previousImport)\n        });\n      } else if (currentImport.rank === previousImport.rank && emptyLinesBetween > 0 && newlinesBetweenImports !== 'always-and-inside-groups') {\n        context.report({\n          node: previousImport.node,\n          message: 'There should be no empty line within import group',\n          fix: removeNewLineAfterImport(context, currentImport, previousImport)\n        });\n      }\n    } else if (emptyLinesBetween > 0) {\n      context.report({\n        node: previousImport.node,\n        message: 'There should be no empty line between import groups',\n        fix: removeNewLineAfterImport(context, currentImport, previousImport)\n      });\n    }\n\n    previousImport = currentImport;\n  });\n}\n\nfunction getAlphabetizeConfig(options) {\n  var alphabetize = options.alphabetize || {};\n  var order = alphabetize.order || 'ignore';\n  var caseInsensitive = alphabetize.caseInsensitive || false;\n  return {\n    order: order,\n    caseInsensitive: caseInsensitive\n  };\n}\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: (0, _docsUrl2['default'])('order')\n    },\n    fixable: 'code',\n    schema: [{\n      type: 'object',\n      properties: {\n        groups: {\n          type: 'array'\n        },\n        pathGroupsExcludedImportTypes: {\n          type: 'array'\n        },\n        pathGroups: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              pattern: {\n                type: 'string'\n              },\n              patternOptions: {\n                type: 'object'\n              },\n              group: {\n                type: 'string',\n                'enum': types\n              },\n              position: {\n                type: 'string',\n                'enum': ['after', 'before']\n              }\n            },\n            required: ['pattern', 'group']\n          }\n        },\n        'newlines-between': {\n          'enum': ['ignore', 'always', 'always-and-inside-groups', 'never']\n        },\n        alphabetize: {\n          type: 'object',\n          properties: {\n            caseInsensitive: {\n              type: 'boolean',\n              'default': false\n            },\n            order: {\n              'enum': ['ignore', 'asc', 'desc'],\n              'default': 'ignore'\n            }\n          },\n          additionalProperties: false\n        },\n        warnOnUnassignedImports: {\n          type: 'boolean',\n          'default': false\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  create: function () {\n    function importOrderRule(context) {\n      var options = context.options[0] || {};\n      var newlinesBetweenImports = options['newlines-between'] || 'ignore';\n      var pathGroupsExcludedImportTypes = new Set(options['pathGroupsExcludedImportTypes'] || ['builtin', 'external', 'object']);\n      var alphabetize = getAlphabetizeConfig(options);\n      var ranks = void 0;\n\n      try {\n        var _convertPathGroupsFor = convertPathGroupsForRanks(options.pathGroups || []),\n            pathGroups = _convertPathGroupsFor.pathGroups,\n            maxPosition = _convertPathGroupsFor.maxPosition;\n\n        var _convertGroupsToRanks = convertGroupsToRanks(options.groups || defaultGroups),\n            groups = _convertGroupsToRanks.groups,\n            omittedTypes = _convertGroupsToRanks.omittedTypes;\n\n        ranks = {\n          groups: groups,\n          omittedTypes: omittedTypes,\n          pathGroups: pathGroups,\n          maxPosition: maxPosition\n        };\n      } catch (error) {\n        // Malformed configuration\n        return {\n          Program: function () {\n            function Program(node) {\n              context.report(node, error.message);\n            }\n\n            return Program;\n          }()\n        };\n      }\n\n      var importMap = new Map();\n\n      function getBlockImports(node) {\n        if (!importMap.has(node)) {\n          importMap.set(node, []);\n        }\n\n        return importMap.get(node);\n      }\n\n      return {\n        ImportDeclaration: function () {\n          function handleImports(node) {\n            // Ignoring unassigned imports unless warnOnUnassignedImports is set\n            if (node.specifiers.length || options.warnOnUnassignedImports) {\n              var name = node.source.value;\n              registerNode(context, {\n                node: node,\n                value: name,\n                displayName: name,\n                type: 'import'\n              }, ranks, getBlockImports(node.parent), pathGroupsExcludedImportTypes);\n            }\n          }\n\n          return handleImports;\n        }(),\n        TSImportEqualsDeclaration: function () {\n          function handleImports(node) {\n            var displayName = void 0;\n            var value = void 0;\n            var type = void 0; // skip \"export import\"s\n\n            if (node.isExport) {\n              return;\n            }\n\n            if (node.moduleReference.type === 'TSExternalModuleReference') {\n              value = node.moduleReference.expression.value;\n              displayName = value;\n              type = 'import';\n            } else {\n              value = '';\n              displayName = context.getSourceCode().getText(node.moduleReference);\n              type = 'import:object';\n            }\n\n            registerNode(context, {\n              node: node,\n              value: value,\n              displayName: displayName,\n              type: type\n            }, ranks, getBlockImports(node.parent), pathGroupsExcludedImportTypes);\n          }\n\n          return handleImports;\n        }(),\n        CallExpression: function () {\n          function handleRequires(node) {\n            if (!(0, _staticRequire2['default'])(node)) {\n              return;\n            }\n\n            var block = getRequireBlock(node);\n\n            if (!block) {\n              return;\n            }\n\n            var name = node.arguments[0].value;\n            registerNode(context, {\n              node: node,\n              value: name,\n              displayName: name,\n              type: 'require'\n            }, ranks, getBlockImports(block), pathGroupsExcludedImportTypes);\n          }\n\n          return handleRequires;\n        }(),\n        'Program:exit': function () {\n          function reportAndReset() {\n            importMap.forEach(function (imported) {\n              if (newlinesBetweenImports !== 'ignore') {\n                makeNewlinesBetweenReport(context, imported, newlinesBetweenImports);\n              }\n\n              if (alphabetize.order !== 'ignore') {\n                mutateRanksToAlphabetize(imported, alphabetize);\n              }\n\n              makeOutOfOrderReport(context, imported);\n            });\n            importMap.clear();\n          }\n\n          return reportAndReset;\n        }()\n      };\n    }\n\n    return importOrderRule;\n  }()\n};","map":{"version":3,"mappings":"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","names":["defaultGroups","reverse","array","map","v","Object","assign","rank","getTokensOrCommentsAfter","sourceCode","node","count","currentNodeOrToken","result","i","getTokenOrCommentAfter","push","getTokensOrCommentsBefore","getTokenOrCommentBefore","takeTokensAfterWhile","condition","tokens","length","takeTokensBeforeWhile","findOutOfOrder","imported","maxSeenRankNode","filter","importedModule","res","findRootNode","parent","body","findEndOfLineWithComments","tokensToEndOfLine","commentOnSameLineAs","endOfTokens","range","text","token","type","loc","start","line","end","findStartOfLineWithComments","startOfTokens","isPlainRequireModule","declarations","decl","id","init","callee","name","arguments","isPlainImportModule","specifiers","isPlainImportEquals","moduleReference","expression","canCrossNodeWhileReorder","canReorderItems","firstNode","secondNode","indexOf","sort","firstIndex","secondIndex","nodesBetween","slice","nodeBetween","_didIteratorError","_iteratorError","_iterator","fixOutOfOrder","context","order","getSourceCode","firstRoot","firstRootStart","firstRootEnd","secondRoot","secondRootStart","secondRootEnd","canFix","newCode","substring","message","displayName","report","fix","fixer","replaceTextRange","reportOutOfOrder","outOfOrder","forEach","imp","found","find","hasHigherRank","importedItem","makeOutOfOrderReport","reversedImported","reversedOrder","getSorter","ascending","multiplier","importsSorter","importA","importB","mutateRanksToAlphabetize","alphabetizeOptions","groupedByRanks","reduce","acc","Array","isArray","groupRanks","keys","sorterFn","comparator","caseInsensitive","a","b","String","value","toLowerCase","groupRank","newRank","alphabetizedRanks","importKind","parseInt","computePathRank","ranks","pathGroups","path","maxPosition","l","pattern","patternOptions","group","position","nocomment","computeRank","importEntry","excludedImportTypes","impType","omittedTypes","has","groups","startsWith","registerNode","getRequireBlock","n","object","types","convertGroupsToRanks","rankObject","index","groupItem","Error","JSON","stringify","undefined","convertPathGroupsForRanks","after","before","transformed","pathGroup","positionString","groupLength","groupIndex","Math","max","key","groupNextPosition","pow","ceil","log10","fixNewLineAfterImport","previousImport","prevRoot","endOfLine","insertTextAfterRange","removeNewLineAfterImport","currentImport","currRoot","rangeToRemove","test","removeRange","makeNewlinesBetweenReport","newlinesBetweenImports","getNumberOfEmptyLinesBetween","linesBetweenImports","lines","trim","emptyLinesBetween","getAlphabetizeConfig","options","alphabetize","module","exports","meta","docs","url","fixable","schema","properties","pathGroupsExcludedImportTypes","items","required","additionalProperties","warnOnUnassignedImports","create","importOrderRule","Set","error","Program","importMap","Map","getBlockImports","set","get","ImportDeclaration","handleImports","source","TSImportEqualsDeclaration","isExport","getText","CallExpression","handleRequires","block","reportAndReset","clear"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\order.js"],"sourcesContent":["'use strict';\n\nimport minimatch from 'minimatch';\nimport importType from '../core/importType';\nimport isStaticRequire from '../core/staticRequire';\nimport docsUrl from '../docsUrl';\n\nconst defaultGroups = ['builtin', 'external', 'parent', 'sibling', 'index'];\n\n// REPORTING AND FIXING\n\nfunction reverse(array) {\n  return array.map(function (v) {\n    return Object.assign({}, v, { rank: -v.rank });\n  }).reverse();\n}\n\nfunction getTokensOrCommentsAfter(sourceCode, node, count) {\n  let currentNodeOrToken = node;\n  const result = [];\n  for (let i = 0; i < count; i++) {\n    currentNodeOrToken = sourceCode.getTokenOrCommentAfter(currentNodeOrToken);\n    if (currentNodeOrToken == null) {\n      break;\n    }\n    result.push(currentNodeOrToken);\n  }\n  return result;\n}\n\nfunction getTokensOrCommentsBefore(sourceCode, node, count) {\n  let currentNodeOrToken = node;\n  const result = [];\n  for (let i = 0; i < count; i++) {\n    currentNodeOrToken = sourceCode.getTokenOrCommentBefore(currentNodeOrToken);\n    if (currentNodeOrToken == null) {\n      break;\n    }\n    result.push(currentNodeOrToken);\n  }\n  return result.reverse();\n}\n\nfunction takeTokensAfterWhile(sourceCode, node, condition) {\n  const tokens = getTokensOrCommentsAfter(sourceCode, node, 100);\n  const result = [];\n  for (let i = 0; i < tokens.length; i++) {\n    if (condition(tokens[i])) {\n      result.push(tokens[i]);\n    } else {\n      break;\n    }\n  }\n  return result;\n}\n\nfunction takeTokensBeforeWhile(sourceCode, node, condition) {\n  const tokens = getTokensOrCommentsBefore(sourceCode, node, 100);\n  const result = [];\n  for (let i = tokens.length - 1; i >= 0; i--) {\n    if (condition(tokens[i])) {\n      result.push(tokens[i]);\n    } else {\n      break;\n    }\n  }\n  return result.reverse();\n}\n\nfunction findOutOfOrder(imported) {\n  if (imported.length === 0) {\n    return [];\n  }\n  let maxSeenRankNode = imported[0];\n  return imported.filter(function (importedModule) {\n    const res = importedModule.rank < maxSeenRankNode.rank;\n    if (maxSeenRankNode.rank < importedModule.rank) {\n      maxSeenRankNode = importedModule;\n    }\n    return res;\n  });\n}\n\nfunction findRootNode(node) {\n  let parent = node;\n  while (parent.parent != null && parent.parent.body == null) {\n    parent = parent.parent;\n  }\n  return parent;\n}\n\nfunction findEndOfLineWithComments(sourceCode, node) {\n  const tokensToEndOfLine = takeTokensAfterWhile(sourceCode, node, commentOnSameLineAs(node));\n  const endOfTokens = tokensToEndOfLine.length > 0\n    ? tokensToEndOfLine[tokensToEndOfLine.length - 1].range[1]\n    : node.range[1];\n  let result = endOfTokens;\n  for (let i = endOfTokens; i < sourceCode.text.length; i++) {\n    if (sourceCode.text[i] === '\\n') {\n      result = i + 1;\n      break;\n    }\n    if (sourceCode.text[i] !== ' ' && sourceCode.text[i] !== '\\t' && sourceCode.text[i] !== '\\r') {\n      break;\n    }\n    result = i + 1;\n  }\n  return result;\n}\n\nfunction commentOnSameLineAs(node) {\n  return token => (token.type === 'Block' ||  token.type === 'Line') &&\n      token.loc.start.line === token.loc.end.line &&\n      token.loc.end.line === node.loc.end.line;\n}\n\nfunction findStartOfLineWithComments(sourceCode, node) {\n  const tokensToEndOfLine = takeTokensBeforeWhile(sourceCode, node, commentOnSameLineAs(node));\n  const startOfTokens = tokensToEndOfLine.length > 0 ? tokensToEndOfLine[0].range[0] : node.range[0];\n  let result = startOfTokens;\n  for (let i = startOfTokens - 1; i > 0; i--) {\n    if (sourceCode.text[i] !== ' ' && sourceCode.text[i] !== '\\t') {\n      break;\n    }\n    result = i;\n  }\n  return result;\n}\n\nfunction isPlainRequireModule(node) {\n  if (node.type !== 'VariableDeclaration') {\n    return false;\n  }\n  if (node.declarations.length !== 1) {\n    return false;\n  }\n  const decl = node.declarations[0];\n  const result = decl.id &&\n    (decl.id.type === 'Identifier' || decl.id.type === 'ObjectPattern') &&\n    decl.init != null &&\n    decl.init.type === 'CallExpression' &&\n    decl.init.callee != null &&\n    decl.init.callee.name === 'require' &&\n    decl.init.arguments != null &&\n    decl.init.arguments.length === 1 &&\n    decl.init.arguments[0].type === 'Literal';\n  return result;\n}\n\nfunction isPlainImportModule(node) {\n  return node.type === 'ImportDeclaration' && node.specifiers != null && node.specifiers.length > 0;\n}\n\nfunction isPlainImportEquals(node) {\n  return node.type === 'TSImportEqualsDeclaration' && node.moduleReference.expression;\n}\n\nfunction canCrossNodeWhileReorder(node) {\n  return isPlainRequireModule(node) || isPlainImportModule(node) || isPlainImportEquals(node);\n}\n\nfunction canReorderItems(firstNode, secondNode) {\n  const parent = firstNode.parent;\n  const [firstIndex, secondIndex] = [\n    parent.body.indexOf(firstNode),\n    parent.body.indexOf(secondNode),\n  ].sort();\n  const nodesBetween = parent.body.slice(firstIndex, secondIndex + 1);\n  for (const nodeBetween of nodesBetween) {\n    if (!canCrossNodeWhileReorder(nodeBetween)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction fixOutOfOrder(context, firstNode, secondNode, order) {\n  const sourceCode = context.getSourceCode();\n\n  const firstRoot = findRootNode(firstNode.node);\n  const firstRootStart = findStartOfLineWithComments(sourceCode, firstRoot);\n  const firstRootEnd = findEndOfLineWithComments(sourceCode, firstRoot);\n\n  const secondRoot = findRootNode(secondNode.node);\n  const secondRootStart = findStartOfLineWithComments(sourceCode, secondRoot);\n  const secondRootEnd = findEndOfLineWithComments(sourceCode, secondRoot);\n  const canFix = canReorderItems(firstRoot, secondRoot);\n\n  let newCode = sourceCode.text.substring(secondRootStart, secondRootEnd);\n  if (newCode[newCode.length - 1] !== '\\n') {\n    newCode = newCode + '\\n';\n  }\n\n  const message = `\\`${secondNode.displayName}\\` import should occur ${order} import of \\`${firstNode.displayName}\\``;\n\n  if (order === 'before') {\n    context.report({\n      node: secondNode.node,\n      message,\n      fix: canFix && (fixer =>\n        fixer.replaceTextRange(\n          [firstRootStart, secondRootEnd],\n          newCode + sourceCode.text.substring(firstRootStart, secondRootStart),\n        )),\n    });\n  } else if (order === 'after') {\n    context.report({\n      node: secondNode.node,\n      message,\n      fix: canFix && (fixer =>\n        fixer.replaceTextRange(\n          [secondRootStart, firstRootEnd],\n          sourceCode.text.substring(secondRootEnd, firstRootEnd) + newCode,\n        )),\n    });\n  }\n}\n\nfunction reportOutOfOrder(context, imported, outOfOrder, order) {\n  outOfOrder.forEach(function (imp) {\n    const found = imported.find(function hasHigherRank(importedItem) {\n      return importedItem.rank > imp.rank;\n    });\n    fixOutOfOrder(context, found, imp, order);\n  });\n}\n\nfunction makeOutOfOrderReport(context, imported) {\n  const outOfOrder = findOutOfOrder(imported);\n  if (!outOfOrder.length) {\n    return;\n  }\n  // There are things to report. Try to minimize the number of reported errors.\n  const reversedImported = reverse(imported);\n  const reversedOrder = findOutOfOrder(reversedImported);\n  if (reversedOrder.length < outOfOrder.length) {\n    reportOutOfOrder(context, reversedImported, reversedOrder, 'after');\n    return;\n  }\n  reportOutOfOrder(context, imported, outOfOrder, 'before');\n}\n\nfunction getSorter(ascending) {\n  const multiplier = ascending ? 1 : -1;\n\n  return function importsSorter(importA, importB) {\n    let result;\n\n    if (importA < importB) {\n      result = -1;\n    } else if (importA > importB) {\n      result = 1;\n    } else {\n      result = 0;\n    }\n\n    return result * multiplier;\n  };\n}\n\nfunction mutateRanksToAlphabetize(imported, alphabetizeOptions) {\n  const groupedByRanks = imported.reduce(function (acc, importedItem) {\n    if (!Array.isArray(acc[importedItem.rank])) {\n      acc[importedItem.rank] = [];\n    }\n    acc[importedItem.rank].push(importedItem);\n    return acc;\n  }, {});\n\n  const groupRanks = Object.keys(groupedByRanks);\n\n  const sorterFn = getSorter(alphabetizeOptions.order === 'asc');\n  const comparator = alphabetizeOptions.caseInsensitive\n    ? (a, b) => sorterFn(String(a.value).toLowerCase(), String(b.value).toLowerCase())\n    : (a, b) => sorterFn(a.value, b.value);\n\n  // sort imports locally within their group\n  groupRanks.forEach(function (groupRank) {\n    groupedByRanks[groupRank].sort(comparator);\n  });\n\n  // assign globally unique rank to each import\n  let newRank = 0;\n  const alphabetizedRanks = groupRanks.sort().reduce(function (acc, groupRank) {\n    groupedByRanks[groupRank].forEach(function (importedItem) {\n      acc[`${importedItem.value}|${importedItem.node.importKind}`] = parseInt(groupRank, 10) + newRank;\n      newRank += 1;\n    });\n    return acc;\n  }, {});\n\n  // mutate the original group-rank with alphabetized-rank\n  imported.forEach(function (importedItem) {\n    importedItem.rank = alphabetizedRanks[`${importedItem.value}|${importedItem.node.importKind}`];\n  });\n}\n\n// DETECTING\n\nfunction computePathRank(ranks, pathGroups, path, maxPosition) {\n  for (let i = 0, l = pathGroups.length; i < l; i++) {\n    const { pattern, patternOptions, group, position = 1 } = pathGroups[i];\n    if (minimatch(path, pattern, patternOptions || { nocomment: true })) {\n      return ranks[group] + (position / maxPosition);\n    }\n  }\n}\n\nfunction computeRank(context, ranks, importEntry, excludedImportTypes) {\n  let impType;\n  let rank;\n  if (importEntry.type === 'import:object') {\n    impType = 'object';\n  } else if (importEntry.node.importKind === 'type' && ranks.omittedTypes.indexOf('type') === -1) {\n    impType = 'type';\n  } else {\n    impType = importType(importEntry.value, context);\n  }\n  if (!excludedImportTypes.has(impType)) {\n    rank = computePathRank(ranks.groups, ranks.pathGroups, importEntry.value, ranks.maxPosition);\n  }\n  if (typeof rank === 'undefined') {\n    rank = ranks.groups[impType];\n  }\n  if (importEntry.type !== 'import' && !importEntry.type.startsWith('import:')) {\n    rank += 100;\n  }\n\n  return rank;\n}\n\nfunction registerNode(context, importEntry, ranks, imported, excludedImportTypes) {\n  const rank = computeRank(context, ranks, importEntry, excludedImportTypes);\n  if (rank !== -1) {\n    imported.push(Object.assign({}, importEntry, { rank }));\n  }\n}\n\nfunction getRequireBlock(node) {\n  let n = node;\n  // Handle cases like `const baz = require('foo').bar.baz`\n  // and `const foo = require('foo')()`\n  while (\n    (n.parent.type === 'MemberExpression' && n.parent.object === n) ||\n    (n.parent.type === 'CallExpression' && n.parent.callee === n)\n  ) {\n    n = n.parent;\n  }\n  if (\n    n.parent.type === 'VariableDeclarator' &&\n    n.parent.parent.type === 'VariableDeclaration' &&\n    n.parent.parent.parent.type === 'Program'\n  ) {\n    return n.parent.parent.parent;\n  }\n}\n\nconst types = ['builtin', 'external', 'internal', 'unknown', 'parent', 'sibling', 'index', 'object', 'type'];\n\n// Creates an object with type-rank pairs.\n// Example: { index: 0, sibling: 1, parent: 1, external: 1, builtin: 2, internal: 2 }\n// Will throw an error if it contains a type that does not exist, or has a duplicate\nfunction convertGroupsToRanks(groups) {\n  const rankObject = groups.reduce(function (res, group, index) {\n    if (typeof group === 'string') {\n      group = [group];\n    }\n    group.forEach(function (groupItem) {\n      if (types.indexOf(groupItem) === -1) {\n        throw new Error('Incorrect configuration of the rule: Unknown type `' +\n          JSON.stringify(groupItem) + '`');\n      }\n      if (res[groupItem] !== undefined) {\n        throw new Error('Incorrect configuration of the rule: `' + groupItem + '` is duplicated');\n      }\n      res[groupItem] = index;\n    });\n    return res;\n  }, {});\n\n  const omittedTypes = types.filter(function (type) {\n    return rankObject[type] === undefined;\n  });\n\n  const ranks = omittedTypes.reduce(function (res, type) {\n    res[type] = groups.length;\n    return res;\n  }, rankObject);\n\n  return { groups: ranks, omittedTypes };\n}\n\nfunction convertPathGroupsForRanks(pathGroups) {\n  const after = {};\n  const before = {};\n\n  const transformed = pathGroups.map((pathGroup, index) => {\n    const { group, position: positionString } = pathGroup;\n    let position = 0;\n    if (positionString === 'after') {\n      if (!after[group]) {\n        after[group] = 1;\n      }\n      position = after[group]++;\n    } else if (positionString === 'before') {\n      if (!before[group]) {\n        before[group] = [];\n      }\n      before[group].push(index);\n    }\n\n    return Object.assign({}, pathGroup, { position });\n  });\n\n  let maxPosition = 1;\n\n  Object.keys(before).forEach((group) => {\n    const groupLength = before[group].length;\n    before[group].forEach((groupIndex, index) => {\n      transformed[groupIndex].position = -1 * (groupLength - index);\n    });\n    maxPosition = Math.max(maxPosition, groupLength);\n  });\n\n  Object.keys(after).forEach((key) => {\n    const groupNextPosition = after[key];\n    maxPosition = Math.max(maxPosition, groupNextPosition - 1);\n  });\n\n  return {\n    pathGroups: transformed,\n    maxPosition: maxPosition > 10 ? Math.pow(10, Math.ceil(Math.log10(maxPosition))) : 10,\n  };\n}\n\nfunction fixNewLineAfterImport(context, previousImport) {\n  const prevRoot = findRootNode(previousImport.node);\n  const tokensToEndOfLine = takeTokensAfterWhile(\n    context.getSourceCode(), prevRoot, commentOnSameLineAs(prevRoot));\n\n  let endOfLine = prevRoot.range[1];\n  if (tokensToEndOfLine.length > 0) {\n    endOfLine = tokensToEndOfLine[tokensToEndOfLine.length - 1].range[1];\n  }\n  return (fixer) => fixer.insertTextAfterRange([prevRoot.range[0], endOfLine], '\\n');\n}\n\nfunction removeNewLineAfterImport(context, currentImport, previousImport) {\n  const sourceCode = context.getSourceCode();\n  const prevRoot = findRootNode(previousImport.node);\n  const currRoot = findRootNode(currentImport.node);\n  const rangeToRemove = [\n    findEndOfLineWithComments(sourceCode, prevRoot),\n    findStartOfLineWithComments(sourceCode, currRoot),\n  ];\n  if (/^\\s*$/.test(sourceCode.text.substring(rangeToRemove[0], rangeToRemove[1]))) {\n    return (fixer) => fixer.removeRange(rangeToRemove);\n  }\n  return undefined;\n}\n\nfunction makeNewlinesBetweenReport(context, imported, newlinesBetweenImports) {\n  const getNumberOfEmptyLinesBetween = (currentImport, previousImport) => {\n    const linesBetweenImports = context.getSourceCode().lines.slice(\n      previousImport.node.loc.end.line,\n      currentImport.node.loc.start.line - 1,\n    );\n\n    return linesBetweenImports.filter((line) => !line.trim().length).length;\n  };\n  let previousImport = imported[0];\n\n  imported.slice(1).forEach(function (currentImport) {\n    const emptyLinesBetween = getNumberOfEmptyLinesBetween(currentImport, previousImport);\n\n    if (newlinesBetweenImports === 'always'\n        || newlinesBetweenImports === 'always-and-inside-groups') {\n      if (currentImport.rank !== previousImport.rank && emptyLinesBetween === 0) {\n        context.report({\n          node: previousImport.node,\n          message: 'There should be at least one empty line between import groups',\n          fix: fixNewLineAfterImport(context, previousImport),\n        });\n      } else if (currentImport.rank === previousImport.rank\n        && emptyLinesBetween > 0\n        && newlinesBetweenImports !== 'always-and-inside-groups') {\n        context.report({\n          node: previousImport.node,\n          message: 'There should be no empty line within import group',\n          fix: removeNewLineAfterImport(context, currentImport, previousImport),\n        });\n      }\n    } else if (emptyLinesBetween > 0) {\n      context.report({\n        node: previousImport.node,\n        message: 'There should be no empty line between import groups',\n        fix: removeNewLineAfterImport(context, currentImport, previousImport),\n      });\n    }\n\n    previousImport = currentImport;\n  });\n}\n\nfunction getAlphabetizeConfig(options) {\n  const alphabetize = options.alphabetize || {};\n  const order = alphabetize.order || 'ignore';\n  const caseInsensitive = alphabetize.caseInsensitive || false;\n\n  return { order, caseInsensitive };\n}\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: docsUrl('order'),\n    },\n\n    fixable: 'code',\n    schema: [\n      {\n        type: 'object',\n        properties: {\n          groups: {\n            type: 'array',\n          },\n          pathGroupsExcludedImportTypes: {\n            type: 'array',\n          },\n          pathGroups: {\n            type: 'array',\n            items: {\n              type: 'object',\n              properties: {\n                pattern: {\n                  type: 'string',\n                },\n                patternOptions: {\n                  type: 'object',\n                },\n                group: {\n                  type: 'string',\n                  enum: types,\n                },\n                position: {\n                  type: 'string',\n                  enum: ['after', 'before'],\n                },\n              },\n              required: ['pattern', 'group'],\n            },\n          },\n          'newlines-between': {\n            enum: [\n              'ignore',\n              'always',\n              'always-and-inside-groups',\n              'never',\n            ],\n          },\n          alphabetize: {\n            type: 'object',\n            properties: {\n              caseInsensitive: {\n                type: 'boolean',\n                default: false,\n              },\n              order: {\n                enum: ['ignore', 'asc', 'desc'],\n                default: 'ignore',\n              },\n            },\n            additionalProperties: false,\n          },\n          warnOnUnassignedImports: {\n            type: 'boolean',\n            default: false,\n          },\n        },\n        additionalProperties: false,\n      },\n    ],\n  },\n\n  create: function importOrderRule(context) {\n    const options = context.options[0] || {};\n    const newlinesBetweenImports = options['newlines-between'] || 'ignore';\n    const pathGroupsExcludedImportTypes = new Set(options['pathGroupsExcludedImportTypes'] || ['builtin', 'external', 'object']);\n    const alphabetize = getAlphabetizeConfig(options);\n    let ranks;\n\n    try {\n      const { pathGroups, maxPosition } = convertPathGroupsForRanks(options.pathGroups || []);\n      const { groups, omittedTypes } = convertGroupsToRanks(options.groups || defaultGroups);\n      ranks = {\n        groups,\n        omittedTypes,\n        pathGroups,\n        maxPosition,\n      };\n    } catch (error) {\n      // Malformed configuration\n      return {\n        Program(node) {\n          context.report(node, error.message);\n        },\n      };\n    }\n    const importMap = new Map();\n\n    function getBlockImports(node) {\n      if (!importMap.has(node)) {\n        importMap.set(node, []);\n      }\n      return importMap.get(node);\n    }\n\n    return {\n      ImportDeclaration: function handleImports(node) {\n        // Ignoring unassigned imports unless warnOnUnassignedImports is set\n        if (node.specifiers.length || options.warnOnUnassignedImports) {\n          const name = node.source.value;\n          registerNode(\n            context,\n            {\n              node,\n              value: name,\n              displayName: name,\n              type: 'import',\n            },\n            ranks,\n            getBlockImports(node.parent),\n            pathGroupsExcludedImportTypes,\n          );\n        }\n      },\n      TSImportEqualsDeclaration: function handleImports(node) {\n        let displayName;\n        let value;\n        let type;\n        // skip \"export import\"s\n        if (node.isExport) {\n          return;\n        }\n        if (node.moduleReference.type === 'TSExternalModuleReference') {\n          value = node.moduleReference.expression.value;\n          displayName = value;\n          type = 'import';\n        } else {\n          value = '';\n          displayName = context.getSourceCode().getText(node.moduleReference);\n          type = 'import:object';\n        }\n        registerNode(\n          context,\n          {\n            node,\n            value,\n            displayName,\n            type,\n          },\n          ranks,\n          getBlockImports(node.parent),\n          pathGroupsExcludedImportTypes,\n        );\n      },\n      CallExpression: function handleRequires(node) {\n        if (!isStaticRequire(node)) {\n          return;\n        }\n        const block = getRequireBlock(node);\n        if (!block) {\n          return;\n        }\n        const name = node.arguments[0].value;\n        registerNode(\n          context,\n          {\n            node,\n            value: name,\n            displayName: name,\n            type: 'require',\n          },\n          ranks,\n          getBlockImports(block),\n          pathGroupsExcludedImportTypes,\n        );\n      },\n      'Program:exit': function reportAndReset() {\n        importMap.forEach((imported) => {\n          if (newlinesBetweenImports !== 'ignore') {\n            makeNewlinesBetweenReport(context, imported, newlinesBetweenImports);\n          }\n\n          if (alphabetize.order !== 'ignore') {\n            mutateRanksToAlphabetize(imported, alphabetize);\n          }\n\n          makeOutOfOrderReport(context, imported);\n        });\n\n        importMap.clear();\n      },\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"script"}