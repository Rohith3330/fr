{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createPlugin;\n\nvar _pluginSyntaxJsx = require(\"@babel/plugin-syntax-jsx\");\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\"\n};\nconst JSX_SOURCE_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxImportSource\\s+([^\\s]+)\\s*$/m;\nconst JSX_RUNTIME_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxRuntime\\s+([^\\s]+)\\s*$/m;\nconst JSX_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsx\\s+([^\\s]+)\\s*$/m;\nconst JSX_FRAG_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxFrag\\s+([^\\s]+)\\s*$/m;\n\nconst get = (pass, name) => pass.get(`@babel/plugin-react-jsx/${name}`);\n\nconst set = (pass, name, v) => pass.set(`@babel/plugin-react-jsx/${name}`, v);\n\nfunction hasProto(node) {\n  return node.properties.some(value => _core.types.isObjectProperty(value, {\n    computed: false,\n    shorthand: false\n  }) && (_core.types.isIdentifier(value.key, {\n    name: \"__proto__\"\n  }) || _core.types.isStringLiteral(value.key, {\n    value: \"__proto__\"\n  })));\n}\n\nfunction createPlugin(_ref) {\n  let {\n    name,\n    development\n  } = _ref;\n  return (0, _helperPluginUtils.declare)((_, options) => {\n    const {\n      pure: PURE_ANNOTATION,\n      throwIfNamespace = true,\n      filter,\n      runtime: RUNTIME_DEFAULT = development ? \"automatic\" : \"classic\",\n      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag\n    } = options;\n    {\n      var {\n        useSpread = false,\n        useBuiltIns = false\n      } = options;\n\n      if (RUNTIME_DEFAULT === \"classic\") {\n        if (typeof useSpread !== \"boolean\") {\n          throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useSpread (defaults to false)\");\n        }\n\n        if (typeof useBuiltIns !== \"boolean\") {\n          throw new Error(\"transform-react-jsx currently only accepts a boolean option for \" + \"useBuiltIns (defaults to false)\");\n        }\n\n        if (useSpread && useBuiltIns) {\n          throw new Error(\"transform-react-jsx currently only accepts useBuiltIns or useSpread \" + \"but not both\");\n        }\n      }\n    }\n    const injectMetaPropertiesVisitor = {\n      JSXOpeningElement(path, state) {\n        const attributes = [];\n\n        if (isThisAllowed(path.scope)) {\n          attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(\"__self\"), _core.types.jsxExpressionContainer(_core.types.thisExpression())));\n        }\n\n        attributes.push(_core.types.jsxAttribute(_core.types.jsxIdentifier(\"__source\"), _core.types.jsxExpressionContainer(makeSource(path, state))));\n        path.pushContainer(\"attributes\", attributes);\n      }\n\n    };\n    return {\n      name,\n      inherits: _pluginSyntaxJsx.default,\n      visitor: {\n        JSXNamespacedName(path) {\n          if (throwIfNamespace) {\n            throw path.buildCodeFrameError(`Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`);\n          }\n        },\n\n        JSXSpreadChild(path) {\n          throw path.buildCodeFrameError(\"Spread children are not supported in React.\");\n        },\n\n        Program: {\n          enter(path, state) {\n            const {\n              file\n            } = state;\n            let runtime = RUNTIME_DEFAULT;\n            let source = IMPORT_SOURCE_DEFAULT;\n            let pragma = PRAGMA_DEFAULT;\n            let pragmaFrag = PRAGMA_FRAG_DEFAULT;\n            let sourceSet = !!options.importSource;\n            let pragmaSet = !!options.pragma;\n            let pragmaFragSet = !!options.pragmaFrag;\n\n            if (file.ast.comments) {\n              for (const comment of file.ast.comments) {\n                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);\n\n                if (sourceMatches) {\n                  source = sourceMatches[1];\n                  sourceSet = true;\n                }\n\n                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);\n\n                if (runtimeMatches) {\n                  runtime = runtimeMatches[1];\n                }\n\n                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n\n                if (jsxMatches) {\n                  pragma = jsxMatches[1];\n                  pragmaSet = true;\n                }\n\n                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);\n\n                if (jsxFragMatches) {\n                  pragmaFrag = jsxFragMatches[1];\n                  pragmaFragSet = true;\n                }\n              }\n            }\n\n            set(state, \"runtime\", runtime);\n\n            if (runtime === \"classic\") {\n              if (sourceSet) {\n                throw path.buildCodeFrameError(`importSource cannot be set when runtime is classic.`);\n              }\n\n              const createElement = toMemberExpression(pragma);\n              const fragment = toMemberExpression(pragmaFrag);\n              set(state, \"id/createElement\", () => _core.types.cloneNode(createElement));\n              set(state, \"id/fragment\", () => _core.types.cloneNode(fragment));\n              set(state, \"defaultPure\", pragma === DEFAULT.pragma);\n            } else if (runtime === \"automatic\") {\n              if (pragmaSet || pragmaFragSet) {\n                throw path.buildCodeFrameError(`pragma and pragmaFrag cannot be set when runtime is automatic.`);\n              }\n\n              const define = (name, id) => set(state, name, createImportLazily(state, path, id, source));\n\n              define(\"id/jsx\", development ? \"jsxDEV\" : \"jsx\");\n              define(\"id/jsxs\", development ? \"jsxDEV\" : \"jsxs\");\n              define(\"id/createElement\", \"createElement\");\n              define(\"id/fragment\", \"Fragment\");\n              set(state, \"defaultPure\", source === DEFAULT.importSource);\n            } else {\n              throw path.buildCodeFrameError(`Runtime must be either \"classic\" or \"automatic\".`);\n            }\n\n            if (development) {\n              path.traverse(injectMetaPropertiesVisitor, state);\n            }\n          }\n\n        },\n        JSXElement: {\n          exit(path, file) {\n            let callExpr;\n\n            if (get(file, \"runtime\") === \"classic\" || shouldUseCreateElement(path)) {\n              callExpr = buildCreateElementCall(path, file);\n            } else {\n              callExpr = buildJSXElementCall(path, file);\n            }\n\n            path.replaceWith(_core.types.inherits(callExpr, path.node));\n          }\n\n        },\n        JSXFragment: {\n          exit(path, file) {\n            let callExpr;\n\n            if (get(file, \"runtime\") === \"classic\") {\n              callExpr = buildCreateElementFragmentCall(path, file);\n            } else {\n              callExpr = buildJSXFragmentCall(path, file);\n            }\n\n            path.replaceWith(_core.types.inherits(callExpr, path.node));\n          }\n\n        },\n\n        JSXAttribute(path) {\n          if (_core.types.isJSXElement(path.node.value)) {\n            path.node.value = _core.types.jsxExpressionContainer(path.node.value);\n          }\n        }\n\n      }\n    };\n\n    function isDerivedClass(classPath) {\n      return classPath.node.superClass !== null;\n    }\n\n    function isThisAllowed(scope) {\n      do {\n        const {\n          path\n        } = scope;\n\n        if (path.isFunctionParent() && !path.isArrowFunctionExpression()) {\n          if (!path.isMethod()) {\n            return true;\n          }\n\n          if (path.node.kind !== \"constructor\") {\n            return true;\n          }\n\n          return !isDerivedClass(path.parentPath.parentPath);\n        }\n\n        if (path.isTSModuleBlock()) {\n          return false;\n        }\n      } while (scope = scope.parent);\n\n      return true;\n    }\n\n    function call(pass, name, args) {\n      const node = _core.types.callExpression(get(pass, `id/${name}`)(), args);\n\n      if (PURE_ANNOTATION != null ? PURE_ANNOTATION : get(pass, \"defaultPure\")) (0, _helperAnnotateAsPure.default)(node);\n      return node;\n    }\n\n    function shouldUseCreateElement(path) {\n      const openingPath = path.get(\"openingElement\");\n      const attributes = openingPath.node.attributes;\n      let seenPropsSpread = false;\n\n      for (let i = 0; i < attributes.length; i++) {\n        const attr = attributes[i];\n\n        if (seenPropsSpread && _core.types.isJSXAttribute(attr) && attr.name.name === \"key\") {\n          return true;\n        } else if (_core.types.isJSXSpreadAttribute(attr)) {\n          seenPropsSpread = true;\n        }\n      }\n\n      return false;\n    }\n\n    function convertJSXIdentifier(node, parent) {\n      if (_core.types.isJSXIdentifier(node)) {\n        if (node.name === \"this\" && _core.types.isReferenced(node, parent)) {\n          return _core.types.thisExpression();\n        } else if (_core.types.isValidIdentifier(node.name, false)) {\n          node.type = \"Identifier\";\n          return node;\n        } else {\n          return _core.types.stringLiteral(node.name);\n        }\n      } else if (_core.types.isJSXMemberExpression(node)) {\n        return _core.types.memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));\n      } else if (_core.types.isJSXNamespacedName(node)) {\n        return _core.types.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n      }\n\n      return node;\n    }\n\n    function convertAttributeValue(node) {\n      if (_core.types.isJSXExpressionContainer(node)) {\n        return node.expression;\n      } else {\n        return node;\n      }\n    }\n\n    function accumulateAttribute(array, attribute) {\n      if (_core.types.isJSXSpreadAttribute(attribute.node)) {\n        const arg = attribute.node.argument;\n\n        if (_core.types.isObjectExpression(arg) && !hasProto(arg)) {\n          array.push(...arg.properties);\n        } else {\n          array.push(_core.types.spreadElement(arg));\n        }\n\n        return array;\n      }\n\n      const value = convertAttributeValue(attribute.node.name.name !== \"key\" ? attribute.node.value || _core.types.booleanLiteral(true) : attribute.node.value);\n\n      if (attribute.node.name.name === \"key\" && value === null) {\n        throw attribute.buildCodeFrameError('Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.');\n      }\n\n      if (_core.types.isStringLiteral(value) && !_core.types.isJSXExpressionContainer(attribute.node.value)) {\n        var _value$extra;\n\n        value.value = value.value.replace(/\\n\\s+/g, \" \");\n        (_value$extra = value.extra) == null ? true : delete _value$extra.raw;\n      }\n\n      if (_core.types.isJSXNamespacedName(attribute.node.name)) {\n        attribute.node.name = _core.types.stringLiteral(attribute.node.name.namespace.name + \":\" + attribute.node.name.name.name);\n      } else if (_core.types.isValidIdentifier(attribute.node.name.name, false)) {\n        attribute.node.name.type = \"Identifier\";\n      } else {\n        attribute.node.name = _core.types.stringLiteral(attribute.node.name.name);\n      }\n\n      array.push(_core.types.inherits(_core.types.objectProperty(attribute.node.name, value), attribute.node));\n      return array;\n    }\n\n    function buildChildrenProperty(children) {\n      let childrenNode;\n\n      if (children.length === 1) {\n        childrenNode = children[0];\n      } else if (children.length > 1) {\n        childrenNode = _core.types.arrayExpression(children);\n      } else {\n        return undefined;\n      }\n\n      return _core.types.objectProperty(_core.types.identifier(\"children\"), childrenNode);\n    }\n\n    function buildJSXElementCall(path, file) {\n      const openingPath = path.get(\"openingElement\");\n      const args = [getTag(openingPath)];\n      const attribsArray = [];\n      const extracted = Object.create(null);\n\n      for (const attr of openingPath.get(\"attributes\")) {\n        if (attr.isJSXAttribute() && _core.types.isJSXIdentifier(attr.node.name)) {\n          const {\n            name\n          } = attr.node.name;\n\n          switch (name) {\n            case \"__source\":\n            case \"__self\":\n              if (extracted[name]) throw sourceSelfError(path, name);\n\n            case \"key\":\n              {\n                const keyValue = convertAttributeValue(attr.node.value);\n\n                if (keyValue === null) {\n                  throw attr.buildCodeFrameError('Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.');\n                }\n\n                extracted[name] = keyValue;\n                break;\n              }\n\n            default:\n              attribsArray.push(attr);\n          }\n        } else {\n          attribsArray.push(attr);\n        }\n      }\n\n      const children = _core.types.react.buildChildren(path.node);\n\n      let attribs;\n\n      if (attribsArray.length || children.length) {\n        attribs = buildJSXOpeningElementAttributes(attribsArray, children);\n      } else {\n        attribs = _core.types.objectExpression([]);\n      }\n\n      args.push(attribs);\n\n      if (development) {\n        var _extracted$key, _extracted$__source, _extracted$__self;\n\n        args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : path.scope.buildUndefinedNode());\n      } else if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    function buildJSXOpeningElementAttributes(attribs, children) {\n      const props = attribs.reduce(accumulateAttribute, []);\n\n      if ((children == null ? void 0 : children.length) > 0) {\n        props.push(buildChildrenProperty(children));\n      }\n\n      return _core.types.objectExpression(props);\n    }\n\n    function buildJSXFragmentCall(path, file) {\n      const args = [get(file, \"id/fragment\")()];\n\n      const children = _core.types.react.buildChildren(path.node);\n\n      args.push(_core.types.objectExpression(children.length > 0 ? [buildChildrenProperty(children)] : []));\n\n      if (development) {\n        args.push(path.scope.buildUndefinedNode(), _core.types.booleanLiteral(children.length > 1));\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    function buildCreateElementFragmentCall(path, file) {\n      if (filter && !filter(path.node, file)) return;\n      return call(file, \"createElement\", [get(file, \"id/fragment\")(), _core.types.nullLiteral(), ..._core.types.react.buildChildren(path.node)]);\n    }\n\n    function buildCreateElementCall(path, file) {\n      const openingPath = path.get(\"openingElement\");\n      return call(file, \"createElement\", [getTag(openingPath), buildCreateElementOpeningElementAttributes(file, path, openingPath.get(\"attributes\")), ..._core.types.react.buildChildren(path.node)]);\n    }\n\n    function getTag(openingPath) {\n      const tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);\n      let tagName;\n\n      if (_core.types.isIdentifier(tagExpr)) {\n        tagName = tagExpr.name;\n      } else if (_core.types.isStringLiteral(tagExpr)) {\n        tagName = tagExpr.value;\n      }\n\n      if (_core.types.react.isCompatTag(tagName)) {\n        return _core.types.stringLiteral(tagName);\n      } else {\n        return tagExpr;\n      }\n    }\n\n    function buildCreateElementOpeningElementAttributes(file, path, attribs) {\n      const runtime = get(file, \"runtime\");\n      {\n        if (runtime !== \"automatic\") {\n          const objs = [];\n          const props = attribs.reduce(accumulateAttribute, []);\n\n          if (!useSpread) {\n            let start = 0;\n            props.forEach((prop, i) => {\n              if (_core.types.isSpreadElement(prop)) {\n                if (i > start) {\n                  objs.push(_core.types.objectExpression(props.slice(start, i)));\n                }\n\n                objs.push(prop.argument);\n                start = i + 1;\n              }\n            });\n\n            if (props.length > start) {\n              objs.push(_core.types.objectExpression(props.slice(start)));\n            }\n          } else if (props.length) {\n            objs.push(_core.types.objectExpression(props));\n          }\n\n          if (!objs.length) {\n            return _core.types.nullLiteral();\n          }\n\n          if (objs.length === 1) {\n            if (!(_core.types.isSpreadElement(props[0]) && _core.types.isObjectExpression(props[0].argument))) {\n              return objs[0];\n            }\n          }\n\n          if (!_core.types.isObjectExpression(objs[0])) {\n            objs.unshift(_core.types.objectExpression([]));\n          }\n\n          const helper = useBuiltIns ? _core.types.memberExpression(_core.types.identifier(\"Object\"), _core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n          return _core.types.callExpression(helper, objs);\n        }\n      }\n      const props = [];\n      const found = Object.create(null);\n\n      for (const attr of attribs) {\n        const name = _core.types.isJSXAttribute(attr) && _core.types.isJSXIdentifier(attr.name) && attr.name.name;\n\n        if (runtime === \"automatic\" && (name === \"__source\" || name === \"__self\")) {\n          if (found[name]) throw sourceSelfError(path, name);\n          found[name] = true;\n        }\n\n        accumulateAttribute(props, attr);\n      }\n\n      return props.length === 1 && _core.types.isSpreadElement(props[0]) && !_core.types.isObjectExpression(props[0].argument) ? props[0].argument : props.length > 0 ? _core.types.objectExpression(props) : _core.types.nullLiteral();\n    }\n  });\n\n  function getSource(source, importName) {\n    switch (importName) {\n      case \"Fragment\":\n        return `${source}/${development ? \"jsx-dev-runtime\" : \"jsx-runtime\"}`;\n\n      case \"jsxDEV\":\n        return `${source}/jsx-dev-runtime`;\n\n      case \"jsx\":\n      case \"jsxs\":\n        return `${source}/jsx-runtime`;\n\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function createImportLazily(pass, path, importName, source) {\n    return () => {\n      const actualSource = getSource(source, importName);\n\n      if ((0, _helperModuleImports.isModule)(path)) {\n        let reference = get(pass, `imports/${importName}`);\n        if (reference) return _core.types.cloneNode(reference);\n        reference = (0, _helperModuleImports.addNamed)(path, importName, actualSource, {\n          importedInterop: \"uncompiled\",\n          importPosition: \"after\"\n        });\n        set(pass, `imports/${importName}`, reference);\n        return reference;\n      } else {\n        let reference = get(pass, `requires/${actualSource}`);\n\n        if (reference) {\n          reference = _core.types.cloneNode(reference);\n        } else {\n          reference = (0, _helperModuleImports.addNamespace)(path, actualSource, {\n            importedInterop: \"uncompiled\"\n          });\n          set(pass, `requires/${actualSource}`, reference);\n        }\n\n        return _core.types.memberExpression(reference, _core.types.identifier(importName));\n      }\n    };\n  }\n}\n\nfunction toMemberExpression(id) {\n  return id.split(\".\").map(name => _core.types.identifier(name)).reduce((object, property) => _core.types.memberExpression(object, property));\n}\n\nfunction makeSource(path, state) {\n  const location = path.node.loc;\n\n  if (!location) {\n    return path.scope.buildUndefinedNode();\n  }\n\n  if (!state.fileNameIdentifier) {\n    const {\n      filename = \"\"\n    } = state;\n    const fileNameIdentifier = path.scope.generateUidIdentifier(\"_jsxFileName\");\n    const scope = path.hub.getScope();\n\n    if (scope) {\n      scope.push({\n        id: fileNameIdentifier,\n        init: _core.types.stringLiteral(filename)\n      });\n    }\n\n    state.fileNameIdentifier = fileNameIdentifier;\n  }\n\n  return makeTrace(_core.types.cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);\n}\n\nfunction makeTrace(fileNameIdentifier, lineNumber, column0Based) {\n  const fileLineLiteral = lineNumber != null ? _core.types.numericLiteral(lineNumber) : _core.types.nullLiteral();\n  const fileColumnLiteral = column0Based != null ? _core.types.numericLiteral(column0Based + 1) : _core.types.nullLiteral();\n\n  const fileNameProperty = _core.types.objectProperty(_core.types.identifier(\"fileName\"), fileNameIdentifier);\n\n  const lineNumberProperty = _core.types.objectProperty(_core.types.identifier(\"lineNumber\"), fileLineLiteral);\n\n  const columnNumberProperty = _core.types.objectProperty(_core.types.identifier(\"columnNumber\"), fileColumnLiteral);\n\n  return _core.types.objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);\n}\n\nfunction sourceSelfError(path, name) {\n  const pluginName = `transform-react-jsx-${name.slice(2)}`;\n  return path.buildCodeFrameError(`Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`);\n}","map":{"version":3,"mappings":"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","names":["DEFAULT","importSource","runtime","pragma","pragmaFrag","JSX_SOURCE_ANNOTATION_REGEX","JSX_RUNTIME_ANNOTATION_REGEX","JSX_ANNOTATION_REGEX","JSX_FRAG_ANNOTATION_REGEX","get","pass","name","set","v","hasProto","node","properties","some","value","t","isObjectProperty","computed","shorthand","isIdentifier","key","isStringLiteral","createPlugin","development","_","options","pure","PURE_ANNOTATION","throwIfNamespace","filter","RUNTIME_DEFAULT","IMPORT_SOURCE_DEFAULT","PRAGMA_DEFAULT","PRAGMA_FRAG_DEFAULT","useSpread","useBuiltIns","Error","injectMetaPropertiesVisitor","JSXOpeningElement","path","state","attributes","isThisAllowed","scope","push","jsxAttribute","jsxIdentifier","jsxExpressionContainer","thisExpression","makeSource","pushContainer","inherits","jsx","visitor","JSXNamespacedName","buildCodeFrameError","JSXSpreadChild","Program","enter","file","source","sourceSet","pragmaSet","pragmaFragSet","ast","comments","comment","sourceMatches","exec","runtimeMatches","jsxMatches","jsxFragMatches","createElement","toMemberExpression","fragment","cloneNode","define","id","createImportLazily","traverse","JSXElement","exit","callExpr","shouldUseCreateElement","buildCreateElementCall","buildJSXElementCall","replaceWith","JSXFragment","buildCreateElementFragmentCall","buildJSXFragmentCall","JSXAttribute","isJSXElement","isDerivedClass","classPath","superClass","isFunctionParent","isArrowFunctionExpression","isMethod","kind","parentPath","isTSModuleBlock","parent","call","args","callExpression","openingPath","seenPropsSpread","i","length","attr","isJSXAttribute","isJSXSpreadAttribute","convertJSXIdentifier","isJSXIdentifier","isReferenced","isValidIdentifier","type","stringLiteral","isJSXMemberExpression","memberExpression","object","property","isJSXNamespacedName","namespace","convertAttributeValue","isJSXExpressionContainer","expression","accumulateAttribute","array","attribute","arg","argument","isObjectExpression","spreadElement","booleanLiteral","replace","extra","_value$extra","raw","objectProperty","buildChildrenProperty","children","childrenNode","arrayExpression","undefined","identifier","getTag","attribsArray","extracted","Object","create","sourceSelfError","keyValue","react","buildChildren","attribs","buildJSXOpeningElementAttributes","objectExpression","buildUndefinedNode","__source","__self","props","reduce","nullLiteral","buildCreateElementOpeningElementAttributes","tagExpr","tagName","isCompatTag","objs","start","forEach","prop","isSpreadElement","slice","unshift","helper","addHelper","found","getSource","importName","actualSource","reference","importedInterop","importPosition","split","map","location","loc","fileNameIdentifier","filename","generateUidIdentifier","hub","getScope","init","makeTrace","line","column","lineNumber","column0Based","fileLineLiteral","numericLiteral","fileColumnLiteral","fileNameProperty","lineNumberProperty","columnNumberProperty","pluginName"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-transform-react-jsx\\src\\create-plugin.ts"],"sourcesContent":["import jsx from \"@babel/plugin-syntax-jsx\";\nimport { declare } from \"@babel/helper-plugin-utils\";\nimport { types as t } from \"@babel/core\";\nimport type { PluginPass } from \"@babel/core\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\nimport { addNamed, addNamespace, isModule } from \"@babel/helper-module-imports\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport type {\n  CallExpression,\n  Class,\n  Expression,\n  Identifier,\n  JSXAttribute,\n  JSXElement,\n  JSXFragment,\n  JSXOpeningElement,\n  JSXSpreadAttribute,\n  MemberExpression,\n  ObjectExpression,\n  Program,\n} from \"@babel/types\";\n\nconst DEFAULT = {\n  importSource: \"react\",\n  runtime: \"automatic\",\n  pragma: \"React.createElement\",\n  pragmaFrag: \"React.Fragment\",\n};\n\nconst JSX_SOURCE_ANNOTATION_REGEX =\n  /^\\s*\\*?\\s*@jsxImportSource\\s+([^\\s]+)\\s*$/m;\nconst JSX_RUNTIME_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxRuntime\\s+([^\\s]+)\\s*$/m;\n\nconst JSX_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsx\\s+([^\\s]+)\\s*$/m;\nconst JSX_FRAG_ANNOTATION_REGEX = /^\\s*\\*?\\s*@jsxFrag\\s+([^\\s]+)\\s*$/m;\n\nconst get = (pass: PluginPass, name: string) =>\n  pass.get(`@babel/plugin-react-jsx/${name}`);\nconst set = (pass: PluginPass, name: string, v: any) =>\n  pass.set(`@babel/plugin-react-jsx/${name}`, v);\n\nfunction hasProto(node: t.ObjectExpression) {\n  return node.properties.some(\n    value =>\n      t.isObjectProperty(value, { computed: false, shorthand: false }) &&\n      (t.isIdentifier(value.key, { name: \"__proto__\" }) ||\n        t.isStringLiteral(value.key, { value: \"__proto__\" })),\n  );\n}\n\nexport interface Options {\n  filter?: (node: t.Node, pass: PluginPass) => boolean;\n  importSource?: string;\n  pragma?: string;\n  pragmaFrag?: string;\n  pure?: string;\n  runtime?: \"automatic\" | \"classic\";\n  throwIfNamespace?: boolean;\n  useBuiltIns: boolean;\n  useSpread?: boolean;\n}\nexport default function createPlugin({\n  name,\n  development,\n}: {\n  name: string;\n  development: boolean;\n}) {\n  return declare((_, options: Options) => {\n    const {\n      pure: PURE_ANNOTATION,\n\n      throwIfNamespace = true,\n\n      // TODO (Babel 8): It should throw if this option is used with the automatic runtime\n      filter,\n\n      runtime: RUNTIME_DEFAULT = process.env.BABEL_8_BREAKING\n        ? \"automatic\"\n        : development\n        ? \"automatic\"\n        : \"classic\",\n\n      importSource: IMPORT_SOURCE_DEFAULT = DEFAULT.importSource,\n      pragma: PRAGMA_DEFAULT = DEFAULT.pragma,\n      pragmaFrag: PRAGMA_FRAG_DEFAULT = DEFAULT.pragmaFrag,\n    } = options;\n\n    if (process.env.BABEL_8_BREAKING) {\n      if (\"useSpread\" in options) {\n        throw new Error(\n          '@babel/plugin-transform-react-jsx: Since Babel 8, an inline object with spread elements is always used, and the \"useSpread\" option is no longer available. Please remove it from your config.',\n        );\n      }\n\n      if (\"useBuiltIns\" in options) {\n        const useBuiltInsFormatted = JSON.stringify(options.useBuiltIns);\n        throw new Error(\n          `@babel/plugin-transform-react-jsx: Since \"useBuiltIns\" is removed in Babel 8, you can remove it from the config.\n- Babel 8 now transforms JSX spread to object spread. If you need to transpile object spread with\n\\`useBuiltIns: ${useBuiltInsFormatted}\\`, you can use the following config\n{\n  \"plugins\": [\n    \"@babel/plugin-transform-react-jsx\"\n    [\"@babel/plugin-proposal-object-rest-spread\", { \"loose\": true, \"useBuiltIns\": ${useBuiltInsFormatted} }]\n  ]\n}`,\n        );\n      }\n    } else {\n      // eslint-disable-next-line no-var\n      var { useSpread = false, useBuiltIns = false } = options;\n\n      if (RUNTIME_DEFAULT === \"classic\") {\n        if (typeof useSpread !== \"boolean\") {\n          throw new Error(\n            \"transform-react-jsx currently only accepts a boolean option for \" +\n              \"useSpread (defaults to false)\",\n          );\n        }\n\n        if (typeof useBuiltIns !== \"boolean\") {\n          throw new Error(\n            \"transform-react-jsx currently only accepts a boolean option for \" +\n              \"useBuiltIns (defaults to false)\",\n          );\n        }\n\n        if (useSpread && useBuiltIns) {\n          throw new Error(\n            \"transform-react-jsx currently only accepts useBuiltIns or useSpread \" +\n              \"but not both\",\n          );\n        }\n      }\n    }\n\n    const injectMetaPropertiesVisitor: Visitor<PluginPass> = {\n      JSXOpeningElement(path, state) {\n        const attributes = [];\n        if (isThisAllowed(path.scope)) {\n          attributes.push(\n            t.jsxAttribute(\n              t.jsxIdentifier(\"__self\"),\n              t.jsxExpressionContainer(t.thisExpression()),\n            ),\n          );\n        }\n        attributes.push(\n          t.jsxAttribute(\n            t.jsxIdentifier(\"__source\"),\n            t.jsxExpressionContainer(makeSource(path, state)),\n          ),\n        );\n        path.pushContainer(\"attributes\", attributes);\n      },\n    };\n\n    return {\n      name,\n      inherits: jsx,\n      visitor: {\n        JSXNamespacedName(path) {\n          if (throwIfNamespace) {\n            throw path.buildCodeFrameError(\n              `Namespace tags are not supported by default. React's JSX doesn't support namespace tags. \\\nYou can set \\`throwIfNamespace: false\\` to bypass this warning.`,\n            );\n          }\n        },\n\n        JSXSpreadChild(path) {\n          throw path.buildCodeFrameError(\n            \"Spread children are not supported in React.\",\n          );\n        },\n\n        Program: {\n          enter(path, state) {\n            const { file } = state;\n            let runtime: string = RUNTIME_DEFAULT;\n\n            let source: string = IMPORT_SOURCE_DEFAULT;\n            let pragma: string = PRAGMA_DEFAULT;\n            let pragmaFrag: string = PRAGMA_FRAG_DEFAULT;\n\n            let sourceSet = !!options.importSource;\n            let pragmaSet = !!options.pragma;\n            let pragmaFragSet = !!options.pragmaFrag;\n\n            if (file.ast.comments) {\n              for (const comment of file.ast.comments) {\n                const sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (sourceMatches) {\n                  source = sourceMatches[1];\n                  sourceSet = true;\n                }\n\n                const runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (runtimeMatches) {\n                  runtime = runtimeMatches[1];\n                }\n\n                const jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);\n                if (jsxMatches) {\n                  pragma = jsxMatches[1];\n                  pragmaSet = true;\n                }\n                const jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(\n                  comment.value,\n                );\n                if (jsxFragMatches) {\n                  pragmaFrag = jsxFragMatches[1];\n                  pragmaFragSet = true;\n                }\n              }\n            }\n\n            set(state, \"runtime\", runtime);\n            if (runtime === \"classic\") {\n              if (sourceSet) {\n                throw path.buildCodeFrameError(\n                  `importSource cannot be set when runtime is classic.`,\n                );\n              }\n\n              const createElement = toMemberExpression(pragma);\n              const fragment = toMemberExpression(pragmaFrag);\n\n              set(state, \"id/createElement\", () => t.cloneNode(createElement));\n              set(state, \"id/fragment\", () => t.cloneNode(fragment));\n\n              set(state, \"defaultPure\", pragma === DEFAULT.pragma);\n            } else if (runtime === \"automatic\") {\n              if (pragmaSet || pragmaFragSet) {\n                throw path.buildCodeFrameError(\n                  `pragma and pragmaFrag cannot be set when runtime is automatic.`,\n                );\n              }\n\n              const define = (name: string, id: string) =>\n                set(state, name, createImportLazily(state, path, id, source));\n\n              define(\"id/jsx\", development ? \"jsxDEV\" : \"jsx\");\n              define(\"id/jsxs\", development ? \"jsxDEV\" : \"jsxs\");\n              define(\"id/createElement\", \"createElement\");\n              define(\"id/fragment\", \"Fragment\");\n\n              set(state, \"defaultPure\", source === DEFAULT.importSource);\n            } else {\n              throw path.buildCodeFrameError(\n                `Runtime must be either \"classic\" or \"automatic\".`,\n              );\n            }\n\n            if (development) {\n              path.traverse(injectMetaPropertiesVisitor, state);\n            }\n          },\n\n          // TODO (Babel 8): Decide if this should be removed or brought back.\n          // see: https://github.com/babel/babel/pull/12253#discussion_r513086528\n          //\n          // exit(path, state) {\n          //   if (\n          //     get(state, \"runtime\") === \"classic\" &&\n          //     get(state, \"pragmaSet\") &&\n          //     get(state, \"usedFragment\") &&\n          //     !get(state, \"pragmaFragSet\")\n          //   ) {\n          //     throw new Error(\n          //       \"transform-react-jsx: pragma has been set but \" +\n          //         \"pragmaFrag has not been set\",\n          //     );\n          //   }\n          // },\n        },\n\n        JSXElement: {\n          exit(path, file) {\n            let callExpr;\n            if (\n              get(file, \"runtime\") === \"classic\" ||\n              shouldUseCreateElement(path)\n            ) {\n              callExpr = buildCreateElementCall(path, file);\n            } else {\n              callExpr = buildJSXElementCall(path, file);\n            }\n\n            path.replaceWith(t.inherits(callExpr, path.node));\n          },\n        },\n\n        JSXFragment: {\n          exit(path, file) {\n            let callExpr;\n            if (get(file, \"runtime\") === \"classic\") {\n              callExpr = buildCreateElementFragmentCall(path, file);\n            } else {\n              callExpr = buildJSXFragmentCall(path, file);\n            }\n\n            path.replaceWith(t.inherits(callExpr, path.node));\n          },\n        },\n\n        JSXAttribute(path) {\n          if (t.isJSXElement(path.node.value)) {\n            path.node.value = t.jsxExpressionContainer(path.node.value);\n          }\n        },\n      } as Visitor<PluginPass>,\n    };\n\n    // Returns whether the class has specified a superclass.\n    function isDerivedClass(classPath: NodePath<Class>) {\n      return classPath.node.superClass !== null;\n    }\n\n    // Returns whether `this` is allowed at given scope.\n    function isThisAllowed(scope: Scope) {\n      // This specifically skips arrow functions as they do not rewrite `this`.\n      do {\n        const { path } = scope;\n        if (path.isFunctionParent() && !path.isArrowFunctionExpression()) {\n          if (!path.isMethod()) {\n            // If the closest parent is a regular function, `this` will be rebound, therefore it is fine to use `this`.\n            return true;\n          }\n          // Current node is within a method, so we need to check if the method is a constructor.\n          if (path.node.kind !== \"constructor\") {\n            // We are not in a constructor, therefore it is always fine to use `this`.\n            return true;\n          }\n          // Now we are in a constructor. If it is a derived class, we do not reference `this`.\n          return !isDerivedClass(path.parentPath.parentPath as NodePath<Class>);\n        }\n        if (path.isTSModuleBlock()) {\n          // If the closeset parent is a TS Module block, `this` will not be allowed.\n          return false;\n        }\n      } while ((scope = scope.parent));\n      // We are not in a method or function. It is fine to use `this`.\n      return true;\n    }\n\n    function call(\n      pass: PluginPass,\n      name: string,\n      args: CallExpression[\"arguments\"],\n    ) {\n      const node = t.callExpression(get(pass, `id/${name}`)(), args);\n      if (PURE_ANNOTATION ?? get(pass, \"defaultPure\")) annotateAsPure(node);\n      return node;\n    }\n\n    // We want to use React.createElement, even in the case of\n    // jsx, for <div {...props} key={key} /> to distinguish it\n    // from <div key={key} {...props} />. This is an intermediary\n    // step while we deprecate key spread from props. Afterwards,\n    // we will stop using createElement in the transform.\n    function shouldUseCreateElement(path: NodePath<JSXElement>) {\n      const openingPath = path.get(\"openingElement\");\n      const attributes = openingPath.node.attributes;\n\n      let seenPropsSpread = false;\n      for (let i = 0; i < attributes.length; i++) {\n        const attr = attributes[i];\n        if (\n          seenPropsSpread &&\n          t.isJSXAttribute(attr) &&\n          attr.name.name === \"key\"\n        ) {\n          return true;\n        } else if (t.isJSXSpreadAttribute(attr)) {\n          seenPropsSpread = true;\n        }\n      }\n      return false;\n    }\n\n    function convertJSXIdentifier(\n      node: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n      parent: t.JSXOpeningElement | t.JSXMemberExpression,\n    ): t.ThisExpression | t.StringLiteral | t.MemberExpression | t.Identifier {\n      if (t.isJSXIdentifier(node)) {\n        if (node.name === \"this\" && t.isReferenced(node, parent)) {\n          return t.thisExpression();\n        } else if (t.isValidIdentifier(node.name, false)) {\n          // @ts-expect-error cast AST type to Identifier\n          node.type = \"Identifier\";\n          return node as unknown as t.Identifier;\n        } else {\n          return t.stringLiteral(node.name);\n        }\n      } else if (t.isJSXMemberExpression(node)) {\n        return t.memberExpression(\n          convertJSXIdentifier(node.object, node),\n          convertJSXIdentifier(node.property, node),\n        );\n      } else if (t.isJSXNamespacedName(node)) {\n        /**\n         * If the flag \"throwIfNamespace\" is false\n         * print XMLNamespace like string literal\n         */\n        return t.stringLiteral(`${node.namespace.name}:${node.name.name}`);\n      }\n\n      // todo: this branch should be unreachable\n      return node;\n    }\n\n    function convertAttributeValue(\n      node: t.JSXAttribute[\"value\"] | t.BooleanLiteral,\n    ) {\n      if (t.isJSXExpressionContainer(node)) {\n        return node.expression;\n      } else {\n        return node;\n      }\n    }\n\n    function accumulateAttribute(\n      array: ObjectExpression[\"properties\"],\n      attribute: NodePath<JSXAttribute | JSXSpreadAttribute>,\n    ) {\n      if (t.isJSXSpreadAttribute(attribute.node)) {\n        const arg = attribute.node.argument;\n        // Collect properties into props array if spreading object expression\n        if (t.isObjectExpression(arg) && !hasProto(arg)) {\n          array.push(...arg.properties);\n        } else {\n          array.push(t.spreadElement(arg));\n        }\n        return array;\n      }\n\n      const value = convertAttributeValue(\n        attribute.node.name.name !== \"key\"\n          ? attribute.node.value || t.booleanLiteral(true)\n          : attribute.node.value,\n      );\n\n      if (attribute.node.name.name === \"key\" && value === null) {\n        throw attribute.buildCodeFrameError(\n          'Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.',\n        );\n      }\n\n      if (\n        t.isStringLiteral(value) &&\n        !t.isJSXExpressionContainer(attribute.node.value)\n      ) {\n        value.value = value.value.replace(/\\n\\s+/g, \" \");\n\n        // \"raw\" JSXText should not be used from a StringLiteral because it needs to be escaped.\n        delete value.extra?.raw;\n      }\n\n      if (t.isJSXNamespacedName(attribute.node.name)) {\n        // @ts-expect-error mutating AST\n        attribute.node.name = t.stringLiteral(\n          attribute.node.name.namespace.name +\n            \":\" +\n            attribute.node.name.name.name,\n        );\n      } else if (t.isValidIdentifier(attribute.node.name.name, false)) {\n        // @ts-expect-error mutating AST\n        attribute.node.name.type = \"Identifier\";\n      } else {\n        // @ts-expect-error mutating AST\n        attribute.node.name = t.stringLiteral(attribute.node.name.name);\n      }\n\n      array.push(\n        t.inherits(\n          t.objectProperty(\n            // @ts-expect-error The attribute.node.name is an Identifier now\n            attribute.node.name,\n            value,\n          ),\n          attribute.node,\n        ),\n      );\n      return array;\n    }\n\n    function buildChildrenProperty(children: Expression[]) {\n      let childrenNode;\n      if (children.length === 1) {\n        childrenNode = children[0];\n      } else if (children.length > 1) {\n        childrenNode = t.arrayExpression(children);\n      } else {\n        return undefined;\n      }\n\n      return t.objectProperty(t.identifier(\"children\"), childrenNode);\n    }\n\n    // Builds JSX into:\n    // Production: React.jsx(type, arguments, key)\n    // Development: React.jsxDEV(type, arguments, key, isStaticChildren, source, self)\n    function buildJSXElementCall(path: NodePath<JSXElement>, file: PluginPass) {\n      const openingPath = path.get(\"openingElement\");\n      const args: t.Expression[] = [getTag(openingPath)];\n\n      const attribsArray = [];\n      const extracted = Object.create(null);\n\n      // for React.jsx, key, __source (dev), and __self (dev) is passed in as\n      // a separate argument rather than in the args object. We go through the\n      // props and filter out these three keywords so we can pass them in\n      // as separate arguments later\n      for (const attr of openingPath.get(\"attributes\")) {\n        if (attr.isJSXAttribute() && t.isJSXIdentifier(attr.node.name)) {\n          const { name } = attr.node.name;\n          switch (name) {\n            case \"__source\":\n            case \"__self\":\n              if (extracted[name]) throw sourceSelfError(path, name);\n            /* falls through */\n            case \"key\": {\n              const keyValue = convertAttributeValue(attr.node.value);\n              if (keyValue === null) {\n                throw attr.buildCodeFrameError(\n                  'Please provide an explicit key value. Using \"key\" as a shorthand for \"key={true}\" is not allowed.',\n                );\n              }\n\n              extracted[name] = keyValue;\n              break;\n            }\n            default:\n              attribsArray.push(attr);\n          }\n        } else {\n          attribsArray.push(attr);\n        }\n      }\n\n      const children = t.react.buildChildren(path.node);\n\n      let attribs: t.ObjectExpression;\n\n      if (attribsArray.length || children.length) {\n        attribs = buildJSXOpeningElementAttributes(\n          attribsArray,\n          //@ts-expect-error The children here contains JSXSpreadChild,\n          // which will be thrown later\n          children,\n        );\n      } else {\n        // attributes should never be null\n        attribs = t.objectExpression([]);\n      }\n\n      args.push(attribs);\n\n      if (development) {\n        // isStaticChildren, __source, and __self are only used in development\n        // automatically include __source and __self in this plugin\n        // so we can eliminate the need for separate Babel plugins in Babel 8\n        args.push(\n          extracted.key ?? path.scope.buildUndefinedNode(),\n          t.booleanLiteral(children.length > 1),\n          extracted.__source ?? path.scope.buildUndefinedNode(),\n          extracted.__self ?? path.scope.buildUndefinedNode(),\n        );\n      } else if (extracted.key !== undefined) {\n        args.push(extracted.key);\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    // Builds props for React.jsx. This function adds children into the props\n    // and ensures that props is always an object\n    function buildJSXOpeningElementAttributes(\n      attribs: NodePath<JSXAttribute | JSXSpreadAttribute>[],\n      children: Expression[],\n    ) {\n      const props = attribs.reduce(accumulateAttribute, []);\n\n      // In React.jsx, children is no longer a separate argument, but passed in\n      // through the argument object\n      if (children?.length > 0) {\n        props.push(buildChildrenProperty(children));\n      }\n\n      return t.objectExpression(props);\n    }\n\n    // Builds JSX Fragment <></> into\n    // Production: React.jsx(type, arguments)\n    // Development: React.jsxDEV(type, { children })\n    function buildJSXFragmentCall(\n      path: NodePath<JSXFragment>,\n      file: PluginPass,\n    ) {\n      const args = [get(file, \"id/fragment\")()];\n\n      const children = t.react.buildChildren(path.node);\n\n      args.push(\n        t.objectExpression(\n          children.length > 0\n            ? [\n                buildChildrenProperty(\n                  //@ts-expect-error The children here contains JSXSpreadChild,\n                  // which will be thrown later\n                  children,\n                ),\n              ]\n            : [],\n        ),\n      );\n\n      if (development) {\n        args.push(\n          path.scope.buildUndefinedNode(),\n          t.booleanLiteral(children.length > 1),\n        );\n      }\n\n      return call(file, children.length > 1 ? \"jsxs\" : \"jsx\", args);\n    }\n\n    // Builds JSX Fragment <></> into\n    // React.createElement(React.Fragment, null, ...children)\n    function buildCreateElementFragmentCall(\n      path: NodePath<JSXFragment>,\n      file: PluginPass,\n    ) {\n      if (filter && !filter(path.node, file)) return;\n\n      return call(file, \"createElement\", [\n        get(file, \"id/fragment\")(),\n        t.nullLiteral(),\n        ...t.react.buildChildren(path.node),\n      ]);\n    }\n\n    // Builds JSX into:\n    // Production: React.createElement(type, arguments, children)\n    // Development: React.createElement(type, arguments, children, source, self)\n    function buildCreateElementCall(\n      path: NodePath<JSXElement>,\n      file: PluginPass,\n    ) {\n      const openingPath = path.get(\"openingElement\");\n\n      return call(file, \"createElement\", [\n        getTag(openingPath),\n        buildCreateElementOpeningElementAttributes(\n          file,\n          path,\n          openingPath.get(\"attributes\"),\n        ),\n        // @ts-expect-error JSXSpreadChild has been transformed in convertAttributeValue\n        ...t.react.buildChildren(path.node),\n      ]);\n    }\n\n    function getTag(openingPath: NodePath<JSXOpeningElement>) {\n      const tagExpr = convertJSXIdentifier(\n        openingPath.node.name,\n        openingPath.node,\n      );\n\n      let tagName: string;\n      if (t.isIdentifier(tagExpr)) {\n        tagName = tagExpr.name;\n      } else if (t.isStringLiteral(tagExpr)) {\n        tagName = tagExpr.value;\n      }\n\n      if (t.react.isCompatTag(tagName)) {\n        return t.stringLiteral(tagName);\n      } else {\n        return tagExpr;\n      }\n    }\n\n    /**\n     * The logic for this is quite terse. It's because we need to\n     * support spread elements. We loop over all attributes,\n     * breaking on spreads, we then push a new object containing\n     * all prior attributes to an array for later processing.\n     */\n    function buildCreateElementOpeningElementAttributes(\n      file: PluginPass,\n      path: NodePath<JSXElement>,\n      attribs: NodePath<JSXAttribute | JSXSpreadAttribute>[],\n    ) {\n      const runtime = get(file, \"runtime\");\n      if (!process.env.BABEL_8_BREAKING) {\n        if (runtime !== \"automatic\") {\n          const objs = [];\n          const props = attribs.reduce(accumulateAttribute, []);\n\n          if (!useSpread) {\n            // Convert syntax to use multiple objects instead of spread\n            let start = 0;\n            props.forEach((prop, i) => {\n              if (t.isSpreadElement(prop)) {\n                if (i > start) {\n                  objs.push(t.objectExpression(props.slice(start, i)));\n                }\n                objs.push(prop.argument);\n                start = i + 1;\n              }\n            });\n            if (props.length > start) {\n              objs.push(t.objectExpression(props.slice(start)));\n            }\n          } else if (props.length) {\n            objs.push(t.objectExpression(props));\n          }\n\n          if (!objs.length) {\n            return t.nullLiteral();\n          }\n\n          if (objs.length === 1) {\n            if (\n              !(\n                t.isSpreadElement(props[0]) &&\n                // If an object expression is spread element's argument\n                // it is very likely to contain __proto__ and we should stop\n                // optimizing spread element\n                t.isObjectExpression(props[0].argument)\n              )\n            ) {\n              return objs[0];\n            }\n          }\n\n          // looks like we have multiple objects\n          if (!t.isObjectExpression(objs[0])) {\n            objs.unshift(t.objectExpression([]));\n          }\n\n          const helper = useBuiltIns\n            ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n            : file.addHelper(\"extends\");\n\n          // spread it\n          return t.callExpression(helper, objs);\n        }\n      }\n\n      const props: ObjectExpression[\"properties\"] = [];\n      const found = Object.create(null);\n\n      for (const attr of attribs) {\n        const name =\n          t.isJSXAttribute(attr) &&\n          t.isJSXIdentifier(attr.name) &&\n          attr.name.name;\n\n        if (\n          runtime === \"automatic\" &&\n          (name === \"__source\" || name === \"__self\")\n        ) {\n          if (found[name]) throw sourceSelfError(path, name);\n          found[name] = true;\n        }\n\n        accumulateAttribute(props, attr);\n      }\n\n      return props.length === 1 &&\n        t.isSpreadElement(props[0]) &&\n        // If an object expression is spread element's argument\n        // it is very likely to contain __proto__ and we should stop\n        // optimizing spread element\n        !t.isObjectExpression(props[0].argument)\n        ? props[0].argument\n        : props.length > 0\n        ? t.objectExpression(props)\n        : t.nullLiteral();\n    }\n  });\n\n  function getSource(source: string, importName: string) {\n    switch (importName) {\n      case \"Fragment\":\n        return `${source}/${development ? \"jsx-dev-runtime\" : \"jsx-runtime\"}`;\n      case \"jsxDEV\":\n        return `${source}/jsx-dev-runtime`;\n      case \"jsx\":\n      case \"jsxs\":\n        return `${source}/jsx-runtime`;\n      case \"createElement\":\n        return source;\n    }\n  }\n\n  function createImportLazily(\n    pass: PluginPass,\n    path: NodePath<Program>,\n    importName: string,\n    source: string,\n  ): () => Identifier | MemberExpression {\n    return () => {\n      const actualSource = getSource(source, importName);\n      if (isModule(path)) {\n        let reference = get(pass, `imports/${importName}`);\n        if (reference) return t.cloneNode(reference);\n\n        reference = addNamed(path, importName, actualSource, {\n          importedInterop: \"uncompiled\",\n          importPosition: \"after\",\n        });\n        set(pass, `imports/${importName}`, reference);\n\n        return reference;\n      } else {\n        let reference = get(pass, `requires/${actualSource}`);\n        if (reference) {\n          reference = t.cloneNode(reference);\n        } else {\n          reference = addNamespace(path, actualSource, {\n            importedInterop: \"uncompiled\",\n          });\n          set(pass, `requires/${actualSource}`, reference);\n        }\n\n        return t.memberExpression(reference, t.identifier(importName));\n      }\n    };\n  }\n}\n\nfunction toMemberExpression(id: string): Identifier | MemberExpression {\n  return (\n    id\n      .split(\".\")\n      .map(name => t.identifier(name))\n      // @ts-expect-error - The Array#reduce does not have a signature\n      // where the type of initialial value differs from callback return type\n      .reduce((object, property) => t.memberExpression(object, property))\n  );\n}\n\nfunction makeSource(path: NodePath, state: PluginPass) {\n  const location = path.node.loc;\n  if (!location) {\n    // the element was generated and doesn't have location information\n    return path.scope.buildUndefinedNode();\n  }\n\n  // @ts-expect-error todo: avoid mutating PluginPass\n  if (!state.fileNameIdentifier) {\n    const { filename = \"\" } = state;\n\n    const fileNameIdentifier = path.scope.generateUidIdentifier(\"_jsxFileName\");\n    const scope = path.hub.getScope();\n    if (scope) {\n      scope.push({\n        id: fileNameIdentifier,\n        init: t.stringLiteral(filename),\n      });\n    }\n    // @ts-expect-error todo: avoid mutating PluginPass\n    state.fileNameIdentifier = fileNameIdentifier;\n  }\n\n  return makeTrace(\n    t.cloneNode(\n      // @ts-expect-error todo: avoid mutating PluginPass\n      state.fileNameIdentifier,\n    ),\n    location.start.line,\n    location.start.column,\n  );\n}\n\nfunction makeTrace(\n  fileNameIdentifier: Identifier,\n  lineNumber?: number,\n  column0Based?: number,\n) {\n  const fileLineLiteral =\n    lineNumber != null ? t.numericLiteral(lineNumber) : t.nullLiteral();\n\n  const fileColumnLiteral =\n    column0Based != null ? t.numericLiteral(column0Based + 1) : t.nullLiteral();\n\n  const fileNameProperty = t.objectProperty(\n    t.identifier(\"fileName\"),\n    fileNameIdentifier,\n  );\n  const lineNumberProperty = t.objectProperty(\n    t.identifier(\"lineNumber\"),\n    fileLineLiteral,\n  );\n  const columnNumberProperty = t.objectProperty(\n    t.identifier(\"columnNumber\"),\n    fileColumnLiteral,\n  );\n  return t.objectExpression([\n    fileNameProperty,\n    lineNumberProperty,\n    columnNumberProperty,\n  ]);\n}\n\nfunction sourceSelfError(path: NodePath, name: string) {\n  const pluginName = `transform-react-jsx-${name.slice(2)}`;\n\n  return path.buildCodeFrameError(\n    `Duplicate ${name} prop found. You are most likely using the deprecated ${pluginName} Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.`,\n  );\n}\n"]},"metadata":{},"sourceType":"script"}