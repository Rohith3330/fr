{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst {\n  visitSkip\n} = require('../lib/xast.js');\n\nconst {\n  referencesProps\n} = require('./_collections.js');\n\nexports.type = 'visitor';\nexports.name = 'cleanupIDs';\nexports.active = true;\nexports.description = 'removes unused IDs and minifies used';\nconst regReferencesUrl = /\\burl\\((\"|')?#(.+?)\\1\\)/;\nconst regReferencesHref = /^#(.+?)$/;\nconst regReferencesBegin = /(\\w+)\\./;\nconst generateIDchars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\nconst maxIDindex = generateIDchars.length - 1;\n/**\n * Check if an ID starts with any one of a list of strings.\n *\n * @type {(string: string, prefixes: Array<string>) => boolean}\n */\n\nconst hasStringPrefix = (string, prefixes) => {\n  for (const prefix of prefixes) {\n    if (string.startsWith(prefix)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Generate unique minimal ID.\n *\n * @type {(currentID: null | Array<number>) => Array<number>}\n */\n\n\nconst generateID = currentID => {\n  if (currentID == null) {\n    return [0];\n  }\n\n  currentID[currentID.length - 1] += 1;\n\n  for (let i = currentID.length - 1; i > 0; i--) {\n    if (currentID[i] > maxIDindex) {\n      currentID[i] = 0;\n\n      if (currentID[i - 1] !== undefined) {\n        currentID[i - 1]++;\n      }\n    }\n  }\n\n  if (currentID[0] > maxIDindex) {\n    currentID[0] = 0;\n    currentID.unshift(0);\n  }\n\n  return currentID;\n};\n/**\n * Get string from generated ID array.\n *\n * @type {(arr: Array<number>, prefix: string) => string}\n */\n\n\nconst getIDstring = (arr, prefix) => {\n  return prefix + arr.map(i => generateIDchars[i]).join('');\n};\n/**\n * Remove unused and minify used IDs\n * (only if there are no any <style> or <script>).\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<{\n *   remove?: boolean,\n *   minify?: boolean,\n *   prefix?: string,\n *   preserve?: Array<string>,\n *   preservePrefixes?: Array<string>,\n *   force?: boolean,\n * }>}\n */\n\n\nexports.fn = (_root, params) => {\n  const {\n    remove = true,\n    minify = true,\n    prefix = '',\n    preserve = [],\n    preservePrefixes = [],\n    force = false\n  } = params;\n  const preserveIDs = new Set(Array.isArray(preserve) ? preserve : preserve ? [preserve] : []);\n  const preserveIDPrefixes = Array.isArray(preservePrefixes) ? preservePrefixes : preservePrefixes ? [preservePrefixes] : [];\n  /**\n   * @type {Map<string, XastElement>}\n   */\n\n  const nodeById = new Map();\n  /**\n   * @type {Map<string, Array<{element: XastElement, name: string, value: string }>>}\n   */\n\n  const referencesById = new Map();\n  let deoptimized = false;\n  return {\n    element: {\n      enter: node => {\n        if (force == false) {\n          // deoptimize if style or script elements are present\n          if ((node.name === 'style' || node.name === 'script') && node.children.length !== 0) {\n            deoptimized = true;\n            return;\n          } // avoid removing IDs if the whole SVG consists only of defs\n\n\n          if (node.name === 'svg') {\n            let hasDefsOnly = true;\n\n            for (const child of node.children) {\n              if (child.type !== 'element' || child.name !== 'defs') {\n                hasDefsOnly = false;\n                break;\n              }\n            }\n\n            if (hasDefsOnly) {\n              return visitSkip;\n            }\n          }\n        }\n\n        for (const [name, value] of Object.entries(node.attributes)) {\n          if (name === 'id') {\n            // collect all ids\n            const id = value;\n\n            if (nodeById.has(id)) {\n              delete node.attributes.id; // remove repeated id\n            } else {\n              nodeById.set(id, node);\n            }\n          } else {\n            // collect all references\n\n            /**\n             * @type {null | string}\n             */\n            let id = null;\n\n            if (referencesProps.includes(name)) {\n              const match = value.match(regReferencesUrl);\n\n              if (match != null) {\n                id = match[2]; // url() reference\n              }\n            }\n\n            if (name === 'href' || name.endsWith(':href')) {\n              const match = value.match(regReferencesHref);\n\n              if (match != null) {\n                id = match[1]; // href reference\n              }\n            }\n\n            if (name === 'begin') {\n              const match = value.match(regReferencesBegin);\n\n              if (match != null) {\n                id = match[1]; // href reference\n              }\n            }\n\n            if (id != null) {\n              let refs = referencesById.get(id);\n\n              if (refs == null) {\n                refs = [];\n                referencesById.set(id, refs);\n              }\n\n              refs.push({\n                element: node,\n                name,\n                value\n              });\n            }\n          }\n        }\n      }\n    },\n    root: {\n      exit: () => {\n        if (deoptimized) {\n          return;\n        }\n        /**\n         * @type {(id: string) => boolean}\n         **/\n\n\n        const isIdPreserved = id => preserveIDs.has(id) || hasStringPrefix(id, preserveIDPrefixes);\n        /**\n         * @type {null | Array<number>}\n         */\n\n\n        let currentID = null;\n\n        for (const [id, refs] of referencesById) {\n          const node = nodeById.get(id);\n\n          if (node != null) {\n            // replace referenced IDs with the minified ones\n            if (minify && isIdPreserved(id) === false) {\n              /**\n               * @type {null | string}\n               */\n              let currentIDString = null;\n\n              do {\n                currentID = generateID(currentID);\n                currentIDString = getIDstring(currentID, prefix);\n              } while (isIdPreserved(currentIDString));\n\n              node.attributes.id = currentIDString;\n\n              for (const {\n                element,\n                name,\n                value\n              } of refs) {\n                if (value.includes('#')) {\n                  // replace id in href and url()\n                  element.attributes[name] = value.replace(`#${id}`, `#${currentIDString}`);\n                } else {\n                  // replace id in begin attribute\n                  element.attributes[name] = value.replace(`${id}.`, `${currentIDString}.`);\n                }\n              }\n            } // keep referenced node\n\n\n            nodeById.delete(id);\n          }\n        } // remove non-referenced IDs attributes from elements\n\n\n        if (remove) {\n          for (const [id, node] of nodeById) {\n            if (isIdPreserved(id) === false) {\n              delete node.attributes.id;\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["visitSkip","require","referencesProps","exports","type","name","active","description","regReferencesUrl","regReferencesHref","regReferencesBegin","generateIDchars","maxIDindex","length","hasStringPrefix","string","prefixes","prefix","startsWith","generateID","currentID","i","undefined","unshift","getIDstring","arr","map","join","fn","_root","params","remove","minify","preserve","preservePrefixes","force","preserveIDs","Set","Array","isArray","preserveIDPrefixes","nodeById","Map","referencesById","deoptimized","element","enter","node","children","hasDefsOnly","child","value","Object","entries","attributes","id","has","set","includes","match","endsWith","refs","get","push","root","exit","isIdPreserved","currentIDString","replace","delete"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/svgo/plugins/cleanupIDs.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst { visitSkip } = require('../lib/xast.js');\nconst { referencesProps } = require('./_collections.js');\n\nexports.type = 'visitor';\nexports.name = 'cleanupIDs';\nexports.active = true;\nexports.description = 'removes unused IDs and minifies used';\n\nconst regReferencesUrl = /\\burl\\((\"|')?#(.+?)\\1\\)/;\nconst regReferencesHref = /^#(.+?)$/;\nconst regReferencesBegin = /(\\w+)\\./;\nconst generateIDchars = [\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i',\n  'j',\n  'k',\n  'l',\n  'm',\n  'n',\n  'o',\n  'p',\n  'q',\n  'r',\n  's',\n  't',\n  'u',\n  'v',\n  'w',\n  'x',\n  'y',\n  'z',\n  'A',\n  'B',\n  'C',\n  'D',\n  'E',\n  'F',\n  'G',\n  'H',\n  'I',\n  'J',\n  'K',\n  'L',\n  'M',\n  'N',\n  'O',\n  'P',\n  'Q',\n  'R',\n  'S',\n  'T',\n  'U',\n  'V',\n  'W',\n  'X',\n  'Y',\n  'Z',\n];\nconst maxIDindex = generateIDchars.length - 1;\n\n/**\n * Check if an ID starts with any one of a list of strings.\n *\n * @type {(string: string, prefixes: Array<string>) => boolean}\n */\nconst hasStringPrefix = (string, prefixes) => {\n  for (const prefix of prefixes) {\n    if (string.startsWith(prefix)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Generate unique minimal ID.\n *\n * @type {(currentID: null | Array<number>) => Array<number>}\n */\nconst generateID = (currentID) => {\n  if (currentID == null) {\n    return [0];\n  }\n  currentID[currentID.length - 1] += 1;\n  for (let i = currentID.length - 1; i > 0; i--) {\n    if (currentID[i] > maxIDindex) {\n      currentID[i] = 0;\n      if (currentID[i - 1] !== undefined) {\n        currentID[i - 1]++;\n      }\n    }\n  }\n  if (currentID[0] > maxIDindex) {\n    currentID[0] = 0;\n    currentID.unshift(0);\n  }\n  return currentID;\n};\n\n/**\n * Get string from generated ID array.\n *\n * @type {(arr: Array<number>, prefix: string) => string}\n */\nconst getIDstring = (arr, prefix) => {\n  return prefix + arr.map((i) => generateIDchars[i]).join('');\n};\n\n/**\n * Remove unused and minify used IDs\n * (only if there are no any <style> or <script>).\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<{\n *   remove?: boolean,\n *   minify?: boolean,\n *   prefix?: string,\n *   preserve?: Array<string>,\n *   preservePrefixes?: Array<string>,\n *   force?: boolean,\n * }>}\n */\nexports.fn = (_root, params) => {\n  const {\n    remove = true,\n    minify = true,\n    prefix = '',\n    preserve = [],\n    preservePrefixes = [],\n    force = false,\n  } = params;\n  const preserveIDs = new Set(\n    Array.isArray(preserve) ? preserve : preserve ? [preserve] : []\n  );\n  const preserveIDPrefixes = Array.isArray(preservePrefixes)\n    ? preservePrefixes\n    : preservePrefixes\n    ? [preservePrefixes]\n    : [];\n  /**\n   * @type {Map<string, XastElement>}\n   */\n  const nodeById = new Map();\n  /**\n   * @type {Map<string, Array<{element: XastElement, name: string, value: string }>>}\n   */\n  const referencesById = new Map();\n  let deoptimized = false;\n\n  return {\n    element: {\n      enter: (node) => {\n        if (force == false) {\n          // deoptimize if style or script elements are present\n          if (\n            (node.name === 'style' || node.name === 'script') &&\n            node.children.length !== 0\n          ) {\n            deoptimized = true;\n            return;\n          }\n\n          // avoid removing IDs if the whole SVG consists only of defs\n          if (node.name === 'svg') {\n            let hasDefsOnly = true;\n            for (const child of node.children) {\n              if (child.type !== 'element' || child.name !== 'defs') {\n                hasDefsOnly = false;\n                break;\n              }\n            }\n            if (hasDefsOnly) {\n              return visitSkip;\n            }\n          }\n        }\n\n        for (const [name, value] of Object.entries(node.attributes)) {\n          if (name === 'id') {\n            // collect all ids\n            const id = value;\n            if (nodeById.has(id)) {\n              delete node.attributes.id; // remove repeated id\n            } else {\n              nodeById.set(id, node);\n            }\n          } else {\n            // collect all references\n            /**\n             * @type {null | string}\n             */\n            let id = null;\n            if (referencesProps.includes(name)) {\n              const match = value.match(regReferencesUrl);\n              if (match != null) {\n                id = match[2]; // url() reference\n              }\n            }\n            if (name === 'href' || name.endsWith(':href')) {\n              const match = value.match(regReferencesHref);\n              if (match != null) {\n                id = match[1]; // href reference\n              }\n            }\n            if (name === 'begin') {\n              const match = value.match(regReferencesBegin);\n              if (match != null) {\n                id = match[1]; // href reference\n              }\n            }\n            if (id != null) {\n              let refs = referencesById.get(id);\n              if (refs == null) {\n                refs = [];\n                referencesById.set(id, refs);\n              }\n              refs.push({ element: node, name, value });\n            }\n          }\n        }\n      },\n    },\n\n    root: {\n      exit: () => {\n        if (deoptimized) {\n          return;\n        }\n        /**\n         * @type {(id: string) => boolean}\n         **/\n        const isIdPreserved = (id) =>\n          preserveIDs.has(id) || hasStringPrefix(id, preserveIDPrefixes);\n        /**\n         * @type {null | Array<number>}\n         */\n        let currentID = null;\n        for (const [id, refs] of referencesById) {\n          const node = nodeById.get(id);\n          if (node != null) {\n            // replace referenced IDs with the minified ones\n            if (minify && isIdPreserved(id) === false) {\n              /**\n               * @type {null | string}\n               */\n              let currentIDString = null;\n              do {\n                currentID = generateID(currentID);\n                currentIDString = getIDstring(currentID, prefix);\n              } while (isIdPreserved(currentIDString));\n              node.attributes.id = currentIDString;\n              for (const { element, name, value } of refs) {\n                if (value.includes('#')) {\n                  // replace id in href and url()\n                  element.attributes[name] = value.replace(\n                    `#${id}`,\n                    `#${currentIDString}`\n                  );\n                } else {\n                  // replace id in begin attribute\n                  element.attributes[name] = value.replace(\n                    `${id}.`,\n                    `${currentIDString}.`\n                  );\n                }\n              }\n            }\n            // keep referenced node\n            nodeById.delete(id);\n          }\n        }\n        // remove non-referenced IDs attributes from elements\n        if (remove) {\n          for (const [id, node] of nodeById) {\n            if (isIdPreserved(id) === false) {\n              delete node.attributes.id;\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}