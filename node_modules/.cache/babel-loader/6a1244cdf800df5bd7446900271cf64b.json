{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forwardAsync = forwardAsync;\nexports.isAsync = void 0;\nexports.isThenable = isThenable;\nexports.maybeAsync = maybeAsync;\nexports.waitFor = exports.onFirstPause = void 0;\n\nfunction _gensync() {\n  var data = require(\"gensync\");\n\n  _gensync = function _gensync() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nvar runGenerator = _gensync()( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(item) {\n  return _regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.delegateYield(item, \"t0\", 1);\n\n        case 1:\n          return _context.abrupt(\"return\", _context.t0);\n\n        case 2:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _callee);\n}));\n\nvar isAsync = _gensync()({\n  sync: function sync() {\n    return false;\n  },\n  errback: function errback(cb) {\n    return cb(null, true);\n  }\n});\n\nexports.isAsync = isAsync;\n\nfunction maybeAsync(fn, message) {\n  return _gensync()({\n    sync: function sync() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var result = fn.apply(this, args);\n      if (isThenable(result)) throw new Error(message);\n      return result;\n    },\n    async: function async() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return Promise.resolve(fn.apply(this, args));\n    }\n  });\n}\n\nvar withKind = _gensync()({\n  sync: function sync(cb) {\n    return cb(\"sync\");\n  },\n  async: function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(cb) {\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", cb(\"async\"));\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function async(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }()\n});\n\nfunction forwardAsync(action, cb) {\n  var g = _gensync()(action);\n\n  return withKind(function (kind) {\n    var adapted = g[kind];\n    return cb(adapted);\n  });\n}\n\nvar onFirstPause = _gensync()({\n  name: \"onFirstPause\",\n  arity: 2,\n  sync: function sync(item) {\n    return runGenerator.sync(item);\n  },\n  errback: function errback(item, firstPause, cb) {\n    var completed = false;\n    runGenerator.errback(item, function (err, value) {\n      completed = true;\n      cb(err, value);\n    });\n\n    if (!completed) {\n      firstPause();\n    }\n  }\n});\n\nexports.onFirstPause = onFirstPause;\n\nvar waitFor = _gensync()({\n  sync: function sync(x) {\n    return x;\n  },\n  async: function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(x) {\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", x);\n\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function async(_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }()\n});\n\nexports.waitFor = waitFor;\n\nfunction isThenable(val) {\n  return !!val && (typeof val === \"object\" || typeof val === \"function\") && !!val.then && typeof val.then === \"function\";\n}\n\n0 && 0;","map":{"version":3,"mappings":"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","names":["_gensync","runGenerator","gensync","item","isAsync","sync","errback","cb","maybeAsync","fn","message","args","result","apply","isThenable","Error","async","Promise","resolve","withKind","forwardAsync","action","g","kind","adapted","onFirstPause","name","arity","firstPause","completed","err","value","waitFor","x","val","then"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\gensync-utils\\async.ts"],"sourcesContent":["import gensync, { type Gensync, type Handler, type Callback } from \"gensync\";\n\ntype MaybePromise<T> = T | Promise<T>;\n\nconst runGenerator: {\n  sync<Return>(gen: Handler<Return>): Return;\n  async<Return>(gen: Handler<Return>): Promise<Return>;\n  errback<Return>(gen: Handler<Return>, cb: Callback<Return>): void;\n} = gensync(function* (item: Handler<any>): Handler<any> {\n  return yield* item;\n});\n\n// This Gensync returns true if the current execution context is\n// asynchronous, otherwise it returns false.\nexport const isAsync = gensync({\n  sync: () => false,\n  errback: cb => cb(null, true),\n});\n\n// This function wraps any functions (which could be either synchronous or\n// asynchronous) with a Gensync. If the wrapped function returns a promise\n// but the current execution context is synchronous, it will throw the\n// provided error.\n// This is used to handle user-provided functions which could be asynchronous.\nexport function maybeAsync<Args extends unknown[], Return>(\n  fn: (...args: Args) => Return,\n  message: string,\n): Gensync<Args, Return> {\n  return gensync({\n    sync(...args) {\n      const result = fn.apply(this, args) as Return;\n      if (isThenable(result)) throw new Error(message);\n      return result;\n    },\n    async(...args) {\n      return Promise.resolve(fn.apply(this, args));\n    },\n  });\n}\n\nconst withKind = gensync({\n  sync: cb => cb(\"sync\"),\n  async: async cb => cb(\"async\"),\n}) as <T>(cb: (kind: \"sync\" | \"async\") => MaybePromise<T>) => Handler<T>;\n\n// This function wraps a generator (or a Gensync) into another function which,\n// when called, will run the provided generator in a sync or async way, depending\n// on the execution context where this forwardAsync function is called.\n// This is useful, for example, when passing a callback to a function which isn't\n// aware of gensync, but it only knows about synchronous and asynchronous functions.\n// An example is cache.using, which being exposed to the user must be as simple as\n// possible:\n//     yield* forwardAsync(gensyncFn, wrappedFn =>\n//       cache.using(x => {\n//         // Here we don't know about gensync. wrappedFn is a\n//         // normal sync or async function\n//         return wrappedFn(x);\n//       })\n//     )\nexport function forwardAsync<Args extends unknown[], Return>(\n  action: (...args: Args) => Handler<Return>,\n  cb: (\n    adapted: (...args: Args) => MaybePromise<Return>,\n  ) => MaybePromise<Return>,\n): Handler<Return> {\n  const g = gensync(action);\n  return withKind(kind => {\n    const adapted = g[kind];\n    return cb(adapted);\n  });\n}\n\n// If the given generator is executed asynchronously, the first time that it\n// is paused (i.e. When it yields a gensync generator which can't be run\n// synchronously), call the \"firstPause\" callback.\nexport const onFirstPause = gensync<\n  [gen: Handler<unknown>, firstPause: () => void],\n  unknown\n>({\n  name: \"onFirstPause\",\n  arity: 2,\n  sync: function (item) {\n    return runGenerator.sync(item);\n  },\n  errback: function (item, firstPause, cb) {\n    let completed = false;\n\n    runGenerator.errback(item, (err, value) => {\n      completed = true;\n      cb(err, value);\n    });\n\n    if (!completed) {\n      firstPause();\n    }\n  },\n}) as <T>(gen: Handler<T>, firstPause: () => void) => Handler<T>;\n\n// Wait for the given promise to be resolved\nexport const waitFor = gensync({\n  sync: x => x,\n  async: async x => x,\n}) as <T>(p: T | Promise<T>) => Handler<T>;\n\nexport function isThenable<T = any>(val: any): val is PromiseLike<T> {\n  return (\n    !!val &&\n    (typeof val === \"object\" || typeof val === \"function\") &&\n    !!val.then &&\n    typeof val.then === \"function\"\n  );\n}\n"]},"metadata":{},"sourceType":"script"}