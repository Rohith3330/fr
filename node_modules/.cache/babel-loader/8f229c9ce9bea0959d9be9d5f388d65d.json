{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ensureAsync;\n\nvar _setImmediate = require('./internal/setImmediate.js');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained. ES2017 `async` functions are returned as-is -- they are immune\n * to Zalgo's corrupting influences, as they always resolve on a later tick.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\n\n\nfunction ensureAsync(fn) {\n  if ((0, _wrapAsync.isAsync)(fn)) return fn;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var callback = args.pop();\n    var sync = true;\n    args.push(function () {\n      for (var _len2 = arguments.length, innerArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        innerArgs[_key2] = arguments[_key2];\n      }\n\n      if (sync) {\n        (0, _setImmediate2.default)(() => callback(...innerArgs));\n      } else {\n        callback(...innerArgs);\n      }\n    });\n    fn.apply(this, args);\n    sync = false;\n  };\n}\n\nmodule.exports = exports['default'];","map":{"version":3,"names":["Object","defineProperty","exports","value","default","ensureAsync","_setImmediate","require","_setImmediate2","_interopRequireDefault","_wrapAsync","obj","__esModule","fn","isAsync","args","callback","pop","sync","push","innerArgs","apply","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/async/ensureAsync.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = ensureAsync;\n\nvar _setImmediate = require('./internal/setImmediate.js');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nvar _wrapAsync = require('./internal/wrapAsync.js');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained. ES2017 `async` functions are returned as-is -- they are immune\n * to Zalgo's corrupting influences, as they always resolve on a later tick.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nfunction ensureAsync(fn) {\n    if ((0, _wrapAsync.isAsync)(fn)) return fn;\n    return function (...args /*, callback*/) {\n        var callback = args.pop();\n        var sync = true;\n        args.push((...innerArgs) => {\n            if (sync) {\n                (0, _setImmediate2.default)(() => callback(...innerArgs));\n            } else {\n                callback(...innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    };\n}\nmodule.exports = exports['default'];"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EACzCC,KAAK,EAAE;AADkC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,WAAlB;;AAEA,IAAIC,aAAa,GAAGC,OAAO,CAAC,4BAAD,CAA3B;;AAEA,IAAIC,cAAc,GAAGC,sBAAsB,CAACH,aAAD,CAA3C;;AAEA,IAAII,UAAU,GAAGH,OAAO,CAAC,yBAAD,CAAxB;;AAEA,SAASE,sBAAT,CAAgCE,GAAhC,EAAqC;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;IAAEP,OAAO,EAAEO;EAAX,CAArC;AAAwD;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASN,WAAT,CAAqBQ,EAArB,EAAyB;EACrB,IAAI,CAAC,GAAGH,UAAU,CAACI,OAAf,EAAwBD,EAAxB,CAAJ,EAAiC,OAAOA,EAAP;EACjC,OAAO,YAAkC;IAAA,kCAArBE,IAAqB;MAArBA,IAAqB;IAAA;;IACrC,IAAIC,QAAQ,GAAGD,IAAI,CAACE,GAAL,EAAf;IACA,IAAIC,IAAI,GAAG,IAAX;IACAH,IAAI,CAACI,IAAL,CAAU,YAAkB;MAAA,mCAAdC,SAAc;QAAdA,SAAc;MAAA;;MACxB,IAAIF,IAAJ,EAAU;QACN,CAAC,GAAGV,cAAc,CAACJ,OAAnB,EAA4B,MAAMY,QAAQ,CAAC,GAAGI,SAAJ,CAA1C;MACH,CAFD,MAEO;QACHJ,QAAQ,CAAC,GAAGI,SAAJ,CAAR;MACH;IACJ,CAND;IAOAP,EAAE,CAACQ,KAAH,CAAS,IAAT,EAAeN,IAAf;IACAG,IAAI,GAAG,KAAP;EACH,CAZD;AAaH;;AACDI,MAAM,CAACpB,OAAP,GAAiBA,OAAO,CAAC,SAAD,CAAxB"},"metadata":{},"sourceType":"script"}