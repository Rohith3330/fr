{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: () => expandTailwindAtRules\n});\n\nconst _quickLru = /*#__PURE__*/_interopRequireDefault(require(\"quick-lru\"));\n\nconst _sharedState = /*#__PURE__*/_interopRequireWildcard(require(\"./sharedState\"));\n\nconst _generateRules = require(\"./generateRules\");\n\nconst _bigSign = /*#__PURE__*/_interopRequireDefault(require(\"../util/bigSign\"));\n\nconst _log = /*#__PURE__*/_interopRequireDefault(require(\"../util/log\"));\n\nconst _cloneNodes = /*#__PURE__*/_interopRequireDefault(require(\"../util/cloneNodes\"));\n\nconst _defaultExtractor = require(\"./defaultExtractor\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nlet env = _sharedState.env;\nconst builtInExtractors = {\n  DEFAULT: _defaultExtractor.defaultExtractor\n};\nconst builtInTransformers = {\n  DEFAULT: content => content,\n  svelte: content => content.replace(/(?:^|\\s)class:/g, \" \")\n};\n\nfunction getExtractor(context, fileExtension) {\n  let extractors = context.tailwindConfig.content.extract;\n  return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);\n}\n\nfunction getTransformer(tailwindConfig, fileExtension) {\n  let transformers = tailwindConfig.content.transform;\n  return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;\n}\n\nlet extractorCache = new WeakMap(); // Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though â€” if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\n\nfunction getClassCandidates(content, extractor, candidates, seen) {\n  if (!extractorCache.has(extractor)) {\n    extractorCache.set(extractor, new _quickLru.default({\n      maxSize: 25000\n    }));\n  }\n\n  for (let line of content.split(\"\\n\")) {\n    line = line.trim();\n\n    if (seen.has(line)) {\n      continue;\n    }\n\n    seen.add(line);\n\n    if (extractorCache.get(extractor).has(line)) {\n      for (let match of extractorCache.get(extractor).get(line)) {\n        candidates.add(match);\n      }\n    } else {\n      let extractorMatches = extractor(line).filter(s => s !== \"!*\");\n      let lineMatchesSet = new Set(extractorMatches);\n\n      for (let match1 of lineMatchesSet) {\n        candidates.add(match1);\n      }\n\n      extractorCache.get(extractor).set(line, lineMatchesSet);\n    }\n  }\n}\n\nfunction buildStylesheet(rules, context) {\n  let sortedRules = rules.sort((_ref, _ref2) => {\n    let [a] = _ref;\n    let [z] = _ref2;\n    return (0, _bigSign.default)(a - z);\n  });\n  let returnValue = {\n    base: new Set(),\n    defaults: new Set(),\n    components: new Set(),\n    utilities: new Set(),\n    variants: new Set(),\n    // All the CSS that is not Tailwind related can be put in this bucket. This\n    // will make it easier to later use this information when we want to\n    // `@apply` for example. The main reason we do this here is because we\n    // still need to make sure the order is correct. Last but not least, we\n    // will make sure to always re-inject this section into the css, even if\n    // certain rules were not used. This means that it will look like a no-op\n    // from the user's perspective, but we gathered all the useful information\n    // we need.\n    user: new Set()\n  };\n\n  for (let [sort, rule] of sortedRules) {\n    if (sort >= context.minimumScreen) {\n      returnValue.variants.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.base) {\n      returnValue.base.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.defaults) {\n      returnValue.defaults.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.components) {\n      returnValue.components.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.utilities) {\n      returnValue.utilities.add(rule);\n      continue;\n    }\n\n    if (sort & context.layerOrder.user) {\n      returnValue.user.add(rule);\n      continue;\n    }\n  }\n\n  return returnValue;\n}\n\nfunction expandTailwindAtRules(context) {\n  return root => {\n    let layerNodes = {\n      base: null,\n      components: null,\n      utilities: null,\n      variants: null\n    };\n    root.walkAtRules(rule => {\n      // Make sure this file contains Tailwind directives. If not, we can save\n      // a lot of work and bail early. Also we don't have to register our touch\n      // file as a dependency since the output of this CSS does not depend on\n      // the source of any templates. Think Vue <style> blocks for example.\n      if (rule.name === \"tailwind\") {\n        if (Object.keys(layerNodes).includes(rule.params)) {\n          layerNodes[rule.params] = rule;\n        }\n      }\n    });\n\n    if (Object.values(layerNodes).every(n => n === null)) {\n      return root;\n    } // ---\n    // Find potential rules in changed files\n\n\n    let candidates = new Set([_sharedState.NOT_ON_DEMAND]);\n    let seen = new Set();\n    env.DEBUG && console.time(\"Reading changed files\");\n\n    for (let {\n      content,\n      extension\n    } of context.changedContent) {\n      let transformer = getTransformer(context.tailwindConfig, extension);\n      let extractor = getExtractor(context, extension);\n      getClassCandidates(transformer(content), extractor, candidates, seen);\n    }\n\n    env.DEBUG && console.timeEnd(\"Reading changed files\"); // ---\n    // Generate the actual CSS\n\n    let classCacheCount = context.classCache.size;\n    env.DEBUG && console.time(\"Generate rules\");\n    let rules = (0, _generateRules.generateRules)(candidates, context);\n    env.DEBUG && console.timeEnd(\"Generate rules\"); // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n\n    env.DEBUG && console.time(\"Build stylesheet\");\n\n    if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n      for (let rule of rules) {\n        context.ruleCache.add(rule);\n      }\n\n      context.stylesheetCache = buildStylesheet([...context.ruleCache], context);\n    }\n\n    env.DEBUG && console.timeEnd(\"Build stylesheet\");\n    let {\n      defaults: defaultNodes,\n      base: baseNodes,\n      components: componentNodes,\n      utilities: utilityNodes,\n      variants: screenNodes\n    } = context.stylesheetCache; // ---\n    // Replace any Tailwind directives with generated CSS\n\n    if (layerNodes.base) {\n      layerNodes.base.before((0, _cloneNodes.default)([...baseNodes, ...defaultNodes], layerNodes.base.source, {\n        layer: \"base\"\n      }));\n      layerNodes.base.remove();\n    }\n\n    if (layerNodes.components) {\n      layerNodes.components.before((0, _cloneNodes.default)([...componentNodes], layerNodes.components.source, {\n        layer: \"components\"\n      }));\n      layerNodes.components.remove();\n    }\n\n    if (layerNodes.utilities) {\n      layerNodes.utilities.before((0, _cloneNodes.default)([...utilityNodes], layerNodes.utilities.source, {\n        layer: \"utilities\"\n      }));\n      layerNodes.utilities.remove();\n    } // We do post-filtering to not alter the emitted order of the variants\n\n\n    const variantNodes = Array.from(screenNodes).filter(node => {\n      var ref;\n      const parentLayer = (ref = node.raws.tailwind) === null || ref === void 0 ? void 0 : ref.parentLayer;\n\n      if (parentLayer === \"components\") {\n        return layerNodes.components !== null;\n      }\n\n      if (parentLayer === \"utilities\") {\n        return layerNodes.utilities !== null;\n      }\n\n      return true;\n    });\n\n    if (layerNodes.variants) {\n      layerNodes.variants.before((0, _cloneNodes.default)(variantNodes, layerNodes.variants.source, {\n        layer: \"variants\"\n      }));\n      layerNodes.variants.remove();\n    } else if (variantNodes.length > 0) {\n      root.append((0, _cloneNodes.default)(variantNodes, root.source, {\n        layer: \"variants\"\n      }));\n    } // If we've got a utility layer and no utilities are generated there's likely something wrong\n\n\n    const hasUtilityVariants = variantNodes.some(node => {\n      var ref;\n      return ((ref = node.raws.tailwind) === null || ref === void 0 ? void 0 : ref.parentLayer) === \"utilities\";\n    });\n\n    if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {\n      _log.default.warn(\"content-problems\", [\"No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.\", \"https://tailwindcss.com/docs/content-configuration\"]);\n    } // ---\n\n\n    if (env.DEBUG) {\n      console.log(\"Potential classes: \", candidates.size);\n      console.log(\"Active contexts: \", _sharedState.contextSourcesMap.size);\n    } // Clear the cache for the changed files\n\n\n    context.changedContent = []; // Cleanup any leftover @layer atrules\n\n    root.walkAtRules(\"layer\", rule => {\n      if (Object.keys(layerNodes).includes(rule.params)) {\n        rule.remove();\n      }\n    });\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","expandTailwindAtRules","_quickLru","_interopRequireDefault","require","_sharedState","_interopRequireWildcard","_generateRules","_bigSign","_log","_cloneNodes","_defaultExtractor","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","env","builtInExtractors","DEFAULT","defaultExtractor","builtInTransformers","content","svelte","replace","getExtractor","context","fileExtension","extractors","tailwindConfig","extract","getTransformer","transformers","transform","extractorCache","getClassCandidates","extractor","candidates","seen","maxSize","line","split","trim","add","match","extractorMatches","filter","s","lineMatchesSet","Set","match1","buildStylesheet","rules","sortedRules","sort","a","z","returnValue","base","defaults","components","utilities","variants","user","rule","minimumScreen","layerOrder","root","layerNodes","walkAtRules","name","keys","includes","params","values","every","n","NOT_ON_DEMAND","DEBUG","console","time","extension","changedContent","transformer","timeEnd","classCacheCount","classCache","size","generateRules","stylesheetCache","ruleCache","defaultNodes","baseNodes","componentNodes","utilityNodes","screenNodes","before","source","layer","remove","variantNodes","Array","from","node","ref","parentLayer","raws","tailwind","length","append","hasUtilityVariants","some","warn","log","contextSourcesMap"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/lib/lib/expandTailwindAtRules.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"default\", {\n    enumerable: true,\n    get: ()=>expandTailwindAtRules\n});\nconst _quickLru = /*#__PURE__*/ _interopRequireDefault(require(\"quick-lru\"));\nconst _sharedState = /*#__PURE__*/ _interopRequireWildcard(require(\"./sharedState\"));\nconst _generateRules = require(\"./generateRules\");\nconst _bigSign = /*#__PURE__*/ _interopRequireDefault(require(\"../util/bigSign\"));\nconst _log = /*#__PURE__*/ _interopRequireDefault(require(\"../util/log\"));\nconst _cloneNodes = /*#__PURE__*/ _interopRequireDefault(require(\"../util/cloneNodes\"));\nconst _defaultExtractor = require(\"./defaultExtractor\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet env = _sharedState.env;\nconst builtInExtractors = {\n    DEFAULT: _defaultExtractor.defaultExtractor\n};\nconst builtInTransformers = {\n    DEFAULT: (content)=>content,\n    svelte: (content)=>content.replace(/(?:^|\\s)class:/g, \" \")\n};\nfunction getExtractor(context, fileExtension) {\n    let extractors = context.tailwindConfig.content.extract;\n    return extractors[fileExtension] || extractors.DEFAULT || builtInExtractors[fileExtension] || builtInExtractors.DEFAULT(context);\n}\nfunction getTransformer(tailwindConfig, fileExtension) {\n    let transformers = tailwindConfig.content.transform;\n    return transformers[fileExtension] || transformers.DEFAULT || builtInTransformers[fileExtension] || builtInTransformers.DEFAULT;\n}\nlet extractorCache = new WeakMap();\n// Scans template contents for possible classes. This is a hot path on initial build but\n// not too important for subsequent builds. The faster the better though â€” if we can speed\n// up these regexes by 50% that could cut initial build time by like 20%.\nfunction getClassCandidates(content, extractor, candidates, seen) {\n    if (!extractorCache.has(extractor)) {\n        extractorCache.set(extractor, new _quickLru.default({\n            maxSize: 25000\n        }));\n    }\n    for (let line of content.split(\"\\n\")){\n        line = line.trim();\n        if (seen.has(line)) {\n            continue;\n        }\n        seen.add(line);\n        if (extractorCache.get(extractor).has(line)) {\n            for (let match of extractorCache.get(extractor).get(line)){\n                candidates.add(match);\n            }\n        } else {\n            let extractorMatches = extractor(line).filter((s)=>s !== \"!*\");\n            let lineMatchesSet = new Set(extractorMatches);\n            for (let match1 of lineMatchesSet){\n                candidates.add(match1);\n            }\n            extractorCache.get(extractor).set(line, lineMatchesSet);\n        }\n    }\n}\nfunction buildStylesheet(rules, context) {\n    let sortedRules = rules.sort(([a], [z])=>(0, _bigSign.default)(a - z));\n    let returnValue = {\n        base: new Set(),\n        defaults: new Set(),\n        components: new Set(),\n        utilities: new Set(),\n        variants: new Set(),\n        // All the CSS that is not Tailwind related can be put in this bucket. This\n        // will make it easier to later use this information when we want to\n        // `@apply` for example. The main reason we do this here is because we\n        // still need to make sure the order is correct. Last but not least, we\n        // will make sure to always re-inject this section into the css, even if\n        // certain rules were not used. This means that it will look like a no-op\n        // from the user's perspective, but we gathered all the useful information\n        // we need.\n        user: new Set()\n    };\n    for (let [sort, rule] of sortedRules){\n        if (sort >= context.minimumScreen) {\n            returnValue.variants.add(rule);\n            continue;\n        }\n        if (sort & context.layerOrder.base) {\n            returnValue.base.add(rule);\n            continue;\n        }\n        if (sort & context.layerOrder.defaults) {\n            returnValue.defaults.add(rule);\n            continue;\n        }\n        if (sort & context.layerOrder.components) {\n            returnValue.components.add(rule);\n            continue;\n        }\n        if (sort & context.layerOrder.utilities) {\n            returnValue.utilities.add(rule);\n            continue;\n        }\n        if (sort & context.layerOrder.user) {\n            returnValue.user.add(rule);\n            continue;\n        }\n    }\n    return returnValue;\n}\nfunction expandTailwindAtRules(context) {\n    return (root)=>{\n        let layerNodes = {\n            base: null,\n            components: null,\n            utilities: null,\n            variants: null\n        };\n        root.walkAtRules((rule)=>{\n            // Make sure this file contains Tailwind directives. If not, we can save\n            // a lot of work and bail early. Also we don't have to register our touch\n            // file as a dependency since the output of this CSS does not depend on\n            // the source of any templates. Think Vue <style> blocks for example.\n            if (rule.name === \"tailwind\") {\n                if (Object.keys(layerNodes).includes(rule.params)) {\n                    layerNodes[rule.params] = rule;\n                }\n            }\n        });\n        if (Object.values(layerNodes).every((n)=>n === null)) {\n            return root;\n        }\n        // ---\n        // Find potential rules in changed files\n        let candidates = new Set([\n            _sharedState.NOT_ON_DEMAND\n        ]);\n        let seen = new Set();\n        env.DEBUG && console.time(\"Reading changed files\");\n        for (let { content , extension  } of context.changedContent){\n            let transformer = getTransformer(context.tailwindConfig, extension);\n            let extractor = getExtractor(context, extension);\n            getClassCandidates(transformer(content), extractor, candidates, seen);\n        }\n        env.DEBUG && console.timeEnd(\"Reading changed files\");\n        // ---\n        // Generate the actual CSS\n        let classCacheCount = context.classCache.size;\n        env.DEBUG && console.time(\"Generate rules\");\n        let rules = (0, _generateRules.generateRules)(candidates, context);\n        env.DEBUG && console.timeEnd(\"Generate rules\");\n        // We only ever add to the classCache, so if it didn't grow, there is nothing new.\n        env.DEBUG && console.time(\"Build stylesheet\");\n        if (context.stylesheetCache === null || context.classCache.size !== classCacheCount) {\n            for (let rule of rules){\n                context.ruleCache.add(rule);\n            }\n            context.stylesheetCache = buildStylesheet([\n                ...context.ruleCache\n            ], context);\n        }\n        env.DEBUG && console.timeEnd(\"Build stylesheet\");\n        let { defaults: defaultNodes , base: baseNodes , components: componentNodes , utilities: utilityNodes , variants: screenNodes ,  } = context.stylesheetCache;\n        // ---\n        // Replace any Tailwind directives with generated CSS\n        if (layerNodes.base) {\n            layerNodes.base.before((0, _cloneNodes.default)([\n                ...baseNodes,\n                ...defaultNodes\n            ], layerNodes.base.source, {\n                layer: \"base\"\n            }));\n            layerNodes.base.remove();\n        }\n        if (layerNodes.components) {\n            layerNodes.components.before((0, _cloneNodes.default)([\n                ...componentNodes\n            ], layerNodes.components.source, {\n                layer: \"components\"\n            }));\n            layerNodes.components.remove();\n        }\n        if (layerNodes.utilities) {\n            layerNodes.utilities.before((0, _cloneNodes.default)([\n                ...utilityNodes\n            ], layerNodes.utilities.source, {\n                layer: \"utilities\"\n            }));\n            layerNodes.utilities.remove();\n        }\n        // We do post-filtering to not alter the emitted order of the variants\n        const variantNodes = Array.from(screenNodes).filter((node)=>{\n            var ref;\n            const parentLayer = (ref = node.raws.tailwind) === null || ref === void 0 ? void 0 : ref.parentLayer;\n            if (parentLayer === \"components\") {\n                return layerNodes.components !== null;\n            }\n            if (parentLayer === \"utilities\") {\n                return layerNodes.utilities !== null;\n            }\n            return true;\n        });\n        if (layerNodes.variants) {\n            layerNodes.variants.before((0, _cloneNodes.default)(variantNodes, layerNodes.variants.source, {\n                layer: \"variants\"\n            }));\n            layerNodes.variants.remove();\n        } else if (variantNodes.length > 0) {\n            root.append((0, _cloneNodes.default)(variantNodes, root.source, {\n                layer: \"variants\"\n            }));\n        }\n        // If we've got a utility layer and no utilities are generated there's likely something wrong\n        const hasUtilityVariants = variantNodes.some((node)=>{\n            var ref;\n            return ((ref = node.raws.tailwind) === null || ref === void 0 ? void 0 : ref.parentLayer) === \"utilities\";\n        });\n        if (layerNodes.utilities && utilityNodes.size === 0 && !hasUtilityVariants) {\n            _log.default.warn(\"content-problems\", [\n                \"No utility classes were detected in your source files. If this is unexpected, double-check the `content` option in your Tailwind CSS configuration.\",\n                \"https://tailwindcss.com/docs/content-configuration\", \n            ]);\n        }\n        // ---\n        if (env.DEBUG) {\n            console.log(\"Potential classes: \", candidates.size);\n            console.log(\"Active contexts: \", _sharedState.contextSourcesMap.size);\n        }\n        // Clear the cache for the changed files\n        context.changedContent = [];\n        // Cleanup any leftover @layer atrules\n        root.walkAtRules(\"layer\", (rule)=>{\n            if (Object.keys(layerNodes).includes(rule.params)) {\n                rule.remove();\n            }\n        });\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}