{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RULE_NAME = void 0;\n\nconst create_testing_library_rule_1 = require(\"../create-testing-library-rule\");\n\nconst node_utils_1 = require(\"../node-utils\");\n\nexports.RULE_NAME = 'await-async-utils';\nexports.default = (0, create_testing_library_rule_1.createTestingLibraryRule)({\n  name: exports.RULE_NAME,\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Enforce promises from async utils to be awaited properly',\n      recommendedConfig: {\n        dom: 'error',\n        angular: 'error',\n        react: 'error',\n        vue: 'error',\n        marko: 'error'\n      }\n    },\n    messages: {\n      awaitAsyncUtil: 'Promise returned from `{{ name }}` must be handled',\n      asyncUtilWrapper: 'Promise returned from {{ name }} wrapper over async util must be handled'\n    },\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context, _, helpers) {\n    const functionWrappersNames = [];\n\n    function detectAsyncUtilWrapper(node) {\n      const innerFunction = (0, node_utils_1.getInnermostReturningFunction)(context, node);\n\n      if (innerFunction) {\n        functionWrappersNames.push((0, node_utils_1.getFunctionName)(innerFunction));\n      }\n    }\n\n    return {\n      'CallExpression Identifier'(node) {\n        if (helpers.isAsyncUtil(node)) {\n          detectAsyncUtilWrapper(node);\n          const closestCallExpression = (0, node_utils_1.findClosestCallExpressionNode)(node, true);\n\n          if (!closestCallExpression || !closestCallExpression.parent) {\n            return;\n          }\n\n          const references = (0, node_utils_1.getVariableReferences)(context, closestCallExpression.parent);\n\n          if (references.length === 0) {\n            if (!(0, node_utils_1.isPromiseHandled)(node)) {\n              context.report({\n                node,\n                messageId: 'awaitAsyncUtil',\n                data: {\n                  name: node.name\n                }\n              });\n            }\n          } else {\n            for (const reference of references) {\n              const referenceNode = reference.identifier;\n\n              if (!(0, node_utils_1.isPromiseHandled)(referenceNode)) {\n                context.report({\n                  node,\n                  messageId: 'awaitAsyncUtil',\n                  data: {\n                    name: node.name\n                  }\n                });\n                return;\n              }\n            }\n          }\n        } else if (functionWrappersNames.includes(node.name)) {\n          if (!(0, node_utils_1.isPromiseHandled)(node)) {\n            context.report({\n              node,\n              messageId: 'asyncUtilWrapper',\n              data: {\n                name: node.name\n              }\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n});","map":{"version":3,"names":["Object","defineProperty","exports","value","RULE_NAME","create_testing_library_rule_1","require","node_utils_1","default","createTestingLibraryRule","name","meta","type","docs","description","recommendedConfig","dom","angular","react","vue","marko","messages","awaitAsyncUtil","asyncUtilWrapper","schema","defaultOptions","create","context","_","helpers","functionWrappersNames","detectAsyncUtilWrapper","node","innerFunction","getInnermostReturningFunction","push","getFunctionName","isAsyncUtil","closestCallExpression","findClosestCallExpressionNode","parent","references","getVariableReferences","length","isPromiseHandled","report","messageId","data","reference","referenceNode","identifier","includes"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-testing-library/rules/await-async-utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RULE_NAME = void 0;\nconst create_testing_library_rule_1 = require(\"../create-testing-library-rule\");\nconst node_utils_1 = require(\"../node-utils\");\nexports.RULE_NAME = 'await-async-utils';\nexports.default = (0, create_testing_library_rule_1.createTestingLibraryRule)({\n    name: exports.RULE_NAME,\n    meta: {\n        type: 'problem',\n        docs: {\n            description: 'Enforce promises from async utils to be awaited properly',\n            recommendedConfig: {\n                dom: 'error',\n                angular: 'error',\n                react: 'error',\n                vue: 'error',\n                marko: 'error',\n            },\n        },\n        messages: {\n            awaitAsyncUtil: 'Promise returned from `{{ name }}` must be handled',\n            asyncUtilWrapper: 'Promise returned from {{ name }} wrapper over async util must be handled',\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create(context, _, helpers) {\n        const functionWrappersNames = [];\n        function detectAsyncUtilWrapper(node) {\n            const innerFunction = (0, node_utils_1.getInnermostReturningFunction)(context, node);\n            if (innerFunction) {\n                functionWrappersNames.push((0, node_utils_1.getFunctionName)(innerFunction));\n            }\n        }\n        return {\n            'CallExpression Identifier'(node) {\n                if (helpers.isAsyncUtil(node)) {\n                    detectAsyncUtilWrapper(node);\n                    const closestCallExpression = (0, node_utils_1.findClosestCallExpressionNode)(node, true);\n                    if (!closestCallExpression || !closestCallExpression.parent) {\n                        return;\n                    }\n                    const references = (0, node_utils_1.getVariableReferences)(context, closestCallExpression.parent);\n                    if (references.length === 0) {\n                        if (!(0, node_utils_1.isPromiseHandled)(node)) {\n                            context.report({\n                                node,\n                                messageId: 'awaitAsyncUtil',\n                                data: {\n                                    name: node.name,\n                                },\n                            });\n                        }\n                    }\n                    else {\n                        for (const reference of references) {\n                            const referenceNode = reference.identifier;\n                            if (!(0, node_utils_1.isPromiseHandled)(referenceNode)) {\n                                context.report({\n                                    node,\n                                    messageId: 'awaitAsyncUtil',\n                                    data: {\n                                        name: node.name,\n                                    },\n                                });\n                                return;\n                            }\n                        }\n                    }\n                }\n                else if (functionWrappersNames.includes(node.name)) {\n                    if (!(0, node_utils_1.isPromiseHandled)(node)) {\n                        context.report({\n                            node,\n                            messageId: 'asyncUtilWrapper',\n                            data: { name: node.name },\n                        });\n                    }\n                }\n            },\n        };\n    },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}