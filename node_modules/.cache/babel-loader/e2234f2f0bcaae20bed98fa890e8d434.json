{"ast":null,"code":"'use strict';\n\nconst {\n  collectStylesheet,\n  computeStyle\n} = require('../lib/style.js');\n\nconst {\n  pathElems\n} = require('./_collections.js');\n\nconst {\n  path2js,\n  js2path\n} = require('./_path.js');\n\nconst {\n  applyTransforms\n} = require('./_applyTransforms.js');\n\nconst {\n  cleanupOutData\n} = require('../lib/svgo/tools');\n\nexports.name = 'convertPathData';\nexports.type = 'visitor';\nexports.active = true;\nexports.description = 'optimizes path data: writes in shorter form, applies transformations';\nexports.params = {\n  applyTransforms: true,\n  applyTransformsStroked: true,\n  makeArcs: {\n    threshold: 2.5,\n    // coefficient of rounding error\n    tolerance: 0.5 // percentage of radius\n\n  },\n  straightCurves: true,\n  lineShorthands: true,\n  curveSmoothShorthands: true,\n  floatPrecision: 3,\n  transformPrecision: 5,\n  removeUseless: true,\n  collapseRepeated: true,\n  utilizeAbsolute: true,\n  leadingZero: true,\n  negativeExtraSpace: true,\n  noSpaceAfterFlags: false,\n  // a20 60 45 0 1 30 20 → a20 60 45 0130 20\n  forceAbsolutePath: false\n};\nlet roundData;\nlet precision;\nlet error;\nlet arcThreshold;\nlet arcTolerance;\n/**\n * Convert absolute Path to relative,\n * collapse repeated instructions,\n * detect and convert Lineto shorthands,\n * remove useless instructions like \"l0,0\",\n * trim useless delimiters and leading zeros,\n * decrease accuracy of floating-point numbers.\n *\n * @see https://www.w3.org/TR/SVG11/paths.html#PathData\n *\n * @param {Object} item current iteration item\n * @param {Object} params plugin params\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\n\nexports.fn = (root, params) => {\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: node => {\n        if (pathElems.includes(node.name) && node.attributes.d != null) {\n          const computedStyle = computeStyle(stylesheet, node);\n          precision = params.floatPrecision;\n          error = precision !== false ? +Math.pow(0.1, precision).toFixed(precision) : 1e-2;\n          roundData = precision > 0 && precision < 20 ? strongRound : round;\n\n          if (params.makeArcs) {\n            arcThreshold = params.makeArcs.threshold;\n            arcTolerance = params.makeArcs.tolerance;\n          }\n\n          const hasMarkerMid = computedStyle['marker-mid'] != null;\n          const maybeHasStroke = computedStyle.stroke && (computedStyle.stroke.type === 'dynamic' || computedStyle.stroke.value !== 'none');\n          const maybeHasLinecap = computedStyle['stroke-linecap'] && (computedStyle['stroke-linecap'].type === 'dynamic' || computedStyle['stroke-linecap'].value !== 'butt');\n          const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;\n          var data = path2js(node); // TODO: get rid of functions returns\n\n          if (data.length) {\n            if (params.applyTransforms) {\n              applyTransforms(node, data, params);\n            }\n\n            convertToRelative(data);\n            data = filters(data, params, {\n              maybeHasStrokeAndLinecap,\n              hasMarkerMid\n            });\n\n            if (params.utilizeAbsolute) {\n              data = convertToMixed(data, params);\n            }\n\n            js2path(node, data, params);\n          }\n        }\n      }\n    }\n  };\n};\n/**\n * Convert absolute path data coordinates to relative.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\n\n\nconst convertToRelative = pathData => {\n  let start = [0, 0];\n  let cursor = [0, 0];\n  let prevCoords = [0, 0];\n\n  for (let i = 0; i < pathData.length; i += 1) {\n    const pathItem = pathData[i];\n    let {\n      command,\n      args\n    } = pathItem; // moveto (x y)\n\n    if (command === 'm') {\n      // update start and cursor\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n\n    if (command === 'M') {\n      // M → m\n      // skip first moveto\n      if (i !== 0) {\n        command = 'm';\n      }\n\n      args[0] -= cursor[0];\n      args[1] -= cursor[1]; // update start and cursor\n\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    } // lineto (x y)\n\n\n    if (command === 'l') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n\n    if (command === 'L') {\n      // L → l\n      command = 'l';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    } // horizontal lineto (x)\n\n\n    if (command === 'h') {\n      cursor[0] += args[0];\n    }\n\n    if (command === 'H') {\n      // H → h\n      command = 'h';\n      args[0] -= cursor[0];\n      cursor[0] += args[0];\n    } // vertical lineto (y)\n\n\n    if (command === 'v') {\n      cursor[1] += args[0];\n    }\n\n    if (command === 'V') {\n      // V → v\n      command = 'v';\n      args[0] -= cursor[1];\n      cursor[1] += args[0];\n    } // curveto (x1 y1 x2 y2 x y)\n\n\n    if (command === 'c') {\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n    }\n\n    if (command === 'C') {\n      // C → c\n      command = 'c';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      args[4] -= cursor[0];\n      args[5] -= cursor[1];\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n    } // smooth curveto (x2 y2 x y)\n\n\n    if (command === 's') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n\n    if (command === 'S') {\n      // S → s\n      command = 's';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    } // quadratic Bézier curveto (x1 y1 x y)\n\n\n    if (command === 'q') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n\n    if (command === 'Q') {\n      // Q → q\n      command = 'q';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    } // smooth quadratic Bézier curveto (x y)\n\n\n    if (command === 't') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n\n    if (command === 'T') {\n      // T → t\n      command = 't';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    } // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n\n\n    if (command === 'a') {\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n    }\n\n    if (command === 'A') {\n      // A → a\n      command = 'a';\n      args[5] -= cursor[0];\n      args[6] -= cursor[1];\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n    } // closepath\n\n\n    if (command === 'Z' || command === 'z') {\n      // reset cursor\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n    }\n\n    pathItem.command = command;\n    pathItem.args = args; // store absolute coordinates for later use\n    // base should preserve reference from other element\n\n    pathItem.base = prevCoords;\n    pathItem.coords = [cursor[0], cursor[1]];\n    prevCoords = pathItem.coords;\n  }\n\n  return pathData;\n};\n/**\n * Main filters loop.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\n\n\nfunction filters(path, params, _ref) {\n  let {\n    maybeHasStrokeAndLinecap,\n    hasMarkerMid\n  } = _ref;\n  var stringify = data2Path.bind(null, params),\n      relSubpoint = [0, 0],\n      pathBase = [0, 0],\n      prev = {};\n  path = path.filter(function (item, index, path) {\n    let command = item.command;\n    let data = item.args;\n    let next = path[index + 1];\n\n    if (command !== 'Z' && command !== 'z') {\n      var sdata = data,\n          circle;\n\n      if (command === 's') {\n        sdata = [0, 0].concat(data);\n\n        if (command === 'c' || command === 's') {\n          var pdata = prev.args,\n              n = pdata.length; // (-x, -y) of the prev tangent point relative to the current point\n\n          sdata[0] = pdata[n - 2] - pdata[n - 4];\n          sdata[1] = pdata[n - 1] - pdata[n - 3];\n        }\n      } // convert curves to arcs if possible\n\n\n      if (params.makeArcs && (command == 'c' || command == 's') && isConvex(sdata) && (circle = findCircle(sdata))) {\n        var r = roundData([circle.radius])[0],\n            angle = findArcAngle(sdata, circle),\n            sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,\n            arc = {\n          command: 'a',\n          args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],\n          coords: item.coords.slice(),\n          base: item.base\n        },\n            output = [arc],\n            // relative coordinates to adjust the found circle\n        relCenter = [circle.center[0] - sdata[4], circle.center[1] - sdata[5]],\n            relCircle = {\n          center: relCenter,\n          radius: circle.radius\n        },\n            arcCurves = [item],\n            hasPrev = 0,\n            suffix = '',\n            nextLonghand;\n\n        if (prev.command == 'c' && isConvex(prev.args) && isArcPrev(prev.args, circle) || prev.command == 'a' && prev.sdata && isArcPrev(prev.sdata, circle)) {\n          arcCurves.unshift(prev);\n          arc.base = prev.base;\n          arc.args[5] = arc.coords[0] - arc.base[0];\n          arc.args[6] = arc.coords[1] - arc.base[1];\n          var prevData = prev.command == 'a' ? prev.sdata : prev.args;\n          var prevAngle = findArcAngle(prevData, {\n            center: [prevData[4] + circle.center[0], prevData[5] + circle.center[1]],\n            radius: circle.radius\n          });\n          angle += prevAngle;\n          if (angle > Math.PI) arc.args[3] = 1;\n          hasPrev = 1;\n        } // check if next curves are fitting the arc\n\n\n        for (var j = index; (next = path[++j]) && ~'cs'.indexOf(next.command);) {\n          var nextData = next.args;\n\n          if (next.command == 's') {\n            nextLonghand = makeLonghand({\n              command: 's',\n              args: next.args.slice()\n            }, path[j - 1].args);\n            nextData = nextLonghand.args;\n            nextLonghand.args = nextData.slice(0, 2);\n            suffix = stringify([nextLonghand]);\n          }\n\n          if (isConvex(nextData) && isArc(nextData, relCircle)) {\n            angle += findArcAngle(nextData, relCircle);\n            if (angle - 2 * Math.PI > 1e-3) break; // more than 360°\n\n            if (angle > Math.PI) arc.args[3] = 1;\n            arcCurves.push(next);\n\n            if (2 * Math.PI - angle > 1e-3) {\n              // less than 360°\n              arc.coords = next.coords;\n              arc.args[5] = arc.coords[0] - arc.base[0];\n              arc.args[6] = arc.coords[1] - arc.base[1];\n            } else {\n              // full circle, make a half-circle arc and add a second one\n              arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);\n              arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);\n              arc.coords = [arc.base[0] + arc.args[5], arc.base[1] + arc.args[6]];\n              arc = {\n                command: 'a',\n                args: [r, r, 0, 0, sweep, next.coords[0] - arc.coords[0], next.coords[1] - arc.coords[1]],\n                coords: next.coords,\n                base: arc.coords\n              };\n              output.push(arc);\n              j++;\n              break;\n            }\n\n            relCenter[0] -= nextData[4];\n            relCenter[1] -= nextData[5];\n          } else break;\n        }\n\n        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {\n          if (path[j] && path[j].command == 's') {\n            makeLonghand(path[j], path[j - 1].args);\n          }\n\n          if (hasPrev) {\n            var prevArc = output.shift();\n            roundData(prevArc.args);\n            relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];\n            relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];\n            prev.command = 'a';\n            prev.args = prevArc.args;\n            item.base = prev.coords = prevArc.coords;\n          }\n\n          arc = output.shift();\n\n          if (arcCurves.length == 1) {\n            item.sdata = sdata.slice(); // preserve curve data for future checks\n          } else if (arcCurves.length - 1 - hasPrev > 0) {\n            // filter out consumed next items\n            path.splice.apply(path, [index + 1, arcCurves.length - 1 - hasPrev].concat(output));\n          }\n\n          if (!arc) return false;\n          command = 'a';\n          data = arc.args;\n          item.coords = arc.coords;\n        }\n      } // Rounding relative coordinates, taking in account accummulating error\n      // to get closer to absolute coordinates. Sum of rounded value remains same:\n      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2\n\n\n      if (precision !== false) {\n        if (command === 'm' || command === 'l' || command === 't' || command === 'q' || command === 's' || command === 'c') {\n          for (var i = data.length; i--;) {\n            data[i] += item.base[i % 2] - relSubpoint[i % 2];\n          }\n        } else if (command == 'h') {\n          data[0] += item.base[0] - relSubpoint[0];\n        } else if (command == 'v') {\n          data[0] += item.base[1] - relSubpoint[1];\n        } else if (command == 'a') {\n          data[5] += item.base[0] - relSubpoint[0];\n          data[6] += item.base[1] - relSubpoint[1];\n        }\n\n        roundData(data);\n        if (command == 'h') relSubpoint[0] += data[0];else if (command == 'v') relSubpoint[1] += data[0];else {\n          relSubpoint[0] += data[data.length - 2];\n          relSubpoint[1] += data[data.length - 1];\n        }\n        roundData(relSubpoint);\n\n        if (command === 'M' || command === 'm') {\n          pathBase[0] = relSubpoint[0];\n          pathBase[1] = relSubpoint[1];\n        }\n      } // convert straight curves into lines segments\n\n\n      if (params.straightCurves) {\n        if (command === 'c' && isCurveStraightLine(data) || command === 's' && isCurveStraightLine(sdata)) {\n          if (next && next.command == 's') makeLonghand(next, data); // fix up next curve\n\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 'q' && isCurveStraightLine(data)) {\n          if (next && next.command == 't') makeLonghand(next, data); // fix up next curve\n\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 't' && prev.command !== 'q' && prev.command !== 't') {\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 'a' && (data[0] === 0 || data[1] === 0)) {\n          command = 'l';\n          data = data.slice(-2);\n        }\n      } // horizontal and vertical line shorthands\n      // l 50 0 → h 50\n      // l 0 50 → v 50\n\n\n      if (params.lineShorthands && command === 'l') {\n        if (data[1] === 0) {\n          command = 'h';\n          data.pop();\n        } else if (data[0] === 0) {\n          command = 'v';\n          data.shift();\n        }\n      } // collapse repeated commands\n      // h 20 h 30 -> h 50\n\n\n      if (params.collapseRepeated && hasMarkerMid === false && (command === 'm' || command === 'h' || command === 'v') && prev.command && command == prev.command.toLowerCase() && (command != 'h' && command != 'v' || prev.args[0] >= 0 == data[0] >= 0)) {\n        prev.args[0] += data[0];\n\n        if (command != 'h' && command != 'v') {\n          prev.args[1] += data[1];\n        }\n\n        prev.coords = item.coords;\n        path[index] = prev;\n        return false;\n      } // convert curves into smooth shorthands\n\n\n      if (params.curveSmoothShorthands && prev.command) {\n        // curveto\n        if (command === 'c') {\n          // c + c → c + s\n          if (prev.command === 'c' && data[0] === -(prev.args[2] - prev.args[4]) && data[1] === -(prev.args[3] - prev.args[5])) {\n            command = 's';\n            data = data.slice(2);\n          } // s + c → s + s\n          else if (prev.command === 's' && data[0] === -(prev.args[0] - prev.args[2]) && data[1] === -(prev.args[1] - prev.args[3])) {\n            command = 's';\n            data = data.slice(2);\n          } // [^cs] + c → [^cs] + s\n          else if (prev.command !== 'c' && prev.command !== 's' && data[0] === 0 && data[1] === 0) {\n            command = 's';\n            data = data.slice(2);\n          }\n        } // quadratic Bézier curveto\n        else if (command === 'q') {\n          // q + q → q + t\n          if (prev.command === 'q' && data[0] === prev.args[2] - prev.args[0] && data[1] === prev.args[3] - prev.args[1]) {\n            command = 't';\n            data = data.slice(2);\n          } // t + q → t + t\n          else if (prev.command === 't' && data[2] === prev.args[0] && data[3] === prev.args[1]) {\n            command = 't';\n            data = data.slice(2);\n          }\n        }\n      } // remove useless non-first path segments\n\n\n      if (params.removeUseless && !maybeHasStrokeAndLinecap) {\n        // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0\n        if ((command === 'l' || command === 'h' || command === 'v' || command === 'q' || command === 't' || command === 'c' || command === 's') && data.every(function (i) {\n          return i === 0;\n        })) {\n          path[index] = prev;\n          return false;\n        } // a 25,25 -30 0,1 0,0\n\n\n        if (command === 'a' && data[5] === 0 && data[6] === 0) {\n          path[index] = prev;\n          return false;\n        }\n      }\n\n      item.command = command;\n      item.args = data;\n      prev = item;\n    } else {\n      // z resets coordinates\n      relSubpoint[0] = pathBase[0];\n      relSubpoint[1] = pathBase[1];\n      if (prev.command === 'Z' || prev.command === 'z') return false;\n      prev = item;\n    }\n\n    return true;\n  });\n  return path;\n}\n/**\n * Writes data in shortest form using absolute or relative coordinates.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\n\n\nfunction convertToMixed(path, params) {\n  var prev = path[0];\n  path = path.filter(function (item, index) {\n    if (index == 0) return true;\n\n    if (item.command === 'Z' || item.command === 'z') {\n      prev = item;\n      return true;\n    }\n\n    var command = item.command,\n        data = item.args,\n        adata = data.slice();\n\n    if (command === 'm' || command === 'l' || command === 't' || command === 'q' || command === 's' || command === 'c') {\n      for (var i = adata.length; i--;) {\n        adata[i] += item.base[i % 2];\n      }\n    } else if (command == 'h') {\n      adata[0] += item.base[0];\n    } else if (command == 'v') {\n      adata[0] += item.base[1];\n    } else if (command == 'a') {\n      adata[5] += item.base[0];\n      adata[6] += item.base[1];\n    }\n\n    roundData(adata);\n    var absoluteDataStr = cleanupOutData(adata, params),\n        relativeDataStr = cleanupOutData(data, params); // Convert to absolute coordinates if it's shorter or forceAbsolutePath is true.\n    // v-20 -> V0\n    // Don't convert if it fits following previous command.\n    // l20 30-10-50 instead of l20 30L20 30\n\n    if (params.forceAbsolutePath || absoluteDataStr.length < relativeDataStr.length && !(params.negativeExtraSpace && command == prev.command && prev.command.charCodeAt(0) > 96 && absoluteDataStr.length == relativeDataStr.length - 1 && (data[0] < 0 || /^0\\./.test(data[0]) && prev.args[prev.args.length - 1] % 1))) {\n      item.command = command.toUpperCase();\n      item.args = adata;\n    }\n\n    prev = item;\n    return true;\n  });\n  return path;\n}\n/**\n * Checks if curve is convex. Control points of such a curve must form\n * a convex quadrilateral with diagonals crosspoint inside of it.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\n\n\nfunction isConvex(data) {\n  var center = getIntersection([0, 0, data[2], data[3], data[0], data[1], data[4], data[5]]);\n  return center && data[2] < center[0] == center[0] < 0 && data[3] < center[1] == center[1] < 0 && data[4] < center[0] == center[0] < data[0] && data[5] < center[1] == center[1] < data[1];\n}\n/**\n * Computes lines equations by two points and returns their intersection point.\n *\n * @param {Array} coords 8 numbers for 4 pairs of coordinates (x,y)\n * @return {Array|undefined} output coordinate of lines' crosspoint\n */\n\n\nfunction getIntersection(coords) {\n  // Prev line equation parameters.\n  var a1 = coords[1] - coords[3],\n      // y1 - y2\n  b1 = coords[2] - coords[0],\n      // x2 - x1\n  c1 = coords[0] * coords[3] - coords[2] * coords[1],\n      // x1 * y2 - x2 * y1\n  // Next line equation parameters\n  a2 = coords[5] - coords[7],\n      // y1 - y2\n  b2 = coords[6] - coords[4],\n      // x2 - x1\n  c2 = coords[4] * coords[7] - coords[5] * coords[6],\n      // x1 * y2 - x2 * y1\n  denom = a1 * b2 - a2 * b1;\n  if (!denom) return; // parallel lines havn't an intersection\n\n  var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];\n\n  if (!isNaN(cross[0]) && !isNaN(cross[1]) && isFinite(cross[0]) && isFinite(cross[1])) {\n    return cross;\n  }\n}\n/**\n * Decrease accuracy of floating-point numbers\n * in path data keeping a specified number of decimals.\n * Smart rounds values like 2.3491 to 2.35 instead of 2.349.\n * Doesn't apply \"smartness\" if the number precision fits already.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\n\n\nfunction strongRound(data) {\n  for (var i = data.length; i-- > 0;) {\n    if (data[i].toFixed(precision) != data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error ? +data[i].toFixed(precision) : rounded;\n    }\n  }\n\n  return data;\n}\n/**\n * Simple rounding function if precision is 0.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\n\n\nfunction round(data) {\n  for (var i = data.length; i-- > 0;) {\n    data[i] = Math.round(data[i]);\n  }\n\n  return data;\n}\n/**\n * Checks if a curve is a straight line by measuring distance\n * from middle points to the line formed by end points.\n *\n * @param {Array} xs array of curve points x-coordinates\n * @param {Array} ys array of curve points y-coordinates\n * @return {Boolean}\n */\n\n\nfunction isCurveStraightLine(data) {\n  // Get line equation a·x + b·y + c = 0 coefficients a, b (c = 0) by start and end points.\n  var i = data.length - 2,\n      a = -data[i + 1],\n      // y1 − y2 (y1 = 0)\n  b = data[i],\n      // x2 − x1 (x1 = 0)\n  d = 1 / (a * a + b * b); // same part for all points\n\n  if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case\n  // Distance from point (x0, y0) to the line is sqrt((c − a·x0 − b·y0)² / (a² + b²))\n\n  while ((i -= 2) >= 0) {\n    if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error) return false;\n  }\n\n  return true;\n}\n/**\n * Converts next curve from shorthand to full form using the current curve data.\n *\n * @param {Object} item curve to convert\n * @param {Array} data current curve data\n */\n\n\nfunction makeLonghand(item, data) {\n  switch (item.command) {\n    case 's':\n      item.command = 'c';\n      break;\n\n    case 't':\n      item.command = 'q';\n      break;\n  }\n\n  item.args.unshift(data[data.length - 2] - data[data.length - 4], data[data.length - 1] - data[data.length - 3]);\n  return item;\n}\n/**\n * Returns distance between two points\n *\n * @param {Array} point1 first point coordinates\n * @param {Array} point2 second point coordinates\n * @return {Number} distance\n */\n\n\nfunction getDistance(point1, point2) {\n  return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);\n}\n/**\n * Returns coordinates of the curve point corresponding to the certain t\n * a·(1 - t)³·p1 + b·(1 - t)²·t·p2 + c·(1 - t)·t²·p3 + d·t³·p4,\n * where pN are control points and p1 is zero due to relative coordinates.\n *\n * @param {Array} curve array of curve points coordinates\n * @param {Number} t parametric position from 0 to 1\n * @return {Array} Point coordinates\n */\n\n\nfunction getCubicBezierPoint(curve, t) {\n  var sqrT = t * t,\n      cubT = sqrT * t,\n      mt = 1 - t,\n      sqrMt = mt * mt;\n  return [3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4], 3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5]];\n}\n/**\n * Finds circle by 3 points of the curve and checks if the curve fits the found circle.\n *\n * @param {Array} curve\n * @return {Object|undefined} circle\n */\n\n\nfunction findCircle(curve) {\n  var midPoint = getCubicBezierPoint(curve, 1 / 2),\n      m1 = [midPoint[0] / 2, midPoint[1] / 2],\n      m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],\n      center = getIntersection([m1[0], m1[1], m1[0] + m1[1], m1[1] - m1[0], m2[0], m2[1], m2[0] + (m2[1] - midPoint[1]), m2[1] - (m2[0] - midPoint[0])]),\n      radius = center && getDistance([0, 0], center),\n      tolerance = Math.min(arcThreshold * error, arcTolerance * radius / 100);\n  if (center && radius < 1e15 && [1 / 4, 3 / 4].every(function (point) {\n    return Math.abs(getDistance(getCubicBezierPoint(curve, point), center) - radius) <= tolerance;\n  })) return {\n    center: center,\n    radius: radius\n  };\n}\n/**\n * Checks if a curve fits the given circle.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\n\nfunction isArc(curve, circle) {\n  var tolerance = Math.min(arcThreshold * error, arcTolerance * circle.radius / 100);\n  return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {\n    return Math.abs(getDistance(getCubicBezierPoint(curve, point), circle.center) - circle.radius) <= tolerance;\n  });\n}\n/**\n * Checks if a previous curve fits the given circle.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\n\nfunction isArcPrev(curve, circle) {\n  return isArc(curve, {\n    center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],\n    radius: circle.radius\n  });\n}\n/**\n * Finds angle of a curve fitting the given arc.\n\n * @param {Array} curve\n * @param {Object} relCircle\n * @return {Number} angle\n */\n\n\nfunction findArcAngle(curve, relCircle) {\n  var x1 = -relCircle.center[0],\n      y1 = -relCircle.center[1],\n      x2 = curve[4] - relCircle.center[0],\n      y2 = curve[5] - relCircle.center[1];\n  return Math.acos((x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)));\n}\n/**\n * Converts given path data to string.\n *\n * @param {Object} params\n * @param {Array} pathData\n * @return {String}\n */\n\n\nfunction data2Path(params, pathData) {\n  return pathData.reduce(function (pathString, item) {\n    var strData = '';\n\n    if (item.args) {\n      strData = cleanupOutData(roundData(item.args.slice()), params);\n    }\n\n    return pathString + item.command + strData;\n  }, '');\n}","map":{"version":3,"names":["collectStylesheet","computeStyle","require","pathElems","path2js","js2path","applyTransforms","cleanupOutData","exports","name","type","active","description","params","applyTransformsStroked","makeArcs","threshold","tolerance","straightCurves","lineShorthands","curveSmoothShorthands","floatPrecision","transformPrecision","removeUseless","collapseRepeated","utilizeAbsolute","leadingZero","negativeExtraSpace","noSpaceAfterFlags","forceAbsolutePath","roundData","precision","error","arcThreshold","arcTolerance","fn","root","stylesheet","element","enter","node","includes","attributes","d","computedStyle","Math","pow","toFixed","strongRound","round","hasMarkerMid","maybeHasStroke","stroke","value","maybeHasLinecap","maybeHasStrokeAndLinecap","data","length","convertToRelative","filters","convertToMixed","pathData","start","cursor","prevCoords","i","pathItem","command","args","base","coords","path","stringify","data2Path","bind","relSubpoint","pathBase","prev","filter","item","index","next","sdata","circle","concat","pdata","n","isConvex","findCircle","r","radius","angle","findArcAngle","sweep","arc","slice","output","relCenter","center","relCircle","arcCurves","hasPrev","suffix","nextLonghand","isArcPrev","unshift","prevData","prevAngle","PI","j","indexOf","nextData","makeLonghand","isArc","push","prevArc","shift","splice","apply","isCurveStraightLine","pop","toLowerCase","every","adata","absoluteDataStr","relativeDataStr","charCodeAt","test","toUpperCase","getIntersection","a1","b1","c1","a2","b2","c2","denom","cross","isNaN","isFinite","rounded","abs","a","b","sqrt","getDistance","point1","point2","hypot","getCubicBezierPoint","curve","t","sqrT","cubT","mt","sqrMt","midPoint","m1","m2","min","point","x1","y1","x2","y2","acos","reduce","pathString","strData"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/svgo/plugins/convertPathData.js"],"sourcesContent":["'use strict';\n\nconst { collectStylesheet, computeStyle } = require('../lib/style.js');\nconst { pathElems } = require('./_collections.js');\nconst { path2js, js2path } = require('./_path.js');\nconst { applyTransforms } = require('./_applyTransforms.js');\nconst { cleanupOutData } = require('../lib/svgo/tools');\n\nexports.name = 'convertPathData';\nexports.type = 'visitor';\nexports.active = true;\nexports.description =\n  'optimizes path data: writes in shorter form, applies transformations';\n\nexports.params = {\n  applyTransforms: true,\n  applyTransformsStroked: true,\n  makeArcs: {\n    threshold: 2.5, // coefficient of rounding error\n    tolerance: 0.5, // percentage of radius\n  },\n  straightCurves: true,\n  lineShorthands: true,\n  curveSmoothShorthands: true,\n  floatPrecision: 3,\n  transformPrecision: 5,\n  removeUseless: true,\n  collapseRepeated: true,\n  utilizeAbsolute: true,\n  leadingZero: true,\n  negativeExtraSpace: true,\n  noSpaceAfterFlags: false, // a20 60 45 0 1 30 20 → a20 60 45 0130 20\n  forceAbsolutePath: false,\n};\n\nlet roundData;\nlet precision;\nlet error;\nlet arcThreshold;\nlet arcTolerance;\n\n/**\n * Convert absolute Path to relative,\n * collapse repeated instructions,\n * detect and convert Lineto shorthands,\n * remove useless instructions like \"l0,0\",\n * trim useless delimiters and leading zeros,\n * decrease accuracy of floating-point numbers.\n *\n * @see https://www.w3.org/TR/SVG11/paths.html#PathData\n *\n * @param {Object} item current iteration item\n * @param {Object} params plugin params\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\nexports.fn = (root, params) => {\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: (node) => {\n        if (pathElems.includes(node.name) && node.attributes.d != null) {\n          const computedStyle = computeStyle(stylesheet, node);\n          precision = params.floatPrecision;\n          error =\n            precision !== false\n              ? +Math.pow(0.1, precision).toFixed(precision)\n              : 1e-2;\n          roundData = precision > 0 && precision < 20 ? strongRound : round;\n          if (params.makeArcs) {\n            arcThreshold = params.makeArcs.threshold;\n            arcTolerance = params.makeArcs.tolerance;\n          }\n          const hasMarkerMid = computedStyle['marker-mid'] != null;\n\n          const maybeHasStroke =\n            computedStyle.stroke &&\n            (computedStyle.stroke.type === 'dynamic' ||\n              computedStyle.stroke.value !== 'none');\n          const maybeHasLinecap =\n            computedStyle['stroke-linecap'] &&\n            (computedStyle['stroke-linecap'].type === 'dynamic' ||\n              computedStyle['stroke-linecap'].value !== 'butt');\n          const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;\n\n          var data = path2js(node);\n\n          // TODO: get rid of functions returns\n          if (data.length) {\n            if (params.applyTransforms) {\n              applyTransforms(node, data, params);\n            }\n\n            convertToRelative(data);\n\n            data = filters(data, params, {\n              maybeHasStrokeAndLinecap,\n              hasMarkerMid,\n            });\n\n            if (params.utilizeAbsolute) {\n              data = convertToMixed(data, params);\n            }\n\n            js2path(node, data, params);\n          }\n        }\n      },\n    },\n  };\n};\n\n/**\n * Convert absolute path data coordinates to relative.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\nconst convertToRelative = (pathData) => {\n  let start = [0, 0];\n  let cursor = [0, 0];\n  let prevCoords = [0, 0];\n\n  for (let i = 0; i < pathData.length; i += 1) {\n    const pathItem = pathData[i];\n    let { command, args } = pathItem;\n\n    // moveto (x y)\n    if (command === 'm') {\n      // update start and cursor\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n    if (command === 'M') {\n      // M → m\n      // skip first moveto\n      if (i !== 0) {\n        command = 'm';\n      }\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      // update start and cursor\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n      start[0] = cursor[0];\n      start[1] = cursor[1];\n    }\n\n    // lineto (x y)\n    if (command === 'l') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n    if (command === 'L') {\n      // L → l\n      command = 'l';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n\n    // horizontal lineto (x)\n    if (command === 'h') {\n      cursor[0] += args[0];\n    }\n    if (command === 'H') {\n      // H → h\n      command = 'h';\n      args[0] -= cursor[0];\n      cursor[0] += args[0];\n    }\n\n    // vertical lineto (y)\n    if (command === 'v') {\n      cursor[1] += args[0];\n    }\n    if (command === 'V') {\n      // V → v\n      command = 'v';\n      args[0] -= cursor[1];\n      cursor[1] += args[0];\n    }\n\n    // curveto (x1 y1 x2 y2 x y)\n    if (command === 'c') {\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n    }\n    if (command === 'C') {\n      // C → c\n      command = 'c';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      args[4] -= cursor[0];\n      args[5] -= cursor[1];\n      cursor[0] += args[4];\n      cursor[1] += args[5];\n    }\n\n    // smooth curveto (x2 y2 x y)\n    if (command === 's') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n    if (command === 'S') {\n      // S → s\n      command = 's';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n\n    // quadratic Bézier curveto (x1 y1 x y)\n    if (command === 'q') {\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n    if (command === 'Q') {\n      // Q → q\n      command = 'q';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      args[2] -= cursor[0];\n      args[3] -= cursor[1];\n      cursor[0] += args[2];\n      cursor[1] += args[3];\n    }\n\n    // smooth quadratic Bézier curveto (x y)\n    if (command === 't') {\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n    if (command === 'T') {\n      // T → t\n      command = 't';\n      args[0] -= cursor[0];\n      args[1] -= cursor[1];\n      cursor[0] += args[0];\n      cursor[1] += args[1];\n    }\n\n    // elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)\n    if (command === 'a') {\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n    }\n    if (command === 'A') {\n      // A → a\n      command = 'a';\n      args[5] -= cursor[0];\n      args[6] -= cursor[1];\n      cursor[0] += args[5];\n      cursor[1] += args[6];\n    }\n\n    // closepath\n    if (command === 'Z' || command === 'z') {\n      // reset cursor\n      cursor[0] = start[0];\n      cursor[1] = start[1];\n    }\n\n    pathItem.command = command;\n    pathItem.args = args;\n    // store absolute coordinates for later use\n    // base should preserve reference from other element\n    pathItem.base = prevCoords;\n    pathItem.coords = [cursor[0], cursor[1]];\n    prevCoords = pathItem.coords;\n  }\n\n  return pathData;\n};\n\n/**\n * Main filters loop.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\nfunction filters(path, params, { maybeHasStrokeAndLinecap, hasMarkerMid }) {\n  var stringify = data2Path.bind(null, params),\n    relSubpoint = [0, 0],\n    pathBase = [0, 0],\n    prev = {};\n\n  path = path.filter(function (item, index, path) {\n    let command = item.command;\n    let data = item.args;\n    let next = path[index + 1];\n\n    if (command !== 'Z' && command !== 'z') {\n      var sdata = data,\n        circle;\n\n      if (command === 's') {\n        sdata = [0, 0].concat(data);\n\n        if (command === 'c' || command === 's') {\n          var pdata = prev.args,\n            n = pdata.length;\n\n          // (-x, -y) of the prev tangent point relative to the current point\n          sdata[0] = pdata[n - 2] - pdata[n - 4];\n          sdata[1] = pdata[n - 1] - pdata[n - 3];\n        }\n      }\n\n      // convert curves to arcs if possible\n      if (\n        params.makeArcs &&\n        (command == 'c' || command == 's') &&\n        isConvex(sdata) &&\n        (circle = findCircle(sdata))\n      ) {\n        var r = roundData([circle.radius])[0],\n          angle = findArcAngle(sdata, circle),\n          sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,\n          arc = {\n            command: 'a',\n            args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],\n            coords: item.coords.slice(),\n            base: item.base,\n          },\n          output = [arc],\n          // relative coordinates to adjust the found circle\n          relCenter = [\n            circle.center[0] - sdata[4],\n            circle.center[1] - sdata[5],\n          ],\n          relCircle = { center: relCenter, radius: circle.radius },\n          arcCurves = [item],\n          hasPrev = 0,\n          suffix = '',\n          nextLonghand;\n\n        if (\n          (prev.command == 'c' &&\n            isConvex(prev.args) &&\n            isArcPrev(prev.args, circle)) ||\n          (prev.command == 'a' && prev.sdata && isArcPrev(prev.sdata, circle))\n        ) {\n          arcCurves.unshift(prev);\n          arc.base = prev.base;\n          arc.args[5] = arc.coords[0] - arc.base[0];\n          arc.args[6] = arc.coords[1] - arc.base[1];\n          var prevData = prev.command == 'a' ? prev.sdata : prev.args;\n          var prevAngle = findArcAngle(prevData, {\n            center: [\n              prevData[4] + circle.center[0],\n              prevData[5] + circle.center[1],\n            ],\n            radius: circle.radius,\n          });\n          angle += prevAngle;\n          if (angle > Math.PI) arc.args[3] = 1;\n          hasPrev = 1;\n        }\n\n        // check if next curves are fitting the arc\n        for (\n          var j = index;\n          (next = path[++j]) && ~'cs'.indexOf(next.command);\n\n        ) {\n          var nextData = next.args;\n          if (next.command == 's') {\n            nextLonghand = makeLonghand(\n              { command: 's', args: next.args.slice() },\n              path[j - 1].args\n            );\n            nextData = nextLonghand.args;\n            nextLonghand.args = nextData.slice(0, 2);\n            suffix = stringify([nextLonghand]);\n          }\n          if (isConvex(nextData) && isArc(nextData, relCircle)) {\n            angle += findArcAngle(nextData, relCircle);\n            if (angle - 2 * Math.PI > 1e-3) break; // more than 360°\n            if (angle > Math.PI) arc.args[3] = 1;\n            arcCurves.push(next);\n            if (2 * Math.PI - angle > 1e-3) {\n              // less than 360°\n              arc.coords = next.coords;\n              arc.args[5] = arc.coords[0] - arc.base[0];\n              arc.args[6] = arc.coords[1] - arc.base[1];\n            } else {\n              // full circle, make a half-circle arc and add a second one\n              arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);\n              arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);\n              arc.coords = [\n                arc.base[0] + arc.args[5],\n                arc.base[1] + arc.args[6],\n              ];\n              arc = {\n                command: 'a',\n                args: [\n                  r,\n                  r,\n                  0,\n                  0,\n                  sweep,\n                  next.coords[0] - arc.coords[0],\n                  next.coords[1] - arc.coords[1],\n                ],\n                coords: next.coords,\n                base: arc.coords,\n              };\n              output.push(arc);\n              j++;\n              break;\n            }\n            relCenter[0] -= nextData[4];\n            relCenter[1] -= nextData[5];\n          } else break;\n        }\n\n        if ((stringify(output) + suffix).length < stringify(arcCurves).length) {\n          if (path[j] && path[j].command == 's') {\n            makeLonghand(path[j], path[j - 1].args);\n          }\n          if (hasPrev) {\n            var prevArc = output.shift();\n            roundData(prevArc.args);\n            relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];\n            relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];\n            prev.command = 'a';\n            prev.args = prevArc.args;\n            item.base = prev.coords = prevArc.coords;\n          }\n          arc = output.shift();\n          if (arcCurves.length == 1) {\n            item.sdata = sdata.slice(); // preserve curve data for future checks\n          } else if (arcCurves.length - 1 - hasPrev > 0) {\n            // filter out consumed next items\n            path.splice.apply(\n              path,\n              [index + 1, arcCurves.length - 1 - hasPrev].concat(output)\n            );\n          }\n          if (!arc) return false;\n          command = 'a';\n          data = arc.args;\n          item.coords = arc.coords;\n        }\n      }\n\n      // Rounding relative coordinates, taking in account accummulating error\n      // to get closer to absolute coordinates. Sum of rounded value remains same:\n      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2\n      if (precision !== false) {\n        if (\n          command === 'm' ||\n          command === 'l' ||\n          command === 't' ||\n          command === 'q' ||\n          command === 's' ||\n          command === 'c'\n        ) {\n          for (var i = data.length; i--; ) {\n            data[i] += item.base[i % 2] - relSubpoint[i % 2];\n          }\n        } else if (command == 'h') {\n          data[0] += item.base[0] - relSubpoint[0];\n        } else if (command == 'v') {\n          data[0] += item.base[1] - relSubpoint[1];\n        } else if (command == 'a') {\n          data[5] += item.base[0] - relSubpoint[0];\n          data[6] += item.base[1] - relSubpoint[1];\n        }\n        roundData(data);\n\n        if (command == 'h') relSubpoint[0] += data[0];\n        else if (command == 'v') relSubpoint[1] += data[0];\n        else {\n          relSubpoint[0] += data[data.length - 2];\n          relSubpoint[1] += data[data.length - 1];\n        }\n        roundData(relSubpoint);\n\n        if (command === 'M' || command === 'm') {\n          pathBase[0] = relSubpoint[0];\n          pathBase[1] = relSubpoint[1];\n        }\n      }\n\n      // convert straight curves into lines segments\n      if (params.straightCurves) {\n        if (\n          (command === 'c' && isCurveStraightLine(data)) ||\n          (command === 's' && isCurveStraightLine(sdata))\n        ) {\n          if (next && next.command == 's') makeLonghand(next, data); // fix up next curve\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 'q' && isCurveStraightLine(data)) {\n          if (next && next.command == 't') makeLonghand(next, data); // fix up next curve\n          command = 'l';\n          data = data.slice(-2);\n        } else if (\n          command === 't' &&\n          prev.command !== 'q' &&\n          prev.command !== 't'\n        ) {\n          command = 'l';\n          data = data.slice(-2);\n        } else if (command === 'a' && (data[0] === 0 || data[1] === 0)) {\n          command = 'l';\n          data = data.slice(-2);\n        }\n      }\n\n      // horizontal and vertical line shorthands\n      // l 50 0 → h 50\n      // l 0 50 → v 50\n      if (params.lineShorthands && command === 'l') {\n        if (data[1] === 0) {\n          command = 'h';\n          data.pop();\n        } else if (data[0] === 0) {\n          command = 'v';\n          data.shift();\n        }\n      }\n\n      // collapse repeated commands\n      // h 20 h 30 -> h 50\n      if (\n        params.collapseRepeated &&\n        hasMarkerMid === false &&\n        (command === 'm' || command === 'h' || command === 'v') &&\n        prev.command &&\n        command == prev.command.toLowerCase() &&\n        ((command != 'h' && command != 'v') ||\n          prev.args[0] >= 0 == data[0] >= 0)\n      ) {\n        prev.args[0] += data[0];\n        if (command != 'h' && command != 'v') {\n          prev.args[1] += data[1];\n        }\n        prev.coords = item.coords;\n        path[index] = prev;\n        return false;\n      }\n\n      // convert curves into smooth shorthands\n      if (params.curveSmoothShorthands && prev.command) {\n        // curveto\n        if (command === 'c') {\n          // c + c → c + s\n          if (\n            prev.command === 'c' &&\n            data[0] === -(prev.args[2] - prev.args[4]) &&\n            data[1] === -(prev.args[3] - prev.args[5])\n          ) {\n            command = 's';\n            data = data.slice(2);\n          }\n\n          // s + c → s + s\n          else if (\n            prev.command === 's' &&\n            data[0] === -(prev.args[0] - prev.args[2]) &&\n            data[1] === -(prev.args[1] - prev.args[3])\n          ) {\n            command = 's';\n            data = data.slice(2);\n          }\n\n          // [^cs] + c → [^cs] + s\n          else if (\n            prev.command !== 'c' &&\n            prev.command !== 's' &&\n            data[0] === 0 &&\n            data[1] === 0\n          ) {\n            command = 's';\n            data = data.slice(2);\n          }\n        }\n\n        // quadratic Bézier curveto\n        else if (command === 'q') {\n          // q + q → q + t\n          if (\n            prev.command === 'q' &&\n            data[0] === prev.args[2] - prev.args[0] &&\n            data[1] === prev.args[3] - prev.args[1]\n          ) {\n            command = 't';\n            data = data.slice(2);\n          }\n\n          // t + q → t + t\n          else if (\n            prev.command === 't' &&\n            data[2] === prev.args[0] &&\n            data[3] === prev.args[1]\n          ) {\n            command = 't';\n            data = data.slice(2);\n          }\n        }\n      }\n\n      // remove useless non-first path segments\n      if (params.removeUseless && !maybeHasStrokeAndLinecap) {\n        // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0\n        if (\n          (command === 'l' ||\n            command === 'h' ||\n            command === 'v' ||\n            command === 'q' ||\n            command === 't' ||\n            command === 'c' ||\n            command === 's') &&\n          data.every(function (i) {\n            return i === 0;\n          })\n        ) {\n          path[index] = prev;\n          return false;\n        }\n\n        // a 25,25 -30 0,1 0,0\n        if (command === 'a' && data[5] === 0 && data[6] === 0) {\n          path[index] = prev;\n          return false;\n        }\n      }\n\n      item.command = command;\n      item.args = data;\n\n      prev = item;\n    } else {\n      // z resets coordinates\n      relSubpoint[0] = pathBase[0];\n      relSubpoint[1] = pathBase[1];\n      if (prev.command === 'Z' || prev.command === 'z') return false;\n      prev = item;\n    }\n\n    return true;\n  });\n\n  return path;\n}\n\n/**\n * Writes data in shortest form using absolute or relative coordinates.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\nfunction convertToMixed(path, params) {\n  var prev = path[0];\n\n  path = path.filter(function (item, index) {\n    if (index == 0) return true;\n    if (item.command === 'Z' || item.command === 'z') {\n      prev = item;\n      return true;\n    }\n\n    var command = item.command,\n      data = item.args,\n      adata = data.slice();\n\n    if (\n      command === 'm' ||\n      command === 'l' ||\n      command === 't' ||\n      command === 'q' ||\n      command === 's' ||\n      command === 'c'\n    ) {\n      for (var i = adata.length; i--; ) {\n        adata[i] += item.base[i % 2];\n      }\n    } else if (command == 'h') {\n      adata[0] += item.base[0];\n    } else if (command == 'v') {\n      adata[0] += item.base[1];\n    } else if (command == 'a') {\n      adata[5] += item.base[0];\n      adata[6] += item.base[1];\n    }\n\n    roundData(adata);\n\n    var absoluteDataStr = cleanupOutData(adata, params),\n      relativeDataStr = cleanupOutData(data, params);\n\n    // Convert to absolute coordinates if it's shorter or forceAbsolutePath is true.\n    // v-20 -> V0\n    // Don't convert if it fits following previous command.\n    // l20 30-10-50 instead of l20 30L20 30\n    if (\n      params.forceAbsolutePath ||\n      (absoluteDataStr.length < relativeDataStr.length &&\n        !(\n          params.negativeExtraSpace &&\n          command == prev.command &&\n          prev.command.charCodeAt(0) > 96 &&\n          absoluteDataStr.length == relativeDataStr.length - 1 &&\n          (data[0] < 0 ||\n            (/^0\\./.test(data[0]) && prev.args[prev.args.length - 1] % 1))\n        ))\n    ) {\n      item.command = command.toUpperCase();\n      item.args = adata;\n    }\n\n    prev = item;\n\n    return true;\n  });\n\n  return path;\n}\n\n/**\n * Checks if curve is convex. Control points of such a curve must form\n * a convex quadrilateral with diagonals crosspoint inside of it.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\nfunction isConvex(data) {\n  var center = getIntersection([\n    0,\n    0,\n    data[2],\n    data[3],\n    data[0],\n    data[1],\n    data[4],\n    data[5],\n  ]);\n\n  return (\n    center &&\n    data[2] < center[0] == center[0] < 0 &&\n    data[3] < center[1] == center[1] < 0 &&\n    data[4] < center[0] == center[0] < data[0] &&\n    data[5] < center[1] == center[1] < data[1]\n  );\n}\n\n/**\n * Computes lines equations by two points and returns their intersection point.\n *\n * @param {Array} coords 8 numbers for 4 pairs of coordinates (x,y)\n * @return {Array|undefined} output coordinate of lines' crosspoint\n */\nfunction getIntersection(coords) {\n  // Prev line equation parameters.\n  var a1 = coords[1] - coords[3], // y1 - y2\n    b1 = coords[2] - coords[0], // x2 - x1\n    c1 = coords[0] * coords[3] - coords[2] * coords[1], // x1 * y2 - x2 * y1\n    // Next line equation parameters\n    a2 = coords[5] - coords[7], // y1 - y2\n    b2 = coords[6] - coords[4], // x2 - x1\n    c2 = coords[4] * coords[7] - coords[5] * coords[6], // x1 * y2 - x2 * y1\n    denom = a1 * b2 - a2 * b1;\n\n  if (!denom) return; // parallel lines havn't an intersection\n\n  var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];\n  if (\n    !isNaN(cross[0]) &&\n    !isNaN(cross[1]) &&\n    isFinite(cross[0]) &&\n    isFinite(cross[1])\n  ) {\n    return cross;\n  }\n}\n\n/**\n * Decrease accuracy of floating-point numbers\n * in path data keeping a specified number of decimals.\n * Smart rounds values like 2.3491 to 2.35 instead of 2.349.\n * Doesn't apply \"smartness\" if the number precision fits already.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\nfunction strongRound(data) {\n  for (var i = data.length; i-- > 0; ) {\n    if (data[i].toFixed(precision) != data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] =\n        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error\n          ? +data[i].toFixed(precision)\n          : rounded;\n    }\n  }\n  return data;\n}\n\n/**\n * Simple rounding function if precision is 0.\n *\n * @param {Array} data input data array\n * @return {Array} output data array\n */\nfunction round(data) {\n  for (var i = data.length; i-- > 0; ) {\n    data[i] = Math.round(data[i]);\n  }\n  return data;\n}\n\n/**\n * Checks if a curve is a straight line by measuring distance\n * from middle points to the line formed by end points.\n *\n * @param {Array} xs array of curve points x-coordinates\n * @param {Array} ys array of curve points y-coordinates\n * @return {Boolean}\n */\n\nfunction isCurveStraightLine(data) {\n  // Get line equation a·x + b·y + c = 0 coefficients a, b (c = 0) by start and end points.\n  var i = data.length - 2,\n    a = -data[i + 1], // y1 − y2 (y1 = 0)\n    b = data[i], // x2 − x1 (x1 = 0)\n    d = 1 / (a * a + b * b); // same part for all points\n\n  if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case\n\n  // Distance from point (x0, y0) to the line is sqrt((c − a·x0 − b·y0)² / (a² + b²))\n  while ((i -= 2) >= 0) {\n    if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)\n      return false;\n  }\n\n  return true;\n}\n\n/**\n * Converts next curve from shorthand to full form using the current curve data.\n *\n * @param {Object} item curve to convert\n * @param {Array} data current curve data\n */\n\nfunction makeLonghand(item, data) {\n  switch (item.command) {\n    case 's':\n      item.command = 'c';\n      break;\n    case 't':\n      item.command = 'q';\n      break;\n  }\n  item.args.unshift(\n    data[data.length - 2] - data[data.length - 4],\n    data[data.length - 1] - data[data.length - 3]\n  );\n  return item;\n}\n\n/**\n * Returns distance between two points\n *\n * @param {Array} point1 first point coordinates\n * @param {Array} point2 second point coordinates\n * @return {Number} distance\n */\n\nfunction getDistance(point1, point2) {\n  return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);\n}\n\n/**\n * Returns coordinates of the curve point corresponding to the certain t\n * a·(1 - t)³·p1 + b·(1 - t)²·t·p2 + c·(1 - t)·t²·p3 + d·t³·p4,\n * where pN are control points and p1 is zero due to relative coordinates.\n *\n * @param {Array} curve array of curve points coordinates\n * @param {Number} t parametric position from 0 to 1\n * @return {Array} Point coordinates\n */\n\nfunction getCubicBezierPoint(curve, t) {\n  var sqrT = t * t,\n    cubT = sqrT * t,\n    mt = 1 - t,\n    sqrMt = mt * mt;\n\n  return [\n    3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],\n    3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5],\n  ];\n}\n\n/**\n * Finds circle by 3 points of the curve and checks if the curve fits the found circle.\n *\n * @param {Array} curve\n * @return {Object|undefined} circle\n */\n\nfunction findCircle(curve) {\n  var midPoint = getCubicBezierPoint(curve, 1 / 2),\n    m1 = [midPoint[0] / 2, midPoint[1] / 2],\n    m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],\n    center = getIntersection([\n      m1[0],\n      m1[1],\n      m1[0] + m1[1],\n      m1[1] - m1[0],\n      m2[0],\n      m2[1],\n      m2[0] + (m2[1] - midPoint[1]),\n      m2[1] - (m2[0] - midPoint[0]),\n    ]),\n    radius = center && getDistance([0, 0], center),\n    tolerance = Math.min(arcThreshold * error, (arcTolerance * radius) / 100);\n\n  if (\n    center &&\n    radius < 1e15 &&\n    [1 / 4, 3 / 4].every(function (point) {\n      return (\n        Math.abs(\n          getDistance(getCubicBezierPoint(curve, point), center) - radius\n        ) <= tolerance\n      );\n    })\n  )\n    return { center: center, radius: radius };\n}\n\n/**\n * Checks if a curve fits the given circle.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\nfunction isArc(curve, circle) {\n  var tolerance = Math.min(\n    arcThreshold * error,\n    (arcTolerance * circle.radius) / 100\n  );\n\n  return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function (point) {\n    return (\n      Math.abs(\n        getDistance(getCubicBezierPoint(curve, point), circle.center) -\n          circle.radius\n      ) <= tolerance\n    );\n  });\n}\n\n/**\n * Checks if a previous curve fits the given circle.\n *\n * @param {Object} circle\n * @param {Array} curve\n * @return {Boolean}\n */\n\nfunction isArcPrev(curve, circle) {\n  return isArc(curve, {\n    center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],\n    radius: circle.radius,\n  });\n}\n\n/**\n * Finds angle of a curve fitting the given arc.\n\n * @param {Array} curve\n * @param {Object} relCircle\n * @return {Number} angle\n */\n\nfunction findArcAngle(curve, relCircle) {\n  var x1 = -relCircle.center[0],\n    y1 = -relCircle.center[1],\n    x2 = curve[4] - relCircle.center[0],\n    y2 = curve[5] - relCircle.center[1];\n\n  return Math.acos(\n    (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n  );\n}\n\n/**\n * Converts given path data to string.\n *\n * @param {Object} params\n * @param {Array} pathData\n * @return {String}\n */\n\nfunction data2Path(params, pathData) {\n  return pathData.reduce(function (pathString, item) {\n    var strData = '';\n    if (item.args) {\n      strData = cleanupOutData(roundData(item.args.slice()), params);\n    }\n    return pathString + item.command + strData;\n  }, '');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}