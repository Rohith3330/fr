{"ast":null,"code":"/**\n * @fileoverview A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments\n * @author Teddy Katz\n */\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\n/**\n * Compares the locations of two objects in a source file\n * @param {{line: number, column: number}} itemA The first object\n * @param {{line: number, column: number}} itemB The second object\n * @returns {number} A value less than 1 if itemA appears before itemB in the source file, greater than 1 if\n * itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.\n */\n\n\nfunction compareLocations(itemA, itemB) {\n  return itemA.line - itemB.line || itemA.column - itemB.column;\n}\n/**\n * Groups a set of directives into sub-arrays by their parent comment.\n * @param {Directive[]} directives Unused directives to be removed.\n * @returns {Directive[][]} Directives grouped by their parent comment.\n */\n\n\nfunction groupByParentComment(directives) {\n  const groups = new Map();\n\n  for (const directive of directives) {\n    const {\n      unprocessedDirective: {\n        parentComment\n      }\n    } = directive;\n\n    if (groups.has(parentComment)) {\n      groups.get(parentComment).push(directive);\n    } else {\n      groups.set(parentComment, [directive]);\n    }\n  }\n\n  return [...groups.values()];\n}\n/**\n * Creates removal details for a set of directives within the same comment.\n * @param {Directive[]} directives Unused directives to be removed.\n * @param {Token} commentToken The backing Comment token.\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\n */\n\n\nfunction createIndividualDirectivesRemoval(directives, commentToken) {\n  /*\n   * `commentToken.value` starts right after `//` or `/*`.\n   * All calculated offsets will be relative to this index.\n   */\n  const commentValueStart = commentToken.range[0] + \"//\".length; // Find where the list of rules starts. `\\S+` matches with the directive name (e.g. `eslint-disable-line`)\n\n  const listStartOffset = /^\\s*\\S+\\s+/u.exec(commentToken.value)[0].length;\n  /*\n   * Get the list text without any surrounding whitespace. In order to preserve the original\n   * formatting, we don't want to change that whitespace.\n   *\n   *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n   *                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   */\n\n  const listText = commentToken.value.slice(listStartOffset) // remove directive name and all whitespace before the list\n  .split(/\\s-{2,}\\s/u)[0] // remove `-- comment`, if it exists\n  .trimEnd(); // remove all whitespace after the list\n\n  /*\n   * We can assume that `listText` contains multiple elements.\n   * Otherwise, this function wouldn't be called - if there is\n   * only one rule in the list, then the whole comment must be removed.\n   */\n\n  return directives.map(directive => {\n    const {\n      ruleId\n    } = directive;\n    const regex = new RegExp(String.raw`(?:^|\\s*,\\s*)${escapeRegExp(ruleId)}(?:\\s*,\\s*|$)`, \"u\");\n    const match = regex.exec(listText);\n    const matchedText = match[0];\n    const matchStartOffset = listStartOffset + match.index;\n    const matchEndOffset = matchStartOffset + matchedText.length;\n    const firstIndexOfComma = matchedText.indexOf(\",\");\n    const lastIndexOfComma = matchedText.lastIndexOf(\",\");\n    let removalStartOffset, removalEndOffset;\n\n    if (firstIndexOfComma !== lastIndexOfComma) {\n      /*\n       * Since there are two commas, this must one of the elements in the middle of the list.\n       * Matched range starts where the previous rule name ends, and ends where the next rule name starts.\n       *\n       *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n       *                                    ^^^^^^^^^^^^^^\n       *\n       * We want to remove only the content between the two commas, and also one of the commas.\n       *\n       *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n       *                                     ^^^^^^^^^^^\n       */\n      removalStartOffset = matchStartOffset + firstIndexOfComma;\n      removalEndOffset = matchStartOffset + lastIndexOfComma;\n    } else {\n      /*\n       * This is either the first element or the last element.\n       *\n       * If this is the first element, matched range starts where the first rule name starts\n       * and ends where the second rule name starts. This is exactly the range we want\n       * to remove so that the second rule name will start where the first one was starting\n       * and thus preserve the original formatting.\n       *\n       *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n       *                            ^^^^^^^^^^^\n       *\n       * Similarly, if this is the last element, we've already matched the range we want to\n       * remove. The previous rule name will end where the last one was ending, relative\n       * to the content on the right side.\n       *\n       *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n       *                                               ^^^^^^^^^^^^^\n       */\n      removalStartOffset = matchStartOffset;\n      removalEndOffset = matchEndOffset;\n    }\n\n    return {\n      description: `'${ruleId}'`,\n      fix: {\n        range: [commentValueStart + removalStartOffset, commentValueStart + removalEndOffset],\n        text: \"\"\n      },\n      unprocessedDirective: directive.unprocessedDirective\n    };\n  });\n}\n/**\n * Creates a description of deleting an entire unused disable comment.\n * @param {Directive[]} directives Unused directives to be removed.\n * @param {Token} commentToken The backing Comment token.\n * @returns {{ description, fix, unprocessedDirective }} Details for later creation of an output Problem.\n */\n\n\nfunction createCommentRemoval(directives, commentToken) {\n  const {\n    range\n  } = commentToken;\n  const ruleIds = directives.filter(directive => directive.ruleId).map(directive => `'${directive.ruleId}'`);\n  return {\n    description: ruleIds.length <= 2 ? ruleIds.join(\" or \") : `${ruleIds.slice(0, ruleIds.length - 1).join(\", \")}, or ${ruleIds[ruleIds.length - 1]}`,\n    fix: {\n      range,\n      text: \" \"\n    },\n    unprocessedDirective: directives[0].unprocessedDirective\n  };\n}\n/**\n * Parses details from directives to create output Problems.\n * @param {Directive[]} allDirectives Unused directives to be removed.\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\n */\n\n\nfunction processUnusedDisableDirectives(allDirectives) {\n  const directiveGroups = groupByParentComment(allDirectives);\n  return directiveGroups.flatMap(directives => {\n    const {\n      parentComment\n    } = directives[0].unprocessedDirective;\n    const remainingRuleIds = new Set(parentComment.ruleIds);\n\n    for (const directive of directives) {\n      remainingRuleIds.delete(directive.ruleId);\n    }\n\n    return remainingRuleIds.size ? createIndividualDirectivesRemoval(directives, parentComment.commentToken) : [createCommentRemoval(directives, parentComment.commentToken)];\n  });\n}\n/**\n * This is the same as the exported function, except that it\n * doesn't handle disable-line and disable-next-line directives, and it always reports unused\n * disable directives.\n * @param {Object} options options for applying directives. This is the same as the options\n * for the exported function, except that `reportUnusedDisableDirectives` is not supported\n * (this function always reports unused disable directives).\n * @returns {{problems: Problem[], unusedDisableDirectives: Problem[]}} An object with a list\n * of problems (including suppressed ones) and unused eslint-disable directives\n */\n\n\nfunction applyDirectives(options) {\n  const problems = [];\n  const usedDisableDirectives = new Set();\n\n  for (const problem of options.problems) {\n    let disableDirectivesForProblem = [];\n    let nextDirectiveIndex = 0;\n\n    while (nextDirectiveIndex < options.directives.length && compareLocations(options.directives[nextDirectiveIndex], problem) <= 0) {\n      const directive = options.directives[nextDirectiveIndex++];\n\n      if (directive.ruleId === null || directive.ruleId === problem.ruleId) {\n        switch (directive.type) {\n          case \"disable\":\n            disableDirectivesForProblem.push(directive);\n            break;\n\n          case \"enable\":\n            disableDirectivesForProblem = [];\n            break;\n          // no default\n        }\n      }\n    }\n\n    if (disableDirectivesForProblem.length > 0) {\n      const suppressions = disableDirectivesForProblem.map(directive => ({\n        kind: \"directive\",\n        justification: directive.unprocessedDirective.justification\n      }));\n\n      if (problem.suppressions) {\n        problem.suppressions = problem.suppressions.concat(suppressions);\n      } else {\n        problem.suppressions = suppressions;\n        usedDisableDirectives.add(disableDirectivesForProblem[disableDirectivesForProblem.length - 1]);\n      }\n    }\n\n    problems.push(problem);\n  }\n\n  const unusedDisableDirectivesToReport = options.directives.filter(directive => directive.type === \"disable\" && !usedDisableDirectives.has(directive));\n  const processed = processUnusedDisableDirectives(unusedDisableDirectivesToReport);\n  const unusedDisableDirectives = processed.map(_ref => {\n    let {\n      description,\n      fix,\n      unprocessedDirective\n    } = _ref;\n    const {\n      parentComment,\n      type,\n      line,\n      column\n    } = unprocessedDirective;\n    return {\n      ruleId: null,\n      message: description ? `Unused eslint-disable directive (no problems were reported from ${description}).` : \"Unused eslint-disable directive (no problems were reported).\",\n      line: type === \"disable-next-line\" ? parentComment.commentToken.loc.start.line : line,\n      column: type === \"disable-next-line\" ? parentComment.commentToken.loc.start.column + 1 : column,\n      severity: options.reportUnusedDisableDirectives === \"warn\" ? 1 : 2,\n      nodeType: null,\n      ...(options.disableFixes ? {} : {\n        fix\n      })\n    };\n  });\n  return {\n    problems,\n    unusedDisableDirectives\n  };\n}\n/**\n * Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list\n * of reported problems, adds the suppression information to the problems.\n * @param {Object} options Information about directives and problems\n * @param {{\n *      type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\n *      ruleId: (string|null),\n *      line: number,\n *      column: number,\n *      justification: string\n * }} options.directives Directive comments found in the file, with one-based columns.\n * Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable\n * comment for two different rules is represented as two directives).\n * @param {{ruleId: (string|null), line: number, column: number}[]} options.problems\n * A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.\n * @param {\"off\" | \"warn\" | \"error\"} options.reportUnusedDisableDirectives If `\"warn\"` or `\"error\"`, adds additional problems for unused directives\n * @param {boolean} options.disableFixes If true, it doesn't make `fix` properties.\n * @returns {{ruleId: (string|null), line: number, column: number, suppressions?: {kind: string, justification: string}}[]}\n * An object with a list of reported problems, the suppressed of which contain the suppression information.\n */\n\n\nmodule.exports = _ref2 => {\n  let {\n    directives,\n    disableFixes,\n    problems,\n    reportUnusedDisableDirectives = \"off\"\n  } = _ref2;\n  const blockDirectives = directives.filter(directive => directive.type === \"disable\" || directive.type === \"enable\").map(directive => Object.assign({}, directive, {\n    unprocessedDirective: directive\n  })).sort(compareLocations);\n  const lineDirectives = directives.flatMap(directive => {\n    switch (directive.type) {\n      case \"disable\":\n      case \"enable\":\n        return [];\n\n      case \"disable-line\":\n        return [{\n          type: \"disable\",\n          line: directive.line,\n          column: 1,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }, {\n          type: \"enable\",\n          line: directive.line + 1,\n          column: 0,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }];\n\n      case \"disable-next-line\":\n        return [{\n          type: \"disable\",\n          line: directive.line + 1,\n          column: 1,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }, {\n          type: \"enable\",\n          line: directive.line + 2,\n          column: 0,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }];\n\n      default:\n        throw new TypeError(`Unrecognized directive type '${directive.type}'`);\n    }\n  }).sort(compareLocations);\n  const blockDirectivesResult = applyDirectives({\n    problems,\n    directives: blockDirectives,\n    disableFixes,\n    reportUnusedDisableDirectives\n  });\n  const lineDirectivesResult = applyDirectives({\n    problems: blockDirectivesResult.problems,\n    directives: lineDirectives,\n    disableFixes,\n    reportUnusedDisableDirectives\n  });\n  return reportUnusedDisableDirectives !== \"off\" ? lineDirectivesResult.problems.concat(blockDirectivesResult.unusedDisableDirectives).concat(lineDirectivesResult.unusedDisableDirectives).sort(compareLocations) : lineDirectivesResult.problems;\n};","map":{"version":3,"names":["escapeRegExp","require","compareLocations","itemA","itemB","line","column","groupByParentComment","directives","groups","Map","directive","unprocessedDirective","parentComment","has","get","push","set","values","createIndividualDirectivesRemoval","commentToken","commentValueStart","range","length","listStartOffset","exec","value","listText","slice","split","trimEnd","map","ruleId","regex","RegExp","String","raw","match","matchedText","matchStartOffset","index","matchEndOffset","firstIndexOfComma","indexOf","lastIndexOfComma","lastIndexOf","removalStartOffset","removalEndOffset","description","fix","text","createCommentRemoval","ruleIds","filter","join","processUnusedDisableDirectives","allDirectives","directiveGroups","flatMap","remainingRuleIds","Set","delete","size","applyDirectives","options","problems","usedDisableDirectives","problem","disableDirectivesForProblem","nextDirectiveIndex","type","suppressions","kind","justification","concat","add","unusedDisableDirectivesToReport","processed","unusedDisableDirectives","message","loc","start","severity","reportUnusedDisableDirectives","nodeType","disableFixes","module","exports","blockDirectives","Object","assign","sort","lineDirectives","TypeError","blockDirectivesResult","lineDirectivesResult"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/linter/apply-disable-directives.js"],"sourcesContent":["/**\n * @fileoverview A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments\n * @author Teddy Katz\n */\n\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\n\n/**\n * Compares the locations of two objects in a source file\n * @param {{line: number, column: number}} itemA The first object\n * @param {{line: number, column: number}} itemB The second object\n * @returns {number} A value less than 1 if itemA appears before itemB in the source file, greater than 1 if\n * itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.\n */\nfunction compareLocations(itemA, itemB) {\n    return itemA.line - itemB.line || itemA.column - itemB.column;\n}\n\n/**\n * Groups a set of directives into sub-arrays by their parent comment.\n * @param {Directive[]} directives Unused directives to be removed.\n * @returns {Directive[][]} Directives grouped by their parent comment.\n */\nfunction groupByParentComment(directives) {\n    const groups = new Map();\n\n    for (const directive of directives) {\n        const { unprocessedDirective: { parentComment } } = directive;\n\n        if (groups.has(parentComment)) {\n            groups.get(parentComment).push(directive);\n        } else {\n            groups.set(parentComment, [directive]);\n        }\n    }\n\n    return [...groups.values()];\n}\n\n/**\n * Creates removal details for a set of directives within the same comment.\n * @param {Directive[]} directives Unused directives to be removed.\n * @param {Token} commentToken The backing Comment token.\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\n */\nfunction createIndividualDirectivesRemoval(directives, commentToken) {\n\n    /*\n     * `commentToken.value` starts right after `//` or `/*`.\n     * All calculated offsets will be relative to this index.\n     */\n    const commentValueStart = commentToken.range[0] + \"//\".length;\n\n    // Find where the list of rules starts. `\\S+` matches with the directive name (e.g. `eslint-disable-line`)\n    const listStartOffset = /^\\s*\\S+\\s+/u.exec(commentToken.value)[0].length;\n\n    /*\n     * Get the list text without any surrounding whitespace. In order to preserve the original\n     * formatting, we don't want to change that whitespace.\n     *\n     *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n     *                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     */\n    const listText = commentToken.value\n        .slice(listStartOffset) // remove directive name and all whitespace before the list\n        .split(/\\s-{2,}\\s/u)[0] // remove `-- comment`, if it exists\n        .trimEnd(); // remove all whitespace after the list\n\n    /*\n     * We can assume that `listText` contains multiple elements.\n     * Otherwise, this function wouldn't be called - if there is\n     * only one rule in the list, then the whole comment must be removed.\n     */\n\n    return directives.map(directive => {\n        const { ruleId } = directive;\n\n        const regex = new RegExp(String.raw`(?:^|\\s*,\\s*)${escapeRegExp(ruleId)}(?:\\s*,\\s*|$)`, \"u\");\n        const match = regex.exec(listText);\n        const matchedText = match[0];\n        const matchStartOffset = listStartOffset + match.index;\n        const matchEndOffset = matchStartOffset + matchedText.length;\n\n        const firstIndexOfComma = matchedText.indexOf(\",\");\n        const lastIndexOfComma = matchedText.lastIndexOf(\",\");\n\n        let removalStartOffset, removalEndOffset;\n\n        if (firstIndexOfComma !== lastIndexOfComma) {\n\n            /*\n             * Since there are two commas, this must one of the elements in the middle of the list.\n             * Matched range starts where the previous rule name ends, and ends where the next rule name starts.\n             *\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n             *                                    ^^^^^^^^^^^^^^\n             *\n             * We want to remove only the content between the two commas, and also one of the commas.\n             *\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n             *                                     ^^^^^^^^^^^\n             */\n            removalStartOffset = matchStartOffset + firstIndexOfComma;\n            removalEndOffset = matchStartOffset + lastIndexOfComma;\n\n        } else {\n\n            /*\n             * This is either the first element or the last element.\n             *\n             * If this is the first element, matched range starts where the first rule name starts\n             * and ends where the second rule name starts. This is exactly the range we want\n             * to remove so that the second rule name will start where the first one was starting\n             * and thus preserve the original formatting.\n             *\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n             *                            ^^^^^^^^^^^\n             *\n             * Similarly, if this is the last element, we've already matched the range we want to\n             * remove. The previous rule name will end where the last one was ending, relative\n             * to the content on the right side.\n             *\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\n             *                                               ^^^^^^^^^^^^^\n             */\n            removalStartOffset = matchStartOffset;\n            removalEndOffset = matchEndOffset;\n        }\n\n        return {\n            description: `'${ruleId}'`,\n            fix: {\n                range: [\n                    commentValueStart + removalStartOffset,\n                    commentValueStart + removalEndOffset\n                ],\n                text: \"\"\n            },\n            unprocessedDirective: directive.unprocessedDirective\n        };\n    });\n}\n\n/**\n * Creates a description of deleting an entire unused disable comment.\n * @param {Directive[]} directives Unused directives to be removed.\n * @param {Token} commentToken The backing Comment token.\n * @returns {{ description, fix, unprocessedDirective }} Details for later creation of an output Problem.\n */\nfunction createCommentRemoval(directives, commentToken) {\n    const { range } = commentToken;\n    const ruleIds = directives.filter(directive => directive.ruleId).map(directive => `'${directive.ruleId}'`);\n\n    return {\n        description: ruleIds.length <= 2\n            ? ruleIds.join(\" or \")\n            : `${ruleIds.slice(0, ruleIds.length - 1).join(\", \")}, or ${ruleIds[ruleIds.length - 1]}`,\n        fix: {\n            range,\n            text: \" \"\n        },\n        unprocessedDirective: directives[0].unprocessedDirective\n    };\n}\n\n/**\n * Parses details from directives to create output Problems.\n * @param {Directive[]} allDirectives Unused directives to be removed.\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\n */\nfunction processUnusedDisableDirectives(allDirectives) {\n    const directiveGroups = groupByParentComment(allDirectives);\n\n    return directiveGroups.flatMap(\n        directives => {\n            const { parentComment } = directives[0].unprocessedDirective;\n            const remainingRuleIds = new Set(parentComment.ruleIds);\n\n            for (const directive of directives) {\n                remainingRuleIds.delete(directive.ruleId);\n            }\n\n            return remainingRuleIds.size\n                ? createIndividualDirectivesRemoval(directives, parentComment.commentToken)\n                : [createCommentRemoval(directives, parentComment.commentToken)];\n        }\n    );\n}\n\n/**\n * This is the same as the exported function, except that it\n * doesn't handle disable-line and disable-next-line directives, and it always reports unused\n * disable directives.\n * @param {Object} options options for applying directives. This is the same as the options\n * for the exported function, except that `reportUnusedDisableDirectives` is not supported\n * (this function always reports unused disable directives).\n * @returns {{problems: Problem[], unusedDisableDirectives: Problem[]}} An object with a list\n * of problems (including suppressed ones) and unused eslint-disable directives\n */\nfunction applyDirectives(options) {\n    const problems = [];\n    const usedDisableDirectives = new Set();\n\n    for (const problem of options.problems) {\n        let disableDirectivesForProblem = [];\n        let nextDirectiveIndex = 0;\n\n        while (\n            nextDirectiveIndex < options.directives.length &&\n            compareLocations(options.directives[nextDirectiveIndex], problem) <= 0\n        ) {\n            const directive = options.directives[nextDirectiveIndex++];\n\n            if (directive.ruleId === null || directive.ruleId === problem.ruleId) {\n                switch (directive.type) {\n                    case \"disable\":\n                        disableDirectivesForProblem.push(directive);\n                        break;\n\n                    case \"enable\":\n                        disableDirectivesForProblem = [];\n                        break;\n\n                    // no default\n                }\n            }\n        }\n\n        if (disableDirectivesForProblem.length > 0) {\n            const suppressions = disableDirectivesForProblem.map(directive => ({\n                kind: \"directive\",\n                justification: directive.unprocessedDirective.justification\n            }));\n\n            if (problem.suppressions) {\n                problem.suppressions = problem.suppressions.concat(suppressions);\n            } else {\n                problem.suppressions = suppressions;\n                usedDisableDirectives.add(disableDirectivesForProblem[disableDirectivesForProblem.length - 1]);\n            }\n        }\n\n        problems.push(problem);\n    }\n\n    const unusedDisableDirectivesToReport = options.directives\n        .filter(directive => directive.type === \"disable\" && !usedDisableDirectives.has(directive));\n\n    const processed = processUnusedDisableDirectives(unusedDisableDirectivesToReport);\n\n    const unusedDisableDirectives = processed\n        .map(({ description, fix, unprocessedDirective }) => {\n            const { parentComment, type, line, column } = unprocessedDirective;\n\n            return {\n                ruleId: null,\n                message: description\n                    ? `Unused eslint-disable directive (no problems were reported from ${description}).`\n                    : \"Unused eslint-disable directive (no problems were reported).\",\n                line: type === \"disable-next-line\" ? parentComment.commentToken.loc.start.line : line,\n                column: type === \"disable-next-line\" ? parentComment.commentToken.loc.start.column + 1 : column,\n                severity: options.reportUnusedDisableDirectives === \"warn\" ? 1 : 2,\n                nodeType: null,\n                ...options.disableFixes ? {} : { fix }\n            };\n        });\n\n    return { problems, unusedDisableDirectives };\n}\n\n/**\n * Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list\n * of reported problems, adds the suppression information to the problems.\n * @param {Object} options Information about directives and problems\n * @param {{\n *      type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\n *      ruleId: (string|null),\n *      line: number,\n *      column: number,\n *      justification: string\n * }} options.directives Directive comments found in the file, with one-based columns.\n * Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable\n * comment for two different rules is represented as two directives).\n * @param {{ruleId: (string|null), line: number, column: number}[]} options.problems\n * A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.\n * @param {\"off\" | \"warn\" | \"error\"} options.reportUnusedDisableDirectives If `\"warn\"` or `\"error\"`, adds additional problems for unused directives\n * @param {boolean} options.disableFixes If true, it doesn't make `fix` properties.\n * @returns {{ruleId: (string|null), line: number, column: number, suppressions?: {kind: string, justification: string}}[]}\n * An object with a list of reported problems, the suppressed of which contain the suppression information.\n */\nmodule.exports = ({ directives, disableFixes, problems, reportUnusedDisableDirectives = \"off\" }) => {\n    const blockDirectives = directives\n        .filter(directive => directive.type === \"disable\" || directive.type === \"enable\")\n        .map(directive => Object.assign({}, directive, { unprocessedDirective: directive }))\n        .sort(compareLocations);\n\n    const lineDirectives = directives.flatMap(directive => {\n        switch (directive.type) {\n            case \"disable\":\n            case \"enable\":\n                return [];\n\n            case \"disable-line\":\n                return [\n                    { type: \"disable\", line: directive.line, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },\n                    { type: \"enable\", line: directive.line + 1, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }\n                ];\n\n            case \"disable-next-line\":\n                return [\n                    { type: \"disable\", line: directive.line + 1, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },\n                    { type: \"enable\", line: directive.line + 2, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }\n                ];\n\n            default:\n                throw new TypeError(`Unrecognized directive type '${directive.type}'`);\n        }\n    }).sort(compareLocations);\n\n    const blockDirectivesResult = applyDirectives({\n        problems,\n        directives: blockDirectives,\n        disableFixes,\n        reportUnusedDisableDirectives\n    });\n    const lineDirectivesResult = applyDirectives({\n        problems: blockDirectivesResult.problems,\n        directives: lineDirectives,\n        disableFixes,\n        reportUnusedDisableDirectives\n    });\n\n    return reportUnusedDisableDirectives !== \"off\"\n        ? lineDirectivesResult.problems\n            .concat(blockDirectivesResult.unusedDisableDirectives)\n            .concat(lineDirectivesResult.unusedDisableDirectives)\n            .sort(compareLocations)\n        : lineDirectivesResult.problems;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}