{"ast":null,"code":"import fs from \"fs\";\nimport { join } from \"path\";\nimport { URL, fileURLToPath } from \"url\";\nimport { minify } from \"terser\"; // eslint-disable-line import/no-extraneous-dependencies\n\nconst HELPERS_FOLDER = new URL(\"../src/helpers\", import.meta.url);\nconst IGNORED_FILES = new Set([\"package.json\"]);\nexport default async function generateHelpers() {\n  let output = `/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'yarn gulp generate-runtime-helpers'\n */\n\nimport template from \"@babel/template\";\n\nfunction helper(minVersion: string, source: string) {\n  return Object.freeze({\n    minVersion,\n    ast: () => template.program.ast(source, { preserveComments: true }),\n  })\n}\n\nexport default Object.freeze({\n`;\n\n  for (const file of (await fs.promises.readdir(HELPERS_FOLDER)).sort()) {\n    if (IGNORED_FILES.has(file)) continue;\n    if (file.startsWith(\".\")) continue; // ignore e.g. vim swap files\n\n    const [helperName] = file.split(\".\");\n    const filePath = join(fileURLToPath(HELPERS_FOLDER), file);\n\n    if (!file.endsWith(\".js\")) {\n      console.error(\"ignoring\", filePath);\n      continue;\n    }\n\n    const fileContents = await fs.promises.readFile(filePath, \"utf8\");\n    const minVersionMatch = fileContents.match(/^\\s*\\/\\*\\s*@minVersion\\s+(?<minVersion>\\S+)\\s*\\*\\/\\s*$/m);\n\n    if (!minVersionMatch) {\n      throw new Error(`@minVersion number missing in ${filePath}`);\n    }\n\n    const {\n      minVersion\n    } = minVersionMatch.groups;\n    const source = await minify(fileContents, {\n      mangle: false,\n      // The _typeof helper has a custom directive that we must keep\n      compress: {\n        directives: false\n      }\n    });\n    output += `\\\n  ${JSON.stringify(helperName)}: helper(\n    ${JSON.stringify(minVersion)},\n    ${JSON.stringify(source.code)},\n  ),\n`;\n  }\n\n  output += \"});\";\n  return output;\n}","map":{"version":3,"names":["fs","join","URL","fileURLToPath","minify","HELPERS_FOLDER","import","meta","url","IGNORED_FILES","Set","generateHelpers","output","file","promises","readdir","sort","has","startsWith","helperName","split","filePath","endsWith","console","error","fileContents","readFile","minVersionMatch","match","Error","minVersion","groups","source","mangle","compress","directives","JSON","stringify","code"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/helpers/scripts/generate-helpers.js"],"sourcesContent":["import fs from \"fs\";\nimport { join } from \"path\";\nimport { URL, fileURLToPath } from \"url\";\nimport { minify } from \"terser\"; // eslint-disable-line import/no-extraneous-dependencies\n\nconst HELPERS_FOLDER = new URL(\"../src/helpers\", import.meta.url);\nconst IGNORED_FILES = new Set([\"package.json\"]);\n\nexport default async function generateHelpers() {\n  let output = `/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'yarn gulp generate-runtime-helpers'\n */\n\nimport template from \"@babel/template\";\n\nfunction helper(minVersion: string, source: string) {\n  return Object.freeze({\n    minVersion,\n    ast: () => template.program.ast(source, { preserveComments: true }),\n  })\n}\n\nexport default Object.freeze({\n`;\n\n  for (const file of (await fs.promises.readdir(HELPERS_FOLDER)).sort()) {\n    if (IGNORED_FILES.has(file)) continue;\n    if (file.startsWith(\".\")) continue; // ignore e.g. vim swap files\n\n    const [helperName] = file.split(\".\");\n\n    const filePath = join(fileURLToPath(HELPERS_FOLDER), file);\n    if (!file.endsWith(\".js\")) {\n      console.error(\"ignoring\", filePath);\n      continue;\n    }\n\n    const fileContents = await fs.promises.readFile(filePath, \"utf8\");\n    const minVersionMatch = fileContents.match(\n      /^\\s*\\/\\*\\s*@minVersion\\s+(?<minVersion>\\S+)\\s*\\*\\/\\s*$/m\n    );\n    if (!minVersionMatch) {\n      throw new Error(`@minVersion number missing in ${filePath}`);\n    }\n    const { minVersion } = minVersionMatch.groups;\n\n    const source = await minify(fileContents, {\n      mangle: false,\n      // The _typeof helper has a custom directive that we must keep\n      compress: { directives: false },\n    });\n\n    output += `\\\n  ${JSON.stringify(helperName)}: helper(\n    ${JSON.stringify(minVersion)},\n    ${JSON.stringify(source.code)},\n  ),\n`;\n  }\n\n  output += \"});\";\n  return output;\n}\n"],"mappings":"AAAA,OAAOA,EAAP,MAAe,IAAf;AACA,SAASC,IAAT,QAAqB,MAArB;AACA,SAASC,GAAT,EAAcC,aAAd,QAAmC,KAAnC;AACA,SAASC,MAAT,QAAuB,QAAvB,C,CAAiC;;AAEjC,MAAMC,cAAc,GAAG,IAAIH,GAAJ,CAAQ,gBAAR,EAA0BI,MAAM,CAACC,IAAP,CAAYC,GAAtC,CAAvB;AACA,MAAMC,aAAa,GAAG,IAAIC,GAAJ,CAAQ,CAAC,cAAD,CAAR,CAAtB;AAEA,eAAe,eAAeC,eAAf,GAAiC;EAC9C,IAAIC,MAAM,GAAI;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAfE;;EAiBA,KAAK,MAAMC,IAAX,IAAmB,CAAC,MAAMb,EAAE,CAACc,QAAH,CAAYC,OAAZ,CAAoBV,cAApB,CAAP,EAA4CW,IAA5C,EAAnB,EAAuE;IACrE,IAAIP,aAAa,CAACQ,GAAd,CAAkBJ,IAAlB,CAAJ,EAA6B;IAC7B,IAAIA,IAAI,CAACK,UAAL,CAAgB,GAAhB,CAAJ,EAA0B,SAF2C,CAEjC;;IAEpC,MAAM,CAACC,UAAD,IAAeN,IAAI,CAACO,KAAL,CAAW,GAAX,CAArB;IAEA,MAAMC,QAAQ,GAAGpB,IAAI,CAACE,aAAa,CAACE,cAAD,CAAd,EAAgCQ,IAAhC,CAArB;;IACA,IAAI,CAACA,IAAI,CAACS,QAAL,CAAc,KAAd,CAAL,EAA2B;MACzBC,OAAO,CAACC,KAAR,CAAc,UAAd,EAA0BH,QAA1B;MACA;IACD;;IAED,MAAMI,YAAY,GAAG,MAAMzB,EAAE,CAACc,QAAH,CAAYY,QAAZ,CAAqBL,QAArB,EAA+B,MAA/B,CAA3B;IACA,MAAMM,eAAe,GAAGF,YAAY,CAACG,KAAb,CACtB,yDADsB,CAAxB;;IAGA,IAAI,CAACD,eAAL,EAAsB;MACpB,MAAM,IAAIE,KAAJ,CAAW,iCAAgCR,QAAS,EAApD,CAAN;IACD;;IACD,MAAM;MAAES;IAAF,IAAiBH,eAAe,CAACI,MAAvC;IAEA,MAAMC,MAAM,GAAG,MAAM5B,MAAM,CAACqB,YAAD,EAAe;MACxCQ,MAAM,EAAE,KADgC;MAExC;MACAC,QAAQ,EAAE;QAAEC,UAAU,EAAE;MAAd;IAH8B,CAAf,CAA3B;IAMAvB,MAAM,IAAK;AACf,IAAIwB,IAAI,CAACC,SAAL,CAAelB,UAAf,CAA2B;AAC/B,MAAMiB,IAAI,CAACC,SAAL,CAAeP,UAAf,CAA2B;AACjC,MAAMM,IAAI,CAACC,SAAL,CAAeL,MAAM,CAACM,IAAtB,CAA4B;AAClC;AACA,CALI;EAMD;;EAED1B,MAAM,IAAI,KAAV;EACA,OAAOA,MAAP;AACD"},"metadata":{},"sourceType":"module"}