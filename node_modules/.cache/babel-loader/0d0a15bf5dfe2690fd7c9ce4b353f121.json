{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Rohith\\\\Pictures\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\n/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nexport var SearchSortedProgram = function SearchSortedProgram(batchSize, numInputs, numValues, side) {\n  _classCallCheck(this, SearchSortedProgram);\n  this.variableNames = ['sortedSequence', 'values'];\n  this.customUniforms = [{\n    name: 'numInputs',\n    type: 'int'\n  }];\n  this.outputShape = [batchSize, numValues];\n  var webGL2LoopHead = 'while (left < right) {';\n  // WebGL1 doesn't accept non constant loop conditions, so upper bound loop\n  // iterations.\n  var webGL1LoopHead = \"for (int i = 0; i < \".concat(Math.ceil(Math.log2(numInputs + 1)), \"; ++i) { if (left >= right) break;\");\n  var loopHead = env().getNumber('WEBGL_VERSION') === 2 ? webGL2LoopHead : webGL1LoopHead;\n  // left corresponds to lower bound and right to upper bound.\n  var boundComparator = side === 'left' ? '<' : '<=';\n  this.userCode = \"\\n       int findBound(int batch, float value) {\\n         int left = 0;\\n         int right = numInputs;\\n         int mid;\\n         \".concat(loopHead, \"\\n           mid = (left + right) / 2;\\n           if (getSortedSequence(batch, mid) \").concat(boundComparator, \" value) {\\n             left = mid + 1;\\n           } else {\\n             right = mid;\\n           }\\n         }\\n         return right;\\n       }\\n\\n       void main() {\\n         ivec2 coords = getOutputCoords();\\n         int batch = coords[0];\\n         int valueIndex = coords[1];\\n\\n         float value = getValues(batch, valueIndex);\\n\\n         setOutput(float(findBound(batch, value)));\\n       }\\n     \");\n};","map":null,"metadata":{},"sourceType":"module"}