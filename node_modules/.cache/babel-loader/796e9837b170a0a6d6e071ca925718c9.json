{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nvar Usefulness;\n\n(function (Usefulness) {\n  Usefulness[Usefulness[\"Always\"] = 0] = \"Always\";\n  Usefulness[\"Never\"] = \"will\";\n  Usefulness[\"Sometimes\"] = \"may\";\n})(Usefulness || (Usefulness = {}));\n\nexports.default = util.createRule({\n  name: 'no-base-to-string',\n  meta: {\n    docs: {\n      description: 'Require `.toString()` to only be called on objects which provide useful information when stringified',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    messages: {\n      baseToString: \"'{{name}}' {{certainty}} evaluate to '[object Object]' when stringified.\"\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoredTypeNames: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    type: 'suggestion'\n  },\n  defaultOptions: [{\n    ignoredTypeNames: ['RegExp']\n  }],\n\n  create(context, _ref) {\n    let [option] = _ref;\n\n    var _a;\n\n    const parserServices = util.getParserServices(context);\n    const typeChecker = parserServices.program.getTypeChecker();\n    const ignoredTypeNames = (_a = option.ignoredTypeNames) !== null && _a !== void 0 ? _a : [];\n\n    function checkExpression(node, type) {\n      if (node.type === utils_1.AST_NODE_TYPES.Literal) {\n        return;\n      }\n\n      const certainty = collectToStringCertainty(type !== null && type !== void 0 ? type : typeChecker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node)));\n\n      if (certainty === Usefulness.Always) {\n        return;\n      }\n\n      context.report({\n        data: {\n          certainty,\n          name: context.getSourceCode().getText(node)\n        },\n        messageId: 'baseToString',\n        node\n      });\n    }\n\n    function collectToStringCertainty(type) {\n      const toString = typeChecker.getPropertyOfType(type, 'toString');\n      const declarations = toString === null || toString === void 0 ? void 0 : toString.getDeclarations();\n\n      if (!toString || !declarations || declarations.length === 0) {\n        return Usefulness.Always;\n      } // Patch for old version TypeScript, the Boolean type definition missing toString()\n\n\n      if (type.flags & ts.TypeFlags.Boolean || type.flags & ts.TypeFlags.BooleanLiteral) {\n        return Usefulness.Always;\n      }\n\n      if (ignoredTypeNames.includes(util.getTypeName(typeChecker, type))) {\n        return Usefulness.Always;\n      }\n\n      if (declarations.every(_ref2 => {\n        let {\n          parent\n        } = _ref2;\n        return !ts.isInterfaceDeclaration(parent) || parent.name.text !== 'Object';\n      })) {\n        return Usefulness.Always;\n      }\n\n      if (type.isIntersection()) {\n        for (const subType of type.types) {\n          const subtypeUsefulness = collectToStringCertainty(subType);\n\n          if (subtypeUsefulness === Usefulness.Always) {\n            return Usefulness.Always;\n          }\n        }\n\n        return Usefulness.Never;\n      }\n\n      if (!type.isUnion()) {\n        return Usefulness.Never;\n      }\n\n      let allSubtypesUseful = true;\n      let someSubtypeUseful = false;\n\n      for (const subType of type.types) {\n        const subtypeUsefulness = collectToStringCertainty(subType);\n\n        if (subtypeUsefulness !== Usefulness.Always && allSubtypesUseful) {\n          allSubtypesUseful = false;\n        }\n\n        if (subtypeUsefulness !== Usefulness.Never && !someSubtypeUseful) {\n          someSubtypeUseful = true;\n        }\n      }\n\n      if (allSubtypesUseful && someSubtypeUseful) {\n        return Usefulness.Always;\n      }\n\n      if (someSubtypeUseful) {\n        return Usefulness.Sometimes;\n      }\n\n      return Usefulness.Never;\n    }\n\n    return {\n      'AssignmentExpression[operator = \"+=\"], BinaryExpression[operator = \"+\"]'(node) {\n        const leftType = typeChecker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node.left));\n        const rightType = typeChecker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node.right));\n\n        if (util.getTypeName(typeChecker, leftType) === 'string') {\n          checkExpression(node.right, rightType);\n        } else if (util.getTypeName(typeChecker, rightType) === 'string' && node.left.type !== utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n          checkExpression(node.left, leftType);\n        }\n      },\n\n      'CallExpression > MemberExpression.callee > Identifier[name = \"toString\"].property'(node) {\n        const memberExpr = node.parent;\n        checkExpression(memberExpr.object);\n      },\n\n      TemplateLiteral(node) {\n        if (node.parent && node.parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression) {\n          return;\n        }\n\n        for (const expression of node.expressions) {\n          checkExpression(expression);\n        }\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["Usefulness","exports","util","createRule","name","meta","docs","description","recommended","requiresTypeChecking","messages","baseToString","schema","type","properties","ignoredTypeNames","items","additionalProperties","defaultOptions","create","context","option","parserServices","getParserServices","typeChecker","program","getTypeChecker","_a","checkExpression","node","utils_1","Literal","certainty","collectToStringCertainty","getTypeAtLocation","esTreeNodeToTSNodeMap","get","Always","report","data","getSourceCode","getText","messageId","toString","getPropertyOfType","declarations","getDeclarations","length","flags","ts","TypeFlags","Boolean","BooleanLiteral","includes","getTypeName","every","parent","isInterfaceDeclaration","text","isIntersection","subType","types","subtypeUsefulness","Never","isUnion","allSubtypesUseful","someSubtypeUseful","Sometimes","leftType","left","rightType","right","PrivateIdentifier","memberExpr","object","TemplateLiteral","TaggedTemplateExpression","expression","expressions"],"sources":["../../src/rules/no-base-to-string.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}