{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.couldBeBaseType = couldBeBaseType;\nexports.getTypeAnnotation = getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.isGenericType = isGenericType;\n\nvar inferers = require(\"./inferers\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isArrayTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTSArrayType,\n  isTSTypeAnnotation,\n  isTSTypeReference,\n  isTupleTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction getTypeAnnotation() {\n  let type = this.getData(\"typeAnnotation\");\n\n  if (type != null) {\n    return type;\n  }\n\n  type = this._getTypeAnnotation() || anyTypeAnnotation();\n\n  if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {\n    type = type.typeAnnotation;\n  }\n\n  this.setData(\"typeAnnotation\", type);\n  return type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return anyTypeAnnotation();\n      }\n\n      return voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) != null && _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n\n  if (isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n\n  if (genericName === \"Array\") {\n    if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {\n      return true;\n    }\n  }\n\n  return isGenericTypeAnnotation(type) && isIdentifier(type.id, {\n    name: genericName\n  }) || isTSTypeReference(type) && isIdentifier(type.typeName, {\n    name: genericName\n  });\n}","map":{"version":3,"mappings":"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","names":["anyTypeAnnotation","isAnyTypeAnnotation","isArrayTypeAnnotation","isBooleanTypeAnnotation","isEmptyTypeAnnotation","isFlowBaseAnnotation","isGenericTypeAnnotation","isIdentifier","isMixedTypeAnnotation","isNumberTypeAnnotation","isStringTypeAnnotation","isTSArrayType","isTSTypeAnnotation","isTSTypeReference","isTupleTypeAnnotation","isTypeAnnotation","isUnionTypeAnnotation","isVoidTypeAnnotation","stringTypeAnnotation","voidTypeAnnotation","getTypeAnnotation","type","getData","_getTypeAnnotation","typeAnnotation","setData","typeAnnotationInferringNodes","WeakSet","node","key","parentPath","isVariableDeclarator","declar","declarParent","isForInStatement","isForOfStatement","has","add","inferer","inferers","call","_inferer","validParent","delete","isBaseType","baseName","soft","_isBaseType","Error","couldBeBaseType","name","type2","types","baseTypeStrictlyMatches","rightArg","left","right","isGenericType","genericName","id","typeName"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\path\\inference\\index.ts"],"sourcesContent":["import type NodePath from \"../index\";\nimport * as inferers from \"./inferers\";\nimport {\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isArrayTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTSArrayType,\n  isTSTypeAnnotation,\n  isTSTypeReference,\n  isTupleTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n/**\n * Infer the type of the current `NodePath`.\n */\n\nexport function getTypeAnnotation(this: NodePath): t.FlowType | t.TSType {\n  let type = this.getData(\"typeAnnotation\");\n  if (type != null) {\n    return type;\n  }\n  type = this._getTypeAnnotation() || anyTypeAnnotation();\n  if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {\n    type = type.typeAnnotation;\n  }\n  this.setData(\"typeAnnotation\", type);\n  return type;\n}\n\n// Used to avoid infinite recursion in cases like\n//   var b, c; if (0) { c = 1; b = c; } c = b;\n// It also works with indirect recursion.\nconst typeAnnotationInferringNodes = new WeakSet();\n\n/**\n * todo: split up this method\n */\n\nexport function _getTypeAnnotation(this: NodePath): any {\n  const node = this.node;\n\n  if (!node) {\n    // handle initializerless variables, add in checks for loop initializers too\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      // for (let NODE in bar) {}\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return stringTypeAnnotation();\n      }\n\n      // for (let NODE of bar) {}\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return anyTypeAnnotation();\n      }\n\n      return voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  // @ts-expect-error typeAnnotation may not index node\n  if (node.typeAnnotation) {\n    // @ts-expect-error typeAnnotation may not index node\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    // Bail out from type inference to avoid infinite loops\n    return;\n  }\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    let inferer =\n      // @ts-expect-error inferers do not cover all AST types\n      inferers[node.type];\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    // @ts-expect-error inferers do not cover all AST types\n    inferer = inferers[this.parentPath.type];\n    if (inferer?.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nexport function isBaseType(\n  this: NodePath,\n  baseName: string,\n  soft?: boolean,\n): boolean {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(\n  baseName: string,\n  type?: t.FlowType | t.TSType,\n  soft?: boolean,\n): boolean {\n  if (baseName === \"string\") {\n    return isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nexport function couldBeBaseType(this: NodePath, name: string): boolean {\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n\n  if (isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nexport function baseTypeStrictlyMatches(\n  this: NodePath,\n  rightArg: NodePath,\n): boolean {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n  return false;\n}\n\nexport function isGenericType(this: NodePath, genericName: string): boolean {\n  const type = this.getTypeAnnotation();\n  if (genericName === \"Array\") {\n    // T[]\n    if (\n      isTSArrayType(type) ||\n      isArrayTypeAnnotation(type) ||\n      isTupleTypeAnnotation(type)\n    ) {\n      return true;\n    }\n  }\n  return (\n    (isGenericTypeAnnotation(type) &&\n      isIdentifier(type.id, {\n        name: genericName,\n      })) ||\n    (isTSTypeReference(type) &&\n      isIdentifier(type.typeName, {\n        name: genericName,\n      }))\n  );\n}\n"]},"metadata":{},"sourceType":"script"}