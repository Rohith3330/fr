{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'restrict-plus-operands',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Require both operands of addition to have type `number` or `string`',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    messages: {\n      notNumbers: \"Operands of '+' operation must either be both strings or both numbers.\",\n      notStrings: \"Operands of '+' operation must either be both strings or both numbers. Consider using a template literal.\",\n      notBigInts: \"Operands of '+' operation must be both bigints.\",\n      notValidAnys: \"Operands of '+' operation with any is possible only with string, number, bigint or any\",\n      notValidTypes: \"Operands of '+' operation must either be one of string, number, bigint or any (if allowed by option)\"\n    },\n    schema: [{\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        checkCompoundAssignments: {\n          description: 'Whether to check compound assignments such as `+=`.',\n          type: 'boolean'\n        },\n        allowAny: {\n          description: 'Whether to allow `any` typed values.',\n          type: 'boolean'\n        }\n      }\n    }]\n  },\n  defaultOptions: [{\n    checkCompoundAssignments: false,\n    allowAny: false\n  }],\n\n  create(context, _ref) {\n    let [{\n      checkCompoundAssignments,\n      allowAny\n    }] = _ref;\n    const service = util.getParserServices(context);\n    const typeChecker = service.program.getTypeChecker();\n    /**\n     * Helper function to get base type of node\n     */\n\n    function getBaseTypeOfLiteralType(type) {\n      if (type.isNumberLiteral()) {\n        return 'number';\n      }\n\n      if (type.isStringLiteral() || util.isTypeFlagSet(type, ts.TypeFlags.TemplateLiteral)) {\n        return 'string';\n      } // is BigIntLiteral\n\n\n      if (type.flags & ts.TypeFlags.BigIntLiteral) {\n        return 'bigint';\n      }\n\n      if (type.isUnion()) {\n        const types = type.types.map(getBaseTypeOfLiteralType);\n        return types.every(value => value === types[0]) ? types[0] : 'invalid';\n      }\n\n      if (type.isIntersection()) {\n        const types = type.types.map(getBaseTypeOfLiteralType);\n\n        if (types.some(value => value === 'string')) {\n          return 'string';\n        }\n\n        if (types.some(value => value === 'number')) {\n          return 'number';\n        }\n\n        if (types.some(value => value === 'bigint')) {\n          return 'bigint';\n        }\n\n        return 'invalid';\n      }\n\n      const stringType = typeChecker.typeToString(type);\n\n      if (stringType === 'number' || stringType === 'string' || stringType === 'bigint' || stringType === 'any') {\n        return stringType;\n      }\n\n      return 'invalid';\n    }\n    /**\n     * Helper function to get base type of node\n     * @param node the node to be evaluated.\n     */\n\n\n    function getNodeType(node) {\n      const tsNode = service.esTreeNodeToTSNodeMap.get(node);\n      const type = util.getConstrainedTypeAtLocation(typeChecker, tsNode);\n      return getBaseTypeOfLiteralType(type);\n    }\n\n    function checkPlusOperands(node) {\n      const leftType = getNodeType(node.left);\n      const rightType = getNodeType(node.right);\n\n      if (leftType === rightType) {\n        if (leftType === 'invalid') {\n          context.report({\n            node,\n            messageId: 'notValidTypes'\n          });\n        }\n\n        if (!allowAny && leftType === 'any') {\n          context.report({\n            node,\n            messageId: 'notValidAnys'\n          });\n        }\n\n        return;\n      }\n\n      if (leftType === 'any' || rightType === 'any') {\n        if (!allowAny || leftType === 'invalid' || rightType === 'invalid') {\n          context.report({\n            node,\n            messageId: 'notValidAnys'\n          });\n        }\n\n        return;\n      }\n\n      if (leftType === 'string' || rightType === 'string') {\n        return context.report({\n          node,\n          messageId: 'notStrings'\n        });\n      }\n\n      if (leftType === 'bigint' || rightType === 'bigint') {\n        return context.report({\n          node,\n          messageId: 'notBigInts'\n        });\n      }\n\n      if (leftType === 'number' || rightType === 'number') {\n        return context.report({\n          node,\n          messageId: 'notNumbers'\n        });\n      }\n    }\n\n    return Object.assign({\n      \"BinaryExpression[operator='+']\": checkPlusOperands\n    }, checkCompoundAssignments && {\n      \"AssignmentExpression[operator='+=']\"(node) {\n        checkPlusOperands(node);\n      }\n\n    });\n  }\n\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AAEA;;AAeAA,kBAAeC,IAAI,CAACC,UAAL,CAAqC;EAClDC,IAAI,EAAE,wBAD4C;EAElDC,IAAI,EAAE;IACJC,IAAI,EAAE,SADF;IAEJC,IAAI,EAAE;MACJC,WAAW,EACT,qEAFE;MAGJC,WAAW,EAAE,OAHT;MAIJC,oBAAoB,EAAE;IAJlB,CAFF;IAQJC,QAAQ,EAAE;MACRC,UAAU,EACR,wEAFM;MAGRC,UAAU,EACR,2GAJM;MAKRC,UAAU,EAAE,iDALJ;MAMRC,YAAY,EACV,wFAPM;MAQRC,aAAa,EACX;IATM,CARN;IAmBJC,MAAM,EAAE,CACN;MACEX,IAAI,EAAE,QADR;MAEEY,oBAAoB,EAAE,KAFxB;MAGEC,UAAU,EAAE;QACVC,wBAAwB,EAAE;UACxBZ,WAAW,EAAE,qDADW;UAExBF,IAAI,EAAE;QAFkB,CADhB;QAKVe,QAAQ,EAAE;UACRb,WAAW,EAAE,sCADL;UAERF,IAAI,EAAE;QAFE;MALA;IAHd,CADM;EAnBJ,CAF4C;EAsClDgB,cAAc,EAAE,CACd;IACEF,wBAAwB,EAAE,KAD5B;IAEEC,QAAQ,EAAE;EAFZ,CADc,CAtCkC;;EA4ClDE,MAAM,CAACC,OAAD,QAAkD;IAAA,IAAxC,CAAC;MAAEJ,wBAAF;MAA4BC;IAA5B,CAAD,CAAwC;IACtD,MAAMI,OAAO,GAAGvB,IAAI,CAACwB,iBAAL,CAAuBF,OAAvB,CAAhB;IACA,MAAMG,WAAW,GAAGF,OAAO,CAACG,OAAR,CAAgBC,cAAhB,EAApB;IAIA;;;;IAGA,SAASC,wBAAT,CAAkCxB,IAAlC,EAA+C;MAC7C,IAAIA,IAAI,CAACyB,eAAL,EAAJ,EAA4B;QAC1B,OAAO,QAAP;MACD;;MACD,IACEzB,IAAI,CAAC0B,eAAL,MACA9B,IAAI,CAAC+B,aAAL,CAAmB3B,IAAnB,EAAyB4B,EAAE,CAACC,SAAH,CAAaC,eAAtC,CAFF,EAGE;QACA,OAAO,QAAP;MACD,CAT4C,CAU7C;;;MACA,IAAI9B,IAAI,CAAC+B,KAAL,GAAaH,EAAE,CAACC,SAAH,CAAaG,aAA9B,EAA6C;QAC3C,OAAO,QAAP;MACD;;MACD,IAAIhC,IAAI,CAACiC,OAAL,EAAJ,EAAoB;QAClB,MAAMC,KAAK,GAAGlC,IAAI,CAACkC,KAAL,CAAWC,GAAX,CAAeX,wBAAf,CAAd;QAEA,OAAOU,KAAK,CAACE,KAAN,CAAYC,KAAK,IAAIA,KAAK,KAAKH,KAAK,CAAC,CAAD,CAApC,IAA2CA,KAAK,CAAC,CAAD,CAAhD,GAAsD,SAA7D;MACD;;MAED,IAAIlC,IAAI,CAACsC,cAAL,EAAJ,EAA2B;QACzB,MAAMJ,KAAK,GAAGlC,IAAI,CAACkC,KAAL,CAAWC,GAAX,CAAeX,wBAAf,CAAd;;QAEA,IAAIU,KAAK,CAACK,IAAN,CAAWF,KAAK,IAAIA,KAAK,KAAK,QAA9B,CAAJ,EAA6C;UAC3C,OAAO,QAAP;QACD;;QAED,IAAIH,KAAK,CAACK,IAAN,CAAWF,KAAK,IAAIA,KAAK,KAAK,QAA9B,CAAJ,EAA6C;UAC3C,OAAO,QAAP;QACD;;QAED,IAAIH,KAAK,CAACK,IAAN,CAAWF,KAAK,IAAIA,KAAK,KAAK,QAA9B,CAAJ,EAA6C;UAC3C,OAAO,QAAP;QACD;;QAED,OAAO,SAAP;MACD;;MAED,MAAMG,UAAU,GAAGnB,WAAW,CAACoB,YAAZ,CAAyBzC,IAAzB,CAAnB;;MAEA,IACEwC,UAAU,KAAK,QAAf,IACAA,UAAU,KAAK,QADf,IAEAA,UAAU,KAAK,QAFf,IAGAA,UAAU,KAAK,KAJjB,EAKE;QACA,OAAOA,UAAP;MACD;;MACD,OAAO,SAAP;IACD;IAED;;;;;;IAIA,SAASE,WAAT,CACEC,IADF,EACwD;MAEtD,MAAMC,MAAM,GAAGzB,OAAO,CAAC0B,qBAAR,CAA8BC,GAA9B,CAAkCH,IAAlC,CAAf;MACA,MAAM3C,IAAI,GAAGJ,IAAI,CAACmD,4BAAL,CAAkC1B,WAAlC,EAA+CuB,MAA/C,CAAb;MAEA,OAAOpB,wBAAwB,CAACxB,IAAD,CAA/B;IACD;;IAED,SAASgD,iBAAT,CACEL,IADF,EACiE;MAE/D,MAAMM,QAAQ,GAAGP,WAAW,CAACC,IAAI,CAACO,IAAN,CAA5B;MACA,MAAMC,SAAS,GAAGT,WAAW,CAACC,IAAI,CAACS,KAAN,CAA7B;;MAEA,IAAIH,QAAQ,KAAKE,SAAjB,EAA4B;QAC1B,IAAIF,QAAQ,KAAK,SAAjB,EAA4B;UAC1B/B,OAAO,CAACmC,MAAR,CAAe;YACbV,IADa;YAEbW,SAAS,EAAE;UAFE,CAAf;QAID;;QAED,IAAI,CAACvC,QAAD,IAAakC,QAAQ,KAAK,KAA9B,EAAqC;UACnC/B,OAAO,CAACmC,MAAR,CAAe;YACbV,IADa;YAEbW,SAAS,EAAE;UAFE,CAAf;QAID;;QAED;MACD;;MAED,IAAIL,QAAQ,KAAK,KAAb,IAAsBE,SAAS,KAAK,KAAxC,EAA+C;QAC7C,IAAI,CAACpC,QAAD,IAAakC,QAAQ,KAAK,SAA1B,IAAuCE,SAAS,KAAK,SAAzD,EAAoE;UAClEjC,OAAO,CAACmC,MAAR,CAAe;YACbV,IADa;YAEbW,SAAS,EAAE;UAFE,CAAf;QAID;;QAED;MACD;;MAED,IAAIL,QAAQ,KAAK,QAAb,IAAyBE,SAAS,KAAK,QAA3C,EAAqD;QACnD,OAAOjC,OAAO,CAACmC,MAAR,CAAe;UACpBV,IADoB;UAEpBW,SAAS,EAAE;QAFS,CAAf,CAAP;MAID;;MAED,IAAIL,QAAQ,KAAK,QAAb,IAAyBE,SAAS,KAAK,QAA3C,EAAqD;QACnD,OAAOjC,OAAO,CAACmC,MAAR,CAAe;UACpBV,IADoB;UAEpBW,SAAS,EAAE;QAFS,CAAf,CAAP;MAID;;MAED,IAAIL,QAAQ,KAAK,QAAb,IAAyBE,SAAS,KAAK,QAA3C,EAAqD;QACnD,OAAOjC,OAAO,CAACmC,MAAR,CAAe;UACpBV,IADoB;UAEpBW,SAAS,EAAE;QAFS,CAAf,CAAP;MAID;IACF;;IAED;MACE,kCAAkCN;IADpC,GAEMlC,wBAAwB,IAAI;MAC9B,sCAAsC6B,IAAtC,EAA0C;QACxCK,iBAAiB,CAACL,IAAD,CAAjB;MACD;;IAH6B,CAFlC;EAQD;;AAtLiD,CAArC,CAAf","names":["exports","util","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","messages","notNumbers","notStrings","notBigInts","notValidAnys","notValidTypes","schema","additionalProperties","properties","checkCompoundAssignments","allowAny","defaultOptions","create","context","service","getParserServices","typeChecker","program","getTypeChecker","getBaseTypeOfLiteralType","isNumberLiteral","isStringLiteral","isTypeFlagSet","ts","TypeFlags","TemplateLiteral","flags","BigIntLiteral","isUnion","types","map","every","value","isIntersection","some","stringType","typeToString","getNodeType","node","tsNode","esTreeNodeToTSNodeMap","get","getConstrainedTypeAtLocation","checkPlusOperands","leftType","left","rightType","right","report","messageId"],"sources":["../../src/rules/restrict-plus-operands.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}