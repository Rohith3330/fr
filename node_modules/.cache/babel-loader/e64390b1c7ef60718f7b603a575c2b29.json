{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('css-tree').Rule} CsstreeRule\n * @typedef {import('./types').Specificity} Specificity\n * @typedef {import('./types').Stylesheet} Stylesheet\n * @typedef {import('./types').StylesheetRule} StylesheetRule\n * @typedef {import('./types').StylesheetDeclaration} StylesheetDeclaration\n * @typedef {import('./types').ComputedStyles} ComputedStyles\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').XastChild} XastChild\n */\n\nconst stable = require('stable');\n\nconst csstree = require('css-tree'); // @ts-ignore not defined in @types/csso\n\n\nconst specificity = require('csso/lib/restructure/prepare/specificity');\n\nconst {\n  visit,\n  matches\n} = require('./xast.js');\n\nconst {\n  attrsGroups,\n  inheritableAttrs,\n  presentationNonInheritableGroupAttrs\n} = require('../plugins/_collections.js'); // @ts-ignore not defined in @types/csstree\n\n\nconst csstreeWalkSkip = csstree.walk.skip;\n/**\n * @type {(ruleNode: CsstreeRule, dynamic: boolean) => StylesheetRule}\n */\n\nconst parseRule = (ruleNode, dynamic) => {\n  let selectors;\n  let selectorsSpecificity;\n  /**\n   * @type {Array<StylesheetDeclaration>}\n   */\n\n  const declarations = [];\n  csstree.walk(ruleNode, cssNode => {\n    if (cssNode.type === 'SelectorList') {\n      // compute specificity from original node to consider pseudo classes\n      selectorsSpecificity = specificity(cssNode);\n      const newSelectorsNode = csstree.clone(cssNode);\n      csstree.walk(newSelectorsNode, (pseudoClassNode, item, list) => {\n        if (pseudoClassNode.type === 'PseudoClassSelector') {\n          dynamic = true;\n          list.remove(item);\n        }\n      });\n      selectors = csstree.generate(newSelectorsNode);\n      return csstreeWalkSkip;\n    }\n\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true\n      });\n      return csstreeWalkSkip;\n    }\n  });\n\n  if (selectors == null || selectorsSpecificity == null) {\n    throw Error('assert');\n  }\n\n  return {\n    dynamic,\n    selectors,\n    specificity: selectorsSpecificity,\n    declarations\n  };\n};\n/**\n * @type {(css: string, dynamic: boolean) => Array<StylesheetRule>}\n */\n\n\nconst parseStylesheet = (css, dynamic) => {\n  /**\n   * @type {Array<StylesheetRule>}\n   */\n  const rules = [];\n  const ast = csstree.parse(css, {\n    parseValue: false,\n    parseAtrulePrelude: false\n  });\n  csstree.walk(ast, cssNode => {\n    if (cssNode.type === 'Rule') {\n      rules.push(parseRule(cssNode, dynamic || false));\n      return csstreeWalkSkip;\n    }\n\n    if (cssNode.type === 'Atrule') {\n      if (cssNode.name === 'keyframes') {\n        return csstreeWalkSkip;\n      }\n\n      csstree.walk(cssNode, ruleNode => {\n        if (ruleNode.type === 'Rule') {\n          rules.push(parseRule(ruleNode, dynamic || true));\n          return csstreeWalkSkip;\n        }\n      });\n      return csstreeWalkSkip;\n    }\n  });\n  return rules;\n};\n/**\n * @type {(css: string) => Array<StylesheetDeclaration>}\n */\n\n\nconst parseStyleDeclarations = css => {\n  /**\n   * @type {Array<StylesheetDeclaration>}\n   */\n  const declarations = [];\n  const ast = csstree.parse(css, {\n    context: 'declarationList',\n    parseValue: false\n  });\n  csstree.walk(ast, cssNode => {\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true\n      });\n    }\n  });\n  return declarations;\n};\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\n\n\nconst computeOwnStyle = (stylesheet, node) => {\n  /**\n   * @type {ComputedStyles}\n   */\n  const computedStyle = {};\n  const importantStyles = new Map(); // collect attributes\n\n  for (const [name, value] of Object.entries(node.attributes)) {\n    if (attrsGroups.presentation.includes(name)) {\n      computedStyle[name] = {\n        type: 'static',\n        inherited: false,\n        value\n      };\n      importantStyles.set(name, false);\n    }\n  } // collect matching rules\n\n\n  for (const {\n    selectors,\n    declarations,\n    dynamic\n  } of stylesheet.rules) {\n    if (matches(node, selectors)) {\n      for (const {\n        name,\n        value,\n        important\n      } of declarations) {\n        const computed = computedStyle[name];\n\n        if (computed && computed.type === 'dynamic') {\n          continue;\n        }\n\n        if (dynamic) {\n          computedStyle[name] = {\n            type: 'dynamic',\n            inherited: false\n          };\n          continue;\n        }\n\n        if (computed == null || important === true || importantStyles.get(name) === false) {\n          computedStyle[name] = {\n            type: 'static',\n            inherited: false,\n            value\n          };\n          importantStyles.set(name, important);\n        }\n      }\n    }\n  } // collect inline styles\n\n\n  const styleDeclarations = node.attributes.style == null ? [] : parseStyleDeclarations(node.attributes.style);\n\n  for (const {\n    name,\n    value,\n    important\n  } of styleDeclarations) {\n    const computed = computedStyle[name];\n\n    if (computed && computed.type === 'dynamic') {\n      continue;\n    }\n\n    if (computed == null || important === true || importantStyles.get(name) === false) {\n      computedStyle[name] = {\n        type: 'static',\n        inherited: false,\n        value\n      };\n      importantStyles.set(name, important);\n    }\n  }\n\n  return computedStyle;\n};\n/**\n * Compares two selector specificities.\n * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211\n *\n * @type {(a: Specificity, b: Specificity) => number}\n */\n\n\nconst compareSpecificity = (a, b) => {\n  for (var i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n\n  return 0;\n};\n/**\n * @type {(root: XastRoot) => Stylesheet}\n */\n\n\nconst collectStylesheet = root => {\n  /**\n   * @type {Array<StylesheetRule>}\n   */\n  const rules = [];\n  /**\n   * @type {Map<XastElement, XastParent>}\n   */\n\n  const parents = new Map();\n  visit(root, {\n    element: {\n      enter: (node, parentNode) => {\n        // store parents\n        parents.set(node, parentNode); // find and parse all styles\n\n        if (node.name === 'style') {\n          const dynamic = node.attributes.media != null && node.attributes.media !== 'all';\n\n          if (node.attributes.type == null || node.attributes.type === '' || node.attributes.type === 'text/css') {\n            const children = node.children;\n\n            for (const child of children) {\n              if (child.type === 'text' || child.type === 'cdata') {\n                rules.push(...parseStylesheet(child.value, dynamic));\n              }\n            }\n          }\n        }\n      }\n    }\n  }); // sort by selectors specificity\n\n  stable.inplace(rules, (a, b) => compareSpecificity(a.specificity, b.specificity));\n  return {\n    rules,\n    parents\n  };\n};\n\nexports.collectStylesheet = collectStylesheet;\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\n\nconst computeStyle = (stylesheet, node) => {\n  const {\n    parents\n  } = stylesheet; // collect inherited styles\n\n  const computedStyles = computeOwnStyle(stylesheet, node);\n  let parent = parents.get(node);\n\n  while (parent != null && parent.type !== 'root') {\n    const inheritedStyles = computeOwnStyle(stylesheet, parent);\n\n    for (const [name, computed] of Object.entries(inheritedStyles)) {\n      if (computedStyles[name] == null && // ignore not inheritable styles\n      inheritableAttrs.includes(name) === true && presentationNonInheritableGroupAttrs.includes(name) === false) {\n        computedStyles[name] = { ...computed,\n          inherited: true\n        };\n      }\n    }\n\n    parent = parents.get(parent);\n  }\n\n  return computedStyles;\n};\n\nexports.computeStyle = computeStyle;","map":{"version":3,"names":["stable","require","csstree","specificity","visit","matches","attrsGroups","inheritableAttrs","presentationNonInheritableGroupAttrs","csstreeWalkSkip","walk","skip","parseRule","ruleNode","dynamic","selectors","selectorsSpecificity","declarations","cssNode","type","newSelectorsNode","clone","pseudoClassNode","item","list","remove","generate","push","name","property","value","important","Error","parseStylesheet","css","rules","ast","parse","parseValue","parseAtrulePrelude","parseStyleDeclarations","context","computeOwnStyle","stylesheet","node","computedStyle","importantStyles","Map","Object","entries","attributes","presentation","includes","inherited","set","computed","get","styleDeclarations","style","compareSpecificity","a","b","i","collectStylesheet","root","parents","element","enter","parentNode","media","children","child","inplace","exports","computeStyle","computedStyles","parent","inheritedStyles"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/svgo/lib/style.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('css-tree').Rule} CsstreeRule\n * @typedef {import('./types').Specificity} Specificity\n * @typedef {import('./types').Stylesheet} Stylesheet\n * @typedef {import('./types').StylesheetRule} StylesheetRule\n * @typedef {import('./types').StylesheetDeclaration} StylesheetDeclaration\n * @typedef {import('./types').ComputedStyles} ComputedStyles\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').XastChild} XastChild\n */\n\nconst stable = require('stable');\nconst csstree = require('css-tree');\n// @ts-ignore not defined in @types/csso\nconst specificity = require('csso/lib/restructure/prepare/specificity');\nconst { visit, matches } = require('./xast.js');\nconst {\n  attrsGroups,\n  inheritableAttrs,\n  presentationNonInheritableGroupAttrs,\n} = require('../plugins/_collections.js');\n\n// @ts-ignore not defined in @types/csstree\nconst csstreeWalkSkip = csstree.walk.skip;\n\n/**\n * @type {(ruleNode: CsstreeRule, dynamic: boolean) => StylesheetRule}\n */\nconst parseRule = (ruleNode, dynamic) => {\n  let selectors;\n  let selectorsSpecificity;\n  /**\n   * @type {Array<StylesheetDeclaration>}\n   */\n  const declarations = [];\n  csstree.walk(ruleNode, (cssNode) => {\n    if (cssNode.type === 'SelectorList') {\n      // compute specificity from original node to consider pseudo classes\n      selectorsSpecificity = specificity(cssNode);\n      const newSelectorsNode = csstree.clone(cssNode);\n      csstree.walk(newSelectorsNode, (pseudoClassNode, item, list) => {\n        if (pseudoClassNode.type === 'PseudoClassSelector') {\n          dynamic = true;\n          list.remove(item);\n        }\n      });\n      selectors = csstree.generate(newSelectorsNode);\n      return csstreeWalkSkip;\n    }\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true,\n      });\n      return csstreeWalkSkip;\n    }\n  });\n  if (selectors == null || selectorsSpecificity == null) {\n    throw Error('assert');\n  }\n  return {\n    dynamic,\n    selectors,\n    specificity: selectorsSpecificity,\n    declarations,\n  };\n};\n\n/**\n * @type {(css: string, dynamic: boolean) => Array<StylesheetRule>}\n */\nconst parseStylesheet = (css, dynamic) => {\n  /**\n   * @type {Array<StylesheetRule>}\n   */\n  const rules = [];\n  const ast = csstree.parse(css, {\n    parseValue: false,\n    parseAtrulePrelude: false,\n  });\n  csstree.walk(ast, (cssNode) => {\n    if (cssNode.type === 'Rule') {\n      rules.push(parseRule(cssNode, dynamic || false));\n      return csstreeWalkSkip;\n    }\n    if (cssNode.type === 'Atrule') {\n      if (cssNode.name === 'keyframes') {\n        return csstreeWalkSkip;\n      }\n      csstree.walk(cssNode, (ruleNode) => {\n        if (ruleNode.type === 'Rule') {\n          rules.push(parseRule(ruleNode, dynamic || true));\n          return csstreeWalkSkip;\n        }\n      });\n      return csstreeWalkSkip;\n    }\n  });\n  return rules;\n};\n\n/**\n * @type {(css: string) => Array<StylesheetDeclaration>}\n */\nconst parseStyleDeclarations = (css) => {\n  /**\n   * @type {Array<StylesheetDeclaration>}\n   */\n  const declarations = [];\n  const ast = csstree.parse(css, {\n    context: 'declarationList',\n    parseValue: false,\n  });\n  csstree.walk(ast, (cssNode) => {\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true,\n      });\n    }\n  });\n  return declarations;\n};\n\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\nconst computeOwnStyle = (stylesheet, node) => {\n  /**\n   * @type {ComputedStyles}\n   */\n  const computedStyle = {};\n  const importantStyles = new Map();\n\n  // collect attributes\n  for (const [name, value] of Object.entries(node.attributes)) {\n    if (attrsGroups.presentation.includes(name)) {\n      computedStyle[name] = { type: 'static', inherited: false, value };\n      importantStyles.set(name, false);\n    }\n  }\n\n  // collect matching rules\n  for (const { selectors, declarations, dynamic } of stylesheet.rules) {\n    if (matches(node, selectors)) {\n      for (const { name, value, important } of declarations) {\n        const computed = computedStyle[name];\n        if (computed && computed.type === 'dynamic') {\n          continue;\n        }\n        if (dynamic) {\n          computedStyle[name] = { type: 'dynamic', inherited: false };\n          continue;\n        }\n        if (\n          computed == null ||\n          important === true ||\n          importantStyles.get(name) === false\n        ) {\n          computedStyle[name] = { type: 'static', inherited: false, value };\n          importantStyles.set(name, important);\n        }\n      }\n    }\n  }\n\n  // collect inline styles\n  const styleDeclarations =\n    node.attributes.style == null\n      ? []\n      : parseStyleDeclarations(node.attributes.style);\n  for (const { name, value, important } of styleDeclarations) {\n    const computed = computedStyle[name];\n    if (computed && computed.type === 'dynamic') {\n      continue;\n    }\n    if (\n      computed == null ||\n      important === true ||\n      importantStyles.get(name) === false\n    ) {\n      computedStyle[name] = { type: 'static', inherited: false, value };\n      importantStyles.set(name, important);\n    }\n  }\n\n  return computedStyle;\n};\n\n/**\n * Compares two selector specificities.\n * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211\n *\n * @type {(a: Specificity, b: Specificity) => number}\n */\nconst compareSpecificity = (a, b) => {\n  for (var i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n\n  return 0;\n};\n\n/**\n * @type {(root: XastRoot) => Stylesheet}\n */\nconst collectStylesheet = (root) => {\n  /**\n   * @type {Array<StylesheetRule>}\n   */\n  const rules = [];\n  /**\n   * @type {Map<XastElement, XastParent>}\n   */\n  const parents = new Map();\n  visit(root, {\n    element: {\n      enter: (node, parentNode) => {\n        // store parents\n        parents.set(node, parentNode);\n        // find and parse all styles\n        if (node.name === 'style') {\n          const dynamic =\n            node.attributes.media != null && node.attributes.media !== 'all';\n          if (\n            node.attributes.type == null ||\n            node.attributes.type === '' ||\n            node.attributes.type === 'text/css'\n          ) {\n            const children = node.children;\n            for (const child of children) {\n              if (child.type === 'text' || child.type === 'cdata') {\n                rules.push(...parseStylesheet(child.value, dynamic));\n              }\n            }\n          }\n        }\n      },\n    },\n  });\n  // sort by selectors specificity\n  stable.inplace(rules, (a, b) =>\n    compareSpecificity(a.specificity, b.specificity)\n  );\n  return { rules, parents };\n};\nexports.collectStylesheet = collectStylesheet;\n\n/**\n * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles}\n */\nconst computeStyle = (stylesheet, node) => {\n  const { parents } = stylesheet;\n  // collect inherited styles\n  const computedStyles = computeOwnStyle(stylesheet, node);\n  let parent = parents.get(node);\n  while (parent != null && parent.type !== 'root') {\n    const inheritedStyles = computeOwnStyle(stylesheet, parent);\n    for (const [name, computed] of Object.entries(inheritedStyles)) {\n      if (\n        computedStyles[name] == null &&\n        // ignore not inheritable styles\n        inheritableAttrs.includes(name) === true &&\n        presentationNonInheritableGroupAttrs.includes(name) === false\n      ) {\n        computedStyles[name] = { ...computed, inherited: true };\n      }\n    }\n    parent = parents.get(parent);\n  }\n  return computedStyles;\n};\nexports.computeStyle = computeStyle;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}