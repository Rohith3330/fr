{"ast":null,"code":"var hpack = require('../hpack');\n\nvar utils = hpack.utils;\nvar huffman = hpack.huffman.encode;\nvar assert = utils.assert;\n\nvar WBuf = require('wbuf');\n\nfunction Encoder() {\n  this.buffer = new WBuf();\n  this.word = 0;\n  this.bitOffset = 0;\n}\n\nmodule.exports = Encoder;\n\nEncoder.create = function create() {\n  return new Encoder();\n};\n\nEncoder.prototype.render = function render() {\n  return this.buffer.render();\n};\n\nEncoder.prototype.encodeBit = function encodeBit(bit) {\n  var octet;\n  this.word <<= 1;\n  this.word |= bit;\n  this.bitOffset++;\n\n  if (this.bitOffset === 8) {\n    this.buffer.writeUInt8(this.word);\n    this.word = 0;\n    this.bitOffset = 0;\n  }\n};\n\nEncoder.prototype.encodeBits = function encodeBits(bits, len) {\n  var left = bits;\n  var leftLen = len;\n\n  while (leftLen > 0) {\n    var avail = Math.min(leftLen, 8 - this.bitOffset);\n    var toWrite = left >>> leftLen - avail;\n\n    if (avail === 8) {\n      this.buffer.writeUInt8(toWrite);\n    } else {\n      this.word <<= avail;\n      this.word |= toWrite;\n      this.bitOffset += avail;\n\n      if (this.bitOffset === 8) {\n        this.buffer.writeUInt8(this.word);\n        this.word = 0;\n        this.bitOffset = 0;\n      }\n    }\n\n    leftLen -= avail;\n    left &= (1 << leftLen) - 1;\n  }\n}; // Just for testing\n\n\nEncoder.prototype.skipBits = function skipBits(num) {\n  this.bitOffset += num;\n  this.buffer.skip(this.bitOffset >> 3);\n  this.bitOffset &= 0x7;\n};\n\nEncoder.prototype.encodeInt = function encodeInt(num) {\n  var prefix = 8 - this.bitOffset; // We are going to end up octet-aligned\n\n  this.bitOffset = 0;\n  var max = (1 << prefix) - 1; // Fast case - int fits into the prefix\n\n  if (num < max) {\n    this.buffer.writeUInt8(this.word << prefix | num);\n    return octet;\n  }\n\n  var left = num - max;\n  this.buffer.writeUInt8(this.word << prefix | max);\n\n  do {\n    var octet = left & 0x7f;\n    left >>= 7;\n    if (left !== 0) octet |= 0x80;\n    this.buffer.writeUInt8(octet);\n  } while (left !== 0);\n};\n\nEncoder.prototype.encodeStr = function encodeStr(value, isHuffman) {\n  this.encodeBit(isHuffman ? 1 : 0);\n\n  if (!isHuffman) {\n    this.buffer.reserve(value.length + 1);\n    this.encodeInt(value.length);\n\n    for (var i = 0; i < value.length; i++) this.buffer.writeUInt8(value[i]);\n\n    return;\n  }\n\n  var codes = [];\n  var len = 0;\n  var pad = 0;\n\n  for (var i = 0; i < value.length; i++) {\n    var code = huffman[value[i]];\n    codes.push(code);\n    len += code[0];\n  }\n\n  if (len % 8 !== 0) pad = 8 - len % 8;\n  len += pad;\n  this.buffer.reserve(len / 8 + 1);\n  this.encodeInt(len / 8);\n\n  for (var i = 0; i < codes.length; i++) {\n    var code = codes[i];\n    this.encodeBits(code[1], code[0]);\n  } // Append padding\n\n\n  this.encodeBits(0xff >>> 8 - pad, pad);\n};","map":{"version":3,"names":["hpack","require","utils","huffman","encode","assert","WBuf","Encoder","buffer","word","bitOffset","module","exports","create","prototype","render","encodeBit","bit","octet","writeUInt8","encodeBits","bits","len","left","leftLen","avail","Math","min","toWrite","skipBits","num","skip","encodeInt","prefix","max","encodeStr","value","isHuffman","reserve","length","i","codes","pad","code","push"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/hpack.js/lib/hpack/encoder.js"],"sourcesContent":["var hpack = require('../hpack');\nvar utils = hpack.utils;\nvar huffman = hpack.huffman.encode;\nvar assert = utils.assert;\n\nvar WBuf = require('wbuf');\n\nfunction Encoder() {\n  this.buffer = new WBuf();\n  this.word = 0;\n  this.bitOffset = 0;\n}\nmodule.exports = Encoder;\n\nEncoder.create = function create() {\n  return new Encoder();\n};\n\nEncoder.prototype.render = function render() {\n  return this.buffer.render();\n};\n\nEncoder.prototype.encodeBit = function encodeBit(bit) {\n  var octet;\n\n  this.word <<= 1;\n  this.word |= bit;\n  this.bitOffset++;\n\n  if (this.bitOffset === 8) {\n    this.buffer.writeUInt8(this.word);\n    this.word = 0;\n    this.bitOffset = 0;\n  }\n};\n\nEncoder.prototype.encodeBits = function encodeBits(bits, len) {\n  var left = bits;\n  var leftLen = len;\n\n  while (leftLen > 0) {\n    var avail = Math.min(leftLen, 8 - this.bitOffset);\n    var toWrite = left >>> (leftLen - avail);\n\n    if (avail === 8) {\n      this.buffer.writeUInt8(toWrite);\n    } else {\n      this.word <<= avail;\n      this.word |= toWrite;\n      this.bitOffset += avail;\n      if (this.bitOffset === 8) {\n        this.buffer.writeUInt8(this.word);\n        this.word = 0;\n        this.bitOffset = 0;\n      }\n    }\n\n    leftLen -= avail;\n    left &= (1 << leftLen) - 1;\n  }\n};\n\n// Just for testing\nEncoder.prototype.skipBits = function skipBits(num) {\n  this.bitOffset += num;\n  this.buffer.skip(this.bitOffset >> 3);\n  this.bitOffset &= 0x7;\n};\n\nEncoder.prototype.encodeInt = function encodeInt(num) {\n  var prefix = 8 - this.bitOffset;\n\n  // We are going to end up octet-aligned\n  this.bitOffset = 0;\n\n  var max = (1 << prefix) - 1;\n\n  // Fast case - int fits into the prefix\n  if (num < max) {\n    this.buffer.writeUInt8((this.word << prefix) | num);\n    return octet;\n  }\n\n  var left = num - max;\n  this.buffer.writeUInt8((this.word << prefix) | max);\n  do {\n    var octet = left & 0x7f;\n    left >>= 7;\n    if (left !== 0)\n      octet |= 0x80;\n\n    this.buffer.writeUInt8(octet);\n  } while (left !== 0);\n};\n\nEncoder.prototype.encodeStr = function encodeStr(value, isHuffman) {\n  this.encodeBit(isHuffman ? 1 : 0);\n\n  if (!isHuffman) {\n    this.buffer.reserve(value.length + 1);\n    this.encodeInt(value.length);\n    for (var i = 0; i < value.length; i++)\n      this.buffer.writeUInt8(value[i]);\n    return;\n  }\n\n  var codes = [];\n  var len = 0;\n  var pad = 0;\n\n  for (var i = 0; i < value.length; i++) {\n    var code = huffman[value[i]];\n    codes.push(code);\n    len += code[0];\n  }\n  if (len % 8 !== 0)\n    pad = 8 - (len % 8);\n  len += pad;\n\n  this.buffer.reserve((len / 8) + 1);\n  this.encodeInt(len / 8);\n  for (var i = 0; i < codes.length; i++) {\n    var code = codes[i];\n    this.encodeBits(code[1], code[0]);\n  }\n\n  // Append padding\n  this.encodeBits(0xff >>> (8 - pad), pad);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}