{"ast":null,"code":"/* eslint-env mocha */\n\n/* eslint no-template-curly-in-string: 0 */\nimport assert from 'assert';\nimport { extractProp, changePlugins, fallbackToBabylon, describeIfNotBabylon, setParserName } from '../helper';\nimport getPropValue from '../../src/getPropValue';\ndescribe('getPropValue', () => {\n  beforeEach(() => {\n    setParserName('babel');\n  });\n  it('should export a function', () => {\n    const expected = 'function';\n    const actual = typeof getPropValue;\n    assert.equal(actual, expected);\n  });\n  it('should return undefined when not provided with a JSXAttribute', () => {\n    const expected = undefined;\n    const actual = getPropValue(1);\n    assert.equal(actual, expected);\n  });\n  it('should not throw error when trying to get value from unknown node type', () => {\n    const prop = {\n      type: 'JSXAttribute',\n      value: {\n        type: 'JSXExpressionContainer'\n      }\n    };\n    let counter = 0; // eslint-disable-next-line no-console\n\n    const errorOrig = console.error; // eslint-disable-next-line no-console\n\n    console.error = () => {\n      counter += 1;\n    };\n\n    let value;\n    assert.doesNotThrow(() => {\n      value = getPropValue(prop);\n    }, Error);\n    assert.equal(null, value);\n    assert.equal(counter, 1); // eslint-disable-next-line no-console\n\n    console.error = errorOrig;\n  });\n  describe('Null', () => {\n    it('should return true when no value is given', () => {\n      const prop = extractProp('<div foo />');\n      const expected = true;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Literal', () => {\n    it('should return correct string if value is a string', () => {\n      const prop = extractProp('<div foo=\"bar\" />');\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return correct string if value is a string expression', () => {\n      const prop = extractProp('<div foo={\"bar\"} />');\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return correct integer if value is a integer expression', () => {\n      const prop = extractProp('<div foo={1} />');\n      const expected = 1;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should convert \"true\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"true\" />');\n      const expected = true;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should convert \"false\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"false\" />');\n      const expected = false;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('JSXElement', () => {\n    it('should return correct representation of JSX element as a string', () => {\n      const prop = extractProp('<div foo={<bar />} />');\n      const expected = '<bar />';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return correct representation of JSX element with children as a string', () => {\n      const prop = extractProp('<div foo={<bar><baz />foo</bar>} />');\n      const expected = '<bar><baz />foo</bar>';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  (fallbackToBabylon ? describe.skip : describe)('JSXFragment', () => {\n    it('should return correct representation of JSX fragment as a string', () => {\n      const prop = extractProp('<div foo={<></>} />');\n      const expected = '<></>';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return correct representation of JSX fragment with children as a string', () => {\n      const prop = extractProp('<div foo={<><div />abc</>} />');\n      const expected = '<><div />abc</>';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Identifier', () => {\n    it('should return string representation of variable identifier', () => {\n      const prop = extractProp('<div foo={bar} />');\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return undefined when identifier is literally `undefined`', () => {\n      const prop = extractProp('<div foo={undefined} />');\n      const expected = undefined;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return String object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={String} />');\n      const expected = String;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return Array object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Array} />');\n      const expected = Array;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return Date object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Date} />');\n      const expected = Date;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return Infinity object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Infinity} />');\n      const expected = Infinity;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return Math object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Math} />');\n      const expected = Math;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return Number object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Number} />');\n      const expected = Number;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return Object object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Object} />');\n      const expected = Object;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Template literal', () => {\n    it('should return template literal with vars wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={`bar ${baz}`} />');\n      const expected = 'bar {baz}';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string \"undefined\" for expressions that evaluate to undefined', () => {\n      const prop = extractProp('<div foo={`bar ${undefined}`} />');\n      const expected = 'bar undefined';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return template literal with expression type wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={`bar ${baz()}`} />');\n      const expected = 'bar {CallExpression}';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should ignore non-expressions in the template literal', () => {\n      const prop = extractProp('<div foo={`bar ${<baz />}`} />');\n      const expected = 'bar ';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Tagged Template literal', () => {\n    it('should return template literal with vars wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={noop`bar ${baz}`} />');\n      const expected = 'bar {baz}';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string \"undefined\" for expressions that evaluate to undefined', () => {\n      const prop = extractProp('<div foo={noop`bar ${undefined}`} />');\n      const expected = 'bar undefined';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return template literal with expression type wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={noop`bar ${baz()}`} />');\n      const expected = 'bar {CallExpression}';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should ignore non-expressions in the template literal', () => {\n      const prop = extractProp('<div foo={noop`bar ${<baz />}`} />');\n      const expected = 'bar ';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Arrow function expression', () => {\n    it('should return a function', () => {\n      const prop = extractProp('<div foo={ () => { return \"bar\"; }} />');\n      const expected = 'function';\n      const actual = getPropValue(prop);\n      assert.equal(expected, typeof actual); // For code coverage ¯\\_(ツ)_/¯\n\n      actual();\n    });\n    it('should handle ArrowFunctionExpression as conditional consequent', () => {\n      const prop = extractProp('<div foo={ (true) ? () => null : () => ({})} />');\n      const expected = 'function';\n      const actual = getPropValue(prop);\n      assert.equal(expected, typeof actual); // For code coverage ¯\\_(ツ)_/¯\n\n      actual();\n    });\n  });\n  describe('Function expression', () => {\n    it('should return a function', () => {\n      const prop = extractProp('<div foo={ function() { return \"bar\"; } } />');\n      const expected = 'function';\n      const actual = getPropValue(prop);\n      assert.equal(expected, typeof actual); // For code coverage ¯\\_(ツ)_/¯\n\n      actual();\n    });\n  });\n  describe('Logical expression', () => {\n    it('should correctly infer result of && logical expression based on derived values', () => {\n      const prop = extractProp('<div foo={bar && baz} />');\n      const expected = 'baz';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return undefined when evaluating `undefined && undefined` ', () => {\n      const prop = extractProp('<div foo={undefined && undefined} />');\n      const expected = undefined;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should correctly infer result of || logical expression based on derived values', () => {\n      const prop = extractProp('<div foo={bar || baz} />');\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should correctly infer result of || logical expression based on derived values', () => {\n      const prop = extractProp('<div foo={undefined || baz} />');\n      const expected = 'baz';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return undefined when evaluating `undefined || undefined` ', () => {\n      const prop = extractProp('<div foo={undefined || undefined} />');\n      const expected = undefined;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should correctly infer result of ?? logical expression based on derived values', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={bar ?? baz} />');\n        const expected = 'bar';\n        const actual = getPropValue(prop);\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n    it('should correctly infer result of ?? logical expression based on derived values', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={undefined ?? baz} />');\n        const expected = 'baz';\n        const actual = getPropValue(prop);\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n    it('should return undefined when evaluating `undefined ?? undefined` ', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={undefined ?? undefined} />');\n        const expected = undefined;\n        const actual = getPropValue(prop);\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n    it('should return undefined when evaluating `null ?? undefined` ', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={null ?? undefined} />');\n        const expected = undefined;\n        const actual = getPropValue(prop);\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n    it('should return undefined when evaluating `undefined ?? null` ', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={undefined ?? null} />');\n        const expected = null;\n        const actual = getPropValue(prop);\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n    it('should return null when evaluating `null ?? null` ', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={null ?? null} />');\n        const expected = null;\n        const actual = getPropValue(prop);\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n  });\n  describe('Member expression', () => {\n    it('should return string representation of form `object.property`', () => {\n      const prop = extractProp('<div foo={bar.baz} />');\n      const expected = 'bar.baz';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate to a correct representation of member expression with a nullable member', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={bar?.baz} />');\n        const expected = 'bar?.baz';\n        const actual = getPropValue(prop);\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n    it('should evaluate to a correct representation of optional call expression', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={bar.baz?.(quux)} />');\n        const expected = 'bar.baz?.(quux)';\n        const actual = getPropValue(prop);\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n  });\n  describe('Call expression', () => {\n    it('should return string representation of callee', () => {\n      const prop = extractProp('<div foo={bar()} />');\n      const expected = 'bar()';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of callee', () => {\n      const prop = extractProp('<div foo={bar.call()} />');\n      const expected = 'bar.call()';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Unary expression', () => {\n    it('should correctly evaluate an expression that prefixes with -', () => {\n      const prop = extractProp('<div foo={-bar} />'); // -\"bar\" => NaN\n\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that prefixes with -', () => {\n      const prop = extractProp('<div foo={-42} />');\n      const expected = -42;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that prefixes with +', () => {\n      const prop = extractProp('<div foo={+bar} />'); // +\"bar\" => NaN\n\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that prefixes with +', () => {\n      const prop = extractProp('<div foo={+42} />');\n      const expected = 42;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that prefixes with !', () => {\n      const prop = extractProp('<div foo={!bar} />');\n      const expected = false; // !\"bar\" === false\n\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that prefixes with ~', () => {\n      const prop = extractProp('<div foo={~bar} />');\n      const expected = -1; // ~\"bar\" === -1\n\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return true when evaluating `delete foo`', () => {\n      const prop = extractProp('<div foo={delete x} />');\n      const expected = true;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return undefined when evaluating `void foo`', () => {\n      const prop = extractProp('<div foo={void x} />');\n      const expected = undefined;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    }); // TODO: We should fix this to check to see if we can evaluate it.\n\n    it('should return undefined when evaluating `typeof foo`', () => {\n      const prop = extractProp('<div foo={typeof x} />');\n      const expected = undefined;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Update expression', () => {\n    it('should correctly evaluate an expression that prefixes with ++', () => {\n      const prop = extractProp('<div foo={++bar} />'); // ++\"bar\" => NaN\n\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that prefixes with --', () => {\n      const prop = extractProp('<div foo={--bar} />');\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that suffixes with ++', () => {\n      const prop = extractProp('<div foo={bar++} />'); // \"bar\"++ => NaN\n\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate an expression that suffixes with --', () => {\n      const prop = extractProp('<div foo={bar--} />');\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n      assert.equal(actual, expected);\n    });\n  });\n  describe('This expression', () => {\n    it('should return string value `this`', () => {\n      const prop = extractProp('<div foo={this} />');\n      const expected = 'this';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Conditional expression', () => {\n    it('should evaluate the conditional based on the derived values correctly', () => {\n      const prop = extractProp('<div foo={bar ? baz : bam} />');\n      const expected = 'baz';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the conditional based on the derived values correctly', () => {\n      const prop = extractProp('<div foo={undefined ? baz : bam} />');\n      const expected = 'bam';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the conditional based on the derived values correctly', () => {\n      const prop = extractProp('<div foo={(1 > 2) ? baz : bam} />');\n      const expected = 'bam';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Binary expression', () => {\n    it('should evaluate the `==` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 == \"1\"} />');\n      const falseProp = extractProp('<div foo={1 == bar} />');\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n    it('should evaluate the `!=` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 != \"2\"} />');\n      const falseProp = extractProp('<div foo={1 != \"1\"} />');\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n    it('should evaluate the `===` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 === 1} />');\n      const falseProp = extractProp('<div foo={1 === \"1\"} />');\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n    it('should evaluate the `!==` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 !== \"1\"} />');\n      const falseProp = extractProp('<div foo={1 !== 1} />');\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n    it('should evaluate the `<` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 < 2} />');\n      const falseProp = extractProp('<div foo={1 < 0} />');\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n    it('should evaluate the `>` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 > 0} />');\n      const falseProp = extractProp('<div foo={1 > 2} />');\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n    it('should evaluate the `<=` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 <= 1} />');\n      const falseProp = extractProp('<div foo={1 <= 0} />');\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n    it('should evaluate the `>=` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 >= 1} />');\n      const falseProp = extractProp('<div foo={1 >= 2} />');\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n    it('should evaluate the `<<` operator correctly', () => {\n      const prop = extractProp('<div foo={1 << 2} />');\n      const expected = 4;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the `>>` operator correctly', () => {\n      const prop = extractProp('<div foo={1 >> 2} />');\n      const expected = 0;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the `>>>` operator correctly', () => {\n      const prop = extractProp('<div foo={2 >>> 1} />');\n      const expected = 1;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the `+` operator correctly', () => {\n      const prop = extractProp('<div foo={1 + 1} />');\n      const expected = 2;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the `-` operator correctly', () => {\n      const prop = extractProp('<div foo={1 - 1} />');\n      const expected = 0;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the `*` operator correctly', () => {\n      const prop = extractProp('<div foo={10 * 10} />');\n      const expected = 100;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the `/` operator correctly', () => {\n      const prop = extractProp('<div foo={10 / 2} />');\n      const expected = 5;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the `%` operator correctly', () => {\n      const prop = extractProp('<div foo={10 % 3} />');\n      const expected = 1;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the `|` operator correctly', () => {\n      const prop = extractProp('<div foo={10 | 1} />');\n      const expected = 11;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the `^` operator correctly', () => {\n      const prop = extractProp('<div foo={10 ^ 1} />');\n      const expected = 11;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the `&` operator correctly', () => {\n      const prop = extractProp('<div foo={10 & 1} />');\n      const expected = 0;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the `in` operator correctly', () => {\n      const prop = extractProp('<div foo={foo in bar} />');\n      const expected = false;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the `instanceof` operator correctly', () => {\n      const prop = extractProp('<div foo={{} instanceof Object} />');\n      const expected = true;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should evaluate the `instanceof` operator when right side is not a function', () => {\n      const prop = extractProp('<div foo={\"bar\" instanceof Baz} />');\n      const expected = false;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describe('Object expression', () => {\n    it('should evaluate to a correct representation of the object in props', () => {\n      const prop = extractProp('<div foo={ { bar: \"baz\" } } />');\n      const expected = {\n        bar: 'baz'\n      };\n      const actual = getPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n    it('should evaluate to a correct representation of the object, ignore spread properties', () => {\n      const prop = extractProp('<div foo={{bar: \"baz\", ...{baz: \"bar\", foo: {...{bar: \"meh\"}}}}} />');\n      const expected = {\n        bar: 'baz',\n        baz: 'bar',\n        foo: {\n          bar: 'meh'\n        }\n      };\n      const actual = getPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n    it('should evaluate to a correct representation of the object, ignore spread properties', () => {\n      const prop = extractProp('<div foo={{ pathname: manageRoute, state: {...data}}} />');\n      const expected = {\n        pathname: 'manageRoute',\n        state: {}\n      };\n      const actual = getPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n  });\n  describe('New expression', () => {\n    it('should return a new empty object', () => {\n      const prop = extractProp('<div foo={new Bar()} />');\n      const expected = {};\n      const actual = getPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n  });\n  describe('Array expression', () => {\n    it('should evaluate to correct representation of the the array in props', () => {\n      const prop = extractProp('<div foo={[\"bar\", 42, , null]} />');\n      const expected = ['bar', 42, undefined, null];\n      const actual = getPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n    it('should evaluate to a correct representation of an array with spread elements', () => {\n      const prop = extractProp('<div foo={[...this.props.params, bar]} />');\n      const expected = [undefined, 'bar'];\n      const actual = getPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n  });\n  it('should return an empty array provided an empty array in props', () => {\n    const prop = extractProp('<div foo={[]} />');\n    const expected = [];\n    const actual = getPropValue(prop);\n    assert.deepEqual(actual, expected);\n  });\n  describe('Bind expression', () => {\n    it('should return string representation of bind function call when object is null', () => {\n      const prop = extractProp('<div foo={::this.handleClick} />');\n      const expected = 'this.handleClick.bind(this)';\n      const actual = getPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n    it('should return string representation of bind function call when object is not null', () => {\n      const prop = extractProp('<div foo={foo::bar} />');\n      const expected = 'bar.bind(foo)';\n      const actual = getPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n    it('should return string representation of bind function call when binding to object properties', () => {\n      const prop = extractProp('<div foo={a.b::c} />');\n      const otherProp = extractProp('<div foo={::a.b.c} />');\n      const expected = 'a.b.c.bind(a.b)';\n      const actual = getPropValue(prop);\n      const otherExpected = 'a.b.c.bind(a.b)';\n      const otherActual = getPropValue(otherProp);\n      assert.deepEqual(actual, expected);\n      assert.deepEqual(otherExpected, otherActual);\n    });\n  });\n  describe('Type Cast Expression', () => {\n    it('should throw a parsing error', () => {\n      let counter = 0; // eslint-disable-next-line no-console\n\n      const warnOrig = console.warn; // eslint-disable-next-line no-console\n\n      console.warn = () => {\n        counter += 1;\n      }; // eslint-disable-next-line no-undef\n\n\n      expect(() => {\n        extractProp('<div foo={(this.handleClick: (event: MouseEvent) => void))} />');\n      }).toThrow();\n      assert.equal(counter, 1); // eslint-disable-next-line no-console\n\n      console.warn = warnOrig;\n    });\n  });\n  describe('AssignmentExpression', () => {\n    it('should recognize and extract assignment', () => {\n      const prop = extractProp('<div foo={foo = bar} />');\n      const expected = 'foo = bar';\n      const actual = getPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n    it('should recognize and extract combination assignments', () => {\n      const prop = extractProp('<div foo={foo += bar} />');\n      const expected = 'foo += bar';\n      const actual = getPropValue(prop);\n      assert.deepEqual(actual, expected);\n    });\n  });\n  describeIfNotBabylon('Typescript', () => {\n    beforeEach(() => {\n      changePlugins(pls => [...pls, 'typescript']);\n    });\n    it('should return string representation of variable identifier wrapped in a Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={bar!} />');\n      const expected = 'bar!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of variable identifier wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar!)!} />');\n      const expected = '(bar!)!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of variable identifier wrapped in a Typescript type coercion', () => {\n      const prop = extractProp('<div foo={bar as any} />');\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n  describeIfNotBabylon('TSNonNullExpression', () => {\n    beforeEach(() => {\n      changePlugins(pls => [...pls, 'typescript']);\n    });\n    it('should return string representation of a TSNonNullExpression of form `variable!`', () => {\n      const prop = extractProp('<div foo={bar!} />');\n      const expected = 'bar!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of a TSNonNullExpression of form `object!.property`', () => {\n      const prop = extractProp('<div foo={bar!.bar} />');\n      const expected = 'bar!.bar';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of a TSNonNullExpression of form `object!.property!`', () => {\n      const prop = extractProp('<div foo={bar!.bar!} />');\n      const actual = getPropValue(prop);\n      const expected = 'bar!.bar!';\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of a TSNonNullExpression of form `object.property!`', () => {\n      const prop = extractProp('<div foo={bar.bar!} />');\n      const actual = getPropValue(prop);\n      const expected = 'bar.bar!';\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of a TSNonNullExpression of form `object.property.property!`', () => {\n      const prop = extractProp('<div foo={bar.bar.bar!} />');\n      const actual = getPropValue(prop);\n      const expected = 'bar.bar.bar!';\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of a TSNonNullExpression of form `object!.property.property!`', () => {\n      const prop = extractProp('<div foo={bar!.bar.bar!} />');\n      const actual = getPropValue(prop);\n      const expected = 'bar!.bar.bar!';\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of an object wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar!.bar)!} />');\n      const expected = '(bar!.bar)!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of a cast wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar as Bar).baz!} />');\n      const actual = getPropValue(prop);\n      const expected = 'bar.baz!';\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of an object wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar.bar)!} />');\n      const expected = '(bar.bar)!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of an object wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar!.bar.bar!)!} />');\n      const expected = '(bar!.bar.bar!)!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should return string representation of variable identifier wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar!)!} />');\n      const expected = '(bar!)!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should work with a this.props value', () => {\n      const prop = extractProp('<a foo={this.props.href!}>Download</a>');\n      const expected = 'this.props.href!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('should correctly evaluate a bracketed navigation expression that prefixes with !', () => {\n      const prop = extractProp('<Link foo={data![0].url} />');\n      const expected = 'data![0].url';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n    it('works with an optional chain with an `as`', () => {\n      const prop = extractProp('<img src={images?.footer as string} />', 'src');\n      const expected = 'images?.footer';\n      const actual = getPropValue(prop, 'src');\n      assert.equal(actual, expected);\n    });\n  });\n  describe('JSX empty expression', () => {\n    it('should work with an empty expression', () => {\n      const prop = extractProp('<div>\\n{/* Hello there */}\\n</div>', 'children');\n      const expected = undefined;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n});","map":{"version":3,"names":["assert","extractProp","changePlugins","fallbackToBabylon","describeIfNotBabylon","setParserName","getPropValue","describe","beforeEach","it","expected","actual","equal","undefined","prop","type","value","counter","errorOrig","console","error","doesNotThrow","Error","skip","String","Array","Date","Infinity","Math","Number","Object","runTest","expect","toThrow","isNaN","trueProp","falseProp","trueVal","falseVal","bar","deepEqual","baz","foo","pathname","state","otherProp","otherExpected","otherActual","warnOrig","warn","pls"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jsx-ast-utils/__tests__/src/getPropValue-babelparser-test.js"],"sourcesContent":["/* eslint-env mocha */\n/* eslint no-template-curly-in-string: 0 */\nimport assert from 'assert';\nimport {\n  extractProp,\n  changePlugins,\n  fallbackToBabylon,\n  describeIfNotBabylon,\n  setParserName,\n} from '../helper';\nimport getPropValue from '../../src/getPropValue';\n\ndescribe('getPropValue', () => {\n  beforeEach(() => {\n    setParserName('babel');\n  });\n\n  it('should export a function', () => {\n    const expected = 'function';\n    const actual = typeof getPropValue;\n\n    assert.equal(actual, expected);\n  });\n\n  it('should return undefined when not provided with a JSXAttribute', () => {\n    const expected = undefined;\n    const actual = getPropValue(1);\n\n    assert.equal(actual, expected);\n  });\n\n  it('should not throw error when trying to get value from unknown node type', () => {\n    const prop = {\n      type: 'JSXAttribute',\n      value: {\n        type: 'JSXExpressionContainer',\n      },\n    };\n    let counter = 0;\n    // eslint-disable-next-line no-console\n    const errorOrig = console.error;\n    // eslint-disable-next-line no-console\n    console.error = () => {\n      counter += 1;\n    };\n    let value;\n    assert.doesNotThrow(() => {\n      value = getPropValue(prop);\n    }, Error);\n\n    assert.equal(null, value);\n    assert.equal(counter, 1);\n    // eslint-disable-next-line no-console\n    console.error = errorOrig;\n  });\n\n  describe('Null', () => {\n    it('should return true when no value is given', () => {\n      const prop = extractProp('<div foo />');\n\n      const expected = true;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Literal', () => {\n    it('should return correct string if value is a string', () => {\n      const prop = extractProp('<div foo=\"bar\" />');\n\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return correct string if value is a string expression', () => {\n      const prop = extractProp('<div foo={\"bar\"} />');\n\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return correct integer if value is a integer expression', () => {\n      const prop = extractProp('<div foo={1} />');\n\n      const expected = 1;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should convert \"true\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"true\" />');\n\n      const expected = true;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should convert \"false\" to boolean type', () => {\n      const prop = extractProp('<div foo=\"false\" />');\n\n      const expected = false;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('JSXElement', () => {\n    it('should return correct representation of JSX element as a string', () => {\n      const prop = extractProp('<div foo={<bar />} />');\n\n      const expected = '<bar />';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return correct representation of JSX element with children as a string', () => {\n      const prop = extractProp('<div foo={<bar><baz />foo</bar>} />');\n\n      const expected = '<bar><baz />foo</bar>';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  (fallbackToBabylon ? describe.skip : describe)('JSXFragment', () => {\n    it('should return correct representation of JSX fragment as a string', () => {\n      const prop = extractProp('<div foo={<></>} />');\n\n      const expected = '<></>';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return correct representation of JSX fragment with children as a string', () => {\n      const prop = extractProp('<div foo={<><div />abc</>} />');\n\n      const expected = '<><div />abc</>';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Identifier', () => {\n    it('should return string representation of variable identifier', () => {\n      const prop = extractProp('<div foo={bar} />');\n\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return undefined when identifier is literally `undefined`', () => {\n      const prop = extractProp('<div foo={undefined} />');\n\n      const expected = undefined;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return String object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={String} />');\n\n      const expected = String;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return Array object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Array} />');\n\n      const expected = Array;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return Date object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Date} />');\n\n      const expected = Date;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return Infinity object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Infinity} />');\n\n      const expected = Infinity;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return Math object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Math} />');\n\n      const expected = Math;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return Number object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Number} />');\n\n      const expected = Number;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return Object object when using a reserved JavaScript object', () => {\n      const prop = extractProp('<div foo={Object} />');\n\n      const expected = Object;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Template literal', () => {\n    it('should return template literal with vars wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={`bar ${baz}`} />');\n\n      const expected = 'bar {baz}';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string \"undefined\" for expressions that evaluate to undefined', () => {\n      const prop = extractProp('<div foo={`bar ${undefined}`} />');\n\n      const expected = 'bar undefined';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return template literal with expression type wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={`bar ${baz()}`} />');\n\n      const expected = 'bar {CallExpression}';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should ignore non-expressions in the template literal', () => {\n      const prop = extractProp('<div foo={`bar ${<baz />}`} />');\n\n      const expected = 'bar ';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Tagged Template literal', () => {\n    it('should return template literal with vars wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={noop`bar ${baz}`} />');\n\n      const expected = 'bar {baz}';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string \"undefined\" for expressions that evaluate to undefined', () => {\n      const prop = extractProp('<div foo={noop`bar ${undefined}`} />');\n\n      const expected = 'bar undefined';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return template literal with expression type wrapped in curly braces', () => {\n      const prop = extractProp('<div foo={noop`bar ${baz()}`} />');\n\n      const expected = 'bar {CallExpression}';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should ignore non-expressions in the template literal', () => {\n      const prop = extractProp('<div foo={noop`bar ${<baz />}`} />');\n\n      const expected = 'bar ';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Arrow function expression', () => {\n    it('should return a function', () => {\n      const prop = extractProp('<div foo={ () => { return \"bar\"; }} />');\n\n      const expected = 'function';\n      const actual = getPropValue(prop);\n\n      assert.equal(expected, typeof actual);\n\n      // For code coverage ¯\\_(ツ)_/¯\n      actual();\n    });\n    it('should handle ArrowFunctionExpression as conditional consequent', () => {\n      const prop = extractProp('<div foo={ (true) ? () => null : () => ({})} />');\n\n      const expected = 'function';\n      const actual = getPropValue(prop);\n\n      assert.equal(expected, typeof actual);\n\n      // For code coverage ¯\\_(ツ)_/¯\n      actual();\n    });\n  });\n\n  describe('Function expression', () => {\n    it('should return a function', () => {\n      const prop = extractProp('<div foo={ function() { return \"bar\"; } } />');\n\n      const expected = 'function';\n      const actual = getPropValue(prop);\n\n      assert.equal(expected, typeof actual);\n\n      // For code coverage ¯\\_(ツ)_/¯\n      actual();\n    });\n  });\n\n  describe('Logical expression', () => {\n    it('should correctly infer result of && logical expression based on derived values', () => {\n      const prop = extractProp('<div foo={bar && baz} />');\n\n      const expected = 'baz';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return undefined when evaluating `undefined && undefined` ', () => {\n      const prop = extractProp('<div foo={undefined && undefined} />');\n\n      const expected = undefined;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly infer result of || logical expression based on derived values', () => {\n      const prop = extractProp('<div foo={bar || baz} />');\n\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly infer result of || logical expression based on derived values', () => {\n      const prop = extractProp('<div foo={undefined || baz} />');\n\n      const expected = 'baz';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return undefined when evaluating `undefined || undefined` ', () => {\n      const prop = extractProp('<div foo={undefined || undefined} />');\n\n      const expected = undefined;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly infer result of ?? logical expression based on derived values', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={bar ?? baz} />');\n\n        const expected = 'bar';\n        const actual = getPropValue(prop);\n\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n\n    it('should correctly infer result of ?? logical expression based on derived values', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={undefined ?? baz} />');\n\n        const expected = 'baz';\n        const actual = getPropValue(prop);\n\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n\n    it('should return undefined when evaluating `undefined ?? undefined` ', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={undefined ?? undefined} />');\n\n        const expected = undefined;\n        const actual = getPropValue(prop);\n\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n\n    it('should return undefined when evaluating `null ?? undefined` ', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={null ?? undefined} />');\n\n        const expected = undefined;\n        const actual = getPropValue(prop);\n\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n\n    it('should return undefined when evaluating `undefined ?? null` ', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={undefined ?? null} />');\n\n        const expected = null;\n        const actual = getPropValue(prop);\n\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n\n    it('should return null when evaluating `null ?? null` ', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={null ?? null} />');\n\n        const expected = null;\n        const actual = getPropValue(prop);\n\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n  });\n\n  describe('Member expression', () => {\n    it('should return string representation of form `object.property`', () => {\n      const prop = extractProp('<div foo={bar.baz} />');\n\n      const expected = 'bar.baz';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate to a correct representation of member expression with a nullable member', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={bar?.baz} />');\n\n        const expected = 'bar?.baz';\n        const actual = getPropValue(prop);\n\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n\n    it('should evaluate to a correct representation of optional call expression', () => {\n      const runTest = () => {\n        const prop = extractProp('<div foo={bar.baz?.(quux)} />');\n\n        const expected = 'bar.baz?.(quux)';\n        const actual = getPropValue(prop);\n\n        assert.equal(actual, expected);\n      };\n\n      if (fallbackToBabylon) {\n        // eslint-disable-next-line no-undef\n        expect(runTest).toThrow();\n      } else {\n        runTest();\n      }\n    });\n  });\n\n  describe('Call expression', () => {\n    it('should return string representation of callee', () => {\n      const prop = extractProp('<div foo={bar()} />');\n\n      const expected = 'bar()';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of callee', () => {\n      const prop = extractProp('<div foo={bar.call()} />');\n\n      const expected = 'bar.call()';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Unary expression', () => {\n    it('should correctly evaluate an expression that prefixes with -', () => {\n      const prop = extractProp('<div foo={-bar} />');\n\n      // -\"bar\" => NaN\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with -', () => {\n      const prop = extractProp('<div foo={-42} />');\n\n      const expected = -42;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with +', () => {\n      const prop = extractProp('<div foo={+bar} />');\n\n      // +\"bar\" => NaN\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with +', () => {\n      const prop = extractProp('<div foo={+42} />');\n\n      const expected = 42;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with !', () => {\n      const prop = extractProp('<div foo={!bar} />');\n\n      const expected = false; // !\"bar\" === false\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with ~', () => {\n      const prop = extractProp('<div foo={~bar} />');\n\n      const expected = -1; // ~\"bar\" === -1\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return true when evaluating `delete foo`', () => {\n      const prop = extractProp('<div foo={delete x} />');\n\n      const expected = true;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return undefined when evaluating `void foo`', () => {\n      const prop = extractProp('<div foo={void x} />');\n\n      const expected = undefined;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    // TODO: We should fix this to check to see if we can evaluate it.\n    it('should return undefined when evaluating `typeof foo`', () => {\n      const prop = extractProp('<div foo={typeof x} />');\n\n      const expected = undefined;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Update expression', () => {\n    it('should correctly evaluate an expression that prefixes with ++', () => {\n      const prop = extractProp('<div foo={++bar} />');\n\n      // ++\"bar\" => NaN\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that prefixes with --', () => {\n      const prop = extractProp('<div foo={--bar} />');\n\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that suffixes with ++', () => {\n      const prop = extractProp('<div foo={bar++} />');\n\n      // \"bar\"++ => NaN\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate an expression that suffixes with --', () => {\n      const prop = extractProp('<div foo={bar--} />');\n\n      const expected = true;\n      const actual = Number.isNaN(getPropValue(prop));\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('This expression', () => {\n    it('should return string value `this`', () => {\n      const prop = extractProp('<div foo={this} />');\n\n      const expected = 'this';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Conditional expression', () => {\n    it('should evaluate the conditional based on the derived values correctly', () => {\n      const prop = extractProp('<div foo={bar ? baz : bam} />');\n\n      const expected = 'baz';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the conditional based on the derived values correctly', () => {\n      const prop = extractProp('<div foo={undefined ? baz : bam} />');\n\n      const expected = 'bam';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the conditional based on the derived values correctly', () => {\n      const prop = extractProp('<div foo={(1 > 2) ? baz : bam} />');\n\n      const expected = 'bam';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Binary expression', () => {\n    it('should evaluate the `==` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 == \"1\"} />');\n      const falseProp = extractProp('<div foo={1 == bar} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `!=` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 != \"2\"} />');\n      const falseProp = extractProp('<div foo={1 != \"1\"} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `===` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 === 1} />');\n      const falseProp = extractProp('<div foo={1 === \"1\"} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `!==` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 !== \"1\"} />');\n      const falseProp = extractProp('<div foo={1 !== 1} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `<` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 < 2} />');\n      const falseProp = extractProp('<div foo={1 < 0} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `>` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 > 0} />');\n      const falseProp = extractProp('<div foo={1 > 2} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `<=` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 <= 1} />');\n      const falseProp = extractProp('<div foo={1 <= 0} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `>=` operator correctly', () => {\n      const trueProp = extractProp('<div foo={1 >= 1} />');\n      const falseProp = extractProp('<div foo={1 >= 2} />');\n\n      const trueVal = getPropValue(trueProp);\n      const falseVal = getPropValue(falseProp);\n\n      assert.equal(true, trueVal);\n      assert.equal(false, falseVal);\n    });\n\n    it('should evaluate the `<<` operator correctly', () => {\n      const prop = extractProp('<div foo={1 << 2} />');\n\n      const expected = 4;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `>>` operator correctly', () => {\n      const prop = extractProp('<div foo={1 >> 2} />');\n\n      const expected = 0;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `>>>` operator correctly', () => {\n      const prop = extractProp('<div foo={2 >>> 1} />');\n\n      const expected = 1;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `+` operator correctly', () => {\n      const prop = extractProp('<div foo={1 + 1} />');\n\n      const expected = 2;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `-` operator correctly', () => {\n      const prop = extractProp('<div foo={1 - 1} />');\n\n      const expected = 0;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `*` operator correctly', () => {\n      const prop = extractProp('<div foo={10 * 10} />');\n\n      const expected = 100;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `/` operator correctly', () => {\n      const prop = extractProp('<div foo={10 / 2} />');\n\n      const expected = 5;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `%` operator correctly', () => {\n      const prop = extractProp('<div foo={10 % 3} />');\n\n      const expected = 1;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `|` operator correctly', () => {\n      const prop = extractProp('<div foo={10 | 1} />');\n\n      const expected = 11;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `^` operator correctly', () => {\n      const prop = extractProp('<div foo={10 ^ 1} />');\n\n      const expected = 11;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `&` operator correctly', () => {\n      const prop = extractProp('<div foo={10 & 1} />');\n\n      const expected = 0;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `in` operator correctly', () => {\n      const prop = extractProp('<div foo={foo in bar} />');\n\n      const expected = false;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `instanceof` operator correctly', () => {\n      const prop = extractProp('<div foo={{} instanceof Object} />');\n\n      const expected = true;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should evaluate the `instanceof` operator when right side is not a function', () => {\n      const prop = extractProp('<div foo={\"bar\" instanceof Baz} />');\n\n      const expected = false;\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('Object expression', () => {\n    it('should evaluate to a correct representation of the object in props', () => {\n      const prop = extractProp('<div foo={ { bar: \"baz\" } } />');\n\n      const expected = { bar: 'baz' };\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    it('should evaluate to a correct representation of the object, ignore spread properties', () => {\n      const prop = extractProp('<div foo={{bar: \"baz\", ...{baz: \"bar\", foo: {...{bar: \"meh\"}}}}} />');\n\n      const expected = { bar: 'baz', baz: 'bar', foo: { bar: 'meh' } };\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    it('should evaluate to a correct representation of the object, ignore spread properties', () => {\n      const prop = extractProp('<div foo={{ pathname: manageRoute, state: {...data}}} />');\n\n      const expected = { pathname: 'manageRoute', state: {} };\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  describe('New expression', () => {\n    it('should return a new empty object', () => {\n      const prop = extractProp('<div foo={new Bar()} />');\n\n      const expected = {};\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  describe('Array expression', () => {\n    it('should evaluate to correct representation of the the array in props', () => {\n      const prop = extractProp('<div foo={[\"bar\", 42, , null]} />');\n\n      const expected = ['bar', 42, undefined, null];\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    it('should evaluate to a correct representation of an array with spread elements', () => {\n      const prop = extractProp('<div foo={[...this.props.params, bar]} />');\n\n      const expected = [undefined, 'bar'];\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  it('should return an empty array provided an empty array in props', () => {\n    const prop = extractProp('<div foo={[]} />');\n\n    const expected = [];\n    const actual = getPropValue(prop);\n\n    assert.deepEqual(actual, expected);\n  });\n\n  describe('Bind expression', () => {\n    it('should return string representation of bind function call when object is null', () => {\n      const prop = extractProp('<div foo={::this.handleClick} />');\n\n      const expected = 'this.handleClick.bind(this)';\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    it('should return string representation of bind function call when object is not null', () => {\n      const prop = extractProp('<div foo={foo::bar} />');\n\n      const expected = 'bar.bind(foo)';\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    it('should return string representation of bind function call when binding to object properties', () => {\n      const prop = extractProp('<div foo={a.b::c} />');\n      const otherProp = extractProp('<div foo={::a.b.c} />');\n\n      const expected = 'a.b.c.bind(a.b)';\n      const actual = getPropValue(prop);\n\n      const otherExpected = 'a.b.c.bind(a.b)';\n      const otherActual = getPropValue(otherProp);\n\n      assert.deepEqual(actual, expected);\n      assert.deepEqual(otherExpected, otherActual);\n    });\n  });\n\n  describe('Type Cast Expression', () => {\n    it('should throw a parsing error', () => {\n      let counter = 0;\n      // eslint-disable-next-line no-console\n      const warnOrig = console.warn;\n      // eslint-disable-next-line no-console\n      console.warn = () => {\n        counter += 1;\n      };\n      // eslint-disable-next-line no-undef\n      expect(() => {\n        extractProp('<div foo={(this.handleClick: (event: MouseEvent) => void))} />');\n      }).toThrow();\n      assert.equal(counter, 1);\n      // eslint-disable-next-line no-console\n      console.warn = warnOrig;\n    });\n  });\n\n  describe('AssignmentExpression', () => {\n    it('should recognize and extract assignment', () => {\n      const prop = extractProp('<div foo={foo = bar} />');\n\n      const expected = 'foo = bar';\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n\n    it('should recognize and extract combination assignments', () => {\n      const prop = extractProp('<div foo={foo += bar} />');\n\n      const expected = 'foo += bar';\n      const actual = getPropValue(prop);\n\n      assert.deepEqual(actual, expected);\n    });\n  });\n\n  describeIfNotBabylon('Typescript', () => {\n    beforeEach(() => {\n      changePlugins((pls) => [...pls, 'typescript']);\n    });\n\n    it('should return string representation of variable identifier wrapped in a Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={bar!} />');\n\n      const expected = 'bar!';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of variable identifier wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar!)!} />');\n\n      const expected = '(bar!)!';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of variable identifier wrapped in a Typescript type coercion', () => {\n      const prop = extractProp('<div foo={bar as any} />');\n\n      const expected = 'bar';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describeIfNotBabylon('TSNonNullExpression', () => {\n    beforeEach(() => {\n      changePlugins((pls) => [...pls, 'typescript']);\n    });\n\n    it('should return string representation of a TSNonNullExpression of form `variable!`', () => {\n      const prop = extractProp('<div foo={bar!} />');\n      const expected = 'bar!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of a TSNonNullExpression of form `object!.property`', () => {\n      const prop = extractProp('<div foo={bar!.bar} />');\n      const expected = 'bar!.bar';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of a TSNonNullExpression of form `object!.property!`', () => {\n      const prop = extractProp('<div foo={bar!.bar!} />');\n      const actual = getPropValue(prop);\n      const expected = 'bar!.bar!';\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of a TSNonNullExpression of form `object.property!`', () => {\n      const prop = extractProp('<div foo={bar.bar!} />');\n      const actual = getPropValue(prop);\n      const expected = 'bar.bar!';\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of a TSNonNullExpression of form `object.property.property!`', () => {\n      const prop = extractProp('<div foo={bar.bar.bar!} />');\n      const actual = getPropValue(prop);\n      const expected = 'bar.bar.bar!';\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of a TSNonNullExpression of form `object!.property.property!`', () => {\n      const prop = extractProp('<div foo={bar!.bar.bar!} />');\n      const actual = getPropValue(prop);\n      const expected = 'bar!.bar.bar!';\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of an object wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar!.bar)!} />');\n      const expected = '(bar!.bar)!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of a cast wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar as Bar).baz!} />');\n      const actual = getPropValue(prop);\n      const expected = 'bar.baz!';\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of an object wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar.bar)!} />');\n      const expected = '(bar.bar)!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of an object wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar!.bar.bar!)!} />');\n      const expected = '(bar!.bar.bar!)!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n\n    it('should return string representation of variable identifier wrapped in a deep Typescript non-null assertion', () => {\n      const prop = extractProp('<div foo={(bar!)!} />');\n      const expected = '(bar!)!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n\n    it('should work with a this.props value', () => {\n      const prop = extractProp('<a foo={this.props.href!}>Download</a>');\n      const expected = 'this.props.href!';\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n\n    it('should correctly evaluate a bracketed navigation expression that prefixes with !', () => {\n      const prop = extractProp('<Link foo={data![0].url} />');\n\n      const expected = 'data![0].url';\n      const actual = getPropValue(prop);\n\n      assert.equal(actual, expected);\n    });\n\n    it('works with an optional chain with an `as`', () => {\n      const prop = extractProp('<img src={images?.footer as string} />', 'src');\n\n      const expected = 'images?.footer';\n      const actual = getPropValue(prop, 'src');\n\n      assert.equal(actual, expected);\n    });\n  });\n\n  describe('JSX empty expression', () => {\n    it('should work with an empty expression', () => {\n      const prop = extractProp('<div>\\n{/* Hello there */}\\n</div>', 'children');\n      const expected = undefined;\n      const actual = getPropValue(prop);\n      assert.equal(actual, expected);\n    });\n  });\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}