{"ast":null,"code":"/**\n * @fileoverview Rule Validator\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst ajv = require(\"../shared/ajv\")();\n\nconst {\n  parseRuleId,\n  getRuleFromConfig,\n  getRuleOptionsSchema\n} = require(\"./flat-config-helpers\");\n\nconst ruleReplacements = require(\"../../conf/replacements.json\"); //-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Throws a helpful error when a rule cannot be found.\n * @param {Object} ruleId The rule identifier.\n * @param {string} ruleId.pluginName The ID of the rule to find.\n * @param {string} ruleId.ruleName The ID of the rule to find.\n * @param {Object} config The config to search in.\n * @throws {TypeError} For missing plugin or rule.\n * @returns {void}\n */\n\n\nfunction throwRuleNotFoundError(_ref, config) {\n  let {\n    pluginName,\n    ruleName\n  } = _ref;\n  const ruleId = pluginName === \"@\" ? ruleName : `${pluginName}/${ruleName}`;\n  const errorMessageHeader = `Key \"rules\": Key \"${ruleId}\"`;\n  let errorMessage = `${errorMessageHeader}: Could not find plugin \"${pluginName}\".`; // if the plugin exists then we need to check if the rule exists\n\n  if (config.plugins && config.plugins[pluginName]) {\n    const replacementRuleName = ruleReplacements.rules[ruleName];\n\n    if (pluginName === \"@\" && replacementRuleName) {\n      errorMessage = `${errorMessageHeader}: Rule \"${ruleName}\" was removed and replaced by \"${replacementRuleName}\".`;\n    } else {\n      errorMessage = `${errorMessageHeader}: Could not find \"${ruleName}\" in plugin \"${pluginName}\".`; // otherwise, let's see if we can find the rule name elsewhere\n\n      for (const [otherPluginName, otherPlugin] of Object.entries(config.plugins)) {\n        if (otherPlugin.rules && otherPlugin.rules[ruleName]) {\n          errorMessage += ` Did you mean \"${otherPluginName}/${ruleName}\"?`;\n          break;\n        }\n      }\n    } // falls through to throw error\n\n  }\n\n  throw new TypeError(errorMessage);\n} //-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Implements validation functionality for the rules portion of a config.\n */\n\n\nclass RuleValidator {\n  /**\n   * Creates a new instance.\n   */\n  constructor() {\n    /**\n     * A collection of compiled validators for rules that have already\n     * been validated.\n     * @type {WeakMap}\n     */\n    this.validators = new WeakMap();\n  }\n  /**\n   * Validates all of the rule configurations in a config against each\n   * rule's schema.\n   * @param {Object} config The full config to validate. This object must\n   *      contain both the rules section and the plugins section.\n   * @returns {void}\n   * @throws {Error} If a rule's configuration does not match its schema.\n   */\n\n\n  validate(config) {\n    if (!config.rules) {\n      return;\n    }\n\n    for (const [ruleId, ruleOptions] of Object.entries(config.rules)) {\n      // check for edge case\n      if (ruleId === \"__proto__\") {\n        continue;\n      }\n      /*\n       * If a rule is disabled, we don't do any validation. This allows\n       * users to safely set any value to 0 or \"off\" without worrying\n       * that it will cause a validation error.\n       *\n       * Note: ruleOptions is always an array at this point because\n       * this validation occurs after FlatConfigArray has merged and\n       * normalized values.\n       */\n\n\n      if (ruleOptions[0] === 0) {\n        continue;\n      }\n\n      const rule = getRuleFromConfig(ruleId, config);\n\n      if (!rule) {\n        throwRuleNotFoundError(parseRuleId(ruleId), config);\n      } // Precompile and cache validator the first time\n\n\n      if (!this.validators.has(rule)) {\n        const schema = getRuleOptionsSchema(rule);\n\n        if (schema) {\n          this.validators.set(rule, ajv.compile(schema));\n        }\n      }\n\n      const validateRule = this.validators.get(rule);\n\n      if (validateRule) {\n        validateRule(ruleOptions.slice(1));\n\n        if (validateRule.errors) {\n          throw new Error(`Key \"rules\": Key \"${ruleId}\": ${validateRule.errors.map(error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`).join(\"\")}`);\n        }\n      }\n    }\n  }\n\n}\n\nexports.RuleValidator = RuleValidator;","map":{"version":3,"names":["ajv","require","parseRuleId","getRuleFromConfig","getRuleOptionsSchema","ruleReplacements","throwRuleNotFoundError","config","pluginName","ruleName","ruleId","errorMessageHeader","errorMessage","plugins","replacementRuleName","rules","otherPluginName","otherPlugin","Object","entries","TypeError","RuleValidator","constructor","validators","WeakMap","validate","ruleOptions","rule","has","schema","set","compile","validateRule","get","slice","errors","Error","map","error","JSON","stringify","data","message","join","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/config/rule-validator.js"],"sourcesContent":["/**\n * @fileoverview Rule Validator\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst ajv = require(\"../shared/ajv\")();\nconst {\n    parseRuleId,\n    getRuleFromConfig,\n    getRuleOptionsSchema\n} = require(\"./flat-config-helpers\");\nconst ruleReplacements = require(\"../../conf/replacements.json\");\n\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\n * Throws a helpful error when a rule cannot be found.\n * @param {Object} ruleId The rule identifier.\n * @param {string} ruleId.pluginName The ID of the rule to find.\n * @param {string} ruleId.ruleName The ID of the rule to find.\n * @param {Object} config The config to search in.\n * @throws {TypeError} For missing plugin or rule.\n * @returns {void}\n */\nfunction throwRuleNotFoundError({ pluginName, ruleName }, config) {\n\n    const ruleId = pluginName === \"@\" ? ruleName : `${pluginName}/${ruleName}`;\n\n    const errorMessageHeader = `Key \"rules\": Key \"${ruleId}\"`;\n    let errorMessage = `${errorMessageHeader}: Could not find plugin \"${pluginName}\".`;\n\n    // if the plugin exists then we need to check if the rule exists\n    if (config.plugins && config.plugins[pluginName]) {\n        const replacementRuleName = ruleReplacements.rules[ruleName];\n\n        if (pluginName === \"@\" && replacementRuleName) {\n\n            errorMessage = `${errorMessageHeader}: Rule \"${ruleName}\" was removed and replaced by \"${replacementRuleName}\".`;\n\n        } else {\n\n            errorMessage = `${errorMessageHeader}: Could not find \"${ruleName}\" in plugin \"${pluginName}\".`;\n\n            // otherwise, let's see if we can find the rule name elsewhere\n            for (const [otherPluginName, otherPlugin] of Object.entries(config.plugins)) {\n                if (otherPlugin.rules && otherPlugin.rules[ruleName]) {\n                    errorMessage += ` Did you mean \"${otherPluginName}/${ruleName}\"?`;\n                    break;\n                }\n            }\n\n        }\n\n        // falls through to throw error\n    }\n\n    throw new TypeError(errorMessage);\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Implements validation functionality for the rules portion of a config.\n */\nclass RuleValidator {\n\n    /**\n     * Creates a new instance.\n     */\n    constructor() {\n\n        /**\n         * A collection of compiled validators for rules that have already\n         * been validated.\n         * @type {WeakMap}\n         */\n        this.validators = new WeakMap();\n    }\n\n    /**\n     * Validates all of the rule configurations in a config against each\n     * rule's schema.\n     * @param {Object} config The full config to validate. This object must\n     *      contain both the rules section and the plugins section.\n     * @returns {void}\n     * @throws {Error} If a rule's configuration does not match its schema.\n     */\n    validate(config) {\n\n        if (!config.rules) {\n            return;\n        }\n\n        for (const [ruleId, ruleOptions] of Object.entries(config.rules)) {\n\n            // check for edge case\n            if (ruleId === \"__proto__\") {\n                continue;\n            }\n\n            /*\n             * If a rule is disabled, we don't do any validation. This allows\n             * users to safely set any value to 0 or \"off\" without worrying\n             * that it will cause a validation error.\n             *\n             * Note: ruleOptions is always an array at this point because\n             * this validation occurs after FlatConfigArray has merged and\n             * normalized values.\n             */\n            if (ruleOptions[0] === 0) {\n                continue;\n            }\n\n            const rule = getRuleFromConfig(ruleId, config);\n\n            if (!rule) {\n                throwRuleNotFoundError(parseRuleId(ruleId), config);\n            }\n\n            // Precompile and cache validator the first time\n            if (!this.validators.has(rule)) {\n                const schema = getRuleOptionsSchema(rule);\n\n                if (schema) {\n                    this.validators.set(rule, ajv.compile(schema));\n                }\n            }\n\n            const validateRule = this.validators.get(rule);\n\n            if (validateRule) {\n\n                validateRule(ruleOptions.slice(1));\n\n                if (validateRule.errors) {\n                    throw new Error(`Key \"rules\": Key \"${ruleId}\": ${\n                        validateRule.errors.map(\n                            error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`\n                        ).join(\"\")\n                    }`);\n                }\n            }\n        }\n    }\n}\n\nexports.RuleValidator = RuleValidator;\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,eAAD,CAAP,EAAZ;;AACA,MAAM;EACFC,WADE;EAEFC,iBAFE;EAGFC;AAHE,IAIFH,OAAO,CAAC,uBAAD,CAJX;;AAKA,MAAMI,gBAAgB,GAAGJ,OAAO,CAAC,8BAAD,CAAhC,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,sBAAT,OAA0DC,MAA1D,EAAkE;EAAA,IAAlC;IAAEC,UAAF;IAAcC;EAAd,CAAkC;EAE9D,MAAMC,MAAM,GAAGF,UAAU,KAAK,GAAf,GAAqBC,QAArB,GAAiC,GAAED,UAAW,IAAGC,QAAS,EAAzE;EAEA,MAAME,kBAAkB,GAAI,qBAAoBD,MAAO,GAAvD;EACA,IAAIE,YAAY,GAAI,GAAED,kBAAmB,4BAA2BH,UAAW,IAA/E,CAL8D,CAO9D;;EACA,IAAID,MAAM,CAACM,OAAP,IAAkBN,MAAM,CAACM,OAAP,CAAeL,UAAf,CAAtB,EAAkD;IAC9C,MAAMM,mBAAmB,GAAGT,gBAAgB,CAACU,KAAjB,CAAuBN,QAAvB,CAA5B;;IAEA,IAAID,UAAU,KAAK,GAAf,IAAsBM,mBAA1B,EAA+C;MAE3CF,YAAY,GAAI,GAAED,kBAAmB,WAAUF,QAAS,kCAAiCK,mBAAoB,IAA7G;IAEH,CAJD,MAIO;MAEHF,YAAY,GAAI,GAAED,kBAAmB,qBAAoBF,QAAS,gBAAeD,UAAW,IAA5F,CAFG,CAIH;;MACA,KAAK,MAAM,CAACQ,eAAD,EAAkBC,WAAlB,CAAX,IAA6CC,MAAM,CAACC,OAAP,CAAeZ,MAAM,CAACM,OAAtB,CAA7C,EAA6E;QACzE,IAAII,WAAW,CAACF,KAAZ,IAAqBE,WAAW,CAACF,KAAZ,CAAkBN,QAAlB,CAAzB,EAAsD;UAClDG,YAAY,IAAK,kBAAiBI,eAAgB,IAAGP,QAAS,IAA9D;UACA;QACH;MACJ;IAEJ,CAnB6C,CAqB9C;;EACH;;EAED,MAAM,IAAIW,SAAJ,CAAcR,YAAd,CAAN;AACH,C,CAED;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMS,aAAN,CAAoB;EAEhB;AACJ;AACA;EACIC,WAAW,GAAG;IAEV;AACR;AACA;AACA;AACA;IACQ,KAAKC,UAAL,GAAkB,IAAIC,OAAJ,EAAlB;EACH;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;EACIC,QAAQ,CAAClB,MAAD,EAAS;IAEb,IAAI,CAACA,MAAM,CAACQ,KAAZ,EAAmB;MACf;IACH;;IAED,KAAK,MAAM,CAACL,MAAD,EAASgB,WAAT,CAAX,IAAoCR,MAAM,CAACC,OAAP,CAAeZ,MAAM,CAACQ,KAAtB,CAApC,EAAkE;MAE9D;MACA,IAAIL,MAAM,KAAK,WAAf,EAA4B;QACxB;MACH;MAED;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;MACY,IAAIgB,WAAW,CAAC,CAAD,CAAX,KAAmB,CAAvB,EAA0B;QACtB;MACH;;MAED,MAAMC,IAAI,GAAGxB,iBAAiB,CAACO,MAAD,EAASH,MAAT,CAA9B;;MAEA,IAAI,CAACoB,IAAL,EAAW;QACPrB,sBAAsB,CAACJ,WAAW,CAACQ,MAAD,CAAZ,EAAsBH,MAAtB,CAAtB;MACH,CAxB6D,CA0B9D;;;MACA,IAAI,CAAC,KAAKgB,UAAL,CAAgBK,GAAhB,CAAoBD,IAApB,CAAL,EAAgC;QAC5B,MAAME,MAAM,GAAGzB,oBAAoB,CAACuB,IAAD,CAAnC;;QAEA,IAAIE,MAAJ,EAAY;UACR,KAAKN,UAAL,CAAgBO,GAAhB,CAAoBH,IAApB,EAA0B3B,GAAG,CAAC+B,OAAJ,CAAYF,MAAZ,CAA1B;QACH;MACJ;;MAED,MAAMG,YAAY,GAAG,KAAKT,UAAL,CAAgBU,GAAhB,CAAoBN,IAApB,CAArB;;MAEA,IAAIK,YAAJ,EAAkB;QAEdA,YAAY,CAACN,WAAW,CAACQ,KAAZ,CAAkB,CAAlB,CAAD,CAAZ;;QAEA,IAAIF,YAAY,CAACG,MAAjB,EAAyB;UACrB,MAAM,IAAIC,KAAJ,CAAW,qBAAoB1B,MAAO,MACxCsB,YAAY,CAACG,MAAb,CAAoBE,GAApB,CACIC,KAAK,IAAK,WAAUC,IAAI,CAACC,SAAL,CAAeF,KAAK,CAACG,IAArB,CAA2B,IAAGH,KAAK,CAACI,OAAQ,KADpE,EAEEC,IAFF,CAEO,EAFP,CAGH,EAJK,CAAN;QAKH;MACJ;IACJ;EACJ;;AA/Ee;;AAkFpBC,OAAO,CAACvB,aAAR,GAAwBA,aAAxB"},"metadata":{},"sourceType":"script"}