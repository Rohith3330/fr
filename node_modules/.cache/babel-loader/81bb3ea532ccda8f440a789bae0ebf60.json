{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar isAllowedResource = require('./is-allowed-resource');\n\nvar matchDataUri = require('./match-data-uri');\n\nvar rebaseLocalMap = require('./rebase-local-map');\n\nvar rebaseRemoteMap = require('./rebase-remote-map');\n\nvar Token = require('../tokenizer/token');\n\nvar hasProtocol = require('../utils/has-protocol');\n\nvar isDataUriResource = require('../utils/is-data-uri-resource');\n\nvar isRemoteResource = require('../utils/is-remote-resource');\n\nvar MAP_MARKER_PATTERN = /^\\/\\*# sourceMappingURL=(\\S+) \\*\\/$/;\n\nfunction applySourceMaps(tokens, context, callback) {\n  var applyContext = {\n    callback: callback,\n    fetch: context.options.fetch,\n    index: 0,\n    inline: context.options.inline,\n    inlineRequest: context.options.inlineRequest,\n    inlineTimeout: context.options.inlineTimeout,\n    inputSourceMapTracker: context.inputSourceMapTracker,\n    localOnly: context.localOnly,\n    processedTokens: [],\n    rebaseTo: context.options.rebaseTo,\n    sourceTokens: tokens,\n    warnings: context.warnings\n  };\n  return context.options.sourceMap && tokens.length > 0 ? doApplySourceMaps(applyContext) : callback(tokens);\n}\n\nfunction doApplySourceMaps(applyContext) {\n  var singleSourceTokens = [];\n  var lastSource = findTokenSource(applyContext.sourceTokens[0]);\n  var source;\n  var token;\n  var l;\n\n  for (l = applyContext.sourceTokens.length; applyContext.index < l; applyContext.index++) {\n    token = applyContext.sourceTokens[applyContext.index];\n    source = findTokenSource(token);\n\n    if (source != lastSource) {\n      singleSourceTokens = [];\n      lastSource = source;\n    }\n\n    singleSourceTokens.push(token);\n    applyContext.processedTokens.push(token);\n\n    if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {\n      return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);\n    }\n  }\n\n  return applyContext.callback(applyContext.processedTokens);\n}\n\nfunction findTokenSource(token) {\n  var scope;\n  var metadata;\n\n  if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT || token[0] == Token.RAW) {\n    metadata = token[2][0];\n  } else {\n    scope = token[1][0];\n    metadata = scope[2][0];\n  }\n\n  return metadata[2];\n}\n\nfunction fetchAndApplySourceMap(sourceMapComment, source, singleSourceTokens, applyContext) {\n  return extractInputSourceMapFrom(sourceMapComment, applyContext, function (inputSourceMap) {\n    if (inputSourceMap) {\n      applyContext.inputSourceMapTracker.track(source, inputSourceMap);\n      applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);\n    }\n\n    applyContext.index++;\n    return doApplySourceMaps(applyContext);\n  });\n}\n\nfunction extractInputSourceMapFrom(sourceMapComment, applyContext, whenSourceMapReady) {\n  var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];\n  var absoluteUri;\n  var sourceMap;\n  var rebasedMap;\n\n  if (isDataUriResource(uri)) {\n    sourceMap = extractInputSourceMapFromDataUri(uri);\n    return whenSourceMapReady(sourceMap);\n  }\n\n  if (isRemoteResource(uri)) {\n    return loadInputSourceMapFromRemoteUri(uri, applyContext, function (sourceMap) {\n      var parsedMap;\n\n      if (sourceMap) {\n        parsedMap = JSON.parse(sourceMap);\n        rebasedMap = rebaseRemoteMap(parsedMap, uri);\n        whenSourceMapReady(rebasedMap);\n      } else {\n        whenSourceMapReady(null);\n      }\n    });\n  } // at this point `uri` is already rebased, see lib/reader/rebase.js#rebaseSourceMapComment\n  // it is rebased to be consistent with rebasing other URIs\n  // however here we need to resolve it back to read it from disk\n\n\n  absoluteUri = path.resolve(applyContext.rebaseTo, uri);\n  sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);\n\n  if (sourceMap) {\n    rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);\n    return whenSourceMapReady(rebasedMap);\n  }\n\n  return whenSourceMapReady(null);\n}\n\nfunction extractInputSourceMapFromDataUri(uri) {\n  var dataUriMatch = matchDataUri(uri);\n  var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : 'us-ascii';\n  var encoding = dataUriMatch[3] ? dataUriMatch[3].split(';')[1] : 'utf8';\n  var data = encoding == 'utf8' ? global.unescape(dataUriMatch[4]) : dataUriMatch[4];\n  var buffer = Buffer.from(data, encoding);\n  buffer.charset = charset;\n  return JSON.parse(buffer.toString());\n}\n\nfunction loadInputSourceMapFromRemoteUri(uri, applyContext, whenLoaded) {\n  var isAllowed = isAllowedResource(uri, true, applyContext.inline);\n  var isRuntimeResource = !hasProtocol(uri);\n\n  if (applyContext.localOnly) {\n    applyContext.warnings.push('Cannot fetch remote resource from \"' + uri + '\" as no callback given.');\n    return whenLoaded(null);\n  }\n\n  if (isRuntimeResource) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as no protocol given.');\n    return whenLoaded(null);\n  }\n\n  if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return whenLoaded(null);\n  }\n\n  applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function (error, body) {\n    if (error) {\n      applyContext.warnings.push('Missing source map at \"' + uri + '\" - ' + error);\n      return whenLoaded(null);\n    }\n\n    whenLoaded(body);\n  });\n}\n\nfunction loadInputSourceMapFromLocalUri(uri, applyContext) {\n  var isAllowed = isAllowedResource(uri, false, applyContext.inline);\n  var sourceMap;\n\n  if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {\n    applyContext.warnings.push('Ignoring local source map at \"' + uri + '\" as resource is missing.');\n    return null;\n  }\n\n  if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return null;\n  }\n\n  if (!fs.statSync(uri).size) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is empty.');\n    return null;\n  }\n\n  sourceMap = fs.readFileSync(uri, 'utf-8');\n  return JSON.parse(sourceMap);\n}\n\nfunction applySourceMapRecursively(tokens, inputSourceMapTracker) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n\n      case Token.AT_RULE_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n\n      case Token.AT_RULE_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n\n      case Token.NESTED_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n\n      case Token.NESTED_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n\n      case Token.COMMENT:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n\n      case Token.PROPERTY:\n        applySourceMapRecursively(token, inputSourceMapTracker);\n        break;\n\n      case Token.PROPERTY_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        break;\n\n      case Token.PROPERTY_NAME:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n\n      case Token.PROPERTY_VALUE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n\n      case Token.RULE:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n\n      case Token.RULE_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n    }\n  }\n\n  return tokens;\n}\n\nfunction applySourceMapTo(token, inputSourceMapTracker) {\n  var value = token[1];\n  var metadata = token[2];\n  var newMetadata = [];\n  var i, l;\n\n  for (i = 0, l = metadata.length; i < l; i++) {\n    newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));\n  }\n\n  token[2] = newMetadata;\n}\n\nmodule.exports = applySourceMaps;","map":{"version":3,"names":["fs","require","path","isAllowedResource","matchDataUri","rebaseLocalMap","rebaseRemoteMap","Token","hasProtocol","isDataUriResource","isRemoteResource","MAP_MARKER_PATTERN","applySourceMaps","tokens","context","callback","applyContext","fetch","options","index","inline","inlineRequest","inlineTimeout","inputSourceMapTracker","localOnly","processedTokens","rebaseTo","sourceTokens","warnings","sourceMap","length","doApplySourceMaps","singleSourceTokens","lastSource","findTokenSource","source","token","l","push","COMMENT","test","fetchAndApplySourceMap","scope","metadata","AT_RULE","RAW","sourceMapComment","extractInputSourceMapFrom","inputSourceMap","track","applySourceMapRecursively","whenSourceMapReady","uri","exec","absoluteUri","rebasedMap","extractInputSourceMapFromDataUri","loadInputSourceMapFromRemoteUri","parsedMap","JSON","parse","resolve","loadInputSourceMapFromLocalUri","dataUriMatch","charset","split","encoding","data","global","unescape","buffer","Buffer","from","toString","whenLoaded","isAllowed","isRuntimeResource","error","body","existsSync","statSync","isFile","size","readFileSync","i","applySourceMapTo","AT_RULE_BLOCK","AT_RULE_BLOCK_SCOPE","NESTED_BLOCK","NESTED_BLOCK_SCOPE","PROPERTY","PROPERTY_BLOCK","PROPERTY_NAME","PROPERTY_VALUE","RULE","RULE_SCOPE","value","newMetadata","originalPositionFor","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/clean-css/lib/reader/apply-source-maps.js"],"sourcesContent":["var fs = require('fs');\nvar path = require('path');\n\nvar isAllowedResource = require('./is-allowed-resource');\nvar matchDataUri = require('./match-data-uri');\nvar rebaseLocalMap = require('./rebase-local-map');\nvar rebaseRemoteMap = require('./rebase-remote-map');\n\nvar Token = require('../tokenizer/token');\nvar hasProtocol = require('../utils/has-protocol');\nvar isDataUriResource = require('../utils/is-data-uri-resource');\nvar isRemoteResource = require('../utils/is-remote-resource');\n\nvar MAP_MARKER_PATTERN = /^\\/\\*# sourceMappingURL=(\\S+) \\*\\/$/;\n\nfunction applySourceMaps(tokens, context, callback) {\n  var applyContext = {\n    callback: callback,\n    fetch: context.options.fetch,\n    index: 0,\n    inline: context.options.inline,\n    inlineRequest: context.options.inlineRequest,\n    inlineTimeout: context.options.inlineTimeout,\n    inputSourceMapTracker: context.inputSourceMapTracker,\n    localOnly: context.localOnly,\n    processedTokens: [],\n    rebaseTo: context.options.rebaseTo,\n    sourceTokens: tokens,\n    warnings: context.warnings\n  };\n\n  return context.options.sourceMap && tokens.length > 0\n    ? doApplySourceMaps(applyContext)\n    : callback(tokens);\n}\n\nfunction doApplySourceMaps(applyContext) {\n  var singleSourceTokens = [];\n  var lastSource = findTokenSource(applyContext.sourceTokens[0]);\n  var source;\n  var token;\n  var l;\n\n  for (l = applyContext.sourceTokens.length; applyContext.index < l; applyContext.index++) {\n    token = applyContext.sourceTokens[applyContext.index];\n    source = findTokenSource(token);\n\n    if (source != lastSource) {\n      singleSourceTokens = [];\n      lastSource = source;\n    }\n\n    singleSourceTokens.push(token);\n    applyContext.processedTokens.push(token);\n\n    if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {\n      return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);\n    }\n  }\n\n  return applyContext.callback(applyContext.processedTokens);\n}\n\nfunction findTokenSource(token) {\n  var scope;\n  var metadata;\n\n  if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT || token[0] == Token.RAW) {\n    metadata = token[2][0];\n  } else {\n    scope = token[1][0];\n    metadata = scope[2][0];\n  }\n\n  return metadata[2];\n}\n\nfunction fetchAndApplySourceMap(sourceMapComment, source, singleSourceTokens, applyContext) {\n  return extractInputSourceMapFrom(sourceMapComment, applyContext, function(inputSourceMap) {\n    if (inputSourceMap) {\n      applyContext.inputSourceMapTracker.track(source, inputSourceMap);\n      applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);\n    }\n\n    applyContext.index++;\n    return doApplySourceMaps(applyContext);\n  });\n}\n\nfunction extractInputSourceMapFrom(sourceMapComment, applyContext, whenSourceMapReady) {\n  var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];\n  var absoluteUri;\n  var sourceMap;\n  var rebasedMap;\n\n  if (isDataUriResource(uri)) {\n    sourceMap = extractInputSourceMapFromDataUri(uri);\n    return whenSourceMapReady(sourceMap);\n  } if (isRemoteResource(uri)) {\n    return loadInputSourceMapFromRemoteUri(uri, applyContext, function(sourceMap) {\n      var parsedMap;\n\n      if (sourceMap) {\n        parsedMap = JSON.parse(sourceMap);\n        rebasedMap = rebaseRemoteMap(parsedMap, uri);\n        whenSourceMapReady(rebasedMap);\n      } else {\n        whenSourceMapReady(null);\n      }\n    });\n  }\n  // at this point `uri` is already rebased, see lib/reader/rebase.js#rebaseSourceMapComment\n  // it is rebased to be consistent with rebasing other URIs\n  // however here we need to resolve it back to read it from disk\n  absoluteUri = path.resolve(applyContext.rebaseTo, uri);\n  sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);\n\n  if (sourceMap) {\n    rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);\n    return whenSourceMapReady(rebasedMap);\n  }\n  return whenSourceMapReady(null);\n}\n\nfunction extractInputSourceMapFromDataUri(uri) {\n  var dataUriMatch = matchDataUri(uri);\n  var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : 'us-ascii';\n  var encoding = dataUriMatch[3] ? dataUriMatch[3].split(';')[1] : 'utf8';\n  var data = encoding == 'utf8' ? global.unescape(dataUriMatch[4]) : dataUriMatch[4];\n\n  var buffer = Buffer.from(data, encoding);\n  buffer.charset = charset;\n\n  return JSON.parse(buffer.toString());\n}\n\nfunction loadInputSourceMapFromRemoteUri(uri, applyContext, whenLoaded) {\n  var isAllowed = isAllowedResource(uri, true, applyContext.inline);\n  var isRuntimeResource = !hasProtocol(uri);\n\n  if (applyContext.localOnly) {\n    applyContext.warnings.push('Cannot fetch remote resource from \"' + uri + '\" as no callback given.');\n    return whenLoaded(null);\n  } if (isRuntimeResource) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as no protocol given.');\n    return whenLoaded(null);\n  } if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return whenLoaded(null);\n  }\n\n  applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function(error, body) {\n    if (error) {\n      applyContext.warnings.push('Missing source map at \"' + uri + '\" - ' + error);\n      return whenLoaded(null);\n    }\n\n    whenLoaded(body);\n  });\n}\n\nfunction loadInputSourceMapFromLocalUri(uri, applyContext) {\n  var isAllowed = isAllowedResource(uri, false, applyContext.inline);\n  var sourceMap;\n\n  if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {\n    applyContext.warnings.push('Ignoring local source map at \"' + uri + '\" as resource is missing.');\n    return null;\n  } if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return null;\n  } if (!fs.statSync(uri).size) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is empty.');\n    return null;\n  }\n\n  sourceMap = fs.readFileSync(uri, 'utf-8');\n  return JSON.parse(sourceMap);\n}\n\nfunction applySourceMapRecursively(tokens, inputSourceMapTracker) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    switch (token[0]) {\n    case Token.AT_RULE:\n      applySourceMapTo(token, inputSourceMapTracker);\n      break;\n    case Token.AT_RULE_BLOCK:\n      applySourceMapRecursively(token[1], inputSourceMapTracker);\n      applySourceMapRecursively(token[2], inputSourceMapTracker);\n      break;\n    case Token.AT_RULE_BLOCK_SCOPE:\n      applySourceMapTo(token, inputSourceMapTracker);\n      break;\n    case Token.NESTED_BLOCK:\n      applySourceMapRecursively(token[1], inputSourceMapTracker);\n      applySourceMapRecursively(token[2], inputSourceMapTracker);\n      break;\n    case Token.NESTED_BLOCK_SCOPE:\n      applySourceMapTo(token, inputSourceMapTracker);\n      break;\n    case Token.COMMENT:\n      applySourceMapTo(token, inputSourceMapTracker);\n      break;\n    case Token.PROPERTY:\n      applySourceMapRecursively(token, inputSourceMapTracker);\n      break;\n    case Token.PROPERTY_BLOCK:\n      applySourceMapRecursively(token[1], inputSourceMapTracker);\n      break;\n    case Token.PROPERTY_NAME:\n      applySourceMapTo(token, inputSourceMapTracker);\n      break;\n    case Token.PROPERTY_VALUE:\n      applySourceMapTo(token, inputSourceMapTracker);\n      break;\n    case Token.RULE:\n      applySourceMapRecursively(token[1], inputSourceMapTracker);\n      applySourceMapRecursively(token[2], inputSourceMapTracker);\n      break;\n    case Token.RULE_SCOPE:\n      applySourceMapTo(token, inputSourceMapTracker);\n    }\n  }\n\n  return tokens;\n}\n\nfunction applySourceMapTo(token, inputSourceMapTracker) {\n  var value = token[1];\n  var metadata = token[2];\n  var newMetadata = [];\n  var i, l;\n\n  for (i = 0, l = metadata.length; i < l; i++) {\n    newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));\n  }\n\n  token[2] = newMetadata;\n}\n\nmodule.exports = applySourceMaps;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}