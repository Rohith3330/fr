{"ast":null,"code":"/**\n * @fileoverview Report missing `key` props in iterators/collection literals.\n * @author Ben Mosher\n */\n'use strict';\n\nconst hasProp = require('jsx-ast-utils/hasProp');\n\nconst propName = require('jsx-ast-utils/propName');\n\nconst values = require('object.values');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst pragmaUtil = require('../util/pragma');\n\nconst report = require('../util/report');\n\nconst astUtil = require('../util/ast'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst defaultOptions = {\n  checkFragmentShorthand: false,\n  checkKeyMustBeforeSpread: false,\n  warnOnDuplicates: false\n};\nconst messages = {\n  missingIterKey: 'Missing \"key\" prop for element in iterator',\n  missingIterKeyUsePrag: 'Missing \"key\" prop for element in iterator. Shorthand fragment syntax does not support providing keys. Use {{reactPrag}}.{{fragPrag}} instead',\n  missingArrayKey: 'Missing \"key\" prop for element in array',\n  missingArrayKeyUsePrag: 'Missing \"key\" prop for element in array. Shorthand fragment syntax does not support providing keys. Use {{reactPrag}}.{{fragPrag}} instead',\n  keyBeforeSpread: '`key` prop must be placed before any `{...spread}, to avoid conflicting with React’s new JSX transform: https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html`',\n  nonUniqueKeys: '`key` prop must be unique'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow missing `key` props in iterators/collection literals',\n      category: 'Possible Errors',\n      recommended: true,\n      url: docsUrl('jsx-key')\n    },\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        checkFragmentShorthand: {\n          type: 'boolean',\n          default: defaultOptions.checkFragmentShorthand\n        },\n        checkKeyMustBeforeSpread: {\n          type: 'boolean',\n          default: defaultOptions.checkKeyMustBeforeSpread\n        },\n        warnOnDuplicates: {\n          type: 'boolean',\n          default: defaultOptions.warnOnDuplicates\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const options = Object.assign({}, defaultOptions, context.options[0]);\n    const checkFragmentShorthand = options.checkFragmentShorthand;\n    const checkKeyMustBeforeSpread = options.checkKeyMustBeforeSpread;\n    const warnOnDuplicates = options.warnOnDuplicates;\n    const reactPragma = pragmaUtil.getFromContext(context);\n    const fragmentPragma = pragmaUtil.getFragmentFromContext(context);\n\n    function checkIteratorElement(node) {\n      if (node.type === 'JSXElement' && !hasProp(node.openingElement.attributes, 'key')) {\n        report(context, messages.missingIterKey, 'missingIterKey', {\n          node\n        });\n      } else if (checkFragmentShorthand && node.type === 'JSXFragment') {\n        report(context, messages.missingIterKeyUsePrag, 'missingIterKeyUsePrag', {\n          node,\n          data: {\n            reactPrag: reactPragma,\n            fragPrag: fragmentPragma\n          }\n        });\n      }\n    }\n\n    function getReturnStatements(node) {\n      const returnStatements = arguments[1] || [];\n\n      if (node.type === 'IfStatement') {\n        if (node.consequent) {\n          getReturnStatements(node.consequent, returnStatements);\n        }\n\n        if (node.alternate) {\n          getReturnStatements(node.alternate, returnStatements);\n        }\n      } else if (Array.isArray(node.body)) {\n        node.body.forEach(item => {\n          if (item.type === 'IfStatement') {\n            getReturnStatements(item, returnStatements);\n          }\n\n          if (item.type === 'ReturnStatement') {\n            returnStatements.push(item);\n          }\n        });\n      }\n\n      return returnStatements;\n    }\n\n    function isKeyAfterSpread(attributes) {\n      let hasFoundSpread = false;\n      return attributes.some(attribute => {\n        if (attribute.type === 'JSXSpreadAttribute') {\n          hasFoundSpread = true;\n          return false;\n        }\n\n        if (attribute.type !== 'JSXAttribute') {\n          return false;\n        }\n\n        return hasFoundSpread && propName(attribute) === 'key';\n      });\n    }\n    /**\n     * Checks if the given node is a function expression or arrow function,\n     * and checks if there is a missing key prop in return statement's arguments\n     * @param {ASTNode} node\n     */\n\n\n    function checkFunctionsBlockStatement(node) {\n      if (astUtil.isFunctionLikeExpression(node)) {\n        if (node.body.type === 'BlockStatement') {\n          getReturnStatements(node.body).filter(returnStatement => returnStatement && returnStatement.argument).forEach(returnStatement => {\n            checkIteratorElement(returnStatement.argument);\n          });\n        }\n      }\n    }\n    /**\n     * Checks if the given node is an arrow function that has an JSX Element or JSX Fragment in its body,\n     * and the JSX is missing a key prop\n     * @param {ASTNode} node\n     */\n\n\n    function checkArrowFunctionWithJSX(node) {\n      const isArrFn = node && node.type === 'ArrowFunctionExpression';\n\n      if (isArrFn && (node.body.type === 'JSXElement' || node.body.type === 'JSXFragment')) {\n        checkIteratorElement(node.body);\n      }\n    }\n\n    const seen = new WeakSet();\n    return {\n      'ArrayExpression, JSXElement > JSXElement'(node) {\n        const jsx = (node.type === 'ArrayExpression' ? node.elements : node.parent.children).filter(x => x && x.type === 'JSXElement');\n\n        if (jsx.length === 0) {\n          return;\n        }\n\n        const map = {};\n        jsx.forEach(element => {\n          const attrs = element.openingElement.attributes;\n          const keys = attrs.filter(x => x.name && x.name.name === 'key');\n\n          if (keys.length === 0) {\n            if (node.type === 'ArrayExpression') {\n              report(context, messages.missingArrayKey, 'missingArrayKey', {\n                node: element\n              });\n            }\n          } else {\n            keys.forEach(attr => {\n              const value = context.getSourceCode().getText(attr.value);\n\n              if (!map[value]) {\n                map[value] = [];\n              }\n\n              map[value].push(attr);\n\n              if (checkKeyMustBeforeSpread && isKeyAfterSpread(attrs)) {\n                report(context, messages.keyBeforeSpread, 'keyBeforeSpread', {\n                  node: node.type === 'ArrayExpression' ? node : node.parent\n                });\n              }\n            });\n          }\n        });\n\n        if (warnOnDuplicates) {\n          values(map).filter(v => v.length > 1).forEach(v => {\n            v.forEach(n => {\n              if (!seen.has(n)) {\n                seen.add(n);\n                report(context, messages.nonUniqueKeys, 'nonUniqueKeys', {\n                  node: n\n                });\n              }\n            });\n          });\n        }\n      },\n\n      JSXFragment(node) {\n        if (!checkFragmentShorthand) {\n          return;\n        }\n\n        if (node.parent.type === 'ArrayExpression') {\n          report(context, messages.missingArrayKeyUsePrag, 'missingArrayKeyUsePrag', {\n            node,\n            data: {\n              reactPrag: reactPragma,\n              fragPrag: fragmentPragma\n            }\n          });\n        }\n      },\n\n      // Array.prototype.map\n      // eslint-disable-next-line no-multi-str\n      'CallExpression[callee.type=\"MemberExpression\"][callee.property.name=\"map\"],\\\n       CallExpression[callee.type=\"OptionalMemberExpression\"][callee.property.name=\"map\"],\\\n       OptionalCallExpression[callee.type=\"MemberExpression\"][callee.property.name=\"map\"],\\\n       OptionalCallExpression[callee.type=\"OptionalMemberExpression\"][callee.property.name=\"map\"]'(node) {\n        const fn = node.arguments.length > 0 && node.arguments[0];\n\n        if (!fn || !astUtil.isFunctionLikeExpression(fn)) {\n          return;\n        }\n\n        checkArrowFunctionWithJSX(fn);\n        checkFunctionsBlockStatement(fn);\n      },\n\n      // Array.from\n      'CallExpression[callee.type=\"MemberExpression\"][callee.property.name=\"from\"]'(node) {\n        const fn = node.arguments.length > 1 && node.arguments[1];\n\n        if (!astUtil.isFunctionLikeExpression(fn)) {\n          return;\n        }\n\n        checkArrowFunctionWithJSX(fn);\n        checkFunctionsBlockStatement(fn);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["hasProp","require","propName","values","docsUrl","pragmaUtil","report","astUtil","defaultOptions","checkFragmentShorthand","checkKeyMustBeforeSpread","warnOnDuplicates","messages","missingIterKey","missingIterKeyUsePrag","missingArrayKey","missingArrayKeyUsePrag","keyBeforeSpread","nonUniqueKeys","module","exports","meta","docs","description","category","recommended","url","schema","type","properties","default","additionalProperties","create","context","options","Object","assign","reactPragma","getFromContext","fragmentPragma","getFragmentFromContext","checkIteratorElement","node","openingElement","attributes","data","reactPrag","fragPrag","getReturnStatements","returnStatements","arguments","consequent","alternate","Array","isArray","body","forEach","item","push","isKeyAfterSpread","hasFoundSpread","some","attribute","checkFunctionsBlockStatement","isFunctionLikeExpression","filter","returnStatement","argument","checkArrowFunctionWithJSX","isArrFn","seen","WeakSet","jsx","elements","parent","children","x","length","map","element","attrs","keys","name","attr","value","getSourceCode","getText","v","n","has","add","JSXFragment","fn"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-key.js"],"sourcesContent":["/**\n * @fileoverview Report missing `key` props in iterators/collection literals.\n * @author Ben Mosher\n */\n\n'use strict';\n\nconst hasProp = require('jsx-ast-utils/hasProp');\nconst propName = require('jsx-ast-utils/propName');\nconst values = require('object.values');\nconst docsUrl = require('../util/docsUrl');\nconst pragmaUtil = require('../util/pragma');\nconst report = require('../util/report');\nconst astUtil = require('../util/ast');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst defaultOptions = {\n  checkFragmentShorthand: false,\n  checkKeyMustBeforeSpread: false,\n  warnOnDuplicates: false,\n};\n\nconst messages = {\n  missingIterKey: 'Missing \"key\" prop for element in iterator',\n  missingIterKeyUsePrag: 'Missing \"key\" prop for element in iterator. Shorthand fragment syntax does not support providing keys. Use {{reactPrag}}.{{fragPrag}} instead',\n  missingArrayKey: 'Missing \"key\" prop for element in array',\n  missingArrayKeyUsePrag: 'Missing \"key\" prop for element in array. Shorthand fragment syntax does not support providing keys. Use {{reactPrag}}.{{fragPrag}} instead',\n  keyBeforeSpread: '`key` prop must be placed before any `{...spread}, to avoid conflicting with React’s new JSX transform: https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html`',\n  nonUniqueKeys: '`key` prop must be unique',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow missing `key` props in iterators/collection literals',\n      category: 'Possible Errors',\n      recommended: true,\n      url: docsUrl('jsx-key'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        checkFragmentShorthand: {\n          type: 'boolean',\n          default: defaultOptions.checkFragmentShorthand,\n        },\n        checkKeyMustBeforeSpread: {\n          type: 'boolean',\n          default: defaultOptions.checkKeyMustBeforeSpread,\n        },\n        warnOnDuplicates: {\n          type: 'boolean',\n          default: defaultOptions.warnOnDuplicates,\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create(context) {\n    const options = Object.assign({}, defaultOptions, context.options[0]);\n    const checkFragmentShorthand = options.checkFragmentShorthand;\n    const checkKeyMustBeforeSpread = options.checkKeyMustBeforeSpread;\n    const warnOnDuplicates = options.warnOnDuplicates;\n    const reactPragma = pragmaUtil.getFromContext(context);\n    const fragmentPragma = pragmaUtil.getFragmentFromContext(context);\n\n    function checkIteratorElement(node) {\n      if (node.type === 'JSXElement' && !hasProp(node.openingElement.attributes, 'key')) {\n        report(context, messages.missingIterKey, 'missingIterKey', {\n          node,\n        });\n      } else if (checkFragmentShorthand && node.type === 'JSXFragment') {\n        report(context, messages.missingIterKeyUsePrag, 'missingIterKeyUsePrag', {\n          node,\n          data: {\n            reactPrag: reactPragma,\n            fragPrag: fragmentPragma,\n          },\n        });\n      }\n    }\n\n    function getReturnStatements(node) {\n      const returnStatements = arguments[1] || [];\n      if (node.type === 'IfStatement') {\n        if (node.consequent) {\n          getReturnStatements(node.consequent, returnStatements);\n        }\n        if (node.alternate) {\n          getReturnStatements(node.alternate, returnStatements);\n        }\n      } else if (Array.isArray(node.body)) {\n        node.body.forEach((item) => {\n          if (item.type === 'IfStatement') {\n            getReturnStatements(item, returnStatements);\n          }\n\n          if (item.type === 'ReturnStatement') {\n            returnStatements.push(item);\n          }\n        });\n      }\n\n      return returnStatements;\n    }\n\n    function isKeyAfterSpread(attributes) {\n      let hasFoundSpread = false;\n      return attributes.some((attribute) => {\n        if (attribute.type === 'JSXSpreadAttribute') {\n          hasFoundSpread = true;\n          return false;\n        }\n        if (attribute.type !== 'JSXAttribute') {\n          return false;\n        }\n        return hasFoundSpread && propName(attribute) === 'key';\n      });\n    }\n\n    /**\n     * Checks if the given node is a function expression or arrow function,\n     * and checks if there is a missing key prop in return statement's arguments\n     * @param {ASTNode} node\n     */\n    function checkFunctionsBlockStatement(node) {\n      if (astUtil.isFunctionLikeExpression(node)) {\n        if (node.body.type === 'BlockStatement') {\n          getReturnStatements(node.body)\n            .filter((returnStatement) => returnStatement && returnStatement.argument)\n            .forEach((returnStatement) => {\n              checkIteratorElement(returnStatement.argument);\n            });\n        }\n      }\n    }\n\n    /**\n     * Checks if the given node is an arrow function that has an JSX Element or JSX Fragment in its body,\n     * and the JSX is missing a key prop\n     * @param {ASTNode} node\n     */\n    function checkArrowFunctionWithJSX(node) {\n      const isArrFn = node && node.type === 'ArrowFunctionExpression';\n\n      if (isArrFn && (node.body.type === 'JSXElement' || node.body.type === 'JSXFragment')) {\n        checkIteratorElement(node.body);\n      }\n    }\n\n    const seen = new WeakSet();\n\n    return {\n      'ArrayExpression, JSXElement > JSXElement'(node) {\n        const jsx = (node.type === 'ArrayExpression' ? node.elements : node.parent.children).filter((x) => x && x.type === 'JSXElement');\n        if (jsx.length === 0) {\n          return;\n        }\n\n        const map = {};\n        jsx.forEach((element) => {\n          const attrs = element.openingElement.attributes;\n          const keys = attrs.filter((x) => x.name && x.name.name === 'key');\n\n          if (keys.length === 0) {\n            if (node.type === 'ArrayExpression') {\n              report(context, messages.missingArrayKey, 'missingArrayKey', {\n                node: element,\n              });\n            }\n          } else {\n            keys.forEach((attr) => {\n              const value = context.getSourceCode().getText(attr.value);\n              if (!map[value]) { map[value] = []; }\n              map[value].push(attr);\n\n              if (checkKeyMustBeforeSpread && isKeyAfterSpread(attrs)) {\n                report(context, messages.keyBeforeSpread, 'keyBeforeSpread', {\n                  node: node.type === 'ArrayExpression' ? node : node.parent,\n                });\n              }\n            });\n          }\n        });\n\n        if (warnOnDuplicates) {\n          values(map).filter((v) => v.length > 1).forEach((v) => {\n            v.forEach((n) => {\n              if (!seen.has(n)) {\n                seen.add(n);\n                report(context, messages.nonUniqueKeys, 'nonUniqueKeys', {\n                  node: n,\n                });\n              }\n            });\n          });\n        }\n      },\n\n      JSXFragment(node) {\n        if (!checkFragmentShorthand) {\n          return;\n        }\n\n        if (node.parent.type === 'ArrayExpression') {\n          report(context, messages.missingArrayKeyUsePrag, 'missingArrayKeyUsePrag', {\n            node,\n            data: {\n              reactPrag: reactPragma,\n              fragPrag: fragmentPragma,\n            },\n          });\n        }\n      },\n\n      // Array.prototype.map\n      // eslint-disable-next-line no-multi-str\n      'CallExpression[callee.type=\"MemberExpression\"][callee.property.name=\"map\"],\\\n       CallExpression[callee.type=\"OptionalMemberExpression\"][callee.property.name=\"map\"],\\\n       OptionalCallExpression[callee.type=\"MemberExpression\"][callee.property.name=\"map\"],\\\n       OptionalCallExpression[callee.type=\"OptionalMemberExpression\"][callee.property.name=\"map\"]'(node) {\n        const fn = node.arguments.length > 0 && node.arguments[0];\n        if (!fn || !astUtil.isFunctionLikeExpression(fn)) {\n          return;\n        }\n\n        checkArrowFunctionWithJSX(fn);\n\n        checkFunctionsBlockStatement(fn);\n      },\n\n      // Array.from\n      'CallExpression[callee.type=\"MemberExpression\"][callee.property.name=\"from\"]'(node) {\n        const fn = node.arguments.length > 1 && node.arguments[1];\n        if (!astUtil.isFunctionLikeExpression(fn)) {\n          return;\n        }\n\n        checkArrowFunctionWithJSX(fn);\n\n        checkFunctionsBlockStatement(fn);\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}