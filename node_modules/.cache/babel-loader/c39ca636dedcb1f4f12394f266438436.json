{"ast":null,"code":"import fs from 'fs';\nimport url from 'url';\nimport postcss from 'postcss';\nimport dlv from 'dlv';\nimport selectorParser from 'postcss-selector-parser';\nimport { flagEnabled } from '../featureFlags.js';\nimport transformThemeValue from '../util/transformThemeValue';\nimport parseObjectStyles from '../util/parseObjectStyles';\nimport prefixSelector from '../util/prefixSelector';\nimport isPlainObject from '../util/isPlainObject';\nimport escapeClassName from '../util/escapeClassName';\nimport nameClass, { formatClass } from '../util/nameClass';\nimport { coerceValue } from '../util/pluginUtils';\nimport bigSign from '../util/bigSign';\nimport { variantPlugins, corePlugins } from '../corePlugins';\nimport * as sharedState from './sharedState';\nimport { env } from './sharedState';\nimport { toPath } from '../util/toPath';\nimport log from '../util/log';\nimport negateValue from '../util/negateValue';\nimport isValidArbitraryValue from '../util/isValidArbitraryValue';\nimport { generateRules } from './generateRules';\nimport { hasContentChanged } from './cacheInvalidation.js';\nlet MATCH_VARIANT = Symbol();\n\nfunction prefix(context, selector) {\n  let prefix = context.tailwindConfig.prefix;\n  return typeof prefix === 'function' ? prefix(selector) : prefix + selector;\n}\n\nfunction parseVariantFormatString(input) {\n  if (input.includes('{')) {\n    if (!isBalanced(input)) throw new Error(`Your { and } are unbalanced.`);\n    return input.split(/{(.*)}/gim).flatMap(line => parseVariantFormatString(line)).filter(Boolean);\n  }\n\n  return [input.trim()];\n}\n\nfunction isBalanced(input) {\n  let count = 0;\n\n  for (let char of input) {\n    if (char === '{') {\n      count++;\n    } else if (char === '}') {\n      if (--count < 0) {\n        return false; // unbalanced\n      }\n    }\n  }\n\n  return count === 0;\n}\n\nfunction insertInto(list, value) {\n  let {\n    before = []\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  before = [].concat(before);\n\n  if (before.length <= 0) {\n    list.push(value);\n    return;\n  }\n\n  let idx = list.length - 1;\n\n  for (let other of before) {\n    let iidx = list.indexOf(other);\n    if (iidx === -1) continue;\n    idx = Math.min(idx, iidx);\n  }\n\n  list.splice(idx, 0, value);\n}\n\nfunction parseStyles(styles) {\n  if (!Array.isArray(styles)) {\n    return parseStyles([styles]);\n  }\n\n  return styles.flatMap(style => {\n    let isNode = !Array.isArray(style) && !isPlainObject(style);\n    return isNode ? style : parseObjectStyles(style);\n  });\n}\n\nfunction getClasses(selector, mutate) {\n  let parser = selectorParser(selectors => {\n    let allClasses = [];\n\n    if (mutate) {\n      mutate(selectors);\n    }\n\n    selectors.walkClasses(classNode => {\n      allClasses.push(classNode.value);\n    });\n    return allClasses;\n  });\n  return parser.transformSync(selector);\n}\n\nfunction extractCandidates(node) {\n  let state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    containsNonOnDemandable: false\n  };\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let classes = []; // Handle normal rules\n\n  if (node.type === 'rule') {\n    // Ignore everything inside a :not(...). This allows you to write code like\n    // `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n    // not generated it. But now we will ignore everything inside a `:not`, so\n    // that it still gets generated.\n    function ignoreNot(selectors) {\n      selectors.walkPseudos(pseudo => {\n        if (pseudo.value === ':not') {\n          pseudo.remove();\n        }\n      });\n    }\n\n    for (let selector of node.selectors) {\n      let classCandidates = getClasses(selector, ignoreNot); // At least one of the selectors contains non-\"on-demandable\" candidates.\n\n      if (classCandidates.length === 0) {\n        state.containsNonOnDemandable = true;\n      }\n\n      for (let classCandidate of classCandidates) {\n        classes.push(classCandidate);\n      }\n    }\n  } // Handle at-rules (which contains nested rules)\n  else if (node.type === 'atrule') {\n    node.walkRules(rule => {\n      for (let classCandidate of rule.selectors.flatMap(selector => getClasses(selector))) {\n        classes.push(classCandidate);\n      }\n    });\n  }\n\n  if (depth === 0) {\n    return [state.containsNonOnDemandable || classes.length === 0, classes];\n  }\n\n  return classes;\n}\n\nfunction withIdentifiers(styles) {\n  return parseStyles(styles).flatMap(node => {\n    let nodeMap = new Map();\n    let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node); // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n\n    if (containsNonOnDemandableSelectors) {\n      candidates.unshift(sharedState.NOT_ON_DEMAND);\n    } // However, it could be that it also contains \"on-demandable\" candidates.\n    // E.g.: `span, .foo {}`, in that case it should still be possible to use\n    // `@apply foo` for example.\n\n\n    return candidates.map(c => {\n      if (!nodeMap.has(node)) {\n        nodeMap.set(node, node);\n      }\n\n      return [c, nodeMap.get(node)];\n    });\n  });\n}\n\nexport function isValidVariantFormatString(format) {\n  return format.startsWith('@') || format.includes('&');\n}\nexport function parseVariant(variant) {\n  variant = variant.replace(/\\n+/g, '').replace(/\\s{1,}/g, ' ').trim();\n  let fns = parseVariantFormatString(variant).map(str => {\n    if (!str.startsWith('@')) {\n      return _ref => {\n        let {\n          format\n        } = _ref;\n        return format(str);\n      };\n    }\n\n    let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);\n    return _ref2 => {\n      let {\n        wrap\n      } = _ref2;\n      return wrap(postcss.atRule({\n        name,\n        params: params.trim()\n      }));\n    };\n  }).reverse();\n  return api => {\n    for (let fn of fns) {\n      fn(api);\n    }\n  };\n}\n\nfunction buildPluginApi(tailwindConfig, context, _ref3) {\n  let {\n    variantList,\n    variantMap,\n    offsets,\n    classList\n  } = _ref3;\n\n  function getConfigValue(path, defaultValue) {\n    return path ? dlv(tailwindConfig, path, defaultValue) : tailwindConfig;\n  }\n\n  function applyConfiguredPrefix(selector) {\n    return prefixSelector(tailwindConfig.prefix, selector);\n  }\n\n  function prefixIdentifier(identifier, options) {\n    if (identifier === sharedState.NOT_ON_DEMAND) {\n      return sharedState.NOT_ON_DEMAND;\n    }\n\n    if (!options.respectPrefix) {\n      return identifier;\n    }\n\n    return context.tailwindConfig.prefix + identifier;\n  }\n\n  function resolveThemeValue(path, defaultValue) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const [pathRoot, ...subPaths] = toPath(path);\n    const value = getConfigValue(['theme', pathRoot, ...subPaths], defaultValue);\n    return transformThemeValue(pathRoot)(value, opts);\n  }\n\n  const theme = Object.assign(function (path) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    return resolveThemeValue(path, defaultValue);\n  }, {\n    withAlpha: (path, opacityValue) => resolveThemeValue(path, undefined, {\n      opacityValue\n    })\n  });\n  let api = {\n    postcss,\n    prefix: applyConfiguredPrefix,\n    e: escapeClassName,\n    config: getConfigValue,\n    theme,\n    corePlugins: path => {\n      if (Array.isArray(tailwindConfig.corePlugins)) {\n        return tailwindConfig.corePlugins.includes(path);\n      }\n\n      return getConfigValue(['corePlugins', path], true);\n    },\n    variants: () => {\n      // Preserved for backwards compatibility but not used in v3.0+\n      return [];\n    },\n\n    addBase(base) {\n      for (let [identifier, rule] of withIdentifiers(base)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n        let offset = offsets.base++;\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: 'base'\n        }, rule]);\n      }\n    },\n\n    /**\n     * @param {string} group\n     * @param {Record<string, string | string[]>} declarations\n     */\n    addDefaults(group, declarations) {\n      const groups = {\n        [`@defaults ${group}`]: declarations\n      };\n\n      for (let [identifier, rule] of withIdentifiers(groups)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.base++,\n          layer: 'defaults'\n        }, rule]);\n      }\n    },\n\n    addComponents(components, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: false\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n\n      for (let [identifier, rule] of withIdentifiers(components)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        classList.add(prefixedIdentifier);\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.components++,\n          layer: 'components',\n          options\n        }, rule]);\n      }\n    },\n\n    addUtilities(utilities, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: true\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n\n      for (let [identifier, rule] of withIdentifiers(utilities)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        classList.add(prefixedIdentifier);\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.utilities++,\n          layer: 'utilities',\n          options\n        }, rule]);\n      }\n    },\n\n    matchUtilities: function (utilities, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: true\n      };\n      options = { ...defaultOptions,\n        ...options\n      };\n      let offset = offsets.utilities++;\n\n      for (let identifier in utilities) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = utilities[identifier];\n        classList.add([prefixedIdentifier, options]);\n\n        function wrapped(modifier, _ref4) {\n          let {\n            isOnlyPlugin\n          } = _ref4;\n          let {\n            type = 'any'\n          } = options;\n          type = [].concat(type);\n          let [value, coercedType] = coerceValue(type, modifier, options, tailwindConfig);\n\n          if (value === undefined) {\n            return [];\n          }\n\n          if (!type.includes(coercedType) && !isOnlyPlugin) {\n            return [];\n          }\n\n          if (!isValidArbitraryValue(value)) {\n            return [];\n          }\n\n          let ruleSets = [].concat(rule(value)).filter(Boolean).map(declaration => ({\n            [nameClass(identifier, modifier)]: declaration\n          }));\n          return ruleSets;\n        }\n\n        let withOffsets = [{\n          sort: offset,\n          layer: 'utilities',\n          options\n        }, wrapped];\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    },\n    matchComponents: function (components, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: false\n      };\n      options = { ...defaultOptions,\n        ...options\n      };\n      let offset = offsets.components++;\n\n      for (let identifier in components) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = components[identifier];\n        classList.add([prefixedIdentifier, options]);\n\n        function wrapped(modifier, _ref5) {\n          let {\n            isOnlyPlugin\n          } = _ref5;\n          let {\n            type = 'any'\n          } = options;\n          type = [].concat(type);\n          let [value, coercedType] = coerceValue(type, modifier, options, tailwindConfig);\n\n          if (value === undefined) {\n            return [];\n          }\n\n          if (!type.includes(coercedType)) {\n            if (isOnlyPlugin) {\n              log.warn([`Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`, `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + ':', '')}\\`.`]);\n            } else {\n              return [];\n            }\n          }\n\n          if (!isValidArbitraryValue(value)) {\n            return [];\n          }\n\n          let ruleSets = [].concat(rule(value)).filter(Boolean).map(declaration => ({\n            [nameClass(identifier, modifier)]: declaration\n          }));\n          return ruleSets;\n        }\n\n        let withOffsets = [{\n          sort: offset,\n          layer: 'components',\n          options\n        }, wrapped];\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    },\n\n    addVariant(variantName, variantFunctions) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      variantFunctions = [].concat(variantFunctions).map(variantFunction => {\n        if (typeof variantFunction !== 'string') {\n          // Safelist public API functions\n          return api => {\n            let {\n              args,\n              modifySelectors,\n              container,\n              separator,\n              wrap,\n              format\n            } = api;\n            let result = variantFunction(Object.assign({\n              modifySelectors,\n              container,\n              separator\n            }, variantFunction[MATCH_VARIANT] && {\n              args,\n              wrap,\n              format\n            }));\n\n            if (typeof result === 'string' && !isValidVariantFormatString(result)) {\n              throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n            }\n\n            if (Array.isArray(result)) {\n              return result.filter(variant => typeof variant === 'string').map(variant => parseVariant(variant));\n            } // result may be undefined with legacy variants that use APIs like `modifySelectors`\n            // result may also be a postcss node if someone was returning the result from `modifySelectors`\n\n\n            return result && typeof result === 'string' && parseVariant(result)(api);\n          };\n        }\n\n        if (!isValidVariantFormatString(variantFunction)) {\n          throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n        }\n\n        return parseVariant(variantFunction);\n      });\n      insertInto(variantList, variantName, options);\n      variantMap.set(variantName, variantFunctions);\n    }\n\n  };\n\n  if (flagEnabled(tailwindConfig, 'matchVariant')) {\n    api.matchVariant = function (variants, options) {\n      for (let variant in variants) {\n        for (let [k, v] of Object.entries(options?.values ?? {})) {\n          api.addVariant(`${variant}-${k}`, variants[variant](v));\n        }\n\n        api.addVariant(variant, Object.assign(_ref6 => {\n          let {\n            args\n          } = _ref6;\n          return variants[variant](args);\n        }, {\n          [MATCH_VARIANT]: true\n        }), options);\n      }\n    };\n  }\n\n  return api;\n}\n\nlet fileModifiedMapCache = new WeakMap();\nexport function getFileModifiedMap(context) {\n  if (!fileModifiedMapCache.has(context)) {\n    fileModifiedMapCache.set(context, new Map());\n  }\n\n  return fileModifiedMapCache.get(context);\n}\n\nfunction trackModified(files, fileModifiedMap) {\n  let changed = false;\n\n  for (let file of files) {\n    if (!file) continue;\n    let parsed = url.parse(file);\n    let pathname = parsed.hash ? parsed.href.replace(parsed.hash, '') : parsed.href;\n    pathname = parsed.search ? pathname.replace(parsed.search, '') : pathname;\n    let newModified = fs.statSync(decodeURIComponent(pathname), {\n      throwIfNoEntry: false\n    })?.mtimeMs;\n\n    if (!newModified) {\n      // It could happen that a file is passed in that doesn't exist. E.g.:\n      // postcss-cli will provide you a fake path when reading from stdin. This\n      // path then looks like /path-to-your-project/stdin In that case we just\n      // want to ignore it and don't track changes at all.\n      continue;\n    }\n\n    if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n      changed = true;\n    }\n\n    fileModifiedMap.set(file, newModified);\n  }\n\n  return changed;\n}\n\nfunction extractVariantAtRules(node) {\n  node.walkAtRules(atRule => {\n    if (['responsive', 'variants'].includes(atRule.name)) {\n      extractVariantAtRules(atRule);\n      atRule.before(atRule.nodes);\n      atRule.remove();\n    }\n  });\n}\n\nfunction collectLayerPlugins(root) {\n  let layerPlugins = [];\n  root.each(node => {\n    if (node.type === 'atrule' && ['responsive', 'variants'].includes(node.name)) {\n      node.name = 'layer';\n      node.params = 'utilities';\n    }\n  }); // Walk @layer rules and treat them like plugins\n\n  root.walkAtRules('layer', layerRule => {\n    extractVariantAtRules(layerRule);\n\n    if (layerRule.params === 'base') {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function (_ref7) {\n          let {\n            addBase\n          } = _ref7;\n          addBase(node, {\n            respectPrefix: false\n          });\n        });\n      }\n\n      layerRule.remove();\n    } else if (layerRule.params === 'components') {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function (_ref8) {\n          let {\n            addComponents\n          } = _ref8;\n          addComponents(node, {\n            respectPrefix: false,\n            preserveSource: true\n          });\n        });\n      }\n\n      layerRule.remove();\n    } else if (layerRule.params === 'utilities') {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function (_ref9) {\n          let {\n            addUtilities\n          } = _ref9;\n          addUtilities(node, {\n            respectPrefix: false,\n            preserveSource: true\n          });\n        });\n      }\n\n      layerRule.remove();\n    }\n  });\n  return layerPlugins;\n}\n\nfunction resolvePlugins(context, root) {\n  let corePluginList = Object.entries({ ...variantPlugins,\n    ...corePlugins\n  }).map(_ref10 => {\n    let [name, plugin] = _ref10;\n\n    if (!context.tailwindConfig.corePlugins.includes(name)) {\n      return null;\n    }\n\n    return plugin;\n  }).filter(Boolean);\n  let userPlugins = context.tailwindConfig.plugins.map(plugin => {\n    if (plugin.__isOptionsFunction) {\n      plugin = plugin();\n    }\n\n    return typeof plugin === 'function' ? plugin : plugin.handler;\n  });\n  let layerPlugins = collectLayerPlugins(root); // TODO: This is a workaround for backwards compatibility, since custom variants\n  // were historically sorted before screen/stackable variants.\n\n  let beforeVariants = [variantPlugins['pseudoElementVariants'], variantPlugins['pseudoClassVariants']];\n  let afterVariants = [variantPlugins['directionVariants'], variantPlugins['reducedMotionVariants'], variantPlugins['prefersContrastVariants'], variantPlugins['darkVariants'], variantPlugins['printVariant'], variantPlugins['screenVariants'], variantPlugins['orientationVariants']];\n  return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins];\n}\n\nfunction registerPlugins(plugins, context) {\n  let variantList = [];\n  let variantMap = new Map();\n  let offsets = {\n    defaults: 0n,\n    base: 0n,\n    components: 0n,\n    utilities: 0n,\n    user: 0n\n  };\n  let classList = new Set();\n  let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n    variantList,\n    variantMap,\n    offsets,\n    classList\n  });\n\n  for (let plugin of plugins) {\n    if (Array.isArray(plugin)) {\n      for (let pluginItem of plugin) {\n        pluginItem(pluginApi);\n      }\n    } else {\n      plugin?.(pluginApi);\n    }\n  }\n\n  let highestOffset = (args => args.reduce((m, e) => e > m ? e : m))([offsets.base, offsets.defaults, offsets.components, offsets.utilities, offsets.user]);\n\n  let reservedBits = BigInt(highestOffset.toString(2).length); // A number one less than the top range of the highest offset area\n  // so arbitrary properties are always sorted at the end.\n\n  context.arbitraryPropertiesSort = (1n << reservedBits << 0n) - 1n;\n  context.layerOrder = {\n    defaults: 1n << reservedBits << 0n,\n    base: 1n << reservedBits << 1n,\n    components: 1n << reservedBits << 2n,\n    utilities: 1n << reservedBits << 3n,\n    user: 1n << reservedBits << 4n\n  };\n  reservedBits += 5n;\n  let offset = 0;\n  context.variantOrder = new Map(variantList.map((variant, i) => {\n    let variantFunctions = variantMap.get(variant).length;\n    let bits = 1n << BigInt(i + offset) << reservedBits;\n    offset += variantFunctions - 1;\n    return [variant, bits];\n  }).sort((_ref11, _ref12) => {\n    let [, a] = _ref11;\n    let [, z] = _ref12;\n    return bigSign(a - z);\n  }));\n  context.minimumScreen = [...context.variantOrder.values()].shift(); // Build variantMap\n\n  for (let [variantName, variantFunctions] of variantMap.entries()) {\n    let sort = context.variantOrder.get(variantName);\n    context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx) => [sort << BigInt(idx), variantFunction]));\n  }\n\n  let safelist = (context.tailwindConfig.safelist ?? []).filter(Boolean);\n\n  if (safelist.length > 0) {\n    let checks = [];\n\n    for (let value of safelist) {\n      if (typeof value === 'string') {\n        context.changedContent.push({\n          content: value,\n          extension: 'html'\n        });\n        continue;\n      }\n\n      if (value instanceof RegExp) {\n        log.warn('root-regex', ['Regular expressions in `safelist` work differently in Tailwind CSS v3.0.', 'Update your `safelist` configuration to eliminate this warning.', 'https://tailwindcss.com/docs/content-configuration#safelisting-classes']);\n        continue;\n      }\n\n      checks.push(value);\n    }\n\n    if (checks.length > 0) {\n      let patternMatchingCount = new Map();\n      let prefixLength = context.tailwindConfig.prefix.length;\n\n      for (let util of classList) {\n        let utils = Array.isArray(util) ? (() => {\n          let [utilName, options] = util;\n          let values = Object.keys(options?.values ?? {});\n          let classes = values.map(value => formatClass(utilName, value));\n\n          if (options?.supportsNegativeValues) {\n            // This is the normal negated version\n            // e.g. `-inset-1` or `-tw-inset-1`\n            classes = [...classes, ...classes.map(cls => '-' + cls)]; // This is the negated version *after* the prefix\n            // e.g. `tw--inset-1`\n            // The prefix is already attached to util name\n            // So we add the negative after the prefix\n\n            classes = [...classes, ...classes.map(cls => cls.slice(0, prefixLength) + '-' + cls.slice(prefixLength))];\n          }\n\n          if ([].concat(options?.type).includes('color')) {\n            classes = [...classes, ...classes.flatMap(cls => Object.keys(context.tailwindConfig.theme.opacity).map(opacity => `${cls}/${opacity}`))];\n          }\n\n          return classes;\n        })() : [util];\n\n        for (let util of utils) {\n          for (let {\n            pattern,\n            variants = []\n          } of checks) {\n            // RegExp with the /g flag are stateful, so let's reset the last\n            // index pointer to reset the state.\n            pattern.lastIndex = 0;\n\n            if (!patternMatchingCount.has(pattern)) {\n              patternMatchingCount.set(pattern, 0);\n            }\n\n            if (!pattern.test(util)) continue;\n            patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n            context.changedContent.push({\n              content: util,\n              extension: 'html'\n            });\n\n            for (let variant of variants) {\n              context.changedContent.push({\n                content: variant + context.tailwindConfig.separator + util,\n                extension: 'html'\n              });\n            }\n          }\n        }\n      }\n\n      for (let [regex, count] of patternMatchingCount.entries()) {\n        if (count !== 0) continue;\n        log.warn([`The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`, 'Fix this pattern or remove it from your `safelist` configuration.', 'https://tailwindcss.com/docs/content-configuration#safelisting-classes']);\n      }\n    }\n  } // A list of utilities that are used by certain Tailwind CSS utilities but\n  // that don't exist on their own. This will result in them \"not existing\" and\n  // sorting could be weird since you still require them in order to make the\n  // host utitlies work properly. (Thanks Biology)\n\n\n  let parasiteUtilities = new Set([prefix(context, 'group'), prefix(context, 'peer')]);\n\n  context.getClassOrder = function getClassOrder(classes) {\n    let sortedClassNames = new Map();\n\n    for (let [sort, rule] of generateRules(new Set(classes), context)) {\n      if (sortedClassNames.has(rule.raws.tailwind.candidate)) continue;\n      sortedClassNames.set(rule.raws.tailwind.candidate, sort);\n    }\n\n    return classes.map(className => {\n      let order = sortedClassNames.get(className) ?? null;\n\n      if (order === null && parasiteUtilities.has(className)) {\n        // This will make sure that it is at the very beginning of the\n        // `components` layer which technically means 'before any\n        // components'.\n        order = context.layerOrder.components;\n      }\n\n      return [className, order];\n    });\n  }; // Generate a list of strings for autocompletion purposes, e.g.\n  // ['uppercase', 'lowercase', ...]\n\n\n  context.getClassList = function getClassList() {\n    let output = [];\n\n    for (let util of classList) {\n      if (Array.isArray(util)) {\n        let [utilName, options] = util;\n        let negativeClasses = [];\n\n        for (let [key, value] of Object.entries(options?.values ?? {})) {\n          output.push(formatClass(utilName, key));\n\n          if (options?.supportsNegativeValues && negateValue(value)) {\n            negativeClasses.push(formatClass(utilName, `-${key}`));\n          }\n        }\n\n        output.push(...negativeClasses);\n      } else {\n        output.push(util);\n      }\n    }\n\n    return output;\n  };\n}\n\nexport function createContext(tailwindConfig) {\n  let changedContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : postcss.root();\n  let context = {\n    disposables: [],\n    ruleCache: new Set(),\n    classCache: new Map(),\n    applyClassCache: new Map(),\n    notClassCache: new Set(),\n    postCssNodeCache: new Map(),\n    candidateRuleMap: new Map(),\n    tailwindConfig,\n    changedContent: changedContent,\n    variantMap: new Map(),\n    stylesheetCache: null\n  };\n  let resolvedPlugins = resolvePlugins(context, root);\n  registerPlugins(resolvedPlugins, context);\n  return context;\n}\nlet contextMap = sharedState.contextMap;\nlet configContextMap = sharedState.configContextMap;\nlet contextSourcesMap = sharedState.contextSourcesMap;\nexport function getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n  let sourcePath = result.opts.from;\n  let isConfigFile = userConfigPath !== null;\n  env.DEBUG && console.log('Source path:', sourcePath);\n  let existingContext;\n\n  if (isConfigFile && contextMap.has(sourcePath)) {\n    existingContext = contextMap.get(sourcePath);\n  } else if (configContextMap.has(tailwindConfigHash)) {\n    let context = configContextMap.get(tailwindConfigHash);\n    contextSourcesMap.get(context).add(sourcePath);\n    contextMap.set(sourcePath, context);\n    existingContext = context;\n  }\n\n  let cssDidChange = hasContentChanged(sourcePath, root); // If there's already a context in the cache and we don't need to\n  // reset the context, return the cached context.\n\n  if (existingContext) {\n    let contextDependenciesChanged = trackModified([...contextDependencies], getFileModifiedMap(existingContext));\n\n    if (!contextDependenciesChanged && !cssDidChange) {\n      return [existingContext, false];\n    }\n  } // If this source is in the context map, get the old context.\n  // Remove this source from the context sources for the old context,\n  // and clean up that context if no one else is using it. This can be\n  // called by many processes in rapid succession, so we check for presence\n  // first because the first process to run this code will wipe it out first.\n\n\n  if (contextMap.has(sourcePath)) {\n    let oldContext = contextMap.get(sourcePath);\n\n    if (contextSourcesMap.has(oldContext)) {\n      contextSourcesMap.get(oldContext).delete(sourcePath);\n\n      if (contextSourcesMap.get(oldContext).size === 0) {\n        contextSourcesMap.delete(oldContext);\n\n        for (let [tailwindConfigHash, context] of configContextMap) {\n          if (context === oldContext) {\n            configContextMap.delete(tailwindConfigHash);\n          }\n        }\n\n        for (let disposable of oldContext.disposables.splice(0)) {\n          disposable(oldContext);\n        }\n      }\n    }\n  }\n\n  env.DEBUG && console.log('Setting up new context...');\n  let context = createContext(tailwindConfig, [], root);\n  trackModified([...contextDependencies], getFileModifiedMap(context)); // ---\n  // Update all context tracking state\n\n  configContextMap.set(tailwindConfigHash, context);\n  contextMap.set(sourcePath, context);\n\n  if (!contextSourcesMap.has(context)) {\n    contextSourcesMap.set(context, new Set());\n  }\n\n  contextSourcesMap.get(context).add(sourcePath);\n  return [context, true];\n}","map":{"version":3,"names":["fs","url","postcss","dlv","selectorParser","flagEnabled","transformThemeValue","parseObjectStyles","prefixSelector","isPlainObject","escapeClassName","nameClass","formatClass","coerceValue","bigSign","variantPlugins","corePlugins","sharedState","env","toPath","log","negateValue","isValidArbitraryValue","generateRules","hasContentChanged","MATCH_VARIANT","Symbol","prefix","context","selector","tailwindConfig","parseVariantFormatString","input","includes","isBalanced","Error","split","flatMap","line","filter","Boolean","trim","count","char","insertInto","list","value","before","concat","length","push","idx","other","iidx","indexOf","Math","min","splice","parseStyles","styles","Array","isArray","style","isNode","getClasses","mutate","parser","selectors","allClasses","walkClasses","classNode","transformSync","extractCandidates","node","state","containsNonOnDemandable","depth","classes","type","ignoreNot","walkPseudos","pseudo","remove","classCandidates","classCandidate","walkRules","rule","withIdentifiers","nodeMap","Map","containsNonOnDemandableSelectors","candidates","unshift","NOT_ON_DEMAND","map","c","has","set","get","isValidVariantFormatString","format","startsWith","parseVariant","variant","replace","fns","str","name","params","exec","wrap","atRule","reverse","api","fn","buildPluginApi","variantList","variantMap","offsets","classList","getConfigValue","path","defaultValue","applyConfiguredPrefix","prefixIdentifier","identifier","options","respectPrefix","resolveThemeValue","opts","pathRoot","subPaths","theme","Object","assign","undefined","withAlpha","opacityValue","e","config","variants","addBase","base","prefixedIdentifier","offset","candidateRuleMap","sort","layer","addDefaults","group","declarations","groups","addComponents","components","defaultOptions","preserveSource","respectImportant","add","addUtilities","utilities","matchUtilities","wrapped","modifier","isOnlyPlugin","coercedType","ruleSets","declaration","withOffsets","matchComponents","warn","addVariant","variantName","variantFunctions","variantFunction","args","modifySelectors","container","separator","result","matchVariant","k","v","entries","values","fileModifiedMapCache","WeakMap","getFileModifiedMap","trackModified","files","fileModifiedMap","changed","file","parsed","parse","pathname","hash","href","search","newModified","statSync","decodeURIComponent","throwIfNoEntry","mtimeMs","extractVariantAtRules","walkAtRules","nodes","collectLayerPlugins","root","layerPlugins","each","layerRule","resolvePlugins","corePluginList","plugin","userPlugins","plugins","__isOptionsFunction","handler","beforeVariants","afterVariants","registerPlugins","defaults","user","Set","pluginApi","pluginItem","highestOffset","reduce","m","reservedBits","BigInt","toString","arbitraryPropertiesSort","layerOrder","variantOrder","i","bits","a","z","minimumScreen","shift","safelist","checks","changedContent","content","extension","RegExp","patternMatchingCount","prefixLength","util","utils","utilName","keys","supportsNegativeValues","cls","slice","opacity","pattern","lastIndex","test","regex","parasiteUtilities","getClassOrder","sortedClassNames","raws","tailwind","candidate","className","order","getClassList","output","negativeClasses","key","createContext","disposables","ruleCache","classCache","applyClassCache","notClassCache","postCssNodeCache","stylesheetCache","resolvedPlugins","contextMap","configContextMap","contextSourcesMap","getContext","userConfigPath","tailwindConfigHash","contextDependencies","sourcePath","from","isConfigFile","DEBUG","console","existingContext","cssDidChange","contextDependenciesChanged","oldContext","delete","size","disposable"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/src/lib/setupContextUtils.js"],"sourcesContent":["import fs from 'fs'\nimport url from 'url'\nimport postcss from 'postcss'\nimport dlv from 'dlv'\nimport selectorParser from 'postcss-selector-parser'\n\nimport { flagEnabled } from '../featureFlags.js'\nimport transformThemeValue from '../util/transformThemeValue'\nimport parseObjectStyles from '../util/parseObjectStyles'\nimport prefixSelector from '../util/prefixSelector'\nimport isPlainObject from '../util/isPlainObject'\nimport escapeClassName from '../util/escapeClassName'\nimport nameClass, { formatClass } from '../util/nameClass'\nimport { coerceValue } from '../util/pluginUtils'\nimport bigSign from '../util/bigSign'\nimport { variantPlugins, corePlugins } from '../corePlugins'\nimport * as sharedState from './sharedState'\nimport { env } from './sharedState'\nimport { toPath } from '../util/toPath'\nimport log from '../util/log'\nimport negateValue from '../util/negateValue'\nimport isValidArbitraryValue from '../util/isValidArbitraryValue'\nimport { generateRules } from './generateRules'\nimport { hasContentChanged } from './cacheInvalidation.js'\n\nlet MATCH_VARIANT = Symbol()\n\nfunction prefix(context, selector) {\n  let prefix = context.tailwindConfig.prefix\n  return typeof prefix === 'function' ? prefix(selector) : prefix + selector\n}\n\nfunction parseVariantFormatString(input) {\n  if (input.includes('{')) {\n    if (!isBalanced(input)) throw new Error(`Your { and } are unbalanced.`)\n\n    return input\n      .split(/{(.*)}/gim)\n      .flatMap((line) => parseVariantFormatString(line))\n      .filter(Boolean)\n  }\n\n  return [input.trim()]\n}\n\nfunction isBalanced(input) {\n  let count = 0\n\n  for (let char of input) {\n    if (char === '{') {\n      count++\n    } else if (char === '}') {\n      if (--count < 0) {\n        return false // unbalanced\n      }\n    }\n  }\n\n  return count === 0\n}\n\nfunction insertInto(list, value, { before = [] } = {}) {\n  before = [].concat(before)\n\n  if (before.length <= 0) {\n    list.push(value)\n    return\n  }\n\n  let idx = list.length - 1\n  for (let other of before) {\n    let iidx = list.indexOf(other)\n    if (iidx === -1) continue\n    idx = Math.min(idx, iidx)\n  }\n\n  list.splice(idx, 0, value)\n}\n\nfunction parseStyles(styles) {\n  if (!Array.isArray(styles)) {\n    return parseStyles([styles])\n  }\n\n  return styles.flatMap((style) => {\n    let isNode = !Array.isArray(style) && !isPlainObject(style)\n    return isNode ? style : parseObjectStyles(style)\n  })\n}\n\nfunction getClasses(selector, mutate) {\n  let parser = selectorParser((selectors) => {\n    let allClasses = []\n\n    if (mutate) {\n      mutate(selectors)\n    }\n\n    selectors.walkClasses((classNode) => {\n      allClasses.push(classNode.value)\n    })\n\n    return allClasses\n  })\n  return parser.transformSync(selector)\n}\n\nfunction extractCandidates(node, state = { containsNonOnDemandable: false }, depth = 0) {\n  let classes = []\n\n  // Handle normal rules\n  if (node.type === 'rule') {\n    // Ignore everything inside a :not(...). This allows you to write code like\n    // `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n    // not generated it. But now we will ignore everything inside a `:not`, so\n    // that it still gets generated.\n    function ignoreNot(selectors) {\n      selectors.walkPseudos((pseudo) => {\n        if (pseudo.value === ':not') {\n          pseudo.remove()\n        }\n      })\n    }\n\n    for (let selector of node.selectors) {\n      let classCandidates = getClasses(selector, ignoreNot)\n      // At least one of the selectors contains non-\"on-demandable\" candidates.\n      if (classCandidates.length === 0) {\n        state.containsNonOnDemandable = true\n      }\n\n      for (let classCandidate of classCandidates) {\n        classes.push(classCandidate)\n      }\n    }\n  }\n\n  // Handle at-rules (which contains nested rules)\n  else if (node.type === 'atrule') {\n    node.walkRules((rule) => {\n      for (let classCandidate of rule.selectors.flatMap((selector) => getClasses(selector))) {\n        classes.push(classCandidate)\n      }\n    })\n  }\n\n  if (depth === 0) {\n    return [state.containsNonOnDemandable || classes.length === 0, classes]\n  }\n\n  return classes\n}\n\nfunction withIdentifiers(styles) {\n  return parseStyles(styles).flatMap((node) => {\n    let nodeMap = new Map()\n    let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node)\n\n    // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n    if (containsNonOnDemandableSelectors) {\n      candidates.unshift(sharedState.NOT_ON_DEMAND)\n    }\n\n    // However, it could be that it also contains \"on-demandable\" candidates.\n    // E.g.: `span, .foo {}`, in that case it should still be possible to use\n    // `@apply foo` for example.\n    return candidates.map((c) => {\n      if (!nodeMap.has(node)) {\n        nodeMap.set(node, node)\n      }\n      return [c, nodeMap.get(node)]\n    })\n  })\n}\n\nexport function isValidVariantFormatString(format) {\n  return format.startsWith('@') || format.includes('&')\n}\n\nexport function parseVariant(variant) {\n  variant = variant\n    .replace(/\\n+/g, '')\n    .replace(/\\s{1,}/g, ' ')\n    .trim()\n\n  let fns = parseVariantFormatString(variant)\n    .map((str) => {\n      if (!str.startsWith('@')) {\n        return ({ format }) => format(str)\n      }\n\n      let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str)\n      return ({ wrap }) => wrap(postcss.atRule({ name, params: params.trim() }))\n    })\n    .reverse()\n\n  return (api) => {\n    for (let fn of fns) {\n      fn(api)\n    }\n  }\n}\n\nfunction buildPluginApi(tailwindConfig, context, { variantList, variantMap, offsets, classList }) {\n  function getConfigValue(path, defaultValue) {\n    return path ? dlv(tailwindConfig, path, defaultValue) : tailwindConfig\n  }\n\n  function applyConfiguredPrefix(selector) {\n    return prefixSelector(tailwindConfig.prefix, selector)\n  }\n\n  function prefixIdentifier(identifier, options) {\n    if (identifier === sharedState.NOT_ON_DEMAND) {\n      return sharedState.NOT_ON_DEMAND\n    }\n\n    if (!options.respectPrefix) {\n      return identifier\n    }\n\n    return context.tailwindConfig.prefix + identifier\n  }\n\n  function resolveThemeValue(path, defaultValue, opts = {}) {\n    const [pathRoot, ...subPaths] = toPath(path)\n    const value = getConfigValue(['theme', pathRoot, ...subPaths], defaultValue)\n    return transformThemeValue(pathRoot)(value, opts)\n  }\n\n  const theme = Object.assign(\n    (path, defaultValue = undefined) => resolveThemeValue(path, defaultValue),\n    {\n      withAlpha: (path, opacityValue) => resolveThemeValue(path, undefined, { opacityValue }),\n    }\n  )\n\n  let api = {\n    postcss,\n    prefix: applyConfiguredPrefix,\n    e: escapeClassName,\n    config: getConfigValue,\n    theme,\n    corePlugins: (path) => {\n      if (Array.isArray(tailwindConfig.corePlugins)) {\n        return tailwindConfig.corePlugins.includes(path)\n      }\n\n      return getConfigValue(['corePlugins', path], true)\n    },\n    variants: () => {\n      // Preserved for backwards compatibility but not used in v3.0+\n      return []\n    },\n    addBase(base) {\n      for (let [identifier, rule] of withIdentifiers(base)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {})\n        let offset = offsets.base++\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, [])\n        }\n\n        context.candidateRuleMap\n          .get(prefixedIdentifier)\n          .push([{ sort: offset, layer: 'base' }, rule])\n      }\n    },\n    /**\n     * @param {string} group\n     * @param {Record<string, string | string[]>} declarations\n     */\n    addDefaults(group, declarations) {\n      const groups = {\n        [`@defaults ${group}`]: declarations,\n      }\n\n      for (let [identifier, rule] of withIdentifiers(groups)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {})\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, [])\n        }\n\n        context.candidateRuleMap\n          .get(prefixedIdentifier)\n          .push([{ sort: offsets.base++, layer: 'defaults' }, rule])\n      }\n    },\n    addComponents(components, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: false,\n      }\n\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options)\n\n      for (let [identifier, rule] of withIdentifiers(components)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options)\n\n        classList.add(prefixedIdentifier)\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, [])\n        }\n\n        context.candidateRuleMap\n          .get(prefixedIdentifier)\n          .push([{ sort: offsets.components++, layer: 'components', options }, rule])\n      }\n    },\n    addUtilities(utilities, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: true,\n      }\n\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options)\n\n      for (let [identifier, rule] of withIdentifiers(utilities)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options)\n\n        classList.add(prefixedIdentifier)\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, [])\n        }\n\n        context.candidateRuleMap\n          .get(prefixedIdentifier)\n          .push([{ sort: offsets.utilities++, layer: 'utilities', options }, rule])\n      }\n    },\n    matchUtilities: function (utilities, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: true,\n      }\n\n      options = { ...defaultOptions, ...options }\n\n      let offset = offsets.utilities++\n\n      for (let identifier in utilities) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options)\n        let rule = utilities[identifier]\n\n        classList.add([prefixedIdentifier, options])\n\n        function wrapped(modifier, { isOnlyPlugin }) {\n          let { type = 'any' } = options\n          type = [].concat(type)\n          let [value, coercedType] = coerceValue(type, modifier, options, tailwindConfig)\n\n          if (value === undefined) {\n            return []\n          }\n\n          if (!type.includes(coercedType) && !isOnlyPlugin) {\n            return []\n          }\n\n          if (!isValidArbitraryValue(value)) {\n            return []\n          }\n\n          let ruleSets = []\n            .concat(rule(value))\n            .filter(Boolean)\n            .map((declaration) => ({\n              [nameClass(identifier, modifier)]: declaration,\n            }))\n\n          return ruleSets\n        }\n\n        let withOffsets = [{ sort: offset, layer: 'utilities', options }, wrapped]\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, [])\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets)\n      }\n    },\n    matchComponents: function (components, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: false,\n      }\n\n      options = { ...defaultOptions, ...options }\n\n      let offset = offsets.components++\n\n      for (let identifier in components) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options)\n        let rule = components[identifier]\n\n        classList.add([prefixedIdentifier, options])\n\n        function wrapped(modifier, { isOnlyPlugin }) {\n          let { type = 'any' } = options\n          type = [].concat(type)\n          let [value, coercedType] = coerceValue(type, modifier, options, tailwindConfig)\n\n          if (value === undefined) {\n            return []\n          }\n\n          if (!type.includes(coercedType)) {\n            if (isOnlyPlugin) {\n              log.warn([\n                `Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,\n                `You can safely update it to \\`${identifier}-${modifier.replace(\n                  coercedType + ':',\n                  ''\n                )}\\`.`,\n              ])\n            } else {\n              return []\n            }\n          }\n\n          if (!isValidArbitraryValue(value)) {\n            return []\n          }\n\n          let ruleSets = []\n            .concat(rule(value))\n            .filter(Boolean)\n            .map((declaration) => ({\n              [nameClass(identifier, modifier)]: declaration,\n            }))\n\n          return ruleSets\n        }\n\n        let withOffsets = [{ sort: offset, layer: 'components', options }, wrapped]\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, [])\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets)\n      }\n    },\n    addVariant(variantName, variantFunctions, options = {}) {\n      variantFunctions = [].concat(variantFunctions).map((variantFunction) => {\n        if (typeof variantFunction !== 'string') {\n          // Safelist public API functions\n          return (api) => {\n            let { args, modifySelectors, container, separator, wrap, format } = api\n            let result = variantFunction(\n              Object.assign(\n                { modifySelectors, container, separator },\n                variantFunction[MATCH_VARIANT] && { args, wrap, format }\n              )\n            )\n\n            if (typeof result === 'string' && !isValidVariantFormatString(result)) {\n              throw new Error(\n                `Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`\n              )\n            }\n\n            if (Array.isArray(result)) {\n              return result\n                .filter((variant) => typeof variant === 'string')\n                .map((variant) => parseVariant(variant))\n            }\n\n            // result may be undefined with legacy variants that use APIs like `modifySelectors`\n            // result may also be a postcss node if someone was returning the result from `modifySelectors`\n            return result && typeof result === 'string' && parseVariant(result)(api)\n          }\n        }\n\n        if (!isValidVariantFormatString(variantFunction)) {\n          throw new Error(\n            `Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`\n          )\n        }\n\n        return parseVariant(variantFunction)\n      })\n\n      insertInto(variantList, variantName, options)\n      variantMap.set(variantName, variantFunctions)\n    },\n  }\n\n  if (flagEnabled(tailwindConfig, 'matchVariant')) {\n    api.matchVariant = function (variants, options) {\n      for (let variant in variants) {\n        for (let [k, v] of Object.entries(options?.values ?? {})) {\n          api.addVariant(`${variant}-${k}`, variants[variant](v))\n        }\n\n        api.addVariant(\n          variant,\n          Object.assign(({ args }) => variants[variant](args), { [MATCH_VARIANT]: true }),\n          options\n        )\n      }\n    }\n  }\n\n  return api\n}\n\nlet fileModifiedMapCache = new WeakMap()\nexport function getFileModifiedMap(context) {\n  if (!fileModifiedMapCache.has(context)) {\n    fileModifiedMapCache.set(context, new Map())\n  }\n  return fileModifiedMapCache.get(context)\n}\n\nfunction trackModified(files, fileModifiedMap) {\n  let changed = false\n\n  for (let file of files) {\n    if (!file) continue\n\n    let parsed = url.parse(file)\n    let pathname = parsed.hash ? parsed.href.replace(parsed.hash, '') : parsed.href\n    pathname = parsed.search ? pathname.replace(parsed.search, '') : pathname\n    let newModified = fs.statSync(decodeURIComponent(pathname), { throwIfNoEntry: false })?.mtimeMs\n    if (!newModified) {\n      // It could happen that a file is passed in that doesn't exist. E.g.:\n      // postcss-cli will provide you a fake path when reading from stdin. This\n      // path then looks like /path-to-your-project/stdin In that case we just\n      // want to ignore it and don't track changes at all.\n      continue\n    }\n\n    if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n      changed = true\n    }\n\n    fileModifiedMap.set(file, newModified)\n  }\n\n  return changed\n}\n\nfunction extractVariantAtRules(node) {\n  node.walkAtRules((atRule) => {\n    if (['responsive', 'variants'].includes(atRule.name)) {\n      extractVariantAtRules(atRule)\n      atRule.before(atRule.nodes)\n      atRule.remove()\n    }\n  })\n}\n\nfunction collectLayerPlugins(root) {\n  let layerPlugins = []\n\n  root.each((node) => {\n    if (node.type === 'atrule' && ['responsive', 'variants'].includes(node.name)) {\n      node.name = 'layer'\n      node.params = 'utilities'\n    }\n  })\n\n  // Walk @layer rules and treat them like plugins\n  root.walkAtRules('layer', (layerRule) => {\n    extractVariantAtRules(layerRule)\n\n    if (layerRule.params === 'base') {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function ({ addBase }) {\n          addBase(node, { respectPrefix: false })\n        })\n      }\n      layerRule.remove()\n    } else if (layerRule.params === 'components') {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function ({ addComponents }) {\n          addComponents(node, { respectPrefix: false, preserveSource: true })\n        })\n      }\n      layerRule.remove()\n    } else if (layerRule.params === 'utilities') {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function ({ addUtilities }) {\n          addUtilities(node, { respectPrefix: false, preserveSource: true })\n        })\n      }\n      layerRule.remove()\n    }\n  })\n\n  return layerPlugins\n}\n\nfunction resolvePlugins(context, root) {\n  let corePluginList = Object.entries({ ...variantPlugins, ...corePlugins })\n    .map(([name, plugin]) => {\n      if (!context.tailwindConfig.corePlugins.includes(name)) {\n        return null\n      }\n\n      return plugin\n    })\n    .filter(Boolean)\n\n  let userPlugins = context.tailwindConfig.plugins.map((plugin) => {\n    if (plugin.__isOptionsFunction) {\n      plugin = plugin()\n    }\n\n    return typeof plugin === 'function' ? plugin : plugin.handler\n  })\n\n  let layerPlugins = collectLayerPlugins(root)\n\n  // TODO: This is a workaround for backwards compatibility, since custom variants\n  // were historically sorted before screen/stackable variants.\n  let beforeVariants = [\n    variantPlugins['pseudoElementVariants'],\n    variantPlugins['pseudoClassVariants'],\n  ]\n  let afterVariants = [\n    variantPlugins['directionVariants'],\n    variantPlugins['reducedMotionVariants'],\n    variantPlugins['prefersContrastVariants'],\n    variantPlugins['darkVariants'],\n    variantPlugins['printVariant'],\n    variantPlugins['screenVariants'],\n    variantPlugins['orientationVariants'],\n  ]\n\n  return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins]\n}\n\nfunction registerPlugins(plugins, context) {\n  let variantList = []\n  let variantMap = new Map()\n  let offsets = {\n    defaults: 0n,\n    base: 0n,\n    components: 0n,\n    utilities: 0n,\n    user: 0n,\n  }\n\n  let classList = new Set()\n\n  let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n    variantList,\n    variantMap,\n    offsets,\n    classList,\n  })\n\n  for (let plugin of plugins) {\n    if (Array.isArray(plugin)) {\n      for (let pluginItem of plugin) {\n        pluginItem(pluginApi)\n      }\n    } else {\n      plugin?.(pluginApi)\n    }\n  }\n\n  let highestOffset = ((args) => args.reduce((m, e) => (e > m ? e : m)))([\n    offsets.base,\n    offsets.defaults,\n    offsets.components,\n    offsets.utilities,\n    offsets.user,\n  ])\n  let reservedBits = BigInt(highestOffset.toString(2).length)\n\n  // A number one less than the top range of the highest offset area\n  // so arbitrary properties are always sorted at the end.\n  context.arbitraryPropertiesSort = ((1n << reservedBits) << 0n) - 1n\n\n  context.layerOrder = {\n    defaults: (1n << reservedBits) << 0n,\n    base: (1n << reservedBits) << 1n,\n    components: (1n << reservedBits) << 2n,\n    utilities: (1n << reservedBits) << 3n,\n    user: (1n << reservedBits) << 4n,\n  }\n\n  reservedBits += 5n\n\n  let offset = 0\n  context.variantOrder = new Map(\n    variantList\n      .map((variant, i) => {\n        let variantFunctions = variantMap.get(variant).length\n        let bits = (1n << BigInt(i + offset)) << reservedBits\n        offset += variantFunctions - 1\n        return [variant, bits]\n      })\n      .sort(([, a], [, z]) => bigSign(a - z))\n  )\n\n  context.minimumScreen = [...context.variantOrder.values()].shift()\n\n  // Build variantMap\n  for (let [variantName, variantFunctions] of variantMap.entries()) {\n    let sort = context.variantOrder.get(variantName)\n    context.variantMap.set(\n      variantName,\n      variantFunctions.map((variantFunction, idx) => [sort << BigInt(idx), variantFunction])\n    )\n  }\n\n  let safelist = (context.tailwindConfig.safelist ?? []).filter(Boolean)\n  if (safelist.length > 0) {\n    let checks = []\n\n    for (let value of safelist) {\n      if (typeof value === 'string') {\n        context.changedContent.push({ content: value, extension: 'html' })\n        continue\n      }\n\n      if (value instanceof RegExp) {\n        log.warn('root-regex', [\n          'Regular expressions in `safelist` work differently in Tailwind CSS v3.0.',\n          'Update your `safelist` configuration to eliminate this warning.',\n          'https://tailwindcss.com/docs/content-configuration#safelisting-classes',\n        ])\n        continue\n      }\n\n      checks.push(value)\n    }\n\n    if (checks.length > 0) {\n      let patternMatchingCount = new Map()\n      let prefixLength = context.tailwindConfig.prefix.length\n\n      for (let util of classList) {\n        let utils = Array.isArray(util)\n          ? (() => {\n              let [utilName, options] = util\n              let values = Object.keys(options?.values ?? {})\n              let classes = values.map((value) => formatClass(utilName, value))\n\n              if (options?.supportsNegativeValues) {\n                // This is the normal negated version\n                // e.g. `-inset-1` or `-tw-inset-1`\n                classes = [...classes, ...classes.map((cls) => '-' + cls)]\n\n                // This is the negated version *after* the prefix\n                // e.g. `tw--inset-1`\n                // The prefix is already attached to util name\n                // So we add the negative after the prefix\n                classes = [\n                  ...classes,\n                  ...classes.map(\n                    (cls) => cls.slice(0, prefixLength) + '-' + cls.slice(prefixLength)\n                  ),\n                ]\n              }\n\n              if ([].concat(options?.type).includes('color')) {\n                classes = [\n                  ...classes,\n                  ...classes.flatMap((cls) =>\n                    Object.keys(context.tailwindConfig.theme.opacity).map(\n                      (opacity) => `${cls}/${opacity}`\n                    )\n                  ),\n                ]\n              }\n\n              return classes\n            })()\n          : [util]\n\n        for (let util of utils) {\n          for (let { pattern, variants = [] } of checks) {\n            // RegExp with the /g flag are stateful, so let's reset the last\n            // index pointer to reset the state.\n            pattern.lastIndex = 0\n\n            if (!patternMatchingCount.has(pattern)) {\n              patternMatchingCount.set(pattern, 0)\n            }\n\n            if (!pattern.test(util)) continue\n\n            patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1)\n\n            context.changedContent.push({ content: util, extension: 'html' })\n            for (let variant of variants) {\n              context.changedContent.push({\n                content: variant + context.tailwindConfig.separator + util,\n                extension: 'html',\n              })\n            }\n          }\n        }\n      }\n\n      for (let [regex, count] of patternMatchingCount.entries()) {\n        if (count !== 0) continue\n\n        log.warn([\n          `The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`,\n          'Fix this pattern or remove it from your `safelist` configuration.',\n          'https://tailwindcss.com/docs/content-configuration#safelisting-classes',\n        ])\n      }\n    }\n  }\n\n  // A list of utilities that are used by certain Tailwind CSS utilities but\n  // that don't exist on their own. This will result in them \"not existing\" and\n  // sorting could be weird since you still require them in order to make the\n  // host utitlies work properly. (Thanks Biology)\n  let parasiteUtilities = new Set([prefix(context, 'group'), prefix(context, 'peer')])\n  context.getClassOrder = function getClassOrder(classes) {\n    let sortedClassNames = new Map()\n    for (let [sort, rule] of generateRules(new Set(classes), context)) {\n      if (sortedClassNames.has(rule.raws.tailwind.candidate)) continue\n      sortedClassNames.set(rule.raws.tailwind.candidate, sort)\n    }\n\n    return classes.map((className) => {\n      let order = sortedClassNames.get(className) ?? null\n\n      if (order === null && parasiteUtilities.has(className)) {\n        // This will make sure that it is at the very beginning of the\n        // `components` layer which technically means 'before any\n        // components'.\n        order = context.layerOrder.components\n      }\n\n      return [className, order]\n    })\n  }\n\n  // Generate a list of strings for autocompletion purposes, e.g.\n  // ['uppercase', 'lowercase', ...]\n  context.getClassList = function getClassList() {\n    let output = []\n\n    for (let util of classList) {\n      if (Array.isArray(util)) {\n        let [utilName, options] = util\n        let negativeClasses = []\n\n        for (let [key, value] of Object.entries(options?.values ?? {})) {\n          output.push(formatClass(utilName, key))\n          if (options?.supportsNegativeValues && negateValue(value)) {\n            negativeClasses.push(formatClass(utilName, `-${key}`))\n          }\n        }\n\n        output.push(...negativeClasses)\n      } else {\n        output.push(util)\n      }\n    }\n\n    return output\n  }\n}\n\nexport function createContext(tailwindConfig, changedContent = [], root = postcss.root()) {\n  let context = {\n    disposables: [],\n    ruleCache: new Set(),\n    classCache: new Map(),\n    applyClassCache: new Map(),\n    notClassCache: new Set(),\n    postCssNodeCache: new Map(),\n    candidateRuleMap: new Map(),\n    tailwindConfig,\n    changedContent: changedContent,\n    variantMap: new Map(),\n    stylesheetCache: null,\n  }\n\n  let resolvedPlugins = resolvePlugins(context, root)\n  registerPlugins(resolvedPlugins, context)\n\n  return context\n}\n\nlet contextMap = sharedState.contextMap\nlet configContextMap = sharedState.configContextMap\nlet contextSourcesMap = sharedState.contextSourcesMap\n\nexport function getContext(\n  root,\n  result,\n  tailwindConfig,\n  userConfigPath,\n  tailwindConfigHash,\n  contextDependencies\n) {\n  let sourcePath = result.opts.from\n  let isConfigFile = userConfigPath !== null\n\n  env.DEBUG && console.log('Source path:', sourcePath)\n\n  let existingContext\n\n  if (isConfigFile && contextMap.has(sourcePath)) {\n    existingContext = contextMap.get(sourcePath)\n  } else if (configContextMap.has(tailwindConfigHash)) {\n    let context = configContextMap.get(tailwindConfigHash)\n    contextSourcesMap.get(context).add(sourcePath)\n    contextMap.set(sourcePath, context)\n\n    existingContext = context\n  }\n\n  let cssDidChange = hasContentChanged(sourcePath, root)\n\n  // If there's already a context in the cache and we don't need to\n  // reset the context, return the cached context.\n  if (existingContext) {\n    let contextDependenciesChanged = trackModified(\n      [...contextDependencies],\n      getFileModifiedMap(existingContext)\n    )\n    if (!contextDependenciesChanged && !cssDidChange) {\n      return [existingContext, false]\n    }\n  }\n\n  // If this source is in the context map, get the old context.\n  // Remove this source from the context sources for the old context,\n  // and clean up that context if no one else is using it. This can be\n  // called by many processes in rapid succession, so we check for presence\n  // first because the first process to run this code will wipe it out first.\n  if (contextMap.has(sourcePath)) {\n    let oldContext = contextMap.get(sourcePath)\n    if (contextSourcesMap.has(oldContext)) {\n      contextSourcesMap.get(oldContext).delete(sourcePath)\n      if (contextSourcesMap.get(oldContext).size === 0) {\n        contextSourcesMap.delete(oldContext)\n        for (let [tailwindConfigHash, context] of configContextMap) {\n          if (context === oldContext) {\n            configContextMap.delete(tailwindConfigHash)\n          }\n        }\n        for (let disposable of oldContext.disposables.splice(0)) {\n          disposable(oldContext)\n        }\n      }\n    }\n  }\n\n  env.DEBUG && console.log('Setting up new context...')\n\n  let context = createContext(tailwindConfig, [], root)\n\n  trackModified([...contextDependencies], getFileModifiedMap(context))\n\n  // ---\n\n  // Update all context tracking state\n\n  configContextMap.set(tailwindConfigHash, context)\n  contextMap.set(sourcePath, context)\n\n  if (!contextSourcesMap.has(context)) {\n    contextSourcesMap.set(context, new Set())\n  }\n\n  contextSourcesMap.get(context).add(sourcePath)\n\n  return [context, true]\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}