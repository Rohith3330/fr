{"ast":null,"code":"// @ts-check\n\n/**\n * @file\n * Helper plugin manages the cached state of the child compilation\n *\n * To optimize performance the child compilation is running asyncronously.\n * Therefore it needs to be started in the compiler.make phase and ends after\n * the compilation.afterCompile phase.\n *\n * To prevent bugs from blocked hooks there is no promise or event based api\n * for this plugin.\n *\n * Example usage:\n *\n * ```js\n    const childCompilerPlugin = new PersistentChildCompilerPlugin();\n    childCompilerPlugin.addEntry('./src/index.js');\n    compiler.hooks.afterCompile.tapAsync('MyPlugin', (compilation, callback) => {\n      console.log(childCompilerPlugin.getCompilationResult()['./src/index.js']));\n      return true;\n    });\n * ```\n */\n// Import types\n\n/** @typedef {import(\"webpack/lib/Compiler.js\")} WebpackCompiler */\n\n/** @typedef {import(\"webpack/lib/Compilation.js\")} WebpackCompilation */\n\n/** @typedef {{hash: string, entry: any, content: string }} ChildCompilationResultEntry */\n\n/** @typedef {import(\"./file-watcher-api\").Snapshot} Snapshot */\n\n/** @typedef {{fileDependencies: string[], contextDependencies: string[], missingDependencies: string[]}} FileDependencies */\n\n/** @typedef {{\n  dependencies: FileDependencies,\n  compiledEntries: {[entryName: string]: ChildCompilationResultEntry}\n} | {\n  dependencies: FileDependencies,\n  error: Error\n}} ChildCompilationResult */\n'use strict';\n\nconst {\n  HtmlWebpackChildCompiler\n} = require('./child-compiler');\n\nconst fileWatcherApi = require('./file-watcher-api');\n/**\n * This plugin is a singleton for performance reasons.\n * To keep track if a plugin does already exist for the compiler they are cached\n * in this map\n * @type {WeakMap<WebpackCompiler, PersistentChildCompilerSingletonPlugin>}}\n */\n\n\nconst compilerMap = new WeakMap();\n\nclass CachedChildCompilation {\n  /**\n   * @param {WebpackCompiler} compiler\n   */\n  constructor(compiler) {\n    /**\n     * @private\n     * @type {WebpackCompiler}\n     */\n    this.compiler = compiler; // Create a singleton instance for the compiler\n    // if there is none\n\n    if (compilerMap.has(compiler)) {\n      return;\n    }\n\n    const persistentChildCompilerSingletonPlugin = new PersistentChildCompilerSingletonPlugin();\n    compilerMap.set(compiler, persistentChildCompilerSingletonPlugin);\n    persistentChildCompilerSingletonPlugin.apply(compiler);\n  }\n  /**\n   * apply is called by the webpack main compiler during the start phase\n   * @param {string} entry\n   */\n\n\n  addEntry(entry) {\n    const persistentChildCompilerSingletonPlugin = compilerMap.get(this.compiler);\n\n    if (!persistentChildCompilerSingletonPlugin) {\n      throw new Error('PersistentChildCompilerSingletonPlugin instance not found.');\n    }\n\n    persistentChildCompilerSingletonPlugin.addEntry(entry);\n  }\n\n  getCompilationResult() {\n    const persistentChildCompilerSingletonPlugin = compilerMap.get(this.compiler);\n\n    if (!persistentChildCompilerSingletonPlugin) {\n      throw new Error('PersistentChildCompilerSingletonPlugin instance not found.');\n    }\n\n    return persistentChildCompilerSingletonPlugin.getLatestResult();\n  }\n  /**\n   * Returns the result for the given entry\n   * @param {string} entry\n   * @returns {\n      | { mainCompilationHash: string, error: Error }\n      | { mainCompilationHash: string, compiledEntry: ChildCompilationResultEntry }\n    }\n   */\n\n\n  getCompilationEntryResult(entry) {\n    const latestResult = this.getCompilationResult();\n    const compilationResult = latestResult.compilationResult;\n    return 'error' in compilationResult ? {\n      mainCompilationHash: latestResult.mainCompilationHash,\n      error: compilationResult.error\n    } : {\n      mainCompilationHash: latestResult.mainCompilationHash,\n      compiledEntry: compilationResult.compiledEntries[entry]\n    };\n  }\n\n}\n\nclass PersistentChildCompilerSingletonPlugin {\n  constructor() {\n    /**\n     * @private\n     * @type {\n      | {\n        isCompiling: false,\n        isVerifyingCache: false,\n        entries: string[],\n        compiledEntries: string[],\n        mainCompilationHash: string,\n        compilationResult: ChildCompilationResult\n      }\n    | Readonly<{\n      isCompiling: false,\n      isVerifyingCache: true,\n      entries: string[],\n      previousEntries: string[],\n      previousResult: ChildCompilationResult\n    }>\n    | Readonly <{\n      isVerifyingCache: false,\n      isCompiling: true,\n      entries: string[],\n    }>\n    } the internal compilation state */\n    this.compilationState = {\n      isCompiling: false,\n      isVerifyingCache: false,\n      entries: [],\n      compiledEntries: [],\n      mainCompilationHash: 'initial',\n      compilationResult: {\n        dependencies: {\n          fileDependencies: [],\n          contextDependencies: [],\n          missingDependencies: []\n        },\n        compiledEntries: {}\n      }\n    };\n  }\n  /**\n   * apply is called by the webpack main compiler during the start phase\n   * @param {WebpackCompiler} compiler\n   */\n\n\n  apply(compiler) {\n    /** @type Promise<ChildCompilationResult> */\n    let childCompilationResultPromise = Promise.resolve({\n      dependencies: {\n        fileDependencies: [],\n        contextDependencies: [],\n        missingDependencies: []\n      },\n      compiledEntries: {}\n    });\n    /**\n     * The main compilation hash which will only be updated\n     * if the childCompiler changes\n     */\n\n    let mainCompilationHashOfLastChildRecompile = '';\n    /** @typedef{Snapshot|undefined} */\n\n    let previousFileSystemSnapshot;\n    let compilationStartTime = new Date().getTime();\n    compiler.hooks.make.tapAsync('PersistentChildCompilerSingletonPlugin', (mainCompilation, callback) => {\n      if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {\n        return callback(new Error('Child compilation has already started'));\n      } // Update the time to the current compile start time\n\n\n      compilationStartTime = new Date().getTime(); // The compilation starts - adding new templates is now not possible anymore\n\n      this.compilationState = {\n        isCompiling: false,\n        isVerifyingCache: true,\n        previousEntries: this.compilationState.compiledEntries,\n        previousResult: this.compilationState.compilationResult,\n        entries: this.compilationState.entries\n      }; // Validate cache:\n\n      const isCacheValidPromise = this.isCacheValid(previousFileSystemSnapshot, mainCompilation);\n      let cachedResult = childCompilationResultPromise;\n      childCompilationResultPromise = isCacheValidPromise.then(isCacheValid => {\n        // Reuse cache\n        if (isCacheValid) {\n          return cachedResult;\n        } // Start the compilation\n\n\n        const compiledEntriesPromise = this.compileEntries(mainCompilation, this.compilationState.entries); // Update snapshot as soon as we know the filedependencies\n        // this might possibly cause bugs if files were changed inbetween\n        // compilation start and snapshot creation\n\n        compiledEntriesPromise.then(childCompilationResult => {\n          return fileWatcherApi.createSnapshot(childCompilationResult.dependencies, mainCompilation, compilationStartTime);\n        }).then(snapshot => {\n          previousFileSystemSnapshot = snapshot;\n        });\n        return compiledEntriesPromise;\n      }); // Add files to compilation which needs to be watched:\n\n      mainCompilation.hooks.optimizeTree.tapAsync('PersistentChildCompilerSingletonPlugin', (chunks, modules, callback) => {\n        const handleCompilationDonePromise = childCompilationResultPromise.then(childCompilationResult => {\n          this.watchFiles(mainCompilation, childCompilationResult.dependencies);\n        });\n        handleCompilationDonePromise.then(() => callback(null, chunks, modules), callback);\n      }); // Store the final compilation once the main compilation hash is known\n\n      mainCompilation.hooks.additionalAssets.tapAsync('PersistentChildCompilerSingletonPlugin', callback => {\n        const didRecompilePromise = Promise.all([childCompilationResultPromise, cachedResult]).then(_ref => {\n          let [childCompilationResult, cachedResult] = _ref;\n          // Update if childCompilation changed\n          return cachedResult !== childCompilationResult;\n        });\n        const handleCompilationDonePromise = Promise.all([childCompilationResultPromise, didRecompilePromise]).then(_ref2 => {\n          let [childCompilationResult, didRecompile] = _ref2;\n\n          // Update hash and snapshot if childCompilation changed\n          if (didRecompile) {\n            mainCompilationHashOfLastChildRecompile = mainCompilation.hash;\n          }\n\n          this.compilationState = {\n            isCompiling: false,\n            isVerifyingCache: false,\n            entries: this.compilationState.entries,\n            compiledEntries: this.compilationState.entries,\n            compilationResult: childCompilationResult,\n            mainCompilationHash: mainCompilationHashOfLastChildRecompile\n          };\n        });\n        handleCompilationDonePromise.then(() => callback(null), callback);\n      }); // Continue compilation:\n\n      callback(null);\n    });\n  }\n  /**\n   * Add a new entry to the next compile run\n   * @param {string} entry\n   */\n\n\n  addEntry(entry) {\n    if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {\n      throw new Error('The child compiler has already started to compile. ' + \"Please add entries before the main compiler 'make' phase has started or \" + 'after the compilation is done.');\n    }\n\n    if (this.compilationState.entries.indexOf(entry) === -1) {\n      this.compilationState.entries = [...this.compilationState.entries, entry];\n    }\n  }\n\n  getLatestResult() {\n    if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {\n      throw new Error('The child compiler is not done compiling. ' + \"Please access the result after the compiler 'make' phase has started or \" + 'after the compilation is done.');\n    }\n\n    return {\n      mainCompilationHash: this.compilationState.mainCompilationHash,\n      compilationResult: this.compilationState.compilationResult\n    };\n  }\n  /**\n   * Verify that the cache is still valid\n   * @private\n   * @param {Snapshot | undefined} snapshot\n   * @param {WebpackCompilation} mainCompilation\n   * @returns {Promise<boolean>}\n   */\n\n\n  isCacheValid(snapshot, mainCompilation) {\n    if (!this.compilationState.isVerifyingCache) {\n      return Promise.reject(new Error('Cache validation can only be done right before the compilation starts'));\n    } // If there are no entries we don't need a new child compilation\n\n\n    if (this.compilationState.entries.length === 0) {\n      return Promise.resolve(true);\n    } // If there are new entries the cache is invalid\n\n\n    if (this.compilationState.entries !== this.compilationState.previousEntries) {\n      return Promise.resolve(false);\n    } // Mark the cache as invalid if there is no snapshot\n\n\n    if (!snapshot) {\n      return Promise.resolve(false);\n    }\n\n    return fileWatcherApi.isSnapShotValid(snapshot, mainCompilation);\n  }\n  /**\n   * Start to compile all templates\n   *\n   * @private\n   * @param {WebpackCompilation} mainCompilation\n   * @param {string[]} entries\n   * @returns {Promise<ChildCompilationResult>}\n   */\n\n\n  compileEntries(mainCompilation, entries) {\n    const compiler = new HtmlWebpackChildCompiler(entries);\n    return compiler.compileTemplates(mainCompilation).then(result => {\n      return {\n        // The compiled sources to render the content\n        compiledEntries: result,\n        // The file dependencies to find out if a\n        // recompilation is required\n        dependencies: compiler.fileDependencies,\n        // The main compilation hash can be used to find out\n        // if this compilation was done during the current compilation\n        mainCompilationHash: mainCompilation.hash\n      };\n    }, error => ({\n      // The compiled sources to render the content\n      error,\n      // The file dependencies to find out if a\n      // recompilation is required\n      dependencies: compiler.fileDependencies,\n      // The main compilation hash can be used to find out\n      // if this compilation was done during the current compilation\n      mainCompilationHash: mainCompilation.hash\n    }));\n  }\n  /**\n   * @private\n   * @param {WebpackCompilation} mainCompilation\n   * @param {FileDependencies} files\n   */\n\n\n  watchFiles(mainCompilation, files) {\n    fileWatcherApi.watchFiles(mainCompilation, files);\n  }\n\n}\n\nmodule.exports = {\n  CachedChildCompilation\n};","map":{"version":3,"names":["HtmlWebpackChildCompiler","require","fileWatcherApi","compilerMap","WeakMap","CachedChildCompilation","constructor","compiler","has","persistentChildCompilerSingletonPlugin","PersistentChildCompilerSingletonPlugin","set","apply","addEntry","entry","get","Error","getCompilationResult","getLatestResult","getCompilationEntryResult","latestResult","compilationResult","mainCompilationHash","error","compiledEntry","compiledEntries","compilationState","isCompiling","isVerifyingCache","entries","dependencies","fileDependencies","contextDependencies","missingDependencies","childCompilationResultPromise","Promise","resolve","mainCompilationHashOfLastChildRecompile","previousFileSystemSnapshot","compilationStartTime","Date","getTime","hooks","make","tapAsync","mainCompilation","callback","previousEntries","previousResult","isCacheValidPromise","isCacheValid","cachedResult","then","compiledEntriesPromise","compileEntries","childCompilationResult","createSnapshot","snapshot","optimizeTree","chunks","modules","handleCompilationDonePromise","watchFiles","additionalAssets","didRecompilePromise","all","didRecompile","hash","indexOf","reject","length","isSnapShotValid","compileTemplates","result","files","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/html-webpack-plugin/lib/cached-child-compiler.js"],"sourcesContent":["// @ts-check\n/**\n * @file\n * Helper plugin manages the cached state of the child compilation\n *\n * To optimize performance the child compilation is running asyncronously.\n * Therefore it needs to be started in the compiler.make phase and ends after\n * the compilation.afterCompile phase.\n *\n * To prevent bugs from blocked hooks there is no promise or event based api\n * for this plugin.\n *\n * Example usage:\n *\n * ```js\n    const childCompilerPlugin = new PersistentChildCompilerPlugin();\n    childCompilerPlugin.addEntry('./src/index.js');\n    compiler.hooks.afterCompile.tapAsync('MyPlugin', (compilation, callback) => {\n      console.log(childCompilerPlugin.getCompilationResult()['./src/index.js']));\n      return true;\n    });\n * ```\n */\n\n// Import types\n/** @typedef {import(\"webpack/lib/Compiler.js\")} WebpackCompiler */\n/** @typedef {import(\"webpack/lib/Compilation.js\")} WebpackCompilation */\n/** @typedef {{hash: string, entry: any, content: string }} ChildCompilationResultEntry */\n/** @typedef {import(\"./file-watcher-api\").Snapshot} Snapshot */\n/** @typedef {{fileDependencies: string[], contextDependencies: string[], missingDependencies: string[]}} FileDependencies */\n/** @typedef {{\n  dependencies: FileDependencies,\n  compiledEntries: {[entryName: string]: ChildCompilationResultEntry}\n} | {\n  dependencies: FileDependencies,\n  error: Error\n}} ChildCompilationResult */\n'use strict';\n\nconst { HtmlWebpackChildCompiler } = require('./child-compiler');\nconst fileWatcherApi = require('./file-watcher-api');\n\n/**\n * This plugin is a singleton for performance reasons.\n * To keep track if a plugin does already exist for the compiler they are cached\n * in this map\n * @type {WeakMap<WebpackCompiler, PersistentChildCompilerSingletonPlugin>}}\n */\nconst compilerMap = new WeakMap();\n\nclass CachedChildCompilation {\n  /**\n   * @param {WebpackCompiler} compiler\n   */\n  constructor (compiler) {\n    /**\n     * @private\n     * @type {WebpackCompiler}\n     */\n    this.compiler = compiler;\n    // Create a singleton instance for the compiler\n    // if there is none\n    if (compilerMap.has(compiler)) {\n      return;\n    }\n    const persistentChildCompilerSingletonPlugin = new PersistentChildCompilerSingletonPlugin();\n    compilerMap.set(compiler, persistentChildCompilerSingletonPlugin);\n    persistentChildCompilerSingletonPlugin.apply(compiler);\n  }\n\n  /**\n   * apply is called by the webpack main compiler during the start phase\n   * @param {string} entry\n   */\n  addEntry (entry) {\n    const persistentChildCompilerSingletonPlugin = compilerMap.get(this.compiler);\n    if (!persistentChildCompilerSingletonPlugin) {\n      throw new Error(\n        'PersistentChildCompilerSingletonPlugin instance not found.'\n      );\n    }\n    persistentChildCompilerSingletonPlugin.addEntry(entry);\n  }\n\n  getCompilationResult () {\n    const persistentChildCompilerSingletonPlugin = compilerMap.get(this.compiler);\n    if (!persistentChildCompilerSingletonPlugin) {\n      throw new Error(\n        'PersistentChildCompilerSingletonPlugin instance not found.'\n      );\n    }\n    return persistentChildCompilerSingletonPlugin.getLatestResult();\n  }\n\n  /**\n   * Returns the result for the given entry\n   * @param {string} entry\n   * @returns {\n      | { mainCompilationHash: string, error: Error }\n      | { mainCompilationHash: string, compiledEntry: ChildCompilationResultEntry }\n    }\n   */\n  getCompilationEntryResult (entry) {\n    const latestResult = this.getCompilationResult();\n    const compilationResult = latestResult.compilationResult;\n    return 'error' in compilationResult ? {\n      mainCompilationHash: latestResult.mainCompilationHash,\n      error: compilationResult.error\n    } : {\n      mainCompilationHash: latestResult.mainCompilationHash,\n      compiledEntry: compilationResult.compiledEntries[entry]\n    };\n  }\n}\n\nclass PersistentChildCompilerSingletonPlugin {\n  constructor () {\n    /**\n     * @private\n     * @type {\n      | {\n        isCompiling: false,\n        isVerifyingCache: false,\n        entries: string[],\n        compiledEntries: string[],\n        mainCompilationHash: string,\n        compilationResult: ChildCompilationResult\n      }\n    | Readonly<{\n      isCompiling: false,\n      isVerifyingCache: true,\n      entries: string[],\n      previousEntries: string[],\n      previousResult: ChildCompilationResult\n    }>\n    | Readonly <{\n      isVerifyingCache: false,\n      isCompiling: true,\n      entries: string[],\n    }>\n  } the internal compilation state */\n    this.compilationState = {\n      isCompiling: false,\n      isVerifyingCache: false,\n      entries: [],\n      compiledEntries: [],\n      mainCompilationHash: 'initial',\n      compilationResult: {\n        dependencies: {\n          fileDependencies: [],\n          contextDependencies: [],\n          missingDependencies: []\n        },\n        compiledEntries: {}\n      }\n    };\n  }\n\n  /**\n   * apply is called by the webpack main compiler during the start phase\n   * @param {WebpackCompiler} compiler\n   */\n  apply (compiler) {\n    /** @type Promise<ChildCompilationResult> */\n    let childCompilationResultPromise = Promise.resolve({\n      dependencies: {\n        fileDependencies: [],\n        contextDependencies: [],\n        missingDependencies: []\n      },\n      compiledEntries: {}\n    });\n    /**\n     * The main compilation hash which will only be updated\n     * if the childCompiler changes\n     */\n    let mainCompilationHashOfLastChildRecompile = '';\n    /** @typedef{Snapshot|undefined} */\n    let previousFileSystemSnapshot;\n    let compilationStartTime = new Date().getTime();\n\n    compiler.hooks.make.tapAsync(\n      'PersistentChildCompilerSingletonPlugin',\n      (mainCompilation, callback) => {\n        if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {\n          return callback(new Error('Child compilation has already started'));\n        }\n\n        // Update the time to the current compile start time\n        compilationStartTime = new Date().getTime();\n\n        // The compilation starts - adding new templates is now not possible anymore\n        this.compilationState = {\n          isCompiling: false,\n          isVerifyingCache: true,\n          previousEntries: this.compilationState.compiledEntries,\n          previousResult: this.compilationState.compilationResult,\n          entries: this.compilationState.entries\n        };\n\n        // Validate cache:\n        const isCacheValidPromise = this.isCacheValid(previousFileSystemSnapshot, mainCompilation);\n\n        let cachedResult = childCompilationResultPromise;\n        childCompilationResultPromise = isCacheValidPromise.then((isCacheValid) => {\n          // Reuse cache\n          if (isCacheValid) {\n            return cachedResult;\n          }\n          // Start the compilation\n          const compiledEntriesPromise = this.compileEntries(\n            mainCompilation,\n            this.compilationState.entries\n          );\n          // Update snapshot as soon as we know the filedependencies\n          // this might possibly cause bugs if files were changed inbetween\n          // compilation start and snapshot creation\n          compiledEntriesPromise.then((childCompilationResult) => {\n            return fileWatcherApi.createSnapshot(childCompilationResult.dependencies, mainCompilation, compilationStartTime);\n          }).then((snapshot) => {\n            previousFileSystemSnapshot = snapshot;\n          });\n          return compiledEntriesPromise;\n        });\n\n        // Add files to compilation which needs to be watched:\n        mainCompilation.hooks.optimizeTree.tapAsync(\n          'PersistentChildCompilerSingletonPlugin',\n          (chunks, modules, callback) => {\n            const handleCompilationDonePromise = childCompilationResultPromise.then(\n              childCompilationResult => {\n                this.watchFiles(\n                  mainCompilation,\n                  childCompilationResult.dependencies\n                );\n              });\n            handleCompilationDonePromise.then(() => callback(null, chunks, modules), callback);\n          }\n        );\n\n        // Store the final compilation once the main compilation hash is known\n        mainCompilation.hooks.additionalAssets.tapAsync(\n          'PersistentChildCompilerSingletonPlugin',\n          (callback) => {\n            const didRecompilePromise = Promise.all([childCompilationResultPromise, cachedResult]).then(\n              ([childCompilationResult, cachedResult]) => {\n                // Update if childCompilation changed\n                return (cachedResult !== childCompilationResult);\n              }\n            );\n\n            const handleCompilationDonePromise = Promise.all([childCompilationResultPromise, didRecompilePromise]).then(\n              ([childCompilationResult, didRecompile]) => {\n                // Update hash and snapshot if childCompilation changed\n                if (didRecompile) {\n                  mainCompilationHashOfLastChildRecompile = mainCompilation.hash;\n                }\n                this.compilationState = {\n                  isCompiling: false,\n                  isVerifyingCache: false,\n                  entries: this.compilationState.entries,\n                  compiledEntries: this.compilationState.entries,\n                  compilationResult: childCompilationResult,\n                  mainCompilationHash: mainCompilationHashOfLastChildRecompile\n                };\n              });\n            handleCompilationDonePromise.then(() => callback(null), callback);\n          }\n        );\n\n        // Continue compilation:\n        callback(null);\n      }\n    );\n  }\n\n  /**\n   * Add a new entry to the next compile run\n   * @param {string} entry\n   */\n  addEntry (entry) {\n    if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {\n      throw new Error(\n        'The child compiler has already started to compile. ' +\n        \"Please add entries before the main compiler 'make' phase has started or \" +\n        'after the compilation is done.'\n      );\n    }\n    if (this.compilationState.entries.indexOf(entry) === -1) {\n      this.compilationState.entries = [...this.compilationState.entries, entry];\n    }\n  }\n\n  getLatestResult () {\n    if (this.compilationState.isCompiling || this.compilationState.isVerifyingCache) {\n      throw new Error(\n        'The child compiler is not done compiling. ' +\n        \"Please access the result after the compiler 'make' phase has started or \" +\n        'after the compilation is done.'\n      );\n    }\n    return {\n      mainCompilationHash: this.compilationState.mainCompilationHash,\n      compilationResult: this.compilationState.compilationResult\n    };\n  }\n\n  /**\n   * Verify that the cache is still valid\n   * @private\n   * @param {Snapshot | undefined} snapshot\n   * @param {WebpackCompilation} mainCompilation\n   * @returns {Promise<boolean>}\n   */\n  isCacheValid (snapshot, mainCompilation) {\n    if (!this.compilationState.isVerifyingCache) {\n      return Promise.reject(new Error('Cache validation can only be done right before the compilation starts'));\n    }\n    // If there are no entries we don't need a new child compilation\n    if (this.compilationState.entries.length === 0) {\n      return Promise.resolve(true);\n    }\n    // If there are new entries the cache is invalid\n    if (this.compilationState.entries !== this.compilationState.previousEntries) {\n      return Promise.resolve(false);\n    }\n    // Mark the cache as invalid if there is no snapshot\n    if (!snapshot) {\n      return Promise.resolve(false);\n    }\n    return fileWatcherApi.isSnapShotValid(snapshot, mainCompilation);\n  }\n\n  /**\n   * Start to compile all templates\n   *\n   * @private\n   * @param {WebpackCompilation} mainCompilation\n   * @param {string[]} entries\n   * @returns {Promise<ChildCompilationResult>}\n   */\n  compileEntries (mainCompilation, entries) {\n    const compiler = new HtmlWebpackChildCompiler(entries);\n    return compiler.compileTemplates(mainCompilation).then((result) => {\n      return {\n      // The compiled sources to render the content\n        compiledEntries: result,\n        // The file dependencies to find out if a\n        // recompilation is required\n        dependencies: compiler.fileDependencies,\n        // The main compilation hash can be used to find out\n        // if this compilation was done during the current compilation\n        mainCompilationHash: mainCompilation.hash\n      };\n    }, error => ({\n      // The compiled sources to render the content\n      error,\n      // The file dependencies to find out if a\n      // recompilation is required\n      dependencies: compiler.fileDependencies,\n      // The main compilation hash can be used to find out\n      // if this compilation was done during the current compilation\n      mainCompilationHash: mainCompilation.hash\n    }));\n  }\n\n  /**\n   * @private\n   * @param {WebpackCompilation} mainCompilation\n   * @param {FileDependencies} files\n   */\n  watchFiles (mainCompilation, files) {\n    fileWatcherApi.watchFiles(mainCompilation, files);\n  }\n}\n\nmodule.exports = {\n  CachedChildCompilation\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}