{"ast":null,"code":"#!/usr/bin/env node\n\n/**\n * @fileoverview Main CLI that is run via the eslint command.\n * @author Nicholas C. Zakas\n */\n\n/* eslint no-console:off -- CLI */\n\"use strict\"; // must do this initialization *before* other requires in order to work\n\nif (process.argv.includes(\"--debug\")) {\n  require(\"debug\").enable(\"eslint:*,-eslint:code-path,eslintrc:*\");\n} //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Read data from stdin til the end.\n *\n * Note: See\n * - https://github.com/nodejs/node/blob/master/doc/api/process.md#processstdin\n * - https://github.com/nodejs/node/blob/master/doc/api/process.md#a-note-on-process-io\n * - https://lists.gnu.org/archive/html/bug-gnu-emacs/2016-01/msg00419.html\n * - https://github.com/nodejs/node/issues/7439 (historical)\n *\n * On Windows using `fs.readFileSync(STDIN_FILE_DESCRIPTOR, \"utf8\")` seems\n * to read 4096 bytes before blocking and never drains to read further data.\n *\n * The investigation on the Emacs thread indicates:\n *\n * > Emacs on MS-Windows uses pipes to communicate with subprocesses; a\n * > pipe on Windows has a 4K buffer. So as soon as Emacs writes more than\n * > 4096 bytes to the pipe, the pipe becomes full, and Emacs then waits for\n * > the subprocess to read its end of the pipe, at which time Emacs will\n * > write the rest of the stuff.\n * @returns {Promise<string>} The read text.\n */\n\n\nfunction readStdin() {\n  return new Promise((resolve, reject) => {\n    let content = \"\";\n    let chunk = \"\";\n    process.stdin.setEncoding(\"utf8\").on(\"readable\", () => {\n      while ((chunk = process.stdin.read()) !== null) {\n        content += chunk;\n      }\n    }).on(\"end\", () => resolve(content)).on(\"error\", reject);\n  });\n}\n/**\n * Get the error message of a given value.\n * @param {any} error The value to get.\n * @returns {string} The error message.\n */\n\n\nfunction getErrorMessage(error) {\n  // Lazy loading because this is used only if an error happened.\n  const util = require(\"util\"); // Foolproof -- third-party module might throw non-object.\n\n\n  if (typeof error !== \"object\" || error === null) {\n    return String(error);\n  } // Use templates if `error.messageTemplate` is present.\n\n\n  if (typeof error.messageTemplate === \"string\") {\n    try {\n      const template = require(`../messages/${error.messageTemplate}.js`);\n\n      return template(error.messageData || {});\n    } catch {// Ignore template error then fallback to use `error.stack`.\n    }\n  } // Use the stacktrace if it's an error object.\n\n\n  if (typeof error.stack === \"string\") {\n    return error.stack;\n  } // Otherwise, dump the object.\n\n\n  return util.format(\"%o\", error);\n}\n/**\n * Catch and report unexpected error.\n * @param {any} error The thrown error object.\n * @returns {void}\n */\n\n\nfunction onFatalError(error) {\n  process.exitCode = 2;\n\n  const {\n    version\n  } = require(\"../package.json\");\n\n  const message = getErrorMessage(error);\n  console.error(`\nOops! Something went wrong! :(\n\nESLint: ${version}\n\n${message}`);\n} //------------------------------------------------------------------------------\n// Execution\n//------------------------------------------------------------------------------\n\n\n(async function main() {\n  process.on(\"uncaughtException\", onFatalError);\n  process.on(\"unhandledRejection\", onFatalError); // Call the config initializer if `--init` is present.\n\n  if (process.argv.includes(\"--init\")) {\n    // `eslint --init` has been moved to `@eslint/create-config`\n    console.warn(\"You can also run this command directly using 'npm init @eslint/config'.\");\n\n    const spawn = require(\"cross-spawn\");\n\n    spawn.sync(\"npm\", [\"init\", \"@eslint/config\"], {\n      encoding: \"utf8\",\n      stdio: \"inherit\"\n    });\n    return;\n  } // Otherwise, call the CLI.\n\n\n  process.exitCode = await require(\"../lib/cli\").execute(process.argv, process.argv.includes(\"--stdin\") ? await readStdin() : null, true);\n})().catch(onFatalError);","map":{"version":3,"names":["process","argv","includes","require","enable","readStdin","Promise","resolve","reject","content","chunk","stdin","setEncoding","on","read","getErrorMessage","error","util","String","messageTemplate","template","messageData","stack","format","onFatalError","exitCode","version","message","console","main","warn","spawn","sync","encoding","stdio","execute","catch"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/bin/eslint.js"],"sourcesContent":["#!/usr/bin/env node\n\n/**\n * @fileoverview Main CLI that is run via the eslint command.\n * @author Nicholas C. Zakas\n */\n\n/* eslint no-console:off -- CLI */\n\n\"use strict\";\n\n// must do this initialization *before* other requires in order to work\nif (process.argv.includes(\"--debug\")) {\n    require(\"debug\").enable(\"eslint:*,-eslint:code-path,eslintrc:*\");\n}\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Read data from stdin til the end.\n *\n * Note: See\n * - https://github.com/nodejs/node/blob/master/doc/api/process.md#processstdin\n * - https://github.com/nodejs/node/blob/master/doc/api/process.md#a-note-on-process-io\n * - https://lists.gnu.org/archive/html/bug-gnu-emacs/2016-01/msg00419.html\n * - https://github.com/nodejs/node/issues/7439 (historical)\n *\n * On Windows using `fs.readFileSync(STDIN_FILE_DESCRIPTOR, \"utf8\")` seems\n * to read 4096 bytes before blocking and never drains to read further data.\n *\n * The investigation on the Emacs thread indicates:\n *\n * > Emacs on MS-Windows uses pipes to communicate with subprocesses; a\n * > pipe on Windows has a 4K buffer. So as soon as Emacs writes more than\n * > 4096 bytes to the pipe, the pipe becomes full, and Emacs then waits for\n * > the subprocess to read its end of the pipe, at which time Emacs will\n * > write the rest of the stuff.\n * @returns {Promise<string>} The read text.\n */\nfunction readStdin() {\n    return new Promise((resolve, reject) => {\n        let content = \"\";\n        let chunk = \"\";\n\n        process.stdin\n            .setEncoding(\"utf8\")\n            .on(\"readable\", () => {\n                while ((chunk = process.stdin.read()) !== null) {\n                    content += chunk;\n                }\n            })\n            .on(\"end\", () => resolve(content))\n            .on(\"error\", reject);\n    });\n}\n\n/**\n * Get the error message of a given value.\n * @param {any} error The value to get.\n * @returns {string} The error message.\n */\nfunction getErrorMessage(error) {\n\n    // Lazy loading because this is used only if an error happened.\n    const util = require(\"util\");\n\n    // Foolproof -- third-party module might throw non-object.\n    if (typeof error !== \"object\" || error === null) {\n        return String(error);\n    }\n\n    // Use templates if `error.messageTemplate` is present.\n    if (typeof error.messageTemplate === \"string\") {\n        try {\n            const template = require(`../messages/${error.messageTemplate}.js`);\n\n            return template(error.messageData || {});\n        } catch {\n\n            // Ignore template error then fallback to use `error.stack`.\n        }\n    }\n\n    // Use the stacktrace if it's an error object.\n    if (typeof error.stack === \"string\") {\n        return error.stack;\n    }\n\n    // Otherwise, dump the object.\n    return util.format(\"%o\", error);\n}\n\n/**\n * Catch and report unexpected error.\n * @param {any} error The thrown error object.\n * @returns {void}\n */\nfunction onFatalError(error) {\n    process.exitCode = 2;\n\n    const { version } = require(\"../package.json\");\n    const message = getErrorMessage(error);\n\n    console.error(`\nOops! Something went wrong! :(\n\nESLint: ${version}\n\n${message}`);\n}\n\n//------------------------------------------------------------------------------\n// Execution\n//------------------------------------------------------------------------------\n\n(async function main() {\n    process.on(\"uncaughtException\", onFatalError);\n    process.on(\"unhandledRejection\", onFatalError);\n\n    // Call the config initializer if `--init` is present.\n    if (process.argv.includes(\"--init\")) {\n\n        // `eslint --init` has been moved to `@eslint/create-config`\n        console.warn(\"You can also run this command directly using 'npm init @eslint/config'.\");\n\n        const spawn = require(\"cross-spawn\");\n\n        spawn.sync(\"npm\", [\"init\", \"@eslint/config\"], { encoding: \"utf8\", stdio: \"inherit\" });\n        return;\n    }\n\n    // Otherwise, call the CLI.\n    process.exitCode = await require(\"../lib/cli\").execute(\n        process.argv,\n        process.argv.includes(\"--stdin\") ? await readStdin() : null,\n        true\n    );\n}()).catch(onFatalError);\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA,a,CAEA;;AACA,IAAIA,OAAO,CAACC,IAAR,CAAaC,QAAb,CAAsB,SAAtB,CAAJ,EAAsC;EAClCC,OAAO,CAAC,OAAD,CAAP,CAAiBC,MAAjB,CAAwB,uCAAxB;AACH,C,CAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,SAAT,GAAqB;EACjB,OAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;IACpC,IAAIC,OAAO,GAAG,EAAd;IACA,IAAIC,KAAK,GAAG,EAAZ;IAEAV,OAAO,CAACW,KAAR,CACKC,WADL,CACiB,MADjB,EAEKC,EAFL,CAEQ,UAFR,EAEoB,MAAM;MAClB,OAAO,CAACH,KAAK,GAAGV,OAAO,CAACW,KAAR,CAAcG,IAAd,EAAT,MAAmC,IAA1C,EAAgD;QAC5CL,OAAO,IAAIC,KAAX;MACH;IACJ,CANL,EAOKG,EAPL,CAOQ,KAPR,EAOe,MAAMN,OAAO,CAACE,OAAD,CAP5B,EAQKI,EARL,CAQQ,OARR,EAQiBL,MARjB;EASH,CAbM,CAAP;AAcH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASO,eAAT,CAAyBC,KAAzB,EAAgC;EAE5B;EACA,MAAMC,IAAI,GAAGd,OAAO,CAAC,MAAD,CAApB,CAH4B,CAK5B;;;EACA,IAAI,OAAOa,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAA3C,EAAiD;IAC7C,OAAOE,MAAM,CAACF,KAAD,CAAb;EACH,CAR2B,CAU5B;;;EACA,IAAI,OAAOA,KAAK,CAACG,eAAb,KAAiC,QAArC,EAA+C;IAC3C,IAAI;MACA,MAAMC,QAAQ,GAAGjB,OAAO,CAAE,eAAca,KAAK,CAACG,eAAgB,KAAtC,CAAxB;;MAEA,OAAOC,QAAQ,CAACJ,KAAK,CAACK,WAAN,IAAqB,EAAtB,CAAf;IACH,CAJD,CAIE,MAAM,CAEJ;IACH;EACJ,CApB2B,CAsB5B;;;EACA,IAAI,OAAOL,KAAK,CAACM,KAAb,KAAuB,QAA3B,EAAqC;IACjC,OAAON,KAAK,CAACM,KAAb;EACH,CAzB2B,CA2B5B;;;EACA,OAAOL,IAAI,CAACM,MAAL,CAAY,IAAZ,EAAkBP,KAAlB,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASQ,YAAT,CAAsBR,KAAtB,EAA6B;EACzBhB,OAAO,CAACyB,QAAR,GAAmB,CAAnB;;EAEA,MAAM;IAAEC;EAAF,IAAcvB,OAAO,CAAC,iBAAD,CAA3B;;EACA,MAAMwB,OAAO,GAAGZ,eAAe,CAACC,KAAD,CAA/B;EAEAY,OAAO,CAACZ,KAAR,CAAe;AACnB;AACA;AACA,UAAUU,OAAQ;AAClB;AACA,EAAEC,OAAQ,EALN;AAMH,C,CAED;AACA;AACA;;;AAEC,gBAAeE,IAAf,GAAsB;EACnB7B,OAAO,CAACa,EAAR,CAAW,mBAAX,EAAgCW,YAAhC;EACAxB,OAAO,CAACa,EAAR,CAAW,oBAAX,EAAiCW,YAAjC,EAFmB,CAInB;;EACA,IAAIxB,OAAO,CAACC,IAAR,CAAaC,QAAb,CAAsB,QAAtB,CAAJ,EAAqC;IAEjC;IACA0B,OAAO,CAACE,IAAR,CAAa,yEAAb;;IAEA,MAAMC,KAAK,GAAG5B,OAAO,CAAC,aAAD,CAArB;;IAEA4B,KAAK,CAACC,IAAN,CAAW,KAAX,EAAkB,CAAC,MAAD,EAAS,gBAAT,CAAlB,EAA8C;MAAEC,QAAQ,EAAE,MAAZ;MAAoBC,KAAK,EAAE;IAA3B,CAA9C;IACA;EACH,CAdkB,CAgBnB;;;EACAlC,OAAO,CAACyB,QAAR,GAAmB,MAAMtB,OAAO,CAAC,YAAD,CAAP,CAAsBgC,OAAtB,CACrBnC,OAAO,CAACC,IADa,EAErBD,OAAO,CAACC,IAAR,CAAaC,QAAb,CAAsB,SAAtB,IAAmC,MAAMG,SAAS,EAAlD,GAAuD,IAFlC,EAGrB,IAHqB,CAAzB;AAKH,CAtBA,GAAD,CAsBK+B,KAtBL,CAsBWZ,YAtBX"},"metadata":{},"sourceType":"script"}