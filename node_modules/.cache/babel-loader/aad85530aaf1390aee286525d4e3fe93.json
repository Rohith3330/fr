{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst util_1 = require(\"../../compile/util\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst nullable_1 = require(\"./nullable\");\n\nconst error_1 = require(\"./error\");\n\nconst def = {\n  keyword: \"values\",\n  schemaType: \"object\",\n  error: (0, error_1.typeError)(\"object\"),\n\n  code(cxt) {\n    (0, metadata_1.checkMetadata)(cxt);\n    const {\n      gen,\n      data,\n      schema,\n      it\n    } = cxt;\n    if ((0, util_1.alwaysValidSchema)(it, schema)) return;\n    const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);\n    gen.if(cond);\n    gen.assign(valid, validateMap());\n    gen.elseIf((0, codegen_1.not)(valid));\n    cxt.error();\n    gen.endIf();\n    cxt.ok(valid);\n\n    function validateMap() {\n      const _valid = gen.name(\"valid\");\n\n      if (it.allErrors) {\n        const validMap = gen.let(\"valid\", true);\n        validateValues(() => gen.assign(validMap, false));\n        return validMap;\n      }\n\n      gen.var(_valid, true);\n      validateValues(() => gen.break());\n      return _valid;\n\n      function validateValues(notValid) {\n        gen.forIn(\"key\", data, key => {\n          cxt.subschema({\n            keyword: \"values\",\n            dataProp: key,\n            dataPropType: util_1.Type.Str\n          }, _valid);\n          gen.if((0, codegen_1.not)(_valid), notValid);\n        });\n      }\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":";;;;;;AAEA;;AACA;;AACA;;AACA;;AACA;;AAIA,MAAMA,GAAG,GAA0B;EACjCC,OAAO,EAAE,QADwB;EAEjCC,UAAU,EAAE,QAFqB;EAGjCC,KAAK,EAAE,uBAAU,QAAV,CAH0B;;EAIjCC,IAAI,CAACC,GAAD,EAAgB;IAClB,8BAAcA,GAAd;IACA,MAAM;MAACC,GAAD;MAAMC,IAAN;MAAYC,MAAZ;MAAoBC;IAApB,IAA0BJ,GAAhC;IACA,IAAI,8BAAkBI,EAAlB,EAAsBD,MAAtB,CAAJ,EAAmC;IACnC,MAAM,CAACE,KAAD,EAAQC,IAAR,IAAgB,oCAAoBN,GAApB,EAAyBE,IAAzB,CAAtB;IACAD,GAAG,CAACM,EAAJ,CAAOD,IAAP;IACAL,GAAG,CAACO,MAAJ,CAAWH,KAAX,EAAkBI,WAAW,EAA7B;IACAR,GAAG,CAACS,MAAJ,CAAW,mBAAIL,KAAJ,CAAX;IACAL,GAAG,CAACF,KAAJ;IACAG,GAAG,CAACU,KAAJ;IACAX,GAAG,CAACY,EAAJ,CAAOP,KAAP;;IAEA,SAASI,WAAT,GAAoB;MAClB,MAAMI,MAAM,GAAGZ,GAAG,CAACa,IAAJ,CAAS,OAAT,CAAf;;MACA,IAAIV,EAAE,CAACW,SAAP,EAAkB;QAChB,MAAMC,QAAQ,GAAGf,GAAG,CAACgB,GAAJ,CAAQ,OAAR,EAAiB,IAAjB,CAAjB;QACAC,cAAc,CAAC,MAAMjB,GAAG,CAACO,MAAJ,CAAWQ,QAAX,EAAqB,KAArB,CAAP,CAAd;QACA,OAAOA,QAAP;MACD;;MACDf,GAAG,CAACkB,GAAJ,CAAQN,MAAR,EAAgB,IAAhB;MACAK,cAAc,CAAC,MAAMjB,GAAG,CAACmB,KAAJ,EAAP,CAAd;MACA,OAAOP,MAAP;;MAEA,SAASK,cAAT,CAAwBG,QAAxB,EAA4C;QAC1CpB,GAAG,CAACqB,KAAJ,CAAU,KAAV,EAAiBpB,IAAjB,EAAwBqB,GAAD,IAAQ;UAC7BvB,GAAG,CAACwB,SAAJ,CACE;YACE5B,OAAO,EAAE,QADX;YAEE6B,QAAQ,EAAEF,GAFZ;YAGEG,YAAY,EAAEC,YAAKC;UAHrB,CADF,EAMEf,MANF;UAQAZ,GAAG,CAACM,EAAJ,CAAO,mBAAIM,MAAJ,CAAP,EAAoBQ,QAApB;QACD,CAVD;MAWD;IACF;EACF;;AAzCgC,CAAnC;AA4CAQ,kBAAelC,GAAf","names":["def","keyword","schemaType","error","code","cxt","gen","data","schema","it","valid","cond","if","assign","validateMap","elseIf","endIf","ok","_valid","name","allErrors","validMap","let","validateValues","var","break","notValid","forIn","key","subschema","dataProp","dataPropType","util_1","Str","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\mini-css-extract-plugin\\node_modules\\ajv\\lib\\vocabularies\\jtd\\values.ts"],"sourcesContent":["import type {CodeKeywordDefinition, SchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema, Type} from \"../../compile/util\"\nimport {not, Name} from \"../../compile/codegen\"\nimport {checkMetadata} from \"./metadata\"\nimport {checkNullableObject} from \"./nullable\"\nimport {typeError, _JTDTypeError} from \"./error\"\n\nexport type JTDValuesError = _JTDTypeError<\"values\", \"object\", SchemaObject>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"values\",\n  schemaType: \"object\",\n  error: typeError(\"object\"),\n  code(cxt: KeywordCxt) {\n    checkMetadata(cxt)\n    const {gen, data, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const [valid, cond] = checkNullableObject(cxt, data)\n    gen.if(cond)\n    gen.assign(valid, validateMap())\n    gen.elseIf(not(valid))\n    cxt.error()\n    gen.endIf()\n    cxt.ok(valid)\n\n    function validateMap(): Name | boolean {\n      const _valid = gen.name(\"valid\")\n      if (it.allErrors) {\n        const validMap = gen.let(\"valid\", true)\n        validateValues(() => gen.assign(validMap, false))\n        return validMap\n      }\n      gen.var(_valid, true)\n      validateValues(() => gen.break())\n      return _valid\n\n      function validateValues(notValid: () => void): void {\n        gen.forIn(\"key\", data, (key) => {\n          cxt.subschema(\n            {\n              keyword: \"values\",\n              dataProp: key,\n              dataPropType: Type.Str,\n            },\n            _valid\n          )\n          gen.if(not(_valid), notValid)\n        })\n      }\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}