{"ast":null,"code":"\"use strict\";\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // A simple implementation of make-array\n\n\nfunction makeArray(subject) {\n  return Array.isArray(subject) ? subject : [subject];\n}\n\nvar EMPTY = '';\nvar SPACE = ' ';\nvar ESCAPE = '\\\\';\nvar REGEX_TEST_BLANK_LINE = /^\\s+$/;\nvar REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/;\nvar REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/;\nvar REGEX_SPLITALL_CRLF = /\\r?\\n/g; // /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\n\nvar REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/;\nvar SLASH = '/';\nvar KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol[\"for\"]('node-ignore')\n/* istanbul ignore next */\n: 'node-ignore';\n\nvar define = function define(object, key, value) {\n  return Object.defineProperty(object, key, {\n    value: value\n  });\n};\n\nvar REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;\n\nvar RETURN_FALSE = function RETURN_FALSE() {\n  return false;\n}; // Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\n\n\nvar sanitizeRange = function sanitizeRange(range) {\n  return range.replace(REGEX_REGEXP_RANGE, function (match, from, to) {\n    return from.charCodeAt(0) <= to.charCodeAt(0) ? match // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : EMPTY;\n  });\n}; // See fixtures #59\n\n\nvar cleanRangeBackSlash = function cleanRangeBackSlash(slashes) {\n  var length = slashes.length;\n  return slashes.slice(0, length - length % 2);\n}; // > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n// '`foo/`' should not continue with the '`..`'\n\n\nvar REPLACERS = [// > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n[// (a\\ ) -> (a )\n// (a  ) -> (a)\n// (a \\ ) -> (a  )\n/\\\\?\\s+$/, function (match) {\n  return match.indexOf('\\\\') === 0 ? SPACE : EMPTY;\n}], // replace (\\ ) with ' '\n[/\\\\\\s/g, function () {\n  return SPACE;\n}], // Escape metacharacters\n// which is written down by users but means special for regular expressions.\n// > There are 12 characters with special meanings:\n// > - the backslash \\,\n// > - the caret ^,\n// > - the dollar sign $,\n// > - the period or dot .,\n// > - the vertical bar or pipe symbol |,\n// > - the question mark ?,\n// > - the asterisk or star *,\n// > - the plus sign +,\n// > - the opening parenthesis (,\n// > - the closing parenthesis ),\n// > - and the opening square bracket [,\n// > - the opening curly brace {,\n// > These special characters are often called \"metacharacters\".\n[/[\\\\$.|*+(){^]/g, function (match) {\n  return \"\\\\\".concat(match);\n}], [// > a question mark (?) matches a single character\n/(?!\\\\)\\?/g, function () {\n  return '[^/]';\n}], // leading slash\n[// > A leading slash matches the beginning of the pathname.\n// > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n// A leading slash matches the beginning of the pathname\n/^\\//, function () {\n  return '^';\n}], // replace special metacharacter slash after the leading slash\n[/\\//g, function () {\n  return '\\\\/';\n}], [// > A leading \"**\" followed by a slash means match in all directories.\n// > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n// > the same as pattern \"foo\".\n// > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n// >   under directory \"foo\".\n// Notice that the '*'s have been replaced as '\\\\*'\n/^\\^*\\\\\\*\\\\\\*\\\\\\//, // '**/foo' <-> 'foo'\nfunction () {\n  return '^(?:.*\\\\/)?';\n}], // starting\n[// there will be no leading '/'\n//   (which has been replaced by section \"leading slash\")\n// If starts with '**', adding a '^' to the regular expression also works\n/^(?=[^^])/, function startingReplacer() {\n  // If has a slash `/` at the beginning or middle\n  return !/\\/(?!$)/.test(this) // > Prior to 2.22.1\n  // > If the pattern does not contain a slash /,\n  // >   Git treats it as a shell glob pattern\n  // Actually, if there is only a trailing slash,\n  //   git also treats it as a shell glob pattern\n  // After 2.22.1 (compatible but clearer)\n  // > If there is a separator at the beginning or middle (or both)\n  // > of the pattern, then the pattern is relative to the directory\n  // > level of the particular .gitignore file itself.\n  // > Otherwise the pattern may also match at any level below\n  // > the .gitignore level.\n  ? '(?:^|\\\\/)' // > Otherwise, Git treats the pattern as a shell glob suitable for\n  // >   consumption by fnmatch(3)\n  : '^';\n}], // two globstars\n[// Use lookahead assertions so that we could match more than one `'/**'`\n/\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g, // Zero, one or several directories\n// should not use '*', or it will be replaced by the next replacer\n// Check if it is not the last `'/**'`\nfunction (_, index, str) {\n  return index + 6 < str.length // case: /**/\n  // > A slash followed by two consecutive asterisks then a slash matches\n  // >   zero or more directories.\n  // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n  // '/**/'\n  ? '(?:\\\\/[^\\\\/]+)*' // case: /**\n  // > A trailing `\"/**\"` matches everything inside.\n  // #21: everything inside but it should not include the current folder\n  : '\\\\/.+';\n}], // intermediate wildcards\n[// Never replace escaped '*'\n// ignore rule '\\*' will match the path '*'\n// 'abc.*/' -> go\n// 'abc.*'  -> skip this rule\n/(^|[^\\\\]+)\\\\\\*(?=.+)/g, // '*.js' matches '.js'\n// '*.js' doesn't match 'abc'\nfunction (_, p1) {\n  return \"\".concat(p1, \"[^\\\\/]*\");\n}], [// unescape, revert step 3 except for back slash\n// For example, if a user escape a '\\\\*',\n// after step 3, the result will be '\\\\\\\\\\\\*'\n/\\\\\\\\\\\\(?=[$.|*+(){^])/g, function () {\n  return ESCAPE;\n}], [// '\\\\\\\\' -> '\\\\'\n/\\\\\\\\/g, function () {\n  return ESCAPE;\n}], [// > The range notation, e.g. [a-zA-Z],\n// > can be used to match one of the characters in a range.\n// `\\` is escaped by step 3\n/(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g, function (match, leadEscape, range, endEscape, close) {\n  return leadEscape === ESCAPE // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n  ? \"\\\\[\".concat(range).concat(cleanRangeBackSlash(endEscape)).concat(close) : close === ']' ? endEscape.length % 2 === 0 // A normal case, and it is a range notation\n  // '[bar]'\n  // '[bar\\\\\\\\]'\n  ? \"[\".concat(sanitizeRange(range)).concat(endEscape, \"]\") // Invalid range notaton\n  // '[bar\\\\]' -> '[bar\\\\\\\\]'\n  : '[]' : '[]';\n}], // ending\n[// 'js' will not match 'js.'\n// 'ab' will not match 'abc'\n/(?:[^*])$/, // WTF!\n// https://git-scm.com/docs/gitignore\n// changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n// which re-fixes #24, #38\n// > If there is a separator at the end of the pattern then the pattern\n// > will only match directories, otherwise the pattern can match both\n// > files and directories.\n// 'js*' will not match 'a.js'\n// 'js/' will not match 'a.js'\n// 'js' will match 'a.js' and 'a.js/'\nfunction (match) {\n  return /\\/$/.test(match) // foo/ will not match 'foo'\n  ? \"\".concat(match, \"$\") // foo matches 'foo' and 'foo/'\n  : \"\".concat(match, \"(?=$|\\\\/$)\");\n}], // trailing wildcard\n[/(\\^|\\\\\\/)?\\\\\\*$/, function (_, p1) {\n  var prefix = p1 // '\\^':\n  // '/*' does not match EMPTY\n  // '/*' does not match everything\n  // '\\\\\\/':\n  // 'abc/*' does not match 'abc/'\n  ? \"\".concat(p1, \"[^/]+\") // 'a*' matches 'a'\n  // 'a*' matches 'aa'\n  : '[^/]*';\n  return \"\".concat(prefix, \"(?=$|\\\\/$)\");\n}]]; // A simple cache, because an ignore rule only has only one certain meaning\n\nvar regexCache = Object.create(null); // @param {pattern}\n\nvar makeRegex = function makeRegex(pattern, ignoreCase) {\n  var source = regexCache[pattern];\n\n  if (!source) {\n    source = REPLACERS.reduce(function (prev, current) {\n      return prev.replace(current[0], current[1].bind(pattern));\n    }, pattern);\n    regexCache[pattern] = source;\n  }\n\n  return ignoreCase ? new RegExp(source, 'i') : new RegExp(source);\n};\n\nvar isString = function isString(subject) {\n  return typeof subject === 'string';\n}; // > A blank line matches no files, so it can serve as a separator for readability.\n\n\nvar checkPattern = function checkPattern(pattern) {\n  return pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0;\n};\n\nvar splitPattern = function splitPattern(pattern) {\n  return pattern.split(REGEX_SPLITALL_CRLF);\n};\n\nvar IgnoreRule = function IgnoreRule(origin, pattern, negative, regex) {\n  _classCallCheck(this, IgnoreRule);\n\n  this.origin = origin;\n  this.pattern = pattern;\n  this.negative = negative;\n  this.regex = regex;\n};\n\nvar createRule = function createRule(pattern, ignoreCase) {\n  var origin = pattern;\n  var negative = false; // > An optional prefix \"!\" which negates the pattern;\n\n  if (pattern.indexOf('!') === 0) {\n    negative = true;\n    pattern = pattern.substr(1);\n  }\n\n  pattern = pattern // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!') // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');\n  var regex = makeRegex(pattern, ignoreCase);\n  return new IgnoreRule(origin, pattern, negative, regex);\n};\n\nvar throwError = function throwError(message, Ctor) {\n  throw new Ctor(message);\n};\n\nvar checkPath = function checkPath(path, originalPath, doThrow) {\n  if (!isString(path)) {\n    return doThrow(\"path must be a string, but got `\".concat(originalPath, \"`\"), TypeError);\n  } // We don't know if we should ignore EMPTY, so throw\n\n\n  if (!path) {\n    return doThrow(\"path must not be empty\", TypeError);\n  } // Check if it is a relative path\n\n\n  if (checkPath.isNotRelative(path)) {\n    var r = '`path.relative()`d';\n    return doThrow(\"path should be a \".concat(r, \" string, but got \\\"\").concat(originalPath, \"\\\"\"), RangeError);\n  }\n\n  return true;\n};\n\nvar isNotRelative = function isNotRelative(path) {\n  return REGEX_TEST_INVALID_PATH.test(path);\n};\n\ncheckPath.isNotRelative = isNotRelative;\n\ncheckPath.convert = function (p) {\n  return p;\n};\n\nvar Ignore = /*#__PURE__*/function () {\n  function Ignore() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$ignorecase = _ref.ignorecase,\n        ignorecase = _ref$ignorecase === void 0 ? true : _ref$ignorecase,\n        _ref$ignoreCase = _ref.ignoreCase,\n        ignoreCase = _ref$ignoreCase === void 0 ? ignorecase : _ref$ignoreCase,\n        _ref$allowRelativePat = _ref.allowRelativePaths,\n        allowRelativePaths = _ref$allowRelativePat === void 0 ? false : _ref$allowRelativePat;\n\n    _classCallCheck(this, Ignore);\n\n    define(this, KEY_IGNORE, true);\n    this._rules = [];\n    this._ignoreCase = ignoreCase;\n    this._allowRelativePaths = allowRelativePaths;\n\n    this._initCache();\n  }\n\n  _createClass(Ignore, [{\n    key: \"_initCache\",\n    value: function _initCache() {\n      this._ignoreCache = Object.create(null);\n      this._testCache = Object.create(null);\n    }\n  }, {\n    key: \"_addPattern\",\n    value: function _addPattern(pattern) {\n      // #32\n      if (pattern && pattern[KEY_IGNORE]) {\n        this._rules = this._rules.concat(pattern._rules);\n        this._added = true;\n        return;\n      }\n\n      if (checkPattern(pattern)) {\n        var rule = createRule(pattern, this._ignoreCase);\n        this._added = true;\n\n        this._rules.push(rule);\n      }\n    } // @param {Array<string> | string | Ignore} pattern\n\n  }, {\n    key: \"add\",\n    value: function add(pattern) {\n      this._added = false;\n      makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this); // Some rules have just added to the ignore,\n      // making the behavior changed.\n\n      if (this._added) {\n        this._initCache();\n      }\n\n      return this;\n    } // legacy\n\n  }, {\n    key: \"addPattern\",\n    value: function addPattern(pattern) {\n      return this.add(pattern);\n    } //          |           ignored : unignored\n    // negative |   0:0   |   0:1   |   1:0   |   1:1\n    // -------- | ------- | ------- | ------- | --------\n    //     0    |  TEST   |  TEST   |  SKIP   |    X\n    //     1    |  TESTIF |  SKIP   |  TEST   |    X\n    // - SKIP: always skip\n    // - TEST: always test\n    // - TESTIF: only test if checkUnignored\n    // - X: that never happen\n    // @param {boolean} whether should check if the path is unignored,\n    //   setting `checkUnignored` to `false` could reduce additional\n    //   path matching.\n    // @returns {TestResult} true if a file is ignored\n\n  }, {\n    key: \"_testOne\",\n    value: function _testOne(path, checkUnignored) {\n      var ignored = false;\n      var unignored = false;\n\n      this._rules.forEach(function (rule) {\n        var negative = rule.negative;\n\n        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {\n          return;\n        }\n\n        var matched = rule.regex.test(path);\n\n        if (matched) {\n          ignored = !negative;\n          unignored = negative;\n        }\n      });\n\n      return {\n        ignored: ignored,\n        unignored: unignored\n      };\n    } // @returns {TestResult}\n\n  }, {\n    key: \"_test\",\n    value: function _test(originalPath, cache, checkUnignored, slices) {\n      var path = originalPath // Supports nullable path\n      && checkPath.convert(originalPath);\n      checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);\n      return this._t(path, cache, checkUnignored, slices);\n    }\n  }, {\n    key: \"_t\",\n    value: function _t(path, cache, checkUnignored, slices) {\n      if (path in cache) {\n        return cache[path];\n      }\n\n      if (!slices) {\n        // path/to/a.js\n        // ['path', 'to', 'a.js']\n        slices = path.split(SLASH);\n      }\n\n      slices.pop(); // If the path has no parent directory, just test it\n\n      if (!slices.length) {\n        return cache[path] = this._testOne(path, checkUnignored);\n      }\n\n      var parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices); // If the path contains a parent directory, check the parent first\n\n\n      return cache[path] = parent.ignored // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      ? parent : this._testOne(path, checkUnignored);\n    }\n  }, {\n    key: \"ignores\",\n    value: function ignores(path) {\n      return this._test(path, this._ignoreCache, false).ignored;\n    }\n  }, {\n    key: \"createFilter\",\n    value: function createFilter() {\n      var _this = this;\n\n      return function (path) {\n        return !_this.ignores(path);\n      };\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(paths) {\n      return makeArray(paths).filter(this.createFilter());\n    } // @returns {TestResult}\n\n  }, {\n    key: \"test\",\n    value: function test(path) {\n      return this._test(path, this._testCache, true);\n    }\n  }]);\n\n  return Ignore;\n}();\n\nvar factory = function factory(options) {\n  return new Ignore(options);\n};\n\nvar isPathValid = function isPathValid(path) {\n  return checkPath(path && checkPath.convert(path), path, RETURN_FALSE);\n};\n\nfactory.isPathValid = isPathValid; // Fixes typescript\n\nfactory[\"default\"] = factory;\nmodule.exports = factory; // Windows\n// --------------------------------------------------------------\n\n/* istanbul ignore if  */\n\nif ( // Detect `process` so that it can run in browsers.\ntypeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {\n  /* eslint no-control-regex: \"off\" */\n  var makePosix = function makePosix(str) {\n    return /^\\\\\\\\\\?\\\\/.test(str) || /[\\0-\\x1F\"<>\\|]+/.test(str) ? str : str.replace(/\\\\/g, '/');\n  };\n\n  checkPath.convert = makePosix; // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n\n  var REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i;\n\n  checkPath.isNotRelative = function (path) {\n    return REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);\n  };\n}","map":{"version":3,"names":["_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","makeArray","subject","Array","isArray","EMPTY","SPACE","ESCAPE","REGEX_TEST_BLANK_LINE","REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION","REGEX_REPLACE_LEADING_EXCAPED_HASH","REGEX_SPLITALL_CRLF","REGEX_TEST_INVALID_PATH","SLASH","KEY_IGNORE","Symbol","define","object","value","REGEX_REGEXP_RANGE","RETURN_FALSE","sanitizeRange","range","replace","match","from","to","charCodeAt","cleanRangeBackSlash","slashes","slice","REPLACERS","indexOf","concat","startingReplacer","test","_","index","str","p1","leadEscape","endEscape","close","prefix","regexCache","create","makeRegex","pattern","ignoreCase","source","reduce","prev","current","bind","RegExp","isString","checkPattern","splitPattern","split","IgnoreRule","origin","negative","regex","createRule","substr","throwError","message","Ctor","checkPath","path","originalPath","doThrow","isNotRelative","r","RangeError","convert","p","Ignore","_ref","arguments","undefined","_ref$ignorecase","ignorecase","_ref$ignoreCase","_ref$allowRelativePat","allowRelativePaths","_rules","_ignoreCase","_allowRelativePaths","_initCache","_ignoreCache","_testCache","_addPattern","_added","rule","push","add","forEach","addPattern","_testOne","checkUnignored","ignored","unignored","matched","_test","cache","slices","_t","pop","parent","join","ignores","createFilter","_this","filter","paths","factory","options","isPathValid","module","exports","process","env","IGNORE_TEST_WIN32","platform","makePosix","REGIX_IS_WINDOWS_PATH_ABSOLUTE"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/ignore/legacy.js"],"sourcesContent":["\"use strict\";\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// A simple implementation of make-array\nfunction makeArray(subject) {\n  return Array.isArray(subject) ? subject : [subject];\n}\n\nvar EMPTY = '';\nvar SPACE = ' ';\nvar ESCAPE = '\\\\';\nvar REGEX_TEST_BLANK_LINE = /^\\s+$/;\nvar REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/;\nvar REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/;\nvar REGEX_SPLITALL_CRLF = /\\r?\\n/g; // /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\n\nvar REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/;\nvar SLASH = '/';\nvar KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol[\"for\"]('node-ignore')\n/* istanbul ignore next */\n: 'node-ignore';\n\nvar define = function define(object, key, value) {\n  return Object.defineProperty(object, key, {\n    value: value\n  });\n};\n\nvar REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;\n\nvar RETURN_FALSE = function RETURN_FALSE() {\n  return false;\n}; // Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\n\n\nvar sanitizeRange = function sanitizeRange(range) {\n  return range.replace(REGEX_REGEXP_RANGE, function (match, from, to) {\n    return from.charCodeAt(0) <= to.charCodeAt(0) ? match // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : EMPTY;\n  });\n}; // See fixtures #59\n\n\nvar cleanRangeBackSlash = function cleanRangeBackSlash(slashes) {\n  var length = slashes.length;\n  return slashes.slice(0, length - length % 2);\n}; // > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n// '`foo/`' should not continue with the '`..`'\n\n\nvar REPLACERS = [// > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n[// (a\\ ) -> (a )\n// (a  ) -> (a)\n// (a \\ ) -> (a  )\n/\\\\?\\s+$/, function (match) {\n  return match.indexOf('\\\\') === 0 ? SPACE : EMPTY;\n}], // replace (\\ ) with ' '\n[/\\\\\\s/g, function () {\n  return SPACE;\n}], // Escape metacharacters\n// which is written down by users but means special for regular expressions.\n// > There are 12 characters with special meanings:\n// > - the backslash \\,\n// > - the caret ^,\n// > - the dollar sign $,\n// > - the period or dot .,\n// > - the vertical bar or pipe symbol |,\n// > - the question mark ?,\n// > - the asterisk or star *,\n// > - the plus sign +,\n// > - the opening parenthesis (,\n// > - the closing parenthesis ),\n// > - and the opening square bracket [,\n// > - the opening curly brace {,\n// > These special characters are often called \"metacharacters\".\n[/[\\\\$.|*+(){^]/g, function (match) {\n  return \"\\\\\".concat(match);\n}], [// > a question mark (?) matches a single character\n/(?!\\\\)\\?/g, function () {\n  return '[^/]';\n}], // leading slash\n[// > A leading slash matches the beginning of the pathname.\n// > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n// A leading slash matches the beginning of the pathname\n/^\\//, function () {\n  return '^';\n}], // replace special metacharacter slash after the leading slash\n[/\\//g, function () {\n  return '\\\\/';\n}], [// > A leading \"**\" followed by a slash means match in all directories.\n// > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n// > the same as pattern \"foo\".\n// > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n// >   under directory \"foo\".\n// Notice that the '*'s have been replaced as '\\\\*'\n/^\\^*\\\\\\*\\\\\\*\\\\\\//, // '**/foo' <-> 'foo'\nfunction () {\n  return '^(?:.*\\\\/)?';\n}], // starting\n[// there will be no leading '/'\n//   (which has been replaced by section \"leading slash\")\n// If starts with '**', adding a '^' to the regular expression also works\n/^(?=[^^])/, function startingReplacer() {\n  // If has a slash `/` at the beginning or middle\n  return !/\\/(?!$)/.test(this) // > Prior to 2.22.1\n  // > If the pattern does not contain a slash /,\n  // >   Git treats it as a shell glob pattern\n  // Actually, if there is only a trailing slash,\n  //   git also treats it as a shell glob pattern\n  // After 2.22.1 (compatible but clearer)\n  // > If there is a separator at the beginning or middle (or both)\n  // > of the pattern, then the pattern is relative to the directory\n  // > level of the particular .gitignore file itself.\n  // > Otherwise the pattern may also match at any level below\n  // > the .gitignore level.\n  ? '(?:^|\\\\/)' // > Otherwise, Git treats the pattern as a shell glob suitable for\n  // >   consumption by fnmatch(3)\n  : '^';\n}], // two globstars\n[// Use lookahead assertions so that we could match more than one `'/**'`\n/\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g, // Zero, one or several directories\n// should not use '*', or it will be replaced by the next replacer\n// Check if it is not the last `'/**'`\nfunction (_, index, str) {\n  return index + 6 < str.length // case: /**/\n  // > A slash followed by two consecutive asterisks then a slash matches\n  // >   zero or more directories.\n  // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n  // '/**/'\n  ? '(?:\\\\/[^\\\\/]+)*' // case: /**\n  // > A trailing `\"/**\"` matches everything inside.\n  // #21: everything inside but it should not include the current folder\n  : '\\\\/.+';\n}], // intermediate wildcards\n[// Never replace escaped '*'\n// ignore rule '\\*' will match the path '*'\n// 'abc.*/' -> go\n// 'abc.*'  -> skip this rule\n/(^|[^\\\\]+)\\\\\\*(?=.+)/g, // '*.js' matches '.js'\n// '*.js' doesn't match 'abc'\nfunction (_, p1) {\n  return \"\".concat(p1, \"[^\\\\/]*\");\n}], [// unescape, revert step 3 except for back slash\n// For example, if a user escape a '\\\\*',\n// after step 3, the result will be '\\\\\\\\\\\\*'\n/\\\\\\\\\\\\(?=[$.|*+(){^])/g, function () {\n  return ESCAPE;\n}], [// '\\\\\\\\' -> '\\\\'\n/\\\\\\\\/g, function () {\n  return ESCAPE;\n}], [// > The range notation, e.g. [a-zA-Z],\n// > can be used to match one of the characters in a range.\n// `\\` is escaped by step 3\n/(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g, function (match, leadEscape, range, endEscape, close) {\n  return leadEscape === ESCAPE // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n  ? \"\\\\[\".concat(range).concat(cleanRangeBackSlash(endEscape)).concat(close) : close === ']' ? endEscape.length % 2 === 0 // A normal case, and it is a range notation\n  // '[bar]'\n  // '[bar\\\\\\\\]'\n  ? \"[\".concat(sanitizeRange(range)).concat(endEscape, \"]\") // Invalid range notaton\n  // '[bar\\\\]' -> '[bar\\\\\\\\]'\n  : '[]' : '[]';\n}], // ending\n[// 'js' will not match 'js.'\n// 'ab' will not match 'abc'\n/(?:[^*])$/, // WTF!\n// https://git-scm.com/docs/gitignore\n// changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n// which re-fixes #24, #38\n// > If there is a separator at the end of the pattern then the pattern\n// > will only match directories, otherwise the pattern can match both\n// > files and directories.\n// 'js*' will not match 'a.js'\n// 'js/' will not match 'a.js'\n// 'js' will match 'a.js' and 'a.js/'\nfunction (match) {\n  return /\\/$/.test(match) // foo/ will not match 'foo'\n  ? \"\".concat(match, \"$\") // foo matches 'foo' and 'foo/'\n  : \"\".concat(match, \"(?=$|\\\\/$)\");\n}], // trailing wildcard\n[/(\\^|\\\\\\/)?\\\\\\*$/, function (_, p1) {\n  var prefix = p1 // '\\^':\n  // '/*' does not match EMPTY\n  // '/*' does not match everything\n  // '\\\\\\/':\n  // 'abc/*' does not match 'abc/'\n  ? \"\".concat(p1, \"[^/]+\") // 'a*' matches 'a'\n  // 'a*' matches 'aa'\n  : '[^/]*';\n  return \"\".concat(prefix, \"(?=$|\\\\/$)\");\n}]]; // A simple cache, because an ignore rule only has only one certain meaning\n\nvar regexCache = Object.create(null); // @param {pattern}\n\nvar makeRegex = function makeRegex(pattern, ignoreCase) {\n  var source = regexCache[pattern];\n\n  if (!source) {\n    source = REPLACERS.reduce(function (prev, current) {\n      return prev.replace(current[0], current[1].bind(pattern));\n    }, pattern);\n    regexCache[pattern] = source;\n  }\n\n  return ignoreCase ? new RegExp(source, 'i') : new RegExp(source);\n};\n\nvar isString = function isString(subject) {\n  return typeof subject === 'string';\n}; // > A blank line matches no files, so it can serve as a separator for readability.\n\n\nvar checkPattern = function checkPattern(pattern) {\n  return pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0;\n};\n\nvar splitPattern = function splitPattern(pattern) {\n  return pattern.split(REGEX_SPLITALL_CRLF);\n};\n\nvar IgnoreRule = function IgnoreRule(origin, pattern, negative, regex) {\n  _classCallCheck(this, IgnoreRule);\n\n  this.origin = origin;\n  this.pattern = pattern;\n  this.negative = negative;\n  this.regex = regex;\n};\n\nvar createRule = function createRule(pattern, ignoreCase) {\n  var origin = pattern;\n  var negative = false; // > An optional prefix \"!\" which negates the pattern;\n\n  if (pattern.indexOf('!') === 0) {\n    negative = true;\n    pattern = pattern.substr(1);\n  }\n\n  pattern = pattern // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!') // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');\n  var regex = makeRegex(pattern, ignoreCase);\n  return new IgnoreRule(origin, pattern, negative, regex);\n};\n\nvar throwError = function throwError(message, Ctor) {\n  throw new Ctor(message);\n};\n\nvar checkPath = function checkPath(path, originalPath, doThrow) {\n  if (!isString(path)) {\n    return doThrow(\"path must be a string, but got `\".concat(originalPath, \"`\"), TypeError);\n  } // We don't know if we should ignore EMPTY, so throw\n\n\n  if (!path) {\n    return doThrow(\"path must not be empty\", TypeError);\n  } // Check if it is a relative path\n\n\n  if (checkPath.isNotRelative(path)) {\n    var r = '`path.relative()`d';\n    return doThrow(\"path should be a \".concat(r, \" string, but got \\\"\").concat(originalPath, \"\\\"\"), RangeError);\n  }\n\n  return true;\n};\n\nvar isNotRelative = function isNotRelative(path) {\n  return REGEX_TEST_INVALID_PATH.test(path);\n};\n\ncheckPath.isNotRelative = isNotRelative;\n\ncheckPath.convert = function (p) {\n  return p;\n};\n\nvar Ignore = /*#__PURE__*/function () {\n  function Ignore() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$ignorecase = _ref.ignorecase,\n        ignorecase = _ref$ignorecase === void 0 ? true : _ref$ignorecase,\n        _ref$ignoreCase = _ref.ignoreCase,\n        ignoreCase = _ref$ignoreCase === void 0 ? ignorecase : _ref$ignoreCase,\n        _ref$allowRelativePat = _ref.allowRelativePaths,\n        allowRelativePaths = _ref$allowRelativePat === void 0 ? false : _ref$allowRelativePat;\n\n    _classCallCheck(this, Ignore);\n\n    define(this, KEY_IGNORE, true);\n    this._rules = [];\n    this._ignoreCase = ignoreCase;\n    this._allowRelativePaths = allowRelativePaths;\n\n    this._initCache();\n  }\n\n  _createClass(Ignore, [{\n    key: \"_initCache\",\n    value: function _initCache() {\n      this._ignoreCache = Object.create(null);\n      this._testCache = Object.create(null);\n    }\n  }, {\n    key: \"_addPattern\",\n    value: function _addPattern(pattern) {\n      // #32\n      if (pattern && pattern[KEY_IGNORE]) {\n        this._rules = this._rules.concat(pattern._rules);\n        this._added = true;\n        return;\n      }\n\n      if (checkPattern(pattern)) {\n        var rule = createRule(pattern, this._ignoreCase);\n        this._added = true;\n\n        this._rules.push(rule);\n      }\n    } // @param {Array<string> | string | Ignore} pattern\n\n  }, {\n    key: \"add\",\n    value: function add(pattern) {\n      this._added = false;\n      makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this); // Some rules have just added to the ignore,\n      // making the behavior changed.\n\n      if (this._added) {\n        this._initCache();\n      }\n\n      return this;\n    } // legacy\n\n  }, {\n    key: \"addPattern\",\n    value: function addPattern(pattern) {\n      return this.add(pattern);\n    } //          |           ignored : unignored\n    // negative |   0:0   |   0:1   |   1:0   |   1:1\n    // -------- | ------- | ------- | ------- | --------\n    //     0    |  TEST   |  TEST   |  SKIP   |    X\n    //     1    |  TESTIF |  SKIP   |  TEST   |    X\n    // - SKIP: always skip\n    // - TEST: always test\n    // - TESTIF: only test if checkUnignored\n    // - X: that never happen\n    // @param {boolean} whether should check if the path is unignored,\n    //   setting `checkUnignored` to `false` could reduce additional\n    //   path matching.\n    // @returns {TestResult} true if a file is ignored\n\n  }, {\n    key: \"_testOne\",\n    value: function _testOne(path, checkUnignored) {\n      var ignored = false;\n      var unignored = false;\n\n      this._rules.forEach(function (rule) {\n        var negative = rule.negative;\n\n        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {\n          return;\n        }\n\n        var matched = rule.regex.test(path);\n\n        if (matched) {\n          ignored = !negative;\n          unignored = negative;\n        }\n      });\n\n      return {\n        ignored: ignored,\n        unignored: unignored\n      };\n    } // @returns {TestResult}\n\n  }, {\n    key: \"_test\",\n    value: function _test(originalPath, cache, checkUnignored, slices) {\n      var path = originalPath // Supports nullable path\n      && checkPath.convert(originalPath);\n      checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);\n      return this._t(path, cache, checkUnignored, slices);\n    }\n  }, {\n    key: \"_t\",\n    value: function _t(path, cache, checkUnignored, slices) {\n      if (path in cache) {\n        return cache[path];\n      }\n\n      if (!slices) {\n        // path/to/a.js\n        // ['path', 'to', 'a.js']\n        slices = path.split(SLASH);\n      }\n\n      slices.pop(); // If the path has no parent directory, just test it\n\n      if (!slices.length) {\n        return cache[path] = this._testOne(path, checkUnignored);\n      }\n\n      var parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices); // If the path contains a parent directory, check the parent first\n\n\n      return cache[path] = parent.ignored // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      ? parent : this._testOne(path, checkUnignored);\n    }\n  }, {\n    key: \"ignores\",\n    value: function ignores(path) {\n      return this._test(path, this._ignoreCache, false).ignored;\n    }\n  }, {\n    key: \"createFilter\",\n    value: function createFilter() {\n      var _this = this;\n\n      return function (path) {\n        return !_this.ignores(path);\n      };\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(paths) {\n      return makeArray(paths).filter(this.createFilter());\n    } // @returns {TestResult}\n\n  }, {\n    key: \"test\",\n    value: function test(path) {\n      return this._test(path, this._testCache, true);\n    }\n  }]);\n\n  return Ignore;\n}();\n\nvar factory = function factory(options) {\n  return new Ignore(options);\n};\n\nvar isPathValid = function isPathValid(path) {\n  return checkPath(path && checkPath.convert(path), path, RETURN_FALSE);\n};\n\nfactory.isPathValid = isPathValid; // Fixes typescript\n\nfactory[\"default\"] = factory;\nmodule.exports = factory; // Windows\n// --------------------------------------------------------------\n\n/* istanbul ignore if  */\n\nif ( // Detect `process` so that it can run in browsers.\ntypeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {\n  /* eslint no-control-regex: \"off\" */\n  var makePosix = function makePosix(str) {\n    return /^\\\\\\\\\\?\\\\/.test(str) || /[\\0-\\x1F\"<>\\|]+/.test(str) ? str : str.replace(/\\\\/g, '/');\n  };\n\n  checkPath.convert = makePosix; // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n\n  var REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i;\n\n  checkPath.isNotRelative = function (path) {\n    return REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);\n  };\n}\n"],"mappings":"AAAA;;AAEA,SAASA,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;IAAE,IAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;IAA2BE,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;IAAwDD,UAAU,CAACE,YAAX,GAA0B,IAA1B;IAAgC,IAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;IAA4BC,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;EAA4D;AAAE;;AAE7T,SAASO,YAAT,CAAsBC,WAAtB,EAAmCC,UAAnC,EAA+CC,WAA/C,EAA4D;EAAE,IAAID,UAAJ,EAAgBd,iBAAiB,CAACa,WAAW,CAACG,SAAb,EAAwBF,UAAxB,CAAjB;EAAsD,IAAIC,WAAJ,EAAiBf,iBAAiB,CAACa,WAAD,EAAcE,WAAd,CAAjB;EAA6C,OAAOF,WAAP;AAAqB;;AAEvN,SAASI,eAAT,CAAyBC,QAAzB,EAAmCL,WAAnC,EAAgD;EAAE,IAAI,EAAEK,QAAQ,YAAYL,WAAtB,CAAJ,EAAwC;IAAE,MAAM,IAAIM,SAAJ,CAAc,mCAAd,CAAN;EAA2D;AAAE,C,CAEzJ;;;AACA,SAASC,SAAT,CAAmBC,OAAnB,EAA4B;EAC1B,OAAOC,KAAK,CAACC,OAAN,CAAcF,OAAd,IAAyBA,OAAzB,GAAmC,CAACA,OAAD,CAA1C;AACD;;AAED,IAAIG,KAAK,GAAG,EAAZ;AACA,IAAIC,KAAK,GAAG,GAAZ;AACA,IAAIC,MAAM,GAAG,IAAb;AACA,IAAIC,qBAAqB,GAAG,OAA5B;AACA,IAAIC,yCAAyC,GAAG,MAAhD;AACA,IAAIC,kCAAkC,GAAG,MAAzC;AACA,IAAIC,mBAAmB,GAAG,QAA1B,C,CAAoC;AACpC;AACA;AACA;AACA;;AAEA,IAAIC,uBAAuB,GAAG,cAA9B;AACA,IAAIC,KAAK,GAAG,GAAZ;AACA,IAAIC,UAAU,GAAG,OAAOC,MAAP,KAAkB,WAAlB,GAAgCA,MAAM,CAAC,KAAD,CAAN,CAAc,aAAd;AACjD;AADiB,EAEf,aAFF;;AAIA,IAAIC,MAAM,GAAG,SAASA,MAAT,CAAgBC,MAAhB,EAAwBzB,GAAxB,EAA6B0B,KAA7B,EAAoC;EAC/C,OAAO5B,MAAM,CAACC,cAAP,CAAsB0B,MAAtB,EAA8BzB,GAA9B,EAAmC;IACxC0B,KAAK,EAAEA;EADiC,CAAnC,CAAP;AAGD,CAJD;;AAMA,IAAIC,kBAAkB,GAAG,kBAAzB;;AAEA,IAAIC,YAAY,GAAG,SAASA,YAAT,GAAwB;EACzC,OAAO,KAAP;AACD,CAFD,C,CAEG;AACH;;;AAGA,IAAIC,aAAa,GAAG,SAASA,aAAT,CAAuBC,KAAvB,EAA8B;EAChD,OAAOA,KAAK,CAACC,OAAN,CAAcJ,kBAAd,EAAkC,UAAUK,KAAV,EAAiBC,IAAjB,EAAuBC,EAAvB,EAA2B;IAClE,OAAOD,IAAI,CAACE,UAAL,CAAgB,CAAhB,KAAsBD,EAAE,CAACC,UAAH,CAAc,CAAd,CAAtB,GAAyCH,KAAzC,CAA+C;IACtD;IADO,EAELnB,KAFF;EAGD,CAJM,CAAP;AAKD,CAND,C,CAMG;;;AAGH,IAAIuB,mBAAmB,GAAG,SAASA,mBAAT,CAA6BC,OAA7B,EAAsC;EAC9D,IAAI5C,MAAM,GAAG4C,OAAO,CAAC5C,MAArB;EACA,OAAO4C,OAAO,CAACC,KAAR,CAAc,CAAd,EAAiB7C,MAAM,GAAGA,MAAM,GAAG,CAAnC,CAAP;AACD,CAHD,C,CAGG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,IAAI8C,SAAS,GAAG,CAAC;AACjB,CAAC;AACD;AACA;AACA,SAHA,EAGW,UAAUP,KAAV,EAAiB;EAC1B,OAAOA,KAAK,CAACQ,OAAN,CAAc,IAAd,MAAwB,CAAxB,GAA4B1B,KAA5B,GAAoCD,KAA3C;AACD,CALD,CADgB,EAMZ;AACJ,CAAC,OAAD,EAAU,YAAY;EACpB,OAAOC,KAAP;AACD,CAFD,CAPgB,EASZ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gBAAD,EAAmB,UAAUkB,KAAV,EAAiB;EAClC,OAAO,KAAKS,MAAL,CAAYT,KAAZ,CAAP;AACD,CAFD,CAzBgB,EA2BZ,CAAC;AACL,WADI,EACS,YAAY;EACvB,OAAO,MAAP;AACD,CAHG,CA3BY,EA8BZ;AACJ,CAAC;AACD;AACA;AACA,KAHA,EAGO,YAAY;EACjB,OAAO,GAAP;AACD,CALD,CA/BgB,EAoCZ;AACJ,CAAC,KAAD,EAAQ,YAAY;EAClB,OAAO,KAAP;AACD,CAFD,CArCgB,EAuCZ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA,kBANI,EAMgB;AACpB,YAAY;EACV,OAAO,aAAP;AACD,CATG,CAvCY,EAgDZ;AACJ,CAAC;AACD;AACA;AACA,WAHA,EAGa,SAASU,gBAAT,GAA4B;EACvC;EACA,OAAO,CAAC,UAAUC,IAAV,CAAe,IAAf,CAAD,CAAsB;EAC7B;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAVO,EAWL,WAXK,CAWO;EACd;EAZO,EAaL,GAbF;AAcD,CAnBD,CAjDgB,EAoEZ;AACJ,CAAC;AACD,yBADA,EAC2B;AAC3B;AACA;AACA,UAAUC,CAAV,EAAaC,KAAb,EAAoBC,GAApB,EAAyB;EACvB,OAAOD,KAAK,GAAG,CAAR,GAAYC,GAAG,CAACrD,MAAhB,CAAuB;EAC9B;EACA;EACA;EACA;EAJO,EAKL,iBALK,CAKa;EACpB;EACA;EAPO,EAQL,OARF;AASD,CAdD,CArEgB,EAmFZ;AACJ,CAAC;AACD;AACA;AACA;AACA,uBAJA,EAIyB;AACzB;AACA,UAAUmD,CAAV,EAAaG,EAAb,EAAiB;EACf,OAAO,GAAGN,MAAH,CAAUM,EAAV,EAAc,SAAd,CAAP;AACD,CARD,CApFgB,EA4FZ,CAAC;AACL;AACA;AACA,wBAHI,EAGsB,YAAY;EACpC,OAAOhC,MAAP;AACD,CALG,CA5FY,EAiGZ,CAAC;AACL,OADI,EACK,YAAY;EACnB,OAAOA,MAAP;AACD,CAHG,CAjGY,EAoGZ,CAAC;AACL;AACA;AACA,+BAHI,EAG6B,UAAUiB,KAAV,EAAiBgB,UAAjB,EAA6BlB,KAA7B,EAAoCmB,SAApC,EAA+CC,KAA/C,EAAsD;EACrF,OAAOF,UAAU,KAAKjC,MAAf,CAAsB;EAAtB,EACL,MAAM0B,MAAN,CAAaX,KAAb,EAAoBW,MAApB,CAA2BL,mBAAmB,CAACa,SAAD,CAA9C,EAA2DR,MAA3D,CAAkES,KAAlE,CADK,GACsEA,KAAK,KAAK,GAAV,GAAgBD,SAAS,CAACxD,MAAV,GAAmB,CAAnB,KAAyB,CAAzB,CAA2B;EACxH;EACA;EAF6F,EAG3F,IAAIgD,MAAJ,CAAWZ,aAAa,CAACC,KAAD,CAAxB,EAAiCW,MAAjC,CAAwCQ,SAAxC,EAAmD,GAAnD,CAH2F,CAGnC;EAC1D;EAJ6F,EAK3F,IAL2E,GAKpE,IANT;AAOD,CAXG,CApGY,EA+GZ;AACJ,CAAC;AACD;AACA,WAFA,EAEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAUjB,KAAV,EAAiB;EACf,OAAO,MAAMW,IAAN,CAAWX,KAAX,EAAkB;EAAlB,EACL,GAAGS,MAAH,CAAUT,KAAV,EAAiB,GAAjB,CADK,CACiB;EADjB,EAEL,GAAGS,MAAH,CAAUT,KAAV,EAAiB,YAAjB,CAFF;AAGD,CAhBD,CAhHgB,EAgIZ;AACJ,CAAC,iBAAD,EAAoB,UAAUY,CAAV,EAAaG,EAAb,EAAiB;EACnC,IAAII,MAAM,GAAGJ,EAAE,CAAC;EAChB;EACA;EACA;EACA;EAJe,EAKb,GAAGN,MAAH,CAAUM,EAAV,EAAc,OAAd,CALa,CAKU;EACzB;EANe,EAOb,OAPF;EAQA,OAAO,GAAGN,MAAH,CAAUU,MAAV,EAAkB,YAAlB,CAAP;AACD,CAVD,CAjIgB,CAAhB,C,CA2IK;;AAEL,IAAIC,UAAU,GAAGtD,MAAM,CAACuD,MAAP,CAAc,IAAd,CAAjB,C,CAAsC;;AAEtC,IAAIC,SAAS,GAAG,SAASA,SAAT,CAAmBC,OAAnB,EAA4BC,UAA5B,EAAwC;EACtD,IAAIC,MAAM,GAAGL,UAAU,CAACG,OAAD,CAAvB;;EAEA,IAAI,CAACE,MAAL,EAAa;IACXA,MAAM,GAAGlB,SAAS,CAACmB,MAAV,CAAiB,UAAUC,IAAV,EAAgBC,OAAhB,EAAyB;MACjD,OAAOD,IAAI,CAAC5B,OAAL,CAAa6B,OAAO,CAAC,CAAD,CAApB,EAAyBA,OAAO,CAAC,CAAD,CAAP,CAAWC,IAAX,CAAgBN,OAAhB,CAAzB,CAAP;IACD,CAFQ,EAENA,OAFM,CAAT;IAGAH,UAAU,CAACG,OAAD,CAAV,GAAsBE,MAAtB;EACD;;EAED,OAAOD,UAAU,GAAG,IAAIM,MAAJ,CAAWL,MAAX,EAAmB,GAAnB,CAAH,GAA6B,IAAIK,MAAJ,CAAWL,MAAX,CAA9C;AACD,CAXD;;AAaA,IAAIM,QAAQ,GAAG,SAASA,QAAT,CAAkBrD,OAAlB,EAA2B;EACxC,OAAO,OAAOA,OAAP,KAAmB,QAA1B;AACD,CAFD,C,CAEG;;;AAGH,IAAIsD,YAAY,GAAG,SAASA,YAAT,CAAsBT,OAAtB,EAA+B;EAChD,OAAOA,OAAO,IAAIQ,QAAQ,CAACR,OAAD,CAAnB,IAAgC,CAACvC,qBAAqB,CAAC2B,IAAtB,CAA2BY,OAA3B,CAAjC,CAAqE;EAArE,GACJA,OAAO,CAACf,OAAR,CAAgB,GAAhB,MAAyB,CAD5B;AAED,CAHD;;AAKA,IAAIyB,YAAY,GAAG,SAASA,YAAT,CAAsBV,OAAtB,EAA+B;EAChD,OAAOA,OAAO,CAACW,KAAR,CAAc/C,mBAAd,CAAP;AACD,CAFD;;AAIA,IAAIgD,UAAU,GAAG,SAASA,UAAT,CAAoBC,MAApB,EAA4Bb,OAA5B,EAAqCc,QAArC,EAA+CC,KAA/C,EAAsD;EACrEhE,eAAe,CAAC,IAAD,EAAO6D,UAAP,CAAf;;EAEA,KAAKC,MAAL,GAAcA,MAAd;EACA,KAAKb,OAAL,GAAeA,OAAf;EACA,KAAKc,QAAL,GAAgBA,QAAhB;EACA,KAAKC,KAAL,GAAaA,KAAb;AACD,CAPD;;AASA,IAAIC,UAAU,GAAG,SAASA,UAAT,CAAoBhB,OAApB,EAA6BC,UAA7B,EAAyC;EACxD,IAAIY,MAAM,GAAGb,OAAb;EACA,IAAIc,QAAQ,GAAG,KAAf,CAFwD,CAElC;;EAEtB,IAAId,OAAO,CAACf,OAAR,CAAgB,GAAhB,MAAyB,CAA7B,EAAgC;IAC9B6B,QAAQ,GAAG,IAAX;IACAd,OAAO,GAAGA,OAAO,CAACiB,MAAR,CAAe,CAAf,CAAV;EACD;;EAEDjB,OAAO,GAAGA,OAAO,CAAC;EAClB;EADiB,CAEhBxB,OAFS,CAEDd,yCAFC,EAE0C,GAF1C,EAE+C;EACzD;EAHU,CAITc,OAJS,CAIDb,kCAJC,EAImC,GAJnC,CAAV;EAKA,IAAIoD,KAAK,GAAGhB,SAAS,CAACC,OAAD,EAAUC,UAAV,CAArB;EACA,OAAO,IAAIW,UAAJ,CAAeC,MAAf,EAAuBb,OAAvB,EAAgCc,QAAhC,EAA0CC,KAA1C,CAAP;AACD,CAhBD;;AAkBA,IAAIG,UAAU,GAAG,SAASA,UAAT,CAAoBC,OAApB,EAA6BC,IAA7B,EAAmC;EAClD,MAAM,IAAIA,IAAJ,CAASD,OAAT,CAAN;AACD,CAFD;;AAIA,IAAIE,SAAS,GAAG,SAASA,SAAT,CAAmBC,IAAnB,EAAyBC,YAAzB,EAAuCC,OAAvC,EAAgD;EAC9D,IAAI,CAAChB,QAAQ,CAACc,IAAD,CAAb,EAAqB;IACnB,OAAOE,OAAO,CAAC,mCAAmCtC,MAAnC,CAA0CqC,YAA1C,EAAwD,GAAxD,CAAD,EAA+DtE,SAA/D,CAAd;EACD,CAH6D,CAG5D;;;EAGF,IAAI,CAACqE,IAAL,EAAW;IACT,OAAOE,OAAO,CAAC,wBAAD,EAA2BvE,SAA3B,CAAd;EACD,CAR6D,CAQ5D;;;EAGF,IAAIoE,SAAS,CAACI,aAAV,CAAwBH,IAAxB,CAAJ,EAAmC;IACjC,IAAII,CAAC,GAAG,oBAAR;IACA,OAAOF,OAAO,CAAC,oBAAoBtC,MAApB,CAA2BwC,CAA3B,EAA8B,qBAA9B,EAAqDxC,MAArD,CAA4DqC,YAA5D,EAA0E,IAA1E,CAAD,EAAkFI,UAAlF,CAAd;EACD;;EAED,OAAO,IAAP;AACD,CAjBD;;AAmBA,IAAIF,aAAa,GAAG,SAASA,aAAT,CAAuBH,IAAvB,EAA6B;EAC/C,OAAOzD,uBAAuB,CAACuB,IAAxB,CAA6BkC,IAA7B,CAAP;AACD,CAFD;;AAIAD,SAAS,CAACI,aAAV,GAA0BA,aAA1B;;AAEAJ,SAAS,CAACO,OAAV,GAAoB,UAAUC,CAAV,EAAa;EAC/B,OAAOA,CAAP;AACD,CAFD;;AAIA,IAAIC,MAAM,GAAG,aAAa,YAAY;EACpC,SAASA,MAAT,GAAkB;IAChB,IAAIC,IAAI,GAAGC,SAAS,CAAC9F,MAAV,GAAmB,CAAnB,IAAwB8F,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA/E;IAAA,IACIE,eAAe,GAAGH,IAAI,CAACI,UAD3B;IAAA,IAEIA,UAAU,GAAGD,eAAe,KAAK,KAAK,CAAzB,GAA6B,IAA7B,GAAoCA,eAFrD;IAAA,IAGIE,eAAe,GAAGL,IAAI,CAAC9B,UAH3B;IAAA,IAIIA,UAAU,GAAGmC,eAAe,KAAK,KAAK,CAAzB,GAA6BD,UAA7B,GAA0CC,eAJ3D;IAAA,IAKIC,qBAAqB,GAAGN,IAAI,CAACO,kBALjC;IAAA,IAMIA,kBAAkB,GAAGD,qBAAqB,KAAK,KAAK,CAA/B,GAAmC,KAAnC,GAA2CA,qBANpE;;IAQAtF,eAAe,CAAC,IAAD,EAAO+E,MAAP,CAAf;;IAEA7D,MAAM,CAAC,IAAD,EAAOF,UAAP,EAAmB,IAAnB,CAAN;IACA,KAAKwE,MAAL,GAAc,EAAd;IACA,KAAKC,WAAL,GAAmBvC,UAAnB;IACA,KAAKwC,mBAAL,GAA2BH,kBAA3B;;IAEA,KAAKI,UAAL;EACD;;EAEDhG,YAAY,CAACoF,MAAD,EAAS,CAAC;IACpBrF,GAAG,EAAE,YADe;IAEpB0B,KAAK,EAAE,SAASuE,UAAT,GAAsB;MAC3B,KAAKC,YAAL,GAAoBpG,MAAM,CAACuD,MAAP,CAAc,IAAd,CAApB;MACA,KAAK8C,UAAL,GAAkBrG,MAAM,CAACuD,MAAP,CAAc,IAAd,CAAlB;IACD;EALmB,CAAD,EAMlB;IACDrD,GAAG,EAAE,aADJ;IAED0B,KAAK,EAAE,SAAS0E,WAAT,CAAqB7C,OAArB,EAA8B;MACnC;MACA,IAAIA,OAAO,IAAIA,OAAO,CAACjC,UAAD,CAAtB,EAAoC;QAClC,KAAKwE,MAAL,GAAc,KAAKA,MAAL,CAAYrD,MAAZ,CAAmBc,OAAO,CAACuC,MAA3B,CAAd;QACA,KAAKO,MAAL,GAAc,IAAd;QACA;MACD;;MAED,IAAIrC,YAAY,CAACT,OAAD,CAAhB,EAA2B;QACzB,IAAI+C,IAAI,GAAG/B,UAAU,CAAChB,OAAD,EAAU,KAAKwC,WAAf,CAArB;QACA,KAAKM,MAAL,GAAc,IAAd;;QAEA,KAAKP,MAAL,CAAYS,IAAZ,CAAiBD,IAAjB;MACD;IACF,CAhBA,CAgBC;;EAhBD,CANkB,EAwBlB;IACDtG,GAAG,EAAE,KADJ;IAED0B,KAAK,EAAE,SAAS8E,GAAT,CAAajD,OAAb,EAAsB;MAC3B,KAAK8C,MAAL,GAAc,KAAd;MACA5F,SAAS,CAACsD,QAAQ,CAACR,OAAD,CAAR,GAAoBU,YAAY,CAACV,OAAD,CAAhC,GAA4CA,OAA7C,CAAT,CAA+DkD,OAA/D,CAAuE,KAAKL,WAA5E,EAAyF,IAAzF,EAF2B,CAEqE;MAChG;;MAEA,IAAI,KAAKC,MAAT,EAAiB;QACf,KAAKJ,UAAL;MACD;;MAED,OAAO,IAAP;IACD,CAZA,CAYC;;EAZD,CAxBkB,EAsClB;IACDjG,GAAG,EAAE,YADJ;IAED0B,KAAK,EAAE,SAASgF,UAAT,CAAoBnD,OAApB,EAA6B;MAClC,OAAO,KAAKiD,GAAL,CAASjD,OAAT,CAAP;IACD,CAJA,CAIC;IACF;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;EAhBC,CAtCkB,EAwDlB;IACDvD,GAAG,EAAE,UADJ;IAED0B,KAAK,EAAE,SAASiF,QAAT,CAAkB9B,IAAlB,EAAwB+B,cAAxB,EAAwC;MAC7C,IAAIC,OAAO,GAAG,KAAd;MACA,IAAIC,SAAS,GAAG,KAAhB;;MAEA,KAAKhB,MAAL,CAAYW,OAAZ,CAAoB,UAAUH,IAAV,EAAgB;QAClC,IAAIjC,QAAQ,GAAGiC,IAAI,CAACjC,QAApB;;QAEA,IAAIyC,SAAS,KAAKzC,QAAd,IAA0BwC,OAAO,KAAKC,SAAtC,IAAmDzC,QAAQ,IAAI,CAACwC,OAAb,IAAwB,CAACC,SAAzB,IAAsC,CAACF,cAA9F,EAA8G;UAC5G;QACD;;QAED,IAAIG,OAAO,GAAGT,IAAI,CAAChC,KAAL,CAAW3B,IAAX,CAAgBkC,IAAhB,CAAd;;QAEA,IAAIkC,OAAJ,EAAa;UACXF,OAAO,GAAG,CAACxC,QAAX;UACAyC,SAAS,GAAGzC,QAAZ;QACD;MACF,CAbD;;MAeA,OAAO;QACLwC,OAAO,EAAEA,OADJ;QAELC,SAAS,EAAEA;MAFN,CAAP;IAID,CAzBA,CAyBC;;EAzBD,CAxDkB,EAmFlB;IACD9G,GAAG,EAAE,OADJ;IAED0B,KAAK,EAAE,SAASsF,KAAT,CAAelC,YAAf,EAA6BmC,KAA7B,EAAoCL,cAApC,EAAoDM,MAApD,EAA4D;MACjE,IAAIrC,IAAI,GAAGC,YAAY,CAAC;MAAD,GACpBF,SAAS,CAACO,OAAV,CAAkBL,YAAlB,CADH;MAEAF,SAAS,CAACC,IAAD,EAAOC,YAAP,EAAqB,KAAKkB,mBAAL,GAA2BpE,YAA3B,GAA0C6C,UAA/D,CAAT;MACA,OAAO,KAAK0C,EAAL,CAAQtC,IAAR,EAAcoC,KAAd,EAAqBL,cAArB,EAAqCM,MAArC,CAAP;IACD;EAPA,CAnFkB,EA2FlB;IACDlH,GAAG,EAAE,IADJ;IAED0B,KAAK,EAAE,SAASyF,EAAT,CAAYtC,IAAZ,EAAkBoC,KAAlB,EAAyBL,cAAzB,EAAyCM,MAAzC,EAAiD;MACtD,IAAIrC,IAAI,IAAIoC,KAAZ,EAAmB;QACjB,OAAOA,KAAK,CAACpC,IAAD,CAAZ;MACD;;MAED,IAAI,CAACqC,MAAL,EAAa;QACX;QACA;QACAA,MAAM,GAAGrC,IAAI,CAACX,KAAL,CAAW7C,KAAX,CAAT;MACD;;MAED6F,MAAM,CAACE,GAAP,GAXsD,CAWxC;;MAEd,IAAI,CAACF,MAAM,CAACzH,MAAZ,EAAoB;QAClB,OAAOwH,KAAK,CAACpC,IAAD,CAAL,GAAc,KAAK8B,QAAL,CAAc9B,IAAd,EAAoB+B,cAApB,CAArB;MACD;;MAED,IAAIS,MAAM,GAAG,KAAKF,EAAL,CAAQD,MAAM,CAACI,IAAP,CAAYjG,KAAZ,IAAqBA,KAA7B,EAAoC4F,KAApC,EAA2CL,cAA3C,EAA2DM,MAA3D,CAAb,CAjBsD,CAiB2B;;;MAGjF,OAAOD,KAAK,CAACpC,IAAD,CAAL,GAAcwC,MAAM,CAACR,OAAP,CAAe;MACpC;MADqB,EAEnBQ,MAFmB,GAEV,KAAKV,QAAL,CAAc9B,IAAd,EAAoB+B,cAApB,CAFX;IAGD;EAzBA,CA3FkB,EAqHlB;IACD5G,GAAG,EAAE,SADJ;IAED0B,KAAK,EAAE,SAAS6F,OAAT,CAAiB1C,IAAjB,EAAuB;MAC5B,OAAO,KAAKmC,KAAL,CAAWnC,IAAX,EAAiB,KAAKqB,YAAtB,EAAoC,KAApC,EAA2CW,OAAlD;IACD;EAJA,CArHkB,EA0HlB;IACD7G,GAAG,EAAE,cADJ;IAED0B,KAAK,EAAE,SAAS8F,YAAT,GAAwB;MAC7B,IAAIC,KAAK,GAAG,IAAZ;;MAEA,OAAO,UAAU5C,IAAV,EAAgB;QACrB,OAAO,CAAC4C,KAAK,CAACF,OAAN,CAAc1C,IAAd,CAAR;MACD,CAFD;IAGD;EARA,CA1HkB,EAmIlB;IACD7E,GAAG,EAAE,QADJ;IAED0B,KAAK,EAAE,SAASgG,MAAT,CAAgBC,KAAhB,EAAuB;MAC5B,OAAOlH,SAAS,CAACkH,KAAD,CAAT,CAAiBD,MAAjB,CAAwB,KAAKF,YAAL,EAAxB,CAAP;IACD,CAJA,CAIC;;EAJD,CAnIkB,EAyIlB;IACDxH,GAAG,EAAE,MADJ;IAED0B,KAAK,EAAE,SAASiB,IAAT,CAAckC,IAAd,EAAoB;MACzB,OAAO,KAAKmC,KAAL,CAAWnC,IAAX,EAAiB,KAAKsB,UAAtB,EAAkC,IAAlC,CAAP;IACD;EAJA,CAzIkB,CAAT,CAAZ;;EAgJA,OAAOd,MAAP;AACD,CArKyB,EAA1B;;AAuKA,IAAIuC,OAAO,GAAG,SAASA,OAAT,CAAiBC,OAAjB,EAA0B;EACtC,OAAO,IAAIxC,MAAJ,CAAWwC,OAAX,CAAP;AACD,CAFD;;AAIA,IAAIC,WAAW,GAAG,SAASA,WAAT,CAAqBjD,IAArB,EAA2B;EAC3C,OAAOD,SAAS,CAACC,IAAI,IAAID,SAAS,CAACO,OAAV,CAAkBN,IAAlB,CAAT,EAAkCA,IAAlC,EAAwCjD,YAAxC,CAAhB;AACD,CAFD;;AAIAgG,OAAO,CAACE,WAAR,GAAsBA,WAAtB,C,CAAmC;;AAEnCF,OAAO,CAAC,SAAD,CAAP,GAAqBA,OAArB;AACAG,MAAM,CAACC,OAAP,GAAiBJ,OAAjB,C,CAA0B;AAC1B;;AAEA;;AAEA,KAAK;AACL,OAAOK,OAAP,KAAmB,WAAnB,KAAmCA,OAAO,CAACC,GAAR,IAAeD,OAAO,CAACC,GAAR,CAAYC,iBAA3B,IAAgDF,OAAO,CAACG,QAAR,KAAqB,OAAxG,CADA,EACkH;EAChH;EACA,IAAIC,SAAS,GAAG,SAASA,SAAT,CAAmBvF,GAAnB,EAAwB;IACtC,OAAO,YAAYH,IAAZ,CAAiBG,GAAjB,KAAyB,kBAAkBH,IAAlB,CAAuBG,GAAvB,CAAzB,GAAuDA,GAAvD,GAA6DA,GAAG,CAACf,OAAJ,CAAY,KAAZ,EAAmB,GAAnB,CAApE;EACD,CAFD;;EAIA6C,SAAS,CAACO,OAAV,GAAoBkD,SAApB,CANgH,CAMjF;EAC/B;;EAEA,IAAIC,8BAA8B,GAAG,YAArC;;EAEA1D,SAAS,CAACI,aAAV,GAA0B,UAAUH,IAAV,EAAgB;IACxC,OAAOyD,8BAA8B,CAAC3F,IAA/B,CAAoCkC,IAApC,KAA6CG,aAAa,CAACH,IAAD,CAAjE;EACD,CAFD;AAGD"},"metadata":{},"sourceType":"script"}