{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (fn) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, callArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      callArgs[_key2] = arguments[_key2];\n    }\n\n    return fn(...args, ...callArgs);\n  };\n};\n\nmodule.exports = exports[\"default\"];\n/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} fn - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @returns {Function} the partially-applied function\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */","map":{"version":3,"names":["Object","defineProperty","exports","value","default","fn","args","callArgs","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/async/apply.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (fn, ...args) {\n  return (...callArgs) => fn(...args, ...callArgs);\n};\n\nmodule.exports = exports[\"default\"]; /**\n                                      * Creates a continuation function with some arguments already applied.\n                                      *\n                                      * Useful as a shorthand when combined with other control flow functions. Any\n                                      * arguments passed to the returned function are added to the arguments\n                                      * originally passed to apply.\n                                      *\n                                      * @name apply\n                                      * @static\n                                      * @memberOf module:Utils\n                                      * @method\n                                      * @category Util\n                                      * @param {Function} fn - The function you want to eventually apply all\n                                      * arguments to. Invokes with (arguments...).\n                                      * @param {...*} arguments... - Any number of arguments to automatically apply\n                                      * when the continuation is called.\n                                      * @returns {Function} the partially-applied function\n                                      * @example\n                                      *\n                                      * // using apply\n                                      * async.parallel([\n                                      *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n                                      *     async.apply(fs.writeFile, 'testfile2', 'test2')\n                                      * ]);\n                                      *\n                                      *\n                                      * // the same process without using apply\n                                      * async.parallel([\n                                      *     function(callback) {\n                                      *         fs.writeFile('testfile1', 'test1', callback);\n                                      *     },\n                                      *     function(callback) {\n                                      *         fs.writeFile('testfile2', 'test2', callback);\n                                      *     }\n                                      * ]);\n                                      *\n                                      * // It's possible to pass any number of additional arguments when calling the\n                                      * // continuation:\n                                      *\n                                      * node> var fn = async.apply(sys.puts, 'one');\n                                      * node> fn('two', 'three');\n                                      * one\n                                      * two\n                                      * three\n                                      */"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;;AAIAD,OAAO,CAACE,OAAR,GAAkB,UAAUC,EAAV,EAAuB;EAAA,kCAANC,IAAM;IAANA,IAAM;EAAA;;EACvC,OAAO;IAAA,mCAAIC,QAAJ;MAAIA,QAAJ;IAAA;;IAAA,OAAiBF,EAAE,CAAC,GAAGC,IAAJ,EAAU,GAAGC,QAAb,CAAnB;EAAA,CAAP;AACD,CAFD;;AAIAC,MAAM,CAACN,OAAP,GAAiBA,OAAO,CAAC,SAAD,CAAxB;AAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"script"}