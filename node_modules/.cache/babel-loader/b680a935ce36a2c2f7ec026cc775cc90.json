{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'require-array-sort-compare',\n  defaultOptions: [{\n    ignoreStringArrays: false\n  }],\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Require `Array#sort` calls to always provide a `compareFunction`',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    messages: {\n      requireCompare: \"Require 'compare' argument.\"\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreStringArrays: {\n          description: 'Whether to ignore arrays in which all elements are strings.',\n          type: 'boolean'\n        }\n      }\n    }]\n  },\n\n  create(context, _ref) {\n    let [options] = _ref;\n    const service = util.getParserServices(context);\n    const checker = service.program.getTypeChecker();\n    /**\n     * Check if a given node is an array which all elements are string.\n     * @param node\n     */\n\n    function isStringArrayNode(node) {\n      const type = checker.getTypeAtLocation(service.esTreeNodeToTSNodeMap.get(node));\n\n      if (checker.isArrayType(type) || checker.isTupleType(type)) {\n        const typeArgs = checker.getTypeArguments(type);\n        return typeArgs.every(arg => util.getTypeName(checker, arg) === 'string');\n      }\n\n      return false;\n    }\n\n    return {\n      \"CallExpression[arguments.length=0] > MemberExpression[property.name='sort'][computed=false]\"(callee) {\n        const tsNode = service.esTreeNodeToTSNodeMap.get(callee.object);\n        const calleeObjType = util.getConstrainedTypeAtLocation(checker, tsNode);\n\n        if (options.ignoreStringArrays && isStringArrayNode(callee.object)) {\n          return;\n        }\n\n        if (util.isTypeArrayTypeOrUnionOfArrayTypes(calleeObjType, checker)) {\n          context.report({\n            node: callee.parent,\n            messageId: 'requireCompare'\n          });\n        }\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;AASAA,kBAAeC,IAAI,CAACC,UAAL,CAAqC;EAClDC,IAAI,EAAE,4BAD4C;EAElDC,cAAc,EAAE,CACd;IACEC,kBAAkB,EAAE;EADtB,CADc,CAFkC;EAQlDC,IAAI,EAAE;IACJC,IAAI,EAAE,SADF;IAEJC,IAAI,EAAE;MACJC,WAAW,EACT,kEAFE;MAGJC,WAAW,EAAE,KAHT;MAIJC,oBAAoB,EAAE;IAJlB,CAFF;IAQJC,QAAQ,EAAE;MACRC,cAAc,EAAE;IADR,CARN;IAWJC,MAAM,EAAE,CACN;MACEP,IAAI,EAAE,QADR;MAEEQ,UAAU,EAAE;QACVV,kBAAkB,EAAE;UAClBI,WAAW,EACT,6DAFgB;UAGlBF,IAAI,EAAE;QAHY;MADV;IAFd,CADM;EAXJ,CAR4C;;EAiClDS,MAAM,CAACC,OAAD,QAAmB;IAAA,IAAT,CAACC,OAAD,CAAS;IACvB,MAAMC,OAAO,GAAGlB,IAAI,CAACmB,iBAAL,CAAuBH,OAAvB,CAAhB;IACA,MAAMI,OAAO,GAAGF,OAAO,CAACG,OAAR,CAAgBC,cAAhB,EAAhB;IAEA;;;;;IAIA,SAASC,iBAAT,CAA2BC,IAA3B,EAAgE;MAC9D,MAAMlB,IAAI,GAAGc,OAAO,CAACK,iBAAR,CACXP,OAAO,CAACQ,qBAAR,CAA8BC,GAA9B,CAAkCH,IAAlC,CADW,CAAb;;MAGA,IAAIJ,OAAO,CAACQ,WAAR,CAAoBtB,IAApB,KAA6Bc,OAAO,CAACS,WAAR,CAAoBvB,IAApB,CAAjC,EAA4D;QAC1D,MAAMwB,QAAQ,GAAGV,OAAO,CAACW,gBAAR,CAAyBzB,IAAzB,CAAjB;QACA,OAAOwB,QAAQ,CAACE,KAAT,CACLC,GAAG,IAAIjC,IAAI,CAACkC,WAAL,CAAiBd,OAAjB,EAA0Ba,GAA1B,MAAmC,QADrC,CAAP;MAGD;;MACD,OAAO,KAAP;IACD;;IAED,OAAO;MACL,8FACEE,MADF,EACmC;QAEjC,MAAMC,MAAM,GAAGlB,OAAO,CAACQ,qBAAR,CAA8BC,GAA9B,CAAkCQ,MAAM,CAACE,MAAzC,CAAf;QACA,MAAMC,aAAa,GAAGtC,IAAI,CAACuC,4BAAL,CACpBnB,OADoB,EAEpBgB,MAFoB,CAAtB;;QAKA,IAAInB,OAAO,CAACb,kBAAR,IAA8BmB,iBAAiB,CAACY,MAAM,CAACE,MAAR,CAAnD,EAAoE;UAClE;QACD;;QAED,IAAIrC,IAAI,CAACwC,kCAAL,CAAwCF,aAAxC,EAAuDlB,OAAvD,CAAJ,EAAqE;UACnEJ,OAAO,CAACyB,MAAR,CAAe;YAAEjB,IAAI,EAAEW,MAAM,CAACO,MAAf;YAAwBC,SAAS,EAAE;UAAnC,CAAf;QACD;MACF;;IAjBI,CAAP;EAmBD;;AAzEiD,CAArC,CAAf","names":["exports","util","createRule","name","defaultOptions","ignoreStringArrays","meta","type","docs","description","recommended","requiresTypeChecking","messages","requireCompare","schema","properties","create","context","options","service","getParserServices","checker","program","getTypeChecker","isStringArrayNode","node","getTypeAtLocation","esTreeNodeToTSNodeMap","get","isArrayType","isTupleType","typeArgs","getTypeArguments","every","arg","getTypeName","callee","tsNode","object","calleeObjType","getConstrainedTypeAtLocation","isTypeArrayTypeOrUnionOfArrayTypes","report","parent","messageId"],"sources":["../../src/rules/require-array-sort-compare.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}