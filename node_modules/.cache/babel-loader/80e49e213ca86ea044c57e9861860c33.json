{"ast":null,"code":"/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Enforce camelcase naming convention\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/camelcase\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreImports: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreGlobals: {\n          type: \"boolean\",\n          default: false\n        },\n        properties: {\n          enum: [\"always\", \"never\"]\n        },\n        allow: {\n          type: \"array\",\n          items: [{\n            type: \"string\"\n          }],\n          minItems: 0,\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      notCamelCase: \"Identifier '{{name}}' is not in camel case.\",\n      notCamelCasePrivate: \"#{{name}} is not in camel case.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const properties = options.properties === \"never\" ? \"never\" : \"always\";\n    const ignoreDestructuring = options.ignoreDestructuring;\n    const ignoreImports = options.ignoreImports;\n    const ignoreGlobals = options.ignoreGlobals;\n    const allow = options.allow || []; //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n    // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n\n    const reported = new Set();\n    /**\n     * Checks if a string contains an underscore and isn't all upper-case\n     * @param {string} name The string to check.\n     * @returns {boolean} if the string is underscored\n     * @private\n     */\n\n    function isUnderscored(name) {\n      const nameBody = name.replace(/^_+|_+$/gu, \"\"); // if there's an underscore, it might be A_CONSTANT, which is okay\n\n      return nameBody.includes(\"_\") && nameBody !== nameBody.toUpperCase();\n    }\n    /**\n     * Checks if a string match the ignore list\n     * @param {string} name The string to check.\n     * @returns {boolean} if the string is ignored\n     * @private\n     */\n\n\n    function isAllowed(name) {\n      return allow.some(entry => name === entry || name.match(new RegExp(entry, \"u\")));\n    }\n    /**\n     * Checks if a given name is good or not.\n     * @param {string} name The name to check.\n     * @returns {boolean} `true` if the name is good.\n     * @private\n     */\n\n\n    function isGoodName(name) {\n      return !isUnderscored(name) || isAllowed(name);\n    }\n    /**\n     * Checks if a given identifier reference or member expression is an assignment\n     * target.\n     * @param {ASTNode} node The node to check.\n     * @returns {boolean} `true` if the node is an assignment target.\n     */\n\n\n    function isAssignmentTarget(node) {\n      const parent = node.parent;\n\n      switch (parent.type) {\n        case \"AssignmentExpression\":\n        case \"AssignmentPattern\":\n          return parent.left === node;\n\n        case \"Property\":\n          return parent.parent.type === \"ObjectPattern\" && parent.value === node;\n\n        case \"ArrayPattern\":\n        case \"RestElement\":\n          return true;\n\n        default:\n          return false;\n      }\n    }\n    /**\n     * Checks if a given binding identifier uses the original name as-is.\n     * - If it's in object destructuring or object expression, the original name is its property name.\n     * - If it's in import declaration, the original name is its exported name.\n     * @param {ASTNode} node The `Identifier` node to check.\n     * @returns {boolean} `true` if the identifier uses the original name as-is.\n     */\n\n\n    function equalsToOriginalName(node) {\n      const localName = node.name;\n      const valueNode = node.parent.type === \"AssignmentPattern\" ? node.parent : node;\n      const parent = valueNode.parent;\n\n      switch (parent.type) {\n        case \"Property\":\n          return (parent.parent.type === \"ObjectPattern\" || parent.parent.type === \"ObjectExpression\") && parent.value === valueNode && !parent.computed && parent.key.type === \"Identifier\" && parent.key.name === localName;\n\n        case \"ImportSpecifier\":\n          return parent.local === node && astUtils.getModuleExportName(parent.imported) === localName;\n\n        default:\n          return false;\n      }\n    }\n    /**\n     * Reports an AST node as a rule violation.\n     * @param {ASTNode} node The node to report.\n     * @returns {void}\n     * @private\n     */\n\n\n    function report(node) {\n      if (reported.has(node.range[0])) {\n        return;\n      }\n\n      reported.add(node.range[0]); // Report it.\n\n      context.report({\n        node,\n        messageId: node.type === \"PrivateIdentifier\" ? \"notCamelCasePrivate\" : \"notCamelCase\",\n        data: {\n          name: node.name\n        }\n      });\n    }\n    /**\n     * Reports an identifier reference or a binding identifier.\n     * @param {ASTNode} node The `Identifier` node to report.\n     * @returns {void}\n     */\n\n\n    function reportReferenceId(node) {\n      /*\n       * For backward compatibility, if it's in callings then ignore it.\n       * Not sure why it is.\n       */\n      if (node.parent.type === \"CallExpression\" || node.parent.type === \"NewExpression\") {\n        return;\n      }\n      /*\n       * For backward compatibility, if it's a default value of\n       * destructuring/parameters then ignore it.\n       * Not sure why it is.\n       */\n\n\n      if (node.parent.type === \"AssignmentPattern\" && node.parent.right === node) {\n        return;\n      }\n      /*\n       * The `ignoreDestructuring` flag skips the identifiers that uses\n       * the property name as-is.\n       */\n\n\n      if (ignoreDestructuring && equalsToOriginalName(node)) {\n        return;\n      }\n\n      report(node);\n    }\n\n    return {\n      // Report camelcase of global variable references ------------------\n      Program() {\n        const scope = context.getScope();\n\n        if (!ignoreGlobals) {\n          // Defined globals in config files or directive comments.\n          for (const variable of scope.variables) {\n            if (variable.identifiers.length > 0 || isGoodName(variable.name)) {\n              continue;\n            }\n\n            for (const reference of variable.references) {\n              /*\n               * For backward compatibility, this rule reports read-only\n               * references as well.\n               */\n              reportReferenceId(reference.identifier);\n            }\n          }\n        } // Undefined globals.\n\n\n        for (const reference of scope.through) {\n          const id = reference.identifier;\n\n          if (isGoodName(id.name)) {\n            continue;\n          }\n          /*\n           * For backward compatibility, this rule reports read-only\n           * references as well.\n           */\n\n\n          reportReferenceId(id);\n        }\n      },\n\n      // Report camelcase of declared variables --------------------------\n      [[\"VariableDeclaration\", \"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\", \"ClassDeclaration\", \"ClassExpression\", \"CatchClause\"]](node) {\n        for (const variable of context.getDeclaredVariables(node)) {\n          if (isGoodName(variable.name)) {\n            continue;\n          }\n\n          const id = variable.identifiers[0]; // Report declaration.\n\n          if (!(ignoreDestructuring && equalsToOriginalName(id))) {\n            report(id);\n          }\n          /*\n           * For backward compatibility, report references as well.\n           * It looks unnecessary because declarations are reported.\n           */\n\n\n          for (const reference of variable.references) {\n            if (reference.init) {\n              continue; // Skip the write references of initializers.\n            }\n\n            reportReferenceId(reference.identifier);\n          }\n        }\n      },\n\n      // Report camelcase in properties ----------------------------------\n      [[\"ObjectExpression > Property[computed!=true] > Identifier.key\", \"MethodDefinition[computed!=true] > Identifier.key\", \"PropertyDefinition[computed!=true] > Identifier.key\", \"MethodDefinition > PrivateIdentifier.key\", \"PropertyDefinition > PrivateIdentifier.key\"]](node) {\n        if (properties === \"never\" || isGoodName(node.name)) {\n          return;\n        }\n\n        report(node);\n      },\n\n      \"MemberExpression[computed!=true] > Identifier.property\"(node) {\n        if (properties === \"never\" || !isAssignmentTarget(node.parent) || // ‚Üê ignore read-only references.\n        isGoodName(node.name)) {\n          return;\n        }\n\n        report(node);\n      },\n\n      // Report camelcase in import --------------------------------------\n      ImportDeclaration(node) {\n        for (const variable of context.getDeclaredVariables(node)) {\n          if (isGoodName(variable.name)) {\n            continue;\n          }\n\n          const id = variable.identifiers[0]; // Report declaration.\n\n          if (!(ignoreImports && equalsToOriginalName(id))) {\n            report(id);\n          }\n          /*\n           * For backward compatibility, report references as well.\n           * It looks unnecessary because declarations are reported.\n           */\n\n\n          for (const reference of variable.references) {\n            reportReferenceId(reference.identifier);\n          }\n        }\n      },\n\n      // Report camelcase in re-export -----------------------------------\n      [[\"ExportAllDeclaration > Identifier.exported\", \"ExportSpecifier > Identifier.exported\"]](node) {\n        if (isGoodName(node.name)) {\n          return;\n        }\n\n        report(node);\n      },\n\n      // Report camelcase in labels --------------------------------------\n      [[\"LabeledStatement > Identifier.label\",\n      /*\n       * For backward compatibility, report references as well.\n       * It looks unnecessary because declarations are reported.\n       */\n      \"BreakStatement > Identifier.label\", \"ContinueStatement > Identifier.label\"]](node) {\n        if (isGoodName(node.name)) {\n          return;\n        }\n\n        report(node);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","properties","ignoreDestructuring","default","ignoreImports","ignoreGlobals","enum","allow","items","minItems","uniqueItems","additionalProperties","messages","notCamelCase","notCamelCasePrivate","create","context","options","reported","Set","isUnderscored","name","nameBody","replace","includes","toUpperCase","isAllowed","some","entry","match","RegExp","isGoodName","isAssignmentTarget","node","parent","left","value","equalsToOriginalName","localName","valueNode","computed","key","local","getModuleExportName","imported","report","has","range","add","messageId","data","reportReferenceId","right","Program","scope","getScope","variable","variables","identifiers","length","reference","references","identifier","through","id","getDeclaredVariables","init","ImportDeclaration"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/camelcase.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce camelcase naming convention\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/camelcase\"\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    ignoreDestructuring: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreImports: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    ignoreGlobals: {\n                        type: \"boolean\",\n                        default: false\n                    },\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    },\n                    allow: {\n                        type: \"array\",\n                        items: [\n                            {\n                                type: \"string\"\n                            }\n                        ],\n                        minItems: 0,\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        messages: {\n            notCamelCase: \"Identifier '{{name}}' is not in camel case.\",\n            notCamelCasePrivate: \"#{{name}} is not in camel case.\"\n        }\n    },\n\n    create(context) {\n        const options = context.options[0] || {};\n        const properties = options.properties === \"never\" ? \"never\" : \"always\";\n        const ignoreDestructuring = options.ignoreDestructuring;\n        const ignoreImports = options.ignoreImports;\n        const ignoreGlobals = options.ignoreGlobals;\n        const allow = options.allow || [];\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        const reported = new Set();\n\n        /**\n         * Checks if a string contains an underscore and isn't all upper-case\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is underscored\n         * @private\n         */\n        function isUnderscored(name) {\n            const nameBody = name.replace(/^_+|_+$/gu, \"\");\n\n            // if there's an underscore, it might be A_CONSTANT, which is okay\n            return nameBody.includes(\"_\") && nameBody !== nameBody.toUpperCase();\n        }\n\n        /**\n         * Checks if a string match the ignore list\n         * @param {string} name The string to check.\n         * @returns {boolean} if the string is ignored\n         * @private\n         */\n        function isAllowed(name) {\n            return allow.some(\n                entry => name === entry || name.match(new RegExp(entry, \"u\"))\n            );\n        }\n\n        /**\n         * Checks if a given name is good or not.\n         * @param {string} name The name to check.\n         * @returns {boolean} `true` if the name is good.\n         * @private\n         */\n        function isGoodName(name) {\n            return !isUnderscored(name) || isAllowed(name);\n        }\n\n        /**\n         * Checks if a given identifier reference or member expression is an assignment\n         * target.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} `true` if the node is an assignment target.\n         */\n        function isAssignmentTarget(node) {\n            const parent = node.parent;\n\n            switch (parent.type) {\n                case \"AssignmentExpression\":\n                case \"AssignmentPattern\":\n                    return parent.left === node;\n\n                case \"Property\":\n                    return (\n                        parent.parent.type === \"ObjectPattern\" &&\n                        parent.value === node\n                    );\n                case \"ArrayPattern\":\n                case \"RestElement\":\n                    return true;\n\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Checks if a given binding identifier uses the original name as-is.\n         * - If it's in object destructuring or object expression, the original name is its property name.\n         * - If it's in import declaration, the original name is its exported name.\n         * @param {ASTNode} node The `Identifier` node to check.\n         * @returns {boolean} `true` if the identifier uses the original name as-is.\n         */\n        function equalsToOriginalName(node) {\n            const localName = node.name;\n            const valueNode = node.parent.type === \"AssignmentPattern\"\n                ? node.parent\n                : node;\n            const parent = valueNode.parent;\n\n            switch (parent.type) {\n                case \"Property\":\n                    return (\n                        (parent.parent.type === \"ObjectPattern\" || parent.parent.type === \"ObjectExpression\") &&\n                        parent.value === valueNode &&\n                        !parent.computed &&\n                        parent.key.type === \"Identifier\" &&\n                        parent.key.name === localName\n                    );\n\n                case \"ImportSpecifier\":\n                    return (\n                        parent.local === node &&\n                        astUtils.getModuleExportName(parent.imported) === localName\n                    );\n\n                default:\n                    return false;\n            }\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (reported.has(node.range[0])) {\n                return;\n            }\n            reported.add(node.range[0]);\n\n            // Report it.\n            context.report({\n                node,\n                messageId: node.type === \"PrivateIdentifier\"\n                    ? \"notCamelCasePrivate\"\n                    : \"notCamelCase\",\n                data: { name: node.name }\n            });\n        }\n\n        /**\n         * Reports an identifier reference or a binding identifier.\n         * @param {ASTNode} node The `Identifier` node to report.\n         * @returns {void}\n         */\n        function reportReferenceId(node) {\n\n            /*\n             * For backward compatibility, if it's in callings then ignore it.\n             * Not sure why it is.\n             */\n            if (\n                node.parent.type === \"CallExpression\" ||\n                node.parent.type === \"NewExpression\"\n            ) {\n                return;\n            }\n\n            /*\n             * For backward compatibility, if it's a default value of\n             * destructuring/parameters then ignore it.\n             * Not sure why it is.\n             */\n            if (\n                node.parent.type === \"AssignmentPattern\" &&\n                node.parent.right === node\n            ) {\n                return;\n            }\n\n            /*\n             * The `ignoreDestructuring` flag skips the identifiers that uses\n             * the property name as-is.\n             */\n            if (ignoreDestructuring && equalsToOriginalName(node)) {\n                return;\n            }\n\n            report(node);\n        }\n\n        return {\n\n            // Report camelcase of global variable references ------------------\n            Program() {\n                const scope = context.getScope();\n\n                if (!ignoreGlobals) {\n\n                    // Defined globals in config files or directive comments.\n                    for (const variable of scope.variables) {\n                        if (\n                            variable.identifiers.length > 0 ||\n                            isGoodName(variable.name)\n                        ) {\n                            continue;\n                        }\n                        for (const reference of variable.references) {\n\n                            /*\n                             * For backward compatibility, this rule reports read-only\n                             * references as well.\n                             */\n                            reportReferenceId(reference.identifier);\n                        }\n                    }\n                }\n\n                // Undefined globals.\n                for (const reference of scope.through) {\n                    const id = reference.identifier;\n\n                    if (isGoodName(id.name)) {\n                        continue;\n                    }\n\n                    /*\n                     * For backward compatibility, this rule reports read-only\n                     * references as well.\n                     */\n                    reportReferenceId(id);\n                }\n            },\n\n            // Report camelcase of declared variables --------------------------\n            [[\n                \"VariableDeclaration\",\n                \"FunctionDeclaration\",\n                \"FunctionExpression\",\n                \"ArrowFunctionExpression\",\n                \"ClassDeclaration\",\n                \"ClassExpression\",\n                \"CatchClause\"\n            ]](node) {\n                for (const variable of context.getDeclaredVariables(node)) {\n                    if (isGoodName(variable.name)) {\n                        continue;\n                    }\n                    const id = variable.identifiers[0];\n\n                    // Report declaration.\n                    if (!(ignoreDestructuring && equalsToOriginalName(id))) {\n                        report(id);\n                    }\n\n                    /*\n                     * For backward compatibility, report references as well.\n                     * It looks unnecessary because declarations are reported.\n                     */\n                    for (const reference of variable.references) {\n                        if (reference.init) {\n                            continue; // Skip the write references of initializers.\n                        }\n                        reportReferenceId(reference.identifier);\n                    }\n                }\n            },\n\n            // Report camelcase in properties ----------------------------------\n            [[\n                \"ObjectExpression > Property[computed!=true] > Identifier.key\",\n                \"MethodDefinition[computed!=true] > Identifier.key\",\n                \"PropertyDefinition[computed!=true] > Identifier.key\",\n                \"MethodDefinition > PrivateIdentifier.key\",\n                \"PropertyDefinition > PrivateIdentifier.key\"\n            ]](node) {\n                if (properties === \"never\" || isGoodName(node.name)) {\n                    return;\n                }\n                report(node);\n            },\n            \"MemberExpression[computed!=true] > Identifier.property\"(node) {\n                if (\n                    properties === \"never\" ||\n                    !isAssignmentTarget(node.parent) || // ‚Üê ignore read-only references.\n                    isGoodName(node.name)\n                ) {\n                    return;\n                }\n                report(node);\n            },\n\n            // Report camelcase in import --------------------------------------\n            ImportDeclaration(node) {\n                for (const variable of context.getDeclaredVariables(node)) {\n                    if (isGoodName(variable.name)) {\n                        continue;\n                    }\n                    const id = variable.identifiers[0];\n\n                    // Report declaration.\n                    if (!(ignoreImports && equalsToOriginalName(id))) {\n                        report(id);\n                    }\n\n                    /*\n                     * For backward compatibility, report references as well.\n                     * It looks unnecessary because declarations are reported.\n                     */\n                    for (const reference of variable.references) {\n                        reportReferenceId(reference.identifier);\n                    }\n                }\n            },\n\n            // Report camelcase in re-export -----------------------------------\n            [[\n                \"ExportAllDeclaration > Identifier.exported\",\n                \"ExportSpecifier > Identifier.exported\"\n            ]](node) {\n                if (isGoodName(node.name)) {\n                    return;\n                }\n                report(node);\n            },\n\n            // Report camelcase in labels --------------------------------------\n            [[\n                \"LabeledStatement > Identifier.label\",\n\n                /*\n                 * For backward compatibility, report references as well.\n                 * It looks unnecessary because declarations are reported.\n                 */\n                \"BreakStatement > Identifier.label\",\n                \"ContinueStatement > Identifier.label\"\n            ]](node) {\n                if (isGoodName(node.name)) {\n                    return;\n                }\n                report(node);\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}