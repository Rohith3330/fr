{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = filterItems;\nexports.isRequired = isRequired;\nexports.targetsSupported = targetsSupported;\n\nvar _semver = require(\"semver\");\n\nvar _plugins = require(\"@babel/compat-data/plugins\");\n\nvar _utils = require(\"./utils\");\n\nfunction targetsSupported(target, support) {\n  const targetEnvironments = Object.keys(target);\n\n  if (targetEnvironments.length === 0) {\n    return false;\n  }\n\n  const unsupportedEnvironments = targetEnvironments.filter(environment => {\n    const lowestImplementedVersion = (0, _utils.getLowestImplementedVersion)(support, environment);\n\n    if (!lowestImplementedVersion) {\n      return true;\n    }\n\n    const lowestTargetedVersion = target[environment];\n\n    if ((0, _utils.isUnreleasedVersion)(lowestTargetedVersion, environment)) {\n      return false;\n    }\n\n    if ((0, _utils.isUnreleasedVersion)(lowestImplementedVersion, environment)) {\n      return true;\n    }\n\n    if (!_semver.valid(lowestTargetedVersion.toString())) {\n      throw new Error(`Invalid version passed for target \"${environment}\": \"${lowestTargetedVersion}\". ` + \"Versions must be in semver format (major.minor.patch)\");\n    }\n\n    return _semver.gt((0, _utils.semverify)(lowestImplementedVersion), lowestTargetedVersion.toString());\n  });\n  return unsupportedEnvironments.length === 0;\n}\n\nfunction isRequired(name, targets) {\n  let {\n    compatData = _plugins,\n    includes,\n    excludes\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (excludes != null && excludes.has(name)) return false;\n  if (includes != null && includes.has(name)) return true;\n  return !targetsSupported(targets, compatData[name]);\n}\n\nfunction filterItems(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {\n  const result = new Set();\n  const options = {\n    compatData: list,\n    includes,\n    excludes\n  };\n\n  for (const item in list) {\n    if (isRequired(item, targets, options)) {\n      result.add(item);\n    } else if (pluginSyntaxMap) {\n      const shippedProposalsSyntax = pluginSyntaxMap.get(item);\n\n      if (shippedProposalsSyntax) {\n        result.add(shippedProposalsSyntax);\n      }\n    }\n  }\n\n  if (defaultIncludes) {\n    defaultIncludes.forEach(item => !excludes.has(item) && result.add(item));\n  }\n\n  if (defaultExcludes) {\n    defaultExcludes.forEach(item => !includes.has(item) && result.delete(item));\n  }\n\n  return result;\n}","map":{"version":3,"mappings":"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","names":["targetsSupported","target","support","targetEnvironments","Object","keys","length","unsupportedEnvironments","filter","environment","lowestImplementedVersion","lowestTargetedVersion","semver","valid","toString","Error","gt","isRequired","name","targets","compatData","pluginsCompatData","includes","excludes","has","filterItems","list","defaultIncludes","defaultExcludes","pluginSyntaxMap","result","Set","options","item","add","shippedProposalsSyntax","get","forEach","delete"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-compilation-targets\\src\\filter-items.ts"],"sourcesContent":["import semver from \"semver\";\n\nimport pluginsCompatData from \"@babel/compat-data/plugins\";\n\nimport type { Targets } from \"./types\";\nimport {\n  getLowestImplementedVersion,\n  isUnreleasedVersion,\n  semverify,\n} from \"./utils\";\n\nexport function targetsSupported(target: Targets, support: Targets) {\n  const targetEnvironments = Object.keys(target) as Array<keyof Targets>;\n\n  if (targetEnvironments.length === 0) {\n    return false;\n  }\n\n  const unsupportedEnvironments = targetEnvironments.filter(environment => {\n    const lowestImplementedVersion = getLowestImplementedVersion(\n      support,\n      environment,\n    );\n\n    // Feature is not implemented in that environment\n    if (!lowestImplementedVersion) {\n      return true;\n    }\n\n    const lowestTargetedVersion = target[environment];\n\n    // If targets has unreleased value as a lowest version, then don't require a plugin.\n    if (isUnreleasedVersion(lowestTargetedVersion, environment)) {\n      return false;\n    }\n\n    // Include plugin if it is supported in the unreleased environment, which wasn't specified in targets\n    if (isUnreleasedVersion(lowestImplementedVersion, environment)) {\n      return true;\n    }\n\n    if (!semver.valid(lowestTargetedVersion.toString())) {\n      throw new Error(\n        `Invalid version passed for target \"${environment}\": \"${lowestTargetedVersion}\". ` +\n          \"Versions must be in semver format (major.minor.patch)\",\n      );\n    }\n\n    return semver.gt(\n      semverify(lowestImplementedVersion),\n      lowestTargetedVersion.toString(),\n    );\n  });\n\n  return unsupportedEnvironments.length === 0;\n}\n\nexport function isRequired(\n  name: string,\n  targets: Targets,\n  {\n    compatData = pluginsCompatData,\n    includes,\n    excludes,\n  }: {\n    compatData?: { [feature: string]: Targets };\n    includes?: Set<string>;\n    excludes?: Set<string>;\n  } = {},\n) {\n  if (excludes?.has(name)) return false;\n  if (includes?.has(name)) return true;\n  return !targetsSupported(targets, compatData[name]);\n}\n\nexport default function filterItems(\n  list: { [feature: string]: Targets },\n  includes: Set<string>,\n  excludes: Set<string>,\n  targets: Targets,\n  defaultIncludes: Array<string> | null,\n  defaultExcludes?: Array<string> | null,\n  pluginSyntaxMap?: Map<string, string | null>,\n) {\n  const result = new Set<string>();\n  const options = { compatData: list, includes, excludes };\n\n  for (const item in list) {\n    if (isRequired(item, targets, options)) {\n      result.add(item);\n    } else if (pluginSyntaxMap) {\n      const shippedProposalsSyntax = pluginSyntaxMap.get(item);\n\n      if (shippedProposalsSyntax) {\n        result.add(shippedProposalsSyntax);\n      }\n    }\n  }\n\n  if (defaultIncludes) {\n    defaultIncludes.forEach(item => !excludes.has(item) && result.add(item));\n  }\n\n  if (defaultExcludes) {\n    defaultExcludes.forEach(item => !includes.has(item) && result.delete(item));\n  }\n\n  return result;\n}\n"]},"metadata":{},"sourceType":"script"}