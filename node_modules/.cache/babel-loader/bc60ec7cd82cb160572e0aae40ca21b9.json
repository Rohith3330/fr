{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst tsutils_1 = require(\"tsutils\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nconst getOperatorPrecedence_1 = require(\"../util/getOperatorPrecedence\");\n\nexports.default = util.createRule({\n  name: 'return-await',\n  meta: {\n    docs: {\n      description: 'Enforce consistent returning of awaited values',\n      recommended: false,\n      requiresTypeChecking: true,\n      extendsBaseRule: 'no-return-await'\n    },\n    fixable: 'code',\n    hasSuggestions: true,\n    type: 'problem',\n    messages: {\n      nonPromiseAwait: 'Returning an awaited value that is not a promise is not allowed.',\n      disallowedPromiseAwait: 'Returning an awaited promise is not allowed in this context.',\n      requiredPromiseAwait: 'Returning an awaited promise is required in this context.'\n    },\n    schema: [{\n      enum: ['in-try-catch', 'always', 'never']\n    }]\n  },\n  defaultOptions: ['in-try-catch'],\n\n  create(context, _ref) {\n    let [option] = _ref;\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n    const scopeInfoStack = [];\n\n    function enterFunction(node) {\n      scopeInfoStack.push({\n        hasAsync: node.async,\n        owningFunc: node\n      });\n    }\n\n    function exitFunction() {\n      scopeInfoStack.pop();\n    }\n\n    function inTry(node) {\n      let ancestor = node.parent;\n\n      while (ancestor && !ts.isFunctionLike(ancestor)) {\n        if (ts.isTryStatement(ancestor)) {\n          return true;\n        }\n\n        ancestor = ancestor.parent;\n      }\n\n      return false;\n    }\n\n    function inCatch(node) {\n      let ancestor = node.parent;\n\n      while (ancestor && !ts.isFunctionLike(ancestor)) {\n        if (ts.isCatchClause(ancestor)) {\n          return true;\n        }\n\n        ancestor = ancestor.parent;\n      }\n\n      return false;\n    }\n\n    function isReturnPromiseInFinally(node) {\n      let ancestor = node.parent;\n\n      while (ancestor && !ts.isFunctionLike(ancestor)) {\n        if (ts.isTryStatement(ancestor.parent) && ts.isBlock(ancestor) && ancestor.parent.end === ancestor.end) {\n          return true;\n        }\n\n        ancestor = ancestor.parent;\n      }\n\n      return false;\n    }\n\n    function hasFinallyBlock(node) {\n      let ancestor = node.parent;\n\n      while (ancestor && !ts.isFunctionLike(ancestor)) {\n        if (ts.isTryStatement(ancestor)) {\n          return !!ancestor.finallyBlock;\n        }\n\n        ancestor = ancestor.parent;\n      }\n\n      return false;\n    } // function findTokensToRemove()\n\n\n    function removeAwait(fixer, node) {\n      // Should always be an await node; but let's be safe.\n\n      /* istanbul ignore if */\n      if (!util.isAwaitExpression(node)) {\n        return null;\n      }\n\n      const awaitToken = sourceCode.getFirstToken(node, util.isAwaitKeyword); // Should always be the case; but let's be safe.\n\n      /* istanbul ignore if */\n\n      if (!awaitToken) {\n        return null;\n      }\n\n      const startAt = awaitToken.range[0];\n      let endAt = awaitToken.range[1]; // Also remove any extraneous whitespace after `await`, if there is any.\n\n      const nextToken = sourceCode.getTokenAfter(awaitToken, {\n        includeComments: true\n      });\n\n      if (nextToken) {\n        endAt = nextToken.range[0];\n      }\n\n      return fixer.removeRange([startAt, endAt]);\n    }\n\n    function insertAwait(fixer, node, isHighPrecendence) {\n      if (isHighPrecendence) {\n        return fixer.insertTextBefore(node, 'await ');\n      } else {\n        return [fixer.insertTextBefore(node, 'await ('), fixer.insertTextAfter(node, ')')];\n      }\n    }\n\n    function isHigherPrecedenceThanAwait(node) {\n      const operator = (0, tsutils_1.isBinaryExpression)(node) ? node.operatorToken.kind : ts.SyntaxKind.Unknown;\n      const nodePrecedence = (0, getOperatorPrecedence_1.getOperatorPrecedence)(node.kind, operator);\n      const awaitPrecedence = (0, getOperatorPrecedence_1.getOperatorPrecedence)(ts.SyntaxKind.AwaitExpression, ts.SyntaxKind.Unknown);\n      return nodePrecedence > awaitPrecedence;\n    }\n\n    function test(node, expression) {\n      let child;\n      const isAwait = ts.isAwaitExpression(expression);\n\n      if (isAwait) {\n        child = expression.getChildAt(1);\n      } else {\n        child = expression;\n      }\n\n      const type = checker.getTypeAtLocation(child);\n      const isThenable = tsutils.isThenableType(checker, expression, type);\n\n      if (!isAwait && !isThenable) {\n        return;\n      }\n\n      if (isAwait && !isThenable) {\n        // any/unknown could be thenable; do not auto-fix\n        const useAutoFix = !(util.isTypeAnyType(type) || util.isTypeUnknownType(type));\n\n        const fix = fixer => removeAwait(fixer, node);\n\n        context.report(Object.assign({\n          messageId: 'nonPromiseAwait',\n          node\n        }, useAutoFix ? {\n          fix\n        } : {\n          suggest: [{\n            messageId: 'nonPromiseAwait',\n            fix\n          }]\n        }));\n        return;\n      }\n\n      if (option === 'always') {\n        if (!isAwait && isThenable) {\n          context.report({\n            messageId: 'requiredPromiseAwait',\n            node,\n            fix: fixer => insertAwait(fixer, node, isHigherPrecedenceThanAwait(expression))\n          });\n        }\n\n        return;\n      }\n\n      if (option === 'never') {\n        if (isAwait) {\n          context.report({\n            messageId: 'disallowedPromiseAwait',\n            node,\n            fix: fixer => removeAwait(fixer, node)\n          });\n        }\n\n        return;\n      }\n\n      if (option === 'in-try-catch') {\n        const isInTryCatch = inTry(expression) || inCatch(expression);\n\n        if (isAwait && !isInTryCatch) {\n          context.report({\n            messageId: 'disallowedPromiseAwait',\n            node,\n            fix: fixer => removeAwait(fixer, node)\n          });\n        } else if (!isAwait && isInTryCatch) {\n          if (inCatch(expression) && !hasFinallyBlock(expression)) {\n            return;\n          }\n\n          if (isReturnPromiseInFinally(expression)) {\n            return;\n          }\n\n          context.report({\n            messageId: 'requiredPromiseAwait',\n            node,\n            fix: fixer => insertAwait(fixer, node, isHigherPrecedenceThanAwait(expression))\n          });\n        }\n\n        return;\n      }\n    }\n\n    function findPossiblyReturnedNodes(node) {\n      if (node.type === utils_1.AST_NODE_TYPES.ConditionalExpression) {\n        return [...findPossiblyReturnedNodes(node.alternate), ...findPossiblyReturnedNodes(node.consequent)];\n      }\n\n      return [node];\n    }\n\n    return {\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n      ArrowFunctionExpression: enterFunction,\n      'FunctionDeclaration:exit': exitFunction,\n      'FunctionExpression:exit': exitFunction,\n      'ArrowFunctionExpression:exit': exitFunction,\n\n      // executes after less specific handler, so exitFunction is called\n      'ArrowFunctionExpression[async = true]:exit'(node) {\n        if (node.body.type !== utils_1.AST_NODE_TYPES.BlockStatement) {\n          findPossiblyReturnedNodes(node.body).forEach(node => {\n            const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n            test(node, tsNode);\n          });\n        }\n      },\n\n      ReturnStatement(node) {\n        const scopeInfo = scopeInfoStack[scopeInfoStack.length - 1];\n\n        if (!(scopeInfo === null || scopeInfo === void 0 ? void 0 : scopeInfo.hasAsync) || !node.argument) {\n          return;\n        }\n\n        findPossiblyReturnedNodes(node.argument).forEach(node => {\n          const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n          test(node, tsNode);\n        });\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","docs","description","recommended","requiresTypeChecking","extendsBaseRule","fixable","hasSuggestions","type","messages","nonPromiseAwait","disallowedPromiseAwait","requiredPromiseAwait","schema","enum","defaultOptions","create","context","option","parserServices","getParserServices","checker","program","getTypeChecker","sourceCode","getSourceCode","scopeInfoStack","enterFunction","node","push","hasAsync","async","owningFunc","exitFunction","pop","inTry","ancestor","parent","ts","isFunctionLike","isTryStatement","inCatch","isCatchClause","isReturnPromiseInFinally","isBlock","end","hasFinallyBlock","finallyBlock","removeAwait","fixer","isAwaitExpression","awaitToken","getFirstToken","isAwaitKeyword","startAt","range","endAt","nextToken","getTokenAfter","includeComments","removeRange","insertAwait","isHighPrecendence","insertTextBefore","insertTextAfter","isHigherPrecedenceThanAwait","operator","operatorToken","kind","SyntaxKind","Unknown","nodePrecedence","awaitPrecedence","AwaitExpression","test","expression","child","isAwait","getChildAt","getTypeAtLocation","isThenable","tsutils","isThenableType","useAutoFix","isTypeAnyType","isTypeUnknownType","fix","report","Object","messageId","suggest","isInTryCatch","findPossiblyReturnedNodes","utils_1","ConditionalExpression","alternate","consequent","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","body","BlockStatement","forEach","tsNode","esTreeNodeToTSNodeMap","get","ReturnStatement","scopeInfo","length","argument"],"sources":["../../src/rules/return-await.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}