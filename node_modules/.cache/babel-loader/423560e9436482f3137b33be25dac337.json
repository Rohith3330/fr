{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n/**\n * Parses a given value as options.\n * @param {any} options A value to parse.\n * @returns {Object} The parsed options.\n */\n\nfunction parseOptions(options) {\n  let functions = true;\n  let classes = true;\n  let variables = true;\n  let allowNamedExports = false;\n\n  if (typeof options === \"string\") {\n    functions = options !== \"nofunc\";\n  } else if (typeof options === \"object\" && options !== null) {\n    functions = options.functions !== false;\n    classes = options.classes !== false;\n    variables = options.variables !== false;\n    allowNamedExports = !!options.allowNamedExports;\n  }\n\n  return {\n    functions,\n    classes,\n    variables,\n    allowNamedExports\n  };\n}\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n * @param {ASTNode} node An node to check.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\n\n\nfunction isInRange(node, location) {\n  return node && node.range[0] <= location && location <= node.range[1];\n}\n/**\n * Checks whether or not a given location is inside of the range of a class static initializer.\n * Static initializers are static blocks and initializers of static fields.\n * @param {ASTNode} node `ClassBody` node to check static initializers.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of a class static initializer.\n */\n\n\nfunction isInClassStaticInitializerRange(node, location) {\n  return node.body.some(classMember => classMember.type === \"StaticBlock\" && isInRange(classMember, location) || classMember.type === \"PropertyDefinition\" && classMember.static && classMember.value && isInRange(classMember.value, location));\n}\n/**\n * Checks whether a given scope is the scope of a a class static initializer.\n * Static initializers are static blocks and initializers of static fields.\n * @param {eslint-scope.Scope} scope A scope to check.\n * @returns {boolean} `true` if the scope is a class static initializer scope.\n */\n\n\nfunction isClassStaticInitializerScope(scope) {\n  if (scope.type === \"class-static-block\") {\n    return true;\n  }\n\n  if (scope.type === \"class-field-initializer\") {\n    // `scope.block` is PropertyDefinition#value node\n    const propertyDefinition = scope.block.parent;\n    return propertyDefinition.static;\n  }\n\n  return false;\n}\n/**\n * Checks whether a given reference is evaluated in an execution context\n * that isn't the one where the variable it refers to is defined.\n * Execution contexts are:\n * - top-level\n * - functions\n * - class field initializers (implicit functions)\n * - class static blocks (implicit functions)\n * Static class field initializers and class static blocks are automatically run during the class definition evaluation,\n * and therefore we'll consider them as a part of the parent execution context.\n * Example:\n *\n *   const x = 1;\n *\n *   x; // returns `false`\n *   () => x; // returns `true`\n *\n *   class C {\n *       field = x; // returns `true`\n *       static field = x; // returns `false`\n *\n *       method() {\n *           x; // returns `true`\n *       }\n *\n *       static method() {\n *           x; // returns `true`\n *       }\n *\n *       static {\n *           x; // returns `false`\n *       }\n *   }\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is from a separate execution context.\n */\n\n\nfunction isFromSeparateExecutionContext(reference) {\n  const variable = reference.resolved;\n  let scope = reference.from; // Scope#variableScope represents execution context\n\n  while (variable.scope.variableScope !== scope.variableScope) {\n    if (isClassStaticInitializerScope(scope.variableScope)) {\n      scope = scope.variableScope.upper;\n    } else {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Checks whether or not a given reference is evaluated during the initialization of its variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n *     var C = class { [C]; };\n *     var C = class { static foo = C; };\n *     var C = class { static { foo = C; } };\n *     class C extends C {}\n *     class C extends (class { static foo = C; }) {}\n *     class C { [C]; }\n * @param {Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is evaluated during the initialization.\n */\n\n\nfunction isEvaluatedDuringInitialization(reference) {\n  if (isFromSeparateExecutionContext(reference)) {\n    /*\n     * Even if the reference appears in the initializer, it isn't evaluated during the initialization.\n     * For example, `const x = () => x;` is valid.\n     */\n    return false;\n  }\n\n  const location = reference.identifier.range[1];\n  const definition = reference.resolved.defs[0];\n\n  if (definition.type === \"ClassName\") {\n    // `ClassDeclaration` or `ClassExpression`\n    const classDefinition = definition.node;\n    return isInRange(classDefinition, location) &&\n    /*\n     * Class binding is initialized before running static initializers.\n     * For example, `class C { static foo = C; static { bar = C; } }` is valid.\n     */\n    !isInClassStaticInitializerRange(classDefinition.body, location);\n  }\n\n  let node = definition.name.parent;\n\n  while (node) {\n    if (node.type === \"VariableDeclarator\") {\n      if (isInRange(node.init, location)) {\n        return true;\n      }\n\n      if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {\n        return true;\n      }\n\n      break;\n    } else if (node.type === \"AssignmentPattern\") {\n      if (isInRange(node.right, location)) {\n        return true;\n      }\n    } else if (SENTINEL_TYPE.test(node.type)) {\n      break;\n    }\n\n    node = node.parent;\n  }\n\n  return false;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow the use of variables before they are defined\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-use-before-define\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"nofunc\"]\n      }, {\n        type: \"object\",\n        properties: {\n          functions: {\n            type: \"boolean\"\n          },\n          classes: {\n            type: \"boolean\"\n          },\n          variables: {\n            type: \"boolean\"\n          },\n          allowNamedExports: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      usedBeforeDefined: \"'{{name}}' was used before it was defined.\"\n    }\n  },\n\n  create(context) {\n    const options = parseOptions(context.options[0]);\n    /**\n     * Determines whether a given reference should be checked.\n     *\n     * Returns `false` if the reference is:\n     * - initialization's (e.g., `let a = 1`).\n     * - referring to an undefined variable (i.e., if it's an unresolved reference).\n     * - referring to a variable that is defined, but not in the given source code\n     *   (e.g., global environment variable or `arguments` in functions).\n     * - allowed by options.\n     * @param {eslint-scope.Reference} reference The reference\n     * @returns {boolean} `true` if the reference should be checked\n     */\n\n    function shouldCheck(reference) {\n      if (reference.init) {\n        return false;\n      }\n\n      const {\n        identifier\n      } = reference;\n\n      if (options.allowNamedExports && identifier.parent.type === \"ExportSpecifier\" && identifier.parent.local === identifier) {\n        return false;\n      }\n\n      const variable = reference.resolved;\n\n      if (!variable || variable.defs.length === 0) {\n        return false;\n      }\n\n      const definitionType = variable.defs[0].type;\n\n      if (!options.functions && definitionType === \"FunctionName\") {\n        return false;\n      }\n\n      if ((!options.variables && definitionType === \"Variable\" || !options.classes && definitionType === \"ClassName\") && // don't skip checking the reference if it's in the same execution context, because of TDZ\n      isFromSeparateExecutionContext(reference)) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Finds and validates all references in a given scope and its child scopes.\n     * @param {eslint-scope.Scope} scope The scope object.\n     * @returns {void}\n     */\n\n\n    function checkReferencesInScope(scope) {\n      scope.references.filter(shouldCheck).forEach(reference => {\n        const variable = reference.resolved;\n        const definitionIdentifier = variable.defs[0].name;\n\n        if (reference.identifier.range[1] < definitionIdentifier.range[1] || isEvaluatedDuringInitialization(reference)) {\n          context.report({\n            node: reference.identifier,\n            messageId: \"usedBeforeDefined\",\n            data: reference.identifier\n          });\n        }\n      });\n      scope.childScopes.forEach(checkReferencesInScope);\n    }\n\n    return {\n      Program() {\n        checkReferencesInScope(context.getScope());\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["SENTINEL_TYPE","FOR_IN_OF_TYPE","parseOptions","options","functions","classes","variables","allowNamedExports","isInRange","node","location","range","isInClassStaticInitializerRange","body","some","classMember","type","static","value","isClassStaticInitializerScope","scope","propertyDefinition","block","parent","isFromSeparateExecutionContext","reference","variable","resolved","from","variableScope","upper","isEvaluatedDuringInitialization","identifier","definition","defs","classDefinition","name","init","test","right","module","exports","meta","docs","description","recommended","url","schema","oneOf","enum","properties","additionalProperties","messages","usedBeforeDefined","create","context","shouldCheck","local","length","definitionType","checkReferencesInScope","references","filter","forEach","definitionIdentifier","report","messageId","data","childScopes","Program","getScope"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/no-use-before-define.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n\n/**\n * Parses a given value as options.\n * @param {any} options A value to parse.\n * @returns {Object} The parsed options.\n */\nfunction parseOptions(options) {\n    let functions = true;\n    let classes = true;\n    let variables = true;\n    let allowNamedExports = false;\n\n    if (typeof options === \"string\") {\n        functions = (options !== \"nofunc\");\n    } else if (typeof options === \"object\" && options !== null) {\n        functions = options.functions !== false;\n        classes = options.classes !== false;\n        variables = options.variables !== false;\n        allowNamedExports = !!options.allowNamedExports;\n    }\n\n    return { functions, classes, variables, allowNamedExports };\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n * @param {ASTNode} node An node to check.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\nfunction isInRange(node, location) {\n    return node && node.range[0] <= location && location <= node.range[1];\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a class static initializer.\n * Static initializers are static blocks and initializers of static fields.\n * @param {ASTNode} node `ClassBody` node to check static initializers.\n * @param {number} location A location to check.\n * @returns {boolean} `true` if the location is inside of a class static initializer.\n */\nfunction isInClassStaticInitializerRange(node, location) {\n    return node.body.some(classMember => (\n        (\n            classMember.type === \"StaticBlock\" &&\n            isInRange(classMember, location)\n        ) ||\n        (\n            classMember.type === \"PropertyDefinition\" &&\n            classMember.static &&\n            classMember.value &&\n            isInRange(classMember.value, location)\n        )\n    ));\n}\n\n/**\n * Checks whether a given scope is the scope of a a class static initializer.\n * Static initializers are static blocks and initializers of static fields.\n * @param {eslint-scope.Scope} scope A scope to check.\n * @returns {boolean} `true` if the scope is a class static initializer scope.\n */\nfunction isClassStaticInitializerScope(scope) {\n    if (scope.type === \"class-static-block\") {\n        return true;\n    }\n\n    if (scope.type === \"class-field-initializer\") {\n\n        // `scope.block` is PropertyDefinition#value node\n        const propertyDefinition = scope.block.parent;\n\n        return propertyDefinition.static;\n    }\n\n    return false;\n}\n\n/**\n * Checks whether a given reference is evaluated in an execution context\n * that isn't the one where the variable it refers to is defined.\n * Execution contexts are:\n * - top-level\n * - functions\n * - class field initializers (implicit functions)\n * - class static blocks (implicit functions)\n * Static class field initializers and class static blocks are automatically run during the class definition evaluation,\n * and therefore we'll consider them as a part of the parent execution context.\n * Example:\n *\n *   const x = 1;\n *\n *   x; // returns `false`\n *   () => x; // returns `true`\n *\n *   class C {\n *       field = x; // returns `true`\n *       static field = x; // returns `false`\n *\n *       method() {\n *           x; // returns `true`\n *       }\n *\n *       static method() {\n *           x; // returns `true`\n *       }\n *\n *       static {\n *           x; // returns `false`\n *       }\n *   }\n * @param {eslint-scope.Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is from a separate execution context.\n */\nfunction isFromSeparateExecutionContext(reference) {\n    const variable = reference.resolved;\n    let scope = reference.from;\n\n    // Scope#variableScope represents execution context\n    while (variable.scope.variableScope !== scope.variableScope) {\n        if (isClassStaticInitializerScope(scope.variableScope)) {\n            scope = scope.variableScope.upper;\n        } else {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a given reference is evaluated during the initialization of its variable.\n *\n * This returns `true` in the following cases:\n *\n *     var a = a\n *     var [a = a] = list\n *     var {a = a} = obj\n *     for (var a in a) {}\n *     for (var a of a) {}\n *     var C = class { [C]; };\n *     var C = class { static foo = C; };\n *     var C = class { static { foo = C; } };\n *     class C extends C {}\n *     class C extends (class { static foo = C; }) {}\n *     class C { [C]; }\n * @param {Reference} reference A reference to check.\n * @returns {boolean} `true` if the reference is evaluated during the initialization.\n */\nfunction isEvaluatedDuringInitialization(reference) {\n    if (isFromSeparateExecutionContext(reference)) {\n\n        /*\n         * Even if the reference appears in the initializer, it isn't evaluated during the initialization.\n         * For example, `const x = () => x;` is valid.\n         */\n        return false;\n    }\n\n    const location = reference.identifier.range[1];\n    const definition = reference.resolved.defs[0];\n\n    if (definition.type === \"ClassName\") {\n\n        // `ClassDeclaration` or `ClassExpression`\n        const classDefinition = definition.node;\n\n        return (\n            isInRange(classDefinition, location) &&\n\n            /*\n             * Class binding is initialized before running static initializers.\n             * For example, `class C { static foo = C; static { bar = C; } }` is valid.\n             */\n            !isInClassStaticInitializerRange(classDefinition.body, location)\n        );\n    }\n\n    let node = definition.name.parent;\n\n    while (node) {\n        if (node.type === \"VariableDeclarator\") {\n            if (isInRange(node.init, location)) {\n                return true;\n            }\n            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\n                isInRange(node.parent.parent.right, location)\n            ) {\n                return true;\n            }\n            break;\n        } else if (node.type === \"AssignmentPattern\") {\n            if (isInRange(node.right, location)) {\n                return true;\n            }\n        } else if (SENTINEL_TYPE.test(node.type)) {\n            break;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow the use of variables before they are defined\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/no-use-before-define\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"nofunc\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            functions: { type: \"boolean\" },\n                            classes: { type: \"boolean\" },\n                            variables: { type: \"boolean\" },\n                            allowNamedExports: { type: \"boolean\" }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            usedBeforeDefined: \"'{{name}}' was used before it was defined.\"\n        }\n    },\n\n    create(context) {\n        const options = parseOptions(context.options[0]);\n\n        /**\n         * Determines whether a given reference should be checked.\n         *\n         * Returns `false` if the reference is:\n         * - initialization's (e.g., `let a = 1`).\n         * - referring to an undefined variable (i.e., if it's an unresolved reference).\n         * - referring to a variable that is defined, but not in the given source code\n         *   (e.g., global environment variable or `arguments` in functions).\n         * - allowed by options.\n         * @param {eslint-scope.Reference} reference The reference\n         * @returns {boolean} `true` if the reference should be checked\n         */\n        function shouldCheck(reference) {\n            if (reference.init) {\n                return false;\n            }\n\n            const { identifier } = reference;\n\n            if (\n                options.allowNamedExports &&\n                identifier.parent.type === \"ExportSpecifier\" &&\n                identifier.parent.local === identifier\n            ) {\n                return false;\n            }\n\n            const variable = reference.resolved;\n\n            if (!variable || variable.defs.length === 0) {\n                return false;\n            }\n\n            const definitionType = variable.defs[0].type;\n\n            if (!options.functions && definitionType === \"FunctionName\") {\n                return false;\n            }\n\n            if (\n                (\n                    !options.variables && definitionType === \"Variable\" ||\n                    !options.classes && definitionType === \"ClassName\"\n                ) &&\n\n                // don't skip checking the reference if it's in the same execution context, because of TDZ\n                isFromSeparateExecutionContext(reference)\n            ) {\n                return false;\n            }\n\n            return true;\n        }\n\n        /**\n         * Finds and validates all references in a given scope and its child scopes.\n         * @param {eslint-scope.Scope} scope The scope object.\n         * @returns {void}\n         */\n        function checkReferencesInScope(scope) {\n            scope.references.filter(shouldCheck).forEach(reference => {\n                const variable = reference.resolved;\n                const definitionIdentifier = variable.defs[0].name;\n\n                if (\n                    reference.identifier.range[1] < definitionIdentifier.range[1] ||\n                    isEvaluatedDuringInitialization(reference)\n                ) {\n                    context.report({\n                        node: reference.identifier,\n                        messageId: \"usedBeforeDefined\",\n                        data: reference.identifier\n                    });\n                }\n            });\n\n            scope.childScopes.forEach(checkReferencesInScope);\n        }\n\n        return {\n            Program() {\n                checkReferencesInScope(context.getScope());\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}