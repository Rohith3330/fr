{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = convertFunctionParams;\n\nvar _core = require(\"@babel/core\");\n\nvar _shadowUtils = require(\"./shadow-utils\");\n\nconst buildDefaultParam = _core.template.statement(`\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n`);\n\nconst buildLooseDefaultParam = _core.template.statement(`\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n`);\n\nconst buildLooseDestructuredDefaultParam = _core.template.statement(`\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n`);\n\nconst buildSafeArgumentsAccess = _core.template.statement(`\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n`);\n\nfunction convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement) {\n  const params = path.get(\"params\");\n  const isSimpleParameterList = params.every(param => param.isIdentifier());\n  if (isSimpleParameterList) return false;\n  const {\n    node,\n    scope\n  } = path;\n  const body = [];\n  const shadowedParams = new Set();\n\n  for (const param of params) {\n    (0, _shadowUtils.collectShadowedParamsNames)(param, scope, shadowedParams);\n  }\n\n  const state = {\n    needsOuterBinding: false,\n    scope\n  };\n\n  if (shadowedParams.size === 0) {\n    for (const param of params) {\n      if (!param.isIdentifier()) param.traverse(_shadowUtils.iifeVisitor, state);\n      if (state.needsOuterBinding) break;\n    }\n  }\n\n  let firstOptionalIndex = null;\n\n  for (let i = 0; i < params.length; i++) {\n    const param = params[i];\n\n    if (shouldTransformParam && !shouldTransformParam(i)) {\n      continue;\n    }\n\n    const transformedRestNodes = [];\n\n    if (replaceRestElement) {\n      replaceRestElement(path, param, transformedRestNodes);\n    }\n\n    const paramIsAssignmentPattern = param.isAssignmentPattern();\n\n    if (paramIsAssignmentPattern && (ignoreFunctionLength || _core.types.isMethod(node, {\n      kind: \"set\"\n    }))) {\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n      const undefinedNode = scope.buildUndefinedNode();\n\n      if (left.isIdentifier()) {\n        body.push(buildLooseDefaultParam({\n          ASSIGNMENT_IDENTIFIER: _core.types.cloneNode(left.node),\n          DEFAULT_VALUE: right.node,\n          UNDEFINED: undefinedNode\n        }));\n        param.replaceWith(left.node);\n      } else if (left.isObjectPattern() || left.isArrayPattern()) {\n        const paramName = scope.generateUidIdentifier();\n        body.push(buildLooseDestructuredDefaultParam({\n          ASSIGNMENT_IDENTIFIER: left.node,\n          DEFAULT_VALUE: right.node,\n          PARAMETER_NAME: _core.types.cloneNode(paramName),\n          UNDEFINED: undefinedNode\n        }));\n        param.replaceWith(paramName);\n      }\n    } else if (paramIsAssignmentPattern) {\n      if (firstOptionalIndex === null) firstOptionalIndex = i;\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n      const defNode = buildDefaultParam({\n        VARIABLE_NAME: left.node,\n        DEFAULT_VALUE: right.node,\n        ARGUMENT_KEY: _core.types.numericLiteral(i)\n      });\n      body.push(defNode);\n    } else if (firstOptionalIndex !== null) {\n      const defNode = buildSafeArgumentsAccess([param.node, _core.types.numericLiteral(i)]);\n      body.push(defNode);\n    } else if (param.isObjectPattern() || param.isArrayPattern()) {\n      const uid = path.scope.generateUidIdentifier(\"ref\");\n      uid.typeAnnotation = param.node.typeAnnotation;\n\n      const defNode = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(param.node, uid)]);\n\n      body.push(defNode);\n      param.replaceWith(_core.types.cloneNode(uid));\n    }\n\n    if (transformedRestNodes) {\n      for (const transformedNode of transformedRestNodes) {\n        body.push(transformedNode);\n      }\n    }\n  }\n\n  if (firstOptionalIndex !== null) {\n    node.params = node.params.slice(0, firstOptionalIndex);\n  }\n\n  path.ensureBlock();\n\n  if (state.needsOuterBinding || shadowedParams.size > 0) {\n    body.push((0, _shadowUtils.buildScopeIIFE)(shadowedParams, path.node.body));\n    path.set(\"body\", _core.types.blockStatement(body));\n    const bodyPath = path.get(\"body.body\");\n    const arrowPath = bodyPath[bodyPath.length - 1].get(\"argument.callee\");\n    arrowPath.arrowFunctionToExpression();\n    arrowPath.node.generator = path.node.generator;\n    arrowPath.node.async = path.node.async;\n    path.node.generator = false;\n  } else {\n    path.get(\"body\").unshiftContainer(\"body\", body);\n  }\n\n  return true;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","convertFunctionParams","_core","require","_shadowUtils","buildDefaultParam","template","statement","buildLooseDefaultParam","buildLooseDestructuredDefaultParam","buildSafeArgumentsAccess","path","ignoreFunctionLength","shouldTransformParam","replaceRestElement","params","get","isSimpleParameterList","every","param","isIdentifier","node","scope","body","shadowedParams","Set","collectShadowedParamsNames","state","needsOuterBinding","size","traverse","iifeVisitor","firstOptionalIndex","i","length","transformedRestNodes","paramIsAssignmentPattern","isAssignmentPattern","types","isMethod","kind","left","right","undefinedNode","buildUndefinedNode","push","ASSIGNMENT_IDENTIFIER","cloneNode","DEFAULT_VALUE","UNDEFINED","replaceWith","isObjectPattern","isArrayPattern","paramName","generateUidIdentifier","PARAMETER_NAME","defNode","VARIABLE_NAME","ARGUMENT_KEY","numericLiteral","uid","typeAnnotation","variableDeclaration","variableDeclarator","transformedNode","slice","ensureBlock","buildScopeIIFE","set","blockStatement","bodyPath","arrowPath","arrowFunctionToExpression","generator","async","unshiftContainer"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/plugin-transform-parameters/lib/params.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = convertFunctionParams;\n\nvar _core = require(\"@babel/core\");\n\nvar _shadowUtils = require(\"./shadow-utils\");\n\nconst buildDefaultParam = _core.template.statement(`\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n`);\n\nconst buildLooseDefaultParam = _core.template.statement(`\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n`);\n\nconst buildLooseDestructuredDefaultParam = _core.template.statement(`\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n`);\n\nconst buildSafeArgumentsAccess = _core.template.statement(`\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n`);\n\nfunction convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement) {\n  const params = path.get(\"params\");\n  const isSimpleParameterList = params.every(param => param.isIdentifier());\n  if (isSimpleParameterList) return false;\n  const {\n    node,\n    scope\n  } = path;\n  const body = [];\n  const shadowedParams = new Set();\n\n  for (const param of params) {\n    (0, _shadowUtils.collectShadowedParamsNames)(param, scope, shadowedParams);\n  }\n\n  const state = {\n    needsOuterBinding: false,\n    scope\n  };\n\n  if (shadowedParams.size === 0) {\n    for (const param of params) {\n      if (!param.isIdentifier()) param.traverse(_shadowUtils.iifeVisitor, state);\n      if (state.needsOuterBinding) break;\n    }\n  }\n\n  let firstOptionalIndex = null;\n\n  for (let i = 0; i < params.length; i++) {\n    const param = params[i];\n\n    if (shouldTransformParam && !shouldTransformParam(i)) {\n      continue;\n    }\n\n    const transformedRestNodes = [];\n\n    if (replaceRestElement) {\n      replaceRestElement(path, param, transformedRestNodes);\n    }\n\n    const paramIsAssignmentPattern = param.isAssignmentPattern();\n\n    if (paramIsAssignmentPattern && (ignoreFunctionLength || _core.types.isMethod(node, {\n      kind: \"set\"\n    }))) {\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n      const undefinedNode = scope.buildUndefinedNode();\n\n      if (left.isIdentifier()) {\n        body.push(buildLooseDefaultParam({\n          ASSIGNMENT_IDENTIFIER: _core.types.cloneNode(left.node),\n          DEFAULT_VALUE: right.node,\n          UNDEFINED: undefinedNode\n        }));\n        param.replaceWith(left.node);\n      } else if (left.isObjectPattern() || left.isArrayPattern()) {\n        const paramName = scope.generateUidIdentifier();\n        body.push(buildLooseDestructuredDefaultParam({\n          ASSIGNMENT_IDENTIFIER: left.node,\n          DEFAULT_VALUE: right.node,\n          PARAMETER_NAME: _core.types.cloneNode(paramName),\n          UNDEFINED: undefinedNode\n        }));\n        param.replaceWith(paramName);\n      }\n    } else if (paramIsAssignmentPattern) {\n      if (firstOptionalIndex === null) firstOptionalIndex = i;\n      const left = param.get(\"left\");\n      const right = param.get(\"right\");\n      const defNode = buildDefaultParam({\n        VARIABLE_NAME: left.node,\n        DEFAULT_VALUE: right.node,\n        ARGUMENT_KEY: _core.types.numericLiteral(i)\n      });\n      body.push(defNode);\n    } else if (firstOptionalIndex !== null) {\n      const defNode = buildSafeArgumentsAccess([param.node, _core.types.numericLiteral(i)]);\n      body.push(defNode);\n    } else if (param.isObjectPattern() || param.isArrayPattern()) {\n      const uid = path.scope.generateUidIdentifier(\"ref\");\n      uid.typeAnnotation = param.node.typeAnnotation;\n\n      const defNode = _core.types.variableDeclaration(\"let\", [_core.types.variableDeclarator(param.node, uid)]);\n\n      body.push(defNode);\n      param.replaceWith(_core.types.cloneNode(uid));\n    }\n\n    if (transformedRestNodes) {\n      for (const transformedNode of transformedRestNodes) {\n        body.push(transformedNode);\n      }\n    }\n  }\n\n  if (firstOptionalIndex !== null) {\n    node.params = node.params.slice(0, firstOptionalIndex);\n  }\n\n  path.ensureBlock();\n\n  if (state.needsOuterBinding || shadowedParams.size > 0) {\n    body.push((0, _shadowUtils.buildScopeIIFE)(shadowedParams, path.node.body));\n    path.set(\"body\", _core.types.blockStatement(body));\n    const bodyPath = path.get(\"body.body\");\n    const arrowPath = bodyPath[bodyPath.length - 1].get(\"argument.callee\");\n    arrowPath.arrowFunctionToExpression();\n    arrowPath.node.generator = path.node.generator;\n    arrowPath.node.async = path.node.async;\n    path.node.generator = false;\n  } else {\n    path.get(\"body\").unshiftContainer(\"body\", body);\n  }\n\n  return true;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}