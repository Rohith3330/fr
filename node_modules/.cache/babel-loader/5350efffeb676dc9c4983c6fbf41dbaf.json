{"ast":null,"code":"/*\n * Utilities: A classic collection of JavaScript utilities\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nlet fs = require('fs');\n\nlet path = require('path');\n/**\n  @name file\n  @namespace file\n*/\n\n\nlet fileUtils = new function () {\n  // Recursively copy files and directories\n  let _copyFile = function (fromPath, toPath, opts) {\n    let from = path.normalize(fromPath);\n    let to = path.normalize(toPath);\n    let options = opts || {};\n    let fromStat;\n    let toStat;\n    let destExists;\n    let destDoesNotExistErr;\n    let content;\n    let filename;\n    let dirContents;\n    let targetDir;\n    fromStat = fs.statSync(from);\n\n    try {\n      //console.dir(to + ' destExists');\n      toStat = fs.statSync(to);\n      destExists = true;\n    } catch (e) {\n      //console.dir(to + ' does not exist');\n      destDoesNotExistErr = e;\n      destExists = false;\n    } // Destination dir or file exists, copy into (directory)\n    // or overwrite (file)\n\n\n    if (destExists) {\n      // If there's a rename-via-copy file/dir name passed, use it.\n      // Otherwise use the actual file/dir name\n      filename = options.rename || path.basename(from); // Copying a directory\n\n      if (fromStat.isDirectory()) {\n        dirContents = fs.readdirSync(from);\n        targetDir = path.join(to, filename); // We don't care if the target dir already exists\n\n        try {\n          fs.mkdirSync(targetDir, {\n            mode: fromStat.mode & 0o777\n          });\n        } catch (e) {\n          if (e.code !== 'EEXIST') {\n            throw e;\n          }\n        }\n\n        for (let i = 0, ii = dirContents.length; i < ii; i++) {\n          _copyFile(path.join(from, dirContents[i]), targetDir, {\n            preserveMode: options.preserveMode\n          });\n        }\n      } // Copying a file\n      else {\n        content = fs.readFileSync(from);\n        let mode = fromStat.mode & 0o777;\n        let targetFile = to;\n\n        if (toStat.isDirectory()) {\n          targetFile = path.join(to, filename);\n        }\n\n        let fileExists = fs.existsSync(targetFile);\n        fs.writeFileSync(targetFile, content); // If the file didn't already exist, use the original file mode.\n        // Otherwise, only update the mode if preserverMode is true.\n\n        if (!fileExists || options.preserveMode) {\n          fs.chmodSync(targetFile, mode);\n        }\n      }\n    } // Dest doesn't exist, can't create it\n    else {\n      throw destDoesNotExistErr;\n    }\n  }; // Remove the given directory\n\n\n  let _rmDir = function (dirPath) {\n    let dir = path.normalize(dirPath);\n    let paths = [];\n    paths = fs.readdirSync(dir);\n    paths.forEach(function (p) {\n      let curr = path.join(dir, p);\n      let stat = fs.lstatSync(curr);\n\n      if (stat.isDirectory()) {\n        _rmDir(curr);\n      } else {\n        try {\n          fs.unlinkSync(curr);\n        } catch (e) {\n          if (e.code === 'EPERM') {\n            fs.chmodSync(curr, parseInt(666, 8));\n            fs.unlinkSync(curr);\n          } else {\n            throw e;\n          }\n        }\n      }\n    });\n    fs.rmdirSync(dir);\n  };\n  /**\n    @name file#cpR\n    @public\n    @function\n    @description Copies a directory/file to a destination\n    @param {String} fromPath The source path to copy from\n    @param {String} toPath The destination path to copy to\n    @param {Object} opts Options to use\n      @param {Boolean} [opts.preserveMode] If target file already exists, this\n        determines whether the original file's mode is copied over. The default of\n        false mimics the behavior of the `cp` command line tool. (Default: false)\n  */\n\n\n  this.cpR = function (fromPath, toPath, options) {\n    let from = path.normalize(fromPath);\n    let to = path.normalize(toPath);\n    let toStat;\n    let doesNotExistErr;\n    let filename;\n    let opts = options || {};\n\n    if (from == to) {\n      throw new Error('Cannot copy ' + from + ' to itself.');\n    } // Handle rename-via-copy\n\n\n    try {\n      toStat = fs.statSync(to);\n    } catch (e) {\n      doesNotExistErr = e; // Get abs path so it's possible to check parent dir\n\n      if (!this.isAbsolute(to)) {\n        to = path.join(process.cwd(), to);\n      } // Save the file/dir name\n\n\n      filename = path.basename(to); // See if a parent dir exists, so there's a place to put the\n      /// renamed file/dir (resets the destination for the copy)\n\n      to = path.dirname(to);\n\n      try {\n        toStat = fs.statSync(to);\n      } catch (e) {}\n\n      if (toStat && toStat.isDirectory()) {\n        // Set the rename opt to pass to the copy func, will be used\n        // as the new file/dir name\n        opts.rename = filename; //console.log('filename ' + filename);\n      } else {\n        throw doesNotExistErr;\n      }\n    }\n\n    _copyFile(from, to, opts);\n  };\n  /**\n    @name file#mkdirP\n    @public\n    @function\n    @description Create the given directory(ies) using the given mode permissions\n    @param {String} dir The directory to create\n    @param {Number} mode The mode to give the created directory(ies)(Default: 0755)\n  */\n\n\n  this.mkdirP = function (dir, mode) {\n    let dirPath = path.normalize(dir);\n    let paths = dirPath.split(/\\/|\\\\/);\n    let currPath = '';\n    let next;\n\n    if (paths[0] == '' || /^[A-Za-z]+:/.test(paths[0])) {\n      currPath = paths.shift() || '/';\n      currPath = path.join(currPath, paths.shift()); //console.log('basedir');\n    }\n\n    while (next = paths.shift()) {\n      if (next == '..') {\n        currPath = path.join(currPath, next);\n        continue;\n      }\n\n      currPath = path.join(currPath, next);\n\n      try {\n        //console.log('making ' + currPath);\n        fs.mkdirSync(currPath, mode || parseInt(755, 8));\n      } catch (e) {\n        if (e.code != 'EEXIST') {\n          throw e;\n        }\n      }\n    }\n  };\n  /**\n    @name file#rmRf\n    @public\n    @function\n    @description Deletes the given directory/file\n    @param {String} p The path to delete, can be a directory or file\n  */\n\n\n  this.rmRf = function (p, options) {\n    let stat;\n\n    try {\n      stat = fs.lstatSync(p);\n\n      if (stat.isDirectory()) {\n        _rmDir(p);\n      } else {\n        fs.unlinkSync(p);\n      }\n    } catch (e) {}\n  };\n  /**\n    @name file#isAbsolute\n    @public\n    @function\n    @return {Boolean/String} If it's absolute the first character is returned otherwise false\n    @description Checks if a given path is absolute or relative\n    @param {String} p Path to check\n  */\n\n\n  this.isAbsolute = function (p) {\n    let match = /^[A-Za-z]+:\\\\|^\\//.exec(p);\n\n    if (match && match.length) {\n      return match[0];\n    }\n\n    return false;\n  };\n  /**\n    @name file#absolutize\n    @public\n    @function\n    @return {String} Returns the absolute path for the given path\n    @description Returns the absolute path for the given path\n    @param {String} p The path to get the absolute path for\n  */\n\n\n  this.absolutize = function (p) {\n    if (this.isAbsolute(p)) {\n      return p;\n    } else {\n      return path.join(process.cwd(), p);\n    }\n  };\n}();\nmodule.exports = fileUtils;","map":{"version":3,"names":["fs","require","path","fileUtils","_copyFile","fromPath","toPath","opts","from","normalize","to","options","fromStat","toStat","destExists","destDoesNotExistErr","content","filename","dirContents","targetDir","statSync","e","rename","basename","isDirectory","readdirSync","join","mkdirSync","mode","code","i","ii","length","preserveMode","readFileSync","targetFile","fileExists","existsSync","writeFileSync","chmodSync","_rmDir","dirPath","dir","paths","forEach","p","curr","stat","lstatSync","unlinkSync","parseInt","rmdirSync","cpR","doesNotExistErr","Error","isAbsolute","process","cwd","dirname","mkdirP","split","currPath","next","test","shift","rmRf","match","exec","absolutize","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jake/lib/utils/file.js"],"sourcesContent":["/*\n * Utilities: A classic collection of JavaScript utilities\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nlet fs = require('fs');\nlet path = require('path');\n\n/**\n  @name file\n  @namespace file\n*/\n\nlet fileUtils = new (function () {\n\n  // Recursively copy files and directories\n  let _copyFile = function (fromPath, toPath, opts) {\n    let from = path.normalize(fromPath)\n    let to = path.normalize(toPath)\n    let options = opts || {}\n    let fromStat;\n    let toStat;\n    let destExists;\n    let destDoesNotExistErr;\n    let content;\n    let filename;\n    let dirContents;\n    let targetDir;\n\n    fromStat = fs.statSync(from);\n\n    try {\n      //console.dir(to + ' destExists');\n      toStat = fs.statSync(to);\n      destExists = true;\n    }\n    catch(e) {\n      //console.dir(to + ' does not exist');\n      destDoesNotExistErr = e;\n      destExists = false;\n    }\n    // Destination dir or file exists, copy into (directory)\n    // or overwrite (file)\n    if (destExists) {\n\n      // If there's a rename-via-copy file/dir name passed, use it.\n      // Otherwise use the actual file/dir name\n      filename = options.rename || path.basename(from);\n\n      // Copying a directory\n      if (fromStat.isDirectory()) {\n        dirContents = fs.readdirSync(from);\n        targetDir = path.join(to, filename);\n        // We don't care if the target dir already exists\n        try {\n          fs.mkdirSync(targetDir, {mode: fromStat.mode & 0o777});\n        }\n        catch(e) {\n          if (e.code !== 'EEXIST') {\n            throw e;\n          }\n        }\n        for (let i = 0, ii = dirContents.length; i < ii; i++) {\n          _copyFile(path.join(from, dirContents[i]), targetDir, {preserveMode: options.preserveMode});\n        }\n      }\n      // Copying a file\n      else {\n        content = fs.readFileSync(from);\n        let mode = fromStat.mode & 0o777;\n        let targetFile = to;\n\n        if (toStat.isDirectory()) {\n          targetFile = path.join(to, filename);\n        }\n\n        let fileExists = fs.existsSync(targetFile);\n        fs.writeFileSync(targetFile, content);\n\n        // If the file didn't already exist, use the original file mode.\n        // Otherwise, only update the mode if preserverMode is true.\n        if(!fileExists || options.preserveMode) {\n          fs.chmodSync(targetFile, mode);\n        }\n      }\n    }\n    // Dest doesn't exist, can't create it\n    else {\n      throw destDoesNotExistErr;\n    }\n  };\n\n  // Remove the given directory\n  let _rmDir = function (dirPath) {\n    let dir = path.normalize(dirPath);\n    let paths = [];\n    paths = fs.readdirSync(dir);\n    paths.forEach(function (p) {\n      let curr = path.join(dir, p);\n      let stat = fs.lstatSync(curr);\n      if (stat.isDirectory()) {\n        _rmDir(curr);\n      }\n      else {\n        try {\n          fs.unlinkSync(curr);\n        } catch(e) {\n          if (e.code === 'EPERM') {\n            fs.chmodSync(curr, parseInt(666, 8));\n            fs.unlinkSync(curr);\n          } else {\n            throw e;\n          }\n        }\n      }\n    });\n    fs.rmdirSync(dir);\n  };\n\n  /**\n    @name file#cpR\n    @public\n    @function\n    @description Copies a directory/file to a destination\n    @param {String} fromPath The source path to copy from\n    @param {String} toPath The destination path to copy to\n    @param {Object} opts Options to use\n      @param {Boolean} [opts.preserveMode] If target file already exists, this\n        determines whether the original file's mode is copied over. The default of\n        false mimics the behavior of the `cp` command line tool. (Default: false)\n  */\n  this.cpR = function (fromPath, toPath, options) {\n    let from = path.normalize(fromPath);\n    let to = path.normalize(toPath);\n    let toStat;\n    let doesNotExistErr;\n    let filename;\n    let opts = options || {};\n\n    if (from == to) {\n      throw new Error('Cannot copy ' + from + ' to itself.');\n    }\n\n    // Handle rename-via-copy\n    try {\n      toStat = fs.statSync(to);\n    }\n    catch(e) {\n      doesNotExistErr = e;\n\n      // Get abs path so it's possible to check parent dir\n      if (!this.isAbsolute(to)) {\n        to = path.join(process.cwd(), to);\n      }\n\n      // Save the file/dir name\n      filename = path.basename(to);\n      // See if a parent dir exists, so there's a place to put the\n      /// renamed file/dir (resets the destination for the copy)\n      to = path.dirname(to);\n      try {\n        toStat = fs.statSync(to);\n      }\n      catch(e) {}\n      if (toStat && toStat.isDirectory()) {\n        // Set the rename opt to pass to the copy func, will be used\n        // as the new file/dir name\n        opts.rename = filename;\n        //console.log('filename ' + filename);\n      }\n      else {\n        throw doesNotExistErr;\n      }\n    }\n\n    _copyFile(from, to, opts);\n  };\n\n  /**\n    @name file#mkdirP\n    @public\n    @function\n    @description Create the given directory(ies) using the given mode permissions\n    @param {String} dir The directory to create\n    @param {Number} mode The mode to give the created directory(ies)(Default: 0755)\n  */\n  this.mkdirP = function (dir, mode) {\n    let dirPath = path.normalize(dir);\n    let paths = dirPath.split(/\\/|\\\\/);\n    let currPath = '';\n    let next;\n\n    if (paths[0] == '' || /^[A-Za-z]+:/.test(paths[0])) {\n      currPath = paths.shift() || '/';\n      currPath = path.join(currPath, paths.shift());\n      //console.log('basedir');\n    }\n    while ((next = paths.shift())) {\n      if (next == '..') {\n        currPath = path.join(currPath, next);\n        continue;\n      }\n      currPath = path.join(currPath, next);\n      try {\n        //console.log('making ' + currPath);\n        fs.mkdirSync(currPath, mode || parseInt(755, 8));\n      }\n      catch(e) {\n        if (e.code != 'EEXIST') {\n          throw e;\n        }\n      }\n    }\n  };\n\n  /**\n    @name file#rmRf\n    @public\n    @function\n    @description Deletes the given directory/file\n    @param {String} p The path to delete, can be a directory or file\n  */\n  this.rmRf = function (p, options) {\n    let stat;\n    try {\n      stat = fs.lstatSync(p);\n      if (stat.isDirectory()) {\n        _rmDir(p);\n      }\n      else {\n        fs.unlinkSync(p);\n      }\n    }\n    catch (e) {}\n  };\n\n  /**\n    @name file#isAbsolute\n    @public\n    @function\n    @return {Boolean/String} If it's absolute the first character is returned otherwise false\n    @description Checks if a given path is absolute or relative\n    @param {String} p Path to check\n  */\n  this.isAbsolute = function (p) {\n    let match = /^[A-Za-z]+:\\\\|^\\//.exec(p);\n    if (match && match.length) {\n      return match[0];\n    }\n    return false;\n  };\n\n  /**\n    @name file#absolutize\n    @public\n    @function\n    @return {String} Returns the absolute path for the given path\n    @description Returns the absolute path for the given path\n    @param {String} p The path to get the absolute path for\n  */\n  this.absolutize = function (p) {\n    if (this.isAbsolute(p)) {\n      return p;\n    }\n    else {\n      return path.join(process.cwd(), p);\n    }\n  };\n\n})();\n\nmodule.exports = fileUtils;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}