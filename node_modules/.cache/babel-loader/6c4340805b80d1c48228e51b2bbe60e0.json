{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRules = exports.isJSONType = void 0;\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"];\nconst jsonTypes = new Set(_jsonTypes);\n\nfunction isJSONType(x) {\n  return typeof x == \"string\" && jsonTypes.has(x);\n}\n\nexports.isJSONType = isJSONType;\n\nfunction getRules() {\n  const groups = {\n    number: {\n      type: \"number\",\n      rules: []\n    },\n    string: {\n      type: \"string\",\n      rules: []\n    },\n    array: {\n      type: \"array\",\n      rules: []\n    },\n    object: {\n      type: \"object\",\n      rules: []\n    }\n  };\n  return {\n    types: { ...groups,\n      integer: true,\n      boolean: true,\n      null: true\n    },\n    rules: [{\n      rules: []\n    }, groups.number, groups.string, groups.array, groups.object],\n    post: {\n      rules: []\n    },\n    all: {},\n    keywords: {}\n  };\n}\n\nexports.getRules = getRules;","map":{"version":3,"mappings":";;;;;;AAEA,MAAMA,UAAU,GAAG,CAAC,QAAD,EAAW,QAAX,EAAqB,SAArB,EAAgC,SAAhC,EAA2C,MAA3C,EAAmD,QAAnD,EAA6D,OAA7D,CAAnB;AAIA,MAAMC,SAAS,GAAgB,IAAIC,GAAJ,CAAQF,UAAR,CAA/B;;AAEA,SAAgBG,UAAhB,CAA2BC,CAA3B,EAAqC;EACnC,OAAO,OAAOA,CAAP,IAAY,QAAZ,IAAwBH,SAAS,CAACI,GAAV,CAAcD,CAAd,CAA/B;AACD;;AAFDE;;AA2BA,SAAgBC,QAAhB,GAAwB;EACtB,MAAMC,MAAM,GAAgE;IAC1EC,MAAM,EAAE;MAACC,IAAI,EAAE,QAAP;MAAiBC,KAAK,EAAE;IAAxB,CADkE;IAE1EC,MAAM,EAAE;MAACF,IAAI,EAAE,QAAP;MAAiBC,KAAK,EAAE;IAAxB,CAFkE;IAG1EE,KAAK,EAAE;MAACH,IAAI,EAAE,OAAP;MAAgBC,KAAK,EAAE;IAAvB,CAHmE;IAI1EG,MAAM,EAAE;MAACJ,IAAI,EAAE,QAAP;MAAiBC,KAAK,EAAE;IAAxB;EAJkE,CAA5E;EAMA,OAAO;IACLI,KAAK,EAAE,EAAC,GAAGP,MAAJ;MAAYQ,OAAO,EAAE,IAArB;MAA2BC,OAAO,EAAE,IAApC;MAA0CC,IAAI,EAAE;IAAhD,CADF;IAELP,KAAK,EAAE,CAAC;MAACA,KAAK,EAAE;IAAR,CAAD,EAAcH,MAAM,CAACC,MAArB,EAA6BD,MAAM,CAACI,MAApC,EAA4CJ,MAAM,CAACK,KAAnD,EAA0DL,MAAM,CAACM,MAAjE,CAFF;IAGLK,IAAI,EAAE;MAACR,KAAK,EAAE;IAAR,CAHD;IAILS,GAAG,EAAE,EAJA;IAKLC,QAAQ,EAAE;EALL,CAAP;AAOD;;AAdDf","names":["_jsonTypes","jsonTypes","Set","isJSONType","x","has","exports","getRules","groups","number","type","rules","string","array","object","types","integer","boolean","null","post","all","keywords"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\compile\\rules.ts"],"sourcesContent":["import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = typeof _jsonTypes[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n"]},"metadata":{},"sourceType":"script"}