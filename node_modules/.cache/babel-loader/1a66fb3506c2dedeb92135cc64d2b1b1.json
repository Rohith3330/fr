{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = transpileEnum;\nexports.translateEnumValues = translateEnumValues;\n\nvar _core = require(\"@babel/core\");\n\nvar _assert = require(\"assert\");\n\nfunction transpileEnum(path, t) {\n  const {\n    node\n  } = path;\n\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n\n  const name = node.id.name;\n  const fill = enumFill(path, t, node.id);\n\n  switch (path.parent.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\":\n      {\n        path.insertAfter(fill);\n\n        if (seen(path.parentPath)) {\n          path.remove();\n        } else {\n          const isGlobal = t.isProgram(path.parent);\n          path.scope.registerDeclaration(path.replaceWith(makeVar(node.id, t, isGlobal ? \"var\" : \"let\"))[0]);\n        }\n\n        break;\n      }\n\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n\n  function seen(parentPath) {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\n\nfunction makeVar(id, t, kind) {\n  return t.variableDeclaration(kind, [t.variableDeclarator(id)]);\n}\n\nconst buildEnumWrapper = (0, _core.template)(`\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n`);\nconst buildStringAssignment = (0, _core.template)(`\n  ENUM[\"NAME\"] = VALUE;\n`);\nconst buildNumericAssignment = (0, _core.template)(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\n\nconst buildEnumMember = (isString, options) => (isString ? buildStringAssignment : buildNumericAssignment)(options);\n\nfunction enumFill(path, t, id) {\n  const x = translateEnumValues(path, t);\n  const assignments = x.map(_ref => {\n    let [memberName, memberValue] = _ref;\n    return buildEnumMember(t.isStringLiteral(memberValue), {\n      ENUM: t.cloneNode(id),\n      NAME: memberName,\n      VALUE: memberValue\n    });\n  });\n  return buildEnumWrapper({\n    ID: t.cloneNode(id),\n    ASSIGNMENTS: assignments\n  });\n}\n\nfunction ReferencedIdentifier(expr, state) {\n  const {\n    seen,\n    path,\n    t\n  } = state;\n  const name = expr.node.name;\n\n  if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {\n    expr.replaceWith(t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)));\n    expr.skip();\n  }\n}\n\nconst enumSelfReferenceVisitor = {\n  ReferencedIdentifier\n};\n\nfunction translateEnumValues(path, t) {\n  const seen = new Map();\n  let constValue = -1;\n  let lastName;\n  return path.get(\"members\").map(memberPath => {\n    const member = memberPath.node;\n    const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n    const initializer = member.initializer;\n    let value;\n\n    if (initializer) {\n      constValue = evaluate(initializer, seen);\n\n      if (constValue !== undefined) {\n        seen.set(name, constValue);\n\n        if (typeof constValue === \"number\") {\n          value = t.numericLiteral(constValue);\n        } else {\n          _assert(typeof constValue === \"string\");\n\n          value = t.stringLiteral(constValue);\n        }\n      } else {\n        const initializerPath = memberPath.get(\"initializer\");\n\n        if (initializerPath.isReferencedIdentifier()) {\n          ReferencedIdentifier(initializerPath, {\n            t,\n            seen,\n            path\n          });\n        } else {\n          initializerPath.traverse(enumSelfReferenceVisitor, {\n            t,\n            seen,\n            path\n          });\n        }\n\n        value = initializerPath.node;\n        seen.set(name, undefined);\n      }\n    } else if (typeof constValue === \"number\") {\n      constValue += 1;\n      value = t.numericLiteral(constValue);\n      seen.set(name, constValue);\n    } else if (typeof constValue === \"string\") {\n      throw path.buildCodeFrameError(\"Enum member must have initializer.\");\n    } else {\n      const lastRef = t.memberExpression(t.cloneNode(path.node.id), t.stringLiteral(lastName), true);\n      value = t.binaryExpression(\"+\", t.numericLiteral(1), lastRef);\n      seen.set(name, undefined);\n    }\n\n    lastName = name;\n    return [name, value];\n  });\n}\n\nfunction evaluate(expr, seen) {\n  return evalConstant(expr);\n\n  function evalConstant(expr) {\n    switch (expr.type) {\n      case \"StringLiteral\":\n        return expr.value;\n\n      case \"UnaryExpression\":\n        return evalUnaryExpression(expr);\n\n      case \"BinaryExpression\":\n        return evalBinaryExpression(expr);\n\n      case \"NumericLiteral\":\n        return expr.value;\n\n      case \"ParenthesizedExpression\":\n        return evalConstant(expr.expression);\n\n      case \"Identifier\":\n        return seen.get(expr.name);\n\n      case \"TemplateLiteral\":\n        if (expr.quasis.length === 1) {\n          return expr.quasis[0].value.cooked;\n        }\n\n      default:\n        return undefined;\n    }\n  }\n\n  function evalUnaryExpression(_ref2) {\n    let {\n      argument,\n      operator\n    } = _ref2;\n    const value = evalConstant(argument);\n\n    if (value === undefined) {\n      return undefined;\n    }\n\n    switch (operator) {\n      case \"+\":\n        return value;\n\n      case \"-\":\n        return -value;\n\n      case \"~\":\n        return ~value;\n\n      default:\n        return undefined;\n    }\n  }\n\n  function evalBinaryExpression(expr) {\n    const left = evalConstant(expr.left);\n\n    if (left === undefined) {\n      return undefined;\n    }\n\n    const right = evalConstant(expr.right);\n\n    if (right === undefined) {\n      return undefined;\n    }\n\n    switch (expr.operator) {\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n\n      case \"<<\":\n        return left << right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"*\":\n        return left * right;\n\n      case \"/\":\n        return left / right;\n\n      case \"+\":\n        return left + right;\n\n      case \"-\":\n        return left - right;\n\n      case \"%\":\n        return left % right;\n\n      default:\n        return undefined;\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["transpileEnum","path","t","node","declare","remove","name","id","fill","enumFill","parent","type","insertAfter","seen","parentPath","isGlobal","isProgram","scope","registerDeclaration","replaceWith","makeVar","Error","isExportDeclaration","getData","setData","kind","variableDeclaration","variableDeclarator","buildEnumWrapper","buildStringAssignment","buildNumericAssignment","buildEnumMember","isString","options","x","translateEnumValues","assignments","map","memberName","memberValue","isStringLiteral","ENUM","cloneNode","NAME","VALUE","ID","ASSIGNMENTS","ReferencedIdentifier","expr","state","has","hasOwnBinding","memberExpression","skip","enumSelfReferenceVisitor","Map","constValue","lastName","get","memberPath","member","isIdentifier","value","initializer","evaluate","undefined","set","numericLiteral","assert","stringLiteral","initializerPath","isReferencedIdentifier","traverse","buildCodeFrameError","lastRef","binaryExpression","evalConstant","evalUnaryExpression","evalBinaryExpression","expression","quasis","length","cooked","argument","operator","left","right"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-transform-typescript\\src\\enum.ts"],"sourcesContent":["import { template } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport type * as t from \"@babel/types\";\nimport assert from \"assert\";\n\ntype t = typeof t;\n\nexport default function transpileEnum(\n  path: NodePath<t.TSEnumDeclaration>,\n  t: t,\n) {\n  const { node } = path;\n\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n\n  const name = node.id.name;\n  const fill = enumFill(path, t, node.id);\n\n  switch (path.parent.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\": {\n      path.insertAfter(fill);\n      if (seen(path.parentPath)) {\n        path.remove();\n      } else {\n        const isGlobal = t.isProgram(path.parent); // && !path.parent.body.some(t.isModuleDeclaration);\n        path.scope.registerDeclaration(\n          path.replaceWith(makeVar(node.id, t, isGlobal ? \"var\" : \"let\"))[0],\n        );\n      }\n      break;\n    }\n\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n\n  function seen(parentPath: NodePath<t.Node>): boolean {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\n\nfunction makeVar(id: t.Identifier, t: t, kind: \"var\" | \"let\" | \"const\") {\n  return t.variableDeclaration(kind, [t.variableDeclarator(id)]);\n}\n\nconst buildEnumWrapper = template(`\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n`);\n\nconst buildStringAssignment = template(`\n  ENUM[\"NAME\"] = VALUE;\n`);\n\nconst buildNumericAssignment = template(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\n\nconst buildEnumMember = (isString: boolean, options: Record<string, unknown>) =>\n  (isString ? buildStringAssignment : buildNumericAssignment)(options);\n\n/**\n * Generates the statement that fills in the variable declared by the enum.\n * `(function (E) { ... assignments ... })(E || (E = {}));`\n */\nfunction enumFill(path: NodePath<t.TSEnumDeclaration>, t: t, id: t.Identifier) {\n  const x = translateEnumValues(path, t);\n  const assignments = x.map(([memberName, memberValue]) =>\n    buildEnumMember(t.isStringLiteral(memberValue), {\n      ENUM: t.cloneNode(id),\n      NAME: memberName,\n      VALUE: memberValue,\n    }),\n  );\n\n  return buildEnumWrapper({\n    ID: t.cloneNode(id),\n    ASSIGNMENTS: assignments,\n  });\n}\n\n/**\n * Maps the name of an enum member to its value.\n * We keep track of the previous enum members so you can write code like:\n *   enum E {\n *     X = 1 << 0,\n *     Y = 1 << 1,\n *     Z = X | Y,\n *   }\n */\ntype PreviousEnumMembers = Map<string, number | string>;\n\ntype EnumSelfReferenceVisitorState = {\n  seen: PreviousEnumMembers;\n  path: NodePath<t.TSEnumDeclaration>;\n  t: t;\n};\n\nfunction ReferencedIdentifier(\n  expr: NodePath<t.Identifier>,\n  state: EnumSelfReferenceVisitorState,\n) {\n  const { seen, path, t } = state;\n  const name = expr.node.name;\n  if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {\n    expr.replaceWith(\n      t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)),\n    );\n    expr.skip();\n  }\n}\n\nconst enumSelfReferenceVisitor = {\n  ReferencedIdentifier,\n};\n\nexport function translateEnumValues(\n  path: NodePath<t.TSEnumDeclaration>,\n  t: t,\n): Array<[name: string, value: t.Expression]> {\n  const seen: PreviousEnumMembers = new Map();\n  // Start at -1 so the first enum member is its increment, 0.\n  let constValue: number | string | undefined = -1;\n  let lastName: string;\n\n  return path.get(\"members\").map(memberPath => {\n    const member = memberPath.node;\n    const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n    const initializer = member.initializer;\n    let value: t.Expression;\n    if (initializer) {\n      constValue = evaluate(initializer, seen);\n      if (constValue !== undefined) {\n        seen.set(name, constValue);\n        if (typeof constValue === \"number\") {\n          value = t.numericLiteral(constValue);\n        } else {\n          assert(typeof constValue === \"string\");\n          value = t.stringLiteral(constValue);\n        }\n      } else {\n        const initializerPath = memberPath.get(\"initializer\");\n\n        if (initializerPath.isReferencedIdentifier()) {\n          ReferencedIdentifier(initializerPath, {\n            t,\n            seen,\n            path,\n          });\n        } else {\n          initializerPath.traverse(enumSelfReferenceVisitor, { t, seen, path });\n        }\n\n        value = initializerPath.node;\n        seen.set(name, undefined);\n      }\n    } else if (typeof constValue === \"number\") {\n      constValue += 1;\n      value = t.numericLiteral(constValue);\n      seen.set(name, constValue);\n    } else if (typeof constValue === \"string\") {\n      throw path.buildCodeFrameError(\"Enum member must have initializer.\");\n    } else {\n      // create dynamic initializer: 1 + ENUM[\"PREVIOUS\"]\n      const lastRef = t.memberExpression(\n        t.cloneNode(path.node.id),\n        t.stringLiteral(lastName),\n        true,\n      );\n      value = t.binaryExpression(\"+\", t.numericLiteral(1), lastRef);\n      seen.set(name, undefined);\n    }\n\n    lastName = name;\n    return [name, value];\n  });\n}\n\n// Based on the TypeScript repository's `evalConstant` in `checker.ts`.\nfunction evaluate(\n  expr: t.Node,\n  seen: PreviousEnumMembers,\n): number | string | typeof undefined {\n  return evalConstant(expr);\n\n  function evalConstant(expr: t.Node): number | typeof undefined {\n    switch (expr.type) {\n      case \"StringLiteral\":\n        return expr.value;\n      case \"UnaryExpression\":\n        return evalUnaryExpression(expr);\n      case \"BinaryExpression\":\n        return evalBinaryExpression(expr);\n      case \"NumericLiteral\":\n        return expr.value;\n      case \"ParenthesizedExpression\":\n        return evalConstant(expr.expression);\n      case \"Identifier\":\n        return seen.get(expr.name);\n      case \"TemplateLiteral\":\n        if (expr.quasis.length === 1) {\n          return expr.quasis[0].value.cooked;\n        }\n      /* falls through */\n      default:\n        return undefined;\n    }\n  }\n\n  function evalUnaryExpression({\n    argument,\n    operator,\n  }: t.UnaryExpression): number | typeof undefined {\n    const value = evalConstant(argument);\n    if (value === undefined) {\n      return undefined;\n    }\n\n    switch (operator) {\n      case \"+\":\n        return value;\n      case \"-\":\n        return -value;\n      case \"~\":\n        return ~value;\n      default:\n        return undefined;\n    }\n  }\n\n  function evalBinaryExpression(expr: t.BinaryExpression): number | undefined {\n    const left = evalConstant(expr.left);\n    if (left === undefined) {\n      return undefined;\n    }\n    const right = evalConstant(expr.right);\n    if (right === undefined) {\n      return undefined;\n    }\n\n    switch (expr.operator) {\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n      case \"<<\":\n        return left << right;\n      case \"^\":\n        return left ^ right;\n      case \"*\":\n        return left * right;\n      case \"/\":\n        return left / right;\n      case \"+\":\n        return left + right;\n      case \"-\":\n        return left - right;\n      case \"%\":\n        return left % right;\n      default:\n        return undefined;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}