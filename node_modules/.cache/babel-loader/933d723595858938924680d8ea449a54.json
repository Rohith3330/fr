{"ast":null,"code":"\"use strict\";\n\nvar Buffer = require(\"buffer\").Buffer; // Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer\n// == Extend Node primitives to use iconv-lite =================================\n\n\nmodule.exports = function (iconv) {\n  var original = undefined; // Place to keep original methods.\n  // Node authors rewrote Buffer internals to make it compatible with\n  // Uint8Array and we cannot patch key functions since then.\n  // Note: this does use older Buffer API on a purpose\n\n  iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);\n\n  iconv.extendNodeEncodings = function extendNodeEncodings() {\n    if (original) return;\n    original = {};\n\n    if (!iconv.supportsNodeEncodingsExtension) {\n      console.error(\"ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node\");\n      console.error(\"See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility\");\n      return;\n    }\n\n    var nodeNativeEncodings = {\n      'hex': true,\n      'utf8': true,\n      'utf-8': true,\n      'ascii': true,\n      'binary': true,\n      'base64': true,\n      'ucs2': true,\n      'ucs-2': true,\n      'utf16le': true,\n      'utf-16le': true\n    };\n\n    Buffer.isNativeEncoding = function (enc) {\n      return enc && nodeNativeEncodings[enc.toLowerCase()];\n    }; // -- SlowBuffer -----------------------------------------------------------\n\n\n    var SlowBuffer = require('buffer').SlowBuffer;\n\n    original.SlowBufferToString = SlowBuffer.prototype.toString;\n\n    SlowBuffer.prototype.toString = function (encoding, start, end) {\n      encoding = String(encoding || 'utf8').toLowerCase(); // Use native conversion when possible\n\n      if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferToString.call(this, encoding, start, end); // Otherwise, use our decoding method.\n\n      if (typeof start == 'undefined') start = 0;\n      if (typeof end == 'undefined') end = this.length;\n      return iconv.decode(this.slice(start, end), encoding);\n    };\n\n    original.SlowBufferWrite = SlowBuffer.prototype.write;\n\n    SlowBuffer.prototype.write = function (string, offset, length, encoding) {\n      // Support both (string, offset, length, encoding)\n      // and the legacy (string, encoding, offset, length)\n      if (isFinite(offset)) {\n        if (!isFinite(length)) {\n          encoding = length;\n          length = undefined;\n        }\n      } else {\n        // legacy\n        var swap = encoding;\n        encoding = offset;\n        offset = length;\n        length = swap;\n      }\n\n      offset = +offset || 0;\n      var remaining = this.length - offset;\n\n      if (!length) {\n        length = remaining;\n      } else {\n        length = +length;\n\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n\n      encoding = String(encoding || 'utf8').toLowerCase(); // Use native conversion when possible\n\n      if (Buffer.isNativeEncoding(encoding)) return original.SlowBufferWrite.call(this, string, offset, length, encoding);\n      if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds'); // Otherwise, use our encoding method.\n\n      var buf = iconv.encode(string, encoding);\n      if (buf.length < length) length = buf.length;\n      buf.copy(this, offset, 0, length);\n      return length;\n    }; // -- Buffer ---------------------------------------------------------------\n\n\n    original.BufferIsEncoding = Buffer.isEncoding;\n\n    Buffer.isEncoding = function (encoding) {\n      return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);\n    };\n\n    original.BufferByteLength = Buffer.byteLength;\n\n    Buffer.byteLength = SlowBuffer.byteLength = function (str, encoding) {\n      encoding = String(encoding || 'utf8').toLowerCase(); // Use native conversion when possible\n\n      if (Buffer.isNativeEncoding(encoding)) return original.BufferByteLength.call(this, str, encoding); // Slow, I know, but we don't have a better way yet.\n\n      return iconv.encode(str, encoding).length;\n    };\n\n    original.BufferToString = Buffer.prototype.toString;\n\n    Buffer.prototype.toString = function (encoding, start, end) {\n      encoding = String(encoding || 'utf8').toLowerCase(); // Use native conversion when possible\n\n      if (Buffer.isNativeEncoding(encoding)) return original.BufferToString.call(this, encoding, start, end); // Otherwise, use our decoding method.\n\n      if (typeof start == 'undefined') start = 0;\n      if (typeof end == 'undefined') end = this.length;\n      return iconv.decode(this.slice(start, end), encoding);\n    };\n\n    original.BufferWrite = Buffer.prototype.write;\n\n    Buffer.prototype.write = function (string, offset, length, encoding) {\n      var _offset = offset,\n          _length = length,\n          _encoding = encoding; // Support both (string, offset, length, encoding)\n      // and the legacy (string, encoding, offset, length)\n\n      if (isFinite(offset)) {\n        if (!isFinite(length)) {\n          encoding = length;\n          length = undefined;\n        }\n      } else {\n        // legacy\n        var swap = encoding;\n        encoding = offset;\n        offset = length;\n        length = swap;\n      }\n\n      encoding = String(encoding || 'utf8').toLowerCase(); // Use native conversion when possible\n\n      if (Buffer.isNativeEncoding(encoding)) return original.BufferWrite.call(this, string, _offset, _length, _encoding);\n      offset = +offset || 0;\n      var remaining = this.length - offset;\n\n      if (!length) {\n        length = remaining;\n      } else {\n        length = +length;\n\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n\n      if (string.length > 0 && (length < 0 || offset < 0)) throw new RangeError('attempt to write beyond buffer bounds'); // Otherwise, use our encoding method.\n\n      var buf = iconv.encode(string, encoding);\n      if (buf.length < length) length = buf.length;\n      buf.copy(this, offset, 0, length);\n      return length; // TODO: Set _charsWritten.\n    }; // -- Readable -------------------------------------------------------------\n\n\n    if (iconv.supportsStreams) {\n      var Readable = require('stream').Readable;\n\n      original.ReadableSetEncoding = Readable.prototype.setEncoding;\n\n      Readable.prototype.setEncoding = function setEncoding(enc, options) {\n        // Use our own decoder, it has the same interface.\n        // We cannot use original function as it doesn't handle BOM-s.\n        this._readableState.decoder = iconv.getDecoder(enc, options);\n        this._readableState.encoding = enc;\n      };\n\n      Readable.prototype.collect = iconv._collect;\n    }\n  }; // Remove iconv-lite Node primitive extensions.\n\n\n  iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {\n    if (!iconv.supportsNodeEncodingsExtension) return;\n    if (!original) throw new Error(\"require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.\");\n    delete Buffer.isNativeEncoding;\n\n    var SlowBuffer = require('buffer').SlowBuffer;\n\n    SlowBuffer.prototype.toString = original.SlowBufferToString;\n    SlowBuffer.prototype.write = original.SlowBufferWrite;\n    Buffer.isEncoding = original.BufferIsEncoding;\n    Buffer.byteLength = original.BufferByteLength;\n    Buffer.prototype.toString = original.BufferToString;\n    Buffer.prototype.write = original.BufferWrite;\n\n    if (iconv.supportsStreams) {\n      var Readable = require('stream').Readable;\n\n      Readable.prototype.setEncoding = original.ReadableSetEncoding;\n      delete Readable.prototype.collect;\n    }\n\n    original = undefined;\n  };\n};","map":{"version":3,"names":["Buffer","require","module","exports","iconv","original","undefined","supportsNodeEncodingsExtension","from","Uint8Array","extendNodeEncodings","console","error","nodeNativeEncodings","isNativeEncoding","enc","toLowerCase","SlowBuffer","SlowBufferToString","prototype","toString","encoding","start","end","String","call","length","decode","slice","SlowBufferWrite","write","string","offset","isFinite","swap","remaining","RangeError","buf","encode","copy","BufferIsEncoding","isEncoding","encodingExists","BufferByteLength","byteLength","str","BufferToString","BufferWrite","_offset","_length","_encoding","supportsStreams","Readable","ReadableSetEncoding","setEncoding","options","_readableState","decoder","getDecoder","collect","_collect","undoExtendNodeEncodings","Error"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/body-parser/node_modules/iconv-lite/lib/extend-node.js"],"sourcesContent":["\"use strict\";\nvar Buffer = require(\"buffer\").Buffer;\n// Note: not polyfilled with safer-buffer on a purpose, as overrides Buffer\n\n// == Extend Node primitives to use iconv-lite =================================\n\nmodule.exports = function (iconv) {\n    var original = undefined; // Place to keep original methods.\n\n    // Node authors rewrote Buffer internals to make it compatible with\n    // Uint8Array and we cannot patch key functions since then.\n    // Note: this does use older Buffer API on a purpose\n    iconv.supportsNodeEncodingsExtension = !(Buffer.from || new Buffer(0) instanceof Uint8Array);\n\n    iconv.extendNodeEncodings = function extendNodeEncodings() {\n        if (original) return;\n        original = {};\n\n        if (!iconv.supportsNodeEncodingsExtension) {\n            console.error(\"ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node\");\n            console.error(\"See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility\");\n            return;\n        }\n\n        var nodeNativeEncodings = {\n            'hex': true, 'utf8': true, 'utf-8': true, 'ascii': true, 'binary': true, \n            'base64': true, 'ucs2': true, 'ucs-2': true, 'utf16le': true, 'utf-16le': true,\n        };\n\n        Buffer.isNativeEncoding = function(enc) {\n            return enc && nodeNativeEncodings[enc.toLowerCase()];\n        }\n\n        // -- SlowBuffer -----------------------------------------------------------\n        var SlowBuffer = require('buffer').SlowBuffer;\n\n        original.SlowBufferToString = SlowBuffer.prototype.toString;\n        SlowBuffer.prototype.toString = function(encoding, start, end) {\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.SlowBufferToString.call(this, encoding, start, end);\n\n            // Otherwise, use our decoding method.\n            if (typeof start == 'undefined') start = 0;\n            if (typeof end == 'undefined') end = this.length;\n            return iconv.decode(this.slice(start, end), encoding);\n        }\n\n        original.SlowBufferWrite = SlowBuffer.prototype.write;\n        SlowBuffer.prototype.write = function(string, offset, length, encoding) {\n            // Support both (string, offset, length, encoding)\n            // and the legacy (string, encoding, offset, length)\n            if (isFinite(offset)) {\n                if (!isFinite(length)) {\n                    encoding = length;\n                    length = undefined;\n                }\n            } else {  // legacy\n                var swap = encoding;\n                encoding = offset;\n                offset = length;\n                length = swap;\n            }\n\n            offset = +offset || 0;\n            var remaining = this.length - offset;\n            if (!length) {\n                length = remaining;\n            } else {\n                length = +length;\n                if (length > remaining) {\n                    length = remaining;\n                }\n            }\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.SlowBufferWrite.call(this, string, offset, length, encoding);\n\n            if (string.length > 0 && (length < 0 || offset < 0))\n                throw new RangeError('attempt to write beyond buffer bounds');\n\n            // Otherwise, use our encoding method.\n            var buf = iconv.encode(string, encoding);\n            if (buf.length < length) length = buf.length;\n            buf.copy(this, offset, 0, length);\n            return length;\n        }\n\n        // -- Buffer ---------------------------------------------------------------\n\n        original.BufferIsEncoding = Buffer.isEncoding;\n        Buffer.isEncoding = function(encoding) {\n            return Buffer.isNativeEncoding(encoding) || iconv.encodingExists(encoding);\n        }\n\n        original.BufferByteLength = Buffer.byteLength;\n        Buffer.byteLength = SlowBuffer.byteLength = function(str, encoding) {\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.BufferByteLength.call(this, str, encoding);\n\n            // Slow, I know, but we don't have a better way yet.\n            return iconv.encode(str, encoding).length;\n        }\n\n        original.BufferToString = Buffer.prototype.toString;\n        Buffer.prototype.toString = function(encoding, start, end) {\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.BufferToString.call(this, encoding, start, end);\n\n            // Otherwise, use our decoding method.\n            if (typeof start == 'undefined') start = 0;\n            if (typeof end == 'undefined') end = this.length;\n            return iconv.decode(this.slice(start, end), encoding);\n        }\n\n        original.BufferWrite = Buffer.prototype.write;\n        Buffer.prototype.write = function(string, offset, length, encoding) {\n            var _offset = offset, _length = length, _encoding = encoding;\n            // Support both (string, offset, length, encoding)\n            // and the legacy (string, encoding, offset, length)\n            if (isFinite(offset)) {\n                if (!isFinite(length)) {\n                    encoding = length;\n                    length = undefined;\n                }\n            } else {  // legacy\n                var swap = encoding;\n                encoding = offset;\n                offset = length;\n                length = swap;\n            }\n\n            encoding = String(encoding || 'utf8').toLowerCase();\n\n            // Use native conversion when possible\n            if (Buffer.isNativeEncoding(encoding))\n                return original.BufferWrite.call(this, string, _offset, _length, _encoding);\n\n            offset = +offset || 0;\n            var remaining = this.length - offset;\n            if (!length) {\n                length = remaining;\n            } else {\n                length = +length;\n                if (length > remaining) {\n                    length = remaining;\n                }\n            }\n\n            if (string.length > 0 && (length < 0 || offset < 0))\n                throw new RangeError('attempt to write beyond buffer bounds');\n\n            // Otherwise, use our encoding method.\n            var buf = iconv.encode(string, encoding);\n            if (buf.length < length) length = buf.length;\n            buf.copy(this, offset, 0, length);\n            return length;\n\n            // TODO: Set _charsWritten.\n        }\n\n\n        // -- Readable -------------------------------------------------------------\n        if (iconv.supportsStreams) {\n            var Readable = require('stream').Readable;\n\n            original.ReadableSetEncoding = Readable.prototype.setEncoding;\n            Readable.prototype.setEncoding = function setEncoding(enc, options) {\n                // Use our own decoder, it has the same interface.\n                // We cannot use original function as it doesn't handle BOM-s.\n                this._readableState.decoder = iconv.getDecoder(enc, options);\n                this._readableState.encoding = enc;\n            }\n\n            Readable.prototype.collect = iconv._collect;\n        }\n    }\n\n    // Remove iconv-lite Node primitive extensions.\n    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {\n        if (!iconv.supportsNodeEncodingsExtension)\n            return;\n        if (!original)\n            throw new Error(\"require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.\")\n\n        delete Buffer.isNativeEncoding;\n\n        var SlowBuffer = require('buffer').SlowBuffer;\n\n        SlowBuffer.prototype.toString = original.SlowBufferToString;\n        SlowBuffer.prototype.write = original.SlowBufferWrite;\n\n        Buffer.isEncoding = original.BufferIsEncoding;\n        Buffer.byteLength = original.BufferByteLength;\n        Buffer.prototype.toString = original.BufferToString;\n        Buffer.prototype.write = original.BufferWrite;\n\n        if (iconv.supportsStreams) {\n            var Readable = require('stream').Readable;\n\n            Readable.prototype.setEncoding = original.ReadableSetEncoding;\n            delete Readable.prototype.collect;\n        }\n\n        original = undefined;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}