{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params\n    } = _ref;\n    return (0, codegen_1.str)`must match \"${params.ifClause}\" schema`;\n  },\n  params: _ref2 => {\n    let {\n      params\n    } = _ref2;\n    return (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`;\n  }\n};\nconst def = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      parentSchema,\n      it\n    } = cxt;\n\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      (0, util_1.checkStrictMode)(it, '\"if\" without \"then\" and \"else\" is ignored');\n    }\n\n    const hasThen = hasSchema(it, \"then\");\n    const hasElse = hasSchema(it, \"else\");\n    if (!hasThen && !hasElse) return;\n    const valid = gen.let(\"valid\", true);\n    const schValid = gen.name(\"_valid\");\n    validateIf();\n    cxt.reset();\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\");\n      cxt.setParams({\n        ifClause\n      });\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause));\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"));\n    } else {\n      gen.if((0, codegen_1.not)(schValid), validateClause(\"else\"));\n    }\n\n    cxt.pass(valid, () => cxt.error(true));\n\n    function validateIf() {\n      const schCxt = cxt.subschema({\n        keyword: \"if\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false\n      }, schValid);\n      cxt.mergeEvaluated(schCxt);\n    }\n\n    function validateClause(keyword, ifClause) {\n      return () => {\n        const schCxt = cxt.subschema({\n          keyword\n        }, schValid);\n        gen.assign(valid, schValid);\n        cxt.mergeValidEvaluated(schCxt, valid);\n        if (ifClause) gen.assign(ifClause, (0, codegen_1._)`${keyword}`);else cxt.setParams({\n          ifClause: keyword\n        });\n      };\n    }\n  }\n\n};\n\nfunction hasSchema(it, keyword) {\n  const schema = it.schema[keyword];\n  return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);\n}\n\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","ifClause","def","keyword","schemaType","trackErrors","code","cxt","gen","parentSchema","it","then","undefined","else","hasThen","hasSchema","hasElse","valid","let","schValid","name","validateIf","reset","setParams","if","validateClause","pass","schCxt","subschema","compositeRule","createErrors","allErrors","mergeEvaluated","assign","mergeValidEvaluated","schema","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\vocabularies\\applicator\\if.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}