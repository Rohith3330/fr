{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst schema = [{\n  enum: ['always', 'always-multiline', 'only-multiline', 'never'],\n  type: 'string'\n}, {\n  enum: ['always', 'always-multiline', 'only-multiline', 'never'],\n  type: 'string'\n}, {\n  enum: ['always', 'always-multiline', 'only-multiline', 'never'],\n  type: 'string'\n}]; // required for reporting the correct position\n\nconst getLast = (property, indexer) => {\n  if (!property) {\n    return indexer;\n  }\n\n  if (!indexer) {\n    return property;\n  }\n\n  if (property.loc.end.line > indexer.loc.end.line) {\n    return property;\n  }\n\n  if (indexer.loc.end.line > property.loc.end.line) {\n    return indexer;\n  }\n\n  if (property.loc.end.column > indexer.loc.end.column) {\n    return property;\n  }\n\n  return indexer;\n};\n\nconst create = context => {\n  const option = context.options[0] || 'never';\n  const interfaceOption = context.options[1] || option;\n  const inexactNotationOption = context.options[2] || 'never';\n  const sourceCode = context.getSourceCode();\n\n  const getNodeOption = node => {\n    if (node.parent.type === 'InterfaceDeclaration') {\n      return interfaceOption;\n    }\n\n    if (node.inexact) {\n      return inexactNotationOption;\n    }\n\n    return option;\n  };\n\n  const reporter = (node, message, fix) => {\n    return () => {\n      context.report({\n        fix,\n        message,\n        node\n      });\n    };\n  };\n\n  const makeReporters = (node, tokenToFix) => {\n    return {\n      dangle: reporter(node, 'Unexpected trailing delimiter', fixer => {\n        return fixer.replaceText(tokenToFix, '');\n      }),\n      noDangle: reporter(node, 'Missing trailing delimiter', fixer => {\n        return fixer.insertTextAfter(tokenToFix, ',');\n      })\n    };\n  };\n\n  const evaluate = (node, lastChildNode) => {\n    if (!lastChildNode && !node.inexact) {\n      return;\n    }\n\n    const [penultimateToken, lastToken] = sourceCode.getLastTokens(node, 2);\n    const isDangling = [';', ','].includes(penultimateToken.value);\n    const isMultiLine = penultimateToken.loc.start.line !== lastToken.loc.start.line; // Use the object node if it's inexact since there's no child node for the inexact notation\n\n    const report = makeReporters(node.inexact ? node : lastChildNode, penultimateToken);\n    const nodeOption = getNodeOption(node);\n\n    if (nodeOption === 'always' && !isDangling) {\n      report.noDangle();\n      return;\n    }\n\n    if (nodeOption === 'never' && isDangling) {\n      report.dangle();\n      return;\n    }\n\n    if (nodeOption === 'always-multiline' && !isDangling && isMultiLine) {\n      report.noDangle();\n      return;\n    }\n\n    if (nodeOption === 'always-multiline' && isDangling && !isMultiLine) {\n      report.dangle();\n      return;\n    }\n\n    if (nodeOption === 'only-multiline' && isDangling && !isMultiLine) {\n      report.dangle();\n    }\n  };\n\n  return {\n    ObjectTypeAnnotation(node) {\n      evaluate(node, getLast(_lodash.default.last(node.properties), _lodash.default.last(node.indexers)));\n    },\n\n    TupleTypeAnnotation(node) {\n      evaluate(node, _lodash.default.last(node.types));\n    }\n\n  };\n};\n\nvar _default = {\n  create,\n  meta: {\n    fixable: 'code'\n  },\n  schema\n};\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_lodash","_interopRequireDefault","require","obj","__esModule","schema","enum","type","getLast","property","indexer","loc","end","line","column","create","context","option","options","interfaceOption","inexactNotationOption","sourceCode","getSourceCode","getNodeOption","node","parent","inexact","reporter","message","fix","report","makeReporters","tokenToFix","dangle","fixer","replaceText","noDangle","insertTextAfter","evaluate","lastChildNode","penultimateToken","lastToken","getLastTokens","isDangling","includes","isMultiLine","start","nodeOption","ObjectTypeAnnotation","last","properties","indexers","TupleTypeAnnotation","types","_default","meta","fixable","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-flowtype/dist/rules/delimiterDangle.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst schema = [{\n  enum: ['always', 'always-multiline', 'only-multiline', 'never'],\n  type: 'string'\n}, {\n  enum: ['always', 'always-multiline', 'only-multiline', 'never'],\n  type: 'string'\n}, {\n  enum: ['always', 'always-multiline', 'only-multiline', 'never'],\n  type: 'string'\n}]; // required for reporting the correct position\n\nconst getLast = (property, indexer) => {\n  if (!property) {\n    return indexer;\n  }\n\n  if (!indexer) {\n    return property;\n  }\n\n  if (property.loc.end.line > indexer.loc.end.line) {\n    return property;\n  }\n\n  if (indexer.loc.end.line > property.loc.end.line) {\n    return indexer;\n  }\n\n  if (property.loc.end.column > indexer.loc.end.column) {\n    return property;\n  }\n\n  return indexer;\n};\n\nconst create = context => {\n  const option = context.options[0] || 'never';\n  const interfaceOption = context.options[1] || option;\n  const inexactNotationOption = context.options[2] || 'never';\n  const sourceCode = context.getSourceCode();\n\n  const getNodeOption = node => {\n    if (node.parent.type === 'InterfaceDeclaration') {\n      return interfaceOption;\n    }\n\n    if (node.inexact) {\n      return inexactNotationOption;\n    }\n\n    return option;\n  };\n\n  const reporter = (node, message, fix) => {\n    return () => {\n      context.report({\n        fix,\n        message,\n        node\n      });\n    };\n  };\n\n  const makeReporters = (node, tokenToFix) => {\n    return {\n      dangle: reporter(node, 'Unexpected trailing delimiter', fixer => {\n        return fixer.replaceText(tokenToFix, '');\n      }),\n      noDangle: reporter(node, 'Missing trailing delimiter', fixer => {\n        return fixer.insertTextAfter(tokenToFix, ',');\n      })\n    };\n  };\n\n  const evaluate = (node, lastChildNode) => {\n    if (!lastChildNode && !node.inexact) {\n      return;\n    }\n\n    const [penultimateToken, lastToken] = sourceCode.getLastTokens(node, 2);\n    const isDangling = [';', ','].includes(penultimateToken.value);\n    const isMultiLine = penultimateToken.loc.start.line !== lastToken.loc.start.line; // Use the object node if it's inexact since there's no child node for the inexact notation\n\n    const report = makeReporters(node.inexact ? node : lastChildNode, penultimateToken);\n    const nodeOption = getNodeOption(node);\n\n    if (nodeOption === 'always' && !isDangling) {\n      report.noDangle();\n      return;\n    }\n\n    if (nodeOption === 'never' && isDangling) {\n      report.dangle();\n      return;\n    }\n\n    if (nodeOption === 'always-multiline' && !isDangling && isMultiLine) {\n      report.noDangle();\n      return;\n    }\n\n    if (nodeOption === 'always-multiline' && isDangling && !isMultiLine) {\n      report.dangle();\n      return;\n    }\n\n    if (nodeOption === 'only-multiline' && isDangling && !isMultiLine) {\n      report.dangle();\n    }\n  };\n\n  return {\n    ObjectTypeAnnotation(node) {\n      evaluate(node, getLast(_lodash.default.last(node.properties), _lodash.default.last(node.indexers)));\n    },\n\n    TupleTypeAnnotation(node) {\n      evaluate(node, _lodash.default.last(node.types));\n    }\n\n  };\n};\n\nvar _default = {\n  create,\n  meta: {\n    fixable: 'code'\n  },\n  schema\n};\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}