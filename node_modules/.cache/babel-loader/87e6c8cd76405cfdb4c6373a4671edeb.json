{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _hoist = require(\"./hoist\");\n\nvar _emit = require(\"./emit\");\n\nvar _replaceShorthandObjectMethod = _interopRequireDefault(require(\"./replaceShorthandObjectMethod\"));\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nexports.getVisitor = function (_ref) {\n  var t = _ref.types;\n  return {\n    Method: function Method(path, state) {\n      var node = path.node;\n      if (!shouldRegenerate(node, state)) return;\n      var container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);\n      path.get(\"body\").set(\"body\", [t.returnStatement(t.callExpression(container, []))]); // Regardless of whether or not the wrapped function is a an async method\n      // or generator the outer function should not be\n\n      node.async = false;\n      node.generator = false; // Unwrap the wrapper IIFE's environment so super and this and such still work.\n\n      path.get(\"body.body.0.argument.callee\").unwrapFunctionEnvironment();\n    },\n    Function: {\n      exit: util.wrapWithTypes(t, function (path, state) {\n        var node = path.node;\n        if (!shouldRegenerate(node, state)) return; // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n\n        path = (0, _replaceShorthandObjectMethod[\"default\"])(path);\n        node = path.node;\n        var contextId = path.scope.generateUidIdentifier(\"context\");\n        var argsId = path.scope.generateUidIdentifier(\"args\");\n        path.ensureBlock();\n        var bodyBlockPath = path.get(\"body\");\n\n        if (node.async) {\n          bodyBlockPath.traverse(awaitVisitor);\n        }\n\n        bodyBlockPath.traverse(functionSentVisitor, {\n          context: contextId\n        });\n        var outerBody = [];\n        var innerBody = [];\n        bodyBlockPath.get(\"body\").forEach(function (childPath) {\n          var node = childPath.node;\n\n          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {\n            // Babylon represents directives like \"use strict\" as elements\n            // of a bodyBlockPath.node.directives array, but they could just\n            // as easily be represented (by other parsers) as traditional\n            // string-literal-valued expression statements, so we need to\n            // handle that here. (#248)\n            outerBody.push(node);\n          } else if (node && node._blockHoist != null) {\n            outerBody.push(node);\n          } else {\n            innerBody.push(node);\n          }\n        });\n\n        if (outerBody.length > 0) {\n          // Only replace the inner body if we actually hoisted any statements\n          // to the outer body.\n          bodyBlockPath.node.body = innerBody;\n        }\n\n        var outerFnExpr = getOuterFnExpr(path); // Note that getOuterFnExpr has the side-effect of ensuring that the\n        // function has a name (so node.id will always be an Identifier), even\n        // if a temporary name has to be synthesized.\n\n        t.assertIdentifier(node.id);\n        var innerFnId = t.identifier(node.id.name + \"$\"); // Turn all declarations into vars, and replace the original\n        // declarations with equivalent assignment expressions.\n\n        var vars = (0, _hoist.hoist)(path);\n        var context = {\n          usesThis: false,\n          usesArguments: false,\n          getArgsId: function getArgsId() {\n            return t.clone(argsId);\n          }\n        };\n        path.traverse(argumentsThisVisitor, context);\n\n        if (context.usesArguments) {\n          vars = vars || t.variableDeclaration(\"var\", []);\n          vars.declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier(\"arguments\")));\n        }\n\n        var emitter = new _emit.Emitter(contextId);\n        emitter.explode(path.get(\"body\"));\n\n        if (vars && vars.declarations.length > 0) {\n          outerBody.push(vars);\n        }\n\n        var wrapArgs = [emitter.getContextFunction(innerFnId)];\n        var tryLocsList = emitter.getTryLocsList();\n\n        if (node.generator) {\n          wrapArgs.push(outerFnExpr);\n        } else if (context.usesThis || tryLocsList || node.async) {\n          // Async functions that are not generators don't care about the\n          // outer function because they don't need it to be marked and don't\n          // inherit from its .prototype.\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (context.usesThis) {\n          wrapArgs.push(t.thisExpression());\n        } else if (tryLocsList || node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (tryLocsList) {\n          wrapArgs.push(tryLocsList);\n        } else if (node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (node.async) {\n          // Rename any locally declared \"Promise\" variable,\n          // to use the global one.\n          var currentScope = path.scope;\n\n          do {\n            if (currentScope.hasOwnBinding(\"Promise\")) currentScope.rename(\"Promise\");\n          } while (currentScope = currentScope.parent);\n\n          wrapArgs.push(t.identifier(\"Promise\"));\n        }\n\n        var wrapCall = t.callExpression(util.runtimeProperty(node.async ? \"async\" : \"wrap\"), wrapArgs);\n        outerBody.push(t.returnStatement(wrapCall));\n        node.body = t.blockStatement(outerBody); // We injected a few new variable declarations (for every hoisted var),\n        // so we need to add them to the scope.\n\n        path.get(\"body.body\").forEach(function (p) {\n          return p.scope.registerDeclaration(p);\n        });\n        var oldDirectives = bodyBlockPath.node.directives;\n\n        if (oldDirectives) {\n          // Babylon represents directives like \"use strict\" as elements of\n          // a bodyBlockPath.node.directives array. (#248)\n          node.body.directives = oldDirectives;\n        }\n\n        var wasGeneratorFunction = node.generator;\n\n        if (wasGeneratorFunction) {\n          node.generator = false;\n        }\n\n        if (node.async) {\n          node.async = false;\n        }\n\n        if (wasGeneratorFunction && t.isExpression(node)) {\n          util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n          path.addComment(\"leading\", \"#__PURE__\");\n        }\n\n        var insertedLocs = emitter.getInsertedLocs();\n        path.traverse({\n          NumericLiteral: function NumericLiteral(path) {\n            if (!insertedLocs.has(path.node)) {\n              return;\n            }\n\n            path.replaceWith(t.numericLiteral(path.node.value));\n          }\n        }); // Generators are processed in 'exit' handlers so that regenerator only has to run on\n        // an ES5 AST, but that means traversal will not pick up newly inserted references\n        // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n\n        path.requeue();\n      })\n    }\n  };\n}; // Check if a node should be transformed by regenerator\n\n\nfunction shouldRegenerate(node, state) {\n  if (node.generator) {\n    if (node.async) {\n      // Async generator\n      return state.opts.asyncGenerators !== false;\n    } else {\n      // Plain generator\n      return state.opts.generators !== false;\n    }\n  } else if (node.async) {\n    // Async function\n    return state.opts.async !== false;\n  } else {\n    // Not a generator or async function.\n    return false;\n  }\n} // Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\n\n\nfunction getOuterFnExpr(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n  t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return t.clone(node.id);\n}\n\nvar markInfo = new WeakMap();\n\nfunction getMarkInfo(node) {\n  if (!markInfo.has(node)) {\n    markInfo.set(node, {});\n  }\n\n  return markInfo.get(node);\n}\n\nfunction getMarkedFunctionId(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertIdentifier(node.id);\n  var blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  var block = blockPath.node;\n\n  _assert[\"default\"].ok(Array.isArray(block.body));\n\n  var info = getMarkInfo(block);\n\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  _assert[\"default\"].strictEqual(info.declPath.node, info.decl); // Get a new unique identifier for our marked variable.\n\n\n  var markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  var markCallExp = t.callExpression(util.runtimeProperty(\"mark\"), [t.clone(node.id)]);\n  var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;\n  var markCallExpPath = info.declPath.get(\"declarations.\" + index + \".init\");\n\n  _assert[\"default\"].strictEqual(markCallExpPath.node, markCallExp);\n\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n  return t.clone(markedId);\n}\n\nvar argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration|Method\": function FunctionExpressionFunctionDeclarationMethod(path) {\n    path.skip();\n  },\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression: function ThisExpression(path, state) {\n    state.usesThis = true;\n  }\n};\nvar functionSentVisitor = {\n  MetaProperty: function MetaProperty(path) {\n    var node = path.node;\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      var t = util.getTypes();\n      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier(\"_sent\")));\n    }\n  }\n};\nvar awaitVisitor = {\n  Function: function Function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n  AwaitExpression: function AwaitExpression(path) {\n    var t = util.getTypes(); // Convert await expressions to yield expressions.\n\n    var argument = path.node.argument; // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n\n    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty(\"awrap\"), [argument]), false));\n  }\n};","map":{"version":3,"names":["_interopRequireDefault","require","_assert","_hoist","_emit","_replaceShorthandObjectMethod","util","_interopRequireWildcard","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","exports","getVisitor","_ref","t","types","Method","path","state","node","shouldRegenerate","container","functionExpression","cloneNode","body","generator","async","returnStatement","callExpression","unwrapFunctionEnvironment","Function","exit","wrapWithTypes","contextId","scope","generateUidIdentifier","argsId","ensureBlock","bodyBlockPath","traverse","awaitVisitor","functionSentVisitor","context","outerBody","innerBody","forEach","childPath","isExpressionStatement","isStringLiteral","expression","push","_blockHoist","length","outerFnExpr","getOuterFnExpr","assertIdentifier","id","innerFnId","identifier","name","vars","hoist","usesThis","usesArguments","getArgsId","clone","argumentsThisVisitor","variableDeclaration","declarations","variableDeclarator","emitter","Emitter","explode","wrapArgs","getContextFunction","tryLocsList","getTryLocsList","nullLiteral","thisExpression","currentScope","hasOwnBinding","rename","parent","wrapCall","runtimeProperty","blockStatement","p","registerDeclaration","oldDirectives","directives","wasGeneratorFunction","isExpression","replaceWithOrRemove","addComment","insertedLocs","getInsertedLocs","NumericLiteral","replaceWith","numericLiteral","value","requeue","opts","asyncGenerators","generators","funPath","getTypes","assertFunction","isFunctionDeclaration","getMarkedFunctionId","markInfo","getMarkInfo","blockPath","findParent","isProgram","isBlockStatement","block","ok","Array","isArray","info","decl","unshiftContainer","declPath","strictEqual","markedId","markCallExp","index","markCallExpPath","FunctionExpressionFunctionDeclarationMethod","skip","Identifier","isReference","ThisExpression","MetaProperty","meta","property","memberExpression","AwaitExpression","argument","yieldExpression"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/regenerator-transform/lib/visit.js"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _hoist = require(\"./hoist\");\n\nvar _emit = require(\"./emit\");\n\nvar _replaceShorthandObjectMethod = _interopRequireDefault(require(\"./replaceShorthandObjectMethod\"));\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nexports.getVisitor = function (_ref) {\n  var t = _ref.types;\n  return {\n    Method: function Method(path, state) {\n      var node = path.node;\n      if (!shouldRegenerate(node, state)) return;\n      var container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);\n      path.get(\"body\").set(\"body\", [t.returnStatement(t.callExpression(container, []))]); // Regardless of whether or not the wrapped function is a an async method\n      // or generator the outer function should not be\n\n      node.async = false;\n      node.generator = false; // Unwrap the wrapper IIFE's environment so super and this and such still work.\n\n      path.get(\"body.body.0.argument.callee\").unwrapFunctionEnvironment();\n    },\n    Function: {\n      exit: util.wrapWithTypes(t, function (path, state) {\n        var node = path.node;\n        if (!shouldRegenerate(node, state)) return; // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n\n        path = (0, _replaceShorthandObjectMethod[\"default\"])(path);\n        node = path.node;\n        var contextId = path.scope.generateUidIdentifier(\"context\");\n        var argsId = path.scope.generateUidIdentifier(\"args\");\n        path.ensureBlock();\n        var bodyBlockPath = path.get(\"body\");\n\n        if (node.async) {\n          bodyBlockPath.traverse(awaitVisitor);\n        }\n\n        bodyBlockPath.traverse(functionSentVisitor, {\n          context: contextId\n        });\n        var outerBody = [];\n        var innerBody = [];\n        bodyBlockPath.get(\"body\").forEach(function (childPath) {\n          var node = childPath.node;\n\n          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {\n            // Babylon represents directives like \"use strict\" as elements\n            // of a bodyBlockPath.node.directives array, but they could just\n            // as easily be represented (by other parsers) as traditional\n            // string-literal-valued expression statements, so we need to\n            // handle that here. (#248)\n            outerBody.push(node);\n          } else if (node && node._blockHoist != null) {\n            outerBody.push(node);\n          } else {\n            innerBody.push(node);\n          }\n        });\n\n        if (outerBody.length > 0) {\n          // Only replace the inner body if we actually hoisted any statements\n          // to the outer body.\n          bodyBlockPath.node.body = innerBody;\n        }\n\n        var outerFnExpr = getOuterFnExpr(path); // Note that getOuterFnExpr has the side-effect of ensuring that the\n        // function has a name (so node.id will always be an Identifier), even\n        // if a temporary name has to be synthesized.\n\n        t.assertIdentifier(node.id);\n        var innerFnId = t.identifier(node.id.name + \"$\"); // Turn all declarations into vars, and replace the original\n        // declarations with equivalent assignment expressions.\n\n        var vars = (0, _hoist.hoist)(path);\n        var context = {\n          usesThis: false,\n          usesArguments: false,\n          getArgsId: function getArgsId() {\n            return t.clone(argsId);\n          }\n        };\n        path.traverse(argumentsThisVisitor, context);\n\n        if (context.usesArguments) {\n          vars = vars || t.variableDeclaration(\"var\", []);\n          vars.declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier(\"arguments\")));\n        }\n\n        var emitter = new _emit.Emitter(contextId);\n        emitter.explode(path.get(\"body\"));\n\n        if (vars && vars.declarations.length > 0) {\n          outerBody.push(vars);\n        }\n\n        var wrapArgs = [emitter.getContextFunction(innerFnId)];\n        var tryLocsList = emitter.getTryLocsList();\n\n        if (node.generator) {\n          wrapArgs.push(outerFnExpr);\n        } else if (context.usesThis || tryLocsList || node.async) {\n          // Async functions that are not generators don't care about the\n          // outer function because they don't need it to be marked and don't\n          // inherit from its .prototype.\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (context.usesThis) {\n          wrapArgs.push(t.thisExpression());\n        } else if (tryLocsList || node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (tryLocsList) {\n          wrapArgs.push(tryLocsList);\n        } else if (node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n\n        if (node.async) {\n          // Rename any locally declared \"Promise\" variable,\n          // to use the global one.\n          var currentScope = path.scope;\n\n          do {\n            if (currentScope.hasOwnBinding(\"Promise\")) currentScope.rename(\"Promise\");\n          } while (currentScope = currentScope.parent);\n\n          wrapArgs.push(t.identifier(\"Promise\"));\n        }\n\n        var wrapCall = t.callExpression(util.runtimeProperty(node.async ? \"async\" : \"wrap\"), wrapArgs);\n        outerBody.push(t.returnStatement(wrapCall));\n        node.body = t.blockStatement(outerBody); // We injected a few new variable declarations (for every hoisted var),\n        // so we need to add them to the scope.\n\n        path.get(\"body.body\").forEach(function (p) {\n          return p.scope.registerDeclaration(p);\n        });\n        var oldDirectives = bodyBlockPath.node.directives;\n\n        if (oldDirectives) {\n          // Babylon represents directives like \"use strict\" as elements of\n          // a bodyBlockPath.node.directives array. (#248)\n          node.body.directives = oldDirectives;\n        }\n\n        var wasGeneratorFunction = node.generator;\n\n        if (wasGeneratorFunction) {\n          node.generator = false;\n        }\n\n        if (node.async) {\n          node.async = false;\n        }\n\n        if (wasGeneratorFunction && t.isExpression(node)) {\n          util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n          path.addComment(\"leading\", \"#__PURE__\");\n        }\n\n        var insertedLocs = emitter.getInsertedLocs();\n        path.traverse({\n          NumericLiteral: function NumericLiteral(path) {\n            if (!insertedLocs.has(path.node)) {\n              return;\n            }\n\n            path.replaceWith(t.numericLiteral(path.node.value));\n          }\n        }); // Generators are processed in 'exit' handlers so that regenerator only has to run on\n        // an ES5 AST, but that means traversal will not pick up newly inserted references\n        // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n\n        path.requeue();\n      })\n    }\n  };\n}; // Check if a node should be transformed by regenerator\n\n\nfunction shouldRegenerate(node, state) {\n  if (node.generator) {\n    if (node.async) {\n      // Async generator\n      return state.opts.asyncGenerators !== false;\n    } else {\n      // Plain generator\n      return state.opts.generators !== false;\n    }\n  } else if (node.async) {\n    // Async function\n    return state.opts.async !== false;\n  } else {\n    // Not a generator or async function.\n    return false;\n  }\n} // Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\n\n\nfunction getOuterFnExpr(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertFunction(node);\n\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n\n  if (node.generator && // Non-generator functions don't need to be marked.\n  t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n\n  return t.clone(node.id);\n}\n\nvar markInfo = new WeakMap();\n\nfunction getMarkInfo(node) {\n  if (!markInfo.has(node)) {\n    markInfo.set(node, {});\n  }\n\n  return markInfo.get(node);\n}\n\nfunction getMarkedFunctionId(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertIdentifier(node.id);\n  var blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n\n  if (!blockPath) {\n    return node.id;\n  }\n\n  var block = blockPath.node;\n\n  _assert[\"default\"].ok(Array.isArray(block.body));\n\n  var info = getMarkInfo(block);\n\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n\n  _assert[\"default\"].strictEqual(info.declPath.node, info.decl); // Get a new unique identifier for our marked variable.\n\n\n  var markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  var markCallExp = t.callExpression(util.runtimeProperty(\"mark\"), [t.clone(node.id)]);\n  var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;\n  var markCallExpPath = info.declPath.get(\"declarations.\" + index + \".init\");\n\n  _assert[\"default\"].strictEqual(markCallExpPath.node, markCallExp);\n\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n  return t.clone(markedId);\n}\n\nvar argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration|Method\": function FunctionExpressionFunctionDeclarationMethod(path) {\n    path.skip();\n  },\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression: function ThisExpression(path, state) {\n    state.usesThis = true;\n  }\n};\nvar functionSentVisitor = {\n  MetaProperty: function MetaProperty(path) {\n    var node = path.node;\n\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      var t = util.getTypes();\n      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier(\"_sent\")));\n    }\n  }\n};\nvar awaitVisitor = {\n  Function: function Function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n  AwaitExpression: function AwaitExpression(path) {\n    var t = util.getTypes(); // Convert await expressions to yield expressions.\n\n    var argument = path.node.argument; // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n\n    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty(\"awrap\"), [argument]), false));\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}