{"ast":null,"code":"const mdnAtrules = require('mdn-data/css/at-rules.json');\n\nconst mdnProperties = require('mdn-data/css/properties.json');\n\nconst mdnSyntaxes = require('mdn-data/css/syntaxes.json');\n\nconst patch = require('./patch.json');\n\nconst extendSyntax = /^\\s*\\|\\s*/;\n\nfunction preprocessAtrules(dict) {\n  const result = Object.create(null);\n\n  for (const atruleName in dict) {\n    const atrule = dict[atruleName];\n    let descriptors = null;\n\n    if (atrule.descriptors) {\n      descriptors = Object.create(null);\n\n      for (const descriptor in atrule.descriptors) {\n        descriptors[descriptor] = atrule.descriptors[descriptor].syntax;\n      }\n    }\n\n    result[atruleName.substr(1)] = {\n      prelude: atrule.syntax.trim().match(/^@\\S+\\s+([^;\\{]*)/)[1].trim() || null,\n      descriptors\n    };\n  }\n\n  return result;\n}\n\nfunction patchDictionary(dict, patchDict) {\n  const result = {}; // copy all syntaxes for an original dict\n\n  for (const key in dict) {\n    result[key] = dict[key].syntax || dict[key];\n  } // apply a patch\n\n\n  for (const key in patchDict) {\n    if (key in dict) {\n      if (patchDict[key].syntax) {\n        result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + ' ' + patchDict[key].syntax.trim() : patchDict[key].syntax;\n      } else {\n        delete result[key];\n      }\n    } else {\n      if (patchDict[key].syntax) {\n        result[key] = patchDict[key].syntax.replace(extendSyntax, '');\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction unpackSyntaxes(dict) {\n  const result = {};\n\n  for (const key in dict) {\n    result[key] = dict[key].syntax;\n  }\n\n  return result;\n}\n\nfunction patchAtrules(dict, patchDict) {\n  const result = {}; // copy all syntaxes for an original dict\n\n  for (const key in dict) {\n    const patchDescriptors = patchDict[key] && patchDict[key].descriptors || null;\n    result[key] = {\n      prelude: key in patchDict && 'prelude' in patchDict[key] ? patchDict[key].prelude : dict[key].prelude || null,\n      descriptors: dict[key].descriptors ? patchDictionary(dict[key].descriptors, patchDescriptors || {}) : patchDescriptors && unpackSyntaxes(patchDescriptors)\n    };\n  } // apply a patch\n\n\n  for (const key in patchDict) {\n    if (!hasOwnProperty.call(dict, key)) {\n      result[key] = {\n        prelude: patchDict[key].prelude || null,\n        descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)\n      };\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  types: patchDictionary(mdnSyntaxes, patch.syntaxes),\n  atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),\n  properties: patchDictionary(mdnProperties, patch.properties)\n};","map":{"version":3,"names":["mdnAtrules","require","mdnProperties","mdnSyntaxes","patch","extendSyntax","preprocessAtrules","dict","result","Object","create","atruleName","atrule","descriptors","descriptor","syntax","substr","prelude","trim","match","patchDictionary","patchDict","key","test","replace","unpackSyntaxes","patchAtrules","patchDescriptors","hasOwnProperty","call","module","exports","types","syntaxes","atrules","properties"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/csso/node_modules/css-tree/data/index.js"],"sourcesContent":["const mdnAtrules = require('mdn-data/css/at-rules.json');\nconst mdnProperties = require('mdn-data/css/properties.json');\nconst mdnSyntaxes = require('mdn-data/css/syntaxes.json');\nconst patch = require('./patch.json');\nconst extendSyntax = /^\\s*\\|\\s*/;\n\nfunction preprocessAtrules(dict) {\n    const result = Object.create(null);\n\n    for (const atruleName in dict) {\n        const atrule = dict[atruleName];\n        let descriptors = null;\n\n        if (atrule.descriptors) {\n            descriptors = Object.create(null);\n\n            for (const descriptor in atrule.descriptors) {\n                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;\n            }\n        }\n\n        result[atruleName.substr(1)] = {\n            prelude: atrule.syntax.trim().match(/^@\\S+\\s+([^;\\{]*)/)[1].trim() || null,\n            descriptors\n        };\n    }\n\n    return result;\n}\n\nfunction patchDictionary(dict, patchDict) {\n    const result = {};\n\n    // copy all syntaxes for an original dict\n    for (const key in dict) {\n        result[key] = dict[key].syntax || dict[key];\n    }\n\n    // apply a patch\n    for (const key in patchDict) {\n        if (key in dict) {\n            if (patchDict[key].syntax) {\n                result[key] = extendSyntax.test(patchDict[key].syntax)\n                    ? result[key] + ' ' + patchDict[key].syntax.trim()\n                    : patchDict[key].syntax;\n            } else {\n                delete result[key];\n            }\n        } else {\n            if (patchDict[key].syntax) {\n                result[key] = patchDict[key].syntax.replace(extendSyntax, '');\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction unpackSyntaxes(dict) {\n    const result = {};\n\n    for (const key in dict) {\n        result[key] = dict[key].syntax;\n    }\n\n    return result;\n}\n\nfunction patchAtrules(dict, patchDict) {\n    const result = {};\n\n    // copy all syntaxes for an original dict\n    for (const key in dict) {\n        const patchDescriptors = (patchDict[key] && patchDict[key].descriptors) || null;\n\n        result[key] = {\n            prelude: key in patchDict && 'prelude' in patchDict[key]\n                ? patchDict[key].prelude\n                : dict[key].prelude || null,\n            descriptors: dict[key].descriptors\n                ? patchDictionary(dict[key].descriptors, patchDescriptors || {})\n                : patchDescriptors && unpackSyntaxes(patchDescriptors)\n        };\n    }\n\n    // apply a patch\n    for (const key in patchDict) {\n        if (!hasOwnProperty.call(dict, key)) {\n            result[key] = {\n                prelude: patchDict[key].prelude || null,\n                descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)\n            };\n        }\n    }\n\n    return result;\n}\n\nmodule.exports = {\n    types: patchDictionary(mdnSyntaxes, patch.syntaxes),\n    atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),\n    properties: patchDictionary(mdnProperties, patch.properties)\n};\n"],"mappings":"AAAA,MAAMA,UAAU,GAAGC,OAAO,CAAC,4BAAD,CAA1B;;AACA,MAAMC,aAAa,GAAGD,OAAO,CAAC,8BAAD,CAA7B;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,4BAAD,CAA3B;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,cAAD,CAArB;;AACA,MAAMI,YAAY,GAAG,WAArB;;AAEA,SAASC,iBAAT,CAA2BC,IAA3B,EAAiC;EAC7B,MAAMC,MAAM,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAf;;EAEA,KAAK,MAAMC,UAAX,IAAyBJ,IAAzB,EAA+B;IAC3B,MAAMK,MAAM,GAAGL,IAAI,CAACI,UAAD,CAAnB;IACA,IAAIE,WAAW,GAAG,IAAlB;;IAEA,IAAID,MAAM,CAACC,WAAX,EAAwB;MACpBA,WAAW,GAAGJ,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;;MAEA,KAAK,MAAMI,UAAX,IAAyBF,MAAM,CAACC,WAAhC,EAA6C;QACzCA,WAAW,CAACC,UAAD,CAAX,GAA0BF,MAAM,CAACC,WAAP,CAAmBC,UAAnB,EAA+BC,MAAzD;MACH;IACJ;;IAEDP,MAAM,CAACG,UAAU,CAACK,MAAX,CAAkB,CAAlB,CAAD,CAAN,GAA+B;MAC3BC,OAAO,EAAEL,MAAM,CAACG,MAAP,CAAcG,IAAd,GAAqBC,KAArB,CAA2B,mBAA3B,EAAgD,CAAhD,EAAmDD,IAAnD,MAA6D,IAD3C;MAE3BL;IAF2B,CAA/B;EAIH;;EAED,OAAOL,MAAP;AACH;;AAED,SAASY,eAAT,CAAyBb,IAAzB,EAA+Bc,SAA/B,EAA0C;EACtC,MAAMb,MAAM,GAAG,EAAf,CADsC,CAGtC;;EACA,KAAK,MAAMc,GAAX,IAAkBf,IAAlB,EAAwB;IACpBC,MAAM,CAACc,GAAD,CAAN,GAAcf,IAAI,CAACe,GAAD,CAAJ,CAAUP,MAAV,IAAoBR,IAAI,CAACe,GAAD,CAAtC;EACH,CANqC,CAQtC;;;EACA,KAAK,MAAMA,GAAX,IAAkBD,SAAlB,EAA6B;IACzB,IAAIC,GAAG,IAAIf,IAAX,EAAiB;MACb,IAAIc,SAAS,CAACC,GAAD,CAAT,CAAeP,MAAnB,EAA2B;QACvBP,MAAM,CAACc,GAAD,CAAN,GAAcjB,YAAY,CAACkB,IAAb,CAAkBF,SAAS,CAACC,GAAD,CAAT,CAAeP,MAAjC,IACRP,MAAM,CAACc,GAAD,CAAN,GAAc,GAAd,GAAoBD,SAAS,CAACC,GAAD,CAAT,CAAeP,MAAf,CAAsBG,IAAtB,EADZ,GAERG,SAAS,CAACC,GAAD,CAAT,CAAeP,MAFrB;MAGH,CAJD,MAIO;QACH,OAAOP,MAAM,CAACc,GAAD,CAAb;MACH;IACJ,CARD,MAQO;MACH,IAAID,SAAS,CAACC,GAAD,CAAT,CAAeP,MAAnB,EAA2B;QACvBP,MAAM,CAACc,GAAD,CAAN,GAAcD,SAAS,CAACC,GAAD,CAAT,CAAeP,MAAf,CAAsBS,OAAtB,CAA8BnB,YAA9B,EAA4C,EAA5C,CAAd;MACH;IACJ;EACJ;;EAED,OAAOG,MAAP;AACH;;AAED,SAASiB,cAAT,CAAwBlB,IAAxB,EAA8B;EAC1B,MAAMC,MAAM,GAAG,EAAf;;EAEA,KAAK,MAAMc,GAAX,IAAkBf,IAAlB,EAAwB;IACpBC,MAAM,CAACc,GAAD,CAAN,GAAcf,IAAI,CAACe,GAAD,CAAJ,CAAUP,MAAxB;EACH;;EAED,OAAOP,MAAP;AACH;;AAED,SAASkB,YAAT,CAAsBnB,IAAtB,EAA4Bc,SAA5B,EAAuC;EACnC,MAAMb,MAAM,GAAG,EAAf,CADmC,CAGnC;;EACA,KAAK,MAAMc,GAAX,IAAkBf,IAAlB,EAAwB;IACpB,MAAMoB,gBAAgB,GAAIN,SAAS,CAACC,GAAD,CAAT,IAAkBD,SAAS,CAACC,GAAD,CAAT,CAAeT,WAAlC,IAAkD,IAA3E;IAEAL,MAAM,CAACc,GAAD,CAAN,GAAc;MACVL,OAAO,EAAEK,GAAG,IAAID,SAAP,IAAoB,aAAaA,SAAS,CAACC,GAAD,CAA1C,GACHD,SAAS,CAACC,GAAD,CAAT,CAAeL,OADZ,GAEHV,IAAI,CAACe,GAAD,CAAJ,CAAUL,OAAV,IAAqB,IAHjB;MAIVJ,WAAW,EAAEN,IAAI,CAACe,GAAD,CAAJ,CAAUT,WAAV,GACPO,eAAe,CAACb,IAAI,CAACe,GAAD,CAAJ,CAAUT,WAAX,EAAwBc,gBAAgB,IAAI,EAA5C,CADR,GAEPA,gBAAgB,IAAIF,cAAc,CAACE,gBAAD;IAN9B,CAAd;EAQH,CAfkC,CAiBnC;;;EACA,KAAK,MAAML,GAAX,IAAkBD,SAAlB,EAA6B;IACzB,IAAI,CAACO,cAAc,CAACC,IAAf,CAAoBtB,IAApB,EAA0Be,GAA1B,CAAL,EAAqC;MACjCd,MAAM,CAACc,GAAD,CAAN,GAAc;QACVL,OAAO,EAAEI,SAAS,CAACC,GAAD,CAAT,CAAeL,OAAf,IAA0B,IADzB;QAEVJ,WAAW,EAAEQ,SAAS,CAACC,GAAD,CAAT,CAAeT,WAAf,IAA8BY,cAAc,CAACJ,SAAS,CAACC,GAAD,CAAT,CAAeT,WAAhB;MAF/C,CAAd;IAIH;EACJ;;EAED,OAAOL,MAAP;AACH;;AAEDsB,MAAM,CAACC,OAAP,GAAiB;EACbC,KAAK,EAAEZ,eAAe,CAACjB,WAAD,EAAcC,KAAK,CAAC6B,QAApB,CADT;EAEbC,OAAO,EAAER,YAAY,CAACpB,iBAAiB,CAACN,UAAD,CAAlB,EAAgCI,KAAK,CAAC8B,OAAtC,CAFR;EAGbC,UAAU,EAAEf,eAAe,CAAClB,aAAD,EAAgBE,KAAK,CAAC+B,UAAtB;AAHd,CAAjB"},"metadata":{},"sourceType":"script"}