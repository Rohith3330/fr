{"ast":null,"code":"'use strict';\n\nconst generate = require('regjsgen').generate;\n\nconst parse = require('regjsparser').parse;\n\nconst regenerate = require('regenerate');\n\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\n\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\n\nconst iuMappings = require('./data/iu-mappings.js');\n\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n\nfunction flatMap(array, callback) {\n  const result = [];\n  array.forEach(item => {\n    const res = callback(item);\n\n    if (Array.isArray(res)) {\n      result.push.apply(result, res);\n    } else {\n      result.push(res);\n    }\n  });\n  return result;\n}\n\nconst SPECIAL_CHARS = /([\\\\^$.*+?()[\\]{}|])/g; // Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\n\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF); // Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\n\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n.remove( // minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n0x000A, // Line Feed <LF>\n0x000D, // Carriage Return <CR>\n0x2028, // Line Separator <LS>\n0x2029 // Paragraph Separator <PS>\n);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n  if (unicode) {\n    if (ignoreCase) {\n      return ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n    }\n\n    return ESCAPE_SETS.UNICODE.get(character);\n  }\n\n  return ESCAPE_SETS.REGULAR.get(character);\n};\n\nconst getUnicodeDotSet = dotAll => {\n  return dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\n\nconst getUnicodePropertyValueSet = (property, value) => {\n  const path = value ? `${property}/${value}` : `Binary_Property/${property}`;\n\n  try {\n    return require(`regenerate-unicode-properties/${path}.js`);\n  } catch (exception) {\n    throw new Error(`Failed to recognize value \\`${value}\\` for property ` + `\\`${property}\\`.`);\n  }\n};\n\nconst handleLoneUnicodePropertyNameOrValue = value => {\n  // It could be a `General_Category` value or a binary property.\n  // Note: `unicodeMatchPropertyValue` throws on invalid values.\n  try {\n    const property = 'General_Category';\n    const category = unicodeMatchPropertyValue(property, value);\n    return getUnicodePropertyValueSet(property, category);\n  } catch (exception) {} // It’s not a `General_Category` value, so check if it’s a property\n  // of strings.\n\n\n  try {\n    return getUnicodePropertyValueSet('Property_of_Strings', value);\n  } catch (exception) {} // Lastly, check if it’s a binary property of single code points.\n  // Note: `unicodeMatchProperty` throws on invalid properties.\n\n\n  const property = unicodeMatchProperty(value);\n  return getUnicodePropertyValueSet(property);\n};\n\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n  const parts = value.split('=');\n  const firstPart = parts[0];\n  let set;\n\n  if (parts.length == 1) {\n    set = handleLoneUnicodePropertyNameOrValue(firstPart);\n  } else {\n    // The pattern consists of two parts, i.e. `Property=Value`.\n    const property = unicodeMatchProperty(firstPart);\n    const value = unicodeMatchPropertyValue(property, parts[1]);\n    set = getUnicodePropertyValueSet(property, value);\n  }\n\n  if (isNegative) {\n    if (set.strings) {\n      throw new Error('Cannot negate Unicode property of strings');\n    }\n\n    return {\n      characters: UNICODE_SET.clone().remove(set.characters),\n      strings: new Set()\n    };\n  }\n\n  return {\n    characters: set.characters.clone(),\n    strings: set.strings // We need to escape strings like *️⃣ to make sure that they can be safely used in unions.\n    ? new Set(set.strings.map(str => str.replace(SPECIAL_CHARS, '\\\\$1'))) : new Set()\n  };\n};\n\nconst getUnicodePropertyEscapeCharacterClassData = (property, isNegative) => {\n  const set = getUnicodePropertyEscapeSet(property, isNegative);\n  const data = getCharacterClassEmptyData();\n  data.singleChars = set.characters;\n\n  if (set.strings.size > 0) {\n    data.longStrings = set.strings;\n    data.maybeIncludesStrings = true;\n  }\n\n  return data;\n}; // Given a range of code points, add any case-folded code points in that range\n// to a set.\n\n\nregenerate.prototype.iuAddRange = function (min, max) {\n  const $this = this;\n\n  do {\n    const folded = caseFold(min);\n\n    if (folded) {\n      $this.add(folded);\n    }\n  } while (++min <= max);\n\n  return $this;\n};\n\nregenerate.prototype.iuRemoveRange = function (min, max) {\n  const $this = this;\n\n  do {\n    const folded = caseFold(min);\n\n    if (folded) {\n      $this.remove(folded);\n    }\n  } while (++min <= max);\n\n  return $this;\n};\n\nconst update = (item, pattern) => {\n  let tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\n  switch (tree.type) {\n    case 'characterClass':\n    case 'group':\n    case 'value':\n      // No wrapping needed.\n      break;\n\n    default:\n      // Wrap the pattern in a non-capturing group.\n      tree = wrap(tree, pattern);\n  }\n\n  Object.assign(item, tree);\n};\n\nconst wrap = (tree, pattern) => {\n  // Wrap the pattern in a non-capturing group.\n  return {\n    'type': 'group',\n    'behavior': 'ignore',\n    'body': [tree],\n    'raw': `(?:${pattern})`\n  };\n};\n\nconst caseFold = codePoint => {\n  return iuMappings.get(codePoint) || false;\n};\n\nconst buildHandler = action => {\n  switch (action) {\n    case 'union':\n      return {\n        single: (data, cp) => {\n          data.singleChars.add(cp);\n        },\n        regSet: (data, set2) => {\n          data.singleChars.add(set2);\n        },\n        range: (data, start, end) => {\n          data.singleChars.addRange(start, end);\n        },\n        iuRange: (data, start, end) => {\n          data.singleChars.iuAddRange(start, end);\n        },\n        nested: (data, nestedData) => {\n          data.singleChars.add(nestedData.singleChars);\n\n          for (const str of nestedData.longStrings) data.longStrings.add(str);\n\n          if (nestedData.maybeIncludesStrings) data.maybeIncludesStrings = true;\n        }\n      };\n\n    case 'union-negative':\n      {\n        const regSet = (data, set2) => {\n          data.singleChars = UNICODE_SET.clone().remove(set2).add(data.singleChars);\n        };\n\n        return {\n          single: (data, cp) => {\n            const unicode = UNICODE_SET.clone();\n            data.singleChars = data.singleChars.contains(cp) ? unicode : unicode.remove(cp);\n          },\n          regSet: regSet,\n          range: (data, start, end) => {\n            data.singleChars = UNICODE_SET.clone().removeRange(start, end).add(data.singleChars);\n          },\n          iuRange: (data, start, end) => {\n            data.singleChars = UNICODE_SET.clone().iuRemoveRange(start, end).add(data.singleChars);\n          },\n          nested: (data, nestedData) => {\n            regSet(data, nestedData.singleChars);\n            if (nestedData.maybeIncludesStrings) throw new Error('ASSERTION ERROR');\n          }\n        };\n      }\n\n    case 'intersection':\n      {\n        const regSet = (data, set2) => {\n          if (data.first) data.singleChars = set2;else data.singleChars.intersection(set2);\n        };\n\n        return {\n          single: (data, cp) => {\n            data.singleChars = data.first || data.singleChars.contains(cp) ? regenerate(cp) : regenerate();\n            data.longStrings.clear();\n            data.maybeIncludesStrings = false;\n          },\n          regSet: (data, set) => {\n            regSet(data, set);\n            data.longStrings.clear();\n            data.maybeIncludesStrings = false;\n          },\n          range: (data, start, end) => {\n            if (data.first) data.singleChars.addRange(start, end);else data.singleChars.intersection(regenerate().addRange(start, end));\n            data.longStrings.clear();\n            data.maybeIncludesStrings = false;\n          },\n          iuRange: (data, start, end) => {\n            if (data.first) data.singleChars.iuAddRange(start, end);else data.singleChars.intersection(regenerate().iuAddRange(start, end));\n            data.longStrings.clear();\n            data.maybeIncludesStrings = false;\n          },\n          nested: (data, nestedData) => {\n            regSet(data, nestedData.singleChars);\n\n            if (data.first) {\n              data.longStrings = nestedData.longStrings;\n              data.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n            } else {\n              for (const str of data.longStrings) {\n                if (!nestedData.longStrings.has(str)) data.longStrings.delete(str);\n              }\n\n              if (!nestedData.maybeIncludesStrings) data.maybeIncludesStrings = false;\n            }\n          }\n        };\n      }\n\n    case 'subtraction':\n      {\n        const regSet = (data, set2) => {\n          if (data.first) data.singleChars.add(set2);else data.singleChars.remove(set2);\n        };\n\n        return {\n          single: (data, cp) => {\n            if (data.first) data.singleChars.add(cp);else data.singleChars.remove(cp);\n          },\n          regSet: regSet,\n          range: (data, start, end) => {\n            if (data.first) data.singleChars.addRange(start, end);else data.singleChars.removeRange(start, end);\n          },\n          iuRange: (data, start, end) => {\n            if (data.first) data.singleChars.iuAddRange(start, end);else data.singleChars.iuRemoveRange(start, end);\n          },\n          nested: (data, nestedData) => {\n            regSet(data, nestedData.singleChars);\n\n            if (data.first) {\n              data.longStrings = nestedData.longStrings;\n              data.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n            } else {\n              for (const str of data.longStrings) {\n                if (nestedData.longStrings.has(str)) data.longStrings.delete(str);\n              }\n            }\n          }\n        };\n      }\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(`Unknown set action: ${characterClassItem.kind}`);\n  }\n};\n\nconst getCharacterClassEmptyData = () => ({\n  transformed: config.transform.unicodeFlag,\n  singleChars: regenerate(),\n  longStrings: new Set(),\n  hasEmptyString: false,\n  first: true,\n  maybeIncludesStrings: false\n});\n\nconst maybeFold = codePoint => {\n  if (config.flags.ignoreCase && config.transform.unicodeFlag) {\n    const folded = caseFold(codePoint);\n\n    if (folded) {\n      return [codePoint, folded];\n    }\n  }\n\n  return [codePoint];\n};\n\nconst computeClassStrings = (classStrings, regenerateOptions) => {\n  let data = getCharacterClassEmptyData();\n\n  for (const string of classStrings.strings) {\n    if (string.characters.length === 1) {\n      maybeFold(string.characters[0].codePoint).forEach(cp => {\n        data.singleChars.add(cp);\n      });\n    } else {\n      let stringifiedString;\n\n      if (config.flags.ignoreCase && config.transform.unicodeFlag) {\n        stringifiedString = '';\n\n        for (const ch of string.characters) {\n          let set = regenerate(ch.codePoint);\n          const folded = caseFold(ch.codePoint);\n          if (folded) set.add(folded);\n          stringifiedString += set.toString(regenerateOptions);\n        }\n      } else {\n        stringifiedString = string.characters.map(ch => generate(ch)).join('');\n      }\n\n      data.longStrings.add(stringifiedString);\n      data.maybeIncludesStrings = true;\n    }\n  }\n\n  return data;\n};\n\nconst computeCharacterClass = (characterClassItem, regenerateOptions) => {\n  let data = getCharacterClassEmptyData();\n  let handlePositive;\n  let handleNegative;\n\n  switch (characterClassItem.kind) {\n    case 'union':\n      handlePositive = buildHandler('union');\n      handleNegative = buildHandler('union-negative');\n      break;\n\n    case 'intersection':\n      handlePositive = buildHandler('intersection');\n      handleNegative = buildHandler('subtraction');\n      break;\n\n    case 'subtraction':\n      handlePositive = buildHandler('subtraction');\n      handleNegative = buildHandler('intersection');\n      break;\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(`Unknown character class kind: ${characterClassItem.kind}`);\n  }\n\n  for (const item of characterClassItem.body) {\n    switch (item.type) {\n      case 'value':\n        maybeFold(item.codePoint).forEach(cp => {\n          handlePositive.single(data, cp);\n        });\n        break;\n\n      case 'characterClassRange':\n        const min = item.min.codePoint;\n        const max = item.max.codePoint;\n        handlePositive.range(data, min, max);\n\n        if (config.flags.ignoreCase && config.transform.unicodeFlag) {\n          handlePositive.iuRange(data, min, max);\n        }\n\n        break;\n\n      case 'characterClassEscape':\n        handlePositive.regSet(data, getCharacterClassEscapeSet(item.value, config.flags.unicode, config.flags.ignoreCase));\n        break;\n\n      case 'unicodePropertyEscape':\n        const nestedData = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n        handlePositive.nested(data, nestedData);\n        data.transformed = data.transformed || config.transform.unicodePropertyEscapes || config.transform.unicodeSetsFlag && nestedData.maybeIncludesStrings;\n        break;\n\n      case 'characterClass':\n        const handler = item.negative ? handleNegative : handlePositive;\n        const res = computeCharacterClass(item, regenerateOptions);\n        handler.nested(data, res);\n        data.transformed = true;\n        break;\n\n      case 'classStrings':\n        handlePositive.nested(data, computeClassStrings(item, regenerateOptions));\n        data.transformed = true;\n        break;\n      // The `default` clause is only here as a safeguard; it should never be\n      // reached. Code coverage tools should ignore it.\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error(`Unknown term type: ${item.type}`);\n    }\n\n    data.first = false;\n  }\n\n  if (characterClassItem.negative && data.maybeIncludesStrings) {\n    throw new SyntaxError('Cannot negate set containing strings');\n  }\n\n  return data;\n};\n\nconst processCharacterClass = function (characterClassItem, regenerateOptions) {\n  let computed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : computeCharacterClass(characterClassItem, regenerateOptions);\n  const negative = characterClassItem.negative;\n  const {\n    singleChars,\n    transformed,\n    longStrings\n  } = computed;\n\n  if (transformed) {\n    const setStr = singleChars.toString(regenerateOptions);\n\n    if (negative) {\n      if (config.useUnicodeFlag) {\n        update(characterClassItem, `[^${setStr[0] === '[' ? setStr.slice(1, -1) : setStr}]`);\n      } else {\n        update(characterClassItem, `(?!${setStr})[\\\\s\\\\S]`);\n      }\n    } else {\n      const hasEmptyString = longStrings.has('');\n      const pieces = Array.from(longStrings).sort((a, b) => b.length - a.length);\n\n      if (setStr !== '[]' || longStrings.size === 0) {\n        pieces.splice(pieces.length - (hasEmptyString ? 1 : 0), 0, setStr);\n      }\n\n      update(characterClassItem, pieces.join('|'));\n    }\n  }\n\n  return characterClassItem;\n};\n\nconst assertNoUnmatchedReferences = groups => {\n  const unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\n  if (unmatchedReferencesNames.length > 0) {\n    throw new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n  }\n};\n\nconst processTerm = (item, regenerateOptions, groups) => {\n  switch (item.type) {\n    case 'dot':\n      if (config.transform.unicodeFlag) {\n        update(item, getUnicodeDotSet(config.flags.dotAll).toString(regenerateOptions));\n      } else if (config.transform.dotAllFlag) {\n        // TODO: consider changing this at the regenerate level.\n        update(item, '[\\\\s\\\\S]');\n      }\n\n      break;\n\n    case 'characterClass':\n      item = processCharacterClass(item, regenerateOptions);\n      break;\n\n    case 'unicodePropertyEscape':\n      const data = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n\n      if (data.maybeIncludesStrings) {\n        if (!config.flags.unicodeSets) {\n          throw new Error('Properties of strings are only supported when using the unicodeSets (v) flag.');\n        }\n\n        if (config.transform.unicodeSetsFlag) {\n          data.transformed = true;\n          item = processCharacterClass(item, regenerateOptions, data);\n        }\n      } else if (config.transform.unicodePropertyEscapes) {\n        update(item, data.singleChars.toString(regenerateOptions));\n      }\n\n      break;\n\n    case 'characterClassEscape':\n      if (config.transform.unicodeFlag) {\n        update(item, getCharacterClassEscapeSet(item.value,\n        /* config.transform.unicodeFlag implies config.flags.unicode */\n        true, config.flags.ignoreCase).toString(regenerateOptions));\n      }\n\n      break;\n\n    case 'group':\n      if (item.behavior == 'normal') {\n        groups.lastIndex++;\n      }\n\n      if (item.name) {\n        const name = item.name.value;\n\n        if (groups.namesConflicts[name]) {\n          throw new Error(`Group '${name}' has already been defined in this context.`);\n        }\n\n        groups.namesConflicts[name] = true;\n\n        if (config.transform.namedGroups) {\n          delete item.name;\n        }\n\n        const index = groups.lastIndex;\n\n        if (!groups.names[name]) {\n          groups.names[name] = [];\n        }\n\n        groups.names[name].push(index);\n\n        if (groups.onNamedGroup) {\n          groups.onNamedGroup.call(null, name, index);\n        }\n\n        if (groups.unmatchedReferences[name]) {\n          delete groups.unmatchedReferences[name];\n        }\n      }\n\n    /* falls through */\n\n    case 'quantifier':\n      item.body = item.body.map(term => {\n        return processTerm(term, regenerateOptions, groups);\n      });\n      break;\n\n    case 'disjunction':\n      const outerNamesConflicts = groups.namesConflicts;\n      item.body = item.body.map(term => {\n        groups.namesConflicts = Object.create(outerNamesConflicts);\n        return processTerm(term, regenerateOptions, groups);\n      });\n      break;\n\n    case 'alternative':\n      item.body = flatMap(item.body, term => {\n        const res = processTerm(term, regenerateOptions, groups); // Alternatives cannot contain alternatives; flatten them.\n\n        return res.type === 'alternative' ? res.body : res;\n      });\n      break;\n\n    case 'value':\n      const codePoint = item.codePoint;\n      const set = regenerate(codePoint);\n\n      if (config.flags.ignoreCase && config.transform.unicodeFlag) {\n        const folded = caseFold(codePoint);\n\n        if (folded) {\n          set.add(folded);\n        }\n      }\n\n      update(item, set.toString(regenerateOptions));\n      break;\n\n    case 'reference':\n      if (item.name) {\n        const name = item.name.value;\n        const indexes = groups.names[name];\n\n        if (!indexes) {\n          groups.unmatchedReferences[name] = true;\n        }\n\n        if (config.transform.namedGroups) {\n          if (indexes) {\n            const body = indexes.map(index => ({\n              'type': 'reference',\n              'matchIndex': index,\n              'raw': '\\\\' + index\n            }));\n\n            if (body.length === 1) {\n              return body[0];\n            }\n\n            return {\n              'type': 'alternative',\n              'body': body,\n              'raw': body.map(term => term.raw).join('')\n            };\n          } // This named reference comes before the group where it’s defined,\n          // so it’s always an empty match.\n\n\n          return {\n            'type': 'group',\n            'behavior': 'ignore',\n            'body': [],\n            'raw': '(?:)'\n          };\n        }\n      }\n\n      break;\n\n    case 'anchor':\n    case 'empty':\n    case 'group':\n      // Nothing to do here.\n      break;\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(`Unknown term type: ${item.type}`);\n  }\n\n  return item;\n};\n\nconst config = {\n  'flags': {\n    'ignoreCase': false,\n    'unicode': false,\n    'unicodeSets': false,\n    'dotAll': false\n  },\n  'transform': {\n    'dotAllFlag': false,\n    'unicodeFlag': false,\n    'unicodeSetsFlag': false,\n    'unicodePropertyEscapes': false,\n    'namedGroups': false\n  },\n\n  get useUnicodeFlag() {\n    return (this.flags.unicode || this.flags.unicodeSets) && !this.transform.unicodeFlag;\n  }\n\n};\n\nconst validateOptions = options => {\n  if (!options) return;\n\n  for (const key of Object.keys(options)) {\n    const value = options[key];\n\n    switch (key) {\n      case 'dotAllFlag':\n      case 'unicodeFlag':\n      case 'unicodePropertyEscapes':\n      case 'namedGroups':\n        if (value != null && value !== false && value !== 'transform') {\n          throw new Error(`.${key} must be false (default) or 'transform'.`);\n        }\n\n        break;\n\n      case 'unicodeSetsFlag':\n        if (value != null && value !== false && value !== 'parse' && value !== 'transform') {\n          throw new Error(`.${key} must be false (default), 'parse' or 'transform'.`);\n        }\n\n        break;\n\n      case 'onNamedGroup':\n        if (value != null && typeof value !== 'function') {\n          throw new Error('.onNamedGroup must be a function.');\n        }\n\n        break;\n\n      default:\n        throw new Error(`.${key} is not a valid regexpu-core option.`);\n    }\n  }\n};\n\nconst hasFlag = (flags, flag) => flags ? flags.includes(flag) : false;\n\nconst transform = (options, name) => options ? options[name] === 'transform' : false;\n\nconst rewritePattern = (pattern, flags, options) => {\n  validateOptions(options);\n  config.flags.unicode = hasFlag(flags, 'u');\n  config.flags.unicodeSets = hasFlag(flags, 'v');\n  config.flags.ignoreCase = hasFlag(flags, 'i');\n  config.flags.dotAll = hasFlag(flags, 's');\n  config.transform.dotAllFlag = config.flags.dotAll && transform(options, 'dotAllFlag');\n  config.transform.unicodeFlag = (config.flags.unicode || config.flags.unicodeSets) && transform(options, 'unicodeFlag');\n  config.transform.unicodeSetsFlag = config.flags.unicodeSets && transform(options, 'unicodeSetsFlag'); // unicodeFlag: 'transform' implies unicodePropertyEscapes: 'transform'\n\n  config.transform.unicodePropertyEscapes = config.flags.unicode && (transform(options, 'unicodeFlag') || transform(options, 'unicodePropertyEscapes'));\n  config.transform.namedGroups = transform(options, 'namedGroups');\n  const regjsparserFeatures = {\n    'unicodeSet': Boolean(options && options.unicodeSetsFlag),\n    // Enable every stable RegExp feature by default\n    'unicodePropertyEscape': true,\n    'namedGroups': true,\n    'lookbehind': true\n  };\n  const regenerateOptions = {\n    'hasUnicodeFlag': config.useUnicodeFlag,\n    'bmpOnly': !config.flags.unicode\n  };\n  const groups = {\n    'onNamedGroup': options && options.onNamedGroup,\n    'lastIndex': 0,\n    'names': Object.create(null),\n    // { [name]: Array<index> }\n    'namesConflicts': Object.create(null),\n    // { [name]: true }\n    'unmatchedReferences': Object.create(null) // { [name]: true }\n\n  };\n  const tree = parse(pattern, flags, regjsparserFeatures); // Note: `processTerm` mutates `tree` and `groups`.\n\n  processTerm(tree, regenerateOptions, groups);\n  assertNoUnmatchedReferences(groups);\n  return generate(tree);\n};\n\nmodule.exports = rewritePattern;","map":{"version":3,"names":["generate","require","parse","regenerate","unicodeMatchProperty","unicodeMatchPropertyValue","iuMappings","ESCAPE_SETS","flatMap","array","callback","result","forEach","item","res","Array","isArray","push","apply","SPECIAL_CHARS","UNICODE_SET","addRange","DOT_SET_UNICODE","clone","remove","getCharacterClassEscapeSet","character","unicode","ignoreCase","UNICODE_IGNORE_CASE","get","UNICODE","REGULAR","getUnicodeDotSet","dotAll","getUnicodePropertyValueSet","property","value","path","exception","Error","handleLoneUnicodePropertyNameOrValue","category","getUnicodePropertyEscapeSet","isNegative","parts","split","firstPart","set","length","strings","characters","Set","map","str","replace","getUnicodePropertyEscapeCharacterClassData","data","getCharacterClassEmptyData","singleChars","size","longStrings","maybeIncludesStrings","prototype","iuAddRange","min","max","$this","folded","caseFold","add","iuRemoveRange","update","pattern","tree","config","useUnicodeFlag","type","wrap","Object","assign","codePoint","buildHandler","action","single","cp","regSet","set2","range","start","end","iuRange","nested","nestedData","contains","removeRange","first","intersection","clear","has","delete","characterClassItem","kind","transformed","transform","unicodeFlag","hasEmptyString","maybeFold","flags","computeClassStrings","classStrings","regenerateOptions","string","stringifiedString","ch","toString","join","computeCharacterClass","handlePositive","handleNegative","body","negative","unicodePropertyEscapes","unicodeSetsFlag","handler","SyntaxError","processCharacterClass","computed","setStr","slice","pieces","from","sort","a","b","splice","assertNoUnmatchedReferences","groups","unmatchedReferencesNames","keys","unmatchedReferences","processTerm","dotAllFlag","unicodeSets","behavior","lastIndex","name","namesConflicts","namedGroups","index","names","onNamedGroup","call","term","outerNamesConflicts","create","indexes","raw","validateOptions","options","key","hasFlag","flag","includes","rewritePattern","regjsparserFeatures","Boolean","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/regexpu-core/rewrite-pattern.js"],"sourcesContent":["'use strict';\n\nconst generate = require('regjsgen').generate;\nconst parse = require('regjsparser').parse;\nconst regenerate = require('regenerate');\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst iuMappings = require('./data/iu-mappings.js');\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n\nfunction flatMap(array, callback) {\n\tconst result = [];\n\tarray.forEach(item => {\n\t\tconst res = callback(item);\n\t\tif (Array.isArray(res)) {\n\t\t\tresult.push.apply(result, res);\n\t\t} else {\n\t\t\tresult.push(res);\n\t\t}\n\t});\n\treturn result;\n}\n\nconst SPECIAL_CHARS = /([\\\\^$.*+?()[\\]{}|])/g;\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n\t.remove(\n\t\t// minus `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n\t\t0x000A, // Line Feed <LF>\n\t\t0x000D, // Carriage Return <CR>\n\t\t0x2028, // Line Separator <LS>\n\t\t0x2029  // Paragraph Separator <PS>\n\t);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n\tif (unicode) {\n\t\tif (ignoreCase) {\n\t\t\treturn ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n\t\t}\n\t\treturn ESCAPE_SETS.UNICODE.get(character);\n\t}\n\treturn ESCAPE_SETS.REGULAR.get(character);\n};\n\nconst getUnicodeDotSet = (dotAll) => {\n\treturn dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\n\nconst getUnicodePropertyValueSet = (property, value) => {\n\tconst path = value ?\n\t\t`${ property }/${ value }` :\n\t\t`Binary_Property/${ property }`;\n\ttry {\n\t\treturn require(`regenerate-unicode-properties/${ path }.js`);\n\t} catch (exception) {\n\t\tthrow new Error(\n\t\t\t`Failed to recognize value \\`${ value }\\` for property ` +\n\t\t\t`\\`${ property }\\`.`\n\t\t);\n\t}\n};\n\nconst handleLoneUnicodePropertyNameOrValue = (value) => {\n\t// It could be a `General_Category` value or a binary property.\n\t// Note: `unicodeMatchPropertyValue` throws on invalid values.\n\ttry {\n\t\tconst property = 'General_Category';\n\t\tconst category = unicodeMatchPropertyValue(property, value);\n\t\treturn getUnicodePropertyValueSet(property, category);\n\t} catch (exception) {}\n\t// It’s not a `General_Category` value, so check if it’s a property\n\t// of strings.\n\ttry {\n\t\treturn getUnicodePropertyValueSet('Property_of_Strings', value);\n\t} catch (exception) {}\n\t// Lastly, check if it’s a binary property of single code points.\n\t// Note: `unicodeMatchProperty` throws on invalid properties.\n\tconst property = unicodeMatchProperty(value);\n\treturn getUnicodePropertyValueSet(property);\n};\n\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n\tconst parts = value.split('=');\n\tconst firstPart = parts[0];\n\tlet set;\n\tif (parts.length == 1) {\n\t\tset = handleLoneUnicodePropertyNameOrValue(firstPart);\n\t} else {\n\t\t// The pattern consists of two parts, i.e. `Property=Value`.\n\t\tconst property = unicodeMatchProperty(firstPart);\n\t\tconst value = unicodeMatchPropertyValue(property, parts[1]);\n\t\tset = getUnicodePropertyValueSet(property, value);\n\t}\n\tif (isNegative) {\n\t\tif (set.strings) {\n\t\t\tthrow new Error('Cannot negate Unicode property of strings');\n\t\t}\n\t\treturn {\n\t\t\tcharacters: UNICODE_SET.clone().remove(set.characters),\n\t\t\tstrings: new Set()\n\t\t};\n\t}\n\treturn {\n\t\tcharacters: set.characters.clone(),\n\t\tstrings: set.strings\n\t\t\t// We need to escape strings like *️⃣ to make sure that they can be safely used in unions.\n\t\t\t? new Set(set.strings.map(str => str.replace(SPECIAL_CHARS, '\\\\$1')))\n\t\t\t: new Set()\n\t};\n};\n\nconst getUnicodePropertyEscapeCharacterClassData = (property, isNegative) => {\n\tconst set = getUnicodePropertyEscapeSet(property, isNegative);\n\tconst data = getCharacterClassEmptyData();\n\tdata.singleChars = set.characters;\n\tif (set.strings.size > 0) {\n\t\tdata.longStrings = set.strings;\n\t\tdata.maybeIncludesStrings = true;\n\t}\n\treturn data;\n};\n\n// Given a range of code points, add any case-folded code points in that range\n// to a set.\nregenerate.prototype.iuAddRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min);\n\t\tif (folded) {\n\t\t\t$this.add(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\nregenerate.prototype.iuRemoveRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min);\n\t\tif (folded) {\n\t\t\t$this.remove(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\n\nconst update = (item, pattern) => {\n\tlet tree = parse(pattern, config.useUnicodeFlag ? 'u' : '');\n\tswitch (tree.type) {\n\t\tcase 'characterClass':\n\t\tcase 'group':\n\t\tcase 'value':\n\t\t\t// No wrapping needed.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Wrap the pattern in a non-capturing group.\n\t\t\ttree = wrap(tree, pattern);\n\t}\n\tObject.assign(item, tree);\n};\n\nconst wrap = (tree, pattern) => {\n\t// Wrap the pattern in a non-capturing group.\n\treturn {\n\t\t'type': 'group',\n\t\t'behavior': 'ignore',\n\t\t'body': [tree],\n\t\t'raw': `(?:${ pattern })`\n\t};\n};\n\nconst caseFold = (codePoint) => {\n\treturn iuMappings.get(codePoint) || false;\n};\n\nconst buildHandler = (action) => {\n\tswitch (action) {\n\t\tcase 'union':\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tdata.singleChars.add(cp);\n\t\t\t\t},\n\t\t\t\tregSet: (data, set2) => {\n\t\t\t\t\tdata.singleChars.add(set2);\n\t\t\t\t},\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars.addRange(start, end);\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars.iuAddRange(start, end);\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tdata.singleChars.add(nestedData.singleChars);\n\t\t\t\t\tfor (const str of nestedData.longStrings) data.longStrings.add(str);\n\t\t\t\t\tif (nestedData.maybeIncludesStrings) data.maybeIncludesStrings = true;\n\t\t\t\t}\n\t\t\t};\n\t\tcase 'union-negative': {\n\t\t\tconst regSet = (data, set2) => {\n\t\t\t\tdata.singleChars = UNICODE_SET.clone().remove(set2).add(data.singleChars);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tconst unicode = UNICODE_SET.clone();\n\t\t\t\t\tdata.singleChars = data.singleChars.contains(cp) ? unicode : unicode.remove(cp);\n\t\t\t\t},\n\t\t\t\tregSet: regSet,\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars = UNICODE_SET.clone().removeRange(start, end).add(data.singleChars);\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars = UNICODE_SET.clone().iuRemoveRange(start, end).add(data.singleChars);\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tregSet(data, nestedData.singleChars);\n\t\t\t\t\tif (nestedData.maybeIncludesStrings) throw new Error('ASSERTION ERROR');\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcase 'intersection': {\n\t\t\tconst regSet = (data, set2) => {\n\t\t\t\tif (data.first) data.singleChars = set2;\n\t\t\t\telse data.singleChars.intersection(set2);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tdata.singleChars = data.first || data.singleChars.contains(cp) ? regenerate(cp) : regenerate();\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\tregSet: (data, set) => {\n\t\t\t\t\tregSet(data, set);\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.addRange(start, end);\n\t\t\t\t\telse data.singleChars.intersection(regenerate().addRange(start, end));\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.iuAddRange(start, end);\n\t\t\t\t\telse data.singleChars.intersection(regenerate().iuAddRange(start, end));\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tregSet(data, nestedData.singleChars);\n\n\t\t\t\t\tif (data.first) {\n\t\t\t\t\t\tdata.longStrings = nestedData.longStrings;\n\t\t\t\t\t\tdata.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const str of data.longStrings) {\n\t\t\t\t\t\t\tif (!nestedData.longStrings.has(str)) data.longStrings.delete(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!nestedData.maybeIncludesStrings) data.maybeIncludesStrings = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcase 'subtraction': {\n\t\t\tconst regSet = (data, set2) => {\n\t\t\t\tif (data.first) data.singleChars.add(set2);\n\t\t\t\telse data.singleChars.remove(set2);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tif (data.first) data.singleChars.add(cp);\n\t\t\t\t\telse data.singleChars.remove(cp);\n\t\t\t\t},\n\t\t\t\tregSet: regSet,\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.addRange(start, end);\n\t\t\t\t\telse data.singleChars.removeRange(start, end);\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.iuAddRange(start, end);\n\t\t\t\t\telse data.singleChars.iuRemoveRange(start, end);\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tregSet(data, nestedData.singleChars);\n\n\t\t\t\t\tif (data.first) {\n\t\t\t\t\t\tdata.longStrings = nestedData.longStrings;\n\t\t\t\t\t\tdata.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const str of data.longStrings) {\n\t\t\t\t\t\t\tif (nestedData.longStrings.has(str)) data.longStrings.delete(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown set action: ${ characterClassItem.kind }`);\n\t}\n};\n\nconst getCharacterClassEmptyData = () => ({\n\ttransformed: config.transform.unicodeFlag,\n\tsingleChars: regenerate(),\n\tlongStrings: new Set(),\n\thasEmptyString: false,\n\tfirst: true,\n\tmaybeIncludesStrings: false\n});\n\nconst maybeFold = (codePoint) => {\n\tif (config.flags.ignoreCase && config.transform.unicodeFlag) {\n\t\tconst folded = caseFold(codePoint);\n\t\tif (folded) {\n\t\t\treturn [codePoint, folded];\n\t\t}\n\t}\n\treturn [codePoint];\n};\n\nconst computeClassStrings = (classStrings, regenerateOptions) => {\n\tlet data = getCharacterClassEmptyData();\n\n\tfor (const string of classStrings.strings) {\n\t\tif (string.characters.length === 1) {\n\t\t\tmaybeFold(string.characters[0].codePoint).forEach((cp) => {\n\t\t\t\tdata.singleChars.add(cp);\n\t\t\t});\n\t\t} else {\n\t\t\tlet stringifiedString;\n\t\t\tif (config.flags.ignoreCase && config.transform.unicodeFlag) {\n\t\t\t\tstringifiedString = '';\n\t\t\t\tfor (const ch of string.characters) {\n\t\t\t\t\tlet set = regenerate(ch.codePoint);\n\t\t\t\t\tconst folded = caseFold(ch.codePoint);\n\t\t\t\t\tif (folded) set.add(folded);\n\t\t\t\t\tstringifiedString += set.toString(regenerateOptions);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstringifiedString = string.characters.map(ch => generate(ch)).join('')\n\t\t\t}\n\n\t\t\tdata.longStrings.add(stringifiedString);\n\t\t\tdata.maybeIncludesStrings = true;\n\t\t}\n\t}\n\n\treturn data;\n}\n\nconst computeCharacterClass = (characterClassItem, regenerateOptions) => {\n\tlet data = getCharacterClassEmptyData();\n\n\tlet handlePositive;\n\tlet handleNegative;\n\n\tswitch (characterClassItem.kind) {\n\t\tcase 'union':\n\t\t\thandlePositive = buildHandler('union');\n\t\t\thandleNegative = buildHandler('union-negative');\n\t\t\tbreak;\n\t\tcase 'intersection':\n\t\t\thandlePositive = buildHandler('intersection');\n\t\t\thandleNegative = buildHandler('subtraction');\n\t\t\tbreak;\n\t\tcase 'subtraction':\n\t\t\thandlePositive = buildHandler('subtraction');\n\t\t\thandleNegative = buildHandler('intersection');\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown character class kind: ${ characterClassItem.kind }`);\n\t}\n\n\tfor (const item of characterClassItem.body) {\n\t\tswitch (item.type) {\n\t\t\tcase 'value':\n\t\t\t\tmaybeFold(item.codePoint).forEach((cp) => {\n\t\t\t\t\thandlePositive.single(data, cp);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassRange':\n\t\t\t\tconst min = item.min.codePoint;\n\t\t\t\tconst max = item.max.codePoint;\n\t\t\t\thandlePositive.range(data, min, max);\n\t\t\t\tif (config.flags.ignoreCase && config.transform.unicodeFlag) {\n\t\t\t\t\thandlePositive.iuRange(data, min, max);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassEscape':\n\t\t\t\thandlePositive.regSet(data, getCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.flags.unicode,\n\t\t\t\t\tconfig.flags.ignoreCase\n\t\t\t\t));\n\t\t\t\tbreak;\n\t\t\tcase 'unicodePropertyEscape':\n\t\t\t\tconst nestedData = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n\t\t\t\thandlePositive.nested(data, nestedData);\n\t\t\t\tdata.transformed =\n\t\t\t\t\tdata.transformed ||\n\t\t\t\t\tconfig.transform.unicodePropertyEscapes ||\n\t\t\t\t\t(config.transform.unicodeSetsFlag && nestedData.maybeIncludesStrings);\n\t\t\t\tbreak;\n\t\t\tcase 'characterClass':\n\t\t\t\tconst handler = item.negative ? handleNegative : handlePositive;\n\t\t\t\tconst res = computeCharacterClass(item, regenerateOptions);\n\t\t\t\thandler.nested(data, res);\n\t\t\t\tdata.transformed = true;\n\t\t\t\tbreak;\n\t\t\tcase 'classStrings':\n\t\t\t\thandlePositive.nested(data, computeClassStrings(item, regenerateOptions));\n\t\t\t\tdata.transformed = true;\n\t\t\t\tbreak;\n\t\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t\t// reached. Code coverage tools should ignore it.\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t\t}\n\n\t\tdata.first = false;\n\t}\n\n\tif (characterClassItem.negative && data.maybeIncludesStrings) {\n\t\tthrow new SyntaxError('Cannot negate set containing strings');\n\t}\n\n\treturn data;\n}\n\nconst processCharacterClass = (\n\tcharacterClassItem,\n\tregenerateOptions,\n\tcomputed = computeCharacterClass(characterClassItem, regenerateOptions)\n) => {\n\tconst negative = characterClassItem.negative;\n\tconst { singleChars, transformed, longStrings } = computed;\n\tif (transformed) {\n\t\tconst setStr = singleChars.toString(regenerateOptions);\n\n\t\tif (negative) {\n\t\t\tif (config.useUnicodeFlag) {\n\t\t\t\tupdate(characterClassItem, `[^${setStr[0] === '[' ? setStr.slice(1, -1) : setStr}]`)\n\t\t\t} else {\n\t\t\t\tupdate(characterClassItem, `(?!${setStr})[\\\\s\\\\S]`)\n\t\t\t}\n\t\t} else {\n\t\t\tconst hasEmptyString = longStrings.has('');\n\t\t\tconst pieces = Array.from(longStrings).sort((a, b) => b.length - a.length);\n\n\t\t\tif (setStr !== '[]' || longStrings.size === 0) {\n\t\t\t\tpieces.splice(pieces.length - (hasEmptyString ? 1 : 0), 0, setStr);\n\t\t\t}\n\n\t\t\tupdate(characterClassItem, pieces.join('|'));\n\t\t}\n\t}\n\treturn characterClassItem;\n};\n\nconst assertNoUnmatchedReferences = (groups) => {\n\tconst unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\tif (unmatchedReferencesNames.length > 0) {\n\t\tthrow new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n\t}\n};\n\nconst processTerm = (item, regenerateOptions, groups) => {\n\tswitch (item.type) {\n\t\tcase 'dot':\n\t\t\tif (config.transform.unicodeFlag) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetUnicodeDotSet(config.flags.dotAll).toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t} else if (config.transform.dotAllFlag) {\n\t\t\t\t// TODO: consider changing this at the regenerate level.\n\t\t\t\tupdate(item, '[\\\\s\\\\S]');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClass':\n\t\t\titem = processCharacterClass(item, regenerateOptions);\n\t\t\tbreak;\n\t\tcase 'unicodePropertyEscape':\n\t\t\tconst data = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n\t\t\tif (data.maybeIncludesStrings) {\n\t\t\t\tif (!config.flags.unicodeSets) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Properties of strings are only supported when using the unicodeSets (v) flag.'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (config.transform.unicodeSetsFlag) {\n\t\t\t\t\tdata.transformed = true;\n\t\t\t\t\titem = processCharacterClass(item, regenerateOptions, data);\n\t\t\t\t}\n\t\t\t} else if (config.transform.unicodePropertyEscapes) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tdata.singleChars.toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClassEscape':\n\t\t\tif (config.transform.unicodeFlag) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetCharacterClassEscapeSet(\n\t\t\t\t\t\titem.value,\n\t\t\t\t\t\t/* config.transform.unicodeFlag implies config.flags.unicode */ true,\n\t\t\t\t\t\tconfig.flags.ignoreCase\n\t\t\t\t\t).toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'group':\n\t\t\tif (item.behavior == 'normal') {\n\t\t\t\tgroups.lastIndex++;\n\t\t\t}\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\n\t\t\t\tif (groups.namesConflicts[name]) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Group '${ name }' has already been defined in this context.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tgroups.namesConflicts[name] = true;\n\n\t\t\t\tif (config.transform.namedGroups) {\n\t\t\t\t\tdelete item.name;\n\t\t\t\t}\n\n\t\t\t\tconst index = groups.lastIndex;\n\t\t\t\tif (!groups.names[name]) {\n\t\t\t\t\tgroups.names[name] = [];\n\t\t\t\t}\n\t\t\t\tgroups.names[name].push(index);\n\n\t\t\t\tif (groups.onNamedGroup) {\n\t\t\t\t\tgroups.onNamedGroup.call(null, name, index);\n\t\t\t\t}\n\n\t\t\t\tif (groups.unmatchedReferences[name]) {\n\t\t\t\t\tdelete groups.unmatchedReferences[name];\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* falls through */\n\t\tcase 'quantifier':\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'disjunction':\n\t\t\tconst outerNamesConflicts = groups.namesConflicts;\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\tgroups.namesConflicts = Object.create(outerNamesConflicts);\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'alternative':\n\t\t\titem.body = flatMap(item.body, term => {\n\t\t\t\tconst res = processTerm(term, regenerateOptions, groups);\n\t\t\t\t// Alternatives cannot contain alternatives; flatten them.\n\t\t\t\treturn res.type === 'alternative' ? res.body : res;\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'value':\n\t\t\tconst codePoint = item.codePoint;\n\t\t\tconst set = regenerate(codePoint);\n\t\t\tif (config.flags.ignoreCase && config.transform.unicodeFlag) {\n\t\t\t\tconst folded = caseFold(codePoint);\n\t\t\t\tif (folded) {\n\t\t\t\t\tset.add(folded);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate(item, set.toString(regenerateOptions));\n\t\t\tbreak;\n\t\tcase 'reference':\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\t\t\t\tconst indexes = groups.names[name];\n\t\t\t\tif (!indexes) {\n\t\t\t\t\tgroups.unmatchedReferences[name] = true;\n\t\t\t\t}\n\n\t\t\t\tif (config.transform.namedGroups) {\n\t\t\t\t\tif (indexes) {\n\t\t\t\t\t\tconst body = indexes.map(index => ({\n\t\t\t\t\t\t\t'type': 'reference',\n\t\t\t\t\t\t\t'matchIndex': index,\n\t\t\t\t\t\t\t'raw': '\\\\' + index,\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tif (body.length === 1) {\n\t\t\t\t\t\t\treturn body[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t'type': 'alternative',\n\t\t\t\t\t\t\t'body': body,\n\t\t\t\t\t\t\t'raw': body.map(term => term.raw).join(''),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// This named reference comes before the group where it’s defined,\n\t\t\t\t\t// so it’s always an empty match.\n\t\t\t\t\treturn {\n\t\t\t\t\t\t'type': 'group',\n\t\t\t\t\t\t'behavior': 'ignore',\n\t\t\t\t\t\t'body': [],\n\t\t\t\t\t\t'raw': '(?:)',\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'anchor':\n\t\tcase 'empty':\n\t\tcase 'group':\n\t\t\t// Nothing to do here.\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t}\n\treturn item;\n};\n\nconst config = {\n\t'flags': {\n\t\t'ignoreCase': false,\n\t\t'unicode': false,\n\t\t'unicodeSets': false,\n\t\t'dotAll': false,\n\t},\n\t'transform': {\n\t\t'dotAllFlag': false,\n\t\t'unicodeFlag': false,\n\t\t'unicodeSetsFlag': false,\n\t\t'unicodePropertyEscapes': false,\n\t\t'namedGroups': false,\n\t},\n\tget useUnicodeFlag() {\n\t\treturn (this.flags.unicode || this.flags.unicodeSets) && !this.transform.unicodeFlag;\n\t}\n};\n\nconst validateOptions = (options) => {\n\tif (!options) return;\n\n\tfor (const key of Object.keys(options)) {\n\t\tconst value = options[key];\n\t\tswitch (key) {\n\t\t\tcase 'dotAllFlag':\n\t\t\tcase 'unicodeFlag':\n\t\t\tcase 'unicodePropertyEscapes':\n\t\t\tcase 'namedGroups':\n\t\t\t\tif (value != null && value !== false && value !== 'transform') {\n\t\t\t\t\tthrow new Error(`.${key} must be false (default) or 'transform'.`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'unicodeSetsFlag':\n\t\t\t\tif (value != null && value !== false && value !== 'parse' && value !== 'transform') {\n\t\t\t\t\tthrow new Error(`.${key} must be false (default), 'parse' or 'transform'.`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'onNamedGroup':\n\t\t\t\tif (value != null && typeof value !== 'function') {\n\t\t\t\t\tthrow new Error('.onNamedGroup must be a function.');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`.${key} is not a valid regexpu-core option.`);\n\t\t}\n\t}\n};\n\nconst hasFlag = (flags, flag) => flags ? flags.includes(flag) : false;\nconst transform = (options, name) => options ? options[name] === 'transform' : false;\n\nconst rewritePattern = (pattern, flags, options) => {\n\tvalidateOptions(options);\n\n\tconfig.flags.unicode = hasFlag(flags, 'u');\n\tconfig.flags.unicodeSets = hasFlag(flags, 'v');\n\tconfig.flags.ignoreCase = hasFlag(flags, 'i');\n\tconfig.flags.dotAll = hasFlag(flags, 's');\n\n\tconfig.transform.dotAllFlag = config.flags.dotAll && transform(options, 'dotAllFlag');\n\tconfig.transform.unicodeFlag = (config.flags.unicode || config.flags.unicodeSets) && transform(options, 'unicodeFlag');\n\tconfig.transform.unicodeSetsFlag = config.flags.unicodeSets && transform(options, 'unicodeSetsFlag');\n\n\t// unicodeFlag: 'transform' implies unicodePropertyEscapes: 'transform'\n\tconfig.transform.unicodePropertyEscapes = config.flags.unicode && (\n\t\ttransform(options, 'unicodeFlag') || transform(options, 'unicodePropertyEscapes')\n\t);\n\tconfig.transform.namedGroups = transform(options, 'namedGroups');\n\n\tconst regjsparserFeatures = {\n\t\t'unicodeSet': Boolean(options && options.unicodeSetsFlag),\n\n\t\t// Enable every stable RegExp feature by default\n\t\t'unicodePropertyEscape': true,\n\t\t'namedGroups': true,\n\t\t'lookbehind': true,\n\t};\n\n\tconst regenerateOptions = {\n\t\t'hasUnicodeFlag': config.useUnicodeFlag,\n\t\t'bmpOnly': !config.flags.unicode\n\t};\n\n\tconst groups = {\n\t\t'onNamedGroup': options && options.onNamedGroup,\n\t\t'lastIndex': 0,\n\t\t'names': Object.create(null), // { [name]: Array<index> }\n\t\t'namesConflicts': Object.create(null), // { [name]: true }\n\t\t'unmatchedReferences': Object.create(null) // { [name]: true }\n\t};\n\n\tconst tree = parse(pattern, flags, regjsparserFeatures);\n\t// Note: `processTerm` mutates `tree` and `groups`.\n\tprocessTerm(tree, regenerateOptions, groups);\n\tassertNoUnmatchedReferences(groups);\n\treturn generate(tree);\n};\n\nmodule.exports = rewritePattern;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}