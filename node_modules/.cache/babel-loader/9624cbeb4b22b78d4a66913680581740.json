{"ast":null,"code":"'use strict';\n\nconst valueParser = require('postcss-value-parser');\n/**\n * @param {(number|string)[]} list\n * @param {valueParser.Node} node\n * @param {number} index\n * @return {(number|string)[]}\n */\n\n\nfunction getValues(list, node, index) {\n  if (index % 2 === 0) {\n    /** @type {number|string} */\n    let value = NaN;\n\n    if (node.type === 'function' && (node.value === 'var' || node.value === 'env') && node.nodes.length === 1) {\n      value = valueParser.stringify(node.nodes);\n    } else if (node.type === 'word') {\n      value = parseFloat(node.value);\n    }\n\n    return [...list, value];\n  }\n\n  return list;\n}\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\n\n\nfunction matrix3d(node, values) {\n  if (values.length !== 16) {\n    return;\n  } // matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1) => matrix(a, b, c, d, tx, ty)\n\n\n  if (values[15] && values[2] === 0 && values[3] === 0 && values[6] === 0 && values[7] === 0 && values[8] === 0 && values[9] === 0 && values[10] === 1 && values[11] === 0 && values[14] === 0 && values[15] === 1) {\n    const {\n      nodes\n    } = node;\n    node.value = 'matrix';\n    node.nodes = [nodes[0], // a\n    nodes[1], // ,\n    nodes[2], // b\n    nodes[3], // ,\n    nodes[8], // c\n    nodes[9], // ,\n    nodes[10], // d\n    nodes[11], // ,\n    nodes[24], // tx\n    nodes[25], // ,\n    nodes[26] // ty\n    ];\n  }\n}\n\nconst rotate3dMappings = new Map([[[1, 0, 0].toString(), 'rotateX'], // rotate3d(1, 0, 0, a) => rotateX(a)\n[[0, 1, 0].toString(), 'rotateY'], // rotate3d(0, 1, 0, a) => rotateY(a)\n[[0, 0, 1].toString(), 'rotate'] // rotate3d(0, 0, 1, a) => rotate(a)\n]);\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\n\nfunction rotate3d(node, values) {\n  if (values.length !== 4) {\n    return;\n  }\n\n  const {\n    nodes\n  } = node;\n  const match = rotate3dMappings.get(values.slice(0, 3).toString());\n\n  if (match) {\n    node.value = match;\n    node.nodes = [nodes[6]];\n  }\n}\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\n\n\nfunction rotateZ(node, values) {\n  if (values.length !== 1) {\n    return;\n  } // rotateZ(rz) => rotate(rz)\n\n\n  node.value = 'rotate';\n}\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\n\n\nfunction scale(node, values) {\n  if (values.length !== 2) {\n    return;\n  }\n\n  const {\n    nodes\n  } = node;\n  const [first, second] = values; // scale(sx, sy) => scale(sx)\n\n  if (first === second) {\n    node.nodes = [nodes[0]];\n    return;\n  } // scale(sx, 1) => scaleX(sx)\n\n\n  if (second === 1) {\n    node.value = 'scaleX';\n    node.nodes = [nodes[0]];\n    return;\n  } // scale(1, sy) => scaleY(sy)\n\n\n  if (first === 1) {\n    node.value = 'scaleY';\n    node.nodes = [nodes[2]];\n    return;\n  }\n}\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\n\n\nfunction scale3d(node, values) {\n  if (values.length !== 3) {\n    return;\n  }\n\n  const {\n    nodes\n  } = node;\n  const [first, second, third] = values; // scale3d(sx, 1, 1) => scaleX(sx)\n\n  if (second === 1 && third === 1) {\n    node.value = 'scaleX';\n    node.nodes = [nodes[0]];\n    return;\n  } // scale3d(1, sy, 1) => scaleY(sy)\n\n\n  if (first === 1 && third === 1) {\n    node.value = 'scaleY';\n    node.nodes = [nodes[2]];\n    return;\n  } // scale3d(1, 1, sz) => scaleZ(sz)\n\n\n  if (first === 1 && second === 1) {\n    node.value = 'scaleZ';\n    node.nodes = [nodes[4]];\n    return;\n  }\n}\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\n\n\nfunction translate(node, values) {\n  if (values.length !== 2) {\n    return;\n  }\n\n  const {\n    nodes\n  } = node; // translate(tx, 0) => translate(tx)\n\n  if (values[1] === 0) {\n    node.nodes = [nodes[0]];\n    return;\n  } // translate(0, ty) => translateY(ty)\n\n\n  if (values[0] === 0) {\n    node.value = 'translateY';\n    node.nodes = [nodes[2]];\n    return;\n  }\n}\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\n\n\nfunction translate3d(node, values) {\n  if (values.length !== 3) {\n    return;\n  }\n\n  const {\n    nodes\n  } = node; // translate3d(0, 0, tz) => translateZ(tz)\n\n  if (values[0] === 0 && values[1] === 0) {\n    node.value = 'translateZ';\n    node.nodes = [nodes[4]];\n  }\n}\n\nconst reducers = new Map([['matrix3d', matrix3d], ['rotate3d', rotate3d], ['rotateZ', rotateZ], ['scale', scale], ['scale3d', scale3d], ['translate', translate], ['translate3d', translate3d]]);\n/**\n * @param {string} name\n * @return {string}\n */\n\nfunction normalizeReducerName(name) {\n  const lowerCasedName = name.toLowerCase();\n\n  if (lowerCasedName === 'rotatez') {\n    return 'rotateZ';\n  }\n\n  return lowerCasedName;\n}\n/**\n * @param {valueParser.Node} node\n * @return {false}\n */\n\n\nfunction reduce(node) {\n  if (node.type === 'function') {\n    const normalizedReducerName = normalizeReducerName(node.value);\n    const reducer = reducers.get(normalizedReducerName);\n\n    if (reducer !== undefined) {\n      reducer(node, node.nodes.reduce(getValues, []));\n    }\n  }\n\n  return false;\n}\n/**\n * @type {import('postcss').PluginCreator<void>}\n * @return {import('postcss').Plugin}\n */\n\n\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-reduce-transforms',\n\n    prepare() {\n      const cache = new Map();\n      return {\n        OnceExit(css) {\n          css.walkDecls(/transform$/i, decl => {\n            const value = decl.value;\n\n            if (!value) {\n              return;\n            }\n\n            if (cache.has(value)) {\n              decl.value = cache.get(value);\n              return;\n            }\n\n            const result = valueParser(value).walk(reduce).toString();\n            decl.value = result;\n            cache.set(value, result);\n          });\n        }\n\n      };\n    }\n\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;","map":{"version":3,"names":["valueParser","require","getValues","list","node","index","value","NaN","type","nodes","length","stringify","parseFloat","matrix3d","values","rotate3dMappings","Map","toString","rotate3d","match","get","slice","rotateZ","scale","first","second","scale3d","third","translate","translate3d","reducers","normalizeReducerName","name","lowerCasedName","toLowerCase","reduce","normalizedReducerName","reducer","undefined","pluginCreator","postcssPlugin","prepare","cache","OnceExit","css","walkDecls","decl","has","result","walk","set","postcss","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-reduce-transforms/src/index.js"],"sourcesContent":["'use strict';\nconst valueParser = require('postcss-value-parser');\n\n/**\n * @param {(number|string)[]} list\n * @param {valueParser.Node} node\n * @param {number} index\n * @return {(number|string)[]}\n */\nfunction getValues(list, node, index) {\n  if (index % 2 === 0) {\n    /** @type {number|string} */\n    let value = NaN;\n\n    if (\n      node.type === 'function' &&\n      (node.value === 'var' || node.value === 'env') &&\n      node.nodes.length === 1\n    ) {\n      value = valueParser.stringify(node.nodes);\n    } else if (node.type === 'word') {\n      value = parseFloat(node.value);\n    }\n\n    return [...list, value];\n  }\n\n  return list;\n}\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction matrix3d(node, values) {\n  if (values.length !== 16) {\n    return;\n  }\n\n  // matrix3d(a, b, 0, 0, c, d, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1) => matrix(a, b, c, d, tx, ty)\n  if (\n    values[15] &&\n    values[2] === 0 &&\n    values[3] === 0 &&\n    values[6] === 0 &&\n    values[7] === 0 &&\n    values[8] === 0 &&\n    values[9] === 0 &&\n    values[10] === 1 &&\n    values[11] === 0 &&\n    values[14] === 0 &&\n    values[15] === 1\n  ) {\n    const { nodes } = node;\n\n    node.value = 'matrix';\n    node.nodes = [\n      nodes[0], // a\n      nodes[1], // ,\n      nodes[2], // b\n      nodes[3], // ,\n      nodes[8], // c\n      nodes[9], // ,\n      nodes[10], // d\n      nodes[11], // ,\n      nodes[24], // tx\n      nodes[25], // ,\n      nodes[26], // ty\n    ];\n  }\n}\n\nconst rotate3dMappings = new Map([\n  [[1, 0, 0].toString(), 'rotateX'], // rotate3d(1, 0, 0, a) => rotateX(a)\n  [[0, 1, 0].toString(), 'rotateY'], // rotate3d(0, 1, 0, a) => rotateY(a)\n  [[0, 0, 1].toString(), 'rotate'], // rotate3d(0, 0, 1, a) => rotate(a)\n]);\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction rotate3d(node, values) {\n  if (values.length !== 4) {\n    return;\n  }\n\n  const { nodes } = node;\n  const match = rotate3dMappings.get(values.slice(0, 3).toString());\n\n  if (match) {\n    node.value = match;\n    node.nodes = [nodes[6]];\n  }\n}\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction rotateZ(node, values) {\n  if (values.length !== 1) {\n    return;\n  }\n\n  // rotateZ(rz) => rotate(rz)\n  node.value = 'rotate';\n}\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction scale(node, values) {\n  if (values.length !== 2) {\n    return;\n  }\n\n  const { nodes } = node;\n  const [first, second] = values;\n\n  // scale(sx, sy) => scale(sx)\n  if (first === second) {\n    node.nodes = [nodes[0]];\n\n    return;\n  }\n\n  // scale(sx, 1) => scaleX(sx)\n  if (second === 1) {\n    node.value = 'scaleX';\n    node.nodes = [nodes[0]];\n\n    return;\n  }\n\n  // scale(1, sy) => scaleY(sy)\n  if (first === 1) {\n    node.value = 'scaleY';\n    node.nodes = [nodes[2]];\n\n    return;\n  }\n}\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction scale3d(node, values) {\n  if (values.length !== 3) {\n    return;\n  }\n\n  const { nodes } = node;\n  const [first, second, third] = values;\n\n  // scale3d(sx, 1, 1) => scaleX(sx)\n  if (second === 1 && third === 1) {\n    node.value = 'scaleX';\n    node.nodes = [nodes[0]];\n\n    return;\n  }\n\n  // scale3d(1, sy, 1) => scaleY(sy)\n  if (first === 1 && third === 1) {\n    node.value = 'scaleY';\n    node.nodes = [nodes[2]];\n\n    return;\n  }\n\n  // scale3d(1, 1, sz) => scaleZ(sz)\n  if (first === 1 && second === 1) {\n    node.value = 'scaleZ';\n    node.nodes = [nodes[4]];\n\n    return;\n  }\n}\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction translate(node, values) {\n  if (values.length !== 2) {\n    return;\n  }\n\n  const { nodes } = node;\n\n  // translate(tx, 0) => translate(tx)\n  if (values[1] === 0) {\n    node.nodes = [nodes[0]];\n\n    return;\n  }\n\n  // translate(0, ty) => translateY(ty)\n  if (values[0] === 0) {\n    node.value = 'translateY';\n    node.nodes = [nodes[2]];\n\n    return;\n  }\n}\n\n/**\n * @param {valueParser.FunctionNode} node\n * @param {(number|string)[]} values\n * @return {void}\n */\nfunction translate3d(node, values) {\n  if (values.length !== 3) {\n    return;\n  }\n\n  const { nodes } = node;\n\n  // translate3d(0, 0, tz) => translateZ(tz)\n  if (values[0] === 0 && values[1] === 0) {\n    node.value = 'translateZ';\n    node.nodes = [nodes[4]];\n  }\n}\n\nconst reducers = new Map([\n  ['matrix3d', matrix3d],\n  ['rotate3d', rotate3d],\n  ['rotateZ', rotateZ],\n  ['scale', scale],\n  ['scale3d', scale3d],\n  ['translate', translate],\n  ['translate3d', translate3d],\n]);\n/**\n * @param {string} name\n * @return {string}\n */\nfunction normalizeReducerName(name) {\n  const lowerCasedName = name.toLowerCase();\n\n  if (lowerCasedName === 'rotatez') {\n    return 'rotateZ';\n  }\n\n  return lowerCasedName;\n}\n\n/**\n * @param {valueParser.Node} node\n * @return {false}\n */\nfunction reduce(node) {\n  if (node.type === 'function') {\n    const normalizedReducerName = normalizeReducerName(node.value);\n    const reducer = reducers.get(normalizedReducerName);\n    if (reducer !== undefined) {\n      reducer(node, node.nodes.reduce(getValues, []));\n    }\n  }\n  return false;\n}\n\n/**\n * @type {import('postcss').PluginCreator<void>}\n * @return {import('postcss').Plugin}\n */\nfunction pluginCreator() {\n  return {\n    postcssPlugin: 'postcss-reduce-transforms',\n    prepare() {\n      const cache = new Map();\n      return {\n        OnceExit(css) {\n          css.walkDecls(/transform$/i, (decl) => {\n            const value = decl.value;\n\n            if (!value) {\n              return;\n            }\n\n            if (cache.has(value)) {\n              decl.value = cache.get(value);\n\n              return;\n            }\n\n            const result = valueParser(value).walk(reduce).toString();\n\n            decl.value = result;\n            cache.set(value, result);\n          });\n        },\n      };\n    },\n  };\n}\n\npluginCreator.postcss = true;\nmodule.exports = pluginCreator;\n"],"mappings":"AAAA;;AACA,MAAMA,WAAW,GAAGC,OAAO,CAAC,sBAAD,CAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,SAAT,CAAmBC,IAAnB,EAAyBC,IAAzB,EAA+BC,KAA/B,EAAsC;EACpC,IAAIA,KAAK,GAAG,CAAR,KAAc,CAAlB,EAAqB;IACnB;IACA,IAAIC,KAAK,GAAGC,GAAZ;;IAEA,IACEH,IAAI,CAACI,IAAL,KAAc,UAAd,KACCJ,IAAI,CAACE,KAAL,KAAe,KAAf,IAAwBF,IAAI,CAACE,KAAL,KAAe,KADxC,KAEAF,IAAI,CAACK,KAAL,CAAWC,MAAX,KAAsB,CAHxB,EAIE;MACAJ,KAAK,GAAGN,WAAW,CAACW,SAAZ,CAAsBP,IAAI,CAACK,KAA3B,CAAR;IACD,CAND,MAMO,IAAIL,IAAI,CAACI,IAAL,KAAc,MAAlB,EAA0B;MAC/BF,KAAK,GAAGM,UAAU,CAACR,IAAI,CAACE,KAAN,CAAlB;IACD;;IAED,OAAO,CAAC,GAAGH,IAAJ,EAAUG,KAAV,CAAP;EACD;;EAED,OAAOH,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASU,QAAT,CAAkBT,IAAlB,EAAwBU,MAAxB,EAAgC;EAC9B,IAAIA,MAAM,CAACJ,MAAP,KAAkB,EAAtB,EAA0B;IACxB;EACD,CAH6B,CAK9B;;;EACA,IACEI,MAAM,CAAC,EAAD,CAAN,IACAA,MAAM,CAAC,CAAD,CAAN,KAAc,CADd,IAEAA,MAAM,CAAC,CAAD,CAAN,KAAc,CAFd,IAGAA,MAAM,CAAC,CAAD,CAAN,KAAc,CAHd,IAIAA,MAAM,CAAC,CAAD,CAAN,KAAc,CAJd,IAKAA,MAAM,CAAC,CAAD,CAAN,KAAc,CALd,IAMAA,MAAM,CAAC,CAAD,CAAN,KAAc,CANd,IAOAA,MAAM,CAAC,EAAD,CAAN,KAAe,CAPf,IAQAA,MAAM,CAAC,EAAD,CAAN,KAAe,CARf,IASAA,MAAM,CAAC,EAAD,CAAN,KAAe,CATf,IAUAA,MAAM,CAAC,EAAD,CAAN,KAAe,CAXjB,EAYE;IACA,MAAM;MAAEL;IAAF,IAAYL,IAAlB;IAEAA,IAAI,CAACE,KAAL,GAAa,QAAb;IACAF,IAAI,CAACK,KAAL,GAAa,CACXA,KAAK,CAAC,CAAD,CADM,EACD;IACVA,KAAK,CAAC,CAAD,CAFM,EAED;IACVA,KAAK,CAAC,CAAD,CAHM,EAGD;IACVA,KAAK,CAAC,CAAD,CAJM,EAID;IACVA,KAAK,CAAC,CAAD,CALM,EAKD;IACVA,KAAK,CAAC,CAAD,CANM,EAMD;IACVA,KAAK,CAAC,EAAD,CAPM,EAOA;IACXA,KAAK,CAAC,EAAD,CARM,EAQA;IACXA,KAAK,CAAC,EAAD,CATM,EASA;IACXA,KAAK,CAAC,EAAD,CAVM,EAUA;IACXA,KAAK,CAAC,EAAD,CAXM,CAWA;IAXA,CAAb;EAaD;AACF;;AAED,MAAMM,gBAAgB,GAAG,IAAIC,GAAJ,CAAQ,CAC/B,CAAC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAUC,QAAV,EAAD,EAAuB,SAAvB,CAD+B,EACI;AACnC,CAAC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAUA,QAAV,EAAD,EAAuB,SAAvB,CAF+B,EAEI;AACnC,CAAC,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAUA,QAAV,EAAD,EAAuB,QAAvB,CAH+B,CAGG;AAHH,CAAR,CAAzB;AAMA;AACA;AACA;AACA;AACA;;AACA,SAASC,QAAT,CAAkBd,IAAlB,EAAwBU,MAAxB,EAAgC;EAC9B,IAAIA,MAAM,CAACJ,MAAP,KAAkB,CAAtB,EAAyB;IACvB;EACD;;EAED,MAAM;IAAED;EAAF,IAAYL,IAAlB;EACA,MAAMe,KAAK,GAAGJ,gBAAgB,CAACK,GAAjB,CAAqBN,MAAM,CAACO,KAAP,CAAa,CAAb,EAAgB,CAAhB,EAAmBJ,QAAnB,EAArB,CAAd;;EAEA,IAAIE,KAAJ,EAAW;IACTf,IAAI,CAACE,KAAL,GAAaa,KAAb;IACAf,IAAI,CAACK,KAAL,GAAa,CAACA,KAAK,CAAC,CAAD,CAAN,CAAb;EACD;AACF;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASa,OAAT,CAAiBlB,IAAjB,EAAuBU,MAAvB,EAA+B;EAC7B,IAAIA,MAAM,CAACJ,MAAP,KAAkB,CAAtB,EAAyB;IACvB;EACD,CAH4B,CAK7B;;;EACAN,IAAI,CAACE,KAAL,GAAa,QAAb;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASiB,KAAT,CAAenB,IAAf,EAAqBU,MAArB,EAA6B;EAC3B,IAAIA,MAAM,CAACJ,MAAP,KAAkB,CAAtB,EAAyB;IACvB;EACD;;EAED,MAAM;IAAED;EAAF,IAAYL,IAAlB;EACA,MAAM,CAACoB,KAAD,EAAQC,MAAR,IAAkBX,MAAxB,CAN2B,CAQ3B;;EACA,IAAIU,KAAK,KAAKC,MAAd,EAAsB;IACpBrB,IAAI,CAACK,KAAL,GAAa,CAACA,KAAK,CAAC,CAAD,CAAN,CAAb;IAEA;EACD,CAb0B,CAe3B;;;EACA,IAAIgB,MAAM,KAAK,CAAf,EAAkB;IAChBrB,IAAI,CAACE,KAAL,GAAa,QAAb;IACAF,IAAI,CAACK,KAAL,GAAa,CAACA,KAAK,CAAC,CAAD,CAAN,CAAb;IAEA;EACD,CArB0B,CAuB3B;;;EACA,IAAIe,KAAK,KAAK,CAAd,EAAiB;IACfpB,IAAI,CAACE,KAAL,GAAa,QAAb;IACAF,IAAI,CAACK,KAAL,GAAa,CAACA,KAAK,CAAC,CAAD,CAAN,CAAb;IAEA;EACD;AACF;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASiB,OAAT,CAAiBtB,IAAjB,EAAuBU,MAAvB,EAA+B;EAC7B,IAAIA,MAAM,CAACJ,MAAP,KAAkB,CAAtB,EAAyB;IACvB;EACD;;EAED,MAAM;IAAED;EAAF,IAAYL,IAAlB;EACA,MAAM,CAACoB,KAAD,EAAQC,MAAR,EAAgBE,KAAhB,IAAyBb,MAA/B,CAN6B,CAQ7B;;EACA,IAAIW,MAAM,KAAK,CAAX,IAAgBE,KAAK,KAAK,CAA9B,EAAiC;IAC/BvB,IAAI,CAACE,KAAL,GAAa,QAAb;IACAF,IAAI,CAACK,KAAL,GAAa,CAACA,KAAK,CAAC,CAAD,CAAN,CAAb;IAEA;EACD,CAd4B,CAgB7B;;;EACA,IAAIe,KAAK,KAAK,CAAV,IAAeG,KAAK,KAAK,CAA7B,EAAgC;IAC9BvB,IAAI,CAACE,KAAL,GAAa,QAAb;IACAF,IAAI,CAACK,KAAL,GAAa,CAACA,KAAK,CAAC,CAAD,CAAN,CAAb;IAEA;EACD,CAtB4B,CAwB7B;;;EACA,IAAIe,KAAK,KAAK,CAAV,IAAeC,MAAM,KAAK,CAA9B,EAAiC;IAC/BrB,IAAI,CAACE,KAAL,GAAa,QAAb;IACAF,IAAI,CAACK,KAAL,GAAa,CAACA,KAAK,CAAC,CAAD,CAAN,CAAb;IAEA;EACD;AACF;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASmB,SAAT,CAAmBxB,IAAnB,EAAyBU,MAAzB,EAAiC;EAC/B,IAAIA,MAAM,CAACJ,MAAP,KAAkB,CAAtB,EAAyB;IACvB;EACD;;EAED,MAAM;IAAED;EAAF,IAAYL,IAAlB,CAL+B,CAO/B;;EACA,IAAIU,MAAM,CAAC,CAAD,CAAN,KAAc,CAAlB,EAAqB;IACnBV,IAAI,CAACK,KAAL,GAAa,CAACA,KAAK,CAAC,CAAD,CAAN,CAAb;IAEA;EACD,CAZ8B,CAc/B;;;EACA,IAAIK,MAAM,CAAC,CAAD,CAAN,KAAc,CAAlB,EAAqB;IACnBV,IAAI,CAACE,KAAL,GAAa,YAAb;IACAF,IAAI,CAACK,KAAL,GAAa,CAACA,KAAK,CAAC,CAAD,CAAN,CAAb;IAEA;EACD;AACF;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASoB,WAAT,CAAqBzB,IAArB,EAA2BU,MAA3B,EAAmC;EACjC,IAAIA,MAAM,CAACJ,MAAP,KAAkB,CAAtB,EAAyB;IACvB;EACD;;EAED,MAAM;IAAED;EAAF,IAAYL,IAAlB,CALiC,CAOjC;;EACA,IAAIU,MAAM,CAAC,CAAD,CAAN,KAAc,CAAd,IAAmBA,MAAM,CAAC,CAAD,CAAN,KAAc,CAArC,EAAwC;IACtCV,IAAI,CAACE,KAAL,GAAa,YAAb;IACAF,IAAI,CAACK,KAAL,GAAa,CAACA,KAAK,CAAC,CAAD,CAAN,CAAb;EACD;AACF;;AAED,MAAMqB,QAAQ,GAAG,IAAId,GAAJ,CAAQ,CACvB,CAAC,UAAD,EAAaH,QAAb,CADuB,EAEvB,CAAC,UAAD,EAAaK,QAAb,CAFuB,EAGvB,CAAC,SAAD,EAAYI,OAAZ,CAHuB,EAIvB,CAAC,OAAD,EAAUC,KAAV,CAJuB,EAKvB,CAAC,SAAD,EAAYG,OAAZ,CALuB,EAMvB,CAAC,WAAD,EAAcE,SAAd,CANuB,EAOvB,CAAC,aAAD,EAAgBC,WAAhB,CAPuB,CAAR,CAAjB;AASA;AACA;AACA;AACA;;AACA,SAASE,oBAAT,CAA8BC,IAA9B,EAAoC;EAClC,MAAMC,cAAc,GAAGD,IAAI,CAACE,WAAL,EAAvB;;EAEA,IAAID,cAAc,KAAK,SAAvB,EAAkC;IAChC,OAAO,SAAP;EACD;;EAED,OAAOA,cAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASE,MAAT,CAAgB/B,IAAhB,EAAsB;EACpB,IAAIA,IAAI,CAACI,IAAL,KAAc,UAAlB,EAA8B;IAC5B,MAAM4B,qBAAqB,GAAGL,oBAAoB,CAAC3B,IAAI,CAACE,KAAN,CAAlD;IACA,MAAM+B,OAAO,GAAGP,QAAQ,CAACV,GAAT,CAAagB,qBAAb,CAAhB;;IACA,IAAIC,OAAO,KAAKC,SAAhB,EAA2B;MACzBD,OAAO,CAACjC,IAAD,EAAOA,IAAI,CAACK,KAAL,CAAW0B,MAAX,CAAkBjC,SAAlB,EAA6B,EAA7B,CAAP,CAAP;IACD;EACF;;EACD,OAAO,KAAP;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASqC,aAAT,GAAyB;EACvB,OAAO;IACLC,aAAa,EAAE,2BADV;;IAELC,OAAO,GAAG;MACR,MAAMC,KAAK,GAAG,IAAI1B,GAAJ,EAAd;MACA,OAAO;QACL2B,QAAQ,CAACC,GAAD,EAAM;UACZA,GAAG,CAACC,SAAJ,CAAc,aAAd,EAA8BC,IAAD,IAAU;YACrC,MAAMxC,KAAK,GAAGwC,IAAI,CAACxC,KAAnB;;YAEA,IAAI,CAACA,KAAL,EAAY;cACV;YACD;;YAED,IAAIoC,KAAK,CAACK,GAAN,CAAUzC,KAAV,CAAJ,EAAsB;cACpBwC,IAAI,CAACxC,KAAL,GAAaoC,KAAK,CAACtB,GAAN,CAAUd,KAAV,CAAb;cAEA;YACD;;YAED,MAAM0C,MAAM,GAAGhD,WAAW,CAACM,KAAD,CAAX,CAAmB2C,IAAnB,CAAwBd,MAAxB,EAAgClB,QAAhC,EAAf;YAEA6B,IAAI,CAACxC,KAAL,GAAa0C,MAAb;YACAN,KAAK,CAACQ,GAAN,CAAU5C,KAAV,EAAiB0C,MAAjB;UACD,CAjBD;QAkBD;;MApBI,CAAP;IAsBD;;EA1BI,CAAP;AA4BD;;AAEDT,aAAa,CAACY,OAAd,GAAwB,IAAxB;AACAC,MAAM,CAACC,OAAP,GAAiBd,aAAjB"},"metadata":{},"sourceType":"script"}