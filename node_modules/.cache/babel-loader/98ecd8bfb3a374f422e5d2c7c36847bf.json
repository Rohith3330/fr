{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.ensure = ensure;\nexports.get = get;\nexports.getDependencies = getDependencies;\nexports.list = void 0;\nexports.minVersion = minVersion;\n\nvar _traverse = require(\"@babel/traverse\");\n\nvar _t = require(\"@babel/types\");\n\nvar _helpers = require(\"./helpers\");\n\nconst {\n  assignmentExpression,\n  cloneNode,\n  expressionStatement,\n  file,\n  identifier\n} = _t;\n\nfunction makePath(path) {\n  const parts = [];\n\n  for (; path.parentPath; path = path.parentPath) {\n    parts.push(path.key);\n    if (path.inList) parts.push(path.listKey);\n  }\n\n  return parts.reverse().join(\".\");\n}\n\nlet FileClass = undefined;\n\nfunction getHelperMetadata(file) {\n  const globals = new Set();\n  const localBindingNames = new Set();\n  const dependencies = new Map();\n  let exportName;\n  let exportPath;\n  const exportBindingAssignments = [];\n  const importPaths = [];\n  const importBindingsReferences = [];\n  const dependencyVisitor = {\n    ImportDeclaration(child) {\n      const name = child.node.source.value;\n\n      if (!_helpers.default[name]) {\n        throw child.buildCodeFrameError(`Unknown helper ${name}`);\n      }\n\n      if (child.get(\"specifiers\").length !== 1 || !child.get(\"specifiers.0\").isImportDefaultSpecifier()) {\n        throw child.buildCodeFrameError(\"Helpers can only import a default value\");\n      }\n\n      const bindingIdentifier = child.node.specifiers[0].local;\n      dependencies.set(bindingIdentifier, name);\n      importPaths.push(makePath(child));\n    },\n\n    ExportDefaultDeclaration(child) {\n      const decl = child.get(\"declaration\");\n\n      if (!decl.isFunctionDeclaration() || !decl.node.id) {\n        throw decl.buildCodeFrameError(\"Helpers can only export named function declarations\");\n      }\n\n      exportName = decl.node.id.name;\n      exportPath = makePath(child);\n    },\n\n    ExportAllDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n\n    ExportNamedDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n\n    Statement(child) {\n      if (child.isModuleDeclaration()) return;\n      child.skip();\n    }\n\n  };\n  const referenceVisitor = {\n    Program(path) {\n      const bindings = path.scope.getAllBindings();\n      Object.keys(bindings).forEach(name => {\n        if (name === exportName) return;\n        if (dependencies.has(bindings[name].identifier)) return;\n        localBindingNames.add(name);\n      });\n    },\n\n    ReferencedIdentifier(child) {\n      const name = child.node.name;\n      const binding = child.scope.getBinding(name);\n\n      if (!binding) {\n        globals.add(name);\n      } else if (dependencies.has(binding.identifier)) {\n        importBindingsReferences.push(makePath(child));\n      }\n    },\n\n    AssignmentExpression(child) {\n      const left = child.get(\"left\");\n      if (!(exportName in left.getBindingIdentifiers())) return;\n\n      if (!left.isIdentifier()) {\n        throw left.buildCodeFrameError(\"Only simple assignments to exports are allowed in helpers\");\n      }\n\n      const binding = child.scope.getBinding(exportName);\n\n      if (binding != null && binding.scope.path.isProgram()) {\n        exportBindingAssignments.push(makePath(child));\n      }\n    }\n\n  };\n  (0, _traverse.default)(file.ast, dependencyVisitor, file.scope);\n  (0, _traverse.default)(file.ast, referenceVisitor, file.scope);\n  if (!exportPath) throw new Error(\"Helpers must have a default export.\");\n  exportBindingAssignments.reverse();\n  return {\n    globals: Array.from(globals),\n    localBindingNames: Array.from(localBindingNames),\n    dependencies,\n    exportBindingAssignments,\n    exportPath,\n    exportName,\n    importBindingsReferences,\n    importPaths\n  };\n}\n\nfunction permuteHelperAST(file, metadata, id, localBindings, getDependency) {\n  if (localBindings && !id) {\n    throw new Error(\"Unexpected local bindings for module-based helpers.\");\n  }\n\n  if (!id) return;\n  const {\n    localBindingNames,\n    dependencies,\n    exportBindingAssignments,\n    exportPath,\n    exportName,\n    importBindingsReferences,\n    importPaths\n  } = metadata;\n  const dependenciesRefs = {};\n  dependencies.forEach((name, id) => {\n    dependenciesRefs[id.name] = typeof getDependency === \"function\" && getDependency(name) || id;\n  });\n  const toRename = {};\n  const bindings = new Set(localBindings || []);\n  localBindingNames.forEach(name => {\n    let newName = name;\n\n    while (bindings.has(newName)) newName = \"_\" + newName;\n\n    if (newName !== name) toRename[name] = newName;\n  });\n\n  if (id.type === \"Identifier\" && exportName !== id.name) {\n    toRename[exportName] = id.name;\n  }\n\n  const {\n    path\n  } = file;\n  const exp = path.get(exportPath);\n  const imps = importPaths.map(p => path.get(p));\n  const impsBindingRefs = importBindingsReferences.map(p => path.get(p));\n  const decl = exp.get(\"declaration\");\n\n  if (id.type === \"Identifier\") {\n    exp.replaceWith(decl);\n  } else if (id.type === \"MemberExpression\") {\n    exportBindingAssignments.forEach(assignPath => {\n      const assign = path.get(assignPath);\n      assign.replaceWith(assignmentExpression(\"=\", id, assign.node));\n    });\n    exp.replaceWith(decl);\n    path.pushContainer(\"body\", expressionStatement(assignmentExpression(\"=\", id, identifier(exportName))));\n  } else {\n    throw new Error(\"Unexpected helper format.\");\n  }\n\n  Object.keys(toRename).forEach(name => {\n    path.scope.rename(name, toRename[name]);\n  });\n\n  for (const path of imps) path.remove();\n\n  for (const path of impsBindingRefs) {\n    const node = cloneNode(dependenciesRefs[path.node.name]);\n    path.replaceWith(node);\n  }\n}\n\nconst helperData = Object.create(null);\n\nfunction loadHelper(name) {\n  if (!helperData[name]) {\n    const helper = _helpers.default[name];\n\n    if (!helper) {\n      throw Object.assign(new ReferenceError(`Unknown helper ${name}`), {\n        code: \"BABEL_HELPER_UNKNOWN\",\n        helper: name\n      });\n    }\n\n    const fn = () => {\n      {\n        if (!FileClass) {\n          const fakeFile = {\n            ast: file(helper.ast()),\n            path: null\n          };\n          (0, _traverse.default)(fakeFile.ast, {\n            Program: path => (fakeFile.path = path).stop()\n          });\n          return fakeFile;\n        }\n      }\n      return new FileClass({\n        filename: `babel-helper://${name}`\n      }, {\n        ast: file(helper.ast()),\n        code: \"[internal Babel helper code]\",\n        inputMap: null\n      });\n    };\n\n    let metadata = null;\n    helperData[name] = {\n      minVersion: helper.minVersion,\n\n      build(getDependency, id, localBindings) {\n        const file = fn();\n        metadata || (metadata = getHelperMetadata(file));\n        permuteHelperAST(file, metadata, id, localBindings, getDependency);\n        return {\n          nodes: file.ast.program.body,\n          globals: metadata.globals\n        };\n      },\n\n      getDependencies() {\n        metadata || (metadata = getHelperMetadata(fn()));\n        return Array.from(metadata.dependencies.values());\n      }\n\n    };\n  }\n\n  return helperData[name];\n}\n\nfunction get(name, getDependency, id, localBindings) {\n  return loadHelper(name).build(getDependency, id, localBindings);\n}\n\nfunction minVersion(name) {\n  return loadHelper(name).minVersion;\n}\n\nfunction getDependencies(name) {\n  return loadHelper(name).getDependencies();\n}\n\nfunction ensure(name, newFileClass) {\n  FileClass || (FileClass = newFileClass);\n  loadHelper(name);\n}\n\nconst list = Object.keys(_helpers.default).map(name => name.replace(/^_/, \"\"));\nexports.list = list;\nvar _default = get;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["assignmentExpression","cloneNode","expressionStatement","file","identifier","makePath","path","parts","parentPath","push","key","inList","listKey","reverse","join","FileClass","undefined","getHelperMetadata","globals","Set","localBindingNames","dependencies","Map","exportName","exportPath","exportBindingAssignments","importPaths","importBindingsReferences","dependencyVisitor","ImportDeclaration","child","name","node","source","value","helpers","buildCodeFrameError","get","length","isImportDefaultSpecifier","bindingIdentifier","specifiers","local","set","ExportDefaultDeclaration","decl","isFunctionDeclaration","id","ExportAllDeclaration","ExportNamedDeclaration","Statement","isModuleDeclaration","skip","referenceVisitor","Program","bindings","scope","getAllBindings","Object","keys","forEach","has","add","ReferencedIdentifier","binding","getBinding","AssignmentExpression","left","getBindingIdentifiers","isIdentifier","isProgram","ast","Error","Array","from","permuteHelperAST","metadata","localBindings","getDependency","dependenciesRefs","toRename","newName","type","exp","imps","map","p","impsBindingRefs","replaceWith","assignPath","assign","pushContainer","rename","remove","helperData","create","loadHelper","helper","ReferenceError","code","fn","fakeFile","stop","filename","inputMap","minVersion","build","nodes","program","body","getDependencies","values","ensure","newFileClass","list","replace"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helpers\\src\\index.ts"],"sourcesContent":["import type { File } from \"@babel/core\";\nimport type { NodePath, Visitor } from \"@babel/traverse\";\nimport traverse from \"@babel/traverse\";\nimport {\n  assignmentExpression,\n  cloneNode,\n  expressionStatement,\n  file,\n  identifier,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport helpers from \"./helpers\";\n\nfunction makePath(path: NodePath) {\n  const parts = [];\n\n  for (; path.parentPath; path = path.parentPath) {\n    parts.push(path.key);\n    if (path.inList) parts.push(path.listKey);\n  }\n\n  return parts.reverse().join(\".\");\n}\n\nlet FileClass: typeof File | undefined = undefined;\n\ninterface HelperMetadata {\n  globals: string[];\n  localBindingNames: string[];\n  dependencies: Map<t.Identifier, string>;\n  exportBindingAssignments: string[];\n  exportPath: string;\n  exportName: string;\n  importBindingsReferences: string[];\n  importPaths: string[];\n}\n\n/**\n * Given a file AST for a given helper, get a bunch of metadata about it so that Babel can quickly render\n * the helper is whatever context it is needed in.\n */\nfunction getHelperMetadata(file: File): HelperMetadata {\n  const globals = new Set<string>();\n  const localBindingNames = new Set<string>();\n  // Maps imported identifier -> helper name\n  const dependencies = new Map<t.Identifier, string>();\n\n  let exportName: string | undefined;\n  let exportPath: string | undefined;\n  const exportBindingAssignments: string[] = [];\n  const importPaths: string[] = [];\n  const importBindingsReferences: string[] = [];\n\n  const dependencyVisitor: Visitor = {\n    ImportDeclaration(child) {\n      const name = child.node.source.value;\n      if (!helpers[name]) {\n        throw child.buildCodeFrameError(`Unknown helper ${name}`);\n      }\n      if (\n        child.get(\"specifiers\").length !== 1 ||\n        // @ts-expect-error isImportDefaultSpecifier does not work with NodePath union\n        !child.get(\"specifiers.0\").isImportDefaultSpecifier()\n      ) {\n        throw child.buildCodeFrameError(\n          \"Helpers can only import a default value\",\n        );\n      }\n      const bindingIdentifier = child.node.specifiers[0].local;\n      dependencies.set(bindingIdentifier, name);\n      importPaths.push(makePath(child));\n    },\n    ExportDefaultDeclaration(child) {\n      const decl = child.get(\"declaration\");\n\n      if (!decl.isFunctionDeclaration() || !decl.node.id) {\n        throw decl.buildCodeFrameError(\n          \"Helpers can only export named function declarations\",\n        );\n      }\n\n      exportName = decl.node.id.name;\n      exportPath = makePath(child);\n    },\n    ExportAllDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n    ExportNamedDeclaration(child) {\n      throw child.buildCodeFrameError(\"Helpers can only export default\");\n    },\n    Statement(child) {\n      if (child.isModuleDeclaration()) return;\n\n      child.skip();\n    },\n  };\n\n  const referenceVisitor: Visitor = {\n    Program(path) {\n      const bindings = path.scope.getAllBindings();\n\n      Object.keys(bindings).forEach(name => {\n        if (name === exportName) return;\n        if (dependencies.has(bindings[name].identifier)) return;\n\n        localBindingNames.add(name);\n      });\n    },\n    ReferencedIdentifier(child) {\n      const name = child.node.name;\n      const binding = child.scope.getBinding(name);\n      if (!binding) {\n        globals.add(name);\n      } else if (dependencies.has(binding.identifier)) {\n        importBindingsReferences.push(makePath(child));\n      }\n    },\n    AssignmentExpression(child) {\n      const left = child.get(\"left\");\n\n      if (!(exportName in left.getBindingIdentifiers())) return;\n\n      if (!left.isIdentifier()) {\n        throw left.buildCodeFrameError(\n          \"Only simple assignments to exports are allowed in helpers\",\n        );\n      }\n\n      const binding = child.scope.getBinding(exportName);\n\n      if (binding?.scope.path.isProgram()) {\n        exportBindingAssignments.push(makePath(child));\n      }\n    },\n  };\n\n  traverse(file.ast, dependencyVisitor, file.scope);\n  traverse(file.ast, referenceVisitor, file.scope);\n\n  if (!exportPath) throw new Error(\"Helpers must have a default export.\");\n\n  // Process these in reverse so that mutating the references does not invalidate any later paths in\n  // the list.\n  exportBindingAssignments.reverse();\n\n  return {\n    globals: Array.from(globals),\n    localBindingNames: Array.from(localBindingNames),\n    dependencies,\n    exportBindingAssignments,\n    exportPath,\n    exportName,\n    importBindingsReferences,\n    importPaths,\n  };\n}\n\ntype GetDependency = (name: string) => t.Expression;\n\n/**\n * Given a helper AST and information about how it will be used, update the AST to match the usage.\n */\nfunction permuteHelperAST(\n  file: File,\n  metadata: HelperMetadata,\n  id?: t.Identifier | t.MemberExpression,\n  localBindings?: string[],\n  getDependency?: GetDependency,\n) {\n  if (localBindings && !id) {\n    throw new Error(\"Unexpected local bindings for module-based helpers.\");\n  }\n\n  if (!id) return;\n\n  const {\n    localBindingNames,\n    dependencies,\n    exportBindingAssignments,\n    exportPath,\n    exportName,\n    importBindingsReferences,\n    importPaths,\n  } = metadata;\n\n  const dependenciesRefs: Record<string, t.Expression> = {};\n  dependencies.forEach((name, id) => {\n    dependenciesRefs[id.name] =\n      (typeof getDependency === \"function\" && getDependency(name)) || id;\n  });\n\n  const toRename: Record<string, string> = {};\n  const bindings = new Set(localBindings || []);\n  localBindingNames.forEach(name => {\n    let newName = name;\n    while (bindings.has(newName)) newName = \"_\" + newName;\n\n    if (newName !== name) toRename[name] = newName;\n  });\n\n  if (id.type === \"Identifier\" && exportName !== id.name) {\n    toRename[exportName] = id.name;\n  }\n\n  const { path } = file;\n\n  // We need to compute these in advance because removing nodes would\n  // invalidate the paths.\n  const exp: NodePath<t.ExportDefaultDeclaration> = path.get(exportPath);\n  const imps: NodePath<t.ImportDeclaration>[] = importPaths.map(p =>\n    path.get(p),\n  );\n  const impsBindingRefs: NodePath<t.Identifier>[] =\n    importBindingsReferences.map(p => path.get(p));\n\n  // We assert that this is a FunctionDeclaration in dependencyVisitor.\n  const decl = exp.get(\"declaration\") as NodePath<t.FunctionDeclaration>;\n\n  if (id.type === \"Identifier\") {\n    exp.replaceWith(decl);\n  } else if (id.type === \"MemberExpression\") {\n    exportBindingAssignments.forEach(assignPath => {\n      const assign: NodePath<t.Expression> = path.get(assignPath);\n      assign.replaceWith(assignmentExpression(\"=\", id, assign.node));\n    });\n    exp.replaceWith(decl);\n    path.pushContainer(\n      \"body\",\n      expressionStatement(\n        assignmentExpression(\"=\", id, identifier(exportName)),\n      ),\n    );\n  } else {\n    throw new Error(\"Unexpected helper format.\");\n  }\n\n  Object.keys(toRename).forEach(name => {\n    path.scope.rename(name, toRename[name]);\n  });\n\n  for (const path of imps) path.remove();\n  for (const path of impsBindingRefs) {\n    const node = cloneNode(dependenciesRefs[path.node.name]);\n    path.replaceWith(node);\n  }\n}\n\ninterface HelperData {\n  build: (\n    getDependency: GetDependency,\n    id: t.Identifier | t.MemberExpression,\n    localBindings: string[],\n  ) => {\n    nodes: t.Program[\"body\"];\n    globals: string[];\n  };\n  minVersion: string;\n  getDependencies: () => string[];\n}\n\nconst helperData: Record<string, HelperData> = Object.create(null);\nfunction loadHelper(name: string) {\n  if (!helperData[name]) {\n    const helper = helpers[name];\n    if (!helper) {\n      throw Object.assign(new ReferenceError(`Unknown helper ${name}`), {\n        code: \"BABEL_HELPER_UNKNOWN\",\n        helper: name,\n      });\n    }\n\n    const fn = (): File => {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!FileClass) {\n          const fakeFile = { ast: file(helper.ast()), path: null } as File;\n          traverse(fakeFile.ast, {\n            Program: path => (fakeFile.path = path).stop(),\n          });\n          return fakeFile;\n        }\n      }\n      return new FileClass(\n        { filename: `babel-helper://${name}` },\n        {\n          ast: file(helper.ast()),\n          code: \"[internal Babel helper code]\",\n          inputMap: null,\n        },\n      );\n    };\n\n    // We compute the helper metadata lazily, so that we skip that\n    // work if we only need the `.minVersion` (for example because\n    // of a call to `.availableHelper` when `@babel/rutime`).\n    let metadata: HelperMetadata | null = null;\n\n    helperData[name] = {\n      minVersion: helper.minVersion,\n      build(getDependency, id, localBindings) {\n        const file = fn();\n        metadata ||= getHelperMetadata(file);\n        permuteHelperAST(file, metadata, id, localBindings, getDependency);\n\n        return {\n          nodes: file.ast.program.body,\n          globals: metadata.globals,\n        };\n      },\n      getDependencies() {\n        metadata ||= getHelperMetadata(fn());\n        return Array.from(metadata.dependencies.values());\n      },\n    };\n  }\n\n  return helperData[name];\n}\n\nexport function get(\n  name: string,\n  getDependency?: GetDependency,\n  id?: t.Identifier | t.MemberExpression,\n  localBindings?: string[],\n) {\n  return loadHelper(name).build(getDependency, id, localBindings);\n}\n\nexport function minVersion(name: string) {\n  return loadHelper(name).minVersion;\n}\n\nexport function getDependencies(name: string): ReadonlyArray<string> {\n  return loadHelper(name).getDependencies();\n}\n\nexport function ensure(name: string, newFileClass: typeof File) {\n  // We inject the File class here rather than importing it to avoid\n  // circular dependencies between @babel/core and @babel/helpers.\n  FileClass ||= newFileClass;\n\n  loadHelper(name);\n}\n\nexport const list = Object.keys(helpers).map(name => name.replace(/^_/, \"\"));\n\nexport default get;\n"]},"metadata":{},"sourceType":"script"}