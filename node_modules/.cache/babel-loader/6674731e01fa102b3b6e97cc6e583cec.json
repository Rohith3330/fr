{"ast":null,"code":"/**\n * @fileoverview Common propTypes sorting functionality.\n */\n'use strict';\n\nconst astUtil = require('./ast');\n/**\n * Returns the value name of a node.\n *\n * @param {ASTNode} node the node to check.\n * @returns {String} The name of the node.\n */\n\n\nfunction getValueName(node) {\n  return node.type === 'Property' && node.value.property && node.value.property.name;\n}\n/**\n * Checks if the prop is required or not.\n *\n * @param {ASTNode} node the prop to check.\n * @returns {Boolean} true if the prop is required.\n */\n\n\nfunction isRequiredProp(node) {\n  return getValueName(node) === 'isRequired';\n}\n/**\n * Checks if the proptype is a callback by checking if it starts with 'on'.\n *\n * @param {String} propName the name of the proptype to check.\n * @returns {Boolean} true if the proptype is a callback.\n */\n\n\nfunction isCallbackPropName(propName) {\n  return /^on[A-Z]/.test(propName);\n}\n/**\n * Checks if the prop is PropTypes.shape.\n *\n * @param {ASTNode} node the prop to check.\n * @returns {Boolean} true if the prop is PropTypes.shape.\n */\n\n\nfunction isShapeProp(node) {\n  return Boolean(node && node.callee && node.callee.property && node.callee.property.name === 'shape');\n}\n/**\n * Returns the properties of a PropTypes.shape.\n *\n * @param {ASTNode} node the prop to check.\n * @returns {Array} the properties of the PropTypes.shape node.\n */\n\n\nfunction getShapeProperties(node) {\n  return node.arguments && node.arguments[0] && node.arguments[0].properties;\n}\n/**\n * Compares two elements.\n *\n * @param {ASTNode} a the first element to compare.\n * @param {ASTNode} b the second element to compare.\n * @param {Context} context The context of the two nodes.\n * @param {Boolean=} ignoreCase whether or not to ignore case when comparing the two elements.\n * @param {Boolean=} requiredFirst whether or not to sort required elements first.\n * @param {Boolean=} callbacksLast whether or not to sort callbacks after everything else.\n * @returns {Number} the sort order of the two elements.\n */\n\n\nfunction sorter(a, b, context, ignoreCase, requiredFirst, callbacksLast) {\n  const aKey = String(astUtil.getKeyValue(context, a));\n  const bKey = String(astUtil.getKeyValue(context, b));\n\n  if (requiredFirst) {\n    if (isRequiredProp(a) && !isRequiredProp(b)) {\n      return -1;\n    }\n\n    if (!isRequiredProp(a) && isRequiredProp(b)) {\n      return 1;\n    }\n  }\n\n  if (callbacksLast) {\n    if (isCallbackPropName(aKey) && !isCallbackPropName(bKey)) {\n      return 1;\n    }\n\n    if (!isCallbackPropName(aKey) && isCallbackPropName(bKey)) {\n      return -1;\n    }\n  }\n\n  if (ignoreCase) {\n    return aKey.localeCompare(bKey);\n  }\n\n  if (aKey < bKey) {\n    return -1;\n  }\n\n  if (aKey > bKey) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\n * Fixes sort order of prop types.\n *\n * @param {Fixer} fixer the first element to compare.\n * @param {Object} context the second element to compare.\n * @param {Array} declarations The context of the two nodes.\n * @param {Boolean=} ignoreCase whether or not to ignore case when comparing the two elements.\n * @param {Boolean=} requiredFirst whether or not to sort required elements first.\n * @param {Boolean=} callbacksLast whether or not to sort callbacks after everything else.\n * @param {Boolean=} sortShapeProp whether or not to sort propTypes defined in PropTypes.shape.\n * @returns {Object|*|{range, text}} the sort order of the two elements.\n */\n\n\nfunction fixPropTypesSort(fixer, context, declarations, ignoreCase, requiredFirst, callbacksLast, sortShapeProp) {\n  function sortInSource(allNodes, source) {\n    const originalSource = source;\n    const nodeGroups = allNodes.reduce((acc, curr) => {\n      if (curr.type === 'ExperimentalSpreadProperty' || curr.type === 'SpreadElement') {\n        acc.push([]);\n      } else {\n        acc[acc.length - 1].push(curr);\n      }\n\n      return acc;\n    }, [[]]);\n    nodeGroups.forEach(nodes => {\n      const sortedAttributes = nodes.slice().sort((a, b) => sorter(a, b, context, ignoreCase, requiredFirst, callbacksLast));\n      source = nodes.reduceRight((acc, attr, index) => {\n        const sortedAttr = sortedAttributes[index];\n        let sortedAttrText = context.getSourceCode().getText(sortedAttr);\n\n        if (sortShapeProp && isShapeProp(sortedAttr.value)) {\n          const shape = getShapeProperties(sortedAttr.value);\n\n          if (shape) {\n            const attrSource = sortInSource(shape, originalSource);\n            sortedAttrText = attrSource.slice(sortedAttr.range[0], sortedAttr.range[1]);\n          }\n        }\n\n        return `${acc.slice(0, attr.range[0])}${sortedAttrText}${acc.slice(attr.range[1])}`;\n      }, source);\n    });\n    return source;\n  }\n\n  const source = sortInSource(declarations, context.getSourceCode().getText());\n  const rangeStart = declarations[0].range[0];\n  const rangeEnd = declarations[declarations.length - 1].range[1];\n  return fixer.replaceTextRange([rangeStart, rangeEnd], source.slice(rangeStart, rangeEnd));\n}\n\nmodule.exports = {\n  fixPropTypesSort\n};","map":{"version":3,"names":["astUtil","require","getValueName","node","type","value","property","name","isRequiredProp","isCallbackPropName","propName","test","isShapeProp","Boolean","callee","getShapeProperties","arguments","properties","sorter","a","b","context","ignoreCase","requiredFirst","callbacksLast","aKey","String","getKeyValue","bKey","localeCompare","fixPropTypesSort","fixer","declarations","sortShapeProp","sortInSource","allNodes","source","originalSource","nodeGroups","reduce","acc","curr","push","length","forEach","nodes","sortedAttributes","slice","sort","reduceRight","attr","index","sortedAttr","sortedAttrText","getSourceCode","getText","shape","attrSource","range","rangeStart","rangeEnd","replaceTextRange","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/util/propTypesSort.js"],"sourcesContent":["/**\n * @fileoverview Common propTypes sorting functionality.\n */\n\n'use strict';\n\nconst astUtil = require('./ast');\n\n/**\n * Returns the value name of a node.\n *\n * @param {ASTNode} node the node to check.\n * @returns {String} The name of the node.\n */\nfunction getValueName(node) {\n  return node.type === 'Property' && node.value.property && node.value.property.name;\n}\n\n/**\n * Checks if the prop is required or not.\n *\n * @param {ASTNode} node the prop to check.\n * @returns {Boolean} true if the prop is required.\n */\nfunction isRequiredProp(node) {\n  return getValueName(node) === 'isRequired';\n}\n\n/**\n * Checks if the proptype is a callback by checking if it starts with 'on'.\n *\n * @param {String} propName the name of the proptype to check.\n * @returns {Boolean} true if the proptype is a callback.\n */\nfunction isCallbackPropName(propName) {\n  return /^on[A-Z]/.test(propName);\n}\n\n/**\n * Checks if the prop is PropTypes.shape.\n *\n * @param {ASTNode} node the prop to check.\n * @returns {Boolean} true if the prop is PropTypes.shape.\n */\nfunction isShapeProp(node) {\n  return Boolean(\n    node && node.callee && node.callee.property && node.callee.property.name === 'shape'\n  );\n}\n\n/**\n * Returns the properties of a PropTypes.shape.\n *\n * @param {ASTNode} node the prop to check.\n * @returns {Array} the properties of the PropTypes.shape node.\n */\nfunction getShapeProperties(node) {\n  return node.arguments && node.arguments[0] && node.arguments[0].properties;\n}\n\n/**\n * Compares two elements.\n *\n * @param {ASTNode} a the first element to compare.\n * @param {ASTNode} b the second element to compare.\n * @param {Context} context The context of the two nodes.\n * @param {Boolean=} ignoreCase whether or not to ignore case when comparing the two elements.\n * @param {Boolean=} requiredFirst whether or not to sort required elements first.\n * @param {Boolean=} callbacksLast whether or not to sort callbacks after everything else.\n * @returns {Number} the sort order of the two elements.\n */\nfunction sorter(a, b, context, ignoreCase, requiredFirst, callbacksLast) {\n  const aKey = String(astUtil.getKeyValue(context, a));\n  const bKey = String(astUtil.getKeyValue(context, b));\n\n  if (requiredFirst) {\n    if (isRequiredProp(a) && !isRequiredProp(b)) {\n      return -1;\n    }\n    if (!isRequiredProp(a) && isRequiredProp(b)) {\n      return 1;\n    }\n  }\n\n  if (callbacksLast) {\n    if (isCallbackPropName(aKey) && !isCallbackPropName(bKey)) {\n      return 1;\n    }\n    if (!isCallbackPropName(aKey) && isCallbackPropName(bKey)) {\n      return -1;\n    }\n  }\n\n  if (ignoreCase) {\n    return aKey.localeCompare(bKey);\n  }\n\n  if (aKey < bKey) {\n    return -1;\n  }\n  if (aKey > bKey) {\n    return 1;\n  }\n  return 0;\n}\n\n/**\n * Fixes sort order of prop types.\n *\n * @param {Fixer} fixer the first element to compare.\n * @param {Object} context the second element to compare.\n * @param {Array} declarations The context of the two nodes.\n * @param {Boolean=} ignoreCase whether or not to ignore case when comparing the two elements.\n * @param {Boolean=} requiredFirst whether or not to sort required elements first.\n * @param {Boolean=} callbacksLast whether or not to sort callbacks after everything else.\n * @param {Boolean=} sortShapeProp whether or not to sort propTypes defined in PropTypes.shape.\n * @returns {Object|*|{range, text}} the sort order of the two elements.\n */\nfunction fixPropTypesSort(fixer, context, declarations, ignoreCase, requiredFirst, callbacksLast, sortShapeProp) {\n  function sortInSource(allNodes, source) {\n    const originalSource = source;\n    const nodeGroups = allNodes.reduce((acc, curr) => {\n      if (curr.type === 'ExperimentalSpreadProperty' || curr.type === 'SpreadElement') {\n        acc.push([]);\n      } else {\n        acc[acc.length - 1].push(curr);\n      }\n      return acc;\n    }, [[]]);\n\n    nodeGroups.forEach((nodes) => {\n      const sortedAttributes = nodes\n        .slice()\n        .sort((a, b) => sorter(a, b, context, ignoreCase, requiredFirst, callbacksLast));\n\n      source = nodes.reduceRight((acc, attr, index) => {\n        const sortedAttr = sortedAttributes[index];\n        let sortedAttrText = context.getSourceCode().getText(sortedAttr);\n        if (sortShapeProp && isShapeProp(sortedAttr.value)) {\n          const shape = getShapeProperties(sortedAttr.value);\n          if (shape) {\n            const attrSource = sortInSource(\n              shape,\n              originalSource\n            );\n            sortedAttrText = attrSource.slice(sortedAttr.range[0], sortedAttr.range[1]);\n          }\n        }\n        return `${acc.slice(0, attr.range[0])}${sortedAttrText}${acc.slice(attr.range[1])}`;\n      }, source);\n    });\n    return source;\n  }\n\n  const source = sortInSource(declarations, context.getSourceCode().getText());\n\n  const rangeStart = declarations[0].range[0];\n  const rangeEnd = declarations[declarations.length - 1].range[1];\n  return fixer.replaceTextRange([rangeStart, rangeEnd], source.slice(rangeStart, rangeEnd));\n}\n\nmodule.exports = {\n  fixPropTypesSort,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}