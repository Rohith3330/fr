{"ast":null,"code":"var definitions = {};\n\nfunction defineType(typeName, metadata) {\n  definitions[typeName] = metadata;\n}\n\ndefineType(\"Module\", {\n  spec: {\n    wasm: \"https://webassembly.github.io/spec/core/binary/modules.html#binary-module\",\n    wat: \"https://webassembly.github.io/spec/core/text/modules.html#text-module\"\n  },\n  doc: \"A module consists of a sequence of sections (termed fields in the text format).\",\n  unionType: [\"Node\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"string\"\n    },\n    fields: {\n      array: true,\n      type: \"Node\"\n    },\n    metadata: {\n      optional: true,\n      type: \"ModuleMetadata\"\n    }\n  }\n});\ndefineType(\"ModuleMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    sections: {\n      array: true,\n      type: \"SectionMetadata\"\n    },\n    functionNames: {\n      optional: true,\n      array: true,\n      type: \"FunctionNameMetadata\"\n    },\n    localNames: {\n      optional: true,\n      array: true,\n      type: \"ModuleMetadata\"\n    },\n    producers: {\n      optional: true,\n      array: true,\n      type: \"ProducersSectionMetadata\"\n    }\n  }\n});\ndefineType(\"ModuleNameMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"FunctionNameMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    },\n    index: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"LocalNameMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    },\n    localIndex: {\n      type: \"number\"\n    },\n    functionIndex: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"BinaryModule\", {\n  unionType: [\"Node\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"string\"\n    },\n    blob: {\n      array: true,\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"QuoteModule\", {\n  unionType: [\"Node\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"string\"\n    },\n    string: {\n      array: true,\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"SectionMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    section: {\n      type: \"SectionName\"\n    },\n    startOffset: {\n      type: \"number\"\n    },\n    size: {\n      type: \"NumberLiteral\"\n    },\n    vectorOfSize: {\n      comment: \"Size of the vector in the section (if any)\",\n      type: \"NumberLiteral\"\n    }\n  }\n});\ndefineType(\"ProducersSectionMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    producers: {\n      array: true,\n      type: \"ProducerMetadata\"\n    }\n  }\n});\ndefineType(\"ProducerMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    language: {\n      type: \"ProducerMetadataVersionedName\",\n      array: true\n    },\n    processedBy: {\n      type: \"ProducerMetadataVersionedName\",\n      array: true\n    },\n    sdk: {\n      type: \"ProducerMetadataVersionedName\",\n      array: true\n    }\n  }\n});\ndefineType(\"ProducerMetadataVersionedName\", {\n  unionType: [\"Node\"],\n  fields: {\n    name: {\n      type: \"string\"\n    },\n    version: {\n      type: \"string\"\n    }\n  }\n});\n/*\nInstructions\n*/\n\ndefineType(\"LoopInstruction\", {\n  unionType: [\"Node\", \"Block\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"loop\"\n    },\n    label: {\n      maybe: true,\n      type: \"Identifier\"\n    },\n    resulttype: {\n      maybe: true,\n      type: \"Valtype\"\n    },\n    instr: {\n      array: true,\n      type: \"Instruction\"\n    }\n  }\n});\ndefineType(\"Instr\", {\n  unionType: [\"Node\", \"Expression\", \"Instruction\"],\n  fields: {\n    id: {\n      type: \"string\"\n    },\n    object: {\n      optional: true,\n      type: \"Valtype\"\n    },\n    args: {\n      array: true,\n      type: \"Expression\"\n    },\n    namedArgs: {\n      optional: true,\n      type: \"Object\"\n    }\n  }\n});\ndefineType(\"IfInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"if\"\n    },\n    testLabel: {\n      comment: \"only for WAST\",\n      type: \"Identifier\"\n    },\n    test: {\n      array: true,\n      type: \"Instruction\"\n    },\n    result: {\n      maybe: true,\n      type: \"Valtype\"\n    },\n    consequent: {\n      array: true,\n      type: \"Instruction\"\n    },\n    alternate: {\n      array: true,\n      type: \"Instruction\"\n    }\n  }\n});\n/* \nConcrete value types\n*/\n\ndefineType(\"StringLiteral\", {\n  unionType: [\"Node\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"NumberLiteral\", {\n  unionType: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"number\"\n    },\n    raw: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"LongNumberLiteral\", {\n  unionType: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"LongNumber\"\n    },\n    raw: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"FloatLiteral\", {\n  unionType: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"number\"\n    },\n    nan: {\n      optional: true,\n      type: \"boolean\"\n    },\n    inf: {\n      optional: true,\n      type: \"boolean\"\n    },\n    raw: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"Elem\", {\n  unionType: [\"Node\"],\n  fields: {\n    table: {\n      type: \"Index\"\n    },\n    offset: {\n      array: true,\n      type: \"Instruction\"\n    },\n    funcs: {\n      array: true,\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"IndexInFuncSection\", {\n  unionType: [\"Node\"],\n  fields: {\n    index: {\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"ValtypeLiteral\", {\n  unionType: [\"Node\", \"Expression\"],\n  fields: {\n    name: {\n      type: \"Valtype\"\n    }\n  }\n});\ndefineType(\"TypeInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"Index\"\n    },\n    functype: {\n      type: \"Signature\"\n    }\n  }\n});\ndefineType(\"Start\", {\n  unionType: [\"Node\"],\n  fields: {\n    index: {\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"GlobalType\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    valtype: {\n      type: \"Valtype\"\n    },\n    mutability: {\n      type: \"Mutability\"\n    }\n  }\n});\ndefineType(\"LeadingComment\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"BlockComment\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"Data\", {\n  unionType: [\"Node\"],\n  fields: {\n    memoryIndex: {\n      type: \"Memidx\"\n    },\n    offset: {\n      type: \"Instruction\"\n    },\n    init: {\n      type: \"ByteArray\"\n    }\n  }\n});\ndefineType(\"Global\", {\n  unionType: [\"Node\"],\n  fields: {\n    globalType: {\n      type: \"GlobalType\"\n    },\n    init: {\n      array: true,\n      type: \"Instruction\"\n    },\n    name: {\n      maybe: true,\n      type: \"Identifier\"\n    }\n  }\n});\ndefineType(\"Table\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    elementType: {\n      type: \"TableElementType\"\n    },\n    limits: {\n      assertNodeType: true,\n      type: \"Limit\"\n    },\n    name: {\n      maybe: true,\n      type: \"Identifier\"\n    },\n    elements: {\n      array: true,\n      optional: true,\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"Memory\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    limits: {\n      type: \"Limit\"\n    },\n    id: {\n      maybe: true,\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"FuncImportDescr\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    id: {\n      type: \"Identifier\"\n    },\n    signature: {\n      type: \"Signature\"\n    }\n  }\n});\ndefineType(\"ModuleImport\", {\n  unionType: [\"Node\"],\n  fields: {\n    module: {\n      type: \"string\"\n    },\n    name: {\n      type: \"string\"\n    },\n    descr: {\n      type: \"ImportDescr\"\n    }\n  }\n});\ndefineType(\"ModuleExportDescr\", {\n  unionType: [\"Node\"],\n  fields: {\n    exportType: {\n      type: \"ExportDescrType\"\n    },\n    id: {\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"ModuleExport\", {\n  unionType: [\"Node\"],\n  fields: {\n    name: {\n      type: \"string\"\n    },\n    descr: {\n      type: \"ModuleExportDescr\"\n    }\n  }\n});\ndefineType(\"Limit\", {\n  unionType: [\"Node\"],\n  fields: {\n    min: {\n      type: \"number\"\n    },\n    max: {\n      optional: true,\n      type: \"number\"\n    },\n    // Threads proposal, shared memory\n    shared: {\n      optional: true,\n      type: \"boolean\"\n    }\n  }\n});\ndefineType(\"Signature\", {\n  unionType: [\"Node\"],\n  fields: {\n    params: {\n      array: true,\n      type: \"FuncParam\"\n    },\n    results: {\n      array: true,\n      type: \"Valtype\"\n    }\n  }\n});\ndefineType(\"Program\", {\n  unionType: [\"Node\"],\n  fields: {\n    body: {\n      array: true,\n      type: \"Node\"\n    }\n  }\n});\ndefineType(\"Identifier\", {\n  unionType: [\"Node\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"string\"\n    },\n    raw: {\n      optional: true,\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"BlockInstruction\", {\n  unionType: [\"Node\", \"Block\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"block\"\n    },\n    label: {\n      maybe: true,\n      type: \"Identifier\"\n    },\n    instr: {\n      array: true,\n      type: \"Instruction\"\n    },\n    result: {\n      maybe: true,\n      type: \"Valtype\"\n    }\n  }\n});\ndefineType(\"CallInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"call\"\n    },\n    index: {\n      type: \"Index\"\n    },\n    instrArgs: {\n      array: true,\n      optional: true,\n      type: \"Expression\"\n    },\n    numeric: {\n      type: \"Index\",\n      optional: true\n    }\n  }\n});\ndefineType(\"CallIndirectInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"call_indirect\"\n    },\n    signature: {\n      type: \"SignatureOrTypeRef\"\n    },\n    intrs: {\n      array: true,\n      optional: true,\n      type: \"Expression\"\n    }\n  }\n});\ndefineType(\"ByteArray\", {\n  unionType: [\"Node\"],\n  fields: {\n    values: {\n      array: true,\n      type: \"Byte\"\n    }\n  }\n});\ndefineType(\"Func\", {\n  unionType: [\"Node\", \"Block\"],\n  fields: {\n    name: {\n      maybe: true,\n      type: \"Index\"\n    },\n    signature: {\n      type: \"SignatureOrTypeRef\"\n    },\n    body: {\n      array: true,\n      type: \"Instruction\"\n    },\n    isExternal: {\n      comment: \"means that it has been imported from the outside js\",\n      optional: true,\n      type: \"boolean\"\n    },\n    metadata: {\n      optional: true,\n      type: \"FuncMetadata\"\n    }\n  }\n});\n/**\n * Intrinsics\n */\n\ndefineType(\"InternalBrUnless\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {\n    target: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"InternalGoto\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {\n    target: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"InternalCallExtern\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {\n    target: {\n      type: \"number\"\n    }\n  }\n}); // function bodies are terminated by an `end` instruction but are missing a\n// return instruction\n//\n// Since we can't inject a new instruction we are injecting a new instruction.\n\ndefineType(\"InternalEndAndReturn\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {}\n});\nmodule.exports = definitions;","map":{"version":3,"names":["definitions","defineType","typeName","metadata","spec","wasm","wat","doc","unionType","fields","id","maybe","type","array","optional","sections","functionNames","localNames","producers","value","index","localIndex","functionIndex","blob","string","section","startOffset","size","vectorOfSize","comment","language","processedBy","sdk","name","version","constant","label","resulttype","instr","object","args","namedArgs","testLabel","test","result","consequent","alternate","raw","nan","inf","table","offset","funcs","functype","valtype","mutability","memoryIndex","init","globalType","elementType","limits","assertNodeType","elements","signature","module","descr","exportType","min","max","shared","params","results","body","instrArgs","numeric","intrs","values","isExternal","target","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@webassemblyjs/ast/esm/definitions.js"],"sourcesContent":["var definitions = {};\n\nfunction defineType(typeName, metadata) {\n  definitions[typeName] = metadata;\n}\n\ndefineType(\"Module\", {\n  spec: {\n    wasm: \"https://webassembly.github.io/spec/core/binary/modules.html#binary-module\",\n    wat: \"https://webassembly.github.io/spec/core/text/modules.html#text-module\"\n  },\n  doc: \"A module consists of a sequence of sections (termed fields in the text format).\",\n  unionType: [\"Node\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"string\"\n    },\n    fields: {\n      array: true,\n      type: \"Node\"\n    },\n    metadata: {\n      optional: true,\n      type: \"ModuleMetadata\"\n    }\n  }\n});\ndefineType(\"ModuleMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    sections: {\n      array: true,\n      type: \"SectionMetadata\"\n    },\n    functionNames: {\n      optional: true,\n      array: true,\n      type: \"FunctionNameMetadata\"\n    },\n    localNames: {\n      optional: true,\n      array: true,\n      type: \"ModuleMetadata\"\n    },\n    producers: {\n      optional: true,\n      array: true,\n      type: \"ProducersSectionMetadata\"\n    }\n  }\n});\ndefineType(\"ModuleNameMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"FunctionNameMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    },\n    index: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"LocalNameMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    },\n    localIndex: {\n      type: \"number\"\n    },\n    functionIndex: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"BinaryModule\", {\n  unionType: [\"Node\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"string\"\n    },\n    blob: {\n      array: true,\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"QuoteModule\", {\n  unionType: [\"Node\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"string\"\n    },\n    string: {\n      array: true,\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"SectionMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    section: {\n      type: \"SectionName\"\n    },\n    startOffset: {\n      type: \"number\"\n    },\n    size: {\n      type: \"NumberLiteral\"\n    },\n    vectorOfSize: {\n      comment: \"Size of the vector in the section (if any)\",\n      type: \"NumberLiteral\"\n    }\n  }\n});\ndefineType(\"ProducersSectionMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    producers: {\n      array: true,\n      type: \"ProducerMetadata\"\n    }\n  }\n});\ndefineType(\"ProducerMetadata\", {\n  unionType: [\"Node\"],\n  fields: {\n    language: {\n      type: \"ProducerMetadataVersionedName\",\n      array: true\n    },\n    processedBy: {\n      type: \"ProducerMetadataVersionedName\",\n      array: true\n    },\n    sdk: {\n      type: \"ProducerMetadataVersionedName\",\n      array: true\n    }\n  }\n});\ndefineType(\"ProducerMetadataVersionedName\", {\n  unionType: [\"Node\"],\n  fields: {\n    name: {\n      type: \"string\"\n    },\n    version: {\n      type: \"string\"\n    }\n  }\n});\n/*\nInstructions\n*/\n\ndefineType(\"LoopInstruction\", {\n  unionType: [\"Node\", \"Block\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"loop\"\n    },\n    label: {\n      maybe: true,\n      type: \"Identifier\"\n    },\n    resulttype: {\n      maybe: true,\n      type: \"Valtype\"\n    },\n    instr: {\n      array: true,\n      type: \"Instruction\"\n    }\n  }\n});\ndefineType(\"Instr\", {\n  unionType: [\"Node\", \"Expression\", \"Instruction\"],\n  fields: {\n    id: {\n      type: \"string\"\n    },\n    object: {\n      optional: true,\n      type: \"Valtype\"\n    },\n    args: {\n      array: true,\n      type: \"Expression\"\n    },\n    namedArgs: {\n      optional: true,\n      type: \"Object\"\n    }\n  }\n});\ndefineType(\"IfInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"if\"\n    },\n    testLabel: {\n      comment: \"only for WAST\",\n      type: \"Identifier\"\n    },\n    test: {\n      array: true,\n      type: \"Instruction\"\n    },\n    result: {\n      maybe: true,\n      type: \"Valtype\"\n    },\n    consequent: {\n      array: true,\n      type: \"Instruction\"\n    },\n    alternate: {\n      array: true,\n      type: \"Instruction\"\n    }\n  }\n});\n/* \nConcrete value types\n*/\n\ndefineType(\"StringLiteral\", {\n  unionType: [\"Node\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"NumberLiteral\", {\n  unionType: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"number\"\n    },\n    raw: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"LongNumberLiteral\", {\n  unionType: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"LongNumber\"\n    },\n    raw: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"FloatLiteral\", {\n  unionType: [\"Node\", \"NumericLiteral\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"number\"\n    },\n    nan: {\n      optional: true,\n      type: \"boolean\"\n    },\n    inf: {\n      optional: true,\n      type: \"boolean\"\n    },\n    raw: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"Elem\", {\n  unionType: [\"Node\"],\n  fields: {\n    table: {\n      type: \"Index\"\n    },\n    offset: {\n      array: true,\n      type: \"Instruction\"\n    },\n    funcs: {\n      array: true,\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"IndexInFuncSection\", {\n  unionType: [\"Node\"],\n  fields: {\n    index: {\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"ValtypeLiteral\", {\n  unionType: [\"Node\", \"Expression\"],\n  fields: {\n    name: {\n      type: \"Valtype\"\n    }\n  }\n});\ndefineType(\"TypeInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      maybe: true,\n      type: \"Index\"\n    },\n    functype: {\n      type: \"Signature\"\n    }\n  }\n});\ndefineType(\"Start\", {\n  unionType: [\"Node\"],\n  fields: {\n    index: {\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"GlobalType\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    valtype: {\n      type: \"Valtype\"\n    },\n    mutability: {\n      type: \"Mutability\"\n    }\n  }\n});\ndefineType(\"LeadingComment\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"BlockComment\", {\n  unionType: [\"Node\"],\n  fields: {\n    value: {\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"Data\", {\n  unionType: [\"Node\"],\n  fields: {\n    memoryIndex: {\n      type: \"Memidx\"\n    },\n    offset: {\n      type: \"Instruction\"\n    },\n    init: {\n      type: \"ByteArray\"\n    }\n  }\n});\ndefineType(\"Global\", {\n  unionType: [\"Node\"],\n  fields: {\n    globalType: {\n      type: \"GlobalType\"\n    },\n    init: {\n      array: true,\n      type: \"Instruction\"\n    },\n    name: {\n      maybe: true,\n      type: \"Identifier\"\n    }\n  }\n});\ndefineType(\"Table\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    elementType: {\n      type: \"TableElementType\"\n    },\n    limits: {\n      assertNodeType: true,\n      type: \"Limit\"\n    },\n    name: {\n      maybe: true,\n      type: \"Identifier\"\n    },\n    elements: {\n      array: true,\n      optional: true,\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"Memory\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    limits: {\n      type: \"Limit\"\n    },\n    id: {\n      maybe: true,\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"FuncImportDescr\", {\n  unionType: [\"Node\", \"ImportDescr\"],\n  fields: {\n    id: {\n      type: \"Identifier\"\n    },\n    signature: {\n      type: \"Signature\"\n    }\n  }\n});\ndefineType(\"ModuleImport\", {\n  unionType: [\"Node\"],\n  fields: {\n    module: {\n      type: \"string\"\n    },\n    name: {\n      type: \"string\"\n    },\n    descr: {\n      type: \"ImportDescr\"\n    }\n  }\n});\ndefineType(\"ModuleExportDescr\", {\n  unionType: [\"Node\"],\n  fields: {\n    exportType: {\n      type: \"ExportDescrType\"\n    },\n    id: {\n      type: \"Index\"\n    }\n  }\n});\ndefineType(\"ModuleExport\", {\n  unionType: [\"Node\"],\n  fields: {\n    name: {\n      type: \"string\"\n    },\n    descr: {\n      type: \"ModuleExportDescr\"\n    }\n  }\n});\ndefineType(\"Limit\", {\n  unionType: [\"Node\"],\n  fields: {\n    min: {\n      type: \"number\"\n    },\n    max: {\n      optional: true,\n      type: \"number\"\n    },\n    // Threads proposal, shared memory\n    shared: {\n      optional: true,\n      type: \"boolean\"\n    }\n  }\n});\ndefineType(\"Signature\", {\n  unionType: [\"Node\"],\n  fields: {\n    params: {\n      array: true,\n      type: \"FuncParam\"\n    },\n    results: {\n      array: true,\n      type: \"Valtype\"\n    }\n  }\n});\ndefineType(\"Program\", {\n  unionType: [\"Node\"],\n  fields: {\n    body: {\n      array: true,\n      type: \"Node\"\n    }\n  }\n});\ndefineType(\"Identifier\", {\n  unionType: [\"Node\", \"Expression\"],\n  fields: {\n    value: {\n      type: \"string\"\n    },\n    raw: {\n      optional: true,\n      type: \"string\"\n    }\n  }\n});\ndefineType(\"BlockInstruction\", {\n  unionType: [\"Node\", \"Block\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"block\"\n    },\n    label: {\n      maybe: true,\n      type: \"Identifier\"\n    },\n    instr: {\n      array: true,\n      type: \"Instruction\"\n    },\n    result: {\n      maybe: true,\n      type: \"Valtype\"\n    }\n  }\n});\ndefineType(\"CallInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"call\"\n    },\n    index: {\n      type: \"Index\"\n    },\n    instrArgs: {\n      array: true,\n      optional: true,\n      type: \"Expression\"\n    },\n    numeric: {\n      type: \"Index\",\n      optional: true\n    }\n  }\n});\ndefineType(\"CallIndirectInstruction\", {\n  unionType: [\"Node\", \"Instruction\"],\n  fields: {\n    id: {\n      constant: true,\n      type: \"string\",\n      value: \"call_indirect\"\n    },\n    signature: {\n      type: \"SignatureOrTypeRef\"\n    },\n    intrs: {\n      array: true,\n      optional: true,\n      type: \"Expression\"\n    }\n  }\n});\ndefineType(\"ByteArray\", {\n  unionType: [\"Node\"],\n  fields: {\n    values: {\n      array: true,\n      type: \"Byte\"\n    }\n  }\n});\ndefineType(\"Func\", {\n  unionType: [\"Node\", \"Block\"],\n  fields: {\n    name: {\n      maybe: true,\n      type: \"Index\"\n    },\n    signature: {\n      type: \"SignatureOrTypeRef\"\n    },\n    body: {\n      array: true,\n      type: \"Instruction\"\n    },\n    isExternal: {\n      comment: \"means that it has been imported from the outside js\",\n      optional: true,\n      type: \"boolean\"\n    },\n    metadata: {\n      optional: true,\n      type: \"FuncMetadata\"\n    }\n  }\n});\n/**\n * Intrinsics\n */\n\ndefineType(\"InternalBrUnless\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {\n    target: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"InternalGoto\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {\n    target: {\n      type: \"number\"\n    }\n  }\n});\ndefineType(\"InternalCallExtern\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {\n    target: {\n      type: \"number\"\n    }\n  }\n}); // function bodies are terminated by an `end` instruction but are missing a\n// return instruction\n//\n// Since we can't inject a new instruction we are injecting a new instruction.\n\ndefineType(\"InternalEndAndReturn\", {\n  unionType: [\"Node\", \"Intrinsic\"],\n  fields: {}\n});\nmodule.exports = definitions;"],"mappings":"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"},"metadata":{},"sourceType":"script"}