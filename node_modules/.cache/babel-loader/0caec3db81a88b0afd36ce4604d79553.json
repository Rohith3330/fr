{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;\n\nconst util_1 = require(\"./util\");\n\nconst equal = require(\"fast-deep-equal\");\n\nconst traverse = require(\"json-schema-traverse\"); // TODO refactor to use keyword definitions\n\n\nconst SIMPLE_INLINED = new Set([\"type\", \"format\", \"pattern\", \"maxLength\", \"minLength\", \"maxProperties\", \"minProperties\", \"maxItems\", \"minItems\", \"maximum\", \"minimum\", \"uniqueItems\", \"multipleOf\", \"required\", \"enum\", \"const\"]);\n\nfunction inlineRef(schema) {\n  let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (typeof schema == \"boolean\") return true;\n  if (limit === true) return !hasRef(schema);\n  if (!limit) return false;\n  return countKeys(schema) <= limit;\n}\n\nexports.inlineRef = inlineRef;\nconst REF_KEYWORDS = new Set([\"$ref\", \"$recursiveRef\", \"$recursiveAnchor\", \"$dynamicRef\", \"$dynamicAnchor\"]);\n\nfunction hasRef(schema) {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true;\n    const sch = schema[key];\n    if (Array.isArray(sch) && sch.some(hasRef)) return true;\n    if (typeof sch == \"object\" && hasRef(sch)) return true;\n  }\n\n  return false;\n}\n\nfunction countKeys(schema) {\n  let count = 0;\n\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity;\n    count++;\n    if (SIMPLE_INLINED.has(key)) continue;\n\n    if (typeof schema[key] == \"object\") {\n      (0, util_1.eachItem)(schema[key], sch => count += countKeys(sch));\n    }\n\n    if (count === Infinity) return Infinity;\n  }\n\n  return count;\n}\n\nfunction getFullPath(resolver) {\n  let id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  let normalize = arguments.length > 2 ? arguments[2] : undefined;\n  if (normalize !== false) id = normalizeId(id);\n  const p = resolver.parse(id);\n  return _getFullPath(resolver, p);\n}\n\nexports.getFullPath = getFullPath;\n\nfunction _getFullPath(resolver, p) {\n  const serialized = resolver.serialize(p);\n  return serialized.split(\"#\")[0] + \"#\";\n}\n\nexports._getFullPath = _getFullPath;\nconst TRAILING_SLASH_HASH = /#\\/?$/;\n\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n}\n\nexports.normalizeId = normalizeId;\n\nfunction resolveUrl(resolver, baseId, id) {\n  id = normalizeId(id);\n  return resolver.resolve(baseId, id);\n}\n\nexports.resolveUrl = resolveUrl;\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i;\n\nfunction getSchemaRefs(schema, baseId) {\n  if (typeof schema == \"boolean\") return {};\n  const {\n    schemaId,\n    uriResolver\n  } = this.opts;\n  const schId = normalizeId(schema[schemaId] || baseId);\n  const baseIds = {\n    \"\": schId\n  };\n  const pathPrefix = getFullPath(uriResolver, schId, false);\n  const localRefs = {};\n  const schemaRefs = new Set();\n  traverse(schema, {\n    allKeys: true\n  }, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return;\n    const fullPath = pathPrefix + jsonPtr;\n    let baseId = baseIds[parentJsonPtr];\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId]);\n    addAnchor.call(this, sch.$anchor);\n    addAnchor.call(this, sch.$dynamicAnchor);\n    baseIds[jsonPtr] = baseId;\n\n    function addRef(ref) {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve;\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref);\n      if (schemaRefs.has(ref)) throw ambiguos(ref);\n      schemaRefs.add(ref);\n      let schOrRef = this.refs[ref];\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef];\n\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref);\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref);\n          localRefs[ref] = sch;\n        } else {\n          this.refs[ref] = fullPath;\n        }\n      }\n\n      return ref;\n    }\n\n    function addAnchor(anchor) {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`);\n        addRef.call(this, `#${anchor}`);\n      }\n    }\n  });\n  return localRefs;\n\n  function checkAmbiguosRef(sch1, sch2, ref) {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref);\n  }\n\n  function ambiguos(ref) {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`);\n  }\n}\n\nexports.getSchemaRefs = getSchemaRefs;","map":{"version":3,"mappings":"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","names":["SIMPLE_INLINED","Set","inlineRef","schema","limit","hasRef","countKeys","exports","REF_KEYWORDS","key","has","sch","Array","isArray","some","count","Infinity","getFullPath","resolver","id","normalize","normalizeId","p","parse","_getFullPath","serialized","serialize","split","TRAILING_SLASH_HASH","replace","resolveUrl","baseId","resolve","ANCHOR","getSchemaRefs","schemaId","uriResolver","opts","schId","baseIds","pathPrefix","localRefs","schemaRefs","traverse","allKeys","jsonPtr","_","parentJsonPtr","undefined","fullPath","addRef","call","addAnchor","$anchor","$dynamicAnchor","ref","_resolve","ambiguos","add","schOrRef","refs","checkAmbiguosRef","anchor","test","Error","sch1","sch2","equal"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\compile\\resolve.ts"],"sourcesContent":["import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponents} from \"uri-js\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponents): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let baseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") baseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = baseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(baseId ? _resolve(baseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}