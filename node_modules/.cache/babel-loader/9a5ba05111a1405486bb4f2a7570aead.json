{"ast":null,"code":"let path = require('path');\n\nlet fs = require('fs');\n\nlet Task = require('./task/task').Task; // Split a task to two parts, name space and task name.\n// For example, given 'foo:bin/a%.c', return an object with\n// - 'ns'     : foo\n// - 'name'   : bin/a%.c\n\n\nfunction splitNs(task) {\n  let parts = task.split(':');\n  let name = parts.pop();\n  let ns = resolveNs(parts);\n  return {\n    'name': name,\n    'ns': ns\n  };\n} // Return the namespace based on an array of names.\n// For example, given ['foo', 'baz' ], return the namespace\n//\n//   default -> foo -> baz\n//\n// where default is the global root namespace\n// and -> means child namespace.\n\n\nfunction resolveNs(parts) {\n  let ns = jake.defaultNamespace;\n\n  for (let i = 0, l = parts.length; ns && i < l; i++) {\n    ns = ns.childNamespaces[parts[i]];\n  }\n\n  return ns;\n} // Given a pattern p, say 'foo:bin/a%.c'\n// Return an object with\n// - 'ns'     : foo\n// - 'dir'    : bin\n// - 'prefix' : a\n// - 'suffix' : .c\n\n\nfunction resolve(p) {\n  let task = splitNs(p);\n  let name = task.name;\n  let ns = task.ns;\n  let split = path.basename(name).split('%');\n  return {\n    ns: ns,\n    dir: path.dirname(name),\n    prefix: split[0],\n    suffix: split[1]\n  };\n} // Test whether string a is a suffix of string b\n\n\nfunction stringEndWith(a, b) {\n  let l;\n  return (l = b.lastIndexOf(a)) == -1 ? false : l + a.length == b.length;\n} // Replace the suffix a of the string s with b.\n// Note that, it is assumed a is a suffix of s.\n\n\nfunction stringReplaceSuffix(s, a, b) {\n  return s.slice(0, s.lastIndexOf(a)) + b;\n}\n\nclass Rule {\n  constructor(opts) {\n    this.pattern = opts.pattern;\n    this.source = opts.source;\n    this.prereqs = opts.prereqs;\n    this.action = opts.action;\n    this.opts = opts.opts;\n    this.desc = opts.desc;\n    this.ns = opts.ns;\n  } // Create a file task based on this rule for the specified\n  // task-name\n  // ======\n  // FIXME: Right now this just throws away any passed-in args\n  // for the synthsized task (taskArgs param)\n  // ======\n\n\n  createTask(fullName, level) {\n    let self = this;\n    let pattern;\n    let source;\n    let action;\n    let opts;\n    let prereqs;\n    let valid;\n    let src;\n    let tNs;\n    let createdTask;\n    let name = Task.getBaseTaskName(fullName);\n    let nsPath = Task.getBaseNamespacePath(fullName);\n    let ns = this.ns.resolveNamespace(nsPath);\n    pattern = this.pattern;\n    source = this.source;\n\n    if (typeof source == 'string') {\n      src = Rule.getSource(name, pattern, source);\n    } else {\n      src = source(name);\n    } // TODO: Write a utility function that appends a\n    // taskname to a namespace path\n\n\n    src = nsPath.split(':').filter(function (item) {\n      return !!item;\n    }).concat(src).join(':'); // Generate the prerequisite for the matching task.\n    //    It is the original prerequisites plus the prerequisite\n    //    representing source file, i.e.,\n    //\n    //      rule( '%.o', '%.c', ['some.h'] ...\n    //\n    //    If the objective is main.o, then new task should be\n    //\n    //      file( 'main.o', ['main.c', 'some.h' ] ...\n\n    prereqs = this.prereqs.slice(); // Get a copy to work with\n\n    prereqs.unshift(src); // Prereq should be:\n    // 1. an existing task\n    // 2. an existing file on disk\n    // 3. a valid rule (i.e., not at too deep a level)\n\n    valid = prereqs.some(function (p) {\n      let ns = self.ns;\n      return ns.resolveTask(p) || fs.existsSync(Task.getBaseTaskName(p)) || jake.attemptRule(p, ns, level + 1);\n    }); // If any of the prereqs aren't valid, the rule isn't valid\n\n    if (!valid) {\n      return null;\n    } // Otherwise, hunky-dory, finish creating the task for the rule\n    else {\n      // Create the action for the task\n      action = function () {\n        let task = this;\n        self.action.apply(task);\n      };\n\n      opts = this.opts; // Insert the file task into Jake\n      //\n      // Since createTask function stores the task as a child task\n      // of currentNamespace. Here we temporariliy switch the namespace.\n      // FIXME: Should allow optional ns passed in instead of this hack\n\n      tNs = jake.currentNamespace;\n      jake.currentNamespace = ns;\n      createdTask = jake.createTask('file', name, prereqs, action, opts);\n      createdTask.source = src.split(':').pop();\n      jake.currentNamespace = tNs;\n      return createdTask;\n    }\n  }\n\n  match(name) {\n    return Rule.match(this.pattern, name);\n  } // Test wether the a prerequisite matchs the pattern.\n  // The arg 'pattern' does not have namespace as prefix.\n  // For example, the following tests are true\n  //\n  //   pattern      |    name\n  //   bin/%.o      |    bin/main.o\n  //   bin/%.o      |    foo:bin/main.o\n  //\n  // The following tests are false (trivally)\n  //\n  //   pattern      |    name\n  //   bin/%.o      |    foobin/main.o\n  //   bin/%.o      |    bin/main.oo\n\n\n  static match(pattern, name) {\n    let p;\n    let task;\n    let obj;\n    let filename;\n\n    if (pattern instanceof RegExp) {\n      return pattern.test(name);\n    } else if (pattern.indexOf('%') == -1) {\n      // No Pattern. No Folder. No Namespace.\n      // A Simple Suffix Rule. Just test suffix\n      return stringEndWith(pattern, name);\n    } else {\n      // Resolve the dir, prefix and suffix of pattern\n      p = resolve(pattern); // Resolve the namespace and task-name\n\n      task = splitNs(name);\n      name = task.name; // Set the objective as the task-name\n\n      obj = name; // Namespace is already matched.\n      // Check dir\n\n      if (path.dirname(obj) != p.dir) {\n        return false;\n      }\n\n      filename = path.basename(obj); // Check file name length\n\n      if (p.prefix.length + p.suffix.length + 1 > filename.length) {\n        // Length does not match.\n        return false;\n      } // Check prefix\n\n\n      if (filename.indexOf(p.prefix) !== 0) {\n        return false;\n      } // Check suffix\n\n\n      if (!stringEndWith(p.suffix, filename)) {\n        return false;\n      } // OK. Find a match.\n\n\n      return true;\n    }\n  } // Generate the source based on\n  //  - name    name for the synthesized task\n  //  - pattern    pattern for the objective\n  //  - source    pattern for the source\n  //\n  // Return the source with properties\n  //  - dep      the prerequisite of source\n  //             (with the namespace)\n  //\n  //  - file     the file name of source\n  //             (without the namespace)\n  //\n  // For example, given\n  //\n  //  - name   foo:bin/main.o\n  //  - pattern    bin/%.o\n  //  - source    src/%.c\n  //\n  //    return 'foo:src/main.c',\n  //\n\n\n  static getSource(name, pattern, source) {\n    let dep;\n    let pat;\n    let match;\n    let file;\n    let src; // Regex pattern -- use to look up the extension\n\n    if (pattern instanceof RegExp) {\n      match = pattern.exec(name);\n\n      if (match) {\n        if (typeof source == 'function') {\n          src = source(name);\n        } else {\n          src = stringReplaceSuffix(name, match[0], source);\n        }\n      }\n    } // Assume string\n    else {\n      // Simple string suffix replacement\n      if (pattern.indexOf('%') == -1) {\n        if (typeof source == 'function') {\n          src = source(name);\n        } else {\n          src = stringReplaceSuffix(name, pattern, source);\n        }\n      } // Percent-based substitution\n      else {\n        pat = pattern.replace('%', '(.*?)');\n        pat = new RegExp(pat);\n        match = pat.exec(name);\n\n        if (match) {\n          if (typeof source == 'function') {\n            src = source(name);\n          } else {\n            file = match[1];\n            file = source.replace('%', file);\n            dep = match[0];\n            src = name.replace(dep, file);\n          }\n        }\n      }\n    }\n\n    return src;\n  }\n\n}\n\nexports.Rule = Rule;","map":{"version":3,"names":["path","require","fs","Task","splitNs","task","parts","split","name","pop","ns","resolveNs","jake","defaultNamespace","i","l","length","childNamespaces","resolve","p","basename","dir","dirname","prefix","suffix","stringEndWith","a","b","lastIndexOf","stringReplaceSuffix","s","slice","Rule","constructor","opts","pattern","source","prereqs","action","desc","createTask","fullName","level","self","valid","src","tNs","createdTask","getBaseTaskName","nsPath","getBaseNamespacePath","resolveNamespace","getSource","filter","item","concat","join","unshift","some","resolveTask","existsSync","attemptRule","apply","currentNamespace","match","obj","filename","RegExp","test","indexOf","dep","pat","file","exec","replace","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jake/lib/rule.js"],"sourcesContent":["let path = require('path');\nlet fs = require('fs');\nlet Task = require('./task/task').Task;\n\n// Split a task to two parts, name space and task name.\n// For example, given 'foo:bin/a%.c', return an object with\n// - 'ns'     : foo\n// - 'name'   : bin/a%.c\nfunction splitNs(task) {\n  let parts = task.split(':');\n  let name = parts.pop();\n  let ns = resolveNs(parts);\n  return {\n    'name' : name,\n    'ns'   : ns\n  };\n}\n\n// Return the namespace based on an array of names.\n// For example, given ['foo', 'baz' ], return the namespace\n//\n//   default -> foo -> baz\n//\n// where default is the global root namespace\n// and -> means child namespace.\nfunction resolveNs(parts) {\n  let  ns = jake.defaultNamespace;\n  for(let i = 0, l = parts.length; ns && i < l; i++) {\n    ns = ns.childNamespaces[parts[i]];\n  }\n  return ns;\n}\n\n// Given a pattern p, say 'foo:bin/a%.c'\n// Return an object with\n// - 'ns'     : foo\n// - 'dir'    : bin\n// - 'prefix' : a\n// - 'suffix' : .c\nfunction resolve(p) {\n  let task = splitNs(p);\n  let name  = task.name;\n  let ns    = task.ns;\n  let split = path.basename(name).split('%');\n  return {\n    ns: ns,\n    dir: path.dirname(name),\n    prefix: split[0],\n    suffix: split[1]\n  };\n}\n\n// Test whether string a is a suffix of string b\nfunction stringEndWith(a, b) {\n  let l;\n  return (l = b.lastIndexOf(a)) == -1 ? false : l + a.length == b.length;\n}\n\n// Replace the suffix a of the string s with b.\n// Note that, it is assumed a is a suffix of s.\nfunction stringReplaceSuffix(s, a, b) {\n  return s.slice(0, s.lastIndexOf(a)) + b;\n}\n\nclass Rule {\n  constructor(opts) {\n    this.pattern = opts.pattern;\n    this.source = opts.source;\n    this.prereqs = opts.prereqs;\n    this.action = opts.action;\n    this.opts = opts.opts;\n    this.desc =  opts.desc;\n    this.ns = opts.ns;\n  }\n\n  // Create a file task based on this rule for the specified\n  // task-name\n  // ======\n  // FIXME: Right now this just throws away any passed-in args\n  // for the synthsized task (taskArgs param)\n  // ======\n  createTask(fullName, level) {\n    let self = this;\n    let pattern;\n    let source;\n    let action;\n    let opts;\n    let prereqs;\n    let valid;\n    let src;\n    let tNs;\n    let createdTask;\n    let name = Task.getBaseTaskName(fullName);\n    let nsPath = Task.getBaseNamespacePath(fullName);\n    let ns = this.ns.resolveNamespace(nsPath);\n\n    pattern = this.pattern;\n    source = this.source;\n\n    if (typeof source == 'string') {\n      src = Rule.getSource(name, pattern, source);\n    }\n    else {\n      src = source(name);\n    }\n\n    // TODO: Write a utility function that appends a\n    // taskname to a namespace path\n    src = nsPath.split(':').filter(function (item) {\n      return !!item;\n    }).concat(src).join(':');\n\n    // Generate the prerequisite for the matching task.\n    //    It is the original prerequisites plus the prerequisite\n    //    representing source file, i.e.,\n    //\n    //      rule( '%.o', '%.c', ['some.h'] ...\n    //\n    //    If the objective is main.o, then new task should be\n    //\n    //      file( 'main.o', ['main.c', 'some.h' ] ...\n    prereqs = this.prereqs.slice(); // Get a copy to work with\n    prereqs.unshift(src);\n\n    // Prereq should be:\n    // 1. an existing task\n    // 2. an existing file on disk\n    // 3. a valid rule (i.e., not at too deep a level)\n    valid = prereqs.some(function (p) {\n      let ns = self.ns;\n      return ns.resolveTask(p) ||\n        fs.existsSync(Task.getBaseTaskName(p)) ||\n        jake.attemptRule(p, ns, level + 1);\n    });\n\n    // If any of the prereqs aren't valid, the rule isn't valid\n    if (!valid) {\n      return null;\n    }\n    // Otherwise, hunky-dory, finish creating the task for the rule\n    else {\n      // Create the action for the task\n      action = function () {\n        let task = this;\n        self.action.apply(task);\n      };\n\n      opts = this.opts;\n\n      // Insert the file task into Jake\n      //\n      // Since createTask function stores the task as a child task\n      // of currentNamespace. Here we temporariliy switch the namespace.\n      // FIXME: Should allow optional ns passed in instead of this hack\n      tNs = jake.currentNamespace;\n      jake.currentNamespace = ns;\n      createdTask = jake.createTask('file', name, prereqs, action, opts);\n      createdTask.source = src.split(':').pop();\n      jake.currentNamespace = tNs;\n\n      return createdTask;\n    }\n  }\n\n  match(name) {\n    return Rule.match(this.pattern, name);\n  }\n\n  // Test wether the a prerequisite matchs the pattern.\n  // The arg 'pattern' does not have namespace as prefix.\n  // For example, the following tests are true\n  //\n  //   pattern      |    name\n  //   bin/%.o      |    bin/main.o\n  //   bin/%.o      |    foo:bin/main.o\n  //\n  // The following tests are false (trivally)\n  //\n  //   pattern      |    name\n  //   bin/%.o      |    foobin/main.o\n  //   bin/%.o      |    bin/main.oo\n  static match(pattern, name) {\n    let p;\n    let task;\n    let obj;\n    let filename;\n\n    if (pattern instanceof RegExp) {\n      return pattern.test(name);\n    }\n    else if (pattern.indexOf('%') == -1) {\n      // No Pattern. No Folder. No Namespace.\n      // A Simple Suffix Rule. Just test suffix\n      return stringEndWith(pattern, name);\n    }\n    else {\n      // Resolve the dir, prefix and suffix of pattern\n      p = resolve(pattern);\n\n      // Resolve the namespace and task-name\n      task = splitNs(name);\n      name = task.name;\n\n      // Set the objective as the task-name\n      obj = name;\n\n      // Namespace is already matched.\n\n      // Check dir\n      if (path.dirname(obj) != p.dir) {\n        return false;\n      }\n\n      filename = path.basename(obj);\n\n      // Check file name length\n      if ((p.prefix.length + p.suffix.length + 1) > filename.length) {\n        // Length does not match.\n        return false;\n      }\n\n      // Check prefix\n      if (filename.indexOf(p.prefix) !== 0) {\n        return false;\n      }\n\n      // Check suffix\n      if (!stringEndWith(p.suffix, filename)) {\n        return false;\n      }\n\n      // OK. Find a match.\n      return true;\n    }\n  }\n\n  // Generate the source based on\n  //  - name    name for the synthesized task\n  //  - pattern    pattern for the objective\n  //  - source    pattern for the source\n  //\n  // Return the source with properties\n  //  - dep      the prerequisite of source\n  //             (with the namespace)\n  //\n  //  - file     the file name of source\n  //             (without the namespace)\n  //\n  // For example, given\n  //\n  //  - name   foo:bin/main.o\n  //  - pattern    bin/%.o\n  //  - source    src/%.c\n  //\n  //    return 'foo:src/main.c',\n  //\n  static getSource(name, pattern, source) {\n    let dep;\n    let pat;\n    let match;\n    let file;\n    let src;\n\n    // Regex pattern -- use to look up the extension\n    if (pattern instanceof RegExp) {\n      match = pattern.exec(name);\n      if (match) {\n        if (typeof source == 'function') {\n          src = source(name);\n        }\n        else {\n          src = stringReplaceSuffix(name, match[0], source);\n        }\n      }\n    }\n    // Assume string\n    else {\n      // Simple string suffix replacement\n      if (pattern.indexOf('%') == -1) {\n        if (typeof source == 'function') {\n          src = source(name);\n        }\n        else {\n          src = stringReplaceSuffix(name, pattern, source);\n        }\n      }\n      // Percent-based substitution\n      else {\n        pat = pattern.replace('%', '(.*?)');\n        pat = new RegExp(pat);\n        match = pat.exec(name);\n        if (match) {\n          if (typeof source == 'function') {\n            src = source(name);\n          }\n          else {\n            file = match[1];\n            file = source.replace('%', file);\n            dep = match[0];\n            src = name.replace(dep, file);\n          }\n        }\n      }\n    }\n\n    return src;\n  }\n}\n\n\nexports.Rule = Rule;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}