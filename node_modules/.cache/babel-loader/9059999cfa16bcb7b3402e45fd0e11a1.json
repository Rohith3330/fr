{"ast":null,"code":"import { useCallback, useEffect, useRef, useState } from 'react';\n/**\n * A hook that mirrors `useState` in function and API, expect that setState\n * calls return a promise that resolves after the state has been set (in an effect).\n *\n * This is _similar_ to the second callback in classy setState calls, but fires later.\n *\n * ```ts\n * const [counter, setState] = useStateAsync(1);\n *\n * const handleIncrement = async () => {\n *   await setState(2);\n *   doWorkRequiringCurrentState()\n * }\n * ```\n *\n * @param initialState initialize with some state value same as `useState`\n */\n\nexport default function useStateAsync(initialState) {\n  var _useState = useState(initialState),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var resolvers = useRef([]);\n  useEffect(function () {\n    resolvers.current.forEach(function (resolve) {\n      return resolve(state);\n    });\n    resolvers.current.length = 0;\n  }, [state]);\n  var setStateAsync = useCallback(function (update) {\n    return new Promise(function (resolve, reject) {\n      setState(function (prevState) {\n        try {\n          var nextState; // ugly instanceof for typescript\n\n          if (update instanceof Function) {\n            nextState = update(prevState);\n          } else {\n            nextState = update;\n          } // If state does not change, we must resolve the promise because\n          // react won't re-render and effect will not resolve. If there are already\n          // resolvers queued, then it should be safe to assume an update will happen\n\n\n          if (!resolvers.current.length && Object.is(nextState, prevState)) {\n            resolve(nextState);\n          } else {\n            resolvers.current.push(resolve);\n          }\n\n          return nextState;\n        } catch (e) {\n          reject(e);\n          throw e;\n        }\n      });\n    });\n  }, [setState]);\n  return [state, setStateAsync];\n}","map":{"version":3,"names":["useCallback","useEffect","useRef","useState","useStateAsync","initialState","_useState","state","setState","resolvers","current","forEach","resolve","length","setStateAsync","update","Promise","reject","prevState","nextState","Function","Object","is","push","e"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@restart/hooks/esm/useStateAsync.js"],"sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react';\n\n/**\n * A hook that mirrors `useState` in function and API, expect that setState\n * calls return a promise that resolves after the state has been set (in an effect).\n *\n * This is _similar_ to the second callback in classy setState calls, but fires later.\n *\n * ```ts\n * const [counter, setState] = useStateAsync(1);\n *\n * const handleIncrement = async () => {\n *   await setState(2);\n *   doWorkRequiringCurrentState()\n * }\n * ```\n *\n * @param initialState initialize with some state value same as `useState`\n */\nexport default function useStateAsync(initialState) {\n  var _useState = useState(initialState),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var resolvers = useRef([]);\n  useEffect(function () {\n    resolvers.current.forEach(function (resolve) {\n      return resolve(state);\n    });\n    resolvers.current.length = 0;\n  }, [state]);\n  var setStateAsync = useCallback(function (update) {\n    return new Promise(function (resolve, reject) {\n      setState(function (prevState) {\n        try {\n          var nextState; // ugly instanceof for typescript\n\n          if (update instanceof Function) {\n            nextState = update(prevState);\n          } else {\n            nextState = update;\n          } // If state does not change, we must resolve the promise because\n          // react won't re-render and effect will not resolve. If there are already\n          // resolvers queued, then it should be safe to assume an update will happen\n\n\n          if (!resolvers.current.length && Object.is(nextState, prevState)) {\n            resolve(nextState);\n          } else {\n            resolvers.current.push(resolve);\n          }\n\n          return nextState;\n        } catch (e) {\n          reject(e);\n          throw e;\n        }\n      });\n    });\n  }, [setState]);\n  return [state, setStateAsync];\n}"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,MAAjC,EAAyCC,QAAzC,QAAyD,OAAzD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,aAAT,CAAuBC,YAAvB,EAAqC;EAClD,IAAIC,SAAS,GAAGH,QAAQ,CAACE,YAAD,CAAxB;EAAA,IACIE,KAAK,GAAGD,SAAS,CAAC,CAAD,CADrB;EAAA,IAEIE,QAAQ,GAAGF,SAAS,CAAC,CAAD,CAFxB;;EAIA,IAAIG,SAAS,GAAGP,MAAM,CAAC,EAAD,CAAtB;EACAD,SAAS,CAAC,YAAY;IACpBQ,SAAS,CAACC,OAAV,CAAkBC,OAAlB,CAA0B,UAAUC,OAAV,EAAmB;MAC3C,OAAOA,OAAO,CAACL,KAAD,CAAd;IACD,CAFD;IAGAE,SAAS,CAACC,OAAV,CAAkBG,MAAlB,GAA2B,CAA3B;EACD,CALQ,EAKN,CAACN,KAAD,CALM,CAAT;EAMA,IAAIO,aAAa,GAAGd,WAAW,CAAC,UAAUe,MAAV,EAAkB;IAChD,OAAO,IAAIC,OAAJ,CAAY,UAAUJ,OAAV,EAAmBK,MAAnB,EAA2B;MAC5CT,QAAQ,CAAC,UAAUU,SAAV,EAAqB;QAC5B,IAAI;UACF,IAAIC,SAAJ,CADE,CACa;;UAEf,IAAIJ,MAAM,YAAYK,QAAtB,EAAgC;YAC9BD,SAAS,GAAGJ,MAAM,CAACG,SAAD,CAAlB;UACD,CAFD,MAEO;YACLC,SAAS,GAAGJ,MAAZ;UACD,CAPC,CAOA;UACF;UACA;;;UAGA,IAAI,CAACN,SAAS,CAACC,OAAV,CAAkBG,MAAnB,IAA6BQ,MAAM,CAACC,EAAP,CAAUH,SAAV,EAAqBD,SAArB,CAAjC,EAAkE;YAChEN,OAAO,CAACO,SAAD,CAAP;UACD,CAFD,MAEO;YACLV,SAAS,CAACC,OAAV,CAAkBa,IAAlB,CAAuBX,OAAvB;UACD;;UAED,OAAOO,SAAP;QACD,CAnBD,CAmBE,OAAOK,CAAP,EAAU;UACVP,MAAM,CAACO,CAAD,CAAN;UACA,MAAMA,CAAN;QACD;MACF,CAxBO,CAAR;IAyBD,CA1BM,CAAP;EA2BD,CA5B8B,EA4B5B,CAAChB,QAAD,CA5B4B,CAA/B;EA6BA,OAAO,CAACD,KAAD,EAAQO,aAAR,CAAP;AACD"},"metadata":{},"sourceType":"module"}