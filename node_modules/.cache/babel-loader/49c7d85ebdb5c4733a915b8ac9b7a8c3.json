{"ast":null,"code":"/**\n * @fileoverview Utility to convert gitignore patterns to minimatch.\n * @author Nicholas C. Zakas\n */\n\n/**\n * Converts a gitignore pattern to a minimatch pattern.\n * @param {string} pattern The gitignore pattern to convert. \n * @returns {string} A minimatch pattern equivalent to `pattern`.\n */\nfunction gitignoreToMinimatch(pattern) {\n  if (typeof pattern !== \"string\") {\n    throw new TypeError(\"Argument must be a string.\");\n  } // Special case: Empty string\n\n\n  if (!pattern) {\n    return pattern;\n  } // strip off negation to make life easier\n\n\n  const negated = pattern.startsWith(\"!\");\n  let patternToTest = negated ? pattern.slice(1) : pattern;\n  let result = patternToTest;\n  let leadingSlash = false; // strip off leading slash\n\n  if (patternToTest[0] === \"/\") {\n    leadingSlash = true;\n    result = patternToTest.slice(1);\n  } // For the most part, the first character determines what to do\n\n\n  switch (result[0]) {\n    case \"*\":\n      if (patternToTest[1] !== \"*\") {\n        result = \"**/\" + result;\n      }\n\n      break;\n\n    default:\n      if (!leadingSlash && !result.includes(\"/\") || result.endsWith(\"/\")) {\n        result = \"**/\" + result;\n      } // no further changes if the pattern ends with a wildcard\n\n\n      if (result.endsWith(\"*\") || result.endsWith(\"?\")) {\n        break;\n      } // differentiate between filenames and directory names\n\n\n      if (!/\\.[a-z\\d_-]+$/.test(result)) {\n        if (!result.endsWith(\"/\")) {\n          result += \"/\";\n        }\n\n        result += \"**\";\n      }\n\n  }\n\n  return negated ? \"!\" + result : result;\n}\n\nexport { gitignoreToMinimatch };","map":{"version":3,"names":["gitignoreToMinimatch","pattern","TypeError","negated","startsWith","patternToTest","slice","result","leadingSlash","includes","endsWith","test"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@humanwhocodes/gitignore-to-minimatch/dist/gitignore-to-minimatch.js"],"sourcesContent":["/**\n * @fileoverview Utility to convert gitignore patterns to minimatch.\n * @author Nicholas C. Zakas\n */\n\n/**\n * Converts a gitignore pattern to a minimatch pattern.\n * @param {string} pattern The gitignore pattern to convert. \n * @returns {string} A minimatch pattern equivalent to `pattern`.\n */\nfunction gitignoreToMinimatch(pattern) {\n\n    if (typeof pattern !== \"string\") {\n        throw new TypeError(\"Argument must be a string.\");\n    }\n\n    // Special case: Empty string\n    if (!pattern) {\n        return pattern;\n    }\n\n    // strip off negation to make life easier\n    const negated = pattern.startsWith(\"!\");\n    let patternToTest = negated ? pattern.slice(1) : pattern;\n    let result = patternToTest;\n    let leadingSlash = false;\n\n    // strip off leading slash\n    if (patternToTest[0] === \"/\") {\n        leadingSlash = true;\n        result = patternToTest.slice(1);\n    }\n\n    // For the most part, the first character determines what to do\n    switch (result[0]) {\n\n        case \"*\":\n            if (patternToTest[1] !== \"*\") {\n                result = \"**/\" + result;\n            }\n            break;\n\n        default:\n            if (!leadingSlash && !result.includes(\"/\") || result.endsWith(\"/\")) {\n                result = \"**/\" + result;\n            }\n\n            // no further changes if the pattern ends with a wildcard\n            if (result.endsWith(\"*\") || result.endsWith(\"?\")) {\n                break;\n            }\n\n            // differentiate between filenames and directory names\n            if (!/\\.[a-z\\d_-]+$/.test(result)) {\n                if (!result.endsWith(\"/\")) {\n                    result += \"/\";\n                }\n\n                result += \"**\";\n            }\n    }\n\n    return negated ? \"!\" + result : result;\n\n}\n\nexport { gitignoreToMinimatch };\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASA,oBAAT,CAA8BC,OAA9B,EAAuC;EAEnC,IAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;IAC7B,MAAM,IAAIC,SAAJ,CAAc,4BAAd,CAAN;EACH,CAJkC,CAMnC;;;EACA,IAAI,CAACD,OAAL,EAAc;IACV,OAAOA,OAAP;EACH,CATkC,CAWnC;;;EACA,MAAME,OAAO,GAAGF,OAAO,CAACG,UAAR,CAAmB,GAAnB,CAAhB;EACA,IAAIC,aAAa,GAAGF,OAAO,GAAGF,OAAO,CAACK,KAAR,CAAc,CAAd,CAAH,GAAsBL,OAAjD;EACA,IAAIM,MAAM,GAAGF,aAAb;EACA,IAAIG,YAAY,GAAG,KAAnB,CAfmC,CAiBnC;;EACA,IAAIH,aAAa,CAAC,CAAD,CAAb,KAAqB,GAAzB,EAA8B;IAC1BG,YAAY,GAAG,IAAf;IACAD,MAAM,GAAGF,aAAa,CAACC,KAAd,CAAoB,CAApB,CAAT;EACH,CArBkC,CAuBnC;;;EACA,QAAQC,MAAM,CAAC,CAAD,CAAd;IAEI,KAAK,GAAL;MACI,IAAIF,aAAa,CAAC,CAAD,CAAb,KAAqB,GAAzB,EAA8B;QAC1BE,MAAM,GAAG,QAAQA,MAAjB;MACH;;MACD;;IAEJ;MACI,IAAI,CAACC,YAAD,IAAiB,CAACD,MAAM,CAACE,QAAP,CAAgB,GAAhB,CAAlB,IAA0CF,MAAM,CAACG,QAAP,CAAgB,GAAhB,CAA9C,EAAoE;QAChEH,MAAM,GAAG,QAAQA,MAAjB;MACH,CAHL,CAKI;;;MACA,IAAIA,MAAM,CAACG,QAAP,CAAgB,GAAhB,KAAwBH,MAAM,CAACG,QAAP,CAAgB,GAAhB,CAA5B,EAAkD;QAC9C;MACH,CARL,CAUI;;;MACA,IAAI,CAAC,gBAAgBC,IAAhB,CAAqBJ,MAArB,CAAL,EAAmC;QAC/B,IAAI,CAACA,MAAM,CAACG,QAAP,CAAgB,GAAhB,CAAL,EAA2B;UACvBH,MAAM,IAAI,GAAV;QACH;;QAEDA,MAAM,IAAI,IAAV;MACH;;EAzBT;;EA4BA,OAAOJ,OAAO,GAAG,MAAMI,MAAT,GAAkBA,MAAhC;AAEH;;AAED,SAASP,oBAAT"},"metadata":{},"sourceType":"module"}