{"ast":null,"code":"'use strict';\n\nconst csstree = require('css-tree');\n\nconst {\n  referencesProps\n} = require('./_collections.js');\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').PluginInfo} PluginInfo\n */\n\n\nexports.type = 'visitor';\nexports.name = 'prefixIds';\nexports.active = false;\nexports.description = 'prefix IDs';\n/**\n * extract basename from path\n * @type {(path: string) => string}\n */\n\nconst getBasename = path => {\n  // extract everything after latest slash or backslash\n  const matched = path.match(/[/\\\\]?([^/\\\\]+)$/);\n\n  if (matched) {\n    return matched[1];\n  }\n\n  return '';\n};\n/**\n * escapes a string for being used as ID\n * @type {(string: string) => string}\n */\n\n\nconst escapeIdentifierName = str => {\n  return str.replace(/[. ]/g, '_');\n};\n/**\n * @type {(string: string) => string}\n */\n\n\nconst unquote = string => {\n  if (string.startsWith('\"') && string.endsWith('\"') || string.startsWith(\"'\") && string.endsWith(\"'\")) {\n    return string.slice(1, -1);\n  }\n\n  return string;\n};\n/**\n * prefix an ID\n * @type {(prefix: string, name: string) => string}\n */\n\n\nconst prefixId = (prefix, value) => {\n  if (value.startsWith(prefix)) {\n    return value;\n  }\n\n  return prefix + value;\n};\n/**\n * prefix an #ID\n * @type {(prefix: string, name: string) => string | null}\n */\n\n\nconst prefixReference = (prefix, value) => {\n  if (value.startsWith('#')) {\n    return '#' + prefixId(prefix, value.slice(1));\n  }\n\n  return null;\n};\n/**\n * Prefixes identifiers\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('../lib/types').Plugin<{\n *   prefix?: boolean | string | ((node: XastElement, info: PluginInfo) => string),\n *   delim?: string,\n *   prefixIds?: boolean,\n *   prefixClassNames?: boolean,\n * }>}\n */\n\n\nexports.fn = (_root, params, info) => {\n  const {\n    delim = '__',\n    prefixIds = true,\n    prefixClassNames = true\n  } = params;\n  return {\n    element: {\n      enter: node => {\n        /**\n         * prefix, from file name or option\n         * @type {string}\n         */\n        let prefix = 'prefix' + delim;\n\n        if (typeof params.prefix === 'function') {\n          prefix = params.prefix(node, info) + delim;\n        } else if (typeof params.prefix === 'string') {\n          prefix = params.prefix + delim;\n        } else if (params.prefix === false) {\n          prefix = '';\n        } else if (info.path != null && info.path.length > 0) {\n          prefix = escapeIdentifierName(getBasename(info.path)) + delim;\n        } // prefix id/class selectors and url() references in styles\n\n\n        if (node.name === 'style') {\n          // skip empty <style/> elements\n          if (node.children.length === 0) {\n            return;\n          } // parse styles\n\n\n          let cssText = '';\n\n          if (node.children[0].type === 'text' || node.children[0].type === 'cdata') {\n            cssText = node.children[0].value;\n          }\n          /**\n           * @type {null | csstree.CssNode}\n           */\n\n\n          let cssAst = null;\n\n          try {\n            cssAst = csstree.parse(cssText, {\n              parseValue: true,\n              parseCustomProperty: false\n            });\n          } catch {\n            return;\n          }\n\n          csstree.walk(cssAst, node => {\n            // #ID, .class selectors\n            if (prefixIds && node.type === 'IdSelector' || prefixClassNames && node.type === 'ClassSelector') {\n              node.name = prefixId(prefix, node.name);\n              return;\n            } // url(...) references\n\n\n            if (node.type === 'Url' && node.value.value && node.value.value.length > 0) {\n              const prefixed = prefixReference(prefix, unquote(node.value.value));\n\n              if (prefixed != null) {\n                node.value.value = prefixed;\n              }\n            }\n          }); // update styles\n\n          if (node.children[0].type === 'text' || node.children[0].type === 'cdata') {\n            node.children[0].value = csstree.generate(cssAst);\n          }\n\n          return;\n        } // prefix an ID attribute value\n\n\n        if (prefixIds && node.attributes.id != null && node.attributes.id.length !== 0) {\n          node.attributes.id = prefixId(prefix, node.attributes.id);\n        } // prefix a class attribute value\n\n\n        if (prefixClassNames && node.attributes.class != null && node.attributes.class.length !== 0) {\n          node.attributes.class = node.attributes.class.split(/\\s+/).map(name => prefixId(prefix, name)).join(' ');\n        } // prefix a href attribute value\n        // xlink:href is deprecated, must be still supported\n\n\n        for (const name of ['href', 'xlink:href']) {\n          if (node.attributes[name] != null && node.attributes[name].length !== 0) {\n            const prefixed = prefixReference(prefix, node.attributes[name]);\n\n            if (prefixed != null) {\n              node.attributes[name] = prefixed;\n            }\n          }\n        } // prefix an URL attribute value\n\n\n        for (const name of referencesProps) {\n          if (node.attributes[name] != null && node.attributes[name].length !== 0) {\n            node.attributes[name] = node.attributes[name].replace(/url\\((.*?)\\)/gi, (match, url) => {\n              const prefixed = prefixReference(prefix, url);\n\n              if (prefixed == null) {\n                return match;\n              }\n\n              return `url(${prefixed})`;\n            });\n          }\n        } // prefix begin/end attribute value\n\n\n        for (const name of ['begin', 'end']) {\n          if (node.attributes[name] != null && node.attributes[name].length !== 0) {\n            const parts = node.attributes[name].split(/\\s*;\\s+/).map(val => {\n              if (val.endsWith('.end') || val.endsWith('.start')) {\n                const [id, postfix] = val.split('.');\n                return `${prefixId(prefix, id)}.${postfix}`;\n              }\n\n              return val;\n            });\n            node.attributes[name] = parts.join('; ');\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["csstree","require","referencesProps","exports","type","name","active","description","getBasename","path","matched","match","escapeIdentifierName","str","replace","unquote","string","startsWith","endsWith","slice","prefixId","prefix","value","prefixReference","fn","_root","params","info","delim","prefixIds","prefixClassNames","element","enter","node","length","children","cssText","cssAst","parse","parseValue","parseCustomProperty","walk","prefixed","generate","attributes","id","class","split","map","join","url","parts","val","postfix"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/svgo/plugins/prefixIds.js"],"sourcesContent":["'use strict';\n\nconst csstree = require('css-tree');\nconst { referencesProps } = require('./_collections.js');\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').PluginInfo} PluginInfo\n */\n\nexports.type = 'visitor';\nexports.name = 'prefixIds';\nexports.active = false;\nexports.description = 'prefix IDs';\n\n/**\n * extract basename from path\n * @type {(path: string) => string}\n */\nconst getBasename = (path) => {\n  // extract everything after latest slash or backslash\n  const matched = path.match(/[/\\\\]?([^/\\\\]+)$/);\n  if (matched) {\n    return matched[1];\n  }\n  return '';\n};\n\n/**\n * escapes a string for being used as ID\n * @type {(string: string) => string}\n */\nconst escapeIdentifierName = (str) => {\n  return str.replace(/[. ]/g, '_');\n};\n\n/**\n * @type {(string: string) => string}\n */\nconst unquote = (string) => {\n  if (\n    (string.startsWith('\"') && string.endsWith('\"')) ||\n    (string.startsWith(\"'\") && string.endsWith(\"'\"))\n  ) {\n    return string.slice(1, -1);\n  }\n  return string;\n};\n\n/**\n * prefix an ID\n * @type {(prefix: string, name: string) => string}\n */\nconst prefixId = (prefix, value) => {\n  if (value.startsWith(prefix)) {\n    return value;\n  }\n  return prefix + value;\n};\n\n/**\n * prefix an #ID\n * @type {(prefix: string, name: string) => string | null}\n */\nconst prefixReference = (prefix, value) => {\n  if (value.startsWith('#')) {\n    return '#' + prefixId(prefix, value.slice(1));\n  }\n  return null;\n};\n\n/**\n * Prefixes identifiers\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('../lib/types').Plugin<{\n *   prefix?: boolean | string | ((node: XastElement, info: PluginInfo) => string),\n *   delim?: string,\n *   prefixIds?: boolean,\n *   prefixClassNames?: boolean,\n * }>}\n */\nexports.fn = (_root, params, info) => {\n  const { delim = '__', prefixIds = true, prefixClassNames = true } = params;\n\n  return {\n    element: {\n      enter: (node) => {\n        /**\n         * prefix, from file name or option\n         * @type {string}\n         */\n        let prefix = 'prefix' + delim;\n        if (typeof params.prefix === 'function') {\n          prefix = params.prefix(node, info) + delim;\n        } else if (typeof params.prefix === 'string') {\n          prefix = params.prefix + delim;\n        } else if (params.prefix === false) {\n          prefix = '';\n        } else if (info.path != null && info.path.length > 0) {\n          prefix = escapeIdentifierName(getBasename(info.path)) + delim;\n        }\n\n        // prefix id/class selectors and url() references in styles\n        if (node.name === 'style') {\n          // skip empty <style/> elements\n          if (node.children.length === 0) {\n            return;\n          }\n\n          // parse styles\n          let cssText = '';\n          if (\n            node.children[0].type === 'text' ||\n            node.children[0].type === 'cdata'\n          ) {\n            cssText = node.children[0].value;\n          }\n          /**\n           * @type {null | csstree.CssNode}\n           */\n          let cssAst = null;\n          try {\n            cssAst = csstree.parse(cssText, {\n              parseValue: true,\n              parseCustomProperty: false,\n            });\n          } catch {\n            return;\n          }\n\n          csstree.walk(cssAst, (node) => {\n            // #ID, .class selectors\n            if (\n              (prefixIds && node.type === 'IdSelector') ||\n              (prefixClassNames && node.type === 'ClassSelector')\n            ) {\n              node.name = prefixId(prefix, node.name);\n              return;\n            }\n            // url(...) references\n            if (\n              node.type === 'Url' &&\n              node.value.value &&\n              node.value.value.length > 0\n            ) {\n              const prefixed = prefixReference(\n                prefix,\n                unquote(node.value.value)\n              );\n              if (prefixed != null) {\n                node.value.value = prefixed;\n              }\n            }\n          });\n\n          // update styles\n          if (\n            node.children[0].type === 'text' ||\n            node.children[0].type === 'cdata'\n          ) {\n            node.children[0].value = csstree.generate(cssAst);\n          }\n          return;\n        }\n\n        // prefix an ID attribute value\n        if (\n          prefixIds &&\n          node.attributes.id != null &&\n          node.attributes.id.length !== 0\n        ) {\n          node.attributes.id = prefixId(prefix, node.attributes.id);\n        }\n\n        // prefix a class attribute value\n        if (\n          prefixClassNames &&\n          node.attributes.class != null &&\n          node.attributes.class.length !== 0\n        ) {\n          node.attributes.class = node.attributes.class\n            .split(/\\s+/)\n            .map((name) => prefixId(prefix, name))\n            .join(' ');\n        }\n\n        // prefix a href attribute value\n        // xlink:href is deprecated, must be still supported\n        for (const name of ['href', 'xlink:href']) {\n          if (\n            node.attributes[name] != null &&\n            node.attributes[name].length !== 0\n          ) {\n            const prefixed = prefixReference(prefix, node.attributes[name]);\n            if (prefixed != null) {\n              node.attributes[name] = prefixed;\n            }\n          }\n        }\n\n        // prefix an URL attribute value\n        for (const name of referencesProps) {\n          if (\n            node.attributes[name] != null &&\n            node.attributes[name].length !== 0\n          ) {\n            node.attributes[name] = node.attributes[name].replace(\n              /url\\((.*?)\\)/gi,\n              (match, url) => {\n                const prefixed = prefixReference(prefix, url);\n                if (prefixed == null) {\n                  return match;\n                }\n                return `url(${prefixed})`;\n              }\n            );\n          }\n        }\n\n        // prefix begin/end attribute value\n        for (const name of ['begin', 'end']) {\n          if (\n            node.attributes[name] != null &&\n            node.attributes[name].length !== 0\n          ) {\n            const parts = node.attributes[name].split(/\\s*;\\s+/).map((val) => {\n              if (val.endsWith('.end') || val.endsWith('.start')) {\n                const [id, postfix] = val.split('.');\n                return `${prefixId(prefix, id)}.${postfix}`;\n              }\n              return val;\n            });\n            node.attributes[name] = parts.join('; ');\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAM;EAAEC;AAAF,IAAsBD,OAAO,CAAC,mBAAD,CAAnC;AAEA;AACA;AACA;AACA;;;AAEAE,OAAO,CAACC,IAAR,GAAe,SAAf;AACAD,OAAO,CAACE,IAAR,GAAe,WAAf;AACAF,OAAO,CAACG,MAAR,GAAiB,KAAjB;AACAH,OAAO,CAACI,WAAR,GAAsB,YAAtB;AAEA;AACA;AACA;AACA;;AACA,MAAMC,WAAW,GAAIC,IAAD,IAAU;EAC5B;EACA,MAAMC,OAAO,GAAGD,IAAI,CAACE,KAAL,CAAW,kBAAX,CAAhB;;EACA,IAAID,OAAJ,EAAa;IACX,OAAOA,OAAO,CAAC,CAAD,CAAd;EACD;;EACD,OAAO,EAAP;AACD,CAPD;AASA;AACA;AACA;AACA;;;AACA,MAAME,oBAAoB,GAAIC,GAAD,IAAS;EACpC,OAAOA,GAAG,CAACC,OAAJ,CAAY,OAAZ,EAAqB,GAArB,CAAP;AACD,CAFD;AAIA;AACA;AACA;;;AACA,MAAMC,OAAO,GAAIC,MAAD,IAAY;EAC1B,IACGA,MAAM,CAACC,UAAP,CAAkB,GAAlB,KAA0BD,MAAM,CAACE,QAAP,CAAgB,GAAhB,CAA3B,IACCF,MAAM,CAACC,UAAP,CAAkB,GAAlB,KAA0BD,MAAM,CAACE,QAAP,CAAgB,GAAhB,CAF7B,EAGE;IACA,OAAOF,MAAM,CAACG,KAAP,CAAa,CAAb,EAAgB,CAAC,CAAjB,CAAP;EACD;;EACD,OAAOH,MAAP;AACD,CARD;AAUA;AACA;AACA;AACA;;;AACA,MAAMI,QAAQ,GAAG,CAACC,MAAD,EAASC,KAAT,KAAmB;EAClC,IAAIA,KAAK,CAACL,UAAN,CAAiBI,MAAjB,CAAJ,EAA8B;IAC5B,OAAOC,KAAP;EACD;;EACD,OAAOD,MAAM,GAAGC,KAAhB;AACD,CALD;AAOA;AACA;AACA;AACA;;;AACA,MAAMC,eAAe,GAAG,CAACF,MAAD,EAASC,KAAT,KAAmB;EACzC,IAAIA,KAAK,CAACL,UAAN,CAAiB,GAAjB,CAAJ,EAA2B;IACzB,OAAO,MAAMG,QAAQ,CAACC,MAAD,EAASC,KAAK,CAACH,KAAN,CAAY,CAAZ,CAAT,CAArB;EACD;;EACD,OAAO,IAAP;AACD,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAhB,OAAO,CAACqB,EAAR,GAAa,CAACC,KAAD,EAAQC,MAAR,EAAgBC,IAAhB,KAAyB;EACpC,MAAM;IAAEC,KAAK,GAAG,IAAV;IAAgBC,SAAS,GAAG,IAA5B;IAAkCC,gBAAgB,GAAG;EAArD,IAA8DJ,MAApE;EAEA,OAAO;IACLK,OAAO,EAAE;MACPC,KAAK,EAAGC,IAAD,IAAU;QACf;AACR;AACA;AACA;QACQ,IAAIZ,MAAM,GAAG,WAAWO,KAAxB;;QACA,IAAI,OAAOF,MAAM,CAACL,MAAd,KAAyB,UAA7B,EAAyC;UACvCA,MAAM,GAAGK,MAAM,CAACL,MAAP,CAAcY,IAAd,EAAoBN,IAApB,IAA4BC,KAArC;QACD,CAFD,MAEO,IAAI,OAAOF,MAAM,CAACL,MAAd,KAAyB,QAA7B,EAAuC;UAC5CA,MAAM,GAAGK,MAAM,CAACL,MAAP,GAAgBO,KAAzB;QACD,CAFM,MAEA,IAAIF,MAAM,CAACL,MAAP,KAAkB,KAAtB,EAA6B;UAClCA,MAAM,GAAG,EAAT;QACD,CAFM,MAEA,IAAIM,IAAI,CAAClB,IAAL,IAAa,IAAb,IAAqBkB,IAAI,CAAClB,IAAL,CAAUyB,MAAV,GAAmB,CAA5C,EAA+C;UACpDb,MAAM,GAAGT,oBAAoB,CAACJ,WAAW,CAACmB,IAAI,CAAClB,IAAN,CAAZ,CAApB,GAA+CmB,KAAxD;QACD,CAdc,CAgBf;;;QACA,IAAIK,IAAI,CAAC5B,IAAL,KAAc,OAAlB,EAA2B;UACzB;UACA,IAAI4B,IAAI,CAACE,QAAL,CAAcD,MAAd,KAAyB,CAA7B,EAAgC;YAC9B;UACD,CAJwB,CAMzB;;;UACA,IAAIE,OAAO,GAAG,EAAd;;UACA,IACEH,IAAI,CAACE,QAAL,CAAc,CAAd,EAAiB/B,IAAjB,KAA0B,MAA1B,IACA6B,IAAI,CAACE,QAAL,CAAc,CAAd,EAAiB/B,IAAjB,KAA0B,OAF5B,EAGE;YACAgC,OAAO,GAAGH,IAAI,CAACE,QAAL,CAAc,CAAd,EAAiBb,KAA3B;UACD;UACD;AACV;AACA;;;UACU,IAAIe,MAAM,GAAG,IAAb;;UACA,IAAI;YACFA,MAAM,GAAGrC,OAAO,CAACsC,KAAR,CAAcF,OAAd,EAAuB;cAC9BG,UAAU,EAAE,IADkB;cAE9BC,mBAAmB,EAAE;YAFS,CAAvB,CAAT;UAID,CALD,CAKE,MAAM;YACN;UACD;;UAEDxC,OAAO,CAACyC,IAAR,CAAaJ,MAAb,EAAsBJ,IAAD,IAAU;YAC7B;YACA,IACGJ,SAAS,IAAII,IAAI,CAAC7B,IAAL,KAAc,YAA5B,IACC0B,gBAAgB,IAAIG,IAAI,CAAC7B,IAAL,KAAc,eAFrC,EAGE;cACA6B,IAAI,CAAC5B,IAAL,GAAYe,QAAQ,CAACC,MAAD,EAASY,IAAI,CAAC5B,IAAd,CAApB;cACA;YACD,CAR4B,CAS7B;;;YACA,IACE4B,IAAI,CAAC7B,IAAL,KAAc,KAAd,IACA6B,IAAI,CAACX,KAAL,CAAWA,KADX,IAEAW,IAAI,CAACX,KAAL,CAAWA,KAAX,CAAiBY,MAAjB,GAA0B,CAH5B,EAIE;cACA,MAAMQ,QAAQ,GAAGnB,eAAe,CAC9BF,MAD8B,EAE9BN,OAAO,CAACkB,IAAI,CAACX,KAAL,CAAWA,KAAZ,CAFuB,CAAhC;;cAIA,IAAIoB,QAAQ,IAAI,IAAhB,EAAsB;gBACpBT,IAAI,CAACX,KAAL,CAAWA,KAAX,GAAmBoB,QAAnB;cACD;YACF;UACF,CAvBD,EA3ByB,CAoDzB;;UACA,IACET,IAAI,CAACE,QAAL,CAAc,CAAd,EAAiB/B,IAAjB,KAA0B,MAA1B,IACA6B,IAAI,CAACE,QAAL,CAAc,CAAd,EAAiB/B,IAAjB,KAA0B,OAF5B,EAGE;YACA6B,IAAI,CAACE,QAAL,CAAc,CAAd,EAAiBb,KAAjB,GAAyBtB,OAAO,CAAC2C,QAAR,CAAiBN,MAAjB,CAAzB;UACD;;UACD;QACD,CA7Ec,CA+Ef;;;QACA,IACER,SAAS,IACTI,IAAI,CAACW,UAAL,CAAgBC,EAAhB,IAAsB,IADtB,IAEAZ,IAAI,CAACW,UAAL,CAAgBC,EAAhB,CAAmBX,MAAnB,KAA8B,CAHhC,EAIE;UACAD,IAAI,CAACW,UAAL,CAAgBC,EAAhB,GAAqBzB,QAAQ,CAACC,MAAD,EAASY,IAAI,CAACW,UAAL,CAAgBC,EAAzB,CAA7B;QACD,CAtFc,CAwFf;;;QACA,IACEf,gBAAgB,IAChBG,IAAI,CAACW,UAAL,CAAgBE,KAAhB,IAAyB,IADzB,IAEAb,IAAI,CAACW,UAAL,CAAgBE,KAAhB,CAAsBZ,MAAtB,KAAiC,CAHnC,EAIE;UACAD,IAAI,CAACW,UAAL,CAAgBE,KAAhB,GAAwBb,IAAI,CAACW,UAAL,CAAgBE,KAAhB,CACrBC,KADqB,CACf,KADe,EAErBC,GAFqB,CAEhB3C,IAAD,IAAUe,QAAQ,CAACC,MAAD,EAAShB,IAAT,CAFD,EAGrB4C,IAHqB,CAGhB,GAHgB,CAAxB;QAID,CAlGc,CAoGf;QACA;;;QACA,KAAK,MAAM5C,IAAX,IAAmB,CAAC,MAAD,EAAS,YAAT,CAAnB,EAA2C;UACzC,IACE4B,IAAI,CAACW,UAAL,CAAgBvC,IAAhB,KAAyB,IAAzB,IACA4B,IAAI,CAACW,UAAL,CAAgBvC,IAAhB,EAAsB6B,MAAtB,KAAiC,CAFnC,EAGE;YACA,MAAMQ,QAAQ,GAAGnB,eAAe,CAACF,MAAD,EAASY,IAAI,CAACW,UAAL,CAAgBvC,IAAhB,CAAT,CAAhC;;YACA,IAAIqC,QAAQ,IAAI,IAAhB,EAAsB;cACpBT,IAAI,CAACW,UAAL,CAAgBvC,IAAhB,IAAwBqC,QAAxB;YACD;UACF;QACF,CAhHc,CAkHf;;;QACA,KAAK,MAAMrC,IAAX,IAAmBH,eAAnB,EAAoC;UAClC,IACE+B,IAAI,CAACW,UAAL,CAAgBvC,IAAhB,KAAyB,IAAzB,IACA4B,IAAI,CAACW,UAAL,CAAgBvC,IAAhB,EAAsB6B,MAAtB,KAAiC,CAFnC,EAGE;YACAD,IAAI,CAACW,UAAL,CAAgBvC,IAAhB,IAAwB4B,IAAI,CAACW,UAAL,CAAgBvC,IAAhB,EAAsBS,OAAtB,CACtB,gBADsB,EAEtB,CAACH,KAAD,EAAQuC,GAAR,KAAgB;cACd,MAAMR,QAAQ,GAAGnB,eAAe,CAACF,MAAD,EAAS6B,GAAT,CAAhC;;cACA,IAAIR,QAAQ,IAAI,IAAhB,EAAsB;gBACpB,OAAO/B,KAAP;cACD;;cACD,OAAQ,OAAM+B,QAAS,GAAvB;YACD,CARqB,CAAxB;UAUD;QACF,CAnIc,CAqIf;;;QACA,KAAK,MAAMrC,IAAX,IAAmB,CAAC,OAAD,EAAU,KAAV,CAAnB,EAAqC;UACnC,IACE4B,IAAI,CAACW,UAAL,CAAgBvC,IAAhB,KAAyB,IAAzB,IACA4B,IAAI,CAACW,UAAL,CAAgBvC,IAAhB,EAAsB6B,MAAtB,KAAiC,CAFnC,EAGE;YACA,MAAMiB,KAAK,GAAGlB,IAAI,CAACW,UAAL,CAAgBvC,IAAhB,EAAsB0C,KAAtB,CAA4B,SAA5B,EAAuCC,GAAvC,CAA4CI,GAAD,IAAS;cAChE,IAAIA,GAAG,CAAClC,QAAJ,CAAa,MAAb,KAAwBkC,GAAG,CAAClC,QAAJ,CAAa,QAAb,CAA5B,EAAoD;gBAClD,MAAM,CAAC2B,EAAD,EAAKQ,OAAL,IAAgBD,GAAG,CAACL,KAAJ,CAAU,GAAV,CAAtB;gBACA,OAAQ,GAAE3B,QAAQ,CAACC,MAAD,EAASwB,EAAT,CAAa,IAAGQ,OAAQ,EAA1C;cACD;;cACD,OAAOD,GAAP;YACD,CANa,CAAd;YAOAnB,IAAI,CAACW,UAAL,CAAgBvC,IAAhB,IAAwB8C,KAAK,CAACF,IAAN,CAAW,IAAX,CAAxB;UACD;QACF;MACF;IAtJM;EADJ,CAAP;AA0JD,CA7JD"},"metadata":{},"sourceType":"script"}