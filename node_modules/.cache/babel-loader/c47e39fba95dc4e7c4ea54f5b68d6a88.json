{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _core = require(\"@babel/core\");\n\nconst buildForAwait = (0, _core.template)(`\n  async function wrapper() {\n    var ITERATOR_ABRUPT_COMPLETION = false;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY;\n        ITERATOR_ABRUPT_COMPLETION = !(STEP_KEY = await ITERATOR_KEY.next()).done;\n        ITERATOR_ABRUPT_COMPLETION = false\n      ) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (ITERATOR_ABRUPT_COMPLETION && ITERATOR_KEY.return != null) {\n          await ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n`);\n\nfunction _default(path, _ref) {\n  let {\n    getAsyncIterator\n  } = _ref;\n  const {\n    node,\n    scope,\n    parent\n  } = path;\n  const stepKey = scope.generateUidIdentifier(\"step\");\n\n  const stepValue = _core.types.memberExpression(stepKey, _core.types.identifier(\"value\"));\n\n  const left = node.left;\n  let declar;\n\n  if (_core.types.isIdentifier(left) || _core.types.isPattern(left) || _core.types.isMemberExpression(left)) {\n    declar = _core.types.expressionStatement(_core.types.assignmentExpression(\"=\", left, stepValue));\n  } else if (_core.types.isVariableDeclaration(left)) {\n    declar = _core.types.variableDeclaration(left.kind, [_core.types.variableDeclarator(left.declarations[0].id, stepValue)]);\n  }\n\n  let template = buildForAwait({\n    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier(\"didIteratorError\"),\n    ITERATOR_ABRUPT_COMPLETION: scope.generateUidIdentifier(\"iteratorAbruptCompletion\"),\n    ITERATOR_ERROR_KEY: scope.generateUidIdentifier(\"iteratorError\"),\n    ITERATOR_KEY: scope.generateUidIdentifier(\"iterator\"),\n    GET_ITERATOR: getAsyncIterator,\n    OBJECT: node.right,\n    STEP_KEY: _core.types.cloneNode(stepKey)\n  });\n  template = template.body.body;\n\n  const isLabeledParent = _core.types.isLabeledStatement(parent);\n\n  const tryBody = template[3].block.body;\n  const loop = tryBody[0];\n\n  if (isLabeledParent) {\n    tryBody[0] = _core.types.labeledStatement(parent.label, loop);\n  }\n\n  return {\n    replaceParent: isLabeledParent,\n    node: template,\n    declar,\n    loop\n  };\n}","map":{"version":3,"mappings":";;;;;;;AAAA;;AAGA,MAAMA,aAAa,GAAG,oBAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CA3BsB,CAAtB;;AA6Be,kBACbC,IADa,QAGb;EAAA,IADA;IAAEC;EAAF,CACA;EACA,MAAM;IAAEC,IAAF;IAAQC,KAAR;IAAeC;EAAf,IAA0BJ,IAAhC;EAEA,MAAMK,OAAO,GAAGF,KAAK,CAACG,qBAANH,CAA4B,MAA5BA,CAAhB;;EACA,MAAMI,SAAS,GAAGC,YAAEC,gBAAFD,CAAmBH,OAAnBG,EAA4BA,YAAEE,UAAFF,CAAa,OAAbA,CAA5BA,CAAlB;;EACA,MAAMG,IAAI,GAAGT,IAAI,CAACS,IAAlB;EACA,IAAIC,MAAJ;;EAEA,IAAIJ,YAAEK,YAAFL,CAAeG,IAAfH,KAAwBA,YAAEM,SAAFN,CAAYG,IAAZH,CAAxBA,IAA6CA,YAAEO,kBAAFP,CAAqBG,IAArBH,CAAjD,EAA6E;IAE3EI,MAAM,GAAGJ,YAAEQ,mBAAFR,CACPA,YAAES,oBAAFT,CAAuB,GAAvBA,EAA4BG,IAA5BH,EAAkCD,SAAlCC,CADOA,CAATI;EAFF,OAKO,IAAIJ,YAAEU,qBAAFV,CAAwBG,IAAxBH,CAAJ,EAAmC;IAExCI,MAAM,GAAGJ,YAAEW,mBAAFX,CAAsBG,IAAI,CAACS,IAA3BZ,EAAiC,CACxCA,YAAEa,kBAAFb,CAAqBG,IAAI,CAACW,YAALX,CAAkB,CAAlBA,EAAqBY,EAA1Cf,EAA8CD,SAA9CC,CADwC,CAAjCA,CAATI;EAGD;;EACD,IAAIY,QAAQ,GAAGzB,aAAa,CAAC;IAC3B0B,sBAAsB,EAAEtB,KAAK,CAACG,qBAANH,CAA4B,kBAA5BA,CADG;IAE3BuB,0BAA0B,EAAEvB,KAAK,CAACG,qBAANH,CAC1B,0BAD0BA,CAFD;IAK3BwB,kBAAkB,EAAExB,KAAK,CAACG,qBAANH,CAA4B,eAA5BA,CALO;IAM3ByB,YAAY,EAAEzB,KAAK,CAACG,qBAANH,CAA4B,UAA5BA,CANa;IAO3B0B,YAAY,EAAE5B,gBAPa;IAQ3B6B,MAAM,EAAE5B,IAAI,CAAC6B,KARc;IAS3BC,QAAQ,EAAExB,YAAEyB,SAAFzB,CAAYH,OAAZG;EATiB,CAAD,CAA5B;EAcAgB,QAAQ,GAAGA,QAAQ,CAACU,IAATV,CAAcU,IAAzBV;;EAEA,MAAMW,eAAe,GAAG3B,YAAE4B,kBAAF5B,CAAqBJ,MAArBI,CAAxB;;EACA,MAAM6B,OAAO,GAAIb,QAAQ,CAAC,CAAD,CAARA,CAA+Bc,KAA/Bd,CAAqCU,IAAtD;EACA,MAAMK,IAAI,GAAGF,OAAO,CAAC,CAAD,CAApB;;EAEA,IAAIF,eAAJ,EAAqB;IACnBE,OAAO,CAAC,CAAD,CAAPA,GAAa7B,YAAEgC,gBAAFhC,CAAmBJ,MAAM,CAACqC,KAA1BjC,EAAiC+B,IAAjC/B,CAAb6B;EACD;;EAED,OAAO;IACLK,aAAa,EAAEP,eADV;IAELjC,IAAI,EAAEsB,QAFD;IAGLZ,MAHK;IAIL2B;EAJK,CAAP;AAMD","names":["buildForAwait","path","getAsyncIterator","node","scope","parent","stepKey","generateUidIdentifier","stepValue","t","memberExpression","identifier","left","declar","isIdentifier","isPattern","isMemberExpression","expressionStatement","assignmentExpression","isVariableDeclaration","variableDeclaration","kind","variableDeclarator","declarations","id","template","ITERATOR_HAD_ERROR_KEY","ITERATOR_ABRUPT_COMPLETION","ITERATOR_ERROR_KEY","ITERATOR_KEY","GET_ITERATOR","OBJECT","right","STEP_KEY","cloneNode","body","isLabeledParent","isLabeledStatement","tryBody","block","loop","labeledStatement","label","replaceParent"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\plugin-proposal-async-generator-functions\\src\\for-await.ts"],"sourcesContent":["import { types as t, template } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\n\nconst buildForAwait = template(`\n  async function wrapper() {\n    var ITERATOR_ABRUPT_COMPLETION = false;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY;\n        ITERATOR_ABRUPT_COMPLETION = !(STEP_KEY = await ITERATOR_KEY.next()).done;\n        ITERATOR_ABRUPT_COMPLETION = false\n      ) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (ITERATOR_ABRUPT_COMPLETION && ITERATOR_KEY.return != null) {\n          await ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n`);\n\nexport default function (\n  path: NodePath<t.ForOfStatement>,\n  { getAsyncIterator }: { getAsyncIterator: t.Identifier },\n) {\n  const { node, scope, parent } = path;\n\n  const stepKey = scope.generateUidIdentifier(\"step\");\n  const stepValue = t.memberExpression(stepKey, t.identifier(\"value\"));\n  const left = node.left;\n  let declar;\n\n  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {\n    // for await (i of test), for await ({ i } of test)\n    declar = t.expressionStatement(\n      t.assignmentExpression(\"=\", left, stepValue),\n    );\n  } else if (t.isVariableDeclaration(left)) {\n    // for await (let i of test)\n    declar = t.variableDeclaration(left.kind, [\n      t.variableDeclarator(left.declarations[0].id, stepValue),\n    ]);\n  }\n  let template = buildForAwait({\n    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier(\"didIteratorError\"),\n    ITERATOR_ABRUPT_COMPLETION: scope.generateUidIdentifier(\n      \"iteratorAbruptCompletion\",\n    ),\n    ITERATOR_ERROR_KEY: scope.generateUidIdentifier(\"iteratorError\"),\n    ITERATOR_KEY: scope.generateUidIdentifier(\"iterator\"),\n    GET_ITERATOR: getAsyncIterator,\n    OBJECT: node.right,\n    STEP_KEY: t.cloneNode(stepKey),\n  });\n\n  // remove async function wrapper\n  // @ts-expect-error todo(flow->ts) improve type annotation for buildForAwait\n  template = template.body.body as t.Statement[];\n\n  const isLabeledParent = t.isLabeledStatement(parent);\n  const tryBody = (template[3] as t.TryStatement).block.body;\n  const loop = tryBody[0] as t.ForStatement;\n\n  if (isLabeledParent) {\n    tryBody[0] = t.labeledStatement(parent.label, loop);\n  }\n\n  return {\n    replaceParent: isLabeledParent,\n    node: template,\n    declar,\n    loop,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}