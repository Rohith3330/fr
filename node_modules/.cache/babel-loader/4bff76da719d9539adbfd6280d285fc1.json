{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.computeAccessibleDescription = computeAccessibleDescription;\n\nvar _accessibleNameAndDescription = require(\"./accessible-name-and-description\");\n\nvar _util = require(\"./util\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * @param root\n * @param options\n * @returns\n */\n\n\nfunction computeAccessibleDescription(root) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var description = (0, _util.queryIdRefs)(root, \"aria-describedby\").map(function (element) {\n    return (0, _accessibleNameAndDescription.computeTextAlternative)(element, _objectSpread(_objectSpread({}, options), {}, {\n      compute: \"description\"\n    }));\n  }).join(\" \"); // TODO: Technically we need to make sure that node wasn't used for the accessible name\n  //       This causes `description_1.0_combobox-focusable-manual` to fail\n  //\n  // https://www.w3.org/TR/html-aam-1.0/#accessible-name-and-description-computation\n  // says for so many elements to use the `title` that we assume all elements are considered\n\n  if (description === \"\") {\n    var title = root.getAttribute(\"title\");\n    description = title === null ? \"\" : title;\n  }\n\n  return description;\n}","map":{"version":3,"mappings":";;;;;AAAA;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AACA;;;AACO,SAASA,4BAAT,CACNC,IADM,EAGG;EAAA,IADTC,OACS,uEADgC,EAChC;EACT,IAAIC,WAAW,GAAG,uBAAYF,IAAZ,EAAkB,kBAAlB,EAChBG,GADgB,CACZ,UAACC,OAAD,EAAa;IACjB,OAAO,0DAAuBA,OAAvB,kCACHH,OADG;MAENI,OAAO,EAAE;IAFH,GAAP;EAFgB,GAOhBC,IAPgB,CAOX,GAPW,CAAlB,CADS,CAUT;EACA;EACA;EACA;EACA;;EACA,IAAIJ,WAAW,KAAK,EAApB,EAAwB;IACvB,IAAMK,KAAK,GAAGP,IAAI,CAACQ,YAALR,CAAkB,OAAlBA,CAAd;IACAE,WAAW,GAAGK,KAAK,KAAK,IAAVA,GAAiB,EAAjBA,GAAsBA,KAApCL;EACA;;EAED,OAAOA,WAAP;AACA","names":["computeAccessibleDescription","root","options","description","map","element","compute","join","title","getAttribute"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\dom-accessibility-api\\sources\\accessible-description.ts"],"sourcesContent":["import {\n\tcomputeTextAlternative,\n\tComputeTextAlternativeOptions,\n} from \"./accessible-name-and-description\";\nimport { queryIdRefs } from \"./util\";\n\n/**\n * @param root\n * @param options\n * @returns\n */\nexport function computeAccessibleDescription(\n\troot: Element,\n\toptions: ComputeTextAlternativeOptions = {}\n): string {\n\tlet description = queryIdRefs(root, \"aria-describedby\")\n\t\t.map((element) => {\n\t\t\treturn computeTextAlternative(element, {\n\t\t\t\t...options,\n\t\t\t\tcompute: \"description\",\n\t\t\t});\n\t\t})\n\t\t.join(\" \");\n\n\t// TODO: Technically we need to make sure that node wasn't used for the accessible name\n\t//       This causes `description_1.0_combobox-focusable-manual` to fail\n\t//\n\t// https://www.w3.org/TR/html-aam-1.0/#accessible-name-and-description-computation\n\t// says for so many elements to use the `title` that we assume all elements are considered\n\tif (description === \"\") {\n\t\tconst title = root.getAttribute(\"title\");\n\t\tdescription = title === null ? \"\" : title;\n\t}\n\n\treturn description;\n}\n"]},"metadata":{},"sourceType":"script"}