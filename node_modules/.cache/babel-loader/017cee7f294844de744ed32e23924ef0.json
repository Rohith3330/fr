{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.intRange = void 0;\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst timestamp_1 = require(\"../../runtime/timestamp\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst error_1 = require(\"./error\");\n\nexports.intRange = {\n  int8: [-128, 127, 3],\n  uint8: [0, 255, 3],\n  int16: [-32768, 32767, 5],\n  uint16: [0, 65535, 5],\n  int32: [-2147483648, 2147483647, 10],\n  uint32: [0, 4294967295, 10]\n};\nconst error = {\n  message: cxt => (0, error_1.typeErrorMessage)(cxt, cxt.schema),\n  params: cxt => (0, error_1.typeErrorParams)(cxt, cxt.schema)\n};\n\nfunction timestampCode(cxt) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  const {\n    timestamp,\n    allowDate\n  } = it.opts;\n  if (timestamp === \"date\") return (0, codegen_1._)`${data} instanceof Date `;\n  const vts = (0, util_1.useFunc)(gen, timestamp_1.default);\n  const allowDateArg = allowDate ? (0, codegen_1._)`, true` : codegen_1.nil;\n  const validString = (0, codegen_1._)`typeof ${data} == \"string\" && ${vts}(${data}${allowDateArg})`;\n  return timestamp === \"string\" ? validString : (0, codegen_1.or)((0, codegen_1._)`${data} instanceof Date`, validString);\n}\n\nconst def = {\n  keyword: \"type\",\n  schemaType: \"string\",\n  error,\n\n  code(cxt) {\n    (0, metadata_1.checkMetadata)(cxt);\n    const {\n      data,\n      schema,\n      parentSchema,\n      it\n    } = cxt;\n    let cond;\n\n    switch (schema) {\n      case \"boolean\":\n      case \"string\":\n        cond = (0, codegen_1._)`typeof ${data} == ${schema}`;\n        break;\n\n      case \"timestamp\":\n        {\n          cond = timestampCode(cxt);\n          break;\n        }\n\n      case \"float32\":\n      case \"float64\":\n        cond = (0, codegen_1._)`typeof ${data} == \"number\"`;\n        break;\n\n      default:\n        {\n          const sch = schema;\n          cond = (0, codegen_1._)`typeof ${data} == \"number\" && isFinite(${data}) && !(${data} % 1)`;\n\n          if (!it.opts.int32range && (sch === \"int32\" || sch === \"uint32\")) {\n            if (sch === \"uint32\") cond = (0, codegen_1._)`${cond} && ${data} >= 0`;\n          } else {\n            const [min, max] = exports.intRange[sch];\n            cond = (0, codegen_1._)`${cond} && ${data} >= ${min} && ${data} <= ${max}`;\n          }\n        }\n    }\n\n    cxt.pass(parentSchema.nullable ? (0, codegen_1.or)((0, codegen_1._)`${data} === null`, cond) : cond);\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["exports","int8","uint8","int16","uint16","int32","uint32","error","message","cxt","schema","params","timestampCode","gen","data","it","timestamp","allowDate","opts","vts","timestamp_1","allowDateArg","codegen_1","validString","def","keyword","schemaType","code","parentSchema","cond","sch","int32range","min","max","pass","nullable"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\vocabularies\\jtd\\type.ts"],"sourcesContent":["import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, nil, or, Code} from \"../../compile/codegen\"\nimport validTimestamp from \"../../runtime/timestamp\"\nimport {useFunc} from \"../../compile/util\"\nimport {checkMetadata} from \"./metadata\"\nimport {typeErrorMessage, typeErrorParams, _JTDTypeError} from \"./error\"\n\nexport type JTDTypeError = _JTDTypeError<\"type\", JTDType, JTDType>\n\nexport type IntType = \"int8\" | \"uint8\" | \"int16\" | \"uint16\" | \"int32\" | \"uint32\"\n\nexport const intRange: {[T in IntType]: [number, number, number]} = {\n  int8: [-128, 127, 3],\n  uint8: [0, 255, 3],\n  int16: [-32768, 32767, 5],\n  uint16: [0, 65535, 5],\n  int32: [-2147483648, 2147483647, 10],\n  uint32: [0, 4294967295, 10],\n}\n\nexport type JTDType = \"boolean\" | \"string\" | \"timestamp\" | \"float32\" | \"float64\" | IntType\n\nconst error: KeywordErrorDefinition = {\n  message: (cxt) => typeErrorMessage(cxt, cxt.schema),\n  params: (cxt) => typeErrorParams(cxt, cxt.schema),\n}\n\nfunction timestampCode(cxt: KeywordCxt): Code {\n  const {gen, data, it} = cxt\n  const {timestamp, allowDate} = it.opts\n  if (timestamp === \"date\") return _`${data} instanceof Date `\n  const vts = useFunc(gen, validTimestamp)\n  const allowDateArg = allowDate ? _`, true` : nil\n  const validString = _`typeof ${data} == \"string\" && ${vts}(${data}${allowDateArg})`\n  return timestamp === \"string\" ? validString : or(_`${data} instanceof Date`, validString)\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"type\",\n  schemaType: \"string\",\n  error,\n  code(cxt: KeywordCxt) {\n    checkMetadata(cxt)\n    const {data, schema, parentSchema, it} = cxt\n    let cond: Code\n    switch (schema) {\n      case \"boolean\":\n      case \"string\":\n        cond = _`typeof ${data} == ${schema}`\n        break\n      case \"timestamp\": {\n        cond = timestampCode(cxt)\n        break\n      }\n      case \"float32\":\n      case \"float64\":\n        cond = _`typeof ${data} == \"number\"`\n        break\n      default: {\n        const sch = schema as IntType\n        cond = _`typeof ${data} == \"number\" && isFinite(${data}) && !(${data} % 1)`\n        if (!it.opts.int32range && (sch === \"int32\" || sch === \"uint32\")) {\n          if (sch === \"uint32\") cond = _`${cond} && ${data} >= 0`\n        } else {\n          const [min, max] = intRange[sch]\n          cond = _`${cond} && ${data} >= ${min} && ${data} <= ${max}`\n        }\n      }\n    }\n    cxt.pass(parentSchema.nullable ? or(_`${data} === null`, cond) : cond)\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}