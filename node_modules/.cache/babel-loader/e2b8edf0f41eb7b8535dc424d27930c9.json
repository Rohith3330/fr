{"ast":null,"code":"/**\n * @fileoverview Rule to flag use of parseInt without a radix argument\n * @author James Allardice\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst MODE_ALWAYS = \"always\",\n      MODE_AS_NEEDED = \"as-needed\";\nconst validRadixValues = new Set(Array.from({\n  length: 37 - 2\n}, (_, index) => index + 2));\n/**\n * Checks whether a given variable is shadowed or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is shadowed.\n */\n\nfunction isShadowed(variable) {\n  return variable.defs.length >= 1;\n}\n/**\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\n *      method.\n */\n\n\nfunction isParseIntMethod(node) {\n  return node.type === \"MemberExpression\" && !node.computed && node.property.type === \"Identifier\" && node.property.name === \"parseInt\";\n}\n/**\n * Checks whether a given node is a valid value of radix or not.\n *\n * The following values are invalid.\n *\n * - A literal except integers between 2 and 36.\n * - undefined.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is valid.\n */\n\n\nfunction isValidRadix(radix) {\n  return !(radix.type === \"Literal\" && !validRadixValues.has(radix.value) || radix.type === \"Identifier\" && radix.name === \"undefined\");\n}\n/**\n * Checks whether a given node is a default value of radix or not.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is the literal node of `10`.\n */\n\n\nfunction isDefaultRadix(radix) {\n  return radix.type === \"Literal\" && radix.value === 10;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Enforce the consistent use of the radix argument when using `parseInt()`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/radix\"\n    },\n    hasSuggestions: true,\n    schema: [{\n      enum: [\"always\", \"as-needed\"]\n    }],\n    messages: {\n      missingParameters: \"Missing parameters.\",\n      redundantRadix: \"Redundant radix parameter.\",\n      missingRadix: \"Missing radix parameter.\",\n      invalidRadix: \"Invalid radix parameter, must be an integer between 2 and 36.\",\n      addRadixParameter10: \"Add radix parameter `10` for parsing decimal numbers.\"\n    }\n  },\n\n  create(context) {\n    const mode = context.options[0] || MODE_ALWAYS;\n    /**\n     * Checks the arguments of a given CallExpression node and reports it if it\n     * offends this rule.\n     * @param {ASTNode} node A CallExpression node to check.\n     * @returns {void}\n     */\n\n    function checkArguments(node) {\n      const args = node.arguments;\n\n      switch (args.length) {\n        case 0:\n          context.report({\n            node,\n            messageId: \"missingParameters\"\n          });\n          break;\n\n        case 1:\n          if (mode === MODE_ALWAYS) {\n            context.report({\n              node,\n              messageId: \"missingRadix\",\n              suggest: [{\n                messageId: \"addRadixParameter10\",\n\n                fix(fixer) {\n                  const sourceCode = context.getSourceCode();\n                  const tokens = sourceCode.getTokens(node);\n                  const lastToken = tokens[tokens.length - 1]; // Parenthesis.\n\n                  const secondToLastToken = tokens[tokens.length - 2]; // May or may not be a comma.\n\n                  const hasTrailingComma = secondToLastToken.type === \"Punctuator\" && secondToLastToken.value === \",\";\n                  return fixer.insertTextBefore(lastToken, hasTrailingComma ? \" 10,\" : \", 10\");\n                }\n\n              }]\n            });\n          }\n\n          break;\n\n        default:\n          if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n            context.report({\n              node,\n              messageId: \"redundantRadix\"\n            });\n          } else if (!isValidRadix(args[1])) {\n            context.report({\n              node,\n              messageId: \"invalidRadix\"\n            });\n          }\n\n          break;\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        const scope = context.getScope();\n        let variable; // Check `parseInt()`\n\n        variable = astUtils.getVariableByName(scope, \"parseInt\");\n\n        if (variable && !isShadowed(variable)) {\n          variable.references.forEach(reference => {\n            const node = reference.identifier;\n\n            if (astUtils.isCallee(node)) {\n              checkArguments(node.parent);\n            }\n          });\n        } // Check `Number.parseInt()`\n\n\n        variable = astUtils.getVariableByName(scope, \"Number\");\n\n        if (variable && !isShadowed(variable)) {\n          variable.references.forEach(reference => {\n            const node = reference.identifier.parent;\n            const maybeCallee = node.parent.type === \"ChainExpression\" ? node.parent : node;\n\n            if (isParseIntMethod(node) && astUtils.isCallee(maybeCallee)) {\n              checkArguments(maybeCallee.parent);\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","MODE_ALWAYS","MODE_AS_NEEDED","validRadixValues","Set","Array","from","length","_","index","isShadowed","variable","defs","isParseIntMethod","node","type","computed","property","name","isValidRadix","radix","has","value","isDefaultRadix","module","exports","meta","docs","description","recommended","url","hasSuggestions","schema","enum","messages","missingParameters","redundantRadix","missingRadix","invalidRadix","addRadixParameter10","create","context","mode","options","checkArguments","args","arguments","report","messageId","suggest","fix","fixer","sourceCode","getSourceCode","tokens","getTokens","lastToken","secondToLastToken","hasTrailingComma","insertTextBefore","scope","getScope","getVariableByName","references","forEach","reference","identifier","isCallee","parent","maybeCallee"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/radix.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag use of parseInt without a radix argument\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst MODE_ALWAYS = \"always\",\n    MODE_AS_NEEDED = \"as-needed\";\n\nconst validRadixValues = new Set(Array.from({ length: 37 - 2 }, (_, index) => index + 2));\n\n/**\n * Checks whether a given variable is shadowed or not.\n * @param {eslint-scope.Variable} variable A variable to check.\n * @returns {boolean} `true` if the variable is shadowed.\n */\nfunction isShadowed(variable) {\n    return variable.defs.length >= 1;\n}\n\n/**\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\n * @param {ASTNode} node A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\n *      method.\n */\nfunction isParseIntMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"parseInt\"\n    );\n}\n\n/**\n * Checks whether a given node is a valid value of radix or not.\n *\n * The following values are invalid.\n *\n * - A literal except integers between 2 and 36.\n * - undefined.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is valid.\n */\nfunction isValidRadix(radix) {\n    return !(\n        (radix.type === \"Literal\" && !validRadixValues.has(radix.value)) ||\n        (radix.type === \"Identifier\" && radix.name === \"undefined\")\n    );\n}\n\n/**\n * Checks whether a given node is a default value of radix or not.\n * @param {ASTNode} radix A node of radix to check.\n * @returns {boolean} `true` if the node is the literal node of `10`.\n */\nfunction isDefaultRadix(radix) {\n    return radix.type === \"Literal\" && radix.value === 10;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Enforce the consistent use of the radix argument when using `parseInt()`\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/radix\"\n        },\n\n        hasSuggestions: true,\n\n        schema: [\n            {\n                enum: [\"always\", \"as-needed\"]\n            }\n        ],\n\n        messages: {\n            missingParameters: \"Missing parameters.\",\n            redundantRadix: \"Redundant radix parameter.\",\n            missingRadix: \"Missing radix parameter.\",\n            invalidRadix: \"Invalid radix parameter, must be an integer between 2 and 36.\",\n            addRadixParameter10: \"Add radix parameter `10` for parsing decimal numbers.\"\n        }\n    },\n\n    create(context) {\n        const mode = context.options[0] || MODE_ALWAYS;\n\n        /**\n         * Checks the arguments of a given CallExpression node and reports it if it\n         * offends this rule.\n         * @param {ASTNode} node A CallExpression node to check.\n         * @returns {void}\n         */\n        function checkArguments(node) {\n            const args = node.arguments;\n\n            switch (args.length) {\n                case 0:\n                    context.report({\n                        node,\n                        messageId: \"missingParameters\"\n                    });\n                    break;\n\n                case 1:\n                    if (mode === MODE_ALWAYS) {\n                        context.report({\n                            node,\n                            messageId: \"missingRadix\",\n                            suggest: [\n                                {\n                                    messageId: \"addRadixParameter10\",\n                                    fix(fixer) {\n                                        const sourceCode = context.getSourceCode();\n                                        const tokens = sourceCode.getTokens(node);\n                                        const lastToken = tokens[tokens.length - 1]; // Parenthesis.\n                                        const secondToLastToken = tokens[tokens.length - 2]; // May or may not be a comma.\n                                        const hasTrailingComma = secondToLastToken.type === \"Punctuator\" && secondToLastToken.value === \",\";\n\n                                        return fixer.insertTextBefore(lastToken, hasTrailingComma ? \" 10,\" : \", 10\");\n                                    }\n                                }\n                            ]\n                        });\n                    }\n                    break;\n\n                default:\n                    if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n                        context.report({\n                            node,\n                            messageId: \"redundantRadix\"\n                        });\n                    } else if (!isValidRadix(args[1])) {\n                        context.report({\n                            node,\n                            messageId: \"invalidRadix\"\n                        });\n                    }\n                    break;\n            }\n        }\n\n        return {\n            \"Program:exit\"() {\n                const scope = context.getScope();\n                let variable;\n\n                // Check `parseInt()`\n                variable = astUtils.getVariableByName(scope, \"parseInt\");\n                if (variable && !isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier;\n\n                        if (astUtils.isCallee(node)) {\n                            checkArguments(node.parent);\n                        }\n                    });\n                }\n\n                // Check `Number.parseInt()`\n                variable = astUtils.getVariableByName(scope, \"Number\");\n                if (variable && !isShadowed(variable)) {\n                    variable.references.forEach(reference => {\n                        const node = reference.identifier.parent;\n                        const maybeCallee = node.parent.type === \"ChainExpression\"\n                            ? node.parent\n                            : node;\n\n                        if (isParseIntMethod(node) && astUtils.isCallee(maybeCallee)) {\n                            checkArguments(maybeCallee.parent);\n                        }\n                    });\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}