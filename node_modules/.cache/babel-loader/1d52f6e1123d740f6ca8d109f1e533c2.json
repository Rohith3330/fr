{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\nimport { HOP, makePredicate, return_this, string_template, regexp_source_fix, regexp_is_safe } from \"../utils/index.js\";\nimport { AST_Array, AST_BigInt, AST_Binary, AST_Call, AST_Chain, AST_Class, AST_Conditional, AST_Constant, AST_Dot, AST_Expansion, AST_Function, AST_Lambda, AST_New, AST_Node, AST_Object, AST_PropAccess, AST_RegExp, AST_Statement, AST_Symbol, AST_SymbolRef, AST_TemplateString, AST_UnaryPrefix, AST_With } from \"../ast.js\";\nimport { is_undeclared_ref } from \"./inference.js\";\nimport { is_pure_native_value, is_pure_native_fn, is_pure_native_method } from \"./native-objects.js\"; // methods to evaluate a constant expression\n\nfunction def_eval(node, func) {\n  node.DEFMETHOD(\"_eval\", func);\n} // Used to propagate a nullish short-circuit signal upwards through the chain.\n\n\nexport const nullish = Symbol(\"This AST_Chain is nullish\"); // If the node has been successfully reduced to a constant,\n// then its value is returned; otherwise the element itself\n// is returned.\n// They can be distinguished as constant value is never a\n// descendant of AST_Node.\n\nAST_Node.DEFMETHOD(\"evaluate\", function (compressor) {\n  if (!compressor.option(\"evaluate\")) return this;\n\n  var val = this._eval(compressor, 1);\n\n  if (!val || val instanceof RegExp) return val;\n  if (typeof val == \"function\" || typeof val == \"object\" || val == nullish) return this;\n  return val;\n});\nvar unaryPrefix = makePredicate(\"! ~ - + void\");\nAST_Node.DEFMETHOD(\"is_constant\", function () {\n  // Accomodate when compress option evaluate=false\n  // as well as the common constant expressions !0 and -1\n  if (this instanceof AST_Constant) {\n    return !(this instanceof AST_RegExp);\n  } else {\n    return this instanceof AST_UnaryPrefix && this.expression instanceof AST_Constant && unaryPrefix.has(this.operator);\n  }\n});\ndef_eval(AST_Statement, function () {\n  throw new Error(string_template(\"Cannot evaluate a statement [{file}:{line},{col}]\", this.start));\n});\ndef_eval(AST_Lambda, return_this);\ndef_eval(AST_Class, return_this);\ndef_eval(AST_Node, return_this);\ndef_eval(AST_Constant, function () {\n  return this.getValue();\n});\ndef_eval(AST_BigInt, return_this);\ndef_eval(AST_RegExp, function (compressor) {\n  let evaluated = compressor.evaluated_regexps.get(this.value);\n\n  if (evaluated === undefined && regexp_is_safe(this.value.source)) {\n    try {\n      const {\n        source,\n        flags\n      } = this.value;\n      evaluated = new RegExp(source, flags);\n    } catch (e) {\n      evaluated = null;\n    }\n\n    compressor.evaluated_regexps.set(this.value, evaluated);\n  }\n\n  return evaluated || this;\n});\ndef_eval(AST_TemplateString, function () {\n  if (this.segments.length !== 1) return this;\n  return this.segments[0].value;\n});\ndef_eval(AST_Function, function (compressor) {\n  if (compressor.option(\"unsafe\")) {\n    var fn = function () {};\n\n    fn.node = this;\n\n    fn.toString = () => this.print_to_string();\n\n    return fn;\n  }\n\n  return this;\n});\ndef_eval(AST_Array, function (compressor, depth) {\n  if (compressor.option(\"unsafe\")) {\n    var elements = [];\n\n    for (var i = 0, len = this.elements.length; i < len; i++) {\n      var element = this.elements[i];\n\n      var value = element._eval(compressor, depth);\n\n      if (element === value) return this;\n      elements.push(value);\n    }\n\n    return elements;\n  }\n\n  return this;\n});\ndef_eval(AST_Object, function (compressor, depth) {\n  if (compressor.option(\"unsafe\")) {\n    var val = {};\n\n    for (var i = 0, len = this.properties.length; i < len; i++) {\n      var prop = this.properties[i];\n      if (prop instanceof AST_Expansion) return this;\n      var key = prop.key;\n\n      if (key instanceof AST_Symbol) {\n        key = key.name;\n      } else if (key instanceof AST_Node) {\n        key = key._eval(compressor, depth);\n        if (key === prop.key) return this;\n      }\n\n      if (typeof Object.prototype[key] === \"function\") {\n        return this;\n      }\n\n      if (prop.value instanceof AST_Function) continue;\n      val[key] = prop.value._eval(compressor, depth);\n      if (val[key] === prop.value) return this;\n    }\n\n    return val;\n  }\n\n  return this;\n});\nvar non_converting_unary = makePredicate(\"! typeof void\");\ndef_eval(AST_UnaryPrefix, function (compressor, depth) {\n  var e = this.expression; // Function would be evaluated to an array and so typeof would\n  // incorrectly return 'object'. Hence making is a special case.\n\n  if (compressor.option(\"typeofs\") && this.operator == \"typeof\" && (e instanceof AST_Lambda || e instanceof AST_SymbolRef && e.fixed_value() instanceof AST_Lambda)) {\n    return typeof function () {};\n  }\n\n  if (!non_converting_unary.has(this.operator)) depth++;\n  e = e._eval(compressor, depth);\n  if (e === this.expression) return this;\n\n  switch (this.operator) {\n    case \"!\":\n      return !e;\n\n    case \"typeof\":\n      // typeof <RegExp> returns \"object\" or \"function\" on different platforms\n      // so cannot evaluate reliably\n      if (e instanceof RegExp) return this;\n      return typeof e;\n\n    case \"void\":\n      return void e;\n\n    case \"~\":\n      return ~e;\n\n    case \"-\":\n      return -e;\n\n    case \"+\":\n      return +e;\n  }\n\n  return this;\n});\nvar non_converting_binary = makePredicate(\"&& || ?? === !==\");\nconst identity_comparison = makePredicate(\"== != === !==\");\n\nconst has_identity = value => typeof value === \"object\" || typeof value === \"function\" || typeof value === \"symbol\";\n\ndef_eval(AST_Binary, function (compressor, depth) {\n  if (!non_converting_binary.has(this.operator)) depth++;\n\n  var left = this.left._eval(compressor, depth);\n\n  if (left === this.left) return this;\n\n  var right = this.right._eval(compressor, depth);\n\n  if (right === this.right) return this;\n  var result;\n\n  if (left != null && right != null && identity_comparison.has(this.operator) && has_identity(left) && has_identity(right) && typeof left === typeof right) {\n    // Do not compare by reference\n    return this;\n  }\n\n  switch (this.operator) {\n    case \"&&\":\n      result = left && right;\n      break;\n\n    case \"||\":\n      result = left || right;\n      break;\n\n    case \"??\":\n      result = left != null ? left : right;\n      break;\n\n    case \"|\":\n      result = left | right;\n      break;\n\n    case \"&\":\n      result = left & right;\n      break;\n\n    case \"^\":\n      result = left ^ right;\n      break;\n\n    case \"+\":\n      result = left + right;\n      break;\n\n    case \"*\":\n      result = left * right;\n      break;\n\n    case \"**\":\n      result = Math.pow(left, right);\n      break;\n\n    case \"/\":\n      result = left / right;\n      break;\n\n    case \"%\":\n      result = left % right;\n      break;\n\n    case \"-\":\n      result = left - right;\n      break;\n\n    case \"<<\":\n      result = left << right;\n      break;\n\n    case \">>\":\n      result = left >> right;\n      break;\n\n    case \">>>\":\n      result = left >>> right;\n      break;\n\n    case \"==\":\n      result = left == right;\n      break;\n\n    case \"===\":\n      result = left === right;\n      break;\n\n    case \"!=\":\n      result = left != right;\n      break;\n\n    case \"!==\":\n      result = left !== right;\n      break;\n\n    case \"<\":\n      result = left < right;\n      break;\n\n    case \"<=\":\n      result = left <= right;\n      break;\n\n    case \">\":\n      result = left > right;\n      break;\n\n    case \">=\":\n      result = left >= right;\n      break;\n\n    default:\n      return this;\n  }\n\n  if (isNaN(result) && compressor.find_parent(AST_With)) {\n    // leave original expression as is\n    return this;\n  }\n\n  return result;\n});\ndef_eval(AST_Conditional, function (compressor, depth) {\n  var condition = this.condition._eval(compressor, depth);\n\n  if (condition === this.condition) return this;\n  var node = condition ? this.consequent : this.alternative;\n\n  var value = node._eval(compressor, depth);\n\n  return value === node ? this : value;\n}); // Set of AST_SymbolRef which are currently being evaluated.\n// Avoids infinite recursion of ._eval()\n\nconst reentrant_ref_eval = new Set();\ndef_eval(AST_SymbolRef, function (compressor, depth) {\n  if (reentrant_ref_eval.has(this)) return this;\n  var fixed = this.fixed_value();\n  if (!fixed) return this;\n  reentrant_ref_eval.add(this);\n\n  const value = fixed._eval(compressor, depth);\n\n  reentrant_ref_eval.delete(this);\n  if (value === fixed) return this;\n\n  if (value && typeof value == \"object\") {\n    var escaped = this.definition().escaped;\n    if (escaped && depth > escaped) return this;\n  }\n\n  return value;\n});\nconst global_objs = {\n  Array,\n  Math,\n  Number,\n  Object,\n  String\n};\nconst regexp_flags = new Set([\"dotAll\", \"global\", \"ignoreCase\", \"multiline\", \"sticky\", \"unicode\"]);\ndef_eval(AST_PropAccess, function (compressor, depth) {\n  let obj = this.expression._eval(compressor, depth + 1);\n\n  if (obj === nullish || this.optional && obj == null) return nullish;\n\n  if (compressor.option(\"unsafe\")) {\n    var key = this.property;\n\n    if (key instanceof AST_Node) {\n      key = key._eval(compressor, depth);\n      if (key === this.property) return this;\n    }\n\n    var exp = this.expression;\n\n    if (is_undeclared_ref(exp)) {\n      var aa;\n      var first_arg = exp.name === \"hasOwnProperty\" && key === \"call\" && (aa = compressor.parent() && compressor.parent().args) && aa && aa[0] && aa[0].evaluate(compressor);\n      first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;\n\n      if (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared) {\n        return this.clone();\n      }\n\n      if (!is_pure_native_value(exp.name, key)) return this;\n      obj = global_objs[exp.name];\n    } else {\n      if (obj instanceof RegExp) {\n        if (key == \"source\") {\n          return regexp_source_fix(obj.source);\n        } else if (key == \"flags\" || regexp_flags.has(key)) {\n          return obj[key];\n        }\n      }\n\n      if (!obj || obj === exp || !HOP(obj, key)) return this;\n      if (typeof obj == \"function\") switch (key) {\n        case \"name\":\n          return obj.node.name ? obj.node.name.name : \"\";\n\n        case \"length\":\n          return obj.node.length_property();\n\n        default:\n          return this;\n      }\n    }\n\n    return obj[key];\n  }\n\n  return this;\n});\ndef_eval(AST_Chain, function (compressor, depth) {\n  const evaluated = this.expression._eval(compressor, depth);\n\n  return evaluated === nullish ? undefined : evaluated === this.expression ? this : evaluated;\n});\ndef_eval(AST_Call, function (compressor, depth) {\n  var exp = this.expression;\n\n  const callee = exp._eval(compressor, depth);\n\n  if (callee === nullish || this.optional && callee == null) return nullish;\n\n  if (compressor.option(\"unsafe\") && exp instanceof AST_PropAccess) {\n    var key = exp.property;\n\n    if (key instanceof AST_Node) {\n      key = key._eval(compressor, depth);\n      if (key === exp.property) return this;\n    }\n\n    var val;\n    var e = exp.expression;\n\n    if (is_undeclared_ref(e)) {\n      var first_arg = e.name === \"hasOwnProperty\" && key === \"call\" && this.args[0] && this.args[0].evaluate(compressor);\n      first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;\n\n      if (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared) {\n        return this.clone();\n      }\n\n      if (!is_pure_native_fn(e.name, key)) return this;\n      val = global_objs[e.name];\n    } else {\n      val = e._eval(compressor, depth + 1);\n      if (val === e || !val) return this;\n      if (!is_pure_native_method(val.constructor.name, key)) return this;\n    }\n\n    var args = [];\n\n    for (var i = 0, len = this.args.length; i < len; i++) {\n      var arg = this.args[i];\n\n      var value = arg._eval(compressor, depth);\n\n      if (arg === value) return this;\n      if (arg instanceof AST_Lambda) return this;\n      args.push(value);\n    }\n\n    try {\n      return val[key].apply(val, args);\n    } catch (ex) {// We don't really care\n    }\n  }\n\n  return this;\n}); // Also a subclass of AST_Call\n\ndef_eval(AST_New, return_this);","map":{"version":3,"names":["HOP","makePredicate","return_this","string_template","regexp_source_fix","regexp_is_safe","AST_Array","AST_BigInt","AST_Binary","AST_Call","AST_Chain","AST_Class","AST_Conditional","AST_Constant","AST_Dot","AST_Expansion","AST_Function","AST_Lambda","AST_New","AST_Node","AST_Object","AST_PropAccess","AST_RegExp","AST_Statement","AST_Symbol","AST_SymbolRef","AST_TemplateString","AST_UnaryPrefix","AST_With","is_undeclared_ref","is_pure_native_value","is_pure_native_fn","is_pure_native_method","def_eval","node","func","DEFMETHOD","nullish","Symbol","compressor","option","val","_eval","RegExp","unaryPrefix","expression","has","operator","Error","start","getValue","evaluated","evaluated_regexps","get","value","undefined","source","flags","e","set","segments","length","fn","toString","print_to_string","depth","elements","i","len","element","push","properties","prop","key","name","Object","prototype","non_converting_unary","fixed_value","non_converting_binary","identity_comparison","has_identity","left","right","result","Math","pow","isNaN","find_parent","condition","consequent","alternative","reentrant_ref_eval","Set","fixed","add","delete","escaped","definition","global_objs","Array","Number","String","regexp_flags","obj","optional","property","exp","aa","first_arg","parent","args","evaluate","thedef","undeclared","clone","length_property","callee","constructor","arg","apply","ex"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/terser/lib/compress/evaluate.js"],"sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nimport {\n    HOP,\n    makePredicate,\n    return_this,\n    string_template,\n    regexp_source_fix,\n    regexp_is_safe,\n} from \"../utils/index.js\";\nimport {\n    AST_Array,\n    AST_BigInt,\n    AST_Binary,\n    AST_Call,\n    AST_Chain,\n    AST_Class,\n    AST_Conditional,\n    AST_Constant,\n    AST_Dot,\n    AST_Expansion,\n    AST_Function,\n    AST_Lambda,\n    AST_New,\n    AST_Node,\n    AST_Object,\n    AST_PropAccess,\n    AST_RegExp,\n    AST_Statement,\n    AST_Symbol,\n    AST_SymbolRef,\n    AST_TemplateString,\n    AST_UnaryPrefix,\n    AST_With,\n} from \"../ast.js\";\nimport { is_undeclared_ref} from \"./inference.js\";\nimport { is_pure_native_value, is_pure_native_fn, is_pure_native_method } from \"./native-objects.js\";\n\n// methods to evaluate a constant expression\n\nfunction def_eval(node, func) {\n    node.DEFMETHOD(\"_eval\", func);\n}\n\n// Used to propagate a nullish short-circuit signal upwards through the chain.\nexport const nullish = Symbol(\"This AST_Chain is nullish\");\n\n// If the node has been successfully reduced to a constant,\n// then its value is returned; otherwise the element itself\n// is returned.\n// They can be distinguished as constant value is never a\n// descendant of AST_Node.\nAST_Node.DEFMETHOD(\"evaluate\", function (compressor) {\n    if (!compressor.option(\"evaluate\"))\n        return this;\n    var val = this._eval(compressor, 1);\n    if (!val || val instanceof RegExp)\n        return val;\n    if (typeof val == \"function\" || typeof val == \"object\" || val == nullish)\n        return this;\n    return val;\n});\n\nvar unaryPrefix = makePredicate(\"! ~ - + void\");\nAST_Node.DEFMETHOD(\"is_constant\", function () {\n    // Accomodate when compress option evaluate=false\n    // as well as the common constant expressions !0 and -1\n    if (this instanceof AST_Constant) {\n        return !(this instanceof AST_RegExp);\n    } else {\n        return this instanceof AST_UnaryPrefix\n            && this.expression instanceof AST_Constant\n            && unaryPrefix.has(this.operator);\n    }\n});\n\ndef_eval(AST_Statement, function () {\n    throw new Error(string_template(\"Cannot evaluate a statement [{file}:{line},{col}]\", this.start));\n});\n\ndef_eval(AST_Lambda, return_this);\ndef_eval(AST_Class, return_this);\ndef_eval(AST_Node, return_this);\ndef_eval(AST_Constant, function () {\n    return this.getValue();\n});\n\ndef_eval(AST_BigInt, return_this);\n\ndef_eval(AST_RegExp, function (compressor) {\n    let evaluated = compressor.evaluated_regexps.get(this.value);\n    if (evaluated === undefined && regexp_is_safe(this.value.source)) {\n        try {\n            const { source, flags } = this.value;\n            evaluated = new RegExp(source, flags);\n        } catch (e) {\n            evaluated = null;\n        }\n        compressor.evaluated_regexps.set(this.value, evaluated);\n    }\n    return evaluated || this;\n});\n\ndef_eval(AST_TemplateString, function () {\n    if (this.segments.length !== 1) return this;\n    return this.segments[0].value;\n});\n\ndef_eval(AST_Function, function (compressor) {\n    if (compressor.option(\"unsafe\")) {\n        var fn = function () { };\n        fn.node = this;\n        fn.toString = () => this.print_to_string();\n        return fn;\n    }\n    return this;\n});\n\ndef_eval(AST_Array, function (compressor, depth) {\n    if (compressor.option(\"unsafe\")) {\n        var elements = [];\n        for (var i = 0, len = this.elements.length; i < len; i++) {\n            var element = this.elements[i];\n            var value = element._eval(compressor, depth);\n            if (element === value)\n                return this;\n            elements.push(value);\n        }\n        return elements;\n    }\n    return this;\n});\n\ndef_eval(AST_Object, function (compressor, depth) {\n    if (compressor.option(\"unsafe\")) {\n        var val = {};\n        for (var i = 0, len = this.properties.length; i < len; i++) {\n            var prop = this.properties[i];\n            if (prop instanceof AST_Expansion)\n                return this;\n            var key = prop.key;\n            if (key instanceof AST_Symbol) {\n                key = key.name;\n            } else if (key instanceof AST_Node) {\n                key = key._eval(compressor, depth);\n                if (key === prop.key)\n                    return this;\n            }\n            if (typeof Object.prototype[key] === \"function\") {\n                return this;\n            }\n            if (prop.value instanceof AST_Function)\n                continue;\n            val[key] = prop.value._eval(compressor, depth);\n            if (val[key] === prop.value)\n                return this;\n        }\n        return val;\n    }\n    return this;\n});\n\nvar non_converting_unary = makePredicate(\"! typeof void\");\ndef_eval(AST_UnaryPrefix, function (compressor, depth) {\n    var e = this.expression;\n    // Function would be evaluated to an array and so typeof would\n    // incorrectly return 'object'. Hence making is a special case.\n    if (compressor.option(\"typeofs\")\n        && this.operator == \"typeof\"\n        && (e instanceof AST_Lambda\n            || e instanceof AST_SymbolRef\n            && e.fixed_value() instanceof AST_Lambda)) {\n        return typeof function () { };\n    }\n    if (!non_converting_unary.has(this.operator))\n        depth++;\n    e = e._eval(compressor, depth);\n    if (e === this.expression)\n        return this;\n    switch (this.operator) {\n        case \"!\": return !e;\n        case \"typeof\":\n            // typeof <RegExp> returns \"object\" or \"function\" on different platforms\n            // so cannot evaluate reliably\n            if (e instanceof RegExp)\n                return this;\n            return typeof e;\n        case \"void\": return void e;\n        case \"~\": return ~e;\n        case \"-\": return -e;\n        case \"+\": return +e;\n    }\n    return this;\n});\n\nvar non_converting_binary = makePredicate(\"&& || ?? === !==\");\nconst identity_comparison = makePredicate(\"== != === !==\");\nconst has_identity = value => typeof value === \"object\"\n    || typeof value === \"function\"\n    || typeof value === \"symbol\";\n\ndef_eval(AST_Binary, function (compressor, depth) {\n    if (!non_converting_binary.has(this.operator))\n        depth++;\n\n    var left = this.left._eval(compressor, depth);\n    if (left === this.left)\n        return this;\n    var right = this.right._eval(compressor, depth);\n    if (right === this.right)\n        return this;\n    var result;\n\n    if (left != null\n        && right != null\n        && identity_comparison.has(this.operator)\n        && has_identity(left)\n        && has_identity(right)\n        && typeof left === typeof right) {\n        // Do not compare by reference\n        return this;\n    }\n\n    switch (this.operator) {\n        case \"&&\": result = left && right; break;\n        case \"||\": result = left || right; break;\n        case \"??\": result = left != null ? left : right; break;\n        case \"|\": result = left | right; break;\n        case \"&\": result = left & right; break;\n        case \"^\": result = left ^ right; break;\n        case \"+\": result = left + right; break;\n        case \"*\": result = left * right; break;\n        case \"**\": result = Math.pow(left, right); break;\n        case \"/\": result = left / right; break;\n        case \"%\": result = left % right; break;\n        case \"-\": result = left - right; break;\n        case \"<<\": result = left << right; break;\n        case \">>\": result = left >> right; break;\n        case \">>>\": result = left >>> right; break;\n        case \"==\": result = left == right; break;\n        case \"===\": result = left === right; break;\n        case \"!=\": result = left != right; break;\n        case \"!==\": result = left !== right; break;\n        case \"<\": result = left < right; break;\n        case \"<=\": result = left <= right; break;\n        case \">\": result = left > right; break;\n        case \">=\": result = left >= right; break;\n        default:\n            return this;\n    }\n    if (isNaN(result) && compressor.find_parent(AST_With)) {\n        // leave original expression as is\n        return this;\n    }\n    return result;\n});\n\ndef_eval(AST_Conditional, function (compressor, depth) {\n    var condition = this.condition._eval(compressor, depth);\n    if (condition === this.condition)\n        return this;\n    var node = condition ? this.consequent : this.alternative;\n    var value = node._eval(compressor, depth);\n    return value === node ? this : value;\n});\n\n// Set of AST_SymbolRef which are currently being evaluated.\n// Avoids infinite recursion of ._eval()\nconst reentrant_ref_eval = new Set();\ndef_eval(AST_SymbolRef, function (compressor, depth) {\n    if (reentrant_ref_eval.has(this))\n        return this;\n\n    var fixed = this.fixed_value();\n    if (!fixed)\n        return this;\n\n    reentrant_ref_eval.add(this);\n    const value = fixed._eval(compressor, depth);\n    reentrant_ref_eval.delete(this);\n\n    if (value === fixed)\n        return this;\n\n    if (value && typeof value == \"object\") {\n        var escaped = this.definition().escaped;\n        if (escaped && depth > escaped)\n            return this;\n    }\n    return value;\n});\n\nconst global_objs = { Array, Math, Number, Object, String };\n\nconst regexp_flags = new Set([\n    \"dotAll\",\n    \"global\",\n    \"ignoreCase\",\n    \"multiline\",\n    \"sticky\",\n    \"unicode\",\n]);\n\ndef_eval(AST_PropAccess, function (compressor, depth) {\n    let obj = this.expression._eval(compressor, depth + 1);\n    if (obj === nullish || (this.optional && obj == null)) return nullish;\n    if (compressor.option(\"unsafe\")) {\n        var key = this.property;\n        if (key instanceof AST_Node) {\n            key = key._eval(compressor, depth);\n            if (key === this.property)\n                return this;\n        }\n        var exp = this.expression;\n        if (is_undeclared_ref(exp)) {\n\n            var aa;\n            var first_arg = exp.name === \"hasOwnProperty\"\n                && key === \"call\"\n                && (aa = compressor.parent() && compressor.parent().args)\n                && (aa && aa[0]\n                    && aa[0].evaluate(compressor));\n\n            first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;\n\n            if (first_arg == null || first_arg.thedef && first_arg.thedef.undeclared) {\n                return this.clone();\n            }\n            if (!is_pure_native_value(exp.name, key))\n                return this;\n            obj = global_objs[exp.name];\n        } else {\n            if (obj instanceof RegExp) {\n                if (key == \"source\") {\n                    return regexp_source_fix(obj.source);\n                } else if (key == \"flags\" || regexp_flags.has(key)) {\n                    return obj[key];\n                }\n            }\n            if (!obj || obj === exp || !HOP(obj, key))\n                return this;\n\n            if (typeof obj == \"function\")\n                switch (key) {\n                    case \"name\":\n                        return obj.node.name ? obj.node.name.name : \"\";\n                    case \"length\":\n                        return obj.node.length_property();\n                    default:\n                        return this;\n                }\n        }\n        return obj[key];\n    }\n    return this;\n});\n\ndef_eval(AST_Chain, function (compressor, depth) {\n    const evaluated = this.expression._eval(compressor, depth);\n    return evaluated === nullish\n        ? undefined\n        : evaluated === this.expression\n          ? this\n          : evaluated;\n});\n\ndef_eval(AST_Call, function (compressor, depth) {\n    var exp = this.expression;\n\n    const callee = exp._eval(compressor, depth);\n    if (callee === nullish || (this.optional && callee == null)) return nullish;\n\n    if (compressor.option(\"unsafe\") && exp instanceof AST_PropAccess) {\n        var key = exp.property;\n        if (key instanceof AST_Node) {\n            key = key._eval(compressor, depth);\n            if (key === exp.property)\n                return this;\n        }\n        var val;\n        var e = exp.expression;\n        if (is_undeclared_ref(e)) {\n            var first_arg = e.name === \"hasOwnProperty\" &&\n                key === \"call\" &&\n                (this.args[0] && this.args[0].evaluate(compressor));\n\n            first_arg = first_arg instanceof AST_Dot ? first_arg.expression : first_arg;\n\n            if ((first_arg == null || first_arg.thedef && first_arg.thedef.undeclared)) {\n                return this.clone();\n            }\n            if (!is_pure_native_fn(e.name, key)) return this;\n            val = global_objs[e.name];\n        } else {\n            val = e._eval(compressor, depth + 1);\n            if (val === e || !val)\n                return this;\n            if (!is_pure_native_method(val.constructor.name, key))\n                return this;\n        }\n        var args = [];\n        for (var i = 0, len = this.args.length; i < len; i++) {\n            var arg = this.args[i];\n            var value = arg._eval(compressor, depth);\n            if (arg === value)\n                return this;\n            if (arg instanceof AST_Lambda)\n                return this;\n            args.push(value);\n        }\n        try {\n            return val[key].apply(val, args);\n        } catch (ex) {\n            // We don't really care\n        }\n    }\n    return this;\n});\n\n// Also a subclass of AST_Call\ndef_eval(AST_New, return_this);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}