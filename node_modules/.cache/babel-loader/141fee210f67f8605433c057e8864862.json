{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption, _api$assumption2;\n\n  api.assertVersion(7);\n  const ignoreToPrimitiveHint = (_api$assumption = api.assumption(\"ignoreToPrimitiveHint\")) != null ? _api$assumption : options.loose;\n  const mutableTemplateObject = (_api$assumption2 = api.assumption(\"mutableTemplateObject\")) != null ? _api$assumption2 : options.loose;\n  let helperName = \"taggedTemplateLiteral\";\n  if (mutableTemplateObject) helperName += \"Loose\";\n\n  function buildConcatCallExpressions(items) {\n    let avail = true;\n    return items.reduce(function (left, right) {\n      let canBeInserted = _core.types.isLiteral(right);\n\n      if (!canBeInserted && avail) {\n        canBeInserted = true;\n        avail = false;\n      }\n\n      if (canBeInserted && _core.types.isCallExpression(left)) {\n        left.arguments.push(right);\n        return left;\n      }\n\n      return _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier(\"concat\")), [right]);\n    });\n  }\n\n  return {\n    name: \"transform-template-literals\",\n    visitor: {\n      TaggedTemplateExpression(path) {\n        const {\n          node\n        } = path;\n        const {\n          quasi\n        } = node;\n        const strings = [];\n        const raws = [];\n        let isStringsRawEqual = true;\n\n        for (const elem of quasi.quasis) {\n          const {\n            raw,\n            cooked\n          } = elem.value;\n          const value = cooked == null ? path.scope.buildUndefinedNode() : _core.types.stringLiteral(cooked);\n          strings.push(value);\n          raws.push(_core.types.stringLiteral(raw));\n\n          if (raw !== cooked) {\n            isStringsRawEqual = false;\n          }\n        }\n\n        const helperArgs = [_core.types.arrayExpression(strings)];\n\n        if (!isStringsRawEqual) {\n          helperArgs.push(_core.types.arrayExpression(raws));\n        }\n\n        const tmp = path.scope.generateUidIdentifier(\"templateObject\");\n        path.scope.getProgramParent().push({\n          id: _core.types.cloneNode(tmp)\n        });\n        path.replaceWith(_core.types.callExpression(node.tag, [_core.template.expression.ast`\n              ${_core.types.cloneNode(tmp)} || (\n                ${tmp} = ${this.addHelper(helperName)}(${helperArgs})\n              )\n            `, ...quasi.expressions]));\n      },\n\n      TemplateLiteral(path) {\n        if (path.parent.type === \"TSLiteralType\") {\n          return;\n        }\n\n        const nodes = [];\n        const expressions = path.get(\"expressions\");\n        let index = 0;\n\n        for (const elem of path.node.quasis) {\n          if (elem.value.cooked) {\n            nodes.push(_core.types.stringLiteral(elem.value.cooked));\n          }\n\n          if (index < expressions.length) {\n            const expr = expressions[index++];\n            const node = expr.node;\n\n            if (!_core.types.isStringLiteral(node, {\n              value: \"\"\n            })) {\n              nodes.push(node);\n            }\n          }\n        }\n\n        if (!_core.types.isStringLiteral(nodes[0]) && !(ignoreToPrimitiveHint && _core.types.isStringLiteral(nodes[1]))) {\n          nodes.unshift(_core.types.stringLiteral(\"\"));\n        }\n\n        let root = nodes[0];\n\n        if (ignoreToPrimitiveHint) {\n          for (let i = 1; i < nodes.length; i++) {\n            root = _core.types.binaryExpression(\"+\", root, nodes[i]);\n          }\n        } else if (nodes.length > 1) {\n          root = buildConcatCallExpressions(nodes);\n        }\n\n        path.replaceWith(root);\n      }\n\n    }\n  };\n});\n\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_helperPluginUtils","require","_core","_default","declare","api","options","_api$assumption","_api$assumption2","assertVersion","ignoreToPrimitiveHint","assumption","loose","mutableTemplateObject","helperName","buildConcatCallExpressions","items","avail","reduce","left","right","canBeInserted","types","isLiteral","isCallExpression","arguments","push","callExpression","memberExpression","identifier","name","visitor","TaggedTemplateExpression","path","node","quasi","strings","raws","isStringsRawEqual","elem","quasis","raw","cooked","scope","buildUndefinedNode","stringLiteral","helperArgs","arrayExpression","tmp","generateUidIdentifier","getProgramParent","id","cloneNode","replaceWith","tag","template","expression","ast","addHelper","expressions","TemplateLiteral","parent","type","nodes","get","index","length","expr","isStringLiteral","unshift","root","i","binaryExpression"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@babel/plugin-transform-template-literals/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\n\nvar _core = require(\"@babel/core\");\n\nvar _default = (0, _helperPluginUtils.declare)((api, options) => {\n  var _api$assumption, _api$assumption2;\n\n  api.assertVersion(7);\n  const ignoreToPrimitiveHint = (_api$assumption = api.assumption(\"ignoreToPrimitiveHint\")) != null ? _api$assumption : options.loose;\n  const mutableTemplateObject = (_api$assumption2 = api.assumption(\"mutableTemplateObject\")) != null ? _api$assumption2 : options.loose;\n  let helperName = \"taggedTemplateLiteral\";\n  if (mutableTemplateObject) helperName += \"Loose\";\n\n  function buildConcatCallExpressions(items) {\n    let avail = true;\n    return items.reduce(function (left, right) {\n      let canBeInserted = _core.types.isLiteral(right);\n\n      if (!canBeInserted && avail) {\n        canBeInserted = true;\n        avail = false;\n      }\n\n      if (canBeInserted && _core.types.isCallExpression(left)) {\n        left.arguments.push(right);\n        return left;\n      }\n\n      return _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier(\"concat\")), [right]);\n    });\n  }\n\n  return {\n    name: \"transform-template-literals\",\n    visitor: {\n      TaggedTemplateExpression(path) {\n        const {\n          node\n        } = path;\n        const {\n          quasi\n        } = node;\n        const strings = [];\n        const raws = [];\n        let isStringsRawEqual = true;\n\n        for (const elem of quasi.quasis) {\n          const {\n            raw,\n            cooked\n          } = elem.value;\n          const value = cooked == null ? path.scope.buildUndefinedNode() : _core.types.stringLiteral(cooked);\n          strings.push(value);\n          raws.push(_core.types.stringLiteral(raw));\n\n          if (raw !== cooked) {\n            isStringsRawEqual = false;\n          }\n        }\n\n        const helperArgs = [_core.types.arrayExpression(strings)];\n\n        if (!isStringsRawEqual) {\n          helperArgs.push(_core.types.arrayExpression(raws));\n        }\n\n        const tmp = path.scope.generateUidIdentifier(\"templateObject\");\n        path.scope.getProgramParent().push({\n          id: _core.types.cloneNode(tmp)\n        });\n        path.replaceWith(_core.types.callExpression(node.tag, [_core.template.expression.ast`\n              ${_core.types.cloneNode(tmp)} || (\n                ${tmp} = ${this.addHelper(helperName)}(${helperArgs})\n              )\n            `, ...quasi.expressions]));\n      },\n\n      TemplateLiteral(path) {\n        if (path.parent.type === \"TSLiteralType\") {\n          return;\n        }\n\n        const nodes = [];\n        const expressions = path.get(\"expressions\");\n        let index = 0;\n\n        for (const elem of path.node.quasis) {\n          if (elem.value.cooked) {\n            nodes.push(_core.types.stringLiteral(elem.value.cooked));\n          }\n\n          if (index < expressions.length) {\n            const expr = expressions[index++];\n            const node = expr.node;\n\n            if (!_core.types.isStringLiteral(node, {\n              value: \"\"\n            })) {\n              nodes.push(node);\n            }\n          }\n        }\n\n        if (!_core.types.isStringLiteral(nodes[0]) && !(ignoreToPrimitiveHint && _core.types.isStringLiteral(nodes[1]))) {\n          nodes.unshift(_core.types.stringLiteral(\"\"));\n        }\n\n        let root = nodes[0];\n\n        if (ignoreToPrimitiveHint) {\n          for (let i = 1; i < nodes.length; i++) {\n            root = _core.types.binaryExpression(\"+\", root, nodes[i]);\n          }\n        } else if (nodes.length > 1) {\n          root = buildConcatCallExpressions(nodes);\n        }\n\n        path.replaceWith(root);\n      }\n\n    }\n  };\n});\n\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}