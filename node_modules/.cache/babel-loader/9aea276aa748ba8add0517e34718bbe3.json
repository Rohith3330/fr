{"ast":null,"code":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nlet path = require('path');\n\nlet fs = require('fs');\n\nlet exec = require('child_process').exec;\n\nlet FileList = require('filelist').FileList;\n/**\n  @name jake\n  @namespace jake\n*/\n\n/**\n  @name jake.PackageTask\n  @constructor\n  @description Instantiating a PackageTask creates a number of Jake\n  Tasks that make packaging and distributing your software easy.\n\n  @param {String} name The name of the project\n  @param {String} version The current project version (will be\n  appended to the project-name in the package-archive\n  @param {Function} definition Defines the contents of the package,\n  and format of the package-archive. Will be executed on the instantiated\n  PackageTask (i.e., 'this', will be the PackageTask instance),\n  to set the various instance-propertiess.\n\n  @example\n  let t = new jake.PackageTask('rous', 'v' + version, function () {\n    let files = [\n      'Capfile'\n    , 'Jakefile'\n    , 'README.md'\n    , 'package.json'\n    , 'app/*'\n    , 'bin/*'\n    , 'config/*'\n    , 'lib/*'\n    , 'node_modules/*'\n    ];\n    this.packageFiles.include(files);\n    this.packageFiles.exclude('node_modules/foobar');\n    this.needTarGz = true;\n  });\n\n */\n\n\nlet PackageTask = function () {\n  let args = Array.prototype.slice.call(arguments);\n  let name = args.shift();\n  let version = args.shift();\n  let definition = args.pop();\n  let prereqs = args.pop() || []; // Optional\n\n  prereqs = [].concat(prereqs); // Accept string or list\n\n  /**\n    @name jake.PackageTask#name\n    @public\n    @type {String}\n    @description The name of the project\n   */\n\n  this.name = name;\n  /**\n    @name jake.PackageTask#version\n    @public\n    @type {String}\n    @description The project version-string\n   */\n\n  this.version = version;\n  /**\n    @name jake.PackageTask#prereqs\n    @public\n    @type {Array}\n    @description Tasks to run before packaging\n   */\n\n  this.prereqs = prereqs;\n  /**\n    @name jake.PackageTask#packageDir\n    @public\n    @type {String='pkg'}\n    @description The directory-name to use for packaging the software\n   */\n\n  this.packageDir = 'pkg';\n  /**\n    @name jake.PackageTask#packageFiles\n    @public\n    @type {jake.FileList}\n    @description The list of files and directories to include in the\n    package-archive\n   */\n\n  this.packageFiles = new FileList();\n  /**\n    @name jake.PackageTask#needTar\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a gzip .tgz archive of the package\n   */\n\n  this.needTar = false;\n  /**\n    @name jake.PackageTask#needTarGz\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a gzip .tar.gz archive of the package\n   */\n\n  this.needTarGz = false;\n  /**\n    @name jake.PackageTask#needTarBz2\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a bzip2 .bz2 archive of the package\n   */\n\n  this.needTarBz2 = false;\n  /**\n    @name jake.PackageTask#needJar\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `jar` utility to create\n    a .jar archive of the package\n   */\n\n  this.needJar = false;\n  /**\n    @name jake.PackageTask#needZip\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `zip` utility to create\n    a .zip archive of the package\n   */\n\n  this.needZip = false;\n  /**\n    @name jake.PackageTask#manifestFile\n    @public\n    @type {String=null}\n    @description Can be set to point the `jar` utility at a manifest\n    file to use in a .jar archive. If unset, one will be automatically\n    created by the `jar` utility. This path should be relative to the\n    root of the package directory (this.packageDir above, likely 'pkg')\n   */\n\n  this.manifestFile = null;\n  /**\n    @name jake.PackageTask#tarCommand\n    @public\n    @type {String='tar'}\n    @description The shell-command to use for creating tar archives.\n   */\n\n  this.tarCommand = 'tar';\n  /**\n    @name jake.PackageTask#jarCommand\n    @public\n    @type {String='jar'}\n    @description The shell-command to use for creating jar archives.\n   */\n\n  this.jarCommand = 'jar';\n  /**\n    @name jake.PackageTask#zipCommand\n    @public\n    @type {String='zip'}\n    @description The shell-command to use for creating zip archives.\n   */\n\n  this.zipCommand = 'zip';\n  /**\n    @name jake.PackageTask#archiveNoBaseDir\n    @public\n    @type {Boolean=false}\n    @description Simple option for performing the archive on the\n    contents of the directory instead of the directory itself\n   */\n\n  this.archiveNoBaseDir = false;\n  /**\n    @name jake.PackageTask#archiveChangeDir\n    @public\n    @type {String=null}\n    @description Equivalent to the '-C' command for the `tar` and `jar`\n    commands. (\"Change to this directory before adding files.\")\n   */\n\n  this.archiveChangeDir = null;\n  /**\n    @name jake.PackageTask#archiveContentDir\n    @public\n    @type {String=null}\n    @description Specifies the files and directories to include in the\n    package-archive. If unset, this will default to the main package\n    directory -- i.e., name + version.\n   */\n\n  this.archiveContentDir = null;\n\n  if (typeof definition == 'function') {\n    definition.call(this);\n  }\n\n  this.define();\n};\n\nPackageTask.prototype = new function () {\n  let _compressOpts = {\n    Tar: {\n      ext: '.tgz',\n      flags: 'czf',\n      cmd: 'tar'\n    },\n    TarGz: {\n      ext: '.tar.gz',\n      flags: 'czf',\n      cmd: 'tar'\n    },\n    TarBz2: {\n      ext: '.tar.bz2',\n      flags: 'cjf',\n      cmd: 'tar'\n    },\n    Jar: {\n      ext: '.jar',\n      flags: 'cf',\n      cmd: 'jar'\n    },\n    Zip: {\n      ext: '.zip',\n      flags: 'qr',\n      cmd: 'zip'\n    }\n  };\n\n  this.define = function () {\n    let self = this;\n    let packageDirPath = this.packageDirPath();\n    let compressTaskArr = [];\n    desc('Build the package for distribution');\n    task('package', self.prereqs.concat(['clobberPackage', 'buildPackage'])); // Backward-compat alias\n\n    task('repackage', ['package']);\n    task('clobberPackage', function () {\n      jake.rmRf(self.packageDir, {\n        silent: true\n      });\n    });\n    desc('Remove the package');\n    task('clobber', ['clobberPackage']);\n\n    let doCommand = function (p) {\n      let filename = path.resolve(self.packageDir + '/' + self.packageName() + _compressOpts[p].ext);\n\n      if (process.platform == 'win32') {\n        // Windows full path may have drive letter, which is going to cause\n        // namespace problems, so strip it.\n        if (filename.length > 2 && filename[1] == ':') {\n          filename = filename.substr(2);\n        }\n      }\n\n      compressTaskArr.push(filename);\n      file(filename, [packageDirPath], function () {\n        let cmd;\n        let opts = _compressOpts[p]; // Directory to move to when doing the compression-task\n        // Changes in the case of zip for emulating -C option\n\n        let chdir = self.packageDir; // Save the current dir so it's possible to pop back up\n        // after compressing\n\n        let currDir = process.cwd();\n        let archiveChangeDir;\n        let archiveContentDir;\n\n        if (self.archiveNoBaseDir) {\n          archiveChangeDir = self.packageName();\n          archiveContentDir = '.';\n        } else {\n          archiveChangeDir = self.archiveChangeDir;\n          archiveContentDir = self.archiveContentDir;\n        }\n\n        cmd = self[opts.cmd + 'Command'];\n        cmd += ' -' + opts.flags;\n\n        if (opts.cmd == 'jar' && self.manifestFile) {\n          cmd += 'm';\n        } // The name of the archive to create -- use full path\n        // so compression can be performed from a different dir\n        // if needed\n\n\n        cmd += ' ' + filename;\n\n        if (opts.cmd == 'jar' && self.manifestFile) {\n          cmd += ' ' + self.manifestFile;\n        } // Where to perform the compression -- -C option isn't\n        // supported in zip, so actually do process.chdir for this\n\n\n        if (archiveChangeDir) {\n          if (opts.cmd == 'zip') {\n            chdir = path.join(chdir, archiveChangeDir);\n          } else {\n            cmd += ' -C ' + archiveChangeDir;\n          }\n        } // Where to get the archive content\n\n\n        if (archiveContentDir) {\n          cmd += ' ' + archiveContentDir;\n        } else {\n          cmd += ' ' + self.packageName();\n        } // Move into the desired dir (usually packageDir) to compress\n        // Return back up to the current dir after the exec\n\n\n        process.chdir(chdir);\n        exec(cmd, function (err, stdout, stderr) {\n          if (err) {\n            throw err;\n          } // Return back up to the starting directory (see above,\n          // before exec)\n\n\n          process.chdir(currDir);\n          complete();\n        });\n      }, {\n        async: true\n      });\n    };\n\n    for (let p in _compressOpts) {\n      if (this['need' + p]) {\n        doCommand(p);\n      }\n    }\n\n    task('buildPackage', compressTaskArr, function () {});\n    directory(this.packageDir);\n    file(packageDirPath, this.packageFiles, function () {\n      jake.mkdirP(packageDirPath);\n      let fileList = [];\n      self.packageFiles.forEach(function (name) {\n        let f = path.join(self.packageDirPath(), name);\n        let fDir = path.dirname(f);\n        jake.mkdirP(fDir, {\n          silent: true\n        }); // Add both files and directories\n\n        fileList.push({\n          from: name,\n          to: f\n        });\n      });\n\n      let _copyFile = function () {\n        let file = fileList.pop();\n        let stat;\n\n        if (file) {\n          stat = fs.statSync(file.from); // Target is a directory, just create it\n\n          if (stat.isDirectory()) {\n            jake.mkdirP(file.to, {\n              silent: true\n            });\n\n            _copyFile();\n          } // Otherwise copy the file\n          else {\n            jake.cpR(file.from, file.to, {\n              silent: true\n            });\n\n            _copyFile();\n          }\n        } else {\n          complete();\n        }\n      };\n\n      _copyFile();\n    }, {\n      async: true\n    });\n  };\n\n  this.packageName = function () {\n    if (this.version) {\n      return this.name + '-' + this.version;\n    } else {\n      return this.name;\n    }\n  };\n\n  this.packageDirPath = function () {\n    return this.packageDir + '/' + this.packageName();\n  };\n}();\njake.PackageTask = PackageTask;\nexports.PackageTask = PackageTask;","map":{"version":3,"names":["path","require","fs","exec","FileList","PackageTask","args","Array","prototype","slice","call","arguments","name","shift","version","definition","pop","prereqs","concat","packageDir","packageFiles","needTar","needTarGz","needTarBz2","needJar","needZip","manifestFile","tarCommand","jarCommand","zipCommand","archiveNoBaseDir","archiveChangeDir","archiveContentDir","define","_compressOpts","Tar","ext","flags","cmd","TarGz","TarBz2","Jar","Zip","self","packageDirPath","compressTaskArr","desc","task","jake","rmRf","silent","doCommand","p","filename","resolve","packageName","process","platform","length","substr","push","file","opts","chdir","currDir","cwd","join","err","stdout","stderr","complete","async","directory","mkdirP","fileList","forEach","f","fDir","dirname","from","to","_copyFile","stat","statSync","isDirectory","cpR","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jake/lib/package_task.js"],"sourcesContent":["/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nlet path = require('path');\nlet fs = require('fs');\nlet exec = require('child_process').exec;\nlet FileList = require('filelist').FileList;\n\n/**\n  @name jake\n  @namespace jake\n*/\n/**\n  @name jake.PackageTask\n  @constructor\n  @description Instantiating a PackageTask creates a number of Jake\n  Tasks that make packaging and distributing your software easy.\n\n  @param {String} name The name of the project\n  @param {String} version The current project version (will be\n  appended to the project-name in the package-archive\n  @param {Function} definition Defines the contents of the package,\n  and format of the package-archive. Will be executed on the instantiated\n  PackageTask (i.e., 'this', will be the PackageTask instance),\n  to set the various instance-propertiess.\n\n  @example\n  let t = new jake.PackageTask('rous', 'v' + version, function () {\n    let files = [\n      'Capfile'\n    , 'Jakefile'\n    , 'README.md'\n    , 'package.json'\n    , 'app/*'\n    , 'bin/*'\n    , 'config/*'\n    , 'lib/*'\n    , 'node_modules/*'\n    ];\n    this.packageFiles.include(files);\n    this.packageFiles.exclude('node_modules/foobar');\n    this.needTarGz = true;\n  });\n\n */\nlet PackageTask = function () {\n  let args = Array.prototype.slice.call(arguments);\n  let name = args.shift();\n  let version = args.shift();\n  let definition = args.pop();\n  let prereqs = args.pop() || []; // Optional\n\n  prereqs = [].concat(prereqs); // Accept string or list\n\n  /**\n    @name jake.PackageTask#name\n    @public\n    @type {String}\n    @description The name of the project\n   */\n  this.name = name;\n  /**\n    @name jake.PackageTask#version\n    @public\n    @type {String}\n    @description The project version-string\n   */\n  this.version = version;\n  /**\n    @name jake.PackageTask#prereqs\n    @public\n    @type {Array}\n    @description Tasks to run before packaging\n   */\n  this.prereqs = prereqs;\n  /**\n    @name jake.PackageTask#packageDir\n    @public\n    @type {String='pkg'}\n    @description The directory-name to use for packaging the software\n   */\n  this.packageDir = 'pkg';\n  /**\n    @name jake.PackageTask#packageFiles\n    @public\n    @type {jake.FileList}\n    @description The list of files and directories to include in the\n    package-archive\n   */\n  this.packageFiles = new FileList();\n  /**\n    @name jake.PackageTask#needTar\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a gzip .tgz archive of the package\n   */\n  this.needTar = false;\n  /**\n    @name jake.PackageTask#needTarGz\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a gzip .tar.gz archive of the package\n   */\n  this.needTarGz = false;\n  /**\n    @name jake.PackageTask#needTarBz2\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `tar` utility to create\n    a bzip2 .bz2 archive of the package\n   */\n  this.needTarBz2 = false;\n  /**\n    @name jake.PackageTask#needJar\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `jar` utility to create\n    a .jar archive of the package\n   */\n  this.needJar = false;\n  /**\n    @name jake.PackageTask#needZip\n    @public\n    @type {Boolean=false}\n    @description If set to true, uses the `zip` utility to create\n    a .zip archive of the package\n   */\n  this.needZip = false;\n  /**\n    @name jake.PackageTask#manifestFile\n    @public\n    @type {String=null}\n    @description Can be set to point the `jar` utility at a manifest\n    file to use in a .jar archive. If unset, one will be automatically\n    created by the `jar` utility. This path should be relative to the\n    root of the package directory (this.packageDir above, likely 'pkg')\n   */\n  this.manifestFile = null;\n  /**\n    @name jake.PackageTask#tarCommand\n    @public\n    @type {String='tar'}\n    @description The shell-command to use for creating tar archives.\n   */\n  this.tarCommand = 'tar';\n  /**\n    @name jake.PackageTask#jarCommand\n    @public\n    @type {String='jar'}\n    @description The shell-command to use for creating jar archives.\n   */\n  this.jarCommand = 'jar';\n  /**\n    @name jake.PackageTask#zipCommand\n    @public\n    @type {String='zip'}\n    @description The shell-command to use for creating zip archives.\n   */\n  this.zipCommand = 'zip';\n  /**\n    @name jake.PackageTask#archiveNoBaseDir\n    @public\n    @type {Boolean=false}\n    @description Simple option for performing the archive on the\n    contents of the directory instead of the directory itself\n   */\n  this.archiveNoBaseDir = false;\n  /**\n    @name jake.PackageTask#archiveChangeDir\n    @public\n    @type {String=null}\n    @description Equivalent to the '-C' command for the `tar` and `jar`\n    commands. (\"Change to this directory before adding files.\")\n   */\n  this.archiveChangeDir = null;\n  /**\n    @name jake.PackageTask#archiveContentDir\n    @public\n    @type {String=null}\n    @description Specifies the files and directories to include in the\n    package-archive. If unset, this will default to the main package\n    directory -- i.e., name + version.\n   */\n  this.archiveContentDir = null;\n\n  if (typeof definition == 'function') {\n    definition.call(this);\n  }\n  this.define();\n};\n\nPackageTask.prototype = new (function () {\n\n  let _compressOpts = {\n    Tar: {\n      ext: '.tgz',\n      flags: 'czf',\n      cmd: 'tar'\n    },\n    TarGz: {\n      ext: '.tar.gz',\n      flags: 'czf',\n      cmd: 'tar'\n    },\n    TarBz2: {\n      ext: '.tar.bz2',\n      flags: 'cjf',\n      cmd: 'tar'\n    },\n    Jar: {\n      ext: '.jar',\n      flags: 'cf',\n      cmd: 'jar'\n    },\n    Zip: {\n      ext: '.zip',\n      flags: 'qr',\n      cmd: 'zip'\n    }\n  };\n\n  this.define = function () {\n    let self = this;\n    let packageDirPath = this.packageDirPath();\n    let compressTaskArr = [];\n\n    desc('Build the package for distribution');\n    task('package', self.prereqs.concat(['clobberPackage', 'buildPackage']));\n    // Backward-compat alias\n    task('repackage', ['package']);\n\n    task('clobberPackage', function () {\n      jake.rmRf(self.packageDir, {silent: true});\n    });\n\n    desc('Remove the package');\n    task('clobber', ['clobberPackage']);\n\n    let doCommand = function (p) {\n      let filename = path.resolve(self.packageDir + '/' + self.packageName() +\n                                  _compressOpts[p].ext);\n      if (process.platform == 'win32') {\n        // Windows full path may have drive letter, which is going to cause\n        // namespace problems, so strip it.\n        if (filename.length > 2 && filename[1] == ':') {\n          filename = filename.substr(2);\n        }\n      }\n      compressTaskArr.push(filename);\n\n      file(filename, [packageDirPath], function () {\n        let cmd;\n        let opts = _compressOpts[p];\n        // Directory to move to when doing the compression-task\n        // Changes in the case of zip for emulating -C option\n        let chdir = self.packageDir;\n        // Save the current dir so it's possible to pop back up\n        // after compressing\n        let currDir = process.cwd();\n        let archiveChangeDir;\n        let archiveContentDir;\n\n        if (self.archiveNoBaseDir) {\n          archiveChangeDir = self.packageName();\n          archiveContentDir = '.';\n        }\n        else {\n          archiveChangeDir = self.archiveChangeDir;\n          archiveContentDir = self.archiveContentDir;\n        }\n\n        cmd = self[opts.cmd + 'Command'];\n        cmd += ' -' + opts.flags;\n        if (opts.cmd == 'jar' && self.manifestFile) {\n          cmd += 'm';\n        }\n\n        // The name of the archive to create -- use full path\n        // so compression can be performed from a different dir\n        // if needed\n        cmd += ' ' + filename;\n\n        if (opts.cmd == 'jar' && self.manifestFile) {\n          cmd += ' ' + self.manifestFile;\n        }\n\n        // Where to perform the compression -- -C option isn't\n        // supported in zip, so actually do process.chdir for this\n        if (archiveChangeDir) {\n          if (opts.cmd == 'zip') {\n            chdir = path.join(chdir, archiveChangeDir);\n          }\n          else {\n            cmd += ' -C ' + archiveChangeDir;\n          }\n        }\n\n        // Where to get the archive content\n        if (archiveContentDir) {\n          cmd += ' ' + archiveContentDir;\n        }\n        else {\n          cmd += ' ' + self.packageName();\n        }\n\n        // Move into the desired dir (usually packageDir) to compress\n        // Return back up to the current dir after the exec\n        process.chdir(chdir);\n\n        exec(cmd, function (err, stdout, stderr) {\n          if (err) { throw err; }\n\n          // Return back up to the starting directory (see above,\n          // before exec)\n          process.chdir(currDir);\n\n          complete();\n        });\n      }, {async: true});\n    };\n\n    for (let p in _compressOpts) {\n      if (this['need' + p]) {\n        doCommand(p);\n      }\n    }\n\n    task('buildPackage', compressTaskArr, function () {});\n\n    directory(this.packageDir);\n\n    file(packageDirPath, this.packageFiles, function () {\n      jake.mkdirP(packageDirPath);\n      let fileList = [];\n      self.packageFiles.forEach(function (name) {\n        let f = path.join(self.packageDirPath(), name);\n        let fDir = path.dirname(f);\n        jake.mkdirP(fDir, {silent: true});\n\n        // Add both files and directories\n        fileList.push({\n          from: name,\n          to: f\n        });\n      });\n      let _copyFile = function () {\n        let file = fileList.pop();\n        let stat;\n        if (file) {\n          stat = fs.statSync(file.from);\n          // Target is a directory, just create it\n          if (stat.isDirectory()) {\n            jake.mkdirP(file.to, {silent: true});\n            _copyFile();\n          }\n          // Otherwise copy the file\n          else {\n            jake.cpR(file.from, file.to, {silent: true});\n            _copyFile();\n          }\n        }\n        else {\n          complete();\n        }\n      };\n      _copyFile();\n    }, {async: true});\n\n\n  };\n\n  this.packageName = function () {\n    if (this.version) {\n      return this.name + '-' + this.version;\n    }\n    else {\n      return this.name;\n    }\n  };\n\n  this.packageDirPath = function () {\n    return this.packageDir + '/' + this.packageName();\n  };\n\n})();\n\njake.PackageTask = PackageTask;\nexports.PackageTask = PackageTask;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}