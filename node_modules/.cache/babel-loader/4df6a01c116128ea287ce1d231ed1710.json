{"ast":null,"code":"var async = require('./async.js'); // API\n\n\nmodule.exports = {\n  iterator: wrapIterator,\n  callback: wrapCallback\n};\n/**\n * Wraps iterators with long signature\n *\n * @this    ReadableAsyncKit#\n * @param   {function} iterator - function to wrap\n * @returns {function} - wrapped function\n */\n\nfunction wrapIterator(iterator) {\n  var stream = this;\n  return function (item, key, cb) {\n    var aborter,\n        wrappedCb = async(wrapIteratorCallback.call(stream, cb, key));\n    stream.jobs[key] = wrappedCb; // it's either shortcut (item, cb)\n\n    if (iterator.length == 2) {\n      aborter = iterator(item, wrappedCb);\n    } // or long format (item, key, cb)\n    else {\n      aborter = iterator(item, key, wrappedCb);\n    }\n\n    return aborter;\n  };\n}\n/**\n * Wraps provided callback function\n * allowing to execute snitch function before\n * real callback\n *\n * @this    ReadableAsyncKit#\n * @param   {function} callback - function to wrap\n * @returns {function} - wrapped function\n */\n\n\nfunction wrapCallback(callback) {\n  var stream = this;\n\n  var wrapped = function (error, result) {\n    return finisher.call(stream, error, result, callback);\n  };\n\n  return wrapped;\n}\n/**\n * Wraps provided iterator callback function\n * makes sure snitch only called once,\n * but passes secondary calls to the original callback\n *\n * @this    ReadableAsyncKit#\n * @param   {function} callback - callback to wrap\n * @param   {number|string} key - iteration key\n * @returns {function} wrapped callback\n */\n\n\nfunction wrapIteratorCallback(callback, key) {\n  var stream = this;\n  return function (error, output) {\n    // don't repeat yourself\n    if (!(key in stream.jobs)) {\n      callback(error, output);\n      return;\n    } // clean up jobs\n\n\n    delete stream.jobs[key];\n    return streamer.call(stream, error, {\n      key: key,\n      value: output\n    }, callback);\n  };\n}\n/**\n * Stream wrapper for iterator callback\n *\n * @this  ReadableAsyncKit#\n * @param {mixed} error - error response\n * @param {mixed} output - iterator output\n * @param {function} callback - callback that expects iterator results\n */\n\n\nfunction streamer(error, output, callback) {\n  if (error && !this.error) {\n    this.error = error;\n    this.pause();\n    this.emit('error', error); // send back value only, as expected\n\n    callback(error, output && output.value);\n    return;\n  } // stream stuff\n\n\n  this.push(output); // back to original track\n  // send back value only, as expected\n\n  callback(error, output && output.value);\n}\n/**\n * Stream wrapper for finishing callback\n *\n * @this  ReadableAsyncKit#\n * @param {mixed} error - error response\n * @param {mixed} output - iterator output\n * @param {function} callback - callback that expects final results\n */\n\n\nfunction finisher(error, output, callback) {\n  // signal end of the stream\n  // only for successfully finished streams\n  if (!error) {\n    this.push(null);\n  } // back to original track\n\n\n  callback(error, output);\n}","map":{"version":3,"names":["async","require","module","exports","iterator","wrapIterator","callback","wrapCallback","stream","item","key","cb","aborter","wrappedCb","wrapIteratorCallback","call","jobs","length","wrapped","error","result","finisher","output","streamer","value","pause","emit","push"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/asynckit/lib/streamify.js"],"sourcesContent":["var async = require('./async.js');\n\n// API\nmodule.exports = {\n  iterator: wrapIterator,\n  callback: wrapCallback\n};\n\n/**\n * Wraps iterators with long signature\n *\n * @this    ReadableAsyncKit#\n * @param   {function} iterator - function to wrap\n * @returns {function} - wrapped function\n */\nfunction wrapIterator(iterator)\n{\n  var stream = this;\n\n  return function(item, key, cb)\n  {\n    var aborter\n      , wrappedCb = async(wrapIteratorCallback.call(stream, cb, key))\n      ;\n\n    stream.jobs[key] = wrappedCb;\n\n    // it's either shortcut (item, cb)\n    if (iterator.length == 2)\n    {\n      aborter = iterator(item, wrappedCb);\n    }\n    // or long format (item, key, cb)\n    else\n    {\n      aborter = iterator(item, key, wrappedCb);\n    }\n\n    return aborter;\n  };\n}\n\n/**\n * Wraps provided callback function\n * allowing to execute snitch function before\n * real callback\n *\n * @this    ReadableAsyncKit#\n * @param   {function} callback - function to wrap\n * @returns {function} - wrapped function\n */\nfunction wrapCallback(callback)\n{\n  var stream = this;\n\n  var wrapped = function(error, result)\n  {\n    return finisher.call(stream, error, result, callback);\n  };\n\n  return wrapped;\n}\n\n/**\n * Wraps provided iterator callback function\n * makes sure snitch only called once,\n * but passes secondary calls to the original callback\n *\n * @this    ReadableAsyncKit#\n * @param   {function} callback - callback to wrap\n * @param   {number|string} key - iteration key\n * @returns {function} wrapped callback\n */\nfunction wrapIteratorCallback(callback, key)\n{\n  var stream = this;\n\n  return function(error, output)\n  {\n    // don't repeat yourself\n    if (!(key in stream.jobs))\n    {\n      callback(error, output);\n      return;\n    }\n\n    // clean up jobs\n    delete stream.jobs[key];\n\n    return streamer.call(stream, error, {key: key, value: output}, callback);\n  };\n}\n\n/**\n * Stream wrapper for iterator callback\n *\n * @this  ReadableAsyncKit#\n * @param {mixed} error - error response\n * @param {mixed} output - iterator output\n * @param {function} callback - callback that expects iterator results\n */\nfunction streamer(error, output, callback)\n{\n  if (error && !this.error)\n  {\n    this.error = error;\n    this.pause();\n    this.emit('error', error);\n    // send back value only, as expected\n    callback(error, output && output.value);\n    return;\n  }\n\n  // stream stuff\n  this.push(output);\n\n  // back to original track\n  // send back value only, as expected\n  callback(error, output && output.value);\n}\n\n/**\n * Stream wrapper for finishing callback\n *\n * @this  ReadableAsyncKit#\n * @param {mixed} error - error response\n * @param {mixed} output - iterator output\n * @param {function} callback - callback that expects final results\n */\nfunction finisher(error, output, callback)\n{\n  // signal end of the stream\n  // only for successfully finished streams\n  if (!error)\n  {\n    this.push(null);\n  }\n\n  // back to original track\n  callback(error, output);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}