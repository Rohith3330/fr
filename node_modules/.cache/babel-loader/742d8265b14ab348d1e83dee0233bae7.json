{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.ensureBlock = ensureBlock;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\n\nvar _t = require(\"@babel/types\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _visitors = require(\"../visitors\");\n\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  toExpression,\n  unaryExpression\n} = _t;\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction setType(path, type) {\n  path.node.type = type;\n}\n\nfunction arrowFunctionToExpression() {\n  let {\n    allowInsertArrow = true,\n    specCompliant = false,\n    noNewArrows = !specCompliant\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const {\n    thisBinding,\n    fnPath: fn\n  } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  fn.ensureBlock();\n  setType(fn, \"FunctionExpression\");\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n    return fn.get(\"callee.object\");\n  }\n\n  return fn;\n}\n\nconst getSuperCallsVisitor = (0, _visitors.merge)([{\n  CallExpression(child, _ref) {\n    let {\n      allSuperCalls\n    } = _ref;\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction hoistFunctionEnvironment(fnPath) {\n  let noNewArrows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let allowInsertArrow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let arrowParent;\n  let thisEnvFn = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      var _arrowParent;\n\n      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;\n      return false;\n    }\n\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  const inConstructor = thisEnvFn.isClassMethod({\n    kind: \"constructor\"\n  });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get(\"callee\");\n      fnPath = thisEnvFn.get(\"body\");\n    } else {\n      throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n    }\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, {\n      allSuperCalls\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => metaProperty(identifier(\"new\"), identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const superParentPath = superProp.parentPath;\n      const isAssignment = superParentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superParentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superParentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superParentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superParentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superParentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return {\n    thisBinding,\n    fnPath\n  };\n}\n\nfunction isLogicalOp(op) {\n  return LOGICAL_OPERATORS.includes(op);\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    const isLogicalAssignment = isLogicalOp(op);\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, assignmentExpression(\"=\", tmp, property), true));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(tmp.name), true), value));\n    } else {\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, property));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(property.name)), value));\n    }\n\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [assignmentExpression(\"=\", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n\n  function rightExpression(op, left, right) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nconst assignSuperThisVisitor = (0, _visitors.merge)([{\n  CallExpression(child, _ref2) {\n    let {\n      supers,\n      thisBinding\n    } = _ref2;\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n    child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nconst getScopeInformationVisitor = (0, _visitors.merge)([{\n  ThisExpression(child, _ref3) {\n    let {\n      thisPaths\n    } = _ref3;\n    thisPaths.push(child);\n  },\n\n  JSXIdentifier(child, _ref4) {\n    let {\n      thisPaths\n    } = _ref4;\n    if (child.node.name !== \"this\") return;\n\n    if (!child.parentPath.isJSXMemberExpression({\n      object: child.node\n    }) && !child.parentPath.isJSXOpeningElement({\n      name: child.node\n    })) {\n      return;\n    }\n\n    thisPaths.push(child);\n  },\n\n  CallExpression(child, _ref5) {\n    let {\n      superCalls\n    } = _ref5;\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n\n  MemberExpression(child, _ref6) {\n    let {\n      superProps\n    } = _ref6;\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n\n  Identifier(child, _ref7) {\n    let {\n      argumentsPaths\n    } = _ref7;\n    if (!child.isReferencedIdentifier({\n      name: \"arguments\"\n    })) return;\n    let curr = child.scope;\n\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while (curr = curr.parent);\n\n    argumentsPaths.push(child);\n  },\n\n  MetaProperty(child, _ref8) {\n    let {\n      newTargetPaths\n    } = _ref8;\n    if (!child.get(\"meta\").isIdentifier({\n      name: \"new\"\n    })) return;\n    if (!child.get(\"property\").isIdentifier({\n      name: \"target\"\n    })) return;\n    newTargetPaths.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","map":{"version":3,"mappings":"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","names":["arrowFunctionExpression","assignmentExpression","binaryExpression","blockStatement","callExpression","conditionalExpression","expressionStatement","identifier","isIdentifier","jsxIdentifier","logicalExpression","LOGICAL_OPERATORS","memberExpression","metaProperty","numericLiteral","objectExpression","restElement","returnStatement","sequenceExpression","spreadElement","stringLiteral","super","_super","thisExpression","toExpression","unaryExpression","toComputedKey","key","isMemberExpression","node","property","isProperty","isMethod","ReferenceError","computed","name","ensureBlock","body","get","bodyNode","Array","isArray","Error","isBlockStatement","statements","stringPath","listKey","isStatement","push","isFunction","parentPath","setup","arrowFunctionToShadowed","isArrowFunctionExpression","arrowFunctionToExpression","unwrapFunctionEnvironment","isFunctionExpression","isFunctionDeclaration","buildCodeFrameError","hoistFunctionEnvironment","setType","path","type","allowInsertArrow","specCompliant","noNewArrows","thisBinding","fnPath","fn","checkBinding","scope","generateUidIdentifier","id","init","unshiftContainer","hub","addHelper","replaceWith","getSuperCallsVisitor","CallExpression","child","allSuperCalls","isSuper","environmentVisitor","arrowParent","thisEnvFn","findParent","p","isProgram","isClassProperty","static","isClassPrivateProperty","inConstructor","isClassMethod","kind","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","getScopeInformation","length","traverse","superBinding","getSuperBinding","forEach","superCall","callee","loc","argumentsBinding","getBinding","args","buildUndefinedNode","argumentsChild","argsRef","newTargetBinding","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","concat","standardizeSuperProperty","superParentPath","isAssignment","isAssignmentExpression","left","isCall","isCallExpression","getSuperPropBinding","value","right","call","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","isLogicalOp","op","includes","operator","assignmentPath","slice","isLogicalAssignment","tmp","generateDeclaredUidIdentifier","object","rightExpression","isUpdateExpression","updateExpr","computedKey","parts","prefix","superClass","assignSuperThisVisitor","supers","has","add","replaceWithMultiple","WeakSet","argsBinding","propName","argsList","fnBody","method","unshift","valueIdent","cacheKey","data","getData","setData","getScopeInformationVisitor","ThisExpression","JSXIdentifier","isJSXMemberExpression","isJSXOpeningElement","MemberExpression","Identifier","isReferencedIdentifier","curr","hasOwnBinding","rename","parent","MetaProperty"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\path\\conversion.ts"],"sourcesContent":["// This file contains methods that convert the path node into another node or some other type of data.\n\nimport {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super as _super,\n  thisExpression,\n  toExpression,\n  unaryExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport { merge as mergeVisitors } from \"../visitors\";\nimport type NodePath from \"./index\";\n\nexport function toComputedKey(this: NodePath) {\n  let key;\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  // @ts-expect-error todo(flow->ts) computed does not exist in ClassPrivateProperty\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nexport function ensureBlock(\n  this: NodePath<\n    t.Loop | t.WithStatement | t.Function | t.LabeledStatement | t.CatchClause\n  >,\n) {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements: Array<t.Statement> = [];\n\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node as t.Expression));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node as t.Expression));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath) as NodePath;\n  body.setup(\n    parentPath,\n    listKey\n      ? // @ts-expect-error listKey must present in parent path\n        parentPath.node[listKey]\n      : parentPath.node,\n    listKey,\n    key,\n  );\n\n  return this.node;\n}\n\n/**\n * Keeping this for backward-compatibility. You should use arrowFunctionToExpression() for >=7.x.\n */\n// TODO(Babel 8): Remove this\nexport function arrowFunctionToShadowed(this: NodePath) {\n  if (!this.isArrowFunctionExpression()) return;\n\n  this.arrowFunctionToExpression();\n}\n\n/**\n * Given an arbitrary function, process its content as if it were an arrow function, moving references\n * to \"this\", \"arguments\", \"super\", and such into the function's parent scope. This method is useful if\n * you have wrapped some set of items in an IIFE or other function, but want \"this\", \"arguments\", and super\"\n * to continue behaving as expected.\n */\nexport function unwrapFunctionEnvironment(this: NodePath) {\n  if (\n    !this.isArrowFunctionExpression() &&\n    !this.isFunctionExpression() &&\n    !this.isFunctionDeclaration()\n  ) {\n    throw this.buildCodeFrameError(\n      \"Can only unwrap the environment of a function.\",\n    );\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction setType<N extends t.Node, T extends N[\"type\"]>(\n  path: NodePath<N>,\n  type: T,\n): asserts path is NodePath<Extract<N, { type: T }>> {\n  path.node.type = type;\n}\n\n/**\n * Convert a given arrow function into a normal ES5 function expression.\n */\nexport function arrowFunctionToExpression(\n  this: NodePath<t.ArrowFunctionExpression>,\n  {\n    allowInsertArrow = true,\n    /** @deprecated Use `noNewArrows` instead */\n    specCompliant = false,\n    // TODO(Babel 8): Consider defaulting to `false` for spec compliancy\n    noNewArrows = !specCompliant,\n  }: {\n    allowInsertArrow?: boolean | void;\n    specCompliant?: boolean | void;\n    noNewArrows?: boolean;\n  } = {},\n): NodePath<Exclude<t.Function, t.Method | t.ArrowFunctionExpression>> {\n  if (!this.isArrowFunctionExpression()) {\n    throw (this as NodePath).buildCodeFrameError(\n      \"Cannot convert non-arrow function to a function expression.\",\n    );\n  }\n\n  const { thisBinding, fnPath: fn } = hoistFunctionEnvironment(\n    this,\n    noNewArrows,\n    allowInsertArrow,\n  );\n\n  // @ts-expect-error TS requires explicit fn type annotation\n  fn.ensureBlock();\n  setType(fn, \"FunctionExpression\");\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding\n      ? null\n      : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([]),\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\n      \"body\",\n      expressionStatement(\n        callExpression(this.hub.addHelper(\"newArrowCheck\"), [\n          thisExpression(),\n          checkBinding\n            ? identifier(checkBinding.name)\n            : identifier(thisBinding),\n        ]),\n      ),\n    );\n\n    fn.replaceWith(\n      callExpression(\n        memberExpression(\n          // @ts-expect-error TS can't infer nameFunction returns CallExpression | ArrowFunctionExpression here\n          nameFunction(this, true) || fn.node,\n          identifier(\"bind\"),\n        ),\n        [checkBinding ? identifier(checkBinding.name) : thisExpression()],\n      ),\n    );\n\n    return fn.get(\"callee.object\");\n  }\n\n  return fn;\n}\n\nconst getSuperCallsVisitor = mergeVisitors<{\n  allSuperCalls: NodePath<t.CallExpression>[];\n}>([\n  {\n    CallExpression(child, { allSuperCalls }) {\n      if (!child.get(\"callee\").isSuper()) return;\n      allSuperCalls.push(child);\n    },\n  },\n  environmentVisitor,\n]);\n\n/**\n * Given a function, traverse its contents, and if there are references to \"this\", \"arguments\", \"super\",\n * or \"new.target\", ensure that these references reference the parent environment around this function.\n *\n * @returns `thisBinding`: the name of the injected reference to `this`; for example \"_this\"\n * @returns `fnPath`: the new path to the function node. This is different from the fnPath\n *                    parameter when the function node is wrapped in another node.\n */\nfunction hoistFunctionEnvironment(\n  fnPath: NodePath<t.Function>,\n  // TODO(Babel 8): Consider defaulting to `false` for spec compliancy\n  noNewArrows: boolean | void = true,\n  allowInsertArrow: boolean | void = true,\n): { thisBinding: string; fnPath: NodePath<t.Function> } {\n  let arrowParent;\n  let thisEnvFn: NodePath<t.Function> = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      arrowParent ??= p;\n      return false;\n    }\n    return (\n      p.isFunction() ||\n      p.isProgram() ||\n      p.isClassProperty({ static: false }) ||\n      p.isClassPrivateProperty({ static: false })\n    );\n  }) as NodePath<t.Function>;\n  const inConstructor = thisEnvFn.isClassMethod({ kind: \"constructor\" });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      // It's safe to wrap this function in another and not hoist to the\n      // top level because the 'this' binding is constant in class\n      // properties (since 'super()' has already been called), so we don't\n      // need to capture/reassign it at the top level.\n      fnPath.replaceWith(\n        callExpression(\n          arrowFunctionExpression([], toExpression(fnPath.node)),\n          [],\n        ),\n      );\n      thisEnvFn = fnPath.get(\"callee\") as NodePath<t.ArrowFunctionExpression>;\n      fnPath = thisEnvFn.get(\"body\") as NodePath<t.FunctionExpression>;\n    } else {\n      throw fnPath.buildCodeFrameError(\n        \"Unable to transform arrow inside class property\",\n      );\n    }\n  }\n\n  const { thisPaths, argumentsPaths, newTargetPaths, superProps, superCalls } =\n    getScopeInformation(fnPath);\n\n  // Convert all super() calls in the constructor, if super is used in an arrow.\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\n        \"Unable to handle nested super() usage in arrow\",\n      );\n    }\n    const allSuperCalls: NodePath<t.CallExpression>[] = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, { allSuperCalls });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  // Convert all \"arguments\" references in the arrow to point at the alias.\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(\n          binaryExpression(\n            \"===\",\n            unaryExpression(\"typeof\", args()),\n            stringLiteral(\"undefined\"),\n          ),\n          thisEnvFn.scope.buildUndefinedNode(),\n          args(),\n        );\n      } else {\n        return args();\n      }\n    });\n\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  // Convert all \"new.target\" references in the arrow to point at the alias.\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () =>\n      metaProperty(identifier(\"new\"), identifier(\"target\")),\n    );\n\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  // Convert all \"super.prop\" references to point at aliases.\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\n        \"Unable to handle nested super.prop usage\",\n      );\n    }\n\n    const flatSuperProps: NodePath<t.MemberExpression>[] = superProps.reduce(\n      (acc, superProp) => acc.concat(standardizeSuperProperty(superProp)),\n      [],\n    );\n\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed\n        ? \"\"\n        : // @ts-expect-error super property must not contain private name\n          superProp.get(\"property\").node.name;\n\n      const superParentPath = superProp.parentPath;\n\n      const isAssignment = superParentPath.isAssignmentExpression({\n        left: superProp.node,\n      });\n      const isCall = superParentPath.isCallExpression({\n        callee: superProp.node,\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n\n      const args: t.Expression[] = [];\n      if (superProp.node.computed) {\n        // SuperProperty must not be a private name\n        args.push(superProp.get(\"property\").node as t.Expression);\n      }\n\n      if (isAssignment) {\n        const value = superParentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superParentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n\n        thisPaths.push(\n          superParentPath.get(\"arguments.0\") as NodePath<t.ThisExpression>,\n        );\n      } else if (isAssignment) {\n        // Replace not only the super.prop, but the whole assignment\n        superParentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  // Convert all \"this\" references in the arrow to point at the alias.\n  let thisBinding: string | null;\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (\n      noNewArrows ||\n      // In subclass constructors, still need to rewrite because \"this\" can't be bound in spec mode\n      // because it might not have been initialized yet.\n      (inConstructor && hasSuperClass(thisEnvFn))\n    ) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX()\n          ? jsxIdentifier(thisBinding)\n          : identifier(thisBinding);\n\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return { thisBinding, fnPath };\n}\n\ntype LogicalOp = Parameters<typeof logicalExpression>[0];\ntype BinaryOp = Parameters<typeof binaryExpression>[0];\n\nfunction isLogicalOp(op: string): op is LogicalOp {\n  return LOGICAL_OPERATORS.includes(op);\n}\n\nfunction standardizeSuperProperty(\n  superProp: NodePath<t.MemberExpression>,\n):\n  | [NodePath<t.MemberExpression>]\n  | [NodePath<t.MemberExpression>, NodePath<t.MemberExpression>] {\n  if (\n    superProp.parentPath.isAssignmentExpression() &&\n    superProp.parentPath.node.operator !== \"=\"\n  ) {\n    const assignmentPath = superProp.parentPath;\n\n    const op = assignmentPath.node.operator.slice(0, -1) as\n      | LogicalOp\n      | BinaryOp;\n\n    const value = assignmentPath.node.right;\n\n    const isLogicalAssignment = isLogicalOp(op);\n\n    if (superProp.node.computed) {\n      // from: super[foo] **= 4;\n      // to:   super[tmp = foo] = super[tmp] ** 4;\n\n      // from: super[foo] ??= 4;\n      // to:   super[tmp = foo] ?? super[tmp] = 4;\n\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n\n      const object = superProp.node.object;\n      const property = superProp.node.property as t.Expression;\n\n      assignmentPath\n        .get(\"left\")\n        .replaceWith(\n          memberExpression(\n            object,\n            assignmentExpression(\"=\", tmp, property),\n            true /* computed */,\n          ),\n        );\n\n      assignmentPath\n        .get(\"right\")\n        .replaceWith(\n          rightExpression(\n            isLogicalAssignment ? \"=\" : op,\n            memberExpression(object, identifier(tmp.name), true /* computed */),\n            value,\n          ),\n        );\n    } else {\n      // from: super.foo **= 4;\n      // to:   super.foo = super.foo ** 4;\n\n      // from: super.foo ??= 4;\n      // to:   super.foo ?? super.foo = 4;\n\n      const object = superProp.node.object;\n      const property = superProp.node.property as t.Identifier;\n\n      assignmentPath\n        .get(\"left\")\n        .replaceWith(memberExpression(object, property));\n\n      assignmentPath\n        .get(\"right\")\n        .replaceWith(\n          rightExpression(\n            isLogicalAssignment ? \"=\" : op,\n            memberExpression(object, identifier(property.name)),\n            value,\n          ),\n        );\n    }\n\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(\n        logicalExpression(\n          op,\n          assignmentPath.node.left as t.MemberExpression,\n          assignmentPath.node.right as t.Expression,\n        ),\n      );\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n\n    return [\n      assignmentPath.get(\"left\") as NodePath<t.MemberExpression>,\n      assignmentPath.get(\"right\").get(\"left\"),\n    ];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed\n      ? superProp.scope.generateDeclaredUidIdentifier(\"prop\")\n      : null;\n\n    const parts: t.Expression[] = [\n      assignmentExpression(\n        \"=\",\n        tmp,\n        memberExpression(\n          superProp.node.object,\n          computedKey\n            ? assignmentExpression(\n                \"=\",\n                computedKey,\n                superProp.node.property as t.Expression,\n              )\n            : superProp.node.property,\n          superProp.node.computed,\n        ),\n      ),\n      assignmentExpression(\n        \"=\",\n        memberExpression(\n          superProp.node.object,\n          computedKey ? identifier(computedKey.name) : superProp.node.property,\n          superProp.node.computed,\n        ),\n        binaryExpression(\n          // map `++` to `+`, and `--` to `-`\n          superProp.parentPath.node.operator[0] as \"+\" | \"-\",\n          identifier(tmp.name),\n          numericLiteral(1),\n        ),\n      ),\n    ];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n\n    const left = updateExpr.get(\n      \"expressions.0.right\",\n    ) as NodePath<t.MemberExpression>;\n    const right = updateExpr.get(\n      \"expressions.1.left\",\n    ) as NodePath<t.MemberExpression>;\n    return [left, right];\n  }\n\n  return [superProp];\n\n  function rightExpression(\n    op: BinaryOp | \"=\",\n    left: t.MemberExpression,\n    right: t.Expression,\n  ) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\n\nfunction hasSuperClass(thisEnvFn: NodePath<t.Function>) {\n  return (\n    thisEnvFn.isClassMethod() &&\n    !!(thisEnvFn.parentPath.parentPath.node as t.Class).superClass\n  );\n}\n\nconst assignSuperThisVisitor = mergeVisitors<{\n  supers: WeakSet<t.CallExpression>;\n  thisBinding: string;\n}>([\n  {\n    CallExpression(child, { supers, thisBinding }) {\n      if (!child.get(\"callee\").isSuper()) return;\n      if (supers.has(child.node)) return;\n      supers.add(child.node);\n\n      child.replaceWithMultiple([\n        child.node,\n        assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\")),\n      ]);\n    },\n  },\n  environmentVisitor,\n]);\n\n// Create a binding that evaluates to the \"this\" of the given function.\nfunction getThisBinding(\n  thisEnvFn: NodePath<t.Function>,\n  inConstructor: boolean,\n) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding,\n    });\n  });\n}\n\n// Create a binding for a function that will call \"super()\" with arguments passed through.\nfunction getSuperBinding(thisEnvFn: NodePath<t.Function>) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression(\n      [restElement(argsBinding)],\n      callExpression(_super(), [spreadElement(identifier(argsBinding.name))]),\n    );\n  });\n}\n\n// Create a binding for a function that will call \"super.foo\" or \"super[foo]\".\nfunction getSuperPropBinding(\n  thisEnvFn: NodePath<t.Function>,\n  isAssignment: boolean,\n  propName: string,\n) {\n  const op = isAssignment ? \"set\" : \"get\";\n\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n\n    let fnBody;\n    if (propName) {\n      // () => super.foo\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      // (method) => super[method]\n      argsList.unshift(method);\n      fnBody = memberExpression(\n        _super(),\n        identifier(method.name),\n        true /* computed */,\n      );\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(\n  thisEnvFn: NodePath,\n  key: string,\n  init: (name: string) => t.Expression,\n) {\n  const cacheKey = \"binding:\" + key;\n  let data: string | undefined = thisEnvFn.getData(cacheKey);\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data),\n    });\n  }\n\n  return data;\n}\n\ntype ScopeInfo = {\n  thisPaths: NodePath<t.ThisExpression | t.JSXIdentifier>[];\n  superCalls: NodePath<t.CallExpression>[];\n  superProps: NodePath<t.MemberExpression>[];\n  argumentsPaths: NodePath<t.Identifier | t.JSXIdentifier>[];\n  newTargetPaths: NodePath<t.MetaProperty>[];\n};\n\nconst getScopeInformationVisitor = mergeVisitors<ScopeInfo>([\n  {\n    ThisExpression(child, { thisPaths }) {\n      thisPaths.push(child);\n    },\n    JSXIdentifier(child, { thisPaths }) {\n      if (child.node.name !== \"this\") return;\n      if (\n        !child.parentPath.isJSXMemberExpression({ object: child.node }) &&\n        !child.parentPath.isJSXOpeningElement({ name: child.node })\n      ) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n    CallExpression(child, { superCalls }) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n    MemberExpression(child, { superProps }) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n    Identifier(child, { argumentsPaths }) {\n      if (!child.isReferencedIdentifier({ name: \"arguments\" })) return;\n\n      let curr = child.scope;\n      do {\n        if (curr.hasOwnBinding(\"arguments\")) {\n          curr.rename(\"arguments\");\n          return;\n        }\n        if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while ((curr = curr.parent));\n\n      argumentsPaths.push(child);\n    },\n    MetaProperty(child, { newTargetPaths }) {\n      if (!child.get(\"meta\").isIdentifier({ name: \"new\" })) return;\n      if (!child.get(\"property\").isIdentifier({ name: \"target\" })) return;\n\n      newTargetPaths.push(child);\n    },\n  },\n  environmentVisitor,\n]);\n\nfunction getScopeInformation(fnPath: NodePath) {\n  const thisPaths: ScopeInfo[\"thisPaths\"] = [];\n  const argumentsPaths: ScopeInfo[\"argumentsPaths\"] = [];\n  const newTargetPaths: ScopeInfo[\"newTargetPaths\"] = [];\n  const superProps: ScopeInfo[\"superProps\"] = [];\n  const superCalls: ScopeInfo[\"superCalls\"] = [];\n\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls,\n  });\n\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}