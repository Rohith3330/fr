{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _templateObject = _taggedTemplateLiteral(['', ''], ['', '']);\n\nfunction _taggedTemplateLiteral(strings, raw) {\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * @class TemplateTag\n * @classdesc Consumes a pipeline of composable transformer plugins and produces a template tag.\n */\n\n\nvar TemplateTag = function () {\n  /**\n   * constructs a template tag\n   * @constructs TemplateTag\n   * @param  {...Object} [...transformers] - an array or arguments list of transformers\n   * @return {Function}                    - a template tag\n   */\n  function TemplateTag() {\n    var _this = this;\n\n    for (var _len = arguments.length, transformers = Array(_len), _key = 0; _key < _len; _key++) {\n      transformers[_key] = arguments[_key];\n    }\n\n    _classCallCheck(this, TemplateTag);\n\n    this.tag = function (strings) {\n      for (var _len2 = arguments.length, expressions = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        expressions[_key2 - 1] = arguments[_key2];\n      }\n\n      if (typeof strings === 'function') {\n        // if the first argument passed is a function, assume it is a template tag and return\n        // an intermediary tag that processes the template using the aforementioned tag, passing the\n        // result to our tag\n        return _this.interimTag.bind(_this, strings);\n      }\n\n      if (typeof strings === 'string') {\n        // if the first argument passed is a string, just transform it\n        return _this.transformEndResult(strings);\n      } // else, return a transformed end result of processing the template with our tag\n\n\n      strings = strings.map(_this.transformString.bind(_this));\n      return _this.transformEndResult(strings.reduce(_this.processSubstitutions.bind(_this, expressions)));\n    }; // if first argument is an array, extrude it as a list of transformers\n\n\n    if (transformers.length > 0 && Array.isArray(transformers[0])) {\n      transformers = transformers[0];\n    } // if any transformers are functions, this means they are not initiated - automatically initiate them\n\n\n    this.transformers = transformers.map(function (transformer) {\n      return typeof transformer === 'function' ? transformer() : transformer;\n    }); // return an ES2015 template tag\n\n    return this.tag;\n  }\n  /**\n   * Applies all transformers to a template literal tagged with this method.\n   * If a function is passed as the first argument, assumes the function is a template tag\n   * and applies it to the template, returning a template tag.\n   * @param  {(Function|String|Array<String>)} strings        - Either a template tag or an array containing template strings separated by identifier\n   * @param  {...*}                            ...expressions - Optional list of substitution values.\n   * @return {(String|Function)}                              - Either an intermediary tag function or the results of processing the template.\n   */\n\n\n  _createClass(TemplateTag, [{\n    key: 'interimTag',\n\n    /**\n     * An intermediary template tag that receives a template tag and passes the result of calling the template with the received\n     * template tag to our own template tag.\n     * @param  {Function}        nextTag          - the received template tag\n     * @param  {Array<String>}   template         - the template to process\n     * @param  {...*}            ...substitutions - `substitutions` is an array of all substitutions in the template\n     * @return {*}                                - the final processed value\n     */\n    value: function interimTag(previousTag, template) {\n      for (var _len3 = arguments.length, substitutions = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        substitutions[_key3 - 2] = arguments[_key3];\n      }\n\n      return this.tag(_templateObject, previousTag.apply(undefined, [template].concat(substitutions)));\n    }\n    /**\n     * Performs bulk processing on the tagged template, transforming each substitution and then\n     * concatenating the resulting values into a string.\n     * @param  {Array<*>} substitutions - an array of all remaining substitutions present in this template\n     * @param  {String}   resultSoFar   - this iteration's result string so far\n     * @param  {String}   remainingPart - the template chunk after the current substitution\n     * @return {String}                 - the result of joining this iteration's processed substitution with the result\n     */\n\n  }, {\n    key: 'processSubstitutions',\n    value: function processSubstitutions(substitutions, resultSoFar, remainingPart) {\n      var substitution = this.transformSubstitution(substitutions.shift(), resultSoFar);\n      return ''.concat(resultSoFar, substitution, remainingPart);\n    }\n    /**\n     * Iterate through each transformer, applying the transformer's `onString` method to the template\n     * strings before all substitutions are processed.\n     * @param {String}  str - The input string\n     * @return {String}     - The final results of processing each transformer\n     */\n\n  }, {\n    key: 'transformString',\n    value: function transformString(str) {\n      var cb = function cb(res, transform) {\n        return transform.onString ? transform.onString(res) : res;\n      };\n\n      return this.transformers.reduce(cb, str);\n    }\n    /**\n     * When a substitution is encountered, iterates through each transformer and applies the transformer's\n     * `onSubstitution` method to the substitution.\n     * @param  {*}      substitution - The current substitution\n     * @param  {String} resultSoFar  - The result up to and excluding this substitution.\n     * @return {*}                   - The final result of applying all substitution transformations.\n     */\n\n  }, {\n    key: 'transformSubstitution',\n    value: function transformSubstitution(substitution, resultSoFar) {\n      var cb = function cb(res, transform) {\n        return transform.onSubstitution ? transform.onSubstitution(res, resultSoFar) : res;\n      };\n\n      return this.transformers.reduce(cb, substitution);\n    }\n    /**\n     * Iterates through each transformer, applying the transformer's `onEndResult` method to the\n     * template literal after all substitutions have finished processing.\n     * @param  {String} endResult - The processed template, just before it is returned from the tag\n     * @return {String}           - The final results of processing each transformer\n     */\n\n  }, {\n    key: 'transformEndResult',\n    value: function transformEndResult(endResult) {\n      var cb = function cb(res, transform) {\n        return transform.onEndResult ? transform.onEndResult(res) : res;\n      };\n\n      return this.transformers.reduce(cb, endResult);\n    }\n  }]);\n\n  return TemplateTag;\n}();\n\nexport default TemplateTag;","map":{"version":3,"mappings":"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","names":["TemplateTag","transformers","arguments","_classCallCheck","tag","strings","expressions","_this","interimTag","bind","transformEndResult","map","transformString","reduce","processSubstitutions","length","Array","isArray","transformer","previousTag","template","substitutions","_templateObject","resultSoFar","remainingPart","substitution","transformSubstitution","shift","concat","str","cb","res","transform","onString","onSubstitution","endResult","onEndResult"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\common-tags\\src\\TemplateTag\\TemplateTag.js"],"sourcesContent":["/**\n * @class TemplateTag\n * @classdesc Consumes a pipeline of composable transformer plugins and produces a template tag.\n */\nexport default class TemplateTag {\n  /**\n   * constructs a template tag\n   * @constructs TemplateTag\n   * @param  {...Object} [...transformers] - an array or arguments list of transformers\n   * @return {Function}                    - a template tag\n   */\n  constructor(...transformers) {\n    // if first argument is an array, extrude it as a list of transformers\n    if (transformers.length > 0 && Array.isArray(transformers[0])) {\n      transformers = transformers[0];\n    }\n\n    // if any transformers are functions, this means they are not initiated - automatically initiate them\n    this.transformers = transformers.map(transformer => {\n      return typeof transformer === 'function' ? transformer() : transformer;\n    });\n\n    // return an ES2015 template tag\n    return this.tag;\n  }\n\n  /**\n   * Applies all transformers to a template literal tagged with this method.\n   * If a function is passed as the first argument, assumes the function is a template tag\n   * and applies it to the template, returning a template tag.\n   * @param  {(Function|String|Array<String>)} strings        - Either a template tag or an array containing template strings separated by identifier\n   * @param  {...*}                            ...expressions - Optional list of substitution values.\n   * @return {(String|Function)}                              - Either an intermediary tag function or the results of processing the template.\n   */\n  tag = (strings, ...expressions) => {\n    if (typeof strings === 'function') {\n      // if the first argument passed is a function, assume it is a template tag and return\n      // an intermediary tag that processes the template using the aforementioned tag, passing the\n      // result to our tag\n      return this.interimTag.bind(this, strings);\n    }\n\n    if (typeof strings === 'string') {\n      // if the first argument passed is a string, just transform it\n      return this.transformEndResult(strings);\n    }\n\n    // else, return a transformed end result of processing the template with our tag\n    strings = strings.map(this.transformString.bind(this));\n    return this.transformEndResult(\n      strings.reduce(this.processSubstitutions.bind(this, expressions)),\n    );\n  };\n\n  /**\n   * An intermediary template tag that receives a template tag and passes the result of calling the template with the received\n   * template tag to our own template tag.\n   * @param  {Function}        nextTag          - the received template tag\n   * @param  {Array<String>}   template         - the template to process\n   * @param  {...*}            ...substitutions - `substitutions` is an array of all substitutions in the template\n   * @return {*}                                - the final processed value\n   */\n  interimTag(previousTag, template, ...substitutions) {\n    return this.tag`${previousTag(template, ...substitutions)}`;\n  }\n\n  /**\n   * Performs bulk processing on the tagged template, transforming each substitution and then\n   * concatenating the resulting values into a string.\n   * @param  {Array<*>} substitutions - an array of all remaining substitutions present in this template\n   * @param  {String}   resultSoFar   - this iteration's result string so far\n   * @param  {String}   remainingPart - the template chunk after the current substitution\n   * @return {String}                 - the result of joining this iteration's processed substitution with the result\n   */\n  processSubstitutions(substitutions, resultSoFar, remainingPart) {\n    const substitution = this.transformSubstitution(\n      substitutions.shift(),\n      resultSoFar,\n    );\n    return ''.concat(resultSoFar, substitution, remainingPart);\n  }\n\n  /**\n   * Iterate through each transformer, applying the transformer's `onString` method to the template\n   * strings before all substitutions are processed.\n   * @param {String}  str - The input string\n   * @return {String}     - The final results of processing each transformer\n   */\n  transformString(str) {\n    const cb = (res, transform) =>\n      transform.onString ? transform.onString(res) : res;\n    return this.transformers.reduce(cb, str);\n  }\n\n  /**\n   * When a substitution is encountered, iterates through each transformer and applies the transformer's\n   * `onSubstitution` method to the substitution.\n   * @param  {*}      substitution - The current substitution\n   * @param  {String} resultSoFar  - The result up to and excluding this substitution.\n   * @return {*}                   - The final result of applying all substitution transformations.\n   */\n  transformSubstitution(substitution, resultSoFar) {\n    const cb = (res, transform) =>\n      transform.onSubstitution\n        ? transform.onSubstitution(res, resultSoFar)\n        : res;\n    return this.transformers.reduce(cb, substitution);\n  }\n\n  /**\n   * Iterates through each transformer, applying the transformer's `onEndResult` method to the\n   * template literal after all substitutions have finished processing.\n   * @param  {String} endResult - The processed template, just before it is returned from the tag\n   * @return {String}           - The final results of processing each transformer\n   */\n  transformEndResult(endResult) {\n    const cb = (res, transform) =>\n      transform.onEndResult ? transform.onEndResult(res) : res;\n    return this.transformers.reduce(cb, endResult);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}