{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'no-floating-promises',\n  meta: {\n    docs: {\n      description: 'Require Promise-like statements to be handled appropriately',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    hasSuggestions: true,\n    messages: {\n      floating: 'Promises must be awaited, end with a call to .catch, or end with a call to .then with a rejection handler.',\n      floatingVoid: 'Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler' + ' or be explicitly marked as ignored with the `void` operator.',\n      floatingFixVoid: 'Add void operator to ignore.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreVoid: {\n          description: 'Whether to ignore `void` expressions.',\n          type: 'boolean'\n        },\n        ignoreIIFE: {\n          description: 'Whether to ignore async IIFEs (Immediately Invocated Function Expressions).',\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    type: 'problem'\n  },\n  defaultOptions: [{\n    ignoreVoid: true,\n    ignoreIIFE: false\n  }],\n\n  create(context, _ref) {\n    let [options] = _ref;\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n    return {\n      ExpressionStatement(node) {\n        if (options.ignoreIIFE && isAsyncIife(node)) {\n          return;\n        }\n\n        let expression = node.expression;\n\n        if (expression.type === utils_1.AST_NODE_TYPES.ChainExpression) {\n          expression = expression.expression;\n        }\n\n        if (isUnhandledPromise(checker, expression)) {\n          if (options.ignoreVoid) {\n            context.report({\n              node,\n              messageId: 'floatingVoid',\n              suggest: [{\n                messageId: 'floatingFixVoid',\n\n                fix(fixer) {\n                  let code = sourceCode.getText(node);\n                  code = `void ${code}`;\n                  return fixer.replaceText(node, code);\n                }\n\n              }]\n            });\n          } else {\n            context.report({\n              node,\n              messageId: 'floating'\n            });\n          }\n        }\n      }\n\n    };\n\n    function isAsyncIife(node) {\n      if (node.expression.type !== utils_1.AST_NODE_TYPES.CallExpression) {\n        return false;\n      }\n\n      return node.expression.type === utils_1.AST_NODE_TYPES.CallExpression && (node.expression.callee.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression || node.expression.callee.type === utils_1.AST_NODE_TYPES.FunctionExpression);\n    }\n\n    function isUnhandledPromise(checker, node) {\n      // First, check expressions whose resulting types may not be promise-like\n      if (node.type === utils_1.AST_NODE_TYPES.SequenceExpression) {\n        // Any child in a comma expression could return a potentially unhandled\n        // promise, so we check them all regardless of whether the final returned\n        // value is promise-like.\n        return node.expressions.some(item => isUnhandledPromise(checker, item));\n      }\n\n      if (!options.ignoreVoid && node.type === utils_1.AST_NODE_TYPES.UnaryExpression && node.operator === 'void') {\n        // Similarly, a `void` expression always returns undefined, so we need to\n        // see what's inside it without checking the type of the overall expression.\n        return isUnhandledPromise(checker, node.argument);\n      } // Check the type. At this point it can't be unhandled if it isn't a promise\n\n\n      if (!isPromiseLike(checker, parserServices.esTreeNodeToTSNodeMap.get(node))) {\n        return false;\n      }\n\n      if (node.type === utils_1.AST_NODE_TYPES.CallExpression) {\n        // If the outer expression is a call, it must be either a `.then()` or\n        // `.catch()` that handles the promise.\n        return !isPromiseCatchCallWithHandler(node) && !isPromiseThenCallWithRejectionHandler(node) && !isPromiseFinallyCallWithHandler(node);\n      } else if (node.type === utils_1.AST_NODE_TYPES.ConditionalExpression) {\n        // We must be getting the promise-like value from one of the branches of the\n        // ternary. Check them directly.\n        return isUnhandledPromise(checker, node.alternate) || isUnhandledPromise(checker, node.consequent);\n      } else if (node.type === utils_1.AST_NODE_TYPES.MemberExpression || node.type === utils_1.AST_NODE_TYPES.Identifier || node.type === utils_1.AST_NODE_TYPES.NewExpression) {\n        // If it is just a property access chain or a `new` call (e.g. `foo.bar` or\n        // `new Promise()`), the promise is not handled because it doesn't have the\n        // necessary then/catch call at the end of the chain.\n        return true;\n      } // We conservatively return false for all other types of expressions because\n      // we don't want to accidentally fail if the promise is handled internally but\n      // we just can't tell.\n\n\n      return false;\n    }\n  }\n\n}); // Modified from tsutils.isThenable() to only consider thenables which can be\n// rejected/caught via a second parameter. Original source (MIT licensed):\n//\n//   https://github.com/ajafff/tsutils/blob/49d0d31050b44b81e918eae4fbaf1dfe7b7286af/util/type.ts#L95-L125\n\nfunction isPromiseLike(checker, node) {\n  const type = checker.getTypeAtLocation(node);\n\n  for (const ty of tsutils.unionTypeParts(checker.getApparentType(type))) {\n    const then = ty.getProperty('then');\n\n    if (then === undefined) {\n      continue;\n    }\n\n    const thenType = checker.getTypeOfSymbolAtLocation(then, node);\n\n    if (hasMatchingSignature(thenType, signature => signature.parameters.length >= 2 && isFunctionParam(checker, signature.parameters[0], node) && isFunctionParam(checker, signature.parameters[1], node))) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction hasMatchingSignature(type, matcher) {\n  for (const t of tsutils.unionTypeParts(type)) {\n    if (t.getCallSignatures().some(matcher)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isFunctionParam(checker, param, node) {\n  const type = checker.getApparentType(checker.getTypeOfSymbolAtLocation(param, node));\n\n  for (const t of tsutils.unionTypeParts(type)) {\n    if (t.getCallSignatures().length !== 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isPromiseCatchCallWithHandler(expression) {\n  return expression.callee.type === utils_1.AST_NODE_TYPES.MemberExpression && expression.callee.property.type === utils_1.AST_NODE_TYPES.Identifier && expression.callee.property.name === 'catch' && expression.arguments.length >= 1;\n}\n\nfunction isPromiseThenCallWithRejectionHandler(expression) {\n  return expression.callee.type === utils_1.AST_NODE_TYPES.MemberExpression && expression.callee.property.type === utils_1.AST_NODE_TYPES.Identifier && expression.callee.property.name === 'then' && expression.arguments.length >= 2;\n}\n\nfunction isPromiseFinallyCallWithHandler(expression) {\n  return expression.callee.type === utils_1.AST_NODE_TYPES.MemberExpression && expression.callee.property.type === utils_1.AST_NODE_TYPES.Identifier && expression.callee.property.name === 'finally' && expression.arguments.length >= 1;\n}","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","docs","description","recommended","requiresTypeChecking","hasSuggestions","messages","floating","floatingVoid","floatingFixVoid","schema","type","properties","ignoreVoid","ignoreIIFE","additionalProperties","defaultOptions","create","context","options","parserServices","getParserServices","checker","program","getTypeChecker","sourceCode","getSourceCode","ExpressionStatement","node","isAsyncIife","expression","utils_1","ChainExpression","isUnhandledPromise","report","messageId","suggest","fix","fixer","code","getText","replaceText","CallExpression","callee","ArrowFunctionExpression","FunctionExpression","SequenceExpression","expressions","some","item","UnaryExpression","operator","argument","isPromiseLike","esTreeNodeToTSNodeMap","get","isPromiseCatchCallWithHandler","isPromiseThenCallWithRejectionHandler","isPromiseFinallyCallWithHandler","ConditionalExpression","alternate","consequent","MemberExpression","Identifier","NewExpression","getTypeAtLocation","ty","tsutils","unionTypeParts","getApparentType","then","getProperty","undefined","thenType","getTypeOfSymbolAtLocation","hasMatchingSignature","signature","parameters","length","isFunctionParam","matcher","t","getCallSignatures","param","property","arguments"],"sources":["../../src/rules/no-floating-promises.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}