{"ast":null,"code":"var Marker = require('./marker');\n\nvar Token = require('./token');\n\nvar formatPosition = require('../utils/format-position');\n\nvar Level = {\n  BLOCK: 'block',\n  COMMENT: 'comment',\n  DOUBLE_QUOTE: 'double-quote',\n  RULE: 'rule',\n  SINGLE_QUOTE: 'single-quote'\n};\nvar AT_RULES = ['@charset', '@import'];\nvar BLOCK_RULES = ['@-moz-document', '@document', '@-moz-keyframes', '@-ms-keyframes', '@-o-keyframes', '@-webkit-keyframes', '@keyframes', '@media', '@supports'];\nvar IGNORE_END_COMMENT_PATTERN = /\\/\\* clean-css ignore:end \\*\\/$/;\nvar IGNORE_START_COMMENT_PATTERN = /^\\/\\* clean-css ignore:start \\*\\//;\nvar PAGE_MARGIN_BOXES = ['@bottom-center', '@bottom-left', '@bottom-left-corner', '@bottom-right', '@bottom-right-corner', '@left-bottom', '@left-middle', '@left-top', '@right-bottom', '@right-middle', '@right-top', '@top-center', '@top-left', '@top-left-corner', '@top-right', '@top-right-corner'];\nvar EXTRA_PAGE_BOXES = ['@footnote', '@footnotes', '@left', '@page-float-bottom', '@page-float-top', '@right'];\nvar REPEAT_PATTERN = /^\\[\\s{0,31}\\d+\\s{0,31}\\]$/;\nvar TAIL_BROKEN_VALUE_PATTERN = /([^}])\\}*$/;\nvar RULE_WORD_SEPARATOR_PATTERN = /[\\s(]/;\n\nfunction tokenize(source, externalContext) {\n  var internalContext = {\n    level: Level.BLOCK,\n    position: {\n      source: externalContext.source || undefined,\n      line: 1,\n      column: 0,\n      index: 0\n    }\n  };\n  return intoTokens(source, externalContext, internalContext, false);\n}\n\nfunction intoTokens(source, externalContext, internalContext, isNested) {\n  var allTokens = [];\n  var newTokens = allTokens;\n  var lastToken;\n  var ruleToken;\n  var ruleTokens = [];\n  var propertyToken;\n  var metadata;\n  var metadatas = [];\n  var level = internalContext.level;\n  var levels = [];\n  var buffer = [];\n  var buffers = [];\n  var isBufferEmpty = true;\n  var serializedBuffer;\n  var serializedBufferPart;\n  var roundBracketLevel = 0;\n  var isQuoted;\n  var isSpace;\n  var isNewLineNix;\n  var isNewLineWin;\n  var isCarriageReturn;\n  var isCommentStart;\n  var wasCommentStart = false;\n  var isCommentEnd;\n  var wasCommentEnd = false;\n  var isCommentEndMarker;\n  var isEscaped;\n  var wasEscaped = false;\n  var characterWithNoSpecialMeaning;\n  var isPreviousDash = false;\n  var isVariable = false;\n  var isRaw = false;\n  var seekingValue = false;\n  var seekingPropertyBlockClosing = false;\n  var position = internalContext.position;\n  var lastCommentStartAt;\n\n  for (; position.index < source.length; position.index++) {\n    var character = source[position.index];\n    isQuoted = level == Level.SINGLE_QUOTE || level == Level.DOUBLE_QUOTE;\n    isSpace = character == Marker.SPACE || character == Marker.TAB;\n    isNewLineNix = character == Marker.NEW_LINE_NIX;\n    isNewLineWin = character == Marker.NEW_LINE_NIX && source[position.index - 1] == Marker.CARRIAGE_RETURN;\n    isCarriageReturn = character == Marker.CARRIAGE_RETURN && source[position.index + 1] && source[position.index + 1] != Marker.NEW_LINE_NIX;\n    isCommentStart = !wasCommentEnd && level != Level.COMMENT && !isQuoted && character == Marker.ASTERISK && source[position.index - 1] == Marker.FORWARD_SLASH;\n    isCommentEndMarker = !wasCommentStart && !isQuoted && character == Marker.FORWARD_SLASH && source[position.index - 1] == Marker.ASTERISK;\n    isCommentEnd = level == Level.COMMENT && isCommentEndMarker;\n    characterWithNoSpecialMeaning = !isSpace && !isCarriageReturn && (character >= 'A' && character <= 'Z' || character >= 'a' && character <= 'z' || character >= '0' && character <= '9' || character == '-');\n    isVariable = isVariable || level != Level.COMMENT && !seekingValue && isPreviousDash && character === '-';\n    isPreviousDash = character === '-';\n    roundBracketLevel = Math.max(roundBracketLevel, 0);\n    metadata = isBufferEmpty ? [position.line, position.column, position.source] : metadata;\n\n    if (isEscaped) {\n      // previous character was a backslash\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (characterWithNoSpecialMeaning) {\n      // it's just an alphanumeric character or a hyphen (part of any rule or property name) so let's end it quickly\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if ((isSpace || isNewLineNix && !isNewLineWin) && (isQuoted || level == Level.COMMENT)) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if ((isSpace || isNewLineNix && !isNewLineWin) && isBufferEmpty) {// noop\n    } else if (!isCommentEnd && level == Level.COMMENT) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (!isCommentStart && !isCommentEnd && isRaw) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (isCommentStart && isVariable && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {\n      // comment start within a variable, e.g. var(/*<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      levels.push(level);\n      level = Level.COMMENT;\n    } else if (isCommentStart && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {\n      // comment start within block preceded by some content, e.g. div/*<--\n      metadatas.push(metadata);\n      buffer.push(character);\n      buffers.push(buffer.slice(0, -2));\n      isBufferEmpty = false;\n      buffer = buffer.slice(-2);\n      metadata = [position.line, position.column - 1, position.source];\n      levels.push(level);\n      level = Level.COMMENT;\n    } else if (isCommentStart) {\n      // comment start, e.g. /*<--\n      levels.push(level);\n      level = Level.COMMENT;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (isCommentEnd && isVariable) {\n      // comment end within a variable, e.g. var(/*!*/<--\n      buffer.push(character);\n      level = levels.pop();\n    } else if (isCommentEnd && isIgnoreStartComment(buffer)) {\n      // ignore:start comment end, e.g. /* clean-css ignore:start */<--\n      serializedBuffer = buffer.join('').trim() + character;\n      lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];\n      newTokens.push(lastToken);\n      isRaw = true;\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEnd && isIgnoreEndComment(buffer)) {\n      // ignore:start comment end, e.g. /* clean-css ignore:end */<--\n      serializedBuffer = buffer.join('') + character;\n      lastCommentStartAt = serializedBuffer.lastIndexOf(Marker.FORWARD_SLASH + Marker.ASTERISK);\n      serializedBufferPart = serializedBuffer.substring(0, lastCommentStartAt);\n      lastToken = [Token.RAW, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];\n      newTokens.push(lastToken);\n      serializedBufferPart = serializedBuffer.substring(lastCommentStartAt);\n      metadata = [position.line, position.column - serializedBufferPart.length + 1, position.source];\n      lastToken = [Token.COMMENT, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];\n      newTokens.push(lastToken);\n      isRaw = false;\n      level = levels.pop();\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEnd) {\n      // comment end, e.g. /* comment */<--\n      serializedBuffer = buffer.join('').trim() + character;\n      lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];\n      newTokens.push(lastToken);\n      level = levels.pop();\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEndMarker && source[position.index + 1] != Marker.ASTERISK) {\n      externalContext.warnings.push('Unexpected \\'*/\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {\n      // single quotation start, e.g. a[href^='https<--\n      levels.push(level);\n      level = Level.SINGLE_QUOTE;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {\n      // single quotation end, e.g. a[href^='https'<--\n      level = levels.pop();\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {\n      // double quotation start, e.g. a[href^=\"<--\n      levels.push(level);\n      level = Level.DOUBLE_QUOTE;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {\n      // double quotation end, e.g. a[href^=\"https\"<--\n      level = levels.pop();\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character != Marker.CLOSE_ROUND_BRACKET && character != Marker.OPEN_ROUND_BRACKET && level != Level.COMMENT && !isQuoted && roundBracketLevel > 0) {\n      // character inside any function, e.g. hsla(.<--\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {\n      // round open bracket, e.g. @import url(<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {\n      // round open bracket, e.g. @import url(test.css)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      roundBracketLevel--;\n    } else if (character == Marker.SEMICOLON && level == Level.BLOCK && buffer[0] == Marker.AT) {\n      // semicolon ending rule at block level, e.g. @import '...';<--\n      serializedBuffer = buffer.join('').trim();\n      allTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.BLOCK && ruleToken) {\n      // comma separator at block level, e.g. a,div,<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.AT_RULE) {\n      // comma separator at block level, e.g. @import url(...) screen,<--\n      // keep iterating as end semicolon will create the token\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.COMMA && level == Level.BLOCK) {\n      // comma separator at block level, e.g. a,<--\n      ruleToken = [tokenTypeFrom(buffer), [], []];\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, 0)]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && ruleToken && ruleToken[0] == Token.NESTED_BLOCK) {\n      // open brace opening at-rule at block level, e.g. @media{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      allTokens.push(ruleToken);\n      levels.push(level);\n      position.column++;\n      position.index++;\n      buffer = [];\n      isBufferEmpty = true;\n      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);\n      ruleToken = null;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.NESTED_BLOCK) {\n      // open brace opening at-rule at block level, e.g. @media{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken = ruleToken || [Token.NESTED_BLOCK, [], []];\n      ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      allTokens.push(ruleToken);\n      levels.push(level);\n      position.column++;\n      position.index++;\n      buffer = [];\n      isBufferEmpty = true;\n      isVariable = false;\n      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);\n      ruleToken = null;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK) {\n      // open brace opening rule at block level, e.g. div{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken = ruleToken || [tokenTypeFrom(buffer), [], []];\n      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);\n      newTokens = ruleToken[2];\n      allTokens.push(ruleToken);\n      levels.push(level);\n      level = Level.RULE;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && seekingValue) {\n      // open brace opening rule at rule level, e.g. div{--variable:{<--\n      ruleTokens.push(ruleToken);\n      ruleToken = [Token.PROPERTY_BLOCK, []];\n      propertyToken.push(ruleToken);\n      newTokens = ruleToken[1];\n      levels.push(level);\n      level = Level.RULE;\n      seekingValue = false;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && isPageMarginBox(buffer)) {\n      // open brace opening page-margin box at rule level, e.g. @page{@top-center{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleTokens.push(ruleToken);\n      ruleToken = [Token.AT_RULE_BLOCK, [], []];\n      ruleToken[1].push([Token.AT_RULE_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      newTokens.push(ruleToken);\n      newTokens = ruleToken[2];\n      levels.push(level);\n      level = Level.RULE;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COLON && level == Level.RULE && !seekingValue) {\n      // colon at rule level, e.g. a{color:<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken = [Token.PROPERTY, [Token.PROPERTY_NAME, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]];\n      newTokens.push(propertyToken);\n      seekingValue = true;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && ruleTokens.length > 0 && !isBufferEmpty && buffer[0] == Marker.AT) {\n      // semicolon at rule level for at-rule, e.g. a{--color:{@apply(--other-color);<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && !isBufferEmpty) {\n      // semicolon at rule level, e.g. a{color:red;<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n      isVariable = false;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && isBufferEmpty && isVariable && !propertyToken[2]) {\n      // semicolon after empty variable value at rule level, e.g. a{--color: ;<--\n      propertyToken.push([Token.PROPERTY_VALUE, ' ', [originalMetadata(metadata, ' ', externalContext)]]);\n      isVariable = false;\n      propertyToken = null;\n      seekingValue = false;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && isBufferEmpty) {\n      // semicolon after bracketed value at rule level, e.g. a{color:rgb(...);<--\n      propertyToken = null;\n      seekingValue = false;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && !isBufferEmpty && buffer[0] == Marker.AT) {\n      // semicolon for at-rule at rule level, e.g. a{@apply(--variable);<--\n      serializedBuffer = buffer.join('');\n      newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && seekingPropertyBlockClosing) {\n      // close brace after a property block at rule level, e.g. a{--custom:{color:red;};<--\n      seekingPropertyBlockClosing = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && isBufferEmpty) {// stray semicolon at rule level, e.g. a{;<--\n      // noop\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && seekingValue && !isBufferEmpty && ruleTokens.length > 0) {\n      // close brace at rule level, e.g. a{--color:{color:red}<--\n      serializedBuffer = buffer.join('');\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && !isBufferEmpty && buffer[0] == Marker.AT && ruleTokens.length > 0) {\n      // close brace at rule level for at-rule, e.g. a{--color:{@apply(--other-color)}<--\n      serializedBuffer = buffer.join('');\n      ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && ruleTokens.length > 0) {\n      // close brace at rule level after space, e.g. a{--color:{color:red }<--\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n      level = levels.pop();\n      seekingValue = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && !isBufferEmpty) {\n      // close brace at rule level, e.g. a{color:red}<--\n      serializedBuffer = buffer.join('');\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = allTokens;\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && !isBufferEmpty && buffer[0] == Marker.AT) {\n      // close brace after at-rule at rule level, e.g. a{@apply(--variable)}<--\n      propertyToken = null;\n      ruleToken = null;\n      serializedBuffer = buffer.join('').trim();\n      newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      newTokens = allTokens;\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && levels[levels.length - 1] == Level.RULE) {\n      // close brace after a property block at rule level, e.g. a{--custom:{color:red;}<--\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n      level = levels.pop();\n      seekingValue = false;\n      seekingPropertyBlockClosing = true;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && isVariable && propertyToken && !propertyToken[2]) {\n      // close brace after an empty variable declaration inside a rule, e.g. a{--color: }<--\n      propertyToken.push([Token.PROPERTY_VALUE, ' ', [originalMetadata(metadata, ' ', externalContext)]]);\n      isVariable = false;\n      propertyToken = null;\n      ruleToken = null;\n      newTokens = allTokens;\n      level = levels.pop();\n      seekingValue = false;\n      isVariable = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE) {\n      // close brace after a rule, e.g. a{color:red;}<--\n      propertyToken = null;\n      ruleToken = null;\n      newTokens = allTokens;\n      level = levels.pop();\n      seekingValue = false;\n      isVariable = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK && !isNested && position.index <= source.length - 1) {\n      // stray close brace at block level, e.g. a{color:red}color:blue}<--\n      externalContext.warnings.push('Unexpected \\'}\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK) {\n      // close brace at block level, e.g. @media screen {...}<--\n      break;\n    } else if (character == Marker.OPEN_ROUND_BRACKET && level == Level.RULE && seekingValue) {\n      // round open bracket, e.g. a{color:hsla(<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue && roundBracketLevel == 1) {\n      // round close bracket, e.g. a{color:hsla(0,0%,0%)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      roundBracketLevel--;\n      buffer = [];\n      isBufferEmpty = true;\n      isVariable = false;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue) {\n      // round close bracket within other brackets, e.g. a{width:calc((10rem / 2)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      isVariable = false;\n      roundBracketLevel--;\n    } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue && !isBufferEmpty) {\n      // forward slash within a property, e.g. a{background:url(image.png) 0 0/<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue) {\n      // forward slash within a property after space, e.g. a{background:url(image.png) 0 0 /<--\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue && !isBufferEmpty) {\n      // comma within a property, e.g. a{background:url(image.png),<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue) {\n      // comma within a property after space, e.g. a{background:url(image.png) ,<--\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_SQUARE_BRACKET && propertyToken && propertyToken.length > 1 && !isBufferEmpty && isRepeatToken(buffer)) {\n      buffer.push(character);\n      serializedBuffer = buffer.join('').trim();\n      propertyToken[propertyToken.length - 1][1] += serializedBuffer;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if ((isSpace || isNewLineNix && !isNewLineWin) && level == Level.RULE && seekingValue && propertyToken && !isBufferEmpty) {\n      // space or *nix newline within property, e.g. a{margin:0 <--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && level == Level.RULE && seekingValue && propertyToken && buffer.length > 1) {\n      // win newline within property, e.g. a{margin:0\\r\\n<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && level == Level.RULE && seekingValue) {\n      // win newline\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && buffer.length == 1) {\n      // ignore windows newline which is composed of two characters\n      buffer.pop();\n      isBufferEmpty = buffer.length === 0;\n    } else if (!isBufferEmpty || !isSpace && !isNewLineNix && !isNewLineWin && !isCarriageReturn) {\n      // any character\n      buffer.push(character);\n      isBufferEmpty = false;\n    }\n\n    wasEscaped = isEscaped;\n    isEscaped = !wasEscaped && character == Marker.BACK_SLASH;\n    wasCommentStart = isCommentStart;\n    wasCommentEnd = isCommentEnd;\n    position.line = isNewLineWin || isNewLineNix || isCarriageReturn ? position.line + 1 : position.line;\n    position.column = isNewLineWin || isNewLineNix || isCarriageReturn ? 0 : position.column + 1;\n  }\n\n  if (seekingValue) {\n    externalContext.warnings.push('Missing \\'}\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n  }\n\n  if (seekingValue && buffer.length > 0) {\n    serializedBuffer = buffer.join('').trimRight().replace(TAIL_BROKEN_VALUE_PATTERN, '$1').trimRight();\n    propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n    buffer = [];\n  }\n\n  if (buffer.length > 0) {\n    externalContext.warnings.push('Invalid character(s) \\'' + buffer.join('') + '\\' at ' + formatPosition(metadata) + '. Ignoring.');\n  }\n\n  return allTokens;\n}\n\nfunction isIgnoreStartComment(buffer) {\n  return IGNORE_START_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);\n}\n\nfunction isIgnoreEndComment(buffer) {\n  return IGNORE_END_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);\n}\n\nfunction originalMetadata(metadata, value, externalContext, selectorFallbacks) {\n  var source = metadata[2];\n  return externalContext.inputSourceMapTracker.isTracking(source) ? externalContext.inputSourceMapTracker.originalPositionFor(metadata, value.length, selectorFallbacks) : metadata;\n}\n\nfunction tokenTypeFrom(buffer) {\n  var isAtRule = buffer[0] == Marker.AT || buffer[0] == Marker.UNDERSCORE;\n  var ruleWord = buffer.join('').split(RULE_WORD_SEPARATOR_PATTERN)[0];\n\n  if (isAtRule && BLOCK_RULES.indexOf(ruleWord) > -1) {\n    return Token.NESTED_BLOCK;\n  }\n\n  if (isAtRule && AT_RULES.indexOf(ruleWord) > -1) {\n    return Token.AT_RULE;\n  }\n\n  if (isAtRule) {\n    return Token.AT_RULE_BLOCK;\n  }\n\n  return Token.RULE;\n}\n\nfunction tokenScopeFrom(tokenType) {\n  if (tokenType == Token.RULE) {\n    return Token.RULE_SCOPE;\n  }\n\n  if (tokenType == Token.NESTED_BLOCK) {\n    return Token.NESTED_BLOCK_SCOPE;\n  }\n\n  if (tokenType == Token.AT_RULE_BLOCK) {\n    return Token.AT_RULE_BLOCK_SCOPE;\n  }\n}\n\nfunction isPageMarginBox(buffer) {\n  var serializedBuffer = buffer.join('').trim();\n  return PAGE_MARGIN_BOXES.indexOf(serializedBuffer) > -1 || EXTRA_PAGE_BOXES.indexOf(serializedBuffer) > -1;\n}\n\nfunction isRepeatToken(buffer) {\n  return REPEAT_PATTERN.test(buffer.join('') + Marker.CLOSE_SQUARE_BRACKET);\n}\n\nmodule.exports = tokenize;","map":{"version":3,"names":["Marker","require","Token","formatPosition","Level","BLOCK","COMMENT","DOUBLE_QUOTE","RULE","SINGLE_QUOTE","AT_RULES","BLOCK_RULES","IGNORE_END_COMMENT_PATTERN","IGNORE_START_COMMENT_PATTERN","PAGE_MARGIN_BOXES","EXTRA_PAGE_BOXES","REPEAT_PATTERN","TAIL_BROKEN_VALUE_PATTERN","RULE_WORD_SEPARATOR_PATTERN","tokenize","source","externalContext","internalContext","level","position","undefined","line","column","index","intoTokens","isNested","allTokens","newTokens","lastToken","ruleToken","ruleTokens","propertyToken","metadata","metadatas","levels","buffer","buffers","isBufferEmpty","serializedBuffer","serializedBufferPart","roundBracketLevel","isQuoted","isSpace","isNewLineNix","isNewLineWin","isCarriageReturn","isCommentStart","wasCommentStart","isCommentEnd","wasCommentEnd","isCommentEndMarker","isEscaped","wasEscaped","characterWithNoSpecialMeaning","isPreviousDash","isVariable","isRaw","seekingValue","seekingPropertyBlockClosing","lastCommentStartAt","length","character","SPACE","TAB","NEW_LINE_NIX","CARRIAGE_RETURN","ASTERISK","FORWARD_SLASH","Math","max","push","slice","pop","isIgnoreStartComment","join","trim","originalMetadata","isIgnoreEndComment","lastIndexOf","substring","RAW","warnings","CLOSE_ROUND_BRACKET","OPEN_ROUND_BRACKET","SEMICOLON","AT","AT_RULE","COMMA","tokenScopeFrom","tokenTypeFrom","OPEN_CURLY_BRACKET","NESTED_BLOCK","NESTED_BLOCK_SCOPE","PROPERTY_BLOCK","isPageMarginBox","AT_RULE_BLOCK","AT_RULE_BLOCK_SCOPE","COLON","PROPERTY","PROPERTY_NAME","PROPERTY_VALUE","CLOSE_CURLY_BRACKET","CLOSE_SQUARE_BRACKET","isRepeatToken","BACK_SLASH","trimRight","replace","test","value","selectorFallbacks","inputSourceMapTracker","isTracking","originalPositionFor","isAtRule","UNDERSCORE","ruleWord","split","indexOf","tokenType","RULE_SCOPE","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/clean-css/lib/tokenizer/tokenize.js"],"sourcesContent":["var Marker = require('./marker');\nvar Token = require('./token');\n\nvar formatPosition = require('../utils/format-position');\n\nvar Level = {\n  BLOCK: 'block',\n  COMMENT: 'comment',\n  DOUBLE_QUOTE: 'double-quote',\n  RULE: 'rule',\n  SINGLE_QUOTE: 'single-quote'\n};\n\nvar AT_RULES = [\n  '@charset',\n  '@import'\n];\n\nvar BLOCK_RULES = [\n  '@-moz-document',\n  '@document',\n  '@-moz-keyframes',\n  '@-ms-keyframes',\n  '@-o-keyframes',\n  '@-webkit-keyframes',\n  '@keyframes',\n  '@media',\n  '@supports'\n];\n\nvar IGNORE_END_COMMENT_PATTERN = /\\/\\* clean-css ignore:end \\*\\/$/;\nvar IGNORE_START_COMMENT_PATTERN = /^\\/\\* clean-css ignore:start \\*\\//;\n\nvar PAGE_MARGIN_BOXES = [\n  '@bottom-center',\n  '@bottom-left',\n  '@bottom-left-corner',\n  '@bottom-right',\n  '@bottom-right-corner',\n  '@left-bottom',\n  '@left-middle',\n  '@left-top',\n  '@right-bottom',\n  '@right-middle',\n  '@right-top',\n  '@top-center',\n  '@top-left',\n  '@top-left-corner',\n  '@top-right',\n  '@top-right-corner'\n];\n\nvar EXTRA_PAGE_BOXES = [\n  '@footnote',\n  '@footnotes',\n  '@left',\n  '@page-float-bottom',\n  '@page-float-top',\n  '@right'\n];\n\nvar REPEAT_PATTERN = /^\\[\\s{0,31}\\d+\\s{0,31}\\]$/;\nvar TAIL_BROKEN_VALUE_PATTERN = /([^}])\\}*$/;\nvar RULE_WORD_SEPARATOR_PATTERN = /[\\s(]/;\n\nfunction tokenize(source, externalContext) {\n  var internalContext = {\n    level: Level.BLOCK,\n    position: {\n      source: externalContext.source || undefined,\n      line: 1,\n      column: 0,\n      index: 0\n    }\n  };\n\n  return intoTokens(source, externalContext, internalContext, false);\n}\n\nfunction intoTokens(source, externalContext, internalContext, isNested) {\n  var allTokens = [];\n  var newTokens = allTokens;\n  var lastToken;\n  var ruleToken;\n  var ruleTokens = [];\n  var propertyToken;\n  var metadata;\n  var metadatas = [];\n  var level = internalContext.level;\n  var levels = [];\n  var buffer = [];\n  var buffers = [];\n  var isBufferEmpty = true;\n  var serializedBuffer;\n  var serializedBufferPart;\n  var roundBracketLevel = 0;\n  var isQuoted;\n  var isSpace;\n  var isNewLineNix;\n  var isNewLineWin;\n  var isCarriageReturn;\n  var isCommentStart;\n  var wasCommentStart = false;\n  var isCommentEnd;\n  var wasCommentEnd = false;\n  var isCommentEndMarker;\n  var isEscaped;\n  var wasEscaped = false;\n  var characterWithNoSpecialMeaning;\n  var isPreviousDash = false;\n  var isVariable = false;\n  var isRaw = false;\n  var seekingValue = false;\n  var seekingPropertyBlockClosing = false;\n  var position = internalContext.position;\n  var lastCommentStartAt;\n\n  for (; position.index < source.length; position.index++) {\n    var character = source[position.index];\n\n    isQuoted = level == Level.SINGLE_QUOTE || level == Level.DOUBLE_QUOTE;\n    isSpace = character == Marker.SPACE || character == Marker.TAB;\n    isNewLineNix = character == Marker.NEW_LINE_NIX;\n    isNewLineWin = character == Marker.NEW_LINE_NIX\n      && source[position.index - 1] == Marker.CARRIAGE_RETURN;\n    isCarriageReturn = character == Marker.CARRIAGE_RETURN\n      && source[position.index + 1] && source[position.index + 1] != Marker.NEW_LINE_NIX;\n    isCommentStart = !wasCommentEnd\n      && level != Level.COMMENT && !isQuoted\n      && character == Marker.ASTERISK && source[position.index - 1] == Marker.FORWARD_SLASH;\n    isCommentEndMarker = !wasCommentStart\n      && !isQuoted && character == Marker.FORWARD_SLASH\n      && source[position.index - 1] == Marker.ASTERISK;\n    isCommentEnd = level == Level.COMMENT && isCommentEndMarker;\n    characterWithNoSpecialMeaning = !isSpace && !isCarriageReturn && (character >= 'A' && character <= 'Z' || character >= 'a' && character <= 'z' || character >= '0' && character <= '9' || character == '-');\n    isVariable = isVariable || (level != Level.COMMENT && !seekingValue && isPreviousDash && character === '-');\n    isPreviousDash = character === '-';\n    roundBracketLevel = Math.max(roundBracketLevel, 0);\n\n    metadata = isBufferEmpty\n      ? [position.line, position.column, position.source]\n      : metadata;\n\n    if (isEscaped) {\n      // previous character was a backslash\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (characterWithNoSpecialMeaning) {\n      // it's just an alphanumeric character or a hyphen (part of any rule or property name) so let's end it quickly\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if ((isSpace || isNewLineNix && !isNewLineWin) && (isQuoted || level == Level.COMMENT)) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if ((isSpace || isNewLineNix && !isNewLineWin) && isBufferEmpty) {\n      // noop\n    } else if (!isCommentEnd && level == Level.COMMENT) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (!isCommentStart && !isCommentEnd && isRaw) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (isCommentStart\n        && isVariable\n        && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {\n      // comment start within a variable, e.g. var(/*<--\n      buffer.push(character);\n      isBufferEmpty = false;\n\n      levels.push(level);\n      level = Level.COMMENT;\n    } else if (isCommentStart && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {\n      // comment start within block preceded by some content, e.g. div/*<--\n      metadatas.push(metadata);\n      buffer.push(character);\n      buffers.push(buffer.slice(0, -2));\n      isBufferEmpty = false;\n\n      buffer = buffer.slice(-2);\n      metadata = [position.line, position.column - 1, position.source];\n\n      levels.push(level);\n      level = Level.COMMENT;\n    } else if (isCommentStart) {\n      // comment start, e.g. /*<--\n      levels.push(level);\n      level = Level.COMMENT;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (isCommentEnd && isVariable) {\n      // comment end within a variable, e.g. var(/*!*/<--\n      buffer.push(character);\n      level = levels.pop();\n    } else if (isCommentEnd && isIgnoreStartComment(buffer)) {\n      // ignore:start comment end, e.g. /* clean-css ignore:start */<--\n      serializedBuffer = buffer.join('').trim() + character;\n      lastToken = [\n        Token.COMMENT,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ];\n      newTokens.push(lastToken);\n\n      isRaw = true;\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEnd && isIgnoreEndComment(buffer)) {\n      // ignore:start comment end, e.g. /* clean-css ignore:end */<--\n      serializedBuffer = buffer.join('') + character;\n      lastCommentStartAt = serializedBuffer.lastIndexOf(Marker.FORWARD_SLASH + Marker.ASTERISK);\n\n      serializedBufferPart = serializedBuffer.substring(0, lastCommentStartAt);\n      lastToken = [\n        Token.RAW,\n        serializedBufferPart,\n        [originalMetadata(metadata, serializedBufferPart, externalContext)]\n      ];\n      newTokens.push(lastToken);\n\n      serializedBufferPart = serializedBuffer.substring(lastCommentStartAt);\n      metadata = [position.line, position.column - serializedBufferPart.length + 1, position.source];\n      lastToken = [\n        Token.COMMENT,\n        serializedBufferPart,\n        [originalMetadata(metadata, serializedBufferPart, externalContext)]\n      ];\n      newTokens.push(lastToken);\n\n      isRaw = false;\n      level = levels.pop();\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEnd) {\n      // comment end, e.g. /* comment */<--\n      serializedBuffer = buffer.join('').trim() + character;\n      lastToken = [\n        Token.COMMENT,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ];\n      newTokens.push(lastToken);\n\n      level = levels.pop();\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEndMarker && source[position.index + 1] != Marker.ASTERISK) {\n      externalContext.warnings.push('Unexpected \\'*/\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {\n      // single quotation start, e.g. a[href^='https<--\n      levels.push(level);\n      level = Level.SINGLE_QUOTE;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {\n      // single quotation end, e.g. a[href^='https'<--\n      level = levels.pop();\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {\n      // double quotation start, e.g. a[href^=\"<--\n      levels.push(level);\n      level = Level.DOUBLE_QUOTE;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {\n      // double quotation end, e.g. a[href^=\"https\"<--\n      level = levels.pop();\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character != Marker.CLOSE_ROUND_BRACKET\n      && character != Marker.OPEN_ROUND_BRACKET\n      && level != Level.COMMENT && !isQuoted && roundBracketLevel > 0) {\n      // character inside any function, e.g. hsla(.<--\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.OPEN_ROUND_BRACKET\n      && !isQuoted && level != Level.COMMENT\n      && !seekingValue) {\n      // round open bracket, e.g. @import url(<--\n      buffer.push(character);\n      isBufferEmpty = false;\n\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET\n      && !isQuoted\n      && level != Level.COMMENT\n      && !seekingValue) {\n      // round open bracket, e.g. @import url(test.css)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n\n      roundBracketLevel--;\n    } else if (character == Marker.SEMICOLON && level == Level.BLOCK && buffer[0] == Marker.AT) {\n      // semicolon ending rule at block level, e.g. @import '...';<--\n      serializedBuffer = buffer.join('').trim();\n      allTokens.push([\n        Token.AT_RULE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.BLOCK && ruleToken) {\n      // comma separator at block level, e.g. a,div,<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([\n        tokenScopeFrom(ruleToken[0]),\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.AT_RULE) {\n      // comma separator at block level, e.g. @import url(...) screen,<--\n      // keep iterating as end semicolon will create the token\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.COMMA && level == Level.BLOCK) {\n      // comma separator at block level, e.g. a,<--\n      ruleToken = [tokenTypeFrom(buffer), [], []];\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([\n        tokenScopeFrom(ruleToken[0]),\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext, 0)]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.OPEN_CURLY_BRACKET\n      && level == Level.BLOCK\n      && ruleToken\n      && ruleToken[0] == Token.NESTED_BLOCK) {\n      // open brace opening at-rule at block level, e.g. @media{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([\n        Token.NESTED_BLOCK_SCOPE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      allTokens.push(ruleToken);\n\n      levels.push(level);\n      position.column++;\n      position.index++;\n      buffer = [];\n      isBufferEmpty = true;\n\n      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);\n      ruleToken = null;\n    } else if (character == Marker.OPEN_CURLY_BRACKET\n      && level == Level.BLOCK\n      && tokenTypeFrom(buffer) == Token.NESTED_BLOCK) {\n      // open brace opening at-rule at block level, e.g. @media{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken = ruleToken || [Token.NESTED_BLOCK, [], []];\n      ruleToken[1].push([\n        Token.NESTED_BLOCK_SCOPE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      allTokens.push(ruleToken);\n\n      levels.push(level);\n      position.column++;\n      position.index++;\n      buffer = [];\n      isBufferEmpty = true;\n      isVariable = false;\n\n      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);\n      ruleToken = null;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK) {\n      // open brace opening rule at block level, e.g. div{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken = ruleToken || [tokenTypeFrom(buffer), [], []];\n      ruleToken[1].push([\n        tokenScopeFrom(ruleToken[0]),\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]\n      ]);\n      newTokens = ruleToken[2];\n      allTokens.push(ruleToken);\n\n      levels.push(level);\n      level = Level.RULE;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && seekingValue) {\n      // open brace opening rule at rule level, e.g. div{--variable:{<--\n      ruleTokens.push(ruleToken);\n      ruleToken = [Token.PROPERTY_BLOCK, []];\n      propertyToken.push(ruleToken);\n      newTokens = ruleToken[1];\n\n      levels.push(level);\n      level = Level.RULE;\n      seekingValue = false;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && isPageMarginBox(buffer)) {\n      // open brace opening page-margin box at rule level, e.g. @page{@top-center{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleTokens.push(ruleToken);\n      ruleToken = [Token.AT_RULE_BLOCK, [], []];\n      ruleToken[1].push([\n        Token.AT_RULE_BLOCK_SCOPE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      newTokens.push(ruleToken);\n      newTokens = ruleToken[2];\n\n      levels.push(level);\n      level = Level.RULE;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COLON && level == Level.RULE && !seekingValue) {\n      // colon at rule level, e.g. a{color:<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken = [\n        Token.PROPERTY,\n        [\n          Token.PROPERTY_NAME,\n          serializedBuffer,\n          [originalMetadata(metadata, serializedBuffer, externalContext)]\n        ]\n      ];\n      newTokens.push(propertyToken);\n\n      seekingValue = true;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON\n      && level == Level.RULE\n      && propertyToken\n      && ruleTokens.length > 0\n      && !isBufferEmpty\n      && buffer[0] == Marker.AT) {\n      // semicolon at rule level for at-rule, e.g. a{--color:{@apply(--other-color);<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([\n        Token.AT_RULE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && !isBufferEmpty) {\n      // semicolon at rule level, e.g. a{color:red;<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      propertyToken = null;\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n      isVariable = false;\n    } else if (character == Marker.SEMICOLON\n      && level == Level.RULE\n      && propertyToken\n      && isBufferEmpty\n      && isVariable\n      && !propertyToken[2]) {\n      // semicolon after empty variable value at rule level, e.g. a{--color: ;<--\n      propertyToken.push([Token.PROPERTY_VALUE, ' ', [originalMetadata(metadata, ' ', externalContext)]]);\n      isVariable = false;\n      propertyToken = null;\n      seekingValue = false;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && isBufferEmpty) {\n      // semicolon after bracketed value at rule level, e.g. a{color:rgb(...);<--\n      propertyToken = null;\n      seekingValue = false;\n    } else if (character == Marker.SEMICOLON\n      && level == Level.RULE\n      && !isBufferEmpty\n      && buffer[0] == Marker.AT) {\n      // semicolon for at-rule at rule level, e.g. a{@apply(--variable);<--\n      serializedBuffer = buffer.join('');\n      newTokens.push([\n        Token.AT_RULE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && seekingPropertyBlockClosing) {\n      // close brace after a property block at rule level, e.g. a{--custom:{color:red;};<--\n      seekingPropertyBlockClosing = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && isBufferEmpty) {\n      // stray semicolon at rule level, e.g. a{;<--\n      // noop\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && propertyToken\n      && seekingValue\n      && !isBufferEmpty && ruleTokens.length > 0) {\n      // close brace at rule level, e.g. a{--color:{color:red}<--\n      serializedBuffer = buffer.join('');\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && propertyToken\n      && !isBufferEmpty\n      && buffer[0] == Marker.AT\n      && ruleTokens.length > 0) {\n      // close brace at rule level for at-rule, e.g. a{--color:{@apply(--other-color)}<--\n      serializedBuffer = buffer.join('');\n      ruleToken[1].push([\n        Token.AT_RULE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && propertyToken\n      && ruleTokens.length > 0) {\n      // close brace at rule level after space, e.g. a{--color:{color:red }<--\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && propertyToken\n      && !isBufferEmpty) {\n      // close brace at rule level, e.g. a{color:red}<--\n      serializedBuffer = buffer.join('');\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && !isBufferEmpty\n      && buffer[0] == Marker.AT) {\n      // close brace after at-rule at rule level, e.g. a{@apply(--variable)}<--\n      propertyToken = null;\n      ruleToken = null;\n      serializedBuffer = buffer.join('').trim();\n      newTokens.push([\n        Token.AT_RULE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && levels[levels.length - 1] == Level.RULE) {\n      // close brace after a property block at rule level, e.g. a{--custom:{color:red;}<--\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n      seekingPropertyBlockClosing = true;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.RULE\n      && isVariable\n      && propertyToken\n      && !propertyToken[2]) {\n      // close brace after an empty variable declaration inside a rule, e.g. a{--color: }<--\n      propertyToken.push([Token.PROPERTY_VALUE, ' ', [originalMetadata(metadata, ' ', externalContext)]]);\n      isVariable = false;\n      propertyToken = null;\n      ruleToken = null;\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n      isVariable = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE) {\n      // close brace after a rule, e.g. a{color:red;}<--\n      propertyToken = null;\n      ruleToken = null;\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n      isVariable = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET\n      && level == Level.BLOCK\n      && !isNested\n      && position.index <= source.length - 1) {\n      // stray close brace at block level, e.g. a{color:red}color:blue}<--\n      externalContext.warnings.push('Unexpected \\'}\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK) {\n      // close brace at block level, e.g. @media screen {...}<--\n      break;\n    } else if (character == Marker.OPEN_ROUND_BRACKET && level == Level.RULE && seekingValue) {\n      // round open bracket, e.g. a{color:hsla(<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET\n      && level == Level.RULE\n      && seekingValue\n      && roundBracketLevel == 1) {\n      // round close bracket, e.g. a{color:hsla(0,0%,0%)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      roundBracketLevel--;\n      buffer = [];\n      isBufferEmpty = true;\n      isVariable = false;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue) {\n      // round close bracket within other brackets, e.g. a{width:calc((10rem / 2)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      isVariable = false;\n      roundBracketLevel--;\n    } else if (character == Marker.FORWARD_SLASH\n      && source[position.index + 1] != Marker.ASTERISK\n      && level == Level.RULE\n      && seekingValue\n      && !isBufferEmpty) {\n      // forward slash within a property, e.g. a{background:url(image.png) 0 0/<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        character,\n        [[position.line, position.column, position.source]]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.FORWARD_SLASH\n      && source[position.index + 1] != Marker.ASTERISK\n      && level == Level.RULE\n      && seekingValue) {\n      // forward slash within a property after space, e.g. a{background:url(image.png) 0 0 /<--\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        character,\n        [[position.line, position.column, position.source]]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue && !isBufferEmpty) {\n      // comma within a property, e.g. a{background:url(image.png),<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        character,\n        [[position.line, position.column, position.source]]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue) {\n      // comma within a property after space, e.g. a{background:url(image.png) ,<--\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        character,\n        [[position.line, position.column, position.source]]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_SQUARE_BRACKET\n      && propertyToken\n      && propertyToken.length > 1\n      && !isBufferEmpty\n      && isRepeatToken(buffer)) {\n      buffer.push(character);\n      serializedBuffer = buffer.join('').trim();\n      propertyToken[propertyToken.length - 1][1] += serializedBuffer;\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if ((isSpace || (isNewLineNix && !isNewLineWin))\n      && level == Level.RULE\n      && seekingValue\n      && propertyToken\n      && !isBufferEmpty) {\n      // space or *nix newline within property, e.g. a{margin:0 <--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && level == Level.RULE && seekingValue && propertyToken && buffer.length > 1) {\n      // win newline within property, e.g. a{margin:0\\r\\n<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([\n        Token.PROPERTY_VALUE,\n        serializedBuffer,\n        [originalMetadata(metadata, serializedBuffer, externalContext)]\n      ]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && level == Level.RULE && seekingValue) {\n      // win newline\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && buffer.length == 1) {\n      // ignore windows newline which is composed of two characters\n      buffer.pop();\n      isBufferEmpty = buffer.length === 0;\n    } else if (!isBufferEmpty || !isSpace && !isNewLineNix && !isNewLineWin && !isCarriageReturn) {\n      // any character\n      buffer.push(character);\n      isBufferEmpty = false;\n    }\n\n    wasEscaped = isEscaped;\n    isEscaped = !wasEscaped && character == Marker.BACK_SLASH;\n    wasCommentStart = isCommentStart;\n    wasCommentEnd = isCommentEnd;\n\n    position.line = (isNewLineWin || isNewLineNix || isCarriageReturn) ? position.line + 1 : position.line;\n    position.column = (isNewLineWin || isNewLineNix || isCarriageReturn) ? 0 : position.column + 1;\n  }\n\n  if (seekingValue) {\n    externalContext.warnings.push('Missing \\'}\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n  }\n\n  if (seekingValue && buffer.length > 0) {\n    serializedBuffer = buffer.join('').trimRight().replace(TAIL_BROKEN_VALUE_PATTERN, '$1').trimRight();\n    propertyToken.push([\n      Token.PROPERTY_VALUE,\n      serializedBuffer,\n      [originalMetadata(metadata, serializedBuffer, externalContext)]\n    ]);\n\n    buffer = [];\n  }\n\n  if (buffer.length > 0) {\n    externalContext.warnings.push('Invalid character(s) \\'' + buffer.join('') + '\\' at ' + formatPosition(metadata) + '. Ignoring.');\n  }\n\n  return allTokens;\n}\n\nfunction isIgnoreStartComment(buffer) {\n  return IGNORE_START_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);\n}\n\nfunction isIgnoreEndComment(buffer) {\n  return IGNORE_END_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);\n}\n\nfunction originalMetadata(metadata, value, externalContext, selectorFallbacks) {\n  var source = metadata[2];\n\n  return externalContext.inputSourceMapTracker.isTracking(source)\n    ? externalContext.inputSourceMapTracker.originalPositionFor(metadata, value.length, selectorFallbacks)\n    : metadata;\n}\n\nfunction tokenTypeFrom(buffer) {\n  var isAtRule = buffer[0] == Marker.AT || buffer[0] == Marker.UNDERSCORE;\n  var ruleWord = buffer.join('').split(RULE_WORD_SEPARATOR_PATTERN)[0];\n\n  if (isAtRule && BLOCK_RULES.indexOf(ruleWord) > -1) {\n    return Token.NESTED_BLOCK;\n  } if (isAtRule && AT_RULES.indexOf(ruleWord) > -1) {\n    return Token.AT_RULE;\n  } if (isAtRule) {\n    return Token.AT_RULE_BLOCK;\n  }\n  return Token.RULE;\n}\n\nfunction tokenScopeFrom(tokenType) {\n  if (tokenType == Token.RULE) {\n    return Token.RULE_SCOPE;\n  } if (tokenType == Token.NESTED_BLOCK) {\n    return Token.NESTED_BLOCK_SCOPE;\n  } if (tokenType == Token.AT_RULE_BLOCK) {\n    return Token.AT_RULE_BLOCK_SCOPE;\n  }\n}\n\nfunction isPageMarginBox(buffer) {\n  var serializedBuffer = buffer.join('').trim();\n\n  return PAGE_MARGIN_BOXES.indexOf(serializedBuffer) > -1 || EXTRA_PAGE_BOXES.indexOf(serializedBuffer) > -1;\n}\n\nfunction isRepeatToken(buffer) {\n  return REPEAT_PATTERN.test(buffer.join('') + Marker.CLOSE_SQUARE_BRACKET);\n}\n\nmodule.exports = tokenize;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}