{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\nexports.replaceWith = replaceWith;\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar _t = require(\"@babel/types\");\n\nvar _helperHoistVariables = require(\"@babel/helper-hoist-variables\");\n\nconst {\n  FUNCTION_TYPES,\n  arrowFunctionExpression,\n  assignmentExpression,\n  awaitExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  inheritLeadingComments,\n  inheritTrailingComments,\n  inheritsComments,\n  isExpression,\n  isProgram,\n  isStatement,\n  removeComments,\n  returnStatement,\n  toSequenceExpression,\n  validate,\n  yieldExpression\n} = _t;\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  inheritLeadingComments(nodes[0], this.node);\n  inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n  let ast;\n\n  try {\n    replacement = `(${replacement})`;\n    ast = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  const expressionAST = ast.program.body[0].expression;\n\n  _index.default.removeProperties(expressionAST);\n\n  return this.replaceWith(expressionAST);\n}\n\nfunction replaceWith(replacementPath) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    inheritsComments(replacement, oldNode);\n    removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    validate(this.parent, this.key, [node]);\n  } else {\n    validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);\n\n  if (nodesAsSequenceExpression) {\n    return this.replaceWith(nodesAsSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = arrowFunctionExpression([], blockStatement(nodes));\n  this.replaceWith(callExpression(container, []));\n  const callee = this.get(\"callee\");\n  (0, _helperHoistVariables.default)(callee.get(\"body\"), id => {\n    this.scope.push({\n      id\n    });\n  }, \"var\");\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", returnStatement(cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(assignmentExpression(\"=\", cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(returnStatement(path.node.expression));\n    }\n  }\n\n  callee.arrowFunctionToExpression();\n  const newCallee = callee;\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(yieldExpression(this.node, true));\n  }\n\n  return newCallee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","map":{"version":3,"mappings":"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","names":["FUNCTION_TYPES","arrowFunctionExpression","assignmentExpression","awaitExpression","blockStatement","callExpression","cloneNode","expressionStatement","identifier","inheritLeadingComments","inheritTrailingComments","inheritsComments","isExpression","isProgram","isStatement","removeComments","returnStatement","toSequenceExpression","validate","yieldExpression","replaceWithMultiple","nodes","resync","_verifyNodeList","node","length","get","pathCache","parent","delete","container","key","paths","insertAfter","requeue","remove","replaceWithSourceString","replacement","ast","err","loc","message","start","line","column","code","expressionAST","program","body","expression","traverse","removeProperties","replaceWith","replacementPath","removed","Error","NodePath","Array","isArray","nodePath","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","parentPath","isExportDefaultDeclaration","replaceExpressionWithStatements","oldNode","_replaceWith","type","setScope","ReferenceError","inList","debug","set","nodesAsSequenceExpression","scope","functionParent","getFunctionParent","isParentAsync","is","isParentGenerator","callee","id","push","completionRecords","getCompletionRecords","path","isExpressionStatement","loop","findParent","isLoop","uid","getData","generateDeclaredUidIdentifier","pushContainer","setData","name","arrowFunctionToExpression","newCallee","needToAwaitFunction","hasType","needToYieldFunction","replaceInline","_containerInsertAfter"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\path\\replacement.ts"],"sourcesContent":["// This file contains methods responsible for replacing a node with another.\n\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport traverse from \"../index\";\nimport NodePath from \"./index\";\nimport { path as pathCache } from \"../cache\";\nimport { parse } from \"@babel/parser\";\nimport {\n  FUNCTION_TYPES,\n  arrowFunctionExpression,\n  assignmentExpression,\n  awaitExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  inheritLeadingComments,\n  inheritTrailingComments,\n  inheritsComments,\n  isExpression,\n  isProgram,\n  isStatement,\n  removeComments,\n  returnStatement,\n  toSequenceExpression,\n  validate,\n  yieldExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport hoistVariables from \"@babel/helper-hoist-variables\";\n\n/**\n * Replace a node with an array of multiple. This method performs the following steps:\n *\n *  - Inherit the comments of first provided node with that of the current node.\n *  - Insert the provided nodes after the current node.\n *  - Remove the current node.\n */\n\nexport function replaceWithMultiple(\n  this: NodePath,\n  nodes: t.Node | t.Node[],\n): NodePath[] {\n  this.resync();\n\n  nodes = this._verifyNodeList(nodes);\n  inheritLeadingComments(nodes[0], this.node);\n  inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  pathCache.get(this.parent)?.delete(this.node);\n  this.node =\n    // @ts-expect-error this.key must present in this.container\n    this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n  return paths;\n}\n\n/**\n * Parse a string as an expression and replace the current node with the result.\n *\n * NOTE: This is typically not a good idea to use. Building source strings when\n * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's\n * easier to use, your transforms will be extremely brittle.\n */\n\nexport function replaceWithSourceString(this: NodePath, replacement: string) {\n  this.resync();\n  let ast: t.File;\n\n  try {\n    replacement = `(${replacement})`;\n    // @ts-expect-error todo: use babel-types ast typings in Babel parser\n    ast = parse(replacement);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message +=\n        \" - make sure this is an expression.\\n\" +\n        codeFrameColumns(replacement, {\n          start: {\n            line: loc.line,\n            column: loc.column + 1,\n          },\n        });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n    throw err;\n  }\n\n  const expressionAST = (ast.program.body[0] as t.ExpressionStatement)\n    .expression;\n  traverse.removeProperties(expressionAST);\n  return this.replaceWith(expressionAST);\n}\n\n/**\n * Replace the current node with another.\n */\n\nexport function replaceWith<R extends t.Node>(\n  this: NodePath,\n  replacementPath: R | NodePath<R>,\n): [NodePath<R>] {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  let replacement: t.Node =\n    replacementPath instanceof NodePath\n      ? replacementPath.node\n      : replacementPath;\n\n  if (!replacement) {\n    throw new Error(\n      \"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\",\n    );\n  }\n\n  if (this.node === replacement) {\n    return [this as NodePath<R>];\n  }\n\n  if (this.isProgram() && !isProgram(replacement)) {\n    throw new Error(\n      \"You can only replace a Program root node with another Program node\",\n    );\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\n      \"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\",\n    );\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\n      \"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\",\n    );\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && isExpression(replacement)) {\n    if (\n      !this.canHaveVariableDeclarationOrExpression() &&\n      !this.canSwapBetweenExpressionAndStatement(replacement) &&\n      !this.parentPath.isExportDefaultDeclaration()\n    ) {\n      // replacing a statement with an expression so wrap it in an expression statement\n      replacement = expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && isStatement(replacement)) {\n    if (\n      !this.canHaveVariableDeclarationOrExpression() &&\n      !this.canSwapBetweenExpressionAndStatement(replacement)\n    ) {\n      // replacing an expression with a statement so let's explode it\n      return this.replaceExpressionWithStatements([replacement]) as [\n        NodePath<R>,\n      ];\n    }\n  }\n\n  const oldNode = this.node;\n  if (oldNode) {\n    inheritsComments(replacement, oldNode);\n    removeComments(oldNode);\n  }\n\n  // replace the node\n  this._replaceWith(replacement);\n  this.type = replacement.type;\n\n  // potentially create new scope\n  this.setScope();\n\n  // requeue for visiting\n  this.requeue();\n\n  return [\n    nodePath ? (this.get(nodePath) as NodePath<R>) : (this as NodePath<R>),\n  ];\n}\n\n/**\n * Description\n */\n\nexport function _replaceWith(this: NodePath, node: t.Node) {\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    // @ts-expect-error todo(flow->ts): check if validate accepts a numeric key\n    validate(this.parent, this.key, [node]);\n  } else {\n    validate(this.parent, this.key as string, node);\n  }\n\n  this.debug(`Replace with ${node?.type}`);\n  pathCache.get(this.parent)?.set(node, this).delete(this.node);\n\n  this.node =\n    // @ts-expect-error this.key must present in this.container\n    this.container[this.key] = node;\n}\n\n/**\n * This method takes an array of statements nodes and then explodes it\n * into expressions. This method retains completion records which is\n * extremely important to retain original semantics.\n */\n\nexport function replaceExpressionWithStatements(\n  this: NodePath,\n  nodes: Array<t.Statement>,\n) {\n  this.resync();\n\n  const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);\n\n  if (nodesAsSequenceExpression) {\n    return this.replaceWith(nodesAsSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent?.is(\"async\");\n  const isParentGenerator = functionParent?.is(\"generator\");\n\n  const container = arrowFunctionExpression([], blockStatement(nodes));\n\n  this.replaceWith(callExpression(container, []));\n  // replaceWith changes the type of \"this\", but it isn't trackable by TS\n  type ThisType = NodePath<\n    t.CallExpression & {\n      callee: t.ArrowFunctionExpression & { body: t.BlockStatement };\n    }\n  >;\n\n  // hoist variable declaration in do block\n  // `(do { var x = 1; x;})` -> `var x; (() => { x = 1; return x; })()`\n  const callee = (this as ThisType).get(\"callee\");\n  hoistVariables(\n    callee.get(\"body\"),\n    (id: t.Identifier) => {\n      this.scope.push({ id });\n    },\n    \"var\",\n  );\n\n  // add implicit returns to all ending expression statements\n  const completionRecords: Array<NodePath> = (this as ThisType)\n    .get(\"callee\")\n    .getCompletionRecords();\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n\n    const loop = path.findParent(path => path.isLoop());\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee\n          .get(\"body\")\n          .pushContainer(\"body\", returnStatement(cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = identifier(uid.name);\n      }\n\n      path\n        .get(\"expression\")\n        .replaceWith(\n          assignmentExpression(\"=\", cloneNode(uid), path.node.expression),\n        );\n    } else {\n      path.replaceWith(returnStatement(path.node.expression));\n    }\n  }\n\n  // This is an IIFE, so we don't need to worry about the noNewArrows assumption\n  callee.arrowFunctionToExpression();\n  // Fixme: we can not `assert this is NodePath<t.FunctionExpression>` in `arrowFunctionToExpression`\n  // because it is not a class method known at compile time.\n  const newCallee = callee as unknown as NodePath<t.FunctionExpression>;\n\n  // (() => await xxx)() -> await (async () => await xxx)();\n  const needToAwaitFunction =\n    isParentAsync &&\n    traverse.hasType(\n      (this.get(\"callee.body\") as NodePath<t.BlockStatement>).node,\n      \"AwaitExpression\",\n      FUNCTION_TYPES,\n    );\n  const needToYieldFunction =\n    isParentGenerator &&\n    traverse.hasType(\n      (this.get(\"callee.body\") as NodePath<t.BlockStatement>).node,\n      \"YieldExpression\",\n      FUNCTION_TYPES,\n    );\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n    // yield* will await the generator return result\n    if (!needToYieldFunction) {\n      this.replaceWith(awaitExpression((this as ThisType).node));\n    }\n  }\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(yieldExpression((this as ThisType).node, true));\n  }\n\n  return newCallee.get(\"body.body\");\n}\n\nexport function replaceInline(this: NodePath, nodes: t.Node | Array<t.Node>) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n      const paths = this._containerInsertAfter(nodes);\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}