{"ast":null,"code":"/**\n * @fileoverview Utility class and functions for React components detection\n * @author Yannick Croissant\n */\n'use strict';\n\nconst arrayIncludes = require('array-includes');\n\nconst fromEntries = require('object.fromentries');\n\nconst values = require('object.values');\n\nconst variableUtil = require('./variable');\n\nconst pragmaUtil = require('./pragma');\n\nconst astUtil = require('./ast');\n\nconst componentUtil = require('./componentUtil');\n\nconst propTypesUtil = require('./propTypes');\n\nconst jsxUtil = require('./jsx');\n\nconst usedPropTypesUtil = require('./usedPropTypes');\n\nconst defaultPropsUtil = require('./defaultProps');\n\nconst isFirstLetterCapitalized = require('./isFirstLetterCapitalized');\n\nconst isDestructuredFromPragmaImport = require('./isDestructuredFromPragmaImport');\n\nfunction getId(node) {\n  return node && node.range.join(':');\n}\n\nfunction usedPropTypesAreEquivalent(propA, propB) {\n  if (propA.name === propB.name) {\n    if (!propA.allNames && !propB.allNames) {\n      return true;\n    }\n\n    if (Array.isArray(propA.allNames) && Array.isArray(propB.allNames) && propA.allNames.join('') === propB.allNames.join('')) {\n      return true;\n    }\n\n    return false;\n  }\n\n  return false;\n}\n\nfunction mergeUsedPropTypes(propsList, newPropsList) {\n  const propsToAdd = newPropsList.filter(newProp => {\n    const newPropIsAlreadyInTheList = propsList.some(prop => usedPropTypesAreEquivalent(prop, newProp));\n    return !newPropIsAlreadyInTheList;\n  });\n  return propsList.concat(propsToAdd);\n}\n\nconst USE_HOOK_PREFIX_REGEX = /^use[A-Z]/;\nconst Lists = new WeakMap();\nconst ReactImports = new WeakMap();\n/**\n * Components\n */\n\nclass Components {\n  constructor() {\n    Lists.set(this, {});\n    ReactImports.set(this, {});\n  }\n  /**\n   * Add a node to the components list, or update it if it's already in the list\n   *\n   * @param {ASTNode} node The AST node being added.\n   * @param {Number} confidence Confidence in the component detection (0=banned, 1=maybe, 2=yes)\n   * @returns {Object} Added component object\n   */\n\n\n  add(node, confidence) {\n    const id = getId(node);\n    const list = Lists.get(this);\n\n    if (list[id]) {\n      if (confidence === 0 || list[id].confidence === 0) {\n        list[id].confidence = 0;\n      } else {\n        list[id].confidence = Math.max(list[id].confidence, confidence);\n      }\n\n      return list[id];\n    }\n\n    list[id] = {\n      node,\n      confidence\n    };\n    return list[id];\n  }\n  /**\n   * Find a component in the list using its node\n   *\n   * @param {ASTNode} node The AST node being searched.\n   * @returns {Object} Component object, undefined if the component is not found or has confidence value of 0.\n   */\n\n\n  get(node) {\n    const id = getId(node);\n    const item = Lists.get(this)[id];\n\n    if (item && item.confidence >= 1) {\n      return item;\n    }\n\n    return null;\n  }\n  /**\n   * Update a component in the list\n   *\n   * @param {ASTNode} node The AST node being updated.\n   * @param {Object} props Additional properties to add to the component.\n   */\n\n\n  set(node, props) {\n    const list = Lists.get(this);\n    let component = list[getId(node)];\n\n    while (!component) {\n      node = node.parent;\n\n      if (!node) {\n        return;\n      }\n\n      component = list[getId(node)];\n    }\n\n    Object.assign(component, props, {\n      usedPropTypes: mergeUsedPropTypes(component.usedPropTypes || [], props.usedPropTypes || [])\n    });\n  }\n  /**\n   * Return the components list\n   * Components for which we are not confident are not returned\n   *\n   * @returns {Object} Components list\n   */\n\n\n  list() {\n    const thisList = Lists.get(this);\n    const list = {};\n    const usedPropTypes = {}; // Find props used in components for which we are not confident\n\n    Object.keys(thisList).filter(i => thisList[i].confidence < 2).forEach(i => {\n      let component = null;\n      let node = null;\n      node = thisList[i].node;\n\n      while (!component && node.parent) {\n        node = node.parent; // Stop moving up if we reach a decorator\n\n        if (node.type === 'Decorator') {\n          break;\n        }\n\n        component = this.get(node);\n      }\n\n      if (component) {\n        const newUsedProps = (thisList[i].usedPropTypes || []).filter(propType => !propType.node || propType.node.kind !== 'init');\n        const componentId = getId(component.node);\n        usedPropTypes[componentId] = mergeUsedPropTypes(usedPropTypes[componentId] || [], newUsedProps);\n      }\n    }); // Assign used props in not confident components to the parent component\n\n    Object.keys(thisList).filter(j => thisList[j].confidence >= 2).forEach(j => {\n      const id = getId(thisList[j].node);\n      list[j] = thisList[j];\n\n      if (usedPropTypes[id]) {\n        list[j].usedPropTypes = mergeUsedPropTypes(list[j].usedPropTypes || [], usedPropTypes[id]);\n      }\n    });\n    return list;\n  }\n  /**\n   * Return the length of the components list\n   * Components for which we are not confident are not counted\n   *\n   * @returns {Number} Components list length\n   */\n\n\n  length() {\n    const list = Lists.get(this);\n    return Object.keys(list).filter(i => list[i].confidence >= 2).length;\n  }\n  /**\n   * Return the node naming the default React import\n   * It can be used to determine the local name of import, even if it's imported\n   * with an unusual name.\n   *\n   * @returns {ASTNode} React default import node\n   */\n\n\n  getDefaultReactImports() {\n    return ReactImports.get(this).defaultReactImports;\n  }\n  /**\n   * Return the nodes of all React named imports\n   *\n   * @returns {Object} The list of React named imports\n   */\n\n\n  getNamedReactImports() {\n    return ReactImports.get(this).namedReactImports;\n  }\n  /**\n   * Add the default React import specifier to the scope\n   *\n   * @param {ASTNode} specifier The AST Node of the default React import\n   * @returns {void}\n   */\n\n\n  addDefaultReactImport(specifier) {\n    const info = ReactImports.get(this);\n    ReactImports.set(this, Object.assign({}, info, {\n      defaultReactImports: (info.defaultReactImports || []).concat(specifier)\n    }));\n  }\n  /**\n   * Add a named React import specifier to the scope\n   *\n   * @param {ASTNode} specifier The AST Node of a named React import\n   * @returns {void}\n   */\n\n\n  addNamedReactImport(specifier) {\n    const info = ReactImports.get(this);\n    ReactImports.set(this, Object.assign({}, info, {\n      namedReactImports: (info.namedReactImports || []).concat(specifier)\n    }));\n  }\n\n}\n\nfunction getWrapperFunctions(context, pragma) {\n  const componentWrapperFunctions = context.settings.componentWrapperFunctions || []; // eslint-disable-next-line arrow-body-style\n\n  return componentWrapperFunctions.map(wrapperFunction => {\n    return typeof wrapperFunction === 'string' ? {\n      property: wrapperFunction\n    } : Object.assign({}, wrapperFunction, {\n      object: wrapperFunction.object === '<pragma>' ? pragma : wrapperFunction.object\n    });\n  }).concat([{\n    property: 'forwardRef',\n    object: pragma\n  }, {\n    property: 'memo',\n    object: pragma\n  }]);\n} // eslint-disable-next-line valid-jsdoc\n\n/**\n * Merge many eslint rules into one\n * @param {{[_: string]: Function}[]} rules the returned values for eslint rule.create(context)\n * @returns {{[_: string]: Function}} merged rule\n */\n\n\nfunction mergeRules(rules) {\n  /** @type {Map<string, Function[]>} */\n  const handlersByKey = new Map();\n  rules.forEach(rule => {\n    Object.keys(rule).forEach(key => {\n      const fns = handlersByKey.get(key);\n\n      if (!fns) {\n        handlersByKey.set(key, [rule[key]]);\n      } else {\n        fns.push(rule[key]);\n      }\n    });\n  });\n  /** @type {{[key: string]: Function}} */\n\n  const rule = {};\n  handlersByKey.forEach((fns, key) => {\n    rule[key] = function mergedHandler(node) {\n      fns.forEach(fn => {\n        fn(node);\n      });\n    };\n  });\n  return rule;\n}\n\nfunction componentRule(rule, context) {\n  const pragma = pragmaUtil.getFromContext(context);\n  const sourceCode = context.getSourceCode();\n  const components = new Components();\n  const wrapperFunctions = getWrapperFunctions(context, pragma); // Utilities for component detection\n\n  const utils = {\n    /**\n     * Check if variable is destructured from pragma import\n     *\n     * @param {string} variable The variable name to check\n     * @returns {Boolean} True if createElement is destructured from the pragma\n     */\n    isDestructuredFromPragmaImport(variable) {\n      return isDestructuredFromPragmaImport(variable, context);\n    },\n\n    isReturningJSX(ASTNode, strict) {\n      return jsxUtil.isReturningJSX(ASTNode, context, strict, true);\n    },\n\n    isReturningJSXOrNull(ASTNode, strict) {\n      return jsxUtil.isReturningJSX(ASTNode, context, strict);\n    },\n\n    isReturningOnlyNull(ASTNode) {\n      return jsxUtil.isReturningOnlyNull(ASTNode, context);\n    },\n\n    getPragmaComponentWrapper(node) {\n      let isPragmaComponentWrapper;\n      let currentNode = node;\n      let prevNode;\n\n      do {\n        currentNode = currentNode.parent;\n        isPragmaComponentWrapper = this.isPragmaComponentWrapper(currentNode);\n\n        if (isPragmaComponentWrapper) {\n          prevNode = currentNode;\n        }\n      } while (isPragmaComponentWrapper);\n\n      return prevNode;\n    },\n\n    getComponentNameFromJSXElement(node) {\n      if (node.type !== 'JSXElement') {\n        return null;\n      }\n\n      if (node.openingElement && node.openingElement.name && node.openingElement.name.name) {\n        return node.openingElement.name.name;\n      }\n\n      return null;\n    },\n\n    /**\n     * Getting the first JSX element's name.\n     * @param {object} node\n     * @returns {string | null}\n     */\n    getNameOfWrappedComponent(node) {\n      if (node.length < 1) {\n        return null;\n      }\n\n      const body = node[0].body;\n\n      if (!body) {\n        return null;\n      }\n\n      if (body.type === 'JSXElement') {\n        return this.getComponentNameFromJSXElement(body);\n      }\n\n      if (body.type === 'BlockStatement') {\n        const jsxElement = body.body.find(item => item.type === 'ReturnStatement');\n        return jsxElement && jsxElement.argument && this.getComponentNameFromJSXElement(jsxElement.argument);\n      }\n\n      return null;\n    },\n\n    /**\n     * Get the list of names of components created till now\n     * @returns {string | boolean}\n     */\n    getDetectedComponents() {\n      const list = components.list();\n      return values(list).filter(val => {\n        if (val.node.type === 'ClassDeclaration') {\n          return true;\n        }\n\n        if (val.node.type === 'ArrowFunctionExpression' && val.node.parent && val.node.parent.type === 'VariableDeclarator' && val.node.parent.id) {\n          return true;\n        }\n\n        return false;\n      }).map(val => {\n        if (val.node.type === 'ArrowFunctionExpression') return val.node.parent.id.name;\n        return val.node.id && val.node.id.name;\n      });\n    },\n\n    /**\n     * It will check whether memo/forwardRef is wrapping existing component or\n     * creating a new one.\n     * @param {object} node\n     * @returns {boolean}\n     */\n    nodeWrapsComponent(node) {\n      const childComponent = this.getNameOfWrappedComponent(node.arguments);\n      const componentList = this.getDetectedComponents();\n      return !!childComponent && arrayIncludes(componentList, childComponent);\n    },\n\n    isPragmaComponentWrapper(node) {\n      if (!node || node.type !== 'CallExpression') {\n        return false;\n      }\n\n      return wrapperFunctions.some(wrapperFunction => {\n        if (node.callee.type === 'MemberExpression') {\n          return wrapperFunction.object && wrapperFunction.object === node.callee.object.name && wrapperFunction.property === node.callee.property.name && !this.nodeWrapsComponent(node);\n        }\n\n        return wrapperFunction.property === node.callee.name && (!wrapperFunction.object // Functions coming from the current pragma need special handling\n        || wrapperFunction.object === pragma && this.isDestructuredFromPragmaImport(node.callee.name));\n      });\n    },\n\n    /**\n     * Find a return statement in the current node\n     *\n     * @param {ASTNode} node The AST node being checked\n     */\n    findReturnStatement: astUtil.findReturnStatement,\n\n    /**\n     * Get the parent component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentComponent() {\n      return componentUtil.getParentES6Component(context) || componentUtil.getParentES5Component(context) || utils.getParentStatelessComponent();\n    },\n\n    /**\n     * @param {ASTNode} node\n     * @returns {boolean}\n     */\n    isInAllowedPositionForComponent(node) {\n      switch (node.parent.type) {\n        case 'VariableDeclarator':\n        case 'AssignmentExpression':\n        case 'Property':\n        case 'ReturnStatement':\n        case 'ExportDefaultDeclaration':\n        case 'ArrowFunctionExpression':\n          {\n            return true;\n          }\n\n        case 'SequenceExpression':\n          {\n            return utils.isInAllowedPositionForComponent(node.parent) && node === node.parent.expressions[node.parent.expressions.length - 1];\n          }\n\n        default:\n          return false;\n      }\n    },\n\n    /**\n     * Get node if node is a stateless component, or node.parent in cases like\n     * `React.memo` or `React.forwardRef`. Otherwise returns `undefined`.\n     * @param {ASTNode} node\n     * @returns {ASTNode | undefined}\n     */\n    getStatelessComponent(node) {\n      const parent = node.parent;\n\n      if (node.type === 'FunctionDeclaration' && (!node.id || isFirstLetterCapitalized(node.id.name)) && utils.isReturningJSXOrNull(node)) {\n        return node;\n      }\n\n      if (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') {\n        const isMethod = parent.type === 'Property' && parent.method;\n        const isPropertyAssignment = parent.type === 'AssignmentExpression' && parent.left.type === 'MemberExpression';\n        const isModuleExportsAssignment = isPropertyAssignment && parent.left.object.name === 'module' && parent.left.property.name === 'exports';\n\n        if (node.parent.type === 'ExportDefaultDeclaration') {\n          if (utils.isReturningJSX(node)) {\n            return node;\n          }\n\n          return undefined;\n        }\n\n        if (node.parent.type === 'VariableDeclarator' && utils.isReturningJSXOrNull(node)) {\n          if (isFirstLetterCapitalized(node.parent.id.name)) {\n            return node;\n          }\n\n          return undefined;\n        } // case: const any = () => { return (props) => null }\n        // case: const any = () => (props) => null\n\n\n        if ((node.parent.type === 'ReturnStatement' || node.parent.type === 'ArrowFunctionExpression' && node.parent.expression) && !utils.isReturningJSX(node)) {\n          return undefined;\n        } // case: any = () => { return => null }\n        // case: any = () => null\n\n\n        if (node.parent.type === 'AssignmentExpression' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n          if (isFirstLetterCapitalized(node.parent.left.name)) {\n            return node;\n          }\n\n          return undefined;\n        } // case: any = () => () => null\n\n\n        if (node.parent.type === 'ArrowFunctionExpression' && node.parent.parent.type === 'AssignmentExpression' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n          if (isFirstLetterCapitalized(node.parent.parent.left.name)) {\n            return node;\n          }\n\n          return undefined;\n        } // case: { any: () => () => null }\n\n\n        if (node.parent.type === 'ArrowFunctionExpression' && node.parent.parent.type === 'Property' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n          if (isFirstLetterCapitalized(node.parent.parent.key.name)) {\n            return node;\n          }\n\n          return undefined;\n        } // case: any = function() {return function() {return null;};}\n\n\n        if (node.parent.type === 'ReturnStatement') {\n          if (isFirstLetterCapitalized(node.id && node.id.name)) {\n            return node;\n          }\n\n          const functionExpr = node.parent.parent.parent;\n\n          if (functionExpr.parent.type === 'AssignmentExpression' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n            if (isFirstLetterCapitalized(functionExpr.parent.left.name)) {\n              return node;\n            }\n\n            return undefined;\n          }\n        } // case: { any: function() {return function() {return null;};} }\n\n\n        if (node.parent.type === 'ReturnStatement') {\n          const functionExpr = node.parent.parent.parent;\n\n          if (functionExpr.parent.type === 'Property' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n            if (isFirstLetterCapitalized(functionExpr.parent.key.name)) {\n              return node;\n            }\n\n            return undefined;\n          }\n        } // for case abc = { [someobject.somekey]: props => { ... return not-jsx } }\n\n\n        if (node.parent && node.parent.key && node.parent.key.type === 'MemberExpression' && !utils.isReturningJSX(node) && !utils.isReturningOnlyNull(node)) {\n          return undefined;\n        } // Case like `React.memo(() => <></>)` or `React.forwardRef(...)`\n\n\n        const pragmaComponentWrapper = utils.getPragmaComponentWrapper(node);\n\n        if (pragmaComponentWrapper && utils.isReturningJSXOrNull(node)) {\n          return pragmaComponentWrapper;\n        }\n\n        if (!(utils.isInAllowedPositionForComponent(node) && utils.isReturningJSXOrNull(node))) {\n          return undefined;\n        }\n\n        if (utils.isParentComponentNotStatelessComponent(node)) {\n          return undefined;\n        }\n\n        if (isMethod && !isFirstLetterCapitalized(node.parent.key.name)) {\n          return utils.isReturningJSX(node) ? node : undefined;\n        }\n\n        if (node.id) {\n          return isFirstLetterCapitalized(node.id.name) ? node : undefined;\n        }\n\n        if (isPropertyAssignment && !isModuleExportsAssignment && !isFirstLetterCapitalized(parent.left.property.name)) {\n          return undefined;\n        }\n\n        if (parent.type === 'Property' && utils.isReturningOnlyNull(node)) {\n          return undefined;\n        }\n\n        return node;\n      }\n\n      return undefined;\n    },\n\n    /**\n     * Get the parent stateless component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentStatelessComponent() {\n      let scope = context.getScope();\n\n      while (scope) {\n        const node = scope.block;\n        const statelessComponent = utils.getStatelessComponent(node);\n\n        if (statelessComponent) {\n          return statelessComponent;\n        }\n\n        scope = scope.upper;\n      }\n\n      return null;\n    },\n\n    /**\n     * Get the related component from a node\n     *\n     * @param {ASTNode} node The AST node being checked (must be a MemberExpression).\n     * @returns {ASTNode} component node, null if we cannot find the component\n     */\n    getRelatedComponent(node) {\n      let i;\n      let j;\n      let k;\n      let l;\n      let componentNode; // Get the component path\n\n      const componentPath = [];\n\n      while (node) {\n        if (node.property && node.property.type === 'Identifier') {\n          componentPath.push(node.property.name);\n        }\n\n        if (node.object && node.object.type === 'Identifier') {\n          componentPath.push(node.object.name);\n        }\n\n        node = node.object;\n      }\n\n      componentPath.reverse();\n      const componentName = componentPath.slice(0, componentPath.length - 1).join('.'); // Find the variable in the current scope\n\n      const variableName = componentPath.shift();\n\n      if (!variableName) {\n        return null;\n      }\n\n      let variableInScope;\n      const variables = variableUtil.variablesInScope(context);\n\n      for (i = 0, j = variables.length; i < j; i++) {\n        if (variables[i].name === variableName) {\n          variableInScope = variables[i];\n          break;\n        }\n      }\n\n      if (!variableInScope) {\n        return null;\n      } // Try to find the component using variable references\n\n\n      const refs = variableInScope.references;\n      refs.some(ref => {\n        let refId = ref.identifier;\n\n        if (refId.parent && refId.parent.type === 'MemberExpression') {\n          refId = refId.parent;\n        }\n\n        if (sourceCode.getText(refId) !== componentName) {\n          return false;\n        }\n\n        if (refId.type === 'MemberExpression') {\n          componentNode = refId.parent.right;\n        } else if (refId.parent && refId.parent.type === 'VariableDeclarator' && refId.parent.init && refId.parent.init.type !== 'Identifier') {\n          componentNode = refId.parent.init;\n        }\n\n        return true;\n      });\n\n      if (componentNode) {\n        // Return the component\n        return components.add(componentNode, 1);\n      } // Try to find the component using variable declarations\n\n\n      const defs = variableInScope.defs;\n      const defInScope = defs.find(def => def.type === 'ClassName' || def.type === 'FunctionName' || def.type === 'Variable');\n\n      if (!defInScope || !defInScope.node) {\n        return null;\n      }\n\n      componentNode = defInScope.node.init || defInScope.node; // Traverse the node properties to the component declaration\n\n      for (i = 0, j = componentPath.length; i < j; i++) {\n        if (!componentNode.properties) {\n          continue; // eslint-disable-line no-continue\n        }\n\n        for (k = 0, l = componentNode.properties.length; k < l; k++) {\n          if (componentNode.properties[k].key && componentNode.properties[k].key.name === componentPath[i]) {\n            componentNode = componentNode.properties[k];\n            break;\n          }\n        }\n\n        if (!componentNode || !componentNode.value) {\n          return null;\n        }\n\n        componentNode = componentNode.value;\n      } // Return the component\n\n\n      return components.add(componentNode, 1);\n    },\n\n    isParentComponentNotStatelessComponent(node) {\n      return !!(node.parent && node.parent.key && node.parent.key.type === 'Identifier' // custom component functions must start with a capital letter (returns false otherwise)\n      && node.parent.key.name.charAt(0) === node.parent.key.name.charAt(0).toLowerCase() // react render function cannot have params\n      && !!(node.params || []).length);\n    },\n\n    /**\n     * Identify whether a node (CallExpression) is a call to a React hook\n     *\n     * @param {ASTNode} node The AST node being searched. (expects CallExpression)\n     * @param {('useCallback'|'useContext'|'useDebugValue'|'useEffect'|'useImperativeHandle'|'useLayoutEffect'|'useMemo'|'useReducer'|'useRef'|'useState')[]} [expectedHookNames] React hook names to which search is limited.\n     * @returns {Boolean} True if the node is a call to a React hook\n     */\n    isReactHookCall(node, expectedHookNames) {\n      if (node.type !== 'CallExpression') {\n        return false;\n      }\n\n      const defaultReactImports = components.getDefaultReactImports();\n      const namedReactImports = components.getNamedReactImports();\n      const defaultReactImportName = defaultReactImports && defaultReactImports[0] && defaultReactImports[0].local.name;\n      const reactHookImportSpecifiers = namedReactImports && namedReactImports.filter(specifier => USE_HOOK_PREFIX_REGEX.test(specifier.imported.name));\n      const reactHookImportNames = reactHookImportSpecifiers && fromEntries(reactHookImportSpecifiers.map(specifier => [specifier.local.name, specifier.imported.name]));\n      const isPotentialReactHookCall = defaultReactImportName && node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && node.callee.object.name === defaultReactImportName && node.callee.property.type === 'Identifier' && node.callee.property.name.match(USE_HOOK_PREFIX_REGEX);\n      const isPotentialHookCall = reactHookImportNames && node.callee.type === 'Identifier' && node.callee.name.match(USE_HOOK_PREFIX_REGEX);\n      const scope = (isPotentialReactHookCall || isPotentialHookCall) && context.getScope();\n      const reactResolvedDefs = isPotentialReactHookCall && scope.references && scope.references.find(reference => reference.identifier.name === defaultReactImportName).resolved.defs;\n      const isReactShadowed = isPotentialReactHookCall && reactResolvedDefs && reactResolvedDefs.some(reactDef => reactDef.type !== 'ImportBinding');\n      const potentialHookReference = isPotentialHookCall && scope.references && scope.references.find(reference => reactHookImportNames[reference.identifier.name]);\n      const hookResolvedDefs = potentialHookReference && potentialHookReference.resolved.defs;\n      const localHookName = isPotentialReactHookCall && node.callee.property.name || isPotentialHookCall && potentialHookReference && node.callee.name;\n      const isHookShadowed = isPotentialHookCall && hookResolvedDefs && hookResolvedDefs.some(hookDef => hookDef.name.name === localHookName && hookDef.type !== 'ImportBinding');\n      const isHookCall = isPotentialReactHookCall && !isReactShadowed || isPotentialHookCall && localHookName && !isHookShadowed;\n\n      if (!isHookCall) {\n        return false;\n      }\n\n      if (!expectedHookNames) {\n        return true;\n      }\n\n      return arrayIncludes(expectedHookNames, reactHookImportNames && reactHookImportNames[localHookName] || localHookName);\n    }\n\n  }; // Component detection instructions\n\n  const detectionInstructions = {\n    CallExpression(node) {\n      if (!utils.isPragmaComponentWrapper(node)) {\n        return;\n      }\n\n      if (node.arguments.length > 0 && astUtil.isFunctionLikeExpression(node.arguments[0])) {\n        components.add(node, 2);\n      }\n    },\n\n    ClassExpression(node) {\n      if (!componentUtil.isES6Component(node, context)) {\n        return;\n      }\n\n      components.add(node, 2);\n    },\n\n    ClassDeclaration(node) {\n      if (!componentUtil.isES6Component(node, context)) {\n        return;\n      }\n\n      components.add(node, 2);\n    },\n\n    ObjectExpression(node) {\n      if (!componentUtil.isES5Component(node, context)) {\n        return;\n      }\n\n      components.add(node, 2);\n    },\n\n    FunctionExpression(node) {\n      if (node.async) {\n        components.add(node, 0);\n        return;\n      }\n\n      const component = utils.getParentComponent();\n\n      if (!component || component.parent && component.parent.type === 'JSXExpressionContainer') {\n        // Ban the node if we cannot find a parent component\n        components.add(node, 0);\n        return;\n      }\n\n      components.add(component, 2);\n    },\n\n    FunctionDeclaration(node) {\n      if (node.async) {\n        components.add(node, 0);\n        return;\n      }\n\n      node = utils.getParentComponent();\n\n      if (!node) {\n        return;\n      }\n\n      components.add(node, 2);\n    },\n\n    ArrowFunctionExpression(node) {\n      if (node.async) {\n        components.add(node, 0);\n        return;\n      }\n\n      const component = utils.getParentComponent();\n\n      if (!component || component.parent && component.parent.type === 'JSXExpressionContainer') {\n        // Ban the node if we cannot find a parent component\n        components.add(node, 0);\n        return;\n      }\n\n      components.add(component, 2);\n    },\n\n    ThisExpression(node) {\n      const component = utils.getParentStatelessComponent();\n\n      if (!component || !/Function/.test(component.type) || !node.parent.property) {\n        return;\n      } // Ban functions accessing a property on a ThisExpression\n\n\n      components.add(node, 0);\n    }\n\n  }; // Detect React import specifiers\n\n  const reactImportInstructions = {\n    ImportDeclaration(node) {\n      const isReactImported = node.source.type === 'Literal' && node.source.value === 'react';\n\n      if (!isReactImported) {\n        return;\n      }\n\n      node.specifiers.forEach(specifier => {\n        if (specifier.type === 'ImportDefaultSpecifier') {\n          components.addDefaultReactImport(specifier);\n        }\n\n        if (specifier.type === 'ImportSpecifier') {\n          components.addNamedReactImport(specifier);\n        }\n      });\n    }\n\n  };\n  const ruleInstructions = rule(context, components, utils);\n  const propTypesInstructions = propTypesUtil(context, components, utils);\n  const usedPropTypesInstructions = usedPropTypesUtil(context, components, utils);\n  const defaultPropsInstructions = defaultPropsUtil(context, components, utils);\n  const mergedRule = mergeRules([detectionInstructions, propTypesInstructions, usedPropTypesInstructions, defaultPropsInstructions, reactImportInstructions, ruleInstructions]);\n  return mergedRule;\n}\n\nmodule.exports = Object.assign(Components, {\n  detect(rule) {\n    return componentRule.bind(this, rule);\n  }\n\n});","map":{"version":3,"names":["arrayIncludes","require","fromEntries","values","variableUtil","pragmaUtil","astUtil","componentUtil","propTypesUtil","jsxUtil","usedPropTypesUtil","defaultPropsUtil","isFirstLetterCapitalized","isDestructuredFromPragmaImport","getId","node","range","join","usedPropTypesAreEquivalent","propA","propB","name","allNames","Array","isArray","mergeUsedPropTypes","propsList","newPropsList","propsToAdd","filter","newProp","newPropIsAlreadyInTheList","some","prop","concat","USE_HOOK_PREFIX_REGEX","Lists","WeakMap","ReactImports","Components","constructor","set","add","confidence","id","list","get","Math","max","item","props","component","parent","Object","assign","usedPropTypes","thisList","keys","i","forEach","type","newUsedProps","propType","kind","componentId","j","length","getDefaultReactImports","defaultReactImports","getNamedReactImports","namedReactImports","addDefaultReactImport","specifier","info","addNamedReactImport","getWrapperFunctions","context","pragma","componentWrapperFunctions","settings","map","wrapperFunction","property","object","mergeRules","rules","handlersByKey","Map","rule","key","fns","push","mergedHandler","fn","componentRule","getFromContext","sourceCode","getSourceCode","components","wrapperFunctions","utils","variable","isReturningJSX","ASTNode","strict","isReturningJSXOrNull","isReturningOnlyNull","getPragmaComponentWrapper","isPragmaComponentWrapper","currentNode","prevNode","getComponentNameFromJSXElement","openingElement","getNameOfWrappedComponent","body","jsxElement","find","argument","getDetectedComponents","val","nodeWrapsComponent","childComponent","arguments","componentList","callee","findReturnStatement","getParentComponent","getParentES6Component","getParentES5Component","getParentStatelessComponent","isInAllowedPositionForComponent","expressions","getStatelessComponent","isMethod","method","isPropertyAssignment","left","isModuleExportsAssignment","undefined","expression","functionExpr","pragmaComponentWrapper","isParentComponentNotStatelessComponent","scope","getScope","block","statelessComponent","upper","getRelatedComponent","k","l","componentNode","componentPath","reverse","componentName","slice","variableName","shift","variableInScope","variables","variablesInScope","refs","references","ref","refId","identifier","getText","right","init","defs","defInScope","def","properties","value","charAt","toLowerCase","params","isReactHookCall","expectedHookNames","defaultReactImportName","local","reactHookImportSpecifiers","test","imported","reactHookImportNames","isPotentialReactHookCall","match","isPotentialHookCall","reactResolvedDefs","reference","resolved","isReactShadowed","reactDef","potentialHookReference","hookResolvedDefs","localHookName","isHookShadowed","hookDef","isHookCall","detectionInstructions","CallExpression","isFunctionLikeExpression","ClassExpression","isES6Component","ClassDeclaration","ObjectExpression","isES5Component","FunctionExpression","async","FunctionDeclaration","ArrowFunctionExpression","ThisExpression","reactImportInstructions","ImportDeclaration","isReactImported","source","specifiers","ruleInstructions","propTypesInstructions","usedPropTypesInstructions","defaultPropsInstructions","mergedRule","module","exports","detect","bind"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/util/Components.js"],"sourcesContent":["/**\n * @fileoverview Utility class and functions for React components detection\n * @author Yannick Croissant\n */\n\n'use strict';\n\nconst arrayIncludes = require('array-includes');\nconst fromEntries = require('object.fromentries');\nconst values = require('object.values');\n\nconst variableUtil = require('./variable');\nconst pragmaUtil = require('./pragma');\nconst astUtil = require('./ast');\nconst componentUtil = require('./componentUtil');\nconst propTypesUtil = require('./propTypes');\nconst jsxUtil = require('./jsx');\nconst usedPropTypesUtil = require('./usedPropTypes');\nconst defaultPropsUtil = require('./defaultProps');\nconst isFirstLetterCapitalized = require('./isFirstLetterCapitalized');\nconst isDestructuredFromPragmaImport = require('./isDestructuredFromPragmaImport');\n\nfunction getId(node) {\n  return node && node.range.join(':');\n}\n\nfunction usedPropTypesAreEquivalent(propA, propB) {\n  if (propA.name === propB.name) {\n    if (!propA.allNames && !propB.allNames) {\n      return true;\n    }\n    if (Array.isArray(propA.allNames) && Array.isArray(propB.allNames) && propA.allNames.join('') === propB.allNames.join('')) {\n      return true;\n    }\n    return false;\n  }\n  return false;\n}\n\nfunction mergeUsedPropTypes(propsList, newPropsList) {\n  const propsToAdd = newPropsList.filter((newProp) => {\n    const newPropIsAlreadyInTheList = propsList.some((prop) => usedPropTypesAreEquivalent(prop, newProp));\n    return !newPropIsAlreadyInTheList;\n  });\n\n  return propsList.concat(propsToAdd);\n}\n\nconst USE_HOOK_PREFIX_REGEX = /^use[A-Z]/;\n\nconst Lists = new WeakMap();\nconst ReactImports = new WeakMap();\n\n/**\n * Components\n */\nclass Components {\n  constructor() {\n    Lists.set(this, {});\n    ReactImports.set(this, {});\n  }\n\n  /**\n   * Add a node to the components list, or update it if it's already in the list\n   *\n   * @param {ASTNode} node The AST node being added.\n   * @param {Number} confidence Confidence in the component detection (0=banned, 1=maybe, 2=yes)\n   * @returns {Object} Added component object\n   */\n  add(node, confidence) {\n    const id = getId(node);\n    const list = Lists.get(this);\n    if (list[id]) {\n      if (confidence === 0 || list[id].confidence === 0) {\n        list[id].confidence = 0;\n      } else {\n        list[id].confidence = Math.max(list[id].confidence, confidence);\n      }\n      return list[id];\n    }\n    list[id] = {\n      node,\n      confidence,\n    };\n    return list[id];\n  }\n\n  /**\n   * Find a component in the list using its node\n   *\n   * @param {ASTNode} node The AST node being searched.\n   * @returns {Object} Component object, undefined if the component is not found or has confidence value of 0.\n   */\n  get(node) {\n    const id = getId(node);\n    const item = Lists.get(this)[id];\n    if (item && item.confidence >= 1) {\n      return item;\n    }\n    return null;\n  }\n\n  /**\n   * Update a component in the list\n   *\n   * @param {ASTNode} node The AST node being updated.\n   * @param {Object} props Additional properties to add to the component.\n   */\n  set(node, props) {\n    const list = Lists.get(this);\n    let component = list[getId(node)];\n    while (!component) {\n      node = node.parent;\n      if (!node) {\n        return;\n      }\n      component = list[getId(node)];\n    }\n\n    Object.assign(\n      component,\n      props,\n      {\n        usedPropTypes: mergeUsedPropTypes(\n          component.usedPropTypes || [],\n          props.usedPropTypes || []\n        ),\n      }\n    );\n  }\n\n  /**\n   * Return the components list\n   * Components for which we are not confident are not returned\n   *\n   * @returns {Object} Components list\n   */\n  list() {\n    const thisList = Lists.get(this);\n    const list = {};\n    const usedPropTypes = {};\n\n    // Find props used in components for which we are not confident\n    Object.keys(thisList).filter((i) => thisList[i].confidence < 2).forEach((i) => {\n      let component = null;\n      let node = null;\n      node = thisList[i].node;\n      while (!component && node.parent) {\n        node = node.parent;\n        // Stop moving up if we reach a decorator\n        if (node.type === 'Decorator') {\n          break;\n        }\n        component = this.get(node);\n      }\n      if (component) {\n        const newUsedProps = (thisList[i].usedPropTypes || []).filter((propType) => !propType.node || propType.node.kind !== 'init');\n\n        const componentId = getId(component.node);\n\n        usedPropTypes[componentId] = mergeUsedPropTypes(usedPropTypes[componentId] || [], newUsedProps);\n      }\n    });\n\n    // Assign used props in not confident components to the parent component\n    Object.keys(thisList).filter((j) => thisList[j].confidence >= 2).forEach((j) => {\n      const id = getId(thisList[j].node);\n      list[j] = thisList[j];\n      if (usedPropTypes[id]) {\n        list[j].usedPropTypes = mergeUsedPropTypes(list[j].usedPropTypes || [], usedPropTypes[id]);\n      }\n    });\n    return list;\n  }\n\n  /**\n   * Return the length of the components list\n   * Components for which we are not confident are not counted\n   *\n   * @returns {Number} Components list length\n   */\n  length() {\n    const list = Lists.get(this);\n    return Object.keys(list).filter((i) => list[i].confidence >= 2).length;\n  }\n\n  /**\n   * Return the node naming the default React import\n   * It can be used to determine the local name of import, even if it's imported\n   * with an unusual name.\n   *\n   * @returns {ASTNode} React default import node\n   */\n  getDefaultReactImports() {\n    return ReactImports.get(this).defaultReactImports;\n  }\n\n  /**\n   * Return the nodes of all React named imports\n   *\n   * @returns {Object} The list of React named imports\n   */\n  getNamedReactImports() {\n    return ReactImports.get(this).namedReactImports;\n  }\n\n  /**\n   * Add the default React import specifier to the scope\n   *\n   * @param {ASTNode} specifier The AST Node of the default React import\n   * @returns {void}\n   */\n  addDefaultReactImport(specifier) {\n    const info = ReactImports.get(this);\n    ReactImports.set(this, Object.assign({}, info, {\n      defaultReactImports: (info.defaultReactImports || []).concat(specifier),\n    }));\n  }\n\n  /**\n   * Add a named React import specifier to the scope\n   *\n   * @param {ASTNode} specifier The AST Node of a named React import\n   * @returns {void}\n   */\n  addNamedReactImport(specifier) {\n    const info = ReactImports.get(this);\n    ReactImports.set(this, Object.assign({}, info, {\n      namedReactImports: (info.namedReactImports || []).concat(specifier),\n    }));\n  }\n}\n\nfunction getWrapperFunctions(context, pragma) {\n  const componentWrapperFunctions = context.settings.componentWrapperFunctions || [];\n\n  // eslint-disable-next-line arrow-body-style\n  return componentWrapperFunctions.map((wrapperFunction) => {\n    return typeof wrapperFunction === 'string'\n      ? { property: wrapperFunction }\n      : Object.assign({}, wrapperFunction, {\n        object: wrapperFunction.object === '<pragma>' ? pragma : wrapperFunction.object,\n      });\n  }).concat([\n    { property: 'forwardRef', object: pragma },\n    { property: 'memo', object: pragma },\n  ]);\n}\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Merge many eslint rules into one\n * @param {{[_: string]: Function}[]} rules the returned values for eslint rule.create(context)\n * @returns {{[_: string]: Function}} merged rule\n */\nfunction mergeRules(rules) {\n  /** @type {Map<string, Function[]>} */\n  const handlersByKey = new Map();\n  rules.forEach((rule) => {\n    Object.keys(rule).forEach((key) => {\n      const fns = handlersByKey.get(key);\n      if (!fns) {\n        handlersByKey.set(key, [rule[key]]);\n      } else {\n        fns.push(rule[key]);\n      }\n    });\n  });\n\n  /** @type {{[key: string]: Function}} */\n  const rule = {};\n  handlersByKey.forEach((fns, key) => {\n    rule[key] = function mergedHandler(node) {\n      fns.forEach((fn) => {\n        fn(node);\n      });\n    };\n  });\n\n  return rule;\n}\n\nfunction componentRule(rule, context) {\n  const pragma = pragmaUtil.getFromContext(context);\n  const sourceCode = context.getSourceCode();\n  const components = new Components();\n  const wrapperFunctions = getWrapperFunctions(context, pragma);\n\n  // Utilities for component detection\n  const utils = {\n    /**\n     * Check if variable is destructured from pragma import\n     *\n     * @param {string} variable The variable name to check\n     * @returns {Boolean} True if createElement is destructured from the pragma\n     */\n    isDestructuredFromPragmaImport(variable) {\n      return isDestructuredFromPragmaImport(variable, context);\n    },\n\n    isReturningJSX(ASTNode, strict) {\n      return jsxUtil.isReturningJSX(ASTNode, context, strict, true);\n    },\n\n    isReturningJSXOrNull(ASTNode, strict) {\n      return jsxUtil.isReturningJSX(ASTNode, context, strict);\n    },\n\n    isReturningOnlyNull(ASTNode) {\n      return jsxUtil.isReturningOnlyNull(ASTNode, context);\n    },\n\n    getPragmaComponentWrapper(node) {\n      let isPragmaComponentWrapper;\n      let currentNode = node;\n      let prevNode;\n      do {\n        currentNode = currentNode.parent;\n        isPragmaComponentWrapper = this.isPragmaComponentWrapper(currentNode);\n        if (isPragmaComponentWrapper) {\n          prevNode = currentNode;\n        }\n      } while (isPragmaComponentWrapper);\n\n      return prevNode;\n    },\n\n    getComponentNameFromJSXElement(node) {\n      if (node.type !== 'JSXElement') {\n        return null;\n      }\n      if (node.openingElement && node.openingElement.name && node.openingElement.name.name) {\n        return node.openingElement.name.name;\n      }\n      return null;\n    },\n\n    /**\n     * Getting the first JSX element's name.\n     * @param {object} node\n     * @returns {string | null}\n     */\n    getNameOfWrappedComponent(node) {\n      if (node.length < 1) {\n        return null;\n      }\n      const body = node[0].body;\n      if (!body) {\n        return null;\n      }\n      if (body.type === 'JSXElement') {\n        return this.getComponentNameFromJSXElement(body);\n      }\n      if (body.type === 'BlockStatement') {\n        const jsxElement = body.body.find((item) => item.type === 'ReturnStatement');\n        return jsxElement\n          && jsxElement.argument\n          && this.getComponentNameFromJSXElement(jsxElement.argument);\n      }\n      return null;\n    },\n\n    /**\n     * Get the list of names of components created till now\n     * @returns {string | boolean}\n     */\n    getDetectedComponents() {\n      const list = components.list();\n      return values(list).filter((val) => {\n        if (val.node.type === 'ClassDeclaration') {\n          return true;\n        }\n        if (\n          val.node.type === 'ArrowFunctionExpression'\n          && val.node.parent\n          && val.node.parent.type === 'VariableDeclarator'\n          && val.node.parent.id\n        ) {\n          return true;\n        }\n        return false;\n      }).map((val) => {\n        if (val.node.type === 'ArrowFunctionExpression') return val.node.parent.id.name;\n        return val.node.id && val.node.id.name;\n      });\n    },\n\n    /**\n     * It will check whether memo/forwardRef is wrapping existing component or\n     * creating a new one.\n     * @param {object} node\n     * @returns {boolean}\n     */\n    nodeWrapsComponent(node) {\n      const childComponent = this.getNameOfWrappedComponent(node.arguments);\n      const componentList = this.getDetectedComponents();\n      return !!childComponent && arrayIncludes(componentList, childComponent);\n    },\n\n    isPragmaComponentWrapper(node) {\n      if (!node || node.type !== 'CallExpression') {\n        return false;\n      }\n\n      return wrapperFunctions.some((wrapperFunction) => {\n        if (node.callee.type === 'MemberExpression') {\n          return wrapperFunction.object\n            && wrapperFunction.object === node.callee.object.name\n            && wrapperFunction.property === node.callee.property.name\n            && !this.nodeWrapsComponent(node);\n        }\n        return wrapperFunction.property === node.callee.name\n          && (!wrapperFunction.object\n            // Functions coming from the current pragma need special handling\n            || (wrapperFunction.object === pragma && this.isDestructuredFromPragmaImport(node.callee.name))\n          );\n      });\n    },\n\n    /**\n     * Find a return statement in the current node\n     *\n     * @param {ASTNode} node The AST node being checked\n     */\n    findReturnStatement: astUtil.findReturnStatement,\n\n    /**\n     * Get the parent component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentComponent() {\n      return (\n        componentUtil.getParentES6Component(context)\n        || componentUtil.getParentES5Component(context)\n        || utils.getParentStatelessComponent()\n      );\n    },\n\n    /**\n     * @param {ASTNode} node\n     * @returns {boolean}\n     */\n    isInAllowedPositionForComponent(node) {\n      switch (node.parent.type) {\n        case 'VariableDeclarator':\n        case 'AssignmentExpression':\n        case 'Property':\n        case 'ReturnStatement':\n        case 'ExportDefaultDeclaration':\n        case 'ArrowFunctionExpression': {\n          return true;\n        }\n        case 'SequenceExpression': {\n          return utils.isInAllowedPositionForComponent(node.parent)\n            && node === node.parent.expressions[node.parent.expressions.length - 1];\n        }\n        default:\n          return false;\n      }\n    },\n\n    /**\n     * Get node if node is a stateless component, or node.parent in cases like\n     * `React.memo` or `React.forwardRef`. Otherwise returns `undefined`.\n     * @param {ASTNode} node\n     * @returns {ASTNode | undefined}\n     */\n    getStatelessComponent(node) {\n      const parent = node.parent;\n      if (\n        node.type === 'FunctionDeclaration'\n        && (!node.id || isFirstLetterCapitalized(node.id.name))\n        && utils.isReturningJSXOrNull(node)\n      ) {\n        return node;\n      }\n\n      if (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression') {\n        const isMethod = parent.type === 'Property' && parent.method;\n        const isPropertyAssignment = parent.type === 'AssignmentExpression'\n          && parent.left.type === 'MemberExpression';\n        const isModuleExportsAssignment = isPropertyAssignment\n          && parent.left.object.name === 'module'\n          && parent.left.property.name === 'exports';\n\n        if (node.parent.type === 'ExportDefaultDeclaration') {\n          if (utils.isReturningJSX(node)) {\n            return node;\n          }\n          return undefined;\n        }\n\n        if (node.parent.type === 'VariableDeclarator' && utils.isReturningJSXOrNull(node)) {\n          if (isFirstLetterCapitalized(node.parent.id.name)) {\n            return node;\n          }\n          return undefined;\n        }\n\n        // case: const any = () => { return (props) => null }\n        // case: const any = () => (props) => null\n        if (\n          (node.parent.type === 'ReturnStatement' || (node.parent.type === 'ArrowFunctionExpression' && node.parent.expression))\n          && !utils.isReturningJSX(node)\n        ) {\n          return undefined;\n        }\n\n        // case: any = () => { return => null }\n        // case: any = () => null\n        if (node.parent.type === 'AssignmentExpression' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n          if (isFirstLetterCapitalized(node.parent.left.name)) {\n            return node;\n          }\n          return undefined;\n        }\n\n        // case: any = () => () => null\n        if (node.parent.type === 'ArrowFunctionExpression' && node.parent.parent.type === 'AssignmentExpression' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n          if (isFirstLetterCapitalized(node.parent.parent.left.name)) {\n            return node;\n          }\n          return undefined;\n        }\n\n        // case: { any: () => () => null }\n        if (node.parent.type === 'ArrowFunctionExpression' && node.parent.parent.type === 'Property' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n          if (isFirstLetterCapitalized(node.parent.parent.key.name)) {\n            return node;\n          }\n          return undefined;\n        }\n\n        // case: any = function() {return function() {return null;};}\n        if (node.parent.type === 'ReturnStatement') {\n          if (isFirstLetterCapitalized(node.id && node.id.name)) {\n            return node;\n          }\n          const functionExpr = node.parent.parent.parent;\n          if (functionExpr.parent.type === 'AssignmentExpression' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n            if (isFirstLetterCapitalized(functionExpr.parent.left.name)) {\n              return node;\n            }\n            return undefined;\n          }\n        }\n\n        // case: { any: function() {return function() {return null;};} }\n        if (node.parent.type === 'ReturnStatement') {\n          const functionExpr = node.parent.parent.parent;\n          if (functionExpr.parent.type === 'Property' && !isPropertyAssignment && utils.isReturningJSXOrNull(node)) {\n            if (isFirstLetterCapitalized(functionExpr.parent.key.name)) {\n              return node;\n            }\n            return undefined;\n          }\n        }\n\n        // for case abc = { [someobject.somekey]: props => { ... return not-jsx } }\n        if (node.parent && node.parent.key && node.parent.key.type === 'MemberExpression' && !utils.isReturningJSX(node) && !utils.isReturningOnlyNull(node)) {\n          return undefined;\n        }\n\n        // Case like `React.memo(() => <></>)` or `React.forwardRef(...)`\n        const pragmaComponentWrapper = utils.getPragmaComponentWrapper(node);\n        if (pragmaComponentWrapper && utils.isReturningJSXOrNull(node)) {\n          return pragmaComponentWrapper;\n        }\n\n        if (!(utils.isInAllowedPositionForComponent(node) && utils.isReturningJSXOrNull(node))) {\n          return undefined;\n        }\n\n        if (utils.isParentComponentNotStatelessComponent(node)) {\n          return undefined;\n        }\n\n        if (isMethod && !isFirstLetterCapitalized(node.parent.key.name)) {\n          return utils.isReturningJSX(node) ? node : undefined;\n        }\n\n        if (node.id) {\n          return isFirstLetterCapitalized(node.id.name) ? node : undefined;\n        }\n\n        if (\n          isPropertyAssignment\n          && !isModuleExportsAssignment\n          && !isFirstLetterCapitalized(parent.left.property.name)\n        ) {\n          return undefined;\n        }\n\n        if (parent.type === 'Property' && utils.isReturningOnlyNull(node)) {\n          return undefined;\n        }\n\n        return node;\n      }\n\n      return undefined;\n    },\n\n    /**\n     * Get the parent stateless component node from the current scope\n     *\n     * @returns {ASTNode} component node, null if we are not in a component\n     */\n    getParentStatelessComponent() {\n      let scope = context.getScope();\n      while (scope) {\n        const node = scope.block;\n        const statelessComponent = utils.getStatelessComponent(node);\n        if (statelessComponent) {\n          return statelessComponent;\n        }\n        scope = scope.upper;\n      }\n      return null;\n    },\n\n    /**\n     * Get the related component from a node\n     *\n     * @param {ASTNode} node The AST node being checked (must be a MemberExpression).\n     * @returns {ASTNode} component node, null if we cannot find the component\n     */\n    getRelatedComponent(node) {\n      let i;\n      let j;\n      let k;\n      let l;\n      let componentNode;\n      // Get the component path\n      const componentPath = [];\n      while (node) {\n        if (node.property && node.property.type === 'Identifier') {\n          componentPath.push(node.property.name);\n        }\n        if (node.object && node.object.type === 'Identifier') {\n          componentPath.push(node.object.name);\n        }\n        node = node.object;\n      }\n      componentPath.reverse();\n      const componentName = componentPath.slice(0, componentPath.length - 1).join('.');\n\n      // Find the variable in the current scope\n      const variableName = componentPath.shift();\n      if (!variableName) {\n        return null;\n      }\n      let variableInScope;\n      const variables = variableUtil.variablesInScope(context);\n      for (i = 0, j = variables.length; i < j; i++) {\n        if (variables[i].name === variableName) {\n          variableInScope = variables[i];\n          break;\n        }\n      }\n      if (!variableInScope) {\n        return null;\n      }\n\n      // Try to find the component using variable references\n      const refs = variableInScope.references;\n      refs.some((ref) => {\n        let refId = ref.identifier;\n        if (refId.parent && refId.parent.type === 'MemberExpression') {\n          refId = refId.parent;\n        }\n        if (sourceCode.getText(refId) !== componentName) {\n          return false;\n        }\n        if (refId.type === 'MemberExpression') {\n          componentNode = refId.parent.right;\n        } else if (\n          refId.parent\n          && refId.parent.type === 'VariableDeclarator'\n          && refId.parent.init\n          && refId.parent.init.type !== 'Identifier'\n        ) {\n          componentNode = refId.parent.init;\n        }\n        return true;\n      });\n\n      if (componentNode) {\n        // Return the component\n        return components.add(componentNode, 1);\n      }\n\n      // Try to find the component using variable declarations\n      const defs = variableInScope.defs;\n      const defInScope = defs.find((def) => (\n        def.type === 'ClassName'\n        || def.type === 'FunctionName'\n        || def.type === 'Variable'\n      ));\n      if (!defInScope || !defInScope.node) {\n        return null;\n      }\n      componentNode = defInScope.node.init || defInScope.node;\n\n      // Traverse the node properties to the component declaration\n      for (i = 0, j = componentPath.length; i < j; i++) {\n        if (!componentNode.properties) {\n          continue; // eslint-disable-line no-continue\n        }\n        for (k = 0, l = componentNode.properties.length; k < l; k++) {\n          if (componentNode.properties[k].key && componentNode.properties[k].key.name === componentPath[i]) {\n            componentNode = componentNode.properties[k];\n            break;\n          }\n        }\n        if (!componentNode || !componentNode.value) {\n          return null;\n        }\n        componentNode = componentNode.value;\n      }\n\n      // Return the component\n      return components.add(componentNode, 1);\n    },\n\n    isParentComponentNotStatelessComponent(node) {\n      return !!(\n        node.parent\n        && node.parent.key\n        && node.parent.key.type === 'Identifier'\n        // custom component functions must start with a capital letter (returns false otherwise)\n        && node.parent.key.name.charAt(0) === node.parent.key.name.charAt(0).toLowerCase()\n        // react render function cannot have params\n        && !!(node.params || []).length\n      );\n    },\n\n    /**\n     * Identify whether a node (CallExpression) is a call to a React hook\n     *\n     * @param {ASTNode} node The AST node being searched. (expects CallExpression)\n     * @param {('useCallback'|'useContext'|'useDebugValue'|'useEffect'|'useImperativeHandle'|'useLayoutEffect'|'useMemo'|'useReducer'|'useRef'|'useState')[]} [expectedHookNames] React hook names to which search is limited.\n     * @returns {Boolean} True if the node is a call to a React hook\n     */\n    isReactHookCall(node, expectedHookNames) {\n      if (node.type !== 'CallExpression') {\n        return false;\n      }\n\n      const defaultReactImports = components.getDefaultReactImports();\n      const namedReactImports = components.getNamedReactImports();\n\n      const defaultReactImportName = defaultReactImports\n        && defaultReactImports[0]\n        && defaultReactImports[0].local.name;\n      const reactHookImportSpecifiers = namedReactImports\n        && namedReactImports.filter((specifier) => USE_HOOK_PREFIX_REGEX.test(specifier.imported.name));\n      const reactHookImportNames = reactHookImportSpecifiers\n        && fromEntries(reactHookImportSpecifiers.map((specifier) => [specifier.local.name, specifier.imported.name]));\n\n      const isPotentialReactHookCall = defaultReactImportName\n        && node.callee.type === 'MemberExpression'\n        && node.callee.object.type === 'Identifier'\n        && node.callee.object.name === defaultReactImportName\n        && node.callee.property.type === 'Identifier'\n        && node.callee.property.name.match(USE_HOOK_PREFIX_REGEX);\n\n      const isPotentialHookCall = reactHookImportNames\n        && node.callee.type === 'Identifier'\n        && node.callee.name.match(USE_HOOK_PREFIX_REGEX);\n\n      const scope = (isPotentialReactHookCall || isPotentialHookCall) && context.getScope();\n\n      const reactResolvedDefs = isPotentialReactHookCall\n        && scope.references\n        && scope.references.find(\n          (reference) => reference.identifier.name === defaultReactImportName\n        ).resolved.defs;\n\n      const isReactShadowed = isPotentialReactHookCall && reactResolvedDefs\n        && reactResolvedDefs.some((reactDef) => reactDef.type !== 'ImportBinding');\n\n      const potentialHookReference = isPotentialHookCall\n        && scope.references\n        && scope.references.find(\n          (reference) => reactHookImportNames[reference.identifier.name]\n        );\n\n      const hookResolvedDefs = potentialHookReference && potentialHookReference.resolved.defs;\n      const localHookName = (isPotentialReactHookCall && node.callee.property.name)\n        || (isPotentialHookCall && potentialHookReference && node.callee.name);\n      const isHookShadowed = isPotentialHookCall\n        && hookResolvedDefs\n        && hookResolvedDefs.some(\n          (hookDef) => hookDef.name.name === localHookName\n          && hookDef.type !== 'ImportBinding'\n        );\n\n      const isHookCall = (isPotentialReactHookCall && !isReactShadowed)\n        || (isPotentialHookCall && localHookName && !isHookShadowed);\n\n      if (!isHookCall) {\n        return false;\n      }\n\n      if (!expectedHookNames) {\n        return true;\n      }\n\n      return arrayIncludes(\n        expectedHookNames,\n        (reactHookImportNames && reactHookImportNames[localHookName]) || localHookName\n      );\n    },\n  };\n\n  // Component detection instructions\n  const detectionInstructions = {\n    CallExpression(node) {\n      if (!utils.isPragmaComponentWrapper(node)) {\n        return;\n      }\n      if (node.arguments.length > 0 && astUtil.isFunctionLikeExpression(node.arguments[0])) {\n        components.add(node, 2);\n      }\n    },\n\n    ClassExpression(node) {\n      if (!componentUtil.isES6Component(node, context)) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    ClassDeclaration(node) {\n      if (!componentUtil.isES6Component(node, context)) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    ObjectExpression(node) {\n      if (!componentUtil.isES5Component(node, context)) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    FunctionExpression(node) {\n      if (node.async) {\n        components.add(node, 0);\n        return;\n      }\n\n      const component = utils.getParentComponent();\n      if (\n        !component\n        || (component.parent && component.parent.type === 'JSXExpressionContainer')\n      ) {\n        // Ban the node if we cannot find a parent component\n        components.add(node, 0);\n        return;\n      }\n      components.add(component, 2);\n    },\n\n    FunctionDeclaration(node) {\n      if (node.async) {\n        components.add(node, 0);\n        return;\n      }\n\n      node = utils.getParentComponent();\n      if (!node) {\n        return;\n      }\n      components.add(node, 2);\n    },\n\n    ArrowFunctionExpression(node) {\n      if (node.async) {\n        components.add(node, 0);\n        return;\n      }\n\n      const component = utils.getParentComponent();\n      if (\n        !component\n        || (component.parent && component.parent.type === 'JSXExpressionContainer')\n      ) {\n        // Ban the node if we cannot find a parent component\n        components.add(node, 0);\n        return;\n      }\n      components.add(component, 2);\n    },\n\n    ThisExpression(node) {\n      const component = utils.getParentStatelessComponent();\n      if (!component || !/Function/.test(component.type) || !node.parent.property) {\n        return;\n      }\n      // Ban functions accessing a property on a ThisExpression\n      components.add(node, 0);\n    },\n  };\n\n  // Detect React import specifiers\n  const reactImportInstructions = {\n    ImportDeclaration(node) {\n      const isReactImported = node.source.type === 'Literal' && node.source.value === 'react';\n      if (!isReactImported) {\n        return;\n      }\n\n      node.specifiers.forEach((specifier) => {\n        if (specifier.type === 'ImportDefaultSpecifier') {\n          components.addDefaultReactImport(specifier);\n        }\n        if (specifier.type === 'ImportSpecifier') {\n          components.addNamedReactImport(specifier);\n        }\n      });\n    },\n  };\n\n  const ruleInstructions = rule(context, components, utils);\n  const propTypesInstructions = propTypesUtil(context, components, utils);\n  const usedPropTypesInstructions = usedPropTypesUtil(context, components, utils);\n  const defaultPropsInstructions = defaultPropsUtil(context, components, utils);\n\n  const mergedRule = mergeRules([\n    detectionInstructions,\n    propTypesInstructions,\n    usedPropTypesInstructions,\n    defaultPropsInstructions,\n    reactImportInstructions,\n    ruleInstructions,\n  ]);\n\n  return mergedRule;\n}\n\nmodule.exports = Object.assign(Components, {\n  detect(rule) {\n    return componentRule.bind(this, rule);\n  },\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}