{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;\n\nconst code_1 = require(\"./code\");\n\nclass ValueError extends Error {\n  constructor(name) {\n    super(`CodeGen: \"code\" for ${name} not defined`);\n    this.value = name.value;\n  }\n\n}\n\nvar UsedValueState;\n\n(function (UsedValueState) {\n  UsedValueState[UsedValueState[\"Started\"] = 0] = \"Started\";\n  UsedValueState[UsedValueState[\"Completed\"] = 1] = \"Completed\";\n})(UsedValueState = exports.UsedValueState || (exports.UsedValueState = {}));\n\nexports.varKinds = {\n  const: new code_1.Name(\"const\"),\n  let: new code_1.Name(\"let\"),\n  var: new code_1.Name(\"var\")\n};\n\nclass Scope {\n  constructor() {\n    let {\n      prefixes,\n      parent\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this._names = {};\n    this._prefixes = prefixes;\n    this._parent = parent;\n  }\n\n  toName(nameOrPrefix) {\n    return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);\n  }\n\n  name(prefix) {\n    return new code_1.Name(this._newName(prefix));\n  }\n\n  _newName(prefix) {\n    const ng = this._names[prefix] || this._nameGroup(prefix);\n\n    return `${prefix}${ng.index++}`;\n  }\n\n  _nameGroup(prefix) {\n    var _a, _b;\n\n    if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`);\n    }\n\n    return this._names[prefix] = {\n      prefix,\n      index: 0\n    };\n  }\n\n}\n\nexports.Scope = Scope;\n\nclass ValueScopeName extends code_1.Name {\n  constructor(prefix, nameStr) {\n    super(nameStr);\n    this.prefix = prefix;\n  }\n\n  setValue(value, _ref) {\n    let {\n      property,\n      itemIndex\n    } = _ref;\n    this.value = value;\n    this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;\n  }\n\n}\n\nexports.ValueScopeName = ValueScopeName;\nconst line = (0, code_1._)`\\n`;\n\nclass ValueScope extends Scope {\n  constructor(opts) {\n    super(opts);\n    this._values = {};\n    this._scope = opts.scope;\n    this.opts = { ...opts,\n      _n: opts.lines ? line : code_1.nil\n    };\n  }\n\n  get() {\n    return this._scope;\n  }\n\n  name(prefix) {\n    return new ValueScopeName(prefix, this._newName(prefix));\n  }\n\n  value(nameOrPrefix, value) {\n    var _a;\n\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\");\n    const name = this.toName(nameOrPrefix);\n    const {\n      prefix\n    } = name;\n    const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;\n    let vs = this._values[prefix];\n\n    if (vs) {\n      const _name = vs.get(valueKey);\n\n      if (_name) return _name;\n    } else {\n      vs = this._values[prefix] = new Map();\n    }\n\n    vs.set(valueKey, name);\n    const s = this._scope[prefix] || (this._scope[prefix] = []);\n    const itemIndex = s.length;\n    s[itemIndex] = value.ref;\n    name.setValue(value, {\n      property: prefix,\n      itemIndex\n    });\n    return name;\n  }\n\n  getValue(prefix, keyOrRef) {\n    const vs = this._values[prefix];\n    if (!vs) return;\n    return vs.get(keyOrRef);\n  }\n\n  scopeRefs(scopeName) {\n    let values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._values;\n    return this._reduceValues(values, name => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n      return (0, code_1._)`${scopeName}${name.scopePath}`;\n    });\n  }\n\n  scopeCode() {\n    let values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._values;\n    let usedValues = arguments.length > 1 ? arguments[1] : undefined;\n    let getCode = arguments.length > 2 ? arguments[2] : undefined;\n    return this._reduceValues(values, name => {\n      if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`);\n      return name.value.code;\n    }, usedValues, getCode);\n  }\n\n  _reduceValues(values, valueCode) {\n    let usedValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let getCode = arguments.length > 3 ? arguments[3] : undefined;\n    let code = code_1.nil;\n\n    for (const prefix in values) {\n      const vs = values[prefix];\n      if (!vs) continue;\n      const nameSet = usedValues[prefix] = usedValues[prefix] || new Map();\n      vs.forEach(name => {\n        if (nameSet.has(name)) return;\n        nameSet.set(name, UsedValueState.Started);\n        let c = valueCode(name);\n\n        if (c) {\n          const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;\n          code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;\n        } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {\n          code = (0, code_1._)`${code}${c}${this.opts._n}`;\n        } else {\n          throw new ValueError(name);\n        }\n\n        nameSet.set(name, UsedValueState.Completed);\n      });\n    }\n\n    return code;\n  }\n\n}\n\nexports.ValueScope = ValueScope;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAeA,MAAMA,UAAN,SAAyBC,KAAzB,CAA8B;EAE5BC,YAAYC,IAAZ,EAAgC;IAC9B,MAAM,uBAAuBA,IAAI,cAAjC;IACA,KAAKC,KAAL,GAAaD,IAAI,CAACC,KAAlB;EACD;;AAL2B;;AA6B9B,IAAYC,cAAZ;;AAAA,WAAYA,cAAZ,EAA0B;EACxBA;EACAA;AACD,CAHD,EAAYA,cAAc,GAAdC,oDAAc,EAAd,CAAZ;;AASaA,mBAAW;EACtBC,KAAK,EAAE,IAAIC,WAAJ,CAAS,OAAT,CADe;EAEtBC,GAAG,EAAE,IAAID,WAAJ,CAAS,KAAT,CAFiB;EAGtBE,GAAG,EAAE,IAAIF,WAAJ,CAAS,KAAT;AAHiB,CAAX;;AAMb,MAAaG,KAAb,CAAkB;EAKhBT,cAAiD;IAAA,IAArC;MAACU,QAAD;MAAWC;IAAX,CAAqC,uEAAF,EAAE;IAJ9B,cAA2C,EAA3C;IAKjB,KAAKC,SAAL,GAAiBF,QAAjB;IACA,KAAKG,OAAL,GAAeF,MAAf;EACD;;EAEDG,MAAM,CAACC,YAAD,EAA4B;IAChC,OAAOA,YAAY,YAAYT,WAAxB,GAA+BS,YAA/B,GAA8C,KAAKd,IAAL,CAAUc,YAAV,CAArD;EACD;;EAEDd,IAAI,CAACe,MAAD,EAAe;IACjB,OAAO,IAAIV,WAAJ,CAAS,KAAKW,QAAL,CAAcD,MAAd,CAAT,CAAP;EACD;;EAESC,QAAQ,CAACD,MAAD,EAAe;IAC/B,MAAME,EAAE,GAAG,KAAKC,MAAL,CAAYH,MAAZ,KAAuB,KAAKI,UAAL,CAAgBJ,MAAhB,CAAlC;;IACA,OAAO,GAAGA,MAAM,GAAGE,EAAE,CAACG,KAAH,EAAU,EAA7B;EACD;;EAEOD,UAAU,CAACJ,MAAD,EAAe;;;IAC/B,IAAI,kBAAKH,OAAL,MAAY,IAAZ,IAAYS,aAAZ,GAAY,MAAZ,GAAYA,GAAEV,SAAd,MAAuB,IAAvB,IAAuBW,aAAvB,GAAuB,MAAvB,GAAuBA,GAAEC,GAAF,CAAMR,MAAN,CAAvB,KAAyC,KAAKJ,SAAL,IAAkB,CAAC,KAAKA,SAAL,CAAeY,GAAf,CAAmBR,MAAnB,CAAhE,EAA6F;MAC3F,MAAM,IAAIjB,KAAJ,CAAU,oBAAoBiB,MAAM,gCAApC,CAAN;IACD;;IACD,OAAQ,KAAKG,MAAL,CAAYH,MAAZ,IAAsB;MAACA,MAAD;MAASK,KAAK,EAAE;IAAhB,CAA9B;EACD;;AA5Be;;AAAlBjB;;AAoCA,MAAaqB,cAAb,SAAoCnB,WAApC,CAAwC;EAKtCN,YAAYgB,MAAZ,EAA4BU,OAA5B,EAA2C;IACzC,MAAMA,OAAN;IACA,KAAKV,MAAL,GAAcA,MAAd;EACD;;EAEDW,QAAQ,CAACzB,KAAD,QAAmD;IAAA,IAAhC;MAAC0B,QAAD;MAAWC;IAAX,CAAgC;IACzD,KAAK3B,KAAL,GAAaA,KAAb;IACA,KAAK4B,SAAL,GAAiB,aAAC,IAAI,IAAIxB,WAAJ,CAASsB,QAAT,CAAkB,IAAIC,SAAS,GAArD;EACD;;AAbqC;;AAAxCzB;AAoBA,MAAM2B,IAAI,GAAG,aAAC,IAAd;;AAEA,MAAaC,UAAb,SAAgCvB,KAAhC,CAAqC;EAKnCT,YAAYiC,IAAZ,EAAmC;IACjC,MAAMA,IAAN;IALiB,eAAuB,EAAvB;IAMjB,KAAKC,MAAL,GAAcD,IAAI,CAACE,KAAnB;IACA,KAAKF,IAAL,GAAY,EAAC,GAAGA,IAAJ;MAAUG,EAAE,EAAEH,IAAI,CAACI,KAAL,GAAaN,IAAb,GAAoBzB;IAAlC,CAAZ;EACD;;EAEDgC,GAAG;IACD,OAAO,KAAKJ,MAAZ;EACD;;EAEDjC,IAAI,CAACe,MAAD,EAAe;IACjB,OAAO,IAAIS,cAAJ,CAAmBT,MAAnB,EAA2B,KAAKC,QAAL,CAAcD,MAAd,CAA3B,CAAP;EACD;;EAEDd,KAAK,CAACa,YAAD,EAAwCb,KAAxC,EAAwD;;;IAC3D,IAAIA,KAAK,CAACqC,GAAN,KAAcC,SAAlB,EAA6B,MAAM,IAAIzC,KAAJ,CAAU,sCAAV,CAAN;IAC7B,MAAME,IAAI,GAAG,KAAKa,MAAL,CAAYC,YAAZ,CAAb;IACA,MAAM;MAACC;IAAD,IAAWf,IAAjB;IACA,MAAMwC,QAAQ,GAAG,WAAK,CAACC,GAAN,MAAS,IAAT,IAASpB,aAAT,GAASA,EAAT,GAAapB,KAAK,CAACqC,GAApC;IACA,IAAII,EAAE,GAAG,KAAKC,OAAL,CAAa5B,MAAb,CAAT;;IACA,IAAI2B,EAAJ,EAAQ;MACN,MAAME,KAAK,GAAGF,EAAE,CAACL,GAAH,CAAOG,QAAP,CAAd;;MACA,IAAII,KAAJ,EAAW,OAAOA,KAAP;IACZ,CAHD,MAGO;MACLF,EAAE,GAAG,KAAKC,OAAL,CAAa5B,MAAb,IAAuB,IAAI8B,GAAJ,EAA5B;IACD;;IACDH,EAAE,CAACI,GAAH,CAAON,QAAP,EAAiBxC,IAAjB;IAEA,MAAM+C,CAAC,GAAG,KAAKd,MAAL,CAAYlB,MAAZ,MAAwB,KAAKkB,MAAL,CAAYlB,MAAZ,IAAsB,EAA9C,CAAV;IACA,MAAMa,SAAS,GAAGmB,CAAC,CAACC,MAApB;IACAD,CAAC,CAACnB,SAAD,CAAD,GAAe3B,KAAK,CAACqC,GAArB;IACAtC,IAAI,CAAC0B,QAAL,CAAczB,KAAd,EAAqB;MAAC0B,QAAQ,EAAEZ,MAAX;MAAmBa;IAAnB,CAArB;IACA,OAAO5B,IAAP;EACD;;EAEDiD,QAAQ,CAAClC,MAAD,EAAiBmC,QAAjB,EAAkC;IACxC,MAAMR,EAAE,GAAG,KAAKC,OAAL,CAAa5B,MAAb,CAAX;IACA,IAAI,CAAC2B,EAAL,EAAS;IACT,OAAOA,EAAE,CAACL,GAAH,CAAOa,QAAP,CAAP;EACD;;EAEDC,SAAS,CAACC,SAAD,EAAqE;IAAA,IAAnDC,MAAmD,uEAAZ,KAAKV,OAAO;IAC5E,OAAO,KAAKW,aAAL,CAAmBD,MAAnB,EAA4BrD,IAAD,IAAyB;MACzD,IAAIA,IAAI,CAAC6B,SAAL,KAAmBU,SAAvB,EAAkC,MAAM,IAAIzC,KAAJ,CAAU,kBAAkBE,IAAI,gBAAhC,CAAN;MAClC,OAAO,aAAC,GAAGoD,SAAS,GAAGpD,IAAI,CAAC6B,SAAS,EAArC;IACD,CAHM,CAAP;EAID;;EAED0B,SAAS,GAG0C;IAAA,IAFjDF,MAEiD,uEAFV,KAAKV,OAEK;IAAA,IADjDa,UACiD;IAAA,IAAjDC,OAAiD;IAEjD,OAAO,KAAKH,aAAL,CACLD,MADK,EAEJrD,IAAD,IAAyB;MACvB,IAAIA,IAAI,CAACC,KAAL,KAAesC,SAAnB,EAA8B,MAAM,IAAIzC,KAAJ,CAAU,kBAAkBE,IAAI,gBAAhC,CAAN;MAC9B,OAAOA,IAAI,CAACC,KAAL,CAAWyD,IAAlB;IACD,CALI,EAMLF,UANK,EAOLC,OAPK,CAAP;EASD;;EAEOH,aAAa,CACnBD,MADmB,EAEnBM,SAFmB,EAI8B;IAAA,IADjDH,UACiD,uEADnB,EACmB;IAAA,IAAjDC,OAAiD;IAEjD,IAAIC,IAAI,GAASrD,UAAjB;;IACA,KAAK,MAAMU,MAAX,IAAqBsC,MAArB,EAA6B;MAC3B,MAAMX,EAAE,GAAGW,MAAM,CAACtC,MAAD,CAAjB;MACA,IAAI,CAAC2B,EAAL,EAAS;MACT,MAAMkB,OAAO,GAAIJ,UAAU,CAACzC,MAAD,CAAV,GAAqByC,UAAU,CAACzC,MAAD,CAAV,IAAsB,IAAI8B,GAAJ,EAA5D;MACAH,EAAE,CAACmB,OAAH,CAAY7D,IAAD,IAAyB;QAClC,IAAI4D,OAAO,CAACrC,GAAR,CAAYvB,IAAZ,CAAJ,EAAuB;QACvB4D,OAAO,CAACd,GAAR,CAAY9C,IAAZ,EAAkBE,cAAc,CAAC4D,OAAjC;QACA,IAAIC,CAAC,GAAGJ,SAAS,CAAC3D,IAAD,CAAjB;;QACA,IAAI+D,CAAJ,EAAO;UACL,MAAMC,GAAG,GAAG,KAAKhC,IAAL,CAAUiC,GAAV,GAAgB9D,iBAASI,GAAzB,GAA+BJ,iBAASC,KAApD;UACAsD,IAAI,GAAG,aAAC,GAAGA,IAAI,GAAGM,GAAG,IAAIhE,IAAI,MAAM+D,CAAC,IAAI,KAAK/B,IAAL,CAAUG,EAAE,EAApD;QACD,CAHD,MAGO,IAAK4B,CAAC,GAAGN,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAGzD,IAAH,CAAhB,EAA2B;UAChC0D,IAAI,GAAG,aAAC,GAAGA,IAAI,GAAGK,CAAC,GAAG,KAAK/B,IAAL,CAAUG,EAAE,EAAlC;QACD,CAFM,MAEA;UACL,MAAM,IAAItC,UAAJ,CAAeG,IAAf,CAAN;QACD;;QACD4D,OAAO,CAACd,GAAR,CAAY9C,IAAZ,EAAkBE,cAAc,CAACgE,SAAjC;MACD,CAbD;IAcD;;IACD,OAAOR,IAAP;EACD;;AAhGkC;;AAArCvD","names":["ValueError","Error","constructor","name","value","UsedValueState","exports","const","code_1","let","var","Scope","prefixes","parent","_prefixes","_parent","toName","nameOrPrefix","prefix","_newName","ng","_names","_nameGroup","index","_a","_b","has","ValueScopeName","nameStr","setValue","property","itemIndex","scopePath","line","ValueScope","opts","_scope","scope","_n","lines","get","ref","undefined","valueKey","key","vs","_values","_name","Map","set","s","length","getValue","keyOrRef","scopeRefs","scopeName","values","_reduceValues","scopeCode","usedValues","getCode","code","valueCode","nameSet","forEach","Started","c","def","es5","Completed"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\ajv-formats\\node_modules\\ajv\\lib\\compile\\codegen\\scope.ts"],"sourcesContent":["import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n"]},"metadata":{},"sourceType":"script"}