{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lilconfigSync = exports.lilconfig = exports.defaultLoaders = void 0;\n\nconst path = require(\"path\");\n\nconst fs = require(\"fs\");\n\nconst os = require(\"os\");\n\nconst fsReadFileAsync = fs.promises.readFile;\n\nfunction getDefaultSearchPlaces(name) {\n  return ['package.json', `.${name}rc.json`, `.${name}rc.js`, `${name}.config.js`, `.${name}rc.cjs`, `${name}.config.cjs`];\n}\n\nfunction getSearchPaths(startDir, stopDir) {\n  return startDir.split(path.sep).reduceRight((acc, _, ind, arr) => {\n    const currentPath = arr.slice(0, ind + 1).join(path.sep);\n    if (!acc.passedStopDir) acc.searchPlaces.push(currentPath || path.sep);\n    if (currentPath === stopDir) acc.passedStopDir = true;\n    return acc;\n  }, {\n    searchPlaces: [],\n    passedStopDir: false\n  }).searchPlaces;\n}\n\nexports.defaultLoaders = Object.freeze({\n  '.js': require,\n  '.json': require,\n  '.cjs': require,\n\n  noExt(_, content) {\n    return JSON.parse(content);\n  }\n\n});\n\nfunction getExtDesc(ext) {\n  return ext === 'noExt' ? 'files without extensions' : `extension \"${ext}\"`;\n}\n\nfunction getOptions(name) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const conf = {\n    stopDir: os.homedir(),\n    searchPlaces: getDefaultSearchPlaces(name),\n    ignoreEmptySearchPlaces: true,\n    transform: x => x,\n    packageProp: [name],\n    ...options,\n    loaders: { ...exports.defaultLoaders,\n      ...options.loaders\n    }\n  };\n  conf.searchPlaces.forEach(place => {\n    const key = path.extname(place) || 'noExt';\n    const loader = conf.loaders[key];\n\n    if (!loader) {\n      throw new Error(`No loader specified for ${getExtDesc(key)}, so searchPlaces item \"${place}\" is invalid`);\n    }\n\n    if (typeof loader !== 'function') {\n      throw new Error(`loader for ${getExtDesc(key)} is not a function (type provided: \"${typeof loader}\"), so searchPlaces item \"${place}\" is invalid`);\n    }\n  });\n  return conf;\n}\n\nfunction getPackageProp(props, obj) {\n  if (typeof props === 'string' && props in obj) return obj[props];\n  return (Array.isArray(props) ? props : props.split('.')).reduce((acc, prop) => acc === undefined ? acc : acc[prop], obj) || null;\n}\n\nfunction getSearchItems(searchPlaces, searchPaths) {\n  return searchPaths.reduce((acc, searchPath) => {\n    searchPlaces.forEach(fileName => acc.push({\n      fileName,\n      filepath: path.join(searchPath, fileName),\n      loaderKey: path.extname(fileName) || 'noExt'\n    }));\n    return acc;\n  }, []);\n}\n\nfunction validateFilePath(filepath) {\n  if (!filepath) throw new Error('load must pass a non-empty string');\n}\n\nfunction validateLoader(loader, ext) {\n  if (!loader) throw new Error(`No loader specified for extension \"${ext}\"`);\n  if (typeof loader !== 'function') throw new Error('loader is not a function');\n}\n\nfunction lilconfig(name, options) {\n  const {\n    ignoreEmptySearchPlaces,\n    loaders,\n    packageProp,\n    searchPlaces,\n    stopDir,\n    transform\n  } = getOptions(name, options);\n  return {\n    async search() {\n      let searchFrom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();\n      const searchPaths = getSearchPaths(searchFrom, stopDir);\n      const result = {\n        config: null,\n        filepath: ''\n      };\n      const searchItems = getSearchItems(searchPlaces, searchPaths);\n\n      for (const {\n        fileName,\n        filepath,\n        loaderKey\n      } of searchItems) {\n        try {\n          await fs.promises.access(filepath);\n        } catch (_a) {\n          continue;\n        }\n\n        const content = String(await fsReadFileAsync(filepath));\n        const loader = loaders[loaderKey];\n\n        if (fileName === 'package.json') {\n          const pkg = await loader(filepath, content);\n          const maybeConfig = getPackageProp(packageProp, pkg);\n\n          if (maybeConfig != null) {\n            result.config = maybeConfig;\n            result.filepath = filepath;\n            break;\n          }\n\n          continue;\n        }\n\n        const isEmpty = content.trim() === '';\n        if (isEmpty && ignoreEmptySearchPlaces) continue;\n\n        if (isEmpty) {\n          result.isEmpty = true;\n          result.config = undefined;\n        } else {\n          validateLoader(loader, loaderKey);\n          result.config = await loader(filepath, content);\n        }\n\n        result.filepath = filepath;\n        break;\n      }\n\n      if (result.filepath === '' && result.config === null) return transform(null);\n      return transform(result);\n    },\n\n    async load(filepath) {\n      validateFilePath(filepath);\n      const absPath = path.resolve(process.cwd(), filepath);\n      const {\n        base,\n        ext\n      } = path.parse(absPath);\n      const loaderKey = ext || 'noExt';\n      const loader = loaders[loaderKey];\n      validateLoader(loader, loaderKey);\n      const content = String(await fsReadFileAsync(absPath));\n\n      if (base === 'package.json') {\n        const pkg = await loader(absPath, content);\n        return transform({\n          config: getPackageProp(packageProp, pkg),\n          filepath: absPath\n        });\n      }\n\n      const result = {\n        config: null,\n        filepath: absPath\n      };\n      const isEmpty = content.trim() === '';\n      if (isEmpty && ignoreEmptySearchPlaces) return transform({\n        config: undefined,\n        filepath: absPath,\n        isEmpty: true\n      });\n      result.config = isEmpty ? undefined : await loader(absPath, content);\n      return transform(isEmpty ? { ...result,\n        isEmpty,\n        config: undefined\n      } : result);\n    }\n\n  };\n}\n\nexports.lilconfig = lilconfig;\n\nfunction lilconfigSync(name, options) {\n  const {\n    ignoreEmptySearchPlaces,\n    loaders,\n    packageProp,\n    searchPlaces,\n    stopDir,\n    transform\n  } = getOptions(name, options);\n  return {\n    search() {\n      let searchFrom = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();\n      const searchPaths = getSearchPaths(searchFrom, stopDir);\n      const result = {\n        config: null,\n        filepath: ''\n      };\n      const searchItems = getSearchItems(searchPlaces, searchPaths);\n\n      for (const {\n        fileName,\n        filepath,\n        loaderKey\n      } of searchItems) {\n        try {\n          fs.accessSync(filepath);\n        } catch (_a) {\n          continue;\n        }\n\n        const loader = loaders[loaderKey];\n        const content = String(fs.readFileSync(filepath));\n\n        if (fileName === 'package.json') {\n          const pkg = loader(filepath, content);\n          const maybeConfig = getPackageProp(packageProp, pkg);\n\n          if (maybeConfig != null) {\n            result.config = maybeConfig;\n            result.filepath = filepath;\n            break;\n          }\n\n          continue;\n        }\n\n        const isEmpty = content.trim() === '';\n        if (isEmpty && ignoreEmptySearchPlaces) continue;\n\n        if (isEmpty) {\n          result.isEmpty = true;\n          result.config = undefined;\n        } else {\n          validateLoader(loader, loaderKey);\n          result.config = loader(filepath, content);\n        }\n\n        result.filepath = filepath;\n        break;\n      }\n\n      if (result.filepath === '' && result.config === null) return transform(null);\n      return transform(result);\n    },\n\n    load(filepath) {\n      validateFilePath(filepath);\n      const absPath = path.resolve(process.cwd(), filepath);\n      const {\n        base,\n        ext\n      } = path.parse(absPath);\n      const loaderKey = ext || 'noExt';\n      const loader = loaders[loaderKey];\n      validateLoader(loader, loaderKey);\n      const content = String(fs.readFileSync(absPath));\n\n      if (base === 'package.json') {\n        const pkg = loader(absPath, content);\n        return transform({\n          config: getPackageProp(packageProp, pkg),\n          filepath: absPath\n        });\n      }\n\n      const result = {\n        config: null,\n        filepath: absPath\n      };\n      const isEmpty = content.trim() === '';\n      if (isEmpty && ignoreEmptySearchPlaces) return transform({\n        filepath: absPath,\n        config: undefined,\n        isEmpty: true\n      });\n      result.config = isEmpty ? undefined : loader(absPath, content);\n      return transform(isEmpty ? { ...result,\n        isEmpty,\n        config: undefined\n      } : result);\n    }\n\n  };\n}\n\nexports.lilconfigSync = lilconfigSync;","map":{"version":3,"names":["Object","defineProperty","exports","value","lilconfigSync","lilconfig","defaultLoaders","path","require","fs","os","fsReadFileAsync","promises","readFile","getDefaultSearchPlaces","name","getSearchPaths","startDir","stopDir","split","sep","reduceRight","acc","_","ind","arr","currentPath","slice","join","passedStopDir","searchPlaces","push","freeze","noExt","content","JSON","parse","getExtDesc","ext","getOptions","options","conf","homedir","ignoreEmptySearchPlaces","transform","x","packageProp","loaders","forEach","place","key","extname","loader","Error","getPackageProp","props","obj","Array","isArray","reduce","prop","undefined","getSearchItems","searchPaths","searchPath","fileName","filepath","loaderKey","validateFilePath","validateLoader","search","searchFrom","process","cwd","result","config","searchItems","access","_a","String","pkg","maybeConfig","isEmpty","trim","load","absPath","resolve","base","accessSync","readFileSync"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/lilconfig/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lilconfigSync = exports.lilconfig = exports.defaultLoaders = void 0;\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst os = require(\"os\");\nconst fsReadFileAsync = fs.promises.readFile;\nfunction getDefaultSearchPlaces(name) {\n    return [\n        'package.json',\n        `.${name}rc.json`,\n        `.${name}rc.js`,\n        `${name}.config.js`,\n        `.${name}rc.cjs`,\n        `${name}.config.cjs`,\n    ];\n}\nfunction getSearchPaths(startDir, stopDir) {\n    return startDir\n        .split(path.sep)\n        .reduceRight((acc, _, ind, arr) => {\n        const currentPath = arr.slice(0, ind + 1).join(path.sep);\n        if (!acc.passedStopDir)\n            acc.searchPlaces.push(currentPath || path.sep);\n        if (currentPath === stopDir)\n            acc.passedStopDir = true;\n        return acc;\n    }, { searchPlaces: [], passedStopDir: false }).searchPlaces;\n}\nexports.defaultLoaders = Object.freeze({\n    '.js': require,\n    '.json': require,\n    '.cjs': require,\n    noExt(_, content) {\n        return JSON.parse(content);\n    },\n});\nfunction getExtDesc(ext) {\n    return ext === 'noExt' ? 'files without extensions' : `extension \"${ext}\"`;\n}\nfunction getOptions(name, options = {}) {\n    const conf = {\n        stopDir: os.homedir(),\n        searchPlaces: getDefaultSearchPlaces(name),\n        ignoreEmptySearchPlaces: true,\n        transform: (x) => x,\n        packageProp: [name],\n        ...options,\n        loaders: { ...exports.defaultLoaders, ...options.loaders },\n    };\n    conf.searchPlaces.forEach(place => {\n        const key = path.extname(place) || 'noExt';\n        const loader = conf.loaders[key];\n        if (!loader) {\n            throw new Error(`No loader specified for ${getExtDesc(key)}, so searchPlaces item \"${place}\" is invalid`);\n        }\n        if (typeof loader !== 'function') {\n            throw new Error(`loader for ${getExtDesc(key)} is not a function (type provided: \"${typeof loader}\"), so searchPlaces item \"${place}\" is invalid`);\n        }\n    });\n    return conf;\n}\nfunction getPackageProp(props, obj) {\n    if (typeof props === 'string' && props in obj)\n        return obj[props];\n    return ((Array.isArray(props) ? props : props.split('.')).reduce((acc, prop) => (acc === undefined ? acc : acc[prop]), obj) || null);\n}\nfunction getSearchItems(searchPlaces, searchPaths) {\n    return searchPaths.reduce((acc, searchPath) => {\n        searchPlaces.forEach(fileName => acc.push({\n            fileName,\n            filepath: path.join(searchPath, fileName),\n            loaderKey: path.extname(fileName) || 'noExt',\n        }));\n        return acc;\n    }, []);\n}\nfunction validateFilePath(filepath) {\n    if (!filepath)\n        throw new Error('load must pass a non-empty string');\n}\nfunction validateLoader(loader, ext) {\n    if (!loader)\n        throw new Error(`No loader specified for extension \"${ext}\"`);\n    if (typeof loader !== 'function')\n        throw new Error('loader is not a function');\n}\nfunction lilconfig(name, options) {\n    const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform, } = getOptions(name, options);\n    return {\n        async search(searchFrom = process.cwd()) {\n            const searchPaths = getSearchPaths(searchFrom, stopDir);\n            const result = {\n                config: null,\n                filepath: '',\n            };\n            const searchItems = getSearchItems(searchPlaces, searchPaths);\n            for (const { fileName, filepath, loaderKey } of searchItems) {\n                try {\n                    await fs.promises.access(filepath);\n                }\n                catch (_a) {\n                    continue;\n                }\n                const content = String(await fsReadFileAsync(filepath));\n                const loader = loaders[loaderKey];\n                if (fileName === 'package.json') {\n                    const pkg = await loader(filepath, content);\n                    const maybeConfig = getPackageProp(packageProp, pkg);\n                    if (maybeConfig != null) {\n                        result.config = maybeConfig;\n                        result.filepath = filepath;\n                        break;\n                    }\n                    continue;\n                }\n                const isEmpty = content.trim() === '';\n                if (isEmpty && ignoreEmptySearchPlaces)\n                    continue;\n                if (isEmpty) {\n                    result.isEmpty = true;\n                    result.config = undefined;\n                }\n                else {\n                    validateLoader(loader, loaderKey);\n                    result.config = await loader(filepath, content);\n                }\n                result.filepath = filepath;\n                break;\n            }\n            if (result.filepath === '' && result.config === null)\n                return transform(null);\n            return transform(result);\n        },\n        async load(filepath) {\n            validateFilePath(filepath);\n            const absPath = path.resolve(process.cwd(), filepath);\n            const { base, ext } = path.parse(absPath);\n            const loaderKey = ext || 'noExt';\n            const loader = loaders[loaderKey];\n            validateLoader(loader, loaderKey);\n            const content = String(await fsReadFileAsync(absPath));\n            if (base === 'package.json') {\n                const pkg = await loader(absPath, content);\n                return transform({\n                    config: getPackageProp(packageProp, pkg),\n                    filepath: absPath,\n                });\n            }\n            const result = {\n                config: null,\n                filepath: absPath,\n            };\n            const isEmpty = content.trim() === '';\n            if (isEmpty && ignoreEmptySearchPlaces)\n                return transform({\n                    config: undefined,\n                    filepath: absPath,\n                    isEmpty: true,\n                });\n            result.config = isEmpty\n                ? undefined\n                : await loader(absPath, content);\n            return transform(isEmpty ? { ...result, isEmpty, config: undefined } : result);\n        },\n    };\n}\nexports.lilconfig = lilconfig;\nfunction lilconfigSync(name, options) {\n    const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform, } = getOptions(name, options);\n    return {\n        search(searchFrom = process.cwd()) {\n            const searchPaths = getSearchPaths(searchFrom, stopDir);\n            const result = {\n                config: null,\n                filepath: '',\n            };\n            const searchItems = getSearchItems(searchPlaces, searchPaths);\n            for (const { fileName, filepath, loaderKey } of searchItems) {\n                try {\n                    fs.accessSync(filepath);\n                }\n                catch (_a) {\n                    continue;\n                }\n                const loader = loaders[loaderKey];\n                const content = String(fs.readFileSync(filepath));\n                if (fileName === 'package.json') {\n                    const pkg = loader(filepath, content);\n                    const maybeConfig = getPackageProp(packageProp, pkg);\n                    if (maybeConfig != null) {\n                        result.config = maybeConfig;\n                        result.filepath = filepath;\n                        break;\n                    }\n                    continue;\n                }\n                const isEmpty = content.trim() === '';\n                if (isEmpty && ignoreEmptySearchPlaces)\n                    continue;\n                if (isEmpty) {\n                    result.isEmpty = true;\n                    result.config = undefined;\n                }\n                else {\n                    validateLoader(loader, loaderKey);\n                    result.config = loader(filepath, content);\n                }\n                result.filepath = filepath;\n                break;\n            }\n            if (result.filepath === '' && result.config === null)\n                return transform(null);\n            return transform(result);\n        },\n        load(filepath) {\n            validateFilePath(filepath);\n            const absPath = path.resolve(process.cwd(), filepath);\n            const { base, ext } = path.parse(absPath);\n            const loaderKey = ext || 'noExt';\n            const loader = loaders[loaderKey];\n            validateLoader(loader, loaderKey);\n            const content = String(fs.readFileSync(absPath));\n            if (base === 'package.json') {\n                const pkg = loader(absPath, content);\n                return transform({\n                    config: getPackageProp(packageProp, pkg),\n                    filepath: absPath,\n                });\n            }\n            const result = {\n                config: null,\n                filepath: absPath,\n            };\n            const isEmpty = content.trim() === '';\n            if (isEmpty && ignoreEmptySearchPlaces)\n                return transform({\n                    filepath: absPath,\n                    config: undefined,\n                    isEmpty: true,\n                });\n            result.config = isEmpty ? undefined : loader(absPath, content);\n            return transform(isEmpty ? { ...result, isEmpty, config: undefined } : result);\n        },\n    };\n}\nexports.lilconfigSync = lilconfigSync;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}