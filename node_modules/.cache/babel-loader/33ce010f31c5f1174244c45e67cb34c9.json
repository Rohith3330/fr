{"ast":null,"code":"/**\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\n * @author Ilya Volodin\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst eslintUtils = require(\"eslint-utils\"); //----------------------------------------------------------------------\n// Helpers\n//----------------------------------------------------------------------\n\n/**\n * Check if the given node is callee of a `NewExpression` node\n * @param {ASTNode} node node to check\n * @returns {boolean} True if the node is callee of a `NewExpression` node\n * @private\n */\n\n\nfunction isCalleeOfNewExpression(node) {\n  const maybeCallee = node.parent.type === \"ChainExpression\" ? node.parent : node;\n  return maybeCallee.parent.type === \"NewExpression\" && maybeCallee.parent.callee === maybeCallee;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"Require parentheses around immediate `function` invocations\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/wrap-iife\"\n    },\n    schema: [{\n      enum: [\"outside\", \"inside\", \"any\"]\n    }, {\n      type: \"object\",\n      properties: {\n        functionPrototypeMethods: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      wrapInvocation: \"Wrap an immediate function invocation in parentheses.\",\n      wrapExpression: \"Wrap only the function expression in parens.\",\n      moveInvocation: \"Move the invocation into the parens that contain the function.\"\n    }\n  },\n\n  create(context) {\n    const style = context.options[0] || \"outside\";\n    const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;\n    const sourceCode = context.getSourceCode();\n    /**\n     * Check if the node is wrapped in any (). All parens count: grouping parens and parens for constructs such as if()\n     * @param {ASTNode} node node to evaluate\n     * @returns {boolean} True if it is wrapped in any parens\n     * @private\n     */\n\n    function isWrappedInAnyParens(node) {\n      return astUtils.isParenthesised(sourceCode, node);\n    }\n    /**\n     * Check if the node is wrapped in grouping (). Parens for constructs such as if() don't count\n     * @param {ASTNode} node node to evaluate\n     * @returns {boolean} True if it is wrapped in grouping parens\n     * @private\n     */\n\n\n    function isWrappedInGroupingParens(node) {\n      return eslintUtils.isParenthesized(1, node, sourceCode);\n    }\n    /**\n     * Get the function node from an IIFE\n     * @param {ASTNode} node node to evaluate\n     * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist\n     */\n\n\n    function getFunctionNodeFromIIFE(node) {\n      const callee = astUtils.skipChainExpression(node.callee);\n\n      if (callee.type === \"FunctionExpression\") {\n        return callee;\n      }\n\n      if (includeFunctionPrototypeMethods && callee.type === \"MemberExpression\" && callee.object.type === \"FunctionExpression\" && (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")) {\n        return callee.object;\n      }\n\n      return null;\n    }\n\n    return {\n      CallExpression(node) {\n        const innerNode = getFunctionNodeFromIIFE(node);\n\n        if (!innerNode) {\n          return;\n        }\n\n        const isCallExpressionWrapped = isWrappedInAnyParens(node),\n              isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);\n\n        if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"wrapInvocation\",\n\n            fix(fixer) {\n              const nodeToSurround = style === \"inside\" ? innerNode : node;\n              return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\n            }\n\n          });\n        } else if (style === \"inside\" && !isFunctionExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"wrapExpression\",\n\n            fix(fixer) {\n              // The outer call expression will always be wrapped at this point.\n              if (isWrappedInGroupingParens(node) && !isCalleeOfNewExpression(node)) {\n                /*\n                 * Parenthesize the function expression and remove unnecessary grouping parens around the call expression.\n                 * Replace the range between the end of the function expression and the end of the call expression.\n                 * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.\n                 */\n                const parenAfter = sourceCode.getTokenAfter(node);\n                return fixer.replaceTextRange([innerNode.range[1], parenAfter.range[1]], `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`);\n              }\n              /*\n               * Call expression is wrapped in mandatory parens such as if(), or in necessary grouping parens.\n               * These parens cannot be removed, so just parenthesize the function expression.\n               */\n\n\n              return fixer.replaceText(innerNode, `(${sourceCode.getText(innerNode)})`);\n            }\n\n          });\n        } else if (style === \"outside\" && !isCallExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"moveInvocation\",\n\n            fix(fixer) {\n              /*\n               * The inner function expression will always be wrapped at this point.\n               * It's only necessary to replace the range between the end of the function expression\n               * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`\n               * should get replaced with `(bar))`.\n               */\n              const parenAfter = sourceCode.getTokenAfter(innerNode);\n              return fixer.replaceTextRange([parenAfter.range[0], node.range[1]], `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","eslintUtils","isCalleeOfNewExpression","node","maybeCallee","parent","type","callee","module","exports","meta","docs","description","recommended","url","schema","enum","properties","functionPrototypeMethods","default","additionalProperties","fixable","messages","wrapInvocation","wrapExpression","moveInvocation","create","context","style","options","includeFunctionPrototypeMethods","sourceCode","getSourceCode","isWrappedInAnyParens","isParenthesised","isWrappedInGroupingParens","isParenthesized","getFunctionNodeFromIIFE","skipChainExpression","object","getStaticPropertyName","CallExpression","innerNode","isCallExpressionWrapped","isFunctionExpressionWrapped","report","messageId","fix","fixer","nodeToSurround","replaceText","getText","parenAfter","getTokenAfter","replaceTextRange","range","slice"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/wrap-iife.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst eslintUtils = require(\"eslint-utils\");\n\n//----------------------------------------------------------------------\n// Helpers\n//----------------------------------------------------------------------\n\n/**\n * Check if the given node is callee of a `NewExpression` node\n * @param {ASTNode} node node to check\n * @returns {boolean} True if the node is callee of a `NewExpression` node\n * @private\n */\nfunction isCalleeOfNewExpression(node) {\n    const maybeCallee = node.parent.type === \"ChainExpression\"\n        ? node.parent\n        : node;\n\n    return (\n        maybeCallee.parent.type === \"NewExpression\" &&\n        maybeCallee.parent.callee === maybeCallee\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"layout\",\n\n        docs: {\n            description: \"Require parentheses around immediate `function` invocations\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/wrap-iife\"\n        },\n\n        schema: [\n            {\n                enum: [\"outside\", \"inside\", \"any\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    functionPrototypeMethods: {\n                        type: \"boolean\",\n                        default: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ],\n\n        fixable: \"code\",\n        messages: {\n            wrapInvocation: \"Wrap an immediate function invocation in parentheses.\",\n            wrapExpression: \"Wrap only the function expression in parens.\",\n            moveInvocation: \"Move the invocation into the parens that contain the function.\"\n        }\n    },\n\n    create(context) {\n\n        const style = context.options[0] || \"outside\";\n        const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;\n\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Check if the node is wrapped in any (). All parens count: grouping parens and parens for constructs such as if()\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if it is wrapped in any parens\n         * @private\n         */\n        function isWrappedInAnyParens(node) {\n            return astUtils.isParenthesised(sourceCode, node);\n        }\n\n        /**\n         * Check if the node is wrapped in grouping (). Parens for constructs such as if() don't count\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if it is wrapped in grouping parens\n         * @private\n         */\n        function isWrappedInGroupingParens(node) {\n            return eslintUtils.isParenthesized(1, node, sourceCode);\n        }\n\n        /**\n         * Get the function node from an IIFE\n         * @param {ASTNode} node node to evaluate\n         * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist\n         */\n        function getFunctionNodeFromIIFE(node) {\n            const callee = astUtils.skipChainExpression(node.callee);\n\n            if (callee.type === \"FunctionExpression\") {\n                return callee;\n            }\n\n            if (includeFunctionPrototypeMethods &&\n                callee.type === \"MemberExpression\" &&\n                callee.object.type === \"FunctionExpression\" &&\n                (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")\n            ) {\n                return callee.object;\n            }\n\n            return null;\n        }\n\n\n        return {\n            CallExpression(node) {\n                const innerNode = getFunctionNodeFromIIFE(node);\n\n                if (!innerNode) {\n                    return;\n                }\n\n                const isCallExpressionWrapped = isWrappedInAnyParens(node),\n                    isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);\n\n                if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"wrapInvocation\",\n                        fix(fixer) {\n                            const nodeToSurround = style === \"inside\" ? innerNode : node;\n\n                            return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\n                        }\n                    });\n                } else if (style === \"inside\" && !isFunctionExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"wrapExpression\",\n                        fix(fixer) {\n\n                            // The outer call expression will always be wrapped at this point.\n\n                            if (isWrappedInGroupingParens(node) && !isCalleeOfNewExpression(node)) {\n\n                                /*\n                                 * Parenthesize the function expression and remove unnecessary grouping parens around the call expression.\n                                 * Replace the range between the end of the function expression and the end of the call expression.\n                                 * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.\n                                 */\n\n                                const parenAfter = sourceCode.getTokenAfter(node);\n\n                                return fixer.replaceTextRange(\n                                    [innerNode.range[1], parenAfter.range[1]],\n                                    `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`\n                                );\n                            }\n\n                            /*\n                             * Call expression is wrapped in mandatory parens such as if(), or in necessary grouping parens.\n                             * These parens cannot be removed, so just parenthesize the function expression.\n                             */\n\n                            return fixer.replaceText(innerNode, `(${sourceCode.getText(innerNode)})`);\n                        }\n                    });\n                } else if (style === \"outside\" && !isCallExpressionWrapped) {\n                    context.report({\n                        node,\n                        messageId: \"moveInvocation\",\n                        fix(fixer) {\n\n                            /*\n                             * The inner function expression will always be wrapped at this point.\n                             * It's only necessary to replace the range between the end of the function expression\n                             * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`\n                             * should get replaced with `(bar))`.\n                             */\n                            const parenAfter = sourceCode.getTokenAfter(innerNode);\n\n                            return fixer.replaceTextRange(\n                                [parenAfter.range[0], node.range[1]],\n                                `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`\n                            );\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}