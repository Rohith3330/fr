{"ast":null,"code":"/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Bag of data used for formatting the `unusedVar` lint message.\n * @typedef {Object} UnusedVarMessageData\n * @property {string} varName The name of the unused var.\n * @property {'defined'|'assigned a value'} action Description of the vars state.\n * @property {string} additional Any additional info to be appended at the end.\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow unused variables\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unused-vars\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"all\", \"local\"]\n      }, {\n        type: \"object\",\n        properties: {\n          vars: {\n            enum: [\"all\", \"local\"]\n          },\n          varsIgnorePattern: {\n            type: \"string\"\n          },\n          args: {\n            enum: [\"all\", \"after-used\", \"none\"]\n          },\n          ignoreRestSiblings: {\n            type: \"boolean\"\n          },\n          argsIgnorePattern: {\n            type: \"string\"\n          },\n          caughtErrors: {\n            enum: [\"all\", \"none\"]\n          },\n          caughtErrorsIgnorePattern: {\n            type: \"string\"\n          },\n          destructuredArrayIgnorePattern: {\n            type: \"string\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n    const config = {\n      vars: \"all\",\n      args: \"after-used\",\n      ignoreRestSiblings: false,\n      caughtErrors: \"none\"\n    };\n    const firstOption = context.options[0];\n\n    if (firstOption) {\n      if (typeof firstOption === \"string\") {\n        config.vars = firstOption;\n      } else {\n        config.vars = firstOption.vars || config.vars;\n        config.args = firstOption.args || config.args;\n        config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n        config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n        if (firstOption.varsIgnorePattern) {\n          config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n        }\n\n        if (firstOption.argsIgnorePattern) {\n          config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n        }\n\n        if (firstOption.caughtErrorsIgnorePattern) {\n          config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n        }\n\n        if (firstOption.destructuredArrayIgnorePattern) {\n          config.destructuredArrayIgnorePattern = new RegExp(firstOption.destructuredArrayIgnorePattern, \"u\");\n        }\n      }\n    }\n    /**\n     * Generates the message data about the variable being defined and unused,\n     * including the ignore pattern if configured.\n     * @param {Variable} unusedVar eslint-scope variable object.\n     * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n     */\n\n\n    function getDefinedMessageData(unusedVar) {\n      const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n      let type;\n      let pattern;\n\n      if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n        type = \"args\";\n        pattern = config.caughtErrorsIgnorePattern.toString();\n      } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n        type = \"args\";\n        pattern = config.argsIgnorePattern.toString();\n      } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n        type = \"vars\";\n        pattern = config.varsIgnorePattern.toString();\n      }\n\n      const additional = type ? `. Allowed unused ${type} must match ${pattern}` : \"\";\n      return {\n        varName: unusedVar.name,\n        action: \"defined\",\n        additional\n      };\n    }\n    /**\n     * Generate the warning message about the variable being\n     * assigned and unused, including the ignore pattern if configured.\n     * @param {Variable} unusedVar eslint-scope variable object.\n     * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n     */\n\n\n    function getAssignedMessageData(unusedVar) {\n      const def = unusedVar.defs[0];\n      let additional = \"\";\n\n      if (config.destructuredArrayIgnorePattern && def && def.name.parent.type === \"ArrayPattern\") {\n        additional = `. Allowed unused elements of array destructuring patterns must match ${config.destructuredArrayIgnorePattern.toString()}`;\n      } else if (config.varsIgnorePattern) {\n        additional = `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}`;\n      }\n\n      return {\n        varName: unusedVar.name,\n        action: \"assigned a value\",\n        additional\n      };\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n\n    const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n    /**\n     * Determines if a given variable is being exported from a module.\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {boolean} True if the variable is exported, false if not.\n     * @private\n     */\n\n    function isExported(variable) {\n      const definition = variable.defs[0];\n\n      if (definition) {\n        let node = definition.node;\n\n        if (node.type === \"VariableDeclarator\") {\n          node = node.parent;\n        } else if (definition.type === \"Parameter\") {\n          return false;\n        }\n\n        return node.parent.type.indexOf(\"Export\") === 0;\n      }\n\n      return false;\n    }\n    /**\n     * Checks whether a node is a sibling of the rest property or not.\n     * @param {ASTNode} node a node to check\n     * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.\n     */\n\n\n    function hasRestSibling(node) {\n      return node.type === \"Property\" && node.parent.type === \"ObjectPattern\" && REST_PROPERTY_TYPE.test(node.parent.properties[node.parent.properties.length - 1].type);\n    }\n    /**\n     * Determines if a variable has a sibling rest property\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {boolean} True if the variable is exported, false if not.\n     * @private\n     */\n\n\n    function hasRestSpreadSibling(variable) {\n      if (config.ignoreRestSiblings) {\n        const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n        const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n        return hasRestSiblingDefinition || hasRestSiblingReference;\n      }\n\n      return false;\n    }\n    /**\n     * Determines if a reference is a read operation.\n     * @param {Reference} ref An eslint-scope Reference\n     * @returns {boolean} whether the given reference represents a read operation\n     * @private\n     */\n\n\n    function isReadRef(ref) {\n      return ref.isRead();\n    }\n    /**\n     * Determine if an identifier is referencing an enclosing function name.\n     * @param {Reference} ref The reference to check.\n     * @param {ASTNode[]} nodes The candidate function nodes.\n     * @returns {boolean} True if it's a self-reference, false if not.\n     * @private\n     */\n\n\n    function isSelfReference(ref, nodes) {\n      let scope = ref.from;\n\n      while (scope) {\n        if (nodes.includes(scope.block)) {\n          return true;\n        }\n\n        scope = scope.upper;\n      }\n\n      return false;\n    }\n    /**\n     * Gets a list of function definitions for a specified variable.\n     * @param {Variable} variable eslint-scope variable object.\n     * @returns {ASTNode[]} Function nodes.\n     * @private\n     */\n\n\n    function getFunctionDefinitions(variable) {\n      const functionDefinitions = [];\n      variable.defs.forEach(def => {\n        const {\n          type,\n          node\n        } = def; // FunctionDeclarations\n\n        if (type === \"FunctionName\") {\n          functionDefinitions.push(node);\n        } // FunctionExpressions\n\n\n        if (type === \"Variable\" && node.init && (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n          functionDefinitions.push(node.init);\n        }\n      });\n      return functionDefinitions;\n    }\n    /**\n     * Checks the position of given nodes.\n     * @param {ASTNode} inner A node which is expected as inside.\n     * @param {ASTNode} outer A node which is expected as outside.\n     * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n     * @private\n     */\n\n\n    function isInside(inner, outer) {\n      return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];\n    }\n    /**\n     * Checks whether a given node is unused expression or not.\n     * @param {ASTNode} node The node itself\n     * @returns {boolean} The node is an unused expression.\n     * @private\n     */\n\n\n    function isUnusedExpression(node) {\n      const parent = node.parent;\n\n      if (parent.type === \"ExpressionStatement\") {\n        return true;\n      }\n\n      if (parent.type === \"SequenceExpression\") {\n        const isLastExpression = parent.expressions[parent.expressions.length - 1] === node;\n\n        if (!isLastExpression) {\n          return true;\n        }\n\n        return isUnusedExpression(parent);\n      }\n\n      return false;\n    }\n    /**\n     * If a given reference is left-hand side of an assignment, this gets\n     * the right-hand side node of the assignment.\n     *\n     * In the following cases, this returns null.\n     *\n     * - The reference is not the LHS of an assignment expression.\n     * - The reference is inside of a loop.\n     * - The reference is inside of a function scope which is different from\n     *   the declaration.\n     * @param {eslint-scope.Reference} ref A reference to check.\n     * @param {ASTNode} prevRhsNode The previous RHS node.\n     * @returns {ASTNode|null} The RHS node or null.\n     * @private\n     */\n\n\n    function getRhsNode(ref, prevRhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      const refScope = ref.from.variableScope;\n      const varScope = ref.resolved.scope.variableScope;\n      const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n      /*\n       * Inherits the previous node if this reference is in the node.\n       * This is for `a = a + a`-like code.\n       */\n\n      if (prevRhsNode && isInside(id, prevRhsNode)) {\n        return prevRhsNode;\n      }\n\n      if (parent.type === \"AssignmentExpression\" && isUnusedExpression(parent) && id === parent.left && !canBeUsedLater) {\n        return parent.right;\n      }\n\n      return null;\n    }\n    /**\n     * Checks whether a given function node is stored to somewhere or not.\n     * If the function node is stored, the function can be used later.\n     * @param {ASTNode} funcNode A function node to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} `true` if under the following conditions:\n     *      - the funcNode is assigned to a variable.\n     *      - the funcNode is bound as an argument of a function call.\n     *      - the function is bound to a property and the object satisfies above conditions.\n     * @private\n     */\n\n\n    function isStorableFunction(funcNode, rhsNode) {\n      let node = funcNode;\n      let parent = funcNode.parent;\n\n      while (parent && isInside(parent, rhsNode)) {\n        switch (parent.type) {\n          case \"SequenceExpression\":\n            if (parent.expressions[parent.expressions.length - 1] !== node) {\n              return false;\n            }\n\n            break;\n\n          case \"CallExpression\":\n          case \"NewExpression\":\n            return parent.callee !== node;\n\n          case \"AssignmentExpression\":\n          case \"TaggedTemplateExpression\":\n          case \"YieldExpression\":\n            return true;\n\n          default:\n            if (STATEMENT_TYPE.test(parent.type)) {\n              /*\n               * If it encountered statements, this is a complex pattern.\n               * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\n               */\n              return true;\n            }\n\n        }\n\n        node = parent;\n        parent = parent.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Checks whether a given Identifier node exists inside of a function node which can be used later.\n     *\n     * \"can be used later\" means:\n     * - the function is assigned to a variable.\n     * - the function is bound to a property and the object can be used later.\n     * - the function is bound as an argument of a function call.\n     *\n     * If a reference exists in a function which can be used later, the reference is read when the function is called.\n     * @param {ASTNode} id An Identifier node to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n     * @private\n     */\n\n\n    function isInsideOfStorableFunction(id, rhsNode) {\n      const funcNode = astUtils.getUpperFunction(id);\n      return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);\n    }\n    /**\n     * Checks whether a given reference is a read to update itself or not.\n     * @param {eslint-scope.Reference} ref A reference to check.\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n     * @returns {boolean} The reference is a read to update itself.\n     * @private\n     */\n\n\n    function isReadForItself(ref, rhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      return ref.isRead() && ( // self update. e.g. `a += 1`, `a++`\n      parent.type === \"AssignmentExpression\" && parent.left === id && isUnusedExpression(parent) || parent.type === \"UpdateExpression\" && isUnusedExpression(parent) || // in RHS of an assignment for itself. e.g. `a = a + 1`\n      rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));\n    }\n    /**\n     * Determine if an identifier is used either in for-in or for-of loops.\n     * @param {Reference} ref The reference to check.\n     * @returns {boolean} whether reference is used in the for-in loops\n     * @private\n     */\n\n\n    function isForInOfRef(ref) {\n      let target = ref.identifier.parent; // \"for (var ...) { return; }\"\n\n      if (target.type === \"VariableDeclarator\") {\n        target = target.parent.parent;\n      }\n\n      if (target.type !== \"ForInStatement\" && target.type !== \"ForOfStatement\") {\n        return false;\n      } // \"for (...) { return; }\"\n\n\n      if (target.body.type === \"BlockStatement\") {\n        target = target.body.body[0]; // \"for (...) return;\"\n      } else {\n        target = target.body;\n      } // For empty loop body\n\n\n      if (!target) {\n        return false;\n      }\n\n      return target.type === \"ReturnStatement\";\n    }\n    /**\n     * Determines if the variable is used.\n     * @param {Variable} variable The variable to check.\n     * @returns {boolean} True if the variable is used\n     * @private\n     */\n\n\n    function isUsedVariable(variable) {\n      const functionNodes = getFunctionDefinitions(variable),\n            isFunctionDefinition = functionNodes.length > 0;\n      let rhsNode = null;\n      return variable.references.some(ref => {\n        if (isForInOfRef(ref)) {\n          return true;\n        }\n\n        const forItself = isReadForItself(ref, rhsNode);\n        rhsNode = getRhsNode(ref, rhsNode);\n        return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));\n      });\n    }\n    /**\n     * Checks whether the given variable is after the last used parameter.\n     * @param {eslint-scope.Variable} variable The variable to check.\n     * @returns {boolean} `true` if the variable is defined after the last\n     * used parameter.\n     */\n\n\n    function isAfterLastUsedArg(variable) {\n      const def = variable.defs[0];\n      const params = context.getDeclaredVariables(def.node);\n      const posteriorParams = params.slice(params.indexOf(variable) + 1); // If any used parameters occur after this parameter, do not report.\n\n      return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n    }\n    /**\n     * Gets an array of variables without read references.\n     * @param {Scope} scope an eslint-scope Scope object.\n     * @param {Variable[]} unusedVars an array that saving result.\n     * @returns {Variable[]} unused variables of the scope and descendant scopes.\n     * @private\n     */\n\n\n    function collectUnusedVariables(scope, unusedVars) {\n      const variables = scope.variables;\n      const childScopes = scope.childScopes;\n      let i, l;\n\n      if (scope.type !== \"global\" || config.vars === \"all\") {\n        for (i = 0, l = variables.length; i < l; ++i) {\n          const variable = variables[i]; // skip a variable of class itself name in the class scope\n\n          if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n            continue;\n          } // skip function expression names and variables marked with markVariableAsUsed()\n\n\n          if (scope.functionExpressionScope || variable.eslintUsed) {\n            continue;\n          } // skip implicit \"arguments\" variable\n\n\n          if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n            continue;\n          } // explicit global variables don't have definitions.\n\n\n          const def = variable.defs[0];\n\n          if (def) {\n            const type = def.type;\n            const refUsedInArrayPatterns = variable.references.some(ref => ref.identifier.parent.type === \"ArrayPattern\"); // skip elements of array destructuring patterns\n\n            if ((def.name.parent.type === \"ArrayPattern\" || refUsedInArrayPatterns) && config.destructuredArrayIgnorePattern && config.destructuredArrayIgnorePattern.test(def.name.name)) {\n              continue;\n            } // skip catch variables\n\n\n            if (type === \"CatchClause\") {\n              if (config.caughtErrors === \"none\") {\n                continue;\n              } // skip ignored parameters\n\n\n              if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n\n            if (type === \"Parameter\") {\n              // skip any setter argument\n              if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                continue;\n              } // if \"args\" option is \"none\", skip any parameter\n\n\n              if (config.args === \"none\") {\n                continue;\n              } // skip ignored parameters\n\n\n              if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                continue;\n              } // if \"args\" option is \"after-used\", skip used variables\n\n\n              if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                continue;\n              }\n            } else {\n              // skip ignored variables\n              if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n          }\n\n          if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n            unusedVars.push(variable);\n          }\n        }\n      }\n\n      for (i = 0, l = childScopes.length; i < l; ++i) {\n        collectUnusedVariables(childScopes[i], unusedVars);\n      }\n\n      return unusedVars;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      \"Program:exit\"(programNode) {\n        const unusedVars = collectUnusedVariables(context.getScope(), []);\n\n        for (let i = 0, l = unusedVars.length; i < l; ++i) {\n          const unusedVar = unusedVars[i]; // Report the first declaration.\n\n          if (unusedVar.defs.length > 0) {\n            // report last write reference, https://github.com/eslint/eslint/issues/14324\n            const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\n            let referenceToReport;\n\n            if (writeReferences.length > 0) {\n              referenceToReport = writeReferences[writeReferences.length - 1];\n            }\n\n            context.report({\n              node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],\n              messageId: \"unusedVar\",\n              data: unusedVar.references.some(ref => ref.isWrite()) ? getAssignedMessageData(unusedVar) : getDefinedMessageData(unusedVar)\n            }); // If there are no regular declaration, report the first `/*globals*/` comment directive.\n          } else if (unusedVar.eslintExplicitGlobalComments) {\n            const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n            context.report({\n              node: programNode,\n              loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n              messageId: \"unusedVar\",\n              data: getDefinedMessageData(unusedVar)\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","oneOf","enum","properties","vars","varsIgnorePattern","args","ignoreRestSiblings","argsIgnorePattern","caughtErrors","caughtErrorsIgnorePattern","destructuredArrayIgnorePattern","additionalProperties","messages","unusedVar","create","context","sourceCode","getSourceCode","REST_PROPERTY_TYPE","config","firstOption","options","RegExp","getDefinedMessageData","defType","defs","pattern","toString","additional","varName","name","action","getAssignedMessageData","def","parent","STATEMENT_TYPE","isExported","variable","definition","node","indexOf","hasRestSibling","test","length","hasRestSpreadSibling","hasRestSiblingDefinition","some","hasRestSiblingReference","references","ref","identifier","isReadRef","isRead","isSelfReference","nodes","scope","from","includes","block","upper","getFunctionDefinitions","functionDefinitions","forEach","push","init","isInside","inner","outer","range","isUnusedExpression","isLastExpression","expressions","getRhsNode","prevRhsNode","id","refScope","variableScope","varScope","resolved","canBeUsedLater","isInLoop","left","right","isStorableFunction","funcNode","rhsNode","callee","isInsideOfStorableFunction","getUpperFunction","isReadForItself","isForInOfRef","target","body","isUsedVariable","functionNodes","isFunctionDefinition","forItself","isAfterLastUsedArg","params","getDeclaredVariables","posteriorParams","slice","v","eslintUsed","collectUnusedVariables","unusedVars","variables","childScopes","i","l","identifiers","functionExpressionScope","refUsedInArrayPatterns","kind","isFunction","programNode","getScope","writeReferences","filter","isWrite","referenceToReport","report","messageId","data","eslintExplicitGlobalComments","directiveComment","loc","getNameLocationInGlobalDirectiveComment"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/no-unused-vars.js"],"sourcesContent":["/**\n * @fileoverview Rule to flag declared but unused variables\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * Bag of data used for formatting the `unusedVar` lint message.\n * @typedef {Object} UnusedVarMessageData\n * @property {string} varName The name of the unused var.\n * @property {'defined'|'assigned a value'} action Description of the vars state.\n * @property {string} additional Any additional info to be appended at the end.\n */\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow unused variables\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-unused-vars\"\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"all\", \"local\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            vars: {\n                                enum: [\"all\", \"local\"]\n                            },\n                            varsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            args: {\n                                enum: [\"all\", \"after-used\", \"none\"]\n                            },\n                            ignoreRestSiblings: {\n                                type: \"boolean\"\n                            },\n                            argsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            caughtErrors: {\n                                enum: [\"all\", \"none\"]\n                            },\n                            caughtErrorsIgnorePattern: {\n                                type: \"string\"\n                            },\n                            destructuredArrayIgnorePattern: {\n                                type: \"string\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ],\n\n        messages: {\n            unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n\n        const config = {\n            vars: \"all\",\n            args: \"after-used\",\n            ignoreRestSiblings: false,\n            caughtErrors: \"none\"\n        };\n\n        const firstOption = context.options[0];\n\n        if (firstOption) {\n            if (typeof firstOption === \"string\") {\n                config.vars = firstOption;\n            } else {\n                config.vars = firstOption.vars || config.vars;\n                config.args = firstOption.args || config.args;\n                config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n                config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n                if (firstOption.varsIgnorePattern) {\n                    config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.argsIgnorePattern) {\n                    config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.caughtErrorsIgnorePattern) {\n                    config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n                }\n\n                if (firstOption.destructuredArrayIgnorePattern) {\n                    config.destructuredArrayIgnorePattern = new RegExp(firstOption.destructuredArrayIgnorePattern, \"u\");\n                }\n            }\n        }\n\n        /**\n         * Generates the message data about the variable being defined and unused,\n         * including the ignore pattern if configured.\n         * @param {Variable} unusedVar eslint-scope variable object.\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n         */\n        function getDefinedMessageData(unusedVar) {\n            const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n            let type;\n            let pattern;\n\n            if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n                type = \"args\";\n                pattern = config.caughtErrorsIgnorePattern.toString();\n            } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n                type = \"args\";\n                pattern = config.argsIgnorePattern.toString();\n            } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n                type = \"vars\";\n                pattern = config.varsIgnorePattern.toString();\n            }\n\n            const additional = type ? `. Allowed unused ${type} must match ${pattern}` : \"\";\n\n            return {\n                varName: unusedVar.name,\n                action: \"defined\",\n                additional\n            };\n        }\n\n        /**\n         * Generate the warning message about the variable being\n         * assigned and unused, including the ignore pattern if configured.\n         * @param {Variable} unusedVar eslint-scope variable object.\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\n         */\n        function getAssignedMessageData(unusedVar) {\n            const def = unusedVar.defs[0];\n            let additional = \"\";\n\n            if (config.destructuredArrayIgnorePattern && def && def.name.parent.type === \"ArrayPattern\") {\n                additional = `. Allowed unused elements of array destructuring patterns must match ${config.destructuredArrayIgnorePattern.toString()}`;\n            } else if (config.varsIgnorePattern) {\n                additional = `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}`;\n            }\n\n            return {\n                varName: unusedVar.name,\n                action: \"assigned a value\",\n                additional\n            };\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n\n        /**\n         * Determines if a given variable is being exported from a module.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function isExported(variable) {\n\n            const definition = variable.defs[0];\n\n            if (definition) {\n\n                let node = definition.node;\n\n                if (node.type === \"VariableDeclarator\") {\n                    node = node.parent;\n                } else if (definition.type === \"Parameter\") {\n                    return false;\n                }\n\n                return node.parent.type.indexOf(\"Export\") === 0;\n            }\n            return false;\n\n        }\n\n        /**\n         * Checks whether a node is a sibling of the rest property or not.\n         * @param {ASTNode} node a node to check\n         * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.\n         */\n        function hasRestSibling(node) {\n            return node.type === \"Property\" &&\n                node.parent.type === \"ObjectPattern\" &&\n                REST_PROPERTY_TYPE.test(node.parent.properties[node.parent.properties.length - 1].type);\n        }\n\n        /**\n         * Determines if a variable has a sibling rest property\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {boolean} True if the variable is exported, false if not.\n         * @private\n         */\n        function hasRestSpreadSibling(variable) {\n            if (config.ignoreRestSiblings) {\n                const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n                const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n\n                return hasRestSiblingDefinition || hasRestSiblingReference;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a reference is a read operation.\n         * @param {Reference} ref An eslint-scope Reference\n         * @returns {boolean} whether the given reference represents a read operation\n         * @private\n         */\n        function isReadRef(ref) {\n            return ref.isRead();\n        }\n\n        /**\n         * Determine if an identifier is referencing an enclosing function name.\n         * @param {Reference} ref The reference to check.\n         * @param {ASTNode[]} nodes The candidate function nodes.\n         * @returns {boolean} True if it's a self-reference, false if not.\n         * @private\n         */\n        function isSelfReference(ref, nodes) {\n            let scope = ref.from;\n\n            while (scope) {\n                if (nodes.includes(scope.block)) {\n                    return true;\n                }\n\n                scope = scope.upper;\n            }\n\n            return false;\n        }\n\n        /**\n         * Gets a list of function definitions for a specified variable.\n         * @param {Variable} variable eslint-scope variable object.\n         * @returns {ASTNode[]} Function nodes.\n         * @private\n         */\n        function getFunctionDefinitions(variable) {\n            const functionDefinitions = [];\n\n            variable.defs.forEach(def => {\n                const { type, node } = def;\n\n                // FunctionDeclarations\n                if (type === \"FunctionName\") {\n                    functionDefinitions.push(node);\n                }\n\n                // FunctionExpressions\n                if (type === \"Variable\" && node.init &&\n                    (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n                    functionDefinitions.push(node.init);\n                }\n            });\n            return functionDefinitions;\n        }\n\n        /**\n         * Checks the position of given nodes.\n         * @param {ASTNode} inner A node which is expected as inside.\n         * @param {ASTNode} outer A node which is expected as outside.\n         * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\n         * @private\n         */\n        function isInside(inner, outer) {\n            return (\n                inner.range[0] >= outer.range[0] &&\n                inner.range[1] <= outer.range[1]\n            );\n        }\n\n        /**\n         * Checks whether a given node is unused expression or not.\n         * @param {ASTNode} node The node itself\n         * @returns {boolean} The node is an unused expression.\n         * @private\n         */\n        function isUnusedExpression(node) {\n            const parent = node.parent;\n\n            if (parent.type === \"ExpressionStatement\") {\n                return true;\n            }\n\n            if (parent.type === \"SequenceExpression\") {\n                const isLastExpression = parent.expressions[parent.expressions.length - 1] === node;\n\n                if (!isLastExpression) {\n                    return true;\n                }\n                return isUnusedExpression(parent);\n            }\n\n            return false;\n        }\n\n        /**\n         * If a given reference is left-hand side of an assignment, this gets\n         * the right-hand side node of the assignment.\n         *\n         * In the following cases, this returns null.\n         *\n         * - The reference is not the LHS of an assignment expression.\n         * - The reference is inside of a loop.\n         * - The reference is inside of a function scope which is different from\n         *   the declaration.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} prevRhsNode The previous RHS node.\n         * @returns {ASTNode|null} The RHS node or null.\n         * @private\n         */\n        function getRhsNode(ref, prevRhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n            const refScope = ref.from.variableScope;\n            const varScope = ref.resolved.scope.variableScope;\n            const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n\n            /*\n             * Inherits the previous node if this reference is in the node.\n             * This is for `a = a + a`-like code.\n             */\n            if (prevRhsNode && isInside(id, prevRhsNode)) {\n                return prevRhsNode;\n            }\n\n            if (parent.type === \"AssignmentExpression\" &&\n                isUnusedExpression(parent) &&\n                id === parent.left &&\n                !canBeUsedLater\n            ) {\n                return parent.right;\n            }\n            return null;\n        }\n\n        /**\n         * Checks whether a given function node is stored to somewhere or not.\n         * If the function node is stored, the function can be used later.\n         * @param {ASTNode} funcNode A function node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if under the following conditions:\n         *      - the funcNode is assigned to a variable.\n         *      - the funcNode is bound as an argument of a function call.\n         *      - the function is bound to a property and the object satisfies above conditions.\n         * @private\n         */\n        function isStorableFunction(funcNode, rhsNode) {\n            let node = funcNode;\n            let parent = funcNode.parent;\n\n            while (parent && isInside(parent, rhsNode)) {\n                switch (parent.type) {\n                    case \"SequenceExpression\":\n                        if (parent.expressions[parent.expressions.length - 1] !== node) {\n                            return false;\n                        }\n                        break;\n\n                    case \"CallExpression\":\n                    case \"NewExpression\":\n                        return parent.callee !== node;\n\n                    case \"AssignmentExpression\":\n                    case \"TaggedTemplateExpression\":\n                    case \"YieldExpression\":\n                        return true;\n\n                    default:\n                        if (STATEMENT_TYPE.test(parent.type)) {\n\n                            /*\n                             * If it encountered statements, this is a complex pattern.\n                             * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\n                             */\n                            return true;\n                        }\n                }\n\n                node = parent;\n                parent = parent.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether a given Identifier node exists inside of a function node which can be used later.\n         *\n         * \"can be used later\" means:\n         * - the function is assigned to a variable.\n         * - the function is bound to a property and the object can be used later.\n         * - the function is bound as an argument of a function call.\n         *\n         * If a reference exists in a function which can be used later, the reference is read when the function is called.\n         * @param {ASTNode} id An Identifier node to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\n         * @private\n         */\n        function isInsideOfStorableFunction(id, rhsNode) {\n            const funcNode = astUtils.getUpperFunction(id);\n\n            return (\n                funcNode &&\n                isInside(funcNode, rhsNode) &&\n                isStorableFunction(funcNode, rhsNode)\n            );\n        }\n\n        /**\n         * Checks whether a given reference is a read to update itself or not.\n         * @param {eslint-scope.Reference} ref A reference to check.\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\n         * @returns {boolean} The reference is a read to update itself.\n         * @private\n         */\n        function isReadForItself(ref, rhsNode) {\n            const id = ref.identifier;\n            const parent = id.parent;\n\n            return ref.isRead() && (\n\n                // self update. e.g. `a += 1`, `a++`\n                (\n                    (\n                        parent.type === \"AssignmentExpression\" &&\n                        parent.left === id &&\n                        isUnusedExpression(parent)\n                    ) ||\n                    (\n                        parent.type === \"UpdateExpression\" &&\n                        isUnusedExpression(parent)\n                    )\n                ) ||\n\n                // in RHS of an assignment for itself. e.g. `a = a + 1`\n                (\n                    rhsNode &&\n                    isInside(id, rhsNode) &&\n                    !isInsideOfStorableFunction(id, rhsNode)\n                )\n            );\n        }\n\n        /**\n         * Determine if an identifier is used either in for-in or for-of loops.\n         * @param {Reference} ref The reference to check.\n         * @returns {boolean} whether reference is used in the for-in loops\n         * @private\n         */\n        function isForInOfRef(ref) {\n            let target = ref.identifier.parent;\n\n\n            // \"for (var ...) { return; }\"\n            if (target.type === \"VariableDeclarator\") {\n                target = target.parent.parent;\n            }\n\n            if (target.type !== \"ForInStatement\" && target.type !== \"ForOfStatement\") {\n                return false;\n            }\n\n            // \"for (...) { return; }\"\n            if (target.body.type === \"BlockStatement\") {\n                target = target.body.body[0];\n\n            // \"for (...) return;\"\n            } else {\n                target = target.body;\n            }\n\n            // For empty loop body\n            if (!target) {\n                return false;\n            }\n\n            return target.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Determines if the variable is used.\n         * @param {Variable} variable The variable to check.\n         * @returns {boolean} True if the variable is used\n         * @private\n         */\n        function isUsedVariable(variable) {\n            const functionNodes = getFunctionDefinitions(variable),\n                isFunctionDefinition = functionNodes.length > 0;\n            let rhsNode = null;\n\n            return variable.references.some(ref => {\n                if (isForInOfRef(ref)) {\n                    return true;\n                }\n\n                const forItself = isReadForItself(ref, rhsNode);\n\n                rhsNode = getRhsNode(ref, rhsNode);\n\n                return (\n                    isReadRef(ref) &&\n                    !forItself &&\n                    !(isFunctionDefinition && isSelfReference(ref, functionNodes))\n                );\n            });\n        }\n\n        /**\n         * Checks whether the given variable is after the last used parameter.\n         * @param {eslint-scope.Variable} variable The variable to check.\n         * @returns {boolean} `true` if the variable is defined after the last\n         * used parameter.\n         */\n        function isAfterLastUsedArg(variable) {\n            const def = variable.defs[0];\n            const params = context.getDeclaredVariables(def.node);\n            const posteriorParams = params.slice(params.indexOf(variable) + 1);\n\n            // If any used parameters occur after this parameter, do not report.\n            return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n        }\n\n        /**\n         * Gets an array of variables without read references.\n         * @param {Scope} scope an eslint-scope Scope object.\n         * @param {Variable[]} unusedVars an array that saving result.\n         * @returns {Variable[]} unused variables of the scope and descendant scopes.\n         * @private\n         */\n        function collectUnusedVariables(scope, unusedVars) {\n            const variables = scope.variables;\n            const childScopes = scope.childScopes;\n            let i, l;\n\n            if (scope.type !== \"global\" || config.vars === \"all\") {\n                for (i = 0, l = variables.length; i < l; ++i) {\n                    const variable = variables[i];\n\n                    // skip a variable of class itself name in the class scope\n                    if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n                        continue;\n                    }\n\n                    // skip function expression names and variables marked with markVariableAsUsed()\n                    if (scope.functionExpressionScope || variable.eslintUsed) {\n                        continue;\n                    }\n\n                    // skip implicit \"arguments\" variable\n                    if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n                        continue;\n                    }\n\n                    // explicit global variables don't have definitions.\n                    const def = variable.defs[0];\n\n                    if (def) {\n                        const type = def.type;\n                        const refUsedInArrayPatterns = variable.references.some(ref => ref.identifier.parent.type === \"ArrayPattern\");\n\n                        // skip elements of array destructuring patterns\n                        if (\n                            (\n                                def.name.parent.type === \"ArrayPattern\" ||\n                                refUsedInArrayPatterns\n                            ) &&\n                            config.destructuredArrayIgnorePattern &&\n                            config.destructuredArrayIgnorePattern.test(def.name.name)\n                        ) {\n                            continue;\n                        }\n\n                        // skip catch variables\n                        if (type === \"CatchClause\") {\n                            if (config.caughtErrors === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n\n                        if (type === \"Parameter\") {\n\n                            // skip any setter argument\n                            if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"none\", skip any parameter\n                            if (config.args === \"none\") {\n                                continue;\n                            }\n\n                            // skip ignored parameters\n                            if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n\n                            // if \"args\" option is \"after-used\", skip used variables\n                            if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                                continue;\n                            }\n                        } else {\n\n                            // skip ignored variables\n                            if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                                continue;\n                            }\n                        }\n                    }\n\n                    if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n                        unusedVars.push(variable);\n                    }\n                }\n            }\n\n            for (i = 0, l = childScopes.length; i < l; ++i) {\n                collectUnusedVariables(childScopes[i], unusedVars);\n            }\n\n            return unusedVars;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            \"Program:exit\"(programNode) {\n                const unusedVars = collectUnusedVariables(context.getScope(), []);\n\n                for (let i = 0, l = unusedVars.length; i < l; ++i) {\n                    const unusedVar = unusedVars[i];\n\n                    // Report the first declaration.\n                    if (unusedVar.defs.length > 0) {\n\n                        // report last write reference, https://github.com/eslint/eslint/issues/14324\n                        const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\n\n                        let referenceToReport;\n\n                        if (writeReferences.length > 0) {\n                            referenceToReport = writeReferences[writeReferences.length - 1];\n                        }\n\n                        context.report({\n                            node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],\n                            messageId: \"unusedVar\",\n                            data: unusedVar.references.some(ref => ref.isWrite())\n                                ? getAssignedMessageData(unusedVar)\n                                : getDefinedMessageData(unusedVar)\n                        });\n\n                    // If there are no regular declaration, report the first `/*globals*/` comment directive.\n                    } else if (unusedVar.eslintExplicitGlobalComments) {\n                        const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n\n                        context.report({\n                            node: programNode,\n                            loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n                            messageId: \"unusedVar\",\n                            data: getDefinedMessageData(unusedVar)\n                        });\n                    }\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;;;AACAC,MAAM,CAACC,OAAP,GAAiB;EACbC,IAAI,EAAE;IACFC,IAAI,EAAE,SADJ;IAGFC,IAAI,EAAE;MACFC,WAAW,EAAE,2BADX;MAEFC,WAAW,EAAE,IAFX;MAGFC,GAAG,EAAE;IAHH,CAHJ;IASFC,MAAM,EAAE,CACJ;MACIC,KAAK,EAAE,CACH;QACIC,IAAI,EAAE,CAAC,KAAD,EAAQ,OAAR;MADV,CADG,EAIH;QACIP,IAAI,EAAE,QADV;QAEIQ,UAAU,EAAE;UACRC,IAAI,EAAE;YACFF,IAAI,EAAE,CAAC,KAAD,EAAQ,OAAR;UADJ,CADE;UAIRG,iBAAiB,EAAE;YACfV,IAAI,EAAE;UADS,CAJX;UAORW,IAAI,EAAE;YACFJ,IAAI,EAAE,CAAC,KAAD,EAAQ,YAAR,EAAsB,MAAtB;UADJ,CAPE;UAURK,kBAAkB,EAAE;YAChBZ,IAAI,EAAE;UADU,CAVZ;UAaRa,iBAAiB,EAAE;YACfb,IAAI,EAAE;UADS,CAbX;UAgBRc,YAAY,EAAE;YACVP,IAAI,EAAE,CAAC,KAAD,EAAQ,MAAR;UADI,CAhBN;UAmBRQ,yBAAyB,EAAE;YACvBf,IAAI,EAAE;UADiB,CAnBnB;UAsBRgB,8BAA8B,EAAE;YAC5BhB,IAAI,EAAE;UADsB;QAtBxB,CAFhB;QA4BIiB,oBAAoB,EAAE;MA5B1B,CAJG;IADX,CADI,CATN;IAiDFC,QAAQ,EAAE;MACNC,SAAS,EAAE;IADL;EAjDR,CADO;;EAuDbC,MAAM,CAACC,OAAD,EAAU;IACZ,MAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB;IAEA,MAAMC,kBAAkB,GAAG,kDAA3B;IAEA,MAAMC,MAAM,GAAG;MACXhB,IAAI,EAAE,KADK;MAEXE,IAAI,EAAE,YAFK;MAGXC,kBAAkB,EAAE,KAHT;MAIXE,YAAY,EAAE;IAJH,CAAf;IAOA,MAAMY,WAAW,GAAGL,OAAO,CAACM,OAAR,CAAgB,CAAhB,CAApB;;IAEA,IAAID,WAAJ,EAAiB;MACb,IAAI,OAAOA,WAAP,KAAuB,QAA3B,EAAqC;QACjCD,MAAM,CAAChB,IAAP,GAAciB,WAAd;MACH,CAFD,MAEO;QACHD,MAAM,CAAChB,IAAP,GAAciB,WAAW,CAACjB,IAAZ,IAAoBgB,MAAM,CAAChB,IAAzC;QACAgB,MAAM,CAACd,IAAP,GAAce,WAAW,CAACf,IAAZ,IAAoBc,MAAM,CAACd,IAAzC;QACAc,MAAM,CAACb,kBAAP,GAA4Bc,WAAW,CAACd,kBAAZ,IAAkCa,MAAM,CAACb,kBAArE;QACAa,MAAM,CAACX,YAAP,GAAsBY,WAAW,CAACZ,YAAZ,IAA4BW,MAAM,CAACX,YAAzD;;QAEA,IAAIY,WAAW,CAAChB,iBAAhB,EAAmC;UAC/Be,MAAM,CAACf,iBAAP,GAA2B,IAAIkB,MAAJ,CAAWF,WAAW,CAAChB,iBAAvB,EAA0C,GAA1C,CAA3B;QACH;;QAED,IAAIgB,WAAW,CAACb,iBAAhB,EAAmC;UAC/BY,MAAM,CAACZ,iBAAP,GAA2B,IAAIe,MAAJ,CAAWF,WAAW,CAACb,iBAAvB,EAA0C,GAA1C,CAA3B;QACH;;QAED,IAAIa,WAAW,CAACX,yBAAhB,EAA2C;UACvCU,MAAM,CAACV,yBAAP,GAAmC,IAAIa,MAAJ,CAAWF,WAAW,CAACX,yBAAvB,EAAkD,GAAlD,CAAnC;QACH;;QAED,IAAIW,WAAW,CAACV,8BAAhB,EAAgD;UAC5CS,MAAM,CAACT,8BAAP,GAAwC,IAAIY,MAAJ,CAAWF,WAAW,CAACV,8BAAvB,EAAuD,GAAvD,CAAxC;QACH;MACJ;IACJ;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASa,qBAAT,CAA+BV,SAA/B,EAA0C;MACtC,MAAMW,OAAO,GAAGX,SAAS,CAACY,IAAV,IAAkBZ,SAAS,CAACY,IAAV,CAAe,CAAf,CAAlB,IAAuCZ,SAAS,CAACY,IAAV,CAAe,CAAf,EAAkB/B,IAAzE;MACA,IAAIA,IAAJ;MACA,IAAIgC,OAAJ;;MAEA,IAAIF,OAAO,KAAK,aAAZ,IAA6BL,MAAM,CAACV,yBAAxC,EAAmE;QAC/Df,IAAI,GAAG,MAAP;QACAgC,OAAO,GAAGP,MAAM,CAACV,yBAAP,CAAiCkB,QAAjC,EAAV;MACH,CAHD,MAGO,IAAIH,OAAO,KAAK,WAAZ,IAA2BL,MAAM,CAACZ,iBAAtC,EAAyD;QAC5Db,IAAI,GAAG,MAAP;QACAgC,OAAO,GAAGP,MAAM,CAACZ,iBAAP,CAAyBoB,QAAzB,EAAV;MACH,CAHM,MAGA,IAAIH,OAAO,KAAK,WAAZ,IAA2BL,MAAM,CAACf,iBAAtC,EAAyD;QAC5DV,IAAI,GAAG,MAAP;QACAgC,OAAO,GAAGP,MAAM,CAACf,iBAAP,CAAyBuB,QAAzB,EAAV;MACH;;MAED,MAAMC,UAAU,GAAGlC,IAAI,GAAI,oBAAmBA,IAAK,eAAcgC,OAAQ,EAAlD,GAAsD,EAA7E;MAEA,OAAO;QACHG,OAAO,EAAEhB,SAAS,CAACiB,IADhB;QAEHC,MAAM,EAAE,SAFL;QAGHH;MAHG,CAAP;IAKH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASI,sBAAT,CAAgCnB,SAAhC,EAA2C;MACvC,MAAMoB,GAAG,GAAGpB,SAAS,CAACY,IAAV,CAAe,CAAf,CAAZ;MACA,IAAIG,UAAU,GAAG,EAAjB;;MAEA,IAAIT,MAAM,CAACT,8BAAP,IAAyCuB,GAAzC,IAAgDA,GAAG,CAACH,IAAJ,CAASI,MAAT,CAAgBxC,IAAhB,KAAyB,cAA7E,EAA6F;QACzFkC,UAAU,GAAI,wEAAuET,MAAM,CAACT,8BAAP,CAAsCiB,QAAtC,EAAiD,EAAtI;MACH,CAFD,MAEO,IAAIR,MAAM,CAACf,iBAAX,EAA8B;QACjCwB,UAAU,GAAI,oCAAmCT,MAAM,CAACf,iBAAP,CAAyBuB,QAAzB,EAAoC,EAArF;MACH;;MAED,OAAO;QACHE,OAAO,EAAEhB,SAAS,CAACiB,IADhB;QAEHC,MAAM,EAAE,kBAFL;QAGHH;MAHG,CAAP;IAKH,CA7FW,CA+FZ;IACA;IACA;;;IAEA,MAAMO,cAAc,GAAG,6BAAvB;IAEA;AACR;AACA;AACA;AACA;AACA;;IACQ,SAASC,UAAT,CAAoBC,QAApB,EAA8B;MAE1B,MAAMC,UAAU,GAAGD,QAAQ,CAACZ,IAAT,CAAc,CAAd,CAAnB;;MAEA,IAAIa,UAAJ,EAAgB;QAEZ,IAAIC,IAAI,GAAGD,UAAU,CAACC,IAAtB;;QAEA,IAAIA,IAAI,CAAC7C,IAAL,KAAc,oBAAlB,EAAwC;UACpC6C,IAAI,GAAGA,IAAI,CAACL,MAAZ;QACH,CAFD,MAEO,IAAII,UAAU,CAAC5C,IAAX,KAAoB,WAAxB,EAAqC;UACxC,OAAO,KAAP;QACH;;QAED,OAAO6C,IAAI,CAACL,MAAL,CAAYxC,IAAZ,CAAiB8C,OAAjB,CAAyB,QAAzB,MAAuC,CAA9C;MACH;;MACD,OAAO,KAAP;IAEH;IAED;AACR;AACA;AACA;AACA;;;IACQ,SAASC,cAAT,CAAwBF,IAAxB,EAA8B;MAC1B,OAAOA,IAAI,CAAC7C,IAAL,KAAc,UAAd,IACH6C,IAAI,CAACL,MAAL,CAAYxC,IAAZ,KAAqB,eADlB,IAEHwB,kBAAkB,CAACwB,IAAnB,CAAwBH,IAAI,CAACL,MAAL,CAAYhC,UAAZ,CAAuBqC,IAAI,CAACL,MAAL,CAAYhC,UAAZ,CAAuByC,MAAvB,GAAgC,CAAvD,EAA0DjD,IAAlF,CAFJ;IAGH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASkD,oBAAT,CAA8BP,QAA9B,EAAwC;MACpC,IAAIlB,MAAM,CAACb,kBAAX,EAA+B;QAC3B,MAAMuC,wBAAwB,GAAGR,QAAQ,CAACZ,IAAT,CAAcqB,IAAd,CAAmBb,GAAG,IAAIQ,cAAc,CAACR,GAAG,CAACH,IAAJ,CAASI,MAAV,CAAxC,CAAjC;QACA,MAAMa,uBAAuB,GAAGV,QAAQ,CAACW,UAAT,CAAoBF,IAApB,CAAyBG,GAAG,IAAIR,cAAc,CAACQ,GAAG,CAACC,UAAJ,CAAehB,MAAhB,CAA9C,CAAhC;QAEA,OAAOW,wBAAwB,IAAIE,uBAAnC;MACH;;MAED,OAAO,KAAP;IACH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASI,SAAT,CAAmBF,GAAnB,EAAwB;MACpB,OAAOA,GAAG,CAACG,MAAJ,EAAP;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASC,eAAT,CAAyBJ,GAAzB,EAA8BK,KAA9B,EAAqC;MACjC,IAAIC,KAAK,GAAGN,GAAG,CAACO,IAAhB;;MAEA,OAAOD,KAAP,EAAc;QACV,IAAID,KAAK,CAACG,QAAN,CAAeF,KAAK,CAACG,KAArB,CAAJ,EAAiC;UAC7B,OAAO,IAAP;QACH;;QAEDH,KAAK,GAAGA,KAAK,CAACI,KAAd;MACH;;MAED,OAAO,KAAP;IACH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASC,sBAAT,CAAgCvB,QAAhC,EAA0C;MACtC,MAAMwB,mBAAmB,GAAG,EAA5B;MAEAxB,QAAQ,CAACZ,IAAT,CAAcqC,OAAd,CAAsB7B,GAAG,IAAI;QACzB,MAAM;UAAEvC,IAAF;UAAQ6C;QAAR,IAAiBN,GAAvB,CADyB,CAGzB;;QACA,IAAIvC,IAAI,KAAK,cAAb,EAA6B;UACzBmE,mBAAmB,CAACE,IAApB,CAAyBxB,IAAzB;QACH,CANwB,CAQzB;;;QACA,IAAI7C,IAAI,KAAK,UAAT,IAAuB6C,IAAI,CAACyB,IAA5B,KACCzB,IAAI,CAACyB,IAAL,CAAUtE,IAAV,KAAmB,oBAAnB,IAA2C6C,IAAI,CAACyB,IAAL,CAAUtE,IAAV,KAAmB,yBAD/D,CAAJ,EAC+F;UAC3FmE,mBAAmB,CAACE,IAApB,CAAyBxB,IAAI,CAACyB,IAA9B;QACH;MACJ,CAbD;MAcA,OAAOH,mBAAP;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASI,QAAT,CAAkBC,KAAlB,EAAyBC,KAAzB,EAAgC;MAC5B,OACID,KAAK,CAACE,KAAN,CAAY,CAAZ,KAAkBD,KAAK,CAACC,KAAN,CAAY,CAAZ,CAAlB,IACAF,KAAK,CAACE,KAAN,CAAY,CAAZ,KAAkBD,KAAK,CAACC,KAAN,CAAY,CAAZ,CAFtB;IAIH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASC,kBAAT,CAA4B9B,IAA5B,EAAkC;MAC9B,MAAML,MAAM,GAAGK,IAAI,CAACL,MAApB;;MAEA,IAAIA,MAAM,CAACxC,IAAP,KAAgB,qBAApB,EAA2C;QACvC,OAAO,IAAP;MACH;;MAED,IAAIwC,MAAM,CAACxC,IAAP,KAAgB,oBAApB,EAA0C;QACtC,MAAM4E,gBAAgB,GAAGpC,MAAM,CAACqC,WAAP,CAAmBrC,MAAM,CAACqC,WAAP,CAAmB5B,MAAnB,GAA4B,CAA/C,MAAsDJ,IAA/E;;QAEA,IAAI,CAAC+B,gBAAL,EAAuB;UACnB,OAAO,IAAP;QACH;;QACD,OAAOD,kBAAkB,CAACnC,MAAD,CAAzB;MACH;;MAED,OAAO,KAAP;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASsC,UAAT,CAAoBvB,GAApB,EAAyBwB,WAAzB,EAAsC;MAClC,MAAMC,EAAE,GAAGzB,GAAG,CAACC,UAAf;MACA,MAAMhB,MAAM,GAAGwC,EAAE,CAACxC,MAAlB;MACA,MAAMyC,QAAQ,GAAG1B,GAAG,CAACO,IAAJ,CAASoB,aAA1B;MACA,MAAMC,QAAQ,GAAG5B,GAAG,CAAC6B,QAAJ,CAAavB,KAAb,CAAmBqB,aAApC;MACA,MAAMG,cAAc,GAAGJ,QAAQ,KAAKE,QAAb,IAAyBxF,QAAQ,CAAC2F,QAAT,CAAkBN,EAAlB,CAAhD;MAEA;AACZ;AACA;AACA;;MACY,IAAID,WAAW,IAAIR,QAAQ,CAACS,EAAD,EAAKD,WAAL,CAA3B,EAA8C;QAC1C,OAAOA,WAAP;MACH;;MAED,IAAIvC,MAAM,CAACxC,IAAP,KAAgB,sBAAhB,IACA2E,kBAAkB,CAACnC,MAAD,CADlB,IAEAwC,EAAE,KAAKxC,MAAM,CAAC+C,IAFd,IAGA,CAACF,cAHL,EAIE;QACE,OAAO7C,MAAM,CAACgD,KAAd;MACH;;MACD,OAAO,IAAP;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASC,kBAAT,CAA4BC,QAA5B,EAAsCC,OAAtC,EAA+C;MAC3C,IAAI9C,IAAI,GAAG6C,QAAX;MACA,IAAIlD,MAAM,GAAGkD,QAAQ,CAAClD,MAAtB;;MAEA,OAAOA,MAAM,IAAI+B,QAAQ,CAAC/B,MAAD,EAASmD,OAAT,CAAzB,EAA4C;QACxC,QAAQnD,MAAM,CAACxC,IAAf;UACI,KAAK,oBAAL;YACI,IAAIwC,MAAM,CAACqC,WAAP,CAAmBrC,MAAM,CAACqC,WAAP,CAAmB5B,MAAnB,GAA4B,CAA/C,MAAsDJ,IAA1D,EAAgE;cAC5D,OAAO,KAAP;YACH;;YACD;;UAEJ,KAAK,gBAAL;UACA,KAAK,eAAL;YACI,OAAOL,MAAM,CAACoD,MAAP,KAAkB/C,IAAzB;;UAEJ,KAAK,sBAAL;UACA,KAAK,0BAAL;UACA,KAAK,iBAAL;YACI,OAAO,IAAP;;UAEJ;YACI,IAAIJ,cAAc,CAACO,IAAf,CAAoBR,MAAM,CAACxC,IAA3B,CAAJ,EAAsC;cAElC;AAC5B;AACA;AACA;cAC4B,OAAO,IAAP;YACH;;QAxBT;;QA2BA6C,IAAI,GAAGL,MAAP;QACAA,MAAM,GAAGA,MAAM,CAACA,MAAhB;MACH;;MAED,OAAO,KAAP;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASqD,0BAAT,CAAoCb,EAApC,EAAwCW,OAAxC,EAAiD;MAC7C,MAAMD,QAAQ,GAAG/F,QAAQ,CAACmG,gBAAT,CAA0Bd,EAA1B,CAAjB;MAEA,OACIU,QAAQ,IACRnB,QAAQ,CAACmB,QAAD,EAAWC,OAAX,CADR,IAEAF,kBAAkB,CAACC,QAAD,EAAWC,OAAX,CAHtB;IAKH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASI,eAAT,CAAyBxC,GAAzB,EAA8BoC,OAA9B,EAAuC;MACnC,MAAMX,EAAE,GAAGzB,GAAG,CAACC,UAAf;MACA,MAAMhB,MAAM,GAAGwC,EAAE,CAACxC,MAAlB;MAEA,OAAOe,GAAG,CAACG,MAAJ,QAEH;MAGQlB,MAAM,CAACxC,IAAP,KAAgB,sBAAhB,IACAwC,MAAM,CAAC+C,IAAP,KAAgBP,EADhB,IAEAL,kBAAkB,CAACnC,MAAD,CAHtB,IAMIA,MAAM,CAACxC,IAAP,KAAgB,kBAAhB,IACA2E,kBAAkB,CAACnC,MAAD,CAR1B,IAYA;MAEImD,OAAO,IACPpB,QAAQ,CAACS,EAAD,EAAKW,OAAL,CADR,IAEA,CAACE,0BAA0B,CAACb,EAAD,EAAKW,OAAL,CAnB5B,CAAP;IAsBH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASK,YAAT,CAAsBzC,GAAtB,EAA2B;MACvB,IAAI0C,MAAM,GAAG1C,GAAG,CAACC,UAAJ,CAAehB,MAA5B,CADuB,CAIvB;;MACA,IAAIyD,MAAM,CAACjG,IAAP,KAAgB,oBAApB,EAA0C;QACtCiG,MAAM,GAAGA,MAAM,CAACzD,MAAP,CAAcA,MAAvB;MACH;;MAED,IAAIyD,MAAM,CAACjG,IAAP,KAAgB,gBAAhB,IAAoCiG,MAAM,CAACjG,IAAP,KAAgB,gBAAxD,EAA0E;QACtE,OAAO,KAAP;MACH,CAXsB,CAavB;;;MACA,IAAIiG,MAAM,CAACC,IAAP,CAAYlG,IAAZ,KAAqB,gBAAzB,EAA2C;QACvCiG,MAAM,GAAGA,MAAM,CAACC,IAAP,CAAYA,IAAZ,CAAiB,CAAjB,CAAT,CADuC,CAG3C;MACC,CAJD,MAIO;QACHD,MAAM,GAAGA,MAAM,CAACC,IAAhB;MACH,CApBsB,CAsBvB;;;MACA,IAAI,CAACD,MAAL,EAAa;QACT,OAAO,KAAP;MACH;;MAED,OAAOA,MAAM,CAACjG,IAAP,KAAgB,iBAAvB;IACH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASmG,cAAT,CAAwBxD,QAAxB,EAAkC;MAC9B,MAAMyD,aAAa,GAAGlC,sBAAsB,CAACvB,QAAD,CAA5C;MAAA,MACI0D,oBAAoB,GAAGD,aAAa,CAACnD,MAAd,GAAuB,CADlD;MAEA,IAAI0C,OAAO,GAAG,IAAd;MAEA,OAAOhD,QAAQ,CAACW,UAAT,CAAoBF,IAApB,CAAyBG,GAAG,IAAI;QACnC,IAAIyC,YAAY,CAACzC,GAAD,CAAhB,EAAuB;UACnB,OAAO,IAAP;QACH;;QAED,MAAM+C,SAAS,GAAGP,eAAe,CAACxC,GAAD,EAAMoC,OAAN,CAAjC;QAEAA,OAAO,GAAGb,UAAU,CAACvB,GAAD,EAAMoC,OAAN,CAApB;QAEA,OACIlC,SAAS,CAACF,GAAD,CAAT,IACA,CAAC+C,SADD,IAEA,EAAED,oBAAoB,IAAI1C,eAAe,CAACJ,GAAD,EAAM6C,aAAN,CAAzC,CAHJ;MAKH,CAdM,CAAP;IAeH;IAED;AACR;AACA;AACA;AACA;AACA;;;IACQ,SAASG,kBAAT,CAA4B5D,QAA5B,EAAsC;MAClC,MAAMJ,GAAG,GAAGI,QAAQ,CAACZ,IAAT,CAAc,CAAd,CAAZ;MACA,MAAMyE,MAAM,GAAGnF,OAAO,CAACoF,oBAAR,CAA6BlE,GAAG,CAACM,IAAjC,CAAf;MACA,MAAM6D,eAAe,GAAGF,MAAM,CAACG,KAAP,CAAaH,MAAM,CAAC1D,OAAP,CAAeH,QAAf,IAA2B,CAAxC,CAAxB,CAHkC,CAKlC;;MACA,OAAO,CAAC+D,eAAe,CAACtD,IAAhB,CAAqBwD,CAAC,IAAIA,CAAC,CAACtD,UAAF,CAAaL,MAAb,GAAsB,CAAtB,IAA2B2D,CAAC,CAACC,UAAvD,CAAR;IACH;IAED;AACR;AACA;AACA;AACA;AACA;AACA;;;IACQ,SAASC,sBAAT,CAAgCjD,KAAhC,EAAuCkD,UAAvC,EAAmD;MAC/C,MAAMC,SAAS,GAAGnD,KAAK,CAACmD,SAAxB;MACA,MAAMC,WAAW,GAAGpD,KAAK,CAACoD,WAA1B;MACA,IAAIC,CAAJ,EAAOC,CAAP;;MAEA,IAAItD,KAAK,CAAC7D,IAAN,KAAe,QAAf,IAA2ByB,MAAM,CAAChB,IAAP,KAAgB,KAA/C,EAAsD;QAClD,KAAKyG,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGH,SAAS,CAAC/D,MAA1B,EAAkCiE,CAAC,GAAGC,CAAtC,EAAyC,EAAED,CAA3C,EAA8C;UAC1C,MAAMvE,QAAQ,GAAGqE,SAAS,CAACE,CAAD,CAA1B,CAD0C,CAG1C;;UACA,IAAIrD,KAAK,CAAC7D,IAAN,KAAe,OAAf,IAA0B6D,KAAK,CAACG,KAAN,CAAYgB,EAAZ,KAAmBrC,QAAQ,CAACyE,WAAT,CAAqB,CAArB,CAAjD,EAA0E;YACtE;UACH,CANyC,CAQ1C;;;UACA,IAAIvD,KAAK,CAACwD,uBAAN,IAAiC1E,QAAQ,CAACkE,UAA9C,EAA0D;YACtD;UACH,CAXyC,CAa1C;;;UACA,IAAIhD,KAAK,CAAC7D,IAAN,KAAe,UAAf,IAA6B2C,QAAQ,CAACP,IAAT,KAAkB,WAA/C,IAA8DO,QAAQ,CAACyE,WAAT,CAAqBnE,MAArB,KAAgC,CAAlG,EAAqG;YACjG;UACH,CAhByC,CAkB1C;;;UACA,MAAMV,GAAG,GAAGI,QAAQ,CAACZ,IAAT,CAAc,CAAd,CAAZ;;UAEA,IAAIQ,GAAJ,EAAS;YACL,MAAMvC,IAAI,GAAGuC,GAAG,CAACvC,IAAjB;YACA,MAAMsH,sBAAsB,GAAG3E,QAAQ,CAACW,UAAT,CAAoBF,IAApB,CAAyBG,GAAG,IAAIA,GAAG,CAACC,UAAJ,CAAehB,MAAf,CAAsBxC,IAAtB,KAA+B,cAA/D,CAA/B,CAFK,CAIL;;YACA,IACI,CACIuC,GAAG,CAACH,IAAJ,CAASI,MAAT,CAAgBxC,IAAhB,KAAyB,cAAzB,IACAsH,sBAFJ,KAIA7F,MAAM,CAACT,8BAJP,IAKAS,MAAM,CAACT,8BAAP,CAAsCgC,IAAtC,CAA2CT,GAAG,CAACH,IAAJ,CAASA,IAApD,CANJ,EAOE;cACE;YACH,CAdI,CAgBL;;;YACA,IAAIpC,IAAI,KAAK,aAAb,EAA4B;cACxB,IAAIyB,MAAM,CAACX,YAAP,KAAwB,MAA5B,EAAoC;gBAChC;cACH,CAHuB,CAKxB;;;cACA,IAAIW,MAAM,CAACV,yBAAP,IAAoCU,MAAM,CAACV,yBAAP,CAAiCiC,IAAjC,CAAsCT,GAAG,CAACH,IAAJ,CAASA,IAA/C,CAAxC,EAA8F;gBAC1F;cACH;YACJ;;YAED,IAAIpC,IAAI,KAAK,WAAb,EAA0B;cAEtB;cACA,IAAI,CAACuC,GAAG,CAACM,IAAJ,CAASL,MAAT,CAAgBxC,IAAhB,KAAyB,UAAzB,IAAuCuC,GAAG,CAACM,IAAJ,CAASL,MAAT,CAAgBxC,IAAhB,KAAyB,kBAAjE,KAAwFuC,GAAG,CAACM,IAAJ,CAASL,MAAT,CAAgB+E,IAAhB,KAAyB,KAArH,EAA4H;gBACxH;cACH,CALqB,CAOtB;;;cACA,IAAI9F,MAAM,CAACd,IAAP,KAAgB,MAApB,EAA4B;gBACxB;cACH,CAVqB,CAYtB;;;cACA,IAAIc,MAAM,CAACZ,iBAAP,IAA4BY,MAAM,CAACZ,iBAAP,CAAyBmC,IAAzB,CAA8BT,GAAG,CAACH,IAAJ,CAASA,IAAvC,CAAhC,EAA8E;gBAC1E;cACH,CAfqB,CAiBtB;;;cACA,IAAIX,MAAM,CAACd,IAAP,KAAgB,YAAhB,IAAgChB,QAAQ,CAAC6H,UAAT,CAAoBjF,GAAG,CAACH,IAAJ,CAASI,MAA7B,CAAhC,IAAwE,CAAC+D,kBAAkB,CAAC5D,QAAD,CAA/F,EAA2G;gBACvG;cACH;YACJ,CArBD,MAqBO;cAEH;cACA,IAAIlB,MAAM,CAACf,iBAAP,IAA4Be,MAAM,CAACf,iBAAP,CAAyBsC,IAAzB,CAA8BT,GAAG,CAACH,IAAJ,CAASA,IAAvC,CAAhC,EAA8E;gBAC1E;cACH;YACJ;UACJ;;UAED,IAAI,CAAC+D,cAAc,CAACxD,QAAD,CAAf,IAA6B,CAACD,UAAU,CAACC,QAAD,CAAxC,IAAsD,CAACO,oBAAoB,CAACP,QAAD,CAA/E,EAA2F;YACvFoE,UAAU,CAAC1C,IAAX,CAAgB1B,QAAhB;UACH;QACJ;MACJ;;MAED,KAAKuE,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGF,WAAW,CAAChE,MAA5B,EAAoCiE,CAAC,GAAGC,CAAxC,EAA2C,EAAED,CAA7C,EAAgD;QAC5CJ,sBAAsB,CAACG,WAAW,CAACC,CAAD,CAAZ,EAAiBH,UAAjB,CAAtB;MACH;;MAED,OAAOA,UAAP;IACH,CAtkBW,CAwkBZ;IACA;IACA;;;IAEA,OAAO;MACH,eAAeU,WAAf,EAA4B;QACxB,MAAMV,UAAU,GAAGD,sBAAsB,CAACzF,OAAO,CAACqG,QAAR,EAAD,EAAqB,EAArB,CAAzC;;QAEA,KAAK,IAAIR,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGJ,UAAU,CAAC9D,MAA/B,EAAuCiE,CAAC,GAAGC,CAA3C,EAA8C,EAAED,CAAhD,EAAmD;UAC/C,MAAM/F,SAAS,GAAG4F,UAAU,CAACG,CAAD,CAA5B,CAD+C,CAG/C;;UACA,IAAI/F,SAAS,CAACY,IAAV,CAAekB,MAAf,GAAwB,CAA5B,EAA+B;YAE3B;YACA,MAAM0E,eAAe,GAAGxG,SAAS,CAACmC,UAAV,CAAqBsE,MAArB,CAA4BrE,GAAG,IAAIA,GAAG,CAACsE,OAAJ,MAAiBtE,GAAG,CAACO,IAAJ,CAASoB,aAAT,KAA2B/D,SAAS,CAAC0C,KAAV,CAAgBqB,aAA/F,CAAxB;YAEA,IAAI4C,iBAAJ;;YAEA,IAAIH,eAAe,CAAC1E,MAAhB,GAAyB,CAA7B,EAAgC;cAC5B6E,iBAAiB,GAAGH,eAAe,CAACA,eAAe,CAAC1E,MAAhB,GAAyB,CAA1B,CAAnC;YACH;;YAED5B,OAAO,CAAC0G,MAAR,CAAe;cACXlF,IAAI,EAAEiF,iBAAiB,GAAGA,iBAAiB,CAACtE,UAArB,GAAkCrC,SAAS,CAACiG,WAAV,CAAsB,CAAtB,CAD9C;cAEXY,SAAS,EAAE,WAFA;cAGXC,IAAI,EAAE9G,SAAS,CAACmC,UAAV,CAAqBF,IAArB,CAA0BG,GAAG,IAAIA,GAAG,CAACsE,OAAJ,EAAjC,IACAvF,sBAAsB,CAACnB,SAAD,CADtB,GAEAU,qBAAqB,CAACV,SAAD;YALhB,CAAf,EAX2B,CAmB/B;UACC,CApBD,MAoBO,IAAIA,SAAS,CAAC+G,4BAAd,EAA4C;YAC/C,MAAMC,gBAAgB,GAAGhH,SAAS,CAAC+G,4BAAV,CAAuC,CAAvC,CAAzB;YAEA7G,OAAO,CAAC0G,MAAR,CAAe;cACXlF,IAAI,EAAE4E,WADK;cAEXW,GAAG,EAAEzI,QAAQ,CAAC0I,uCAAT,CAAiD/G,UAAjD,EAA6D6G,gBAA7D,EAA+EhH,SAAS,CAACiB,IAAzF,CAFM;cAGX4F,SAAS,EAAE,WAHA;cAIXC,IAAI,EAAEpG,qBAAqB,CAACV,SAAD;YAJhB,CAAf;UAMH;QACJ;MACJ;;IAvCE,CAAP;EA0CH;;AA7qBY,CAAjB"},"metadata":{},"sourceType":"script"}