{"ast":null,"code":"import selectorParser from 'postcss-selector-parser';\nimport escapeCommas from './escapeCommas';\nimport { withAlphaValue } from './withAlphaVariable';\nimport { normalize, length, number, percentage, url, color as validateColor, genericName, familyName, image, absoluteSize, relativeSize, position, lineWidth, shadow } from './dataTypes';\nimport negateValue from './negateValue';\nexport function updateAllClasses(selectors, updateClass) {\n  let parser = selectorParser(selectors => {\n    selectors.walkClasses(sel => {\n      let updatedClass = updateClass(sel.value);\n      sel.value = updatedClass;\n\n      if (sel.raws && sel.raws.value) {\n        sel.raws.value = escapeCommas(sel.raws.value);\n      }\n    });\n  });\n  let result = parser.processSync(selectors);\n  return result;\n}\n\nfunction resolveArbitraryValue(modifier, validate) {\n  if (!isArbitraryValue(modifier)) {\n    return undefined;\n  }\n\n  let value = modifier.slice(1, -1);\n\n  if (!validate(value)) {\n    return undefined;\n  }\n\n  return normalize(value);\n}\n\nfunction asNegativeValue(modifier) {\n  let lookup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let validate = arguments.length > 2 ? arguments[2] : undefined;\n  let positiveValue = lookup[modifier];\n\n  if (positiveValue !== undefined) {\n    return negateValue(positiveValue);\n  }\n\n  if (isArbitraryValue(modifier)) {\n    let resolved = resolveArbitraryValue(modifier, validate);\n\n    if (resolved === undefined) {\n      return undefined;\n    }\n\n    return negateValue(resolved);\n  }\n}\n\nexport function asValue(modifier) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let {\n    validate = () => true\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let value = options.values?.[modifier];\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  if (options.supportsNegativeValues && modifier.startsWith('-')) {\n    return asNegativeValue(modifier.slice(1), options.values, validate);\n  }\n\n  return resolveArbitraryValue(modifier, validate);\n}\n\nfunction isArbitraryValue(input) {\n  return input.startsWith('[') && input.endsWith(']');\n}\n\nfunction splitAlpha(modifier) {\n  let slashIdx = modifier.lastIndexOf('/');\n\n  if (slashIdx === -1 || slashIdx === modifier.length - 1) {\n    return [modifier];\n  }\n\n  return [modifier.slice(0, slashIdx), modifier.slice(slashIdx + 1)];\n}\n\nexport function parseColorFormat(value) {\n  if (typeof value === 'string' && value.includes('<alpha-value>')) {\n    let oldValue = value;\n    return _ref => {\n      let {\n        opacityValue = 1\n      } = _ref;\n      return oldValue.replace('<alpha-value>', opacityValue);\n    };\n  }\n\n  return value;\n}\nexport function asColor(modifier) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let {\n    tailwindConfig = {}\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (options.values?.[modifier] !== undefined) {\n    return parseColorFormat(options.values?.[modifier]);\n  }\n\n  let [color, alpha] = splitAlpha(modifier);\n\n  if (alpha !== undefined) {\n    let normalizedColor = options.values?.[color] ?? (isArbitraryValue(color) ? color.slice(1, -1) : undefined);\n\n    if (normalizedColor === undefined) {\n      return undefined;\n    }\n\n    normalizedColor = parseColorFormat(normalizedColor);\n\n    if (isArbitraryValue(alpha)) {\n      return withAlphaValue(normalizedColor, alpha.slice(1, -1));\n    }\n\n    if (tailwindConfig.theme?.opacity?.[alpha] === undefined) {\n      return undefined;\n    }\n\n    return withAlphaValue(normalizedColor, tailwindConfig.theme.opacity[alpha]);\n  }\n\n  return asValue(modifier, options, {\n    validate: validateColor\n  });\n}\nexport function asLookupValue(modifier) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return options.values?.[modifier];\n}\n\nfunction guess(validate) {\n  return (modifier, options) => {\n    return asValue(modifier, options, {\n      validate\n    });\n  };\n}\n\nlet typeMap = {\n  any: asValue,\n  color: asColor,\n  url: guess(url),\n  image: guess(image),\n  length: guess(length),\n  percentage: guess(percentage),\n  position: guess(position),\n  lookup: asLookupValue,\n  'generic-name': guess(genericName),\n  'family-name': guess(familyName),\n  number: guess(number),\n  'line-width': guess(lineWidth),\n  'absolute-size': guess(absoluteSize),\n  'relative-size': guess(relativeSize),\n  shadow: guess(shadow)\n};\nlet supportedTypes = Object.keys(typeMap);\n\nfunction splitAtFirst(input, delim) {\n  let idx = input.indexOf(delim);\n  if (idx === -1) return [undefined, input];\n  return [input.slice(0, idx), input.slice(idx + 1)];\n}\n\nexport function coerceValue(types, modifier, options, tailwindConfig) {\n  if (isArbitraryValue(modifier)) {\n    let arbitraryValue = modifier.slice(1, -1);\n    let [explicitType, value] = splitAtFirst(arbitraryValue, ':'); // It could be that this resolves to `url(https` which is not a valid\n    // identifier. We currently only support \"simple\" words with dashes or\n    // underscores. E.g.: family-name\n\n    if (!/^[\\w-_]+$/g.test(explicitType)) {\n      value = arbitraryValue;\n    } //\n    else if (explicitType !== undefined && !supportedTypes.includes(explicitType)) {\n      return [];\n    }\n\n    if (value.length > 0 && supportedTypes.includes(explicitType)) {\n      return [asValue(`[${value}]`, options), explicitType];\n    }\n  } // Find first matching type\n\n\n  for (let type of [].concat(types)) {\n    let result = typeMap[type](modifier, options, {\n      tailwindConfig\n    });\n    if (result !== undefined) return [result, type];\n  }\n\n  return [];\n}","map":{"version":3,"names":["selectorParser","escapeCommas","withAlphaValue","normalize","length","number","percentage","url","color","validateColor","genericName","familyName","image","absoluteSize","relativeSize","position","lineWidth","shadow","negateValue","updateAllClasses","selectors","updateClass","parser","walkClasses","sel","updatedClass","value","raws","result","processSync","resolveArbitraryValue","modifier","validate","isArbitraryValue","undefined","slice","asNegativeValue","lookup","positiveValue","resolved","asValue","options","values","supportsNegativeValues","startsWith","input","endsWith","splitAlpha","slashIdx","lastIndexOf","parseColorFormat","includes","oldValue","opacityValue","replace","asColor","tailwindConfig","alpha","normalizedColor","theme","opacity","asLookupValue","guess","typeMap","any","supportedTypes","Object","keys","splitAtFirst","delim","idx","indexOf","coerceValue","types","arbitraryValue","explicitType","test","type","concat"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/src/util/pluginUtils.js"],"sourcesContent":["import selectorParser from 'postcss-selector-parser'\nimport escapeCommas from './escapeCommas'\nimport { withAlphaValue } from './withAlphaVariable'\nimport {\n  normalize,\n  length,\n  number,\n  percentage,\n  url,\n  color as validateColor,\n  genericName,\n  familyName,\n  image,\n  absoluteSize,\n  relativeSize,\n  position,\n  lineWidth,\n  shadow,\n} from './dataTypes'\nimport negateValue from './negateValue'\n\nexport function updateAllClasses(selectors, updateClass) {\n  let parser = selectorParser((selectors) => {\n    selectors.walkClasses((sel) => {\n      let updatedClass = updateClass(sel.value)\n      sel.value = updatedClass\n      if (sel.raws && sel.raws.value) {\n        sel.raws.value = escapeCommas(sel.raws.value)\n      }\n    })\n  })\n\n  let result = parser.processSync(selectors)\n\n  return result\n}\n\nfunction resolveArbitraryValue(modifier, validate) {\n  if (!isArbitraryValue(modifier)) {\n    return undefined\n  }\n\n  let value = modifier.slice(1, -1)\n\n  if (!validate(value)) {\n    return undefined\n  }\n\n  return normalize(value)\n}\n\nfunction asNegativeValue(modifier, lookup = {}, validate) {\n  let positiveValue = lookup[modifier]\n\n  if (positiveValue !== undefined) {\n    return negateValue(positiveValue)\n  }\n\n  if (isArbitraryValue(modifier)) {\n    let resolved = resolveArbitraryValue(modifier, validate)\n\n    if (resolved === undefined) {\n      return undefined\n    }\n\n    return negateValue(resolved)\n  }\n}\n\nexport function asValue(modifier, options = {}, { validate = () => true } = {}) {\n  let value = options.values?.[modifier]\n\n  if (value !== undefined) {\n    return value\n  }\n\n  if (options.supportsNegativeValues && modifier.startsWith('-')) {\n    return asNegativeValue(modifier.slice(1), options.values, validate)\n  }\n\n  return resolveArbitraryValue(modifier, validate)\n}\n\nfunction isArbitraryValue(input) {\n  return input.startsWith('[') && input.endsWith(']')\n}\n\nfunction splitAlpha(modifier) {\n  let slashIdx = modifier.lastIndexOf('/')\n\n  if (slashIdx === -1 || slashIdx === modifier.length - 1) {\n    return [modifier]\n  }\n\n  return [modifier.slice(0, slashIdx), modifier.slice(slashIdx + 1)]\n}\n\nexport function parseColorFormat(value) {\n  if (typeof value === 'string' && value.includes('<alpha-value>')) {\n    let oldValue = value\n\n    return ({ opacityValue = 1 }) => oldValue.replace('<alpha-value>', opacityValue)\n  }\n\n  return value\n}\n\nexport function asColor(modifier, options = {}, { tailwindConfig = {} } = {}) {\n  if (options.values?.[modifier] !== undefined) {\n    return parseColorFormat(options.values?.[modifier])\n  }\n\n  let [color, alpha] = splitAlpha(modifier)\n\n  if (alpha !== undefined) {\n    let normalizedColor =\n      options.values?.[color] ?? (isArbitraryValue(color) ? color.slice(1, -1) : undefined)\n\n    if (normalizedColor === undefined) {\n      return undefined\n    }\n\n    normalizedColor = parseColorFormat(normalizedColor)\n\n    if (isArbitraryValue(alpha)) {\n      return withAlphaValue(normalizedColor, alpha.slice(1, -1))\n    }\n\n    if (tailwindConfig.theme?.opacity?.[alpha] === undefined) {\n      return undefined\n    }\n\n    return withAlphaValue(normalizedColor, tailwindConfig.theme.opacity[alpha])\n  }\n\n  return asValue(modifier, options, { validate: validateColor })\n}\n\nexport function asLookupValue(modifier, options = {}) {\n  return options.values?.[modifier]\n}\n\nfunction guess(validate) {\n  return (modifier, options) => {\n    return asValue(modifier, options, { validate })\n  }\n}\n\nlet typeMap = {\n  any: asValue,\n  color: asColor,\n  url: guess(url),\n  image: guess(image),\n  length: guess(length),\n  percentage: guess(percentage),\n  position: guess(position),\n  lookup: asLookupValue,\n  'generic-name': guess(genericName),\n  'family-name': guess(familyName),\n  number: guess(number),\n  'line-width': guess(lineWidth),\n  'absolute-size': guess(absoluteSize),\n  'relative-size': guess(relativeSize),\n  shadow: guess(shadow),\n}\n\nlet supportedTypes = Object.keys(typeMap)\n\nfunction splitAtFirst(input, delim) {\n  let idx = input.indexOf(delim)\n  if (idx === -1) return [undefined, input]\n  return [input.slice(0, idx), input.slice(idx + 1)]\n}\n\nexport function coerceValue(types, modifier, options, tailwindConfig) {\n  if (isArbitraryValue(modifier)) {\n    let arbitraryValue = modifier.slice(1, -1)\n    let [explicitType, value] = splitAtFirst(arbitraryValue, ':')\n\n    // It could be that this resolves to `url(https` which is not a valid\n    // identifier. We currently only support \"simple\" words with dashes or\n    // underscores. E.g.: family-name\n    if (!/^[\\w-_]+$/g.test(explicitType)) {\n      value = arbitraryValue\n    }\n\n    //\n    else if (explicitType !== undefined && !supportedTypes.includes(explicitType)) {\n      return []\n    }\n\n    if (value.length > 0 && supportedTypes.includes(explicitType)) {\n      return [asValue(`[${value}]`, options), explicitType]\n    }\n  }\n\n  // Find first matching type\n  for (let type of [].concat(types)) {\n    let result = typeMap[type](modifier, options, { tailwindConfig })\n    if (result !== undefined) return [result, type]\n  }\n\n  return []\n}\n"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,yBAA3B;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AACA,SAASC,cAAT,QAA+B,qBAA/B;AACA,SACEC,SADF,EAEEC,MAFF,EAGEC,MAHF,EAIEC,UAJF,EAKEC,GALF,EAMEC,KAAK,IAAIC,aANX,EAOEC,WAPF,EAQEC,UARF,EASEC,KATF,EAUEC,YAVF,EAWEC,YAXF,EAYEC,QAZF,EAaEC,SAbF,EAcEC,MAdF,QAeO,aAfP;AAgBA,OAAOC,WAAP,MAAwB,eAAxB;AAEA,OAAO,SAASC,gBAAT,CAA0BC,SAA1B,EAAqCC,WAArC,EAAkD;EACvD,IAAIC,MAAM,GAAGtB,cAAc,CAAEoB,SAAD,IAAe;IACzCA,SAAS,CAACG,WAAV,CAAuBC,GAAD,IAAS;MAC7B,IAAIC,YAAY,GAAGJ,WAAW,CAACG,GAAG,CAACE,KAAL,CAA9B;MACAF,GAAG,CAACE,KAAJ,GAAYD,YAAZ;;MACA,IAAID,GAAG,CAACG,IAAJ,IAAYH,GAAG,CAACG,IAAJ,CAASD,KAAzB,EAAgC;QAC9BF,GAAG,CAACG,IAAJ,CAASD,KAAT,GAAiBzB,YAAY,CAACuB,GAAG,CAACG,IAAJ,CAASD,KAAV,CAA7B;MACD;IACF,CAND;EAOD,CAR0B,CAA3B;EAUA,IAAIE,MAAM,GAAGN,MAAM,CAACO,WAAP,CAAmBT,SAAnB,CAAb;EAEA,OAAOQ,MAAP;AACD;;AAED,SAASE,qBAAT,CAA+BC,QAA/B,EAAyCC,QAAzC,EAAmD;EACjD,IAAI,CAACC,gBAAgB,CAACF,QAAD,CAArB,EAAiC;IAC/B,OAAOG,SAAP;EACD;;EAED,IAAIR,KAAK,GAAGK,QAAQ,CAACI,KAAT,CAAe,CAAf,EAAkB,CAAC,CAAnB,CAAZ;;EAEA,IAAI,CAACH,QAAQ,CAACN,KAAD,CAAb,EAAsB;IACpB,OAAOQ,SAAP;EACD;;EAED,OAAO/B,SAAS,CAACuB,KAAD,CAAhB;AACD;;AAED,SAASU,eAAT,CAAyBL,QAAzB,EAA0D;EAAA,IAAvBM,MAAuB,uEAAd,EAAc;EAAA,IAAVL,QAAU;EACxD,IAAIM,aAAa,GAAGD,MAAM,CAACN,QAAD,CAA1B;;EAEA,IAAIO,aAAa,KAAKJ,SAAtB,EAAiC;IAC/B,OAAOhB,WAAW,CAACoB,aAAD,CAAlB;EACD;;EAED,IAAIL,gBAAgB,CAACF,QAAD,CAApB,EAAgC;IAC9B,IAAIQ,QAAQ,GAAGT,qBAAqB,CAACC,QAAD,EAAWC,QAAX,CAApC;;IAEA,IAAIO,QAAQ,KAAKL,SAAjB,EAA4B;MAC1B,OAAOA,SAAP;IACD;;IAED,OAAOhB,WAAW,CAACqB,QAAD,CAAlB;EACD;AACF;;AAED,OAAO,SAASC,OAAT,CAAiBT,QAAjB,EAAyE;EAAA,IAA9CU,OAA8C,uEAApC,EAAoC;EAAA,IAAhC;IAAET,QAAQ,GAAG,MAAM;EAAnB,CAAgC,uEAAJ,EAAI;EAC9E,IAAIN,KAAK,GAAGe,OAAO,CAACC,MAAR,GAAiBX,QAAjB,CAAZ;;EAEA,IAAIL,KAAK,KAAKQ,SAAd,EAAyB;IACvB,OAAOR,KAAP;EACD;;EAED,IAAIe,OAAO,CAACE,sBAAR,IAAkCZ,QAAQ,CAACa,UAAT,CAAoB,GAApB,CAAtC,EAAgE;IAC9D,OAAOR,eAAe,CAACL,QAAQ,CAACI,KAAT,CAAe,CAAf,CAAD,EAAoBM,OAAO,CAACC,MAA5B,EAAoCV,QAApC,CAAtB;EACD;;EAED,OAAOF,qBAAqB,CAACC,QAAD,EAAWC,QAAX,CAA5B;AACD;;AAED,SAASC,gBAAT,CAA0BY,KAA1B,EAAiC;EAC/B,OAAOA,KAAK,CAACD,UAAN,CAAiB,GAAjB,KAAyBC,KAAK,CAACC,QAAN,CAAe,GAAf,CAAhC;AACD;;AAED,SAASC,UAAT,CAAoBhB,QAApB,EAA8B;EAC5B,IAAIiB,QAAQ,GAAGjB,QAAQ,CAACkB,WAAT,CAAqB,GAArB,CAAf;;EAEA,IAAID,QAAQ,KAAK,CAAC,CAAd,IAAmBA,QAAQ,KAAKjB,QAAQ,CAAC3B,MAAT,GAAkB,CAAtD,EAAyD;IACvD,OAAO,CAAC2B,QAAD,CAAP;EACD;;EAED,OAAO,CAACA,QAAQ,CAACI,KAAT,CAAe,CAAf,EAAkBa,QAAlB,CAAD,EAA8BjB,QAAQ,CAACI,KAAT,CAAea,QAAQ,GAAG,CAA1B,CAA9B,CAAP;AACD;;AAED,OAAO,SAASE,gBAAT,CAA0BxB,KAA1B,EAAiC;EACtC,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACyB,QAAN,CAAe,eAAf,CAAjC,EAAkE;IAChE,IAAIC,QAAQ,GAAG1B,KAAf;IAEA,OAAO;MAAA,IAAC;QAAE2B,YAAY,GAAG;MAAjB,CAAD;MAAA,OAA0BD,QAAQ,CAACE,OAAT,CAAiB,eAAjB,EAAkCD,YAAlC,CAA1B;IAAA,CAAP;EACD;;EAED,OAAO3B,KAAP;AACD;AAED,OAAO,SAAS6B,OAAT,CAAiBxB,QAAjB,EAAuE;EAAA,IAA5CU,OAA4C,uEAAlC,EAAkC;EAAA,IAA9B;IAAEe,cAAc,GAAG;EAAnB,CAA8B,uEAAJ,EAAI;;EAC5E,IAAIf,OAAO,CAACC,MAAR,GAAiBX,QAAjB,MAA+BG,SAAnC,EAA8C;IAC5C,OAAOgB,gBAAgB,CAACT,OAAO,CAACC,MAAR,GAAiBX,QAAjB,CAAD,CAAvB;EACD;;EAED,IAAI,CAACvB,KAAD,EAAQiD,KAAR,IAAiBV,UAAU,CAAChB,QAAD,CAA/B;;EAEA,IAAI0B,KAAK,KAAKvB,SAAd,EAAyB;IACvB,IAAIwB,eAAe,GACjBjB,OAAO,CAACC,MAAR,GAAiBlC,KAAjB,MAA4ByB,gBAAgB,CAACzB,KAAD,CAAhB,GAA0BA,KAAK,CAAC2B,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAA1B,GAA+CD,SAA3E,CADF;;IAGA,IAAIwB,eAAe,KAAKxB,SAAxB,EAAmC;MACjC,OAAOA,SAAP;IACD;;IAEDwB,eAAe,GAAGR,gBAAgB,CAACQ,eAAD,CAAlC;;IAEA,IAAIzB,gBAAgB,CAACwB,KAAD,CAApB,EAA6B;MAC3B,OAAOvD,cAAc,CAACwD,eAAD,EAAkBD,KAAK,CAACtB,KAAN,CAAY,CAAZ,EAAe,CAAC,CAAhB,CAAlB,CAArB;IACD;;IAED,IAAIqB,cAAc,CAACG,KAAf,EAAsBC,OAAtB,GAAgCH,KAAhC,MAA2CvB,SAA/C,EAA0D;MACxD,OAAOA,SAAP;IACD;;IAED,OAAOhC,cAAc,CAACwD,eAAD,EAAkBF,cAAc,CAACG,KAAf,CAAqBC,OAArB,CAA6BH,KAA7B,CAAlB,CAArB;EACD;;EAED,OAAOjB,OAAO,CAACT,QAAD,EAAWU,OAAX,EAAoB;IAAET,QAAQ,EAAEvB;EAAZ,CAApB,CAAd;AACD;AAED,OAAO,SAASoD,aAAT,CAAuB9B,QAAvB,EAA+C;EAAA,IAAdU,OAAc,uEAAJ,EAAI;EACpD,OAAOA,OAAO,CAACC,MAAR,GAAiBX,QAAjB,CAAP;AACD;;AAED,SAAS+B,KAAT,CAAe9B,QAAf,EAAyB;EACvB,OAAO,CAACD,QAAD,EAAWU,OAAX,KAAuB;IAC5B,OAAOD,OAAO,CAACT,QAAD,EAAWU,OAAX,EAAoB;MAAET;IAAF,CAApB,CAAd;EACD,CAFD;AAGD;;AAED,IAAI+B,OAAO,GAAG;EACZC,GAAG,EAAExB,OADO;EAEZhC,KAAK,EAAE+C,OAFK;EAGZhD,GAAG,EAAEuD,KAAK,CAACvD,GAAD,CAHE;EAIZK,KAAK,EAAEkD,KAAK,CAAClD,KAAD,CAJA;EAKZR,MAAM,EAAE0D,KAAK,CAAC1D,MAAD,CALD;EAMZE,UAAU,EAAEwD,KAAK,CAACxD,UAAD,CANL;EAOZS,QAAQ,EAAE+C,KAAK,CAAC/C,QAAD,CAPH;EAQZsB,MAAM,EAAEwB,aARI;EASZ,gBAAgBC,KAAK,CAACpD,WAAD,CATT;EAUZ,eAAeoD,KAAK,CAACnD,UAAD,CAVR;EAWZN,MAAM,EAAEyD,KAAK,CAACzD,MAAD,CAXD;EAYZ,cAAcyD,KAAK,CAAC9C,SAAD,CAZP;EAaZ,iBAAiB8C,KAAK,CAACjD,YAAD,CAbV;EAcZ,iBAAiBiD,KAAK,CAAChD,YAAD,CAdV;EAeZG,MAAM,EAAE6C,KAAK,CAAC7C,MAAD;AAfD,CAAd;AAkBA,IAAIgD,cAAc,GAAGC,MAAM,CAACC,IAAP,CAAYJ,OAAZ,CAArB;;AAEA,SAASK,YAAT,CAAsBvB,KAAtB,EAA6BwB,KAA7B,EAAoC;EAClC,IAAIC,GAAG,GAAGzB,KAAK,CAAC0B,OAAN,CAAcF,KAAd,CAAV;EACA,IAAIC,GAAG,KAAK,CAAC,CAAb,EAAgB,OAAO,CAACpC,SAAD,EAAYW,KAAZ,CAAP;EAChB,OAAO,CAACA,KAAK,CAACV,KAAN,CAAY,CAAZ,EAAemC,GAAf,CAAD,EAAsBzB,KAAK,CAACV,KAAN,CAAYmC,GAAG,GAAG,CAAlB,CAAtB,CAAP;AACD;;AAED,OAAO,SAASE,WAAT,CAAqBC,KAArB,EAA4B1C,QAA5B,EAAsCU,OAAtC,EAA+Ce,cAA/C,EAA+D;EACpE,IAAIvB,gBAAgB,CAACF,QAAD,CAApB,EAAgC;IAC9B,IAAI2C,cAAc,GAAG3C,QAAQ,CAACI,KAAT,CAAe,CAAf,EAAkB,CAAC,CAAnB,CAArB;IACA,IAAI,CAACwC,YAAD,EAAejD,KAAf,IAAwB0C,YAAY,CAACM,cAAD,EAAiB,GAAjB,CAAxC,CAF8B,CAI9B;IACA;IACA;;IACA,IAAI,CAAC,aAAaE,IAAb,CAAkBD,YAAlB,CAAL,EAAsC;MACpCjD,KAAK,GAAGgD,cAAR;IACD,CAFD,CAIA;IAJA,KAKK,IAAIC,YAAY,KAAKzC,SAAjB,IAA8B,CAAC+B,cAAc,CAACd,QAAf,CAAwBwB,YAAxB,CAAnC,EAA0E;MAC7E,OAAO,EAAP;IACD;;IAED,IAAIjD,KAAK,CAACtB,MAAN,GAAe,CAAf,IAAoB6D,cAAc,CAACd,QAAf,CAAwBwB,YAAxB,CAAxB,EAA+D;MAC7D,OAAO,CAACnC,OAAO,CAAE,IAAGd,KAAM,GAAX,EAAee,OAAf,CAAR,EAAiCkC,YAAjC,CAAP;IACD;EACF,CApBmE,CAsBpE;;;EACA,KAAK,IAAIE,IAAT,IAAiB,GAAGC,MAAH,CAAUL,KAAV,CAAjB,EAAmC;IACjC,IAAI7C,MAAM,GAAGmC,OAAO,CAACc,IAAD,CAAP,CAAc9C,QAAd,EAAwBU,OAAxB,EAAiC;MAAEe;IAAF,CAAjC,CAAb;IACA,IAAI5B,MAAM,KAAKM,SAAf,EAA0B,OAAO,CAACN,MAAD,EAASiD,IAAT,CAAP;EAC3B;;EAED,OAAO,EAAP;AACD"},"metadata":{},"sourceType":"module"}