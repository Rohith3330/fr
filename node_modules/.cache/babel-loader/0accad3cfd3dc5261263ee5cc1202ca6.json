{"ast":null,"code":"\"use strict\";\n\nconst {\n  cpus\n} = require('os');\n\nconst {\n  Worker: JestWorker\n} = require('jest-worker');\n\nconst {\n  getESLintOptions\n} = require('./options');\n\nconst {\n  jsonStringifyReplacerSortKeys\n} = require('./utils');\n/** @type {{[key: string]: any}} */\n\n\nconst cache = {};\n/** @typedef {import('eslint').ESLint} ESLint */\n\n/** @typedef {import('eslint').ESLint.LintResult} LintResult */\n\n/** @typedef {import('./options').Options} Options */\n\n/** @typedef {() => Promise<void>} AsyncTask */\n\n/** @typedef {(files: string|string[]) => Promise<LintResult[]>} LintTask */\n\n/** @typedef {{threads: number, ESLint: ESLint, eslint: ESLint, lintFiles: LintTask, cleanup: AsyncTask}} Linter */\n\n/** @typedef {JestWorker & {lintFiles: LintTask}} Worker */\n\n/**\n * @param {Options} options\n * @returns {Linter}\n */\n\nfunction loadESLint(options) {\n  const {\n    eslintPath\n  } = options;\n\n  const {\n    ESLint\n  } = require(eslintPath || 'eslint'); // Filter out loader options before passing the options to ESLint.\n\n\n  const eslint = new ESLint(getESLintOptions(options));\n  return {\n    threads: 1,\n    ESLint,\n    eslint,\n    lintFiles: async files => {\n      const results = await eslint.lintFiles(files); // istanbul ignore else\n\n      if (options.fix) {\n        await ESLint.outputFixes(results);\n      }\n\n      return results;\n    },\n    // no-op for non-threaded\n    cleanup: async () => {}\n  };\n}\n/**\n * @param {string|undefined} key\n * @param {number} poolSize\n * @param {Options} options\n * @returns {Linter}\n */\n\n\nfunction loadESLintThreaded(key, poolSize, options) {\n  const cacheKey = getCacheKey(key, options);\n  const {\n    eslintPath = 'eslint'\n  } = options;\n\n  const source = require.resolve('./worker');\n\n  const workerOptions = {\n    enableWorkerThreads: true,\n    numWorkers: poolSize,\n    setupArgs: [{\n      eslintPath,\n      eslintOptions: getESLintOptions(options)\n    }]\n  };\n  const local = loadESLint(options);\n  let worker =\n  /** @type {Worker?} */\n  new JestWorker(source, workerOptions);\n  /** @type {Linter} */\n\n  const context = { ...local,\n    threads: poolSize,\n    lintFiles: async files => worker && (await worker.lintFiles(files)) ||\n    /* istanbul ignore next */\n    [],\n    cleanup: async () => {\n      cache[cacheKey] = local;\n\n      context.lintFiles = files => local.lintFiles(files);\n\n      if (worker) {\n        worker.end();\n        worker = null;\n      }\n    }\n  };\n  return context;\n}\n/**\n * @param {string|undefined} key\n * @param {Options} options\n * @returns {Linter}\n */\n\n\nfunction getESLint(key, _ref) {\n  let {\n    threads,\n    ...options\n  } = _ref;\n  const max = typeof threads !== 'number' ? threads ? cpus().length - 1 : 1 :\n  /* istanbul ignore next */\n  threads;\n  const cacheKey = getCacheKey(key, {\n    threads,\n    ...options\n  });\n\n  if (!cache[cacheKey]) {\n    cache[cacheKey] = max > 1 ? loadESLintThreaded(key, max, options) : loadESLint(options);\n  }\n\n  return cache[cacheKey];\n}\n/**\n * @param {string|undefined} key\n * @param {Options} options\n * @returns {string}\n */\n\n\nfunction getCacheKey(key, options) {\n  return JSON.stringify({\n    key,\n    options\n  }, jsonStringifyReplacerSortKeys);\n}\n\nmodule.exports = {\n  loadESLint,\n  loadESLintThreaded,\n  getESLint\n};","map":{"version":3,"names":["cpus","require","Worker","JestWorker","getESLintOptions","jsonStringifyReplacerSortKeys","cache","loadESLint","options","eslintPath","ESLint","eslint","threads","lintFiles","files","results","fix","outputFixes","cleanup","loadESLintThreaded","key","poolSize","cacheKey","getCacheKey","source","resolve","workerOptions","enableWorkerThreads","numWorkers","setupArgs","eslintOptions","local","worker","context","end","getESLint","max","length","JSON","stringify","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-webpack-plugin/dist/getESLint.js"],"sourcesContent":["\"use strict\";\n\nconst {\n  cpus\n} = require('os');\n\nconst {\n  Worker: JestWorker\n} = require('jest-worker');\n\nconst {\n  getESLintOptions\n} = require('./options');\n\nconst {\n  jsonStringifyReplacerSortKeys\n} = require('./utils');\n/** @type {{[key: string]: any}} */\n\n\nconst cache = {};\n/** @typedef {import('eslint').ESLint} ESLint */\n\n/** @typedef {import('eslint').ESLint.LintResult} LintResult */\n\n/** @typedef {import('./options').Options} Options */\n\n/** @typedef {() => Promise<void>} AsyncTask */\n\n/** @typedef {(files: string|string[]) => Promise<LintResult[]>} LintTask */\n\n/** @typedef {{threads: number, ESLint: ESLint, eslint: ESLint, lintFiles: LintTask, cleanup: AsyncTask}} Linter */\n\n/** @typedef {JestWorker & {lintFiles: LintTask}} Worker */\n\n/**\n * @param {Options} options\n * @returns {Linter}\n */\n\nfunction loadESLint(options) {\n  const {\n    eslintPath\n  } = options;\n\n  const {\n    ESLint\n  } = require(eslintPath || 'eslint'); // Filter out loader options before passing the options to ESLint.\n\n\n  const eslint = new ESLint(getESLintOptions(options));\n  return {\n    threads: 1,\n    ESLint,\n    eslint,\n    lintFiles: async files => {\n      const results = await eslint.lintFiles(files); // istanbul ignore else\n\n      if (options.fix) {\n        await ESLint.outputFixes(results);\n      }\n\n      return results;\n    },\n    // no-op for non-threaded\n    cleanup: async () => {}\n  };\n}\n/**\n * @param {string|undefined} key\n * @param {number} poolSize\n * @param {Options} options\n * @returns {Linter}\n */\n\n\nfunction loadESLintThreaded(key, poolSize, options) {\n  const cacheKey = getCacheKey(key, options);\n  const {\n    eslintPath = 'eslint'\n  } = options;\n\n  const source = require.resolve('./worker');\n\n  const workerOptions = {\n    enableWorkerThreads: true,\n    numWorkers: poolSize,\n    setupArgs: [{\n      eslintPath,\n      eslintOptions: getESLintOptions(options)\n    }]\n  };\n  const local = loadESLint(options);\n  let worker =\n  /** @type {Worker?} */\n  new JestWorker(source, workerOptions);\n  /** @type {Linter} */\n\n  const context = { ...local,\n    threads: poolSize,\n    lintFiles: async files => worker && (await worker.lintFiles(files)) ||\n    /* istanbul ignore next */\n    [],\n    cleanup: async () => {\n      cache[cacheKey] = local;\n\n      context.lintFiles = files => local.lintFiles(files);\n\n      if (worker) {\n        worker.end();\n        worker = null;\n      }\n    }\n  };\n  return context;\n}\n/**\n * @param {string|undefined} key\n * @param {Options} options\n * @returns {Linter}\n */\n\n\nfunction getESLint(key, {\n  threads,\n  ...options\n}) {\n  const max = typeof threads !== 'number' ? threads ? cpus().length - 1 : 1 :\n  /* istanbul ignore next */\n  threads;\n  const cacheKey = getCacheKey(key, {\n    threads,\n    ...options\n  });\n\n  if (!cache[cacheKey]) {\n    cache[cacheKey] = max > 1 ? loadESLintThreaded(key, max, options) : loadESLint(options);\n  }\n\n  return cache[cacheKey];\n}\n/**\n * @param {string|undefined} key\n * @param {Options} options\n * @returns {string}\n */\n\n\nfunction getCacheKey(key, options) {\n  return JSON.stringify({\n    key,\n    options\n  }, jsonStringifyReplacerSortKeys);\n}\n\nmodule.exports = {\n  loadESLint,\n  loadESLintThreaded,\n  getESLint\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}