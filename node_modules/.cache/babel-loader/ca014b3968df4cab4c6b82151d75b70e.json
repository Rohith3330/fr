{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"ajv/dist/compile/codegen\");\n\nconst transform = {\n  trimStart: s => s.trimStart(),\n  trimEnd: s => s.trimEnd(),\n  trimLeft: s => s.trimStart(),\n  trimRight: s => s.trimEnd(),\n  trim: s => s.trim(),\n  toLowerCase: s => s.toLowerCase(),\n  toUpperCase: s => s.toUpperCase(),\n  toEnumCase: (s, cfg) => (cfg === null || cfg === void 0 ? void 0 : cfg.hash[configKey(s)]) || s\n};\nconst getDef = Object.assign(_getDef, {\n  transform\n});\n\nfunction _getDef() {\n  return {\n    keyword: \"transform\",\n    schemaType: \"array\",\n    before: \"enum\",\n\n    code(cxt) {\n      const {\n        gen,\n        data,\n        schema,\n        parentSchema,\n        it\n      } = cxt;\n      const {\n        parentData,\n        parentDataProperty\n      } = it;\n      const tNames = schema;\n      if (!tNames.length) return;\n      let cfg;\n\n      if (tNames.includes(\"toEnumCase\")) {\n        const config = getEnumCaseCfg(parentSchema);\n        cfg = gen.scopeValue(\"obj\", {\n          ref: config,\n          code: (0, codegen_1.stringify)(config)\n        });\n      }\n\n      gen.if((0, codegen_1._)`typeof ${data} == \"string\" && ${parentData} !== undefined`, () => {\n        gen.assign(data, transformExpr(tNames.slice()));\n        gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, data);\n      });\n\n      function transformExpr(ts) {\n        if (!ts.length) return data;\n        const t = ts.pop();\n        if (!(t in transform)) throw new Error(`transform: unknown transformation ${t}`);\n        const func = gen.scopeValue(\"func\", {\n          ref: transform[t],\n          code: (0, codegen_1._)`require(\"ajv-keywords/dist/definitions/transform\").transform${(0, codegen_1.getProperty)(t)}`\n        });\n        const arg = transformExpr(ts);\n        return cfg && t === \"toEnumCase\" ? (0, codegen_1._)`${func}(${arg}, ${cfg})` : (0, codegen_1._)`${func}(${arg})`;\n      }\n    },\n\n    metaSchema: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n        enum: Object.keys(transform)\n      }\n    }\n  };\n}\n\nfunction getEnumCaseCfg(parentSchema) {\n  // build hash table to enum values\n  const cfg = {\n    hash: {}\n  }; // requires `enum` in the same schema as transform\n\n  if (!parentSchema.enum) throw new Error('transform: \"toEnumCase\" requires \"enum\"');\n\n  for (const v of parentSchema.enum) {\n    if (typeof v !== \"string\") continue;\n    const k = configKey(v); // requires all `enum` values have unique keys\n\n    if (cfg.hash[k]) {\n      throw new Error('transform: \"toEnumCase\" requires all lowercased \"enum\" values to be unique');\n    }\n\n    cfg.hash[k] = v;\n  }\n\n  return cfg;\n}\n\nfunction configKey(s) {\n  return s.toLowerCase();\n}\n\nexports.default = getDef;\nmodule.exports = getDef;","map":{"version":3,"mappings":"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","names":["transform","trimStart","s","trimEnd","trimLeft","trimRight","trim","toLowerCase","toUpperCase","toEnumCase","cfg","hash","configKey","getDef","Object","assign","_getDef","keyword","schemaType","before","code","cxt","gen","data","schema","parentSchema","it","parentData","parentDataProperty","tNames","length","includes","config","getEnumCaseCfg","scopeValue","ref","if","transformExpr","slice","ts","t","pop","Error","func","arg","metaSchema","type","items","enum","keys","v","k","exports","module"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-webpack-plugin\\node_modules\\ajv-keywords\\src\\definitions\\transform.ts"],"sourcesContent":["import type {CodeKeywordDefinition, AnySchemaObject, KeywordCxt, Code, Name} from \"ajv\"\nimport {_, stringify, getProperty} from \"ajv/dist/compile/codegen\"\n\ntype TransformName =\n  | \"trimStart\"\n  | \"trimEnd\"\n  | \"trimLeft\"\n  | \"trimRight\"\n  | \"trim\"\n  | \"toLowerCase\"\n  | \"toUpperCase\"\n  | \"toEnumCase\"\n\ninterface TransformConfig {\n  hash: Record<string, string | undefined>\n}\n\ntype Transform = (s: string, cfg?: TransformConfig) => string\n\nconst transform: {[key in TransformName]: Transform} = {\n  trimStart: (s) => s.trimStart(),\n  trimEnd: (s) => s.trimEnd(),\n  trimLeft: (s) => s.trimStart(),\n  trimRight: (s) => s.trimEnd(),\n  trim: (s) => s.trim(),\n  toLowerCase: (s) => s.toLowerCase(),\n  toUpperCase: (s) => s.toUpperCase(),\n  toEnumCase: (s, cfg) => cfg?.hash[configKey(s)] || s,\n}\n\nconst getDef: (() => CodeKeywordDefinition) & {\n  transform: typeof transform\n} = Object.assign(_getDef, {transform})\n\nfunction _getDef(): CodeKeywordDefinition {\n  return {\n    keyword: \"transform\",\n    schemaType: \"array\",\n    before: \"enum\",\n    code(cxt: KeywordCxt) {\n      const {gen, data, schema, parentSchema, it} = cxt\n      const {parentData, parentDataProperty} = it\n      const tNames: string[] = schema\n      if (!tNames.length) return\n      let cfg: Name | undefined\n      if (tNames.includes(\"toEnumCase\")) {\n        const config = getEnumCaseCfg(parentSchema)\n        cfg = gen.scopeValue(\"obj\", {ref: config, code: stringify(config)})\n      }\n      gen.if(_`typeof ${data} == \"string\" && ${parentData} !== undefined`, () => {\n        gen.assign(data, transformExpr(tNames.slice()))\n        gen.assign(_`${parentData}[${parentDataProperty}]`, data)\n      })\n\n      function transformExpr(ts: string[]): Code {\n        if (!ts.length) return data\n        const t = ts.pop() as string\n        if (!(t in transform)) throw new Error(`transform: unknown transformation ${t}`)\n        const func = gen.scopeValue(\"func\", {\n          ref: transform[t as TransformName],\n          code: _`require(\"ajv-keywords/dist/definitions/transform\").transform${getProperty(t)}`,\n        })\n        const arg = transformExpr(ts)\n        return cfg && t === \"toEnumCase\" ? _`${func}(${arg}, ${cfg})` : _`${func}(${arg})`\n      }\n    },\n    metaSchema: {\n      type: \"array\",\n      items: {type: \"string\", enum: Object.keys(transform)},\n    },\n  }\n}\n\nfunction getEnumCaseCfg(parentSchema: AnySchemaObject): TransformConfig {\n  // build hash table to enum values\n  const cfg: TransformConfig = {hash: {}}\n\n  // requires `enum` in the same schema as transform\n  if (!parentSchema.enum) throw new Error('transform: \"toEnumCase\" requires \"enum\"')\n  for (const v of parentSchema.enum) {\n    if (typeof v !== \"string\") continue\n    const k = configKey(v)\n    // requires all `enum` values have unique keys\n    if (cfg.hash[k]) {\n      throw new Error('transform: \"toEnumCase\" requires all lowercased \"enum\" values to be unique')\n    }\n    cfg.hash[k] = v\n  }\n\n  return cfg\n}\n\nfunction configKey(s: string): string {\n  return s.toLowerCase()\n}\n\nexport default getDef\nmodule.exports = getDef\n"]},"metadata":{},"sourceType":"script"}