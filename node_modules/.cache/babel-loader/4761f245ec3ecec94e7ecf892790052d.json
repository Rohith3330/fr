{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _ScopeManager_options;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScopeManager = void 0;\n\nconst assert_1 = require(\"./assert\");\n\nconst scope_1 = require(\"./scope\");\n\nconst ClassFieldInitializerScope_1 = require(\"./scope/ClassFieldInitializerScope\");\n\nconst ClassStaticBlockScope_1 = require(\"./scope/ClassStaticBlockScope\");\n\nclass ScopeManager {\n  constructor(options) {\n    _ScopeManager_options.set(this, void 0);\n\n    this.scopes = [];\n    this.globalScope = null;\n    this.nodeToScope = new WeakMap();\n    this.currentScope = null;\n\n    __classPrivateFieldSet(this, _ScopeManager_options, options, \"f\");\n\n    this.declaredVariables = new WeakMap();\n  }\n\n  get variables() {\n    const variables = new Set();\n\n    function recurse(scope) {\n      scope.variables.forEach(v => variables.add(v));\n      scope.childScopes.forEach(recurse);\n    }\n\n    this.scopes.forEach(recurse);\n    return Array.from(variables).sort((a, b) => a.$id - b.$id);\n  }\n\n  isGlobalReturn() {\n    return __classPrivateFieldGet(this, _ScopeManager_options, \"f\").globalReturn === true;\n  }\n\n  isModule() {\n    return __classPrivateFieldGet(this, _ScopeManager_options, \"f\").sourceType === 'module';\n  }\n\n  isImpliedStrict() {\n    return __classPrivateFieldGet(this, _ScopeManager_options, \"f\").impliedStrict === true;\n  }\n\n  isStrictModeSupported() {\n    return __classPrivateFieldGet(this, _ScopeManager_options, \"f\").ecmaVersion != null && __classPrivateFieldGet(this, _ScopeManager_options, \"f\").ecmaVersion >= 5;\n  }\n\n  isES6() {\n    return __classPrivateFieldGet(this, _ScopeManager_options, \"f\").ecmaVersion != null && __classPrivateFieldGet(this, _ScopeManager_options, \"f\").ecmaVersion >= 6;\n  }\n  /**\n   * Get the variables that a given AST node defines. The gotten variables' `def[].node`/`def[].parent` property is the node.\n   * If the node does not define any variable, this returns an empty array.\n   * @param node An AST node to get their variables.\n   * @public\n   */\n\n\n  getDeclaredVariables(node) {\n    var _a;\n\n    return (_a = this.declaredVariables.get(node)) !== null && _a !== void 0 ? _a : [];\n  }\n  /**\n   * Get the scope of a given AST node. The gotten scope's `block` property is the node.\n   * This method never returns `function-expression-name` scope. If the node does not have their scope, this returns `null`.\n   *\n   * @param node An AST node to get their scope.\n   * @param inner If the node has multiple scopes, this returns the outermost scope normally.\n   *                If `inner` is `true` then this returns the innermost scope.\n   * @public\n   */\n\n\n  acquire(node) {\n    let inner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    var _a;\n\n    function predicate(testScope) {\n      if (testScope.type === 'function' && testScope.functionExpressionScope) {\n        return false;\n      }\n\n      return true;\n    }\n\n    const scopes = this.nodeToScope.get(node);\n\n    if (!scopes || scopes.length === 0) {\n      return null;\n    } // Heuristic selection from all scopes.\n    // If you would like to get all scopes, please use ScopeManager#acquireAll.\n\n\n    if (scopes.length === 1) {\n      return scopes[0];\n    }\n\n    if (inner) {\n      for (let i = scopes.length - 1; i >= 0; --i) {\n        const scope = scopes[i];\n\n        if (predicate(scope)) {\n          return scope;\n        }\n      }\n\n      return null;\n    }\n\n    return (_a = scopes.find(predicate)) !== null && _a !== void 0 ? _a : null;\n  }\n\n  nestScope(scope) {\n    if (scope instanceof scope_1.GlobalScope) {\n      (0, assert_1.assert)(this.currentScope === null);\n      this.globalScope = scope;\n    }\n\n    this.currentScope = scope;\n    return scope;\n  }\n\n  nestBlockScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.BlockScope(this, this.currentScope, node));\n  }\n\n  nestCatchScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.CatchScope(this, this.currentScope, node));\n  }\n\n  nestClassScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.ClassScope(this, this.currentScope, node));\n  }\n\n  nestClassFieldInitializerScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new ClassFieldInitializerScope_1.ClassFieldInitializerScope(this, this.currentScope, node));\n  }\n\n  nestClassStaticBlockScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new ClassStaticBlockScope_1.ClassStaticBlockScope(this, this.currentScope, node));\n  }\n\n  nestConditionalTypeScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.ConditionalTypeScope(this, this.currentScope, node));\n  }\n\n  nestForScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.ForScope(this, this.currentScope, node));\n  }\n\n  nestFunctionExpressionNameScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.FunctionExpressionNameScope(this, this.currentScope, node));\n  }\n\n  nestFunctionScope(node, isMethodDefinition) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.FunctionScope(this, this.currentScope, node, isMethodDefinition));\n  }\n\n  nestFunctionTypeScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.FunctionTypeScope(this, this.currentScope, node));\n  }\n\n  nestGlobalScope(node) {\n    return this.nestScope(new scope_1.GlobalScope(this, node));\n  }\n\n  nestMappedTypeScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.MappedTypeScope(this, this.currentScope, node));\n  }\n\n  nestModuleScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.ModuleScope(this, this.currentScope, node));\n  }\n\n  nestSwitchScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.SwitchScope(this, this.currentScope, node));\n  }\n\n  nestTSEnumScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.TSEnumScope(this, this.currentScope, node));\n  }\n\n  nestTSModuleScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.TSModuleScope(this, this.currentScope, node));\n  }\n\n  nestTypeScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.TypeScope(this, this.currentScope, node));\n  }\n\n  nestWithScope(node) {\n    (0, assert_1.assert)(this.currentScope);\n    return this.nestScope(new scope_1.WithScope(this, this.currentScope, node));\n  }\n\n}\n\nexports.ScopeManager = ScopeManager;\n_ScopeManager_options = new WeakMap();","map":{"version":3,"mappings":"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","names":["ScopeManager","constructor","options","_ScopeManager_options","scopes","globalScope","nodeToScope","WeakMap","currentScope","__classPrivateFieldSet","declaredVariables","variables","Set","recurse","scope","forEach","v","add","childScopes","Array","from","sort","a","b","$id","isGlobalReturn","__classPrivateFieldGet","globalReturn","isModule","sourceType","isImpliedStrict","impliedStrict","isStrictModeSupported","ecmaVersion","isES6","getDeclaredVariables","node","get","_a","acquire","inner","predicate","testScope","type","functionExpressionScope","length","i","find","nestScope","scope_1","nestBlockScope","nestCatchScope","nestClassScope","nestClassFieldInitializerScope","ClassFieldInitializerScope_1","nestClassStaticBlockScope","ClassStaticBlockScope_1","nestConditionalTypeScope","nestForScope","nestFunctionExpressionNameScope","nestFunctionScope","isMethodDefinition","nestFunctionTypeScope","nestGlobalScope","nestMappedTypeScope","nestModuleScope","nestSwitchScope","nestTSEnumScope","nestTSModuleScope","nestTypeScope","nestWithScope","exports"],"sources":["../src/ScopeManager.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}