{"ast":null,"code":"/**\n * @fileoverview Enforce stateless components to be written as a pure function\n * @author Yannick Croissant\n * @author Alberto Rodríguez\n * @copyright 2015 Alberto Rodríguez. All rights reserved.\n */\n'use strict';\n\nconst Components = require('../util/Components');\n\nconst testReactVersion = require('../util/version').testReactVersion;\n\nconst astUtil = require('../util/ast');\n\nconst componentUtil = require('../util/componentUtil');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst messages = {\n  componentShouldBePure: 'Component should be written as a pure function'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce stateless components to be written as a pure function',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('prefer-stateless-function')\n    },\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        ignorePureComponents: {\n          default: false,\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  create: Components.detect((context, components, utils) => {\n    const configuration = context.options[0] || {};\n    const ignorePureComponents = configuration.ignorePureComponents || false; // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    /**\n     * Checks whether a given array of statements is a single call of `super`.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode[]} body - An array of statements to check.\n     * @returns {boolean} `true` if the body is a single call of `super`.\n     */\n\n    function isSingleSuperCall(body) {\n      return body.length === 1 && body[0].type === 'ExpressionStatement' && body[0].expression.type === 'CallExpression' && body[0].expression.callee.type === 'Super';\n    }\n    /**\n     * Checks whether a given node is a pattern which doesn't have any side effects.\n     * Default parameters and Destructuring parameters can have side effects.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode} node - A pattern node.\n     * @returns {boolean} `true` if the node doesn't have any side effects.\n     */\n\n\n    function isSimple(node) {\n      return node.type === 'Identifier' || node.type === 'RestElement';\n    }\n    /**\n     * Checks whether a given array of expressions is `...arguments` or not.\n     * `super(...arguments)` passes all arguments through.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode[]} superArgs - An array of expressions to check.\n     * @returns {boolean} `true` if the superArgs is `...arguments`.\n     */\n\n\n    function isSpreadArguments(superArgs) {\n      return superArgs.length === 1 && superArgs[0].type === 'SpreadElement' && superArgs[0].argument.type === 'Identifier' && superArgs[0].argument.name === 'arguments';\n    }\n    /**\n     * Checks whether given 2 nodes are identifiers which have the same name or not.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode} ctorParam - A node to check.\n     * @param {ASTNode} superArg - A node to check.\n     * @returns {boolean} `true` if the nodes are identifiers which have the same\n     *      name.\n     */\n\n\n    function isValidIdentifierPair(ctorParam, superArg) {\n      return ctorParam.type === 'Identifier' && superArg.type === 'Identifier' && ctorParam.name === superArg.name;\n    }\n    /**\n     * Checks whether given 2 nodes are a rest/spread pair which has the same values.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode} ctorParam - A node to check.\n     * @param {ASTNode} superArg - A node to check.\n     * @returns {boolean} `true` if the nodes are a rest/spread pair which has the\n     *      same values.\n     */\n\n\n    function isValidRestSpreadPair(ctorParam, superArg) {\n      return ctorParam.type === 'RestElement' && superArg.type === 'SpreadElement' && isValidIdentifierPair(ctorParam.argument, superArg.argument);\n    }\n    /**\n     * Checks whether given 2 nodes have the same value or not.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode} ctorParam - A node to check.\n     * @param {ASTNode} superArg - A node to check.\n     * @returns {boolean} `true` if the nodes have the same value or not.\n     */\n\n\n    function isValidPair(ctorParam, superArg) {\n      return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);\n    }\n    /**\n     * Checks whether the parameters of a constructor and the arguments of `super()`\n     * have the same values or not.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode[]} ctorParams - The parameters of a constructor to check.\n     * @param {ASTNode} superArgs - The arguments of `super()` to check.\n     * @returns {boolean} `true` if those have the same values.\n     */\n\n\n    function isPassingThrough(ctorParams, superArgs) {\n      if (ctorParams.length !== superArgs.length) {\n        return false;\n      }\n\n      for (let i = 0; i < ctorParams.length; ++i) {\n        if (!isValidPair(ctorParams[i], superArgs[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Checks whether the constructor body is a redundant super call.\n     * @see eslint no-useless-constructor rule\n     * @param {Array} body - constructor body content.\n     * @param {Array} ctorParams - The params to check against super call.\n     * @returns {boolean} true if the constructor body is redundant\n     */\n\n\n    function isRedundantSuperCall(body, ctorParams) {\n      return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));\n    }\n    /**\n     * Check if a given AST node have any other properties the ones available in stateless components\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the node has at least one other property, false if not.\n     */\n\n\n    function hasOtherProperties(node) {\n      const properties = astUtil.getComponentProperties(node);\n      return properties.some(property => {\n        const name = astUtil.getPropertyName(property);\n        const isDisplayName = name === 'displayName';\n        const isPropTypes = name === 'propTypes' || name === 'props' && property.typeAnnotation;\n        const contextTypes = name === 'contextTypes';\n        const defaultProps = name === 'defaultProps';\n        const isUselessConstructor = property.kind === 'constructor' && !!property.value.body && isRedundantSuperCall(property.value.body.body, property.value.params);\n        const isRender = name === 'render';\n        return !isDisplayName && !isPropTypes && !contextTypes && !defaultProps && !isUselessConstructor && !isRender;\n      });\n    }\n    /**\n     * Mark component as pure as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n\n\n    function markSCUAsDeclared(node) {\n      components.set(node, {\n        hasSCU: true\n      });\n    }\n    /**\n     * Mark childContextTypes as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n\n\n    function markChildContextTypesAsDeclared(node) {\n      components.set(node, {\n        hasChildContextTypes: true\n      });\n    }\n    /**\n     * Mark a setState as used\n     * @param {ASTNode} node The AST node being checked.\n     */\n\n\n    function markThisAsUsed(node) {\n      components.set(node, {\n        useThis: true\n      });\n    }\n    /**\n     * Mark a props or context as used\n     * @param {ASTNode} node The AST node being checked.\n     */\n\n\n    function markPropsOrContextAsUsed(node) {\n      components.set(node, {\n        usePropsOrContext: true\n      });\n    }\n    /**\n     * Mark a ref as used\n     * @param {ASTNode} node The AST node being checked.\n     */\n\n\n    function markRefAsUsed(node) {\n      components.set(node, {\n        useRef: true\n      });\n    }\n    /**\n     * Mark return as invalid\n     * @param {ASTNode} node The AST node being checked.\n     */\n\n\n    function markReturnAsInvalid(node) {\n      components.set(node, {\n        invalidReturn: true\n      });\n    }\n    /**\n     * Mark a ClassDeclaration as having used decorators\n     * @param {ASTNode} node The AST node being checked.\n     */\n\n\n    function markDecoratorsAsUsed(node) {\n      components.set(node, {\n        useDecorators: true\n      });\n    }\n\n    function visitClass(node) {\n      if (ignorePureComponents && componentUtil.isPureComponent(node, context)) {\n        markSCUAsDeclared(node);\n      }\n\n      if (node.decorators && node.decorators.length) {\n        markDecoratorsAsUsed(node);\n      }\n    }\n\n    return {\n      ClassDeclaration: visitClass,\n      ClassExpression: visitClass,\n\n      // Mark `this` destructuring as a usage of `this`\n      VariableDeclarator(node) {\n        // Ignore destructuring on other than `this`\n        if (!node.id || node.id.type !== 'ObjectPattern' || !node.init || node.init.type !== 'ThisExpression') {\n          return;\n        } // Ignore `props` and `context`\n\n\n        const useThis = node.id.properties.some(property => {\n          const name = astUtil.getPropertyName(property);\n          return name !== 'props' && name !== 'context';\n        });\n\n        if (!useThis) {\n          markPropsOrContextAsUsed(node);\n          return;\n        }\n\n        markThisAsUsed(node);\n      },\n\n      // Mark `this` usage\n      MemberExpression(node) {\n        if (node.object.type !== 'ThisExpression') {\n          if (node.property && node.property.name === 'childContextTypes') {\n            const component = utils.getRelatedComponent(node);\n\n            if (!component) {\n              return;\n            }\n\n            markChildContextTypesAsDeclared(component.node);\n          }\n\n          return; // Ignore calls to `this.props` and `this.context`\n        }\n\n        if ((node.property.name || node.property.value) === 'props' || (node.property.name || node.property.value) === 'context') {\n          markPropsOrContextAsUsed(node);\n          return;\n        }\n\n        markThisAsUsed(node);\n      },\n\n      // Mark `ref` usage\n      JSXAttribute(node) {\n        const name = context.getSourceCode().getText(node.name);\n\n        if (name !== 'ref') {\n          return;\n        }\n\n        markRefAsUsed(node);\n      },\n\n      // Mark `render` that do not return some JSX\n      ReturnStatement(node) {\n        let blockNode;\n        let scope = context.getScope();\n\n        while (scope) {\n          blockNode = scope.block && scope.block.parent;\n\n          if (blockNode && (blockNode.type === 'MethodDefinition' || blockNode.type === 'Property')) {\n            break;\n          }\n\n          scope = scope.upper;\n        }\n\n        const isRender = blockNode && blockNode.key && blockNode.key.name === 'render';\n        const allowNull = testReactVersion(context, '>= 15.0.0'); // Stateless components can return null since React 15\n\n        const isReturningJSX = utils.isReturningJSX(node, !allowNull);\n        const isReturningNull = node.argument && (node.argument.value === null || node.argument.value === false);\n\n        if (!isRender || allowNull && (isReturningJSX || isReturningNull) || !allowNull && isReturningJSX) {\n          return;\n        }\n\n        markReturnAsInvalid(node);\n      },\n\n      'Program:exit'() {\n        const list = components.list();\n        Object.keys(list).forEach(component => {\n          if (hasOtherProperties(list[component].node) || list[component].useThis || list[component].useRef || list[component].invalidReturn || list[component].hasChildContextTypes || list[component].useDecorators || !componentUtil.isES5Component(list[component].node, context) && !componentUtil.isES6Component(list[component].node, context)) {\n            return;\n          }\n\n          if (list[component].hasSCU) {\n            return;\n          }\n\n          report(context, messages.componentShouldBePure, 'componentShouldBePure', {\n            node: list[component].node\n          });\n        });\n      }\n\n    };\n  })\n};","map":{"version":3,"names":["Components","require","testReactVersion","astUtil","componentUtil","docsUrl","report","messages","componentShouldBePure","module","exports","meta","docs","description","category","recommended","url","schema","type","properties","ignorePureComponents","default","additionalProperties","create","detect","context","components","utils","configuration","options","isSingleSuperCall","body","length","expression","callee","isSimple","node","isSpreadArguments","superArgs","argument","name","isValidIdentifierPair","ctorParam","superArg","isValidRestSpreadPair","isValidPair","isPassingThrough","ctorParams","i","isRedundantSuperCall","every","arguments","hasOtherProperties","getComponentProperties","some","property","getPropertyName","isDisplayName","isPropTypes","typeAnnotation","contextTypes","defaultProps","isUselessConstructor","kind","value","params","isRender","markSCUAsDeclared","set","hasSCU","markChildContextTypesAsDeclared","hasChildContextTypes","markThisAsUsed","useThis","markPropsOrContextAsUsed","usePropsOrContext","markRefAsUsed","useRef","markReturnAsInvalid","invalidReturn","markDecoratorsAsUsed","useDecorators","visitClass","isPureComponent","decorators","ClassDeclaration","ClassExpression","VariableDeclarator","id","init","MemberExpression","object","component","getRelatedComponent","JSXAttribute","getSourceCode","getText","ReturnStatement","blockNode","scope","getScope","block","parent","upper","key","allowNull","isReturningJSX","isReturningNull","list","Object","keys","forEach","isES5Component","isES6Component"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/prefer-stateless-function.js"],"sourcesContent":["/**\n * @fileoverview Enforce stateless components to be written as a pure function\n * @author Yannick Croissant\n * @author Alberto Rodríguez\n * @copyright 2015 Alberto Rodríguez. All rights reserved.\n */\n\n'use strict';\n\nconst Components = require('../util/Components');\nconst testReactVersion = require('../util/version').testReactVersion;\nconst astUtil = require('../util/ast');\nconst componentUtil = require('../util/componentUtil');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  componentShouldBePure: 'Component should be written as a pure function',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce stateless components to be written as a pure function',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('prefer-stateless-function'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        ignorePureComponents: {\n          default: false,\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components, utils) => {\n    const configuration = context.options[0] || {};\n    const ignorePureComponents = configuration.ignorePureComponents || false;\n\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n\n    /**\n     * Checks whether a given array of statements is a single call of `super`.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode[]} body - An array of statements to check.\n     * @returns {boolean} `true` if the body is a single call of `super`.\n     */\n    function isSingleSuperCall(body) {\n      return (\n        body.length === 1\n        && body[0].type === 'ExpressionStatement'\n        && body[0].expression.type === 'CallExpression'\n        && body[0].expression.callee.type === 'Super'\n      );\n    }\n\n    /**\n     * Checks whether a given node is a pattern which doesn't have any side effects.\n     * Default parameters and Destructuring parameters can have side effects.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode} node - A pattern node.\n     * @returns {boolean} `true` if the node doesn't have any side effects.\n     */\n    function isSimple(node) {\n      return node.type === 'Identifier' || node.type === 'RestElement';\n    }\n\n    /**\n     * Checks whether a given array of expressions is `...arguments` or not.\n     * `super(...arguments)` passes all arguments through.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode[]} superArgs - An array of expressions to check.\n     * @returns {boolean} `true` if the superArgs is `...arguments`.\n     */\n    function isSpreadArguments(superArgs) {\n      return (\n        superArgs.length === 1\n        && superArgs[0].type === 'SpreadElement'\n        && superArgs[0].argument.type === 'Identifier'\n        && superArgs[0].argument.name === 'arguments'\n      );\n    }\n\n    /**\n     * Checks whether given 2 nodes are identifiers which have the same name or not.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode} ctorParam - A node to check.\n     * @param {ASTNode} superArg - A node to check.\n     * @returns {boolean} `true` if the nodes are identifiers which have the same\n     *      name.\n     */\n    function isValidIdentifierPair(ctorParam, superArg) {\n      return (\n        ctorParam.type === 'Identifier'\n        && superArg.type === 'Identifier'\n        && ctorParam.name === superArg.name\n      );\n    }\n\n    /**\n     * Checks whether given 2 nodes are a rest/spread pair which has the same values.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode} ctorParam - A node to check.\n     * @param {ASTNode} superArg - A node to check.\n     * @returns {boolean} `true` if the nodes are a rest/spread pair which has the\n     *      same values.\n     */\n    function isValidRestSpreadPair(ctorParam, superArg) {\n      return (\n        ctorParam.type === 'RestElement'\n        && superArg.type === 'SpreadElement'\n        && isValidIdentifierPair(ctorParam.argument, superArg.argument)\n      );\n    }\n\n    /**\n     * Checks whether given 2 nodes have the same value or not.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode} ctorParam - A node to check.\n     * @param {ASTNode} superArg - A node to check.\n     * @returns {boolean} `true` if the nodes have the same value or not.\n     */\n    function isValidPair(ctorParam, superArg) {\n      return (\n        isValidIdentifierPair(ctorParam, superArg)\n        || isValidRestSpreadPair(ctorParam, superArg)\n      );\n    }\n\n    /**\n     * Checks whether the parameters of a constructor and the arguments of `super()`\n     * have the same values or not.\n     * @see eslint no-useless-constructor rule\n     * @param {ASTNode[]} ctorParams - The parameters of a constructor to check.\n     * @param {ASTNode} superArgs - The arguments of `super()` to check.\n     * @returns {boolean} `true` if those have the same values.\n     */\n    function isPassingThrough(ctorParams, superArgs) {\n      if (ctorParams.length !== superArgs.length) {\n        return false;\n      }\n\n      for (let i = 0; i < ctorParams.length; ++i) {\n        if (!isValidPair(ctorParams[i], superArgs[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    /**\n     * Checks whether the constructor body is a redundant super call.\n     * @see eslint no-useless-constructor rule\n     * @param {Array} body - constructor body content.\n     * @param {Array} ctorParams - The params to check against super call.\n     * @returns {boolean} true if the constructor body is redundant\n     */\n    function isRedundantSuperCall(body, ctorParams) {\n      return (\n        isSingleSuperCall(body)\n        && ctorParams.every(isSimple)\n        && (\n          isSpreadArguments(body[0].expression.arguments)\n          || isPassingThrough(ctorParams, body[0].expression.arguments)\n        )\n      );\n    }\n\n    /**\n     * Check if a given AST node have any other properties the ones available in stateless components\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {Boolean} True if the node has at least one other property, false if not.\n     */\n    function hasOtherProperties(node) {\n      const properties = astUtil.getComponentProperties(node);\n      return properties.some((property) => {\n        const name = astUtil.getPropertyName(property);\n        const isDisplayName = name === 'displayName';\n        const isPropTypes = name === 'propTypes' || ((name === 'props') && property.typeAnnotation);\n        const contextTypes = name === 'contextTypes';\n        const defaultProps = name === 'defaultProps';\n        const isUselessConstructor = property.kind === 'constructor'\n          && !!property.value.body\n          && isRedundantSuperCall(property.value.body.body, property.value.params);\n        const isRender = name === 'render';\n        return !isDisplayName && !isPropTypes && !contextTypes && !defaultProps && !isUselessConstructor && !isRender;\n      });\n    }\n\n    /**\n     * Mark component as pure as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markSCUAsDeclared(node) {\n      components.set(node, {\n        hasSCU: true,\n      });\n    }\n\n    /**\n     * Mark childContextTypes as declared\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markChildContextTypesAsDeclared(node) {\n      components.set(node, {\n        hasChildContextTypes: true,\n      });\n    }\n\n    /**\n     * Mark a setState as used\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markThisAsUsed(node) {\n      components.set(node, {\n        useThis: true,\n      });\n    }\n\n    /**\n     * Mark a props or context as used\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markPropsOrContextAsUsed(node) {\n      components.set(node, {\n        usePropsOrContext: true,\n      });\n    }\n\n    /**\n     * Mark a ref as used\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markRefAsUsed(node) {\n      components.set(node, {\n        useRef: true,\n      });\n    }\n\n    /**\n     * Mark return as invalid\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markReturnAsInvalid(node) {\n      components.set(node, {\n        invalidReturn: true,\n      });\n    }\n\n    /**\n     * Mark a ClassDeclaration as having used decorators\n     * @param {ASTNode} node The AST node being checked.\n     */\n    function markDecoratorsAsUsed(node) {\n      components.set(node, {\n        useDecorators: true,\n      });\n    }\n\n    function visitClass(node) {\n      if (ignorePureComponents && componentUtil.isPureComponent(node, context)) {\n        markSCUAsDeclared(node);\n      }\n\n      if (node.decorators && node.decorators.length) {\n        markDecoratorsAsUsed(node);\n      }\n    }\n\n    return {\n      ClassDeclaration: visitClass,\n      ClassExpression: visitClass,\n\n      // Mark `this` destructuring as a usage of `this`\n      VariableDeclarator(node) {\n        // Ignore destructuring on other than `this`\n        if (!node.id || node.id.type !== 'ObjectPattern' || !node.init || node.init.type !== 'ThisExpression') {\n          return;\n        }\n        // Ignore `props` and `context`\n        const useThis = node.id.properties.some((property) => {\n          const name = astUtil.getPropertyName(property);\n          return name !== 'props' && name !== 'context';\n        });\n        if (!useThis) {\n          markPropsOrContextAsUsed(node);\n          return;\n        }\n        markThisAsUsed(node);\n      },\n\n      // Mark `this` usage\n      MemberExpression(node) {\n        if (node.object.type !== 'ThisExpression') {\n          if (node.property && node.property.name === 'childContextTypes') {\n            const component = utils.getRelatedComponent(node);\n            if (!component) {\n              return;\n            }\n            markChildContextTypesAsDeclared(component.node);\n          }\n          return;\n        // Ignore calls to `this.props` and `this.context`\n        }\n        if (\n          (node.property.name || node.property.value) === 'props'\n          || (node.property.name || node.property.value) === 'context'\n        ) {\n          markPropsOrContextAsUsed(node);\n          return;\n        }\n        markThisAsUsed(node);\n      },\n\n      // Mark `ref` usage\n      JSXAttribute(node) {\n        const name = context.getSourceCode().getText(node.name);\n        if (name !== 'ref') {\n          return;\n        }\n        markRefAsUsed(node);\n      },\n\n      // Mark `render` that do not return some JSX\n      ReturnStatement(node) {\n        let blockNode;\n        let scope = context.getScope();\n        while (scope) {\n          blockNode = scope.block && scope.block.parent;\n          if (blockNode && (blockNode.type === 'MethodDefinition' || blockNode.type === 'Property')) {\n            break;\n          }\n          scope = scope.upper;\n        }\n        const isRender = blockNode && blockNode.key && blockNode.key.name === 'render';\n        const allowNull = testReactVersion(context, '>= 15.0.0'); // Stateless components can return null since React 15\n        const isReturningJSX = utils.isReturningJSX(node, !allowNull);\n        const isReturningNull = node.argument && (node.argument.value === null || node.argument.value === false);\n        if (\n          !isRender\n          || (allowNull && (isReturningJSX || isReturningNull))\n          || (!allowNull && isReturningJSX)\n        ) {\n          return;\n        }\n        markReturnAsInvalid(node);\n      },\n\n      'Program:exit'() {\n        const list = components.list();\n        Object.keys(list).forEach((component) => {\n          if (\n            hasOtherProperties(list[component].node)\n            || list[component].useThis\n            || list[component].useRef\n            || list[component].invalidReturn\n            || list[component].hasChildContextTypes\n            || list[component].useDecorators\n            || (\n              !componentUtil.isES5Component(list[component].node, context)\n              && !componentUtil.isES6Component(list[component].node, context)\n            )\n          ) {\n            return;\n          }\n\n          if (list[component].hasSCU) {\n            return;\n          }\n          report(context, messages.componentShouldBePure, 'componentShouldBePure', {\n            node: list[component].node,\n          });\n        });\n      },\n    };\n  }),\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}