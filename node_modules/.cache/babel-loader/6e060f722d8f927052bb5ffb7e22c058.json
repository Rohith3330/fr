{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nconst util_1 = require(\"../util\");\n\nexports.default = util.createRule({\n  name: 'no-unnecessary-type-arguments',\n  meta: {\n    docs: {\n      description: 'Disallow type arguments that are equal to the default',\n      recommended: 'strict',\n      requiresTypeChecking: true\n    },\n    fixable: 'code',\n    messages: {\n      unnecessaryTypeParameter: 'This is the default value for this type parameter, so it can be omitted.'\n    },\n    schema: [],\n    type: 'suggestion'\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n\n    function getTypeForComparison(type) {\n      if (util.isTypeReferenceType(type)) {\n        return {\n          type: type.target,\n          typeArguments: util.getTypeArguments(type, checker)\n        };\n      }\n\n      return {\n        type,\n        typeArguments: []\n      };\n    }\n\n    function checkTSArgsAndParameters(esParameters, typeParameters) {\n      // Just check the last one. Must specify previous type parameters if the last one is specified.\n      const i = esParameters.params.length - 1;\n      const arg = esParameters.params[i];\n      const param = typeParameters[i];\n\n      if (!(param === null || param === void 0 ? void 0 : param.default)) {\n        return;\n      } // TODO: would like checker.areTypesEquivalent. https://github.com/Microsoft/TypeScript/issues/13502\n\n\n      const defaultType = checker.getTypeAtLocation(param.default);\n      const argTsNode = parserServices.esTreeNodeToTSNodeMap.get(arg);\n      const argType = checker.getTypeAtLocation(argTsNode); // this check should handle some of the most simple cases of like strings, numbers, etc\n\n      if (defaultType !== argType) {\n        // For more complex types (like aliases to generic object types) - TS won't always create a\n        // global shared type object for the type - so we need to resort to manually comparing the\n        // reference type and the passed type arguments.\n        // Also - in case there are aliases - we need to resolve them before we do checks\n        const defaultTypeResolved = getTypeForComparison(defaultType);\n        const argTypeResolved = getTypeForComparison(argType);\n\n        if ( // ensure the resolved type AND all the parameters are the same\n        defaultTypeResolved.type !== argTypeResolved.type || defaultTypeResolved.typeArguments.length !== argTypeResolved.typeArguments.length || defaultTypeResolved.typeArguments.some((t, i) => t !== argTypeResolved.typeArguments[i])) {\n          return;\n        }\n      }\n\n      context.report({\n        node: arg,\n        messageId: 'unnecessaryTypeParameter',\n        fix: fixer => fixer.removeRange(i === 0 ? esParameters.range : [esParameters.params[i - 1].range[1], arg.range[1]])\n      });\n    }\n\n    return {\n      TSTypeParameterInstantiation(node) {\n        const expression = parserServices.esTreeNodeToTSNodeMap.get(node);\n        const typeParameters = getTypeParametersFromNode(expression, checker);\n\n        if (typeParameters) {\n          checkTSArgsAndParameters(node, typeParameters);\n        }\n      }\n\n    };\n  }\n\n});\n\nfunction getTypeParametersFromNode(node, checker) {\n  if (ts.isExpressionWithTypeArguments(node)) {\n    return getTypeParametersFromType(node.expression, checker);\n  }\n\n  if (ts.isTypeReferenceNode(node)) {\n    return getTypeParametersFromType(node.typeName, checker);\n  }\n\n  if (ts.isCallExpression(node) || ts.isNewExpression(node)) {\n    return getTypeParametersFromCall(node, checker);\n  }\n\n  return undefined;\n}\n\nfunction getTypeParametersFromType(type, checker) {\n  const symAtLocation = checker.getSymbolAtLocation(type);\n\n  if (!symAtLocation) {\n    return undefined;\n  }\n\n  const sym = getAliasedSymbol(symAtLocation, checker);\n  const declarations = sym.getDeclarations();\n\n  if (!declarations) {\n    return undefined;\n  }\n\n  return (0, util_1.findFirstResult)(declarations, decl => ts.isClassLike(decl) || ts.isTypeAliasDeclaration(decl) || ts.isInterfaceDeclaration(decl) ? decl.typeParameters : undefined);\n}\n\nfunction getTypeParametersFromCall(node, checker) {\n  const sig = checker.getResolvedSignature(node);\n  const sigDecl = sig === null || sig === void 0 ? void 0 : sig.getDeclaration();\n\n  if (!sigDecl) {\n    return ts.isNewExpression(node) ? getTypeParametersFromType(node.expression, checker) : undefined;\n  }\n\n  return sigDecl.typeParameters;\n}\n\nfunction getAliasedSymbol(symbol, checker) {\n  return tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias) ? checker.getAliasedSymbol(symbol) : symbol;\n}","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","docs","description","recommended","requiresTypeChecking","fixable","messages","unnecessaryTypeParameter","schema","type","defaultOptions","create","context","parserServices","getParserServices","checker","program","getTypeChecker","getTypeForComparison","isTypeReferenceType","target","typeArguments","getTypeArguments","checkTSArgsAndParameters","esParameters","typeParameters","i","params","length","arg","param","default","defaultType","getTypeAtLocation","argTsNode","esTreeNodeToTSNodeMap","get","argType","defaultTypeResolved","argTypeResolved","some","t","report","node","messageId","fix","fixer","removeRange","range","TSTypeParameterInstantiation","expression","getTypeParametersFromNode","ts","isExpressionWithTypeArguments","getTypeParametersFromType","isTypeReferenceNode","typeName","isCallExpression","isNewExpression","getTypeParametersFromCall","undefined","symAtLocation","getSymbolAtLocation","sym","getAliasedSymbol","declarations","getDeclarations","decl","isClassLike","isTypeAliasDeclaration","isInterfaceDeclaration","sig","getResolvedSignature","sigDecl","getDeclaration","symbol","tsutils","isSymbolFlagSet","SymbolFlags","Alias"],"sources":["../../src/rules/no-unnecessary-type-arguments.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}