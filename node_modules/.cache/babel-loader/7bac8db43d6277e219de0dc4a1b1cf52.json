{"ast":null,"code":"/**\n * @fileoverview Prevent usage of Array index in keys\n * @author Joe Lencioni\n */\n'use strict';\n\nconst has = require('object.hasown/polyfill')();\n\nconst astUtil = require('../util/ast');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst pragma = require('../util/pragma');\n\nconst report = require('../util/report');\n\nconst variableUtil = require('../util/variable'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nfunction isCreateCloneElement(node, context) {\n  if (!node) {\n    return false;\n  }\n\n  if (node.type === 'MemberExpression' || node.type === 'OptionalMemberExpression') {\n    return node.object && node.object.name === pragma.getFromContext(context) && ['createElement', 'cloneElement'].indexOf(node.property.name) !== -1;\n  }\n\n  if (node.type === 'Identifier') {\n    const variable = variableUtil.findVariableByName(context, node.name);\n\n    if (variable && variable.type === 'ImportSpecifier') {\n      return variable.parent.source.value === 'react';\n    }\n  }\n\n  return false;\n}\n\nconst messages = {\n  noArrayIndex: 'Do not use Array index in keys'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow usage of Array index in keys',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('no-array-index-key')\n    },\n    messages,\n    schema: []\n  },\n\n  create(context) {\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n    const indexParamNames = [];\n    const iteratorFunctionsToIndexParamPosition = {\n      every: 1,\n      filter: 1,\n      find: 1,\n      findIndex: 1,\n      forEach: 1,\n      map: 1,\n      reduce: 2,\n      reduceRight: 2,\n      some: 1\n    };\n\n    function isArrayIndex(node) {\n      return node.type === 'Identifier' && indexParamNames.indexOf(node.name) !== -1;\n    }\n\n    function isUsingReactChildren(node) {\n      const callee = node.callee;\n\n      if (!callee || !callee.property || !callee.object) {\n        return null;\n      }\n\n      const isReactChildMethod = ['map', 'forEach'].indexOf(callee.property.name) > -1;\n\n      if (!isReactChildMethod) {\n        return null;\n      }\n\n      const obj = callee.object;\n\n      if (obj && obj.name === 'Children') {\n        return true;\n      }\n\n      if (obj && obj.object && obj.object.name === pragma.getFromContext(context)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function getMapIndexParamName(node) {\n      const callee = node.callee;\n\n      if (callee.type !== 'MemberExpression' && callee.type !== 'OptionalMemberExpression') {\n        return null;\n      }\n\n      if (callee.property.type !== 'Identifier') {\n        return null;\n      }\n\n      if (!has(iteratorFunctionsToIndexParamPosition, callee.property.name)) {\n        return null;\n      }\n\n      const callbackArg = isUsingReactChildren(node) ? node.arguments[1] : node.arguments[0];\n\n      if (!callbackArg) {\n        return null;\n      }\n\n      if (!astUtil.isFunctionLikeExpression(callbackArg)) {\n        return null;\n      }\n\n      const params = callbackArg.params;\n      const indexParamPosition = iteratorFunctionsToIndexParamPosition[callee.property.name];\n\n      if (params.length < indexParamPosition + 1) {\n        return null;\n      }\n\n      return params[indexParamPosition].name;\n    }\n\n    function getIdentifiersFromBinaryExpression(side) {\n      if (side.type === 'Identifier') {\n        return side;\n      }\n\n      if (side.type === 'BinaryExpression') {\n        // recurse\n        const left = getIdentifiersFromBinaryExpression(side.left);\n        const right = getIdentifiersFromBinaryExpression(side.right);\n        return [].concat(left, right).filter(Boolean);\n      }\n\n      return null;\n    }\n\n    function checkPropValue(node) {\n      if (isArrayIndex(node)) {\n        // key={bar}\n        report(context, messages.noArrayIndex, 'noArrayIndex', {\n          node\n        });\n        return;\n      }\n\n      if (node.type === 'TemplateLiteral') {\n        // key={`foo-${bar}`}\n        node.expressions.filter(isArrayIndex).forEach(() => {\n          report(context, messages.noArrayIndex, 'noArrayIndex', {\n            node\n          });\n        });\n        return;\n      }\n\n      if (node.type === 'BinaryExpression') {\n        // key={'foo' + bar}\n        const identifiers = getIdentifiersFromBinaryExpression(node);\n        identifiers.filter(isArrayIndex).forEach(() => {\n          report(context, messages.noArrayIndex, 'noArrayIndex', {\n            node\n          });\n        });\n        return;\n      }\n\n      if (node.type === 'CallExpression' && node.callee && node.callee.type === 'MemberExpression' && node.callee.object && isArrayIndex(node.callee.object) && node.callee.property && node.callee.property.type === 'Identifier' && node.callee.property.name === 'toString') {\n        // key={bar.toString()}\n        report(context, messages.noArrayIndex, 'noArrayIndex', {\n          node\n        });\n        return;\n      }\n\n      if (node.type === 'CallExpression' && node.callee && node.callee.type === 'Identifier' && node.callee.name === 'String' && Array.isArray(node.arguments) && node.arguments.length > 0 && isArrayIndex(node.arguments[0])) {\n        // key={String(bar)}\n        report(context, messages.noArrayIndex, 'noArrayIndex', {\n          node: node.arguments[0]\n        });\n      }\n    }\n\n    function popIndex(node) {\n      const mapIndexParamName = getMapIndexParamName(node);\n\n      if (!mapIndexParamName) {\n        return;\n      }\n\n      indexParamNames.pop();\n    }\n\n    return {\n      'CallExpression, OptionalCallExpression'(node) {\n        if (isCreateCloneElement(node.callee, context) && node.arguments.length > 1) {\n          // React.createElement\n          if (!indexParamNames.length) {\n            return;\n          }\n\n          const props = node.arguments[1];\n\n          if (props.type !== 'ObjectExpression') {\n            return;\n          }\n\n          props.properties.forEach(prop => {\n            if (!prop.key || prop.key.name !== 'key') {\n              // { ...foo }\n              // { foo: bar }\n              return;\n            }\n\n            checkPropValue(prop.value);\n          });\n          return;\n        }\n\n        const mapIndexParamName = getMapIndexParamName(node);\n\n        if (!mapIndexParamName) {\n          return;\n        }\n\n        indexParamNames.push(mapIndexParamName);\n      },\n\n      JSXAttribute(node) {\n        if (node.name.name !== 'key') {\n          // foo={bar}\n          return;\n        }\n\n        if (!indexParamNames.length) {\n          // Not inside a call expression that we think has an index param.\n          return;\n        }\n\n        const value = node.value;\n\n        if (!value || value.type !== 'JSXExpressionContainer') {\n          // key='foo' or just simply 'key'\n          return;\n        }\n\n        checkPropValue(value.expression);\n      },\n\n      'CallExpression:exit': popIndex,\n      'OptionalCallExpression:exit': popIndex\n    };\n  }\n\n};","map":{"version":3,"names":["has","require","astUtil","docsUrl","pragma","report","variableUtil","isCreateCloneElement","node","context","type","object","name","getFromContext","indexOf","property","variable","findVariableByName","parent","source","value","messages","noArrayIndex","module","exports","meta","docs","description","category","recommended","url","schema","create","indexParamNames","iteratorFunctionsToIndexParamPosition","every","filter","find","findIndex","forEach","map","reduce","reduceRight","some","isArrayIndex","isUsingReactChildren","callee","isReactChildMethod","obj","getMapIndexParamName","callbackArg","arguments","isFunctionLikeExpression","params","indexParamPosition","length","getIdentifiersFromBinaryExpression","side","left","right","concat","Boolean","checkPropValue","expressions","identifiers","Array","isArray","popIndex","mapIndexParamName","pop","props","properties","prop","key","push","JSXAttribute","expression"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/no-array-index-key.js"],"sourcesContent":["/**\n * @fileoverview Prevent usage of Array index in keys\n * @author Joe Lencioni\n */\n\n'use strict';\n\nconst has = require('object.hasown/polyfill')();\nconst astUtil = require('../util/ast');\nconst docsUrl = require('../util/docsUrl');\nconst pragma = require('../util/pragma');\nconst report = require('../util/report');\nconst variableUtil = require('../util/variable');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nfunction isCreateCloneElement(node, context) {\n  if (!node) {\n    return false;\n  }\n\n  if (node.type === 'MemberExpression' || node.type === 'OptionalMemberExpression') {\n    return node.object\n      && node.object.name === pragma.getFromContext(context)\n      && ['createElement', 'cloneElement'].indexOf(node.property.name) !== -1;\n  }\n\n  if (node.type === 'Identifier') {\n    const variable = variableUtil.findVariableByName(context, node.name);\n    if (variable && variable.type === 'ImportSpecifier') {\n      return variable.parent.source.value === 'react';\n    }\n  }\n\n  return false;\n}\n\nconst messages = {\n  noArrayIndex: 'Do not use Array index in keys',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow usage of Array index in keys',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('no-array-index-key'),\n    },\n\n    messages,\n\n    schema: [],\n  },\n\n  create(context) {\n    // --------------------------------------------------------------------------\n    // Public\n    // --------------------------------------------------------------------------\n    const indexParamNames = [];\n    const iteratorFunctionsToIndexParamPosition = {\n      every: 1,\n      filter: 1,\n      find: 1,\n      findIndex: 1,\n      forEach: 1,\n      map: 1,\n      reduce: 2,\n      reduceRight: 2,\n      some: 1,\n    };\n\n    function isArrayIndex(node) {\n      return node.type === 'Identifier'\n        && indexParamNames.indexOf(node.name) !== -1;\n    }\n\n    function isUsingReactChildren(node) {\n      const callee = node.callee;\n      if (\n        !callee\n        || !callee.property\n        || !callee.object\n      ) {\n        return null;\n      }\n\n      const isReactChildMethod = ['map', 'forEach'].indexOf(callee.property.name) > -1;\n      if (!isReactChildMethod) {\n        return null;\n      }\n\n      const obj = callee.object;\n      if (obj && obj.name === 'Children') {\n        return true;\n      }\n      if (obj && obj.object && obj.object.name === pragma.getFromContext(context)) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function getMapIndexParamName(node) {\n      const callee = node.callee;\n      if (callee.type !== 'MemberExpression' && callee.type !== 'OptionalMemberExpression') {\n        return null;\n      }\n      if (callee.property.type !== 'Identifier') {\n        return null;\n      }\n      if (!has(iteratorFunctionsToIndexParamPosition, callee.property.name)) {\n        return null;\n      }\n\n      const callbackArg = isUsingReactChildren(node)\n        ? node.arguments[1]\n        : node.arguments[0];\n\n      if (!callbackArg) {\n        return null;\n      }\n\n      if (!astUtil.isFunctionLikeExpression(callbackArg)) {\n        return null;\n      }\n\n      const params = callbackArg.params;\n\n      const indexParamPosition = iteratorFunctionsToIndexParamPosition[callee.property.name];\n      if (params.length < indexParamPosition + 1) {\n        return null;\n      }\n\n      return params[indexParamPosition].name;\n    }\n\n    function getIdentifiersFromBinaryExpression(side) {\n      if (side.type === 'Identifier') {\n        return side;\n      }\n\n      if (side.type === 'BinaryExpression') {\n        // recurse\n        const left = getIdentifiersFromBinaryExpression(side.left);\n        const right = getIdentifiersFromBinaryExpression(side.right);\n        return [].concat(left, right).filter(Boolean);\n      }\n\n      return null;\n    }\n\n    function checkPropValue(node) {\n      if (isArrayIndex(node)) {\n        // key={bar}\n        report(context, messages.noArrayIndex, 'noArrayIndex', {\n          node,\n        });\n        return;\n      }\n\n      if (node.type === 'TemplateLiteral') {\n        // key={`foo-${bar}`}\n        node.expressions.filter(isArrayIndex).forEach(() => {\n          report(context, messages.noArrayIndex, 'noArrayIndex', {\n            node,\n          });\n        });\n\n        return;\n      }\n\n      if (node.type === 'BinaryExpression') {\n        // key={'foo' + bar}\n        const identifiers = getIdentifiersFromBinaryExpression(node);\n\n        identifiers.filter(isArrayIndex).forEach(() => {\n          report(context, messages.noArrayIndex, 'noArrayIndex', {\n            node,\n          });\n        });\n\n        return;\n      }\n\n      if (node.type === 'CallExpression'\n          && node.callee\n          && node.callee.type === 'MemberExpression'\n          && node.callee.object\n          && isArrayIndex(node.callee.object)\n          && node.callee.property\n          && node.callee.property.type === 'Identifier'\n          && node.callee.property.name === 'toString'\n      ) {\n        // key={bar.toString()}\n        report(context, messages.noArrayIndex, 'noArrayIndex', {\n          node,\n        });\n        return;\n      }\n\n      if (node.type === 'CallExpression'\n          && node.callee\n          && node.callee.type === 'Identifier'\n          && node.callee.name === 'String'\n          && Array.isArray(node.arguments)\n          && node.arguments.length > 0\n          && isArrayIndex(node.arguments[0])\n      ) {\n        // key={String(bar)}\n        report(context, messages.noArrayIndex, 'noArrayIndex', {\n          node: node.arguments[0],\n        });\n      }\n    }\n\n    function popIndex(node) {\n      const mapIndexParamName = getMapIndexParamName(node);\n      if (!mapIndexParamName) {\n        return;\n      }\n\n      indexParamNames.pop();\n    }\n\n    return {\n      'CallExpression, OptionalCallExpression'(node) {\n        if (isCreateCloneElement(node.callee, context) && node.arguments.length > 1) {\n          // React.createElement\n          if (!indexParamNames.length) {\n            return;\n          }\n\n          const props = node.arguments[1];\n\n          if (props.type !== 'ObjectExpression') {\n            return;\n          }\n\n          props.properties.forEach((prop) => {\n            if (!prop.key || prop.key.name !== 'key') {\n              // { ...foo }\n              // { foo: bar }\n              return;\n            }\n\n            checkPropValue(prop.value);\n          });\n\n          return;\n        }\n\n        const mapIndexParamName = getMapIndexParamName(node);\n        if (!mapIndexParamName) {\n          return;\n        }\n\n        indexParamNames.push(mapIndexParamName);\n      },\n\n      JSXAttribute(node) {\n        if (node.name.name !== 'key') {\n          // foo={bar}\n          return;\n        }\n\n        if (!indexParamNames.length) {\n          // Not inside a call expression that we think has an index param.\n          return;\n        }\n\n        const value = node.value;\n        if (!value || value.type !== 'JSXExpressionContainer') {\n          // key='foo' or just simply 'key'\n          return;\n        }\n\n        checkPropValue(value.expression);\n      },\n\n      'CallExpression:exit': popIndex,\n      'OptionalCallExpression:exit': popIndex,\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}