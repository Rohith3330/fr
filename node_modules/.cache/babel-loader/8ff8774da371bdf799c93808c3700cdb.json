{"ast":null,"code":"/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n/*\n * NOTE: The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n      path = require(\"path\"),\n      {\n  promisify\n} = require(\"util\"),\n      {\n  ESLint\n} = require(\"./eslint\"),\n      {\n  FlatESLint\n} = require(\"./eslint/flat-eslint\"),\n      createCLIOptions = require(\"./options\"),\n      log = require(\"./shared/logging\"),\n      RuntimeInfo = require(\"./shared/runtime-info\");\n\nconst {\n  Legacy: {\n    naming\n  }\n} = require(\"@eslint/eslintrc\");\n\nconst {\n  findFlatConfigFile\n} = require(\"./eslint/flat-eslint\");\n\nconst {\n  gitignoreToMinimatch\n} = require(\"@humanwhocodes/gitignore-to-minimatch\");\n\nconst {\n  ModuleImporter\n} = require(\"@humanwhocodes/module-importer\");\n\nconst debug = require(\"debug\")(\"eslint:cli\"); //------------------------------------------------------------------------------\n// Types\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"./eslint/eslint\").ESLintOptions} ESLintOptions */\n\n/** @typedef {import(\"./eslint/eslint\").LintMessage} LintMessage */\n\n/** @typedef {import(\"./eslint/eslint\").LintResult} LintResult */\n\n/** @typedef {import(\"./options\").ParsedCLIOptions} ParsedCLIOptions */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst mkdir = promisify(fs.mkdir);\nconst stat = promisify(fs.stat);\nconst writeFile = promisify(fs.writeFile);\n/**\n * Predicate function for whether or not to apply fixes in quiet mode.\n * If a message is a warning, do not apply a fix.\n * @param {LintMessage} message The lint result.\n * @returns {boolean} True if the lint message is an error (and thus should be\n * autofixed), false otherwise.\n */\n\nfunction quietFixPredicate(message) {\n  return message.severity === 2;\n}\n/**\n * Translates the CLI options into the options expected by the ESLint constructor.\n * @param {ParsedCLIOptions} cliOptions The CLI options to translate.\n * @param {\"flat\"|\"eslintrc\"} [configType=\"eslintrc\"] The format of the\n *      config to generate.\n * @returns {Promise<ESLintOptions>} The options object for the ESLint constructor.\n * @private\n */\n\n\nasync function translateOptions(_ref, configType) {\n  let {\n    cache,\n    cacheFile,\n    cacheLocation,\n    cacheStrategy,\n    config,\n    configLookup,\n    env,\n    errorOnUnmatchedPattern,\n    eslintrc,\n    ext,\n    fix,\n    fixDryRun,\n    fixType,\n    global,\n    ignore,\n    ignorePath,\n    ignorePattern,\n    inlineConfig,\n    parser,\n    parserOptions,\n    plugin,\n    quiet,\n    reportUnusedDisableDirectives,\n    resolvePluginsRelativeTo,\n    rule,\n    rulesdir\n  } = _ref;\n  let overrideConfig, overrideConfigFile;\n  const importer = new ModuleImporter();\n\n  if (configType === \"flat\") {\n    overrideConfigFile = typeof config === \"string\" ? config : !configLookup;\n\n    if (overrideConfigFile === false) {\n      overrideConfigFile = void 0;\n    }\n\n    let globals = {};\n\n    if (global) {\n      globals = global.reduce((obj, name) => {\n        if (name.endsWith(\":true\")) {\n          obj[name.slice(0, -5)] = \"writable\";\n        } else {\n          obj[name] = \"readonly\";\n        }\n\n        return obj;\n      }, globals);\n    }\n\n    overrideConfig = [{\n      languageOptions: {\n        globals,\n        parserOptions: parserOptions || {}\n      },\n      rules: rule ? rule : {}\n    }];\n\n    if (parser) {\n      overrideConfig[0].languageOptions.parser = await importer.import(parser);\n    }\n\n    if (plugin) {\n      const plugins = {};\n\n      for (const pluginName of plugin) {\n        const shortName = naming.getShorthandName(pluginName, \"eslint-plugin\");\n        const longName = naming.normalizePackageName(pluginName, \"eslint-plugin\");\n        plugins[shortName] = await importer.import(longName);\n      }\n\n      overrideConfig[0].plugins = plugins;\n    }\n\n    if (ignorePattern) {\n      overrideConfig.push({\n        ignores: ignorePattern.map(gitignoreToMinimatch)\n      });\n    }\n  } else {\n    overrideConfigFile = config;\n    overrideConfig = {\n      env: env && env.reduce((obj, name) => {\n        obj[name] = true;\n        return obj;\n      }, {}),\n      globals: global && global.reduce((obj, name) => {\n        if (name.endsWith(\":true\")) {\n          obj[name.slice(0, -5)] = \"writable\";\n        } else {\n          obj[name] = \"readonly\";\n        }\n\n        return obj;\n      }, {}),\n      ignorePatterns: ignorePattern,\n      parser,\n      parserOptions,\n      plugins: plugin,\n      rules: rule\n    };\n  }\n\n  const options = {\n    allowInlineConfig: inlineConfig,\n    cache,\n    cacheLocation: cacheLocation || cacheFile,\n    cacheStrategy,\n    errorOnUnmatchedPattern,\n    fix: (fix || fixDryRun) && (quiet ? quietFixPredicate : true),\n    fixTypes: fixType,\n    ignore,\n    ignorePath,\n    overrideConfig,\n    overrideConfigFile,\n    reportUnusedDisableDirectives: reportUnusedDisableDirectives ? \"error\" : void 0\n  };\n\n  if (configType !== \"flat\") {\n    options.resolvePluginsRelativeTo = resolvePluginsRelativeTo;\n    options.rulePaths = rulesdir;\n    options.useEslintrc = eslintrc;\n    options.extensions = ext;\n  }\n\n  return options;\n}\n/**\n * Count error messages.\n * @param {LintResult[]} results The lint results.\n * @returns {{errorCount:number;warningCount:number}} The number of error messages.\n */\n\n\nfunction countErrors(results) {\n  let errorCount = 0;\n  let fatalErrorCount = 0;\n  let warningCount = 0;\n\n  for (const result of results) {\n    errorCount += result.errorCount;\n    fatalErrorCount += result.fatalErrorCount;\n    warningCount += result.warningCount;\n  }\n\n  return {\n    errorCount,\n    fatalErrorCount,\n    warningCount\n  };\n}\n/**\n * Check if a given file path is a directory or not.\n * @param {string} filePath The path to a file to check.\n * @returns {Promise<boolean>} `true` if the given path is a directory.\n */\n\n\nasync function isDirectory(filePath) {\n  try {\n    return (await stat(filePath)).isDirectory();\n  } catch (error) {\n    if (error.code === \"ENOENT\" || error.code === \"ENOTDIR\") {\n      return false;\n    }\n\n    throw error;\n  }\n}\n/**\n * Outputs the results of the linting.\n * @param {ESLint} engine The ESLint instance to use.\n * @param {LintResult[]} results The results to print.\n * @param {string} format The name of the formatter to use or the path to the formatter.\n * @param {string} outputFile The path for the output file.\n * @returns {Promise<boolean>} True if the printing succeeds, false if not.\n * @private\n */\n\n\nasync function printResults(engine, results, format, outputFile) {\n  let formatter;\n\n  try {\n    formatter = await engine.loadFormatter(format);\n  } catch (e) {\n    log.error(e.message);\n    return false;\n  }\n\n  const output = await formatter.format(results);\n\n  if (output) {\n    if (outputFile) {\n      const filePath = path.resolve(process.cwd(), outputFile);\n\n      if (await isDirectory(filePath)) {\n        log.error(\"Cannot write to output file path, it is a directory: %s\", outputFile);\n        return false;\n      }\n\n      try {\n        await mkdir(path.dirname(filePath), {\n          recursive: true\n        });\n        await writeFile(filePath, output);\n      } catch (ex) {\n        log.error(\"There was a problem writing the output file:\\n%s\", ex);\n        return false;\n      }\n    } else {\n      log.info(output);\n    }\n  }\n\n  return true;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Encapsulates all CLI behavior for eslint. Makes it easier to test as well as\n * for other Node.js programs to effectively run the CLI.\n */\n\n\nconst cli = {\n  /**\n   * Executes the CLI based on an array of arguments that is passed in.\n   * @param {string|Array|Object} args The arguments to process.\n   * @param {string} [text] The text to lint (used for TTY).\n   * @param {boolean} [allowFlatConfig] Whether or not to allow flat config.\n   * @returns {Promise<number>} The exit code for the operation.\n   */\n  async execute(args, text, allowFlatConfig) {\n    if (Array.isArray(args)) {\n      debug(\"CLI args: %o\", args.slice(2));\n    }\n    /*\n     * Before doing anything, we need to see if we are using a\n     * flat config file. If so, then we need to change the way command\n     * line args are parsed. This is temporary, and when we fully\n     * switch to flat config we can remove this logic.\n     */\n\n\n    const usingFlatConfig = allowFlatConfig && !!(await findFlatConfigFile(process.cwd()));\n    debug(\"Using flat config?\", usingFlatConfig);\n    const CLIOptions = createCLIOptions(usingFlatConfig);\n    /** @type {ParsedCLIOptions} */\n\n    let options;\n\n    try {\n      options = CLIOptions.parse(args);\n    } catch (error) {\n      debug(\"Error parsing CLI options:\", error.message);\n      log.error(error.message);\n      return 2;\n    }\n\n    const files = options._;\n    const useStdin = typeof text === \"string\";\n\n    if (options.help) {\n      log.info(CLIOptions.generateHelp());\n      return 0;\n    }\n\n    if (options.version) {\n      log.info(RuntimeInfo.version());\n      return 0;\n    }\n\n    if (options.envInfo) {\n      try {\n        log.info(RuntimeInfo.environment());\n        return 0;\n      } catch (err) {\n        debug(\"Error retrieving environment info\");\n        log.error(err.message);\n        return 2;\n      }\n    }\n\n    if (options.printConfig) {\n      if (files.length) {\n        log.error(\"The --print-config option must be used with exactly one file name.\");\n        return 2;\n      }\n\n      if (useStdin) {\n        log.error(\"The --print-config option is not available for piped-in code.\");\n        return 2;\n      }\n\n      const engine = usingFlatConfig ? new FlatESLint(await translateOptions(options, \"flat\")) : new ESLint(await translateOptions(options));\n      const fileConfig = await engine.calculateConfigForFile(options.printConfig);\n      log.info(JSON.stringify(fileConfig, null, \"  \"));\n      return 0;\n    }\n\n    debug(`Running on ${useStdin ? \"text\" : \"files\"}`);\n\n    if (options.fix && options.fixDryRun) {\n      log.error(\"The --fix option and the --fix-dry-run option cannot be used together.\");\n      return 2;\n    }\n\n    if (useStdin && options.fix) {\n      log.error(\"The --fix option is not available for piped-in code; use --fix-dry-run instead.\");\n      return 2;\n    }\n\n    if (options.fixType && !options.fix && !options.fixDryRun) {\n      log.error(\"The --fix-type option requires either --fix or --fix-dry-run.\");\n      return 2;\n    }\n\n    const ActiveESLint = usingFlatConfig ? FlatESLint : ESLint;\n    const engine = new ActiveESLint(await translateOptions(options, usingFlatConfig ? \"flat\" : \"eslintrc\"));\n    let results;\n\n    if (useStdin) {\n      results = await engine.lintText(text, {\n        filePath: options.stdinFilename,\n        warnIgnored: true\n      });\n    } else {\n      results = await engine.lintFiles(files);\n    }\n\n    if (options.fix) {\n      debug(\"Fix mode enabled - applying fixes\");\n      await ActiveESLint.outputFixes(results);\n    }\n\n    let resultsToPrint = results;\n\n    if (options.quiet) {\n      debug(\"Quiet mode enabled - filtering out warnings\");\n      resultsToPrint = ActiveESLint.getErrorResults(resultsToPrint);\n    }\n\n    if (await printResults(engine, resultsToPrint, options.format, options.outputFile)) {\n      // Errors and warnings from the original unfiltered results should determine the exit code\n      const {\n        errorCount,\n        fatalErrorCount,\n        warningCount\n      } = countErrors(results);\n      const tooManyWarnings = options.maxWarnings >= 0 && warningCount > options.maxWarnings;\n      const shouldExitForFatalErrors = options.exitOnFatalError && fatalErrorCount > 0;\n\n      if (!errorCount && tooManyWarnings) {\n        log.error(\"ESLint found too many warnings (maximum: %s).\", options.maxWarnings);\n      }\n\n      if (shouldExitForFatalErrors) {\n        return 2;\n      }\n\n      return errorCount || tooManyWarnings ? 1 : 0;\n    }\n\n    return 2;\n  }\n\n};\nmodule.exports = cli;","map":{"version":3,"names":["fs","require","path","promisify","ESLint","FlatESLint","createCLIOptions","log","RuntimeInfo","Legacy","naming","findFlatConfigFile","gitignoreToMinimatch","ModuleImporter","debug","mkdir","stat","writeFile","quietFixPredicate","message","severity","translateOptions","configType","cache","cacheFile","cacheLocation","cacheStrategy","config","configLookup","env","errorOnUnmatchedPattern","eslintrc","ext","fix","fixDryRun","fixType","global","ignore","ignorePath","ignorePattern","inlineConfig","parser","parserOptions","plugin","quiet","reportUnusedDisableDirectives","resolvePluginsRelativeTo","rule","rulesdir","overrideConfig","overrideConfigFile","importer","globals","reduce","obj","name","endsWith","slice","languageOptions","rules","import","plugins","pluginName","shortName","getShorthandName","longName","normalizePackageName","push","ignores","map","ignorePatterns","options","allowInlineConfig","fixTypes","rulePaths","useEslintrc","extensions","countErrors","results","errorCount","fatalErrorCount","warningCount","result","isDirectory","filePath","error","code","printResults","engine","format","outputFile","formatter","loadFormatter","e","output","resolve","process","cwd","dirname","recursive","ex","info","cli","execute","args","text","allowFlatConfig","Array","isArray","usingFlatConfig","CLIOptions","parse","files","_","useStdin","help","generateHelp","version","envInfo","environment","err","printConfig","length","fileConfig","calculateConfigForFile","JSON","stringify","ActiveESLint","lintText","stdinFilename","warnIgnored","lintFiles","outputFixes","resultsToPrint","getErrorResults","tooManyWarnings","maxWarnings","shouldExitForFatalErrors","exitOnFatalError","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/cli.js"],"sourcesContent":["/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n/*\n * NOTE: The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\"),\n    path = require(\"path\"),\n    { promisify } = require(\"util\"),\n    { ESLint } = require(\"./eslint\"),\n    { FlatESLint } = require(\"./eslint/flat-eslint\"),\n    createCLIOptions = require(\"./options\"),\n    log = require(\"./shared/logging\"),\n    RuntimeInfo = require(\"./shared/runtime-info\");\nconst { Legacy: { naming } } = require(\"@eslint/eslintrc\");\nconst { findFlatConfigFile } = require(\"./eslint/flat-eslint\");\nconst { gitignoreToMinimatch } = require(\"@humanwhocodes/gitignore-to-minimatch\");\nconst { ModuleImporter } = require(\"@humanwhocodes/module-importer\");\n\nconst debug = require(\"debug\")(\"eslint:cli\");\n\n//------------------------------------------------------------------------------\n// Types\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"./eslint/eslint\").ESLintOptions} ESLintOptions */\n/** @typedef {import(\"./eslint/eslint\").LintMessage} LintMessage */\n/** @typedef {import(\"./eslint/eslint\").LintResult} LintResult */\n/** @typedef {import(\"./options\").ParsedCLIOptions} ParsedCLIOptions */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst mkdir = promisify(fs.mkdir);\nconst stat = promisify(fs.stat);\nconst writeFile = promisify(fs.writeFile);\n\n/**\n * Predicate function for whether or not to apply fixes in quiet mode.\n * If a message is a warning, do not apply a fix.\n * @param {LintMessage} message The lint result.\n * @returns {boolean} True if the lint message is an error (and thus should be\n * autofixed), false otherwise.\n */\nfunction quietFixPredicate(message) {\n    return message.severity === 2;\n}\n\n/**\n * Translates the CLI options into the options expected by the ESLint constructor.\n * @param {ParsedCLIOptions} cliOptions The CLI options to translate.\n * @param {\"flat\"|\"eslintrc\"} [configType=\"eslintrc\"] The format of the\n *      config to generate.\n * @returns {Promise<ESLintOptions>} The options object for the ESLint constructor.\n * @private\n */\nasync function translateOptions({\n    cache,\n    cacheFile,\n    cacheLocation,\n    cacheStrategy,\n    config,\n    configLookup,\n    env,\n    errorOnUnmatchedPattern,\n    eslintrc,\n    ext,\n    fix,\n    fixDryRun,\n    fixType,\n    global,\n    ignore,\n    ignorePath,\n    ignorePattern,\n    inlineConfig,\n    parser,\n    parserOptions,\n    plugin,\n    quiet,\n    reportUnusedDisableDirectives,\n    resolvePluginsRelativeTo,\n    rule,\n    rulesdir\n}, configType) {\n\n    let overrideConfig, overrideConfigFile;\n    const importer = new ModuleImporter();\n\n    if (configType === \"flat\") {\n        overrideConfigFile = (typeof config === \"string\") ? config : !configLookup;\n        if (overrideConfigFile === false) {\n            overrideConfigFile = void 0;\n        }\n\n        let globals = {};\n\n        if (global) {\n            globals = global.reduce((obj, name) => {\n                if (name.endsWith(\":true\")) {\n                    obj[name.slice(0, -5)] = \"writable\";\n                } else {\n                    obj[name] = \"readonly\";\n                }\n                return obj;\n            }, globals);\n        }\n\n        overrideConfig = [{\n            languageOptions: {\n                globals,\n                parserOptions: parserOptions || {}\n            },\n            rules: rule ? rule : {}\n        }];\n\n        if (parser) {\n            overrideConfig[0].languageOptions.parser = await importer.import(parser);\n        }\n\n        if (plugin) {\n            const plugins = {};\n\n            for (const pluginName of plugin) {\n\n                const shortName = naming.getShorthandName(pluginName, \"eslint-plugin\");\n                const longName = naming.normalizePackageName(pluginName, \"eslint-plugin\");\n\n                plugins[shortName] = await importer.import(longName);\n            }\n\n            overrideConfig[0].plugins = plugins;\n        }\n\n        if (ignorePattern) {\n            overrideConfig.push({\n                ignores: ignorePattern.map(gitignoreToMinimatch)\n            });\n        }\n\n    } else {\n        overrideConfigFile = config;\n\n        overrideConfig = {\n            env: env && env.reduce((obj, name) => {\n                obj[name] = true;\n                return obj;\n            }, {}),\n            globals: global && global.reduce((obj, name) => {\n                if (name.endsWith(\":true\")) {\n                    obj[name.slice(0, -5)] = \"writable\";\n                } else {\n                    obj[name] = \"readonly\";\n                }\n                return obj;\n            }, {}),\n            ignorePatterns: ignorePattern,\n            parser,\n            parserOptions,\n            plugins: plugin,\n            rules: rule\n        };\n    }\n\n    const options = {\n        allowInlineConfig: inlineConfig,\n        cache,\n        cacheLocation: cacheLocation || cacheFile,\n        cacheStrategy,\n        errorOnUnmatchedPattern,\n        fix: (fix || fixDryRun) && (quiet ? quietFixPredicate : true),\n        fixTypes: fixType,\n        ignore,\n        ignorePath,\n        overrideConfig,\n        overrideConfigFile,\n        reportUnusedDisableDirectives: reportUnusedDisableDirectives ? \"error\" : void 0\n    };\n\n    if (configType !== \"flat\") {\n        options.resolvePluginsRelativeTo = resolvePluginsRelativeTo;\n        options.rulePaths = rulesdir;\n        options.useEslintrc = eslintrc;\n        options.extensions = ext;\n    }\n\n    return options;\n}\n\n/**\n * Count error messages.\n * @param {LintResult[]} results The lint results.\n * @returns {{errorCount:number;warningCount:number}} The number of error messages.\n */\nfunction countErrors(results) {\n    let errorCount = 0;\n    let fatalErrorCount = 0;\n    let warningCount = 0;\n\n    for (const result of results) {\n        errorCount += result.errorCount;\n        fatalErrorCount += result.fatalErrorCount;\n        warningCount += result.warningCount;\n    }\n\n    return { errorCount, fatalErrorCount, warningCount };\n}\n\n/**\n * Check if a given file path is a directory or not.\n * @param {string} filePath The path to a file to check.\n * @returns {Promise<boolean>} `true` if the given path is a directory.\n */\nasync function isDirectory(filePath) {\n    try {\n        return (await stat(filePath)).isDirectory();\n    } catch (error) {\n        if (error.code === \"ENOENT\" || error.code === \"ENOTDIR\") {\n            return false;\n        }\n        throw error;\n    }\n}\n\n/**\n * Outputs the results of the linting.\n * @param {ESLint} engine The ESLint instance to use.\n * @param {LintResult[]} results The results to print.\n * @param {string} format The name of the formatter to use or the path to the formatter.\n * @param {string} outputFile The path for the output file.\n * @returns {Promise<boolean>} True if the printing succeeds, false if not.\n * @private\n */\nasync function printResults(engine, results, format, outputFile) {\n    let formatter;\n\n    try {\n        formatter = await engine.loadFormatter(format);\n    } catch (e) {\n        log.error(e.message);\n        return false;\n    }\n\n    const output = await formatter.format(results);\n\n    if (output) {\n        if (outputFile) {\n            const filePath = path.resolve(process.cwd(), outputFile);\n\n            if (await isDirectory(filePath)) {\n                log.error(\"Cannot write to output file path, it is a directory: %s\", outputFile);\n                return false;\n            }\n\n            try {\n                await mkdir(path.dirname(filePath), { recursive: true });\n                await writeFile(filePath, output);\n            } catch (ex) {\n                log.error(\"There was a problem writing the output file:\\n%s\", ex);\n                return false;\n            }\n        } else {\n            log.info(output);\n        }\n    }\n\n    return true;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Encapsulates all CLI behavior for eslint. Makes it easier to test as well as\n * for other Node.js programs to effectively run the CLI.\n */\nconst cli = {\n\n    /**\n     * Executes the CLI based on an array of arguments that is passed in.\n     * @param {string|Array|Object} args The arguments to process.\n     * @param {string} [text] The text to lint (used for TTY).\n     * @param {boolean} [allowFlatConfig] Whether or not to allow flat config.\n     * @returns {Promise<number>} The exit code for the operation.\n     */\n    async execute(args, text, allowFlatConfig) {\n        if (Array.isArray(args)) {\n            debug(\"CLI args: %o\", args.slice(2));\n        }\n\n        /*\n         * Before doing anything, we need to see if we are using a\n         * flat config file. If so, then we need to change the way command\n         * line args are parsed. This is temporary, and when we fully\n         * switch to flat config we can remove this logic.\n         */\n\n        const usingFlatConfig = allowFlatConfig && !!(await findFlatConfigFile(process.cwd()));\n\n        debug(\"Using flat config?\", usingFlatConfig);\n\n        const CLIOptions = createCLIOptions(usingFlatConfig);\n\n        /** @type {ParsedCLIOptions} */\n        let options;\n\n        try {\n            options = CLIOptions.parse(args);\n        } catch (error) {\n            debug(\"Error parsing CLI options:\", error.message);\n            log.error(error.message);\n            return 2;\n        }\n\n        const files = options._;\n        const useStdin = typeof text === \"string\";\n\n        if (options.help) {\n            log.info(CLIOptions.generateHelp());\n            return 0;\n        }\n        if (options.version) {\n            log.info(RuntimeInfo.version());\n            return 0;\n        }\n        if (options.envInfo) {\n            try {\n                log.info(RuntimeInfo.environment());\n                return 0;\n            } catch (err) {\n                debug(\"Error retrieving environment info\");\n                log.error(err.message);\n                return 2;\n            }\n        }\n\n        if (options.printConfig) {\n            if (files.length) {\n                log.error(\"The --print-config option must be used with exactly one file name.\");\n                return 2;\n            }\n            if (useStdin) {\n                log.error(\"The --print-config option is not available for piped-in code.\");\n                return 2;\n            }\n\n            const engine = usingFlatConfig\n                ? new FlatESLint(await translateOptions(options, \"flat\"))\n                : new ESLint(await translateOptions(options));\n            const fileConfig =\n                await engine.calculateConfigForFile(options.printConfig);\n\n            log.info(JSON.stringify(fileConfig, null, \"  \"));\n            return 0;\n        }\n\n        debug(`Running on ${useStdin ? \"text\" : \"files\"}`);\n\n        if (options.fix && options.fixDryRun) {\n            log.error(\"The --fix option and the --fix-dry-run option cannot be used together.\");\n            return 2;\n        }\n        if (useStdin && options.fix) {\n            log.error(\"The --fix option is not available for piped-in code; use --fix-dry-run instead.\");\n            return 2;\n        }\n        if (options.fixType && !options.fix && !options.fixDryRun) {\n            log.error(\"The --fix-type option requires either --fix or --fix-dry-run.\");\n            return 2;\n        }\n\n        const ActiveESLint = usingFlatConfig ? FlatESLint : ESLint;\n\n        const engine = new ActiveESLint(await translateOptions(options, usingFlatConfig ? \"flat\" : \"eslintrc\"));\n        let results;\n\n        if (useStdin) {\n            results = await engine.lintText(text, {\n                filePath: options.stdinFilename,\n                warnIgnored: true\n            });\n        } else {\n            results = await engine.lintFiles(files);\n        }\n\n        if (options.fix) {\n            debug(\"Fix mode enabled - applying fixes\");\n            await ActiveESLint.outputFixes(results);\n        }\n\n        let resultsToPrint = results;\n\n        if (options.quiet) {\n            debug(\"Quiet mode enabled - filtering out warnings\");\n            resultsToPrint = ActiveESLint.getErrorResults(resultsToPrint);\n        }\n\n        if (await printResults(engine, resultsToPrint, options.format, options.outputFile)) {\n\n            // Errors and warnings from the original unfiltered results should determine the exit code\n            const { errorCount, fatalErrorCount, warningCount } = countErrors(results);\n\n            const tooManyWarnings =\n                options.maxWarnings >= 0 && warningCount > options.maxWarnings;\n            const shouldExitForFatalErrors =\n                options.exitOnFatalError && fatalErrorCount > 0;\n\n            if (!errorCount && tooManyWarnings) {\n                log.error(\n                    \"ESLint found too many warnings (maximum: %s).\",\n                    options.maxWarnings\n                );\n            }\n\n            if (shouldExitForFatalErrors) {\n                return 2;\n            }\n\n            return (errorCount || tooManyWarnings) ? 1 : 0;\n        }\n\n        return 2;\n    }\n};\n\nmodule.exports = cli;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}