{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst dataType_1 = require(\"../../compile/validate/dataType\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst equal_1 = require(\"../../runtime/equal\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        i,\n        j\n      }\n    } = _ref;\n    return (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        i,\n        j\n      }\n    } = _ref2;\n    return (0, codegen_1._)`{i: ${i}, j: ${j}}`;\n  }\n};\nconst def = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      parentSchema,\n      schemaCode,\n      it\n    } = cxt;\n    if (!$data && !schema) return;\n    const valid = gen.let(\"valid\");\n    const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];\n    cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);\n    cxt.ok(valid);\n\n    function validateUniqueItems() {\n      const i = gen.let(\"i\", (0, codegen_1._)`${data}.length`);\n      const j = gen.let(\"j\");\n      cxt.setParams({\n        i,\n        j\n      });\n      gen.assign(valid, true);\n      gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));\n    }\n\n    function canOptimize() {\n      return itemTypes.length > 0 && !itemTypes.some(t => t === \"object\" || t === \"array\");\n    }\n\n    function loopN(i, j) {\n      const item = gen.name(\"item\");\n      const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);\n      const indices = gen.const(\"indices\", (0, codegen_1._)`{}`);\n      gen.for((0, codegen_1._)`;${i}--;`, () => {\n        gen.let(item, (0, codegen_1._)`${data}[${i}]`);\n        gen.if(wrongType, (0, codegen_1._)`continue`);\n        if (itemTypes.length > 1) gen.if((0, codegen_1._)`typeof ${item} == \"string\"`, (0, codegen_1._)`${item} += \"_\"`);\n        gen.if((0, codegen_1._)`typeof ${indices}[${item}] == \"number\"`, () => {\n          gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);\n          cxt.error();\n          gen.assign(valid, false).break();\n        }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);\n      });\n    }\n\n    function loopN2(i, j) {\n      const eql = (0, util_1.useFunc)(gen, equal_1.default);\n      const outer = gen.name(\"outer\");\n      gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n        cxt.error();\n        gen.assign(valid, false).break(outer);\n      })));\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":"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","names":["error","message","params","i","j","def","keyword","type","schemaType","$data","code","cxt","gen","data","schema","parentSchema","schemaCode","it","valid","let","itemTypes","items","block$data","validateUniqueItems","ok","setParams","assign","if","canOptimize","loopN","loopN2","length","some","t","item","name","wrongType","opts","strictNumbers","dataType_1","Wrong","indices","const","for","break","eql","equal_1","outer","label","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\mini-css-extract-plugin\\node_modules\\ajv\\lib\\vocabularies\\validation\\uniqueItems.ts"],"sourcesContent":["import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}