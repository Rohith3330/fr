{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nvar INT32_MAX = 2147483647;\nexport function raggedRangeImpl(starts, startsShape, startsDType, limits, limitsShape, deltas, deltasShape) {\n  // Check input tensor shapes.\n  if (startsShape.length > 1) {\n    throw new Error('starts must be a scalar or vector');\n  }\n  if (limitsShape.length > 1) {\n    throw new Error('limits must be a scalar or vector');\n  }\n  if (deltasShape.length > 1) {\n    throw new Error('deltas must be a scalar or vector');\n  }\n  // Determine which tensors we need to broadcast.\n  var broadcastStarts = startsShape.length === 0;\n  var broadcastLimits = limitsShape.length === 0;\n  var broadcastDeltas = deltasShape.length === 0;\n  // nRows (number of output rows) is the size of the non-broadcast inputs,\n  // or 1 if all inputs are scalars.\n  var inSizes = [];\n  if (!broadcastStarts) {\n    inSizes.push(startsShape[0]);\n  }\n  if (!broadcastLimits) {\n    inSizes.push(limitsShape[0]);\n  }\n  if (!broadcastDeltas) {\n    inSizes.push(deltasShape[0]);\n  }\n  for (var i = 1; i < inSizes.length; ++i) {\n    if (inSizes[i] !== inSizes[i - 1]) {\n      throw new Error('starts, limits, and deltas must have the same shape');\n    }\n  }\n  var nRows = inSizes.length === 0 ? 1 : inSizes[0];\n  // Construct the rtNestedSplits tensor.\n  var rtNestedSplits = util.getArrayFromDType('int32', nRows + 1);\n  rtNestedSplits[0] = 0;\n  for (var row = 0; row < nRows; ++row) {\n    var start = broadcastStarts ? starts[0] : starts[row];\n    var limit = broadcastLimits ? limits[0] : limits[row];\n    var delta = broadcastDeltas ? deltas[0] : deltas[row];\n    if (delta === 0) {\n      throw new Error('Requires delta != 0');\n    }\n    var size = void 0; // The number of elements in the specified range.\n    if (delta > 0 && limit < start || delta < 0 && limit > start) {\n      size = 0;\n    } else {\n      size = Math.ceil(Math.abs((limit - start) / delta));\n      if (size > INT32_MAX) {\n        throw new Error(\"Requires ((limit - start) / delta) <= \".concat(INT32_MAX));\n      }\n    }\n    rtNestedSplits[row + 1] = rtNestedSplits[row] + size;\n  }\n  var nVals = rtNestedSplits[nRows];\n  // Construct the rtDenseValues tensor.\n  var rtDenseValues = util.getArrayFromDType(startsDType, nVals);\n  var valueIndex = 0;\n  for (var _row = 0; _row < nRows; ++_row) {\n    var rowSize = rtNestedSplits[_row + 1] - rtNestedSplits[_row];\n    var value = broadcastStarts ? starts[0] : starts[_row];\n    var _delta = broadcastDeltas ? deltas[0] : deltas[_row];\n    for (var _i = 0; _i < rowSize; ++_i) {\n      rtDenseValues[valueIndex++] = value;\n      value += _delta;\n    }\n  }\n  return [rtNestedSplits, rtDenseValues];\n}","map":null,"metadata":{},"sourceType":"module"}