{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nconst fs = require('fs');\n\nconst Module = require('module');\n\nconst path = require('path');\n\nconst hashObject = require('./hash').hashObject;\n\nconst ModuleCache = require('./ModuleCache').default;\n\nconst pkgDir = require('./pkgDir').default;\n\nconst CASE_SENSITIVE_FS = !fs.existsSync(path.join(__dirname.toUpperCase(), 'reSOLVE.js'));\nexports.CASE_SENSITIVE_FS = CASE_SENSITIVE_FS;\nconst ERROR_NAME = 'EslintPluginImportResolveError';\nconst fileExistsCache = new ModuleCache(); // Polyfill Node's `Module.createRequireFromPath` if not present (added in Node v10.12.0)\n// Use `Module.createRequire` if available (added in Node v12.2.0)\n\nconst createRequire = Module.createRequire || Module.createRequireFromPath || function (filename) {\n  const mod = new Module(filename, null);\n  mod.filename = filename;\n  mod.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  mod._compile(`module.exports = require;`, filename);\n\n  return mod.exports;\n};\n\nfunction tryRequire(target, sourceFile) {\n  let resolved;\n\n  try {\n    // Check if the target exists\n    if (sourceFile != null) {\n      try {\n        resolved = createRequire(path.resolve(sourceFile)).resolve(target);\n      } catch (e) {\n        resolved = require.resolve(target);\n      }\n    } else {\n      resolved = require.resolve(target);\n    }\n  } catch (e) {\n    // If the target does not exist then just return undefined\n    return undefined;\n  } // If the target exists then return the loaded module\n\n\n  return require(resolved);\n} // https://stackoverflow.com/a/27382838\n\n\nexports.fileExistsWithCaseSync = function fileExistsWithCaseSync(filepath, cacheSettings, strict) {\n  // don't care if the FS is case-sensitive\n  if (CASE_SENSITIVE_FS) return true; // null means it resolved to a builtin\n\n  if (filepath === null) return true;\n  if (filepath.toLowerCase() === process.cwd().toLowerCase() && !strict) return true;\n  const parsedPath = path.parse(filepath);\n  const dir = parsedPath.dir;\n  let result = fileExistsCache.get(filepath, cacheSettings);\n  if (result != null) return result; // base case\n\n  if (dir === '' || parsedPath.root === filepath) {\n    result = true;\n  } else {\n    const filenames = fs.readdirSync(dir);\n\n    if (filenames.indexOf(parsedPath.base) === -1) {\n      result = false;\n    } else {\n      result = fileExistsWithCaseSync(dir, cacheSettings, strict);\n    }\n  }\n\n  fileExistsCache.set(filepath, result);\n  return result;\n};\n\nfunction relative(modulePath, sourceFile, settings) {\n  return fullResolve(modulePath, sourceFile, settings).path;\n}\n\nfunction fullResolve(modulePath, sourceFile, settings) {\n  // check if this is a bonus core module\n  const coreSet = new Set(settings['import/core-modules']);\n  if (coreSet.has(modulePath)) return {\n    found: true,\n    path: null\n  };\n  const sourceDir = path.dirname(sourceFile);\n  const cacheKey = sourceDir + hashObject(settings).digest('hex') + modulePath;\n  const cacheSettings = ModuleCache.getSettings(settings);\n  const cachedPath = fileExistsCache.get(cacheKey, cacheSettings);\n  if (cachedPath !== undefined) return {\n    found: true,\n    path: cachedPath\n  };\n\n  function cache(resolvedPath) {\n    fileExistsCache.set(cacheKey, resolvedPath);\n  }\n\n  function withResolver(resolver, config) {\n    function v1() {\n      try {\n        const resolved = resolver.resolveImport(modulePath, sourceFile, config);\n        if (resolved === undefined) return {\n          found: false\n        };\n        return {\n          found: true,\n          path: resolved\n        };\n      } catch (err) {\n        return {\n          found: false\n        };\n      }\n    }\n\n    function v2() {\n      return resolver.resolve(modulePath, sourceFile, config);\n    }\n\n    switch (resolver.interfaceVersion) {\n      case 2:\n        return v2();\n\n      default:\n      case 1:\n        return v1();\n    }\n  }\n\n  const configResolvers = settings['import/resolver'] || {\n    'node': settings['import/resolve']\n  }; // backward compatibility\n\n  const resolvers = resolverReducer(configResolvers, new Map());\n\n  for (const pair of resolvers) {\n    const name = pair[0];\n    const config = pair[1];\n    const resolver = requireResolver(name, sourceFile);\n    const resolved = withResolver(resolver, config);\n    if (!resolved.found) continue; // else, counts\n\n    cache(resolved.path);\n    return resolved;\n  } // failed\n  // cache(undefined)\n\n\n  return {\n    found: false\n  };\n}\n\nexports.relative = relative;\n\nfunction resolverReducer(resolvers, map) {\n  if (Array.isArray(resolvers)) {\n    resolvers.forEach(r => resolverReducer(r, map));\n    return map;\n  }\n\n  if (typeof resolvers === 'string') {\n    map.set(resolvers, null);\n    return map;\n  }\n\n  if (typeof resolvers === 'object') {\n    for (const key in resolvers) {\n      map.set(key, resolvers[key]);\n    }\n\n    return map;\n  }\n\n  const err = new Error('invalid resolver config');\n  err.name = ERROR_NAME;\n  throw err;\n}\n\nfunction getBaseDir(sourceFile) {\n  return pkgDir(sourceFile) || process.cwd();\n}\n\nfunction requireResolver(name, sourceFile) {\n  // Try to resolve package with conventional name\n  const resolver = tryRequire(`eslint-import-resolver-${name}`, sourceFile) || tryRequire(name, sourceFile) || tryRequire(path.resolve(getBaseDir(sourceFile), name));\n\n  if (!resolver) {\n    const err = new Error(`unable to load resolver \"${name}\".`);\n    err.name = ERROR_NAME;\n    throw err;\n  }\n\n  if (!isResolverValid(resolver)) {\n    const err = new Error(`${name} with invalid interface loaded as resolver`);\n    err.name = ERROR_NAME;\n    throw err;\n  }\n\n  return resolver;\n}\n\nfunction isResolverValid(resolver) {\n  if (resolver.interfaceVersion === 2) {\n    return resolver.resolve && typeof resolver.resolve === 'function';\n  } else {\n    return resolver.resolveImport && typeof resolver.resolveImport === 'function';\n  }\n}\n\nconst erroredContexts = new Set();\n/**\n * Given\n * @param  {string} p - module path\n * @param  {object} context - ESLint context\n * @return {string} - the full module filesystem path;\n *                    null if package is core;\n *                    undefined if not found\n */\n\nfunction resolve(p, context) {\n  try {\n    return relative(p, context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename(), context.settings);\n  } catch (err) {\n    if (!erroredContexts.has(context)) {\n      // The `err.stack` string starts with `err.name` followed by colon and `err.message`.\n      // We're filtering out the default `err.name` because it adds little value to the message.\n      let errMessage = err.message;\n\n      if (err.name !== ERROR_NAME && err.stack) {\n        errMessage = err.stack.replace(/^Error: /, '');\n      }\n\n      context.report({\n        message: `Resolve error: ${errMessage}`,\n        loc: {\n          line: 1,\n          column: 0\n        }\n      });\n      erroredContexts.add(context);\n    }\n  }\n}\n\nresolve.relative = relative;\nexports.default = resolve;","map":{"version":3,"names":["exports","__esModule","fs","require","Module","path","hashObject","ModuleCache","default","pkgDir","CASE_SENSITIVE_FS","existsSync","join","__dirname","toUpperCase","ERROR_NAME","fileExistsCache","createRequire","createRequireFromPath","filename","mod","paths","_nodeModulePaths","dirname","_compile","tryRequire","target","sourceFile","resolved","resolve","e","undefined","fileExistsWithCaseSync","filepath","cacheSettings","strict","toLowerCase","process","cwd","parsedPath","parse","dir","result","get","root","filenames","readdirSync","indexOf","base","set","relative","modulePath","settings","fullResolve","coreSet","Set","has","found","sourceDir","cacheKey","digest","getSettings","cachedPath","cache","resolvedPath","withResolver","resolver","config","v1","resolveImport","err","v2","interfaceVersion","configResolvers","resolvers","resolverReducer","Map","pair","name","requireResolver","map","Array","isArray","forEach","r","key","Error","getBaseDir","isResolverValid","erroredContexts","p","context","getPhysicalFilename","getFilename","errMessage","message","stack","replace","report","loc","line","column","add"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-module-utils/resolve.js"],"sourcesContent":["'use strict';\nexports.__esModule = true;\n\nconst fs = require('fs');\nconst Module = require('module');\nconst path = require('path');\n\nconst hashObject = require('./hash').hashObject;\nconst ModuleCache = require('./ModuleCache').default;\nconst pkgDir = require('./pkgDir').default;\n\nconst CASE_SENSITIVE_FS = !fs.existsSync(path.join(__dirname.toUpperCase(), 'reSOLVE.js'));\nexports.CASE_SENSITIVE_FS = CASE_SENSITIVE_FS;\n\nconst ERROR_NAME = 'EslintPluginImportResolveError';\n\nconst fileExistsCache = new ModuleCache();\n\n// Polyfill Node's `Module.createRequireFromPath` if not present (added in Node v10.12.0)\n// Use `Module.createRequire` if available (added in Node v12.2.0)\nconst createRequire = Module.createRequire || Module.createRequireFromPath || function (filename) {\n  const mod = new Module(filename, null);\n  mod.filename = filename;\n  mod.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  mod._compile(`module.exports = require;`, filename);\n\n  return mod.exports;\n};\n\nfunction tryRequire(target, sourceFile) {\n  let resolved;\n  try {\n    // Check if the target exists\n    if (sourceFile != null) {\n      try {\n        resolved = createRequire(path.resolve(sourceFile)).resolve(target);\n      } catch (e) {\n        resolved = require.resolve(target);\n      }\n    } else {\n      resolved = require.resolve(target);\n    }\n  } catch (e) {\n    // If the target does not exist then just return undefined\n    return undefined;\n  }\n\n  // If the target exists then return the loaded module\n  return require(resolved);\n}\n\n// https://stackoverflow.com/a/27382838\nexports.fileExistsWithCaseSync = function fileExistsWithCaseSync(filepath, cacheSettings, strict) {\n  // don't care if the FS is case-sensitive\n  if (CASE_SENSITIVE_FS) return true;\n\n  // null means it resolved to a builtin\n  if (filepath === null) return true;\n  if (filepath.toLowerCase() === process.cwd().toLowerCase() && !strict) return true;\n  const parsedPath = path.parse(filepath);\n  const dir = parsedPath.dir;\n\n  let result = fileExistsCache.get(filepath, cacheSettings);\n  if (result != null) return result;\n\n  // base case\n  if (dir === '' || parsedPath.root === filepath) {\n    result = true;\n  } else {\n    const filenames = fs.readdirSync(dir);\n    if (filenames.indexOf(parsedPath.base) === -1) {\n      result = false;\n    } else {\n      result = fileExistsWithCaseSync(dir, cacheSettings, strict);\n    }\n  }\n  fileExistsCache.set(filepath, result);\n  return result;\n};\n\nfunction relative(modulePath, sourceFile, settings) {\n  return fullResolve(modulePath, sourceFile, settings).path;\n}\n\nfunction fullResolve(modulePath, sourceFile, settings) {\n  // check if this is a bonus core module\n  const coreSet = new Set(settings['import/core-modules']);\n  if (coreSet.has(modulePath)) return { found: true, path: null };\n\n  const sourceDir = path.dirname(sourceFile);\n  const cacheKey = sourceDir + hashObject(settings).digest('hex') + modulePath;\n\n  const cacheSettings = ModuleCache.getSettings(settings);\n\n  const cachedPath = fileExistsCache.get(cacheKey, cacheSettings);\n  if (cachedPath !== undefined) return { found: true, path: cachedPath };\n\n  function cache(resolvedPath) {\n    fileExistsCache.set(cacheKey, resolvedPath);\n  }\n\n  function withResolver(resolver, config) {\n\n    function v1() {\n      try {\n        const resolved = resolver.resolveImport(modulePath, sourceFile, config);\n        if (resolved === undefined) return { found: false };\n        return { found: true, path: resolved };\n      } catch (err) {\n        return { found: false };\n      }\n    }\n\n    function v2() {\n      return resolver.resolve(modulePath, sourceFile, config);\n    }\n\n    switch (resolver.interfaceVersion) {\n    case 2:\n      return v2();\n\n    default:\n    case 1:\n      return v1();\n    }\n  }\n\n  const configResolvers = (settings['import/resolver']\n    || { 'node': settings['import/resolve'] }); // backward compatibility\n\n  const resolvers = resolverReducer(configResolvers, new Map());\n\n  for (const pair of resolvers) {\n    const name = pair[0];\n    const config = pair[1];\n    const resolver = requireResolver(name, sourceFile);\n    const resolved = withResolver(resolver, config);\n\n    if (!resolved.found) continue;\n\n    // else, counts\n    cache(resolved.path);\n    return resolved;\n  }\n\n  // failed\n  // cache(undefined)\n  return { found: false };\n}\nexports.relative = relative;\n\nfunction resolverReducer(resolvers, map) {\n  if (Array.isArray(resolvers)) {\n    resolvers.forEach(r => resolverReducer(r, map));\n    return map;\n  }\n\n  if (typeof resolvers === 'string') {\n    map.set(resolvers, null);\n    return map;\n  }\n\n  if (typeof resolvers === 'object') {\n    for (const key in resolvers) {\n      map.set(key, resolvers[key]);\n    }\n    return map;\n  }\n\n  const err = new Error('invalid resolver config');\n  err.name = ERROR_NAME;\n  throw err;\n}\n\nfunction getBaseDir(sourceFile) {\n  return pkgDir(sourceFile) || process.cwd();\n}\nfunction requireResolver(name, sourceFile) {\n  // Try to resolve package with conventional name\n  const resolver = tryRequire(`eslint-import-resolver-${name}`, sourceFile) ||\n    tryRequire(name, sourceFile) ||\n    tryRequire(path.resolve(getBaseDir(sourceFile), name));\n\n  if (!resolver) {\n    const err = new Error(`unable to load resolver \"${name}\".`);\n    err.name = ERROR_NAME;\n    throw err;\n  }\n  if (!isResolverValid(resolver)) {\n    const err = new Error(`${name} with invalid interface loaded as resolver`);\n    err.name = ERROR_NAME;\n    throw err;\n  }\n\n  return resolver;\n}\n\nfunction isResolverValid(resolver) {\n  if (resolver.interfaceVersion === 2) {\n    return resolver.resolve && typeof resolver.resolve === 'function';\n  } else {\n    return resolver.resolveImport && typeof resolver.resolveImport === 'function';\n  }\n}\n\nconst erroredContexts = new Set();\n\n/**\n * Given\n * @param  {string} p - module path\n * @param  {object} context - ESLint context\n * @return {string} - the full module filesystem path;\n *                    null if package is core;\n *                    undefined if not found\n */\nfunction resolve(p, context) {\n  try {\n    return relative(p, context.getPhysicalFilename ? context.getPhysicalFilename() : context.getFilename(), context.settings);\n  } catch (err) {\n    if (!erroredContexts.has(context)) {\n      // The `err.stack` string starts with `err.name` followed by colon and `err.message`.\n      // We're filtering out the default `err.name` because it adds little value to the message.\n      let errMessage = err.message;\n      if (err.name !== ERROR_NAME && err.stack) {\n        errMessage = err.stack.replace(/^Error: /, '');\n      }\n      context.report({\n        message: `Resolve error: ${errMessage}`,\n        loc: { line: 1, column: 0 },\n      });\n      erroredContexts.add(context);\n    }\n  }\n}\nresolve.relative = relative;\nexports.default = resolve;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}