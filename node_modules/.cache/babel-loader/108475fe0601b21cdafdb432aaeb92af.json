{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _ExportVisitor_referencer, _ExportVisitor_exportNode;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExportVisitor = void 0;\n\nconst types_1 = require(\"@typescript-eslint/types\");\n\nconst Visitor_1 = require(\"./Visitor\");\n\nclass ExportVisitor extends Visitor_1.Visitor {\n  constructor(node, referencer) {\n    super(referencer);\n\n    _ExportVisitor_referencer.set(this, void 0);\n\n    _ExportVisitor_exportNode.set(this, void 0);\n\n    __classPrivateFieldSet(this, _ExportVisitor_exportNode, node, \"f\");\n\n    __classPrivateFieldSet(this, _ExportVisitor_referencer, referencer, \"f\");\n  }\n\n  static visit(referencer, node) {\n    const exportReferencer = new ExportVisitor(node, referencer);\n    exportReferencer.visit(node);\n  }\n\n  Identifier(node) {\n    if (__classPrivateFieldGet(this, _ExportVisitor_exportNode, \"f\").exportKind === 'type') {\n      // export type { T };\n      // type exports can only reference types\n      __classPrivateFieldGet(this, _ExportVisitor_referencer, \"f\").currentScope().referenceType(node);\n    } else {\n      __classPrivateFieldGet(this, _ExportVisitor_referencer, \"f\").currentScope().referenceDualValueType(node);\n    }\n  }\n\n  ExportDefaultDeclaration(node) {\n    if (node.declaration.type === types_1.AST_NODE_TYPES.Identifier) {\n      // export default A;\n      // this could be a type or a variable\n      this.visit(node.declaration);\n    } else {// export const a = 1;\n      // export something();\n      // etc\n      // these not included in the scope of this visitor as they are all guaranteed to be values or declare variables\n    }\n  }\n\n  ExportNamedDeclaration(node) {\n    if (node.source) {\n      // export ... from 'foo';\n      // these are external identifiers so there shouldn't be references or defs\n      return;\n    }\n\n    if (!node.declaration) {\n      // export { x };\n      this.visitChildren(node);\n    } else {// export const x = 1;\n      // this is not included in the scope of this visitor as it creates a variable\n    }\n  }\n\n  ExportSpecifier(node) {\n    if (node.exportKind === 'type') {\n      // export { type T };\n      // type exports can only reference types\n      //\n      // we can't let this fall through to the Identifier selector because the exportKind is on this node\n      // and we don't have access to the `.parent` during scope analysis\n      __classPrivateFieldGet(this, _ExportVisitor_referencer, \"f\").currentScope().referenceType(node.local);\n    } else {\n      this.visit(node.local);\n    }\n  }\n\n}\n\nexports.ExportVisitor = ExportVisitor;\n_ExportVisitor_referencer = new WeakMap(), _ExportVisitor_exportNode = new WeakMap();","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AACA;;AAGA;;AAOA,MAAMA,aAAN,SAA4BC,iBAA5B,CAAmC;EAIjCC,YAAYC,IAAZ,EAA8BC,UAA9B,EAAoD;IAClD,MAAMA,UAAN;;IAJFC;;IACAC;;IAIEC,6BAAID,yBAAJ,EAAmBH,IAAnB,EAAuB,GAAvB;;IACAI,6BAAIF,yBAAJ,EAAmBD,UAAnB,EAA6B,GAA7B;EACD;;EAEW,OAALI,KAAK,CAACJ,UAAD,EAAyBD,IAAzB,EAAyC;IACnD,MAAMM,gBAAgB,GAAG,IAAIT,aAAJ,CAAkBG,IAAlB,EAAwBC,UAAxB,CAAzB;IACAK,gBAAgB,CAACD,KAAjB,CAAuBL,IAAvB;EACD;;EAESO,UAAU,CAACP,IAAD,EAA0B;IAC5C,IAAIQ,6BAAIL,yBAAJ,EAAI,GAAJ,EAAiBM,UAAjB,KAAgC,MAApC,EAA4C;MAC1C;MACA;MACAD,6BAAIN,yBAAJ,EAAI,GAAJ,EAAiBQ,YAAjB,GAAgCC,aAAhC,CAA8CX,IAA9C;IACD,CAJD,MAIO;MACLQ,6BAAIN,yBAAJ,EAAI,GAAJ,EAAiBQ,YAAjB,GAAgCE,sBAAhC,CAAuDZ,IAAvD;IACD;EACF;;EAESa,wBAAwB,CAChCb,IADgC,EACO;IAEvC,IAAIA,IAAI,CAACc,WAAL,CAAiBC,IAAjB,KAA0BC,uBAAeT,UAA7C,EAAyD;MACvD;MACA;MACA,KAAKF,KAAL,CAAWL,IAAI,CAACc,WAAhB;IACD,CAJD,MAIO,CACL;MACA;MACA;MACA;IACD;EACF;;EAESG,sBAAsB,CAC9BjB,IAD8B,EACO;IAErC,IAAIA,IAAI,CAACkB,MAAT,EAAiB;MACf;MACA;MACA;IACD;;IAED,IAAI,CAAClB,IAAI,CAACc,WAAV,EAAuB;MACrB;MACA,KAAKK,aAAL,CAAmBnB,IAAnB;IACD,CAHD,MAGO,CACL;MACA;IACD;EACF;;EAESoB,eAAe,CAACpB,IAAD,EAA+B;IACtD,IAAIA,IAAI,CAACS,UAAL,KAAoB,MAAxB,EAAgC;MAC9B;MACA;MACA;MACA;MACA;MACAD,6BAAIN,yBAAJ,EAAI,GAAJ,EAAiBQ,YAAjB,GAAgCC,aAAhC,CAA8CX,IAAI,CAACqB,KAAnD;IACD,CAPD,MAOO;MACL,KAAKhB,KAAL,CAAWL,IAAI,CAACqB,KAAhB;IACD;EACF;;AArEgC;;AAwE1BC","names":["ExportVisitor","Visitor_1","constructor","node","referencer","_ExportVisitor_referencer","_ExportVisitor_exportNode","__classPrivateFieldSet","visit","exportReferencer","Identifier","__classPrivateFieldGet","exportKind","currentScope","referenceType","referenceDualValueType","ExportDefaultDeclaration","declaration","type","types_1","ExportNamedDeclaration","source","visitChildren","ExportSpecifier","local","exports"],"sources":["../../src/referencer/ExportVisitor.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}