{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../lib/types').XastNode} XastNode\n */\n\nconst {\n  inheritableAttrs,\n  elemsGroups\n} = require('./_collections.js');\n\nexports.type = 'visitor';\nexports.name = 'collapseGroups';\nexports.active = true;\nexports.description = 'collapses useless groups';\n/**\n * @type {(node: XastNode, name: string) => boolean}\n */\n\nconst hasAnimatedAttr = (node, name) => {\n  if (node.type === 'element') {\n    if (elemsGroups.animation.includes(node.name) && node.attributes.attributeName === name) {\n      return true;\n    }\n\n    for (const child of node.children) {\n      if (hasAnimatedAttr(child, name)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Collapse useless groups.\n *\n * @example\n * <g>\n *     <g attr1=\"val1\">\n *         <path d=\"...\"/>\n *     </g>\n * </g>\n *         ⬇\n * <g>\n *     <g>\n *         <path attr1=\"val1\" d=\"...\"/>\n *     </g>\n * </g>\n *         ⬇\n * <path attr1=\"val1\" d=\"...\"/>\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<void>}\n */\n\n\nexports.fn = () => {\n  return {\n    element: {\n      exit: (node, parentNode) => {\n        if (parentNode.type === 'root' || parentNode.name === 'switch') {\n          return;\n        } // non-empty groups\n\n\n        if (node.name !== 'g' || node.children.length === 0) {\n          return;\n        } // move group attibutes to the single child element\n\n\n        if (Object.keys(node.attributes).length !== 0 && node.children.length === 1) {\n          const firstChild = node.children[0]; // TODO untangle this mess\n\n          if (firstChild.type === 'element' && firstChild.attributes.id == null && node.attributes.filter == null && (node.attributes.class == null || firstChild.attributes.class == null) && (node.attributes['clip-path'] == null && node.attributes.mask == null || firstChild.name === 'g' && node.attributes.transform == null && firstChild.attributes.transform == null)) {\n            for (const [name, value] of Object.entries(node.attributes)) {\n              // avoid copying to not conflict with animated attribute\n              if (hasAnimatedAttr(firstChild, name)) {\n                return;\n              }\n\n              if (firstChild.attributes[name] == null) {\n                firstChild.attributes[name] = value;\n              } else if (name === 'transform') {\n                firstChild.attributes[name] = value + ' ' + firstChild.attributes[name];\n              } else if (firstChild.attributes[name] === 'inherit') {\n                firstChild.attributes[name] = value;\n              } else if (inheritableAttrs.includes(name) === false && firstChild.attributes[name] !== value) {\n                return;\n              }\n\n              delete node.attributes[name];\n            }\n          }\n        } // collapse groups without attributes\n\n\n        if (Object.keys(node.attributes).length === 0) {\n          // animation elements \"add\" attributes to group\n          // group should be preserved\n          for (const child of node.children) {\n            if (child.type === 'element' && elemsGroups.animation.includes(child.name)) {\n              return;\n            }\n          } // replace current node with all its children\n\n\n          const index = parentNode.children.indexOf(node);\n          parentNode.children.splice(index, 1, ...node.children); // TODO remove in v3\n\n          for (const child of node.children) {\n            // @ts-ignore parentNode is forbidden for public usage\n            // and will be moved in v3\n            child.parentNode = parentNode;\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["inheritableAttrs","elemsGroups","require","exports","type","name","active","description","hasAnimatedAttr","node","animation","includes","attributes","attributeName","child","children","fn","element","exit","parentNode","length","Object","keys","firstChild","id","filter","class","mask","transform","value","entries","index","indexOf","splice"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/svgo/plugins/collapseGroups.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastNode} XastNode\n */\n\nconst { inheritableAttrs, elemsGroups } = require('./_collections.js');\n\nexports.type = 'visitor';\nexports.name = 'collapseGroups';\nexports.active = true;\nexports.description = 'collapses useless groups';\n\n/**\n * @type {(node: XastNode, name: string) => boolean}\n */\nconst hasAnimatedAttr = (node, name) => {\n  if (node.type === 'element') {\n    if (\n      elemsGroups.animation.includes(node.name) &&\n      node.attributes.attributeName === name\n    ) {\n      return true;\n    }\n    for (const child of node.children) {\n      if (hasAnimatedAttr(child, name)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Collapse useless groups.\n *\n * @example\n * <g>\n *     <g attr1=\"val1\">\n *         <path d=\"...\"/>\n *     </g>\n * </g>\n *         ⬇\n * <g>\n *     <g>\n *         <path attr1=\"val1\" d=\"...\"/>\n *     </g>\n * </g>\n *         ⬇\n * <path attr1=\"val1\" d=\"...\"/>\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<void>}\n */\nexports.fn = () => {\n  return {\n    element: {\n      exit: (node, parentNode) => {\n        if (parentNode.type === 'root' || parentNode.name === 'switch') {\n          return;\n        }\n        // non-empty groups\n        if (node.name !== 'g' || node.children.length === 0) {\n          return;\n        }\n\n        // move group attibutes to the single child element\n        if (\n          Object.keys(node.attributes).length !== 0 &&\n          node.children.length === 1\n        ) {\n          const firstChild = node.children[0];\n          // TODO untangle this mess\n          if (\n            firstChild.type === 'element' &&\n            firstChild.attributes.id == null &&\n            node.attributes.filter == null &&\n            (node.attributes.class == null ||\n              firstChild.attributes.class == null) &&\n            ((node.attributes['clip-path'] == null &&\n              node.attributes.mask == null) ||\n              (firstChild.name === 'g' &&\n                node.attributes.transform == null &&\n                firstChild.attributes.transform == null))\n          ) {\n            for (const [name, value] of Object.entries(node.attributes)) {\n              // avoid copying to not conflict with animated attribute\n              if (hasAnimatedAttr(firstChild, name)) {\n                return;\n              }\n              if (firstChild.attributes[name] == null) {\n                firstChild.attributes[name] = value;\n              } else if (name === 'transform') {\n                firstChild.attributes[name] =\n                  value + ' ' + firstChild.attributes[name];\n              } else if (firstChild.attributes[name] === 'inherit') {\n                firstChild.attributes[name] = value;\n              } else if (\n                inheritableAttrs.includes(name) === false &&\n                firstChild.attributes[name] !== value\n              ) {\n                return;\n              }\n              delete node.attributes[name];\n            }\n          }\n        }\n\n        // collapse groups without attributes\n        if (Object.keys(node.attributes).length === 0) {\n          // animation elements \"add\" attributes to group\n          // group should be preserved\n          for (const child of node.children) {\n            if (\n              child.type === 'element' &&\n              elemsGroups.animation.includes(child.name)\n            ) {\n              return;\n            }\n          }\n          // replace current node with all its children\n          const index = parentNode.children.indexOf(node);\n          parentNode.children.splice(index, 1, ...node.children);\n          // TODO remove in v3\n          for (const child of node.children) {\n            // @ts-ignore parentNode is forbidden for public usage\n            // and will be moved in v3\n            child.parentNode = parentNode;\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}