{"ast":null,"code":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nvar fs = require('fs'),\n    path = require('path'),\n    minimatch = require('minimatch'),\n    escapeRegExpChars,\n    merge,\n    basedir,\n    _readDir,\n    readdirR,\n    globSync;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar hasOwn = function (obj, key) {\n  return hasOwnProperty.apply(obj, [key]);\n};\n/**\n  @name escapeRegExpChars\n  @function\n  @return {String} A string of escaped characters\n  @description Escapes regex control-characters in strings\n               used to build regexes dynamically\n  @param {String} string The string of chars to escape\n*/\n\n\nescapeRegExpChars = function () {\n  var specials = ['^', '$', '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\'];\n  var sRE = new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'g');\n  return function (string) {\n    var str = string || '';\n    str = String(str);\n    return str.replace(sRE, '\\\\$1');\n  };\n}();\n/**\n  @name merge\n  @function\n  @return {Object} Returns the merged object\n  @description Merge merges `otherObject` into `object` and takes care of deep\n               merging of objects\n  @param {Object} object Object to merge into\n  @param {Object} otherObject Object to read from\n*/\n\n\nmerge = function (object, otherObject) {\n  var obj = object || {},\n      otherObj = otherObject || {},\n      key,\n      value;\n\n  for (key in otherObj) {\n    if (!hasOwn(otherObj, key)) {\n      continue;\n    }\n\n    if (key === '__proto__' || key === 'constructor') {\n      continue;\n    }\n\n    value = otherObj[key]; // Check if a value is an Object, if so recursively add it's key/values\n\n    if (typeof value === 'object' && !(value instanceof Array)) {\n      // Update value of object to the one from otherObj\n      obj[key] = merge(obj[key], value);\n    } // Value is anything other than an Object, so just add it\n    else {\n      obj[key] = value;\n    }\n  }\n\n  return obj;\n};\n/**\n  Given a patern, return the base directory of it (ie. the folder\n  that will contain all the files matching the path).\n  eg. file.basedir('/test/**') => '/test/'\n  Path ending by '/' are considerd as folder while other are considerd\n  as files, eg.:\n      file.basedir('/test/a/') => '/test/a'\n      file.basedir('/test/a') => '/test'\n  The returned path always end with a '/' so we have:\n      file.basedir(file.basedir(x)) == file.basedir(x)\n*/\n\n\nbasedir = function (pathParam) {\n  var bd = '',\n      parts,\n      part,\n      pos = 0,\n      p = pathParam || ''; // If the path has a leading asterisk, basedir is the current dir\n\n  if (p.indexOf('*') == 0 || p.indexOf('**') == 0) {\n    return '.';\n  } // always consider .. at the end as a folder and not a filename\n\n\n  if (/(?:^|\\/|\\\\)\\.\\.$/.test(p.slice(-3))) {\n    p += '/';\n  }\n\n  parts = p.split(/\\\\|\\//);\n\n  for (var i = 0, l = parts.length - 1; i < l; i++) {\n    part = parts[i];\n\n    if (part.indexOf('*') > -1 || part.indexOf('**') > -1) {\n      break;\n    }\n\n    pos += part.length + 1;\n    bd += part + p[pos - 1];\n  }\n\n  if (!bd) {\n    bd = '.';\n  } // Strip trailing slashes\n\n\n  if (!(bd == '\\\\' || bd == '/')) {\n    bd = bd.replace(/\\\\$|\\/$/, '');\n  }\n\n  return bd;\n}; // Return the contents of a given directory\n\n\n_readDir = function (dirPath) {\n  var dir = path.normalize(dirPath),\n      paths = [],\n      ret = [dir],\n      msg;\n\n  try {\n    paths = fs.readdirSync(dir);\n  } catch (e) {\n    msg = 'Could not read path ' + dir + '\\n';\n\n    if (e.stack) {\n      msg += e.stack;\n    }\n\n    throw new Error(msg);\n  }\n\n  paths.forEach(function (p) {\n    var curr = path.join(dir, p);\n    var stat = fs.statSync(curr);\n\n    if (stat.isDirectory()) {\n      ret = ret.concat(_readDir(curr));\n    } else {\n      ret.push(curr);\n    }\n  });\n  return ret;\n};\n/**\n  @name file#readdirR\n  @function\n  @return {Array} Returns the contents as an Array, can be configured via opts.format\n  @description Reads the given directory returning it's contents\n  @param {String} dir The directory to read\n  @param {Object} opts Options to use\n    @param {String} [opts.format] Set the format to return(Default: Array)\n*/\n\n\nreaddirR = function (dir, opts) {\n  var options = opts || {},\n      format = options.format || 'array',\n      ret;\n  ret = _readDir(dir);\n  return format == 'string' ? ret.join('\\n') : ret;\n};\n\nglobSync = function (pat, opts) {\n  var dirname = basedir(pat),\n      files,\n      matches;\n\n  try {\n    files = readdirR(dirname).map(function (file) {\n      return file.replace(/\\\\/g, '/');\n    });\n  } // Bail if path doesn't exist -- assume no files\n  catch (e) {\n    if (FileList.verbose) console.error(e.message);\n  }\n\n  if (files) {\n    pat = path.normalize(pat);\n    matches = minimatch.match(files, pat, opts || {});\n  }\n\n  return matches || [];\n}; // Constants\n// ---------------\n// List of all the builtin Array methods we want to override\n\n\nvar ARRAY_METHODS = Object.getOwnPropertyNames(Array.prototype) // Array methods that return a copy instead of affecting the original\n,\n    SPECIAL_RETURN = {\n  'concat': true,\n  'slice': true,\n  'filter': true,\n  'map': true\n} // Default file-patterns we want to ignore\n,\n    DEFAULT_IGNORE_PATTERNS = [/(^|[\\/\\\\])CVS([\\/\\\\]|$)/, /(^|[\\/\\\\])\\.svn([\\/\\\\]|$)/, /(^|[\\/\\\\])\\.git([\\/\\\\]|$)/, /\\.bak$/, /~$/] // Ignore core files\n,\n    DEFAULT_IGNORE_FUNCS = [function (name) {\n  var isDir = false,\n      stats;\n\n  try {\n    stats = fs.statSync(name);\n    isDir = stats.isDirectory();\n  } catch (e) {}\n\n  return /(^|[\\/\\\\])core$/.test(name) && !isDir;\n}];\n\nvar FileList = function () {\n  var self = this,\n      wrap; // List of glob-patterns or specific filenames\n\n  this.pendingAdd = []; // Switched to false after lazy-eval of files\n\n  this.pending = true; // Used to calculate exclusions from the list of files\n\n  this.excludes = {\n    pats: DEFAULT_IGNORE_PATTERNS.slice(),\n    funcs: DEFAULT_IGNORE_FUNCS.slice(),\n    regex: null\n  };\n  this.items = []; // Wrap the array methods with the delegates\n\n  wrap = function (prop) {\n    var arr;\n\n    self[prop] = function () {\n      if (self.pending) {\n        self.resolve();\n      }\n\n      if (typeof self.items[prop] == 'function') {\n        // Special method that return a copy\n        if (SPECIAL_RETURN[prop]) {\n          arr = self.items[prop].apply(self.items, arguments);\n          return FileList.clone(self, arr);\n        } else {\n          return self.items[prop].apply(self.items, arguments);\n        }\n      } else {\n        return self.items[prop];\n      }\n    };\n  };\n\n  for (var i = 0, ii = ARRAY_METHODS.length; i < ii; i++) {\n    wrap(ARRAY_METHODS[i]);\n  } // Include whatever files got passed to the constructor\n\n\n  this.include.apply(this, arguments); // Fix constructor linkage\n\n  this.constructor = FileList;\n};\n\nFileList.prototype = new function () {\n  var globPattern = /[*?\\[\\{]/;\n\n  var _addMatching = function (item) {\n    var matches = globSync(item.path, item.options);\n    this.items = this.items.concat(matches);\n  },\n      _resolveAdd = function (item) {\n    if (globPattern.test(item.path)) {\n      _addMatching.call(this, item);\n    } else {\n      this.push(item.path);\n    }\n  },\n      _calculateExcludeRe = function () {\n    var pats = this.excludes.pats,\n        pat,\n        excl = [],\n        matches = [];\n\n    for (var i = 0, ii = pats.length; i < ii; i++) {\n      pat = pats[i];\n\n      if (typeof pat == 'string') {\n        // Glob, look up files\n        if (/[*?]/.test(pat)) {\n          matches = globSync(pat);\n          matches = matches.map(function (m) {\n            return escapeRegExpChars(m);\n          });\n          excl = excl.concat(matches);\n        } // String for regex\n        else {\n          excl.push(escapeRegExpChars(pat));\n        }\n      } // Regex, grab the string-representation\n      else if (pat instanceof RegExp) {\n        excl.push(pat.toString().replace(/^\\/|\\/$/g, ''));\n      }\n    }\n\n    if (excl.length) {\n      this.excludes.regex = new RegExp('(' + excl.join(')|(') + ')');\n    } else {\n      this.excludes.regex = /^$/;\n    }\n  },\n      _resolveExclude = function () {\n    var self = this;\n\n    _calculateExcludeRe.call(this); // No `reject` method, so use reverse-filter\n\n\n    this.items = this.items.filter(function (name) {\n      return !self.shouldExclude(name);\n    });\n  };\n  /**\n   * Includes file-patterns in the FileList. Should be called with one or more\n   * pattern for finding file to include in the list. Arguments should be strings\n   * for either a glob-pattern or a specific file-name, or an array of them\n   */\n\n\n  this.include = function () {\n    var args = Array.prototype.slice.call(arguments),\n        arg,\n        includes = {\n      items: [],\n      options: {}\n    };\n\n    for (var i = 0, ilen = args.length; i < ilen; i++) {\n      arg = args[i];\n\n      if (typeof arg === 'object' && !Array.isArray(arg)) {\n        merge(includes.options, arg);\n      } else {\n        includes.items = includes.items.concat(arg).filter(function (item) {\n          return !!item;\n        });\n      }\n    }\n\n    var items = includes.items.map(function (item) {\n      return {\n        path: item,\n        options: includes.options\n      };\n    });\n    this.pendingAdd = this.pendingAdd.concat(items);\n    return this;\n  };\n  /**\n   * Indicates whether a particular file would be filtered out by the current\n   * exclusion rules for this FileList.\n   * @param {String} name The filename to check\n   * @return {Boolean} Whether or not the file should be excluded\n   */\n\n\n  this.shouldExclude = function (name) {\n    if (!this.excludes.regex) {\n      _calculateExcludeRe.call(this);\n    }\n\n    var excl = this.excludes;\n    return excl.regex.test(name) || excl.funcs.some(function (f) {\n      return !!f(name);\n    });\n  };\n  /**\n   * Excludes file-patterns from the FileList. Should be called with one or more\n   * pattern for finding file to include in the list. Arguments can be:\n   * 1. Strings for either a glob-pattern or a specific file-name\n   * 2. Regular expression literals\n   * 3. Functions to be run on the filename that return a true/false\n   */\n\n\n  this.exclude = function () {\n    var args = Array.isArray(arguments[0]) ? arguments[0] : arguments,\n        arg;\n\n    for (var i = 0, ii = args.length; i < ii; i++) {\n      arg = args[i];\n\n      if (typeof arg == 'function' && !(arg instanceof RegExp)) {\n        this.excludes.funcs.push(arg);\n      } else {\n        this.excludes.pats.push(arg);\n      }\n    }\n\n    if (!this.pending) {\n      _resolveExclude.call(this);\n    }\n\n    return this;\n  };\n  /**\n   * Populates the FileList from the include/exclude rules with a list of\n   * actual files\n   */\n\n\n  this.resolve = function () {\n    var item,\n        uniqueFunc = function (p, c) {\n      if (p.indexOf(c) < 0) {\n        p.push(c);\n      }\n\n      return p;\n    };\n\n    if (this.pending) {\n      this.pending = false;\n\n      while (item = this.pendingAdd.shift()) {\n        _resolveAdd.call(this, item);\n      } // Reduce to a unique list\n\n\n      this.items = this.items.reduce(uniqueFunc, []); // Remove exclusions\n\n      _resolveExclude.call(this);\n    }\n\n    return this;\n  };\n  /**\n   * Convert to a plain-jane array\n   */\n\n\n  this.toArray = function () {\n    // Call slice to ensure lazy-resolution before slicing items\n    var ret = this.slice().items.slice();\n    return ret;\n  };\n  /**\n   * Clear any pending items -- only useful before\n   * calling `resolve`\n   */\n\n\n  this.clearInclusions = function () {\n    this.pendingAdd = [];\n    return this;\n  };\n  /**\n   * Clear any current exclusion rules\n   */\n\n\n  this.clearExclusions = function () {\n    this.excludes = {\n      pats: [],\n      funcs: [],\n      regex: null\n    };\n    return this;\n  };\n}(); // Static method, used to create copy returned by special\n// array methods\n\nFileList.clone = function (list, items) {\n  var clone = new FileList();\n\n  if (items) {\n    clone.items = items;\n  }\n\n  clone.pendingAdd = list.pendingAdd;\n  clone.pending = list.pending;\n\n  for (var p in list.excludes) {\n    clone.excludes[p] = list.excludes[p];\n  }\n\n  return clone;\n};\n\nFileList.verbose = true;\nexports.FileList = FileList;","map":{"version":3,"names":["fs","require","path","minimatch","escapeRegExpChars","merge","basedir","_readDir","readdirR","globSync","hasOwnProperty","Object","prototype","hasOwn","obj","key","apply","specials","sRE","RegExp","join","string","str","String","replace","object","otherObject","otherObj","value","Array","pathParam","bd","parts","part","pos","p","indexOf","test","slice","split","i","l","length","dirPath","dir","normalize","paths","ret","msg","readdirSync","e","stack","Error","forEach","curr","stat","statSync","isDirectory","concat","push","opts","options","format","pat","dirname","files","matches","map","file","FileList","verbose","console","error","message","match","ARRAY_METHODS","getOwnPropertyNames","SPECIAL_RETURN","DEFAULT_IGNORE_PATTERNS","DEFAULT_IGNORE_FUNCS","name","isDir","stats","self","wrap","pendingAdd","pending","excludes","pats","funcs","regex","items","prop","arr","resolve","arguments","clone","ii","include","constructor","globPattern","_addMatching","item","_resolveAdd","call","_calculateExcludeRe","excl","m","toString","_resolveExclude","filter","shouldExclude","args","arg","includes","ilen","isArray","some","f","exclude","uniqueFunc","c","shift","reduce","toArray","clearInclusions","clearExclusions","list","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/filelist/index.js"],"sourcesContent":["/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nvar fs = require('fs')\n, path = require('path')\n, minimatch = require('minimatch')\n, escapeRegExpChars\n, merge\n, basedir\n, _readDir\n, readdirR\n, globSync;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar hasOwn = function (obj, key) { return hasOwnProperty.apply(obj, [key]); };\n\n  /**\n    @name escapeRegExpChars\n    @function\n    @return {String} A string of escaped characters\n    @description Escapes regex control-characters in strings\n                 used to build regexes dynamically\n    @param {String} string The string of chars to escape\n  */\n  escapeRegExpChars = (function () {\n    var specials = [ '^', '$', '/', '.', '*', '+', '?', '|', '(', ')',\n        '[', ']', '{', '}', '\\\\' ];\n    var sRE = new RegExp('(\\\\' + specials.join('|\\\\') + ')', 'g');\n    return function (string) {\n      var str = string || '';\n      str = String(str);\n      return str.replace(sRE, '\\\\$1');\n    };\n  })();\n\n  /**\n    @name merge\n    @function\n    @return {Object} Returns the merged object\n    @description Merge merges `otherObject` into `object` and takes care of deep\n                 merging of objects\n    @param {Object} object Object to merge into\n    @param {Object} otherObject Object to read from\n  */\n  merge = function (object, otherObject) {\n    var obj = object || {}\n      , otherObj = otherObject || {}\n      , key, value;\n\n    for (key in otherObj) {\n\n      if (!hasOwn(otherObj, key)) {\n        continue;\n      }\n      if (key === '__proto__' || key === 'constructor') {\n        continue;\n      }\n\n      value = otherObj[key];\n      // Check if a value is an Object, if so recursively add it's key/values\n      if (typeof value === 'object' && !(value instanceof Array)) {\n        // Update value of object to the one from otherObj\n        obj[key] = merge(obj[key], value);\n      }\n      // Value is anything other than an Object, so just add it\n      else {\n        obj[key] = value;\n      }\n    }\n\n    return obj;\n  };\n  /**\n    Given a patern, return the base directory of it (ie. the folder\n    that will contain all the files matching the path).\n    eg. file.basedir('/test/**') => '/test/'\n    Path ending by '/' are considerd as folder while other are considerd\n    as files, eg.:\n        file.basedir('/test/a/') => '/test/a'\n        file.basedir('/test/a') => '/test'\n    The returned path always end with a '/' so we have:\n        file.basedir(file.basedir(x)) == file.basedir(x)\n  */\n  basedir = function (pathParam) {\n    var bd = ''\n      , parts\n      , part\n      , pos = 0\n      , p = pathParam || '';\n\n    // If the path has a leading asterisk, basedir is the current dir\n    if (p.indexOf('*') == 0 || p.indexOf('**') == 0) {\n      return '.';\n    }\n\n    // always consider .. at the end as a folder and not a filename\n    if (/(?:^|\\/|\\\\)\\.\\.$/.test(p.slice(-3))) {\n      p += '/';\n    }\n\n    parts = p.split(/\\\\|\\//);\n    for (var i = 0, l = parts.length - 1; i < l; i++) {\n      part = parts[i];\n      if (part.indexOf('*') > -1 || part.indexOf('**') > -1) {\n        break;\n      }\n      pos += part.length + 1;\n      bd += part + p[pos - 1];\n    }\n    if (!bd) {\n      bd = '.';\n    }\n    // Strip trailing slashes\n    if (!(bd == '\\\\' || bd == '/')) {\n      bd = bd.replace(/\\\\$|\\/$/, '');\n    }\n    return bd;\n\n  };\n\n  // Return the contents of a given directory\n  _readDir = function (dirPath) {\n    var dir = path.normalize(dirPath)\n      , paths = []\n      , ret = [dir]\n      , msg;\n\n    try {\n      paths = fs.readdirSync(dir);\n    }\n    catch (e) {\n      msg = 'Could not read path ' + dir + '\\n';\n      if (e.stack) {\n        msg += e.stack;\n      }\n      throw new Error(msg);\n    }\n\n    paths.forEach(function (p) {\n      var curr = path.join(dir, p);\n      var stat = fs.statSync(curr);\n      if (stat.isDirectory()) {\n        ret = ret.concat(_readDir(curr));\n      }\n      else {\n        ret.push(curr);\n      }\n    });\n\n    return ret;\n  };\n\n  /**\n    @name file#readdirR\n    @function\n    @return {Array} Returns the contents as an Array, can be configured via opts.format\n    @description Reads the given directory returning it's contents\n    @param {String} dir The directory to read\n    @param {Object} opts Options to use\n      @param {String} [opts.format] Set the format to return(Default: Array)\n  */\n  readdirR = function (dir, opts) {\n    var options = opts || {}\n      , format = options.format || 'array'\n      , ret;\n    ret = _readDir(dir);\n    return format == 'string' ? ret.join('\\n') : ret;\n  };\n\n\nglobSync = function (pat, opts) {\n  var dirname = basedir(pat)\n    , files\n    , matches;\n\n  try {\n    files = readdirR(dirname).map(function(file){\n      return file.replace(/\\\\/g, '/');\n    });\n  }\n  // Bail if path doesn't exist -- assume no files\n  catch(e) {\n    if (FileList.verbose) console.error(e.message);\n  }\n\n  if (files) {\n    pat = path.normalize(pat);\n    matches = minimatch.match(files, pat, opts || {});\n  }\n  return matches || [];\n};\n\n// Constants\n// ---------------\n// List of all the builtin Array methods we want to override\nvar ARRAY_METHODS = Object.getOwnPropertyNames(Array.prototype)\n// Array methods that return a copy instead of affecting the original\n  , SPECIAL_RETURN = {\n      'concat': true\n    , 'slice': true\n    , 'filter': true\n    , 'map': true\n    }\n// Default file-patterns we want to ignore\n  , DEFAULT_IGNORE_PATTERNS = [\n      /(^|[\\/\\\\])CVS([\\/\\\\]|$)/\n    , /(^|[\\/\\\\])\\.svn([\\/\\\\]|$)/\n    , /(^|[\\/\\\\])\\.git([\\/\\\\]|$)/\n    , /\\.bak$/\n    , /~$/\n    ]\n// Ignore core files\n  , DEFAULT_IGNORE_FUNCS = [\n      function (name) {\n        var isDir = false\n          , stats;\n        try {\n          stats = fs.statSync(name);\n          isDir = stats.isDirectory();\n        }\n        catch(e) {}\n        return (/(^|[\\/\\\\])core$/).test(name) && !isDir;\n      }\n    ];\n\nvar FileList = function () {\n  var self = this\n    , wrap;\n\n  // List of glob-patterns or specific filenames\n  this.pendingAdd = [];\n  // Switched to false after lazy-eval of files\n  this.pending = true;\n  // Used to calculate exclusions from the list of files\n  this.excludes = {\n    pats: DEFAULT_IGNORE_PATTERNS.slice()\n  , funcs: DEFAULT_IGNORE_FUNCS.slice()\n  , regex: null\n  };\n  this.items = [];\n\n  // Wrap the array methods with the delegates\n  wrap = function (prop) {\n    var arr;\n    self[prop] = function () {\n      if (self.pending) {\n        self.resolve();\n      }\n      if (typeof self.items[prop] == 'function') {\n        // Special method that return a copy\n        if (SPECIAL_RETURN[prop]) {\n          arr = self.items[prop].apply(self.items, arguments);\n          return FileList.clone(self, arr);\n        }\n        else {\n          return self.items[prop].apply(self.items, arguments);\n        }\n      }\n      else {\n        return self.items[prop];\n      }\n    };\n  };\n  for (var i = 0, ii = ARRAY_METHODS.length; i < ii; i++) {\n    wrap(ARRAY_METHODS[i]);\n  }\n\n  // Include whatever files got passed to the constructor\n  this.include.apply(this, arguments);\n\n  // Fix constructor linkage\n  this.constructor = FileList;\n};\n\nFileList.prototype = new (function () {\n  var globPattern = /[*?\\[\\{]/;\n\n  var _addMatching = function (item) {\n        var matches = globSync(item.path, item.options);\n        this.items = this.items.concat(matches);\n      }\n\n    , _resolveAdd = function (item) {\n        if (globPattern.test(item.path)) {\n          _addMatching.call(this, item);\n        }\n        else {\n          this.push(item.path);\n        }\n      }\n\n    , _calculateExcludeRe = function () {\n        var pats = this.excludes.pats\n          , pat\n          , excl = []\n          , matches = [];\n\n        for (var i = 0, ii = pats.length; i < ii; i++) {\n          pat = pats[i];\n          if (typeof pat == 'string') {\n            // Glob, look up files\n            if (/[*?]/.test(pat)) {\n              matches = globSync(pat);\n              matches = matches.map(function (m) {\n                return escapeRegExpChars(m);\n              });\n              excl = excl.concat(matches);\n            }\n            // String for regex\n            else {\n              excl.push(escapeRegExpChars(pat));\n            }\n          }\n          // Regex, grab the string-representation\n          else if (pat instanceof RegExp) {\n            excl.push(pat.toString().replace(/^\\/|\\/$/g, ''));\n          }\n        }\n        if (excl.length) {\n          this.excludes.regex = new RegExp('(' + excl.join(')|(') + ')');\n        }\n        else {\n          this.excludes.regex = /^$/;\n        }\n      }\n\n    , _resolveExclude = function () {\n        var self = this;\n        _calculateExcludeRe.call(this);\n        // No `reject` method, so use reverse-filter\n        this.items = this.items.filter(function (name) {\n          return !self.shouldExclude(name);\n        });\n      };\n\n  /**\n   * Includes file-patterns in the FileList. Should be called with one or more\n   * pattern for finding file to include in the list. Arguments should be strings\n   * for either a glob-pattern or a specific file-name, or an array of them\n   */\n  this.include = function () {\n    var args = Array.prototype.slice.call(arguments)\n        , arg\n        , includes = { items: [], options: {} };\n\n    for (var i = 0, ilen = args.length; i < ilen; i++) {\n      arg = args[i];\n\n      if (typeof arg === 'object' && !Array.isArray(arg)) {\n        merge(includes.options, arg);\n      } else {\n        includes.items = includes.items.concat(arg).filter(function (item) {\n          return !!item;\n        });\n      }\n    }\n\n    var items = includes.items.map(function(item) {\n      return { path: item, options: includes.options };\n    });\n\n    this.pendingAdd = this.pendingAdd.concat(items);\n\n    return this;\n  };\n\n  /**\n   * Indicates whether a particular file would be filtered out by the current\n   * exclusion rules for this FileList.\n   * @param {String} name The filename to check\n   * @return {Boolean} Whether or not the file should be excluded\n   */\n  this.shouldExclude = function (name) {\n    if (!this.excludes.regex) {\n      _calculateExcludeRe.call(this);\n    }\n    var excl = this.excludes;\n    return excl.regex.test(name) || excl.funcs.some(function (f) {\n      return !!f(name);\n    });\n  };\n\n  /**\n   * Excludes file-patterns from the FileList. Should be called with one or more\n   * pattern for finding file to include in the list. Arguments can be:\n   * 1. Strings for either a glob-pattern or a specific file-name\n   * 2. Regular expression literals\n   * 3. Functions to be run on the filename that return a true/false\n   */\n  this.exclude = function () {\n    var args = Array.isArray(arguments[0]) ? arguments[0] : arguments\n      , arg;\n    for (var i = 0, ii = args.length; i < ii; i++) {\n      arg = args[i];\n      if (typeof arg == 'function' && !(arg instanceof RegExp)) {\n        this.excludes.funcs.push(arg);\n      }\n      else {\n        this.excludes.pats.push(arg);\n      }\n    }\n    if (!this.pending) {\n      _resolveExclude.call(this);\n    }\n    return this;\n  };\n\n  /**\n   * Populates the FileList from the include/exclude rules with a list of\n   * actual files\n   */\n  this.resolve = function () {\n    var item\n      , uniqueFunc = function (p, c) {\n          if (p.indexOf(c) < 0) {\n            p.push(c);\n          }\n          return p;\n        };\n    if (this.pending) {\n      this.pending = false;\n      while ((item = this.pendingAdd.shift())) {\n        _resolveAdd.call(this, item);\n      }\n      // Reduce to a unique list\n      this.items = this.items.reduce(uniqueFunc, []);\n      // Remove exclusions\n      _resolveExclude.call(this);\n    }\n    return this;\n  };\n\n  /**\n   * Convert to a plain-jane array\n   */\n  this.toArray = function () {\n    // Call slice to ensure lazy-resolution before slicing items\n    var ret = this.slice().items.slice();\n    return ret;\n  };\n\n  /**\n   * Clear any pending items -- only useful before\n   * calling `resolve`\n   */\n  this.clearInclusions = function () {\n    this.pendingAdd = [];\n    return this;\n  };\n\n  /**\n   * Clear any current exclusion rules\n   */\n  this.clearExclusions = function () {\n    this.excludes = {\n      pats: []\n    , funcs: []\n    , regex: null\n    };\n    return this;\n  };\n\n})();\n\n// Static method, used to create copy returned by special\n// array methods\nFileList.clone = function (list, items) {\n  var clone = new FileList();\n  if (items) {\n    clone.items = items;\n  }\n  clone.pendingAdd = list.pendingAdd;\n  clone.pending = list.pending;\n  for (var p in list.excludes) {\n    clone.excludes[p] = list.excludes[p];\n  }\n  return clone;\n};\n\nFileList.verbose = true\n\nexports.FileList = FileList;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}