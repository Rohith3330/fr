{"ast":null,"code":"/**\n * @fileoverview Prevent missing props validation in a React component definition\n * @author Yannick Croissant\n */\n'use strict'; // As for exceptions for props.children or props.className (and alike) look at\n// https://github.com/jsx-eslint/eslint-plugin-react/issues/7\n\nconst Components = require('../util/Components');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst messages = {\n  missingPropType: '\\'{{name}}\\' is missing in props validation'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow missing props validation in a React component definition',\n      category: 'Best Practices',\n      recommended: true,\n      url: docsUrl('prop-types')\n    },\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        ignore: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n        customValidators: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n        skipUndeclared: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  create: Components.detect((context, components) => {\n    const configuration = context.options[0] || {};\n    const ignored = configuration.ignore || [];\n    const skipUndeclared = configuration.skipUndeclared || false;\n    /**\n     * Checks if the prop is ignored\n     * @param {String} name Name of the prop to check.\n     * @returns {Boolean} True if the prop is ignored, false if not.\n     */\n\n    function isIgnored(name) {\n      return ignored.indexOf(name) !== -1;\n    }\n    /**\n     * Checks if the component must be validated\n     * @param {Object} component The component to process\n     * @returns {Boolean} True if the component must be validated, false if not.\n     */\n\n\n    function mustBeValidated(component) {\n      const isSkippedByConfig = skipUndeclared && typeof component.declaredPropTypes === 'undefined';\n      return Boolean(component && component.usedPropTypes && !component.ignorePropsValidation && !isSkippedByConfig);\n    }\n    /**\n     * Internal: Checks if the prop is declared\n     * @param {Object} declaredPropTypes Description of propTypes declared in the current component\n     * @param {String[]} keyList Dot separated name of the prop to check.\n     * @returns {Boolean} True if the prop is declared, false if not.\n     */\n\n\n    function internalIsDeclaredInComponent(declaredPropTypes, keyList) {\n      for (let i = 0, j = keyList.length; i < j; i++) {\n        const key = keyList[i];\n        const propType = declaredPropTypes && ( // Check if this key is declared\n        declaredPropTypes[key] // If not, check if this type accepts any key\n        || declaredPropTypes.__ANY_KEY__ // eslint-disable-line no-underscore-dangle\n        );\n\n        if (!propType) {\n          // If it's a computed property, we can't make any further analysis, but is valid\n          return key === '__COMPUTED_PROP__';\n        }\n\n        if (typeof propType === 'object' && !propType.type) {\n          return true;\n        } // Consider every children as declared\n\n\n        if (propType.children === true || propType.containsUnresolvedSpread || propType.containsIndexers) {\n          return true;\n        }\n\n        if (propType.acceptedProperties) {\n          return key in propType.acceptedProperties;\n        }\n\n        if (propType.type === 'union') {\n          // If we fall in this case, we know there is at least one complex type in the union\n          if (i + 1 >= j) {\n            // this is the last key, accept everything\n            return true;\n          } // non trivial, check all of them\n\n\n          const unionTypes = propType.children;\n          const unionPropType = {};\n\n          for (let k = 0, z = unionTypes.length; k < z; k++) {\n            unionPropType[key] = unionTypes[k];\n            const isValid = internalIsDeclaredInComponent(unionPropType, keyList.slice(i));\n\n            if (isValid) {\n              return true;\n            }\n          } // every possible union were invalid\n\n\n          return false;\n        }\n\n        declaredPropTypes = propType.children;\n      }\n\n      return true;\n    }\n    /**\n     * Checks if the prop is declared\n     * @param {ASTNode} node The AST node being checked.\n     * @param {String[]} names List of names of the prop to check.\n     * @returns {Boolean} True if the prop is declared, false if not.\n     */\n\n\n    function isDeclaredInComponent(node, names) {\n      while (node) {\n        const component = components.get(node);\n        const isDeclared = component && component.confidence === 2 && internalIsDeclaredInComponent(component.declaredPropTypes || {}, names);\n\n        if (isDeclared) {\n          return true;\n        }\n\n        node = node.parent;\n      }\n\n      return false;\n    }\n    /**\n     * Reports undeclared proptypes for a given component\n     * @param {Object} component The component to process\n     */\n\n\n    function reportUndeclaredPropTypes(component) {\n      const undeclareds = component.usedPropTypes.filter(propType => propType.node && !isIgnored(propType.allNames[0]) && !isDeclaredInComponent(component.node, propType.allNames));\n      undeclareds.forEach(propType => {\n        report(context, messages.missingPropType, 'missingPropType', {\n          node: propType.node,\n          data: {\n            name: propType.allNames.join('.').replace(/\\.__COMPUTED_PROP__/g, '[]')\n          }\n        });\n      });\n    }\n\n    return {\n      'Program:exit'() {\n        const list = components.list(); // Report undeclared proptypes for all classes\n\n        Object.keys(list).filter(component => mustBeValidated(list[component])).forEach(component => {\n          reportUndeclaredPropTypes(list[component]);\n        });\n      }\n\n    };\n  })\n};","map":{"version":3,"names":["Components","require","docsUrl","report","messages","missingPropType","module","exports","meta","docs","description","category","recommended","url","schema","type","properties","ignore","items","customValidators","skipUndeclared","additionalProperties","create","detect","context","components","configuration","options","ignored","isIgnored","name","indexOf","mustBeValidated","component","isSkippedByConfig","declaredPropTypes","Boolean","usedPropTypes","ignorePropsValidation","internalIsDeclaredInComponent","keyList","i","j","length","key","propType","__ANY_KEY__","children","containsUnresolvedSpread","containsIndexers","acceptedProperties","unionTypes","unionPropType","k","z","isValid","slice","isDeclaredInComponent","node","names","get","isDeclared","confidence","parent","reportUndeclaredPropTypes","undeclareds","filter","allNames","forEach","data","join","replace","list","Object","keys"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/prop-types.js"],"sourcesContent":["/**\n * @fileoverview Prevent missing props validation in a React component definition\n * @author Yannick Croissant\n */\n\n'use strict';\n\n// As for exceptions for props.children or props.className (and alike) look at\n// https://github.com/jsx-eslint/eslint-plugin-react/issues/7\n\nconst Components = require('../util/Components');\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  missingPropType: '\\'{{name}}\\' is missing in props validation',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow missing props validation in a React component definition',\n      category: 'Best Practices',\n      recommended: true,\n      url: docsUrl('prop-types'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        ignore: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n        },\n        customValidators: {\n          type: 'array',\n          items: {\n            type: 'string',\n          },\n        },\n        skipUndeclared: {\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create: Components.detect((context, components) => {\n    const configuration = context.options[0] || {};\n    const ignored = configuration.ignore || [];\n    const skipUndeclared = configuration.skipUndeclared || false;\n\n    /**\n     * Checks if the prop is ignored\n     * @param {String} name Name of the prop to check.\n     * @returns {Boolean} True if the prop is ignored, false if not.\n     */\n    function isIgnored(name) {\n      return ignored.indexOf(name) !== -1;\n    }\n\n    /**\n     * Checks if the component must be validated\n     * @param {Object} component The component to process\n     * @returns {Boolean} True if the component must be validated, false if not.\n     */\n    function mustBeValidated(component) {\n      const isSkippedByConfig = skipUndeclared && typeof component.declaredPropTypes === 'undefined';\n      return Boolean(\n        component\n        && component.usedPropTypes\n        && !component.ignorePropsValidation\n        && !isSkippedByConfig\n      );\n    }\n\n    /**\n     * Internal: Checks if the prop is declared\n     * @param {Object} declaredPropTypes Description of propTypes declared in the current component\n     * @param {String[]} keyList Dot separated name of the prop to check.\n     * @returns {Boolean} True if the prop is declared, false if not.\n     */\n    function internalIsDeclaredInComponent(declaredPropTypes, keyList) {\n      for (let i = 0, j = keyList.length; i < j; i++) {\n        const key = keyList[i];\n        const propType = (\n          declaredPropTypes && (\n            // Check if this key is declared\n            (declaredPropTypes[key] // If not, check if this type accepts any key\n            || declaredPropTypes.__ANY_KEY__) // eslint-disable-line no-underscore-dangle\n          )\n        );\n\n        if (!propType) {\n          // If it's a computed property, we can't make any further analysis, but is valid\n          return key === '__COMPUTED_PROP__';\n        }\n        if (typeof propType === 'object' && !propType.type) {\n          return true;\n        }\n        // Consider every children as declared\n        if (propType.children === true || propType.containsUnresolvedSpread || propType.containsIndexers) {\n          return true;\n        }\n        if (propType.acceptedProperties) {\n          return key in propType.acceptedProperties;\n        }\n        if (propType.type === 'union') {\n          // If we fall in this case, we know there is at least one complex type in the union\n          if (i + 1 >= j) {\n            // this is the last key, accept everything\n            return true;\n          }\n          // non trivial, check all of them\n          const unionTypes = propType.children;\n          const unionPropType = {};\n          for (let k = 0, z = unionTypes.length; k < z; k++) {\n            unionPropType[key] = unionTypes[k];\n            const isValid = internalIsDeclaredInComponent(\n              unionPropType,\n              keyList.slice(i)\n            );\n            if (isValid) {\n              return true;\n            }\n          }\n\n          // every possible union were invalid\n          return false;\n        }\n        declaredPropTypes = propType.children;\n      }\n      return true;\n    }\n\n    /**\n     * Checks if the prop is declared\n     * @param {ASTNode} node The AST node being checked.\n     * @param {String[]} names List of names of the prop to check.\n     * @returns {Boolean} True if the prop is declared, false if not.\n     */\n    function isDeclaredInComponent(node, names) {\n      while (node) {\n        const component = components.get(node);\n\n        const isDeclared = component && component.confidence === 2\n          && internalIsDeclaredInComponent(component.declaredPropTypes || {}, names);\n\n        if (isDeclared) {\n          return true;\n        }\n\n        node = node.parent;\n      }\n      return false;\n    }\n\n    /**\n     * Reports undeclared proptypes for a given component\n     * @param {Object} component The component to process\n     */\n    function reportUndeclaredPropTypes(component) {\n      const undeclareds = component.usedPropTypes.filter((propType) => (\n        propType.node\n        && !isIgnored(propType.allNames[0])\n        && !isDeclaredInComponent(component.node, propType.allNames)\n      ));\n      undeclareds.forEach((propType) => {\n        report(context, messages.missingPropType, 'missingPropType', {\n          node: propType.node,\n          data: {\n            name: propType.allNames.join('.').replace(/\\.__COMPUTED_PROP__/g, '[]'),\n          },\n        });\n      });\n    }\n\n    return {\n      'Program:exit'() {\n        const list = components.list();\n        // Report undeclared proptypes for all classes\n        Object.keys(list).filter((component) => mustBeValidated(list[component])).forEach((component) => {\n          reportUndeclaredPropTypes(list[component]);\n        });\n      },\n    };\n  }),\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}