{"ast":null,"code":"/**\n * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.\n * @author Annie Zhang, Pavel Strashkin\n */\n\"use strict\"; //--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst esutils = require(\"esutils\"); //--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines if a pattern is `module.exports` or `module[\"exports\"]`\n * @param {ASTNode} pattern The left side of the AssignmentExpression\n * @returns {boolean} True if the pattern is `module.exports` or `module[\"exports\"]`\n */\n\n\nfunction isModuleExports(pattern) {\n  if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\n    // module.exports\n    if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\n      return true;\n    } // module[\"exports\"]\n\n\n    if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Determines if a string name is a valid identifier\n * @param {string} name The string to be checked\n * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config\n * @returns {boolean} True if the string is a valid identifier\n */\n\n\nfunction isIdentifier(name, ecmaVersion) {\n  if (ecmaVersion >= 6) {\n    return esutils.keyword.isIdentifierES6(name);\n  }\n\n  return esutils.keyword.isIdentifierES5(name);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst alwaysOrNever = {\n  enum: [\"always\", \"never\"]\n};\nconst optionsObject = {\n  type: \"object\",\n  properties: {\n    considerPropertyDescriptor: {\n      type: \"boolean\"\n    },\n    includeCommonJSModuleExports: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Require function names to match the name of the variable or property to which they are assigned\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/func-name-matching\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        additionalItems: false,\n        items: [alwaysOrNever, optionsObject]\n      }, {\n        type: \"array\",\n        additionalItems: false,\n        items: [optionsObject]\n      }]\n    },\n    messages: {\n      matchProperty: \"Function name `{{funcName}}` should match property name `{{name}}`.\",\n      matchVariable: \"Function name `{{funcName}}` should match variable name `{{name}}`.\",\n      notMatchProperty: \"Function name `{{funcName}}` should not match property name `{{name}}`.\",\n      notMatchVariable: \"Function name `{{funcName}}` should not match variable name `{{name}}`.\"\n    }\n  },\n\n  create(context) {\n    const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\n    const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n    const considerPropertyDescriptor = options.considerPropertyDescriptor;\n    const includeModuleExports = options.includeCommonJSModuleExports;\n    const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;\n    /**\n     * Check whether node is a certain CallExpression.\n     * @param {string} objName object name\n     * @param {string} funcName function name\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} `true` if node matches CallExpression\n     */\n\n    function isPropertyCall(objName, funcName, node) {\n      if (!node) {\n        return false;\n      }\n\n      return node.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(node.callee, objName, funcName);\n    }\n    /**\n     * Compares identifiers based on the nameMatches option\n     * @param {string} x the first identifier\n     * @param {string} y the second identifier\n     * @returns {boolean} whether the two identifiers should warn.\n     */\n\n\n    function shouldWarn(x, y) {\n      return nameMatches === \"always\" && x !== y || nameMatches === \"never\" && x === y;\n    }\n    /**\n     * Reports\n     * @param {ASTNode} node The node to report\n     * @param {string} name The variable or property name\n     * @param {string} funcName The function name\n     * @param {boolean} isProp True if the reported node is a property assignment\n     * @returns {void}\n     */\n\n\n    function report(node, name, funcName, isProp) {\n      let messageId;\n\n      if (nameMatches === \"always\" && isProp) {\n        messageId = \"matchProperty\";\n      } else if (nameMatches === \"always\") {\n        messageId = \"matchVariable\";\n      } else if (isProp) {\n        messageId = \"notMatchProperty\";\n      } else {\n        messageId = \"notMatchVariable\";\n      }\n\n      context.report({\n        node,\n        messageId,\n        data: {\n          name,\n          funcName\n        }\n      });\n    }\n    /**\n     * Determines whether a given node is a string literal\n     * @param {ASTNode} node The node to check\n     * @returns {boolean} `true` if the node is a string literal\n     */\n\n\n    function isStringLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"string\";\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      VariableDeclarator(node) {\n        if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\n          return;\n        }\n\n        if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\n          report(node, node.id.name, node.init.id.name, false);\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (node.right.type !== \"FunctionExpression\" || node.left.computed && node.left.property.type !== \"Literal\" || !includeModuleExports && isModuleExports(node.left) || node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\") {\n          return;\n        }\n\n        const isProp = node.left.type === \"MemberExpression\";\n        const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\n\n        if (node.right.id && name && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\n          report(node, name, node.right.id.name, isProp);\n        }\n      },\n\n      \"Property, PropertyDefinition[value]\"(node) {\n        if (!(node.value.type === \"FunctionExpression\" && node.value.id)) {\n          return;\n        }\n\n        if (node.key.type === \"Identifier\" && !node.computed) {\n          const functionName = node.value.id.name;\n          let propertyName = node.key.name;\n\n          if (considerPropertyDescriptor && propertyName === \"value\" && node.parent.type === \"ObjectExpression\") {\n            if (isPropertyCall(\"Object\", \"defineProperty\", node.parent.parent) || isPropertyCall(\"Reflect\", \"defineProperty\", node.parent.parent)) {\n              const property = node.parent.parent.arguments[1];\n\n              if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {\n                report(node, property.value, functionName, true);\n              }\n            } else if (isPropertyCall(\"Object\", \"defineProperties\", node.parent.parent.parent.parent)) {\n              propertyName = node.parent.parent.key.name;\n\n              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                report(node, propertyName, functionName, true);\n              }\n            } else if (isPropertyCall(\"Object\", \"create\", node.parent.parent.parent.parent)) {\n              propertyName = node.parent.parent.key.name;\n\n              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                report(node, propertyName, functionName, true);\n              }\n            } else if (shouldWarn(propertyName, functionName)) {\n              report(node, propertyName, functionName, true);\n            }\n          } else if (shouldWarn(propertyName, functionName)) {\n            report(node, propertyName, functionName, true);\n          }\n\n          return;\n        }\n\n        if (isStringLiteral(node.key) && isIdentifier(node.key.value, ecmaVersion) && shouldWarn(node.key.value, node.value.id.name)) {\n          report(node, node.key.value, node.value.id.name, true);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","esutils","isModuleExports","pattern","type","object","name","property","value","isIdentifier","ecmaVersion","keyword","isIdentifierES6","isIdentifierES5","alwaysOrNever","enum","optionsObject","properties","considerPropertyDescriptor","includeCommonJSModuleExports","additionalProperties","module","exports","meta","docs","description","recommended","url","schema","anyOf","additionalItems","items","messages","matchProperty","matchVariable","notMatchProperty","notMatchVariable","create","context","options","nameMatches","includeModuleExports","parserOptions","isPropertyCall","objName","funcName","node","isSpecificMemberAccess","callee","shouldWarn","x","y","report","isProp","messageId","data","isStringLiteral","VariableDeclarator","init","id","AssignmentExpression","right","left","computed","getStaticPropertyName","key","functionName","propertyName","parent","arguments"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/func-name-matching.js"],"sourcesContent":["/**\n * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.\n * @author Annie Zhang, Pavel Strashkin\n */\n\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\nconst esutils = require(\"esutils\");\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines if a pattern is `module.exports` or `module[\"exports\"]`\n * @param {ASTNode} pattern The left side of the AssignmentExpression\n * @returns {boolean} True if the pattern is `module.exports` or `module[\"exports\"]`\n */\nfunction isModuleExports(pattern) {\n    if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\n\n        // module.exports\n        if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\n            return true;\n        }\n\n        // module[\"exports\"]\n        if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Determines if a string name is a valid identifier\n * @param {string} name The string to be checked\n * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config\n * @returns {boolean} True if the string is a valid identifier\n */\nfunction isIdentifier(name, ecmaVersion) {\n    if (ecmaVersion >= 6) {\n        return esutils.keyword.isIdentifierES6(name);\n    }\n    return esutils.keyword.isIdentifierES5(name);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst alwaysOrNever = { enum: [\"always\", \"never\"] };\nconst optionsObject = {\n    type: \"object\",\n    properties: {\n        considerPropertyDescriptor: {\n            type: \"boolean\"\n        },\n        includeCommonJSModuleExports: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require function names to match the name of the variable or property to which they are assigned\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/func-name-matching\"\n        },\n\n        schema: {\n            anyOf: [{\n                type: \"array\",\n                additionalItems: false,\n                items: [alwaysOrNever, optionsObject]\n            }, {\n                type: \"array\",\n                additionalItems: false,\n                items: [optionsObject]\n            }]\n        },\n\n        messages: {\n            matchProperty: \"Function name `{{funcName}}` should match property name `{{name}}`.\",\n            matchVariable: \"Function name `{{funcName}}` should match variable name `{{name}}`.\",\n            notMatchProperty: \"Function name `{{funcName}}` should not match property name `{{name}}`.\",\n            notMatchVariable: \"Function name `{{funcName}}` should not match variable name `{{name}}`.\"\n        }\n    },\n\n    create(context) {\n        const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\n        const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n        const considerPropertyDescriptor = options.considerPropertyDescriptor;\n        const includeModuleExports = options.includeCommonJSModuleExports;\n        const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;\n\n        /**\n         * Check whether node is a certain CallExpression.\n         * @param {string} objName object name\n         * @param {string} funcName function name\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if node matches CallExpression\n         */\n        function isPropertyCall(objName, funcName, node) {\n            if (!node) {\n                return false;\n            }\n            return node.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(node.callee, objName, funcName);\n        }\n\n        /**\n         * Compares identifiers based on the nameMatches option\n         * @param {string} x the first identifier\n         * @param {string} y the second identifier\n         * @returns {boolean} whether the two identifiers should warn.\n         */\n        function shouldWarn(x, y) {\n            return (nameMatches === \"always\" && x !== y) || (nameMatches === \"never\" && x === y);\n        }\n\n        /**\n         * Reports\n         * @param {ASTNode} node The node to report\n         * @param {string} name The variable or property name\n         * @param {string} funcName The function name\n         * @param {boolean} isProp True if the reported node is a property assignment\n         * @returns {void}\n         */\n        function report(node, name, funcName, isProp) {\n            let messageId;\n\n            if (nameMatches === \"always\" && isProp) {\n                messageId = \"matchProperty\";\n            } else if (nameMatches === \"always\") {\n                messageId = \"matchVariable\";\n            } else if (isProp) {\n                messageId = \"notMatchProperty\";\n            } else {\n                messageId = \"notMatchVariable\";\n            }\n            context.report({\n                node,\n                messageId,\n                data: {\n                    name,\n                    funcName\n                }\n            });\n        }\n\n        /**\n         * Determines whether a given node is a string literal\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} `true` if the node is a string literal\n         */\n        function isStringLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"string\";\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclarator(node) {\n                if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\n                    return;\n                }\n                if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\n                    report(node, node.id.name, node.init.id.name, false);\n                }\n            },\n\n            AssignmentExpression(node) {\n                if (\n                    node.right.type !== \"FunctionExpression\" ||\n                    (node.left.computed && node.left.property.type !== \"Literal\") ||\n                    (!includeModuleExports && isModuleExports(node.left)) ||\n                    (node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\")\n                ) {\n                    return;\n                }\n\n                const isProp = node.left.type === \"MemberExpression\";\n                const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\n\n                if (node.right.id && name && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\n                    report(node, name, node.right.id.name, isProp);\n                }\n            },\n\n            \"Property, PropertyDefinition[value]\"(node) {\n                if (!(node.value.type === \"FunctionExpression\" && node.value.id)) {\n                    return;\n                }\n\n                if (node.key.type === \"Identifier\" && !node.computed) {\n                    const functionName = node.value.id.name;\n                    let propertyName = node.key.name;\n\n                    if (\n                        considerPropertyDescriptor &&\n                        propertyName === \"value\" &&\n                        node.parent.type === \"ObjectExpression\"\n                    ) {\n                        if (isPropertyCall(\"Object\", \"defineProperty\", node.parent.parent) || isPropertyCall(\"Reflect\", \"defineProperty\", node.parent.parent)) {\n                            const property = node.parent.parent.arguments[1];\n\n                            if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {\n                                report(node, property.value, functionName, true);\n                            }\n                        } else if (isPropertyCall(\"Object\", \"defineProperties\", node.parent.parent.parent.parent)) {\n                            propertyName = node.parent.parent.key.name;\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                                report(node, propertyName, functionName, true);\n                            }\n                        } else if (isPropertyCall(\"Object\", \"create\", node.parent.parent.parent.parent)) {\n                            propertyName = node.parent.parent.key.name;\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                                report(node, propertyName, functionName, true);\n                            }\n                        } else if (shouldWarn(propertyName, functionName)) {\n                            report(node, propertyName, functionName, true);\n                        }\n                    } else if (shouldWarn(propertyName, functionName)) {\n                        report(node, propertyName, functionName, true);\n                    }\n                    return;\n                }\n\n                if (\n                    isStringLiteral(node.key) &&\n                    isIdentifier(node.key.value, ecmaVersion) &&\n                    shouldWarn(node.key.value, node.value.id.name)\n                ) {\n                    report(node, node.key.value, node.value.id.name, true);\n                }\n            }\n        };\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}