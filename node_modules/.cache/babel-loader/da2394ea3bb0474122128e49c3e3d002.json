{"ast":null,"code":"var OffsetToLocation = require('../common/OffsetToLocation');\n\nvar SyntaxError = require('../common/SyntaxError');\n\nvar TokenStream = require('../common/TokenStream');\n\nvar List = require('../common/List');\n\nvar tokenize = require('../tokenizer');\n\nvar constants = require('../tokenizer/const');\n\nvar {\n  findWhiteSpaceStart,\n  cmpStr\n} = require('../tokenizer/utils');\n\nvar sequence = require('./sequence');\n\nvar noop = function () {};\n\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar IDENT = TYPE.Ident;\nvar FUNCTION = TYPE.Function;\nvar URL = TYPE.Url;\nvar HASH = TYPE.Hash;\nvar PERCENTAGE = TYPE.Percentage;\nvar NUMBER = TYPE.Number;\nvar NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)\n\nvar NULL = 0;\n\nfunction createParseContext(name) {\n  return function () {\n    return this[name]();\n  };\n}\n\nfunction processConfig(config) {\n  var parserConfig = {\n    context: {},\n    scope: {},\n    atrule: {},\n    pseudo: {}\n  };\n\n  if (config.parseContext) {\n    for (var name in config.parseContext) {\n      switch (typeof config.parseContext[name]) {\n        case 'function':\n          parserConfig.context[name] = config.parseContext[name];\n          break;\n\n        case 'string':\n          parserConfig.context[name] = createParseContext(config.parseContext[name]);\n          break;\n      }\n    }\n  }\n\n  if (config.scope) {\n    for (var name in config.scope) {\n      parserConfig.scope[name] = config.scope[name];\n    }\n  }\n\n  if (config.atrule) {\n    for (var name in config.atrule) {\n      var atrule = config.atrule[name];\n\n      if (atrule.parse) {\n        parserConfig.atrule[name] = atrule.parse;\n      }\n    }\n  }\n\n  if (config.pseudo) {\n    for (var name in config.pseudo) {\n      var pseudo = config.pseudo[name];\n\n      if (pseudo.parse) {\n        parserConfig.pseudo[name] = pseudo.parse;\n      }\n    }\n  }\n\n  if (config.node) {\n    for (var name in config.node) {\n      parserConfig[name] = config.node[name].parse;\n    }\n  }\n\n  return parserConfig;\n}\n\nmodule.exports = function createParser(config) {\n  var parser = {\n    scanner: new TokenStream(),\n    locationMap: new OffsetToLocation(),\n    filename: '<unknown>',\n    needPositions: false,\n    onParseError: noop,\n    onParseErrorThrow: false,\n    parseAtrulePrelude: true,\n    parseRulePrelude: true,\n    parseValue: true,\n    parseCustomProperty: false,\n    readSequence: sequence,\n    createList: function () {\n      return new List();\n    },\n    createSingleNodeList: function (node) {\n      return new List().appendData(node);\n    },\n    getFirstListNode: function (list) {\n      return list && list.first();\n    },\n    getLastListNode: function (list) {\n      return list.last();\n    },\n    parseWithFallback: function (consumer, fallback) {\n      var startToken = this.scanner.tokenIndex;\n\n      try {\n        return consumer.call(this);\n      } catch (e) {\n        if (this.onParseErrorThrow) {\n          throw e;\n        }\n\n        var fallbackNode = fallback.call(this, startToken);\n        this.onParseErrorThrow = true;\n        this.onParseError(e, fallbackNode);\n        this.onParseErrorThrow = false;\n        return fallbackNode;\n      }\n    },\n    lookupNonWSType: function (offset) {\n      do {\n        var type = this.scanner.lookupType(offset++);\n\n        if (type !== WHITESPACE) {\n          return type;\n        }\n      } while (type !== NULL);\n\n      return NULL;\n    },\n    eat: function (tokenType) {\n      if (this.scanner.tokenType !== tokenType) {\n        var offset = this.scanner.tokenStart;\n        var message = NAME[tokenType] + ' is expected'; // tweak message and offset\n\n        switch (tokenType) {\n          case IDENT:\n            // when identifier is expected but there is a function or url\n            if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {\n              offset = this.scanner.tokenEnd - 1;\n              message = 'Identifier is expected but function found';\n            } else {\n              message = 'Identifier is expected';\n            }\n\n            break;\n\n          case HASH:\n            if (this.scanner.isDelim(NUMBERSIGN)) {\n              this.scanner.next();\n              offset++;\n              message = 'Name is expected';\n            }\n\n            break;\n\n          case PERCENTAGE:\n            if (this.scanner.tokenType === NUMBER) {\n              offset = this.scanner.tokenEnd;\n              message = 'Percent sign is expected';\n            }\n\n            break;\n\n          default:\n            // when test type is part of another token show error for current position + 1\n            // e.g. eat(HYPHENMINUS) will fail on \"-foo\", but pointing on \"-\" is odd\n            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {\n              offset = offset + 1;\n            }\n\n        }\n\n        this.error(message, offset);\n      }\n\n      this.scanner.next();\n    },\n    consume: function (tokenType) {\n      var value = this.scanner.getTokenValue();\n      this.eat(tokenType);\n      return value;\n    },\n    consumeFunctionName: function () {\n      var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);\n      this.eat(FUNCTION);\n      return name;\n    },\n    getLocation: function (start, end) {\n      if (this.needPositions) {\n        return this.locationMap.getLocationRange(start, end, this.filename);\n      }\n\n      return null;\n    },\n    getLocationFromList: function (list) {\n      if (this.needPositions) {\n        var head = this.getFirstListNode(list);\n        var tail = this.getLastListNode(list);\n        return this.locationMap.getLocationRange(head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart, tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart, this.filename);\n      }\n\n      return null;\n    },\n    error: function (message, offset) {\n      var location = typeof offset !== 'undefined' && offset < this.scanner.source.length ? this.locationMap.getLocation(offset) : this.scanner.eof ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1)) : this.locationMap.getLocation(this.scanner.tokenStart);\n      throw new SyntaxError(message || 'Unexpected input', this.scanner.source, location.offset, location.line, location.column);\n    }\n  };\n  config = processConfig(config || {});\n\n  for (var key in config) {\n    parser[key] = config[key];\n  }\n\n  return function (source, options) {\n    options = options || {};\n    var context = options.context || 'default';\n    var onComment = options.onComment;\n    var ast;\n    tokenize(source, parser.scanner);\n    parser.locationMap.setSource(source, options.offset, options.line, options.column);\n    parser.filename = options.filename || '<unknown>';\n    parser.needPositions = Boolean(options.positions);\n    parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;\n    parser.onParseErrorThrow = false;\n    parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;\n    parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;\n    parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n    parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n\n    if (!parser.context.hasOwnProperty(context)) {\n      throw new Error('Unknown context `' + context + '`');\n    }\n\n    if (typeof onComment === 'function') {\n      parser.scanner.forEachToken((type, start, end) => {\n        if (type === COMMENT) {\n          const loc = parser.getLocation(start, end);\n          const value = cmpStr(source, end - 2, end, '*/') ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);\n          onComment(value, loc);\n        }\n      });\n    }\n\n    ast = parser.context[context].call(parser, options);\n\n    if (!parser.scanner.eof) {\n      parser.error();\n    }\n\n    return ast;\n  };\n};","map":{"version":3,"names":["OffsetToLocation","require","SyntaxError","TokenStream","List","tokenize","constants","findWhiteSpaceStart","cmpStr","sequence","noop","TYPE","NAME","WHITESPACE","WhiteSpace","COMMENT","Comment","IDENT","Ident","FUNCTION","Function","URL","Url","HASH","Hash","PERCENTAGE","Percentage","NUMBER","Number","NUMBERSIGN","NULL","createParseContext","name","processConfig","config","parserConfig","context","scope","atrule","pseudo","parseContext","parse","node","module","exports","createParser","parser","scanner","locationMap","filename","needPositions","onParseError","onParseErrorThrow","parseAtrulePrelude","parseRulePrelude","parseValue","parseCustomProperty","readSequence","createList","createSingleNodeList","appendData","getFirstListNode","list","first","getLastListNode","last","parseWithFallback","consumer","fallback","startToken","tokenIndex","call","e","fallbackNode","lookupNonWSType","offset","type","lookupType","eat","tokenType","tokenStart","message","tokenEnd","isDelim","next","source","charCodeAt","error","consume","value","getTokenValue","consumeFunctionName","substring","getLocation","start","end","getLocationRange","getLocationFromList","head","tail","loc","startOffset","location","length","eof","line","column","key","options","onComment","ast","setSource","Boolean","positions","hasOwnProperty","Error","forEachToken","slice"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/css-tree/lib/parser/create.js"],"sourcesContent":["var OffsetToLocation = require('../common/OffsetToLocation');\nvar SyntaxError = require('../common/SyntaxError');\nvar TokenStream = require('../common/TokenStream');\nvar List = require('../common/List');\nvar tokenize = require('../tokenizer');\nvar constants = require('../tokenizer/const');\nvar { findWhiteSpaceStart, cmpStr } = require('../tokenizer/utils');\nvar sequence = require('./sequence');\nvar noop = function() {};\n\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar IDENT = TYPE.Ident;\nvar FUNCTION = TYPE.Function;\nvar URL = TYPE.Url;\nvar HASH = TYPE.Hash;\nvar PERCENTAGE = TYPE.Percentage;\nvar NUMBER = TYPE.Number;\nvar NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)\nvar NULL = 0;\n\nfunction createParseContext(name) {\n    return function() {\n        return this[name]();\n    };\n}\n\nfunction processConfig(config) {\n    var parserConfig = {\n        context: {},\n        scope: {},\n        atrule: {},\n        pseudo: {}\n    };\n\n    if (config.parseContext) {\n        for (var name in config.parseContext) {\n            switch (typeof config.parseContext[name]) {\n                case 'function':\n                    parserConfig.context[name] = config.parseContext[name];\n                    break;\n\n                case 'string':\n                    parserConfig.context[name] = createParseContext(config.parseContext[name]);\n                    break;\n            }\n        }\n    }\n\n    if (config.scope) {\n        for (var name in config.scope) {\n            parserConfig.scope[name] = config.scope[name];\n        }\n    }\n\n    if (config.atrule) {\n        for (var name in config.atrule) {\n            var atrule = config.atrule[name];\n\n            if (atrule.parse) {\n                parserConfig.atrule[name] = atrule.parse;\n            }\n        }\n    }\n\n    if (config.pseudo) {\n        for (var name in config.pseudo) {\n            var pseudo = config.pseudo[name];\n\n            if (pseudo.parse) {\n                parserConfig.pseudo[name] = pseudo.parse;\n            }\n        }\n    }\n\n    if (config.node) {\n        for (var name in config.node) {\n            parserConfig[name] = config.node[name].parse;\n        }\n    }\n\n    return parserConfig;\n}\n\nmodule.exports = function createParser(config) {\n    var parser = {\n        scanner: new TokenStream(),\n        locationMap: new OffsetToLocation(),\n\n        filename: '<unknown>',\n        needPositions: false,\n        onParseError: noop,\n        onParseErrorThrow: false,\n        parseAtrulePrelude: true,\n        parseRulePrelude: true,\n        parseValue: true,\n        parseCustomProperty: false,\n\n        readSequence: sequence,\n\n        createList: function() {\n            return new List();\n        },\n        createSingleNodeList: function(node) {\n            return new List().appendData(node);\n        },\n        getFirstListNode: function(list) {\n            return list && list.first();\n        },\n        getLastListNode: function(list) {\n            return list.last();\n        },\n\n        parseWithFallback: function(consumer, fallback) {\n            var startToken = this.scanner.tokenIndex;\n\n            try {\n                return consumer.call(this);\n            } catch (e) {\n                if (this.onParseErrorThrow) {\n                    throw e;\n                }\n\n                var fallbackNode = fallback.call(this, startToken);\n\n                this.onParseErrorThrow = true;\n                this.onParseError(e, fallbackNode);\n                this.onParseErrorThrow = false;\n\n                return fallbackNode;\n            }\n        },\n\n        lookupNonWSType: function(offset) {\n            do {\n                var type = this.scanner.lookupType(offset++);\n                if (type !== WHITESPACE) {\n                    return type;\n                }\n            } while (type !== NULL);\n\n            return NULL;\n        },\n\n        eat: function(tokenType) {\n            if (this.scanner.tokenType !== tokenType) {\n                var offset = this.scanner.tokenStart;\n                var message = NAME[tokenType] + ' is expected';\n\n                // tweak message and offset\n                switch (tokenType) {\n                    case IDENT:\n                        // when identifier is expected but there is a function or url\n                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {\n                            offset = this.scanner.tokenEnd - 1;\n                            message = 'Identifier is expected but function found';\n                        } else {\n                            message = 'Identifier is expected';\n                        }\n                        break;\n\n                    case HASH:\n                        if (this.scanner.isDelim(NUMBERSIGN)) {\n                            this.scanner.next();\n                            offset++;\n                            message = 'Name is expected';\n                        }\n                        break;\n\n                    case PERCENTAGE:\n                        if (this.scanner.tokenType === NUMBER) {\n                            offset = this.scanner.tokenEnd;\n                            message = 'Percent sign is expected';\n                        }\n                        break;\n\n                    default:\n                        // when test type is part of another token show error for current position + 1\n                        // e.g. eat(HYPHENMINUS) will fail on \"-foo\", but pointing on \"-\" is odd\n                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {\n                            offset = offset + 1;\n                        }\n                }\n\n                this.error(message, offset);\n            }\n\n            this.scanner.next();\n        },\n\n        consume: function(tokenType) {\n            var value = this.scanner.getTokenValue();\n\n            this.eat(tokenType);\n\n            return value;\n        },\n        consumeFunctionName: function() {\n            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);\n\n            this.eat(FUNCTION);\n\n            return name;\n        },\n\n        getLocation: function(start, end) {\n            if (this.needPositions) {\n                return this.locationMap.getLocationRange(\n                    start,\n                    end,\n                    this.filename\n                );\n            }\n\n            return null;\n        },\n        getLocationFromList: function(list) {\n            if (this.needPositions) {\n                var head = this.getFirstListNode(list);\n                var tail = this.getLastListNode(list);\n                return this.locationMap.getLocationRange(\n                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,\n                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,\n                    this.filename\n                );\n            }\n\n            return null;\n        },\n\n        error: function(message, offset) {\n            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length\n                ? this.locationMap.getLocation(offset)\n                : this.scanner.eof\n                    ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1))\n                    : this.locationMap.getLocation(this.scanner.tokenStart);\n\n            throw new SyntaxError(\n                message || 'Unexpected input',\n                this.scanner.source,\n                location.offset,\n                location.line,\n                location.column\n            );\n        }\n    };\n\n    config = processConfig(config || {});\n    for (var key in config) {\n        parser[key] = config[key];\n    }\n\n    return function(source, options) {\n        options = options || {};\n\n        var context = options.context || 'default';\n        var onComment = options.onComment;\n        var ast;\n\n        tokenize(source, parser.scanner);\n        parser.locationMap.setSource(\n            source,\n            options.offset,\n            options.line,\n            options.column\n        );\n\n        parser.filename = options.filename || '<unknown>';\n        parser.needPositions = Boolean(options.positions);\n        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;\n        parser.onParseErrorThrow = false;\n        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;\n        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;\n        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n\n        if (!parser.context.hasOwnProperty(context)) {\n            throw new Error('Unknown context `' + context + '`');\n        }\n\n        if (typeof onComment === 'function') {\n            parser.scanner.forEachToken((type, start, end) => {\n                if (type === COMMENT) {\n                    const loc = parser.getLocation(start, end);\n                    const value = cmpStr(source, end - 2, end, '*/')\n                        ? source.slice(start + 2, end - 2)\n                        : source.slice(start + 2, end);\n\n                    onComment(value, loc);\n                }\n            });\n        }\n\n        ast = parser.context[context].call(parser, options);\n\n        if (!parser.scanner.eof) {\n            parser.error();\n        }\n\n        return ast;\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}