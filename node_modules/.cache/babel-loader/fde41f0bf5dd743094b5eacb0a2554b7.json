{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nconst FUNCTION_CONSTRUCTOR = 'Function';\nconst GLOBAL_CANDIDATES = new Set(['global', 'window', 'globalThis']);\nconst EVAL_LIKE_METHODS = new Set(['setImmediate', 'setInterval', 'setTimeout', 'execScript']);\nexports.default = util.createRule({\n  name: 'no-implied-eval',\n  meta: {\n    docs: {\n      description: 'Disallow the use of `eval()`-like methods',\n      recommended: 'error',\n      extendsBaseRule: true,\n      requiresTypeChecking: true\n    },\n    messages: {\n      noImpliedEvalError: 'Implied eval. Consider passing a function.',\n      noFunctionConstructor: 'Implied eval. Do not use the Function constructor to create functions.'\n    },\n    schema: [],\n    type: 'suggestion'\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const parserServices = util.getParserServices(context);\n    const program = parserServices.program;\n    const checker = parserServices.program.getTypeChecker();\n\n    function getCalleeName(node) {\n      if (node.type === utils_1.AST_NODE_TYPES.Identifier) {\n        return node.name;\n      }\n\n      if (node.type === utils_1.AST_NODE_TYPES.MemberExpression && node.object.type === utils_1.AST_NODE_TYPES.Identifier && GLOBAL_CANDIDATES.has(node.object.name)) {\n        if (node.property.type === utils_1.AST_NODE_TYPES.Identifier) {\n          return node.property.name;\n        }\n\n        if (node.property.type === utils_1.AST_NODE_TYPES.Literal && typeof node.property.value === 'string') {\n          return node.property.value;\n        }\n      }\n\n      return null;\n    }\n\n    function isFunctionType(node) {\n      var _a;\n\n      const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n      const type = checker.getTypeAtLocation(tsNode);\n      const symbol = type.getSymbol();\n\n      if (symbol && tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Function | ts.SymbolFlags.Method)) {\n        return true;\n      }\n\n      if (symbol && symbol.escapedName === FUNCTION_CONSTRUCTOR) {\n        const declarations = (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : [];\n\n        for (const declaration of declarations) {\n          const sourceFile = declaration.getSourceFile();\n\n          if (program.isSourceFileDefaultLibrary(sourceFile)) {\n            return true;\n          }\n        }\n      }\n\n      const signatures = checker.getSignaturesOfType(type, ts.SignatureKind.Call);\n      return signatures.length > 0;\n    }\n\n    function isBind(node) {\n      return node.type === utils_1.AST_NODE_TYPES.MemberExpression ? isBind(node.property) : node.type === utils_1.AST_NODE_TYPES.Identifier && node.name === 'bind';\n    }\n\n    function isFunction(node) {\n      switch (node.type) {\n        case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:\n        case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n        case utils_1.AST_NODE_TYPES.FunctionExpression:\n          return true;\n\n        case utils_1.AST_NODE_TYPES.Literal:\n        case utils_1.AST_NODE_TYPES.TemplateLiteral:\n          return false;\n\n        case utils_1.AST_NODE_TYPES.CallExpression:\n          return isBind(node.callee) || isFunctionType(node);\n\n        default:\n          return isFunctionType(node);\n      }\n    }\n\n    function isReferenceToGlobalFunction(calleeName) {\n      const ref = context.getScope().references.find(ref => ref.identifier.name === calleeName); // ensure it's the \"global\" version\n\n      return !(ref === null || ref === void 0 ? void 0 : ref.resolved) || ref.resolved.defs.length === 0;\n    }\n\n    function checkImpliedEval(node) {\n      var _a;\n\n      const calleeName = getCalleeName(node.callee);\n\n      if (calleeName === null) {\n        return;\n      }\n\n      if (calleeName === FUNCTION_CONSTRUCTOR) {\n        const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node.callee);\n        const type = checker.getTypeAtLocation(tsNode);\n        const symbol = type.getSymbol();\n\n        if (symbol) {\n          const declarations = (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : [];\n\n          for (const declaration of declarations) {\n            const sourceFile = declaration.getSourceFile();\n\n            if (program.isSourceFileDefaultLibrary(sourceFile)) {\n              context.report({\n                node,\n                messageId: 'noFunctionConstructor'\n              });\n              return;\n            }\n          }\n        } else {\n          context.report({\n            node,\n            messageId: 'noFunctionConstructor'\n          });\n          return;\n        }\n      }\n\n      if (node.arguments.length === 0) {\n        return;\n      }\n\n      const [handler] = node.arguments;\n\n      if (EVAL_LIKE_METHODS.has(calleeName) && !isFunction(handler) && isReferenceToGlobalFunction(calleeName)) {\n        context.report({\n          node: handler,\n          messageId: 'noImpliedEvalError'\n        });\n      }\n    }\n\n    return {\n      NewExpression: checkImpliedEval,\n      CallExpression: checkImpliedEval\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["FUNCTION_CONSTRUCTOR","GLOBAL_CANDIDATES","Set","EVAL_LIKE_METHODS","exports","util","createRule","name","meta","docs","description","recommended","extendsBaseRule","requiresTypeChecking","messages","noImpliedEvalError","noFunctionConstructor","schema","type","defaultOptions","create","context","parserServices","getParserServices","program","checker","getTypeChecker","getCalleeName","node","utils_1","Identifier","MemberExpression","object","has","property","Literal","value","isFunctionType","tsNode","esTreeNodeToTSNodeMap","get","getTypeAtLocation","symbol","getSymbol","tsutils","isSymbolFlagSet","ts","SymbolFlags","Function","Method","escapedName","declarations","getDeclarations","_a","declaration","sourceFile","getSourceFile","isSourceFileDefaultLibrary","signatures","getSignaturesOfType","SignatureKind","Call","length","isBind","isFunction","ArrowFunctionExpression","FunctionDeclaration","FunctionExpression","TemplateLiteral","CallExpression","callee","isReferenceToGlobalFunction","calleeName","ref","getScope","references","find","identifier","resolved","defs","checkImpliedEval","report","messageId","arguments","handler","NewExpression"],"sources":["../../src/rules/no-implied-eval.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}