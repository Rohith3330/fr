{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _sliceIterator(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _slicedToArray(arr, i) {\n  if (Array.isArray(arr)) {\n    return arr;\n  } else if (Symbol.iterator in Object(arr)) {\n    return _sliceIterator(arr, i);\n  } else {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n}\n\nimport { isBlock, isFunc, isIdentifier, numberLiteralFromRaw, traverse } from \"../../index\";\nimport { moduleContextFromModuleAST } from \"../ast-module-to-module-context\"; // FIXME(sven): do the same with all block instructions, must be more generic here\n\nfunction newUnexpectedFunction(i) {\n  return new Error(\"unknown function at offset: \" + i);\n}\n\nexport function transform(ast) {\n  var module;\n  traverse(ast, {\n    Module: function (_Module) {\n      function Module(_x) {\n        return _Module.apply(this, arguments);\n      }\n\n      Module.toString = function () {\n        return _Module.toString();\n      };\n\n      return Module;\n    }(function (path) {\n      module = path.node;\n    })\n  });\n  var moduleContext = moduleContextFromModuleAST(module); // Transform the actual instruction in function bodies\n\n  traverse(ast, {\n    Func: function (_Func) {\n      function Func(_x2) {\n        return _Func.apply(this, arguments);\n      }\n\n      Func.toString = function () {\n        return _Func.toString();\n      };\n\n      return Func;\n    }(function (path) {\n      transformFuncPath(path, moduleContext);\n    }),\n    Start: function (_Start) {\n      function Start(_x3) {\n        return _Start.apply(this, arguments);\n      }\n\n      Start.toString = function () {\n        return _Start.toString();\n      };\n\n      return Start;\n    }(function (path) {\n      var index = path.node.index;\n\n      if (isIdentifier(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n\n        path.node.index = numberLiteralFromRaw(offsetInModule);\n      }\n    })\n  });\n}\n\nfunction transformFuncPath(funcPath, moduleContext) {\n  var funcNode = funcPath.node;\n  var signature = funcNode.signature;\n\n  if (signature.type !== \"Signature\") {\n    throw new Error(\"Function signatures must be denormalised before execution\");\n  }\n\n  var params = signature.params; // Add func locals in the context\n\n  params.forEach(function (p) {\n    return moduleContext.addLocal(p.valtype);\n  });\n  traverse(funcNode, {\n    Instr: function (_Instr) {\n      function Instr(_x4) {\n        return _Instr.apply(this, arguments);\n      }\n\n      Instr.toString = function () {\n        return _Instr.toString();\n      };\n\n      return Instr;\n    }(function (instrPath) {\n      var instrNode = instrPath.node;\n      /**\n       * Local access\n       */\n\n      if (instrNode.id === \"get_local\" || instrNode.id === \"set_local\" || instrNode.id === \"tee_local\") {\n        var _instrNode$args = _slicedToArray(instrNode.args, 1),\n            firstArg = _instrNode$args[0];\n\n        if (firstArg.type === \"Identifier\") {\n          var offsetInParams = params.findIndex(function (_ref) {\n            var id = _ref.id;\n            return id === firstArg.value;\n          });\n\n          if (offsetInParams === -1) {\n            throw new Error(\"\".concat(firstArg.value, \" not found in \").concat(instrNode.id, \": not declared in func params\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n\n          instrNode.args[0] = numberLiteralFromRaw(offsetInParams);\n        }\n      }\n      /**\n       * Global access\n       */\n\n\n      if (instrNode.id === \"get_global\" || instrNode.id === \"set_global\") {\n        var _instrNode$args2 = _slicedToArray(instrNode.args, 1),\n            _firstArg = _instrNode$args2[0];\n\n        if (isIdentifier(_firstArg) === true) {\n          var globalOffset = moduleContext.getGlobalOffsetByIdentifier( // $FlowIgnore: reference?\n          _firstArg.value);\n\n          if (typeof globalOffset === \"undefined\") {\n            // $FlowIgnore: reference?\n            throw new Error(\"global \".concat(_firstArg.value, \" not found in module\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n\n          instrNode.args[0] = numberLiteralFromRaw(globalOffset);\n        }\n      }\n      /**\n       * Labels lookup\n       */\n\n\n      if (instrNode.id === \"br\") {\n        var _instrNode$args3 = _slicedToArray(instrNode.args, 1),\n            _firstArg2 = _instrNode$args3[0];\n\n        if (isIdentifier(_firstArg2) === true) {\n          // if the labels is not found it is going to be replaced with -1\n          // which is invalid.\n          var relativeBlockCount = -1; // $FlowIgnore: reference?\n\n          instrPath.findParent(function (_ref2) {\n            var node = _ref2.node;\n\n            if (isBlock(node)) {\n              relativeBlockCount++; // $FlowIgnore: reference?\n\n              var name = node.label || node.name;\n\n              if (_typeof(name) === \"object\") {\n                // $FlowIgnore: isIdentifier ensures that\n                if (name.value === _firstArg2.value) {\n                  // Found it\n                  return false;\n                }\n              }\n            }\n\n            if (isFunc(node)) {\n              return false;\n            }\n          }); // Replace the Identifer node by our new NumberLiteral node\n\n          instrNode.args[0] = numberLiteralFromRaw(relativeBlockCount);\n        }\n      }\n    }),\n\n    /**\n     * Func lookup\n     */\n    CallInstruction: function (_CallInstruction) {\n      function CallInstruction(_x5) {\n        return _CallInstruction.apply(this, arguments);\n      }\n\n      CallInstruction.toString = function () {\n        return _CallInstruction.toString();\n      };\n\n      return CallInstruction;\n    }(function (_ref3) {\n      var node = _ref3.node;\n      var index = node.index;\n\n      if (isIdentifier(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n\n        node.index = numberLiteralFromRaw(offsetInModule);\n      }\n    })\n  });\n}","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","length","err","_slicedToArray","Array","isArray","Object","TypeError","isBlock","isFunc","isIdentifier","numberLiteralFromRaw","traverse","moduleContextFromModuleAST","newUnexpectedFunction","Error","transform","ast","module","Module","_Module","_x","apply","arguments","toString","path","node","moduleContext","Func","_Func","_x2","transformFuncPath","Start","_Start","_x3","index","offsetInModule","getFunctionOffsetByIdentifier","funcPath","funcNode","signature","type","params","forEach","p","addLocal","valtype","Instr","_Instr","_x4","instrPath","instrNode","id","_instrNode$args","args","firstArg","offsetInParams","findIndex","_ref","concat","_instrNode$args2","_firstArg","globalOffset","getGlobalOffsetByIdentifier","_instrNode$args3","_firstArg2","relativeBlockCount","findParent","_ref2","name","label","CallInstruction","_CallInstruction","_x5","_ref3"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@webassemblyjs/ast/esm/transform/wast-identifier-to-index/index.js"],"sourcesContent":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _slicedToArray(arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return _sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }\n\nimport { isBlock, isFunc, isIdentifier, numberLiteralFromRaw, traverse } from \"../../index\";\nimport { moduleContextFromModuleAST } from \"../ast-module-to-module-context\"; // FIXME(sven): do the same with all block instructions, must be more generic here\n\nfunction newUnexpectedFunction(i) {\n  return new Error(\"unknown function at offset: \" + i);\n}\n\nexport function transform(ast) {\n  var module;\n  traverse(ast, {\n    Module: function (_Module) {\n      function Module(_x) {\n        return _Module.apply(this, arguments);\n      }\n\n      Module.toString = function () {\n        return _Module.toString();\n      };\n\n      return Module;\n    }(function (path) {\n      module = path.node;\n    })\n  });\n  var moduleContext = moduleContextFromModuleAST(module); // Transform the actual instruction in function bodies\n\n  traverse(ast, {\n    Func: function (_Func) {\n      function Func(_x2) {\n        return _Func.apply(this, arguments);\n      }\n\n      Func.toString = function () {\n        return _Func.toString();\n      };\n\n      return Func;\n    }(function (path) {\n      transformFuncPath(path, moduleContext);\n    }),\n    Start: function (_Start) {\n      function Start(_x3) {\n        return _Start.apply(this, arguments);\n      }\n\n      Start.toString = function () {\n        return _Start.toString();\n      };\n\n      return Start;\n    }(function (path) {\n      var index = path.node.index;\n\n      if (isIdentifier(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n\n        path.node.index = numberLiteralFromRaw(offsetInModule);\n      }\n    })\n  });\n}\n\nfunction transformFuncPath(funcPath, moduleContext) {\n  var funcNode = funcPath.node;\n  var signature = funcNode.signature;\n\n  if (signature.type !== \"Signature\") {\n    throw new Error(\"Function signatures must be denormalised before execution\");\n  }\n\n  var params = signature.params; // Add func locals in the context\n\n  params.forEach(function (p) {\n    return moduleContext.addLocal(p.valtype);\n  });\n  traverse(funcNode, {\n    Instr: function (_Instr) {\n      function Instr(_x4) {\n        return _Instr.apply(this, arguments);\n      }\n\n      Instr.toString = function () {\n        return _Instr.toString();\n      };\n\n      return Instr;\n    }(function (instrPath) {\n      var instrNode = instrPath.node;\n      /**\n       * Local access\n       */\n\n      if (instrNode.id === \"get_local\" || instrNode.id === \"set_local\" || instrNode.id === \"tee_local\") {\n        var _instrNode$args = _slicedToArray(instrNode.args, 1),\n            firstArg = _instrNode$args[0];\n\n        if (firstArg.type === \"Identifier\") {\n          var offsetInParams = params.findIndex(function (_ref) {\n            var id = _ref.id;\n            return id === firstArg.value;\n          });\n\n          if (offsetInParams === -1) {\n            throw new Error(\"\".concat(firstArg.value, \" not found in \").concat(instrNode.id, \": not declared in func params\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n\n          instrNode.args[0] = numberLiteralFromRaw(offsetInParams);\n        }\n      }\n      /**\n       * Global access\n       */\n\n\n      if (instrNode.id === \"get_global\" || instrNode.id === \"set_global\") {\n        var _instrNode$args2 = _slicedToArray(instrNode.args, 1),\n            _firstArg = _instrNode$args2[0];\n\n        if (isIdentifier(_firstArg) === true) {\n          var globalOffset = moduleContext.getGlobalOffsetByIdentifier( // $FlowIgnore: reference?\n          _firstArg.value);\n\n          if (typeof globalOffset === \"undefined\") {\n            // $FlowIgnore: reference?\n            throw new Error(\"global \".concat(_firstArg.value, \" not found in module\"));\n          } // Replace the Identifer node by our new NumberLiteral node\n\n\n          instrNode.args[0] = numberLiteralFromRaw(globalOffset);\n        }\n      }\n      /**\n       * Labels lookup\n       */\n\n\n      if (instrNode.id === \"br\") {\n        var _instrNode$args3 = _slicedToArray(instrNode.args, 1),\n            _firstArg2 = _instrNode$args3[0];\n\n        if (isIdentifier(_firstArg2) === true) {\n          // if the labels is not found it is going to be replaced with -1\n          // which is invalid.\n          var relativeBlockCount = -1; // $FlowIgnore: reference?\n\n          instrPath.findParent(function (_ref2) {\n            var node = _ref2.node;\n\n            if (isBlock(node)) {\n              relativeBlockCount++; // $FlowIgnore: reference?\n\n              var name = node.label || node.name;\n\n              if (_typeof(name) === \"object\") {\n                // $FlowIgnore: isIdentifier ensures that\n                if (name.value === _firstArg2.value) {\n                  // Found it\n                  return false;\n                }\n              }\n            }\n\n            if (isFunc(node)) {\n              return false;\n            }\n          }); // Replace the Identifer node by our new NumberLiteral node\n\n          instrNode.args[0] = numberLiteralFromRaw(relativeBlockCount);\n        }\n      }\n    }),\n\n    /**\n     * Func lookup\n     */\n    CallInstruction: function (_CallInstruction) {\n      function CallInstruction(_x5) {\n        return _CallInstruction.apply(this, arguments);\n      }\n\n      CallInstruction.toString = function () {\n        return _CallInstruction.toString();\n      };\n\n      return CallInstruction;\n    }(function (_ref3) {\n      var node = _ref3.node;\n      var index = node.index;\n\n      if (isIdentifier(index) === true) {\n        var offsetInModule = moduleContext.getFunctionOffsetByIdentifier(index.value);\n\n        if (typeof offsetInModule === \"undefined\") {\n          throw newUnexpectedFunction(index.value);\n        } // Replace the index Identifier\n        // $FlowIgnore: reference?\n\n\n        node.index = numberLiteralFromRaw(offsetInModule);\n      }\n    })\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}