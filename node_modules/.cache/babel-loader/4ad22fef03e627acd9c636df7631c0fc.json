{"ast":null,"code":"\"use strict\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n/**\n * Filesystem Cache\n *\n * Given a file and a transform function, cache the result into files\n * or retrieve the previously cached files if the given file is already known.\n *\n * @see https://github.com/babel/babel-loader/issues/34\n * @see https://github.com/babel/babel-loader/pull/41\n */\n\n\nconst fs = require(\"fs\");\n\nconst os = require(\"os\");\n\nconst path = require(\"path\");\n\nconst zlib = require(\"zlib\");\n\nconst crypto = require(\"crypto\");\n\nconst findCacheDir = require(\"find-cache-dir\");\n\nconst {\n  promisify\n} = require(\"util\");\n\nconst transform = require(\"./transform\"); // Lazily instantiated when needed\n\n\nlet defaultCacheDirectory = null;\nlet hashType = \"md4\"; // use md5 hashing if md4 is not available\n\ntry {\n  crypto.createHash(hashType);\n} catch (err) {\n  hashType = \"md5\";\n}\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst gunzip = promisify(zlib.gunzip);\nconst gzip = promisify(zlib.gzip);\n\nconst makeDir = require(\"make-dir\");\n/**\n * Read the contents from the compressed file.\n *\n * @async\n * @params {String} filename\n * @params {Boolean} compress\n */\n\n\nconst read = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (filename, compress) {\n    const data = yield readFile(filename + (compress ? \".gz\" : \"\"));\n    const content = compress ? yield gunzip(data) : data;\n    return JSON.parse(content.toString());\n  });\n\n  return function read(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Write contents into a compressed file.\n *\n * @async\n * @params {String} filename\n * @params {Boolean} compress\n * @params {String} result\n */\n\n\nconst write = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (filename, compress, result) {\n    const content = JSON.stringify(result);\n    const data = compress ? yield gzip(content) : content;\n    return yield writeFile(filename + (compress ? \".gz\" : \"\"), data);\n  });\n\n  return function write(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Build the filename for the cached file\n *\n * @params {String} source  File source code\n * @params {Object} options Options used\n *\n * @return {String}\n */\n\n\nconst filename = function (source, identifier, options) {\n  const hash = crypto.createHash(hashType);\n  const contents = JSON.stringify({\n    source,\n    options,\n    identifier\n  });\n  hash.update(contents);\n  return hash.digest(\"hex\") + \".json\";\n};\n/**\n * Handle the cache\n *\n * @params {String} directory\n * @params {Object} params\n */\n\n\nconst handleCache = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (directory, params) {\n    const {\n      source,\n      options = {},\n      cacheIdentifier,\n      cacheDirectory,\n      cacheCompression\n    } = params;\n    const file = path.join(directory, filename(source, cacheIdentifier, options));\n\n    try {\n      // No errors mean that the file was previously cached\n      // we just need to return it\n      return yield read(file, cacheCompression);\n    } catch (err) {}\n\n    const fallback = typeof cacheDirectory !== \"string\" && directory !== os.tmpdir(); // Make sure the directory exists.\n\n    try {\n      yield makeDir(directory);\n    } catch (err) {\n      if (fallback) {\n        return handleCache(os.tmpdir(), params);\n      }\n\n      throw err;\n    } // Otherwise just transform the file\n    // return it to the user asap and write it in cache\n\n\n    const result = yield transform(source, options);\n\n    try {\n      yield write(file, cacheCompression, result);\n    } catch (err) {\n      if (fallback) {\n        // Fallback to tmpdir if node_modules folder not writable\n        return handleCache(os.tmpdir(), params);\n      }\n\n      throw err;\n    }\n\n    return result;\n  });\n\n  return function handleCache(_x6, _x7) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Retrieve file from cache, or create a new one for future reads\n *\n * @async\n * @param  {Object}   params\n * @param  {String}   params.cacheDirectory   Directory to store cached files\n * @param  {String}   params.cacheIdentifier  Unique identifier to bust cache\n * @param  {Boolean}  params.cacheCompression Whether compressing cached files\n * @param  {String}   params.source   Original contents of the file to be cached\n * @param  {Object}   params.options  Options to be given to the transform fn\n *\n * @example\n *\n *   const result = await cache({\n *     cacheDirectory: '.tmp/cache',\n *     cacheIdentifier: 'babel-loader-cachefile',\n *     cacheCompression: false,\n *     source: *source code from file*,\n *     options: {\n *       experimental: true,\n *       runtime: true\n *     },\n *   });\n */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (params) {\n    let directory;\n\n    if (typeof params.cacheDirectory === \"string\") {\n      directory = params.cacheDirectory;\n    } else {\n      if (defaultCacheDirectory === null) {\n        defaultCacheDirectory = findCacheDir({\n          name: \"babel-loader\"\n        }) || os.tmpdir();\n      }\n\n      directory = defaultCacheDirectory;\n    }\n\n    return yield handleCache(directory, params);\n  });\n\n  return function (_x8) {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","_asyncToGenerator","fn","self","args","arguments","apply","err","undefined","fs","require","os","path","zlib","crypto","findCacheDir","promisify","transform","defaultCacheDirectory","hashType","createHash","readFile","writeFile","gunzip","gzip","makeDir","read","_ref","filename","compress","data","content","JSON","parse","toString","_x","_x2","write","_ref2","result","stringify","_x3","_x4","_x5","source","identifier","options","hash","contents","update","digest","handleCache","_ref3","directory","params","cacheIdentifier","cacheDirectory","cacheCompression","file","join","fallback","tmpdir","_x6","_x7","module","exports","_ref4","name","_x8"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/babel-loader/lib/cache.js"],"sourcesContent":["\"use strict\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/**\n * Filesystem Cache\n *\n * Given a file and a transform function, cache the result into files\n * or retrieve the previously cached files if the given file is already known.\n *\n * @see https://github.com/babel/babel-loader/issues/34\n * @see https://github.com/babel/babel-loader/pull/41\n */\nconst fs = require(\"fs\");\n\nconst os = require(\"os\");\n\nconst path = require(\"path\");\n\nconst zlib = require(\"zlib\");\n\nconst crypto = require(\"crypto\");\n\nconst findCacheDir = require(\"find-cache-dir\");\n\nconst {\n  promisify\n} = require(\"util\");\n\nconst transform = require(\"./transform\"); // Lazily instantiated when needed\n\n\nlet defaultCacheDirectory = null;\nlet hashType = \"md4\"; // use md5 hashing if md4 is not available\n\ntry {\n  crypto.createHash(hashType);\n} catch (err) {\n  hashType = \"md5\";\n}\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst gunzip = promisify(zlib.gunzip);\nconst gzip = promisify(zlib.gzip);\n\nconst makeDir = require(\"make-dir\");\n/**\n * Read the contents from the compressed file.\n *\n * @async\n * @params {String} filename\n * @params {Boolean} compress\n */\n\n\nconst read = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (filename, compress) {\n    const data = yield readFile(filename + (compress ? \".gz\" : \"\"));\n    const content = compress ? yield gunzip(data) : data;\n    return JSON.parse(content.toString());\n  });\n\n  return function read(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Write contents into a compressed file.\n *\n * @async\n * @params {String} filename\n * @params {Boolean} compress\n * @params {String} result\n */\n\n\nconst write = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (filename, compress, result) {\n    const content = JSON.stringify(result);\n    const data = compress ? yield gzip(content) : content;\n    return yield writeFile(filename + (compress ? \".gz\" : \"\"), data);\n  });\n\n  return function write(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Build the filename for the cached file\n *\n * @params {String} source  File source code\n * @params {Object} options Options used\n *\n * @return {String}\n */\n\n\nconst filename = function (source, identifier, options) {\n  const hash = crypto.createHash(hashType);\n  const contents = JSON.stringify({\n    source,\n    options,\n    identifier\n  });\n  hash.update(contents);\n  return hash.digest(\"hex\") + \".json\";\n};\n/**\n * Handle the cache\n *\n * @params {String} directory\n * @params {Object} params\n */\n\n\nconst handleCache = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (directory, params) {\n    const {\n      source,\n      options = {},\n      cacheIdentifier,\n      cacheDirectory,\n      cacheCompression\n    } = params;\n    const file = path.join(directory, filename(source, cacheIdentifier, options));\n\n    try {\n      // No errors mean that the file was previously cached\n      // we just need to return it\n      return yield read(file, cacheCompression);\n    } catch (err) {}\n\n    const fallback = typeof cacheDirectory !== \"string\" && directory !== os.tmpdir(); // Make sure the directory exists.\n\n    try {\n      yield makeDir(directory);\n    } catch (err) {\n      if (fallback) {\n        return handleCache(os.tmpdir(), params);\n      }\n\n      throw err;\n    } // Otherwise just transform the file\n    // return it to the user asap and write it in cache\n\n\n    const result = yield transform(source, options);\n\n    try {\n      yield write(file, cacheCompression, result);\n    } catch (err) {\n      if (fallback) {\n        // Fallback to tmpdir if node_modules folder not writable\n        return handleCache(os.tmpdir(), params);\n      }\n\n      throw err;\n    }\n\n    return result;\n  });\n\n  return function handleCache(_x6, _x7) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Retrieve file from cache, or create a new one for future reads\n *\n * @async\n * @param  {Object}   params\n * @param  {String}   params.cacheDirectory   Directory to store cached files\n * @param  {String}   params.cacheIdentifier  Unique identifier to bust cache\n * @param  {Boolean}  params.cacheCompression Whether compressing cached files\n * @param  {String}   params.source   Original contents of the file to be cached\n * @param  {Object}   params.options  Options to be given to the transform fn\n *\n * @example\n *\n *   const result = await cache({\n *     cacheDirectory: '.tmp/cache',\n *     cacheIdentifier: 'babel-loader-cachefile',\n *     cacheCompression: false,\n *     source: *source code from file*,\n *     options: {\n *       experimental: true,\n *       runtime: true\n *     },\n *   });\n */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator(function* (params) {\n    let directory;\n\n    if (typeof params.cacheDirectory === \"string\") {\n      directory = params.cacheDirectory;\n    } else {\n      if (defaultCacheDirectory === null) {\n        defaultCacheDirectory = findCacheDir({\n          name: \"babel-loader\"\n        }) || os.tmpdir();\n      }\n\n      directory = defaultCacheDirectory;\n    }\n\n    return yield handleCache(directory, params);\n  });\n\n  return function (_x8) {\n    return _ref4.apply(this, arguments);\n  };\n}();"],"mappings":"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"},"metadata":{},"sourceType":"script"}