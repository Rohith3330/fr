{"ast":null,"code":"const getCurrentScriptSource = require('./getCurrentScriptSource.js');\n/**\n * @typedef {Object} SocketUrlParts\n * @property {string} [auth]\n * @property {string} hostname\n * @property {string} [protocol]\n * @property {string} pathname\n * @property {string} [port]\n */\n\n/**\n * Parse current location and Webpack's `__resourceQuery` into parts that can create a valid socket URL.\n * @param {string} [resourceQuery] The Webpack `__resourceQuery` string.\n * @param {import('./getWDSMetadata').WDSMetaObj} [metadata] The parsed WDS metadata object.\n * @returns {SocketUrlParts} The parsed URL parts.\n * @see https://webpack.js.org/api/module-variables/#__resourcequery-webpack-specific\n */\n\n\nfunction getSocketUrlParts(resourceQuery, metadata) {\n  if (typeof metadata === 'undefined') {\n    metadata = {};\n  }\n  /** @type {SocketUrlParts} */\n\n\n  let urlParts = {}; // If the resource query is available,\n  // parse it and ignore everything we received from the script host.\n\n  if (resourceQuery) {\n    const parsedQuery = {};\n    const searchParams = new URLSearchParams(resourceQuery.slice(1));\n    searchParams.forEach(function (value, key) {\n      parsedQuery[key] = value;\n    });\n    urlParts.hostname = parsedQuery.sockHost;\n    urlParts.pathname = parsedQuery.sockPath;\n    urlParts.port = parsedQuery.sockPort; // Make sure the protocol from resource query has a trailing colon\n\n    if (parsedQuery.sockProtocol) {\n      urlParts.protocol = parsedQuery.sockProtocol + ':';\n    }\n  } else {\n    const scriptSource = getCurrentScriptSource();\n    let url = {};\n\n    try {\n      // The placeholder `baseURL` with `window.location.href`,\n      // is to allow parsing of path-relative or protocol-relative URLs,\n      // and will have no effect if `scriptSource` is a fully valid URL.\n      url = new URL(scriptSource, window.location.href);\n    } catch (e) {// URL parsing failed, do nothing.\n      // We will still proceed to see if we can recover using `resourceQuery`\n    } // Parse authentication credentials in case we need them\n\n\n    if (url.username) {\n      // Since HTTP basic authentication does not allow empty username,\n      // we only include password if the username is not empty.\n      // Result: <username> or <username>:<password>\n      urlParts.auth = url.username;\n\n      if (url.password) {\n        urlParts.auth += ':' + url.password;\n      }\n    } // `file://` URLs has `'null'` origin\n\n\n    if (url.origin !== 'null') {\n      urlParts.hostname = url.hostname;\n    }\n\n    urlParts.protocol = url.protocol;\n    urlParts.port = url.port;\n  }\n\n  if (!urlParts.pathname) {\n    if (metadata.version === 4) {\n      // This is hard-coded in WDS v4\n      urlParts.pathname = '/ws';\n    } else {\n      // This is hard-coded in WDS v3\n      urlParts.pathname = '/sockjs-node';\n    }\n  } // Check for IPv4 and IPv6 host addresses that correspond to any/empty.\n  // This is important because `hostname` can be empty for some hosts,\n  // such as 'about:blank' or 'file://' URLs.\n\n\n  const isEmptyHostname = urlParts.hostname === '0.0.0.0' || urlParts.hostname === '[::]' || !urlParts.hostname; // We only re-assign the hostname if it is empty,\n  // and if we are using HTTP/HTTPS protocols.\n\n  if (isEmptyHostname && window.location.hostname && window.location.protocol.indexOf('http') === 0) {\n    urlParts.hostname = window.location.hostname;\n  } // We only re-assign `protocol` when `protocol` is unavailable,\n  // or if `hostname` is available and is empty,\n  // since otherwise we risk creating an invalid URL.\n  // We also do this when 'https' is used as it mandates the use of secure sockets.\n\n\n  if (!urlParts.protocol || urlParts.hostname && (isEmptyHostname || window.location.protocol === 'https:')) {\n    urlParts.protocol = window.location.protocol;\n  } // We only re-assign port when it is not available\n\n\n  if (!urlParts.port) {\n    urlParts.port = window.location.port;\n  }\n\n  if (!urlParts.hostname || !urlParts.pathname) {\n    throw new Error(['[React Refresh] Failed to get an URL for the socket connection.', \"This usually means that the current executed script doesn't have a `src` attribute set.\", 'You should either specify the socket path parameters under the `devServer` key in your Webpack config, or use the `overlay` option.', 'https://github.com/pmmmwh/react-refresh-webpack-plugin/blob/main/docs/API.md#overlay'].join('\\n'));\n  }\n\n  return {\n    auth: urlParts.auth,\n    hostname: urlParts.hostname,\n    pathname: urlParts.pathname,\n    protocol: urlParts.protocol,\n    port: urlParts.port || undefined\n  };\n}\n\nmodule.exports = getSocketUrlParts;","map":{"version":3,"names":["getCurrentScriptSource","require","getSocketUrlParts","resourceQuery","metadata","urlParts","parsedQuery","searchParams","URLSearchParams","slice","forEach","value","key","hostname","sockHost","pathname","sockPath","port","sockPort","sockProtocol","protocol","scriptSource","url","URL","window","location","href","e","username","auth","password","origin","version","isEmptyHostname","indexOf","Error","join","undefined","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@pmmmwh/react-refresh-webpack-plugin/sockets/utils/getSocketUrlParts.js"],"sourcesContent":["const getCurrentScriptSource = require('./getCurrentScriptSource.js');\n\n/**\n * @typedef {Object} SocketUrlParts\n * @property {string} [auth]\n * @property {string} hostname\n * @property {string} [protocol]\n * @property {string} pathname\n * @property {string} [port]\n */\n\n/**\n * Parse current location and Webpack's `__resourceQuery` into parts that can create a valid socket URL.\n * @param {string} [resourceQuery] The Webpack `__resourceQuery` string.\n * @param {import('./getWDSMetadata').WDSMetaObj} [metadata] The parsed WDS metadata object.\n * @returns {SocketUrlParts} The parsed URL parts.\n * @see https://webpack.js.org/api/module-variables/#__resourcequery-webpack-specific\n */\nfunction getSocketUrlParts(resourceQuery, metadata) {\n  if (typeof metadata === 'undefined') {\n    metadata = {};\n  }\n\n  /** @type {SocketUrlParts} */\n  let urlParts = {};\n\n  // If the resource query is available,\n  // parse it and ignore everything we received from the script host.\n  if (resourceQuery) {\n    const parsedQuery = {};\n    const searchParams = new URLSearchParams(resourceQuery.slice(1));\n    searchParams.forEach(function (value, key) {\n      parsedQuery[key] = value;\n    });\n\n    urlParts.hostname = parsedQuery.sockHost;\n    urlParts.pathname = parsedQuery.sockPath;\n    urlParts.port = parsedQuery.sockPort;\n\n    // Make sure the protocol from resource query has a trailing colon\n    if (parsedQuery.sockProtocol) {\n      urlParts.protocol = parsedQuery.sockProtocol + ':';\n    }\n  } else {\n    const scriptSource = getCurrentScriptSource();\n\n    let url = {};\n    try {\n      // The placeholder `baseURL` with `window.location.href`,\n      // is to allow parsing of path-relative or protocol-relative URLs,\n      // and will have no effect if `scriptSource` is a fully valid URL.\n      url = new URL(scriptSource, window.location.href);\n    } catch (e) {\n      // URL parsing failed, do nothing.\n      // We will still proceed to see if we can recover using `resourceQuery`\n    }\n\n    // Parse authentication credentials in case we need them\n    if (url.username) {\n      // Since HTTP basic authentication does not allow empty username,\n      // we only include password if the username is not empty.\n      // Result: <username> or <username>:<password>\n      urlParts.auth = url.username;\n      if (url.password) {\n        urlParts.auth += ':' + url.password;\n      }\n    }\n\n    // `file://` URLs has `'null'` origin\n    if (url.origin !== 'null') {\n      urlParts.hostname = url.hostname;\n    }\n\n    urlParts.protocol = url.protocol;\n    urlParts.port = url.port;\n  }\n\n  if (!urlParts.pathname) {\n    if (metadata.version === 4) {\n      // This is hard-coded in WDS v4\n      urlParts.pathname = '/ws';\n    } else {\n      // This is hard-coded in WDS v3\n      urlParts.pathname = '/sockjs-node';\n    }\n  }\n\n  // Check for IPv4 and IPv6 host addresses that correspond to any/empty.\n  // This is important because `hostname` can be empty for some hosts,\n  // such as 'about:blank' or 'file://' URLs.\n  const isEmptyHostname =\n    urlParts.hostname === '0.0.0.0' || urlParts.hostname === '[::]' || !urlParts.hostname;\n  // We only re-assign the hostname if it is empty,\n  // and if we are using HTTP/HTTPS protocols.\n  if (\n    isEmptyHostname &&\n    window.location.hostname &&\n    window.location.protocol.indexOf('http') === 0\n  ) {\n    urlParts.hostname = window.location.hostname;\n  }\n\n  // We only re-assign `protocol` when `protocol` is unavailable,\n  // or if `hostname` is available and is empty,\n  // since otherwise we risk creating an invalid URL.\n  // We also do this when 'https' is used as it mandates the use of secure sockets.\n  if (\n    !urlParts.protocol ||\n    (urlParts.hostname && (isEmptyHostname || window.location.protocol === 'https:'))\n  ) {\n    urlParts.protocol = window.location.protocol;\n  }\n\n  // We only re-assign port when it is not available\n  if (!urlParts.port) {\n    urlParts.port = window.location.port;\n  }\n\n  if (!urlParts.hostname || !urlParts.pathname) {\n    throw new Error(\n      [\n        '[React Refresh] Failed to get an URL for the socket connection.',\n        \"This usually means that the current executed script doesn't have a `src` attribute set.\",\n        'You should either specify the socket path parameters under the `devServer` key in your Webpack config, or use the `overlay` option.',\n        'https://github.com/pmmmwh/react-refresh-webpack-plugin/blob/main/docs/API.md#overlay',\n      ].join('\\n')\n    );\n  }\n\n  return {\n    auth: urlParts.auth,\n    hostname: urlParts.hostname,\n    pathname: urlParts.pathname,\n    protocol: urlParts.protocol,\n    port: urlParts.port || undefined,\n  };\n}\n\nmodule.exports = getSocketUrlParts;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}