{"ast":null,"code":"/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\nif (!global.jake) {\n  let EventEmitter = require('events').EventEmitter; // And so it begins\n\n\n  global.jake = new EventEmitter();\n\n  let fs = require('fs');\n\n  let chalk = require('chalk');\n\n  let taskNs = require('./task');\n\n  let Task = taskNs.Task;\n  let FileTask = taskNs.FileTask;\n  let DirectoryTask = taskNs.DirectoryTask;\n\n  let Rule = require('./rule').Rule;\n\n  let Namespace = require('./namespace').Namespace;\n\n  let RootNamespace = require('./namespace').RootNamespace;\n\n  let api = require('./api');\n\n  let utils = require('./utils');\n\n  let Program = require('./program').Program;\n\n  let loader = require('./loader')();\n\n  let pkg = JSON.parse(fs.readFileSync(__dirname + '/../package.json').toString());\n  const MAX_RULE_RECURSION_LEVEL = 16; // Globalize jake and top-level API methods (e.g., `task`, `desc`)\n\n  Object.assign(global, api); // Copy utils onto base jake\n\n  jake.logger = utils.logger;\n  jake.exec = utils.exec; // File utils should be aliased directly on base jake as well\n\n  Object.assign(jake, utils.file); // Also add top-level API methods to exported object for those who don't want to\n  // use the globals (`file` here will overwrite the 'file' utils namespace)\n\n  Object.assign(jake, api);\n  Object.assign(jake, new function () {\n    this._invocationChain = [];\n    this._taskTimeout = 30000; // Public properties\n    // =================\n\n    this.version = pkg.version; // Used when Jake exits with a specific error-code\n\n    this.errorCode = null; // Loads Jakefiles/jakelibdirs\n\n    this.loader = loader; // The root of all ... namespaces\n\n    this.rootNamespace = new RootNamespace(); // Non-namespaced tasks are placed into the default\n\n    this.defaultNamespace = this.rootNamespace; // Start in the default\n\n    this.currentNamespace = this.defaultNamespace; // Saves the description created by a 'desc' call that prefaces a\n    // 'task' call that defines a task.\n\n    this.currentTaskDescription = null;\n    this.program = new Program();\n    this.FileList = require('filelist').FileList;\n    this.PackageTask = require('./package_task').PackageTask;\n    this.PublishTask = require('./publish_task').PublishTask;\n    this.TestTask = require('./test_task').TestTask;\n    this.Task = Task;\n    this.FileTask = FileTask;\n    this.DirectoryTask = DirectoryTask;\n    this.Namespace = Namespace;\n    this.Rule = Rule;\n\n    this.parseAllTasks = function () {\n      let _parseNs = function (ns) {\n        let nsTasks = ns.tasks;\n        let nsNamespaces = ns.childNamespaces;\n\n        for (let q in nsTasks) {\n          let nsTask = nsTasks[q];\n          jake.Task[nsTask.fullName] = nsTask;\n        }\n\n        for (let p in nsNamespaces) {\n          let nsNamespace = nsNamespaces[p];\n\n          _parseNs(nsNamespace);\n        }\n      };\n\n      _parseNs(jake.defaultNamespace);\n    };\n    /**\n     * Displays the list of descriptions available for tasks defined in\n     * a Jakefile\n     */\n\n\n    this.showAllTaskDescriptions = function (f) {\n      let p;\n      let maxTaskNameLength = 0;\n      let task;\n      let padding;\n      let name;\n      let descr;\n      let filter = typeof f == 'string' ? f : null;\n      let taskParams;\n      let len;\n\n      for (p in jake.Task) {\n        if (!Object.prototype.hasOwnProperty.call(jake.Task, p)) {\n          continue;\n        }\n\n        if (filter && p.indexOf(filter) == -1) {\n          continue;\n        }\n\n        task = jake.Task[p];\n        taskParams = task.params; // Record the length of the longest task name -- used for\n        // pretty alignment of the task descriptions\n\n        if (task.description) {\n          len = p.length + taskParams.length;\n          maxTaskNameLength = len > maxTaskNameLength ? len : maxTaskNameLength;\n        }\n      } // Print out each entry with descriptions neatly aligned\n\n\n      for (p in jake.Task) {\n        if (!Object.prototype.hasOwnProperty.call(jake.Task, p)) {\n          continue;\n        }\n\n        if (filter && p.indexOf(filter) == -1) {\n          continue;\n        }\n\n        task = jake.Task[p];\n        taskParams = \"\";\n\n        if (task.params != \"\") {\n          taskParams = \"[\" + task.params + \"]\";\n        } //name = '\\033[32m' + p + '\\033[39m ';\n\n\n        name = chalk.green(p);\n        descr = task.description;\n\n        if (descr) {\n          descr = chalk.gray('# ' + descr); // Create padding-string with calculated length\n\n          padding = new Array(maxTaskNameLength - p.length - taskParams.length + 4).join(' ');\n          console.log('jake ' + name + taskParams + padding + descr);\n        }\n      }\n    };\n\n    this.createTask = function () {\n      let args = Array.prototype.slice.call(arguments);\n      let arg;\n      let obj;\n      let task;\n      let type;\n      let name;\n      let action;\n      let opts = {};\n      let prereqs = [];\n      type = args.shift(); // name, [deps], [action]\n      // Name (string) + deps (array) format\n\n      if (typeof args[0] == 'string') {\n        name = args.shift();\n\n        if (Array.isArray(args[0])) {\n          prereqs = args.shift();\n        }\n      } // name:deps, [action]\n      // Legacy object-literal syntax, e.g.: {'name': ['depA', 'depB']}\n      else {\n        obj = args.shift();\n\n        for (let p in obj) {\n          prereqs = prereqs.concat(obj[p]);\n          name = p;\n        }\n      } // Optional opts/callback or callback/opts\n\n\n      while (arg = args.shift()) {\n        if (typeof arg == 'function') {\n          action = arg;\n        } else {\n          opts = Object.assign(Object.create(null), arg);\n        }\n      }\n\n      task = jake.currentNamespace.resolveTask(name);\n\n      if (task && !action) {\n        // Task already exists and no action, just update prereqs, and return it.\n        task.prereqs = task.prereqs.concat(prereqs);\n        return task;\n      }\n\n      switch (type) {\n        case 'directory':\n          action = function () {\n            jake.mkdirP(name);\n          };\n\n          task = new DirectoryTask(name, prereqs, action, opts);\n          break;\n\n        case 'file':\n          task = new FileTask(name, prereqs, action, opts);\n          break;\n\n        default:\n          task = new Task(name, prereqs, action, opts);\n      }\n\n      jake.currentNamespace.addTask(task);\n\n      if (jake.currentTaskDescription) {\n        task.description = jake.currentTaskDescription;\n        jake.currentTaskDescription = null;\n      } // FIXME: Should only need to add a new entry for the current\n      // task-definition, not reparse the entire structure\n\n\n      jake.parseAllTasks();\n      return task;\n    };\n\n    this.attemptRule = function (name, ns, level) {\n      let prereqRule;\n      let prereq;\n\n      if (level > MAX_RULE_RECURSION_LEVEL) {\n        return null;\n      } // Check Rule\n\n\n      prereqRule = ns.matchRule(name);\n\n      if (prereqRule) {\n        prereq = prereqRule.createTask(name, level);\n      }\n\n      return prereq || null;\n    };\n\n    this.createPlaceholderFileTask = function (name, namespace) {\n      let parsed = name.split(':');\n      let filePath = parsed.pop(); // Strip any namespace\n\n      let task;\n      task = namespace.resolveTask(name); // If there's not already an existing dummy FileTask for it,\n      // create one\n\n      if (!task) {\n        // Create a dummy FileTask only if file actually exists\n        if (fs.existsSync(filePath)) {\n          task = new jake.FileTask(filePath);\n          task.dummy = true;\n          let ns;\n\n          if (parsed.length) {\n            ns = namespace.resolveNamespace(parsed.join(':'));\n          } else {\n            ns = namespace;\n          }\n\n          if (!namespace) {\n            throw new Error('Invalid namespace, cannot add FileTask');\n          }\n\n          ns.addTask(task); // Put this dummy Task in the global Tasks list so\n          // modTime will be eval'd correctly\n\n          jake.Task[`${ns.path}:${filePath}`] = task;\n        }\n      }\n\n      return task || null;\n    };\n\n    this.run = function () {\n      let args = Array.prototype.slice.call(arguments);\n      let program = this.program;\n      let loader = this.loader;\n      let preempt;\n      let opts;\n      program.parseArgs(args);\n      program.init();\n      preempt = program.firstPreemptiveOption();\n\n      if (preempt) {\n        preempt();\n      } else {\n        opts = program.opts; // jakefile flag set but no jakefile yet\n\n        if (opts.autocomplete && opts.jakefile === true) {\n          process.stdout.write('no-complete');\n          return;\n        } // Load Jakefile and jakelibdir files\n\n\n        let jakefileLoaded = loader.loadFile(opts.jakefile);\n        let jakelibdirLoaded = loader.loadDirectory(opts.jakelibdir);\n\n        if (!jakefileLoaded && !jakelibdirLoaded && !opts.autocomplete) {\n          fail('No Jakefile. Specify a valid path with -f/--jakefile, ' + 'or place one in the current directory.');\n        }\n\n        program.run();\n      }\n    };\n  }());\n}\n\nmodule.exports = jake;","map":{"version":3,"names":["global","jake","EventEmitter","require","fs","chalk","taskNs","Task","FileTask","DirectoryTask","Rule","Namespace","RootNamespace","api","utils","Program","loader","pkg","JSON","parse","readFileSync","__dirname","toString","MAX_RULE_RECURSION_LEVEL","Object","assign","logger","exec","file","_invocationChain","_taskTimeout","version","errorCode","rootNamespace","defaultNamespace","currentNamespace","currentTaskDescription","program","FileList","PackageTask","PublishTask","TestTask","parseAllTasks","_parseNs","ns","nsTasks","tasks","nsNamespaces","childNamespaces","q","nsTask","fullName","p","nsNamespace","showAllTaskDescriptions","f","maxTaskNameLength","task","padding","name","descr","filter","taskParams","len","prototype","hasOwnProperty","call","indexOf","params","description","length","green","gray","Array","join","console","log","createTask","args","slice","arguments","arg","obj","type","action","opts","prereqs","shift","isArray","concat","create","resolveTask","mkdirP","addTask","attemptRule","level","prereqRule","prereq","matchRule","createPlaceholderFileTask","namespace","parsed","split","filePath","pop","existsSync","dummy","resolveNamespace","Error","path","run","preempt","parseArgs","init","firstPreemptiveOption","autocomplete","jakefile","process","stdout","write","jakefileLoaded","loadFile","jakelibdirLoaded","loadDirectory","jakelibdir","fail","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jake/lib/jake.js"],"sourcesContent":["/*\n * Jake JavaScript build tool\n * Copyright 2112 Matthew Eernisse (mde@fleegix.org)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n*/\n\nif (!global.jake) {\n\n  let EventEmitter = require('events').EventEmitter;\n  // And so it begins\n  global.jake = new EventEmitter();\n\n  let fs = require('fs');\n  let chalk = require('chalk');\n  let taskNs = require('./task');\n  let Task = taskNs.Task;\n  let FileTask = taskNs.FileTask;\n  let DirectoryTask = taskNs.DirectoryTask;\n  let Rule = require('./rule').Rule;\n  let Namespace = require('./namespace').Namespace;\n  let RootNamespace = require('./namespace').RootNamespace;\n  let api = require('./api');\n  let utils = require('./utils');\n  let Program = require('./program').Program;\n  let loader = require('./loader')();\n  let pkg = JSON.parse(fs.readFileSync(__dirname + '/../package.json').toString());\n\n  const MAX_RULE_RECURSION_LEVEL = 16;\n\n  // Globalize jake and top-level API methods (e.g., `task`, `desc`)\n  Object.assign(global, api);\n\n  // Copy utils onto base jake\n  jake.logger = utils.logger;\n  jake.exec = utils.exec;\n\n  // File utils should be aliased directly on base jake as well\n  Object.assign(jake, utils.file);\n\n  // Also add top-level API methods to exported object for those who don't want to\n  // use the globals (`file` here will overwrite the 'file' utils namespace)\n  Object.assign(jake, api);\n\n  Object.assign(jake, new (function () {\n\n    this._invocationChain = [];\n    this._taskTimeout = 30000;\n\n    // Public properties\n    // =================\n    this.version = pkg.version;\n    // Used when Jake exits with a specific error-code\n    this.errorCode = null;\n    // Loads Jakefiles/jakelibdirs\n    this.loader = loader;\n    // The root of all ... namespaces\n    this.rootNamespace = new RootNamespace();\n    // Non-namespaced tasks are placed into the default\n    this.defaultNamespace = this.rootNamespace;\n    // Start in the default\n    this.currentNamespace = this.defaultNamespace;\n    // Saves the description created by a 'desc' call that prefaces a\n    // 'task' call that defines a task.\n    this.currentTaskDescription = null;\n    this.program = new Program();\n    this.FileList = require('filelist').FileList;\n    this.PackageTask = require('./package_task').PackageTask;\n    this.PublishTask = require('./publish_task').PublishTask;\n    this.TestTask = require('./test_task').TestTask;\n    this.Task = Task;\n    this.FileTask = FileTask;\n    this.DirectoryTask = DirectoryTask;\n    this.Namespace = Namespace;\n    this.Rule = Rule;\n\n    this.parseAllTasks = function () {\n      let _parseNs = function (ns) {\n        let nsTasks = ns.tasks;\n        let nsNamespaces = ns.childNamespaces;\n        for (let q in nsTasks) {\n          let nsTask = nsTasks[q];\n          jake.Task[nsTask.fullName] = nsTask;\n        }\n        for (let p in nsNamespaces) {\n          let nsNamespace = nsNamespaces[p];\n          _parseNs(nsNamespace);\n        }\n      };\n      _parseNs(jake.defaultNamespace);\n    };\n\n    /**\n     * Displays the list of descriptions available for tasks defined in\n     * a Jakefile\n     */\n    this.showAllTaskDescriptions = function (f) {\n      let p;\n      let maxTaskNameLength = 0;\n      let task;\n      let padding;\n      let name;\n      let descr;\n      let filter = typeof f == 'string' ? f : null;\n      let taskParams;\n      let len;\n\n      for (p in jake.Task) {\n        if (!Object.prototype.hasOwnProperty.call(jake.Task, p)) {\n          continue;\n        }\n        if (filter && p.indexOf(filter) == -1) {\n          continue;\n        }\n        task = jake.Task[p];\n        taskParams = task.params;\n\n        // Record the length of the longest task name -- used for\n        // pretty alignment of the task descriptions\n        if (task.description) {\n          len = p.length + taskParams.length;\n          maxTaskNameLength = len > maxTaskNameLength ?\n            len : maxTaskNameLength;\n        }\n      }\n\n      // Print out each entry with descriptions neatly aligned\n      for (p in jake.Task) {\n        if (!Object.prototype.hasOwnProperty.call(jake.Task, p)) {\n          continue;\n        }\n        if (filter && p.indexOf(filter) == -1) {\n          continue;\n        }\n        task = jake.Task[p];\n\n        taskParams = \"\";\n        if (task.params != \"\") {\n          taskParams = \"[\" + task.params + \"]\";\n        }\n\n        //name = '\\033[32m' + p + '\\033[39m ';\n        name = chalk.green(p);\n\n        descr = task.description;\n        if (descr) {\n          descr = chalk.gray('# ' + descr);\n\n          // Create padding-string with calculated length\n          padding = (new Array(maxTaskNameLength - p.length - taskParams.length + 4)).join(' ');\n\n          console.log('jake ' + name + taskParams + padding + descr);\n        }\n      }\n    };\n\n    this.createTask = function () {\n      let args = Array.prototype.slice.call(arguments);\n      let arg;\n      let obj;\n      let task;\n      let type;\n      let name;\n      let action;\n      let opts = {};\n      let prereqs = [];\n\n      type = args.shift();\n\n      // name, [deps], [action]\n      // Name (string) + deps (array) format\n      if (typeof args[0] == 'string') {\n        name = args.shift();\n        if (Array.isArray(args[0])) {\n          prereqs = args.shift();\n        }\n      }\n      // name:deps, [action]\n      // Legacy object-literal syntax, e.g.: {'name': ['depA', 'depB']}\n      else {\n        obj = args.shift();\n        for (let p in obj) {\n          prereqs = prereqs.concat(obj[p]);\n          name = p;\n        }\n      }\n\n      // Optional opts/callback or callback/opts\n      while ((arg = args.shift())) {\n        if (typeof arg == 'function') {\n          action = arg;\n        }\n        else {\n          opts = Object.assign(Object.create(null), arg);\n        }\n      }\n\n      task = jake.currentNamespace.resolveTask(name);\n      if (task && !action) {\n        // Task already exists and no action, just update prereqs, and return it.\n        task.prereqs = task.prereqs.concat(prereqs);\n        return task;\n      }\n\n      switch (type) {\n      case 'directory':\n        action = function () {\n          jake.mkdirP(name);\n        };\n        task = new DirectoryTask(name, prereqs, action, opts);\n        break;\n      case 'file':\n        task = new FileTask(name, prereqs, action, opts);\n        break;\n      default:\n        task = new Task(name, prereqs, action, opts);\n      }\n\n      jake.currentNamespace.addTask(task);\n\n      if (jake.currentTaskDescription) {\n        task.description = jake.currentTaskDescription;\n        jake.currentTaskDescription = null;\n      }\n\n      // FIXME: Should only need to add a new entry for the current\n      // task-definition, not reparse the entire structure\n      jake.parseAllTasks();\n\n      return task;\n    };\n\n    this.attemptRule = function (name, ns, level) {\n      let prereqRule;\n      let prereq;\n      if (level > MAX_RULE_RECURSION_LEVEL) {\n        return null;\n      }\n      // Check Rule\n      prereqRule = ns.matchRule(name);\n      if (prereqRule) {\n        prereq = prereqRule.createTask(name, level);\n      }\n      return prereq || null;\n    };\n\n    this.createPlaceholderFileTask = function (name, namespace) {\n      let parsed = name.split(':');\n      let filePath = parsed.pop(); // Strip any namespace\n      let task;\n\n      task = namespace.resolveTask(name);\n\n      // If there's not already an existing dummy FileTask for it,\n      // create one\n      if (!task) {\n        // Create a dummy FileTask only if file actually exists\n        if (fs.existsSync(filePath)) {\n          task = new jake.FileTask(filePath);\n          task.dummy = true;\n          let ns;\n          if (parsed.length) {\n            ns = namespace.resolveNamespace(parsed.join(':'));\n          }\n          else {\n            ns = namespace;\n          }\n          if (!namespace) {\n            throw new Error('Invalid namespace, cannot add FileTask');\n          }\n          ns.addTask(task);\n          // Put this dummy Task in the global Tasks list so\n          // modTime will be eval'd correctly\n          jake.Task[`${ns.path}:${filePath}`] = task;\n        }\n      }\n\n      return task || null;\n    };\n\n\n    this.run = function () {\n      let args = Array.prototype.slice.call(arguments);\n      let program = this.program;\n      let loader = this.loader;\n      let preempt;\n      let opts;\n\n      program.parseArgs(args);\n      program.init();\n\n      preempt = program.firstPreemptiveOption();\n      if (preempt) {\n        preempt();\n      }\n      else {\n        opts = program.opts;\n        // jakefile flag set but no jakefile yet\n        if (opts.autocomplete && opts.jakefile === true) {\n          process.stdout.write('no-complete');\n          return;\n        }\n        // Load Jakefile and jakelibdir files\n        let jakefileLoaded = loader.loadFile(opts.jakefile);\n        let jakelibdirLoaded = loader.loadDirectory(opts.jakelibdir);\n\n        if(!jakefileLoaded && !jakelibdirLoaded && !opts.autocomplete) {\n          fail('No Jakefile. Specify a valid path with -f/--jakefile, ' +\n              'or place one in the current directory.');\n        }\n\n        program.run();\n      }\n    };\n\n  })());\n}\n\nmodule.exports = jake;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}