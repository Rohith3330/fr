{"ast":null,"code":"let valueParser = require('postcss-value-parser');\n\nfunction parseValue(value) {\n  let parsed = value.match(/([\\d.-]+)(.*)/);\n\n  if (!parsed || !parsed[1] || !parsed[2] || isNaN(parsed[1])) {\n    return undefined;\n  }\n\n  return [parseFloat(parsed[1]), parsed[2]];\n}\n\nfunction compose(first, second, third) {\n  if (first && second && third) {\n    return `max(${first}, min(${second}, ${third}))`;\n  }\n\n  if (first && second) {\n    return `max(${first}, ${second})`;\n  }\n\n  return first;\n}\n\nfunction updateValue(declaration, value, preserve) {\n  let newValue = value;\n  let newValueAst = valueParser(value);\n  let valueAST = valueParser(declaration.value); // Walk can't be interrupted, so we only care about first\n\n  let foundClamp = false;\n  valueAST.walk((node, index, nodes) => {\n    let isClamp = node.type === 'function' && node.value === 'clamp';\n\n    if (!isClamp || foundClamp) {\n      return;\n    }\n\n    foundClamp = true;\n    nodes[index] = newValueAst;\n  });\n\n  if (foundClamp) {\n    newValue = valueAST.toString();\n  }\n\n  if (preserve) {\n    declaration.cloneBefore({\n      value: newValue\n    });\n  } else {\n    declaration.value = newValue;\n  }\n}\n\nmodule.exports = opts => {\n  opts = opts || {};\n  let precalculate = opts.precalculate ? Boolean(opts.precalculate) : false;\n  let preserve = opts.preserve ? Boolean(opts.preserve) : false;\n  return {\n    postcssPlugin: 'postcss-clamp',\n\n    Declaration(decl) {\n      if (!decl || !decl.value.includes('clamp')) {\n        return;\n      }\n\n      valueParser(decl.value).walk(node => {\n        let nodes = node.nodes;\n\n        if (node.type !== 'function' || node.value !== 'clamp' || nodes.length !== 5) {\n          return;\n        }\n\n        let first = nodes[0];\n        let second = nodes[2];\n        let third = nodes[4];\n        let naive = compose(valueParser.stringify(first), valueParser.stringify(second), valueParser.stringify(third));\n\n        if (!precalculate || second.type !== 'word' || third.type !== 'word') {\n          updateValue(decl, naive, preserve);\n          return;\n        }\n\n        let parsedSecond = parseValue(second.value);\n        let parsedThird = parseValue(third.value);\n\n        if (parsedSecond === undefined || parsedThird === undefined) {\n          updateValue(decl, naive, preserve);\n          return;\n        }\n\n        let [secondValue, secondUnit] = parsedSecond;\n        let [thirdValue, thirdUnit] = parsedThird;\n\n        if (secondUnit !== thirdUnit) {\n          updateValue(decl, naive, preserve);\n          return;\n        }\n\n        let parsedFirst = parseValue(first.value);\n\n        if (parsedFirst === undefined) {\n          let secondThirdValue = `${secondValue + thirdValue}${secondUnit}`;\n          updateValue(decl, compose(valueParser.stringify(first), secondThirdValue), preserve);\n          return;\n        }\n\n        let [firstValue, firstUnit] = parsedFirst;\n\n        if (firstUnit !== secondUnit) {\n          let secondThirdValue = `${secondValue + thirdValue}${secondUnit}`;\n          updateValue(decl, compose(valueParser.stringify(first), secondThirdValue), preserve);\n          return;\n        }\n\n        updateValue(decl, compose(`${firstValue + secondValue + thirdValue}${secondUnit}`), preserve);\n      });\n    }\n\n  };\n};\n\nmodule.exports.postcss = true;","map":{"version":3,"names":["valueParser","require","parseValue","value","parsed","match","isNaN","undefined","parseFloat","compose","first","second","third","updateValue","declaration","preserve","newValue","newValueAst","valueAST","foundClamp","walk","node","index","nodes","isClamp","type","toString","cloneBefore","module","exports","opts","precalculate","Boolean","postcssPlugin","Declaration","decl","includes","length","naive","stringify","parsedSecond","parsedThird","secondValue","secondUnit","thirdValue","thirdUnit","parsedFirst","secondThirdValue","firstValue","firstUnit","postcss"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-clamp/index.js"],"sourcesContent":["let valueParser = require('postcss-value-parser')\n\nfunction parseValue (value) {\n  let parsed = value.match(/([\\d.-]+)(.*)/)\n  if (!parsed || !parsed[1] || !parsed[2] || isNaN(parsed[1])) {\n    return undefined\n  }\n  return [parseFloat(parsed[1]), parsed[2]]\n}\n\nfunction compose (first, second, third) {\n  if (first && second && third) {\n    return `max(${first}, min(${second}, ${third}))`\n  }\n  if (first && second) {\n    return `max(${first}, ${second})`\n  }\n\n  return first\n}\n\nfunction updateValue (declaration, value, preserve) {\n  let newValue = value\n  let newValueAst = valueParser(value)\n  let valueAST = valueParser(declaration.value)\n  // Walk can't be interrupted, so we only care about first\n  let foundClamp = false\n\n  valueAST.walk((node, index, nodes) => {\n    let isClamp = node.type === 'function' && node.value === 'clamp'\n\n    if (!isClamp || foundClamp) {\n      return\n    }\n\n    foundClamp = true\n    nodes[index] = newValueAst\n  })\n\n  if (foundClamp) {\n    newValue = valueAST.toString()\n  }\n\n  if (preserve) {\n    declaration.cloneBefore({ value: newValue })\n  } else {\n    declaration.value = newValue\n  }\n}\n\nmodule.exports = opts => {\n  opts = opts || {}\n  let precalculate = opts.precalculate ? Boolean(opts.precalculate) : false\n  let preserve = opts.preserve ? Boolean(opts.preserve) : false\n\n  return {\n    postcssPlugin: 'postcss-clamp',\n    Declaration (decl) {\n      if (!decl || !decl.value.includes('clamp')) {\n        return\n      }\n      valueParser(decl.value).walk(node => {\n        let nodes = node.nodes\n        if (\n          node.type !== 'function' ||\n          node.value !== 'clamp' ||\n          nodes.length !== 5\n        ) {\n          return\n        }\n        let first = nodes[0]\n        let second = nodes[2]\n        let third = nodes[4]\n        let naive = compose(\n          valueParser.stringify(first),\n          valueParser.stringify(second),\n          valueParser.stringify(third)\n        )\n        if (!precalculate || second.type !== 'word' || third.type !== 'word') {\n          updateValue(decl, naive, preserve)\n          return\n        }\n        let parsedSecond = parseValue(second.value)\n        let parsedThird = parseValue(third.value)\n        if (parsedSecond === undefined || parsedThird === undefined) {\n          updateValue(decl, naive, preserve)\n          return\n        }\n        let [secondValue, secondUnit] = parsedSecond\n        let [thirdValue, thirdUnit] = parsedThird\n        if (secondUnit !== thirdUnit) {\n          updateValue(decl, naive, preserve)\n          return\n        }\n        let parsedFirst = parseValue(first.value)\n        if (parsedFirst === undefined) {\n          let secondThirdValue = `${secondValue + thirdValue}${secondUnit}`\n          updateValue(\n            decl,\n            compose(valueParser.stringify(first), secondThirdValue),\n            preserve\n          )\n          return\n        }\n        let [firstValue, firstUnit] = parsedFirst\n        if (firstUnit !== secondUnit) {\n          let secondThirdValue = `${secondValue + thirdValue}${secondUnit}`\n          updateValue(\n            decl,\n            compose(valueParser.stringify(first), secondThirdValue),\n            preserve\n          )\n          return\n        }\n\n        updateValue(\n          decl,\n          compose(`${firstValue + secondValue + thirdValue}${secondUnit}`),\n          preserve\n        )\n      })\n    }\n  }\n}\n\nmodule.exports.postcss = true\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}