{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = remove;\n/* eslint-disable no-param-reassign */\n\nfunction isInside(scope, regex) {\n  if (!scope.hub.file.opts) {\n    return true;\n  }\n\n  var filename = scope.hub.file.opts.filename;\n\n  if (!filename) {\n    return true;\n  }\n\n  if (!regex) {\n    return false;\n  }\n\n  return regex.test(filename);\n} // Remove a specific path.\n\n\nfunction remove(path, globalOptions, options) {\n  var visitedKey = globalOptions.visitedKey,\n      unsafeWrapTemplate = globalOptions.unsafeWrapTemplate,\n      wrapTemplate = globalOptions.wrapTemplate,\n      mode = globalOptions.mode,\n      ignoreFilenames = globalOptions.ignoreFilenames,\n      types = globalOptions.types;\n\n  if (ignoreFilenames && isInside(path.scope, ignoreFilenames)) {\n    return;\n  } // Prevent infinity loop.\n\n\n  if (path.node[visitedKey]) {\n    return;\n  }\n\n  path.node[visitedKey] = true;\n\n  if (mode === 'remove') {\n    // remove() crash in some conditions.\n    if (path.parentPath.type === 'ConditionalExpression') {\n      path.replaceWith(types.unaryExpression('void', types.numericLiteral(0)));\n    } else {\n      path.remove();\n    }\n\n    return;\n  }\n\n  if (mode === 'wrap' || mode === 'unsafe-wrap') {\n    switch (options.type) {\n      // This is legacy, we do not optimize it.\n      case 'createClass':\n        break;\n      // Inspired from babel-plugin-transform-class-properties.\n\n      case 'class static':\n        {\n          var ref;\n          var pathClassDeclaration = options.pathClassDeclaration;\n\n          if (!pathClassDeclaration.isClassExpression() && pathClassDeclaration.node.id) {\n            ref = pathClassDeclaration.node.id;\n          } else {\n            // Class without name not supported\n            return;\n          }\n\n          var node = types.expressionStatement(types.assignmentExpression('=', types.memberExpression(ref, path.node.key), path.node.value)); // We need to append the node at the parent level in this case.\n\n          if (pathClassDeclaration.parentPath.isExportDeclaration()) {\n            pathClassDeclaration = pathClassDeclaration.parentPath;\n          }\n\n          pathClassDeclaration.insertAfter(node);\n          path.remove();\n          break;\n        }\n\n      case 'assign':\n        if (mode === 'unsafe-wrap') {\n          path.replaceWith(unsafeWrapTemplate({\n            NODE: path.node\n          }));\n        } else {\n          path.replaceWith(wrapTemplate({\n            LEFT: path.node.left,\n            RIGHT: path.node.right\n          }));\n        }\n\n        path.node[visitedKey] = true;\n        break;\n\n      case 'declarator':\n        path.replaceWith(wrapTemplate({\n          LEFT: path.node.id,\n          RIGHT: path.node.init\n        }, {\n          as: 'variableDeclarator'\n        }));\n        path.node[visitedKey] = true;\n        break;\n\n      default:\n        break;\n    }\n\n    return;\n  }\n\n  throw new Error(\"transform-react-remove-prop-type: unsupported mode \".concat(mode, \".\"));\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","remove","isInside","scope","regex","hub","file","opts","filename","test","path","globalOptions","options","visitedKey","unsafeWrapTemplate","wrapTemplate","mode","ignoreFilenames","types","node","parentPath","type","replaceWith","unaryExpression","numericLiteral","ref","pathClassDeclaration","isClassExpression","id","expressionStatement","assignmentExpression","memberExpression","key","isExportDeclaration","insertAfter","NODE","LEFT","left","RIGHT","right","init","as","Error","concat"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/babel-plugin-transform-react-remove-prop-types/lib/remove.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = remove;\n\n/* eslint-disable no-param-reassign */\nfunction isInside(scope, regex) {\n  if (!scope.hub.file.opts) {\n    return true;\n  }\n\n  var filename = scope.hub.file.opts.filename;\n\n  if (!filename) {\n    return true;\n  }\n\n  if (!regex) {\n    return false;\n  }\n\n  return regex.test(filename);\n} // Remove a specific path.\n\n\nfunction remove(path, globalOptions, options) {\n  var visitedKey = globalOptions.visitedKey,\n      unsafeWrapTemplate = globalOptions.unsafeWrapTemplate,\n      wrapTemplate = globalOptions.wrapTemplate,\n      mode = globalOptions.mode,\n      ignoreFilenames = globalOptions.ignoreFilenames,\n      types = globalOptions.types;\n\n  if (ignoreFilenames && isInside(path.scope, ignoreFilenames)) {\n    return;\n  } // Prevent infinity loop.\n\n\n  if (path.node[visitedKey]) {\n    return;\n  }\n\n  path.node[visitedKey] = true;\n\n  if (mode === 'remove') {\n    // remove() crash in some conditions.\n    if (path.parentPath.type === 'ConditionalExpression') {\n      path.replaceWith(types.unaryExpression('void', types.numericLiteral(0)));\n    } else {\n      path.remove();\n    }\n\n    return;\n  }\n\n  if (mode === 'wrap' || mode === 'unsafe-wrap') {\n    switch (options.type) {\n      // This is legacy, we do not optimize it.\n      case 'createClass':\n        break;\n      // Inspired from babel-plugin-transform-class-properties.\n\n      case 'class static':\n        {\n          var ref;\n          var pathClassDeclaration = options.pathClassDeclaration;\n\n          if (!pathClassDeclaration.isClassExpression() && pathClassDeclaration.node.id) {\n            ref = pathClassDeclaration.node.id;\n          } else {\n            // Class without name not supported\n            return;\n          }\n\n          var node = types.expressionStatement(types.assignmentExpression('=', types.memberExpression(ref, path.node.key), path.node.value)); // We need to append the node at the parent level in this case.\n\n          if (pathClassDeclaration.parentPath.isExportDeclaration()) {\n            pathClassDeclaration = pathClassDeclaration.parentPath;\n          }\n\n          pathClassDeclaration.insertAfter(node);\n          path.remove();\n          break;\n        }\n\n      case 'assign':\n        if (mode === 'unsafe-wrap') {\n          path.replaceWith(unsafeWrapTemplate({\n            NODE: path.node\n          }));\n        } else {\n          path.replaceWith(wrapTemplate({\n            LEFT: path.node.left,\n            RIGHT: path.node.right\n          }));\n        }\n\n        path.node[visitedKey] = true;\n        break;\n\n      case 'declarator':\n        path.replaceWith(wrapTemplate({\n          LEFT: path.node.id,\n          RIGHT: path.node.init\n        }, {\n          as: 'variableDeclarator'\n        }));\n        path.node[visitedKey] = true;\n        break;\n\n      default:\n        break;\n    }\n\n    return;\n  }\n\n  throw new Error(\"transform-react-remove-prop-type: unsupported mode \".concat(mode, \".\"));\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}