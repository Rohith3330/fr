{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nconst getLocation = node => {\n  return {\n    end: node.params[node.params.length - 1].loc.end,\n    start: node.params[0].loc.start\n  };\n};\n\nconst isOpeningParenToken = token => {\n  return token.value === '(' && token.type === 'Punctuator';\n};\n\nconst isClosingParenToken = token => {\n  return token.value === ')' && token.type === 'Punctuator';\n};\n\nvar _default = {\n  create(context) {\n    const asNeeded = context.options[0] === 'as-needed';\n    const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n    const sourceCode = context.getSourceCode(); // Determines whether a arrow function argument end with `)`\n    // eslint-disable-next-line complexity\n\n    const parens = node => {\n      const isAsync = node.async;\n      const firstTokenOfParam = sourceCode.getFirstToken(node, isAsync ? 1 : 0); // Remove the parenthesis around a parameter\n\n      const fixParamsWithParenthesis = fixer => {\n        const paramToken = sourceCode.getTokenAfter(firstTokenOfParam);\n        /*\n        * ES8 allows Trailing commas in function parameter lists and calls\n        * https://github.com/eslint/eslint/issues/8834\n        */\n\n        const closingParenToken = sourceCode.getTokenAfter(paramToken, isClosingParenToken);\n        const asyncToken = isAsync ? sourceCode.getTokenBefore(firstTokenOfParam) : null;\n        const shouldAddSpaceForAsync = asyncToken && asyncToken.range[1] === firstTokenOfParam.range[0];\n        return fixer.replaceTextRange([firstTokenOfParam.range[0], closingParenToken.range[1]], `${shouldAddSpaceForAsync ? ' ' : ''}${paramToken.value}`);\n      }; // Type parameters without an opening paren is always a parse error, and\n      // can therefore be safely ignored.\n\n\n      if (node.typeParameters) {\n        return;\n      } // Similarly, a predicate always requires parens just like a return type\n      // does, and therefore this case can also be safely ignored.\n\n\n      if (node.predicate) {\n        return;\n      } // \"as-needed\", { \"requireForBlockBody\": true }: x => x\n\n\n      if (requireForBlockBody && node.params.length === 1 && node.params[0].type === 'Identifier' && !node.params[0].typeAnnotation && node.body.type !== 'BlockStatement' && !node.returnType) {\n        if (isOpeningParenToken(firstTokenOfParam)) {\n          context.report({\n            fix: fixParamsWithParenthesis,\n            loc: getLocation(node),\n            messageId: 'unexpectedParensInline',\n            node\n          });\n        }\n\n        return;\n      }\n\n      if (requireForBlockBody && node.body.type === 'BlockStatement') {\n        if (!isOpeningParenToken(firstTokenOfParam)) {\n          context.report({\n            fix(fixer) {\n              return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n            },\n\n            loc: getLocation(node),\n            messageId: 'expectedParensBlock',\n            node\n          });\n        }\n\n        return;\n      } // \"as-needed\": x => x\n\n\n      if (asNeeded && node.params.length === 1 && node.params[0].type === 'Identifier' && !node.params[0].typeAnnotation && !node.returnType) {\n        if (isOpeningParenToken(firstTokenOfParam)) {\n          context.report({\n            fix: fixParamsWithParenthesis,\n            loc: getLocation(node),\n            messageId: 'unexpectedParens',\n            node\n          });\n        }\n\n        return;\n      }\n\n      if (firstTokenOfParam.type === 'Identifier') {\n        const after = sourceCode.getTokenAfter(firstTokenOfParam); // (x) => x\n\n        if (after.value !== ')') {\n          context.report({\n            fix(fixer) {\n              return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n            },\n\n            loc: getLocation(node),\n            messageId: 'expectedParens',\n            node\n          });\n        }\n      }\n    };\n\n    return {\n      ArrowFunctionExpression: parens\n    };\n  },\n\n  meta: {\n    docs: {\n      category: 'ECMAScript 6',\n      description: 'require parentheses around arrow function arguments',\n      recommended: false,\n      url: 'https://eslint.org/docs/rules/arrow-parens'\n    },\n    fixable: 'code',\n    messages: {\n      expectedParens: 'Expected parentheses around arrow function argument.',\n      expectedParensBlock: 'Expected parentheses around arrow function argument having a body with curly braces.',\n      unexpectedParens: 'Unexpected parentheses around single function argument.',\n      unexpectedParensInline: 'Unexpected parentheses around single function argument having a body with no curly braces.'\n    },\n    type: 'layout'\n  },\n  schema: [{\n    enum: ['always', 'as-needed']\n  }, {\n    additionalProperties: false,\n    properties: {\n      requireForBlockBody: {\n        default: false,\n        type: 'boolean'\n      }\n    },\n    type: 'object'\n  }]\n};\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","getLocation","node","end","params","length","loc","start","isOpeningParenToken","token","type","isClosingParenToken","_default","create","context","asNeeded","options","requireForBlockBody","sourceCode","getSourceCode","parens","isAsync","async","firstTokenOfParam","getFirstToken","fixParamsWithParenthesis","fixer","paramToken","getTokenAfter","closingParenToken","asyncToken","getTokenBefore","shouldAddSpaceForAsync","range","replaceTextRange","typeParameters","predicate","typeAnnotation","body","returnType","report","fix","messageId","replaceText","after","ArrowFunctionExpression","meta","docs","category","description","recommended","url","fixable","messages","expectedParens","expectedParensBlock","unexpectedParens","unexpectedParensInline","schema","enum","additionalProperties","properties","module"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-flowtype/dist/rules/arrowParens.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nconst getLocation = node => {\n  return {\n    end: node.params[node.params.length - 1].loc.end,\n    start: node.params[0].loc.start\n  };\n};\n\nconst isOpeningParenToken = token => {\n  return token.value === '(' && token.type === 'Punctuator';\n};\n\nconst isClosingParenToken = token => {\n  return token.value === ')' && token.type === 'Punctuator';\n};\n\nvar _default = {\n  create(context) {\n    const asNeeded = context.options[0] === 'as-needed';\n    const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n    const sourceCode = context.getSourceCode(); // Determines whether a arrow function argument end with `)`\n    // eslint-disable-next-line complexity\n\n    const parens = node => {\n      const isAsync = node.async;\n      const firstTokenOfParam = sourceCode.getFirstToken(node, isAsync ? 1 : 0); // Remove the parenthesis around a parameter\n\n      const fixParamsWithParenthesis = fixer => {\n        const paramToken = sourceCode.getTokenAfter(firstTokenOfParam);\n        /*\n        * ES8 allows Trailing commas in function parameter lists and calls\n        * https://github.com/eslint/eslint/issues/8834\n        */\n\n        const closingParenToken = sourceCode.getTokenAfter(paramToken, isClosingParenToken);\n        const asyncToken = isAsync ? sourceCode.getTokenBefore(firstTokenOfParam) : null;\n        const shouldAddSpaceForAsync = asyncToken && asyncToken.range[1] === firstTokenOfParam.range[0];\n        return fixer.replaceTextRange([firstTokenOfParam.range[0], closingParenToken.range[1]], `${shouldAddSpaceForAsync ? ' ' : ''}${paramToken.value}`);\n      }; // Type parameters without an opening paren is always a parse error, and\n      // can therefore be safely ignored.\n\n\n      if (node.typeParameters) {\n        return;\n      } // Similarly, a predicate always requires parens just like a return type\n      // does, and therefore this case can also be safely ignored.\n\n\n      if (node.predicate) {\n        return;\n      } // \"as-needed\", { \"requireForBlockBody\": true }: x => x\n\n\n      if (requireForBlockBody && node.params.length === 1 && node.params[0].type === 'Identifier' && !node.params[0].typeAnnotation && node.body.type !== 'BlockStatement' && !node.returnType) {\n        if (isOpeningParenToken(firstTokenOfParam)) {\n          context.report({\n            fix: fixParamsWithParenthesis,\n            loc: getLocation(node),\n            messageId: 'unexpectedParensInline',\n            node\n          });\n        }\n\n        return;\n      }\n\n      if (requireForBlockBody && node.body.type === 'BlockStatement') {\n        if (!isOpeningParenToken(firstTokenOfParam)) {\n          context.report({\n            fix(fixer) {\n              return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n            },\n\n            loc: getLocation(node),\n            messageId: 'expectedParensBlock',\n            node\n          });\n        }\n\n        return;\n      } // \"as-needed\": x => x\n\n\n      if (asNeeded && node.params.length === 1 && node.params[0].type === 'Identifier' && !node.params[0].typeAnnotation && !node.returnType) {\n        if (isOpeningParenToken(firstTokenOfParam)) {\n          context.report({\n            fix: fixParamsWithParenthesis,\n            loc: getLocation(node),\n            messageId: 'unexpectedParens',\n            node\n          });\n        }\n\n        return;\n      }\n\n      if (firstTokenOfParam.type === 'Identifier') {\n        const after = sourceCode.getTokenAfter(firstTokenOfParam); // (x) => x\n\n        if (after.value !== ')') {\n          context.report({\n            fix(fixer) {\n              return fixer.replaceText(firstTokenOfParam, `(${firstTokenOfParam.value})`);\n            },\n\n            loc: getLocation(node),\n            messageId: 'expectedParens',\n            node\n          });\n        }\n      }\n    };\n\n    return {\n      ArrowFunctionExpression: parens\n    };\n  },\n\n  meta: {\n    docs: {\n      category: 'ECMAScript 6',\n      description: 'require parentheses around arrow function arguments',\n      recommended: false,\n      url: 'https://eslint.org/docs/rules/arrow-parens'\n    },\n    fixable: 'code',\n    messages: {\n      expectedParens: 'Expected parentheses around arrow function argument.',\n      expectedParensBlock: 'Expected parentheses around arrow function argument having a body with curly braces.',\n      unexpectedParens: 'Unexpected parentheses around single function argument.',\n      unexpectedParensInline: 'Unexpected parentheses around single function argument having a body with no curly braces.'\n    },\n    type: 'layout'\n  },\n  schema: [{\n    enum: ['always', 'as-needed']\n  }, {\n    additionalProperties: false,\n    properties: {\n      requireForBlockBody: {\n        default: false,\n        type: 'boolean'\n      }\n    },\n    type: 'object'\n  }]\n};\nexports.default = _default;\nmodule.exports = exports.default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}