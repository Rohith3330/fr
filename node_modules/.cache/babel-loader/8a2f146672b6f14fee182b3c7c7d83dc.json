{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst scope_manager_1 = require(\"@typescript-eslint/scope-manager\");\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst util = __importStar(require(\"../util\"));\n\nfunction hasAssignmentBeforeNode(variable, node) {\n  return variable.references.some(ref => ref.isWrite() && ref.identifier.range[1] < node.range[1]) || variable.defs.some(def => isDefinitionWithAssignment(def) && def.node.range[1] < node.range[1]);\n}\n\nfunction isDefinitionWithAssignment(definition) {\n  if (definition.type !== scope_manager_1.DefinitionType.Variable) {\n    return false;\n  }\n\n  const variableDeclarator = definition.node;\n  return variableDeclarator.definite === true || variableDeclarator.init !== null;\n}\n\nexports.default = util.createRule({\n  name: 'no-non-null-asserted-nullish-coalescing',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow non-null assertions in the left operand of a nullish coalescing operator',\n      recommended: 'strict'\n    },\n    messages: {\n      noNonNullAssertedNullishCoalescing: 'The nullish coalescing operator is designed to handle undefined and null - using a non-null assertion is not needed.',\n      suggestRemovingNonNull: 'Remove the non-null assertion.'\n    },\n    schema: [],\n    hasSuggestions: true\n  },\n  defaultOptions: [],\n\n  create(context) {\n    return {\n      'LogicalExpression[operator = \"??\"] > TSNonNullExpression.left'(node) {\n        if (node.expression.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier) {\n          const scope = context.getScope();\n          const identifier = node.expression;\n          const variable = utils_1.ASTUtils.findVariable(scope, identifier.name);\n\n          if (variable && !hasAssignmentBeforeNode(variable, node)) {\n            return;\n          }\n        }\n\n        const sourceCode = context.getSourceCode();\n        context.report({\n          node,\n          messageId: 'noNonNullAssertedNullishCoalescing',\n\n          /*\n          Use a suggestion instead of a fixer, because this can break type checks.\n          The resulting type of the nullish coalesce is only influenced by the right operand if the left operand can be `null` or `undefined`.\n          After removing the non-null assertion the type of the left operand might contain `null` or `undefined` and then the type of the right operand\n          might change the resulting type of the nullish coalesce.\n          See the following example:\n                     function test(x?: string): string {\n            const bar = x! ?? false; // type analysis reports `bar` has type `string`\n            //          x  ?? false; // type analysis reports `bar` has type `string | false`\n            return bar;\n          }\n          */\n          suggest: [{\n            messageId: 'suggestRemovingNonNull',\n\n            fix(fixer) {\n              const exclamationMark = util.nullThrows(sourceCode.getLastToken(node, utils_1.ASTUtils.isNonNullAssertionPunctuator), util.NullThrowsReasons.MissingToken('!', 'Non-null Assertion'));\n              return fixer.remove(exclamationMark);\n            }\n\n          }]\n        });\n      }\n\n    };\n  }\n\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AAEA;;AAEA;;AAEA,SAASA,uBAAT,CACEC,QADF,EAEEC,IAFF,EAEqB;EAEnB,OACED,QAAQ,CAACE,UAAT,CAAoBC,IAApB,CACEC,GAAG,IAAIA,GAAG,CAACC,OAAJ,MAAiBD,GAAG,CAACE,UAAJ,CAAeC,KAAf,CAAqB,CAArB,IAA0BN,IAAI,CAACM,KAAL,CAAW,CAAX,CADpD,KAGAP,QAAQ,CAACQ,IAAT,CAAcL,IAAd,CACEM,GAAG,IACDC,0BAA0B,CAACD,GAAD,CAA1B,IAAmCA,GAAG,CAACR,IAAJ,CAASM,KAAT,CAAe,CAAf,IAAoBN,IAAI,CAACM,KAAL,CAAW,CAAX,CAF3D,CAJF;AASD;;AAED,SAASG,0BAAT,CAAoCC,UAApC,EAA0D;EACxD,IAAIA,UAAU,CAACC,IAAX,KAAoBC,+BAAeC,QAAvC,EAAiD;IAC/C,OAAO,KAAP;EACD;;EAED,MAAMC,kBAAkB,GAAGJ,UAAU,CAACV,IAAtC;EACA,OACEc,kBAAkB,CAACC,QAAnB,KAAgC,IAAhC,IAAwCD,kBAAkB,CAACE,IAAnB,KAA4B,IADtE;AAGD;;AAEDC,kBAAeC,IAAI,CAACC,UAAL,CAAgB;EAC7BC,IAAI,EAAE,yCADuB;EAE7BC,IAAI,EAAE;IACJV,IAAI,EAAE,SADF;IAEJW,IAAI,EAAE;MACJC,WAAW,EACT,mFAFE;MAGJC,WAAW,EAAE;IAHT,CAFF;IAOJC,QAAQ,EAAE;MACRC,kCAAkC,EAChC,sHAFM;MAGRC,sBAAsB,EAAE;IAHhB,CAPN;IAYJC,MAAM,EAAE,EAZJ;IAaJC,cAAc,EAAE;EAbZ,CAFuB;EAiB7BC,cAAc,EAAE,EAjBa;;EAkB7BC,MAAM,CAACC,OAAD,EAAQ;IACZ,OAAO;MACL,gEACEhC,IADF,EACoC;QAElC,IAAIA,IAAI,CAACiC,UAAL,CAAgBtB,IAAhB,KAAyBuB,iBAASC,cAAT,CAAwBC,UAArD,EAAiE;UAC/D,MAAMC,KAAK,GAAGL,OAAO,CAACM,QAAR,EAAd;UACA,MAAMjC,UAAU,GAAGL,IAAI,CAACiC,UAAxB;UACA,MAAMlC,QAAQ,GAAGmC,iBAASK,YAAT,CAAsBF,KAAtB,EAA6BhC,UAAU,CAACe,IAAxC,CAAjB;;UACA,IAAIrB,QAAQ,IAAI,CAACD,uBAAuB,CAACC,QAAD,EAAWC,IAAX,CAAxC,EAA0D;YACxD;UACD;QACF;;QAED,MAAMwC,UAAU,GAAGR,OAAO,CAACS,aAAR,EAAnB;QAEAT,OAAO,CAACU,MAAR,CAAe;UACb1C,IADa;UAEb2C,SAAS,EAAE,oCAFE;;UAGb;;;;;;;;;;;;UAaAC,OAAO,EAAE,CACP;YACED,SAAS,EAAE,wBADb;;YAEEE,GAAG,CAACC,KAAD,EAAM;cACP,MAAMC,eAAe,GAAG7B,IAAI,CAAC8B,UAAL,CACtBR,UAAU,CAACS,YAAX,CACEjD,IADF,EAEEkC,iBAASgB,4BAFX,CADsB,EAKtBhC,IAAI,CAACiC,iBAAL,CAAuBC,YAAvB,CACE,GADF,EAEE,oBAFF,CALsB,CAAxB;cAUA,OAAON,KAAK,CAACO,MAAN,CAAaN,eAAb,CAAP;YACD;;UAdH,CADO;QAhBI,CAAf;MAmCD;;IAlDI,CAAP;EAoDD;;AAvE4B,CAAhB,CAAf","names":["hasAssignmentBeforeNode","variable","node","references","some","ref","isWrite","identifier","range","defs","def","isDefinitionWithAssignment","definition","type","scope_manager_1","Variable","variableDeclarator","definite","init","exports","util","createRule","name","meta","docs","description","recommended","messages","noNonNullAssertedNullishCoalescing","suggestRemovingNonNull","schema","hasSuggestions","defaultOptions","create","context","expression","utils_1","AST_NODE_TYPES","Identifier","scope","getScope","findVariable","sourceCode","getSourceCode","report","messageId","suggest","fix","fixer","exclamationMark","nullThrows","getLastToken","isNonNullAssertionPunctuator","NullThrowsReasons","MissingToken","remove"],"sources":["../../src/rules/no-non-null-asserted-nullish-coalescing.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}