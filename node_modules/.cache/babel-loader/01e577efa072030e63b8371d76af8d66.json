{"ast":null,"code":"/*\n  @license\n\tRollup.js v2.79.0\n\tWed, 31 Aug 2022 04:52:13 GMT - commit 8477f8ff1fe80086556021542b22942ad27a0a69\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\n'use strict';\n\nObject.defineProperty(exports, Symbol.toStringTag, {\n  value: 'Module'\n});\n\nconst require$$0$2 = require('fs');\n\nconst process$2 = require('process');\n\nconst index = require('./index.js');\n\nconst cli = require('../bin/rollup');\n\nconst rollup = require('./rollup.js');\n\nconst require$$0 = require('assert');\n\nconst require$$0$1 = require('events');\n\nconst loadConfigFile_js = require('./loadConfigFile.js');\n\nconst child_process = require('child_process');\n\nrequire('util');\n\nrequire('stream');\n\nrequire('path');\n\nrequire('os');\n\nrequire('./mergeOptions.js');\n\nrequire('perf_hooks');\n\nrequire('crypto');\n\nrequire('url');\n\nrequire('tty');\n\nfunction timeZone() {\n  let date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n  const offset = date.getTimezoneOffset();\n  const absOffset = Math.abs(offset);\n  const hours = Math.floor(absOffset / 60);\n  const minutes = absOffset % 60;\n  const minutesOut = minutes > 0 ? ':' + ('0' + minutes).slice(-2) : '';\n  return (offset < 0 ? '+' : '-') + hours + minutesOut;\n}\n\nfunction dateTime() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let {\n    date = new Date(),\n    local = true,\n    showTimeZone = false,\n    showMilliseconds = false\n  } = options;\n\n  if (local) {\n    // Offset the date so it will return the correct value when getting the ISO string.\n    date = new Date(date.getTime() - date.getTimezoneOffset() * 60000);\n  }\n\n  let end = '';\n\n  if (showTimeZone) {\n    end = ' UTC' + (local ? timeZone(date) : '');\n  }\n\n  if (showMilliseconds && date.getUTCMilliseconds() > 0) {\n    end = ` ${date.getUTCMilliseconds()}ms${end}`;\n  }\n\n  return date.toISOString().replace(/T/, ' ').replace(/\\..+/, end);\n}\n\nvar signalExit = {\n  exports: {}\n};\nvar signals$1 = {\n  exports: {}\n};\nvar hasRequiredSignals;\n\nfunction requireSignals() {\n  if (hasRequiredSignals) return signals$1.exports;\n  hasRequiredSignals = 1;\n\n  (function (module) {\n    // This is not the set of all possible signals.\n    //\n    // It IS, however, the set of all signals that trigger\n    // an exit on either Linux or BSD systems.  Linux is a\n    // superset of the signal names supported on BSD, and\n    // the unknown signals just fail to register, so we can\n    // catch that easily enough.\n    //\n    // Don't bother with SIGKILL.  It's uncatchable, which\n    // means that we can't fire any callbacks anyway.\n    //\n    // If a user does happen to register a handler on a non-\n    // fatal signal like SIGWINCH or something, and then\n    // exit, it'll end up firing `process.emit('exit')`, so\n    // the handler will be fired anyway.\n    //\n    // SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n    // artificially, inherently leave the process in a\n    // state from which it is not safe to try and enter JS\n    // listeners.\n    module.exports = ['SIGABRT', 'SIGALRM', 'SIGHUP', 'SIGINT', 'SIGTERM'];\n\n    if (process.platform !== 'win32') {\n      module.exports.push('SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT' // should detect profiler and enable/disable accordingly.\n      // see #21\n      // 'SIGPROF'\n      );\n    }\n\n    if (process.platform === 'linux') {\n      module.exports.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT', 'SIGUNUSED');\n    }\n  })(signals$1);\n\n  return signals$1.exports;\n} // Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\n\n\nvar process$1 = rollup.commonjsGlobal.process;\n\nconst processOk = function (process) {\n  return process && typeof process === 'object' && typeof process.removeListener === 'function' && typeof process.emit === 'function' && typeof process.reallyExit === 'function' && typeof process.listeners === 'function' && typeof process.kill === 'function' && typeof process.pid === 'number' && typeof process.on === 'function';\n}; // some kind of non-node environment, just no-op\n\n/* istanbul ignore if */\n\n\nif (!processOk(process$1)) {\n  signalExit.exports = function () {\n    return function () {};\n  };\n} else {\n  var assert = require$$0;\n  var signals = requireSignals();\n  var isWin = /^win/i.test(process$1.platform);\n  var EE = require$$0$1;\n  /* istanbul ignore if */\n\n  if (typeof EE !== 'function') {\n    EE = EE.EventEmitter;\n  }\n\n  var emitter;\n\n  if (process$1.__signal_exit_emitter__) {\n    emitter = process$1.__signal_exit_emitter__;\n  } else {\n    emitter = process$1.__signal_exit_emitter__ = new EE();\n    emitter.count = 0;\n    emitter.emitted = {};\n  } // Because this emitter is a global, we have to check to see if a\n  // previous version of this library failed to enable infinite listeners.\n  // I know what you're about to say.  But literally everything about\n  // signal-exit is a compromise with evil.  Get used to it.\n\n\n  if (!emitter.infinite) {\n    emitter.setMaxListeners(Infinity);\n    emitter.infinite = true;\n  }\n\n  signalExit.exports = function (cb, opts) {\n    /* istanbul ignore if */\n    if (!processOk(rollup.commonjsGlobal.process)) {\n      return function () {};\n    }\n\n    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');\n\n    if (loaded === false) {\n      load();\n    }\n\n    var ev = 'exit';\n\n    if (opts && opts.alwaysLast) {\n      ev = 'afterexit';\n    }\n\n    var remove = function () {\n      emitter.removeListener(ev, cb);\n\n      if (emitter.listeners('exit').length === 0 && emitter.listeners('afterexit').length === 0) {\n        unload();\n      }\n    };\n\n    emitter.on(ev, cb);\n    return remove;\n  };\n\n  var unload = function unload() {\n    if (!loaded || !processOk(rollup.commonjsGlobal.process)) {\n      return;\n    }\n\n    loaded = false;\n    signals.forEach(function (sig) {\n      try {\n        process$1.removeListener(sig, sigListeners[sig]);\n      } catch (er) {}\n    });\n    process$1.emit = originalProcessEmit;\n    process$1.reallyExit = originalProcessReallyExit;\n    emitter.count -= 1;\n  };\n\n  signalExit.exports.unload = unload;\n\n  var emit = function emit(event, code, signal) {\n    /* istanbul ignore if */\n    if (emitter.emitted[event]) {\n      return;\n    }\n\n    emitter.emitted[event] = true;\n    emitter.emit(event, code, signal);\n  }; // { <signal>: <listener fn>, ... }\n\n\n  var sigListeners = {};\n  signals.forEach(function (sig) {\n    sigListeners[sig] = function listener() {\n      /* istanbul ignore if */\n      if (!processOk(rollup.commonjsGlobal.process)) {\n        return;\n      } // If there are no other listeners, an exit is coming!\n      // Simplest way: remove us and then re-send the signal.\n      // We know that this will kill the process, so we can\n      // safely emit now.\n\n\n      var listeners = process$1.listeners(sig);\n\n      if (listeners.length === emitter.count) {\n        unload();\n        emit('exit', null, sig);\n        /* istanbul ignore next */\n\n        emit('afterexit', null, sig);\n        /* istanbul ignore next */\n\n        if (isWin && sig === 'SIGHUP') {\n          // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n          // so use a supported signal instead\n          sig = 'SIGINT';\n        }\n        /* istanbul ignore next */\n\n\n        process$1.kill(process$1.pid, sig);\n      }\n    };\n  });\n\n  signalExit.exports.signals = function () {\n    return signals;\n  };\n\n  var loaded = false;\n\n  var load = function load() {\n    if (loaded || !processOk(rollup.commonjsGlobal.process)) {\n      return;\n    }\n\n    loaded = true; // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n\n    emitter.count += 1;\n    signals = signals.filter(function (sig) {\n      try {\n        process$1.on(sig, sigListeners[sig]);\n        return true;\n      } catch (er) {\n        return false;\n      }\n    });\n    process$1.emit = processEmit;\n    process$1.reallyExit = processReallyExit;\n  };\n\n  signalExit.exports.load = load;\n  var originalProcessReallyExit = process$1.reallyExit;\n\n  var processReallyExit = function processReallyExit(code) {\n    /* istanbul ignore if */\n    if (!processOk(rollup.commonjsGlobal.process)) {\n      return;\n    }\n\n    process$1.exitCode = code ||\n    /* istanbul ignore next */\n    0;\n    emit('exit', process$1.exitCode, null);\n    /* istanbul ignore next */\n\n    emit('afterexit', process$1.exitCode, null);\n    /* istanbul ignore next */\n\n    originalProcessReallyExit.call(process$1, process$1.exitCode);\n  };\n\n  var originalProcessEmit = process$1.emit;\n\n  var processEmit = function processEmit(ev, arg) {\n    if (ev === 'exit' && processOk(rollup.commonjsGlobal.process)) {\n      /* istanbul ignore else */\n      if (arg !== undefined) {\n        process$1.exitCode = arg;\n      }\n\n      var ret = originalProcessEmit.apply(this, arguments);\n      /* istanbul ignore next */\n\n      emit('exit', process$1.exitCode, null);\n      /* istanbul ignore next */\n\n      emit('afterexit', process$1.exitCode, null);\n      /* istanbul ignore next */\n\n      return ret;\n    } else {\n      return originalProcessEmit.apply(this, arguments);\n    }\n  };\n}\n\nconst CLEAR_SCREEN = '\\u001Bc';\n\nfunction getResetScreen(configs, allowClearScreen) {\n  let clearScreen = allowClearScreen;\n\n  for (const config of configs) {\n    if (config.watch && config.watch.clearScreen === false) {\n      clearScreen = false;\n    }\n  }\n\n  if (clearScreen) {\n    return heading => loadConfigFile_js.stderr(CLEAR_SCREEN + heading);\n  }\n\n  let firstRun = true;\n  return heading => {\n    if (firstRun) {\n      loadConfigFile_js.stderr(heading);\n      firstRun = false;\n    }\n  };\n}\n\nfunction extractWatchHooks(command) {\n  if (!Array.isArray(command.watch)) return {};\n  return command.watch.filter(value => typeof value === 'object').reduce((acc, keyValueOption) => ({ ...acc,\n    ...keyValueOption\n  }), {});\n}\n\nfunction createWatchHooks(command) {\n  const watchHooks = extractWatchHooks(command);\n  return function (hook) {\n    if (watchHooks[hook]) {\n      const cmd = watchHooks[hook];\n\n      if (!command.silent) {\n        loadConfigFile_js.stderr(loadConfigFile_js.cyan(`watch.${hook} ${loadConfigFile_js.bold(`$ ${cmd}`)}`));\n      }\n\n      try {\n        // !! important - use stderr for all writes from execSync\n        const stdio = [process.stdin, process.stderr, process.stderr];\n        child_process.execSync(cmd, {\n          stdio: command.silent ? 'ignore' : stdio\n        });\n      } catch (e) {\n        loadConfigFile_js.stderr(e.message);\n      }\n    }\n  };\n}\n\nasync function watch(command) {\n  process$2.env.ROLLUP_WATCH = 'true';\n  const isTTY = process$2.stderr.isTTY;\n  const silent = command.silent;\n  let watcher;\n  let configWatcher;\n  let resetScreen;\n  const configFile = command.config ? await cli.getConfigPath(command.config) : null;\n  const runWatchHook = createWatchHooks(command);\n  signalExit.exports(close);\n  process$2.on('uncaughtException', close);\n\n  if (!process$2.stdin.isTTY) {\n    process$2.stdin.on('end', close);\n    process$2.stdin.resume();\n  }\n\n  async function loadConfigFromFileAndTrack(configFile) {\n    let configFileData = null;\n    let configFileRevision = 0;\n    configWatcher = index.chokidar.watch(configFile).on('change', reloadConfigFile);\n    await reloadConfigFile();\n\n    async function reloadConfigFile() {\n      try {\n        const newConfigFileData = await require$$0$2.promises.readFile(configFile, 'utf8');\n\n        if (newConfigFileData === configFileData) {\n          return;\n        }\n\n        configFileRevision++;\n        const currentConfigFileRevision = configFileRevision;\n\n        if (configFileData) {\n          loadConfigFile_js.stderr(`\\nReloading updated config...`);\n        }\n\n        configFileData = newConfigFileData;\n        const {\n          options,\n          warnings\n        } = await loadConfigFile_js.loadAndParseConfigFile(configFile, command);\n\n        if (currentConfigFileRevision !== configFileRevision) {\n          return;\n        }\n\n        if (watcher) {\n          await watcher.close();\n        }\n\n        start(options, warnings);\n      } catch (err) {\n        loadConfigFile_js.handleError(err, true);\n      }\n    }\n  }\n\n  if (configFile) {\n    await loadConfigFromFileAndTrack(configFile);\n  } else {\n    const {\n      options,\n      warnings\n    } = await cli.loadConfigFromCommand(command);\n    start(options, warnings);\n  }\n\n  function start(configs, warnings) {\n    try {\n      watcher = rollup.watch(configs);\n    } catch (err) {\n      return loadConfigFile_js.handleError(err);\n    }\n\n    watcher.on('event', event => {\n      switch (event.code) {\n        case 'ERROR':\n          warnings.flush();\n          loadConfigFile_js.handleError(event.error, true);\n          runWatchHook('onError');\n          break;\n\n        case 'START':\n          if (!silent) {\n            if (!resetScreen) {\n              resetScreen = getResetScreen(configs, isTTY);\n            }\n\n            resetScreen(loadConfigFile_js.underline(`rollup v${rollup.version}`));\n          }\n\n          runWatchHook('onStart');\n          break;\n\n        case 'BUNDLE_START':\n          if (!silent) {\n            let input = event.input;\n\n            if (typeof input !== 'string') {\n              input = Array.isArray(input) ? input.join(', ') : Object.values(input).join(', ');\n            }\n\n            loadConfigFile_js.stderr(loadConfigFile_js.cyan(`bundles ${loadConfigFile_js.bold(input)} → ${loadConfigFile_js.bold(event.output.map(rollup.relativeId).join(', '))}...`));\n          }\n\n          runWatchHook('onBundleStart');\n          break;\n\n        case 'BUNDLE_END':\n          warnings.flush();\n          if (!silent) loadConfigFile_js.stderr(loadConfigFile_js.green(`created ${loadConfigFile_js.bold(event.output.map(rollup.relativeId).join(', '))} in ${loadConfigFile_js.bold(cli.ms(event.duration))}`));\n          runWatchHook('onBundleEnd');\n\n          if (event.result && event.result.getTimings) {\n            cli.printTimings(event.result.getTimings());\n          }\n\n          break;\n\n        case 'END':\n          runWatchHook('onEnd');\n\n          if (!silent && isTTY) {\n            loadConfigFile_js.stderr(`\\n[${dateTime()}] waiting for changes...`);\n          }\n\n      }\n\n      if ('result' in event && event.result) {\n        event.result.close().catch(error => loadConfigFile_js.handleError(error, true));\n      }\n    });\n  }\n\n  async function close(code) {\n    process$2.removeListener('uncaughtException', close); // removing a non-existent listener is a no-op\n\n    process$2.stdin.removeListener('end', close);\n    if (watcher) await watcher.close();\n    if (configWatcher) configWatcher.close();\n\n    if (code) {\n      process$2.exit(code);\n    }\n  }\n}\n\nexports.watch = watch;","map":{"version":3,"names":["Object","defineProperty","exports","Symbol","toStringTag","value","require$$0$2","require","process$2","index","cli","rollup","require$$0","require$$0$1","loadConfigFile_js","child_process","timeZone","date","Date","offset","getTimezoneOffset","absOffset","Math","abs","hours","floor","minutes","minutesOut","slice","dateTime","options","local","showTimeZone","showMilliseconds","getTime","end","getUTCMilliseconds","toISOString","replace","signalExit","signals$1","hasRequiredSignals","requireSignals","module","process","platform","push","process$1","commonjsGlobal","processOk","removeListener","emit","reallyExit","listeners","kill","pid","on","assert","signals","isWin","test","EE","EventEmitter","emitter","__signal_exit_emitter__","count","emitted","infinite","setMaxListeners","Infinity","cb","opts","equal","loaded","load","ev","alwaysLast","remove","length","unload","forEach","sig","sigListeners","er","originalProcessEmit","originalProcessReallyExit","event","code","signal","listener","filter","processEmit","processReallyExit","exitCode","call","arg","undefined","ret","apply","arguments","CLEAR_SCREEN","getResetScreen","configs","allowClearScreen","clearScreen","config","watch","heading","stderr","firstRun","extractWatchHooks","command","Array","isArray","reduce","acc","keyValueOption","createWatchHooks","watchHooks","hook","cmd","silent","cyan","bold","stdio","stdin","execSync","e","message","env","ROLLUP_WATCH","isTTY","watcher","configWatcher","resetScreen","configFile","getConfigPath","runWatchHook","close","resume","loadConfigFromFileAndTrack","configFileData","configFileRevision","chokidar","reloadConfigFile","newConfigFileData","promises","readFile","currentConfigFileRevision","warnings","loadAndParseConfigFile","start","err","handleError","loadConfigFromCommand","flush","error","underline","version","input","join","values","output","map","relativeId","green","ms","duration","result","getTimings","printTimings","catch","exit"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/rollup/dist/shared/watch-cli.js"],"sourcesContent":["/*\n  @license\n\tRollup.js v2.79.0\n\tWed, 31 Aug 2022 04:52:13 GMT - commit 8477f8ff1fe80086556021542b22942ad27a0a69\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\n'use strict';\n\nObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst require$$0$2 = require('fs');\nconst process$2 = require('process');\nconst index = require('./index.js');\nconst cli = require('../bin/rollup');\nconst rollup = require('./rollup.js');\nconst require$$0 = require('assert');\nconst require$$0$1 = require('events');\nconst loadConfigFile_js = require('./loadConfigFile.js');\nconst child_process = require('child_process');\nrequire('util');\nrequire('stream');\nrequire('path');\nrequire('os');\nrequire('./mergeOptions.js');\nrequire('perf_hooks');\nrequire('crypto');\nrequire('url');\nrequire('tty');\n\nfunction timeZone(date = new Date()) {\n\tconst offset = date.getTimezoneOffset();\n\tconst absOffset = Math.abs(offset);\n\tconst hours = Math.floor(absOffset / 60);\n\tconst minutes = absOffset % 60;\n\tconst minutesOut = minutes > 0 ? ':' + ('0' + minutes).slice(-2) : '';\n\treturn (offset < 0 ? '+' : '-') + hours + minutesOut;\n}\n\nfunction dateTime(options = {}) {\n\tlet {\n\t\tdate = new Date(),\n\t\tlocal = true,\n\t\tshowTimeZone = false,\n\t\tshowMilliseconds = false\n\t} = options;\n\n\tif (local) {\n\t\t// Offset the date so it will return the correct value when getting the ISO string.\n\t\tdate = new Date(date.getTime() - (date.getTimezoneOffset() * 60000));\n\t}\n\n\tlet end = '';\n\n\tif (showTimeZone) {\n\t\tend = ' UTC' + (local ? timeZone(date) : '');\n\t}\n\n\tif (showMilliseconds && date.getUTCMilliseconds() > 0) {\n\t\tend = ` ${date.getUTCMilliseconds()}ms${end}`;\n\t}\n\n\treturn date\n\t\t.toISOString()\n\t\t.replace(/T/, ' ')\n\t\t.replace(/\\..+/, end);\n}\n\nvar signalExit = {exports: {}};\n\nvar signals$1 = {exports: {}};\n\nvar hasRequiredSignals;\n\nfunction requireSignals () {\n\tif (hasRequiredSignals) return signals$1.exports;\n\thasRequiredSignals = 1;\n\t(function (module) {\n\t\t// This is not the set of all possible signals.\n\t\t//\n\t\t// It IS, however, the set of all signals that trigger\n\t\t// an exit on either Linux or BSD systems.  Linux is a\n\t\t// superset of the signal names supported on BSD, and\n\t\t// the unknown signals just fail to register, so we can\n\t\t// catch that easily enough.\n\t\t//\n\t\t// Don't bother with SIGKILL.  It's uncatchable, which\n\t\t// means that we can't fire any callbacks anyway.\n\t\t//\n\t\t// If a user does happen to register a handler on a non-\n\t\t// fatal signal like SIGWINCH or something, and then\n\t\t// exit, it'll end up firing `process.emit('exit')`, so\n\t\t// the handler will be fired anyway.\n\t\t//\n\t\t// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n\t\t// artificially, inherently leave the process in a\n\t\t// state from which it is not safe to try and enter JS\n\t\t// listeners.\n\t\tmodule.exports = [\n\t\t  'SIGABRT',\n\t\t  'SIGALRM',\n\t\t  'SIGHUP',\n\t\t  'SIGINT',\n\t\t  'SIGTERM'\n\t\t];\n\n\t\tif (process.platform !== 'win32') {\n\t\t  module.exports.push(\n\t\t    'SIGVTALRM',\n\t\t    'SIGXCPU',\n\t\t    'SIGXFSZ',\n\t\t    'SIGUSR2',\n\t\t    'SIGTRAP',\n\t\t    'SIGSYS',\n\t\t    'SIGQUIT',\n\t\t    'SIGIOT'\n\t\t    // should detect profiler and enable/disable accordingly.\n\t\t    // see #21\n\t\t    // 'SIGPROF'\n\t\t  );\n\t\t}\n\n\t\tif (process.platform === 'linux') {\n\t\t  module.exports.push(\n\t\t    'SIGIO',\n\t\t    'SIGPOLL',\n\t\t    'SIGPWR',\n\t\t    'SIGSTKFLT',\n\t\t    'SIGUNUSED'\n\t\t  );\n\t\t}\n} (signals$1));\n\treturn signals$1.exports;\n}\n\n// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nvar process$1 = rollup.commonjsGlobal.process;\n\nconst processOk = function (process) {\n  return process &&\n    typeof process === 'object' &&\n    typeof process.removeListener === 'function' &&\n    typeof process.emit === 'function' &&\n    typeof process.reallyExit === 'function' &&\n    typeof process.listeners === 'function' &&\n    typeof process.kill === 'function' &&\n    typeof process.pid === 'number' &&\n    typeof process.on === 'function'\n};\n\n// some kind of non-node environment, just no-op\n/* istanbul ignore if */\nif (!processOk(process$1)) {\n  signalExit.exports = function () {\n    return function () {}\n  };\n} else {\n  var assert = require$$0;\n  var signals = requireSignals();\n  var isWin = /^win/i.test(process$1.platform);\n\n  var EE = require$$0$1;\n  /* istanbul ignore if */\n  if (typeof EE !== 'function') {\n    EE = EE.EventEmitter;\n  }\n\n  var emitter;\n  if (process$1.__signal_exit_emitter__) {\n    emitter = process$1.__signal_exit_emitter__;\n  } else {\n    emitter = process$1.__signal_exit_emitter__ = new EE();\n    emitter.count = 0;\n    emitter.emitted = {};\n  }\n\n  // Because this emitter is a global, we have to check to see if a\n  // previous version of this library failed to enable infinite listeners.\n  // I know what you're about to say.  But literally everything about\n  // signal-exit is a compromise with evil.  Get used to it.\n  if (!emitter.infinite) {\n    emitter.setMaxListeners(Infinity);\n    emitter.infinite = true;\n  }\n\n  signalExit.exports = function (cb, opts) {\n    /* istanbul ignore if */\n    if (!processOk(rollup.commonjsGlobal.process)) {\n      return function () {}\n    }\n    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');\n\n    if (loaded === false) {\n      load();\n    }\n\n    var ev = 'exit';\n    if (opts && opts.alwaysLast) {\n      ev = 'afterexit';\n    }\n\n    var remove = function () {\n      emitter.removeListener(ev, cb);\n      if (emitter.listeners('exit').length === 0 &&\n          emitter.listeners('afterexit').length === 0) {\n        unload();\n      }\n    };\n    emitter.on(ev, cb);\n\n    return remove\n  };\n\n  var unload = function unload () {\n    if (!loaded || !processOk(rollup.commonjsGlobal.process)) {\n      return\n    }\n    loaded = false;\n\n    signals.forEach(function (sig) {\n      try {\n        process$1.removeListener(sig, sigListeners[sig]);\n      } catch (er) {}\n    });\n    process$1.emit = originalProcessEmit;\n    process$1.reallyExit = originalProcessReallyExit;\n    emitter.count -= 1;\n  };\n  signalExit.exports.unload = unload;\n\n  var emit = function emit (event, code, signal) {\n    /* istanbul ignore if */\n    if (emitter.emitted[event]) {\n      return\n    }\n    emitter.emitted[event] = true;\n    emitter.emit(event, code, signal);\n  };\n\n  // { <signal>: <listener fn>, ... }\n  var sigListeners = {};\n  signals.forEach(function (sig) {\n    sigListeners[sig] = function listener () {\n      /* istanbul ignore if */\n      if (!processOk(rollup.commonjsGlobal.process)) {\n        return\n      }\n      // If there are no other listeners, an exit is coming!\n      // Simplest way: remove us and then re-send the signal.\n      // We know that this will kill the process, so we can\n      // safely emit now.\n      var listeners = process$1.listeners(sig);\n      if (listeners.length === emitter.count) {\n        unload();\n        emit('exit', null, sig);\n        /* istanbul ignore next */\n        emit('afterexit', null, sig);\n        /* istanbul ignore next */\n        if (isWin && sig === 'SIGHUP') {\n          // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n          // so use a supported signal instead\n          sig = 'SIGINT';\n        }\n        /* istanbul ignore next */\n        process$1.kill(process$1.pid, sig);\n      }\n    };\n  });\n\n  signalExit.exports.signals = function () {\n    return signals\n  };\n\n  var loaded = false;\n\n  var load = function load () {\n    if (loaded || !processOk(rollup.commonjsGlobal.process)) {\n      return\n    }\n    loaded = true;\n\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    emitter.count += 1;\n\n    signals = signals.filter(function (sig) {\n      try {\n        process$1.on(sig, sigListeners[sig]);\n        return true\n      } catch (er) {\n        return false\n      }\n    });\n\n    process$1.emit = processEmit;\n    process$1.reallyExit = processReallyExit;\n  };\n  signalExit.exports.load = load;\n\n  var originalProcessReallyExit = process$1.reallyExit;\n  var processReallyExit = function processReallyExit (code) {\n    /* istanbul ignore if */\n    if (!processOk(rollup.commonjsGlobal.process)) {\n      return\n    }\n    process$1.exitCode = code || /* istanbul ignore next */ 0;\n    emit('exit', process$1.exitCode, null);\n    /* istanbul ignore next */\n    emit('afterexit', process$1.exitCode, null);\n    /* istanbul ignore next */\n    originalProcessReallyExit.call(process$1, process$1.exitCode);\n  };\n\n  var originalProcessEmit = process$1.emit;\n  var processEmit = function processEmit (ev, arg) {\n    if (ev === 'exit' && processOk(rollup.commonjsGlobal.process)) {\n      /* istanbul ignore else */\n      if (arg !== undefined) {\n        process$1.exitCode = arg;\n      }\n      var ret = originalProcessEmit.apply(this, arguments);\n      /* istanbul ignore next */\n      emit('exit', process$1.exitCode, null);\n      /* istanbul ignore next */\n      emit('afterexit', process$1.exitCode, null);\n      /* istanbul ignore next */\n      return ret\n    } else {\n      return originalProcessEmit.apply(this, arguments)\n    }\n  };\n}\n\nconst CLEAR_SCREEN = '\\u001Bc';\nfunction getResetScreen(configs, allowClearScreen) {\n    let clearScreen = allowClearScreen;\n    for (const config of configs) {\n        if (config.watch && config.watch.clearScreen === false) {\n            clearScreen = false;\n        }\n    }\n    if (clearScreen) {\n        return (heading) => loadConfigFile_js.stderr(CLEAR_SCREEN + heading);\n    }\n    let firstRun = true;\n    return (heading) => {\n        if (firstRun) {\n            loadConfigFile_js.stderr(heading);\n            firstRun = false;\n        }\n    };\n}\n\nfunction extractWatchHooks(command) {\n    if (!Array.isArray(command.watch))\n        return {};\n    return command.watch\n        .filter(value => typeof value === 'object')\n        .reduce((acc, keyValueOption) => ({ ...acc, ...keyValueOption }), {});\n}\nfunction createWatchHooks(command) {\n    const watchHooks = extractWatchHooks(command);\n    return function (hook) {\n        if (watchHooks[hook]) {\n            const cmd = watchHooks[hook];\n            if (!command.silent) {\n                loadConfigFile_js.stderr(loadConfigFile_js.cyan(`watch.${hook} ${loadConfigFile_js.bold(`$ ${cmd}`)}`));\n            }\n            try {\n                // !! important - use stderr for all writes from execSync\n                const stdio = [process.stdin, process.stderr, process.stderr];\n                child_process.execSync(cmd, { stdio: command.silent ? 'ignore' : stdio });\n            }\n            catch (e) {\n                loadConfigFile_js.stderr(e.message);\n            }\n        }\n    };\n}\n\nasync function watch(command) {\n    process$2.env.ROLLUP_WATCH = 'true';\n    const isTTY = process$2.stderr.isTTY;\n    const silent = command.silent;\n    let watcher;\n    let configWatcher;\n    let resetScreen;\n    const configFile = command.config ? await cli.getConfigPath(command.config) : null;\n    const runWatchHook = createWatchHooks(command);\n    signalExit.exports(close);\n    process$2.on('uncaughtException', close);\n    if (!process$2.stdin.isTTY) {\n        process$2.stdin.on('end', close);\n        process$2.stdin.resume();\n    }\n    async function loadConfigFromFileAndTrack(configFile) {\n        let configFileData = null;\n        let configFileRevision = 0;\n        configWatcher = index.chokidar.watch(configFile).on('change', reloadConfigFile);\n        await reloadConfigFile();\n        async function reloadConfigFile() {\n            try {\n                const newConfigFileData = await require$$0$2.promises.readFile(configFile, 'utf8');\n                if (newConfigFileData === configFileData) {\n                    return;\n                }\n                configFileRevision++;\n                const currentConfigFileRevision = configFileRevision;\n                if (configFileData) {\n                    loadConfigFile_js.stderr(`\\nReloading updated config...`);\n                }\n                configFileData = newConfigFileData;\n                const { options, warnings } = await loadConfigFile_js.loadAndParseConfigFile(configFile, command);\n                if (currentConfigFileRevision !== configFileRevision) {\n                    return;\n                }\n                if (watcher) {\n                    await watcher.close();\n                }\n                start(options, warnings);\n            }\n            catch (err) {\n                loadConfigFile_js.handleError(err, true);\n            }\n        }\n    }\n    if (configFile) {\n        await loadConfigFromFileAndTrack(configFile);\n    }\n    else {\n        const { options, warnings } = await cli.loadConfigFromCommand(command);\n        start(options, warnings);\n    }\n    function start(configs, warnings) {\n        try {\n            watcher = rollup.watch(configs);\n        }\n        catch (err) {\n            return loadConfigFile_js.handleError(err);\n        }\n        watcher.on('event', event => {\n            switch (event.code) {\n                case 'ERROR':\n                    warnings.flush();\n                    loadConfigFile_js.handleError(event.error, true);\n                    runWatchHook('onError');\n                    break;\n                case 'START':\n                    if (!silent) {\n                        if (!resetScreen) {\n                            resetScreen = getResetScreen(configs, isTTY);\n                        }\n                        resetScreen(loadConfigFile_js.underline(`rollup v${rollup.version}`));\n                    }\n                    runWatchHook('onStart');\n                    break;\n                case 'BUNDLE_START':\n                    if (!silent) {\n                        let input = event.input;\n                        if (typeof input !== 'string') {\n                            input = Array.isArray(input)\n                                ? input.join(', ')\n                                : Object.values(input).join(', ');\n                        }\n                        loadConfigFile_js.stderr(loadConfigFile_js.cyan(`bundles ${loadConfigFile_js.bold(input)} → ${loadConfigFile_js.bold(event.output.map(rollup.relativeId).join(', '))}...`));\n                    }\n                    runWatchHook('onBundleStart');\n                    break;\n                case 'BUNDLE_END':\n                    warnings.flush();\n                    if (!silent)\n                        loadConfigFile_js.stderr(loadConfigFile_js.green(`created ${loadConfigFile_js.bold(event.output.map(rollup.relativeId).join(', '))} in ${loadConfigFile_js.bold(cli.ms(event.duration))}`));\n                    runWatchHook('onBundleEnd');\n                    if (event.result && event.result.getTimings) {\n                        cli.printTimings(event.result.getTimings());\n                    }\n                    break;\n                case 'END':\n                    runWatchHook('onEnd');\n                    if (!silent && isTTY) {\n                        loadConfigFile_js.stderr(`\\n[${dateTime()}] waiting for changes...`);\n                    }\n            }\n            if ('result' in event && event.result) {\n                event.result.close().catch(error => loadConfigFile_js.handleError(error, true));\n            }\n        });\n    }\n    async function close(code) {\n        process$2.removeListener('uncaughtException', close);\n        // removing a non-existent listener is a no-op\n        process$2.stdin.removeListener('end', close);\n        if (watcher)\n            await watcher.close();\n        if (configWatcher)\n            configWatcher.close();\n        if (code) {\n            process$2.exit(code);\n        }\n    }\n}\n\nexports.watch = watch;\n//# sourceMappingURL=watch-cli.js.map\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}