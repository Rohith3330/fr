{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar path = _interopDefault(require('path'));\n\nvar minimatch = _interopDefault(require('minimatch'));\n\nvar createDebug = _interopDefault(require('debug'));\n\nvar objectSchema = require('@humanwhocodes/object-schema');\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Assets that a given value is an array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array. \n */\n\n\nfunction assertIsArray(value) {\n  if (!Array.isArray(value)) {\n    throw new TypeError('Expected value to be an array.');\n  }\n}\n/**\n * Assets that a given value is an array containing only strings and functions.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array of strings and functions.\n */\n\n\nfunction assertIsArrayOfStringsAndFunctions(value, name) {\n  assertIsArray(value);\n\n  if (value.some(item => typeof item !== 'string' && typeof item !== 'function')) {\n    throw new TypeError('Expected array to only contain strings.');\n  }\n} //------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The base schema that every ConfigArray uses.\n * @type Object\n */\n\n\nconst baseSchema = Object.freeze({\n  name: {\n    required: false,\n\n    merge() {\n      return undefined;\n    },\n\n    validate(value) {\n      if (typeof value !== 'string') {\n        throw new TypeError('Property must be a string.');\n      }\n    }\n\n  },\n  files: {\n    required: false,\n\n    merge() {\n      return undefined;\n    },\n\n    validate(value) {\n      // first check if it's an array\n      assertIsArray(value); // then check each member\n\n      value.forEach(item => {\n        if (Array.isArray(item)) {\n          assertIsArrayOfStringsAndFunctions(item);\n        } else if (typeof item !== 'string' && typeof item !== 'function') {\n          throw new TypeError('Items must be a string, a function, or an array of strings and functions.');\n        }\n      });\n    }\n\n  },\n  ignores: {\n    required: false,\n\n    merge() {\n      return undefined;\n    },\n\n    validate: assertIsArrayOfStringsAndFunctions\n  }\n});\n/**\n * @fileoverview ConfigArray\n * @author Nicholas C. Zakas\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst debug = createDebug('@hwc/config-array');\nconst MINIMATCH_OPTIONS = {\n  // matchBase: true,\n  dot: true\n};\nconst CONFIG_TYPES = new Set(['array', 'function']);\n/**\n * Shorthand for checking if a value is a string.\n * @param {any} value The value to check.\n * @returns {boolean} True if a string, false if not. \n */\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Promise<Array>} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\n\n\nasync function normalize(items, context, extraConfigTypes) {\n  const allowFunctions = extraConfigTypes.includes('function');\n  const allowArrays = extraConfigTypes.includes('array');\n\n  async function* flatTraverse(array) {\n    for (let item of array) {\n      if (typeof item === 'function') {\n        if (!allowFunctions) {\n          throw new TypeError('Unexpected function.');\n        }\n\n        item = item(context);\n\n        if (item.then) {\n          item = await item;\n        }\n      }\n\n      if (Array.isArray(item)) {\n        if (!allowArrays) {\n          throw new TypeError('Unexpected array.');\n        }\n\n        yield* flatTraverse(item);\n      } else if (typeof item === 'function') {\n        throw new TypeError('A config function can only return an object or array.');\n      } else {\n        yield item;\n      }\n    }\n  }\n  /*\n   * Async iterables cannot be used with the spread operator, so we need to manually\n   * create the array to return.\n   */\n\n\n  const asyncIterable = await flatTraverse(items);\n  const configs = [];\n\n  for await (const config of asyncIterable) {\n    configs.push(config);\n  }\n\n  return configs;\n}\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Array} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\n\n\nfunction normalizeSync(items, context, extraConfigTypes) {\n  const allowFunctions = extraConfigTypes.includes('function');\n  const allowArrays = extraConfigTypes.includes('array');\n\n  function* flatTraverse(array) {\n    for (let item of array) {\n      if (typeof item === 'function') {\n        if (!allowFunctions) {\n          throw new TypeError('Unexpected function.');\n        }\n\n        item = item(context);\n\n        if (item.then) {\n          throw new TypeError('Async config functions are not supported.');\n        }\n      }\n\n      if (Array.isArray(item)) {\n        if (!allowArrays) {\n          throw new TypeError('Unexpected array.');\n        }\n\n        yield* flatTraverse(item);\n      } else if (typeof item === 'function') {\n        throw new TypeError('A config function can only return an object or array.');\n      } else {\n        yield item;\n      }\n    }\n  }\n\n  return [...flatTraverse(items)];\n}\n/**\n * Determines if a given file path should be ignored based on the given\n * matcher.\n * @param {Array<string|() => boolean>} ignores The ignore patterns to check. \n * @param {string} filePath The absolute path of the file to check.\n * @param {string} relativeFilePath The relative path of the file to check.\n * @returns {boolean} True if the path should be ignored and false if not.\n */\n\n\nfunction shouldIgnoreFilePath(ignores, filePath, relativeFilePath) {\n  // all files outside of the basePath are ignored\n  if (relativeFilePath.startsWith('..')) {\n    return true;\n  }\n\n  let shouldIgnore = false;\n\n  for (const matcher of ignores) {\n    if (typeof matcher === 'function') {\n      shouldIgnore = shouldIgnore || matcher(filePath);\n      continue;\n    }\n    /*\n     * If there's a negated pattern, that means anything matching\n     * must NOT be ignored. To do that, we need to use the `flipNegate`\n     * option for minimatch to check if the filepath matches the\n     * pattern specified after the !, and if that result is true,\n     * then we return false immediately because this file should\n     * never be ignored.\n     */\n\n\n    if (matcher.startsWith('!')) {\n      /*\n       * The file must already be ignored in order to apply a negated\n       * pattern, because negated patterns simply remove files that\n       * would already be ignored.\n       */\n      if (shouldIgnore && minimatch(relativeFilePath, matcher, { ...MINIMATCH_OPTIONS,\n        flipNegate: true\n      })) {\n        return false;\n      }\n    } else {\n      shouldIgnore = shouldIgnore || minimatch(relativeFilePath, matcher, MINIMATCH_OPTIONS);\n    }\n  }\n\n  return shouldIgnore;\n}\n/**\n * Determines if a given file path is matched by a config. If the config\n * has no `files` field, then it matches; otherwise, if a `files` field\n * is present then we match the globs in `files` and exclude any globs in\n * `ignores`.\n * @param {string} filePath The absolute file path to check.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\n\n\nfunction pathMatches(filePath, basePath, config) {\n  /*\n   * For both files and ignores, functions are passed the absolute\n   * file path while strings are compared against the relative\n   * file path.\n   */\n  const relativeFilePath = path.relative(basePath, filePath); // if files isn't an array, throw an error\n\n  if (!Array.isArray(config.files) || config.files.length === 0) {\n    throw new TypeError('The files key must be a non-empty array.');\n  } // match both strings and functions\n\n\n  const match = pattern => {\n    if (isString(pattern)) {\n      return minimatch(relativeFilePath, pattern, MINIMATCH_OPTIONS);\n    }\n\n    if (typeof pattern === 'function') {\n      return pattern(filePath);\n    }\n\n    throw new TypeError(`Unexpected matcher type ${pattern}.`);\n  }; // check for all matches to config.files\n\n\n  let filePathMatchesPattern = config.files.some(pattern => {\n    if (Array.isArray(pattern)) {\n      return pattern.every(match);\n    }\n\n    return match(pattern);\n  });\n  /*\n   * If the file path matches the config.files patterns, then check to see\n   * if there are any files to ignore.\n   */\n\n  if (filePathMatchesPattern && config.ignores) {\n    filePathMatchesPattern = !shouldIgnoreFilePath(config.ignores, filePath, relativeFilePath);\n  }\n\n  return filePathMatchesPattern;\n}\n/**\n * Ensures that a ConfigArray has been normalized.\n * @param {ConfigArray} configArray The ConfigArray to check. \n * @returns {void}\n * @throws {Error} When the `ConfigArray` is not normalized.\n */\n\n\nfunction assertNormalized(configArray) {\n  // TODO: Throw more verbose error\n  if (!configArray.isNormalized()) {\n    throw new Error('ConfigArray must be normalized to perform this operation.');\n  }\n}\n/**\n * Ensures that config types are valid.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {void}\n * @throws {Error} When the config types array is invalid.\n */\n\n\nfunction assertExtraConfigTypes(extraConfigTypes) {\n  if (extraConfigTypes.length > 2) {\n    throw new TypeError('configTypes must be an array with at most two items.');\n  }\n\n  for (const configType of extraConfigTypes) {\n    if (!CONFIG_TYPES.has(configType)) {\n      throw new TypeError(`Unexpected config type \"${configType}\" found. Expected one of: \"object\", \"array\", \"function\".`);\n    }\n  }\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nconst ConfigArraySymbol = {\n  isNormalized: Symbol('isNormalized'),\n  configCache: Symbol('configCache'),\n  schema: Symbol('schema'),\n  finalizeConfig: Symbol('finalizeConfig'),\n  preprocessConfig: Symbol('preprocessConfig')\n}; // used to store calculate data for faster lookup\n\nconst dataCache = new WeakMap();\n/**\n * Represents an array of config objects and provides method for working with\n * those config objects.\n */\n\nclass ConfigArray extends Array {\n  /**\n   * Creates a new instance of ConfigArray.\n   * @param {Iterable|Function|Object} configs An iterable yielding config\n   *      objects, or a config function, or a config object.\n   * @param {string} [options.basePath=\"\"] The path of the config file\n   * @param {boolean} [options.normalized=false] Flag indicating if the\n   *      configs have already been normalized.\n   * @param {Object} [options.schema] The additional schema \n   *      definitions to use for the ConfigArray schema.\n   * @param {Array<string>} [options.configTypes] List of config types supported.\n   */\n  constructor(configs) {\n    let {\n      basePath = '',\n      normalized = false,\n      schema: customSchema,\n      extraConfigTypes = []\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    /**\n    * Tracks if the array has been normalized.\n    * @property isNormalized\n    * @type boolean\n    * @private\n    */\n\n    this[ConfigArraySymbol.isNormalized] = normalized;\n    /**\n    * The schema used for validating and merging configs.\n    * @property schema\n    * @type ObjectSchema\n    * @private\n    */\n\n    this[ConfigArraySymbol.schema] = new objectSchema.ObjectSchema({ ...customSchema,\n      ...baseSchema\n    });\n    /**\n    * The path of the config file that this array was loaded from.\n    * This is used to calculate filename matches.\n    * @property basePath\n    * @type string\n    */\n\n    this.basePath = basePath;\n    assertExtraConfigTypes(extraConfigTypes);\n    /**\n    * The supported config types.\n    * @property configTypes\n    * @type Array<string>\n    */\n\n    this.extraConfigTypes = Object.freeze([...extraConfigTypes]);\n    /**\n    * A cache to store calculated configs for faster repeat lookup.\n    * @property configCache\n    * @type Map\n    * @private\n    */\n\n    this[ConfigArraySymbol.configCache] = new Map(); // init cache\n\n    dataCache.set(this, {\n      explicitMatches: new Map()\n    }); // load the configs into this array\n\n    if (Array.isArray(configs)) {\n      this.push(...configs);\n    } else {\n      this.push(configs);\n    }\n  }\n  /**\n  \t * Prevent normal array methods from creating a new `ConfigArray` instance.\n  \t * This is to ensure that methods such as `slice()` won't try to create a \n  \t * new instance of `ConfigArray` behind the scenes as doing so may throw\n  \t * an error due to the different constructor signature.\n  \t * @returns {Function} The `Array` constructor.\n  \t */\n\n\n  static get [Symbol.species]() {\n    return Array;\n  }\n  /**\n  \t * Returns the `files` globs from every config object in the array.\n  \t * This can be used to determine which files will be matched by a\n  \t * config array or to use as a glob pattern when no patterns are provided\n  \t * for a command line interface.\n  \t * @returns {Array<string|Function>} An array of matchers.\n  \t */\n\n\n  get files() {\n    assertNormalized(this); // if this data has been cached, retrieve it\n\n    const cache = dataCache.get(this);\n\n    if (cache.files) {\n      return cache.files;\n    } // otherwise calculate it\n\n\n    const result = [];\n\n    for (const config of this) {\n      if (config.files) {\n        config.files.forEach(filePattern => {\n          result.push(filePattern);\n        });\n      }\n    } // store result\n\n\n    cache.files = result;\n    dataCache.set(this, cache);\n    return result;\n  }\n  /**\n  \t * Returns ignore matchers that should always be ignored regardless of\n  \t * the matching `files` fields in any configs. This is necessary to mimic\n  \t * the behavior of things like .gitignore and .eslintignore, allowing a\n  \t * globbing operation to be faster.\n  \t * @returns {string[]} An array of string patterns and functions to be ignored.\n  \t */\n\n\n  get ignores() {\n    assertNormalized(this); // if this data has been cached, retrieve it\n\n    const cache = dataCache.get(this);\n\n    if (cache.ignores) {\n      return cache.ignores;\n    } // otherwise calculate it\n\n\n    const result = [];\n\n    for (const config of this) {\n      /*\n       * We only count ignores if there are no other keys in the object.\n       * In this case, it acts list a globally ignored pattern. If there\n       * are additional keys, then ignores act like exclusions.\n       */\n      if (config.ignores && Object.keys(config).length === 1) {\n        result.push(...config.ignores);\n      }\n    } // store result\n\n\n    cache.ignores = result;\n    dataCache.set(this, cache);\n    return result;\n  }\n  /**\n  \t * Indicates if the config array has been normalized.\n  \t * @returns {boolean} True if the config array is normalized, false if not.\n  \t */\n\n\n  isNormalized() {\n    return this[ConfigArraySymbol.isNormalized];\n  }\n  /**\n  \t * Normalizes a config array by flattening embedded arrays and executing\n  \t * config functions.\n  \t * @param {ConfigContext} context The context object for config functions.\n  \t * @returns {Promise<ConfigArray>} The current ConfigArray instance.\n  \t */\n\n\n  async normalize() {\n    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.isNormalized()) {\n      const normalizedConfigs = await normalize(this, context, this.extraConfigTypes);\n      this.length = 0;\n      this.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n      this[ConfigArraySymbol.isNormalized] = true; // prevent further changes\n\n      Object.freeze(this);\n    }\n\n    return this;\n  }\n  /**\n  \t * Normalizes a config array by flattening embedded arrays and executing\n  \t * config functions.\n  \t * @param {ConfigContext} context The context object for config functions.\n  \t * @returns {ConfigArray} The current ConfigArray instance.\n  \t */\n\n\n  normalizeSync() {\n    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.isNormalized()) {\n      const normalizedConfigs = normalizeSync(this, context, this.extraConfigTypes);\n      this.length = 0;\n      this.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n      this[ConfigArraySymbol.isNormalized] = true; // prevent further changes\n\n      Object.freeze(this);\n    }\n\n    return this;\n  }\n  /**\n  \t * Finalizes the state of a config before being cached and returned by\n  \t * `getConfig()`. Does nothing by default but is provided to be\n  \t * overridden by subclasses as necessary.\n  \t * @param {Object} config The config to finalize.\n  \t * @returns {Object} The finalized config.\n  \t */\n\n\n  [ConfigArraySymbol.finalizeConfig](config) {\n    return config;\n  }\n  /**\n  \t * Preprocesses a config during the normalization process. This is the\n  \t * method to override if you want to convert an array item before it is\n  \t * validated for the first time. For example, if you want to replace a\n  \t * string with an object, this is the method to override.\n  \t * @param {Object} config The config to preprocess.\n  \t * @returns {Object} The config to use in place of the argument.\n  \t */\n\n\n  [ConfigArraySymbol.preprocessConfig](config) {\n    return config;\n  }\n  /**\n  \t * Determines if a given file path explicitly matches a `files` entry\n  \t * and also doesn't match an `ignores` entry. Configs that don't have\n  \t * a `files` property are not considered an explicit match.\n  \t * @param {string} filePath The complete path of a file to check.\n  \t * @returns {boolean} True if the file path matches a `files` entry\n  \t * \t\tor false if not.\n  \t */\n\n\n  isExplicitMatch(filePath) {\n    assertNormalized(this);\n    const cache = dataCache.get(this); // first check the cache to avoid duplicate work\n\n    let result = cache.explicitMatches.get(filePath);\n\n    if (typeof result == 'boolean') {\n      return result;\n    } // TODO: Maybe move elsewhere? Maybe combine with getConfig() logic?\n\n\n    const relativeFilePath = path.relative(this.basePath, filePath);\n\n    if (shouldIgnoreFilePath(this.ignores, filePath, relativeFilePath)) {\n      debug(`Ignoring ${filePath}`); // cache and return result\n\n      cache.explicitMatches.set(filePath, false);\n      return false;\n    } // filePath isn't automatically ignored, so try to find a match\n\n\n    for (const config of this) {\n      if (!config.files) {\n        continue;\n      }\n\n      if (pathMatches(filePath, this.basePath, config)) {\n        debug(`Matching config found for ${filePath}`);\n        cache.explicitMatches.set(filePath, true);\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n  \t * Returns the config object for a given file path.\n  \t * @param {string} filePath The complete path of a file to get a config for.\n  \t * @returns {Object} The config object for this file.\n  \t */\n\n\n  getConfig(filePath) {\n    assertNormalized(this); // first check the cache to avoid duplicate work\n\n    let finalConfig = this[ConfigArraySymbol.configCache].get(filePath);\n\n    if (finalConfig) {\n      return finalConfig;\n    } // TODO: Maybe move elsewhere?\n\n\n    const relativeFilePath = path.relative(this.basePath, filePath);\n\n    if (shouldIgnoreFilePath(this.ignores, filePath, relativeFilePath)) {\n      debug(`Ignoring ${filePath}`); // cache and return result - finalConfig is undefined at this point\n\n      this[ConfigArraySymbol.configCache].set(filePath, finalConfig);\n      return finalConfig;\n    } // filePath isn't automatically ignored, so try to construct config\n\n\n    const matchingConfigs = [];\n    let matchFound = false;\n\n    for (const config of this) {\n      if (!config.files) {\n        debug(`Universal config found for ${filePath}`);\n        matchingConfigs.push(config);\n        continue;\n      }\n\n      if (pathMatches(filePath, this.basePath, config)) {\n        debug(`Matching config found for ${filePath}`);\n        matchingConfigs.push(config);\n        matchFound = true;\n        continue;\n      }\n    } // if matching both files and ignores, there will be no config to create\n\n\n    if (!matchFound) {\n      debug(`No matching configs found for ${filePath}`); // cache and return result - finalConfig is undefined at this point\n\n      this[ConfigArraySymbol.configCache].set(filePath, finalConfig);\n      return finalConfig;\n    } // otherwise construct the config\n\n\n    finalConfig = matchingConfigs.reduce((result, config) => {\n      return this[ConfigArraySymbol.schema].merge(result, config);\n    }, {}, this);\n    finalConfig = this[ConfigArraySymbol.finalizeConfig](finalConfig);\n    this[ConfigArraySymbol.configCache].set(filePath, finalConfig);\n    return finalConfig;\n  }\n  /**\n  \t * Determines if the given filepath is ignored based on the configs.\n  \t * @param {string} filePath The complete path of a file to check.\n  \t * @returns {boolean} True if the path is ignored, false if not.\n  \t */\n\n\n  isIgnored(filePath) {\n    return this.getConfig(filePath) === undefined;\n  }\n\n}\n\nexports.ConfigArray = ConfigArray;\nexports.ConfigArraySymbol = ConfigArraySymbol;","map":{"version":3,"names":["Object","defineProperty","exports","value","_interopDefault","ex","path","require","minimatch","createDebug","objectSchema","assertIsArray","Array","isArray","TypeError","assertIsArrayOfStringsAndFunctions","name","some","item","baseSchema","freeze","required","merge","undefined","validate","files","forEach","ignores","debug","MINIMATCH_OPTIONS","dot","CONFIG_TYPES","Set","isString","normalize","items","context","extraConfigTypes","allowFunctions","includes","allowArrays","flatTraverse","array","then","asyncIterable","configs","config","push","normalizeSync","shouldIgnoreFilePath","filePath","relativeFilePath","startsWith","shouldIgnore","matcher","flipNegate","pathMatches","basePath","relative","length","match","pattern","filePathMatchesPattern","every","assertNormalized","configArray","isNormalized","Error","assertExtraConfigTypes","configType","has","ConfigArraySymbol","Symbol","configCache","schema","finalizeConfig","preprocessConfig","dataCache","WeakMap","ConfigArray","constructor","normalized","customSchema","ObjectSchema","Map","set","explicitMatches","species","cache","get","result","filePattern","keys","normalizedConfigs","map","bind","isExplicitMatch","getConfig","finalConfig","matchingConfigs","matchFound","reduce","isIgnored"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/@humanwhocodes/config-array/api.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar path = _interopDefault(require('path'));\nvar minimatch = _interopDefault(require('minimatch'));\nvar createDebug = _interopDefault(require('debug'));\nvar objectSchema = require('@humanwhocodes/object-schema');\n\n/**\n * @fileoverview ConfigSchema\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Assets that a given value is an array.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array. \n */\nfunction assertIsArray(value) {\n\tif (!Array.isArray(value)) {\n\t\tthrow new TypeError('Expected value to be an array.');\n\t}\n}\n\n/**\n * Assets that a given value is an array containing only strings and functions.\n * @param {*} value The value to check.\n * @returns {void}\n * @throws {TypeError} When the value is not an array of strings and functions.\n */\nfunction assertIsArrayOfStringsAndFunctions(value, name) {\n\tassertIsArray(value);\n\n\tif (value.some(item => typeof item !== 'string' && typeof item !== 'function')) {\n\t\tthrow new TypeError('Expected array to only contain strings.');\n\t}\n}\n\n//------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\n * The base schema that every ConfigArray uses.\n * @type Object\n */\nconst baseSchema = Object.freeze({\n\tname: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate(value) {\n\t\t\tif (typeof value !== 'string') {\n\t\t\t\tthrow new TypeError('Property must be a string.');\n\t\t\t}\n\t\t}\n\t},\n\tfiles: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate(value) {\n\n\t\t\t// first check if it's an array\n\t\t\tassertIsArray(value);\n\n\t\t\t// then check each member\n\t\t\tvalue.forEach(item => {\n\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\tassertIsArrayOfStringsAndFunctions(item);\n\t\t\t\t} else if (typeof item !== 'string' && typeof item !== 'function') {\n\t\t\t\t\tthrow new TypeError('Items must be a string, a function, or an array of strings and functions.');\n\t\t\t\t}\n\t\t\t});\n\n\t\t}\n\t},\n\tignores: {\n\t\trequired: false,\n\t\tmerge() {\n\t\t\treturn undefined;\n\t\t},\n\t\tvalidate: assertIsArrayOfStringsAndFunctions\n\t}\n});\n\n/**\n * @fileoverview ConfigArray\n * @author Nicholas C. Zakas\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst debug = createDebug('@hwc/config-array');\n\nconst MINIMATCH_OPTIONS = {\n\t// matchBase: true,\n\tdot: true\n};\n\nconst CONFIG_TYPES = new Set(['array', 'function']);\n\n/**\n * Shorthand for checking if a value is a string.\n * @param {any} value The value to check.\n * @returns {boolean} True if a string, false if not. \n */\nfunction isString(value) {\n\treturn typeof value === 'string';\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Promise<Array>} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nasync function normalize(items, context, extraConfigTypes) {\n\n\tconst allowFunctions = extraConfigTypes.includes('function');\n\tconst allowArrays = extraConfigTypes.includes('array');\n\n\tasync function *flatTraverse(array) {\n\t\tfor (let item of array) {\n\t\t\tif (typeof item === 'function') {\n\t\t\t\tif (!allowFunctions) {\n\t\t\t\t\tthrow new TypeError('Unexpected function.');\n\t\t\t\t}\n\n\t\t\t\titem = item(context);\n\t\t\t\tif (item.then) {\n\t\t\t\t\titem = await item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\tif (!allowArrays) {\n\t\t\t\t\tthrow new TypeError('Unexpected array.');\n\t\t\t\t}\n\t\t\t\tyield * flatTraverse(item);\n\t\t\t} else if (typeof item === 'function') {\n\t\t\t\tthrow new TypeError('A config function can only return an object or array.');\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Async iterables cannot be used with the spread operator, so we need to manually\n\t * create the array to return.\n\t */\n\tconst asyncIterable = await flatTraverse(items);\n\tconst configs = [];\n\n\tfor await (const config of asyncIterable) {\n\t\tconfigs.push(config);\n\t}\n\n\treturn configs;\n}\n\n/**\n * Normalizes a `ConfigArray` by flattening it and executing any functions\n * that are found inside.\n * @param {Array} items The items in a `ConfigArray`.\n * @param {Object} context The context object to pass into any function\n *      found.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {Array} A flattened array containing only config objects.\n * @throws {TypeError} When a config function returns a function.\n */\nfunction normalizeSync(items, context, extraConfigTypes) {\n\n\tconst allowFunctions = extraConfigTypes.includes('function');\n\tconst allowArrays = extraConfigTypes.includes('array');\n\n\tfunction *flatTraverse(array) {\n\t\tfor (let item of array) {\n\t\t\tif (typeof item === 'function') {\n\n\t\t\t\tif (!allowFunctions) {\n\t\t\t\t\tthrow new TypeError('Unexpected function.');\n\t\t\t\t}\n\n\t\t\t\titem = item(context);\n\t\t\t\tif (item.then) {\n\t\t\t\t\tthrow new TypeError('Async config functions are not supported.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Array.isArray(item)) {\n\n\t\t\t\tif (!allowArrays) {\n\t\t\t\t\tthrow new TypeError('Unexpected array.');\n\t\t\t\t}\n\n\t\t\t\tyield * flatTraverse(item);\n\t\t\t} else if (typeof item === 'function') {\n\t\t\t\tthrow new TypeError('A config function can only return an object or array.');\n\t\t\t} else {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [...flatTraverse(items)];\n}\n\n/**\n * Determines if a given file path should be ignored based on the given\n * matcher.\n * @param {Array<string|() => boolean>} ignores The ignore patterns to check. \n * @param {string} filePath The absolute path of the file to check.\n * @param {string} relativeFilePath The relative path of the file to check.\n * @returns {boolean} True if the path should be ignored and false if not.\n */\nfunction shouldIgnoreFilePath(ignores, filePath, relativeFilePath) {\n\n\t// all files outside of the basePath are ignored\n\tif (relativeFilePath.startsWith('..')) {\n\t\treturn true;\n\t}\n\n\tlet shouldIgnore = false;\n\n\tfor (const matcher of ignores) {\n\n\t\tif (typeof matcher === 'function') {\n\t\t\tshouldIgnore = shouldIgnore || matcher(filePath);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If there's a negated pattern, that means anything matching\n\t\t * must NOT be ignored. To do that, we need to use the `flipNegate`\n\t\t * option for minimatch to check if the filepath matches the\n\t\t * pattern specified after the !, and if that result is true,\n\t\t * then we return false immediately because this file should\n\t\t * never be ignored.\n\t\t */\n\t\tif (matcher.startsWith('!')) {\n\n\t\t\t/*\n\t\t\t * The file must already be ignored in order to apply a negated\n\t\t\t * pattern, because negated patterns simply remove files that\n\t\t\t * would already be ignored.\n\t\t\t */\n\t\t\tif (shouldIgnore &&\n\t\t\t\tminimatch(relativeFilePath, matcher, {\n\t\t\t\t\t...MINIMATCH_OPTIONS,\n\t\t\t\t\tflipNegate: true\n\t\t\t\t})) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tshouldIgnore = shouldIgnore || minimatch(relativeFilePath, matcher, MINIMATCH_OPTIONS);\n\t\t}\n\n\t}\n\n\treturn shouldIgnore;\n}\n\n/**\n * Determines if a given file path is matched by a config. If the config\n * has no `files` field, then it matches; otherwise, if a `files` field\n * is present then we match the globs in `files` and exclude any globs in\n * `ignores`.\n * @param {string} filePath The absolute file path to check.\n * @param {Object} config The config object to check.\n * @returns {boolean} True if the file path is matched by the config,\n *      false if not.\n */\nfunction pathMatches(filePath, basePath, config) {\n\n\t/*\n\t * For both files and ignores, functions are passed the absolute\n\t * file path while strings are compared against the relative\n\t * file path.\n\t */\n\tconst relativeFilePath = path.relative(basePath, filePath);\n\n\t// if files isn't an array, throw an error\n\tif (!Array.isArray(config.files) || config.files.length === 0) {\n\t\tthrow new TypeError('The files key must be a non-empty array.');\n\t}\n\n\t// match both strings and functions\n\tconst match = pattern => {\n\n\t\tif (isString(pattern)) {\n\t\t\treturn minimatch(relativeFilePath, pattern, MINIMATCH_OPTIONS);\n\t\t}\n\n\t\tif (typeof pattern === 'function') {\n\t\t\treturn pattern(filePath);\n\t\t}\n\n\t\tthrow new TypeError(`Unexpected matcher type ${pattern}.`);\n\t};\n\n\t// check for all matches to config.files\n\tlet filePathMatchesPattern = config.files.some(pattern => {\n\t\tif (Array.isArray(pattern)) {\n\t\t\treturn pattern.every(match);\n\t\t}\n\n\t\treturn match(pattern);\n\t});\n\n\t/*\n\t * If the file path matches the config.files patterns, then check to see\n\t * if there are any files to ignore.\n\t */\n\tif (filePathMatchesPattern && config.ignores) {\n\t\tfilePathMatchesPattern = !shouldIgnoreFilePath(config.ignores, filePath, relativeFilePath);\n\t}\n\n\treturn filePathMatchesPattern;\n}\n\n/**\n * Ensures that a ConfigArray has been normalized.\n * @param {ConfigArray} configArray The ConfigArray to check. \n * @returns {void}\n * @throws {Error} When the `ConfigArray` is not normalized.\n */\nfunction assertNormalized(configArray) {\n\t// TODO: Throw more verbose error\n\tif (!configArray.isNormalized()) {\n\t\tthrow new Error('ConfigArray must be normalized to perform this operation.');\n\t}\n}\n\n/**\n * Ensures that config types are valid.\n * @param {Array<string>} extraConfigTypes The config types to check.\n * @returns {void}\n * @throws {Error} When the config types array is invalid.\n */\nfunction assertExtraConfigTypes(extraConfigTypes) {\n\tif (extraConfigTypes.length > 2) {\n\t\tthrow new TypeError('configTypes must be an array with at most two items.');\n\t}\n\n\tfor (const configType of extraConfigTypes) {\n\t\tif (!CONFIG_TYPES.has(configType)) {\n\t\t\tthrow new TypeError(`Unexpected config type \"${configType}\" found. Expected one of: \"object\", \"array\", \"function\".`);\n\t\t}\n\t}\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nconst ConfigArraySymbol = {\n\tisNormalized: Symbol('isNormalized'),\n\tconfigCache: Symbol('configCache'),\n\tschema: Symbol('schema'),\n\tfinalizeConfig: Symbol('finalizeConfig'),\n\tpreprocessConfig: Symbol('preprocessConfig')\n};\n\n// used to store calculate data for faster lookup\nconst dataCache = new WeakMap();\n\n/**\n * Represents an array of config objects and provides method for working with\n * those config objects.\n */\nclass ConfigArray extends Array {\n\n\t/**\n\t * Creates a new instance of ConfigArray.\n\t * @param {Iterable|Function|Object} configs An iterable yielding config\n\t *      objects, or a config function, or a config object.\n\t * @param {string} [options.basePath=\"\"] The path of the config file\n\t * @param {boolean} [options.normalized=false] Flag indicating if the\n\t *      configs have already been normalized.\n\t * @param {Object} [options.schema] The additional schema \n\t *      definitions to use for the ConfigArray schema.\n\t * @param {Array<string>} [options.configTypes] List of config types supported.\n\t */\n\tconstructor(configs, {\n\t\tbasePath = '',\n\t\tnormalized = false,\n\t\tschema: customSchema,\n\t\textraConfigTypes = []\n\t} = {}\n) {\n\t\tsuper();\n\n\t\t/**\n\t * Tracks if the array has been normalized.\n\t * @property isNormalized\n\t * @type boolean\n\t * @private\n\t */\n\t\tthis[ConfigArraySymbol.isNormalized] = normalized;\n\n\t\t/**\n\t * The schema used for validating and merging configs.\n\t * @property schema\n\t * @type ObjectSchema\n\t * @private\n\t */\n\t\tthis[ConfigArraySymbol.schema] = new objectSchema.ObjectSchema({\n\t\t\t...customSchema,\n\t\t\t...baseSchema\n\t\t});\n\n\t\t/**\n\t * The path of the config file that this array was loaded from.\n\t * This is used to calculate filename matches.\n\t * @property basePath\n\t * @type string\n\t */\n\t\tthis.basePath = basePath;\n\n\t\tassertExtraConfigTypes(extraConfigTypes);\n\n\t\t/**\n\t * The supported config types.\n\t * @property configTypes\n\t * @type Array<string>\n\t */\n\t\tthis.extraConfigTypes = Object.freeze([...extraConfigTypes]);\n\n\t\t/**\n\t * A cache to store calculated configs for faster repeat lookup.\n\t * @property configCache\n\t * @type Map\n\t * @private\n\t */\n\t\tthis[ConfigArraySymbol.configCache] = new Map();\n\n\t\t// init cache\n\t\tdataCache.set(this, { explicitMatches: new Map() });\n\n\t\t// load the configs into this array\n\t\tif (Array.isArray(configs)) {\n\t\tthis.push(...configs);\n\t\t} else {\n\t\tthis.push(configs);\n\t\t}\n\n\t}\n\n/**\n\t * Prevent normal array methods from creating a new `ConfigArray` instance.\n\t * This is to ensure that methods such as `slice()` won't try to create a \n\t * new instance of `ConfigArray` behind the scenes as doing so may throw\n\t * an error due to the different constructor signature.\n\t * @returns {Function} The `Array` constructor.\n\t */\nstatic get [Symbol.species]() {\n\treturn Array;\n}\n\n/**\n\t * Returns the `files` globs from every config object in the array.\n\t * This can be used to determine which files will be matched by a\n\t * config array or to use as a glob pattern when no patterns are provided\n\t * for a command line interface.\n\t * @returns {Array<string|Function>} An array of matchers.\n\t */\nget files() {\n\n\tassertNormalized(this);\n\n\t// if this data has been cached, retrieve it\n\tconst cache = dataCache.get(this);\n\n\tif (cache.files) {\n\t\treturn cache.files;\n\t}\n\n\t// otherwise calculate it\n\n\tconst result = [];\n\n\tfor (const config of this) {\n\t\tif (config.files) {\n\t\t\tconfig.files.forEach(filePattern => {\n\t\t\t\tresult.push(filePattern);\n\t\t\t});\n\t\t}\n\t}\n\n\t// store result\n\tcache.files = result;\n\tdataCache.set(this, cache);\n\n\treturn result;\n}\n\n/**\n\t * Returns ignore matchers that should always be ignored regardless of\n\t * the matching `files` fields in any configs. This is necessary to mimic\n\t * the behavior of things like .gitignore and .eslintignore, allowing a\n\t * globbing operation to be faster.\n\t * @returns {string[]} An array of string patterns and functions to be ignored.\n\t */\nget ignores() {\n\n\tassertNormalized(this);\n\n\t// if this data has been cached, retrieve it\n\tconst cache = dataCache.get(this);\n\n\tif (cache.ignores) {\n\t\treturn cache.ignores;\n\t}\n\n\t// otherwise calculate it\n\n\tconst result = [];\n\n\tfor (const config of this) {\n\n\t\t/*\n\t\t * We only count ignores if there are no other keys in the object.\n\t\t * In this case, it acts list a globally ignored pattern. If there\n\t\t * are additional keys, then ignores act like exclusions.\n\t\t */\n\t\tif (config.ignores && Object.keys(config).length === 1) {\n\t\t\tresult.push(...config.ignores);\n\t\t}\n\t}\n\n\t// store result\n\tcache.ignores = result;\n\tdataCache.set(this, cache);\n\n\treturn result;\n}\n\n/**\n\t * Indicates if the config array has been normalized.\n\t * @returns {boolean} True if the config array is normalized, false if not.\n\t */\nisNormalized() {\n\treturn this[ConfigArraySymbol.isNormalized];\n}\n\n/**\n\t * Normalizes a config array by flattening embedded arrays and executing\n\t * config functions.\n\t * @param {ConfigContext} context The context object for config functions.\n\t * @returns {Promise<ConfigArray>} The current ConfigArray instance.\n\t */\nasync normalize(context = {}) {\n\n\tif (!this.isNormalized()) {\n\t\tconst normalizedConfigs = await normalize(this, context, this.extraConfigTypes);\n\t\tthis.length = 0;\n\t\tthis.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n\t\tthis[ConfigArraySymbol.isNormalized] = true;\n\n\t\t// prevent further changes\n\t\tObject.freeze(this);\n\t}\n\n\treturn this;\n}\n\n/**\n\t * Normalizes a config array by flattening embedded arrays and executing\n\t * config functions.\n\t * @param {ConfigContext} context The context object for config functions.\n\t * @returns {ConfigArray} The current ConfigArray instance.\n\t */\nnormalizeSync(context = {}) {\n\n\tif (!this.isNormalized()) {\n\t\tconst normalizedConfigs = normalizeSync(this, context, this.extraConfigTypes);\n\t\tthis.length = 0;\n\t\tthis.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n\t\tthis[ConfigArraySymbol.isNormalized] = true;\n\n\t\t// prevent further changes\n\t\tObject.freeze(this);\n\t}\n\n\treturn this;\n}\n\n/**\n\t * Finalizes the state of a config before being cached and returned by\n\t * `getConfig()`. Does nothing by default but is provided to be\n\t * overridden by subclasses as necessary.\n\t * @param {Object} config The config to finalize.\n\t * @returns {Object} The finalized config.\n\t */\n[ConfigArraySymbol.finalizeConfig](config) {\n\treturn config;\n}\n\n/**\n\t * Preprocesses a config during the normalization process. This is the\n\t * method to override if you want to convert an array item before it is\n\t * validated for the first time. For example, if you want to replace a\n\t * string with an object, this is the method to override.\n\t * @param {Object} config The config to preprocess.\n\t * @returns {Object} The config to use in place of the argument.\n\t */\n[ConfigArraySymbol.preprocessConfig](config) {\n\treturn config;\n}\n\n/**\n\t * Determines if a given file path explicitly matches a `files` entry\n\t * and also doesn't match an `ignores` entry. Configs that don't have\n\t * a `files` property are not considered an explicit match.\n\t * @param {string} filePath The complete path of a file to check.\n\t * @returns {boolean} True if the file path matches a `files` entry\n\t * \t\tor false if not.\n\t */\nisExplicitMatch(filePath) {\n\n\tassertNormalized(this);\n\n\tconst cache = dataCache.get(this);\n\n\t// first check the cache to avoid duplicate work\n\tlet result = cache.explicitMatches.get(filePath);\n\n\tif (typeof result == 'boolean') {\n\t\treturn result;\n\t}\n\n\t// TODO: Maybe move elsewhere? Maybe combine with getConfig() logic?\n\tconst relativeFilePath = path.relative(this.basePath, filePath);\n\n\tif (shouldIgnoreFilePath(this.ignores, filePath, relativeFilePath)) {\n\t\tdebug(`Ignoring ${filePath}`);\n\n\t\t// cache and return result\n\t\tcache.explicitMatches.set(filePath, false);\n\t\treturn false;\n\t}\n\n\t// filePath isn't automatically ignored, so try to find a match\n\n\tfor (const config of this) {\n\n\t\tif (!config.files) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pathMatches(filePath, this.basePath, config)) {\n\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\tcache.explicitMatches.set(filePath, true);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n\t * Returns the config object for a given file path.\n\t * @param {string} filePath The complete path of a file to get a config for.\n\t * @returns {Object} The config object for this file.\n\t */\ngetConfig(filePath) {\n\n\tassertNormalized(this);\n\n\t// first check the cache to avoid duplicate work\n\tlet finalConfig = this[ConfigArraySymbol.configCache].get(filePath);\n\n\tif (finalConfig) {\n\t\treturn finalConfig;\n\t}\n\n\t// TODO: Maybe move elsewhere?\n\tconst relativeFilePath = path.relative(this.basePath, filePath);\n\n\tif (shouldIgnoreFilePath(this.ignores, filePath, relativeFilePath)) {\n\t\tdebug(`Ignoring ${filePath}`);\n\n\t\t// cache and return result - finalConfig is undefined at this point\n\t\tthis[ConfigArraySymbol.configCache].set(filePath, finalConfig);\n\t\treturn finalConfig;\n\t}\n\n\t// filePath isn't automatically ignored, so try to construct config\n\n\tconst matchingConfigs = [];\n\tlet matchFound = false;\n\n\tfor (const config of this) {\n\n\t\tif (!config.files) {\n\t\t\tdebug(`Universal config found for ${filePath}`);\n\t\t\tmatchingConfigs.push(config);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pathMatches(filePath, this.basePath, config)) {\n\t\t\tdebug(`Matching config found for ${filePath}`);\n\t\t\tmatchingConfigs.push(config);\n\t\t\tmatchFound = true;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t// if matching both files and ignores, there will be no config to create\n\tif (!matchFound) {\n\t\tdebug(`No matching configs found for ${filePath}`);\n\n\t\t// cache and return result - finalConfig is undefined at this point\n\t\tthis[ConfigArraySymbol.configCache].set(filePath, finalConfig);\n\t\treturn finalConfig;\n\t}\n\n\t// otherwise construct the config\n\n\tfinalConfig = matchingConfigs.reduce((result, config) => {\n\t\treturn this[ConfigArraySymbol.schema].merge(result, config);\n\t}, {}, this);\n\n\tfinalConfig = this[ConfigArraySymbol.finalizeConfig](finalConfig);\n\n\tthis[ConfigArraySymbol.configCache].set(filePath, finalConfig);\n\n\treturn finalConfig;\n}\n\n/**\n\t * Determines if the given filepath is ignored based on the configs.\n\t * @param {string} filePath The complete path of a file to check.\n\t * @returns {boolean} True if the path is ignored, false if not.\n\t */\nisIgnored(filePath) {\n\treturn this.getConfig(filePath) === undefined;\n}\n\n}\n\nexports.ConfigArray = ConfigArray;\nexports.ConfigArraySymbol = ConfigArraySymbol;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}