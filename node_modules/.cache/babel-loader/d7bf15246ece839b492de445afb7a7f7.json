{"ast":null,"code":"/**\n * @fileoverview Rule to enforce var declarations are only at the top of a function.\n * @author Danny Fritz\n * @author Gyandeep Singh\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"Require `var` declarations be placed at the top of their containing scope\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/vars-on-top\"\n    },\n    schema: [],\n    messages: {\n      top: \"All 'var' declarations must be at the top of the function scope.\"\n    }\n  },\n\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Has AST suggesting a directive.\n     * @param {ASTNode} node any node\n     * @returns {boolean} whether the given node structurally represents a directive\n     */\n    function looksLikeDirective(node) {\n      return node.type === \"ExpressionStatement\" && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n    }\n    /**\n     * Check to see if its a ES6 import declaration\n     * @param {ASTNode} node any node\n     * @returns {boolean} whether the given node represents a import declaration\n     */\n\n\n    function looksLikeImport(node) {\n      return node.type === \"ImportDeclaration\" || node.type === \"ImportSpecifier\" || node.type === \"ImportDefaultSpecifier\" || node.type === \"ImportNamespaceSpecifier\";\n    }\n    /**\n     * Checks whether a given node is a variable declaration or not.\n     * @param {ASTNode} node any node\n     * @returns {boolean} `true` if the node is a variable declaration.\n     */\n\n\n    function isVariableDeclaration(node) {\n      return node.type === \"VariableDeclaration\" || node.type === \"ExportNamedDeclaration\" && node.declaration && node.declaration.type === \"VariableDeclaration\";\n    }\n    /**\n     * Checks whether this variable is on top of the block body\n     * @param {ASTNode} node The node to check\n     * @param {ASTNode[]} statements collection of ASTNodes for the parent node block\n     * @returns {boolean} True if var is on top otherwise false\n     */\n\n\n    function isVarOnTop(node, statements) {\n      const l = statements.length;\n      let i = 0; // Skip over directives and imports. Static blocks don't have either.\n\n      if (node.parent.type !== \"StaticBlock\") {\n        for (; i < l; ++i) {\n          if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {\n            break;\n          }\n        }\n      }\n\n      for (; i < l; ++i) {\n        if (!isVariableDeclaration(statements[i])) {\n          return false;\n        }\n\n        if (statements[i] === node) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Checks whether variable is on top at the global level\n     * @param {ASTNode} node The node to check\n     * @param {ASTNode} parent Parent of the node\n     * @returns {void}\n     */\n\n\n    function globalVarCheck(node, parent) {\n      if (!isVarOnTop(node, parent.body)) {\n        context.report({\n          node,\n          messageId: \"top\"\n        });\n      }\n    }\n    /**\n     * Checks whether variable is on top at functional block scope level\n     * @param {ASTNode} node The node to check\n     * @returns {void}\n     */\n\n\n    function blockScopeVarCheck(node) {\n      const {\n        parent\n      } = node;\n\n      if (parent.type === \"BlockStatement\" && /Function/u.test(parent.parent.type) && isVarOnTop(node, parent.body)) {\n        return;\n      }\n\n      if (parent.type === \"StaticBlock\" && isVarOnTop(node, parent.body)) {\n        return;\n      }\n\n      context.report({\n        node,\n        messageId: \"top\"\n      });\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    return {\n      \"VariableDeclaration[kind='var']\"(node) {\n        if (node.parent.type === \"ExportNamedDeclaration\") {\n          globalVarCheck(node.parent, node.parent.parent);\n        } else if (node.parent.type === \"Program\") {\n          globalVarCheck(node, node.parent);\n        } else {\n          blockScopeVarCheck(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["module","exports","meta","type","docs","description","recommended","url","schema","messages","top","create","context","looksLikeDirective","node","expression","value","looksLikeImport","isVariableDeclaration","declaration","isVarOnTop","statements","l","length","i","parent","globalVarCheck","body","report","messageId","blockScopeVarCheck","test"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/vars-on-top.js"],"sourcesContent":["/**\n * @fileoverview Rule to enforce var declarations are only at the top of a function.\n * @author Danny Fritz\n * @author Gyandeep Singh\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"suggestion\",\n\n        docs: {\n            description: \"Require `var` declarations be placed at the top of their containing scope\",\n            recommended: false,\n            url: \"https://eslint.org/docs/rules/vars-on-top\"\n        },\n\n        schema: [],\n        messages: {\n            top: \"All 'var' declarations must be at the top of the function scope.\"\n        }\n    },\n\n    create(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Has AST suggesting a directive.\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * Check to see if its a ES6 import declaration\n         * @param {ASTNode} node any node\n         * @returns {boolean} whether the given node represents a import declaration\n         */\n        function looksLikeImport(node) {\n            return node.type === \"ImportDeclaration\" || node.type === \"ImportSpecifier\" ||\n                node.type === \"ImportDefaultSpecifier\" || node.type === \"ImportNamespaceSpecifier\";\n        }\n\n        /**\n         * Checks whether a given node is a variable declaration or not.\n         * @param {ASTNode} node any node\n         * @returns {boolean} `true` if the node is a variable declaration.\n         */\n        function isVariableDeclaration(node) {\n            return (\n                node.type === \"VariableDeclaration\" ||\n                (\n                    node.type === \"ExportNamedDeclaration\" &&\n                    node.declaration &&\n                    node.declaration.type === \"VariableDeclaration\"\n                )\n            );\n        }\n\n        /**\n         * Checks whether this variable is on top of the block body\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode[]} statements collection of ASTNodes for the parent node block\n         * @returns {boolean} True if var is on top otherwise false\n         */\n        function isVarOnTop(node, statements) {\n            const l = statements.length;\n            let i = 0;\n\n            // Skip over directives and imports. Static blocks don't have either.\n            if (node.parent.type !== \"StaticBlock\") {\n                for (; i < l; ++i) {\n                    if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {\n                        break;\n                    }\n                }\n            }\n\n            for (; i < l; ++i) {\n                if (!isVariableDeclaration(statements[i])) {\n                    return false;\n                }\n                if (statements[i] === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether variable is on top at the global level\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} parent Parent of the node\n         * @returns {void}\n         */\n        function globalVarCheck(node, parent) {\n            if (!isVarOnTop(node, parent.body)) {\n                context.report({ node, messageId: \"top\" });\n            }\n        }\n\n        /**\n         * Checks whether variable is on top at functional block scope level\n         * @param {ASTNode} node The node to check\n         * @returns {void}\n         */\n        function blockScopeVarCheck(node) {\n            const { parent } = node;\n\n            if (\n                parent.type === \"BlockStatement\" &&\n                /Function/u.test(parent.parent.type) &&\n                isVarOnTop(node, parent.body)\n            ) {\n                return;\n            }\n\n            if (\n                parent.type === \"StaticBlock\" &&\n                isVarOnTop(node, parent.body)\n            ) {\n                return;\n            }\n\n            context.report({ node, messageId: \"top\" });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            \"VariableDeclaration[kind='var']\"(node) {\n                if (node.parent.type === \"ExportNamedDeclaration\") {\n                    globalVarCheck(node.parent, node.parent.parent);\n                } else if (node.parent.type === \"Program\") {\n                    globalVarCheck(node, node.parent);\n                } else {\n                    blockScopeVarCheck(node);\n                }\n            }\n        };\n\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}