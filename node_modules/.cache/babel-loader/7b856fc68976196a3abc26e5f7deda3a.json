{"ast":null,"code":"/**\n * @fileoverview Prevents usage of Function.prototype.bind and arrow functions\n *               in React component props.\n * @author Daniel Lo Nigro <dan.cx>\n * @author Jacky Ho\n */\n'use strict';\n\nconst propName = require('jsx-ast-utils/propName');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst jsxUtil = require('../util/jsx');\n\nconst report = require('../util/report'); // -----------------------------------------------------------------------------\n// Rule Definition\n// -----------------------------------------------------------------------------\n\n\nconst messages = {\n  bindCall: 'JSX props should not use .bind()',\n  arrowFunc: 'JSX props should not use arrow functions',\n  bindExpression: 'JSX props should not use ::',\n  func: 'JSX props should not use functions'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow `.bind()` or arrow functions in JSX props',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('jsx-no-bind')\n    },\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        allowArrowFunctions: {\n          default: false,\n          type: 'boolean'\n        },\n        allowBind: {\n          default: false,\n          type: 'boolean'\n        },\n        allowFunctions: {\n          default: false,\n          type: 'boolean'\n        },\n        ignoreRefs: {\n          default: false,\n          type: 'boolean'\n        },\n        ignoreDOMComponents: {\n          default: false,\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {}; // Keep track of all the variable names pointing to a bind call,\n    // bind expression or an arrow function in different block statements\n\n    const blockVariableNameSets = {};\n    /**\n     * @param {string | number} blockStart\n     */\n\n    function setBlockVariableNameSet(blockStart) {\n      blockVariableNameSets[blockStart] = {\n        arrowFunc: new Set(),\n        bindCall: new Set(),\n        bindExpression: new Set(),\n        func: new Set()\n      };\n    }\n\n    function getNodeViolationType(node) {\n      const nodeType = node.type;\n\n      if (!configuration.allowBind && nodeType === 'CallExpression' && node.callee.type === 'MemberExpression' && node.callee.property.type === 'Identifier' && node.callee.property.name === 'bind') {\n        return 'bindCall';\n      }\n\n      if (nodeType === 'ConditionalExpression') {\n        return getNodeViolationType(node.test) || getNodeViolationType(node.consequent) || getNodeViolationType(node.alternate);\n      }\n\n      if (!configuration.allowArrowFunctions && nodeType === 'ArrowFunctionExpression') {\n        return 'arrowFunc';\n      }\n\n      if (!configuration.allowFunctions && (nodeType === 'FunctionExpression' || nodeType === 'FunctionDeclaration')) {\n        return 'func';\n      }\n\n      if (!configuration.allowBind && nodeType === 'BindExpression') {\n        return 'bindExpression';\n      }\n\n      return null;\n    }\n    /**\n     * @param {string | number} violationType\n     * @param {any} variableName\n     * @param {string | number} blockStart\n     */\n\n\n    function addVariableNameToSet(violationType, variableName, blockStart) {\n      blockVariableNameSets[blockStart][violationType].add(variableName);\n    }\n\n    function getBlockStatementAncestors(node) {\n      return context.getAncestors(node).reverse().filter(ancestor => ancestor.type === 'BlockStatement');\n    }\n\n    function reportVariableViolation(node, name, blockStart) {\n      const blockSets = blockVariableNameSets[blockStart];\n      const violationTypes = Object.keys(blockSets);\n      return violationTypes.find(type => {\n        if (blockSets[type].has(name)) {\n          report(context, messages[type], type, {\n            node\n          });\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    function findVariableViolation(node, name) {\n      getBlockStatementAncestors(node).find(block => reportVariableViolation(node, name, block.range[0]));\n    }\n\n    return {\n      BlockStatement(node) {\n        setBlockVariableNameSet(node.range[0]);\n      },\n\n      FunctionDeclaration(node) {\n        const blockAncestors = getBlockStatementAncestors(node);\n        const variableViolationType = getNodeViolationType(node);\n\n        if (blockAncestors.length > 0 && variableViolationType) {\n          addVariableNameToSet(variableViolationType, node.id.name, blockAncestors[0].range[0]);\n        }\n      },\n\n      VariableDeclarator(node) {\n        if (!node.init) {\n          return;\n        }\n\n        const blockAncestors = getBlockStatementAncestors(node);\n        const variableViolationType = getNodeViolationType(node.init);\n\n        if (blockAncestors.length > 0 && variableViolationType && node.parent.kind === 'const' // only support const right now\n        ) {\n          addVariableNameToSet(variableViolationType, node.id.name, blockAncestors[0].range[0]);\n        }\n      },\n\n      JSXAttribute(node) {\n        const isRef = configuration.ignoreRefs && propName(node) === 'ref';\n\n        if (isRef || !node.value || !node.value.expression) {\n          return;\n        }\n\n        const isDOMComponent = jsxUtil.isDOMComponent(node.parent);\n\n        if (configuration.ignoreDOMComponents && isDOMComponent) {\n          return;\n        }\n\n        const valueNode = node.value.expression;\n        const valueNodeType = valueNode.type;\n        const nodeViolationType = getNodeViolationType(valueNode);\n\n        if (valueNodeType === 'Identifier') {\n          findVariableViolation(node, valueNode.name);\n        } else if (nodeViolationType) {\n          report(context, messages[nodeViolationType], nodeViolationType, {\n            node\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["propName","require","docsUrl","jsxUtil","report","messages","bindCall","arrowFunc","bindExpression","func","module","exports","meta","docs","description","category","recommended","url","schema","type","properties","allowArrowFunctions","default","allowBind","allowFunctions","ignoreRefs","ignoreDOMComponents","additionalProperties","create","context","configuration","options","blockVariableNameSets","setBlockVariableNameSet","blockStart","Set","getNodeViolationType","node","nodeType","callee","property","name","test","consequent","alternate","addVariableNameToSet","violationType","variableName","add","getBlockStatementAncestors","getAncestors","reverse","filter","ancestor","reportVariableViolation","blockSets","violationTypes","Object","keys","find","has","findVariableViolation","block","range","BlockStatement","FunctionDeclaration","blockAncestors","variableViolationType","length","id","VariableDeclarator","init","parent","kind","JSXAttribute","isRef","value","expression","isDOMComponent","valueNode","valueNodeType","nodeViolationType"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-no-bind.js"],"sourcesContent":["/**\n * @fileoverview Prevents usage of Function.prototype.bind and arrow functions\n *               in React component props.\n * @author Daniel Lo Nigro <dan.cx>\n * @author Jacky Ho\n */\n\n'use strict';\n\nconst propName = require('jsx-ast-utils/propName');\nconst docsUrl = require('../util/docsUrl');\nconst jsxUtil = require('../util/jsx');\nconst report = require('../util/report');\n\n// -----------------------------------------------------------------------------\n// Rule Definition\n// -----------------------------------------------------------------------------\n\nconst messages = {\n  bindCall: 'JSX props should not use .bind()',\n  arrowFunc: 'JSX props should not use arrow functions',\n  bindExpression: 'JSX props should not use ::',\n  func: 'JSX props should not use functions',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Disallow `.bind()` or arrow functions in JSX props',\n      category: 'Best Practices',\n      recommended: false,\n      url: docsUrl('jsx-no-bind'),\n    },\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        allowArrowFunctions: {\n          default: false,\n          type: 'boolean',\n        },\n        allowBind: {\n          default: false,\n          type: 'boolean',\n        },\n        allowFunctions: {\n          default: false,\n          type: 'boolean',\n        },\n        ignoreRefs: {\n          default: false,\n          type: 'boolean',\n        },\n        ignoreDOMComponents: {\n          default: false,\n          type: 'boolean',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {};\n\n    // Keep track of all the variable names pointing to a bind call,\n    // bind expression or an arrow function in different block statements\n    const blockVariableNameSets = {};\n\n    /**\n     * @param {string | number} blockStart\n     */\n    function setBlockVariableNameSet(blockStart) {\n      blockVariableNameSets[blockStart] = {\n        arrowFunc: new Set(),\n        bindCall: new Set(),\n        bindExpression: new Set(),\n        func: new Set(),\n      };\n    }\n\n    function getNodeViolationType(node) {\n      const nodeType = node.type;\n      if (\n        !configuration.allowBind\n        && nodeType === 'CallExpression'\n        && node.callee.type === 'MemberExpression'\n        && node.callee.property.type === 'Identifier'\n        && node.callee.property.name === 'bind'\n      ) {\n        return 'bindCall';\n      }\n      if (nodeType === 'ConditionalExpression') {\n        return getNodeViolationType(node.test)\n               || getNodeViolationType(node.consequent)\n               || getNodeViolationType(node.alternate);\n      }\n      if (!configuration.allowArrowFunctions && nodeType === 'ArrowFunctionExpression') {\n        return 'arrowFunc';\n      }\n      if (\n        !configuration.allowFunctions\n        && (nodeType === 'FunctionExpression' || nodeType === 'FunctionDeclaration')\n      ) {\n        return 'func';\n      }\n      if (!configuration.allowBind && nodeType === 'BindExpression') {\n        return 'bindExpression';\n      }\n\n      return null;\n    }\n\n    /**\n     * @param {string | number} violationType\n     * @param {any} variableName\n     * @param {string | number} blockStart\n     */\n    function addVariableNameToSet(violationType, variableName, blockStart) {\n      blockVariableNameSets[blockStart][violationType].add(variableName);\n    }\n\n    function getBlockStatementAncestors(node) {\n      return context.getAncestors(node).reverse().filter(\n        (ancestor) => ancestor.type === 'BlockStatement'\n      );\n    }\n\n    function reportVariableViolation(node, name, blockStart) {\n      const blockSets = blockVariableNameSets[blockStart];\n      const violationTypes = Object.keys(blockSets);\n\n      return violationTypes.find((type) => {\n        if (blockSets[type].has(name)) {\n          report(context, messages[type], type, {\n            node,\n          });\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    function findVariableViolation(node, name) {\n      getBlockStatementAncestors(node).find(\n        (block) => reportVariableViolation(node, name, block.range[0])\n      );\n    }\n\n    return {\n      BlockStatement(node) {\n        setBlockVariableNameSet(node.range[0]);\n      },\n\n      FunctionDeclaration(node) {\n        const blockAncestors = getBlockStatementAncestors(node);\n        const variableViolationType = getNodeViolationType(node);\n\n        if (blockAncestors.length > 0 && variableViolationType) {\n          addVariableNameToSet(variableViolationType, node.id.name, blockAncestors[0].range[0]);\n        }\n      },\n\n      VariableDeclarator(node) {\n        if (!node.init) {\n          return;\n        }\n        const blockAncestors = getBlockStatementAncestors(node);\n        const variableViolationType = getNodeViolationType(node.init);\n\n        if (\n          blockAncestors.length > 0\n          && variableViolationType\n          && node.parent.kind === 'const' // only support const right now\n        ) {\n          addVariableNameToSet(\n            variableViolationType, node.id.name, blockAncestors[0].range[0]\n          );\n        }\n      },\n\n      JSXAttribute(node) {\n        const isRef = configuration.ignoreRefs && propName(node) === 'ref';\n        if (isRef || !node.value || !node.value.expression) {\n          return;\n        }\n        const isDOMComponent = jsxUtil.isDOMComponent(node.parent);\n        if (configuration.ignoreDOMComponents && isDOMComponent) {\n          return;\n        }\n        const valueNode = node.value.expression;\n        const valueNodeType = valueNode.type;\n        const nodeViolationType = getNodeViolationType(valueNode);\n\n        if (valueNodeType === 'Identifier') {\n          findVariableViolation(node, valueNode.name);\n        } else if (nodeViolationType) {\n          report(context, messages[nodeViolationType], nodeViolationType, {\n            node,\n          });\n        }\n      },\n    };\n  },\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,wBAAD,CAAxB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,iBAAD,CAAvB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,aAAD,CAAvB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,gBAAD,CAAtB,C,CAEA;AACA;AACA;;;AAEA,MAAMI,QAAQ,GAAG;EACfC,QAAQ,EAAE,kCADK;EAEfC,SAAS,EAAE,0CAFI;EAGfC,cAAc,EAAE,6BAHD;EAIfC,IAAI,EAAE;AAJS,CAAjB;AAOAC,MAAM,CAACC,OAAP,GAAiB;EACfC,IAAI,EAAE;IACJC,IAAI,EAAE;MACJC,WAAW,EAAE,oDADT;MAEJC,QAAQ,EAAE,gBAFN;MAGJC,WAAW,EAAE,KAHT;MAIJC,GAAG,EAAEf,OAAO,CAAC,aAAD;IAJR,CADF;IAQJG,QARI;IAUJa,MAAM,EAAE,CAAC;MACPC,IAAI,EAAE,QADC;MAEPC,UAAU,EAAE;QACVC,mBAAmB,EAAE;UACnBC,OAAO,EAAE,KADU;UAEnBH,IAAI,EAAE;QAFa,CADX;QAKVI,SAAS,EAAE;UACTD,OAAO,EAAE,KADA;UAETH,IAAI,EAAE;QAFG,CALD;QASVK,cAAc,EAAE;UACdF,OAAO,EAAE,KADK;UAEdH,IAAI,EAAE;QAFQ,CATN;QAaVM,UAAU,EAAE;UACVH,OAAO,EAAE,KADC;UAEVH,IAAI,EAAE;QAFI,CAbF;QAiBVO,mBAAmB,EAAE;UACnBJ,OAAO,EAAE,KADU;UAEnBH,IAAI,EAAE;QAFa;MAjBX,CAFL;MAwBPQ,oBAAoB,EAAE;IAxBf,CAAD;EAVJ,CADS;;EAuCfC,MAAM,CAACC,OAAD,EAAU;IACd,MAAMC,aAAa,GAAGD,OAAO,CAACE,OAAR,CAAgB,CAAhB,KAAsB,EAA5C,CADc,CAGd;IACA;;IACA,MAAMC,qBAAqB,GAAG,EAA9B;IAEA;AACJ;AACA;;IACI,SAASC,uBAAT,CAAiCC,UAAjC,EAA6C;MAC3CF,qBAAqB,CAACE,UAAD,CAArB,GAAoC;QAClC3B,SAAS,EAAE,IAAI4B,GAAJ,EADuB;QAElC7B,QAAQ,EAAE,IAAI6B,GAAJ,EAFwB;QAGlC3B,cAAc,EAAE,IAAI2B,GAAJ,EAHkB;QAIlC1B,IAAI,EAAE,IAAI0B,GAAJ;MAJ4B,CAApC;IAMD;;IAED,SAASC,oBAAT,CAA8BC,IAA9B,EAAoC;MAClC,MAAMC,QAAQ,GAAGD,IAAI,CAAClB,IAAtB;;MACA,IACE,CAACW,aAAa,CAACP,SAAf,IACGe,QAAQ,KAAK,gBADhB,IAEGD,IAAI,CAACE,MAAL,CAAYpB,IAAZ,KAAqB,kBAFxB,IAGGkB,IAAI,CAACE,MAAL,CAAYC,QAAZ,CAAqBrB,IAArB,KAA8B,YAHjC,IAIGkB,IAAI,CAACE,MAAL,CAAYC,QAAZ,CAAqBC,IAArB,KAA8B,MALnC,EAME;QACA,OAAO,UAAP;MACD;;MACD,IAAIH,QAAQ,KAAK,uBAAjB,EAA0C;QACxC,OAAOF,oBAAoB,CAACC,IAAI,CAACK,IAAN,CAApB,IACGN,oBAAoB,CAACC,IAAI,CAACM,UAAN,CADvB,IAEGP,oBAAoB,CAACC,IAAI,CAACO,SAAN,CAF9B;MAGD;;MACD,IAAI,CAACd,aAAa,CAACT,mBAAf,IAAsCiB,QAAQ,KAAK,yBAAvD,EAAkF;QAChF,OAAO,WAAP;MACD;;MACD,IACE,CAACR,aAAa,CAACN,cAAf,KACIc,QAAQ,KAAK,oBAAb,IAAqCA,QAAQ,KAAK,qBADtD,CADF,EAGE;QACA,OAAO,MAAP;MACD;;MACD,IAAI,CAACR,aAAa,CAACP,SAAf,IAA4Be,QAAQ,KAAK,gBAA7C,EAA+D;QAC7D,OAAO,gBAAP;MACD;;MAED,OAAO,IAAP;IACD;IAED;AACJ;AACA;AACA;AACA;;;IACI,SAASO,oBAAT,CAA8BC,aAA9B,EAA6CC,YAA7C,EAA2Db,UAA3D,EAAuE;MACrEF,qBAAqB,CAACE,UAAD,CAArB,CAAkCY,aAAlC,EAAiDE,GAAjD,CAAqDD,YAArD;IACD;;IAED,SAASE,0BAAT,CAAoCZ,IAApC,EAA0C;MACxC,OAAOR,OAAO,CAACqB,YAAR,CAAqBb,IAArB,EAA2Bc,OAA3B,GAAqCC,MAArC,CACJC,QAAD,IAAcA,QAAQ,CAAClC,IAAT,KAAkB,gBAD3B,CAAP;IAGD;;IAED,SAASmC,uBAAT,CAAiCjB,IAAjC,EAAuCI,IAAvC,EAA6CP,UAA7C,EAAyD;MACvD,MAAMqB,SAAS,GAAGvB,qBAAqB,CAACE,UAAD,CAAvC;MACA,MAAMsB,cAAc,GAAGC,MAAM,CAACC,IAAP,CAAYH,SAAZ,CAAvB;MAEA,OAAOC,cAAc,CAACG,IAAf,CAAqBxC,IAAD,IAAU;QACnC,IAAIoC,SAAS,CAACpC,IAAD,CAAT,CAAgByC,GAAhB,CAAoBnB,IAApB,CAAJ,EAA+B;UAC7BrC,MAAM,CAACyB,OAAD,EAAUxB,QAAQ,CAACc,IAAD,CAAlB,EAA0BA,IAA1B,EAAgC;YACpCkB;UADoC,CAAhC,CAAN;UAGA,OAAO,IAAP;QACD;;QAED,OAAO,KAAP;MACD,CATM,CAAP;IAUD;;IAED,SAASwB,qBAAT,CAA+BxB,IAA/B,EAAqCI,IAArC,EAA2C;MACzCQ,0BAA0B,CAACZ,IAAD,CAA1B,CAAiCsB,IAAjC,CACGG,KAAD,IAAWR,uBAAuB,CAACjB,IAAD,EAAOI,IAAP,EAAaqB,KAAK,CAACC,KAAN,CAAY,CAAZ,CAAb,CADpC;IAGD;;IAED,OAAO;MACLC,cAAc,CAAC3B,IAAD,EAAO;QACnBJ,uBAAuB,CAACI,IAAI,CAAC0B,KAAL,CAAW,CAAX,CAAD,CAAvB;MACD,CAHI;;MAKLE,mBAAmB,CAAC5B,IAAD,EAAO;QACxB,MAAM6B,cAAc,GAAGjB,0BAA0B,CAACZ,IAAD,CAAjD;QACA,MAAM8B,qBAAqB,GAAG/B,oBAAoB,CAACC,IAAD,CAAlD;;QAEA,IAAI6B,cAAc,CAACE,MAAf,GAAwB,CAAxB,IAA6BD,qBAAjC,EAAwD;UACtDtB,oBAAoB,CAACsB,qBAAD,EAAwB9B,IAAI,CAACgC,EAAL,CAAQ5B,IAAhC,EAAsCyB,cAAc,CAAC,CAAD,CAAd,CAAkBH,KAAlB,CAAwB,CAAxB,CAAtC,CAApB;QACD;MACF,CAZI;;MAcLO,kBAAkB,CAACjC,IAAD,EAAO;QACvB,IAAI,CAACA,IAAI,CAACkC,IAAV,EAAgB;UACd;QACD;;QACD,MAAML,cAAc,GAAGjB,0BAA0B,CAACZ,IAAD,CAAjD;QACA,MAAM8B,qBAAqB,GAAG/B,oBAAoB,CAACC,IAAI,CAACkC,IAAN,CAAlD;;QAEA,IACEL,cAAc,CAACE,MAAf,GAAwB,CAAxB,IACGD,qBADH,IAEG9B,IAAI,CAACmC,MAAL,CAAYC,IAAZ,KAAqB,OAH1B,CAGkC;QAHlC,EAIE;UACA5B,oBAAoB,CAClBsB,qBADkB,EACK9B,IAAI,CAACgC,EAAL,CAAQ5B,IADb,EACmByB,cAAc,CAAC,CAAD,CAAd,CAAkBH,KAAlB,CAAwB,CAAxB,CADnB,CAApB;QAGD;MACF,CA9BI;;MAgCLW,YAAY,CAACrC,IAAD,EAAO;QACjB,MAAMsC,KAAK,GAAG7C,aAAa,CAACL,UAAd,IAA4BzB,QAAQ,CAACqC,IAAD,CAAR,KAAmB,KAA7D;;QACA,IAAIsC,KAAK,IAAI,CAACtC,IAAI,CAACuC,KAAf,IAAwB,CAACvC,IAAI,CAACuC,KAAL,CAAWC,UAAxC,EAAoD;UAClD;QACD;;QACD,MAAMC,cAAc,GAAG3E,OAAO,CAAC2E,cAAR,CAAuBzC,IAAI,CAACmC,MAA5B,CAAvB;;QACA,IAAI1C,aAAa,CAACJ,mBAAd,IAAqCoD,cAAzC,EAAyD;UACvD;QACD;;QACD,MAAMC,SAAS,GAAG1C,IAAI,CAACuC,KAAL,CAAWC,UAA7B;QACA,MAAMG,aAAa,GAAGD,SAAS,CAAC5D,IAAhC;QACA,MAAM8D,iBAAiB,GAAG7C,oBAAoB,CAAC2C,SAAD,CAA9C;;QAEA,IAAIC,aAAa,KAAK,YAAtB,EAAoC;UAClCnB,qBAAqB,CAACxB,IAAD,EAAO0C,SAAS,CAACtC,IAAjB,CAArB;QACD,CAFD,MAEO,IAAIwC,iBAAJ,EAAuB;UAC5B7E,MAAM,CAACyB,OAAD,EAAUxB,QAAQ,CAAC4E,iBAAD,CAAlB,EAAuCA,iBAAvC,EAA0D;YAC9D5C;UAD8D,CAA1D,CAAN;QAGD;MACF;;IApDI,CAAP;EAsDD;;AArLc,CAAjB"},"metadata":{},"sourceType":"script"}