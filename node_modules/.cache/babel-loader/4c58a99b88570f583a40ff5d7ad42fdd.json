{"ast":null,"code":"// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\n\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\n\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\nvar UrlType;\n\n(function (UrlType) {\n  UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n  UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n  UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n  UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n  UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n  UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n  UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n})(UrlType || (UrlType = {}));\n\nfunction isAbsoluteUrl(input) {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input) {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input) {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input) {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input) {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input) {\n  const match = urlRegex.exec(input);\n  return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n}\n\nfunction parseFileUrl(input) {\n  const match = fileRegex.exec(input);\n  const path = match[2];\n  return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n}\n\nfunction makeUrl(scheme, user, host, port, path, query, hash) {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute\n  };\n}\n\nfunction parseUrl(input) {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input ? input.startsWith('?') ? UrlType.Query : input.startsWith('#') ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path) {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url, base) {\n  normalizePath(base, base.type); // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\n\n\nfunction normalizePath(url, type) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/'); // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n\n  let pointer = 1; // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n\n  let positive = 0; // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i]; // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    } // If we encounter a real directory, then we don't need to append anymore.\n\n\n    addTrailingSlash = false; // A current directory, which we can always drop.\n\n    if (piece === '.') continue; // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n\n      continue;\n    } // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n\n\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n\n  if (!path || addTrailingSlash && !path.endsWith('/..')) {\n    path += '/';\n  }\n\n  url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\n\n\nfunction resolve(input, base) {\n  if (!input && !base) return '';\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n  const queryHash = url.query + url.hash;\n\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath:\n      {\n        // The first char is always a \"/\", and we need it to be relative.\n        const path = url.path.slice(1);\n        if (!path) return queryHash || '.';\n\n        if (isRelative(base || input) && !isRelative(path)) {\n          // If base started with a leading \".\", or there is no base and input started with a \".\",\n          // then we need to ensure that the relative path starts with a \".\". We don't know if\n          // relative starts with a \"..\", though, so check before prepending.\n          return './' + path + queryHash;\n        }\n\n        return path + queryHash;\n      }\n\n    case UrlType.AbsolutePath:\n      return url.path + queryHash;\n\n    default:\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n  }\n}\n\nexport { resolve as default };","map":{"version":3,"mappings":"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","names":["schemeRegex","urlRegex","fileRegex","UrlType","isAbsoluteUrl","input","test","isSchemeRelativeUrl","startsWith","isAbsolutePath","isFileUrl","isRelative","parseAbsoluteUrl","match","exec","makeUrl","parseFileUrl","path","scheme","user","host","port","query","hash","type","Absolute","parseUrl","url","SchemeRelative","AbsolutePath","Query","Hash","RelativePath","Empty","stripPathFilename","endsWith","index","lastIndexOf","slice","mergePaths","base","normalizePath","rel","pieces","split","pointer","positive","addTrailingSlash","i","length","piece","resolve","inputType","baseUrl","baseType","queryHash"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@jridgewell\\resolve-uri\\src\\resolve-uri.ts"],"sourcesContent":["// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n  type: UrlType;\n};\n\nenum UrlType {\n  Empty = 1,\n  Hash = 2,\n  Query = 3,\n  RelativePath = 4,\n  AbsolutePath = 5,\n  SchemeRelative = 6,\n  Absolute = 7,\n}\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input: string): boolean {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(\n    match[1],\n    match[2] || '',\n    match[3],\n    match[4] || '',\n    match[5] || '/',\n    match[6] || '',\n    match[7] || '',\n  );\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl(\n    'file:',\n    '',\n    match[1] || '',\n    '',\n    isAbsolutePath(path) ? path : '/' + path,\n    match[3] || '',\n    match[4] || '',\n  );\n}\n\nfunction makeUrl(\n  scheme: string,\n  user: string,\n  host: string,\n  port: string,\n  path: string,\n  query: string,\n  hash: string,\n): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input\n    ? input.startsWith('?')\n      ? UrlType.Query\n      : input.startsWith('#')\n      ? UrlType.Hash\n      : UrlType.RelativePath\n    : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  normalizePath(base, base.type);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url, type: UrlType) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath: {\n      // The first char is always a \"/\", and we need it to be relative.\n      const path = url.path.slice(1);\n\n      if (!path) return queryHash || '.';\n\n      if (isRelative(base || input) && !isRelative(path)) {\n        // If base started with a leading \".\", or there is no base and input started with a \".\",\n        // then we need to ensure that the relative path starts with a \".\". We don't know if\n        // relative starts with a \"..\", though, so check before prepending.\n        return './' + path + queryHash;\n      }\n\n      return path + queryHash;\n    }\n\n    case UrlType.AbsolutePath:\n      return url.path + queryHash;\n\n    default:\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}