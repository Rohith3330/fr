{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._containerInsert = _containerInsert;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._verifyNodeList = _verifyNodeList;\nexports.hoist = hoist;\nexports.insertAfter = insertAfter;\nexports.insertBefore = insertBefore;\nexports.pushContainer = pushContainer;\nexports.unshiftContainer = unshiftContainer;\nexports.updateSiblingKeys = updateSiblingKeys;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isAssignmentExpression,\n  isCallExpression,\n  isExpression,\n  isIdentifier,\n  isSequenceExpression,\n  isSuper,\n  thisExpression\n} = _t;\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nconst last = arr => arr[arr.length - 1];\n\nfunction isHiddenInSequenceExpression(path) {\n  return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));\n}\n\nfunction isAlmostConstantAssignment(node, scope) {\n  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {\n    return false;\n  }\n\n  const blockScope = scope.getBlockParent();\n  return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  if (this.isSequenceExpression()) {\n    return last(this.get(\"expressions\")).insertAfter(nodes_);\n  }\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return isExpression(node) ? expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (isHiddenInSequenceExpression(this)) {\n        nodes.unshift(node);\n      } else if (isCallExpression(node) && isSuper(node.callee)) {\n        nodes.unshift(node);\n        nodes.push(thisExpression());\n      } else if (isAlmostConstantAssignment(node, scope)) {\n        nodes.unshift(node);\n        nodes.push(cloneNode(node.left));\n      } else if (scope.isPure(node, true)) {\n        nodes.push(node);\n      } else {\n        if (parentPath.isMethod({\n          computed: true,\n          key: node\n        })) {\n          scope = scope.parent;\n        }\n\n        const temp = scope.generateDeclaredUidIdentifier();\n        nodes.unshift(expressionStatement(assignmentExpression(\"=\", cloneNode(temp), node)));\n        nodes.push(expressionStatement(cloneNode(temp)));\n      }\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist() {\n  let scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scope;\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;AAEA;;AACA;;AACA;;AACA;;;EACEA;EACAC;EACAC;EACAC;EACAC;EACAC;EACAC;EACAC;EACAC;EACAC;EACAC;EACAC;EACAC;EACAC;;;AASK,SAASC,YAAT,CAELC,MAFK,EAGO;EACZ,KAAKC,gBAAL;;EAEA,MAAMC,KAAK,GAAG,KAAKC,eAAL,CAAqBH,MAArB,CAAd;;EAEA,MAAM;IAAEI;EAAF,IAAiB,IAAvB;;EAEA,IACEA,UAAU,CAACC,qBAAXD,MACAA,UAAU,CAACE,kBAAXF,EADAA,IAEAA,UAAU,CAACG,wBAAXH,EAFAA,IAGCA,UAAU,CAACI,0BAAXJ,MAA2C,KAAKK,aAAL,EAJ9C,EAKE;IACA,OAAOL,UAAU,CAACL,YAAXK,CAAwBF,KAAxBE,CAAP;EANF,OAOO,IACJ,KAAKM,UAAL,CAAgB,YAAhB,KAAiC,CAAC,KAAKC,YAAL,EAAlC,IACAP,UAAU,CAACQ,cAAXR,MAA+B,KAAKS,GAAL,KAAa,MAFxC,EAGL;IACA,IAAI,KAAKC,IAAT,EAAeZ,KAAK,CAACa,IAANb,CAAW,KAAKY,IAAhBZ;IAEf,OAAO,KAAKc,+BAAL,CAAqCd,KAArC,CAAP;EANK,OAOA,IAAIe,KAAK,CAACC,OAAND,CAAc,KAAKE,SAAnBF,CAAJ,EAAmC;IACxC,OAAO,KAAKG,sBAAL,CAA4BlB,KAA5B,CAAP;EADK,OAEA,IAAI,KAAKmB,kBAAL,EAAJ,EAA+B;IACpC,MAAMP,IAAI,GAAG,KAAKA,IAAlB;IACA,MAAMQ,uBAAuB,GAC3BR,IAAI,KACH,CAAC,KAAKT,qBAAL,EAAD,IACES,IAAD,CAAgCS,UAA/BT,IAA6C,IAF5C,CADN;IAKA,KAAKU,WAAL,CAAiBpC,cAAc,CAACkC,uBAAuB,GAAG,CAACR,IAAD,CAAH,GAAY,EAApC,CAA/B;IACA,OAAQ,KAAoCW,gBAApC,CACN,MADM,EAGNvB,KAHM,CAAR;EARK,OAaA;IACL,MAAM,IAAIwB,KAAJ,CACJ,mDACE,0DAFE,CAAN;EAID;AACF;;AAEM,SAASC,gBAAT,CAELC,IAFK,EAGL1B,KAHK,EAIU;EACf,KAAK2B,iBAAL,CAAuBD,IAAvB,EAA6B1B,KAAK,CAAC4B,MAAnC;EAEA,MAAMC,KAAoB,GAAG,EAA7B;EAGA,KAAKZ,SAAL,CAAea,MAAf,CAAsBJ,IAAtB,EAA4B,CAA5B,EAA+B,GAAG1B,KAAlC;;EACA,KAAK,IAAI+B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG/B,KAAK,CAAC4B,MAA1B,EAAkCG,CAAC,EAAnC,EAAuC;IACrC,MAAMC,EAAE,GAAGN,IAAI,GAAGK,CAAlB;IACA,MAAME,IAAI,GAAG,KAAKC,UAAL,CAAgBF,EAAhB,CAAb;IACAH,KAAK,CAAChB,IAANgB,CAAWI,IAAXJ;;IAEA,IAAI,KAAKM,OAAL,IAAgB,KAAKA,OAAL,CAAaC,KAAjC,EAAwC;MACtCH,IAAI,CAACI,WAALJ,CAAiB,KAAKE,OAAtBF;IACD;EACF;;EAED,MAAMK,QAAQ,GAAG,KAAKC,iBAAL,EAAjB;;EAEA,KAAK,MAAMN,IAAX,IAAmBJ,KAAnB,EAA0B;IACxBI,IAAI,CAACO,QAALP;IACAA,IAAI,CAACQ,KAALR,CAAW,WAAXA;;IAEA,KAAK,MAAME,OAAX,IAAsBG,QAAtB,EAAgC;MAC9BH,OAAO,CAACO,UAARP,CAAmBF,IAAnBE,EAAyB,IAAzBA;IACD;EACF;;EAED,OAAON,KAAP;AACD;;AAEM,SAASX,sBAAT,CAELlB,KAFK,EAGL;EACA,OAAO,KAAKyB,gBAAL,CAAsB,KAAKd,GAA3B,EAA0CX,KAA1C,CAAP;AACD;;AAEM,SAAS2C,qBAAT,CAEL3C,KAFK,EAGL;EACA,OAAO,KAAKyB,gBAAL,CAAuB,KAAKd,GAAL,GAAsB,CAA7C,EAAgDX,KAAhD,CAAP;AACD;;AAED,MAAM4C,IAAI,GAAOC,GAAJ,IAAiBA,GAAG,CAACA,GAAG,CAACjB,MAAJiB,GAAa,CAAd,CAAjC;;AAEA,SAASC,4BAAT,CAAsCb,IAAtC,EAA+D;EAC7D,OACEvC,oBAAoB,CAACuC,IAAI,CAACc,MAAN,CAApBrD,KACCkD,IAAI,CAACX,IAAI,CAACc,MAALd,CAAYe,WAAb,CAAJJ,KAAkCX,IAAI,CAACrB,IAAvCgC,IACCE,4BAA4B,CAACb,IAAI,CAAC/B,UAAN,CAF9BR,CADF;AAKD;;AAED,SAASuD,0BAAT,CACErC,IADF,EAEEsC,KAFF,EAG2D;EACzD,IAAI,CAAC5D,sBAAsB,CAACsB,IAAD,CAAvB,IAAiC,CAACnB,YAAY,CAACmB,IAAI,CAACuC,IAAN,CAAlD,EAA+D;IAC7D,OAAO,KAAP;EACD;;EAID,MAAMC,UAAU,GAAGF,KAAK,CAACG,cAANH,EAAnB;EAIA,OACEE,UAAU,CAACE,aAAXF,CAAyBxC,IAAI,CAACuC,IAALvC,CAAU2C,IAAnCH,KACAA,UAAU,CAACI,aAAXJ,CAAyBxC,IAAI,CAACuC,IAALvC,CAAU2C,IAAnCH,EAAyCK,kBAAzCL,CAA4DxB,MAA5DwB,IAAsE,CAFxE;AAID;;AAOM,SAASM,WAAT,CAEL5D,MAFK,EAGO;EACZ,KAAKC,gBAAL;;EAEA,IAAI,KAAKL,oBAAL,EAAJ,EAAiC;IAC/B,OAAOkD,IAAI,CAAC,KAAKe,GAAL,CAAS,aAAT,CAAD,CAAJf,CAA8Bc,WAA9Bd,CAA0C9C,MAA1C8C,CAAP;EACD;;EAED,MAAM5C,KAAK,GAAG,KAAKC,eAAL,CAAqBH,MAArB,CAAd;;EAEA,MAAM;IAAEI;EAAF,IAAiB,IAAvB;;EACA,IACEA,UAAU,CAACC,qBAAXD,MACAA,UAAU,CAACE,kBAAXF,EADAA,IAEAA,UAAU,CAACG,wBAAXH,EAFAA,IAGCA,UAAU,CAACI,0BAAXJ,MAA2C,KAAKK,aAAL,EAJ9C,EAKE;IACA,OAAOL,UAAU,CAACwD,WAAXxD,CACLF,KAAK,CAAC4D,GAAN5D,CAAUY,IAAI,IAAI;MAOhB,OAAOpB,YAAY,CAACoB,IAAD,CAAZpB,GAAqBH,mBAAmB,CAACuB,IAAD,CAAxCpB,GAAiDoB,IAAxD;IAPF,EADKV,CAAP;EANF,OAiBO,IACJ,KAAKM,UAAL,CAAgB,YAAhB,KACC,CAAC,KAAKC,YAAL,EADF,IAEC,CAACP,UAAU,CAACO,YAAXP,EAFF,IAGAA,UAAU,CAACQ,cAAXR,MAA+B,KAAKS,GAAL,KAAa,MAJxC,EAKL;IACA,IAAI,KAAKC,IAAT,EAAe;MACb,MAAMA,IAAI,GAAG,KAAKA,IAAlB;MACA,IAAI;QAAEsC;MAAF,IAAY,IAAhB;;MAEA,IAAIA,KAAK,CAACjB,IAANiB,CAAWW,SAAXX,EAAJ,EAA4B;QAC1BlE,gBAAgB,CAAC4B,IAAD,CAAhB5B;QAEA,KAAKsC,WAAL,CAAiBnC,cAAc,CAACJ,uBAAuB,CAAC,EAAD,EAAK6B,IAAL,CAAxB,EAAoC,EAApC,CAA/B;QACC,KAAK+C,GAAL,CAAS,aAAT,EAAmDD,WAAnD,CAA+D1D,KAA/D;QACD,OAAO,CAAC,IAAD,CAAP;MACD;;MAED,IAAI8C,4BAA4B,CAAC,IAAD,CAAhC,EAAwC;QACtC9C,KAAK,CAAC8D,OAAN9D,CAAcY,IAAdZ;MADF,OAIK,IAAIT,gBAAgB,CAACqB,IAAD,CAAhBrB,IAA0BI,OAAO,CAACiB,IAAI,CAACmD,MAAN,CAArC,EAAoD;QACvD/D,KAAK,CAAC8D,OAAN9D,CAAcY,IAAdZ;QAEAA,KAAK,CAACa,IAANb,CAAWJ,cAAc,EAAzBI;MAHG,OAIE,IAAIiD,0BAA0B,CAACrC,IAAD,EAAOsC,KAAP,CAA9B,EAA6C;QAClDlD,KAAK,CAAC8D,OAAN9D,CAAcY,IAAdZ;QACAA,KAAK,CAACa,IAANb,CAAWZ,SAAS,CAACwB,IAAI,CAACuC,IAAN,CAApBnD;MAFK,OAGA,IAAIkD,KAAK,CAACc,MAANd,CAAatC,IAAbsC,EAAmB,IAAnBA,CAAJ,EAA8B;QAEnClD,KAAK,CAACa,IAANb,CAAWY,IAAXZ;MAFK,OAGA;QAGL,IAAIE,UAAU,CAAC+D,QAAX/D,CAAoB;UAAEgE,QAAQ,EAAE,IAAZ;UAAkBvD,GAAG,EAAEC;QAAvB,CAApBV,CAAJ,EAAwD;UACtDgD,KAAK,GAAGA,KAAK,CAACH,MAAdG;QACD;;QACD,MAAMiB,IAAI,GAAGjB,KAAK,CAACkB,6BAANlB,EAAb;QACAlD,KAAK,CAAC8D,OAAN9D,CACEX,mBAAmB,CAIjBJ,oBAAoB,CAAC,GAAD,EAAMG,SAAS,CAAC+E,IAAD,CAAf,EAAuBvD,IAAvB,CAJH,CADrBZ;QAQAA,KAAK,CAACa,IAANb,CAAWX,mBAAmB,CAACD,SAAS,CAAC+E,IAAD,CAAV,CAA9BnE;MACD;IACF;;IAED,OAAO,KAAKc,+BAAL,CAAqCd,KAArC,CAAP;EAnDK,OAoDA,IAAIe,KAAK,CAACC,OAAND,CAAc,KAAKE,SAAnBF,CAAJ,EAAmC;IACxC,OAAO,KAAK4B,qBAAL,CAA2B3C,KAA3B,CAAP;EADK,OAEA,IAAI,KAAKmB,kBAAL,EAAJ,EAA+B;IACpC,MAAMP,IAAI,GAAG,KAAKA,IAAlB;IACA,MAAMQ,uBAAuB,GAC3BR,IAAI,KACH,CAAC,KAAKT,qBAAL,EAAD,IACES,IAAD,CAAgCS,UAA/BT,IAA6C,IAF5C,CADN;IAKA,KAAKU,WAAL,CAAiBpC,cAAc,CAACkC,uBAAuB,GAAG,CAACR,IAAD,CAAH,GAAY,EAApC,CAA/B;IAEA,OAAO,KAAKyD,aAAL,CAAmB,MAAnB,EAA2BrE,KAA3B,CAAP;EATK,OAUA;IACL,MAAM,IAAIwB,KAAJ,CACJ,mDACE,0DAFE,CAAN;EAID;AACF;;AAMM,SAASG,iBAAT,CAEL2C,SAFK,EAGLC,WAHK,EAIL;EACA,IAAI,CAAC,KAAKxB,MAAV,EAAkB;;EAElB,MAAMlB,KAAK,GAAG2C,YAAUb,GAAVa,CAAc,KAAKzB,MAAnByB,CAAd;;EACA,KAAK,MAAM,GAAGvC,IAAH,CAAX,IAAuBJ,KAAvB,EAA8B;IAC5B,IAAII,IAAI,CAACtB,GAALsB,IAAYqC,SAAhB,EAA2B;MACzBrC,IAAI,CAACtB,GAALsB,IAAYsC,WAAZtC;IACD;EACF;AACF;;AAEM,SAAShC,eAAT,CAELD,KAFK,EAGA;EACL,IAAI,CAACA,KAAL,EAAY;IACV,OAAO,EAAP;EACD;;EAED,IAAI,CAACe,KAAK,CAACC,OAAND,CAAcf,KAAde,CAAL,EAA2B;IACzBf,KAAK,GAAG,CAACA,KAAD,CAARA;EACD;;EAED,KAAK,IAAI+B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG/B,KAAK,CAAC4B,MAA1B,EAAkCG,CAAC,EAAnC,EAAuC;IACrC,MAAMnB,IAAI,GAAGZ,KAAK,CAAC+B,CAAD,CAAlB;IACA,IAAI0C,GAAJ;;IAEA,IAAI,CAAC7D,IAAL,EAAW;MACT6D,GAAG,GAAG,gBAANA;IADF,OAEO,IAAI,OAAO7D,IAAP,KAAgB,QAApB,EAA8B;MACnC6D,GAAG,GAAG,4BAANA;IADK,OAEA,IAAI,CAAC7D,IAAI,CAAC8D,IAAV,EAAgB;MACrBD,GAAG,GAAG,gBAANA;IADK,OAEA,IAAI7D,IAAI,YAAY+D,cAApB,EAA8B;MACnCF,GAAG,GAAG,8CAANA;IACD;;IAED,IAAIA,GAAJ,EAAS;MACP,MAAMC,IAAI,GAAG3D,KAAK,CAACC,OAAND,CAAcH,IAAdG,IAAsB,OAAtBA,GAAgC,OAAOH,IAApD;MACA,MAAM,IAAIY,KAAJ,CACH,aAAYiD,GAAI,sBAAqB1C,CAAE,gBAAe2C,IAAK,EADxD,CAAN;IAGD;EACF;;EAED,OAAO1E,KAAP;AACD;;AAEM,SAASuB,gBAAT,CAELqD,OAFK,EAGL5E,KAHK,EAUL;EAEA,KAAKD,gBAAL;;EAGAC,KAAK,GAAG,KAAKC,eAAL,CAAqBD,KAArB,CAARA;;EAIA,MAAMiC,IAAI,GAAG0C,eAAShB,GAATgB,CAAa;IACxBzE,UAAU,EAAE,IADY;IAExB6C,MAAM,EAAE,KAAKnC,IAFW;IAGxBK,SAAS,EAAE,KAAKL,IAAL,CAAUgE,OAAV,CAHa;IAIxBA,OAJwB;IAKxBjE,GAAG,EAAE;EALmB,CAAbgE,EAMVE,UANUF,CAMC,KAAKxC,OANNwC,CAAb;;EAQA,OAAO1C,IAAI,CAACf,sBAALe,CAELjC,KAFKiC,CAAP;AAID;;AAEM,SAASoC,aAAT,CAELO,OAFK,EAGL5E,KAHK,EAUL;EACA,KAAKD,gBAAL;;EAEA,MAAM+E,aAAa,GAAG,KAAK7E,eAAL,CAEpBD,KAFoB,CAAtB;;EAQA,MAAMiB,SAAS,GAAG,KAAKL,IAAL,CAAUgE,OAAV,CAAlB;;EACA,MAAM3C,IAAI,GAAG0C,eAAShB,GAATgB,CAAa;IACxBzE,UAAU,EAAE,IADY;IAExB6C,MAAM,EAAE,KAAKnC,IAFW;IAGxBK,SAAS,EAAEA,SAHa;IAIxB2D,OAJwB;IAMxBjE,GAAG,EAAEM,SAAS,CAACW;EANS,CAAb+C,EAOVE,UAPUF,CAOC,KAAKxC,OAPNwC,CAAb;;EASA,OAAO1C,IAAI,CAAC8C,mBAAL9C,CAAyB6C,aAAzB7C,CAAP;AACD;;AAMM,SAAS+C,KAAT,GAGL;EAAA,IADA9B,KACA,uEADe,KAAKA,KACpB;EACA,MAAM+B,OAAO,GAAG,IAAIC,gBAAJ,CAAmB,IAAnB,EAAyBhC,KAAzB,CAAhB;EACA,OAAO+B,OAAO,CAACE,GAARF,EAAP;AACD","names":["arrowFunctionExpression","assertExpression","assignmentExpression","blockStatement","callExpression","cloneNode","expressionStatement","isAssignmentExpression","isCallExpression","isExpression","isIdentifier","isSequenceExpression","isSuper","thisExpression","insertBefore","nodes_","_assertUnremoved","nodes","_verifyNodeList","parentPath","isExpressionStatement","isLabeledStatement","isExportNamedDeclaration","isExportDefaultDeclaration","isDeclaration","isNodeType","isJSXElement","isForStatement","key","node","push","replaceExpressionWithStatements","Array","isArray","container","_containerInsertBefore","isStatementOrBlock","shouldInsertCurrentNode","expression","replaceWith","unshiftContainer","Error","_containerInsert","from","updateSiblingKeys","length","paths","splice","i","to","path","getSibling","context","queue","pushContext","contexts","_getQueueContexts","setScope","debug","maybeQueue","_containerInsertAfter","last","arr","isHiddenInSequenceExpression","parent","expressions","isAlmostConstantAssignment","scope","left","blockScope","getBlockParent","hasOwnBinding","name","getOwnBinding","constantViolations","insertAfter","get","map","isPattern","unshift","callee","isPure","isMethod","computed","temp","generateDeclaredUidIdentifier","pushContainer","fromIndex","incrementBy","pathCache","msg","type","NodePath","listKey","setContext","verifiedNodes","replaceWithMultiple","hoist","hoister","PathHoister","run"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\path\\modification.ts"],"sourcesContent":["// This file contains methods that modify the path/node in some ways.\n\nimport { path as pathCache } from \"../cache\";\nimport PathHoister from \"./lib/hoister\";\nimport NodePath from \"./index\";\nimport {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isAssignmentExpression,\n  isCallExpression,\n  isExpression,\n  isIdentifier,\n  isSequenceExpression,\n  isSuper,\n  thisExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type Scope from \"../scope\";\n\n/**\n * Insert the provided nodes before the current one.\n */\n\nexport function insertBefore(\n  this: NodePath,\n  nodes_: t.Node | t.Node[],\n): NodePath[] {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const { parentPath } = this;\n\n  if (\n    parentPath.isExpressionStatement() ||\n    parentPath.isLabeledStatement() ||\n    parentPath.isExportNamedDeclaration() ||\n    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())\n  ) {\n    return parentPath.insertBefore(nodes);\n  } else if (\n    (this.isNodeType(\"Expression\") && !this.isJSXElement()) ||\n    (parentPath.isForStatement() && this.key === \"init\")\n  ) {\n    if (this.node) nodes.push(this.node);\n    // @ts-expect-error todo(flow->ts): check that nodes is an array of statements\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node as t.Statement;\n    const shouldInsertCurrentNode =\n      node &&\n      (!this.isExpressionStatement() ||\n        (node as t.ExpressionStatement).expression != null);\n\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return (this as NodePath<t.BlockStatement>).unshiftContainer(\n      \"body\",\n      // @ts-expect-error Fixme: refine nodes to t.BlockStatement[\"body\"] when this is a BlockStatement path\n      nodes,\n    );\n  } else {\n    throw new Error(\n      \"We don't know what to do with this node type. \" +\n        \"We were previously a Statement but we can't fit in here?\",\n    );\n  }\n}\n\nexport function _containerInsert<N extends t.Node>(\n  this: NodePath,\n  from: number,\n  nodes: N[],\n): NodePath<N>[] {\n  this.updateSiblingKeys(from, nodes.length);\n\n  const paths: NodePath<N>[] = [];\n\n  // @ts-expect-error todo(flow->ts): this.container could be a NodePath\n  this.container.splice(from, 0, ...nodes);\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to) as NodePath<N>;\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nexport function _containerInsertBefore<N extends t.Node>(\n  this: NodePath,\n  nodes: N[],\n) {\n  return this._containerInsert(this.key as number, nodes);\n}\n\nexport function _containerInsertAfter<N extends t.Node>(\n  this: NodePath,\n  nodes: N[],\n) {\n  return this._containerInsert((this.key as number) + 1, nodes);\n}\n\nconst last = <T>(arr: T[]) => arr[arr.length - 1];\n\nfunction isHiddenInSequenceExpression(path: NodePath): boolean {\n  return (\n    isSequenceExpression(path.parent) &&\n    (last(path.parent.expressions) !== path.node ||\n      isHiddenInSequenceExpression(path.parentPath))\n  );\n}\n\nfunction isAlmostConstantAssignment(\n  node: t.Node,\n  scope: Scope,\n): node is t.AssignmentExpression & { left: t.Identifier } {\n  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {\n    return false;\n  }\n\n  // Not every scope can contain variables. For example, we might be in\n  // a ClassScope either in the ClassHeritage or in a computed key.\n  const blockScope = scope.getBlockParent();\n\n  // If the variable is defined in the current scope and only assigned here,\n  // we can be sure that its value won't change.\n  return (\n    blockScope.hasOwnBinding(node.left.name) &&\n    blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1\n  );\n}\n\n/**\n * Insert the provided nodes after the current one. When inserting nodes after an\n * expression, ensure that the completion record is correct by pushing the current node.\n */\n\nexport function insertAfter(\n  this: NodePath,\n  nodes_: t.Node | t.Node[],\n): NodePath[] {\n  this._assertUnremoved();\n\n  if (this.isSequenceExpression()) {\n    return last(this.get(\"expressions\")).insertAfter(nodes_);\n  }\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const { parentPath } = this;\n  if (\n    parentPath.isExpressionStatement() ||\n    parentPath.isLabeledStatement() ||\n    parentPath.isExportNamedDeclaration() ||\n    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())\n  ) {\n    return parentPath.insertAfter(\n      nodes.map(node => {\n        // Usually after an expression we can safely insert another expression:\n        //   A.insertAfter(B)\n        //     foo = A;  -> foo = (A, B);\n        // If A is an expression statement, it isn't safe anymore so we need to\n        // convert B to an expression statement\n        //     A;        -> A; B // No semicolon! It could break if followed by [!\n        return isExpression(node) ? expressionStatement(node) : node;\n      }),\n    );\n  } else if (\n    (this.isNodeType(\"Expression\") &&\n      !this.isJSXElement() &&\n      !parentPath.isJSXElement()) ||\n    (parentPath.isForStatement() && this.key === \"init\")\n  ) {\n    if (this.node) {\n      const node = this.node as t.Expression | t.VariableDeclaration;\n      let { scope } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        (this.get(\"callee.body\") as NodePath<t.Expression>).insertAfter(nodes);\n        return [this];\n      }\n\n      if (isHiddenInSequenceExpression(this)) {\n        nodes.unshift(node);\n      }\n      // We need to preserve the value of this expression.\n      else if (isCallExpression(node) && isSuper(node.callee)) {\n        nodes.unshift(node);\n        // `super(...)` always evaluates to `this`.\n        nodes.push(thisExpression());\n      } else if (isAlmostConstantAssignment(node, scope)) {\n        nodes.unshift(node);\n        nodes.push(cloneNode(node.left));\n      } else if (scope.isPure(node, true)) {\n        // Insert the nodes before rather than after; it's not observable.\n        nodes.push(node);\n      } else {\n        // Inserting after the computed key of a method should insert the\n        // temporary binding in the method's parent's scope.\n        if (parentPath.isMethod({ computed: true, key: node })) {\n          scope = scope.parent;\n        }\n        const temp = scope.generateDeclaredUidIdentifier();\n        nodes.unshift(\n          expressionStatement(\n            // @ts-expect-error todo(flow->ts): This can be a variable\n            // declaraion in the \"init\" of a for statement, but that's\n            // invalid here.\n            assignmentExpression(\"=\", cloneNode(temp), node),\n          ),\n        );\n        nodes.push(expressionStatement(cloneNode(temp)));\n      }\n    }\n    // @ts-expect-error todo(flow->ts): check that nodes is an array of statements\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node as t.Statement;\n    const shouldInsertCurrentNode =\n      node &&\n      (!this.isExpressionStatement() ||\n        (node as t.ExpressionStatement).expression != null);\n\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    // @ts-expect-error Fixme: refine nodes to t.BlockStatement[\"body\"] when this is a BlockStatement path\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\n      \"We don't know what to do with this node type. \" +\n        \"We were previously a Statement but we can't fit in here?\",\n    );\n  }\n}\n\n/**\n * Update all sibling node paths after `fromIndex` by `incrementBy`.\n */\n\nexport function updateSiblingKeys(\n  this: NodePath,\n  fromIndex: number,\n  incrementBy: number,\n) {\n  if (!this.parent) return;\n\n  const paths = pathCache.get(this.parent);\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nexport function _verifyNodeList<N extends t.Node>(\n  this: NodePath,\n  nodes: N | N[],\n): N[] {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof NodePath) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(\n        `Node list ${msg} with the index of ${i} and type of ${type}`,\n      );\n    }\n  }\n\n  return nodes;\n}\n\nexport function unshiftContainer<N extends t.Node, K extends keyof N & string>(\n  this: NodePath<N>,\n  listKey: K,\n  nodes: N[K] extends (infer E)[]\n    ? E | E[]\n    : // todo: refine to t.Node[]\n      //  ? E extends t.Node\n      //    ? E | E[]\n      //    : never\n      never,\n) {\n  // todo: NodePaths<Nodes>\n  this._assertUnremoved();\n\n  // @ts-expect-error fixme\n  nodes = this._verifyNodeList(nodes);\n\n  // get the first path and insert our nodes before it, if it doesn't exist then it\n  // doesn't matter, our nodes will be inserted anyway\n  const path = NodePath.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey] as unknown as t.Node | t.Node[],\n    listKey,\n    key: 0,\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(\n    // @ts-expect-error typings needed to narrow down nodes as t.Node[]\n    nodes,\n  );\n}\n\nexport function pushContainer<N extends t.Node, K extends keyof N & string>(\n  this: NodePath<N>,\n  listKey: K,\n  nodes: N[K] extends (infer E)[]\n    ? E | E[]\n    : // todo: refine to t.Node[]\n      //  ? E extends t.Node\n      //    ? E | E[]\n      //    : never\n      never,\n) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(\n    // @ts-expect-error refine typings\n    nodes,\n  );\n\n  // get an invisible path that represents the last node + 1 and replace it with our\n  // nodes, effectively inlining it\n\n  const container = this.node[listKey];\n  const path = NodePath.get({\n    parentPath: this,\n    parent: this.node,\n    container: container as unknown as t.Node | t.Node[],\n    listKey,\n    // @ts-expect-error TS cannot infer that container is t.Node[]\n    key: container.length,\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\n/**\n * Hoist the current node to the highest scope possible and return a UID\n * referencing it.\n */\nexport function hoist<T extends t.Node>(\n  this: NodePath<T>,\n  scope: Scope = this.scope,\n) {\n  const hoister = new PathHoister<T>(this, scope);\n  return hoister.run();\n}\n"]},"metadata":{},"sourceType":"script"}