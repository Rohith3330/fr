{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PredefinedFormatToCheckFunction = void 0;\n\nconst enums_1 = require(\"./enums\");\n/*\nThese format functions are taken from `tslint-consistent-codestyle/naming-convention`:\nhttps://github.com/ajafff/tslint-consistent-codestyle/blob/ab156cc8881bcc401236d999f4ce034b59039e81/rules/namingConventionRule.ts#L603-L645\n\nThe license for the code can be viewed here:\nhttps://github.com/ajafff/tslint-consistent-codestyle/blob/ab156cc8881bcc401236d999f4ce034b59039e81/LICENSE\n*/\n\n/*\nWhy not regex here? Because it's actually really, really difficult to create a regex to handle\nall of the unicode cases, and we have many non-english users that use non-english characters.\nhttps://gist.github.com/mathiasbynens/6334847\n*/\n\n\nfunction isPascalCase(name) {\n  return name.length === 0 || name[0] === name[0].toUpperCase() && !name.includes('_');\n}\n\nfunction isStrictPascalCase(name) {\n  return name.length === 0 || name[0] === name[0].toUpperCase() && hasStrictCamelHumps(name, true);\n}\n\nfunction isCamelCase(name) {\n  return name.length === 0 || name[0] === name[0].toLowerCase() && !name.includes('_');\n}\n\nfunction isStrictCamelCase(name) {\n  return name.length === 0 || name[0] === name[0].toLowerCase() && hasStrictCamelHumps(name, false);\n}\n\nfunction hasStrictCamelHumps(name, isUpper) {\n  function isUppercaseChar(char) {\n    return char === char.toUpperCase() && char !== char.toLowerCase();\n  }\n\n  if (name.startsWith('_')) {\n    return false;\n  }\n\n  for (let i = 1; i < name.length; ++i) {\n    if (name[i] === '_') {\n      return false;\n    }\n\n    if (isUpper === isUppercaseChar(name[i])) {\n      if (isUpper) {\n        return false;\n      }\n    } else {\n      isUpper = !isUpper;\n    }\n  }\n\n  return true;\n}\n\nfunction isSnakeCase(name) {\n  return name.length === 0 || name === name.toLowerCase() && validateUnderscores(name);\n}\n\nfunction isUpperCase(name) {\n  return name.length === 0 || name === name.toUpperCase() && validateUnderscores(name);\n}\n/** Check for leading trailing and adjacent underscores */\n\n\nfunction validateUnderscores(name) {\n  if (name.startsWith('_')) {\n    return false;\n  }\n\n  let wasUnderscore = false;\n\n  for (let i = 1; i < name.length; ++i) {\n    if (name[i] === '_') {\n      if (wasUnderscore) {\n        return false;\n      }\n\n      wasUnderscore = true;\n    } else {\n      wasUnderscore = false;\n    }\n  }\n\n  return !wasUnderscore;\n}\n\nconst PredefinedFormatToCheckFunction = {\n  [enums_1.PredefinedFormats.PascalCase]: isPascalCase,\n  [enums_1.PredefinedFormats.StrictPascalCase]: isStrictPascalCase,\n  [enums_1.PredefinedFormats.camelCase]: isCamelCase,\n  [enums_1.PredefinedFormats.strictCamelCase]: isStrictCamelCase,\n  [enums_1.PredefinedFormats.UPPER_CASE]: isUpperCase,\n  [enums_1.PredefinedFormats.snake_case]: isSnakeCase\n};\nexports.PredefinedFormatToCheckFunction = PredefinedFormatToCheckFunction;","map":{"version":3,"mappings":"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","names":["isPascalCase","name","length","toUpperCase","includes","isStrictPascalCase","hasStrictCamelHumps","isCamelCase","toLowerCase","isStrictCamelCase","isUpper","isUppercaseChar","char","startsWith","i","isSnakeCase","validateUnderscores","isUpperCase","wasUnderscore","PredefinedFormatToCheckFunction","enums_1","PascalCase","StrictPascalCase","camelCase","strictCamelCase","UPPER_CASE","snake_case","exports"],"sources":["../../../src/rules/naming-convention-utils/format.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}