{"ast":null,"code":"/**\n * Socket wrapping functions for TLS.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2009-2012 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\n\nrequire('./tls');\n/**\n * Wraps a forge.net socket with a TLS layer.\n *\n * @param options:\n *   sessionId: a session ID to reuse, null for a new connection if no session\n *     cache is provided or it is empty.\n *   caStore: an array of certificates to trust.\n *   sessionCache: a session cache to use.\n *   cipherSuites: an optional array of cipher suites to use, see\n *     tls.CipherSuites.\n *   socket: the socket to wrap.\n *   virtualHost: the virtual server name to use in a TLS SNI extension.\n *   verify: a handler used to custom verify certificates in the chain.\n *   getCertificate: an optional callback used to get a certificate.\n *   getPrivateKey: an optional callback used to get a private key.\n *   getSignature: an optional callback used to get a signature.\n *   deflate: function(inBytes) if provided, will deflate TLS records using\n *     the deflate algorithm if the server supports it.\n *   inflate: function(inBytes) if provided, will inflate TLS records using\n *     the deflate algorithm if the server supports it.\n *\n * @return the TLS-wrapped socket.\n */\n\n\nforge.tls.wrapSocket = function (options) {\n  // get raw socket\n  var socket = options.socket; // create TLS socket\n\n  var tlsSocket = {\n    id: socket.id,\n    // set handlers\n    connected: socket.connected || function (e) {},\n    closed: socket.closed || function (e) {},\n    data: socket.data || function (e) {},\n    error: socket.error || function (e) {}\n  }; // create TLS connection\n\n  var c = forge.tls.createConnection({\n    server: false,\n    sessionId: options.sessionId || null,\n    caStore: options.caStore || [],\n    sessionCache: options.sessionCache || null,\n    cipherSuites: options.cipherSuites || null,\n    virtualHost: options.virtualHost,\n    verify: options.verify,\n    getCertificate: options.getCertificate,\n    getPrivateKey: options.getPrivateKey,\n    getSignature: options.getSignature,\n    deflate: options.deflate,\n    inflate: options.inflate,\n    connected: function (c) {\n      // first handshake complete, call handler\n      if (c.handshakes === 1) {\n        tlsSocket.connected({\n          id: socket.id,\n          type: 'connect',\n          bytesAvailable: c.data.length()\n        });\n      }\n    },\n    tlsDataReady: function (c) {\n      // send TLS data over socket\n      return socket.send(c.tlsData.getBytes());\n    },\n    dataReady: function (c) {\n      // indicate application data is ready\n      tlsSocket.data({\n        id: socket.id,\n        type: 'socketData',\n        bytesAvailable: c.data.length()\n      });\n    },\n    closed: function (c) {\n      // close socket\n      socket.close();\n    },\n    error: function (c, e) {\n      // send error, close socket\n      tlsSocket.error({\n        id: socket.id,\n        type: 'tlsError',\n        message: e.message,\n        bytesAvailable: 0,\n        error: e\n      });\n      socket.close();\n    }\n  }); // handle doing handshake after connecting\n\n  socket.connected = function (e) {\n    c.handshake(options.sessionId);\n  }; // handle closing TLS connection\n\n\n  socket.closed = function (e) {\n    if (c.open && c.handshaking) {\n      // error\n      tlsSocket.error({\n        id: socket.id,\n        type: 'ioError',\n        message: 'Connection closed during handshake.',\n        bytesAvailable: 0\n      });\n    }\n\n    c.close(); // call socket handler\n\n    tlsSocket.closed({\n      id: socket.id,\n      type: 'close',\n      bytesAvailable: 0\n    });\n  }; // handle error on socket\n\n\n  socket.error = function (e) {\n    // error\n    tlsSocket.error({\n      id: socket.id,\n      type: e.type,\n      message: e.message,\n      bytesAvailable: 0\n    });\n    c.close();\n  }; // handle receiving raw TLS data from socket\n\n\n  var _requiredBytes = 0;\n\n  socket.data = function (e) {\n    // drop data if connection not open\n    if (!c.open) {\n      socket.receive(e.bytesAvailable);\n    } else {\n      // only receive if there are enough bytes available to\n      // process a record\n      if (e.bytesAvailable >= _requiredBytes) {\n        var count = Math.max(e.bytesAvailable, _requiredBytes);\n        var data = socket.receive(count);\n\n        if (data !== null) {\n          _requiredBytes = c.process(data);\n        }\n      }\n    }\n  };\n  /**\n   * Destroys this socket.\n   */\n\n\n  tlsSocket.destroy = function () {\n    socket.destroy();\n  };\n  /**\n   * Sets this socket's TLS session cache. This should be called before\n   * the socket is connected or after it is closed.\n   *\n   * The cache is an object mapping session IDs to internal opaque state.\n   * An application might need to change the cache used by a particular\n   * tlsSocket between connections if it accesses multiple TLS hosts.\n   *\n   * @param cache the session cache to use.\n   */\n\n\n  tlsSocket.setSessionCache = function (cache) {\n    c.sessionCache = tls.createSessionCache(cache);\n  };\n  /**\n   * Connects this socket.\n   *\n   * @param options:\n   *           host: the host to connect to.\n   *           port: the port to connect to.\n   *           policyPort: the policy port to use (if non-default), 0 to\n   *              use the flash default.\n   *           policyUrl: the policy file URL to use (instead of port).\n   */\n\n\n  tlsSocket.connect = function (options) {\n    socket.connect(options);\n  };\n  /**\n   * Closes this socket.\n   */\n\n\n  tlsSocket.close = function () {\n    c.close();\n  };\n  /**\n   * Determines if the socket is connected or not.\n   *\n   * @return true if connected, false if not.\n   */\n\n\n  tlsSocket.isConnected = function () {\n    return c.isConnected && socket.isConnected();\n  };\n  /**\n   * Writes bytes to this socket.\n   *\n   * @param bytes the bytes (as a string) to write.\n   *\n   * @return true on success, false on failure.\n   */\n\n\n  tlsSocket.send = function (bytes) {\n    return c.prepare(bytes);\n  };\n  /**\n   * Reads bytes from this socket (non-blocking). Fewer than the number of\n   * bytes requested may be read if enough bytes are not available.\n   *\n   * This method should be called from the data handler if there are enough\n   * bytes available. To see how many bytes are available, check the\n   * 'bytesAvailable' property on the event in the data handler or call the\n   * bytesAvailable() function on the socket. If the browser is msie, then the\n   * bytesAvailable() function should be used to avoid race conditions.\n   * Otherwise, using the property on the data handler's event may be quicker.\n   *\n   * @param count the maximum number of bytes to read.\n   *\n   * @return the bytes read (as a string) or null on error.\n   */\n\n\n  tlsSocket.receive = function (count) {\n    return c.data.getBytes(count);\n  };\n  /**\n   * Gets the number of bytes available for receiving on the socket.\n   *\n   * @return the number of bytes available for receiving.\n   */\n\n\n  tlsSocket.bytesAvailable = function () {\n    return c.data.length();\n  };\n\n  return tlsSocket;\n};","map":{"version":3,"names":["forge","require","tls","wrapSocket","options","socket","tlsSocket","id","connected","e","closed","data","error","c","createConnection","server","sessionId","caStore","sessionCache","cipherSuites","virtualHost","verify","getCertificate","getPrivateKey","getSignature","deflate","inflate","handshakes","type","bytesAvailable","length","tlsDataReady","send","tlsData","getBytes","dataReady","close","message","handshake","open","handshaking","_requiredBytes","receive","count","Math","max","process","destroy","setSessionCache","cache","createSessionCache","connect","isConnected","bytes","prepare"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/node-forge/lib/tlssocket.js"],"sourcesContent":["/**\n * Socket wrapping functions for TLS.\n *\n * @author Dave Longley\n *\n * Copyright (c) 2009-2012 Digital Bazaar, Inc.\n */\nvar forge = require('./forge');\nrequire('./tls');\n\n/**\n * Wraps a forge.net socket with a TLS layer.\n *\n * @param options:\n *   sessionId: a session ID to reuse, null for a new connection if no session\n *     cache is provided or it is empty.\n *   caStore: an array of certificates to trust.\n *   sessionCache: a session cache to use.\n *   cipherSuites: an optional array of cipher suites to use, see\n *     tls.CipherSuites.\n *   socket: the socket to wrap.\n *   virtualHost: the virtual server name to use in a TLS SNI extension.\n *   verify: a handler used to custom verify certificates in the chain.\n *   getCertificate: an optional callback used to get a certificate.\n *   getPrivateKey: an optional callback used to get a private key.\n *   getSignature: an optional callback used to get a signature.\n *   deflate: function(inBytes) if provided, will deflate TLS records using\n *     the deflate algorithm if the server supports it.\n *   inflate: function(inBytes) if provided, will inflate TLS records using\n *     the deflate algorithm if the server supports it.\n *\n * @return the TLS-wrapped socket.\n */\nforge.tls.wrapSocket = function(options) {\n  // get raw socket\n  var socket = options.socket;\n\n  // create TLS socket\n  var tlsSocket = {\n    id: socket.id,\n    // set handlers\n    connected: socket.connected || function(e) {},\n    closed: socket.closed || function(e) {},\n    data: socket.data || function(e) {},\n    error: socket.error || function(e) {}\n  };\n\n  // create TLS connection\n  var c = forge.tls.createConnection({\n    server: false,\n    sessionId: options.sessionId || null,\n    caStore: options.caStore || [],\n    sessionCache: options.sessionCache || null,\n    cipherSuites: options.cipherSuites || null,\n    virtualHost: options.virtualHost,\n    verify: options.verify,\n    getCertificate: options.getCertificate,\n    getPrivateKey: options.getPrivateKey,\n    getSignature: options.getSignature,\n    deflate: options.deflate,\n    inflate: options.inflate,\n    connected: function(c) {\n      // first handshake complete, call handler\n      if(c.handshakes === 1) {\n        tlsSocket.connected({\n          id: socket.id,\n          type: 'connect',\n          bytesAvailable: c.data.length()\n        });\n      }\n    },\n    tlsDataReady: function(c) {\n      // send TLS data over socket\n      return socket.send(c.tlsData.getBytes());\n    },\n    dataReady: function(c) {\n      // indicate application data is ready\n      tlsSocket.data({\n        id: socket.id,\n        type: 'socketData',\n        bytesAvailable: c.data.length()\n      });\n    },\n    closed: function(c) {\n      // close socket\n      socket.close();\n    },\n    error: function(c, e) {\n      // send error, close socket\n      tlsSocket.error({\n        id: socket.id,\n        type: 'tlsError',\n        message: e.message,\n        bytesAvailable: 0,\n        error: e\n      });\n      socket.close();\n    }\n  });\n\n  // handle doing handshake after connecting\n  socket.connected = function(e) {\n    c.handshake(options.sessionId);\n  };\n\n  // handle closing TLS connection\n  socket.closed = function(e) {\n    if(c.open && c.handshaking) {\n      // error\n      tlsSocket.error({\n        id: socket.id,\n        type: 'ioError',\n        message: 'Connection closed during handshake.',\n        bytesAvailable: 0\n      });\n    }\n    c.close();\n\n    // call socket handler\n    tlsSocket.closed({\n      id: socket.id,\n      type: 'close',\n      bytesAvailable: 0\n    });\n  };\n\n  // handle error on socket\n  socket.error = function(e) {\n    // error\n    tlsSocket.error({\n      id: socket.id,\n      type: e.type,\n      message: e.message,\n      bytesAvailable: 0\n    });\n    c.close();\n  };\n\n  // handle receiving raw TLS data from socket\n  var _requiredBytes = 0;\n  socket.data = function(e) {\n    // drop data if connection not open\n    if(!c.open) {\n      socket.receive(e.bytesAvailable);\n    } else {\n      // only receive if there are enough bytes available to\n      // process a record\n      if(e.bytesAvailable >= _requiredBytes) {\n        var count = Math.max(e.bytesAvailable, _requiredBytes);\n        var data = socket.receive(count);\n        if(data !== null) {\n          _requiredBytes = c.process(data);\n        }\n      }\n    }\n  };\n\n  /**\n   * Destroys this socket.\n   */\n  tlsSocket.destroy = function() {\n    socket.destroy();\n  };\n\n  /**\n   * Sets this socket's TLS session cache. This should be called before\n   * the socket is connected or after it is closed.\n   *\n   * The cache is an object mapping session IDs to internal opaque state.\n   * An application might need to change the cache used by a particular\n   * tlsSocket between connections if it accesses multiple TLS hosts.\n   *\n   * @param cache the session cache to use.\n   */\n  tlsSocket.setSessionCache = function(cache) {\n    c.sessionCache = tls.createSessionCache(cache);\n  };\n\n  /**\n   * Connects this socket.\n   *\n   * @param options:\n   *           host: the host to connect to.\n   *           port: the port to connect to.\n   *           policyPort: the policy port to use (if non-default), 0 to\n   *              use the flash default.\n   *           policyUrl: the policy file URL to use (instead of port).\n   */\n  tlsSocket.connect = function(options) {\n    socket.connect(options);\n  };\n\n  /**\n   * Closes this socket.\n   */\n  tlsSocket.close = function() {\n    c.close();\n  };\n\n  /**\n   * Determines if the socket is connected or not.\n   *\n   * @return true if connected, false if not.\n   */\n  tlsSocket.isConnected = function() {\n    return c.isConnected && socket.isConnected();\n  };\n\n  /**\n   * Writes bytes to this socket.\n   *\n   * @param bytes the bytes (as a string) to write.\n   *\n   * @return true on success, false on failure.\n   */\n  tlsSocket.send = function(bytes) {\n    return c.prepare(bytes);\n  };\n\n  /**\n   * Reads bytes from this socket (non-blocking). Fewer than the number of\n   * bytes requested may be read if enough bytes are not available.\n   *\n   * This method should be called from the data handler if there are enough\n   * bytes available. To see how many bytes are available, check the\n   * 'bytesAvailable' property on the event in the data handler or call the\n   * bytesAvailable() function on the socket. If the browser is msie, then the\n   * bytesAvailable() function should be used to avoid race conditions.\n   * Otherwise, using the property on the data handler's event may be quicker.\n   *\n   * @param count the maximum number of bytes to read.\n   *\n   * @return the bytes read (as a string) or null on error.\n   */\n  tlsSocket.receive = function(count) {\n    return c.data.getBytes(count);\n  };\n\n  /**\n   * Gets the number of bytes available for receiving on the socket.\n   *\n   * @return the number of bytes available for receiving.\n   */\n  tlsSocket.bytesAvailable = function() {\n    return c.data.length();\n  };\n\n  return tlsSocket;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}