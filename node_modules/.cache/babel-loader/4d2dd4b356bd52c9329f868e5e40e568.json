{"ast":null,"code":"'use strict';\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction getImportValue(node) {\n  return node.type === 'ImportDeclaration' ? node.source.value : node.moduleReference.expression.value;\n}\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: (0, _docsUrl2['default'])('first')\n    },\n    fixable: 'code',\n    schema: [{\n      type: 'string',\n      'enum': ['absolute-first', 'disable-absolute-first']\n    }]\n  },\n  create: function () {\n    function create(context) {\n      function isPossibleDirective(node) {\n        return node.type === 'ExpressionStatement' && node.expression.type === 'Literal' && typeof node.expression.value === 'string';\n      }\n\n      return {\n        'Program': function () {\n          function Program(n) {\n            var body = n.body;\n\n            if (!body) {\n              return;\n            }\n\n            var absoluteFirst = context.options[0] === 'absolute-first';\n            var message = 'Import in body of module; reorder to top.';\n            var sourceCode = context.getSourceCode();\n            var originSourceCode = sourceCode.getText();\n            var nonImportCount = 0;\n            var anyExpressions = false;\n            var anyRelative = false;\n            var lastLegalImp = null;\n            var errorInfos = [];\n            var shouldSort = true;\n            var lastSortNodesIndex = 0;\n            body.forEach(function (node, index) {\n              if (!anyExpressions && isPossibleDirective(node)) {\n                return;\n              }\n\n              anyExpressions = true;\n\n              if (node.type === 'ImportDeclaration' || node.type === 'TSImportEqualsDeclaration') {\n                if (absoluteFirst) {\n                  if (/^\\./.test(getImportValue(node))) {\n                    anyRelative = true;\n                  } else if (anyRelative) {\n                    context.report({\n                      node: node.type === 'ImportDeclaration' ? node.source : node.moduleReference,\n                      message: 'Absolute imports should come before relative imports.'\n                    });\n                  }\n                }\n\n                if (nonImportCount > 0) {\n                  var _iteratorNormalCompletion = true;\n                  var _didIteratorError = false;\n                  var _iteratorError = undefined;\n\n                  try {\n                    for (var _iterator = context.getDeclaredVariables(node)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                      var variable = _step.value;\n                      if (!shouldSort) break;\n                      var references = variable.references;\n\n                      if (references.length) {\n                        var _iteratorNormalCompletion2 = true;\n                        var _didIteratorError2 = false;\n                        var _iteratorError2 = undefined;\n\n                        try {\n                          for (var _iterator2 = references[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                            var reference = _step2.value;\n\n                            if (reference.identifier.range[0] < node.range[1]) {\n                              shouldSort = false;\n                              break;\n                            }\n                          }\n                        } catch (err) {\n                          _didIteratorError2 = true;\n                          _iteratorError2 = err;\n                        } finally {\n                          try {\n                            if (!_iteratorNormalCompletion2 && _iterator2['return']) {\n                              _iterator2['return']();\n                            }\n                          } finally {\n                            if (_didIteratorError2) {\n                              throw _iteratorError2;\n                            }\n                          }\n                        }\n                      }\n                    }\n                  } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion && _iterator['return']) {\n                        _iterator['return']();\n                      }\n                    } finally {\n                      if (_didIteratorError) {\n                        throw _iteratorError;\n                      }\n                    }\n                  }\n\n                  shouldSort && (lastSortNodesIndex = errorInfos.length);\n                  errorInfos.push({\n                    node: node,\n                    range: [body[index - 1].range[1], node.range[1]]\n                  });\n                } else {\n                  lastLegalImp = node;\n                }\n              } else {\n                nonImportCount++;\n              }\n            });\n            if (!errorInfos.length) return;\n            errorInfos.forEach(function (errorInfo, index) {\n              var node = errorInfo.node;\n              var infos = {\n                node: node,\n                message: message\n              };\n\n              if (index < lastSortNodesIndex) {\n                infos.fix = function (fixer) {\n                  return fixer.insertTextAfter(node, '');\n                };\n              } else if (index === lastSortNodesIndex) {\n                var sortNodes = errorInfos.slice(0, lastSortNodesIndex + 1);\n\n                infos.fix = function (fixer) {\n                  var removeFixers = sortNodes.map(function (_errorInfo) {\n                    return fixer.removeRange(_errorInfo.range);\n                  });\n                  var range = [0, removeFixers[removeFixers.length - 1].range[1]];\n                  var insertSourceCode = sortNodes.map(function (_errorInfo) {\n                    var nodeSourceCode = String.prototype.slice.apply(originSourceCode, _errorInfo.range);\n\n                    if (/\\S/.test(nodeSourceCode[0])) {\n                      return '\\n' + nodeSourceCode;\n                    }\n\n                    return nodeSourceCode;\n                  }).join('');\n                  var insertFixer = null;\n                  var replaceSourceCode = '';\n\n                  if (!lastLegalImp) {\n                    insertSourceCode = insertSourceCode.trim() + insertSourceCode.match(/^(\\s+)/)[0];\n                  }\n\n                  insertFixer = lastLegalImp ? fixer.insertTextAfter(lastLegalImp, insertSourceCode) : fixer.insertTextBefore(body[0], insertSourceCode);\n                  var fixers = [insertFixer].concat(removeFixers);\n                  fixers.forEach(function (computedFixer, i) {\n                    replaceSourceCode += originSourceCode.slice(fixers[i - 1] ? fixers[i - 1].range[1] : 0, computedFixer.range[0]) + computedFixer.text;\n                  });\n                  return fixer.replaceTextRange(range, replaceSourceCode);\n                };\n              }\n\n              context.report(infos);\n            });\n          }\n\n          return Program;\n        }()\n      };\n    }\n\n    return create;\n  }()\n};","map":{"version":3,"mappings":"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","names":["getImportValue","node","type","source","value","moduleReference","expression","module","exports","meta","docs","url","fixable","schema","create","context","isPossibleDirective","n","body","absoluteFirst","options","message","sourceCode","getSourceCode","originSourceCode","getText","nonImportCount","anyExpressions","anyRelative","lastLegalImp","errorInfos","shouldSort","lastSortNodesIndex","forEach","index","test","report","getDeclaredVariables","Symbol","variable","references","length","reference","identifier","range","_didIteratorError2","_iteratorError2","_iterator2","_didIteratorError","_iteratorError","_iterator","push","errorInfo","infos","fix","fixer","insertTextAfter","sortNodes","slice","removeFixers","map","_errorInfo","removeRange","insertSourceCode","nodeSourceCode","String","prototype","apply","join","insertFixer","replaceSourceCode","trim","match","insertTextBefore","fixers","concat","computedFixer","i","text","replaceTextRange"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\first.js"],"sourcesContent":["import docsUrl from '../docsUrl';\n\nfunction getImportValue(node) {\n  return node.type === 'ImportDeclaration'\n    ? node.source.value\n    : node.moduleReference.expression.value;\n}\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: docsUrl('first'),\n    },\n    fixable: 'code',\n    schema: [\n      {\n        type: 'string',\n        enum: ['absolute-first', 'disable-absolute-first'],\n      },\n    ],\n  },\n\n  create(context) {\n    function isPossibleDirective(node) {\n      return node.type === 'ExpressionStatement' &&\n        node.expression.type === 'Literal' &&\n        typeof node.expression.value === 'string';\n    }\n\n    return {\n      'Program': function (n) {\n        const body = n.body;\n        if (!body) {\n          return;\n        }\n        const absoluteFirst = context.options[0] === 'absolute-first';\n        const message = 'Import in body of module; reorder to top.';\n        const sourceCode = context.getSourceCode();\n        const originSourceCode = sourceCode.getText();\n        let nonImportCount = 0;\n        let anyExpressions = false;\n        let anyRelative = false;\n        let lastLegalImp = null;\n        const errorInfos = [];\n        let shouldSort = true;\n        let lastSortNodesIndex = 0;\n        body.forEach(function (node, index) {\n          if (!anyExpressions && isPossibleDirective(node)) {\n            return;\n          }\n\n          anyExpressions = true;\n\n          if (node.type === 'ImportDeclaration' || node.type === 'TSImportEqualsDeclaration') {\n            if (absoluteFirst) {\n              if (/^\\./.test(getImportValue(node))) {\n                anyRelative = true;\n              } else if (anyRelative) {\n                context.report({\n                  node: node.type === 'ImportDeclaration' ? node.source : node.moduleReference,\n                  message: 'Absolute imports should come before relative imports.',\n                });\n              }\n            }\n            if (nonImportCount > 0) {\n              for (const variable of context.getDeclaredVariables(node)) {\n                if (!shouldSort) break;\n                const references = variable.references;\n                if (references.length) {\n                  for (const reference of references) {\n                    if (reference.identifier.range[0] < node.range[1]) {\n                      shouldSort = false;\n                      break;\n                    }\n                  }\n                }\n              }\n              shouldSort && (lastSortNodesIndex = errorInfos.length);\n              errorInfos.push({\n                node,\n                range: [body[index - 1].range[1], node.range[1]],\n              });\n            } else {\n              lastLegalImp = node;\n            }\n          } else {\n            nonImportCount++;\n          }\n        });\n        if (!errorInfos.length) return;\n        errorInfos.forEach(function (errorInfo, index) {\n          const node = errorInfo.node;\n          const infos = {\n            node,\n            message,\n          };\n          if (index < lastSortNodesIndex) {\n            infos.fix = function (fixer) {\n              return fixer.insertTextAfter(node, '');\n            };\n          } else if (index === lastSortNodesIndex) {\n            const sortNodes = errorInfos.slice(0, lastSortNodesIndex + 1);\n            infos.fix = function (fixer) {\n              const removeFixers = sortNodes.map(function (_errorInfo) {\n                return fixer.removeRange(_errorInfo.range);\n              });\n              const range = [0, removeFixers[removeFixers.length - 1].range[1]];\n              let insertSourceCode = sortNodes.map(function (_errorInfo) {\n                const nodeSourceCode = String.prototype.slice.apply(\n                  originSourceCode, _errorInfo.range,\n                );\n                if (/\\S/.test(nodeSourceCode[0])) {\n                  return '\\n' + nodeSourceCode;\n                }\n                return nodeSourceCode;\n              }).join('');\n              let insertFixer = null;\n              let replaceSourceCode = '';\n              if (!lastLegalImp) {\n                insertSourceCode =\n                    insertSourceCode.trim() + insertSourceCode.match(/^(\\s+)/)[0];\n              }\n              insertFixer = lastLegalImp ?\n                fixer.insertTextAfter(lastLegalImp, insertSourceCode) :\n                fixer.insertTextBefore(body[0], insertSourceCode);\n              const fixers = [insertFixer].concat(removeFixers);\n              fixers.forEach(function (computedFixer, i) {\n                replaceSourceCode += (originSourceCode.slice(\n                  fixers[i - 1] ? fixers[i - 1].range[1] : 0, computedFixer.range[0],\n                ) + computedFixer.text);\n              });\n              return fixer.replaceTextRange(range, replaceSourceCode);\n            };\n          }\n          context.report(infos);\n        });\n      },\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"script"}