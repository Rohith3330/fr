{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst {\n  cleanupOutData\n} = require('../lib/svgo/tools.js');\n\nconst {\n  transform2js,\n  transformsMultiply,\n  matrixToTransform\n} = require('./_transforms.js');\n\nexports.type = 'visitor';\nexports.name = 'convertTransform';\nexports.active = true;\nexports.description = 'collapses multiple transformations and optimizes it';\n/**\n * Convert matrices to the short aliases,\n * convert long translate, scale or rotate transform notations to the shorts ones,\n * convert transforms to the matrices and multiply them all into one,\n * remove useless transforms.\n *\n * @see https://www.w3.org/TR/SVG11/coords.html#TransformMatrixDefined\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<{\n *   convertToShorts?: boolean,\n *   degPrecision?: number,\n *   floatPrecision?: number,\n *   transformPrecision?: number,\n *   matrixToTransform?: boolean,\n *   shortTranslate?: boolean,\n *   shortScale?: boolean,\n *   shortRotate?: boolean,\n *   removeUseless?: boolean,\n *   collapseIntoOne?: boolean,\n *   leadingZero?: boolean,\n *   negativeExtraSpace?: boolean,\n * }>}\n */\n\nexports.fn = (_root, params) => {\n  const {\n    convertToShorts = true,\n    // degPrecision = 3, // transformPrecision (or matrix precision) - 2 by default\n    degPrecision,\n    floatPrecision = 3,\n    transformPrecision = 5,\n    matrixToTransform = true,\n    shortTranslate = true,\n    shortScale = true,\n    shortRotate = true,\n    removeUseless = true,\n    collapseIntoOne = true,\n    leadingZero = true,\n    negativeExtraSpace = false\n  } = params;\n  const newParams = {\n    convertToShorts,\n    degPrecision,\n    floatPrecision,\n    transformPrecision,\n    matrixToTransform,\n    shortTranslate,\n    shortScale,\n    shortRotate,\n    removeUseless,\n    collapseIntoOne,\n    leadingZero,\n    negativeExtraSpace\n  };\n  return {\n    element: {\n      enter: node => {\n        // transform\n        if (node.attributes.transform != null) {\n          convertTransform(node, 'transform', newParams);\n        } // gradientTransform\n\n\n        if (node.attributes.gradientTransform != null) {\n          convertTransform(node, 'gradientTransform', newParams);\n        } // patternTransform\n\n\n        if (node.attributes.patternTransform != null) {\n          convertTransform(node, 'patternTransform', newParams);\n        }\n      }\n    }\n  };\n};\n/**\n * @typedef {{\n *   convertToShorts: boolean,\n *   degPrecision?: number,\n *   floatPrecision: number,\n *   transformPrecision: number,\n *   matrixToTransform: boolean,\n *   shortTranslate: boolean,\n *   shortScale: boolean,\n *   shortRotate: boolean,\n *   removeUseless: boolean,\n *   collapseIntoOne: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n * }} TransformParams\n */\n\n/**\n * @typedef {{ name: string, data: Array<number> }} TransformItem\n */\n\n/**\n * Main function.\n *\n * @type {(item: XastElement, attrName: string, params: TransformParams) => void}\n */\n\n\nconst convertTransform = (item, attrName, params) => {\n  let data = transform2js(item.attributes[attrName]);\n  params = definePrecision(data, params);\n\n  if (params.collapseIntoOne && data.length > 1) {\n    data = [transformsMultiply(data)];\n  }\n\n  if (params.convertToShorts) {\n    data = convertToShorts(data, params);\n  } else {\n    data.forEach(item => roundTransform(item, params));\n  }\n\n  if (params.removeUseless) {\n    data = removeUseless(data);\n  }\n\n  if (data.length) {\n    item.attributes[attrName] = js2transform(data, params);\n  } else {\n    delete item.attributes[attrName];\n  }\n};\n/**\n * Defines precision to work with certain parts.\n * transformPrecision - for scale and four first matrix parameters (needs a better precision due to multiplying),\n * floatPrecision - for translate including two last matrix and rotate parameters,\n * degPrecision - for rotate and skew. By default it's equal to (rougly)\n * transformPrecision - 2 or floatPrecision whichever is lower. Can be set in params.\n *\n * @type {(data: Array<TransformItem>, params: TransformParams) => TransformParams}\n *\n * clone params so it don't affect other elements transformations.\n */\n\n\nconst definePrecision = (data, _ref) => {\n  let { ...newParams\n  } = _ref;\n  const matrixData = [];\n\n  for (const item of data) {\n    if (item.name == 'matrix') {\n      matrixData.push(...item.data.slice(0, 4));\n    }\n  }\n\n  let significantDigits = newParams.transformPrecision; // Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.\n\n  if (matrixData.length) {\n    newParams.transformPrecision = Math.min(newParams.transformPrecision, Math.max.apply(Math, matrixData.map(floatDigits)) || newParams.transformPrecision);\n    significantDigits = Math.max.apply(Math, matrixData.map(n => n.toString().replace(/\\D+/g, '').length // Number of digits in a number. 123.45 → 5\n    ));\n  } // No sense in angle precision more then number of significant digits in matrix.\n\n\n  if (newParams.degPrecision == null) {\n    newParams.degPrecision = Math.max(0, Math.min(newParams.floatPrecision, significantDigits - 2));\n  }\n\n  return newParams;\n};\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\n\n\nconst degRound = (data, params) => {\n  if (params.degPrecision != null && params.degPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.degPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\n\n\nconst floatRound = (data, params) => {\n  if (params.floatPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.floatPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\n\n\nconst transformRound = (data, params) => {\n  if (params.transformPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.transformPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n/**\n * Returns number of digits after the point. 0.125 → 3\n *\n * @type {(n: number) => number}\n */\n\n\nconst floatDigits = n => {\n  const str = n.toString();\n  return str.slice(str.indexOf('.')).length - 1;\n};\n/**\n * Convert transforms to the shorthand alternatives.\n *\n * @type {(transforms: Array<TransformItem>, params: TransformParams) => Array<TransformItem>}\n */\n\n\nconst convertToShorts = (transforms, params) => {\n  for (var i = 0; i < transforms.length; i++) {\n    var transform = transforms[i]; // convert matrix to the short aliases\n\n    if (params.matrixToTransform && transform.name === 'matrix') {\n      var decomposed = matrixToTransform(transform, params);\n\n      if (js2transform(decomposed, params).length <= js2transform([transform], params).length) {\n        transforms.splice(i, 1, ...decomposed);\n      }\n\n      transform = transforms[i];\n    } // fixed-point numbers\n    // 12.754997 → 12.755\n\n\n    roundTransform(transform, params); // convert long translate transform notation to the shorts one\n    // translate(10 0) → translate(10)\n\n    if (params.shortTranslate && transform.name === 'translate' && transform.data.length === 2 && !transform.data[1]) {\n      transform.data.pop();\n    } // convert long scale transform notation to the shorts one\n    // scale(2 2) → scale(2)\n\n\n    if (params.shortScale && transform.name === 'scale' && transform.data.length === 2 && transform.data[0] === transform.data[1]) {\n      transform.data.pop();\n    } // convert long rotate transform notation to the short one\n    // translate(cx cy) rotate(a) translate(-cx -cy) → rotate(a cx cy)\n\n\n    if (params.shortRotate && transforms[i - 2] && transforms[i - 2].name === 'translate' && transforms[i - 1].name === 'rotate' && transforms[i].name === 'translate' && transforms[i - 2].data[0] === -transforms[i].data[0] && transforms[i - 2].data[1] === -transforms[i].data[1]) {\n      transforms.splice(i - 2, 3, {\n        name: 'rotate',\n        data: [transforms[i - 1].data[0], transforms[i - 2].data[0], transforms[i - 2].data[1]]\n      }); // splice compensation\n\n      i -= 2;\n    }\n  }\n\n  return transforms;\n};\n/**\n * Remove useless transforms.\n *\n * @type {(trasforms: Array<TransformItem>) => Array<TransformItem>}\n */\n\n\nconst removeUseless = transforms => {\n  return transforms.filter(transform => {\n    // translate(0), rotate(0[, cx, cy]), skewX(0), skewY(0)\n    if (['translate', 'rotate', 'skewX', 'skewY'].indexOf(transform.name) > -1 && (transform.data.length == 1 || transform.name == 'rotate') && !transform.data[0] || // translate(0, 0)\n    transform.name == 'translate' && !transform.data[0] && !transform.data[1] || // scale(1)\n    transform.name == 'scale' && transform.data[0] == 1 && (transform.data.length < 2 || transform.data[1] == 1) || // matrix(1 0 0 1 0 0)\n    transform.name == 'matrix' && transform.data[0] == 1 && transform.data[3] == 1 && !(transform.data[1] || transform.data[2] || transform.data[4] || transform.data[5])) {\n      return false;\n    }\n\n    return true;\n  });\n};\n/**\n * Convert transforms JS representation to string.\n *\n * @type {(transformJS: Array<TransformItem>, params: TransformParams) => string}\n */\n\n\nconst js2transform = (transformJS, params) => {\n  var transformString = ''; // collect output value string\n\n  transformJS.forEach(transform => {\n    roundTransform(transform, params);\n    transformString += (transformString && ' ') + transform.name + '(' + cleanupOutData(transform.data, params) + ')';\n  });\n  return transformString;\n};\n/**\n * @type {(transform: TransformItem, params: TransformParams) => TransformItem}\n */\n\n\nconst roundTransform = (transform, params) => {\n  switch (transform.name) {\n    case 'translate':\n      transform.data = floatRound(transform.data, params);\n      break;\n\n    case 'rotate':\n      transform.data = [...degRound(transform.data.slice(0, 1), params), ...floatRound(transform.data.slice(1), params)];\n      break;\n\n    case 'skewX':\n    case 'skewY':\n      transform.data = degRound(transform.data, params);\n      break;\n\n    case 'scale':\n      transform.data = transformRound(transform.data, params);\n      break;\n\n    case 'matrix':\n      transform.data = [...transformRound(transform.data.slice(0, 4), params), ...floatRound(transform.data.slice(4), params)];\n      break;\n  }\n\n  return transform;\n};\n/**\n * Rounds numbers in array.\n *\n * @type {(data: Array<number>) => Array<number>}\n */\n\n\nconst round = data => {\n  return data.map(Math.round);\n};\n/**\n * Decrease accuracy of floating-point numbers\n * in transforms keeping a specified number of decimals.\n * Smart rounds values like 2.349 to 2.35.\n *\n * @type {(precision: number, data: Array<number>) => Array<number>}\n */\n\n\nconst smartRound = (precision, data) => {\n  for (var i = data.length, tolerance = +Math.pow(0.1, precision).toFixed(precision); i--;) {\n    if (Number(data[i].toFixed(precision)) !== data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance ? +data[i].toFixed(precision) : rounded;\n    }\n  }\n\n  return data;\n};","map":{"version":3,"names":["cleanupOutData","require","transform2js","transformsMultiply","matrixToTransform","exports","type","name","active","description","fn","_root","params","convertToShorts","degPrecision","floatPrecision","transformPrecision","shortTranslate","shortScale","shortRotate","removeUseless","collapseIntoOne","leadingZero","negativeExtraSpace","newParams","element","enter","node","attributes","transform","convertTransform","gradientTransform","patternTransform","item","attrName","data","definePrecision","length","forEach","roundTransform","js2transform","matrixData","push","slice","significantDigits","Math","min","max","apply","map","floatDigits","n","toString","replace","degRound","smartRound","round","floatRound","transformRound","str","indexOf","transforms","i","decomposed","splice","pop","filter","transformJS","transformString","precision","tolerance","pow","toFixed","Number","rounded","abs"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/svgo/plugins/convertTransform.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nconst { cleanupOutData } = require('../lib/svgo/tools.js');\nconst {\n  transform2js,\n  transformsMultiply,\n  matrixToTransform,\n} = require('./_transforms.js');\n\nexports.type = 'visitor';\nexports.name = 'convertTransform';\nexports.active = true;\nexports.description = 'collapses multiple transformations and optimizes it';\n\n/**\n * Convert matrices to the short aliases,\n * convert long translate, scale or rotate transform notations to the shorts ones,\n * convert transforms to the matrices and multiply them all into one,\n * remove useless transforms.\n *\n * @see https://www.w3.org/TR/SVG11/coords.html#TransformMatrixDefined\n *\n * @author Kir Belevich\n *\n * @type {import('../lib/types').Plugin<{\n *   convertToShorts?: boolean,\n *   degPrecision?: number,\n *   floatPrecision?: number,\n *   transformPrecision?: number,\n *   matrixToTransform?: boolean,\n *   shortTranslate?: boolean,\n *   shortScale?: boolean,\n *   shortRotate?: boolean,\n *   removeUseless?: boolean,\n *   collapseIntoOne?: boolean,\n *   leadingZero?: boolean,\n *   negativeExtraSpace?: boolean,\n * }>}\n */\nexports.fn = (_root, params) => {\n  const {\n    convertToShorts = true,\n    // degPrecision = 3, // transformPrecision (or matrix precision) - 2 by default\n    degPrecision,\n    floatPrecision = 3,\n    transformPrecision = 5,\n    matrixToTransform = true,\n    shortTranslate = true,\n    shortScale = true,\n    shortRotate = true,\n    removeUseless = true,\n    collapseIntoOne = true,\n    leadingZero = true,\n    negativeExtraSpace = false,\n  } = params;\n  const newParams = {\n    convertToShorts,\n    degPrecision,\n    floatPrecision,\n    transformPrecision,\n    matrixToTransform,\n    shortTranslate,\n    shortScale,\n    shortRotate,\n    removeUseless,\n    collapseIntoOne,\n    leadingZero,\n    negativeExtraSpace,\n  };\n  return {\n    element: {\n      enter: (node) => {\n        // transform\n        if (node.attributes.transform != null) {\n          convertTransform(node, 'transform', newParams);\n        }\n        // gradientTransform\n        if (node.attributes.gradientTransform != null) {\n          convertTransform(node, 'gradientTransform', newParams);\n        }\n        // patternTransform\n        if (node.attributes.patternTransform != null) {\n          convertTransform(node, 'patternTransform', newParams);\n        }\n      },\n    },\n  };\n};\n\n/**\n * @typedef {{\n *   convertToShorts: boolean,\n *   degPrecision?: number,\n *   floatPrecision: number,\n *   transformPrecision: number,\n *   matrixToTransform: boolean,\n *   shortTranslate: boolean,\n *   shortScale: boolean,\n *   shortRotate: boolean,\n *   removeUseless: boolean,\n *   collapseIntoOne: boolean,\n *   leadingZero: boolean,\n *   negativeExtraSpace: boolean,\n * }} TransformParams\n */\n\n/**\n * @typedef {{ name: string, data: Array<number> }} TransformItem\n */\n\n/**\n * Main function.\n *\n * @type {(item: XastElement, attrName: string, params: TransformParams) => void}\n */\nconst convertTransform = (item, attrName, params) => {\n  let data = transform2js(item.attributes[attrName]);\n  params = definePrecision(data, params);\n\n  if (params.collapseIntoOne && data.length > 1) {\n    data = [transformsMultiply(data)];\n  }\n\n  if (params.convertToShorts) {\n    data = convertToShorts(data, params);\n  } else {\n    data.forEach((item) => roundTransform(item, params));\n  }\n\n  if (params.removeUseless) {\n    data = removeUseless(data);\n  }\n\n  if (data.length) {\n    item.attributes[attrName] = js2transform(data, params);\n  } else {\n    delete item.attributes[attrName];\n  }\n};\n\n/**\n * Defines precision to work with certain parts.\n * transformPrecision - for scale and four first matrix parameters (needs a better precision due to multiplying),\n * floatPrecision - for translate including two last matrix and rotate parameters,\n * degPrecision - for rotate and skew. By default it's equal to (rougly)\n * transformPrecision - 2 or floatPrecision whichever is lower. Can be set in params.\n *\n * @type {(data: Array<TransformItem>, params: TransformParams) => TransformParams}\n *\n * clone params so it don't affect other elements transformations.\n */\nconst definePrecision = (data, { ...newParams }) => {\n  const matrixData = [];\n  for (const item of data) {\n    if (item.name == 'matrix') {\n      matrixData.push(...item.data.slice(0, 4));\n    }\n  }\n  let significantDigits = newParams.transformPrecision;\n  // Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.\n  if (matrixData.length) {\n    newParams.transformPrecision = Math.min(\n      newParams.transformPrecision,\n      Math.max.apply(Math, matrixData.map(floatDigits)) ||\n        newParams.transformPrecision\n    );\n    significantDigits = Math.max.apply(\n      Math,\n      matrixData.map(\n        (n) => n.toString().replace(/\\D+/g, '').length // Number of digits in a number. 123.45 → 5\n      )\n    );\n  }\n  // No sense in angle precision more then number of significant digits in matrix.\n  if (newParams.degPrecision == null) {\n    newParams.degPrecision = Math.max(\n      0,\n      Math.min(newParams.floatPrecision, significantDigits - 2)\n    );\n  }\n  return newParams;\n};\n\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst degRound = (data, params) => {\n  if (\n    params.degPrecision != null &&\n    params.degPrecision >= 1 &&\n    params.floatPrecision < 20\n  ) {\n    return smartRound(params.degPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst floatRound = (data, params) => {\n  if (params.floatPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.floatPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n\n/**\n * @type {(data: Array<number>, params: TransformParams) => Array<number>}\n */\nconst transformRound = (data, params) => {\n  if (params.transformPrecision >= 1 && params.floatPrecision < 20) {\n    return smartRound(params.transformPrecision, data);\n  } else {\n    return round(data);\n  }\n};\n\n/**\n * Returns number of digits after the point. 0.125 → 3\n *\n * @type {(n: number) => number}\n */\nconst floatDigits = (n) => {\n  const str = n.toString();\n  return str.slice(str.indexOf('.')).length - 1;\n};\n\n/**\n * Convert transforms to the shorthand alternatives.\n *\n * @type {(transforms: Array<TransformItem>, params: TransformParams) => Array<TransformItem>}\n */\nconst convertToShorts = (transforms, params) => {\n  for (var i = 0; i < transforms.length; i++) {\n    var transform = transforms[i];\n\n    // convert matrix to the short aliases\n    if (params.matrixToTransform && transform.name === 'matrix') {\n      var decomposed = matrixToTransform(transform, params);\n      if (\n        js2transform(decomposed, params).length <=\n        js2transform([transform], params).length\n      ) {\n        transforms.splice(i, 1, ...decomposed);\n      }\n      transform = transforms[i];\n    }\n\n    // fixed-point numbers\n    // 12.754997 → 12.755\n    roundTransform(transform, params);\n\n    // convert long translate transform notation to the shorts one\n    // translate(10 0) → translate(10)\n    if (\n      params.shortTranslate &&\n      transform.name === 'translate' &&\n      transform.data.length === 2 &&\n      !transform.data[1]\n    ) {\n      transform.data.pop();\n    }\n\n    // convert long scale transform notation to the shorts one\n    // scale(2 2) → scale(2)\n    if (\n      params.shortScale &&\n      transform.name === 'scale' &&\n      transform.data.length === 2 &&\n      transform.data[0] === transform.data[1]\n    ) {\n      transform.data.pop();\n    }\n\n    // convert long rotate transform notation to the short one\n    // translate(cx cy) rotate(a) translate(-cx -cy) → rotate(a cx cy)\n    if (\n      params.shortRotate &&\n      transforms[i - 2] &&\n      transforms[i - 2].name === 'translate' &&\n      transforms[i - 1].name === 'rotate' &&\n      transforms[i].name === 'translate' &&\n      transforms[i - 2].data[0] === -transforms[i].data[0] &&\n      transforms[i - 2].data[1] === -transforms[i].data[1]\n    ) {\n      transforms.splice(i - 2, 3, {\n        name: 'rotate',\n        data: [\n          transforms[i - 1].data[0],\n          transforms[i - 2].data[0],\n          transforms[i - 2].data[1],\n        ],\n      });\n\n      // splice compensation\n      i -= 2;\n    }\n  }\n\n  return transforms;\n};\n\n/**\n * Remove useless transforms.\n *\n * @type {(trasforms: Array<TransformItem>) => Array<TransformItem>}\n */\nconst removeUseless = (transforms) => {\n  return transforms.filter((transform) => {\n    // translate(0), rotate(0[, cx, cy]), skewX(0), skewY(0)\n    if (\n      (['translate', 'rotate', 'skewX', 'skewY'].indexOf(transform.name) > -1 &&\n        (transform.data.length == 1 || transform.name == 'rotate') &&\n        !transform.data[0]) ||\n      // translate(0, 0)\n      (transform.name == 'translate' &&\n        !transform.data[0] &&\n        !transform.data[1]) ||\n      // scale(1)\n      (transform.name == 'scale' &&\n        transform.data[0] == 1 &&\n        (transform.data.length < 2 || transform.data[1] == 1)) ||\n      // matrix(1 0 0 1 0 0)\n      (transform.name == 'matrix' &&\n        transform.data[0] == 1 &&\n        transform.data[3] == 1 &&\n        !(\n          transform.data[1] ||\n          transform.data[2] ||\n          transform.data[4] ||\n          transform.data[5]\n        ))\n    ) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\n/**\n * Convert transforms JS representation to string.\n *\n * @type {(transformJS: Array<TransformItem>, params: TransformParams) => string}\n */\nconst js2transform = (transformJS, params) => {\n  var transformString = '';\n\n  // collect output value string\n  transformJS.forEach((transform) => {\n    roundTransform(transform, params);\n    transformString +=\n      (transformString && ' ') +\n      transform.name +\n      '(' +\n      cleanupOutData(transform.data, params) +\n      ')';\n  });\n\n  return transformString;\n};\n\n/**\n * @type {(transform: TransformItem, params: TransformParams) => TransformItem}\n */\nconst roundTransform = (transform, params) => {\n  switch (transform.name) {\n    case 'translate':\n      transform.data = floatRound(transform.data, params);\n      break;\n    case 'rotate':\n      transform.data = [\n        ...degRound(transform.data.slice(0, 1), params),\n        ...floatRound(transform.data.slice(1), params),\n      ];\n      break;\n    case 'skewX':\n    case 'skewY':\n      transform.data = degRound(transform.data, params);\n      break;\n    case 'scale':\n      transform.data = transformRound(transform.data, params);\n      break;\n    case 'matrix':\n      transform.data = [\n        ...transformRound(transform.data.slice(0, 4), params),\n        ...floatRound(transform.data.slice(4), params),\n      ];\n      break;\n  }\n  return transform;\n};\n\n/**\n * Rounds numbers in array.\n *\n * @type {(data: Array<number>) => Array<number>}\n */\nconst round = (data) => {\n  return data.map(Math.round);\n};\n\n/**\n * Decrease accuracy of floating-point numbers\n * in transforms keeping a specified number of decimals.\n * Smart rounds values like 2.349 to 2.35.\n *\n * @type {(precision: number, data: Array<number>) => Array<number>}\n */\nconst smartRound = (precision, data) => {\n  for (\n    var i = data.length,\n      tolerance = +Math.pow(0.1, precision).toFixed(precision);\n    i--;\n\n  ) {\n    if (Number(data[i].toFixed(precision)) !== data[i]) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] =\n        +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance\n          ? +data[i].toFixed(precision)\n          : rounded;\n    }\n  }\n  return data;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}