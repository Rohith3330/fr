{"ast":null,"code":"function sortStarts(a, b) {\n  return (a.range ? a.range[0] : a.start) - (b.range ? b.range[0] : b.start);\n}\n/**\n * Returns the string value of a template literal object.\n * Tries to build it as best as it can based on the passed\n * prop. For instance `This is a ${prop}` will return 'This is a {prop}'.\n *\n * If the template literal builds to undefined (`${undefined}`), then\n * this should return \"undefined\".\n */\n\n\nexport default function extractValueFromTemplateLiteral(value) {\n  const {\n    quasis,\n    expressions\n  } = value;\n  const partitions = quasis.concat(expressions);\n  return partitions.sort(sortStarts).reduce((raw, part) => {\n    const {\n      type\n    } = part;\n\n    if (type === 'TemplateElement') {\n      return raw + part.value.raw;\n    }\n\n    if (type === 'Identifier') {\n      return part.name === 'undefined' ? `${raw}${part.name}` : `${raw}{${part.name}}`;\n    }\n\n    if (type.indexOf('Expression') > -1) {\n      return `${raw}{${type}}`;\n    }\n\n    return raw;\n  }, '');\n}","map":{"version":3,"names":["sortStarts","a","b","range","start","extractValueFromTemplateLiteral","value","quasis","expressions","partitions","concat","sort","reduce","raw","part","type","name","indexOf"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/jsx-ast-utils/src/values/expressions/TemplateLiteral.js"],"sourcesContent":["function sortStarts(a, b) {\n  return (a.range ? a.range[0] : a.start) - (b.range ? b.range[0] : b.start);\n}\n\n/**\n * Returns the string value of a template literal object.\n * Tries to build it as best as it can based on the passed\n * prop. For instance `This is a ${prop}` will return 'This is a {prop}'.\n *\n * If the template literal builds to undefined (`${undefined}`), then\n * this should return \"undefined\".\n */\nexport default function extractValueFromTemplateLiteral(value) {\n  const {\n    quasis,\n    expressions,\n  } = value;\n  const partitions = quasis.concat(expressions);\n\n  return partitions.sort(sortStarts).reduce((raw, part) => {\n    const {\n      type,\n    } = part;\n    if (type === 'TemplateElement') {\n      return raw + part.value.raw;\n    }\n\n    if (type === 'Identifier') {\n      return part.name === 'undefined' ? `${raw}${part.name}` : `${raw}{${part.name}}`;\n    }\n\n    if (type.indexOf('Expression') > -1) {\n      return `${raw}{${type}}`;\n    }\n\n    return raw;\n  }, '');\n}\n"],"mappings":"AAAA,SAASA,UAAT,CAAoBC,CAApB,EAAuBC,CAAvB,EAA0B;EACxB,OAAO,CAACD,CAAC,CAACE,KAAF,GAAUF,CAAC,CAACE,KAAF,CAAQ,CAAR,CAAV,GAAuBF,CAAC,CAACG,KAA1B,KAAoCF,CAAC,CAACC,KAAF,GAAUD,CAAC,CAACC,KAAF,CAAQ,CAAR,CAAV,GAAuBD,CAAC,CAACE,KAA7D,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAe,SAASC,+BAAT,CAAyCC,KAAzC,EAAgD;EAC7D,MAAM;IACJC,MADI;IAEJC;EAFI,IAGFF,KAHJ;EAIA,MAAMG,UAAU,GAAGF,MAAM,CAACG,MAAP,CAAcF,WAAd,CAAnB;EAEA,OAAOC,UAAU,CAACE,IAAX,CAAgBX,UAAhB,EAA4BY,MAA5B,CAAmC,CAACC,GAAD,EAAMC,IAAN,KAAe;IACvD,MAAM;MACJC;IADI,IAEFD,IAFJ;;IAGA,IAAIC,IAAI,KAAK,iBAAb,EAAgC;MAC9B,OAAOF,GAAG,GAAGC,IAAI,CAACR,KAAL,CAAWO,GAAxB;IACD;;IAED,IAAIE,IAAI,KAAK,YAAb,EAA2B;MACzB,OAAOD,IAAI,CAACE,IAAL,KAAc,WAAd,GAA6B,GAAEH,GAAI,GAAEC,IAAI,CAACE,IAAK,EAA/C,GAAoD,GAAEH,GAAI,IAAGC,IAAI,CAACE,IAAK,GAA9E;IACD;;IAED,IAAID,IAAI,CAACE,OAAL,CAAa,YAAb,IAA6B,CAAC,CAAlC,EAAqC;MACnC,OAAQ,GAAEJ,GAAI,IAAGE,IAAK,GAAtB;IACD;;IAED,OAAOF,GAAP;EACD,CAjBM,EAiBJ,EAjBI,CAAP;AAkBD"},"metadata":{},"sourceType":"module"}