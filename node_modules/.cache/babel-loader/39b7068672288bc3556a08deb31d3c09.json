{"ast":null,"code":"\"use strict\";\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\n\nvar _ScopeBase_declaredVariables, _ScopeBase_dynamic, _ScopeBase_staticCloseRef, _ScopeBase_dynamicCloseRef, _ScopeBase_globalCloseRef;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScopeBase = void 0;\n\nconst types_1 = require(\"@typescript-eslint/types\");\n\nconst assert_1 = require(\"../assert\");\n\nconst definition_1 = require(\"../definition\");\n\nconst ID_1 = require(\"../ID\");\n\nconst Reference_1 = require(\"../referencer/Reference\");\n\nconst variable_1 = require(\"../variable\");\n\nconst ScopeType_1 = require(\"./ScopeType\");\n/**\n * Test if scope is strict\n */\n\n\nfunction isStrictScope(scope, block, isMethodDefinition) {\n  var _a;\n\n  let body; // When upper scope is exists and strict, inner scope is also strict.\n\n  if ((_a = scope.upper) === null || _a === void 0 ? void 0 : _a.isStrict) {\n    return true;\n  }\n\n  if (isMethodDefinition) {\n    return true;\n  }\n\n  if (scope.type === ScopeType_1.ScopeType.class || scope.type === ScopeType_1.ScopeType.conditionalType || scope.type === ScopeType_1.ScopeType.functionType || scope.type === ScopeType_1.ScopeType.mappedType || scope.type === ScopeType_1.ScopeType.module || scope.type === ScopeType_1.ScopeType.tsEnum || scope.type === ScopeType_1.ScopeType.tsModule || scope.type === ScopeType_1.ScopeType.type) {\n    return true;\n  }\n\n  if (scope.type === ScopeType_1.ScopeType.block || scope.type === ScopeType_1.ScopeType.switch) {\n    return false;\n  }\n\n  if (scope.type === ScopeType_1.ScopeType.function) {\n    const functionBody = block;\n\n    switch (functionBody.type) {\n      case types_1.AST_NODE_TYPES.ArrowFunctionExpression:\n        if (functionBody.body.type !== types_1.AST_NODE_TYPES.BlockStatement) {\n          return false;\n        }\n\n        body = functionBody.body;\n        break;\n\n      case types_1.AST_NODE_TYPES.Program:\n        body = functionBody;\n        break;\n\n      default:\n        body = functionBody.body;\n    }\n\n    if (!body) {\n      return false;\n    }\n  } else if (scope.type === ScopeType_1.ScopeType.global) {\n    body = block;\n  } else {\n    return false;\n  } // Search 'use strict' directive.\n\n\n  for (const stmt of body.body) {\n    if (stmt.type !== types_1.AST_NODE_TYPES.ExpressionStatement) {\n      break;\n    }\n\n    if (stmt.directive === 'use strict') {\n      return true;\n    }\n\n    const expr = stmt.expression;\n\n    if (expr.type !== types_1.AST_NODE_TYPES.Literal) {\n      break;\n    }\n\n    if (expr.raw === '\"use strict\"' || expr.raw === \"'use strict'\") {\n      return true;\n    }\n\n    if (expr.value === 'use strict') {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Register scope\n */\n\n\nfunction registerScope(scopeManager, scope) {\n  scopeManager.scopes.push(scope);\n  const scopes = scopeManager.nodeToScope.get(scope.block);\n\n  if (scopes) {\n    scopes.push(scope);\n  } else {\n    scopeManager.nodeToScope.set(scope.block, [scope]);\n  }\n}\n\nconst generator = (0, ID_1.createIdGenerator)();\nconst VARIABLE_SCOPE_TYPES = new Set([ScopeType_1.ScopeType.classFieldInitializer, ScopeType_1.ScopeType.classStaticBlock, ScopeType_1.ScopeType.function, ScopeType_1.ScopeType.global, ScopeType_1.ScopeType.module, ScopeType_1.ScopeType.tsModule]);\n\nclass ScopeBase {\n  constructor(scopeManager, type, upperScope, block, isMethodDefinition) {\n    /**\n     * A unique ID for this instance - primarily used to help debugging and testing\n     */\n    this.$id = generator();\n    /**\n     * The array of child scopes. This does not include grandchild scopes.\n     * @public\n     */\n\n    this.childScopes = [];\n    /**\n     * A map of the variables for each node in this scope.\n     * This is map is a pointer to the one in the parent ScopeManager instance\n     */\n\n    _ScopeBase_declaredVariables.set(this, void 0);\n    /**\n     * Generally, through the lexical scoping of JS you can always know which variable an identifier in the source code\n     * refers to. There are a few exceptions to this rule. With `global` and `with` scopes you can only decide at runtime\n     * which variable a reference refers to.\n     * All those scopes are considered \"dynamic\".\n     */\n\n\n    _ScopeBase_dynamic.set(this, void 0);\n    /**\n     * Whether this scope is created by a FunctionExpression.\n     * @public\n     */\n\n\n    this.functionExpressionScope = false;\n    /**\n     * List of {@link Reference}s that are left to be resolved (i.e. which\n     * need to be linked to the variable they refer to).\n     */\n\n    this.leftToResolve = [];\n    /**\n     * Any variable {@link Reference} found in this scope.\n     * This includes occurrences of local variables as well as variables from parent scopes (including the global scope).\n     * For local variables this also includes defining occurrences (like in a 'var' statement).\n     * In a 'function' scope this does not include the occurrences of the formal parameter in the parameter list.\n     * @public\n     */\n\n    this.references = [];\n    /**\n     * The map from variable names to variable objects.\n     * @public\n     */\n\n    this.set = new Map();\n    /**\n     * The {@link Reference}s that are not resolved with this scope.\n     * @public\n     */\n\n    this.through = [];\n    /**\n     * The scoped {@link Variable}s of this scope.\n     * In the case of a 'function' scope this includes the automatic argument `arguments` as its first element, as well\n     * as all further formal arguments.\n     * This does not include variables which are defined in child scopes.\n     * @public\n     */\n\n    this.variables = [];\n\n    _ScopeBase_staticCloseRef.set(this, ref => {\n      const resolve = () => {\n        const name = ref.identifier.name;\n        const variable = this.set.get(name);\n\n        if (!variable) {\n          return false;\n        }\n\n        if (!this.isValidResolution(ref, variable)) {\n          return false;\n        } // make sure we don't match a type reference to a value variable\n\n\n        const isValidTypeReference = ref.isTypeReference && variable.isTypeVariable;\n        const isValidValueReference = ref.isValueReference && variable.isValueVariable;\n\n        if (!isValidTypeReference && !isValidValueReference) {\n          return false;\n        }\n\n        variable.references.push(ref);\n        ref.resolved = variable;\n        return true;\n      };\n\n      if (!resolve()) {\n        this.delegateToUpperScope(ref);\n      }\n    });\n\n    _ScopeBase_dynamicCloseRef.set(this, ref => {\n      // notify all names are through to global\n      let current = this;\n\n      do {\n        current.through.push(ref);\n        current = current.upper;\n      } while (current);\n    });\n\n    _ScopeBase_globalCloseRef.set(this, (ref, scopeManager) => {\n      // let/const/class declarations should be resolved statically.\n      // others should be resolved dynamically.\n      if (this.shouldStaticallyCloseForGlobal(ref, scopeManager)) {\n        __classPrivateFieldGet(this, _ScopeBase_staticCloseRef, \"f\").call(this, ref);\n      } else {\n        __classPrivateFieldGet(this, _ScopeBase_dynamicCloseRef, \"f\").call(this, ref);\n      }\n    });\n\n    const upperScopeAsScopeBase = upperScope;\n    this.type = type;\n\n    __classPrivateFieldSet(this, _ScopeBase_dynamic, this.type === ScopeType_1.ScopeType.global || this.type === ScopeType_1.ScopeType.with, \"f\");\n\n    this.block = block;\n    this.variableScope = this.isVariableScope() ? this : upperScopeAsScopeBase.variableScope;\n    this.upper = upperScope;\n    /**\n     * Whether 'use strict' is in effect in this scope.\n     * @member {boolean} Scope#isStrict\n     */\n\n    this.isStrict = isStrictScope(this, block, isMethodDefinition);\n\n    if (upperScopeAsScopeBase) {\n      // this is guaranteed to be correct at runtime\n      upperScopeAsScopeBase.childScopes.push(this);\n    }\n\n    __classPrivateFieldSet(this, _ScopeBase_declaredVariables, scopeManager.declaredVariables, \"f\");\n\n    registerScope(scopeManager, this);\n  }\n\n  isVariableScope() {\n    return VARIABLE_SCOPE_TYPES.has(this.type);\n  }\n\n  shouldStaticallyClose() {\n    return !__classPrivateFieldGet(this, _ScopeBase_dynamic, \"f\");\n  }\n\n  shouldStaticallyCloseForGlobal(ref, scopeManager) {\n    // On global scope, let/const/class declarations should be resolved statically.\n    const name = ref.identifier.name;\n    const variable = this.set.get(name);\n\n    if (!variable) {\n      return false;\n    } // variable exists on the scope\n    // in module mode, we can statically resolve everything, regardless of its decl type\n\n\n    if (scopeManager.isModule()) {\n      return true;\n    } // in script mode, only certain cases should be statically resolved\n    // Example:\n    // a `var` decl is ignored by the runtime if it clashes with a global name\n    // this means that we should not resolve the reference to the variable\n\n\n    const defs = variable.defs;\n    return defs.length > 0 && defs.every(def => {\n      var _a;\n\n      if (def.type === definition_1.DefinitionType.Variable && ((_a = def.parent) === null || _a === void 0 ? void 0 : _a.type) === types_1.AST_NODE_TYPES.VariableDeclaration && def.parent.kind === 'var') {\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  close(scopeManager) {\n    let closeRef;\n\n    if (this.shouldStaticallyClose()) {\n      closeRef = __classPrivateFieldGet(this, _ScopeBase_staticCloseRef, \"f\");\n    } else if (this.type !== 'global') {\n      closeRef = __classPrivateFieldGet(this, _ScopeBase_dynamicCloseRef, \"f\");\n    } else {\n      closeRef = __classPrivateFieldGet(this, _ScopeBase_globalCloseRef, \"f\");\n    } // Try Resolving all references in this scope.\n\n\n    (0, assert_1.assert)(this.leftToResolve);\n    this.leftToResolve.forEach(ref => closeRef(ref, scopeManager));\n    this.leftToResolve = null;\n    return this.upper;\n  }\n  /**\n   * To override by function scopes.\n   * References in default parameters isn't resolved to variables which are in their function body.\n   */\n\n\n  isValidResolution(_ref, _variable) {\n    return true;\n  }\n\n  delegateToUpperScope(ref) {\n    const upper = this.upper;\n\n    if (upper === null || upper === void 0 ? void 0 : upper.leftToResolve) {\n      upper.leftToResolve.push(ref);\n    }\n\n    this.through.push(ref);\n  }\n\n  addDeclaredVariablesOfNode(variable, node) {\n    if (node == null) {\n      return;\n    }\n\n    let variables = __classPrivateFieldGet(this, _ScopeBase_declaredVariables, \"f\").get(node);\n\n    if (variables == null) {\n      variables = [];\n\n      __classPrivateFieldGet(this, _ScopeBase_declaredVariables, \"f\").set(node, variables);\n    }\n\n    if (!variables.includes(variable)) {\n      variables.push(variable);\n    }\n  }\n\n  defineVariable(nameOrVariable, set, variables, node, def) {\n    const name = typeof nameOrVariable === 'string' ? nameOrVariable : nameOrVariable.name;\n    let variable = set.get(name);\n\n    if (!variable) {\n      variable = typeof nameOrVariable === 'string' ? new variable_1.Variable(name, this) : nameOrVariable;\n      set.set(name, variable);\n      variables.push(variable);\n    }\n\n    if (def) {\n      variable.defs.push(def);\n      this.addDeclaredVariablesOfNode(variable, def.node);\n      this.addDeclaredVariablesOfNode(variable, def.parent);\n    }\n\n    if (node) {\n      variable.identifiers.push(node);\n    }\n  }\n\n  defineIdentifier(node, def) {\n    this.defineVariable(node.name, this.set, this.variables, node, def);\n  }\n\n  defineLiteralIdentifier(node, def) {\n    this.defineVariable(node.value, this.set, this.variables, null, def);\n  }\n\n  referenceValue(node) {\n    let assign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Reference_1.ReferenceFlag.Read;\n    let writeExpr = arguments.length > 2 ? arguments[2] : undefined;\n    let maybeImplicitGlobal = arguments.length > 3 ? arguments[3] : undefined;\n    let init = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    var _a;\n\n    const ref = new Reference_1.Reference(node, this, assign, writeExpr, maybeImplicitGlobal, init, Reference_1.ReferenceTypeFlag.Value);\n    this.references.push(ref);\n    (_a = this.leftToResolve) === null || _a === void 0 ? void 0 : _a.push(ref);\n  }\n\n  referenceType(node) {\n    var _a;\n\n    const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type);\n    this.references.push(ref);\n    (_a = this.leftToResolve) === null || _a === void 0 ? void 0 : _a.push(ref);\n  }\n\n  referenceDualValueType(node) {\n    var _a;\n\n    const ref = new Reference_1.Reference(node, this, Reference_1.ReferenceFlag.Read, null, null, false, Reference_1.ReferenceTypeFlag.Type | Reference_1.ReferenceTypeFlag.Value);\n    this.references.push(ref);\n    (_a = this.leftToResolve) === null || _a === void 0 ? void 0 : _a.push(ref);\n  }\n\n}\n\nexports.ScopeBase = ScopeBase;\n_ScopeBase_declaredVariables = new WeakMap(), _ScopeBase_dynamic = new WeakMap(), _ScopeBase_staticCloseRef = new WeakMap(), _ScopeBase_dynamicCloseRef = new WeakMap(), _ScopeBase_globalCloseRef = new WeakMap();","map":{"version":3,"mappings":"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","names":["isStrictScope","scope","block","isMethodDefinition","body","upper","_a","isStrict","type","ScopeType_1","class","conditionalType","functionType","mappedType","module","tsEnum","tsModule","switch","function","functionBody","types_1","ArrowFunctionExpression","BlockStatement","Program","global","stmt","ExpressionStatement","directive","expr","expression","Literal","raw","value","registerScope","scopeManager","scopes","push","nodeToScope","get","set","generator","VARIABLE_SCOPE_TYPES","Set","classFieldInitializer","classStaticBlock","ScopeBase","constructor","upperScope","_ScopeBase_declaredVariables","_ScopeBase_dynamic","Map","_ScopeBase_staticCloseRef","ref","resolve","name","identifier","variable","isValidResolution","isValidTypeReference","isTypeReference","isTypeVariable","isValidValueReference","isValueReference","isValueVariable","references","resolved","delegateToUpperScope","_ScopeBase_dynamicCloseRef","current","through","_ScopeBase_globalCloseRef","shouldStaticallyCloseForGlobal","__classPrivateFieldGet","call","upperScopeAsScopeBase","__classPrivateFieldSet","with","variableScope","isVariableScope","childScopes","declaredVariables","has","shouldStaticallyClose","isModule","defs","length","every","def","definition_1","Variable","parent","VariableDeclaration","kind","close","closeRef","leftToResolve","forEach","_ref","_variable","addDeclaredVariablesOfNode","node","variables","includes","defineVariable","nameOrVariable","variable_1","identifiers","defineIdentifier","defineLiteralIdentifier","referenceValue","assign","Reference_1","Read","writeExpr","maybeImplicitGlobal","init","Value","referenceType","Type","referenceDualValueType","exports"],"sources":["../../src/scope/ScopeBase.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}