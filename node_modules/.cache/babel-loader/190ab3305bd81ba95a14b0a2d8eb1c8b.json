{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadPlugin = loadPlugin;\nexports.loadPreset = loadPreset;\nexports.resolvePlugin = resolvePlugin;\nexports.resolvePreset = resolvePreset;\n\nfunction _debug() {\n  const data = require(\"debug\");\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../../gensync-utils/async\");\n\nvar _moduleTypes = require(\"./module-types\");\n\nfunction _url() {\n  const data = require(\"url\");\n\n  _url = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _importMetaResolve = require(\"./import-meta-resolve\");\n\nfunction _module() {\n  const data = require(\"module\");\n\n  _module = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nconst debug = _debug()(\"babel:config:loading:files:plugins\");\n\nconst EXACT_RE = /^module:/;\nconst BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\\/|babel-plugin-)/;\nconst BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\\/|babel-preset-)/;\nconst BABEL_PLUGIN_ORG_RE = /^(@babel\\/)(?!plugin-|[^/]+\\/)/;\nconst BABEL_PRESET_ORG_RE = /^(@babel\\/)(?!preset-|[^/]+\\/)/;\nconst OTHER_PLUGIN_ORG_RE = /^(@(?!babel\\/)[^/]+\\/)(?![^/]*babel-plugin(?:-|\\/|$)|[^/]+\\/)/;\nconst OTHER_PRESET_ORG_RE = /^(@(?!babel\\/)[^/]+\\/)(?![^/]*babel-preset(?:-|\\/|$)|[^/]+\\/)/;\nconst OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/;\n\nfunction* resolvePlugin(name, dirname) {\n  return yield* resolveStandardizedName(\"plugin\", name, dirname);\n}\n\nfunction* resolvePreset(name, dirname) {\n  return yield* resolveStandardizedName(\"preset\", name, dirname);\n}\n\nfunction* loadPlugin(name, dirname) {\n  const filepath = yield* resolvePlugin(name, dirname);\n  const value = yield* requireModule(\"plugin\", filepath);\n  debug(\"Loaded plugin %o from %o.\", name, dirname);\n  return {\n    filepath,\n    value\n  };\n}\n\nfunction* loadPreset(name, dirname) {\n  const filepath = yield* resolvePreset(name, dirname);\n  const value = yield* requireModule(\"preset\", filepath);\n  debug(\"Loaded preset %o from %o.\", name, dirname);\n  return {\n    filepath,\n    value\n  };\n}\n\nfunction standardizeName(type, name) {\n  if (_path().isAbsolute(name)) return name;\n  const isPreset = type === \"preset\";\n  return name.replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, `babel-${type}-`).replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, `$1${type}-`).replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, `$1babel-${type}-`).replace(OTHER_ORG_DEFAULT_RE, `$1/babel-${type}`).replace(EXACT_RE, \"\");\n}\n\nfunction* resolveAlternativesHelper(type, name) {\n  const standardizedName = standardizeName(type, name);\n  const {\n    error,\n    value\n  } = yield standardizedName;\n  if (!error) return value;\n  if (error.code !== \"MODULE_NOT_FOUND\") throw error;\n\n  if (standardizedName !== name && !(yield name).error) {\n    error.message += `\\n- If you want to resolve \"${name}\", use \"module:${name}\"`;\n  }\n\n  if (!(yield standardizeName(type, \"@babel/\" + name)).error) {\n    error.message += `\\n- Did you mean \"@babel/${name}\"?`;\n  }\n\n  const oppositeType = type === \"preset\" ? \"plugin\" : \"preset\";\n\n  if (!(yield standardizeName(oppositeType, name)).error) {\n    error.message += `\\n- Did you accidentally pass a ${oppositeType} as a ${type}?`;\n  }\n\n  throw error;\n}\n\nfunction tryRequireResolve(id, _ref) {\n  let {\n    paths: [dirname]\n  } = _ref;\n\n  try {\n    return {\n      error: null,\n      value: (((v, w) => (v = v.split(\".\"), w = w.split(\".\"), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1]))(process.versions.node, \"8.9\") ? require.resolve : function (r, _ref2) {\n        let {\n          paths: [b]\n        } = _ref2;\n        let M = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : require(\"module\");\n\n        let f = M._findPath(r, M._nodeModulePaths(b).concat(b));\n\n        if (f) return f;\n        f = new Error(`Cannot resolve module '${r}'`);\n        f.code = \"MODULE_NOT_FOUND\";\n        throw f;\n      })(id, {\n        paths: [dirname]\n      })\n    };\n  } catch (error) {\n    return {\n      error,\n      value: null\n    };\n  }\n}\n\nfunction tryImportMetaResolve(_x, _x2) {\n  return _tryImportMetaResolve.apply(this, arguments);\n}\n\nfunction _tryImportMetaResolve() {\n  _tryImportMetaResolve = _asyncToGenerator(function* (id, options) {\n    try {\n      return {\n        error: null,\n        value: yield (0, _importMetaResolve.default)(id, options)\n      };\n    } catch (error) {\n      return {\n        error,\n        value: null\n      };\n    }\n  });\n  return _tryImportMetaResolve.apply(this, arguments);\n}\n\nfunction resolveStandardizedNameForRequire(type, name, dirname) {\n  const it = resolveAlternativesHelper(type, name);\n  let res = it.next();\n\n  while (!res.done) {\n    res = it.next(tryRequireResolve(res.value, {\n      paths: [dirname]\n    }));\n  }\n\n  return res.value;\n}\n\nfunction resolveStandardizedNameForImport(_x3, _x4, _x5) {\n  return _resolveStandardizedNameForImport.apply(this, arguments);\n}\n\nfunction _resolveStandardizedNameForImport() {\n  _resolveStandardizedNameForImport = _asyncToGenerator(function* (type, name, dirname) {\n    const parentUrl = (0, _url().pathToFileURL)(_path().join(dirname, \"./babel-virtual-resolve-base.js\")).href;\n    const it = resolveAlternativesHelper(type, name);\n    let res = it.next();\n\n    while (!res.done) {\n      res = it.next(yield tryImportMetaResolve(res.value, parentUrl));\n    }\n\n    return (0, _url().fileURLToPath)(res.value);\n  });\n  return _resolveStandardizedNameForImport.apply(this, arguments);\n}\n\nconst resolveStandardizedName = _gensync()({\n  sync(type, name) {\n    let dirname = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.cwd();\n    return resolveStandardizedNameForRequire(type, name, dirname);\n  },\n\n  async(type, name) {\n    let dirname = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.cwd();\n    return _asyncToGenerator(function* () {\n      if (!_moduleTypes.supportsESM) {\n        return resolveStandardizedNameForRequire(type, name, dirname);\n      }\n\n      try {\n        return yield resolveStandardizedNameForImport(type, name, dirname);\n      } catch (e) {\n        try {\n          return resolveStandardizedNameForRequire(type, name, dirname);\n        } catch (e2) {\n          if (e.type === \"MODULE_NOT_FOUND\") throw e;\n          if (e2.type === \"MODULE_NOT_FOUND\") throw e2;\n          throw e;\n        }\n      }\n    })();\n  }\n\n});\n\n{\n  var LOADING_MODULES = new Set();\n}\n\nfunction* requireModule(type, name) {\n  {\n    if (!(yield* (0, _async.isAsync)()) && LOADING_MODULES.has(name)) {\n      throw new Error(`Reentrant ${type} detected trying to load \"${name}\". This module is not ignored ` + \"and is trying to load itself while compiling itself, leading to a dependency cycle. \" + 'We recommend adding it to your \"ignore\" list in your babelrc, or to a .babelignore.');\n    }\n  }\n\n  try {\n    {\n      LOADING_MODULES.add(name);\n    }\n    return yield* (0, _moduleTypes.default)(name, `You appear to be using a native ECMAScript module ${type}, ` + \"which is only supported when running Babel asynchronously.\", true);\n  } catch (err) {\n    err.message = `[BABEL]: ${err.message} (While processing: ${name})`;\n    throw err;\n  } finally {\n    {\n      LOADING_MODULES.delete(name);\n    }\n  }\n}\n\n0 && 0;","map":{"version":3,"mappings":"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","names":["_debug","_path","_gensync","_url","_module","debug","buildDebug","EXACT_RE","BABEL_PLUGIN_PREFIX_RE","BABEL_PRESET_PREFIX_RE","BABEL_PLUGIN_ORG_RE","BABEL_PRESET_ORG_RE","OTHER_PLUGIN_ORG_RE","OTHER_PRESET_ORG_RE","OTHER_ORG_DEFAULT_RE","resolvePlugin","name","dirname","resolveStandardizedName","resolvePreset","loadPlugin","filepath","value","requireModule","loadPreset","standardizeName","type","path","isAbsolute","isPreset","replace","resolveAlternativesHelper","standardizedName","error","code","message","oppositeType","tryRequireResolve","id","paths","f","tryImportMetaResolve","options","resolveStandardizedNameForRequire","it","res","next","done","resolveStandardizedNameForImport","parentUrl","join","href","gensync","sync","process","cwd","async","supportsESM","e","e2","LOADING_MODULES","Set","has","Error","add","err","delete"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\files\\plugins.ts"],"sourcesContent":["/**\n * This file handles all logic for converting string-based configuration references into loaded objects.\n */\n\nimport buildDebug from \"debug\";\nimport path from \"path\";\nimport gensync, { type Handler } from \"gensync\";\nimport { isAsync } from \"../../gensync-utils/async\";\nimport loadCjsOrMjsDefault, { supportsESM } from \"./module-types\";\nimport { fileURLToPath, pathToFileURL } from \"url\";\n\nimport importMetaResolve from \"./import-meta-resolve\";\n\nimport { createRequire } from \"module\";\nconst require = createRequire(import.meta.url);\n\nconst debug = buildDebug(\"babel:config:loading:files:plugins\");\n\nconst EXACT_RE = /^module:/;\nconst BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\\/|babel-plugin-)/;\nconst BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\\/|babel-preset-)/;\nconst BABEL_PLUGIN_ORG_RE = /^(@babel\\/)(?!plugin-|[^/]+\\/)/;\nconst BABEL_PRESET_ORG_RE = /^(@babel\\/)(?!preset-|[^/]+\\/)/;\nconst OTHER_PLUGIN_ORG_RE =\n  /^(@(?!babel\\/)[^/]+\\/)(?![^/]*babel-plugin(?:-|\\/|$)|[^/]+\\/)/;\nconst OTHER_PRESET_ORG_RE =\n  /^(@(?!babel\\/)[^/]+\\/)(?![^/]*babel-preset(?:-|\\/|$)|[^/]+\\/)/;\nconst OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/;\n\nexport function* resolvePlugin(name: string, dirname: string): Handler<string> {\n  return yield* resolveStandardizedName(\"plugin\", name, dirname);\n}\n\nexport function* resolvePreset(name: string, dirname: string): Handler<string> {\n  return yield* resolveStandardizedName(\"preset\", name, dirname);\n}\n\nexport function* loadPlugin(\n  name: string,\n  dirname: string,\n): Handler<{ filepath: string; value: unknown }> {\n  const filepath = yield* resolvePlugin(name, dirname);\n\n  const value = yield* requireModule(\"plugin\", filepath);\n  debug(\"Loaded plugin %o from %o.\", name, dirname);\n\n  return { filepath, value };\n}\n\nexport function* loadPreset(\n  name: string,\n  dirname: string,\n): Handler<{ filepath: string; value: unknown }> {\n  const filepath = yield* resolvePreset(name, dirname);\n\n  const value = yield* requireModule(\"preset\", filepath);\n\n  debug(\"Loaded preset %o from %o.\", name, dirname);\n\n  return { filepath, value };\n}\n\nfunction standardizeName(type: \"plugin\" | \"preset\", name: string) {\n  // Let absolute and relative paths through.\n  if (path.isAbsolute(name)) return name;\n\n  const isPreset = type === \"preset\";\n\n  return (\n    name\n      // foo -> babel-preset-foo\n      .replace(\n        isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE,\n        `babel-${type}-`,\n      )\n      // @babel/es2015 -> @babel/preset-es2015\n      .replace(\n        isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE,\n        `$1${type}-`,\n      )\n      // @foo/mypreset -> @foo/babel-preset-mypreset\n      .replace(\n        isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE,\n        `$1babel-${type}-`,\n      )\n      // @foo -> @foo/babel-preset\n      .replace(OTHER_ORG_DEFAULT_RE, `$1/babel-${type}`)\n      // module:mypreset -> mypreset\n      .replace(EXACT_RE, \"\")\n  );\n}\n\ntype Result<T> = { error: Error; value: null } | { error: null; value: T };\n\nfunction* resolveAlternativesHelper(\n  type: \"plugin\" | \"preset\",\n  name: string,\n): Iterator<string, string, Result<string>> {\n  const standardizedName = standardizeName(type, name);\n  const { error, value } = yield standardizedName;\n  if (!error) return value;\n\n  // @ts-expect-error code may not index error\n  if (error.code !== \"MODULE_NOT_FOUND\") throw error;\n\n  if (standardizedName !== name && !(yield name).error) {\n    error.message += `\\n- If you want to resolve \"${name}\", use \"module:${name}\"`;\n  }\n\n  if (!(yield standardizeName(type, \"@babel/\" + name)).error) {\n    error.message += `\\n- Did you mean \"@babel/${name}\"?`;\n  }\n\n  const oppositeType = type === \"preset\" ? \"plugin\" : \"preset\";\n  if (!(yield standardizeName(oppositeType, name)).error) {\n    error.message += `\\n- Did you accidentally pass a ${oppositeType} as a ${type}?`;\n  }\n\n  throw error;\n}\n\nfunction tryRequireResolve(\n  id: Parameters<RequireResolve>[0],\n  { paths: [dirname] }: Parameters<RequireResolve>[1],\n): Result<string> {\n  try {\n    return { error: null, value: require.resolve(id, { paths: [dirname] }) };\n  } catch (error) {\n    return { error, value: null };\n  }\n}\n\nasync function tryImportMetaResolve(\n  id: Parameters<ImportMeta[\"resolve\"]>[0],\n  options: Parameters<ImportMeta[\"resolve\"]>[1],\n): Promise<Result<string>> {\n  try {\n    return { error: null, value: await importMetaResolve(id, options) };\n  } catch (error) {\n    return { error, value: null };\n  }\n}\n\nfunction resolveStandardizedNameForRequire(\n  type: \"plugin\" | \"preset\",\n  name: string,\n  dirname: string,\n) {\n  const it = resolveAlternativesHelper(type, name);\n  let res = it.next();\n  while (!res.done) {\n    res = it.next(tryRequireResolve(res.value, { paths: [dirname] }));\n  }\n  return res.value;\n}\nasync function resolveStandardizedNameForImport(\n  type: \"plugin\" | \"preset\",\n  name: string,\n  dirname: string,\n) {\n  const parentUrl = pathToFileURL(\n    path.join(dirname, \"./babel-virtual-resolve-base.js\"),\n  ).href;\n\n  const it = resolveAlternativesHelper(type, name);\n  let res = it.next();\n  while (!res.done) {\n    res = it.next(await tryImportMetaResolve(res.value, parentUrl));\n  }\n  return fileURLToPath(res.value);\n}\n\nconst resolveStandardizedName = gensync<\n  [type: \"plugin\" | \"preset\", name: string, dirname?: string],\n  string\n>({\n  sync(type, name, dirname = process.cwd()) {\n    return resolveStandardizedNameForRequire(type, name, dirname);\n  },\n  async async(type, name, dirname = process.cwd()) {\n    if (!supportsESM) {\n      return resolveStandardizedNameForRequire(type, name, dirname);\n    }\n\n    try {\n      return await resolveStandardizedNameForImport(type, name, dirname);\n    } catch (e) {\n      try {\n        return resolveStandardizedNameForRequire(type, name, dirname);\n      } catch (e2) {\n        if (e.type === \"MODULE_NOT_FOUND\") throw e;\n        if (e2.type === \"MODULE_NOT_FOUND\") throw e2;\n        throw e;\n      }\n    }\n  },\n});\n\nif (!process.env.BABEL_8_BREAKING) {\n  // eslint-disable-next-line no-var\n  var LOADING_MODULES = new Set();\n}\nfunction* requireModule(type: string, name: string): Handler<unknown> {\n  if (!process.env.BABEL_8_BREAKING) {\n    if (!(yield* isAsync()) && LOADING_MODULES.has(name)) {\n      throw new Error(\n        `Reentrant ${type} detected trying to load \"${name}\". This module is not ignored ` +\n          \"and is trying to load itself while compiling itself, leading to a dependency cycle. \" +\n          'We recommend adding it to your \"ignore\" list in your babelrc, or to a .babelignore.',\n      );\n    }\n  }\n\n  try {\n    if (!process.env.BABEL_8_BREAKING) {\n      LOADING_MODULES.add(name);\n    }\n    return yield* loadCjsOrMjsDefault(\n      name,\n      `You appear to be using a native ECMAScript module ${type}, ` +\n        \"which is only supported when running Babel asynchronously.\",\n      // For backward compatibility, we need to support malformed presets\n      // defined as separate named exports rather than a single default\n      // export.\n      // See packages/babel-core/test/fixtures/option-manager/presets/es2015_named.js\n      true,\n    );\n  } catch (err) {\n    err.message = `[BABEL]: ${err.message} (While processing: ${name})`;\n    throw err;\n  } finally {\n    if (!process.env.BABEL_8_BREAKING) {\n      LOADING_MODULES.delete(name);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}