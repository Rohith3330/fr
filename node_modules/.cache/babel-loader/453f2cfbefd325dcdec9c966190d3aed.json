{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _regeneratorRuntime = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _createForOfIteratorHelper = require(\"C:/Users/Rohith/mern/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(findRelativeConfig),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(loadOneConfig),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime().mark(loadConfig),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime().mark(resolveShowConfigPath);\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ROOT_CONFIG_FILENAMES = void 0;\nexports.findConfigUpwards = findConfigUpwards;\nexports.findRelativeConfig = findRelativeConfig;\nexports.findRootConfig = findRootConfig;\nexports.loadConfig = loadConfig;\nexports.resolveShowConfigPath = resolveShowConfigPath;\n\nfunction _debug() {\n  var data = require(\"debug\");\n\n  _debug = function _debug() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fs() {\n  var data = require(\"fs\");\n\n  _fs = function _fs() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  var data = require(\"path\");\n\n  _path = function _path() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _json() {\n  var data = require(\"json5\");\n\n  _json = function _json() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _gensync() {\n  var data = require(\"gensync\");\n\n  _gensync = function _gensync() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _caching = require(\"../caching\");\n\nvar _configApi = require(\"../helpers/config-api\");\n\nvar _utils = require(\"./utils\");\n\nvar _moduleTypes = require(\"./module-types\");\n\nvar _patternToRegex = require(\"../pattern-to-regex\");\n\nvar _configError = require(\"../../errors/config-error\");\n\nvar fs = require(\"../../gensync-utils/fs\");\n\nfunction _module() {\n  var data = require(\"module\");\n\n  _module = function _module() {\n    return data;\n  };\n\n  return data;\n}\n\nvar _rewriteStackTrace = require(\"../../errors/rewrite-stack-trace\");\n\nvar debug = _debug()(\"babel:config:loading:files:configuration\");\n\nvar ROOT_CONFIG_FILENAMES = [\"babel.config.js\", \"babel.config.cjs\", \"babel.config.mjs\", \"babel.config.json\"];\nexports.ROOT_CONFIG_FILENAMES = ROOT_CONFIG_FILENAMES;\nvar RELATIVE_CONFIG_FILENAMES = [\".babelrc\", \".babelrc.js\", \".babelrc.cjs\", \".babelrc.mjs\", \".babelrc.json\"];\nvar BABELIGNORE_FILENAME = \".babelignore\";\n\nfunction findConfigUpwards(rootDir) {\n  var dirname = rootDir;\n\n  for (;;) {\n    var _iterator = _createForOfIteratorHelper(ROOT_CONFIG_FILENAMES),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var filename = _step.value;\n\n        if (_fs().existsSync(_path().join(dirname, filename))) {\n          return dirname;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var nextDir = _path().dirname(dirname);\n\n    if (dirname === nextDir) break;\n    dirname = nextDir;\n  }\n\n  return null;\n}\n\nfunction findRelativeConfig(packageData, envName, caller) {\n  var config, ignore, dirname, _iterator2, _step2, loc, _packageData$pkg, ignoreLoc;\n\n  return _regeneratorRuntime().wrap(function findRelativeConfig$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          config = null;\n          ignore = null;\n          dirname = _path().dirname(packageData.filepath);\n          _iterator2 = _createForOfIteratorHelper(packageData.directories);\n          _context.prev = 4;\n\n          _iterator2.s();\n\n        case 6:\n          if ((_step2 = _iterator2.n()).done) {\n            _context.next = 18;\n            break;\n          }\n\n          loc = _step2.value;\n\n          if (config) {\n            _context.next = 11;\n            break;\n          }\n\n          return _context.delegateYield(loadOneConfig(RELATIVE_CONFIG_FILENAMES, loc, envName, caller, ((_packageData$pkg = packageData.pkg) == null ? void 0 : _packageData$pkg.dirname) === loc ? packageToBabelConfig(packageData.pkg) : null), \"t0\", 10);\n\n        case 10:\n          config = _context.t0;\n\n        case 11:\n          if (ignore) {\n            _context.next = 16;\n            break;\n          }\n\n          ignoreLoc = _path().join(loc, BABELIGNORE_FILENAME);\n          return _context.delegateYield(readIgnoreConfig(ignoreLoc), \"t1\", 14);\n\n        case 14:\n          ignore = _context.t1;\n\n          if (ignore) {\n            debug(\"Found ignore %o from %o.\", ignore.filepath, dirname);\n          }\n\n        case 16:\n          _context.next = 6;\n          break;\n\n        case 18:\n          _context.next = 23;\n          break;\n\n        case 20:\n          _context.prev = 20;\n          _context.t2 = _context[\"catch\"](4);\n\n          _iterator2.e(_context.t2);\n\n        case 23:\n          _context.prev = 23;\n\n          _iterator2.f();\n\n          return _context.finish(23);\n\n        case 26:\n          return _context.abrupt(\"return\", {\n            config: config,\n            ignore: ignore\n          });\n\n        case 27:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[4, 20, 23, 26]]);\n}\n\nfunction findRootConfig(dirname, envName, caller) {\n  return loadOneConfig(ROOT_CONFIG_FILENAMES, dirname, envName, caller);\n}\n\nfunction loadOneConfig(names, dirname, envName, caller) {\n  var previousConfig,\n      configs,\n      config,\n      _args2 = arguments;\n  return _regeneratorRuntime().wrap(function loadOneConfig$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          previousConfig = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : null;\n          return _context2.delegateYield(_gensync().all(names.map(function (filename) {\n            return readConfig(_path().join(dirname, filename), envName, caller);\n          })), \"t0\", 2);\n\n        case 2:\n          configs = _context2.t0;\n          config = configs.reduce(function (previousConfig, config) {\n            if (config && previousConfig) {\n              throw new _configError.default(\"Multiple configuration files found. Please remove one:\\n\" + \" - \".concat(_path().basename(previousConfig.filepath), \"\\n\") + \" - \".concat(config.filepath, \"\\n\") + \"from \".concat(dirname));\n            }\n\n            return config || previousConfig;\n          }, previousConfig);\n\n          if (config) {\n            debug(\"Found configuration %o from %o.\", config.filepath, dirname);\n          }\n\n          return _context2.abrupt(\"return\", config);\n\n        case 6:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n\nfunction loadConfig(name, dirname, envName, caller) {\n  var filepath, conf;\n  return _regeneratorRuntime().wrap(function loadConfig$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          filepath = (function (v, w) {\n            return v = v.split(\".\"), w = w.split(\".\"), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1];\n          }(process.versions.node, \"8.9\") ? require.resolve : function (r, _ref) {\n            var _ref$paths = _slicedToArray(_ref.paths, 1),\n                b = _ref$paths[0];\n\n            var M = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : require(\"module\");\n\n            var f = M._findPath(r, M._nodeModulePaths(b).concat(b));\n\n            if (f) return f;\n            f = new Error(\"Cannot resolve module '\".concat(r, \"'\"));\n            f.code = \"MODULE_NOT_FOUND\";\n            throw f;\n          })(name, {\n            paths: [dirname]\n          });\n          return _context3.delegateYield(readConfig(filepath, envName, caller), \"t0\", 2);\n\n        case 2:\n          conf = _context3.t0;\n\n          if (conf) {\n            _context3.next = 5;\n            break;\n          }\n\n          throw new _configError.default(\"Config file contains no configuration data\", filepath);\n\n        case 5:\n          debug(\"Loaded config %o from %o.\", name, dirname);\n          return _context3.abrupt(\"return\", conf);\n\n        case 7:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3);\n}\n\nfunction readConfig(filepath, envName, caller) {\n  var ext = _path().extname(filepath);\n\n  return ext === \".js\" || ext === \".cjs\" || ext === \".mjs\" ? readConfigJS(filepath, {\n    envName: envName,\n    caller: caller\n  }) : readConfigJSON5(filepath);\n}\n\nvar LOADING_CONFIGS = new Set();\nvar readConfigJS = (0, _caching.makeStrongCache)( /*#__PURE__*/_regeneratorRuntime().mark(function readConfigJS(filepath, cache) {\n  var options, assertCache;\n  return _regeneratorRuntime().wrap(function readConfigJS$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          if (_fs().existsSync(filepath)) {\n            _context4.next = 3;\n            break;\n          }\n\n          cache.never();\n          return _context4.abrupt(\"return\", null);\n\n        case 3:\n          if (!LOADING_CONFIGS.has(filepath)) {\n            _context4.next = 7;\n            break;\n          }\n\n          cache.never();\n          debug(\"Auto-ignoring usage of config %o.\", filepath);\n          return _context4.abrupt(\"return\", {\n            filepath: filepath,\n            dirname: _path().dirname(filepath),\n            options: {}\n          });\n\n        case 7:\n          _context4.prev = 7;\n          LOADING_CONFIGS.add(filepath);\n          return _context4.delegateYield((0, _moduleTypes.default)(filepath, \"You appear to be using a native ECMAScript module configuration \" + \"file, which is only supported when running Babel asynchronously.\"), \"t0\", 10);\n\n        case 10:\n          options = _context4.t0;\n\n        case 11:\n          _context4.prev = 11;\n          LOADING_CONFIGS.delete(filepath);\n          return _context4.finish(11);\n\n        case 14:\n          assertCache = false;\n\n          if (!(typeof options === \"function\")) {\n            _context4.next = 19;\n            break;\n          }\n\n          return _context4.delegateYield([], \"t1\", 17);\n\n        case 17:\n          options = (0, _rewriteStackTrace.endHiddenCallStack)(options)((0, _configApi.makeConfigAPI)(cache));\n          assertCache = true;\n\n        case 19:\n          if (!(!options || typeof options !== \"object\" || Array.isArray(options))) {\n            _context4.next = 21;\n            break;\n          }\n\n          throw new _configError.default(\"Configuration should be an exported JavaScript object.\", filepath);\n\n        case 21:\n          if (!(typeof options.then === \"function\")) {\n            _context4.next = 23;\n            break;\n          }\n\n          throw new _configError.default(\"You appear to be using an async configuration, \" + \"which your current version of Babel does not support. \" + \"We may add support for this in the future, \" + \"but if you're on the most recent version of @babel/core and still \" + \"seeing this error, then you'll need to synchronously return your config.\", filepath);\n\n        case 23:\n          if (assertCache && !cache.configured()) throwConfigError(filepath);\n          return _context4.abrupt(\"return\", {\n            filepath: filepath,\n            dirname: _path().dirname(filepath),\n            options: options\n          });\n\n        case 25:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, readConfigJS, null, [[7,, 11, 14]]);\n}));\nvar packageToBabelConfig = (0, _caching.makeWeakCacheSync)(function (file) {\n  var babel = file.options[\"babel\"];\n  if (typeof babel === \"undefined\") return null;\n\n  if (typeof babel !== \"object\" || Array.isArray(babel) || babel === null) {\n    throw new _configError.default(\".babel property must be an object\", file.filepath);\n  }\n\n  return {\n    filepath: file.filepath,\n    dirname: file.dirname,\n    options: babel\n  };\n});\nvar readConfigJSON5 = (0, _utils.makeStaticFileCache)(function (filepath, content) {\n  var options;\n\n  try {\n    options = _json().parse(content);\n  } catch (err) {\n    throw new _configError.default(\"Error while parsing config - \".concat(err.message), filepath);\n  }\n\n  if (!options) throw new _configError.default(\"No config detected\", filepath);\n\n  if (typeof options !== \"object\") {\n    throw new _configError.default(\"Config returned typeof \".concat(typeof options), filepath);\n  }\n\n  if (Array.isArray(options)) {\n    throw new _configError.default(\"Expected config object but found array\", filepath);\n  }\n\n  delete options[\"$schema\"];\n  return {\n    filepath: filepath,\n    dirname: _path().dirname(filepath),\n    options: options\n  };\n});\nvar readIgnoreConfig = (0, _utils.makeStaticFileCache)(function (filepath, content) {\n  var ignoreDir = _path().dirname(filepath);\n\n  var ignorePatterns = content.split(\"\\n\").map(function (line) {\n    return line.replace(/#(.*?)$/, \"\").trim();\n  }).filter(function (line) {\n    return !!line;\n  });\n\n  var _iterator3 = _createForOfIteratorHelper(ignorePatterns),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var pattern = _step3.value;\n\n      if (pattern[0] === \"!\") {\n        throw new _configError.default(\"Negation of file paths is not supported.\", filepath);\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return {\n    filepath: filepath,\n    dirname: _path().dirname(filepath),\n    ignore: ignorePatterns.map(function (pattern) {\n      return (0, _patternToRegex.default)(pattern, ignoreDir);\n    })\n  };\n});\n\nfunction resolveShowConfigPath(dirname) {\n  var targetPath, absolutePath, stats;\n  return _regeneratorRuntime().wrap(function resolveShowConfigPath$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          targetPath = process.env.BABEL_SHOW_CONFIG_FOR;\n\n          if (!(targetPath != null)) {\n            _context5.next = 8;\n            break;\n          }\n\n          absolutePath = _path().resolve(dirname, targetPath);\n          return _context5.delegateYield(fs.stat(absolutePath), \"t0\", 4);\n\n        case 4:\n          stats = _context5.t0;\n\n          if (stats.isFile()) {\n            _context5.next = 7;\n            break;\n          }\n\n          throw new Error(\"\".concat(absolutePath, \": BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.\"));\n\n        case 7:\n          return _context5.abrupt(\"return\", absolutePath);\n\n        case 8:\n          return _context5.abrupt(\"return\", null);\n\n        case 9:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked4);\n}\n\nfunction throwConfigError(filepath) {\n  throw new _configError.default(\"Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured\\nfor various types of caching, using the first param of their handler functions:\\n\\nmodule.exports = function(api) {\\n  // The API exposes the following:\\n\\n  // Cache the returned value forever and don't call this function again.\\n  api.cache(true);\\n\\n  // Don't cache at all. Not recommended because it will be very slow.\\n  api.cache(false);\\n\\n  // Cached based on the value of some function. If this function returns a value different from\\n  // a previously-encountered value, the plugins will re-evaluate.\\n  var env = api.cache(() => process.env.NODE_ENV);\\n\\n  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for\\n  // any possible NODE_ENV value that might come up during plugin execution.\\n  var isProd = api.cache(() => process.env.NODE_ENV === \\\"production\\\");\\n\\n  // .cache(fn) will perform a linear search though instances to find the matching plugin based\\n  // based on previous instantiated plugins. If you want to recreate the plugin and discard the\\n  // previous instance whenever something changes, you may use:\\n  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === \\\"production\\\");\\n\\n  // Note, we also expose the following more-verbose versions of the above examples:\\n  api.cache.forever(); // api.cache(true)\\n  api.cache.never();   // api.cache(false)\\n  api.cache.using(fn); // api.cache(fn)\\n\\n  // Return the value that will be cached.\\n  return { };\\n};\", filepath);\n}\n\n0 && 0;","map":{"version":3,"mappings":";;;;;;;;sDA0DiBA,kB;uDA4CPC,a;uDA+BOC,U;uDA2LAC,qB;;;;;;;;;;;;AAhUjB;EAAA;;EAAAC;IAAA;EAAA;;EAAA;AAAA;;AACA;EAAA;;EAAAC;IAAA;EAAA;;EAAA;AAAA;;AACA;EAAA;;EAAAC;IAAA;EAAA;;EAAA;AAAA;;AACA;EAAA;;EAAAC;IAAA;EAAA;;EAAA;AAAA;;AACA;EAAA;;EAAAC;IAAA;EAAA;;EAAA;AAAA;;AAEA;;AAEA;;AAEA;;AACA;;AACA;;AAGA;;AAEA;;AAEA;EAAA;;EAAAC;IAAA;EAAA;;EAAA;AAAA;;AACA;;AAGA,IAAMC,KAAK,GAAGC,SAAW,0CAAXA,CAAd;;AAEO,IAAMC,qBAAqB,GAAG,CACnC,iBADmC,EAEnC,kBAFmC,EAGnC,kBAHmC,EAInC,mBAJmC,CAA9B;;AAMP,IAAMC,yBAAyB,GAAG,CAChC,UADgC,EAEhC,aAFgC,EAGhC,cAHgC,EAIhC,cAJgC,EAKhC,eALgC,CAAlC;AAQA,IAAMC,oBAAoB,GAAG,cAA7B;;AAEO,SAASC,iBAAT,CAA2BC,OAA3B,EAA2D;EAChE,IAAIC,OAAO,GAAGD,OAAd;;EACA,SAAS;IAAA,2CACgBJ,qBADhB;IAAA;;IAAA;MACP,oDAA8C;QAAA,IAAnCM,QAAmC;;QAC5C,IAAIC,MAAOC,UAAPD,CAAkBE,QAAKC,IAALD,CAAUJ,OAAVI,EAAmBH,QAAnBG,CAAlBF,CAAJ,EAAqD;UACnD,OAAOF,OAAP;QACD;MACF;IALM;MAAA;IAAA;MAAA;IAAA;;IAOP,IAAMM,OAAO,GAAGF,QAAKJ,OAALI,CAAaJ,OAAbI,CAAhB;;IACA,IAAIJ,OAAO,KAAKM,OAAhB,EAAyB;IACzBN,OAAO,GAAGM,OAAVN;EACD;;EAED,OAAO,IAAP;AACD;;AAEM,SAAUjB,kBAAV,CACLwB,WADK,EAELC,OAFK,EAGLC,MAHK;EAAA;;EAAA;IAAA;MAAA;QAAA;UAKDC,MALC,GAKQ,IALR;UAMDC,MANC,GAMQ,IANR;UAQCX,OARD,GAQWI,QAAKJ,OAALI,CAAaG,WAAW,CAACK,QAAzBR,CARX;UAAA,wCAUaG,WAAW,CAACM,WAVzB;UAAA;;UAAA;;QAAA;UAAA;YAAA;YAAA;UAAA;;UAUMC,GAVN;;UAAA,IAWEJ,MAXF;YAAA;YAAA;UAAA;;UAYQ,8BAAO1B,aAAa,CAC3BY,yBAD2B,EAE3BkB,GAF2B,EAG3BN,OAH2B,EAI3BC,MAJ2B,EAK3B,gCAAW,CAACM,GAAZ,sCAAiBf,OAAjB,MAA6Bc,GAA7B,GACIE,oBAAoB,CAACT,WAAW,CAACQ,GAAb,CADxB,GAEI,IAPuB,CAApB;;QAZR;UAYDL,MAZC;;QAAA;UAAA,IAuBEC,MAvBF;YAAA;YAAA;UAAA;;UAwBKM,SAxBL,GAwBiBb,QAAKC,IAALD,CAAUU,GAAVV,EAAeP,oBAAfO,CAxBjB;UAyBQ,8BAAOc,gBAAgB,CAACD,SAAD,CAAvB;;QAzBR;UAyBDN,MAzBC;;UA2BD,IAAIA,MAAJ,EAAY;YACVlB,KAAK,CAAC,0BAAD,EAA6BkB,MAAM,CAACC,QAApC,EAA8CZ,OAA9C,CAALP;UACD;;QA7BA;UAAA;UAAA;;QAAA;UAAA;UAAA;;QAAA;UAAA;UAAA;;UAAA;;QAAA;UAAA;;UAAA;;UAAA;;QAAA;UAAA,iCAiCE;YAAEiB,MAAF,EAAEA,MAAF;YAAUC;UAAV,CAjCF;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA;;AAoCA,SAASQ,cAAT,CACLnB,OADK,EAELQ,OAFK,EAGLC,MAHK,EAIuB;EAC5B,OAAOzB,aAAa,CAACW,qBAAD,EAAwBK,OAAxB,EAAiCQ,OAAjC,EAA0CC,MAA1C,CAApB;AACD;;AAED,SAAUzB,aAAV,CACEoC,KADF,EAEEpB,OAFF,EAGEQ,OAHF,EAIEC,MAJF;EAAA;EAAA;EAAA;EAAA;EAAA;IAAA;MAAA;QAAA;UAKEY,cALF,8DAKsC,IALtC;UAOkB,+BAAOC,WAAQC,GAARD,CACrBF,KAAK,CAACI,GAANJ,CAAUnB,kBAAQ;YAAA,OAChBwB,UAAU,CAACrB,QAAKC,IAALD,CAAUJ,OAAVI,EAAmBH,QAAnBG,CAAD,EAA+BI,OAA/B,EAAwCC,MAAxC,CADM;UAAA,CAAlBW,CADqBE,CAAP;;QAPlB;UAOQI,OAPR;UAYQhB,MAZR,GAYiBgB,OAAO,CAACC,MAARD,CAAe,UAACL,cAAD,EAAoCX,MAApC,EAA+C;YAC3E,IAAIA,MAAM,IAAIW,cAAd,EAA8B;cAC5B,MAAM,IAAIO,oBAAJ,CACH,0EACOxB,QAAKyB,QAALzB,CAAciB,cAAc,CAACT,QAA7BR,CADP,uBAEOM,MAAM,CAACE,QAFd,yBAGSZ,OAHT,CADG,CAAN;YAMD;;YAED,OAAOU,MAAM,IAAIW,cAAjB;UAVa,GAWZA,cAXYK,CAZjB;;UAyBE,IAAIhB,MAAJ,EAAY;YACVjB,KAAK,CAAC,iCAAD,EAAoCiB,MAAM,CAACE,QAA3C,EAAqDZ,OAArD,CAALP;UACD;;UA3BH,kCA4BSiB,MA5BT;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA;;AA+BO,SAAUzB,UAAV,CACL6C,IADK,EAEL9B,OAFK,EAGLQ,OAHK,EAILC,MAJK;EAAA;EAAA;IAAA;MAAA;QAAA;UAMCG,QAND,GAMY;YAAA;UAAA;YAAA;YAAA;;YAAA;;YAAA;;YAAA;YAAAmB;YAAAA;YAAA;UAAA,GAAgBD,IAAhB,EAAsB;YAAEE,KAAK,EAAE,CAAChC,OAAD;UAAT,CAAtB,CANZ;UAQQ,+BAAOyB,UAAU,CAACb,QAAD,EAAWJ,OAAX,EAAoBC,MAApB,CAAjB;;QARR;UAQCwB,IARD;;UAAA,IASAA,IATA;YAAA;YAAA;UAAA;;UAAA,MAUG,IAAIL,oBAAJ,+CAEJhB,QAFI,CAVH;;QAAA;UAgBLnB,KAAK,CAAC,2BAAD,EAA8BqC,IAA9B,EAAoC9B,OAApC,CAALP;UAhBK,kCAiBEwC,IAjBF;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA;;AAwBP,SAASR,UAAT,CACEb,QADF,EAEEJ,OAFF,EAGEC,MAHF,EAI8B;EAC5B,IAAMyB,GAAG,GAAG9B,QAAK+B,OAAL/B,CAAaQ,QAAbR,CAAZ;;EACA,OAAO8B,GAAG,KAAK,KAARA,IAAiBA,GAAG,KAAK,MAAzBA,IAAmCA,GAAG,KAAK,MAA3CA,GACHE,YAAY,CAACxB,QAAD,EAAW;IAAEJ,OAAF,EAAEA,OAAF;IAAWC;EAAX,CAAX,CADTyB,GAEHG,eAAe,CAACzB,QAAD,CAFnB;AAGD;;AAED,IAAM0B,eAAe,GAAG,IAAIC,GAAJ,EAAxB;AAEA,IAAMH,YAAY,GAAG,uEAAgB,SAAUA,YAAV,CACnCxB,QADmC,EAEnC4B,KAFmC;EAAA;EAAA;IAAA;MAAA;QAAA;UAAA,IAO9BtC,MAAOC,UAAPD,CAAkBU,QAAlBV,CAP8B;YAAA;YAAA;UAAA;;UAQjCsC,KAAK,CAACC,KAAND;UARiC,kCAS1B,IAT0B;;QAAA;UAAA,KAe/BF,eAAe,CAACI,GAAhBJ,CAAoB1B,QAApB0B,CAf+B;YAAA;YAAA;UAAA;;UAgBjCE,KAAK,CAACC,KAAND;UAEA/C,KAAK,CAAC,mCAAD,EAAsCmB,QAAtC,CAALnB;UAlBiC,kCAmB1B;YACLmB,QADK,EACLA,QADK;YAELZ,OAAO,EAAEI,QAAKJ,OAALI,CAAaQ,QAAbR,CAFJ;YAGLuC,OAAO,EAAE;UAHJ,CAnB0B;;QAAA;UAAA;UA4BjCL,eAAe,CAACM,GAAhBN,CAAoB1B,QAApB0B;UACU,+BAAO,0BACf1B,QADe,EAEf,qEACE,kEAHa,CAAP;;QA7BuB;UA6BjC+B,OA7BiC;;QAAA;UAAA;UAmCjCL,eAAe,CAACO,MAAhBP,CAAuB1B,QAAvB0B;UAnCiC;;QAAA;UAsC/BQ,WAtC+B,GAsCjB,KAtCiB;;UAAA,MAuC/B,OAAOH,OAAP,KAAmB,UAvCY;YAAA;YAAA;UAAA;;UAyCjC,+BAAO,EAAP;;QAzCiC;UA2CjCA,OAAO,GAAG,2CAAmBA,OAAnB,EACR,8BAAcH,KAAd,CADQ,CAAVG;UAIAG,WAAW,GAAG,IAAdA;;QA/CiC;UAAA,MAkD/B,CAACH,OAAD,IAAY,OAAOA,OAAP,KAAmB,QAA/B,IAA2CI,KAAK,CAACC,OAAND,CAAcJ,OAAdI,CAlDZ;YAAA;YAAA;UAAA;;UAAA,MAmD3B,IAAInB,oBAAJ,2DAEJhB,QAFI,CAnD2B;;QAAA;UAAA,MA0D/B,OAAO+B,OAAO,CAACM,IAAf,KAAwB,UA1DO;YAAA;YAAA;UAAA;;UAAA,MA2D3B,IAAIrB,oBAAJ,CACH,gTADG,EAMJhB,QANI,CA3D2B;;QAAA;UAqEnC,IAAIkC,WAAW,IAAI,CAACN,KAAK,CAACU,UAANV,EAApB,EAAwCW,gBAAgB,CAACvC,QAAD,CAAhBuC;UArEL,kCAuE5B;YACLvC,QADK,EACLA,QADK;YAELZ,OAAO,EAAEI,QAAKJ,OAALI,CAAaQ,QAAbR,CAFJ;YAGLuC;UAHK,CAvE4B;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA,GAAUP,YAAV;AAAA,CAAhB,EAArB;AA8EA,IAAMpB,oBAAoB,GAAG,gCAC1BoC,cAAD,EAAyC;EACvC,IAAMC,KAAc,GAAGD,IAAI,CAACT,OAALS,CAAa,OAAbA,CAAvB;EAEA,IAAI,OAAOC,KAAP,KAAiB,WAArB,EAAkC,OAAO,IAAP;;EAElC,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BN,KAAK,CAACC,OAAND,CAAcM,KAAdN,CAA7B,IAAqDM,KAAK,KAAK,IAAnE,EAAyE;IACvE,MAAM,IAAIzB,oBAAJ,sCAAqDwB,IAAI,CAACxC,QAA1D,CAAN;EACD;;EAED,OAAO;IACLA,QAAQ,EAAEwC,IAAI,CAACxC,QADV;IAELZ,OAAO,EAAEoD,IAAI,CAACpD,OAFT;IAGL2C,OAAO,EAAEU;EAHJ,CAAP;AAVyB,EAA7B;AAkBA,IAAMhB,eAAe,GAAG,gCAAoB,UAACzB,QAAD,EAAW0C,OAAX,EAAmC;EAC7E,IAAIX,OAAJ;;EACA,IAAI;IACFA,OAAO,GAAGY,QAAMC,KAAND,CAAYD,OAAZC,CAAVZ;EADF,EAEE,OAAOc,GAAP,EAAY;IACZ,MAAM,IAAI7B,oBAAJ,wCAC4B6B,GAAG,CAACC,OADhC,GAEJ9C,QAFI,CAAN;EAID;;EAED,IAAI,CAAC+B,OAAL,EAAc,MAAM,IAAIf,oBAAJ,uBAAsChB,QAAtC,CAAN;;EAEd,IAAI,OAAO+B,OAAP,KAAmB,QAAvB,EAAiC;IAC/B,MAAM,IAAIf,oBAAJ,kCAA0C,OAAOe,OAAjD,GAA4D/B,QAA5D,CAAN;EACD;;EACD,IAAImC,KAAK,CAACC,OAAND,CAAcJ,OAAdI,CAAJ,EAA4B;IAC1B,MAAM,IAAInB,oBAAJ,2CAA0DhB,QAA1D,CAAN;EACD;;EAED,OAAO+B,OAAO,CAAC,SAAD,CAAd;EAEA,OAAO;IACL/B,QADK,EACLA,QADK;IAELZ,OAAO,EAAEI,QAAKJ,OAALI,CAAaQ,QAAbR,CAFJ;IAGLuC;EAHK,CAAP;AAtBsB,EAAxB;AA6BA,IAAMzB,gBAAgB,GAAG,gCAAoB,UAACN,QAAD,EAAW0C,OAAX,EAAuB;EAClE,IAAMK,SAAS,GAAGvD,QAAKJ,OAALI,CAAaQ,QAAbR,CAAlB;;EACA,IAAMwD,cAAc,GAAGN,OAAO,CAC3BO,KADoBP,CACd,IADcA,EAEpB9B,GAFoB8B,CAERQ,cAAI;IAAA,OAAIA,IAAI,CAACC,OAALD,CAAa,SAAbA,EAAwB,EAAxBA,EAA4BE,IAA5BF,EAAJ;EAAA,CAFIR,EAGpBW,MAHoBX,CAGbQ,cAAI;IAAA,OAAI,CAAC,CAACA,IAAN;EAAA,CAHSR,CAAvB;;EAFkE,4CAO5CM,cAP4C;EAAA;;EAAA;IAOlE,uDAAsC;MAAA,IAA3BM,OAA2B;;MACpC,IAAIA,OAAO,CAAC,CAAD,CAAPA,KAAe,GAAnB,EAAwB;QACtB,MAAM,IAAItC,oBAAJ,6CAEJhB,QAFI,CAAN;MAID;IACF;EAdiE;IAAA;EAAA;IAAA;EAAA;;EAgBlE,OAAO;IACLA,QADK,EACLA,QADK;IAELZ,OAAO,EAAEI,QAAKJ,OAALI,CAAaQ,QAAbR,CAFJ;IAGLO,MAAM,EAAEiD,cAAc,CAACpC,GAAfoC,CAAmBM,iBAAO;MAAA,OAChC,6BAAmBA,OAAnB,EAA4BP,SAA5B,CADgC;IAAA,CAA1BC;EAHH,CAAP;AAhBuB,EAAzB;;AAyBO,SAAU1E,qBAAV,CACLc,OADK;EAAA;EAAA;IAAA;MAAA;QAAA;UAGCmE,UAHD,GAGcC,OAAO,CAACC,GAARD,CAAYE,qBAH1B;;UAAA,MAIDH,UAAU,IAAI,IAJb;YAAA;YAAA;UAAA;;UAKGI,YALH,GAKkBnE,QAAKoE,OAALpE,CAAaJ,OAAbI,EAAsB+D,UAAtB/D,CALlB;UAMW,+BAAOqE,EAAE,CAACC,IAAHD,CAAQF,YAARE,CAAP;;QANX;UAMGE,KANH;;UAAA,IAOEA,KAAK,CAACC,MAAND,EAPF;YAAA;YAAA;UAAA;;UAAA,MAQK,IAAIE,KAAJ,WACDN,YADC,0FARL;;QAAA;UAAA,kCAYIA,YAZJ;;QAAA;UAAA,kCAcE,IAdF;;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA;AAAA;;AAiBP,SAASpB,gBAAT,CAA0BvC,QAA1B,EAAmD;EACjD,MAAM,IAAIgB,oBAAJ,wgDAmCJhB,QAnCI,CAAN;AAqCD","names":["findRelativeConfig","loadOneConfig","loadConfig","resolveShowConfigPath","_debug","_fs","_path","_json","_gensync","_module","debug","buildDebug","ROOT_CONFIG_FILENAMES","RELATIVE_CONFIG_FILENAMES","BABELIGNORE_FILENAME","findConfigUpwards","rootDir","dirname","filename","nodeFs","existsSync","path","join","nextDir","packageData","envName","caller","config","ignore","filepath","directories","loc","pkg","packageToBabelConfig","ignoreLoc","readIgnoreConfig","findRootConfig","names","previousConfig","gensync","all","map","readConfig","configs","reduce","ConfigError","basename","name","f","paths","conf","ext","extname","readConfigJS","readConfigJSON5","LOADING_CONFIGS","Set","cache","never","has","options","add","delete","assertCache","Array","isArray","then","configured","throwConfigError","file","babel","content","json5","parse","err","message","ignoreDir","ignorePatterns","split","line","replace","trim","filter","pattern","targetPath","process","env","BABEL_SHOW_CONFIG_FOR","absolutePath","resolve","fs","stat","stats","isFile","Error"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\files\\configuration.ts"],"sourcesContent":["import buildDebug from \"debug\";\nimport nodeFs from \"fs\";\nimport path from \"path\";\nimport json5 from \"json5\";\nimport gensync from \"gensync\";\nimport type { Handler } from \"gensync\";\nimport { makeStrongCache, makeWeakCacheSync } from \"../caching\";\nimport type { CacheConfigurator } from \"../caching\";\nimport { makeConfigAPI } from \"../helpers/config-api\";\nimport type { ConfigAPI } from \"../helpers/config-api\";\nimport { makeStaticFileCache } from \"./utils\";\nimport loadCjsOrMjsDefault from \"./module-types\";\nimport pathPatternToRegex from \"../pattern-to-regex\";\nimport type { FilePackageData, RelativeConfig, ConfigFile } from \"./types\";\nimport type { CallerMetadata } from \"../validation/options\";\nimport ConfigError from \"../../errors/config-error\";\n\nimport * as fs from \"../../gensync-utils/fs\";\n\nimport { createRequire } from \"module\";\nimport { endHiddenCallStack } from \"../../errors/rewrite-stack-trace\";\nconst require = createRequire(import.meta.url);\n\nconst debug = buildDebug(\"babel:config:loading:files:configuration\");\n\nexport const ROOT_CONFIG_FILENAMES = [\n  \"babel.config.js\",\n  \"babel.config.cjs\",\n  \"babel.config.mjs\",\n  \"babel.config.json\",\n];\nconst RELATIVE_CONFIG_FILENAMES = [\n  \".babelrc\",\n  \".babelrc.js\",\n  \".babelrc.cjs\",\n  \".babelrc.mjs\",\n  \".babelrc.json\",\n];\n\nconst BABELIGNORE_FILENAME = \".babelignore\";\n\nexport function findConfigUpwards(rootDir: string): string | null {\n  let dirname = rootDir;\n  for (;;) {\n    for (const filename of ROOT_CONFIG_FILENAMES) {\n      if (nodeFs.existsSync(path.join(dirname, filename))) {\n        return dirname;\n      }\n    }\n\n    const nextDir = path.dirname(dirname);\n    if (dirname === nextDir) break;\n    dirname = nextDir;\n  }\n\n  return null;\n}\n\nexport function* findRelativeConfig(\n  packageData: FilePackageData,\n  envName: string,\n  caller: CallerMetadata | undefined,\n): Handler<RelativeConfig> {\n  let config = null;\n  let ignore = null;\n\n  const dirname = path.dirname(packageData.filepath);\n\n  for (const loc of packageData.directories) {\n    if (!config) {\n      config = yield* loadOneConfig(\n        RELATIVE_CONFIG_FILENAMES,\n        loc,\n        envName,\n        caller,\n        packageData.pkg?.dirname === loc\n          ? packageToBabelConfig(packageData.pkg as ConfigFile)\n          : null,\n      );\n    }\n\n    if (!ignore) {\n      const ignoreLoc = path.join(loc, BABELIGNORE_FILENAME);\n      ignore = yield* readIgnoreConfig(ignoreLoc);\n\n      if (ignore) {\n        debug(\"Found ignore %o from %o.\", ignore.filepath, dirname);\n      }\n    }\n  }\n\n  return { config, ignore };\n}\n\nexport function findRootConfig(\n  dirname: string,\n  envName: string,\n  caller: CallerMetadata | undefined,\n): Handler<ConfigFile | null> {\n  return loadOneConfig(ROOT_CONFIG_FILENAMES, dirname, envName, caller);\n}\n\nfunction* loadOneConfig(\n  names: string[],\n  dirname: string,\n  envName: string,\n  caller: CallerMetadata | undefined,\n  previousConfig: ConfigFile | null = null,\n): Handler<ConfigFile | null> {\n  const configs = yield* gensync.all(\n    names.map(filename =>\n      readConfig(path.join(dirname, filename), envName, caller),\n    ),\n  );\n  const config = configs.reduce((previousConfig: ConfigFile | null, config) => {\n    if (config && previousConfig) {\n      throw new ConfigError(\n        `Multiple configuration files found. Please remove one:\\n` +\n          ` - ${path.basename(previousConfig.filepath)}\\n` +\n          ` - ${config.filepath}\\n` +\n          `from ${dirname}`,\n      );\n    }\n\n    return config || previousConfig;\n  }, previousConfig);\n\n  if (config) {\n    debug(\"Found configuration %o from %o.\", config.filepath, dirname);\n  }\n  return config;\n}\n\nexport function* loadConfig(\n  name: string,\n  dirname: string,\n  envName: string,\n  caller: CallerMetadata | undefined,\n): Handler<ConfigFile> {\n  const filepath = require.resolve(name, { paths: [dirname] });\n\n  const conf = yield* readConfig(filepath, envName, caller);\n  if (!conf) {\n    throw new ConfigError(\n      `Config file contains no configuration data`,\n      filepath,\n    );\n  }\n\n  debug(\"Loaded config %o from %o.\", name, dirname);\n  return conf;\n}\n\n/**\n * Read the given config file, returning the result. Returns null if no config was found, but will\n * throw if there are parsing errors while loading a config.\n */\nfunction readConfig(\n  filepath: string,\n  envName: string,\n  caller: CallerMetadata | undefined,\n): Handler<ConfigFile | null> {\n  const ext = path.extname(filepath);\n  return ext === \".js\" || ext === \".cjs\" || ext === \".mjs\"\n    ? readConfigJS(filepath, { envName, caller })\n    : readConfigJSON5(filepath);\n}\n\nconst LOADING_CONFIGS = new Set();\n\nconst readConfigJS = makeStrongCache(function* readConfigJS(\n  filepath: string,\n  cache: CacheConfigurator<{\n    envName: string;\n    caller: CallerMetadata | undefined;\n  }>,\n): Handler<ConfigFile | null> {\n  if (!nodeFs.existsSync(filepath)) {\n    cache.never();\n    return null;\n  }\n\n  // The `require()` call below can make this code reentrant if a require hook like @babel/register has been\n  // loaded into the system. That would cause Babel to attempt to compile the `.babelrc.js` file as it loads\n  // below. To cover this case, we auto-ignore re-entrant config processing.\n  if (LOADING_CONFIGS.has(filepath)) {\n    cache.never();\n\n    debug(\"Auto-ignoring usage of config %o.\", filepath);\n    return {\n      filepath,\n      dirname: path.dirname(filepath),\n      options: {},\n    };\n  }\n\n  let options: unknown;\n  try {\n    LOADING_CONFIGS.add(filepath);\n    options = yield* loadCjsOrMjsDefault(\n      filepath,\n      \"You appear to be using a native ECMAScript module configuration \" +\n        \"file, which is only supported when running Babel asynchronously.\",\n    );\n  } finally {\n    LOADING_CONFIGS.delete(filepath);\n  }\n\n  let assertCache = false;\n  if (typeof options === \"function\") {\n    // @ts-expect-error - if we want to make it possible to use async configs\n    yield* [];\n\n    options = endHiddenCallStack(options as any as (api: ConfigAPI) => {})(\n      makeConfigAPI(cache),\n    );\n\n    assertCache = true;\n  }\n\n  if (!options || typeof options !== \"object\" || Array.isArray(options)) {\n    throw new ConfigError(\n      `Configuration should be an exported JavaScript object.`,\n      filepath,\n    );\n  }\n\n  // @ts-expect-error todo(flow->ts)\n  if (typeof options.then === \"function\") {\n    throw new ConfigError(\n      `You appear to be using an async configuration, ` +\n        `which your current version of Babel does not support. ` +\n        `We may add support for this in the future, ` +\n        `but if you're on the most recent version of @babel/core and still ` +\n        `seeing this error, then you'll need to synchronously return your config.`,\n      filepath,\n    );\n  }\n\n  if (assertCache && !cache.configured()) throwConfigError(filepath);\n\n  return {\n    filepath,\n    dirname: path.dirname(filepath),\n    options,\n  };\n});\n\nconst packageToBabelConfig = makeWeakCacheSync(\n  (file: ConfigFile): ConfigFile | null => {\n    const babel: unknown = file.options[\"babel\"];\n\n    if (typeof babel === \"undefined\") return null;\n\n    if (typeof babel !== \"object\" || Array.isArray(babel) || babel === null) {\n      throw new ConfigError(`.babel property must be an object`, file.filepath);\n    }\n\n    return {\n      filepath: file.filepath,\n      dirname: file.dirname,\n      options: babel,\n    };\n  },\n);\n\nconst readConfigJSON5 = makeStaticFileCache((filepath, content): ConfigFile => {\n  let options;\n  try {\n    options = json5.parse(content);\n  } catch (err) {\n    throw new ConfigError(\n      `Error while parsing config - ${err.message}`,\n      filepath,\n    );\n  }\n\n  if (!options) throw new ConfigError(`No config detected`, filepath);\n\n  if (typeof options !== \"object\") {\n    throw new ConfigError(`Config returned typeof ${typeof options}`, filepath);\n  }\n  if (Array.isArray(options)) {\n    throw new ConfigError(`Expected config object but found array`, filepath);\n  }\n\n  delete options[\"$schema\"];\n\n  return {\n    filepath,\n    dirname: path.dirname(filepath),\n    options,\n  };\n});\n\nconst readIgnoreConfig = makeStaticFileCache((filepath, content) => {\n  const ignoreDir = path.dirname(filepath);\n  const ignorePatterns = content\n    .split(\"\\n\")\n    .map<string>(line => line.replace(/#(.*?)$/, \"\").trim())\n    .filter(line => !!line);\n\n  for (const pattern of ignorePatterns) {\n    if (pattern[0] === \"!\") {\n      throw new ConfigError(\n        `Negation of file paths is not supported.`,\n        filepath,\n      );\n    }\n  }\n\n  return {\n    filepath,\n    dirname: path.dirname(filepath),\n    ignore: ignorePatterns.map(pattern =>\n      pathPatternToRegex(pattern, ignoreDir),\n    ),\n  };\n});\n\nexport function* resolveShowConfigPath(\n  dirname: string,\n): Handler<string | null> {\n  const targetPath = process.env.BABEL_SHOW_CONFIG_FOR;\n  if (targetPath != null) {\n    const absolutePath = path.resolve(dirname, targetPath);\n    const stats = yield* fs.stat(absolutePath);\n    if (!stats.isFile()) {\n      throw new Error(\n        `${absolutePath}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`,\n      );\n    }\n    return absolutePath;\n  }\n  return null;\n}\n\nfunction throwConfigError(filepath: string): never {\n  throw new ConfigError(\n    `\\\nCaching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured\nfor various types of caching, using the first param of their handler functions:\n\nmodule.exports = function(api) {\n  // The API exposes the following:\n\n  // Cache the returned value forever and don't call this function again.\n  api.cache(true);\n\n  // Don't cache at all. Not recommended because it will be very slow.\n  api.cache(false);\n\n  // Cached based on the value of some function. If this function returns a value different from\n  // a previously-encountered value, the plugins will re-evaluate.\n  var env = api.cache(() => process.env.NODE_ENV);\n\n  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for\n  // any possible NODE_ENV value that might come up during plugin execution.\n  var isProd = api.cache(() => process.env.NODE_ENV === \"production\");\n\n  // .cache(fn) will perform a linear search though instances to find the matching plugin based\n  // based on previous instantiated plugins. If you want to recreate the plugin and discard the\n  // previous instance whenever something changes, you may use:\n  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === \"production\");\n\n  // Note, we also expose the following more-verbose versions of the above examples:\n  api.cache.forever(); // api.cache(true)\n  api.cache.never();   // api.cache(false)\n  api.cache.using(fn); // api.cache(fn)\n\n  // Return the value that will be cached.\n  return { };\n};`,\n    filepath,\n  );\n}\n"]},"metadata":{},"sourceType":"script"}