{"ast":null,"code":"/**\n * @fileoverview Enforce props alphabetical sorting\n * @author Ilya Volodin, Yannick Croissant\n */\n'use strict';\n\nconst propName = require('jsx-ast-utils/propName');\n\nconst includes = require('array-includes');\n\nconst docsUrl = require('../util/docsUrl');\n\nconst jsxUtil = require('../util/jsx');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nfunction isCallbackPropName(name) {\n  return /^on[A-Z]/.test(name);\n}\n\nfunction isMultilineProp(node) {\n  return node.loc.start.line !== node.loc.end.line;\n}\n\nconst messages = {\n  noUnreservedProps: 'A customized reserved first list must only contain a subset of React reserved props. Remove: {{unreservedWords}}',\n  listIsEmpty: 'A customized reserved first list must not be empty',\n  listReservedPropsFirst: 'Reserved props must be listed before all other props',\n  listCallbacksLast: 'Callbacks must be listed after all other props',\n  listShorthandFirst: 'Shorthand props must be listed before all other props',\n  listShorthandLast: 'Shorthand props must be listed after all other props',\n  listMultilineFirst: 'Multiline props must be listed before all other props',\n  listMultilineLast: 'Multiline props must be listed after all other props',\n  sortPropsByAlpha: 'Props should be sorted alphabetically'\n};\nconst RESERVED_PROPS_LIST = ['children', 'dangerouslySetInnerHTML', 'key', 'ref'];\n\nfunction isReservedPropName(name, list) {\n  return list.indexOf(name) >= 0;\n}\n\nlet attributeMap; // attributeMap = { end: endrange, hasComment: true||false if comment in between nodes exists, it needs to be sorted to end }\n\nfunction shouldSortToEnd(node) {\n  const attr = attributeMap.get(node);\n  return !!attr && !!attr.hasComment;\n}\n\nfunction contextCompare(a, b, options) {\n  let aProp = propName(a);\n  let bProp = propName(b);\n  const aSortToEnd = shouldSortToEnd(a);\n  const bSortToEnd = shouldSortToEnd(b);\n\n  if (aSortToEnd && !bSortToEnd) {\n    return 1;\n  }\n\n  if (!aSortToEnd && bSortToEnd) {\n    return -1;\n  }\n\n  if (options.reservedFirst) {\n    const aIsReserved = isReservedPropName(aProp, options.reservedList);\n    const bIsReserved = isReservedPropName(bProp, options.reservedList);\n\n    if (aIsReserved && !bIsReserved) {\n      return -1;\n    }\n\n    if (!aIsReserved && bIsReserved) {\n      return 1;\n    }\n  }\n\n  if (options.callbacksLast) {\n    const aIsCallback = isCallbackPropName(aProp);\n    const bIsCallback = isCallbackPropName(bProp);\n\n    if (aIsCallback && !bIsCallback) {\n      return 1;\n    }\n\n    if (!aIsCallback && bIsCallback) {\n      return -1;\n    }\n  }\n\n  if (options.shorthandFirst || options.shorthandLast) {\n    const shorthandSign = options.shorthandFirst ? -1 : 1;\n\n    if (!a.value && b.value) {\n      return shorthandSign;\n    }\n\n    if (a.value && !b.value) {\n      return -shorthandSign;\n    }\n  }\n\n  if (options.multiline !== 'ignore') {\n    const multilineSign = options.multiline === 'first' ? -1 : 1;\n    const aIsMultiline = isMultilineProp(a);\n    const bIsMultiline = isMultilineProp(b);\n\n    if (aIsMultiline && !bIsMultiline) {\n      return multilineSign;\n    }\n\n    if (!aIsMultiline && bIsMultiline) {\n      return -multilineSign;\n    }\n  }\n\n  if (options.noSortAlphabetically) {\n    return 0;\n  }\n\n  const actualLocale = options.locale === 'auto' ? undefined : options.locale;\n\n  if (options.ignoreCase) {\n    aProp = aProp.toLowerCase();\n    bProp = bProp.toLowerCase();\n    return aProp.localeCompare(bProp, actualLocale);\n  }\n\n  if (aProp === bProp) {\n    return 0;\n  }\n\n  if (options.locale === 'auto') {\n    return aProp < bProp ? -1 : 1;\n  }\n\n  return aProp.localeCompare(bProp, actualLocale);\n}\n/**\n * Create an array of arrays where each subarray is composed of attributes\n * that are considered sortable.\n * @param {Array<JSXSpreadAttribute|JSXAttribute>} attributes\n * @param {Object} context The context of the rule\n * @return {Array<Array<JSXAttribute>>}\n */\n\n\nfunction getGroupsOfSortableAttributes(attributes, context) {\n  const sourceCode = context.getSourceCode();\n  const sortableAttributeGroups = [];\n  let groupCount = 0;\n\n  function addtoSortableAttributeGroups(attribute) {\n    sortableAttributeGroups[groupCount - 1].push(attribute);\n  }\n\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    const nextAttribute = attributes[i + 1];\n    const attributeline = attribute.loc.start.line;\n    let comment = [];\n\n    try {\n      comment = sourceCode.getCommentsAfter(attribute);\n    } catch (e) {\n      /**/\n    }\n\n    const lastAttr = attributes[i - 1];\n    const attrIsSpread = attribute.type === 'JSXSpreadAttribute'; // If we have no groups or if the last attribute was JSXSpreadAttribute\n    // then we start a new group. Append attributes to the group until we\n    // come across another JSXSpreadAttribute or exhaust the array.\n\n    if (!lastAttr || lastAttr.type === 'JSXSpreadAttribute' && !attrIsSpread) {\n      groupCount += 1;\n      sortableAttributeGroups[groupCount - 1] = [];\n    }\n\n    if (!attrIsSpread) {\n      if (comment.length === 0) {\n        attributeMap.set(attribute, {\n          end: attribute.range[1],\n          hasComment: false\n        });\n        addtoSortableAttributeGroups(attribute);\n      } else {\n        const firstComment = comment[0];\n        const commentline = firstComment.loc.start.line;\n\n        if (comment.length === 1) {\n          if (attributeline + 1 === commentline && nextAttribute) {\n            attributeMap.set(attribute, {\n              end: nextAttribute.range[1],\n              hasComment: true\n            });\n            addtoSortableAttributeGroups(attribute);\n            i += 1;\n          } else if (attributeline === commentline) {\n            if (firstComment.type === 'Block' && nextAttribute) {\n              attributeMap.set(attribute, {\n                end: nextAttribute.range[1],\n                hasComment: true\n              });\n              i += 1;\n            } else if (firstComment.type === 'Block') {\n              attributeMap.set(attribute, {\n                end: firstComment.range[1],\n                hasComment: true\n              });\n            } else {\n              attributeMap.set(attribute, {\n                end: firstComment.range[1],\n                hasComment: false\n              });\n            }\n\n            addtoSortableAttributeGroups(attribute);\n          }\n        } else if (comment.length > 1 && attributeline + 1 === comment[1].loc.start.line && nextAttribute) {\n          const commentNextAttribute = sourceCode.getCommentsAfter(nextAttribute);\n          attributeMap.set(attribute, {\n            end: nextAttribute.range[1],\n            hasComment: true\n          });\n\n          if (commentNextAttribute.length === 1 && nextAttribute.loc.start.line === commentNextAttribute[0].loc.start.line) {\n            attributeMap.set(attribute, {\n              end: commentNextAttribute[0].range[1],\n              hasComment: true\n            });\n          }\n\n          addtoSortableAttributeGroups(attribute);\n          i += 1;\n        }\n      }\n    }\n  }\n\n  return sortableAttributeGroups;\n}\n\nfunction generateFixerFunction(node, context, reservedList) {\n  const sourceCode = context.getSourceCode();\n  const attributes = node.attributes.slice(0);\n  const configuration = context.options[0] || {};\n  const ignoreCase = configuration.ignoreCase || false;\n  const callbacksLast = configuration.callbacksLast || false;\n  const shorthandFirst = configuration.shorthandFirst || false;\n  const shorthandLast = configuration.shorthandLast || false;\n  const multiline = configuration.multiline || 'ignore';\n  const noSortAlphabetically = configuration.noSortAlphabetically || false;\n  const reservedFirst = configuration.reservedFirst || false;\n  const locale = configuration.locale || 'auto'; // Sort props according to the context. Only supports ignoreCase.\n  // Since we cannot safely move JSXSpreadAttribute (due to potential variable overrides),\n  // we only consider groups of sortable attributes.\n\n  const options = {\n    ignoreCase,\n    callbacksLast,\n    shorthandFirst,\n    shorthandLast,\n    multiline,\n    noSortAlphabetically,\n    reservedFirst,\n    reservedList,\n    locale\n  };\n  const sortableAttributeGroups = getGroupsOfSortableAttributes(attributes, context);\n  const sortedAttributeGroups = sortableAttributeGroups.slice(0).map(group => group.slice(0).sort((a, b) => contextCompare(a, b, options)));\n  return function fixFunction(fixer) {\n    const fixers = [];\n    let source = sourceCode.getText();\n    sortableAttributeGroups.forEach((sortableGroup, ii) => {\n      sortableGroup.forEach((attr, jj) => {\n        const sortedAttr = sortedAttributeGroups[ii][jj];\n        const sortedAttrText = source.substring(sortedAttr.range[0], attributeMap.get(sortedAttr).end);\n        fixers.push({\n          range: [attr.range[0], attributeMap.get(attr).end],\n          text: sortedAttrText\n        });\n      });\n    });\n    fixers.sort((a, b) => b.range[0] - a.range[0]);\n    const firstFixer = fixers[0];\n    const lastFixer = fixers[fixers.length - 1];\n    const rangeStart = lastFixer ? lastFixer.range[0] : 0;\n    const rangeEnd = firstFixer ? firstFixer.range[1] : -0;\n    fixers.forEach(fix => {\n      source = `${source.substr(0, fix.range[0])}${fix.text}${source.substr(fix.range[1])}`;\n    });\n    return fixer.replaceTextRange([rangeStart, rangeEnd], source.substr(rangeStart, rangeEnd - rangeStart));\n  };\n}\n/**\n * Checks if the `reservedFirst` option is valid\n * @param {Object} context The context of the rule\n * @param {Boolean|Array<String>} reservedFirst The `reservedFirst` option\n * @return {Function|undefined} If an error is detected, a function to generate the error message, otherwise, `undefined`\n */\n// eslint-disable-next-line consistent-return\n\n\nfunction validateReservedFirstConfig(context, reservedFirst) {\n  if (reservedFirst) {\n    if (Array.isArray(reservedFirst)) {\n      // Only allow a subset of reserved words in customized lists\n      const nonReservedWords = reservedFirst.filter(word => !isReservedPropName(word, RESERVED_PROPS_LIST));\n\n      if (reservedFirst.length === 0) {\n        return function Report(decl) {\n          report(context, messages.listIsEmpty, 'listIsEmpty', {\n            node: decl\n          });\n        };\n      }\n\n      if (nonReservedWords.length > 0) {\n        return function Report(decl) {\n          report(context, messages.noUnreservedProps, 'noUnreservedProps', {\n            node: decl,\n            data: {\n              unreservedWords: nonReservedWords.toString()\n            }\n          });\n        };\n      }\n    }\n  }\n}\n\nconst reportedNodeAttributes = new WeakMap();\n/**\n * Check if the current node attribute has already been reported with the same error type\n * if that's the case then we don't report a new error\n * otherwise we report the error\n * @param {Object} nodeAttribute The node attribute to be reported\n * @param {string} errorType The error type to be reported\n * @param {Object} node The parent node for the node attribute\n * @param {Object} context The context of the rule\n * @param {Array<String>} reservedList The list of reserved props\n */\n\nfunction reportNodeAttribute(nodeAttribute, errorType, node, context, reservedList) {\n  const errors = reportedNodeAttributes.get(nodeAttribute) || [];\n\n  if (includes(errors, errorType)) {\n    return;\n  }\n\n  errors.push(errorType);\n  reportedNodeAttributes.set(nodeAttribute, errors);\n  report(context, messages[errorType], errorType, {\n    node: nodeAttribute.name,\n    fix: generateFixerFunction(node, context, reservedList)\n  });\n}\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce props alphabetical sorting',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-sort-props')\n    },\n    fixable: 'code',\n    messages,\n    schema: [{\n      type: 'object',\n      properties: {\n        // Whether callbacks (prefixed with \"on\") should be listed at the very end,\n        // after all other props. Supersedes shorthandLast.\n        callbacksLast: {\n          type: 'boolean'\n        },\n        // Whether shorthand properties (without a value) should be listed first\n        shorthandFirst: {\n          type: 'boolean'\n        },\n        // Whether shorthand properties (without a value) should be listed last\n        shorthandLast: {\n          type: 'boolean'\n        },\n        // Whether multiline properties should be listed first or last\n        multiline: {\n          enum: ['ignore', 'first', 'last'],\n          default: 'ignore'\n        },\n        ignoreCase: {\n          type: 'boolean'\n        },\n        // Whether alphabetical sorting should be enforced\n        noSortAlphabetically: {\n          type: 'boolean'\n        },\n        reservedFirst: {\n          type: ['array', 'boolean']\n        },\n        locale: {\n          type: 'string',\n          default: 'auto'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {};\n    const ignoreCase = configuration.ignoreCase || false;\n    const callbacksLast = configuration.callbacksLast || false;\n    const shorthandFirst = configuration.shorthandFirst || false;\n    const shorthandLast = configuration.shorthandLast || false;\n    const multiline = configuration.multiline || 'ignore';\n    const noSortAlphabetically = configuration.noSortAlphabetically || false;\n    const reservedFirst = configuration.reservedFirst || false;\n    const reservedFirstError = validateReservedFirstConfig(context, reservedFirst);\n    const reservedList = Array.isArray(reservedFirst) ? reservedFirst : RESERVED_PROPS_LIST;\n    const locale = configuration.locale || 'auto';\n    return {\n      Program() {\n        attributeMap = new WeakMap();\n      },\n\n      JSXOpeningElement(node) {\n        // `dangerouslySetInnerHTML` is only \"reserved\" on DOM components\n        const nodeReservedList = reservedFirst && !jsxUtil.isDOMComponent(node) ? reservedList.filter(prop => prop !== 'dangerouslySetInnerHTML') : reservedList;\n        node.attributes.reduce((memo, decl, idx, attrs) => {\n          if (decl.type === 'JSXSpreadAttribute') {\n            return attrs[idx + 1];\n          }\n\n          let previousPropName = propName(memo);\n          let currentPropName = propName(decl);\n          const previousValue = memo.value;\n          const currentValue = decl.value;\n          const previousIsCallback = isCallbackPropName(previousPropName);\n          const currentIsCallback = isCallbackPropName(currentPropName);\n\n          if (ignoreCase) {\n            previousPropName = previousPropName.toLowerCase();\n            currentPropName = currentPropName.toLowerCase();\n          }\n\n          if (reservedFirst) {\n            if (reservedFirstError) {\n              reservedFirstError(decl);\n              return memo;\n            }\n\n            const previousIsReserved = isReservedPropName(previousPropName, nodeReservedList);\n            const currentIsReserved = isReservedPropName(currentPropName, nodeReservedList);\n\n            if (previousIsReserved && !currentIsReserved) {\n              return decl;\n            }\n\n            if (!previousIsReserved && currentIsReserved) {\n              reportNodeAttribute(decl, 'listReservedPropsFirst', node, context, nodeReservedList);\n              return memo;\n            }\n          }\n\n          if (callbacksLast) {\n            if (!previousIsCallback && currentIsCallback) {\n              // Entering the callback prop section\n              return decl;\n            }\n\n            if (previousIsCallback && !currentIsCallback) {\n              // Encountered a non-callback prop after a callback prop\n              reportNodeAttribute(memo, 'listCallbacksLast', node, context, nodeReservedList);\n              return memo;\n            }\n          }\n\n          if (shorthandFirst) {\n            if (currentValue && !previousValue) {\n              return decl;\n            }\n\n            if (!currentValue && previousValue) {\n              reportNodeAttribute(decl, 'listShorthandFirst', node, context, nodeReservedList);\n              return memo;\n            }\n          }\n\n          if (shorthandLast) {\n            if (!currentValue && previousValue) {\n              return decl;\n            }\n\n            if (currentValue && !previousValue) {\n              reportNodeAttribute(memo, 'listShorthandLast', node, context, nodeReservedList);\n              return memo;\n            }\n          }\n\n          const previousIsMultiline = isMultilineProp(memo);\n          const currentIsMultiline = isMultilineProp(decl);\n\n          if (multiline === 'first') {\n            if (previousIsMultiline && !currentIsMultiline) {\n              // Exiting the multiline prop section\n              return decl;\n            }\n\n            if (!previousIsMultiline && currentIsMultiline) {\n              // Encountered a non-multiline prop before a multiline prop\n              reportNodeAttribute(decl, 'listMultilineFirst', node, context, nodeReservedList);\n              return memo;\n            }\n          } else if (multiline === 'last') {\n            if (!previousIsMultiline && currentIsMultiline) {\n              // Entering the multiline prop section\n              return decl;\n            }\n\n            if (previousIsMultiline && !currentIsMultiline) {\n              // Encountered a non-multiline prop after a multiline prop\n              reportNodeAttribute(memo, 'listMultilineLast', node, context, nodeReservedList);\n              return memo;\n            }\n          }\n\n          if (!noSortAlphabetically && (ignoreCase || locale !== 'auto' ? previousPropName.localeCompare(currentPropName, locale === 'auto' ? undefined : locale) > 0 : previousPropName > currentPropName)) {\n            reportNodeAttribute(decl, 'sortPropsByAlpha', node, context, nodeReservedList);\n            return memo;\n          }\n\n          return decl;\n        }, node.attributes[0]);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["propName","require","includes","docsUrl","jsxUtil","report","isCallbackPropName","name","test","isMultilineProp","node","loc","start","line","end","messages","noUnreservedProps","listIsEmpty","listReservedPropsFirst","listCallbacksLast","listShorthandFirst","listShorthandLast","listMultilineFirst","listMultilineLast","sortPropsByAlpha","RESERVED_PROPS_LIST","isReservedPropName","list","indexOf","attributeMap","shouldSortToEnd","attr","get","hasComment","contextCompare","a","b","options","aProp","bProp","aSortToEnd","bSortToEnd","reservedFirst","aIsReserved","reservedList","bIsReserved","callbacksLast","aIsCallback","bIsCallback","shorthandFirst","shorthandLast","shorthandSign","value","multiline","multilineSign","aIsMultiline","bIsMultiline","noSortAlphabetically","actualLocale","locale","undefined","ignoreCase","toLowerCase","localeCompare","getGroupsOfSortableAttributes","attributes","context","sourceCode","getSourceCode","sortableAttributeGroups","groupCount","addtoSortableAttributeGroups","attribute","push","i","length","nextAttribute","attributeline","comment","getCommentsAfter","e","lastAttr","attrIsSpread","type","set","range","firstComment","commentline","commentNextAttribute","generateFixerFunction","slice","configuration","sortedAttributeGroups","map","group","sort","fixFunction","fixer","fixers","source","getText","forEach","sortableGroup","ii","jj","sortedAttr","sortedAttrText","substring","text","firstFixer","lastFixer","rangeStart","rangeEnd","fix","substr","replaceTextRange","validateReservedFirstConfig","Array","isArray","nonReservedWords","filter","word","Report","decl","data","unreservedWords","toString","reportedNodeAttributes","WeakMap","reportNodeAttribute","nodeAttribute","errorType","errors","module","exports","meta","docs","description","category","recommended","url","fixable","schema","properties","enum","default","additionalProperties","create","reservedFirstError","Program","JSXOpeningElement","nodeReservedList","isDOMComponent","prop","reduce","memo","idx","attrs","previousPropName","currentPropName","previousValue","currentValue","previousIsCallback","currentIsCallback","previousIsReserved","currentIsReserved","previousIsMultiline","currentIsMultiline"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-sort-props.js"],"sourcesContent":["/**\n * @fileoverview Enforce props alphabetical sorting\n * @author Ilya Volodin, Yannick Croissant\n */\n\n'use strict';\n\nconst propName = require('jsx-ast-utils/propName');\nconst includes = require('array-includes');\nconst docsUrl = require('../util/docsUrl');\nconst jsxUtil = require('../util/jsx');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nfunction isCallbackPropName(name) {\n  return /^on[A-Z]/.test(name);\n}\n\nfunction isMultilineProp(node) {\n  return node.loc.start.line !== node.loc.end.line;\n}\n\nconst messages = {\n  noUnreservedProps: 'A customized reserved first list must only contain a subset of React reserved props. Remove: {{unreservedWords}}',\n  listIsEmpty: 'A customized reserved first list must not be empty',\n  listReservedPropsFirst: 'Reserved props must be listed before all other props',\n  listCallbacksLast: 'Callbacks must be listed after all other props',\n  listShorthandFirst: 'Shorthand props must be listed before all other props',\n  listShorthandLast: 'Shorthand props must be listed after all other props',\n  listMultilineFirst: 'Multiline props must be listed before all other props',\n  listMultilineLast: 'Multiline props must be listed after all other props',\n  sortPropsByAlpha: 'Props should be sorted alphabetically',\n};\n\nconst RESERVED_PROPS_LIST = [\n  'children',\n  'dangerouslySetInnerHTML',\n  'key',\n  'ref',\n];\n\nfunction isReservedPropName(name, list) {\n  return list.indexOf(name) >= 0;\n}\n\nlet attributeMap;\n// attributeMap = { end: endrange, hasComment: true||false if comment in between nodes exists, it needs to be sorted to end }\n\nfunction shouldSortToEnd(node) {\n  const attr = attributeMap.get(node);\n  return !!attr && !!attr.hasComment;\n}\n\nfunction contextCompare(a, b, options) {\n  let aProp = propName(a);\n  let bProp = propName(b);\n\n  const aSortToEnd = shouldSortToEnd(a);\n  const bSortToEnd = shouldSortToEnd(b);\n  if (aSortToEnd && !bSortToEnd) {\n    return 1;\n  }\n  if (!aSortToEnd && bSortToEnd) {\n    return -1;\n  }\n\n  if (options.reservedFirst) {\n    const aIsReserved = isReservedPropName(aProp, options.reservedList);\n    const bIsReserved = isReservedPropName(bProp, options.reservedList);\n    if (aIsReserved && !bIsReserved) {\n      return -1;\n    }\n    if (!aIsReserved && bIsReserved) {\n      return 1;\n    }\n  }\n\n  if (options.callbacksLast) {\n    const aIsCallback = isCallbackPropName(aProp);\n    const bIsCallback = isCallbackPropName(bProp);\n    if (aIsCallback && !bIsCallback) {\n      return 1;\n    }\n    if (!aIsCallback && bIsCallback) {\n      return -1;\n    }\n  }\n\n  if (options.shorthandFirst || options.shorthandLast) {\n    const shorthandSign = options.shorthandFirst ? -1 : 1;\n    if (!a.value && b.value) {\n      return shorthandSign;\n    }\n    if (a.value && !b.value) {\n      return -shorthandSign;\n    }\n  }\n\n  if (options.multiline !== 'ignore') {\n    const multilineSign = options.multiline === 'first' ? -1 : 1;\n    const aIsMultiline = isMultilineProp(a);\n    const bIsMultiline = isMultilineProp(b);\n    if (aIsMultiline && !bIsMultiline) {\n      return multilineSign;\n    }\n    if (!aIsMultiline && bIsMultiline) {\n      return -multilineSign;\n    }\n  }\n\n  if (options.noSortAlphabetically) {\n    return 0;\n  }\n\n  const actualLocale = options.locale === 'auto' ? undefined : options.locale;\n\n  if (options.ignoreCase) {\n    aProp = aProp.toLowerCase();\n    bProp = bProp.toLowerCase();\n    return aProp.localeCompare(bProp, actualLocale);\n  }\n  if (aProp === bProp) {\n    return 0;\n  }\n  if (options.locale === 'auto') {\n    return aProp < bProp ? -1 : 1;\n  }\n  return aProp.localeCompare(bProp, actualLocale);\n}\n\n/**\n * Create an array of arrays where each subarray is composed of attributes\n * that are considered sortable.\n * @param {Array<JSXSpreadAttribute|JSXAttribute>} attributes\n * @param {Object} context The context of the rule\n * @return {Array<Array<JSXAttribute>>}\n */\nfunction getGroupsOfSortableAttributes(attributes, context) {\n  const sourceCode = context.getSourceCode();\n\n  const sortableAttributeGroups = [];\n  let groupCount = 0;\n  function addtoSortableAttributeGroups(attribute) {\n    sortableAttributeGroups[groupCount - 1].push(attribute);\n  }\n\n  for (let i = 0; i < attributes.length; i++) {\n    const attribute = attributes[i];\n    const nextAttribute = attributes[i + 1];\n    const attributeline = attribute.loc.start.line;\n    let comment = [];\n    try {\n      comment = sourceCode.getCommentsAfter(attribute);\n    } catch (e) { /**/ }\n    const lastAttr = attributes[i - 1];\n    const attrIsSpread = attribute.type === 'JSXSpreadAttribute';\n\n    // If we have no groups or if the last attribute was JSXSpreadAttribute\n    // then we start a new group. Append attributes to the group until we\n    // come across another JSXSpreadAttribute or exhaust the array.\n    if (\n      !lastAttr\n      || (lastAttr.type === 'JSXSpreadAttribute' && !attrIsSpread)\n    ) {\n      groupCount += 1;\n      sortableAttributeGroups[groupCount - 1] = [];\n    }\n    if (!attrIsSpread) {\n      if (comment.length === 0) {\n        attributeMap.set(attribute, { end: attribute.range[1], hasComment: false });\n        addtoSortableAttributeGroups(attribute);\n      } else {\n        const firstComment = comment[0];\n        const commentline = firstComment.loc.start.line;\n        if (comment.length === 1) {\n          if (attributeline + 1 === commentline && nextAttribute) {\n            attributeMap.set(attribute, { end: nextAttribute.range[1], hasComment: true });\n            addtoSortableAttributeGroups(attribute);\n            i += 1;\n          } else if (attributeline === commentline) {\n            if (firstComment.type === 'Block' && nextAttribute) {\n              attributeMap.set(attribute, { end: nextAttribute.range[1], hasComment: true });\n              i += 1;\n            } else if (firstComment.type === 'Block') {\n              attributeMap.set(attribute, { end: firstComment.range[1], hasComment: true });\n            } else {\n              attributeMap.set(attribute, { end: firstComment.range[1], hasComment: false });\n            }\n            addtoSortableAttributeGroups(attribute);\n          }\n        } else if (comment.length > 1 && attributeline + 1 === comment[1].loc.start.line && nextAttribute) {\n          const commentNextAttribute = sourceCode.getCommentsAfter(nextAttribute);\n          attributeMap.set(attribute, { end: nextAttribute.range[1], hasComment: true });\n          if (\n            commentNextAttribute.length === 1\n            && nextAttribute.loc.start.line === commentNextAttribute[0].loc.start.line\n          ) {\n            attributeMap.set(attribute, { end: commentNextAttribute[0].range[1], hasComment: true });\n          }\n          addtoSortableAttributeGroups(attribute);\n          i += 1;\n        }\n      }\n    }\n  }\n  return sortableAttributeGroups;\n}\n\nfunction generateFixerFunction(node, context, reservedList) {\n  const sourceCode = context.getSourceCode();\n  const attributes = node.attributes.slice(0);\n  const configuration = context.options[0] || {};\n  const ignoreCase = configuration.ignoreCase || false;\n  const callbacksLast = configuration.callbacksLast || false;\n  const shorthandFirst = configuration.shorthandFirst || false;\n  const shorthandLast = configuration.shorthandLast || false;\n  const multiline = configuration.multiline || 'ignore';\n  const noSortAlphabetically = configuration.noSortAlphabetically || false;\n  const reservedFirst = configuration.reservedFirst || false;\n  const locale = configuration.locale || 'auto';\n\n  // Sort props according to the context. Only supports ignoreCase.\n  // Since we cannot safely move JSXSpreadAttribute (due to potential variable overrides),\n  // we only consider groups of sortable attributes.\n  const options = {\n    ignoreCase,\n    callbacksLast,\n    shorthandFirst,\n    shorthandLast,\n    multiline,\n    noSortAlphabetically,\n    reservedFirst,\n    reservedList,\n    locale,\n  };\n  const sortableAttributeGroups = getGroupsOfSortableAttributes(attributes, context);\n  const sortedAttributeGroups = sortableAttributeGroups\n    .slice(0)\n    .map((group) => group.slice(0).sort((a, b) => contextCompare(a, b, options)));\n\n  return function fixFunction(fixer) {\n    const fixers = [];\n    let source = sourceCode.getText();\n\n    sortableAttributeGroups.forEach((sortableGroup, ii) => {\n      sortableGroup.forEach((attr, jj) => {\n        const sortedAttr = sortedAttributeGroups[ii][jj];\n        const sortedAttrText = source.substring(sortedAttr.range[0], attributeMap.get(sortedAttr).end);\n        fixers.push({\n          range: [attr.range[0], attributeMap.get(attr).end],\n          text: sortedAttrText,\n        });\n      });\n    });\n\n    fixers.sort((a, b) => b.range[0] - a.range[0]);\n\n    const firstFixer = fixers[0];\n    const lastFixer = fixers[fixers.length - 1];\n    const rangeStart = lastFixer ? lastFixer.range[0] : 0;\n    const rangeEnd = firstFixer ? firstFixer.range[1] : -0;\n\n    fixers.forEach((fix) => {\n      source = `${source.substr(0, fix.range[0])}${fix.text}${source.substr(fix.range[1])}`;\n    });\n\n    return fixer.replaceTextRange([rangeStart, rangeEnd], source.substr(rangeStart, rangeEnd - rangeStart));\n  };\n}\n\n/**\n * Checks if the `reservedFirst` option is valid\n * @param {Object} context The context of the rule\n * @param {Boolean|Array<String>} reservedFirst The `reservedFirst` option\n * @return {Function|undefined} If an error is detected, a function to generate the error message, otherwise, `undefined`\n */\n// eslint-disable-next-line consistent-return\nfunction validateReservedFirstConfig(context, reservedFirst) {\n  if (reservedFirst) {\n    if (Array.isArray(reservedFirst)) {\n      // Only allow a subset of reserved words in customized lists\n      const nonReservedWords = reservedFirst.filter((word) => !isReservedPropName(\n        word,\n        RESERVED_PROPS_LIST\n      ));\n\n      if (reservedFirst.length === 0) {\n        return function Report(decl) {\n          report(context, messages.listIsEmpty, 'listIsEmpty', {\n            node: decl,\n          });\n        };\n      }\n      if (nonReservedWords.length > 0) {\n        return function Report(decl) {\n          report(context, messages.noUnreservedProps, 'noUnreservedProps', {\n            node: decl,\n            data: {\n              unreservedWords: nonReservedWords.toString(),\n            },\n          });\n        };\n      }\n    }\n  }\n}\n\nconst reportedNodeAttributes = new WeakMap();\n/**\n * Check if the current node attribute has already been reported with the same error type\n * if that's the case then we don't report a new error\n * otherwise we report the error\n * @param {Object} nodeAttribute The node attribute to be reported\n * @param {string} errorType The error type to be reported\n * @param {Object} node The parent node for the node attribute\n * @param {Object} context The context of the rule\n * @param {Array<String>} reservedList The list of reserved props\n */\nfunction reportNodeAttribute(nodeAttribute, errorType, node, context, reservedList) {\n  const errors = reportedNodeAttributes.get(nodeAttribute) || [];\n\n  if (includes(errors, errorType)) {\n    return;\n  }\n\n  errors.push(errorType);\n\n  reportedNodeAttributes.set(nodeAttribute, errors);\n\n  report(context, messages[errorType], errorType, {\n    node: nodeAttribute.name,\n    fix: generateFixerFunction(node, context, reservedList),\n  });\n}\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce props alphabetical sorting',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-sort-props'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [{\n      type: 'object',\n      properties: {\n        // Whether callbacks (prefixed with \"on\") should be listed at the very end,\n        // after all other props. Supersedes shorthandLast.\n        callbacksLast: {\n          type: 'boolean',\n        },\n        // Whether shorthand properties (without a value) should be listed first\n        shorthandFirst: {\n          type: 'boolean',\n        },\n        // Whether shorthand properties (without a value) should be listed last\n        shorthandLast: {\n          type: 'boolean',\n        },\n        // Whether multiline properties should be listed first or last\n        multiline: {\n          enum: ['ignore', 'first', 'last'],\n          default: 'ignore',\n        },\n        ignoreCase: {\n          type: 'boolean',\n        },\n        // Whether alphabetical sorting should be enforced\n        noSortAlphabetically: {\n          type: 'boolean',\n        },\n        reservedFirst: {\n          type: ['array', 'boolean'],\n        },\n        locale: {\n          type: 'string',\n          default: 'auto',\n        },\n      },\n      additionalProperties: false,\n    }],\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {};\n    const ignoreCase = configuration.ignoreCase || false;\n    const callbacksLast = configuration.callbacksLast || false;\n    const shorthandFirst = configuration.shorthandFirst || false;\n    const shorthandLast = configuration.shorthandLast || false;\n    const multiline = configuration.multiline || 'ignore';\n    const noSortAlphabetically = configuration.noSortAlphabetically || false;\n    const reservedFirst = configuration.reservedFirst || false;\n    const reservedFirstError = validateReservedFirstConfig(context, reservedFirst);\n    const reservedList = Array.isArray(reservedFirst) ? reservedFirst : RESERVED_PROPS_LIST;\n    const locale = configuration.locale || 'auto';\n\n    return {\n      Program() {\n        attributeMap = new WeakMap();\n      },\n\n      JSXOpeningElement(node) {\n        // `dangerouslySetInnerHTML` is only \"reserved\" on DOM components\n        const nodeReservedList = reservedFirst && !jsxUtil.isDOMComponent(node) ? reservedList.filter((prop) => prop !== 'dangerouslySetInnerHTML') : reservedList;\n\n        node.attributes.reduce((memo, decl, idx, attrs) => {\n          if (decl.type === 'JSXSpreadAttribute') {\n            return attrs[idx + 1];\n          }\n\n          let previousPropName = propName(memo);\n          let currentPropName = propName(decl);\n          const previousValue = memo.value;\n          const currentValue = decl.value;\n          const previousIsCallback = isCallbackPropName(previousPropName);\n          const currentIsCallback = isCallbackPropName(currentPropName);\n\n          if (ignoreCase) {\n            previousPropName = previousPropName.toLowerCase();\n            currentPropName = currentPropName.toLowerCase();\n          }\n\n          if (reservedFirst) {\n            if (reservedFirstError) {\n              reservedFirstError(decl);\n              return memo;\n            }\n\n            const previousIsReserved = isReservedPropName(previousPropName, nodeReservedList);\n            const currentIsReserved = isReservedPropName(currentPropName, nodeReservedList);\n\n            if (previousIsReserved && !currentIsReserved) {\n              return decl;\n            }\n            if (!previousIsReserved && currentIsReserved) {\n              reportNodeAttribute(decl, 'listReservedPropsFirst', node, context, nodeReservedList);\n\n              return memo;\n            }\n          }\n\n          if (callbacksLast) {\n            if (!previousIsCallback && currentIsCallback) {\n              // Entering the callback prop section\n              return decl;\n            }\n            if (previousIsCallback && !currentIsCallback) {\n              // Encountered a non-callback prop after a callback prop\n              reportNodeAttribute(memo, 'listCallbacksLast', node, context, nodeReservedList);\n\n              return memo;\n            }\n          }\n\n          if (shorthandFirst) {\n            if (currentValue && !previousValue) {\n              return decl;\n            }\n            if (!currentValue && previousValue) {\n              reportNodeAttribute(decl, 'listShorthandFirst', node, context, nodeReservedList);\n\n              return memo;\n            }\n          }\n\n          if (shorthandLast) {\n            if (!currentValue && previousValue) {\n              return decl;\n            }\n            if (currentValue && !previousValue) {\n              reportNodeAttribute(memo, 'listShorthandLast', node, context, nodeReservedList);\n\n              return memo;\n            }\n          }\n\n          const previousIsMultiline = isMultilineProp(memo);\n          const currentIsMultiline = isMultilineProp(decl);\n          if (multiline === 'first') {\n            if (previousIsMultiline && !currentIsMultiline) {\n              // Exiting the multiline prop section\n              return decl;\n            }\n            if (!previousIsMultiline && currentIsMultiline) {\n              // Encountered a non-multiline prop before a multiline prop\n              reportNodeAttribute(decl, 'listMultilineFirst', node, context, nodeReservedList);\n\n              return memo;\n            }\n          } else if (multiline === 'last') {\n            if (!previousIsMultiline && currentIsMultiline) {\n              // Entering the multiline prop section\n              return decl;\n            }\n            if (previousIsMultiline && !currentIsMultiline) {\n              // Encountered a non-multiline prop after a multiline prop\n              reportNodeAttribute(memo, 'listMultilineLast', node, context, nodeReservedList);\n\n              return memo;\n            }\n          }\n\n          if (\n            !noSortAlphabetically\n            && (\n              (ignoreCase || locale !== 'auto')\n                ? previousPropName.localeCompare(currentPropName, locale === 'auto' ? undefined : locale) > 0\n                : previousPropName > currentPropName\n            )\n          ) {\n            reportNodeAttribute(decl, 'sortPropsByAlpha', node, context, nodeReservedList);\n\n            return memo;\n          }\n\n          return decl;\n        }, node.attributes[0]);\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}