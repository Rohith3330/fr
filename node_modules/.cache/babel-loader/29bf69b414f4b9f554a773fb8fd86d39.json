{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { util } from '@tensorflow/tfjs-core';\nfunction validateIndices(indices, indicesShape, numParams) {\n  indices.forEach(function (index, i) {\n    if (index < 0 || index >= numParams) {\n      var locString = util.indexToLoc(i, indicesShape.length, util.computeStrides(indicesShape)).join(',');\n      throw new Error(\"indices[\".concat(locString, \"] = \").concat(index, \" is not in [0, \").concat(numParams, \")\"));\n    }\n  });\n}\nfunction validateSplits(paramsNestedSplits, numParamsDenseValues) {\n  // Validate\n  for (var dim = 0; dim < paramsNestedSplits.length; ++dim) {\n    var splits = paramsNestedSplits[dim];\n    var lastSplit = dim === paramsNestedSplits.length - 1 ? numParamsDenseValues : paramsNestedSplits[dim + 1].length;\n    if (splits.length === 0) {\n      throw new Error('Ragged splits may not be empty');\n    }\n    if (splits[0] < 0) {\n      throw new Error('Ragged splits must be non-negative');\n    }\n    if (splits[splits.length - 1] > lastSplit) {\n      throw new Error('Ragged splits must not point past values');\n    }\n    for (var i = 1; i < splits.length; ++i) {\n      if (splits[i - 1] > splits[i]) {\n        throw new Error('Ragged splits must be sorted in ascending order');\n      }\n    }\n  }\n}\n// Construct the `splits` output tensors, encoded using a nested vector.\n// Also find the slices of values that need to be copied, and store them\n// in `valueSlices`.  The total number of values that will be copied (which\n// we need for allocating the output values tensor) is stored in `numValues`.\nfunction makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues) {\n  var valueSlices = [];\n  var numValues = 0;\n  var numSplits = indicesShape.length - 1 + paramsNestedSplits.length;\n  var outSplits = new Array(numSplits).fill(null).map(function () {\n    return [0];\n  });\n  validateSplits(paramsNestedSplits, numParamsDenseValues);\n  // Add `splits` that come from all but the last dimension of the dense\n  // Tensor `indices`.  In particular, for each dimension D, we add a\n  // splits tensor whose values are:\n  //   range(reduceProd(splits.shape[:D]) + 1) * splits.shape[D+1]\n  // E.g., if indices.shape=[2, 3, 4] then we will add splits tensors:\n  //   [0, 3, 6]                    # length=2+1, stride=3\n  //   [0, 4, 8, 12, 16, 20, 24]    # length=2*3+1, stride=4\n  var nrows = 1;\n  for (var dim = 0; dim < indicesShape.length - 1; ++dim) {\n    nrows *= indicesShape[dim];\n    var rowLength = indicesShape[dim + 1];\n    for (var i = 1; i < nrows + 1; ++i) {\n      outSplits[dim].push(i * rowLength);\n    }\n  }\n  // Add `splits` that come from `paramsNestedSplits`.  Starting with the\n  // outermost ragged dimension (i.e., the first `splits` tensor), we work\n  // our way in, finding the range of values that should be copied.  As we\n  // go, we update the output `splits` for each dimension with the appropriate\n  // values.  In particular, the *lengths* of the slices from `param_splits`\n  // should be copied to generate corresponding slice lengths in the output\n  // splits.  E.g., if we are copying a ragged row with length 4, then we\n  // should add a new split point to outSplits that is 4 greater than the\n  // previous split point in outSplits.\n  for (var _i = 0; _i < indices.length; ++_i) {\n    var start = indices[_i];\n    var limit = indices[_i] + 1;\n    // Copy splits.\n    for (var _dim = 0; _dim < paramsNestedSplits.length; ++_dim) {\n      var splits = paramsNestedSplits[_dim];\n      var outDim = _dim + indicesShape.length - 1;\n      if (outDim >= 0) {\n        var outSplitsOutDim = outSplits[outDim];\n        var delta = outSplitsOutDim[outSplitsOutDim.length - 1] - splits[start];\n        for (var j = start; j < limit; ++j) {\n          outSplits[outDim].push(splits[j + 1] + delta);\n        }\n      }\n      start = splits[start];\n      limit = splits[limit];\n    }\n    if (limit !== start) {\n      valueSlices.push([start, limit]);\n      numValues += limit - start;\n    }\n  }\n  return {\n    outSplits: outSplits,\n    valueSlices: valueSlices,\n    numValues: numValues\n  };\n}\nfunction getSplits(outSplits) {\n  var splitsOut = [];\n  var _loop = function _loop(i) {\n    var numSplits = outSplits[i].length;\n    var splits = util.getArrayFromDType('int32', numSplits);\n    splitsOut.push(splits);\n    outSplits[i].forEach(function (value, j) {\n      return splits[j] = value;\n    });\n  };\n  for (var i = 0; i < outSplits.length; ++i) {\n    _loop(i);\n  }\n  return splitsOut;\n}\nfunction computeFlatOuterDims(orig, numOutDims) {\n  var outDims = orig.slice(0, numOutDims);\n  while (outDims.length < numOutDims) {\n    outDims.push(1);\n  }\n  for (var inDim = numOutDims; inDim < orig.length; inDim++) {\n    outDims[numOutDims - 1] *= orig[inDim];\n  }\n  return outDims;\n}\n// For each slice in `(start, limit)` in `valueSlices`, append\n// `paramsDenseValues[start,...,limit] to `values`.  `valueSize` indicates\n// the number of scalars contained in each value paramsDenseValues[i].\nfunction writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, values, valuesShape) {\n  var denseM = computeFlatOuterDims(paramsDenseValuesShape, 2)[1];\n  var valuesM = computeFlatOuterDims(valuesShape, 2)[1];\n  var outPos = 0;\n  var _iterator = _createForOfIteratorHelper(valueSlices),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var slice = _step.value;\n      for (var i = slice[0]; i < slice[1]; ++i) {\n        for (var j = 0; j < valueSize; ++j) {\n          values[outPos * valuesM + j] = paramsDenseValues[i * denseM + j];\n        }\n        ++outPos;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues) {\n  var valuesShape = paramsDenseValuesShape.slice();\n  valuesShape[0] = numValues;\n  var valuesOut = util.getArrayFromDType(paramsDenseValuesDType, util.sizeFromShape(valuesShape));\n  var numElements = paramsDenseValues.length;\n  var valueSize = numElements === 0 ? 0 : numElements / paramsDenseValuesShape[0];\n  writeValueSlices(paramsDenseValues, paramsDenseValuesShape, valueSlices, valueSize, valuesOut, valuesShape);\n  return [valuesOut, valuesShape];\n}\nexport function raggedGatherImpl(paramsNestedSplits, paramsNestedSplitsShapes, paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, indices, indicesShape, outputRaggedRank) {\n  if (paramsNestedSplits.length === 0) {\n    throw new Error('paramsNestedSplits must be non empty');\n  }\n  if (paramsNestedSplitsShapes[0].length === 0) {\n    throw new Error('Split tensors must not be scalars');\n  }\n  var numParams = paramsNestedSplitsShapes[0][0] - 1;\n  validateIndices(indices, indicesShape, numParams);\n  if (paramsDenseValuesShape.length === 0) {\n    throw new Error('params.rank must be nonzero');\n  }\n  var numParamsDenseValues = paramsDenseValuesShape[0];\n  // Calculate the `splits`, and store the value slices that we need to\n  // copy in `valueSlices`.\n  var _makeSplits = makeSplits(indices, indicesShape, paramsNestedSplits, numParamsDenseValues),\n    outSplits = _makeSplits.outSplits,\n    valueSlices = _makeSplits.valueSlices,\n    numValues = _makeSplits.numValues; // Write the output tensors.\n  var outputNestedSplits = getSplits(outSplits);\n  var outputDenseValues = getValues(paramsDenseValues, paramsDenseValuesShape, paramsDenseValuesDType, valueSlices, numValues);\n  return [outputNestedSplits, outputDenseValues[0], outputDenseValues[1]];\n}","map":null,"metadata":{},"sourceType":"module"}