{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../lib/types').Specificity} Specificity\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n */\n\nconst csstree = require('css-tree'); // @ts-ignore not defined in @types/csso\n\n\nconst specificity = require('csso/lib/restructure/prepare/specificity');\n\nconst stable = require('stable');\n\nconst {\n  visitSkip,\n  querySelectorAll,\n  detachNodeFromParent\n} = require('../lib/xast.js');\n\nexports.type = 'visitor';\nexports.name = 'inlineStyles';\nexports.active = true;\nexports.description = 'inline styles (additional options)';\n/**\n * Compares two selector specificities.\n * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211\n *\n * @type {(a: Specificity, b: Specificity) => number}\n */\n\nconst compareSpecificity = (a, b) => {\n  for (var i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n\n  return 0;\n};\n/**\n * Moves + merges styles from style elements to element styles\n *\n * Options\n *   onlyMatchedOnce (default: true)\n *     inline only selectors that match once\n *\n *   removeMatchedSelectors (default: true)\n *     clean up matched selectors,\n *     leave selectors that hadn't matched\n *\n *   useMqs (default: ['', 'screen'])\n *     what media queries to be used\n *     empty string element for styles outside media queries\n *\n *   usePseudos (default: [''])\n *     what pseudo-classes/-elements to be used\n *     empty string element for all non-pseudo-classes and/or -elements\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('../lib/types').Plugin<{\n *   onlyMatchedOnce?: boolean,\n *   removeMatchedSelectors?: boolean,\n *   useMqs?: Array<string>,\n *   usePseudos?: Array<string>\n * }>}\n */\n\n\nexports.fn = (root, params) => {\n  const {\n    onlyMatchedOnce = true,\n    removeMatchedSelectors = true,\n    useMqs = ['', 'screen'],\n    usePseudos = ['']\n  } = params;\n  /**\n   * @type {Array<{ node: XastElement, parentNode: XastParent, cssAst: csstree.StyleSheet }>}\n   */\n\n  const styles = [];\n  /**\n   * @type {Array<{\n   *   node: csstree.Selector,\n   *   item: csstree.ListItem<csstree.CssNode>,\n   *   rule: csstree.Rule,\n   *   matchedElements?: Array<XastElement>\n   * }>}\n   */\n\n  let selectors = [];\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip <foreignObject /> content\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        } // collect only non-empty <style /> elements\n\n\n        if (node.name !== 'style' || node.children.length === 0) {\n          return;\n        } // values other than the empty string or text/css are not used\n\n\n        if (node.attributes.type != null && node.attributes.type !== '' && node.attributes.type !== 'text/css') {\n          return;\n        } // parse css in style element\n\n\n        let cssText = '';\n\n        for (const child of node.children) {\n          if (child.type === 'text' || child.type === 'cdata') {\n            cssText += child.value;\n          }\n        }\n        /**\n         * @type {null | csstree.CssNode}\n         */\n\n\n        let cssAst = null;\n\n        try {\n          cssAst = csstree.parse(cssText, {\n            parseValue: false,\n            parseCustomProperty: false\n          });\n        } catch {\n          return;\n        }\n\n        if (cssAst.type === 'StyleSheet') {\n          styles.push({\n            node,\n            parentNode,\n            cssAst\n          });\n        } // collect selectors\n\n\n        csstree.walk(cssAst, {\n          visit: 'Selector',\n\n          enter(node, item) {\n            const atrule = this.atrule;\n            const rule = this.rule;\n\n            if (rule == null) {\n              return;\n            } // skip media queries not included into useMqs param\n\n\n            let mq = '';\n\n            if (atrule != null) {\n              mq = atrule.name;\n\n              if (atrule.prelude != null) {\n                mq += ` ${csstree.generate(atrule.prelude)}`;\n              }\n            }\n\n            if (useMqs.includes(mq) === false) {\n              return;\n            }\n            /**\n             * @type {Array<{\n             *   item: csstree.ListItem<csstree.CssNode>,\n             *   list: csstree.List<csstree.CssNode>\n             * }>}\n             */\n\n\n            const pseudos = [];\n\n            if (node.type === 'Selector') {\n              node.children.each((childNode, childItem, childList) => {\n                if (childNode.type === 'PseudoClassSelector' || childNode.type === 'PseudoElementSelector') {\n                  pseudos.push({\n                    item: childItem,\n                    list: childList\n                  });\n                }\n              });\n            } // skip pseudo classes and pseudo elements not includes into usePseudos param\n\n\n            const pseudoSelectors = csstree.generate({\n              type: 'Selector',\n              children: new csstree.List().fromArray(pseudos.map(pseudo => pseudo.item.data))\n            });\n\n            if (usePseudos.includes(pseudoSelectors) === false) {\n              return;\n            } // remove pseudo classes and elements to allow querySelector match elements\n            // TODO this is not very accurate since some pseudo classes like first-child\n            // are used for selection\n\n\n            for (const pseudo of pseudos) {\n              pseudo.list.remove(pseudo.item);\n            }\n\n            selectors.push({\n              node,\n              item,\n              rule\n            });\n          }\n\n        });\n      }\n    },\n    root: {\n      exit: () => {\n        if (styles.length === 0) {\n          return;\n        } // stable sort selectors\n\n\n        const sortedSelectors = stable(selectors, (a, b) => {\n          const aSpecificity = specificity(a.item.data);\n          const bSpecificity = specificity(b.item.data);\n          return compareSpecificity(aSpecificity, bSpecificity);\n        }).reverse();\n\n        for (const selector of sortedSelectors) {\n          // match selectors\n          const selectorText = csstree.generate(selector.item.data);\n          /**\n           * @type {Array<XastElement>}\n           */\n\n          const matchedElements = [];\n\n          try {\n            for (const node of querySelectorAll(root, selectorText)) {\n              if (node.type === 'element') {\n                matchedElements.push(node);\n              }\n            }\n          } catch (selectError) {\n            continue;\n          } // nothing selected\n\n\n          if (matchedElements.length === 0) {\n            continue;\n          } // apply styles to matched elements\n          // skip selectors that match more than once if option onlyMatchedOnce is enabled\n\n\n          if (onlyMatchedOnce && matchedElements.length > 1) {\n            continue;\n          } // apply <style/> to matched elements\n\n\n          for (const selectedEl of matchedElements) {\n            const styleDeclarationList = csstree.parse(selectedEl.attributes.style == null ? '' : selectedEl.attributes.style, {\n              context: 'declarationList',\n              parseValue: false\n            });\n\n            if (styleDeclarationList.type !== 'DeclarationList') {\n              continue;\n            }\n\n            const styleDeclarationItems = new Map();\n            csstree.walk(styleDeclarationList, {\n              visit: 'Declaration',\n\n              enter(node, item) {\n                styleDeclarationItems.set(node.property, item);\n              }\n\n            }); // merge declarations\n\n            csstree.walk(selector.rule, {\n              visit: 'Declaration',\n\n              enter(ruleDeclaration) {\n                // existing inline styles have higher priority\n                // no inline styles, external styles,                                    external styles used\n                // inline styles,    external styles same   priority as inline styles,   inline   styles used\n                // inline styles,    external styles higher priority than inline styles, external styles used\n                const matchedItem = styleDeclarationItems.get(ruleDeclaration.property);\n                const ruleDeclarationItem = styleDeclarationList.children.createItem(ruleDeclaration);\n\n                if (matchedItem == null) {\n                  styleDeclarationList.children.append(ruleDeclarationItem);\n                } else if (matchedItem.data.important !== true && ruleDeclaration.important === true) {\n                  styleDeclarationList.children.replace(matchedItem, ruleDeclarationItem);\n                  styleDeclarationItems.set(ruleDeclaration.property, ruleDeclarationItem);\n                }\n              }\n\n            });\n            selectedEl.attributes.style = csstree.generate(styleDeclarationList);\n          }\n\n          if (removeMatchedSelectors && matchedElements.length !== 0 && selector.rule.prelude.type === 'SelectorList') {\n            // clean up matching simple selectors if option removeMatchedSelectors is enabled\n            selector.rule.prelude.children.remove(selector.item);\n          }\n\n          selector.matchedElements = matchedElements;\n        } // no further processing required\n\n\n        if (removeMatchedSelectors === false) {\n          return;\n        } // clean up matched class + ID attribute values\n\n\n        for (const selector of sortedSelectors) {\n          if (selector.matchedElements == null) {\n            continue;\n          }\n\n          if (onlyMatchedOnce && selector.matchedElements.length > 1) {\n            // skip selectors that match more than once if option onlyMatchedOnce is enabled\n            continue;\n          }\n\n          for (const selectedEl of selector.matchedElements) {\n            // class\n            const classList = new Set(selectedEl.attributes.class == null ? null : selectedEl.attributes.class.split(' '));\n            const firstSubSelector = selector.node.children.first();\n\n            if (firstSubSelector != null && firstSubSelector.type === 'ClassSelector') {\n              classList.delete(firstSubSelector.name);\n            }\n\n            if (classList.size === 0) {\n              delete selectedEl.attributes.class;\n            } else {\n              selectedEl.attributes.class = Array.from(classList).join(' ');\n            } // ID\n\n\n            if (firstSubSelector != null && firstSubSelector.type === 'IdSelector') {\n              if (selectedEl.attributes.id === firstSubSelector.name) {\n                delete selectedEl.attributes.id;\n              }\n            }\n          }\n        }\n\n        for (const style of styles) {\n          csstree.walk(style.cssAst, {\n            visit: 'Rule',\n            enter: function (node, item, list) {\n              // clean up <style/> rulesets without any css selectors left\n              if (node.type === 'Rule' && node.prelude.type === 'SelectorList' && node.prelude.children.isEmpty()) {\n                list.remove(item);\n              }\n            }\n          });\n\n          if (style.cssAst.children.isEmpty()) {\n            // remove emtpy style element\n            detachNodeFromParent(style.node, style.parentNode);\n          } else {\n            // update style element if any styles left\n            const firstChild = style.node.children[0];\n\n            if (firstChild.type === 'text' || firstChild.type === 'cdata') {\n              firstChild.value = csstree.generate(style.cssAst);\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["csstree","require","specificity","stable","visitSkip","querySelectorAll","detachNodeFromParent","exports","type","name","active","description","compareSpecificity","a","b","i","fn","root","params","onlyMatchedOnce","removeMatchedSelectors","useMqs","usePseudos","styles","selectors","element","enter","node","parentNode","children","length","attributes","cssText","child","value","cssAst","parse","parseValue","parseCustomProperty","push","walk","visit","item","atrule","rule","mq","prelude","generate","includes","pseudos","each","childNode","childItem","childList","list","pseudoSelectors","List","fromArray","map","pseudo","data","remove","exit","sortedSelectors","aSpecificity","bSpecificity","reverse","selector","selectorText","matchedElements","selectError","selectedEl","styleDeclarationList","style","context","styleDeclarationItems","Map","set","property","ruleDeclaration","matchedItem","get","ruleDeclarationItem","createItem","append","important","replace","classList","Set","class","split","firstSubSelector","first","delete","size","Array","from","join","id","isEmpty","firstChild"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/svgo/plugins/inlineStyles.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').Specificity} Specificity\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n */\n\nconst csstree = require('css-tree');\n// @ts-ignore not defined in @types/csso\nconst specificity = require('csso/lib/restructure/prepare/specificity');\nconst stable = require('stable');\nconst {\n  visitSkip,\n  querySelectorAll,\n  detachNodeFromParent,\n} = require('../lib/xast.js');\n\nexports.type = 'visitor';\nexports.name = 'inlineStyles';\nexports.active = true;\nexports.description = 'inline styles (additional options)';\n\n/**\n * Compares two selector specificities.\n * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211\n *\n * @type {(a: Specificity, b: Specificity) => number}\n */\nconst compareSpecificity = (a, b) => {\n  for (var i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n  return 0;\n};\n\n/**\n * Moves + merges styles from style elements to element styles\n *\n * Options\n *   onlyMatchedOnce (default: true)\n *     inline only selectors that match once\n *\n *   removeMatchedSelectors (default: true)\n *     clean up matched selectors,\n *     leave selectors that hadn't matched\n *\n *   useMqs (default: ['', 'screen'])\n *     what media queries to be used\n *     empty string element for styles outside media queries\n *\n *   usePseudos (default: [''])\n *     what pseudo-classes/-elements to be used\n *     empty string element for all non-pseudo-classes and/or -elements\n *\n * @author strarsis <strarsis@gmail.com>\n *\n * @type {import('../lib/types').Plugin<{\n *   onlyMatchedOnce?: boolean,\n *   removeMatchedSelectors?: boolean,\n *   useMqs?: Array<string>,\n *   usePseudos?: Array<string>\n * }>}\n */\nexports.fn = (root, params) => {\n  const {\n    onlyMatchedOnce = true,\n    removeMatchedSelectors = true,\n    useMqs = ['', 'screen'],\n    usePseudos = [''],\n  } = params;\n\n  /**\n   * @type {Array<{ node: XastElement, parentNode: XastParent, cssAst: csstree.StyleSheet }>}\n   */\n  const styles = [];\n  /**\n   * @type {Array<{\n   *   node: csstree.Selector,\n   *   item: csstree.ListItem<csstree.CssNode>,\n   *   rule: csstree.Rule,\n   *   matchedElements?: Array<XastElement>\n   * }>}\n   */\n  let selectors = [];\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // skip <foreignObject /> content\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        }\n        // collect only non-empty <style /> elements\n        if (node.name !== 'style' || node.children.length === 0) {\n          return;\n        }\n        // values other than the empty string or text/css are not used\n        if (\n          node.attributes.type != null &&\n          node.attributes.type !== '' &&\n          node.attributes.type !== 'text/css'\n        ) {\n          return;\n        }\n        // parse css in style element\n        let cssText = '';\n        for (const child of node.children) {\n          if (child.type === 'text' || child.type === 'cdata') {\n            cssText += child.value;\n          }\n        }\n        /**\n         * @type {null | csstree.CssNode}\n         */\n        let cssAst = null;\n        try {\n          cssAst = csstree.parse(cssText, {\n            parseValue: false,\n            parseCustomProperty: false,\n          });\n        } catch {\n          return;\n        }\n        if (cssAst.type === 'StyleSheet') {\n          styles.push({ node, parentNode, cssAst });\n        }\n\n        // collect selectors\n        csstree.walk(cssAst, {\n          visit: 'Selector',\n          enter(node, item) {\n            const atrule = this.atrule;\n            const rule = this.rule;\n            if (rule == null) {\n              return;\n            }\n\n            // skip media queries not included into useMqs param\n            let mq = '';\n            if (atrule != null) {\n              mq = atrule.name;\n              if (atrule.prelude != null) {\n                mq += ` ${csstree.generate(atrule.prelude)}`;\n              }\n            }\n            if (useMqs.includes(mq) === false) {\n              return;\n            }\n\n            /**\n             * @type {Array<{\n             *   item: csstree.ListItem<csstree.CssNode>,\n             *   list: csstree.List<csstree.CssNode>\n             * }>}\n             */\n            const pseudos = [];\n            if (node.type === 'Selector') {\n              node.children.each((childNode, childItem, childList) => {\n                if (\n                  childNode.type === 'PseudoClassSelector' ||\n                  childNode.type === 'PseudoElementSelector'\n                ) {\n                  pseudos.push({ item: childItem, list: childList });\n                }\n              });\n            }\n\n            // skip pseudo classes and pseudo elements not includes into usePseudos param\n            const pseudoSelectors = csstree.generate({\n              type: 'Selector',\n              children: new csstree.List().fromArray(\n                pseudos.map((pseudo) => pseudo.item.data)\n              ),\n            });\n            if (usePseudos.includes(pseudoSelectors) === false) {\n              return;\n            }\n\n            // remove pseudo classes and elements to allow querySelector match elements\n            // TODO this is not very accurate since some pseudo classes like first-child\n            // are used for selection\n            for (const pseudo of pseudos) {\n              pseudo.list.remove(pseudo.item);\n            }\n\n            selectors.push({ node, item, rule });\n          },\n        });\n      },\n    },\n\n    root: {\n      exit: () => {\n        if (styles.length === 0) {\n          return;\n        }\n        // stable sort selectors\n        const sortedSelectors = stable(selectors, (a, b) => {\n          const aSpecificity = specificity(a.item.data);\n          const bSpecificity = specificity(b.item.data);\n          return compareSpecificity(aSpecificity, bSpecificity);\n        }).reverse();\n\n        for (const selector of sortedSelectors) {\n          // match selectors\n          const selectorText = csstree.generate(selector.item.data);\n          /**\n           * @type {Array<XastElement>}\n           */\n          const matchedElements = [];\n          try {\n            for (const node of querySelectorAll(root, selectorText)) {\n              if (node.type === 'element') {\n                matchedElements.push(node);\n              }\n            }\n          } catch (selectError) {\n            continue;\n          }\n          // nothing selected\n          if (matchedElements.length === 0) {\n            continue;\n          }\n\n          // apply styles to matched elements\n          // skip selectors that match more than once if option onlyMatchedOnce is enabled\n          if (onlyMatchedOnce && matchedElements.length > 1) {\n            continue;\n          }\n\n          // apply <style/> to matched elements\n          for (const selectedEl of matchedElements) {\n            const styleDeclarationList = csstree.parse(\n              selectedEl.attributes.style == null\n                ? ''\n                : selectedEl.attributes.style,\n              {\n                context: 'declarationList',\n                parseValue: false,\n              }\n            );\n            if (styleDeclarationList.type !== 'DeclarationList') {\n              continue;\n            }\n            const styleDeclarationItems = new Map();\n            csstree.walk(styleDeclarationList, {\n              visit: 'Declaration',\n              enter(node, item) {\n                styleDeclarationItems.set(node.property, item);\n              },\n            });\n            // merge declarations\n            csstree.walk(selector.rule, {\n              visit: 'Declaration',\n              enter(ruleDeclaration) {\n                // existing inline styles have higher priority\n                // no inline styles, external styles,                                    external styles used\n                // inline styles,    external styles same   priority as inline styles,   inline   styles used\n                // inline styles,    external styles higher priority than inline styles, external styles used\n                const matchedItem = styleDeclarationItems.get(\n                  ruleDeclaration.property\n                );\n                const ruleDeclarationItem =\n                  styleDeclarationList.children.createItem(ruleDeclaration);\n                if (matchedItem == null) {\n                  styleDeclarationList.children.append(ruleDeclarationItem);\n                } else if (\n                  matchedItem.data.important !== true &&\n                  ruleDeclaration.important === true\n                ) {\n                  styleDeclarationList.children.replace(\n                    matchedItem,\n                    ruleDeclarationItem\n                  );\n                  styleDeclarationItems.set(\n                    ruleDeclaration.property,\n                    ruleDeclarationItem\n                  );\n                }\n              },\n            });\n            selectedEl.attributes.style =\n              csstree.generate(styleDeclarationList);\n          }\n\n          if (\n            removeMatchedSelectors &&\n            matchedElements.length !== 0 &&\n            selector.rule.prelude.type === 'SelectorList'\n          ) {\n            // clean up matching simple selectors if option removeMatchedSelectors is enabled\n            selector.rule.prelude.children.remove(selector.item);\n          }\n          selector.matchedElements = matchedElements;\n        }\n\n        // no further processing required\n        if (removeMatchedSelectors === false) {\n          return;\n        }\n\n        // clean up matched class + ID attribute values\n        for (const selector of sortedSelectors) {\n          if (selector.matchedElements == null) {\n            continue;\n          }\n\n          if (onlyMatchedOnce && selector.matchedElements.length > 1) {\n            // skip selectors that match more than once if option onlyMatchedOnce is enabled\n            continue;\n          }\n\n          for (const selectedEl of selector.matchedElements) {\n            // class\n            const classList = new Set(\n              selectedEl.attributes.class == null\n                ? null\n                : selectedEl.attributes.class.split(' ')\n            );\n            const firstSubSelector = selector.node.children.first();\n            if (\n              firstSubSelector != null &&\n              firstSubSelector.type === 'ClassSelector'\n            ) {\n              classList.delete(firstSubSelector.name);\n            }\n            if (classList.size === 0) {\n              delete selectedEl.attributes.class;\n            } else {\n              selectedEl.attributes.class = Array.from(classList).join(' ');\n            }\n\n            // ID\n            if (\n              firstSubSelector != null &&\n              firstSubSelector.type === 'IdSelector'\n            ) {\n              if (selectedEl.attributes.id === firstSubSelector.name) {\n                delete selectedEl.attributes.id;\n              }\n            }\n          }\n        }\n\n        for (const style of styles) {\n          csstree.walk(style.cssAst, {\n            visit: 'Rule',\n            enter: function (node, item, list) {\n              // clean up <style/> rulesets without any css selectors left\n              if (\n                node.type === 'Rule' &&\n                node.prelude.type === 'SelectorList' &&\n                node.prelude.children.isEmpty()\n              ) {\n                list.remove(item);\n              }\n            },\n          });\n\n          if (style.cssAst.children.isEmpty()) {\n            // remove emtpy style element\n            detachNodeFromParent(style.node, style.parentNode);\n          } else {\n            // update style element if any styles left\n            const firstChild = style.node.children[0];\n            if (firstChild.type === 'text' || firstChild.type === 'cdata') {\n              firstChild.value = csstree.generate(style.cssAst);\n            }\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB,C,CACA;;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,0CAAD,CAA3B;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAM;EACJG,SADI;EAEJC,gBAFI;EAGJC;AAHI,IAIFL,OAAO,CAAC,gBAAD,CAJX;;AAMAM,OAAO,CAACC,IAAR,GAAe,SAAf;AACAD,OAAO,CAACE,IAAR,GAAe,cAAf;AACAF,OAAO,CAACG,MAAR,GAAiB,IAAjB;AACAH,OAAO,CAACI,WAAR,GAAsB,oCAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,kBAAkB,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAU;EACnC,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,IAAI,CAA5B,EAA+B;IAC7B,IAAIF,CAAC,CAACE,CAAD,CAAD,GAAOD,CAAC,CAACC,CAAD,CAAZ,EAAiB;MACf,OAAO,CAAC,CAAR;IACD,CAFD,MAEO,IAAIF,CAAC,CAACE,CAAD,CAAD,GAAOD,CAAC,CAACC,CAAD,CAAZ,EAAiB;MACtB,OAAO,CAAP;IACD;EACF;;EACD,OAAO,CAAP;AACD,CATD;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAR,OAAO,CAACS,EAAR,GAAa,CAACC,IAAD,EAAOC,MAAP,KAAkB;EAC7B,MAAM;IACJC,eAAe,GAAG,IADd;IAEJC,sBAAsB,GAAG,IAFrB;IAGJC,MAAM,GAAG,CAAC,EAAD,EAAK,QAAL,CAHL;IAIJC,UAAU,GAAG,CAAC,EAAD;EAJT,IAKFJ,MALJ;EAOA;AACF;AACA;;EACE,MAAMK,MAAM,GAAG,EAAf;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,IAAIC,SAAS,GAAG,EAAhB;EAEA,OAAO;IACLC,OAAO,EAAE;MACPC,KAAK,EAAE,CAACC,IAAD,EAAOC,UAAP,KAAsB;QAC3B;QACA,IAAID,IAAI,CAAClB,IAAL,KAAc,eAAlB,EAAmC;UACjC,OAAOL,SAAP;QACD,CAJ0B,CAK3B;;;QACA,IAAIuB,IAAI,CAAClB,IAAL,KAAc,OAAd,IAAyBkB,IAAI,CAACE,QAAL,CAAcC,MAAd,KAAyB,CAAtD,EAAyD;UACvD;QACD,CAR0B,CAS3B;;;QACA,IACEH,IAAI,CAACI,UAAL,CAAgBvB,IAAhB,IAAwB,IAAxB,IACAmB,IAAI,CAACI,UAAL,CAAgBvB,IAAhB,KAAyB,EADzB,IAEAmB,IAAI,CAACI,UAAL,CAAgBvB,IAAhB,KAAyB,UAH3B,EAIE;UACA;QACD,CAhB0B,CAiB3B;;;QACA,IAAIwB,OAAO,GAAG,EAAd;;QACA,KAAK,MAAMC,KAAX,IAAoBN,IAAI,CAACE,QAAzB,EAAmC;UACjC,IAAII,KAAK,CAACzB,IAAN,KAAe,MAAf,IAAyByB,KAAK,CAACzB,IAAN,KAAe,OAA5C,EAAqD;YACnDwB,OAAO,IAAIC,KAAK,CAACC,KAAjB;UACD;QACF;QACD;AACR;AACA;;;QACQ,IAAIC,MAAM,GAAG,IAAb;;QACA,IAAI;UACFA,MAAM,GAAGnC,OAAO,CAACoC,KAAR,CAAcJ,OAAd,EAAuB;YAC9BK,UAAU,EAAE,KADkB;YAE9BC,mBAAmB,EAAE;UAFS,CAAvB,CAAT;QAID,CALD,CAKE,MAAM;UACN;QACD;;QACD,IAAIH,MAAM,CAAC3B,IAAP,KAAgB,YAApB,EAAkC;UAChCe,MAAM,CAACgB,IAAP,CAAY;YAAEZ,IAAF;YAAQC,UAAR;YAAoBO;UAApB,CAAZ;QACD,CAtC0B,CAwC3B;;;QACAnC,OAAO,CAACwC,IAAR,CAAaL,MAAb,EAAqB;UACnBM,KAAK,EAAE,UADY;;UAEnBf,KAAK,CAACC,IAAD,EAAOe,IAAP,EAAa;YAChB,MAAMC,MAAM,GAAG,KAAKA,MAApB;YACA,MAAMC,IAAI,GAAG,KAAKA,IAAlB;;YACA,IAAIA,IAAI,IAAI,IAAZ,EAAkB;cAChB;YACD,CALe,CAOhB;;;YACA,IAAIC,EAAE,GAAG,EAAT;;YACA,IAAIF,MAAM,IAAI,IAAd,EAAoB;cAClBE,EAAE,GAAGF,MAAM,CAAClC,IAAZ;;cACA,IAAIkC,MAAM,CAACG,OAAP,IAAkB,IAAtB,EAA4B;gBAC1BD,EAAE,IAAK,IAAG7C,OAAO,CAAC+C,QAAR,CAAiBJ,MAAM,CAACG,OAAxB,CAAiC,EAA3C;cACD;YACF;;YACD,IAAIzB,MAAM,CAAC2B,QAAP,CAAgBH,EAAhB,MAAwB,KAA5B,EAAmC;cACjC;YACD;YAED;AACZ;AACA;AACA;AACA;AACA;;;YACY,MAAMI,OAAO,GAAG,EAAhB;;YACA,IAAItB,IAAI,CAACnB,IAAL,KAAc,UAAlB,EAA8B;cAC5BmB,IAAI,CAACE,QAAL,CAAcqB,IAAd,CAAmB,CAACC,SAAD,EAAYC,SAAZ,EAAuBC,SAAvB,KAAqC;gBACtD,IACEF,SAAS,CAAC3C,IAAV,KAAmB,qBAAnB,IACA2C,SAAS,CAAC3C,IAAV,KAAmB,uBAFrB,EAGE;kBACAyC,OAAO,CAACV,IAAR,CAAa;oBAAEG,IAAI,EAAEU,SAAR;oBAAmBE,IAAI,EAAED;kBAAzB,CAAb;gBACD;cACF,CAPD;YAQD,CAnCe,CAqChB;;;YACA,MAAME,eAAe,GAAGvD,OAAO,CAAC+C,QAAR,CAAiB;cACvCvC,IAAI,EAAE,UADiC;cAEvCqB,QAAQ,EAAE,IAAI7B,OAAO,CAACwD,IAAZ,GAAmBC,SAAnB,CACRR,OAAO,CAACS,GAAR,CAAaC,MAAD,IAAYA,MAAM,CAACjB,IAAP,CAAYkB,IAApC,CADQ;YAF6B,CAAjB,CAAxB;;YAMA,IAAItC,UAAU,CAAC0B,QAAX,CAAoBO,eAApB,MAAyC,KAA7C,EAAoD;cAClD;YACD,CA9Ce,CAgDhB;YACA;YACA;;;YACA,KAAK,MAAMI,MAAX,IAAqBV,OAArB,EAA8B;cAC5BU,MAAM,CAACL,IAAP,CAAYO,MAAZ,CAAmBF,MAAM,CAACjB,IAA1B;YACD;;YAEDlB,SAAS,CAACe,IAAV,CAAe;cAAEZ,IAAF;cAAQe,IAAR;cAAcE;YAAd,CAAf;UACD;;QA1DkB,CAArB;MA4DD;IAtGM,CADJ;IA0GL3B,IAAI,EAAE;MACJ6C,IAAI,EAAE,MAAM;QACV,IAAIvC,MAAM,CAACO,MAAP,KAAkB,CAAtB,EAAyB;UACvB;QACD,CAHS,CAIV;;;QACA,MAAMiC,eAAe,GAAG5D,MAAM,CAACqB,SAAD,EAAY,CAACX,CAAD,EAAIC,CAAJ,KAAU;UAClD,MAAMkD,YAAY,GAAG9D,WAAW,CAACW,CAAC,CAAC6B,IAAF,CAAOkB,IAAR,CAAhC;UACA,MAAMK,YAAY,GAAG/D,WAAW,CAACY,CAAC,CAAC4B,IAAF,CAAOkB,IAAR,CAAhC;UACA,OAAOhD,kBAAkB,CAACoD,YAAD,EAAeC,YAAf,CAAzB;QACD,CAJ6B,CAAN,CAIrBC,OAJqB,EAAxB;;QAMA,KAAK,MAAMC,QAAX,IAAuBJ,eAAvB,EAAwC;UACtC;UACA,MAAMK,YAAY,GAAGpE,OAAO,CAAC+C,QAAR,CAAiBoB,QAAQ,CAACzB,IAAT,CAAckB,IAA/B,CAArB;UACA;AACV;AACA;;UACU,MAAMS,eAAe,GAAG,EAAxB;;UACA,IAAI;YACF,KAAK,MAAM1C,IAAX,IAAmBtB,gBAAgB,CAACY,IAAD,EAAOmD,YAAP,CAAnC,EAAyD;cACvD,IAAIzC,IAAI,CAACnB,IAAL,KAAc,SAAlB,EAA6B;gBAC3B6D,eAAe,CAAC9B,IAAhB,CAAqBZ,IAArB;cACD;YACF;UACF,CAND,CAME,OAAO2C,WAAP,EAAoB;YACpB;UACD,CAfqC,CAgBtC;;;UACA,IAAID,eAAe,CAACvC,MAAhB,KAA2B,CAA/B,EAAkC;YAChC;UACD,CAnBqC,CAqBtC;UACA;;;UACA,IAAIX,eAAe,IAAIkD,eAAe,CAACvC,MAAhB,GAAyB,CAAhD,EAAmD;YACjD;UACD,CAzBqC,CA2BtC;;;UACA,KAAK,MAAMyC,UAAX,IAAyBF,eAAzB,EAA0C;YACxC,MAAMG,oBAAoB,GAAGxE,OAAO,CAACoC,KAAR,CAC3BmC,UAAU,CAACxC,UAAX,CAAsB0C,KAAtB,IAA+B,IAA/B,GACI,EADJ,GAEIF,UAAU,CAACxC,UAAX,CAAsB0C,KAHC,EAI3B;cACEC,OAAO,EAAE,iBADX;cAEErC,UAAU,EAAE;YAFd,CAJ2B,CAA7B;;YASA,IAAImC,oBAAoB,CAAChE,IAArB,KAA8B,iBAAlC,EAAqD;cACnD;YACD;;YACD,MAAMmE,qBAAqB,GAAG,IAAIC,GAAJ,EAA9B;YACA5E,OAAO,CAACwC,IAAR,CAAagC,oBAAb,EAAmC;cACjC/B,KAAK,EAAE,aAD0B;;cAEjCf,KAAK,CAACC,IAAD,EAAOe,IAAP,EAAa;gBAChBiC,qBAAqB,CAACE,GAAtB,CAA0BlD,IAAI,CAACmD,QAA/B,EAAyCpC,IAAzC;cACD;;YAJgC,CAAnC,EAdwC,CAoBxC;;YACA1C,OAAO,CAACwC,IAAR,CAAa2B,QAAQ,CAACvB,IAAtB,EAA4B;cAC1BH,KAAK,EAAE,aADmB;;cAE1Bf,KAAK,CAACqD,eAAD,EAAkB;gBACrB;gBACA;gBACA;gBACA;gBACA,MAAMC,WAAW,GAAGL,qBAAqB,CAACM,GAAtB,CAClBF,eAAe,CAACD,QADE,CAApB;gBAGA,MAAMI,mBAAmB,GACvBV,oBAAoB,CAAC3C,QAArB,CAA8BsD,UAA9B,CAAyCJ,eAAzC,CADF;;gBAEA,IAAIC,WAAW,IAAI,IAAnB,EAAyB;kBACvBR,oBAAoB,CAAC3C,QAArB,CAA8BuD,MAA9B,CAAqCF,mBAArC;gBACD,CAFD,MAEO,IACLF,WAAW,CAACpB,IAAZ,CAAiByB,SAAjB,KAA+B,IAA/B,IACAN,eAAe,CAACM,SAAhB,KAA8B,IAFzB,EAGL;kBACAb,oBAAoB,CAAC3C,QAArB,CAA8ByD,OAA9B,CACEN,WADF,EAEEE,mBAFF;kBAIAP,qBAAqB,CAACE,GAAtB,CACEE,eAAe,CAACD,QADlB,EAEEI,mBAFF;gBAID;cACF;;YA3ByB,CAA5B;YA6BAX,UAAU,CAACxC,UAAX,CAAsB0C,KAAtB,GACEzE,OAAO,CAAC+C,QAAR,CAAiByB,oBAAjB,CADF;UAED;;UAED,IACEpD,sBAAsB,IACtBiD,eAAe,CAACvC,MAAhB,KAA2B,CAD3B,IAEAqC,QAAQ,CAACvB,IAAT,CAAcE,OAAd,CAAsBtC,IAAtB,KAA+B,cAHjC,EAIE;YACA;YACA2D,QAAQ,CAACvB,IAAT,CAAcE,OAAd,CAAsBjB,QAAtB,CAA+BgC,MAA/B,CAAsCM,QAAQ,CAACzB,IAA/C;UACD;;UACDyB,QAAQ,CAACE,eAAT,GAA2BA,eAA3B;QACD,CAtGS,CAwGV;;;QACA,IAAIjD,sBAAsB,KAAK,KAA/B,EAAsC;UACpC;QACD,CA3GS,CA6GV;;;QACA,KAAK,MAAM+C,QAAX,IAAuBJ,eAAvB,EAAwC;UACtC,IAAII,QAAQ,CAACE,eAAT,IAA4B,IAAhC,EAAsC;YACpC;UACD;;UAED,IAAIlD,eAAe,IAAIgD,QAAQ,CAACE,eAAT,CAAyBvC,MAAzB,GAAkC,CAAzD,EAA4D;YAC1D;YACA;UACD;;UAED,KAAK,MAAMyC,UAAX,IAAyBJ,QAAQ,CAACE,eAAlC,EAAmD;YACjD;YACA,MAAMkB,SAAS,GAAG,IAAIC,GAAJ,CAChBjB,UAAU,CAACxC,UAAX,CAAsB0D,KAAtB,IAA+B,IAA/B,GACI,IADJ,GAEIlB,UAAU,CAACxC,UAAX,CAAsB0D,KAAtB,CAA4BC,KAA5B,CAAkC,GAAlC,CAHY,CAAlB;YAKA,MAAMC,gBAAgB,GAAGxB,QAAQ,CAACxC,IAAT,CAAcE,QAAd,CAAuB+D,KAAvB,EAAzB;;YACA,IACED,gBAAgB,IAAI,IAApB,IACAA,gBAAgB,CAACnF,IAAjB,KAA0B,eAF5B,EAGE;cACA+E,SAAS,CAACM,MAAV,CAAiBF,gBAAgB,CAAClF,IAAlC;YACD;;YACD,IAAI8E,SAAS,CAACO,IAAV,KAAmB,CAAvB,EAA0B;cACxB,OAAOvB,UAAU,CAACxC,UAAX,CAAsB0D,KAA7B;YACD,CAFD,MAEO;cACLlB,UAAU,CAACxC,UAAX,CAAsB0D,KAAtB,GAA8BM,KAAK,CAACC,IAAN,CAAWT,SAAX,EAAsBU,IAAtB,CAA2B,GAA3B,CAA9B;YACD,CAlBgD,CAoBjD;;;YACA,IACEN,gBAAgB,IAAI,IAApB,IACAA,gBAAgB,CAACnF,IAAjB,KAA0B,YAF5B,EAGE;cACA,IAAI+D,UAAU,CAACxC,UAAX,CAAsBmE,EAAtB,KAA6BP,gBAAgB,CAAClF,IAAlD,EAAwD;gBACtD,OAAO8D,UAAU,CAACxC,UAAX,CAAsBmE,EAA7B;cACD;YACF;UACF;QACF;;QAED,KAAK,MAAMzB,KAAX,IAAoBlD,MAApB,EAA4B;UAC1BvB,OAAO,CAACwC,IAAR,CAAaiC,KAAK,CAACtC,MAAnB,EAA2B;YACzBM,KAAK,EAAE,MADkB;YAEzBf,KAAK,EAAE,UAAUC,IAAV,EAAgBe,IAAhB,EAAsBY,IAAtB,EAA4B;cACjC;cACA,IACE3B,IAAI,CAACnB,IAAL,KAAc,MAAd,IACAmB,IAAI,CAACmB,OAAL,CAAatC,IAAb,KAAsB,cADtB,IAEAmB,IAAI,CAACmB,OAAL,CAAajB,QAAb,CAAsBsE,OAAtB,EAHF,EAIE;gBACA7C,IAAI,CAACO,MAAL,CAAYnB,IAAZ;cACD;YACF;UAXwB,CAA3B;;UAcA,IAAI+B,KAAK,CAACtC,MAAN,CAAaN,QAAb,CAAsBsE,OAAtB,EAAJ,EAAqC;YACnC;YACA7F,oBAAoB,CAACmE,KAAK,CAAC9C,IAAP,EAAa8C,KAAK,CAAC7C,UAAnB,CAApB;UACD,CAHD,MAGO;YACL;YACA,MAAMwE,UAAU,GAAG3B,KAAK,CAAC9C,IAAN,CAAWE,QAAX,CAAoB,CAApB,CAAnB;;YACA,IAAIuE,UAAU,CAAC5F,IAAX,KAAoB,MAApB,IAA8B4F,UAAU,CAAC5F,IAAX,KAAoB,OAAtD,EAA+D;cAC7D4F,UAAU,CAAClE,KAAX,GAAmBlC,OAAO,CAAC+C,QAAR,CAAiB0B,KAAK,CAACtC,MAAvB,CAAnB;YACD;UACF;QACF;MACF;IAnLG;EA1GD,CAAP;AAgSD,CAtTD"},"metadata":{},"sourceType":"script"}