{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst error = {\n  message: _ref => {\n    let {\n      params: {\n        len\n      }\n    } = _ref;\n    return (0, codegen_1.str)`must NOT have more than ${len} items`;\n  },\n  params: _ref2 => {\n    let {\n      params: {\n        len\n      }\n    } = _ref2;\n    return (0, codegen_1._)`{limit: ${len}}`;\n  }\n};\nconst def = {\n  keyword: \"unevaluatedItems\",\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  error,\n\n  code(cxt) {\n    const {\n      gen,\n      schema,\n      data,\n      it\n    } = cxt;\n    const items = it.items || 0;\n    if (items === true) return;\n    const len = gen.const(\"len\", (0, codegen_1._)`${data}.length`);\n\n    if (schema === false) {\n      cxt.setParams({\n        len: items\n      });\n      cxt.fail((0, codegen_1._)`${len} > ${items}`);\n    } else if (typeof schema == \"object\" && !(0, util_1.alwaysValidSchema)(it, schema)) {\n      const valid = gen.var(\"valid\", (0, codegen_1._)`${len} <= ${items}`);\n      gen.if((0, codegen_1.not)(valid), () => validateItems(valid, items));\n      cxt.ok(valid);\n    }\n\n    it.items = true;\n\n    function validateItems(valid, from) {\n      gen.forRange(\"i\", from, len, i => {\n        cxt.subschema({\n          keyword: \"unevaluatedItems\",\n          dataProp: i,\n          dataPropType: util_1.Type.Num\n        }, valid);\n        if (!it.allErrors) gen.if((0, codegen_1.not)(valid), () => gen.break());\n      });\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"mappings":";;;;;;AAOA;;AACA;;AAIA,MAAMA,KAAK,GAA2B;EACpCC,OAAO,EAAE;IAAA,IAAC;MAACC,MAAM,EAAE;QAACC;MAAD;IAAT,CAAD;IAAA,OAAqB,kBAAG,2BAA2BA,GAAG,QAAtD;EAAA,CAD2B;EAEpCD,MAAM,EAAE;IAAA,IAAC;MAACA,MAAM,EAAE;QAACC;MAAD;IAAT,CAAD;IAAA,OAAqB,gBAAC,WAAWA,GAAG,GAApC;EAAA;AAF4B,CAAtC;AAKA,MAAMC,GAAG,GAA0B;EACjCC,OAAO,EAAE,kBADwB;EAEjCC,IAAI,EAAE,OAF2B;EAGjCC,UAAU,EAAE,CAAC,SAAD,EAAY,QAAZ,CAHqB;EAIjCP,KAJiC;;EAKjCQ,IAAI,CAACC,GAAD,EAAgB;IAClB,MAAM;MAACC,GAAD;MAAMC,MAAN;MAAcC,IAAd;MAAoBC;IAApB,IAA0BJ,GAAhC;IACA,MAAMK,KAAK,GAAGD,EAAE,CAACC,KAAH,IAAY,CAA1B;IACA,IAAIA,KAAK,KAAK,IAAd,EAAoB;IACpB,MAAMX,GAAG,GAAGO,GAAG,CAACK,KAAJ,CAAU,KAAV,EAAiB,gBAAC,GAAGH,IAAI,SAAzB,CAAZ;;IACA,IAAID,MAAM,KAAK,KAAf,EAAsB;MACpBF,GAAG,CAACO,SAAJ,CAAc;QAACb,GAAG,EAAEW;MAAN,CAAd;MACAL,GAAG,CAACQ,IAAJ,CAAS,gBAAC,GAAGd,GAAG,MAAMW,KAAK,EAA3B;IACD,CAHD,MAGO,IAAI,OAAOH,MAAP,IAAiB,QAAjB,IAA6B,CAAC,8BAAkBE,EAAlB,EAAsBF,MAAtB,CAAlC,EAAiE;MACtE,MAAMO,KAAK,GAAGR,GAAG,CAACS,GAAJ,CAAQ,OAAR,EAAiB,gBAAC,GAAGhB,GAAG,OAAOW,KAAK,EAApC,CAAd;MACAJ,GAAG,CAACU,EAAJ,CAAO,mBAAIF,KAAJ,CAAP,EAAmB,MAAMG,aAAa,CAACH,KAAD,EAAQJ,KAAR,CAAtC;MACAL,GAAG,CAACa,EAAJ,CAAOJ,KAAP;IACD;;IACDL,EAAE,CAACC,KAAH,GAAW,IAAX;;IAEA,SAASO,aAAT,CAAuBH,KAAvB,EAAoCK,IAApC,EAAuD;MACrDb,GAAG,CAACc,QAAJ,CAAa,GAAb,EAAkBD,IAAlB,EAAwBpB,GAAxB,EAA8BsB,CAAD,IAAM;QACjChB,GAAG,CAACiB,SAAJ,CAAc;UAACrB,OAAO,EAAE,kBAAV;UAA8BsB,QAAQ,EAAEF,CAAxC;UAA2CG,YAAY,EAAEC,YAAKC;QAA9D,CAAd,EAAkFZ,KAAlF;QACA,IAAI,CAACL,EAAE,CAACkB,SAAR,EAAmBrB,GAAG,CAACU,EAAJ,CAAO,mBAAIF,KAAJ,CAAP,EAAmB,MAAMR,GAAG,CAACsB,KAAJ,EAAzB;MACpB,CAHD;IAID;EACF;;AA1BgC,CAAnC;AA6BAC,kBAAe7B,GAAf","names":["error","message","params","len","def","keyword","type","schemaType","code","cxt","gen","schema","data","it","items","const","setParams","fail","valid","var","if","validateItems","ok","from","forRange","i","subschema","dataProp","dataPropType","util_1","Num","allErrors","break","exports"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\mini-css-extract-plugin\\node_modules\\ajv\\lib\\vocabularies\\unevaluated\\unevaluatedItems.ts"],"sourcesContent":["import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../../compile/util\"\n\nexport type UnevaluatedItemsError = ErrorObject<\"unevaluatedItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"unevaluatedItems\",\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    const items = it.items || 0\n    if (items === true) return\n    const len = gen.const(\"len\", _`${data}.length`)\n    if (schema === false) {\n      cxt.setParams({len: items})\n      cxt.fail(_`${len} > ${items}`)\n    } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n      const valid = gen.var(\"valid\", _`${len} <= ${items}`)\n      gen.if(not(valid), () => validateItems(valid, items))\n      cxt.ok(valid)\n    }\n    it.items = true\n\n    function validateItems(valid: Name, from: Name | number): void {\n      gen.forRange(\"i\", from, len, (i) => {\n        cxt.subschema({keyword: \"unevaluatedItems\", dataProp: i, dataPropType: Type.Num}, valid)\n        if (!it.allErrors) gen.if(not(valid), () => gen.break())\n      })\n    }\n  },\n}\n\nexport default def\n"]},"metadata":{},"sourceType":"script"}