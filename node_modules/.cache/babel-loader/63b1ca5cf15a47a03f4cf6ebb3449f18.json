{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _t = require('@babel/types');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n[\"default\"] = e;\n  return Object.freeze(n);\n}\n\nvar _t__namespace = /*#__PURE__*/_interopNamespace(_t);\n\nfunction willPathCastToBoolean(path) {\n  const maybeWrapped = path;\n  const {\n    node,\n    parentPath\n  } = maybeWrapped;\n\n  if (parentPath.isLogicalExpression()) {\n    const {\n      operator,\n      right\n    } = parentPath.node;\n\n    if (operator === \"&&\" || operator === \"||\" || operator === \"??\" && node === right) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n\n  if (parentPath.isSequenceExpression()) {\n    const {\n      expressions\n    } = parentPath.node;\n\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      return true;\n    }\n  }\n\n  return parentPath.isConditional({\n    test: node\n  }) || parentPath.isUnaryExpression({\n    operator: \"!\"\n  }) || parentPath.isLoop({\n    test: node\n  });\n}\n\nconst {\n  LOGICAL_OPERATORS,\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  identifier,\n  isMemberExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isUpdateExpression,\n  logicalExpression,\n  memberExpression,\n  nullLiteral,\n  optionalCallExpression,\n  optionalMemberExpression,\n  sequenceExpression,\n  updateExpression\n} = _t__namespace;\n\nclass AssignmentMemoiser {\n  constructor() {\n    this._map = void 0;\n    this._map = new WeakMap();\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n\n    const {\n      value\n    } = record;\n    record.count--;\n\n    if (record.count === 0) {\n      return assignmentExpression(\"=\", value, key);\n    }\n\n    return value;\n  }\n\n  set(key, value, count) {\n    return this._map.set(key, {\n      count,\n      value\n    });\n  }\n\n}\n\nfunction toNonOptional(path, base) {\n  const {\n    node\n  } = path;\n\n  if (isOptionalMemberExpression(node)) {\n    return memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      const object = callee.node.object;\n      const context = path.scope.maybeGenerateMemoised(object);\n      callee.get(\"object\").replaceWith(assignmentExpression(\"=\", context, object));\n      return callExpression(memberExpression(base, identifier(\"call\")), [context, ...path.node.arguments]);\n    }\n\n    return callExpression(base, path.node.arguments);\n  }\n\n  return path.node;\n}\n\nfunction isInDetachedTree(path) {\n  while (path) {\n    if (path.isProgram()) break;\n    const {\n      parentPath,\n      container,\n      listKey\n    } = path;\n    const parentNode = parentPath.node;\n\n    if (listKey) {\n      if (container !== parentNode[listKey]) {\n        return true;\n      }\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\nconst handle = {\n  memoise() {},\n\n  handle(member, noDocumentAll) {\n    const {\n      node,\n      parent,\n      parentPath,\n      scope\n    } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      if (isInDetachedTree(member)) return;\n      const endPath = member.find(_ref => {\n        let {\n          node,\n          parent\n        } = _ref;\n\n        if (isOptionalMemberExpression(parent)) {\n          return parent.optional || parent.object !== node;\n        }\n\n        if (isOptionalCallExpression(parent)) {\n          return node !== member.node && parent.optional || parent.callee !== node;\n        }\n\n        return true;\n      });\n\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(callExpression(arrowFunctionExpression([], endPath.node), []));\n        return;\n      }\n\n      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n      const rootParentPath = endPath.parentPath;\n\n      if (rootParentPath.isUpdateExpression({\n        argument: node\n      }) || rootParentPath.isAssignmentExpression({\n        left: node\n      })) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\"\n      });\n\n      if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get(\"property\").isPrivateName()) {\n        throw member.buildCodeFrameError(`can't delete a private class element`);\n      }\n\n      let startingOptional = member;\n\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n\n        throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);\n      }\n\n      const startingNode = startingOptional.isOptionalMemberExpression() ? startingOptional.node.object : startingOptional.node.callee;\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node\n      });\n\n      const isOptionalCall = parent => parentIsOptionalCall;\n\n      const parentIsCall = parentPath.isCallExpression({\n        callee: node\n      });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n\n      if (isOptionalCall()) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular = member.node;\n\n      for (let current = member; current !== endPath;) {\n        const parentPath = current.parentPath;\n\n        if (parentPath === endPath && isOptionalCall() && parent.optional) {\n          regular = parentPath.node;\n          break;\n        }\n\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context;\n      const endParentPath = endPath.parentPath;\n\n      if (isMemberExpression(regular) && endParentPath.isOptionalCallExpression({\n        callee: endPath.node,\n        optional: true\n      })) {\n        const {\n          object\n        } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n\n        if (context) {\n          regular.object = assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      let replacementPath = endPath;\n\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      const baseMemoised = baseNeedsMemoised ? assignmentExpression(\"=\", cloneNode(baseRef), cloneNode(startingNode)) : cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        let nonNullishCheck;\n\n        if (noDocumentAll) {\n          nonNullishCheck = binaryExpression(\"!=\", baseMemoised, nullLiteral());\n        } else {\n          nonNullishCheck = logicalExpression(\"&&\", binaryExpression(\"!==\", baseMemoised, nullLiteral()), binaryExpression(\"!==\", cloneNode(baseRef), scope.buildUndefinedNode()));\n        }\n\n        replacementPath.replaceWith(logicalExpression(\"&&\", nonNullishCheck, regular));\n      } else {\n        let nullishCheck;\n\n        if (noDocumentAll) {\n          nullishCheck = binaryExpression(\"==\", baseMemoised, nullLiteral());\n        } else {\n          nullishCheck = logicalExpression(\"||\", binaryExpression(\"===\", baseMemoised, nullLiteral()), binaryExpression(\"===\", cloneNode(baseRef), scope.buildUndefinedNode()));\n        }\n\n        replacementPath.replaceWith(conditionalExpression(nullishCheck, isDeleteOperation ? booleanLiteral(true) : scope.buildUndefinedNode(), regular));\n      }\n\n      if (context) {\n        const endParent = endParentPath.node;\n        endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee, identifier(\"call\"), false, true), [cloneNode(context), ...endParent.arguments], false));\n      }\n\n      return;\n    }\n\n    if (isUpdateExpression(parent, {\n      argument: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        prefix\n      } = parent;\n      this.memoise(member, 2);\n      const ref = scope.generateUidIdentifierBasedOnNode(node);\n      scope.push({\n        id: ref\n      });\n      const seq = [assignmentExpression(\"=\", cloneNode(ref), this.get(member))];\n\n      if (prefix) {\n        seq.push(updateExpression(operator, cloneNode(ref), prefix));\n        const value = sequenceExpression(seq);\n        parentPath.replaceWith(this.set(member, value));\n        return;\n      } else {\n        const ref2 = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({\n          id: ref2\n        });\n        seq.push(assignmentExpression(\"=\", cloneNode(ref2), updateExpression(operator, cloneNode(ref), prefix)), cloneNode(ref));\n        const value = sequenceExpression(seq);\n        parentPath.replaceWith(sequenceExpression([this.set(member, value), cloneNode(ref2)]));\n        return;\n      }\n    }\n\n    if (parentPath.isAssignmentExpression({\n      left: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        right: value\n      } = parentPath.node;\n\n      if (operator === \"=\") {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const operatorTrunc = operator.slice(0, -1);\n\n        if (LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          this.memoise(member, 1);\n          parentPath.replaceWith(logicalExpression(operatorTrunc, this.get(member), this.set(member, value)));\n        } else {\n          this.memoise(member, 2);\n          parentPath.replaceWith(this.set(member, binaryExpression(operatorTrunc, this.get(member), value)));\n        }\n      }\n\n      return;\n    }\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.call(member, parentPath.node.arguments));\n      return;\n    }\n\n    if (parentPath.isOptionalCallExpression({\n      callee: node\n    })) {\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(callExpression(arrowFunctionExpression([], parentPath.node), []));\n        return;\n      }\n\n      parentPath.replaceWith(this.optionalCall(member, parentPath.node.arguments));\n      return;\n    }\n\n    if (parentPath.isForXStatement({\n      left: node\n    }) || parentPath.isObjectProperty({\n      value: node\n    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isObjectProperty({\n      value: parent\n    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      member.replaceWith(this.boundGet(member));\n    } else {\n      member.replaceWith(this.get(member));\n    }\n  }\n\n};\n\nfunction memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, Object.assign({}, handle, state, {\n    memoiser: new AssignmentMemoiser()\n  }));\n}\n\nexports[\"default\"] = memberExpressionToFunctions;","map":{"version":3,"mappings":"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","names":["willPathCastToBoolean","path","maybeWrapped","node","parentPath","isLogicalExpression","operator","right","isSequenceExpression","expressions","length","isConditional","test","isUnaryExpression","isLoop","LOGICAL_OPERATORS","arrowFunctionExpression","assignmentExpression","binaryExpression","booleanLiteral","callExpression","cloneNode","conditionalExpression","identifier","isMemberExpression","isOptionalCallExpression","isOptionalMemberExpression","isUpdateExpression","logicalExpression","memberExpression","nullLiteral","optionalCallExpression","optionalMemberExpression","sequenceExpression","updateExpression","AssignmentMemoiser","constructor","_map","WeakMap","has","key","get","record","value","count","set","toNonOptional","base","property","computed","callee","optional","object","context","scope","maybeGenerateMemoised","replaceWith","arguments","isInDetachedTree","isProgram","container","listKey","parentNode","handle","memoise","member","noDocumentAll","parent","endPath","find","isPattern","willEndPathCastToBoolean","rootParentPath","argument","isAssignmentExpression","left","buildCodeFrameError","isDeleteOperation","isPrivateName","startingOptional","Error","type","startingNode","baseNeedsMemoised","baseRef","parentIsOptionalCall","isOptionalCall","parentIsCall","isCallExpression","optionalCall","call","boundGet","regular","current","endParentPath","replacementPath","baseMemoised","nonNullishCheck","buildUndefinedNode","nullishCheck","endParent","simpleSet","prefix","ref","generateUidIdentifierBasedOnNode","push","id","seq","ref2","operatorTrunc","slice","includes","isForXStatement","isObjectProperty","isObjectPattern","isAssignmentPattern","isArrayPattern","isRestElement","destructureSet","isTaggedTemplateExpression","memberExpressionToFunctions","visitor","state","traverse","memoiser"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-member-expression-to-functions\\src\\util.ts","C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\helper-member-expression-to-functions\\src\\index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\n\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n *\n * @example\n * // returns true\n * const nodePathAQDotB = NodePath(\"if (a?.#b) {}\").get(\"test\"); // a?.#b\n * willPathCastToBoolean(nodePathAQDotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a?.#b\"))\n * @todo Respect transparent expression wrappers\n * @see {@link packages/babel-plugin-proposal-optional-chaining/src/util.js}\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = path;\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n","import type { NodePath, Visitor } from \"@babel/traverse\";\nimport {\n  LOGICAL_OPERATORS,\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  identifier,\n  isMemberExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isUpdateExpression,\n  logicalExpression,\n  memberExpression,\n  nullLiteral,\n  optionalCallExpression,\n  optionalMemberExpression,\n  sequenceExpression,\n  updateExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { willPathCastToBoolean } from \"./util\";\n\nclass AssignmentMemoiser {\n  private _map: WeakMap<t.Expression, { count: number; value: t.Identifier }>;\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key: t.Expression) {\n    return this._map.has(key);\n  }\n\n  get(key: t.Expression) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n    const { value } = record;\n\n    record.count--;\n    if (record.count === 0) {\n      // The `count` access is the outermost function call (hopefully), so it\n      // does the assignment.\n      return assignmentExpression(\"=\", value, key);\n    }\n    return value;\n  }\n\n  set(key: t.Expression, value: t.Identifier, count: number) {\n    return this._map.set(key, { count, value });\n  }\n}\n\nfunction toNonOptional(\n  path: NodePath<t.Expression>,\n  base: t.Expression,\n): t.Expression {\n  const { node } = path;\n  if (isOptionalMemberExpression(node)) {\n    return memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      // object must be a conditional expression because the optional private access in object has been transformed\n      const object = callee.node.object as t.ConditionalExpression;\n      const context = path.scope.maybeGenerateMemoised(object);\n      callee\n        .get(\"object\")\n        .replaceWith(assignmentExpression(\"=\", context, object));\n\n      return callExpression(memberExpression(base, identifier(\"call\")), [\n        context,\n        ...path.node.arguments,\n      ]);\n    }\n\n    return callExpression(base, path.node.arguments);\n  }\n\n  return path.node;\n}\n\n// Determines if the current path is in a detached tree. This can happen when\n// we are iterating on a path, and replace an ancestor with a new node. Babel\n// doesn't always stop traversing the old node tree, and that can cause\n// inconsistencies.\nfunction isInDetachedTree(path: NodePath) {\n  while (path) {\n    if (path.isProgram()) break;\n\n    const { parentPath, container, listKey } = path;\n    const parentNode = parentPath.node;\n    if (listKey) {\n      if (\n        container !==\n        // @ts-expect-error listKey must be a valid parent node key\n        parentNode[listKey]\n      ) {\n        return true;\n      }\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\ntype Member = NodePath<t.OptionalMemberExpression | t.MemberExpression>;\n\nconst handle = {\n  memoise() {\n    // noop.\n  },\n\n  handle(this: HandlerState, member: Member, noDocumentAll: boolean) {\n    const { node, parent, parentPath, scope } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      // Transforming optional chaining requires we replace ancestors.\n      if (isInDetachedTree(member)) return;\n\n      // We're looking for the end of _this_ optional chain, which is actually\n      // the \"rightmost\" property access of the chain. This is because\n      // everything up to that property access is \"optional\".\n      //\n      // Let's take the case of `FOO?.BAR.baz?.qux`, with `FOO?.BAR` being our\n      // member. The \"end\" to most users would be `qux` property access.\n      // Everything up to it could be skipped if it `FOO` were nullish. But\n      // actually, we can consider the `baz` access to be the end. So we're\n      // looking for the nearest optional chain that is `optional: true`.\n      const endPath = member.find(({ node, parent }) => {\n        if (isOptionalMemberExpression(parent)) {\n          // We need to check `parent.object` since we could be inside the\n          // computed expression of a `bad?.[FOO?.BAR]`. In this case, the\n          // endPath is the `FOO?.BAR` member itself.\n          return parent.optional || parent.object !== node;\n        }\n        if (isOptionalCallExpression(parent)) {\n          // Checking `parent.callee` since we could be in the arguments, eg\n          // `bad?.(FOO?.BAR)`.\n          // Also skip `FOO?.BAR` in `FOO?.BAR?.()` since we need to transform the optional call to ensure proper this\n          return (\n            // In FOO?.#BAR?.(), endPath points the optional call expression so we skip FOO?.#BAR\n            (node !== member.node && parent.optional) || parent.callee !== node\n          );\n        }\n        return true;\n      }) as NodePath<t.OptionalMemberExpression>;\n\n      // Replace `function (a, x = a.b?.#c) {}` to `function (a, x = (() => a.b?.#c)() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], endPath.node), []),\n        );\n        return;\n      }\n\n      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n\n      const rootParentPath = endPath.parentPath;\n      if (\n        rootParentPath.isUpdateExpression({ argument: node }) ||\n        rootParentPath.isAssignmentExpression({ left: node })\n      ) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\",\n      });\n      if (\n        isDeleteOperation &&\n        endPath.isOptionalMemberExpression() &&\n        endPath.get(\"property\").isPrivateName()\n      ) {\n        // @babel/parser will throw error on `delete obj?.#x`.\n        // This error serves as fallback when `delete obj?.#x` is constructed from babel types\n        throw member.buildCodeFrameError(\n          `can't delete a private class element`,\n        );\n      }\n\n      // Now, we're looking for the start of this optional chain, which is\n      // optional to the left of this member.\n      //\n      // Let's take the case of `foo?.bar?.baz.QUX?.BAM`, with `QUX?.BAM` being\n      // our member. The \"start\" to most users would be `foo` object access.\n      // But actually, we can consider the `bar` access to be the start. So\n      // we're looking for the nearest optional chain that is `optional: true`,\n      // which is guaranteed to be somewhere in the object/callee tree.\n      let startingOptional: NodePath<t.Expression> = member;\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n        // prevent infinite loop: unreachable if the AST is well-formed\n        throw new Error(\n          `Internal error: unexpected ${startingOptional.node.type}`,\n        );\n      }\n\n      // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n      const startingNode = startingOptional.isOptionalMemberExpression()\n        ? // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n          startingOptional.node.object\n        : // @ts-expect-error isOptionalMemberExpression does not work with NodePath union\n          startingOptional.node.callee;\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised ?? startingNode;\n\n      // Compute parentIsOptionalCall before `startingOptional` is replaced\n      // as `node` may refer to `startingOptional.node` before replaced.\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node,\n      });\n      // here we use a function to wrap `parentIsOptionalCall` to get type\n      // for parent, do not use it anywhere else\n      // See https://github.com/microsoft/TypeScript/issues/10421\n      const isOptionalCall = (\n        parent: t.Node,\n      ): parent is t.OptionalCallExpression => parentIsOptionalCall;\n      // if parentIsCall is true, it implies that node.extra.parenthesized is always true\n      const parentIsCall = parentPath.isCallExpression({ callee: node });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n      if (isOptionalCall(parent)) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        // `(a?.#b)()` to `(a == null ? void 0 : a.#b.bind(a))()`\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular: t.Expression = member.node;\n      for (let current: NodePath = member; current !== endPath; ) {\n        const parentPath = current.parentPath as NodePath<t.Expression>;\n        // skip transforming `Foo.#BAR?.call(FOO)`\n        if (\n          parentPath === endPath &&\n          isOptionalCall(parent) &&\n          parent.optional\n        ) {\n          regular = parentPath.node;\n          break;\n        }\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context: t.Identifier;\n      const endParentPath = endPath.parentPath as NodePath<t.Expression>;\n      if (\n        isMemberExpression(regular) &&\n        endParentPath.isOptionalCallExpression({\n          callee: endPath.node,\n          optional: true,\n        })\n      ) {\n        const { object } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n        if (context) {\n          regular.object = assignmentExpression(\n            \"=\",\n            context,\n            // object must not be Super when `context` is an identifier\n            object as t.Expression,\n          );\n        }\n      }\n\n      let replacementPath: NodePath = endPath;\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      const baseMemoised = baseNeedsMemoised\n        ? assignmentExpression(\n            \"=\",\n            // When base needs memoised, the baseRef must be an identifier\n            cloneNode(baseRef as t.Identifier),\n            cloneNode(startingNode),\n          )\n        : cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        let nonNullishCheck;\n        if (noDocumentAll) {\n          nonNullishCheck = binaryExpression(\"!=\", baseMemoised, nullLiteral());\n        } else {\n          nonNullishCheck = logicalExpression(\n            \"&&\",\n            binaryExpression(\"!==\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"!==\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n        replacementPath.replaceWith(\n          logicalExpression(\"&&\", nonNullishCheck, regular),\n        );\n      } else {\n        let nullishCheck;\n        if (noDocumentAll) {\n          nullishCheck = binaryExpression(\"==\", baseMemoised, nullLiteral());\n        } else {\n          nullishCheck = logicalExpression(\n            \"||\",\n            binaryExpression(\"===\", baseMemoised, nullLiteral()),\n            binaryExpression(\n              \"===\",\n              cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n\n        replacementPath.replaceWith(\n          conditionalExpression(\n            nullishCheck,\n            isDeleteOperation\n              ? booleanLiteral(true)\n              : scope.buildUndefinedNode(),\n            regular,\n          ),\n        );\n      }\n\n      // context and isDeleteOperation can not be both truthy\n      if (context) {\n        const endParent = endParentPath.node as t.OptionalCallExpression;\n        endParentPath.replaceWith(\n          optionalCallExpression(\n            optionalMemberExpression(\n              endParent.callee,\n              identifier(\"call\"),\n              false,\n              true,\n            ),\n            [cloneNode(context), ...endParent.arguments],\n            false,\n          ),\n        );\n      }\n\n      return;\n    }\n\n    // MEMBER++   ->   _set(MEMBER, (ref = _get(MEMBER), ref2 = ref++, ref)), ref2\n    // ++MEMBER   ->   _set(MEMBER, (ref = _get(MEMBER), ++ref))\n    if (isUpdateExpression(parent, { argument: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, prefix } = parent;\n\n      // Give the state handler a chance to memoise the member, since we'll\n      // reference it twice. The second access (the set) should do the memo\n      // assignment.\n      this.memoise(member, 2);\n\n      const ref = scope.generateUidIdentifierBasedOnNode(node);\n      scope.push({ id: ref });\n\n      const seq: t.Expression[] = [\n        // ref = _get(MEMBER)\n        assignmentExpression(\"=\", cloneNode(ref), this.get(member)),\n      ];\n\n      if (prefix) {\n        seq.push(updateExpression(operator, cloneNode(ref), prefix));\n\n        // (ref = _get(MEMBER), ++ref)\n        const value = sequenceExpression(seq);\n        parentPath.replaceWith(this.set(member, value));\n\n        return;\n      } else {\n        const ref2 = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({ id: ref2 });\n\n        seq.push(\n          assignmentExpression(\n            \"=\",\n            cloneNode(ref2),\n            updateExpression(operator, cloneNode(ref), prefix),\n          ),\n          cloneNode(ref),\n        );\n\n        // (ref = _get(MEMBER), ref2 = ref++, ref)\n        const value = sequenceExpression(seq);\n        parentPath.replaceWith(\n          sequenceExpression([this.set(member, value), cloneNode(ref2)]),\n        );\n\n        return;\n      }\n    }\n\n    // MEMBER = VALUE   ->   _set(MEMBER, VALUE)\n    // MEMBER += VALUE   ->   _set(MEMBER, _get(MEMBER) + VALUE)\n    // MEMBER ??= VALUE   ->   _get(MEMBER) ?? _set(MEMBER, VALUE)\n    if (parentPath.isAssignmentExpression({ left: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, right: value } = parentPath.node;\n\n      if (operator === \"=\") {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const operatorTrunc = operator.slice(0, -1);\n        if (LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          // Give the state handler a chance to memoise the member, since we'll\n          // reference it twice. The first access (the get) should do the memo\n          // assignment.\n          this.memoise(member, 1);\n          parentPath.replaceWith(\n            logicalExpression(\n              operatorTrunc as t.LogicalExpression[\"operator\"],\n              this.get(member),\n              this.set(member, value),\n            ),\n          );\n        } else {\n          // Here, the second access (the set) is evaluated first.\n          this.memoise(member, 2);\n          parentPath.replaceWith(\n            this.set(\n              member,\n              binaryExpression(\n                operatorTrunc as t.BinaryExpression[\"operator\"],\n                this.get(member),\n                value,\n              ),\n            ),\n          );\n        }\n      }\n      return;\n    }\n\n    // MEMBER(ARGS) -> _call(MEMBER, ARGS)\n    if (parentPath.isCallExpression({ callee: node })) {\n      parentPath.replaceWith(this.call(member, parentPath.node.arguments));\n      return;\n    }\n\n    // MEMBER?.(ARGS) -> _optionalCall(MEMBER, ARGS)\n    if (parentPath.isOptionalCallExpression({ callee: node })) {\n      // Replace `function (a, x = a.b.#c?.()) {}` to `function (a, x = (() => a.b.#c?.())() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          callExpression(arrowFunctionExpression([], parentPath.node), []),\n        );\n        return;\n      }\n      parentPath.replaceWith(\n        this.optionalCall(member, parentPath.node.arguments),\n      );\n      return;\n    }\n\n    // for (MEMBER of ARR)\n    // for (MEMBER in ARR)\n    // { KEY: MEMBER } = OBJ -> { KEY: _destructureSet(MEMBER) } = OBJ\n    // { KEY: MEMBER = _VALUE } = OBJ -> { KEY: _destructureSet(MEMBER) = _VALUE } = OBJ\n    // {...MEMBER} -> {..._destructureSet(MEMBER)}\n    //\n    // [MEMBER] = ARR -> [_destructureSet(MEMBER)] = ARR\n    // [MEMBER = _VALUE] = ARR -> [_destructureSet(MEMBER) = _VALUE] = ARR\n    // [...MEMBER] -> [..._destructureSet(MEMBER)]\n    if (\n      // for (MEMBER of ARR)\n      // for (MEMBER in ARR)\n      parentPath.isForXStatement({ left: node }) ||\n      // { KEY: MEMBER } = OBJ\n      (parentPath.isObjectProperty({ value: node }) &&\n        parentPath.parentPath.isObjectPattern()) ||\n      // { KEY: MEMBER = _VALUE } = OBJ\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isObjectProperty({ value: parent }) &&\n        parentPath.parentPath.parentPath.isObjectPattern()) ||\n      // [MEMBER] = ARR\n      parentPath.isArrayPattern() ||\n      // [MEMBER = _VALUE] = ARR\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isArrayPattern()) ||\n      // {...MEMBER}\n      // [...MEMBER]\n      parentPath.isRestElement()\n    ) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      // MEMBER   ->   _get(MEMBER).bind(this)\n      member.replaceWith(this.boundGet(member));\n    } else {\n      // MEMBER   ->   _get(MEMBER)\n      member.replaceWith(this.get(member));\n    }\n  },\n};\n\nexport interface Handler<State> {\n  memoise?(\n    this: HandlerState<State> & State,\n    member: Member,\n    count: number,\n  ): void;\n  destructureSet(\n    this: HandlerState<State> & State,\n    member: Member,\n  ): t.Expression;\n  boundGet(this: HandlerState<State> & State, member: Member): t.Expression;\n  simpleSet?(this: HandlerState<State> & State, member: Member): t.Expression;\n  get(this: HandlerState<State> & State, member: Member): t.Expression;\n  set(\n    this: HandlerState<State> & State,\n    member: Member,\n    value: t.Expression,\n  ): t.Expression;\n  call(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.CallExpression[\"arguments\"],\n  ): t.Expression;\n  optionalCall(\n    this: HandlerState<State> & State,\n    member: Member,\n    args: t.OptionalCallExpression[\"arguments\"],\n  ): t.Expression;\n}\n\nexport interface HandlerState<State = {}> extends Handler<State> {\n  handle(\n    this: HandlerState<State> & State,\n    member: Member,\n    noDocumentAll?: boolean,\n  ): void;\n  memoiser: AssignmentMemoiser;\n}\n\n// We do not provide a default traversal visitor\n// Instead, caller passes one, and must call `state.handle` on the members\n// it wishes to be transformed.\n// Additionally, the caller must pass in a state object with at least\n// get, set, and call methods.\n// Optionally, a memoise method may be defined on the state, which will be\n// called when the member is a self-referential update.\nexport default function memberExpressionToFunctions<CustomState = {}>(\n  path: NodePath,\n  visitor: Visitor<HandlerState<CustomState>>,\n  state: Handler<CustomState> & CustomState,\n) {\n  path.traverse(visitor, {\n    ...handle,\n    ...state,\n    memoiser: new AssignmentMemoiser(),\n  });\n}\n"]},"metadata":{},"sourceType":"script"}