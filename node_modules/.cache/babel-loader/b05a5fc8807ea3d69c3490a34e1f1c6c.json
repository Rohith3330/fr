{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _gensync() {\n  const data = require(\"gensync\");\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nvar context = require(\"../index\");\n\nvar _plugin = require(\"./plugin\");\n\nvar _item = require(\"./item\");\n\nvar _configChain = require(\"./config-chain\");\n\nvar _deepArray = require(\"./helpers/deep-array\");\n\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _caching = require(\"./caching\");\n\nvar _options = require(\"./validation/options\");\n\nvar _plugins = require(\"./validation/plugins\");\n\nvar _configApi = require(\"./helpers/config-api\");\n\nvar _partial = require(\"./partial\");\n\nvar _configError = require(\"../errors/config-error\");\n\nvar _default = _gensync()(function* loadFullConfig(inputOpts) {\n  var _opts$assumptions;\n\n  const result = yield* (0, _partial.default)(inputOpts);\n\n  if (!result) {\n    return null;\n  }\n\n  const {\n    options,\n    context,\n    fileHandling\n  } = result;\n\n  if (fileHandling === \"ignored\") {\n    return null;\n  }\n\n  const optionDefaults = {};\n  const {\n    plugins,\n    presets\n  } = options;\n\n  if (!plugins || !presets) {\n    throw new Error(\"Assertion failure - plugins and presets exist\");\n  }\n\n  const presetContext = Object.assign({}, context, {\n    targets: options.targets\n  });\n\n  const toDescriptor = item => {\n    const desc = (0, _item.getItemDescriptor)(item);\n\n    if (!desc) {\n      throw new Error(\"Assertion failure - must be config item\");\n    }\n\n    return desc;\n  };\n\n  const presetsDescriptors = presets.map(toDescriptor);\n  const initialPluginsDescriptors = plugins.map(toDescriptor);\n  const pluginDescriptorsByPass = [[]];\n  const passes = [];\n  const externalDependencies = [];\n  const ignored = yield* enhanceError(context, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {\n    const presets = [];\n\n    for (let i = 0; i < rawPresets.length; i++) {\n      const descriptor = rawPresets[i];\n\n      if (descriptor.options !== false) {\n        try {\n          var preset = yield* loadPresetDescriptor(descriptor, presetContext);\n        } catch (e) {\n          if (e.code === \"BABEL_UNKNOWN_OPTION\") {\n            (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, \"preset\", e);\n          }\n\n          throw e;\n        }\n\n        externalDependencies.push(preset.externalDependencies);\n\n        if (descriptor.ownPass) {\n          presets.push({\n            preset: preset.chain,\n            pass: []\n          });\n        } else {\n          presets.unshift({\n            preset: preset.chain,\n            pass: pluginDescriptorsPass\n          });\n        }\n      }\n    }\n\n    if (presets.length > 0) {\n      pluginDescriptorsByPass.splice(1, 0, ...presets.map(o => o.pass).filter(p => p !== pluginDescriptorsPass));\n\n      for (const {\n        preset,\n        pass\n      } of presets) {\n        if (!preset) return true;\n        pass.push(...preset.plugins);\n        const ignored = yield* recursePresetDescriptors(preset.presets, pass);\n        if (ignored) return true;\n        preset.options.forEach(opts => {\n          (0, _util.mergeOptions)(optionDefaults, opts);\n        });\n      }\n    }\n  })(presetsDescriptors, pluginDescriptorsByPass[0]);\n  if (ignored) return null;\n  const opts = optionDefaults;\n  (0, _util.mergeOptions)(opts, options);\n  const pluginContext = Object.assign({}, presetContext, {\n    assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {}\n  });\n  yield* enhanceError(context, function* loadPluginDescriptors() {\n    pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);\n\n    for (const descs of pluginDescriptorsByPass) {\n      const pass = [];\n      passes.push(pass);\n\n      for (let i = 0; i < descs.length; i++) {\n        const descriptor = descs[i];\n\n        if (descriptor.options !== false) {\n          try {\n            var plugin = yield* loadPluginDescriptor(descriptor, pluginContext);\n          } catch (e) {\n            if (e.code === \"BABEL_UNKNOWN_PLUGIN_PROPERTY\") {\n              (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, \"plugin\", e);\n            }\n\n            throw e;\n          }\n\n          pass.push(plugin);\n          externalDependencies.push(plugin.externalDependencies);\n        }\n      }\n    }\n  })();\n  opts.plugins = passes[0];\n  opts.presets = passes.slice(1).filter(plugins => plugins.length > 0).map(plugins => ({\n    plugins\n  }));\n  opts.passPerPreset = opts.presets.length > 0;\n  return {\n    options: opts,\n    passes: passes,\n    externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n  };\n});\n\nexports.default = _default;\n\nfunction enhanceError(context, fn) {\n  return function* (arg1, arg2) {\n    try {\n      return yield* fn(arg1, arg2);\n    } catch (e) {\n      if (!/^\\[BABEL\\]/.test(e.message)) {\n        var _context$filename;\n\n        e.message = `[BABEL] ${(_context$filename = context.filename) != null ? _context$filename : \"unknown file\"}: ${e.message}`;\n      }\n\n      throw e;\n    }\n  };\n}\n\nconst makeDescriptorLoader = apiFactory => (0, _caching.makeWeakCache)(function* (_ref, cache) {\n  let {\n    value,\n    options,\n    dirname,\n    alias\n  } = _ref;\n  if (options === false) throw new Error(\"Assertion failure\");\n  options = options || {};\n  const externalDependencies = [];\n  let item = value;\n\n  if (typeof value === \"function\") {\n    const factory = (0, _async.maybeAsync)(value, `You appear to be using an async plugin/preset, but Babel has been called synchronously`);\n    const api = Object.assign({}, context, apiFactory(cache, externalDependencies));\n\n    try {\n      item = yield* factory(api, options, dirname);\n    } catch (e) {\n      if (alias) {\n        e.message += ` (While processing: ${JSON.stringify(alias)})`;\n      }\n\n      throw e;\n    }\n  }\n\n  if (!item || typeof item !== \"object\") {\n    throw new Error(\"Plugin/Preset did not return an object.\");\n  }\n\n  if ((0, _async.isThenable)(item)) {\n    yield* [];\n    throw new Error(`You appear to be using a promise as a plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version. ` + `As an alternative, you can prefix the promise with \"await\". ` + `(While processing: ${JSON.stringify(alias)})`);\n  }\n\n  if (externalDependencies.length > 0 && (!cache.configured() || cache.mode() === \"forever\")) {\n    let error = `A plugin/preset has external untracked dependencies ` + `(${externalDependencies[0]}), but the cache `;\n\n    if (!cache.configured()) {\n      error += `has not been configured to be invalidated when the external dependencies change. `;\n    } else {\n      error += ` has been configured to never be invalidated. `;\n    }\n\n    error += `Plugins/presets should configure their cache to be invalidated when the external ` + `dependencies change, for example using \\`api.cache.invalidate(() => ` + `statSync(filepath).mtimeMs)\\` or \\`api.cache.never()\\`\\n` + `(While processing: ${JSON.stringify(alias)})`;\n    throw new Error(error);\n  }\n\n  return {\n    value: item,\n    options,\n    dirname,\n    alias,\n    externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n  };\n});\n\nconst pluginDescriptorLoader = makeDescriptorLoader(_configApi.makePluginAPI);\nconst presetDescriptorLoader = makeDescriptorLoader(_configApi.makePresetAPI);\n\nfunction* loadPluginDescriptor(descriptor, context) {\n  if (descriptor.value instanceof _plugin.default) {\n    if (descriptor.options) {\n      throw new Error(\"Passed options to an existing Plugin instance will not work.\");\n    }\n\n    return descriptor.value;\n  }\n\n  return yield* instantiatePlugin(yield* pluginDescriptorLoader(descriptor, context), context);\n}\n\nconst instantiatePlugin = (0, _caching.makeWeakCache)(function* (_ref2, cache) {\n  let {\n    value,\n    options,\n    dirname,\n    alias,\n    externalDependencies\n  } = _ref2;\n  const pluginObj = (0, _plugins.validatePluginObject)(value);\n  const plugin = Object.assign({}, pluginObj);\n\n  if (plugin.visitor) {\n    plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));\n  }\n\n  if (plugin.inherits) {\n    const inheritsDescriptor = {\n      name: undefined,\n      alias: `${alias}$inherits`,\n      value: plugin.inherits,\n      options,\n      dirname\n    };\n    const inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, run => {\n      return cache.invalidate(data => run(inheritsDescriptor, data));\n    });\n    plugin.pre = chain(inherits.pre, plugin.pre);\n    plugin.post = chain(inherits.post, plugin.post);\n    plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);\n    plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);\n\n    if (inherits.externalDependencies.length > 0) {\n      if (externalDependencies.length === 0) {\n        externalDependencies = inherits.externalDependencies;\n      } else {\n        externalDependencies = (0, _deepArray.finalize)([externalDependencies, inherits.externalDependencies]);\n      }\n    }\n  }\n\n  return new _plugin.default(plugin, options, alias, externalDependencies);\n});\n\nconst validateIfOptionNeedsFilename = (options, descriptor) => {\n  if (options.test || options.include || options.exclude) {\n    const formattedPresetName = descriptor.name ? `\"${descriptor.name}\"` : \"/* your preset */\";\n    throw new _configError.default([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`, `\\`\\`\\``, `babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`, `\\`\\`\\``, `See https://babeljs.io/docs/en/options#filename for more information.`].join(\"\\n\"));\n  }\n};\n\nconst validatePreset = (preset, context, descriptor) => {\n  if (!context.filename) {\n    const {\n      options\n    } = preset;\n    validateIfOptionNeedsFilename(options, descriptor);\n\n    if (options.overrides) {\n      options.overrides.forEach(overrideOptions => validateIfOptionNeedsFilename(overrideOptions, descriptor));\n    }\n  }\n};\n\nfunction* loadPresetDescriptor(descriptor, context) {\n  const preset = instantiatePreset(yield* presetDescriptorLoader(descriptor, context));\n  validatePreset(preset, context, descriptor);\n  return {\n    chain: yield* (0, _configChain.buildPresetChain)(preset, context),\n    externalDependencies: preset.externalDependencies\n  };\n}\n\nconst instantiatePreset = (0, _caching.makeWeakCacheSync)(_ref3 => {\n  let {\n    value,\n    dirname,\n    alias,\n    externalDependencies\n  } = _ref3;\n  return {\n    options: (0, _options.validate)(\"preset\", value),\n    alias,\n    dirname,\n    externalDependencies\n  };\n});\n\nfunction chain(a, b) {\n  const fns = [a, b].filter(Boolean);\n  if (fns.length <= 1) return fns[0];\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    for (const fn of fns) {\n      fn.apply(this, args);\n    }\n  };\n}\n\n0 && 0;","map":{"version":3,"mappings":"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","names":["_gensync","_traverse","gensync","loadFullConfig","inputOpts","result","options","context","fileHandling","optionDefaults","plugins","presets","Error","presetContext","targets","toDescriptor","item","desc","presetsDescriptors","map","initialPluginsDescriptors","pluginDescriptorsByPass","passes","externalDependencies","ignored","enhanceError","recursePresetDescriptors","rawPresets","pluginDescriptorsPass","i","length","descriptor","preset","loadPresetDescriptor","e","code","push","ownPass","chain","pass","unshift","splice","o","filter","p","forEach","opts","pluginContext","assumptions","loadPluginDescriptors","descs","plugin","loadPluginDescriptor","slice","passPerPreset","fn","arg1","arg2","test","message","filename","makeDescriptorLoader","apiFactory","cache","value","dirname","alias","factory","api","JSON","stringify","configured","mode","error","pluginDescriptorLoader","makePluginAPI","presetDescriptorLoader","makePresetAPI","Plugin","instantiatePlugin","pluginObj","visitor","traverse","explode","inherits","inheritsDescriptor","name","undefined","run","invalidate","data","pre","post","manipulateOptions","visitors","merge","validateIfOptionNeedsFilename","include","exclude","formattedPresetName","ConfigError","join","validatePreset","overrides","overrideOptions","instantiatePreset","a","b","fns","Boolean","args","apply"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\core\\src\\config\\full.ts"],"sourcesContent":["import gensync, { type Handler } from \"gensync\";\nimport { forwardAsync, maybeAsync, isThenable } from \"../gensync-utils/async\";\n\nimport { mergeOptions } from \"./util\";\nimport * as context from \"../index\";\nimport Plugin from \"./plugin\";\nimport { getItemDescriptor } from \"./item\";\nimport { buildPresetChain } from \"./config-chain\";\nimport { finalize as freezeDeepArray } from \"./helpers/deep-array\";\nimport type { DeepArray, ReadonlyDeepArray } from \"./helpers/deep-array\";\nimport type {\n  ConfigContext,\n  ConfigChain,\n  PresetInstance,\n} from \"./config-chain\";\nimport type { UnloadedDescriptor } from \"./config-descriptors\";\nimport traverse from \"@babel/traverse\";\nimport { makeWeakCache, makeWeakCacheSync } from \"./caching\";\nimport type { CacheConfigurator } from \"./caching\";\nimport {\n  validate,\n  checkNoUnwrappedItemOptionPairs,\n} from \"./validation/options\";\nimport type { PluginItem } from \"./validation/options\";\nimport { validatePluginObject } from \"./validation/plugins\";\nimport { makePluginAPI, makePresetAPI } from \"./helpers/config-api\";\nimport type { PluginAPI, PresetAPI } from \"./helpers/config-api\";\n\nimport loadPrivatePartialConfig from \"./partial\";\nimport type { ValidatedOptions } from \"./validation/options\";\n\nimport type * as Context from \"./cache-contexts\";\nimport ConfigError from \"../errors/config-error\";\n\ntype LoadedDescriptor = {\n  value: {};\n  options: {};\n  dirname: string;\n  alias: string;\n  externalDependencies: ReadonlyDeepArray<string>;\n};\n\nexport type { InputOptions } from \"./validation/options\";\n\nexport type ResolvedConfig = {\n  options: any;\n  passes: PluginPasses;\n  externalDependencies: ReadonlyDeepArray<string>;\n};\n\nexport type { Plugin };\nexport type PluginPassList = Array<Plugin>;\nexport type PluginPasses = Array<PluginPassList>;\n\nexport default gensync(function* loadFullConfig(\n  inputOpts: unknown,\n): Handler<ResolvedConfig | null> {\n  const result = yield* loadPrivatePartialConfig(inputOpts);\n  if (!result) {\n    return null;\n  }\n  const { options, context, fileHandling } = result;\n\n  if (fileHandling === \"ignored\") {\n    return null;\n  }\n\n  const optionDefaults = {};\n\n  const { plugins, presets } = options;\n\n  if (!plugins || !presets) {\n    throw new Error(\"Assertion failure - plugins and presets exist\");\n  }\n\n  const presetContext: Context.FullPreset = {\n    ...context,\n    targets: options.targets,\n  };\n\n  const toDescriptor = (item: PluginItem) => {\n    const desc = getItemDescriptor(item);\n    if (!desc) {\n      throw new Error(\"Assertion failure - must be config item\");\n    }\n\n    return desc;\n  };\n\n  const presetsDescriptors = presets.map(toDescriptor);\n  const initialPluginsDescriptors = plugins.map(toDescriptor);\n  const pluginDescriptorsByPass: Array<Array<UnloadedDescriptor>> = [[]];\n  const passes: Array<Array<Plugin>> = [];\n\n  const externalDependencies: DeepArray<string> = [];\n\n  const ignored = yield* enhanceError(\n    context,\n    function* recursePresetDescriptors(\n      rawPresets: Array<UnloadedDescriptor>,\n      pluginDescriptorsPass: Array<UnloadedDescriptor>,\n    ): Handler<true | void> {\n      const presets: Array<{\n        preset: ConfigChain | null;\n        pass: Array<UnloadedDescriptor>;\n      }> = [];\n\n      for (let i = 0; i < rawPresets.length; i++) {\n        const descriptor = rawPresets[i];\n        if (descriptor.options !== false) {\n          try {\n            // eslint-disable-next-line no-var\n            var preset = yield* loadPresetDescriptor(descriptor, presetContext);\n          } catch (e) {\n            if (e.code === \"BABEL_UNKNOWN_OPTION\") {\n              checkNoUnwrappedItemOptionPairs(rawPresets, i, \"preset\", e);\n            }\n            throw e;\n          }\n\n          externalDependencies.push(preset.externalDependencies);\n\n          // Presets normally run in reverse order, but if they\n          // have their own pass they run after the presets\n          // in the previous pass.\n          if (descriptor.ownPass) {\n            presets.push({ preset: preset.chain, pass: [] });\n          } else {\n            presets.unshift({\n              preset: preset.chain,\n              pass: pluginDescriptorsPass,\n            });\n          }\n        }\n      }\n\n      // resolve presets\n      if (presets.length > 0) {\n        // The passes are created in the same order as the preset list, but are inserted before any\n        // existing additional passes.\n        pluginDescriptorsByPass.splice(\n          1,\n          0,\n          ...presets.map(o => o.pass).filter(p => p !== pluginDescriptorsPass),\n        );\n\n        for (const { preset, pass } of presets) {\n          if (!preset) return true;\n\n          pass.push(...preset.plugins);\n\n          const ignored = yield* recursePresetDescriptors(preset.presets, pass);\n          if (ignored) return true;\n\n          preset.options.forEach(opts => {\n            mergeOptions(optionDefaults, opts);\n          });\n        }\n      }\n    },\n  )(presetsDescriptors, pluginDescriptorsByPass[0]);\n\n  if (ignored) return null;\n\n  const opts: any = optionDefaults;\n  mergeOptions(opts, options);\n\n  const pluginContext: Context.FullPlugin = {\n    ...presetContext,\n    assumptions: opts.assumptions ?? {},\n  };\n\n  yield* enhanceError(context, function* loadPluginDescriptors() {\n    pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);\n\n    for (const descs of pluginDescriptorsByPass) {\n      const pass: Plugin[] = [];\n      passes.push(pass);\n\n      for (let i = 0; i < descs.length; i++) {\n        const descriptor: UnloadedDescriptor = descs[i];\n        if (descriptor.options !== false) {\n          try {\n            // eslint-disable-next-line no-var\n            var plugin = yield* loadPluginDescriptor(descriptor, pluginContext);\n          } catch (e) {\n            if (e.code === \"BABEL_UNKNOWN_PLUGIN_PROPERTY\") {\n              // print special message for `plugins: [\"@babel/foo\", { foo: \"option\" }]`\n              checkNoUnwrappedItemOptionPairs(descs, i, \"plugin\", e);\n            }\n            throw e;\n          }\n          pass.push(plugin);\n\n          externalDependencies.push(plugin.externalDependencies);\n        }\n      }\n    }\n  })();\n\n  opts.plugins = passes[0];\n  opts.presets = passes\n    .slice(1)\n    .filter(plugins => plugins.length > 0)\n    .map(plugins => ({ plugins }));\n  opts.passPerPreset = opts.presets.length > 0;\n\n  return {\n    options: opts,\n    passes: passes,\n    externalDependencies: freezeDeepArray(externalDependencies),\n  };\n});\n\nfunction enhanceError<T extends Function>(context: ConfigContext, fn: T): T {\n  return function* (arg1: unknown, arg2: unknown) {\n    try {\n      return yield* fn(arg1, arg2);\n    } catch (e) {\n      // There are a few case where thrown errors will try to annotate themselves multiple times, so\n      // to keep things simple we just bail out if re-wrapping the message.\n      if (!/^\\[BABEL\\]/.test(e.message)) {\n        e.message = `[BABEL] ${context.filename ?? \"unknown file\"}: ${\n          e.message\n        }`;\n      }\n\n      throw e;\n    }\n  } as any;\n}\n\n/**\n * Load a generic plugin/preset from the given descriptor loaded from the config object.\n */\nconst makeDescriptorLoader = <Context, API>(\n  apiFactory: (\n    cache: CacheConfigurator<Context>,\n    externalDependencies: Array<string>,\n  ) => API,\n) =>\n  makeWeakCache(function* (\n    { value, options, dirname, alias }: UnloadedDescriptor,\n    cache: CacheConfigurator<Context>,\n  ): Handler<LoadedDescriptor> {\n    // Disabled presets should already have been filtered out\n    if (options === false) throw new Error(\"Assertion failure\");\n\n    options = options || {};\n\n    const externalDependencies: Array<string> = [];\n\n    let item = value;\n    if (typeof value === \"function\") {\n      const factory = maybeAsync(\n        value,\n        `You appear to be using an async plugin/preset, but Babel has been called synchronously`,\n      );\n\n      const api = {\n        ...context,\n        ...apiFactory(cache, externalDependencies),\n      };\n      try {\n        item = yield* factory(api, options, dirname);\n      } catch (e) {\n        if (alias) {\n          e.message += ` (While processing: ${JSON.stringify(alias)})`;\n        }\n        throw e;\n      }\n    }\n\n    if (!item || typeof item !== \"object\") {\n      throw new Error(\"Plugin/Preset did not return an object.\");\n    }\n\n    if (isThenable(item)) {\n      // @ts-expect-error - if we want to support async plugins\n      yield* [];\n\n      throw new Error(\n        `You appear to be using a promise as a plugin, ` +\n          `which your current version of Babel does not support. ` +\n          `If you're using a published plugin, ` +\n          `you may need to upgrade your @babel/core version. ` +\n          `As an alternative, you can prefix the promise with \"await\". ` +\n          `(While processing: ${JSON.stringify(alias)})`,\n      );\n    }\n\n    if (\n      externalDependencies.length > 0 &&\n      (!cache.configured() || cache.mode() === \"forever\")\n    ) {\n      let error =\n        `A plugin/preset has external untracked dependencies ` +\n        `(${externalDependencies[0]}), but the cache `;\n      if (!cache.configured()) {\n        error += `has not been configured to be invalidated when the external dependencies change. `;\n      } else {\n        error += ` has been configured to never be invalidated. `;\n      }\n      error +=\n        `Plugins/presets should configure their cache to be invalidated when the external ` +\n        `dependencies change, for example using \\`api.cache.invalidate(() => ` +\n        `statSync(filepath).mtimeMs)\\` or \\`api.cache.never()\\`\\n` +\n        `(While processing: ${JSON.stringify(alias)})`;\n\n      throw new Error(error);\n    }\n\n    return {\n      value: item,\n      options,\n      dirname,\n      alias,\n      externalDependencies: freezeDeepArray(externalDependencies),\n    };\n  });\n\nconst pluginDescriptorLoader = makeDescriptorLoader<\n  Context.SimplePlugin,\n  PluginAPI\n>(makePluginAPI);\nconst presetDescriptorLoader = makeDescriptorLoader<\n  Context.SimplePreset,\n  PresetAPI\n>(makePresetAPI);\n\n/**\n * Instantiate a plugin for the given descriptor, returning the plugin/options pair.\n */\nfunction* loadPluginDescriptor(\n  descriptor: UnloadedDescriptor,\n  context: Context.SimplePlugin,\n): Handler<Plugin> {\n  if (descriptor.value instanceof Plugin) {\n    if (descriptor.options) {\n      throw new Error(\n        \"Passed options to an existing Plugin instance will not work.\",\n      );\n    }\n\n    return descriptor.value;\n  }\n\n  return yield* instantiatePlugin(\n    yield* pluginDescriptorLoader(descriptor, context),\n    context,\n  );\n}\n\nconst instantiatePlugin = makeWeakCache(function* (\n  { value, options, dirname, alias, externalDependencies }: LoadedDescriptor,\n  cache: CacheConfigurator<Context.SimplePlugin>,\n): Handler<Plugin> {\n  const pluginObj = validatePluginObject(value);\n\n  const plugin = {\n    ...pluginObj,\n  };\n  if (plugin.visitor) {\n    plugin.visitor = traverse.explode({\n      ...plugin.visitor,\n    });\n  }\n\n  if (plugin.inherits) {\n    const inheritsDescriptor: UnloadedDescriptor = {\n      name: undefined,\n      alias: `${alias}$inherits`,\n      value: plugin.inherits,\n      options,\n      dirname,\n    };\n\n    const inherits = yield* forwardAsync(loadPluginDescriptor, run => {\n      // If the inherited plugin changes, reinstantiate this plugin.\n      return cache.invalidate(data => run(inheritsDescriptor, data));\n    });\n\n    plugin.pre = chain(inherits.pre, plugin.pre);\n    plugin.post = chain(inherits.post, plugin.post);\n    plugin.manipulateOptions = chain(\n      inherits.manipulateOptions,\n      plugin.manipulateOptions,\n    );\n    plugin.visitor = traverse.visitors.merge([\n      inherits.visitor || {},\n      plugin.visitor || {},\n    ]);\n\n    if (inherits.externalDependencies.length > 0) {\n      if (externalDependencies.length === 0) {\n        externalDependencies = inherits.externalDependencies;\n      } else {\n        externalDependencies = freezeDeepArray([\n          externalDependencies,\n          inherits.externalDependencies,\n        ]);\n      }\n    }\n  }\n\n  return new Plugin(plugin, options, alias, externalDependencies);\n});\n\nconst validateIfOptionNeedsFilename = (\n  options: ValidatedOptions,\n  descriptor: UnloadedDescriptor,\n): void => {\n  if (options.test || options.include || options.exclude) {\n    const formattedPresetName = descriptor.name\n      ? `\"${descriptor.name}\"`\n      : \"/* your preset */\";\n    throw new ConfigError(\n      [\n        `Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`,\n        `\\`\\`\\``,\n        `babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`,\n        `\\`\\`\\``,\n        `See https://babeljs.io/docs/en/options#filename for more information.`,\n      ].join(\"\\n\"),\n    );\n  }\n};\n\nconst validatePreset = (\n  preset: PresetInstance,\n  context: ConfigContext,\n  descriptor: UnloadedDescriptor,\n): void => {\n  if (!context.filename) {\n    const { options } = preset;\n    validateIfOptionNeedsFilename(options, descriptor);\n    if (options.overrides) {\n      options.overrides.forEach(overrideOptions =>\n        validateIfOptionNeedsFilename(overrideOptions, descriptor),\n      );\n    }\n  }\n};\n\n/**\n * Generate a config object that will act as the root of a new nested config.\n */\nfunction* loadPresetDescriptor(\n  descriptor: UnloadedDescriptor,\n  context: Context.FullPreset,\n): Handler<{\n  chain: ConfigChain | null;\n  externalDependencies: ReadonlyDeepArray<string>;\n}> {\n  const preset = instantiatePreset(\n    yield* presetDescriptorLoader(descriptor, context),\n  );\n  validatePreset(preset, context, descriptor);\n  return {\n    chain: yield* buildPresetChain(preset, context),\n    externalDependencies: preset.externalDependencies,\n  };\n}\n\nconst instantiatePreset = makeWeakCacheSync(\n  ({\n    value,\n    dirname,\n    alias,\n    externalDependencies,\n  }: LoadedDescriptor): PresetInstance => {\n    return {\n      options: validate(\"preset\", value),\n      alias,\n      dirname,\n      externalDependencies,\n    };\n  },\n);\n\nfunction chain<Args extends any[]>(\n  a: undefined | ((...args: Args) => void),\n  b: undefined | ((...args: Args) => void),\n) {\n  const fns = [a, b].filter(Boolean);\n  if (fns.length <= 1) return fns[0];\n\n  return function (this: unknown, ...args: unknown[]) {\n    for (const fn of fns) {\n      fn.apply(this, args);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"script"}