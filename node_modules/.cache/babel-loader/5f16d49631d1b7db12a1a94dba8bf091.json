{"ast":null,"code":"/**\n * @fileoverview Common used propTypes detection functionality.\n */\n'use strict';\n\nconst astUtil = require('./ast');\n\nconst componentUtil = require('./componentUtil');\n\nconst testReactVersion = require('./version').testReactVersion;\n\nconst ast = require('./ast'); // ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\n\nconst LIFE_CYCLE_METHODS = ['componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate'];\nconst ASYNC_SAFE_LIFE_CYCLE_METHODS = ['getDerivedStateFromProps', 'getSnapshotBeforeUpdate', 'UNSAFE_componentWillReceiveProps', 'UNSAFE_componentWillUpdate'];\n\nfunction createPropVariables() {\n  /** @type {Map<string, string[]>} Maps the variable to its definition. `props.a.b` is stored as `['a', 'b']` */\n  let propVariables = new Map();\n  let hasBeenWritten = false;\n  const stack = [{\n    propVariables,\n    hasBeenWritten\n  }];\n  return {\n    pushScope() {\n      // popVariables is not copied until first write.\n      stack.push({\n        propVariables,\n        hasBeenWritten: false\n      });\n    },\n\n    popScope() {\n      stack.pop();\n      propVariables = stack[stack.length - 1].propVariables;\n      hasBeenWritten = stack[stack.length - 1].hasBeenWritten;\n    },\n\n    /**\n     * Add a variable name to the current scope\n     * @param {string} name\n     * @param {string[]} allNames Example: `props.a.b` should be formatted as `['a', 'b']`\n     * @returns {Map<string, string[]>}\n     */\n    set(name, allNames) {\n      if (!hasBeenWritten) {\n        // copy on write\n        propVariables = new Map(propVariables);\n        Object.assign(stack[stack.length - 1], {\n          propVariables,\n          hasBeenWritten: true\n        });\n        stack[stack.length - 1].hasBeenWritten = true;\n      }\n\n      return propVariables.set(name, allNames);\n    },\n\n    /**\n     * Get the definition of a variable.\n     * @param {string} name\n     * @returns {string[]} Example: `props.a.b` is represented by `['a', 'b']`\n     */\n    get(name) {\n      return propVariables.get(name);\n    }\n\n  };\n}\n/**\n * Checks if the string is one of `props`, `nextProps`, or `prevProps`\n * @param {string} name The AST node being checked.\n * @returns {Boolean} True if the prop name matches\n */\n\n\nfunction isCommonVariableNameForProps(name) {\n  return name === 'props' || name === 'nextProps' || name === 'prevProps';\n}\n/**\n * Checks if the component must be validated\n * @param {Object} component The component to process\n * @returns {Boolean} True if the component must be validated, false if not.\n */\n\n\nfunction mustBeValidated(component) {\n  return !!(component && !component.ignorePropsValidation);\n}\n/**\n * Check if we are in a lifecycle method\n * @param {object} context\n * @param {boolean} checkAsyncSafeLifeCycles\n * @return {boolean} true if we are in a class constructor, false if not\n */\n\n\nfunction inLifeCycleMethod(context, checkAsyncSafeLifeCycles) {\n  let scope = context.getScope();\n\n  while (scope) {\n    if (scope.block && scope.block.parent && scope.block.parent.key) {\n      const name = scope.block.parent.key.name;\n\n      if (LIFE_CYCLE_METHODS.indexOf(name) >= 0) {\n        return true;\n      }\n\n      if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(name) >= 0) {\n        return true;\n      }\n    }\n\n    scope = scope.upper;\n  }\n\n  return false;\n}\n/**\n * Returns true if the given node is a React Component lifecycle method\n * @param {ASTNode} node The AST node being checked.\n * @param {boolean} checkAsyncSafeLifeCycles\n * @return {Boolean} True if the node is a lifecycle method\n */\n\n\nfunction isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles) {\n  const nodeKeyName = (node.key ||\n  /** @type {ASTNode} */\n  {}).name;\n\n  if (node.kind === 'constructor') {\n    return true;\n  }\n\n  if (LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {\n    return true;\n  }\n\n  if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Returns true if the given node is inside a React Component lifecycle\n * method.\n * @param {ASTNode} node The AST node being checked.\n * @param {boolean} checkAsyncSafeLifeCycles\n * @return {Boolean} True if the node is inside a lifecycle method\n */\n\n\nfunction isInLifeCycleMethod(node, checkAsyncSafeLifeCycles) {\n  if ((node.type === 'MethodDefinition' || node.type === 'Property') && isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles)) {\n    return true;\n  }\n\n  if (node.parent) {\n    return isInLifeCycleMethod(node.parent, checkAsyncSafeLifeCycles);\n  }\n\n  return false;\n}\n/**\n * Check if a function node is a setState updater\n * @param {ASTNode} node a function node\n * @return {boolean}\n */\n\n\nfunction isSetStateUpdater(node) {\n  const unwrappedParentCalleeNode = node.parent && node.parent.type === 'CallExpression' && ast.unwrapTSAsExpression(node.parent.callee);\n  return unwrappedParentCalleeNode && unwrappedParentCalleeNode.property && unwrappedParentCalleeNode.property.name === 'setState' // Make sure we are in the updater not the callback\n  && node.parent.arguments[0] === node;\n}\n\nfunction isPropArgumentInSetStateUpdater(context, name) {\n  if (typeof name !== 'string') {\n    return;\n  }\n\n  let scope = context.getScope();\n\n  while (scope) {\n    const unwrappedParentCalleeNode = scope.block && scope.block.parent && scope.block.parent.type === 'CallExpression' && ast.unwrapTSAsExpression(scope.block.parent.callee);\n\n    if (unwrappedParentCalleeNode && unwrappedParentCalleeNode.property && unwrappedParentCalleeNode.property.name === 'setState' // Make sure we are in the updater not the callback\n    && scope.block.parent.arguments[0].range[0] === scope.block.range[0] && scope.block.parent.arguments[0].params && scope.block.parent.arguments[0].params.length > 1) {\n      return scope.block.parent.arguments[0].params[1].name === name;\n    }\n\n    scope = scope.upper;\n  }\n\n  return false;\n}\n/**\n * @param {Context} context\n * @returns {boolean}\n */\n\n\nfunction isInClassComponent(context) {\n  return !!(componentUtil.getParentES6Component(context) || componentUtil.getParentES5Component(context));\n}\n/**\n * Checks if the node is `this.props`\n * @param {ASTNode|undefined} node\n * @returns {boolean}\n */\n\n\nfunction isThisDotProps(node) {\n  return !!node && node.type === 'MemberExpression' && ast.unwrapTSAsExpression(node.object).type === 'ThisExpression' && node.property.name === 'props';\n}\n/**\n * Checks if the prop has spread operator.\n * @param {object} context\n * @param {ASTNode} node The AST node being marked.\n * @returns {Boolean} True if the prop has spread operator, false if not.\n */\n\n\nfunction hasSpreadOperator(context, node) {\n  const tokens = context.getSourceCode().getTokens(node);\n  return tokens.length && tokens[0].value === '...';\n}\n/**\n * Checks if the node is a propTypes usage of the form `this.props.*`, `props.*`, `prevProps.*`, or `nextProps.*`.\n * @param {ASTNode} node\n * @param {Context} context\n * @param {Object} utils\n * @param {boolean} checkAsyncSafeLifeCycles\n * @returns {boolean}\n */\n\n\nfunction isPropTypesUsageByMemberExpression(node, context, utils, checkAsyncSafeLifeCycles) {\n  const unwrappedObjectNode = ast.unwrapTSAsExpression(node.object);\n\n  if (isInClassComponent(context)) {\n    // this.props.*\n    if (isThisDotProps(unwrappedObjectNode)) {\n      return true;\n    } // props.* or prevProps.* or nextProps.*\n\n\n    if (isCommonVariableNameForProps(unwrappedObjectNode.name) && (inLifeCycleMethod(context, checkAsyncSafeLifeCycles) || astUtil.inConstructor(context))) {\n      return true;\n    } // this.setState((_, props) => props.*))\n\n\n    if (isPropArgumentInSetStateUpdater(context, unwrappedObjectNode.name)) {\n      return true;\n    }\n\n    return false;\n  } // props.* in function component\n\n\n  return unwrappedObjectNode.name === 'props' && !ast.isAssignmentLHS(node);\n}\n/**\n * Retrieve the name of a property node\n * @param {ASTNode} node The AST node with the property.\n * @param {Context} context\n * @param {Object} utils\n * @param {boolean} checkAsyncSafeLifeCycles\n * @return {string|undefined} the name of the property or undefined if not found\n */\n\n\nfunction getPropertyName(node, context, utils, checkAsyncSafeLifeCycles) {\n  const property = node.property;\n\n  if (property) {\n    switch (property.type) {\n      case 'Identifier':\n        if (node.computed) {\n          return '__COMPUTED_PROP__';\n        }\n\n        return property.name;\n\n      case 'MemberExpression':\n        return;\n\n      case 'Literal':\n        // Accept computed properties that are literal strings\n        if (typeof property.value === 'string') {\n          return property.value;\n        } // Accept number as well but only accept props[123]\n\n\n        if (typeof property.value === 'number') {\n          if (isPropTypesUsageByMemberExpression(node, context, utils, checkAsyncSafeLifeCycles)) {\n            return property.raw;\n          }\n        }\n\n      // falls through\n\n      default:\n        if (node.computed) {\n          return '__COMPUTED_PROP__';\n        }\n\n        break;\n    }\n  }\n}\n\nmodule.exports = function usedPropTypesInstructions(context, components, utils) {\n  const checkAsyncSafeLifeCycles = testReactVersion(context, '>= 16.3.0');\n  const propVariables = createPropVariables();\n  const pushScope = propVariables.pushScope;\n  const popScope = propVariables.popScope;\n  /**\n   * Mark a prop type as used\n   * @param {ASTNode} node The AST node being marked.\n   * @param {string[]} [parentNames]\n   */\n\n  function markPropTypesAsUsed(node, parentNames) {\n    parentNames = parentNames || [];\n    let type;\n    let name;\n    let allNames;\n    let properties;\n\n    switch (node.type) {\n      case 'OptionalMemberExpression':\n      case 'MemberExpression':\n        name = getPropertyName(node, context, utils, checkAsyncSafeLifeCycles);\n\n        if (name) {\n          allNames = parentNames.concat(name);\n\n          if ( // Match props.foo.bar, don't match bar[props.foo]\n          node.parent.type === 'MemberExpression' && node.parent.object === node) {\n            markPropTypesAsUsed(node.parent, allNames);\n          } // Handle the destructuring part of `const {foo} = props.a.b`\n\n\n          if (node.parent.type === 'VariableDeclarator' && node.parent.id.type === 'ObjectPattern') {\n            node.parent.id.parent = node.parent; // patch for bug in eslint@4 in which ObjectPattern has no parent\n\n            markPropTypesAsUsed(node.parent.id, allNames);\n          } // const a = props.a\n\n\n          if (node.parent.type === 'VariableDeclarator' && node.parent.id.type === 'Identifier') {\n            propVariables.set(node.parent.id.name, allNames);\n          } // Do not mark computed props as used.\n\n\n          type = name !== '__COMPUTED_PROP__' ? 'direct' : null;\n        }\n\n        break;\n\n      case 'ArrowFunctionExpression':\n      case 'FunctionDeclaration':\n      case 'FunctionExpression':\n        {\n          if (node.params.length === 0) {\n            break;\n          }\n\n          type = 'destructuring';\n          const propParam = isSetStateUpdater(node) ? node.params[1] : node.params[0];\n          properties = propParam.type === 'AssignmentPattern' ? propParam.left.properties : propParam.properties;\n          break;\n        }\n\n      case 'ObjectPattern':\n        type = 'destructuring';\n        properties = node.properties;\n        break;\n\n      case 'TSEmptyBodyFunctionExpression':\n        break;\n\n      default:\n        throw new Error(`${node.type} ASTNodes are not handled by markPropTypesAsUsed`);\n    }\n\n    const component = components.get(utils.getParentComponent());\n    const usedPropTypes = component && component.usedPropTypes || [];\n    let ignoreUnusedPropTypesValidation = component && component.ignoreUnusedPropTypesValidation || false;\n\n    switch (type) {\n      case 'direct':\n        {\n          // Ignore Object methods\n          if (name in Object.prototype) {\n            break;\n          }\n\n          const reportedNode = node.property;\n          usedPropTypes.push({\n            name,\n            allNames,\n            node: reportedNode\n          });\n          break;\n        }\n\n      case 'destructuring':\n        {\n          for (let k = 0, l = (properties || []).length; k < l; k++) {\n            if (hasSpreadOperator(context, properties[k]) || properties[k].computed) {\n              ignoreUnusedPropTypesValidation = true;\n              break;\n            }\n\n            const propName = ast.getKeyValue(context, properties[k]);\n\n            if (!propName || properties[k].type !== 'Property') {\n              break;\n            }\n\n            usedPropTypes.push({\n              allNames: parentNames.concat([propName]),\n              name: propName,\n              node: properties[k]\n            });\n\n            if (properties[k].value.type === 'ObjectPattern') {\n              markPropTypesAsUsed(properties[k].value, parentNames.concat([propName]));\n            } else if (properties[k].value.type === 'Identifier') {\n              propVariables.set(properties[k].value.name, parentNames.concat(propName));\n            }\n          }\n\n          break;\n        }\n\n      default:\n        break;\n    }\n\n    components.set(component ? component.node : node, {\n      usedPropTypes,\n      ignoreUnusedPropTypesValidation\n    });\n  }\n  /**\n   * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n   *   FunctionDeclaration, or FunctionExpression\n   */\n\n\n  function markDestructuredFunctionArgumentsAsUsed(node) {\n    const param = node.params && isSetStateUpdater(node) ? node.params[1] : node.params[0];\n    const destructuring = param && (param.type === 'ObjectPattern' || param.type === 'AssignmentPattern' && param.left.type === 'ObjectPattern');\n\n    if (destructuring && (components.get(node) || components.get(node.parent))) {\n      markPropTypesAsUsed(node);\n    }\n  }\n\n  function handleSetStateUpdater(node) {\n    if (!node.params || node.params.length < 2 || !isSetStateUpdater(node)) {\n      return;\n    }\n\n    markPropTypesAsUsed(node);\n  }\n  /**\n   * Handle both stateless functions and setState updater functions.\n   * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n   *   FunctionDeclaration, or FunctionExpression\n   */\n\n\n  function handleFunctionLikeExpressions(node) {\n    pushScope();\n    handleSetStateUpdater(node);\n    markDestructuredFunctionArgumentsAsUsed(node);\n  }\n\n  function handleCustomValidators(component) {\n    const propTypes = component.declaredPropTypes;\n\n    if (!propTypes) {\n      return;\n    }\n\n    Object.keys(propTypes).forEach(key => {\n      const node = propTypes[key].node;\n\n      if (node && node.value && astUtil.isFunctionLikeExpression(node.value)) {\n        markPropTypesAsUsed(node.value);\n      }\n    });\n  }\n\n  return {\n    VariableDeclarator(node) {\n      const unwrappedInitNode = ast.unwrapTSAsExpression(node.init); // let props = this.props\n\n      if (isThisDotProps(unwrappedInitNode) && isInClassComponent(context) && node.id.type === 'Identifier') {\n        propVariables.set(node.id.name, []);\n      } // Only handles destructuring\n\n\n      if (node.id.type !== 'ObjectPattern' || !unwrappedInitNode) {\n        return;\n      } // let {props: {firstname}} = this\n\n\n      const propsProperty = node.id.properties.find(property => property.key && (property.key.name === 'props' || property.key.value === 'props'));\n\n      if (unwrappedInitNode.type === 'ThisExpression' && propsProperty && propsProperty.value.type === 'ObjectPattern') {\n        markPropTypesAsUsed(propsProperty.value);\n        return;\n      } // let {props} = this\n\n\n      if (unwrappedInitNode.type === 'ThisExpression' && propsProperty && propsProperty.value.name === 'props') {\n        propVariables.set('props', []);\n        return;\n      } // let {firstname} = props\n\n\n      if (isCommonVariableNameForProps(unwrappedInitNode.name) && (utils.getParentStatelessComponent() || isInLifeCycleMethod(node, checkAsyncSafeLifeCycles))) {\n        markPropTypesAsUsed(node.id);\n        return;\n      } // let {firstname} = this.props\n\n\n      if (isThisDotProps(unwrappedInitNode) && isInClassComponent(context)) {\n        markPropTypesAsUsed(node.id);\n        return;\n      } // let {firstname} = thing, where thing is defined by const thing = this.props.**.*\n\n\n      if (propVariables.get(unwrappedInitNode.name)) {\n        markPropTypesAsUsed(node.id, propVariables.get(unwrappedInitNode.name));\n      }\n    },\n\n    FunctionDeclaration: handleFunctionLikeExpressions,\n    ArrowFunctionExpression: handleFunctionLikeExpressions,\n    FunctionExpression: handleFunctionLikeExpressions,\n    'FunctionDeclaration:exit': popScope,\n    'ArrowFunctionExpression:exit': popScope,\n    'FunctionExpression:exit': popScope,\n\n    JSXSpreadAttribute(node) {\n      const component = components.get(utils.getParentComponent());\n      components.set(component ? component.node : node, {\n        ignoreUnusedPropTypesValidation: true\n      });\n    },\n\n    'MemberExpression, OptionalMemberExpression'(node) {\n      if (isPropTypesUsageByMemberExpression(node, context, utils, checkAsyncSafeLifeCycles)) {\n        markPropTypesAsUsed(node);\n        return;\n      }\n\n      const propVariable = propVariables.get(ast.unwrapTSAsExpression(node.object).name);\n\n      if (propVariable) {\n        markPropTypesAsUsed(node, propVariable);\n      }\n    },\n\n    ObjectPattern(node) {\n      // If the object pattern is a destructured props object in a lifecycle\n      // method -- mark it for used props.\n      if (isNodeALifeCycleMethod(node.parent.parent, checkAsyncSafeLifeCycles) && node.properties.length > 0) {\n        markPropTypesAsUsed(node.parent);\n      }\n    },\n\n    'Program:exit'() {\n      const list = components.list();\n      Object.keys(list).filter(component => mustBeValidated(list[component])).forEach(component => {\n        handleCustomValidators(list[component]);\n      });\n    }\n\n  };\n};","map":{"version":3,"names":["astUtil","require","componentUtil","testReactVersion","ast","LIFE_CYCLE_METHODS","ASYNC_SAFE_LIFE_CYCLE_METHODS","createPropVariables","propVariables","Map","hasBeenWritten","stack","pushScope","push","popScope","pop","length","set","name","allNames","Object","assign","get","isCommonVariableNameForProps","mustBeValidated","component","ignorePropsValidation","inLifeCycleMethod","context","checkAsyncSafeLifeCycles","scope","getScope","block","parent","key","indexOf","upper","isNodeALifeCycleMethod","node","nodeKeyName","kind","isInLifeCycleMethod","type","isSetStateUpdater","unwrappedParentCalleeNode","unwrapTSAsExpression","callee","property","arguments","isPropArgumentInSetStateUpdater","range","params","isInClassComponent","getParentES6Component","getParentES5Component","isThisDotProps","object","hasSpreadOperator","tokens","getSourceCode","getTokens","value","isPropTypesUsageByMemberExpression","utils","unwrappedObjectNode","inConstructor","isAssignmentLHS","getPropertyName","computed","raw","module","exports","usedPropTypesInstructions","components","markPropTypesAsUsed","parentNames","properties","concat","id","propParam","left","Error","getParentComponent","usedPropTypes","ignoreUnusedPropTypesValidation","prototype","reportedNode","k","l","propName","getKeyValue","markDestructuredFunctionArgumentsAsUsed","param","destructuring","handleSetStateUpdater","handleFunctionLikeExpressions","handleCustomValidators","propTypes","declaredPropTypes","keys","forEach","isFunctionLikeExpression","VariableDeclarator","unwrappedInitNode","init","propsProperty","find","getParentStatelessComponent","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","JSXSpreadAttribute","propVariable","ObjectPattern","list","filter"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/util/usedPropTypes.js"],"sourcesContent":["/**\n * @fileoverview Common used propTypes detection functionality.\n */\n\n'use strict';\n\nconst astUtil = require('./ast');\nconst componentUtil = require('./componentUtil');\nconst testReactVersion = require('./version').testReactVersion;\nconst ast = require('./ast');\n\n// ------------------------------------------------------------------------------\n// Constants\n// ------------------------------------------------------------------------------\n\nconst LIFE_CYCLE_METHODS = ['componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate'];\nconst ASYNC_SAFE_LIFE_CYCLE_METHODS = ['getDerivedStateFromProps', 'getSnapshotBeforeUpdate', 'UNSAFE_componentWillReceiveProps', 'UNSAFE_componentWillUpdate'];\n\nfunction createPropVariables() {\n  /** @type {Map<string, string[]>} Maps the variable to its definition. `props.a.b` is stored as `['a', 'b']` */\n  let propVariables = new Map();\n  let hasBeenWritten = false;\n  const stack = [{ propVariables, hasBeenWritten }];\n  return {\n    pushScope() {\n      // popVariables is not copied until first write.\n      stack.push({ propVariables, hasBeenWritten: false });\n    },\n    popScope() {\n      stack.pop();\n      propVariables = stack[stack.length - 1].propVariables;\n      hasBeenWritten = stack[stack.length - 1].hasBeenWritten;\n    },\n    /**\n     * Add a variable name to the current scope\n     * @param {string} name\n     * @param {string[]} allNames Example: `props.a.b` should be formatted as `['a', 'b']`\n     * @returns {Map<string, string[]>}\n     */\n    set(name, allNames) {\n      if (!hasBeenWritten) {\n        // copy on write\n        propVariables = new Map(propVariables);\n        Object.assign(stack[stack.length - 1], { propVariables, hasBeenWritten: true });\n        stack[stack.length - 1].hasBeenWritten = true;\n      }\n      return propVariables.set(name, allNames);\n    },\n    /**\n     * Get the definition of a variable.\n     * @param {string} name\n     * @returns {string[]} Example: `props.a.b` is represented by `['a', 'b']`\n     */\n    get(name) {\n      return propVariables.get(name);\n    },\n  };\n}\n\n/**\n * Checks if the string is one of `props`, `nextProps`, or `prevProps`\n * @param {string} name The AST node being checked.\n * @returns {Boolean} True if the prop name matches\n */\nfunction isCommonVariableNameForProps(name) {\n  return name === 'props' || name === 'nextProps' || name === 'prevProps';\n}\n\n/**\n * Checks if the component must be validated\n * @param {Object} component The component to process\n * @returns {Boolean} True if the component must be validated, false if not.\n */\nfunction mustBeValidated(component) {\n  return !!(component && !component.ignorePropsValidation);\n}\n\n/**\n * Check if we are in a lifecycle method\n * @param {object} context\n * @param {boolean} checkAsyncSafeLifeCycles\n * @return {boolean} true if we are in a class constructor, false if not\n */\nfunction inLifeCycleMethod(context, checkAsyncSafeLifeCycles) {\n  let scope = context.getScope();\n  while (scope) {\n    if (scope.block && scope.block.parent && scope.block.parent.key) {\n      const name = scope.block.parent.key.name;\n\n      if (LIFE_CYCLE_METHODS.indexOf(name) >= 0) {\n        return true;\n      }\n      if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(name) >= 0) {\n        return true;\n      }\n    }\n    scope = scope.upper;\n  }\n  return false;\n}\n\n/**\n * Returns true if the given node is a React Component lifecycle method\n * @param {ASTNode} node The AST node being checked.\n * @param {boolean} checkAsyncSafeLifeCycles\n * @return {Boolean} True if the node is a lifecycle method\n */\nfunction isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles) {\n  const nodeKeyName = (node.key || /** @type {ASTNode} */ ({})).name;\n\n  if (node.kind === 'constructor') {\n    return true;\n  }\n  if (LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {\n    return true;\n  }\n  if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Returns true if the given node is inside a React Component lifecycle\n * method.\n * @param {ASTNode} node The AST node being checked.\n * @param {boolean} checkAsyncSafeLifeCycles\n * @return {Boolean} True if the node is inside a lifecycle method\n */\nfunction isInLifeCycleMethod(node, checkAsyncSafeLifeCycles) {\n  if ((node.type === 'MethodDefinition' || node.type === 'Property') && isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles)) {\n    return true;\n  }\n\n  if (node.parent) {\n    return isInLifeCycleMethod(node.parent, checkAsyncSafeLifeCycles);\n  }\n\n  return false;\n}\n\n/**\n * Check if a function node is a setState updater\n * @param {ASTNode} node a function node\n * @return {boolean}\n */\nfunction isSetStateUpdater(node) {\n  const unwrappedParentCalleeNode = node.parent && node.parent.type === 'CallExpression'\n    && ast.unwrapTSAsExpression(node.parent.callee);\n\n  return unwrappedParentCalleeNode\n    && unwrappedParentCalleeNode.property\n    && unwrappedParentCalleeNode.property.name === 'setState'\n    // Make sure we are in the updater not the callback\n    && node.parent.arguments[0] === node;\n}\n\nfunction isPropArgumentInSetStateUpdater(context, name) {\n  if (typeof name !== 'string') {\n    return;\n  }\n  let scope = context.getScope();\n  while (scope) {\n    const unwrappedParentCalleeNode = scope.block\n      && scope.block.parent\n      && scope.block.parent.type === 'CallExpression'\n      && ast.unwrapTSAsExpression(scope.block.parent.callee);\n    if (\n      unwrappedParentCalleeNode\n      && unwrappedParentCalleeNode.property\n      && unwrappedParentCalleeNode.property.name === 'setState'\n      // Make sure we are in the updater not the callback\n      && scope.block.parent.arguments[0].range[0] === scope.block.range[0]\n      && scope.block.parent.arguments[0].params\n      && scope.block.parent.arguments[0].params.length > 1\n    ) {\n      return scope.block.parent.arguments[0].params[1].name === name;\n    }\n    scope = scope.upper;\n  }\n  return false;\n}\n\n/**\n * @param {Context} context\n * @returns {boolean}\n */\nfunction isInClassComponent(context) {\n  return !!(componentUtil.getParentES6Component(context) || componentUtil.getParentES5Component(context));\n}\n\n/**\n * Checks if the node is `this.props`\n * @param {ASTNode|undefined} node\n * @returns {boolean}\n */\nfunction isThisDotProps(node) {\n  return !!node\n    && node.type === 'MemberExpression'\n    && ast.unwrapTSAsExpression(node.object).type === 'ThisExpression'\n    && node.property.name === 'props';\n}\n\n/**\n * Checks if the prop has spread operator.\n * @param {object} context\n * @param {ASTNode} node The AST node being marked.\n * @returns {Boolean} True if the prop has spread operator, false if not.\n */\nfunction hasSpreadOperator(context, node) {\n  const tokens = context.getSourceCode().getTokens(node);\n  return tokens.length && tokens[0].value === '...';\n}\n\n/**\n * Checks if the node is a propTypes usage of the form `this.props.*`, `props.*`, `prevProps.*`, or `nextProps.*`.\n * @param {ASTNode} node\n * @param {Context} context\n * @param {Object} utils\n * @param {boolean} checkAsyncSafeLifeCycles\n * @returns {boolean}\n */\nfunction isPropTypesUsageByMemberExpression(node, context, utils, checkAsyncSafeLifeCycles) {\n  const unwrappedObjectNode = ast.unwrapTSAsExpression(node.object);\n\n  if (isInClassComponent(context)) {\n    // this.props.*\n    if (isThisDotProps(unwrappedObjectNode)) {\n      return true;\n    }\n    // props.* or prevProps.* or nextProps.*\n    if (\n      isCommonVariableNameForProps(unwrappedObjectNode.name)\n      && (inLifeCycleMethod(context, checkAsyncSafeLifeCycles) || astUtil.inConstructor(context))\n    ) {\n      return true;\n    }\n    // this.setState((_, props) => props.*))\n    if (isPropArgumentInSetStateUpdater(context, unwrappedObjectNode.name)) {\n      return true;\n    }\n    return false;\n  }\n  // props.* in function component\n  return unwrappedObjectNode.name === 'props' && !ast.isAssignmentLHS(node);\n}\n\n/**\n * Retrieve the name of a property node\n * @param {ASTNode} node The AST node with the property.\n * @param {Context} context\n * @param {Object} utils\n * @param {boolean} checkAsyncSafeLifeCycles\n * @return {string|undefined} the name of the property or undefined if not found\n */\nfunction getPropertyName(node, context, utils, checkAsyncSafeLifeCycles) {\n  const property = node.property;\n  if (property) {\n    switch (property.type) {\n      case 'Identifier':\n        if (node.computed) {\n          return '__COMPUTED_PROP__';\n        }\n        return property.name;\n      case 'MemberExpression':\n        return;\n      case 'Literal':\n        // Accept computed properties that are literal strings\n        if (typeof property.value === 'string') {\n          return property.value;\n        }\n        // Accept number as well but only accept props[123]\n        if (typeof property.value === 'number') {\n          if (isPropTypesUsageByMemberExpression(node, context, utils, checkAsyncSafeLifeCycles)) {\n            return property.raw;\n          }\n        }\n        // falls through\n      default:\n        if (node.computed) {\n          return '__COMPUTED_PROP__';\n        }\n        break;\n    }\n  }\n}\n\nmodule.exports = function usedPropTypesInstructions(context, components, utils) {\n  const checkAsyncSafeLifeCycles = testReactVersion(context, '>= 16.3.0');\n\n  const propVariables = createPropVariables();\n  const pushScope = propVariables.pushScope;\n  const popScope = propVariables.popScope;\n\n  /**\n   * Mark a prop type as used\n   * @param {ASTNode} node The AST node being marked.\n   * @param {string[]} [parentNames]\n   */\n  function markPropTypesAsUsed(node, parentNames) {\n    parentNames = parentNames || [];\n    let type;\n    let name;\n    let allNames;\n    let properties;\n    switch (node.type) {\n      case 'OptionalMemberExpression':\n      case 'MemberExpression':\n        name = getPropertyName(node, context, utils, checkAsyncSafeLifeCycles);\n        if (name) {\n          allNames = parentNames.concat(name);\n          if (\n            // Match props.foo.bar, don't match bar[props.foo]\n            node.parent.type === 'MemberExpression'\n            && node.parent.object === node\n          ) {\n            markPropTypesAsUsed(node.parent, allNames);\n          }\n          // Handle the destructuring part of `const {foo} = props.a.b`\n          if (\n            node.parent.type === 'VariableDeclarator'\n            && node.parent.id.type === 'ObjectPattern'\n          ) {\n            node.parent.id.parent = node.parent; // patch for bug in eslint@4 in which ObjectPattern has no parent\n            markPropTypesAsUsed(node.parent.id, allNames);\n          }\n\n          // const a = props.a\n          if (\n            node.parent.type === 'VariableDeclarator'\n            && node.parent.id.type === 'Identifier'\n          ) {\n            propVariables.set(node.parent.id.name, allNames);\n          }\n          // Do not mark computed props as used.\n          type = name !== '__COMPUTED_PROP__' ? 'direct' : null;\n        }\n        break;\n      case 'ArrowFunctionExpression':\n      case 'FunctionDeclaration':\n      case 'FunctionExpression': {\n        if (node.params.length === 0) {\n          break;\n        }\n        type = 'destructuring';\n        const propParam = isSetStateUpdater(node) ? node.params[1] : node.params[0];\n        properties = propParam.type === 'AssignmentPattern'\n          ? propParam.left.properties\n          : propParam.properties;\n        break;\n      }\n      case 'ObjectPattern':\n        type = 'destructuring';\n        properties = node.properties;\n        break;\n      case 'TSEmptyBodyFunctionExpression':\n        break;\n      default:\n        throw new Error(`${node.type} ASTNodes are not handled by markPropTypesAsUsed`);\n    }\n\n    const component = components.get(utils.getParentComponent());\n    const usedPropTypes = (component && component.usedPropTypes) || [];\n    let ignoreUnusedPropTypesValidation = (component && component.ignoreUnusedPropTypesValidation) || false;\n\n    switch (type) {\n      case 'direct': {\n        // Ignore Object methods\n        if (name in Object.prototype) {\n          break;\n        }\n\n        const reportedNode = node.property;\n        usedPropTypes.push({\n          name,\n          allNames,\n          node: reportedNode,\n        });\n        break;\n      }\n      case 'destructuring': {\n        for (let k = 0, l = (properties || []).length; k < l; k++) {\n          if (hasSpreadOperator(context, properties[k]) || properties[k].computed) {\n            ignoreUnusedPropTypesValidation = true;\n            break;\n          }\n          const propName = ast.getKeyValue(context, properties[k]);\n\n          if (!propName || properties[k].type !== 'Property') {\n            break;\n          }\n\n          usedPropTypes.push({\n            allNames: parentNames.concat([propName]),\n            name: propName,\n            node: properties[k],\n          });\n\n          if (properties[k].value.type === 'ObjectPattern') {\n            markPropTypesAsUsed(properties[k].value, parentNames.concat([propName]));\n          } else if (properties[k].value.type === 'Identifier') {\n            propVariables.set(properties[k].value.name, parentNames.concat(propName));\n          }\n        }\n        break;\n      }\n      default:\n        break;\n    }\n\n    components.set(component ? component.node : node, {\n      usedPropTypes,\n      ignoreUnusedPropTypesValidation,\n    });\n  }\n\n  /**\n   * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n   *   FunctionDeclaration, or FunctionExpression\n   */\n  function markDestructuredFunctionArgumentsAsUsed(node) {\n    const param = node.params && isSetStateUpdater(node) ? node.params[1] : node.params[0];\n\n    const destructuring = param && (\n      param.type === 'ObjectPattern'\n      || ((param.type === 'AssignmentPattern') && (param.left.type === 'ObjectPattern'))\n    );\n\n    if (destructuring && (components.get(node) || components.get(node.parent))) {\n      markPropTypesAsUsed(node);\n    }\n  }\n\n  function handleSetStateUpdater(node) {\n    if (!node.params || node.params.length < 2 || !isSetStateUpdater(node)) {\n      return;\n    }\n    markPropTypesAsUsed(node);\n  }\n\n  /**\n   * Handle both stateless functions and setState updater functions.\n   * @param {ASTNode} node We expect either an ArrowFunctionExpression,\n   *   FunctionDeclaration, or FunctionExpression\n   */\n  function handleFunctionLikeExpressions(node) {\n    pushScope();\n    handleSetStateUpdater(node);\n    markDestructuredFunctionArgumentsAsUsed(node);\n  }\n\n  function handleCustomValidators(component) {\n    const propTypes = component.declaredPropTypes;\n    if (!propTypes) {\n      return;\n    }\n\n    Object.keys(propTypes).forEach((key) => {\n      const node = propTypes[key].node;\n\n      if (node && node.value && astUtil.isFunctionLikeExpression(node.value)) {\n        markPropTypesAsUsed(node.value);\n      }\n    });\n  }\n\n  return {\n    VariableDeclarator(node) {\n      const unwrappedInitNode = ast.unwrapTSAsExpression(node.init);\n\n      // let props = this.props\n      if (isThisDotProps(unwrappedInitNode) && isInClassComponent(context) && node.id.type === 'Identifier') {\n        propVariables.set(node.id.name, []);\n      }\n\n      // Only handles destructuring\n      if (node.id.type !== 'ObjectPattern' || !unwrappedInitNode) {\n        return;\n      }\n\n      // let {props: {firstname}} = this\n      const propsProperty = node.id.properties.find((property) => (\n        property.key\n        && (property.key.name === 'props' || property.key.value === 'props')\n      ));\n\n      if (unwrappedInitNode.type === 'ThisExpression' && propsProperty && propsProperty.value.type === 'ObjectPattern') {\n        markPropTypesAsUsed(propsProperty.value);\n        return;\n      }\n\n      // let {props} = this\n      if (unwrappedInitNode.type === 'ThisExpression' && propsProperty && propsProperty.value.name === 'props') {\n        propVariables.set('props', []);\n        return;\n      }\n\n      // let {firstname} = props\n      if (\n        isCommonVariableNameForProps(unwrappedInitNode.name)\n        && (utils.getParentStatelessComponent() || isInLifeCycleMethod(node, checkAsyncSafeLifeCycles))\n      ) {\n        markPropTypesAsUsed(node.id);\n        return;\n      }\n\n      // let {firstname} = this.props\n      if (isThisDotProps(unwrappedInitNode) && isInClassComponent(context)) {\n        markPropTypesAsUsed(node.id);\n        return;\n      }\n\n      // let {firstname} = thing, where thing is defined by const thing = this.props.**.*\n      if (propVariables.get(unwrappedInitNode.name)) {\n        markPropTypesAsUsed(node.id, propVariables.get(unwrappedInitNode.name));\n      }\n    },\n\n    FunctionDeclaration: handleFunctionLikeExpressions,\n\n    ArrowFunctionExpression: handleFunctionLikeExpressions,\n\n    FunctionExpression: handleFunctionLikeExpressions,\n\n    'FunctionDeclaration:exit': popScope,\n\n    'ArrowFunctionExpression:exit': popScope,\n\n    'FunctionExpression:exit': popScope,\n\n    JSXSpreadAttribute(node) {\n      const component = components.get(utils.getParentComponent());\n      components.set(component ? component.node : node, {\n        ignoreUnusedPropTypesValidation: true,\n      });\n    },\n\n    'MemberExpression, OptionalMemberExpression'(node) {\n      if (isPropTypesUsageByMemberExpression(node, context, utils, checkAsyncSafeLifeCycles)) {\n        markPropTypesAsUsed(node);\n        return;\n      }\n\n      const propVariable = propVariables.get(ast.unwrapTSAsExpression(node.object).name);\n      if (propVariable) {\n        markPropTypesAsUsed(node, propVariable);\n      }\n    },\n\n    ObjectPattern(node) {\n      // If the object pattern is a destructured props object in a lifecycle\n      // method -- mark it for used props.\n      if (isNodeALifeCycleMethod(node.parent.parent, checkAsyncSafeLifeCycles) && node.properties.length > 0) {\n        markPropTypesAsUsed(node.parent);\n      }\n    },\n\n    'Program:exit'() {\n      const list = components.list();\n\n      Object.keys(list).filter((component) => mustBeValidated(list[component])).forEach((component) => {\n        handleCustomValidators(list[component]);\n      });\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}