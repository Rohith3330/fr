{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ancestorHasReturnType = exports.isValidFunctionExpressionReturnType = exports.isTypedFunctionExpression = exports.doesImmediatelyReturnFunctionExpression = exports.checkFunctionReturnType = exports.checkFunctionExpressionReturnType = void 0;\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst astUtils_1 = require(\"./astUtils\");\n\nconst getFunctionHeadLoc_1 = require(\"./getFunctionHeadLoc\");\n/**\n * Checks if a node is a variable declarator with a type annotation.\n * ```\n * const x: Foo = ...\n * ```\n */\n\n\nfunction isVariableDeclaratorWithTypeAnnotation(node) {\n  return node.type === utils_1.AST_NODE_TYPES.VariableDeclarator && !!node.id.typeAnnotation;\n}\n/**\n * Checks if a node is a class property with a type annotation.\n * ```\n * public x: Foo = ...\n * ```\n */\n\n\nfunction isPropertyDefinitionWithTypeAnnotation(node) {\n  return node.type === utils_1.AST_NODE_TYPES.PropertyDefinition && !!node.typeAnnotation;\n}\n/**\n * Checks if a node belongs to:\n * ```\n * new Foo(() => {})\n *         ^^^^^^^^\n * ```\n */\n\n\nfunction isConstructorArgument(node) {\n  return node.type === utils_1.AST_NODE_TYPES.NewExpression;\n}\n/**\n * Checks if a node is a property or a nested property of a typed object:\n * ```\n * const x: Foo = { prop: () => {} }\n * const x = { prop: () => {} } as Foo\n * const x = <Foo>{ prop: () => {} }\n * const x: Foo = { bar: { prop: () => {} } }\n * ```\n */\n\n\nfunction isPropertyOfObjectWithType(property) {\n  if (!property || property.type !== utils_1.AST_NODE_TYPES.Property) {\n    return false;\n  }\n\n  const objectExpr = property.parent; // this shouldn't happen, checking just in case\n\n  /* istanbul ignore if */\n\n  if (!objectExpr || objectExpr.type !== utils_1.AST_NODE_TYPES.ObjectExpression) {\n    return false;\n  }\n\n  const parent = objectExpr.parent; // this shouldn't happen, checking just in case\n\n  /* istanbul ignore if */\n\n  if (!parent) {\n    return false;\n  }\n\n  return (0, astUtils_1.isTypeAssertion)(parent) || isPropertyDefinitionWithTypeAnnotation(parent) || isVariableDeclaratorWithTypeAnnotation(parent) || isFunctionArgument(parent) || isPropertyOfObjectWithType(parent);\n}\n/**\n * Checks if a function belongs to:\n * ```\n * () => () => ...\n * () => function () { ... }\n * () => { return () => ... }\n * () => { return function () { ... } }\n * function fn() { return () => ... }\n * function fn() { return function() { ... } }\n * ```\n */\n\n\nfunction doesImmediatelyReturnFunctionExpression(_ref) {\n  let {\n    body\n  } = _ref;\n\n  // Should always have a body; really checking just in case\n\n  /* istanbul ignore if */\n  if (!body) {\n    return false;\n  } // Check if body is a block with a single statement\n\n\n  if (body.type === utils_1.AST_NODE_TYPES.BlockStatement && body.body.length === 1) {\n    const [statement] = body.body; // Check if that statement is a return statement with an argument\n\n    if (statement.type === utils_1.AST_NODE_TYPES.ReturnStatement && !!statement.argument) {\n      // If so, check that returned argument as body\n      body = statement.argument;\n    }\n  } // Check if the body being returned is a function expression\n\n\n  return body.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression || body.type === utils_1.AST_NODE_TYPES.FunctionExpression;\n}\n\nexports.doesImmediatelyReturnFunctionExpression = doesImmediatelyReturnFunctionExpression;\n/**\n * Checks if a node belongs to:\n * ```\n * foo(() => 1)\n * ```\n */\n\nfunction isFunctionArgument(parent, callee) {\n  return parent.type === utils_1.AST_NODE_TYPES.CallExpression && // make sure this isn't an IIFE\n  parent.callee !== callee;\n}\n/**\n * Checks if a function belongs to:\n * ```\n * () => ({ action: 'xxx' } as const)\n * ```\n */\n\n\nfunction returnsConstAssertionDirectly(node) {\n  const {\n    body\n  } = node;\n\n  if ((0, astUtils_1.isTypeAssertion)(body)) {\n    const {\n      typeAnnotation\n    } = body;\n\n    if (typeAnnotation.type === utils_1.AST_NODE_TYPES.TSTypeReference) {\n      const {\n        typeName\n      } = typeAnnotation;\n\n      if (typeName.type === utils_1.AST_NODE_TYPES.Identifier && typeName.name === 'const') {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * True when the provided function expression is typed.\n */\n\n\nfunction isTypedFunctionExpression(node, options) {\n  const parent = utils_1.ESLintUtils.nullThrows(node.parent, utils_1.ESLintUtils.NullThrowsReasons.MissingParent);\n\n  if (!options.allowTypedFunctionExpressions) {\n    return false;\n  }\n\n  return (0, astUtils_1.isTypeAssertion)(parent) || isVariableDeclaratorWithTypeAnnotation(parent) || isPropertyDefinitionWithTypeAnnotation(parent) || isPropertyOfObjectWithType(parent) || isFunctionArgument(parent, node) || isConstructorArgument(parent);\n}\n\nexports.isTypedFunctionExpression = isTypedFunctionExpression;\n/**\n * Check whether the function expression return type is either typed or valid\n * with the provided options.\n */\n\nfunction isValidFunctionExpressionReturnType(node, options) {\n  if (isTypedFunctionExpression(node, options)) {\n    return true;\n  }\n\n  const parent = utils_1.ESLintUtils.nullThrows(node.parent, utils_1.ESLintUtils.NullThrowsReasons.MissingParent);\n\n  if (options.allowExpressions && parent.type !== utils_1.AST_NODE_TYPES.VariableDeclarator && parent.type !== utils_1.AST_NODE_TYPES.MethodDefinition && parent.type !== utils_1.AST_NODE_TYPES.ExportDefaultDeclaration && parent.type !== utils_1.AST_NODE_TYPES.PropertyDefinition) {\n    return true;\n  } // https://github.com/typescript-eslint/typescript-eslint/issues/653\n\n\n  return options.allowDirectConstAssertionInArrowFunctions === true && node.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression && returnsConstAssertionDirectly(node);\n}\n\nexports.isValidFunctionExpressionReturnType = isValidFunctionExpressionReturnType;\n/**\n * Check that the function expression or declaration is valid.\n */\n\nfunction isValidFunctionReturnType(node, options) {\n  if (options.allowHigherOrderFunctions && doesImmediatelyReturnFunctionExpression(node)) {\n    return true;\n  }\n\n  return node.returnType != null || (0, astUtils_1.isConstructor)(node.parent) || (0, astUtils_1.isSetter)(node.parent);\n}\n/**\n * Checks if a function declaration/expression has a return type.\n */\n\n\nfunction checkFunctionReturnType(node, options, sourceCode, report) {\n  if (isValidFunctionReturnType(node, options)) {\n    return;\n  }\n\n  report((0, getFunctionHeadLoc_1.getFunctionHeadLoc)(node, sourceCode));\n}\n\nexports.checkFunctionReturnType = checkFunctionReturnType;\n/**\n * Checks if a function declaration/expression has a return type.\n */\n\nfunction checkFunctionExpressionReturnType(node, options, sourceCode, report) {\n  if (isValidFunctionExpressionReturnType(node, options)) {\n    return;\n  }\n\n  checkFunctionReturnType(node, options, sourceCode, report);\n}\n\nexports.checkFunctionExpressionReturnType = checkFunctionExpressionReturnType;\n/**\n * Check whether any ancestor of the provided function has a valid return type.\n */\n\nfunction ancestorHasReturnType(node) {\n  let ancestor = node.parent;\n\n  if ((ancestor === null || ancestor === void 0 ? void 0 : ancestor.type) === utils_1.AST_NODE_TYPES.Property) {\n    ancestor = ancestor.value;\n  } // if the ancestor is not a return, then this function was not returned at all, so we can exit early\n\n\n  const isReturnStatement = (ancestor === null || ancestor === void 0 ? void 0 : ancestor.type) === utils_1.AST_NODE_TYPES.ReturnStatement;\n  const isBodylessArrow = (ancestor === null || ancestor === void 0 ? void 0 : ancestor.type) === utils_1.AST_NODE_TYPES.ArrowFunctionExpression && ancestor.body.type !== utils_1.AST_NODE_TYPES.BlockStatement;\n\n  if (!isReturnStatement && !isBodylessArrow) {\n    return false;\n  }\n\n  while (ancestor) {\n    switch (ancestor.type) {\n      case utils_1.AST_NODE_TYPES.ArrowFunctionExpression:\n      case utils_1.AST_NODE_TYPES.FunctionExpression:\n      case utils_1.AST_NODE_TYPES.FunctionDeclaration:\n        if (ancestor.returnType) {\n          return true;\n        }\n\n        break;\n      // const x: Foo = () => {};\n      // Assume that a typed variable types the function expression\n\n      case utils_1.AST_NODE_TYPES.VariableDeclarator:\n        if (ancestor.id.typeAnnotation) {\n          return true;\n        }\n\n        break;\n    }\n\n    ancestor = ancestor.parent;\n  }\n\n  return false;\n}\n\nexports.ancestorHasReturnType = ancestorHasReturnType;","map":{"version":3,"mappings":"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","names":["isVariableDeclaratorWithTypeAnnotation","node","type","utils_1","VariableDeclarator","id","typeAnnotation","isPropertyDefinitionWithTypeAnnotation","PropertyDefinition","isConstructorArgument","NewExpression","isPropertyOfObjectWithType","property","Property","objectExpr","parent","ObjectExpression","isFunctionArgument","doesImmediatelyReturnFunctionExpression","body","BlockStatement","length","statement","ReturnStatement","argument","ArrowFunctionExpression","FunctionExpression","exports","callee","CallExpression","returnsConstAssertionDirectly","TSTypeReference","typeName","Identifier","name","isTypedFunctionExpression","options","nullThrows","NullThrowsReasons","MissingParent","allowTypedFunctionExpressions","isValidFunctionExpressionReturnType","allowExpressions","MethodDefinition","ExportDefaultDeclaration","allowDirectConstAssertionInArrowFunctions","isValidFunctionReturnType","allowHigherOrderFunctions","returnType","checkFunctionReturnType","sourceCode","report","checkFunctionExpressionReturnType","ancestorHasReturnType","ancestor","value","isReturnStatement","isBodylessArrow","FunctionDeclaration"],"sources":["../../src/util/explicitReturnTypeUtils.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}