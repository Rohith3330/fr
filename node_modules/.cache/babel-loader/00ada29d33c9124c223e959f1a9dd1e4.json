{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _declaration = _interopRequireDefault(require(\"./declaration\"));\n\nvar _tokenize = _interopRequireDefault(require(\"./tokenize\"));\n\nvar _comment = _interopRequireDefault(require(\"./comment\"));\n\nvar _atRule = _interopRequireDefault(require(\"./at-rule\"));\n\nvar _root = _interopRequireDefault(require(\"./root\"));\n\nvar _rule = _interopRequireDefault(require(\"./rule\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(input) {\n    this.input = input;\n    this.root = new _root.default();\n    this.current = this.root;\n    this.spaces = '';\n    this.semicolon = false;\n    this.createTokenizer();\n    this.root.source = {\n      input: input,\n      start: {\n        line: 1,\n        column: 1\n      }\n    };\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto.createTokenizer = function createTokenizer() {\n    this.tokenizer = (0, _tokenize.default)(this.input);\n  };\n\n  _proto.parse = function parse() {\n    var token;\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1];\n          break;\n\n        case ';':\n          this.freeSemicolon(token);\n          break;\n\n        case '}':\n          this.end(token);\n          break;\n\n        case 'comment':\n          this.comment(token);\n          break;\n\n        case 'at-word':\n          this.atrule(token);\n          break;\n\n        case '{':\n          this.emptyRule(token);\n          break;\n\n        default:\n          this.other(token);\n          break;\n      }\n    }\n\n    this.endFile();\n  };\n\n  _proto.comment = function comment(token) {\n    var node = new _comment.default();\n    this.init(node, token[2], token[3]);\n    node.source.end = {\n      line: token[4],\n      column: token[5]\n    };\n    var text = token[1].slice(2, -2);\n\n    if (/^\\s*$/.test(text)) {\n      node.text = '';\n      node.raws.left = text;\n      node.raws.right = '';\n    } else {\n      var match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n      node.text = match[2];\n      node.raws.left = match[1];\n      node.raws.right = match[3];\n    }\n  };\n\n  _proto.emptyRule = function emptyRule(token) {\n    var node = new _rule.default();\n    this.init(node, token[2], token[3]);\n    node.selector = '';\n    node.raws.between = '';\n    this.current = node;\n  };\n\n  _proto.other = function other(start) {\n    var end = false;\n    var type = null;\n    var colon = false;\n    var bracket = null;\n    var brackets = [];\n    var tokens = [];\n    var token = start;\n\n    while (token) {\n      type = token[0];\n      tokens.push(token);\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token;\n        brackets.push(type === '(' ? ')' : ']');\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens);\n            return;\n          } else {\n            break;\n          }\n        } else if (type === '{') {\n          this.rule(tokens);\n          return;\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop());\n          end = true;\n          break;\n        } else if (type === ':') {\n          colon = true;\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop();\n        if (brackets.length === 0) bracket = null;\n      }\n\n      token = this.tokenizer.nextToken();\n    }\n\n    if (this.tokenizer.endOfFile()) end = true;\n    if (brackets.length > 0) this.unclosedBracket(bracket);\n\n    if (end && colon) {\n      while (tokens.length) {\n        token = tokens[tokens.length - 1][0];\n        if (token !== 'space' && token !== 'comment') break;\n        this.tokenizer.back(tokens.pop());\n      }\n\n      this.decl(tokens);\n    } else {\n      this.unknownWord(tokens);\n    }\n  };\n\n  _proto.rule = function rule(tokens) {\n    tokens.pop();\n    var node = new _rule.default();\n    this.init(node, tokens[0][2], tokens[0][3]);\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n    this.raw(node, 'selector', tokens);\n    this.current = node;\n  };\n\n  _proto.decl = function decl(tokens) {\n    var node = new _declaration.default();\n    this.init(node);\n    var last = tokens[tokens.length - 1];\n\n    if (last[0] === ';') {\n      this.semicolon = true;\n      tokens.pop();\n    }\n\n    if (last[4]) {\n      node.source.end = {\n        line: last[4],\n        column: last[5]\n      };\n    } else {\n      node.source.end = {\n        line: last[2],\n        column: last[3]\n      };\n    }\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens);\n      node.raws.before += tokens.shift()[1];\n    }\n\n    node.source.start = {\n      line: tokens[0][2],\n      column: tokens[0][3]\n    };\n    node.prop = '';\n\n    while (tokens.length) {\n      var type = tokens[0][0];\n\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break;\n      }\n\n      node.prop += tokens.shift()[1];\n    }\n\n    node.raws.between = '';\n    var token;\n\n    while (tokens.length) {\n      token = tokens.shift();\n\n      if (token[0] === ':') {\n        node.raws.between += token[1];\n        break;\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token]);\n        }\n\n        node.raws.between += token[1];\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0];\n      node.prop = node.prop.slice(1);\n    }\n\n    node.raws.between += this.spacesAndCommentsFromStart(tokens);\n    this.precheckMissedSemicolon(tokens);\n\n    for (var i = tokens.length - 1; i > 0; i--) {\n      token = tokens[i];\n\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true;\n        var string = this.stringFrom(tokens, i);\n        string = this.spacesFromEnd(tokens) + string;\n        if (string !== ' !important') node.raws.important = string;\n        break;\n      } else if (token[1].toLowerCase() === 'important') {\n        var cache = tokens.slice(0);\n        var str = '';\n\n        for (var j = i; j > 0; j--) {\n          var _type = cache[j][0];\n\n          if (str.trim().indexOf('!') === 0 && _type !== 'space') {\n            break;\n          }\n\n          str = cache.pop()[1] + str;\n        }\n\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true;\n          node.raws.important = str;\n          tokens = cache;\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break;\n      }\n    }\n\n    this.raw(node, 'value', tokens);\n    if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);\n  };\n\n  _proto.atrule = function atrule(token) {\n    var node = new _atRule.default();\n    node.name = token[1].slice(1);\n\n    if (node.name === '') {\n      this.unnamedAtrule(node, token);\n    }\n\n    this.init(node, token[2], token[3]);\n    var prev;\n    var shift;\n    var last = false;\n    var open = false;\n    var params = [];\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken();\n\n      if (token[0] === ';') {\n        node.source.end = {\n          line: token[2],\n          column: token[3]\n        };\n        this.semicolon = true;\n        break;\n      } else if (token[0] === '{') {\n        open = true;\n        break;\n      } else if (token[0] === '}') {\n        if (params.length > 0) {\n          shift = params.length - 1;\n          prev = params[shift];\n\n          while (prev && prev[0] === 'space') {\n            prev = params[--shift];\n          }\n\n          if (prev) {\n            node.source.end = {\n              line: prev[4],\n              column: prev[5]\n            };\n          }\n        }\n\n        this.end(token);\n        break;\n      } else {\n        params.push(token);\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true;\n        break;\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params);\n\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params);\n      this.raw(node, 'params', params);\n\n      if (last) {\n        token = params[params.length - 1];\n        node.source.end = {\n          line: token[4],\n          column: token[5]\n        };\n        this.spaces = node.raws.between;\n        node.raws.between = '';\n      }\n    } else {\n      node.raws.afterName = '';\n      node.params = '';\n    }\n\n    if (open) {\n      node.nodes = [];\n      this.current = node;\n    }\n  };\n\n  _proto.end = function end(token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.semicolon = false;\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n    this.spaces = '';\n\n    if (this.current.parent) {\n      this.current.source.end = {\n        line: token[2],\n        column: token[3]\n      };\n      this.current = this.current.parent;\n    } else {\n      this.unexpectedClose(token);\n    }\n  };\n\n  _proto.endFile = function endFile() {\n    if (this.current.parent) this.unclosedBlock();\n\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon;\n    }\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n  };\n\n  _proto.freeSemicolon = function freeSemicolon(token) {\n    this.spaces += token[1];\n\n    if (this.current.nodes) {\n      var prev = this.current.nodes[this.current.nodes.length - 1];\n\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces;\n        this.spaces = '';\n      }\n    }\n  } // Helpers\n  ;\n\n  _proto.init = function init(node, line, column) {\n    this.current.push(node);\n    node.source = {\n      start: {\n        line: line,\n        column: column\n      },\n      input: this.input\n    };\n    node.raws.before = this.spaces;\n    this.spaces = '';\n    if (node.type !== 'comment') this.semicolon = false;\n  };\n\n  _proto.raw = function raw(node, prop, tokens) {\n    var token, type;\n    var length = tokens.length;\n    var value = '';\n    var clean = true;\n    var next, prev;\n    var pattern = /^([.|#])?([\\w])+/i;\n\n    for (var i = 0; i < length; i += 1) {\n      token = tokens[i];\n      type = token[0];\n\n      if (type === 'comment' && node.type === 'rule') {\n        prev = tokens[i - 1];\n        next = tokens[i + 1];\n\n        if (prev[0] !== 'space' && next[0] !== 'space' && pattern.test(prev[1]) && pattern.test(next[1])) {\n          value += token[1];\n        } else {\n          clean = false;\n        }\n\n        continue;\n      }\n\n      if (type === 'comment' || type === 'space' && i === length - 1) {\n        clean = false;\n      } else {\n        value += token[1];\n      }\n    }\n\n    if (!clean) {\n      var raw = tokens.reduce(function (all, i) {\n        return all + i[1];\n      }, '');\n      node.raws[prop] = {\n        value: value,\n        raw: raw\n      };\n    }\n\n    node[prop] = value;\n  };\n\n  _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n    var lastTokenType;\n    var spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  };\n\n  _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n    var next;\n    var spaces = '';\n\n    while (tokens.length) {\n      next = tokens[0][0];\n      if (next !== 'space' && next !== 'comment') break;\n      spaces += tokens.shift()[1];\n    }\n\n    return spaces;\n  };\n\n  _proto.spacesFromEnd = function spacesFromEnd(tokens) {\n    var lastTokenType;\n    var spaces = '';\n\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0];\n      if (lastTokenType !== 'space') break;\n      spaces = tokens.pop()[1] + spaces;\n    }\n\n    return spaces;\n  };\n\n  _proto.stringFrom = function stringFrom(tokens, from) {\n    var result = '';\n\n    for (var i = from; i < tokens.length; i++) {\n      result += tokens[i][1];\n    }\n\n    tokens.splice(from, tokens.length - from);\n    return result;\n  };\n\n  _proto.colon = function colon(tokens) {\n    var brackets = 0;\n    var token, type, prev;\n\n    for (var i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n      type = token[0];\n\n      if (type === '(') {\n        brackets += 1;\n      }\n\n      if (type === ')') {\n        brackets -= 1;\n      }\n\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token);\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue;\n        } else {\n          return i;\n        }\n      }\n\n      prev = token;\n    }\n\n    return false;\n  } // Errors\n  ;\n\n  _proto.unclosedBracket = function unclosedBracket(bracket) {\n    throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);\n  };\n\n  _proto.unknownWord = function unknownWord(tokens) {\n    throw this.input.error('Unknown word', tokens[0][2], tokens[0][3]);\n  };\n\n  _proto.unexpectedClose = function unexpectedClose(token) {\n    throw this.input.error('Unexpected }', token[2], token[3]);\n  };\n\n  _proto.unclosedBlock = function unclosedBlock() {\n    var pos = this.current.source.start;\n    throw this.input.error('Unclosed block', pos.line, pos.column);\n  };\n\n  _proto.doubleColon = function doubleColon(token) {\n    throw this.input.error('Double colon', token[2], token[3]);\n  };\n\n  _proto.unnamedAtrule = function unnamedAtrule(node, token) {\n    throw this.input.error('At-rule without name', token[2], token[3]);\n  };\n\n  _proto.precheckMissedSemicolon = function precheckMissedSemicolon()\n  /* tokens */\n  {// Hook for Safe Parser\n  };\n\n  _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n    var colon = this.colon(tokens);\n    if (colon === false) return;\n    var founded = 0;\n    var token;\n\n    for (var j = colon - 1; j >= 0; j--) {\n      token = tokens[j];\n\n      if (token[0] !== 'space') {\n        founded += 1;\n        if (founded === 2) break;\n      }\n    }\n\n    throw this.input.error('Missed semicolon', token[2], token[3]);\n  };\n\n  return Parser;\n}();\n\nexports.default = Parser;\nmodule.exports = exports.default;","map":{"version":3,"mappings":"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","names":["Parser","input","root","Root","current","spaces","semicolon","createTokenizer","source","start","line","column","tokenizer","parse","token","endOfFile","nextToken","freeSemicolon","end","comment","atrule","emptyRule","other","endFile","node","Comment","init","text","slice","test","raws","left","right","match","Rule","selector","between","type","colon","bracket","brackets","tokens","push","length","decl","rule","back","pop","unclosedBracket","unknownWord","spacesAndCommentsFromEnd","raw","Declaration","last","before","shift","prop","spacesAndCommentsFromStart","precheckMissedSemicolon","i","toLowerCase","important","string","stringFrom","spacesFromEnd","cache","str","j","trim","indexOf","value","checkMissedSemicolon","AtRule","name","unnamedAtrule","prev","open","params","afterName","nodes","after","parent","unexpectedClose","unclosedBlock","ownSemicolon","clean","next","pattern","reduce","all","lastTokenType","from","result","splice","doubleColon","error","pos","founded"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\resolve-url-loader\\node_modules\\postcss\\lib\\parser.es6"],"sourcesContent":["import Declaration from './declaration'\nimport tokenizer from './tokenize'\nimport Comment from './comment'\nimport AtRule from './at-rule'\nimport Root from './root'\nimport Rule from './rule'\n\nexport default class Parser {\n  constructor (input) {\n    this.input = input\n\n    this.root = new Root()\n    this.current = this.root\n    this.spaces = ''\n    this.semicolon = false\n\n    this.createTokenizer()\n    this.root.source = { input, start: { line: 1, column: 1 } }\n  }\n\n  createTokenizer () {\n    this.tokenizer = tokenizer(this.input)\n  }\n\n  parse () {\n    let token\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      switch (token[0]) {\n        case 'space':\n          this.spaces += token[1]\n          break\n\n        case ';':\n          this.freeSemicolon(token)\n          break\n\n        case '}':\n          this.end(token)\n          break\n\n        case 'comment':\n          this.comment(token)\n          break\n\n        case 'at-word':\n          this.atrule(token)\n          break\n\n        case '{':\n          this.emptyRule(token)\n          break\n\n        default:\n          this.other(token)\n          break\n      }\n    }\n    this.endFile()\n  }\n\n  comment (token) {\n    let node = new Comment()\n    this.init(node, token[2], token[3])\n    node.source.end = { line: token[4], column: token[5] }\n\n    let text = token[1].slice(2, -2)\n    if (/^\\s*$/.test(text)) {\n      node.text = ''\n      node.raws.left = text\n      node.raws.right = ''\n    } else {\n      let match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/)\n      node.text = match[2]\n      node.raws.left = match[1]\n      node.raws.right = match[3]\n    }\n  }\n\n  emptyRule (token) {\n    let node = new Rule()\n    this.init(node, token[2], token[3])\n    node.selector = ''\n    node.raws.between = ''\n    this.current = node\n  }\n\n  other (start) {\n    let end = false\n    let type = null\n    let colon = false\n    let bracket = null\n    let brackets = []\n\n    let tokens = []\n    let token = start\n    while (token) {\n      type = token[0]\n      tokens.push(token)\n\n      if (type === '(' || type === '[') {\n        if (!bracket) bracket = token\n        brackets.push(type === '(' ? ')' : ']')\n      } else if (brackets.length === 0) {\n        if (type === ';') {\n          if (colon) {\n            this.decl(tokens)\n            return\n          } else {\n            break\n          }\n        } else if (type === '{') {\n          this.rule(tokens)\n          return\n        } else if (type === '}') {\n          this.tokenizer.back(tokens.pop())\n          end = true\n          break\n        } else if (type === ':') {\n          colon = true\n        }\n      } else if (type === brackets[brackets.length - 1]) {\n        brackets.pop()\n        if (brackets.length === 0) bracket = null\n      }\n\n      token = this.tokenizer.nextToken()\n    }\n\n    if (this.tokenizer.endOfFile()) end = true\n    if (brackets.length > 0) this.unclosedBracket(bracket)\n\n    if (end && colon) {\n      while (tokens.length) {\n        token = tokens[tokens.length - 1][0]\n        if (token !== 'space' && token !== 'comment') break\n        this.tokenizer.back(tokens.pop())\n      }\n      this.decl(tokens)\n    } else {\n      this.unknownWord(tokens)\n    }\n  }\n\n  rule (tokens) {\n    tokens.pop()\n\n    let node = new Rule()\n    this.init(node, tokens[0][2], tokens[0][3])\n\n    node.raws.between = this.spacesAndCommentsFromEnd(tokens)\n    this.raw(node, 'selector', tokens)\n    this.current = node\n  }\n\n  decl (tokens) {\n    let node = new Declaration()\n    this.init(node)\n\n    let last = tokens[tokens.length - 1]\n    if (last[0] === ';') {\n      this.semicolon = true\n      tokens.pop()\n    }\n    if (last[4]) {\n      node.source.end = { line: last[4], column: last[5] }\n    } else {\n      node.source.end = { line: last[2], column: last[3] }\n    }\n\n    while (tokens[0][0] !== 'word') {\n      if (tokens.length === 1) this.unknownWord(tokens)\n      node.raws.before += tokens.shift()[1]\n    }\n    node.source.start = { line: tokens[0][2], column: tokens[0][3] }\n\n    node.prop = ''\n    while (tokens.length) {\n      let type = tokens[0][0]\n      if (type === ':' || type === 'space' || type === 'comment') {\n        break\n      }\n      node.prop += tokens.shift()[1]\n    }\n\n    node.raws.between = ''\n\n    let token\n    while (tokens.length) {\n      token = tokens.shift()\n\n      if (token[0] === ':') {\n        node.raws.between += token[1]\n        break\n      } else {\n        if (token[0] === 'word' && /\\w/.test(token[1])) {\n          this.unknownWord([token])\n        }\n        node.raws.between += token[1]\n      }\n    }\n\n    if (node.prop[0] === '_' || node.prop[0] === '*') {\n      node.raws.before += node.prop[0]\n      node.prop = node.prop.slice(1)\n    }\n    node.raws.between += this.spacesAndCommentsFromStart(tokens)\n    this.precheckMissedSemicolon(tokens)\n\n    for (let i = tokens.length - 1; i > 0; i--) {\n      token = tokens[i]\n      if (token[1].toLowerCase() === '!important') {\n        node.important = true\n        let string = this.stringFrom(tokens, i)\n        string = this.spacesFromEnd(tokens) + string\n        if (string !== ' !important') node.raws.important = string\n        break\n      } else if (token[1].toLowerCase() === 'important') {\n        let cache = tokens.slice(0)\n        let str = ''\n        for (let j = i; j > 0; j--) {\n          let type = cache[j][0]\n          if (str.trim().indexOf('!') === 0 && type !== 'space') {\n            break\n          }\n          str = cache.pop()[1] + str\n        }\n        if (str.trim().indexOf('!') === 0) {\n          node.important = true\n          node.raws.important = str\n          tokens = cache\n        }\n      }\n\n      if (token[0] !== 'space' && token[0] !== 'comment') {\n        break\n      }\n    }\n\n    this.raw(node, 'value', tokens)\n\n    if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens)\n  }\n\n  atrule (token) {\n    let node = new AtRule()\n    node.name = token[1].slice(1)\n    if (node.name === '') {\n      this.unnamedAtrule(node, token)\n    }\n    this.init(node, token[2], token[3])\n\n    let prev\n    let shift\n    let last = false\n    let open = false\n    let params = []\n\n    while (!this.tokenizer.endOfFile()) {\n      token = this.tokenizer.nextToken()\n\n      if (token[0] === ';') {\n        node.source.end = { line: token[2], column: token[3] }\n        this.semicolon = true\n        break\n      } else if (token[0] === '{') {\n        open = true\n        break\n      } else if (token[0] === '}') {\n        if (params.length > 0) {\n          shift = params.length - 1\n          prev = params[shift]\n          while (prev && prev[0] === 'space') {\n            prev = params[--shift]\n          }\n          if (prev) {\n            node.source.end = { line: prev[4], column: prev[5] }\n          }\n        }\n        this.end(token)\n        break\n      } else {\n        params.push(token)\n      }\n\n      if (this.tokenizer.endOfFile()) {\n        last = true\n        break\n      }\n    }\n\n    node.raws.between = this.spacesAndCommentsFromEnd(params)\n    if (params.length) {\n      node.raws.afterName = this.spacesAndCommentsFromStart(params)\n      this.raw(node, 'params', params)\n      if (last) {\n        token = params[params.length - 1]\n        node.source.end = { line: token[4], column: token[5] }\n        this.spaces = node.raws.between\n        node.raws.between = ''\n      }\n    } else {\n      node.raws.afterName = ''\n      node.params = ''\n    }\n\n    if (open) {\n      node.nodes = []\n      this.current = node\n    }\n  }\n\n  end (token) {\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.semicolon = false\n\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n    this.spaces = ''\n\n    if (this.current.parent) {\n      this.current.source.end = { line: token[2], column: token[3] }\n      this.current = this.current.parent\n    } else {\n      this.unexpectedClose(token)\n    }\n  }\n\n  endFile () {\n    if (this.current.parent) this.unclosedBlock()\n    if (this.current.nodes && this.current.nodes.length) {\n      this.current.raws.semicolon = this.semicolon\n    }\n    this.current.raws.after = (this.current.raws.after || '') + this.spaces\n  }\n\n  freeSemicolon (token) {\n    this.spaces += token[1]\n    if (this.current.nodes) {\n      let prev = this.current.nodes[this.current.nodes.length - 1]\n      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n        prev.raws.ownSemicolon = this.spaces\n        this.spaces = ''\n      }\n    }\n  }\n\n  // Helpers\n\n  init (node, line, column) {\n    this.current.push(node)\n\n    node.source = { start: { line, column }, input: this.input }\n    node.raws.before = this.spaces\n    this.spaces = ''\n    if (node.type !== 'comment') this.semicolon = false\n  }\n\n  raw (node, prop, tokens) {\n    let token, type\n    let length = tokens.length\n    let value = ''\n    let clean = true\n    let next, prev\n    let pattern = /^([.|#])?([\\w])+/i\n\n    for (let i = 0; i < length; i += 1) {\n      token = tokens[i]\n      type = token[0]\n\n      if (type === 'comment' && node.type === 'rule') {\n        prev = tokens[i - 1]\n        next = tokens[i + 1]\n\n        if (\n          prev[0] !== 'space' &&\n          next[0] !== 'space' &&\n          pattern.test(prev[1]) &&\n          pattern.test(next[1])\n        ) {\n          value += token[1]\n        } else {\n          clean = false\n        }\n\n        continue\n      }\n\n      if (type === 'comment' || (type === 'space' && i === length - 1)) {\n        clean = false\n      } else {\n        value += token[1]\n      }\n    }\n    if (!clean) {\n      let raw = tokens.reduce((all, i) => all + i[1], '')\n      node.raws[prop] = { value, raw }\n    }\n    node[prop] = value\n  }\n\n  spacesAndCommentsFromEnd (tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  spacesAndCommentsFromStart (tokens) {\n    let next\n    let spaces = ''\n    while (tokens.length) {\n      next = tokens[0][0]\n      if (next !== 'space' && next !== 'comment') break\n      spaces += tokens.shift()[1]\n    }\n    return spaces\n  }\n\n  spacesFromEnd (tokens) {\n    let lastTokenType\n    let spaces = ''\n    while (tokens.length) {\n      lastTokenType = tokens[tokens.length - 1][0]\n      if (lastTokenType !== 'space') break\n      spaces = tokens.pop()[1] + spaces\n    }\n    return spaces\n  }\n\n  stringFrom (tokens, from) {\n    let result = ''\n    for (let i = from; i < tokens.length; i++) {\n      result += tokens[i][1]\n    }\n    tokens.splice(from, tokens.length - from)\n    return result\n  }\n\n  colon (tokens) {\n    let brackets = 0\n    let token, type, prev\n    for (let i = 0; i < tokens.length; i++) {\n      token = tokens[i]\n      type = token[0]\n\n      if (type === '(') {\n        brackets += 1\n      }\n      if (type === ')') {\n        brackets -= 1\n      }\n      if (brackets === 0 && type === ':') {\n        if (!prev) {\n          this.doubleColon(token)\n        } else if (prev[0] === 'word' && prev[1] === 'progid') {\n          continue\n        } else {\n          return i\n        }\n      }\n\n      prev = token\n    }\n    return false\n  }\n\n  // Errors\n\n  unclosedBracket (bracket) {\n    throw this.input.error('Unclosed bracket', bracket[2], bracket[3])\n  }\n\n  unknownWord (tokens) {\n    throw this.input.error('Unknown word', tokens[0][2], tokens[0][3])\n  }\n\n  unexpectedClose (token) {\n    throw this.input.error('Unexpected }', token[2], token[3])\n  }\n\n  unclosedBlock () {\n    let pos = this.current.source.start\n    throw this.input.error('Unclosed block', pos.line, pos.column)\n  }\n\n  doubleColon (token) {\n    throw this.input.error('Double colon', token[2], token[3])\n  }\n\n  unnamedAtrule (node, token) {\n    throw this.input.error('At-rule without name', token[2], token[3])\n  }\n\n  precheckMissedSemicolon (/* tokens */) {\n    // Hook for Safe Parser\n  }\n\n  checkMissedSemicolon (tokens) {\n    let colon = this.colon(tokens)\n    if (colon === false) return\n\n    let founded = 0\n    let token\n    for (let j = colon - 1; j >= 0; j--) {\n      token = tokens[j]\n      if (token[0] !== 'space') {\n        founded += 1\n        if (founded === 2) break\n      }\n    }\n    throw this.input.error('Missed semicolon', token[2], token[3])\n  }\n}\n"]},"metadata":{},"sourceType":"script"}