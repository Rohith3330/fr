{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getWrappingFixer = void 0;\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n/**\n * Wraps node with some code. Adds parenthesis as necessary.\n * @returns Fixer which adds the specified code and parens if necessary.\n */\n\n\nfunction getWrappingFixer(params) {\n  const {\n    sourceCode,\n    node,\n    innerNode = node,\n    wrap\n  } = params;\n  const innerNodes = Array.isArray(innerNode) ? innerNode : [innerNode];\n  return fixer => {\n    const innerCodes = innerNodes.map(innerNode => {\n      let code = sourceCode.getText(innerNode); // check the inner expression's precedence\n\n      if (!isStrongPrecedenceNode(innerNode)) {\n        // the code we are adding might have stronger precedence than our wrapped node\n        // let's wrap our node in parens in case it has a weaker precedence than the code we are wrapping it in\n        code = `(${code})`;\n      }\n\n      return code;\n    }); // do the wrapping\n\n    let code = wrap(...innerCodes); // check the outer expression's precedence\n\n    if (isWeakPrecedenceParent(node)) {\n      // we wrapped the node in some expression which very likely has a different precedence than original wrapped node\n      // let's wrap the whole expression in parens just in case\n      if (!utils_1.ASTUtils.isParenthesized(node, sourceCode)) {\n        code = `(${code})`;\n      }\n    } // check if we need to insert semicolon\n\n\n    if (/^[`([]/.exec(code) && isMissingSemicolonBefore(node, sourceCode)) {\n      code = `;${code}`;\n    }\n\n    return fixer.replaceText(node, code);\n  };\n}\n\nexports.getWrappingFixer = getWrappingFixer;\n/**\n * Check if a node will always have the same precedence if it's parent changes.\n */\n\nfunction isStrongPrecedenceNode(innerNode) {\n  return innerNode.type === utils_1.AST_NODE_TYPES.Literal || innerNode.type === utils_1.AST_NODE_TYPES.Identifier || innerNode.type === utils_1.AST_NODE_TYPES.ArrayExpression || innerNode.type === utils_1.AST_NODE_TYPES.ObjectExpression || innerNode.type === utils_1.AST_NODE_TYPES.MemberExpression || innerNode.type === utils_1.AST_NODE_TYPES.CallExpression || innerNode.type === utils_1.AST_NODE_TYPES.NewExpression || innerNode.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression;\n}\n/**\n * Check if a node's parent could have different precedence if the node changes.\n */\n\n\nfunction isWeakPrecedenceParent(node) {\n  const parent = node.parent;\n\n  if (parent.type === utils_1.AST_NODE_TYPES.UpdateExpression || parent.type === utils_1.AST_NODE_TYPES.UnaryExpression || parent.type === utils_1.AST_NODE_TYPES.BinaryExpression || parent.type === utils_1.AST_NODE_TYPES.LogicalExpression || parent.type === utils_1.AST_NODE_TYPES.ConditionalExpression || parent.type === utils_1.AST_NODE_TYPES.AwaitExpression) {\n    return true;\n  }\n\n  if (parent.type === utils_1.AST_NODE_TYPES.MemberExpression && parent.object === node) {\n    return true;\n  }\n\n  if ((parent.type === utils_1.AST_NODE_TYPES.CallExpression || parent.type === utils_1.AST_NODE_TYPES.NewExpression) && parent.callee === node) {\n    return true;\n  }\n\n  if (parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression && parent.tag === node) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Returns true if a node is at the beginning of expression statement and the statement above doesn't end with semicolon.\n * Doesn't check if the node begins with `(`, `[` or `` ` ``.\n */\n\n\nfunction isMissingSemicolonBefore(node, sourceCode) {\n  for (;;) {\n    const parent = node.parent;\n\n    if (parent.type === utils_1.AST_NODE_TYPES.ExpressionStatement) {\n      const block = parent.parent;\n\n      if (block.type === utils_1.AST_NODE_TYPES.Program || block.type === utils_1.AST_NODE_TYPES.BlockStatement) {\n        // parent is an expression statement in a block\n        const statementIndex = block.body.indexOf(parent);\n        const previousStatement = block.body[statementIndex - 1];\n\n        if (statementIndex > 0 && sourceCode.getLastToken(previousStatement).value !== ';') {\n          return true;\n        }\n      }\n    }\n\n    if (!isLeftHandSide(node)) {\n      return false;\n    }\n\n    node = parent;\n  }\n}\n/**\n * Checks if a node is LHS of an operator.\n */\n\n\nfunction isLeftHandSide(node) {\n  const parent = node.parent; // a++\n\n  if (parent.type === utils_1.AST_NODE_TYPES.UpdateExpression) {\n    return true;\n  } // a + b\n\n\n  if ((parent.type === utils_1.AST_NODE_TYPES.BinaryExpression || parent.type === utils_1.AST_NODE_TYPES.LogicalExpression || parent.type === utils_1.AST_NODE_TYPES.AssignmentExpression) && node === parent.left) {\n    return true;\n  } // a ? b : c\n\n\n  if (parent.type === utils_1.AST_NODE_TYPES.ConditionalExpression && node === parent.test) {\n    return true;\n  } // a(b)\n\n\n  if (parent.type === utils_1.AST_NODE_TYPES.CallExpression && node === parent.callee) {\n    return true;\n  } // a`b`\n\n\n  if (parent.type === utils_1.AST_NODE_TYPES.TaggedTemplateExpression && node === parent.tag) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"mappings":"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","names":["getWrappingFixer","params","sourceCode","node","innerNode","wrap","innerNodes","Array","isArray","fixer","innerCodes","map","code","getText","isStrongPrecedenceNode","isWeakPrecedenceParent","utils_1","isParenthesized","exec","isMissingSemicolonBefore","replaceText","exports","type","Literal","Identifier","ArrayExpression","ObjectExpression","MemberExpression","CallExpression","NewExpression","TaggedTemplateExpression","parent","UpdateExpression","UnaryExpression","BinaryExpression","LogicalExpression","ConditionalExpression","AwaitExpression","object","callee","tag","ExpressionStatement","block","Program","BlockStatement","statementIndex","body","indexOf","previousStatement","getLastToken","value","isLeftHandSide","AssignmentExpression","left","test"],"sources":["../../src/util/getWrappingFixer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}