{"ast":null,"code":"/**\n * @fileoverview Utility functions for JSX\n */\n'use strict';\n\nconst elementType = require('jsx-ast-utils/elementType');\n\nconst astUtil = require('./ast');\n\nconst isCreateElement = require('./isCreateElement');\n\nconst variableUtil = require('./variable'); // See https://github.com/babel/babel/blob/ce420ba51c68591e057696ef43e028f41c6e04cd/packages/babel-types/src/validators/react/isCompatTag.js\n// for why we only test for the first character\n\n\nconst COMPAT_TAG_REGEX = /^[a-z]/;\n/**\n * Checks if a node represents a DOM element according to React.\n * @param {object} node - JSXOpeningElement to check.\n * @returns {boolean} Whether or not the node corresponds to a DOM element.\n */\n\nfunction isDOMComponent(node) {\n  const name = elementType(node);\n  return COMPAT_TAG_REGEX.test(name);\n}\n/**\n * Test whether a JSXElement is a fragment\n * @param {JSXElement} node\n * @param {string} reactPragma\n * @param {string} fragmentPragma\n * @returns {boolean}\n */\n\n\nfunction isFragment(node, reactPragma, fragmentPragma) {\n  const name = node.openingElement.name; // <Fragment>\n\n  if (name.type === 'JSXIdentifier' && name.name === fragmentPragma) {\n    return true;\n  } // <React.Fragment>\n\n\n  if (name.type === 'JSXMemberExpression' && name.object.type === 'JSXIdentifier' && name.object.name === reactPragma && name.property.type === 'JSXIdentifier' && name.property.name === fragmentPragma) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Checks if a node represents a JSX element or fragment.\n * @param {object} node - node to check.\n * @returns {boolean} Whether or not the node if a JSX element or fragment.\n */\n\n\nfunction isJSX(node) {\n  return node && ['JSXElement', 'JSXFragment'].indexOf(node.type) >= 0;\n}\n/**\n * Check if node is like `key={...}` as in `<Foo key={...} />`\n * @param {ASTNode} node\n * @returns {boolean}\n */\n\n\nfunction isJSXAttributeKey(node) {\n  return node.type === 'JSXAttribute' && node.name && node.name.type === 'JSXIdentifier' && node.name.name === 'key';\n}\n/**\n * Check if value has only whitespaces\n * @param {string} value\n * @returns {boolean}\n */\n\n\nfunction isWhiteSpaces(value) {\n  return typeof value === 'string' ? /^\\s*$/.test(value) : false;\n}\n/**\n * Check if the node is returning JSX or null\n *\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Context} context The context of `ASTNode`.\n * @param {Boolean} [strict] If true, in a ternary condition the node must return JSX in both cases\n * @param {Boolean} [ignoreNull] If true, null return values will be ignored\n * @returns {Boolean} True if the node is returning JSX or null, false if not\n */\n\n\nfunction isReturningJSX(ASTnode, context, strict, ignoreNull) {\n  const isJSXValue = node => {\n    if (!node) {\n      return false;\n    }\n\n    switch (node.type) {\n      case 'ConditionalExpression':\n        if (strict) {\n          return isJSXValue(node.consequent) && isJSXValue(node.alternate);\n        }\n\n        return isJSXValue(node.consequent) || isJSXValue(node.alternate);\n\n      case 'LogicalExpression':\n        if (strict) {\n          return isJSXValue(node.left) && isJSXValue(node.right);\n        }\n\n        return isJSXValue(node.left) || isJSXValue(node.right);\n\n      case 'SequenceExpression':\n        return isJSXValue(node.expressions[node.expressions.length - 1]);\n\n      case 'JSXElement':\n      case 'JSXFragment':\n        return true;\n\n      case 'CallExpression':\n        return isCreateElement(node, context);\n\n      case 'Literal':\n        if (!ignoreNull && node.value === null) {\n          return true;\n        }\n\n        return false;\n\n      case 'Identifier':\n        {\n          const variable = variableUtil.findVariableByName(context, node.name);\n          return isJSX(variable);\n        }\n\n      default:\n        return false;\n    }\n  };\n\n  let found = false;\n  astUtil.traverseReturns(ASTnode, context, (node, breakTraverse) => {\n    if (isJSXValue(node)) {\n      found = true;\n      breakTraverse();\n    }\n  });\n  return found;\n}\n/**\n * Check if the node is returning only null values\n *\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Context} context The context of `ASTNode`.\n * @returns {Boolean} True if the node is returning only null values\n */\n\n\nfunction isReturningOnlyNull(ASTnode, context) {\n  let found = false;\n  let foundSomethingElse = false;\n  astUtil.traverseReturns(ASTnode, context, node => {\n    // Traverse return statement\n    astUtil.traverse(node, {\n      enter(childNode) {\n        const setFound = () => {\n          found = true;\n          this.skip();\n        };\n\n        const setFoundSomethingElse = () => {\n          foundSomethingElse = true;\n          this.skip();\n        };\n\n        switch (childNode.type) {\n          case 'ReturnStatement':\n            break;\n\n          case 'ConditionalExpression':\n            if (childNode.consequent.value === null && childNode.alternate.value === null) {\n              setFound();\n            }\n\n            break;\n\n          case 'Literal':\n            if (childNode.value === null) {\n              setFound();\n            }\n\n            break;\n\n          default:\n            setFoundSomethingElse();\n        }\n      }\n\n    });\n  });\n  return found && !foundSomethingElse;\n}\n\nmodule.exports = {\n  isDOMComponent,\n  isFragment,\n  isJSX,\n  isJSXAttributeKey,\n  isWhiteSpaces,\n  isReturningJSX,\n  isReturningOnlyNull\n};","map":{"version":3,"names":["elementType","require","astUtil","isCreateElement","variableUtil","COMPAT_TAG_REGEX","isDOMComponent","node","name","test","isFragment","reactPragma","fragmentPragma","openingElement","type","object","property","isJSX","indexOf","isJSXAttributeKey","isWhiteSpaces","value","isReturningJSX","ASTnode","context","strict","ignoreNull","isJSXValue","consequent","alternate","left","right","expressions","length","variable","findVariableByName","found","traverseReturns","breakTraverse","isReturningOnlyNull","foundSomethingElse","traverse","enter","childNode","setFound","skip","setFoundSomethingElse","module","exports"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/util/jsx.js"],"sourcesContent":["/**\n * @fileoverview Utility functions for JSX\n */\n\n'use strict';\n\nconst elementType = require('jsx-ast-utils/elementType');\n\nconst astUtil = require('./ast');\nconst isCreateElement = require('./isCreateElement');\nconst variableUtil = require('./variable');\n\n// See https://github.com/babel/babel/blob/ce420ba51c68591e057696ef43e028f41c6e04cd/packages/babel-types/src/validators/react/isCompatTag.js\n// for why we only test for the first character\nconst COMPAT_TAG_REGEX = /^[a-z]/;\n\n/**\n * Checks if a node represents a DOM element according to React.\n * @param {object} node - JSXOpeningElement to check.\n * @returns {boolean} Whether or not the node corresponds to a DOM element.\n */\nfunction isDOMComponent(node) {\n  const name = elementType(node);\n  return COMPAT_TAG_REGEX.test(name);\n}\n\n/**\n * Test whether a JSXElement is a fragment\n * @param {JSXElement} node\n * @param {string} reactPragma\n * @param {string} fragmentPragma\n * @returns {boolean}\n */\nfunction isFragment(node, reactPragma, fragmentPragma) {\n  const name = node.openingElement.name;\n\n  // <Fragment>\n  if (name.type === 'JSXIdentifier' && name.name === fragmentPragma) {\n    return true;\n  }\n\n  // <React.Fragment>\n  if (\n    name.type === 'JSXMemberExpression'\n    && name.object.type === 'JSXIdentifier'\n    && name.object.name === reactPragma\n    && name.property.type === 'JSXIdentifier'\n    && name.property.name === fragmentPragma\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Checks if a node represents a JSX element or fragment.\n * @param {object} node - node to check.\n * @returns {boolean} Whether or not the node if a JSX element or fragment.\n */\nfunction isJSX(node) {\n  return node && ['JSXElement', 'JSXFragment'].indexOf(node.type) >= 0;\n}\n\n/**\n * Check if node is like `key={...}` as in `<Foo key={...} />`\n * @param {ASTNode} node\n * @returns {boolean}\n */\nfunction isJSXAttributeKey(node) {\n  return node.type === 'JSXAttribute'\n    && node.name\n    && node.name.type === 'JSXIdentifier'\n    && node.name.name === 'key';\n}\n\n/**\n * Check if value has only whitespaces\n * @param {string} value\n * @returns {boolean}\n */\nfunction isWhiteSpaces(value) {\n  return typeof value === 'string' ? /^\\s*$/.test(value) : false;\n}\n\n/**\n * Check if the node is returning JSX or null\n *\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Context} context The context of `ASTNode`.\n * @param {Boolean} [strict] If true, in a ternary condition the node must return JSX in both cases\n * @param {Boolean} [ignoreNull] If true, null return values will be ignored\n * @returns {Boolean} True if the node is returning JSX or null, false if not\n */\nfunction isReturningJSX(ASTnode, context, strict, ignoreNull) {\n  const isJSXValue = (node) => {\n    if (!node) {\n      return false;\n    }\n    switch (node.type) {\n      case 'ConditionalExpression':\n        if (strict) {\n          return isJSXValue(node.consequent) && isJSXValue(node.alternate);\n        }\n        return isJSXValue(node.consequent) || isJSXValue(node.alternate);\n      case 'LogicalExpression':\n        if (strict) {\n          return isJSXValue(node.left) && isJSXValue(node.right);\n        }\n        return isJSXValue(node.left) || isJSXValue(node.right);\n      case 'SequenceExpression':\n        return isJSXValue(node.expressions[node.expressions.length - 1]);\n      case 'JSXElement':\n      case 'JSXFragment':\n        return true;\n      case 'CallExpression':\n        return isCreateElement(node, context);\n      case 'Literal':\n        if (!ignoreNull && node.value === null) {\n          return true;\n        }\n        return false;\n      case 'Identifier': {\n        const variable = variableUtil.findVariableByName(context, node.name);\n        return isJSX(variable);\n      }\n      default:\n        return false;\n    }\n  };\n\n  let found = false;\n  astUtil.traverseReturns(ASTnode, context, (node, breakTraverse) => {\n    if (isJSXValue(node)) {\n      found = true;\n      breakTraverse();\n    }\n  });\n\n  return found;\n}\n\n/**\n * Check if the node is returning only null values\n *\n * @param {ASTNode} ASTnode The AST node being checked\n * @param {Context} context The context of `ASTNode`.\n * @returns {Boolean} True if the node is returning only null values\n */\nfunction isReturningOnlyNull(ASTnode, context) {\n  let found = false;\n  let foundSomethingElse = false;\n  astUtil.traverseReturns(ASTnode, context, (node) => {\n    // Traverse return statement\n    astUtil.traverse(node, {\n      enter(childNode) {\n        const setFound = () => {\n          found = true;\n          this.skip();\n        };\n        const setFoundSomethingElse = () => {\n          foundSomethingElse = true;\n          this.skip();\n        };\n        switch (childNode.type) {\n          case 'ReturnStatement':\n            break;\n          case 'ConditionalExpression':\n            if (childNode.consequent.value === null && childNode.alternate.value === null) {\n              setFound();\n            }\n            break;\n          case 'Literal':\n            if (childNode.value === null) {\n              setFound();\n            }\n            break;\n          default:\n            setFoundSomethingElse();\n        }\n      },\n    });\n  });\n\n  return found && !foundSomethingElse;\n}\n\nmodule.exports = {\n  isDOMComponent,\n  isFragment,\n  isJSX,\n  isJSXAttributeKey,\n  isWhiteSpaces,\n  isReturningJSX,\n  isReturningOnlyNull,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}