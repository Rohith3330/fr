{"ast":null,"code":"/* Generated by `npm run build`, do not edit! */\n\"use strict\";\n\nvar acorn = require(\"acorn\");\n\nvar tt = acorn.tokTypes;\n\nvar privateClassElements = require(\"../private-class-elements\");\n\nfunction maybeParseFieldValue(field) {\n  if (this.eat(tt.eq)) {\n    var oldInFieldValue = this._inFieldValue;\n    this._inFieldValue = true;\n    field.value = this.parseExpression();\n    this._inFieldValue = oldInFieldValue;\n  } else {\n    field.value = null;\n  }\n}\n\nmodule.exports = function (Parser) {\n  Parser = privateClassElements(Parser);\n  return /*@__PURE__*/function (Parser) {\n    function anonymous() {\n      Parser.apply(this, arguments);\n    }\n\n    if (Parser) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create(Parser && Parser.prototype);\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseClassElement = function parseClassElement(_constructorAllowsSuper) {\n      if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type == this.privateNameToken || this.type == tt.bracketL || this.type == tt.string)) {\n        var branch = this._branch();\n\n        if (branch.type == tt.bracketL) {\n          var count = 0;\n\n          do {\n            if (branch.eat(tt.bracketL)) {\n              ++count;\n            } else if (branch.eat(tt.bracketR)) {\n              --count;\n            } else {\n              branch.next();\n            }\n          } while (count > 0);\n        } else {\n          branch.next();\n        }\n\n        if (branch.type == tt.eq || branch.canInsertSemicolon() || branch.type == tt.semi) {\n          var node = this.startNode();\n\n          if (this.type == this.privateNameToken) {\n            this.parsePrivateClassElementName(node);\n          } else {\n            this.parsePropertyName(node);\n          }\n\n          if (node.key.type === \"Identifier\" && node.key.name === \"constructor\" || node.key.type === \"Literal\" && node.key.value === \"constructor\") {\n            this.raise(node.key.start, \"Classes may not have a field called constructor\");\n          }\n\n          maybeParseFieldValue.call(this, node);\n          this.finishNode(node, \"FieldDefinition\");\n          this.semicolon();\n          return node;\n        }\n      }\n\n      return Parser.prototype.parseClassElement.apply(this, arguments);\n    }; // Prohibit arguments in class field initializers\n\n\n    anonymous.prototype.parseIdent = function parseIdent(liberal, isBinding) {\n      var ident = Parser.prototype.parseIdent.call(this, liberal, isBinding);\n\n      if (this._inFieldValue && ident.name == \"arguments\") {\n        this.raise(ident.start, \"A class field initializer may not contain arguments\");\n      }\n\n      return ident;\n    };\n\n    return anonymous;\n  }(Parser);\n};","map":{"version":3,"names":["acorn","require","tt","tokTypes","privateClassElements","maybeParseFieldValue","field","eat","eq","oldInFieldValue","_inFieldValue","value","parseExpression","module","exports","Parser","anonymous","apply","arguments","__proto__","prototype","Object","create","constructor","parseClassElement","_constructorAllowsSuper","options","ecmaVersion","type","name","privateNameToken","bracketL","string","branch","_branch","count","bracketR","next","canInsertSemicolon","semi","node","startNode","parsePrivateClassElementName","parsePropertyName","key","raise","start","call","finishNode","semicolon","parseIdent","liberal","isBinding","ident"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/acorn-node/lib/class-fields/index.js"],"sourcesContent":["/* Generated by `npm run build`, do not edit! */\n\n\"use strict\"\n\nvar acorn = require(\"acorn\")\nvar tt = acorn.tokTypes\nvar privateClassElements = require(\"../private-class-elements\")\n\nfunction maybeParseFieldValue(field) {\n  if (this.eat(tt.eq)) {\n    var oldInFieldValue = this._inFieldValue\n    this._inFieldValue = true\n    field.value = this.parseExpression()\n    this._inFieldValue = oldInFieldValue\n  } else { field.value = null }\n}\n\nmodule.exports = function(Parser) {\n  Parser = privateClassElements(Parser)\n  return /*@__PURE__*/(function (Parser) {\n    function anonymous () {\n      Parser.apply(this, arguments);\n    }\n\n    if ( Parser ) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create( Parser && Parser.prototype );\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseClassElement = function parseClassElement (_constructorAllowsSuper) {\n      if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type == this.privateNameToken || this.type == tt.bracketL || this.type == tt.string)) {\n        var branch = this._branch()\n        if (branch.type == tt.bracketL) {\n          var count = 0\n          do {\n            if (branch.eat(tt.bracketL)) { ++count }\n            else if (branch.eat(tt.bracketR)) { --count }\n            else { branch.next() }\n          } while (count > 0)\n        } else { branch.next() }\n        if (branch.type == tt.eq || branch.canInsertSemicolon() || branch.type == tt.semi) {\n          var node = this.startNode()\n          if (this.type == this.privateNameToken) {\n            this.parsePrivateClassElementName(node)\n          } else {\n            this.parsePropertyName(node)\n          }\n          if ((node.key.type === \"Identifier\" && node.key.name === \"constructor\") ||\n              (node.key.type === \"Literal\" && node.key.value === \"constructor\")) {\n            this.raise(node.key.start, \"Classes may not have a field called constructor\")\n          }\n          maybeParseFieldValue.call(this, node)\n          this.finishNode(node, \"FieldDefinition\")\n          this.semicolon()\n          return node\n        }\n      }\n\n      return Parser.prototype.parseClassElement.apply(this, arguments)\n    };\n\n    // Prohibit arguments in class field initializers\n    anonymous.prototype.parseIdent = function parseIdent (liberal, isBinding) {\n      var ident = Parser.prototype.parseIdent.call(this, liberal, isBinding)\n      if (this._inFieldValue && ident.name == \"arguments\") { this.raise(ident.start, \"A class field initializer may not contain arguments\") }\n      return ident\n    };\n\n    return anonymous;\n  }(Parser))\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}