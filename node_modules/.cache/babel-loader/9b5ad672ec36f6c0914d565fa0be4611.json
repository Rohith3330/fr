{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport assert from \"assert\";\nimport { Emitter } from \"./emit\";\nimport { inherits } from \"util\";\nimport { getTypes } from \"./util\";\n\nfunction Entry() {\n  assert.ok(this instanceof Entry);\n}\n\nfunction FunctionEntry(returnLoc) {\n  Entry.call(this);\n  getTypes().assertLiteral(returnLoc);\n  this.returnLoc = returnLoc;\n}\n\ninherits(FunctionEntry, Entry);\nexports.FunctionEntry = FunctionEntry;\n\nfunction LoopEntry(breakLoc, continueLoc, label) {\n  Entry.call(this);\n  const t = getTypes();\n  t.assertLiteral(breakLoc);\n  t.assertLiteral(continueLoc);\n\n  if (label) {\n    t.assertIdentifier(label);\n  } else {\n    label = null;\n  }\n\n  this.breakLoc = breakLoc;\n  this.continueLoc = continueLoc;\n  this.label = label;\n}\n\ninherits(LoopEntry, Entry);\nexports.LoopEntry = LoopEntry;\n\nfunction SwitchEntry(breakLoc) {\n  Entry.call(this);\n  getTypes().assertLiteral(breakLoc);\n  this.breakLoc = breakLoc;\n}\n\ninherits(SwitchEntry, Entry);\nexports.SwitchEntry = SwitchEntry;\n\nfunction TryEntry(firstLoc, catchEntry, finallyEntry) {\n  Entry.call(this);\n  const t = getTypes();\n  t.assertLiteral(firstLoc);\n\n  if (catchEntry) {\n    assert.ok(catchEntry instanceof CatchEntry);\n  } else {\n    catchEntry = null;\n  }\n\n  if (finallyEntry) {\n    assert.ok(finallyEntry instanceof FinallyEntry);\n  } else {\n    finallyEntry = null;\n  } // Have to have one or the other (or both).\n\n\n  assert.ok(catchEntry || finallyEntry);\n  this.firstLoc = firstLoc;\n  this.catchEntry = catchEntry;\n  this.finallyEntry = finallyEntry;\n}\n\ninherits(TryEntry, Entry);\nexports.TryEntry = TryEntry;\n\nfunction CatchEntry(firstLoc, paramId) {\n  Entry.call(this);\n  const t = getTypes();\n  t.assertLiteral(firstLoc);\n  t.assertIdentifier(paramId);\n  this.firstLoc = firstLoc;\n  this.paramId = paramId;\n}\n\ninherits(CatchEntry, Entry);\nexports.CatchEntry = CatchEntry;\n\nfunction FinallyEntry(firstLoc, afterLoc) {\n  Entry.call(this);\n  const t = getTypes();\n  t.assertLiteral(firstLoc);\n  t.assertLiteral(afterLoc);\n  this.firstLoc = firstLoc;\n  this.afterLoc = afterLoc;\n}\n\ninherits(FinallyEntry, Entry);\nexports.FinallyEntry = FinallyEntry;\n\nfunction LabeledEntry(breakLoc, label) {\n  Entry.call(this);\n  const t = getTypes();\n  t.assertLiteral(breakLoc);\n  t.assertIdentifier(label);\n  this.breakLoc = breakLoc;\n  this.label = label;\n}\n\ninherits(LabeledEntry, Entry);\nexports.LabeledEntry = LabeledEntry;\n\nfunction LeapManager(emitter) {\n  assert.ok(this instanceof LeapManager);\n  assert.ok(emitter instanceof Emitter);\n  this.emitter = emitter;\n  this.entryStack = [new FunctionEntry(emitter.finalLoc)];\n}\n\nlet LMp = LeapManager.prototype;\nexports.LeapManager = LeapManager;\n\nLMp.withEntry = function (entry, callback) {\n  assert.ok(entry instanceof Entry);\n  this.entryStack.push(entry);\n\n  try {\n    callback.call(this.emitter);\n  } finally {\n    let popped = this.entryStack.pop();\n    assert.strictEqual(popped, entry);\n  }\n};\n\nLMp._findLeapLocation = function (property, label) {\n  for (let i = this.entryStack.length - 1; i >= 0; --i) {\n    let entry = this.entryStack[i];\n    let loc = entry[property];\n\n    if (loc) {\n      if (label) {\n        if (entry.label && entry.label.name === label.name) {\n          return loc;\n        }\n      } else if (entry instanceof LabeledEntry) {// Ignore LabeledEntry entries unless we are actually breaking to\n        // a label.\n      } else {\n        return loc;\n      }\n    }\n  }\n\n  return null;\n};\n\nLMp.getBreakLoc = function (label) {\n  return this._findLeapLocation(\"breakLoc\", label);\n};\n\nLMp.getContinueLoc = function (label) {\n  return this._findLeapLocation(\"continueLoc\", label);\n};","map":{"version":3,"names":["assert","Emitter","inherits","getTypes","Entry","ok","FunctionEntry","returnLoc","call","assertLiteral","exports","LoopEntry","breakLoc","continueLoc","label","t","assertIdentifier","SwitchEntry","TryEntry","firstLoc","catchEntry","finallyEntry","CatchEntry","FinallyEntry","paramId","afterLoc","LabeledEntry","LeapManager","emitter","entryStack","finalLoc","LMp","prototype","withEntry","entry","callback","push","popped","pop","strictEqual","_findLeapLocation","property","i","length","loc","name","getBreakLoc","getContinueLoc"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/regenerator-transform/src/leap.js"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport assert from \"assert\";\nimport { Emitter } from \"./emit\";\nimport { inherits } from \"util\";\nimport { getTypes } from \"./util\";\n\nfunction Entry() {\n  assert.ok(this instanceof Entry);\n}\n\nfunction FunctionEntry(returnLoc) {\n  Entry.call(this);\n  getTypes().assertLiteral(returnLoc);\n  this.returnLoc = returnLoc;\n}\n\ninherits(FunctionEntry, Entry);\nexports.FunctionEntry = FunctionEntry;\n\nfunction LoopEntry(breakLoc, continueLoc, label) {\n  Entry.call(this);\n\n  const t = getTypes();\n\n  t.assertLiteral(breakLoc);\n  t.assertLiteral(continueLoc);\n\n  if (label) {\n    t.assertIdentifier(label);\n  } else {\n    label = null;\n  }\n\n  this.breakLoc = breakLoc;\n  this.continueLoc = continueLoc;\n  this.label = label;\n}\n\ninherits(LoopEntry, Entry);\nexports.LoopEntry = LoopEntry;\n\nfunction SwitchEntry(breakLoc) {\n  Entry.call(this);\n  getTypes().assertLiteral(breakLoc);\n  this.breakLoc = breakLoc;\n}\n\ninherits(SwitchEntry, Entry);\nexports.SwitchEntry = SwitchEntry;\n\nfunction TryEntry(firstLoc, catchEntry, finallyEntry) {\n  Entry.call(this);\n\n  const t = getTypes();\n  t.assertLiteral(firstLoc);\n\n  if (catchEntry) {\n    assert.ok(catchEntry instanceof CatchEntry);\n  } else {\n    catchEntry = null;\n  }\n\n  if (finallyEntry) {\n    assert.ok(finallyEntry instanceof FinallyEntry);\n  } else {\n    finallyEntry = null;\n  }\n\n  // Have to have one or the other (or both).\n  assert.ok(catchEntry || finallyEntry);\n\n  this.firstLoc = firstLoc;\n  this.catchEntry = catchEntry;\n  this.finallyEntry = finallyEntry;\n}\n\ninherits(TryEntry, Entry);\nexports.TryEntry = TryEntry;\n\nfunction CatchEntry(firstLoc, paramId) {\n  Entry.call(this);\n\n  const t = getTypes();\n\n  t.assertLiteral(firstLoc);\n  t.assertIdentifier(paramId);\n\n  this.firstLoc = firstLoc;\n  this.paramId = paramId;\n}\n\ninherits(CatchEntry, Entry);\nexports.CatchEntry = CatchEntry;\n\nfunction FinallyEntry(firstLoc, afterLoc) {\n  Entry.call(this);\n  const t = getTypes();\n  t.assertLiteral(firstLoc);\n  t.assertLiteral(afterLoc);\n  this.firstLoc = firstLoc;\n  this.afterLoc = afterLoc;\n}\n\ninherits(FinallyEntry, Entry);\nexports.FinallyEntry = FinallyEntry;\n\nfunction LabeledEntry(breakLoc, label) {\n  Entry.call(this);\n\n  const t = getTypes();\n\n  t.assertLiteral(breakLoc);\n  t.assertIdentifier(label);\n\n  this.breakLoc = breakLoc;\n  this.label = label;\n}\n\ninherits(LabeledEntry, Entry);\nexports.LabeledEntry = LabeledEntry;\n\nfunction LeapManager(emitter) {\n  assert.ok(this instanceof LeapManager);\n\n  assert.ok(emitter instanceof Emitter);\n\n  this.emitter = emitter;\n  this.entryStack = [new FunctionEntry(emitter.finalLoc)];\n}\n\nlet LMp = LeapManager.prototype;\nexports.LeapManager = LeapManager;\n\nLMp.withEntry = function(entry, callback) {\n  assert.ok(entry instanceof Entry);\n  this.entryStack.push(entry);\n  try {\n    callback.call(this.emitter);\n  } finally {\n    let popped = this.entryStack.pop();\n    assert.strictEqual(popped, entry);\n  }\n};\n\nLMp._findLeapLocation = function(property, label) {\n  for (let i = this.entryStack.length - 1; i >= 0; --i) {\n    let entry = this.entryStack[i];\n    let loc = entry[property];\n    if (loc) {\n      if (label) {\n        if (entry.label &&\n            entry.label.name === label.name) {\n          return loc;\n        }\n      } else if (entry instanceof LabeledEntry) {\n        // Ignore LabeledEntry entries unless we are actually breaking to\n        // a label.\n      } else {\n        return loc;\n      }\n    }\n  }\n\n  return null;\n};\n\nLMp.getBreakLoc = function(label) {\n  return this._findLeapLocation(\"breakLoc\", label);\n};\n\nLMp.getContinueLoc = function(label) {\n  return this._findLeapLocation(\"continueLoc\", label);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}