{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;\n\nvar virtualTypes = require(\"./lib/virtual-types\");\n\nvar _debug = require(\"debug\");\n\nvar _index = require(\"../index\");\n\nvar _scope = require(\"../scope\");\n\nvar _t = require(\"@babel/types\");\n\nvar t = _t;\n\nvar _cache = require(\"../cache\");\n\nvar _generator = require(\"@babel/generator\");\n\nvar NodePath_ancestry = require(\"./ancestry\");\n\nvar NodePath_inference = require(\"./inference\");\n\nvar NodePath_replacement = require(\"./replacement\");\n\nvar NodePath_evaluation = require(\"./evaluation\");\n\nvar NodePath_conversion = require(\"./conversion\");\n\nvar NodePath_introspection = require(\"./introspection\");\n\nvar NodePath_context = require(\"./context\");\n\nvar NodePath_removal = require(\"./removal\");\n\nvar NodePath_modification = require(\"./modification\");\n\nvar NodePath_family = require(\"./family\");\n\nvar NodePath_comments = require(\"./comments\");\n\nvar NodePath_virtual_types_validator = require(\"./lib/virtual-types-validator\");\n\nconst {\n  validate\n} = _t;\n\nconst debug = _debug(\"babel\");\n\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get(_ref) {\n    let {\n      hub,\n      parentPath,\n      parent,\n      container,\n      listKey,\n      key\n    } = _ref;\n\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  hasNode() {\n    return this.node != null;\n  }\n\n  buildCodeFrameError(msg) {\n    let Error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SyntaxError;\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n{\n  NodePath.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;\n}\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nObject.assign(NodePath.prototype, NodePath_virtual_types_validator);\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (!t.TYPES.includes(type)) t.TYPES.push(type);\n}\n\nvar _default = NodePath;\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["validate","debug","buildDebug","REMOVED","SHOULD_STOP","SHOULD_SKIP","NodePath","constructor","hub","parent","contexts","state","opts","_traverseFlags","skipKeys","parentPath","container","listKey","key","node","type","data","context","scope","get","Error","targetNode","paths","pathCache","Map","set","path","setup","getScope","isScope","Scope","setData","val","Object","create","getData","def","undefined","hasNode","buildCodeFrameError","msg","SyntaxError","buildError","traverse","visitor","getPathLocation","parts","inList","unshift","join","message","enabled","toString","code","parentKey","shouldSkip","v","shouldStop","removed","assign","prototype","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","_guessExecutionStatusRelativeToDifferentFunctions","_guessExecutionStatusRelativeTo","t","TYPES","typeKey","fn","TypeError","NodePath_virtual_types_validator","keys","virtualTypes","includes","push"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\@babel\\traverse\\src\\path\\index.ts"],"sourcesContent":["import type { HubInterface } from \"../hub\";\nimport type TraversalContext from \"../context\";\nimport * as virtualTypes from \"./lib/virtual-types\";\nimport buildDebug from \"debug\";\nimport traverse from \"../index\";\nimport type { Visitor } from \"../types\";\nimport Scope from \"../scope\";\nimport { validate } from \"@babel/types\";\nimport * as t from \"@babel/types\";\nimport { path as pathCache } from \"../cache\";\nimport generator from \"@babel/generator\";\n\n// NodePath is split across many files.\nimport * as NodePath_ancestry from \"./ancestry\";\nimport * as NodePath_inference from \"./inference\";\nimport * as NodePath_replacement from \"./replacement\";\nimport * as NodePath_evaluation from \"./evaluation\";\nimport * as NodePath_conversion from \"./conversion\";\nimport * as NodePath_introspection from \"./introspection\";\nimport * as NodePath_context from \"./context\";\nimport * as NodePath_removal from \"./removal\";\nimport * as NodePath_modification from \"./modification\";\nimport * as NodePath_family from \"./family\";\nimport * as NodePath_comments from \"./comments\";\nimport * as NodePath_virtual_types_validator from \"./lib/virtual-types-validator\";\nimport type { NodePathAssetions } from \"./generated/asserts\";\nimport type { NodePathValidators } from \"./generated/validators\";\n\nconst debug = buildDebug(\"babel\");\n\nexport const REMOVED = 1 << 0;\nexport const SHOULD_STOP = 1 << 1;\nexport const SHOULD_SKIP = 1 << 2;\n\nclass NodePath<T extends t.Node = t.Node> {\n  constructor(hub: HubInterface, parent: t.ParentMaps[T[\"type\"]]) {\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n\n    this.context = null;\n    this.scope = null;\n  }\n\n  declare parent: t.ParentMaps[T[\"type\"]];\n  declare hub: HubInterface;\n  declare data: Record<string | symbol, unknown>;\n  // TraversalContext is configured by setContext\n  declare context: TraversalContext;\n  declare scope: Scope;\n\n  contexts: Array<TraversalContext> = [];\n  state: any = null;\n  opts: any = null;\n  // this.shouldSkip = false; this.shouldStop = false; this.removed = false;\n  _traverseFlags: number = 0;\n  skipKeys: any = null;\n  parentPath: t.ParentMaps[T[\"type\"]] extends null\n    ? null\n    : NodePath<t.ParentMaps[T[\"type\"]]> | null = null;\n  container: t.Node | Array<t.Node> | null = null;\n  listKey: string | null = null;\n  key: string | number | null = null;\n  node: T = null;\n  type: T[\"type\"] | null = null;\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key,\n  }: {\n    hub?: HubInterface;\n    parentPath: NodePath | null;\n    parent: t.Node;\n    container: t.Node | t.Node[];\n    listKey?: string;\n    key: string | number;\n  }): NodePath {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode =\n      // @ts-expect-error key must present in container\n      container[key];\n\n    let paths = pathCache.get(parent);\n    if (!paths) {\n      paths = new Map();\n      pathCache.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n\n    return path;\n  }\n\n  getScope(scope: Scope): Scope {\n    return this.isScope() ? new Scope(this) : scope;\n  }\n\n  setData(key: string | symbol, val: any): any {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n    return (this.data[key] = val);\n  }\n\n  getData(key: string | symbol, def?: any): any {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  hasNode(): this is NodePath<NonNullable<this[\"node\"]>> {\n    return this.node != null;\n  }\n\n  buildCodeFrameError(\n    msg: string,\n    Error: new () => Error = SyntaxError,\n  ): Error {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse<T>(visitor: Visitor<T>, state: T): void;\n  traverse(visitor: Visitor): void;\n  traverse(visitor: any, state?: any) {\n    traverse(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key: string, node: any) {\n    validate(this.node, key, node);\n    // @ts-expect-error key must present in this.node\n    this.node[key] = node;\n  }\n\n  getPathLocation(): string {\n    const parts = [];\n    let path: NodePath = this;\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while ((path = path.parentPath));\n    return parts.join(\".\");\n  }\n\n  debug(message: string) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return generator(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n    // ignore inList = true as it should depend on `listKey`\n  }\n\n  get parentKey(): string {\n    return (this.listKey || this.key) as string;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n}\n\nObject.assign(\n  NodePath.prototype,\n  NodePath_ancestry,\n  NodePath_inference,\n  NodePath_replacement,\n  NodePath_evaluation,\n  NodePath_conversion,\n  NodePath_introspection,\n  NodePath_context,\n  NodePath_removal,\n  NodePath_modification,\n  NodePath_family,\n  NodePath_comments,\n);\n\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-expect-error The original _guessExecutionStatusRelativeToDifferentFunctions only worked for paths in\n  // different functions, but _guessExecutionStatusRelativeTo works as a replacement in those cases.\n  NodePath.prototype._guessExecutionStatusRelativeToDifferentFunctions =\n    NodePath_introspection._guessExecutionStatusRelativeTo;\n}\n\n// we can not use `import { TYPES } from \"@babel/types\"` here\n// because the transformNamedBabelTypesImportToDestructuring plugin in babel.config.js\n// does not offer live bindings for `TYPES`\n// we can change to `import { TYPES }` when we are publishing ES modules only\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  // @ts-expect-error typeKey must present in t\n  const fn = t[typeKey];\n  // @ts-expect-error augmenting NodePath prototype\n  NodePath.prototype[typeKey] = function (opts: any) {\n    return fn(this.node, opts);\n  };\n\n  // @ts-expect-error augmenting NodePath prototype\n  NodePath.prototype[`assert${type}`] = function (opts: any) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\n// Register virtual types validators after base types validators\nObject.assign(NodePath.prototype, NodePath_virtual_types_validator);\n\nfor (const type of Object.keys(virtualTypes) as (keyof typeof virtualTypes)[]) {\n  if (type[0] === \"_\") continue;\n  if (!t.TYPES.includes(type)) t.TYPES.push(type);\n}\n\ntype NodePathMixins = typeof NodePath_ancestry &\n  typeof NodePath_inference &\n  typeof NodePath_replacement &\n  typeof NodePath_evaluation &\n  typeof NodePath_conversion &\n  typeof NodePath_introspection &\n  typeof NodePath_context &\n  typeof NodePath_removal &\n  typeof NodePath_modification &\n  typeof NodePath_family &\n  typeof NodePath_comments;\n\n// @ts-expect-error TS throws because ensureBlock returns the body node path\n// however, we don't use the return value and treat it as a transform and\n// assertion utilities. For better type inference we annotate it as an\n// assertion method\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ninterface NodePath<T>\n  extends NodePathAssetions,\n    NodePathValidators,\n    NodePathMixins {\n  /**\n   * @see ./conversion.ts for implementation\n   */\n  ensureBlock<\n    T extends\n      | t.Loop\n      | t.WithStatement\n      | t.Function\n      | t.LabeledStatement\n      | t.CatchClause,\n  >(\n    this: NodePath<T>,\n  ): asserts this is NodePath<T & { body: t.BlockStatement }>;\n}\n\nexport default NodePath;\n"]},"metadata":{},"sourceType":"script"}