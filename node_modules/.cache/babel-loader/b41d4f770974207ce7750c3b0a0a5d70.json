{"ast":null,"code":"\"use strict\";\n/**\n * @fileoverview Really small utility functions that didn't deserve their own files\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.upperCaseFirst = exports.MemberNameType = exports.isDefinitionFile = exports.getNameFromMember = exports.getNameFromIndexSignature = exports.getEnumNames = exports.formatWordList = exports.findFirstResult = exports.arraysAreEqual = exports.arrayGroupByToMap = void 0;\n\nconst type_utils_1 = require(\"@typescript-eslint/type-utils\");\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst DEFINITION_EXTENSIONS = [ts.Extension.Dts, ts.Extension.Dcts, ts.Extension.Dmts];\n/**\n * Check if the context file name is *.d.ts or *.d.tsx\n */\n\nfunction isDefinitionFile(fileName) {\n  const lowerFileName = fileName.toLowerCase();\n\n  for (const definitionExt of DEFINITION_EXTENSIONS) {\n    if (lowerFileName.endsWith(definitionExt)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.isDefinitionFile = isDefinitionFile;\n/**\n * Upper cases the first character or the string\n */\n\nfunction upperCaseFirst(str) {\n  return str[0].toUpperCase() + str.slice(1);\n}\n\nexports.upperCaseFirst = upperCaseFirst;\n\nfunction arrayGroupByToMap(array, getKey) {\n  const groups = new Map();\n\n  for (const item of array) {\n    const key = getKey(item);\n    const existing = groups.get(key);\n\n    if (existing) {\n      existing.push(item);\n    } else {\n      groups.set(key, [item]);\n    }\n  }\n\n  return groups;\n}\n\nexports.arrayGroupByToMap = arrayGroupByToMap;\n\nfunction arraysAreEqual(a, b, eq) {\n  return a === b || a !== undefined && b !== undefined && a.length === b.length && a.every((x, idx) => eq(x, b[idx]));\n}\n\nexports.arraysAreEqual = arraysAreEqual;\n/** Returns the first non-`undefined` result. */\n\nfunction findFirstResult(inputs, getResult) {\n  for (const element of inputs) {\n    const result = getResult(element);\n\n    if (result !== undefined) {\n      return result;\n    }\n  }\n\n  return undefined;\n}\n\nexports.findFirstResult = findFirstResult;\n/**\n * Gets a string representation of the name of the index signature.\n */\n\nfunction getNameFromIndexSignature(node) {\n  const propName = node.parameters.find(parameter => parameter.type === utils_1.AST_NODE_TYPES.Identifier);\n  return propName ? propName.name : '(index signature)';\n}\n\nexports.getNameFromIndexSignature = getNameFromIndexSignature;\nvar MemberNameType;\n\n(function (MemberNameType) {\n  MemberNameType[MemberNameType[\"Private\"] = 1] = \"Private\";\n  MemberNameType[MemberNameType[\"Quoted\"] = 2] = \"Quoted\";\n  MemberNameType[MemberNameType[\"Normal\"] = 3] = \"Normal\";\n  MemberNameType[MemberNameType[\"Expression\"] = 4] = \"Expression\";\n})(MemberNameType || (MemberNameType = {}));\n\nexports.MemberNameType = MemberNameType;\n/**\n * Gets a string name representation of the name of the given MethodDefinition\n * or PropertyDefinition node, with handling for computed property names.\n */\n\nfunction getNameFromMember(member, sourceCode) {\n  if (member.key.type === utils_1.AST_NODE_TYPES.Identifier) {\n    return {\n      type: MemberNameType.Normal,\n      name: member.key.name\n    };\n  }\n\n  if (member.key.type === utils_1.AST_NODE_TYPES.PrivateIdentifier) {\n    return {\n      type: MemberNameType.Private,\n      name: `#${member.key.name}`\n    };\n  }\n\n  if (member.key.type === utils_1.AST_NODE_TYPES.Literal) {\n    const name = `${member.key.value}`;\n\n    if ((0, type_utils_1.requiresQuoting)(name)) {\n      return {\n        type: MemberNameType.Quoted,\n        name: `\"${name}\"`\n      };\n    } else {\n      return {\n        type: MemberNameType.Normal,\n        name\n      };\n    }\n  }\n\n  return {\n    type: MemberNameType.Expression,\n    name: sourceCode.text.slice(...member.key.range)\n  };\n}\n\nexports.getNameFromMember = getNameFromMember;\n\nfunction getEnumNames(myEnum) {\n  return Object.keys(myEnum).filter(x => isNaN(parseInt(x)));\n}\n\nexports.getEnumNames = getEnumNames;\n/**\n * Given an array of words, returns an English-friendly concatenation, separated with commas, with\n * the `and` clause inserted before the last item.\n *\n * Example: ['foo', 'bar', 'baz' ] returns the string \"foo, bar, and baz\".\n */\n\nfunction formatWordList(words) {\n  if (!(words === null || words === void 0 ? void 0 : words.length)) {\n    return '';\n  }\n\n  if (words.length === 1) {\n    return words[0];\n  }\n\n  return [words.slice(0, -1).join(', '), words.slice(-1)[0]].join(' and ');\n}\n\nexports.formatWordList = formatWordList;","map":{"version":3,"mappings":"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","names":["DEFINITION_EXTENSIONS","ts","Extension","Dts","Dcts","Dmts","isDefinitionFile","fileName","lowerFileName","toLowerCase","definitionExt","endsWith","exports","upperCaseFirst","str","toUpperCase","slice","arrayGroupByToMap","array","getKey","groups","Map","item","key","existing","get","push","set","arraysAreEqual","a","b","eq","undefined","length","every","x","idx","findFirstResult","inputs","getResult","element","result","getNameFromIndexSignature","node","propName","parameters","find","parameter","type","utils_1","Identifier","name","MemberNameType","getNameFromMember","member","sourceCode","Normal","PrivateIdentifier","Private","Literal","value","Quoted","Expression","text","range","getEnumNames","myEnum","Object","keys","filter","isNaN","parseInt","formatWordList","words","join"],"sources":["../../src/util/misc.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}