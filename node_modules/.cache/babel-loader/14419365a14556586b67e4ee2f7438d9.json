{"ast":null,"code":"/*\n  @license\n\tRollup.js v2.79.0\n\tWed, 31 Aug 2022 04:52:13 GMT - commit 8477f8ff1fe80086556021542b22942ad27a0a69\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\n'use strict';\n\nObject.defineProperty(exports, Symbol.toStringTag, {\n  value: 'Module'\n});\n\nconst require$$0 = require('path');\n\nconst process = require('process');\n\nconst rollup = require('./rollup.js');\n\nconst mergeOptions = require('./mergeOptions.js');\n\nconst require$$2 = require('os');\n\nconst index = require('./index.js');\n\nrequire('perf_hooks');\n\nrequire('crypto');\n\nrequire('fs');\n\nrequire('events');\n\nrequire('util');\n\nrequire('stream');\n\nclass FileWatcher {\n  constructor(task, chokidarOptions) {\n    this.transformWatchers = new Map();\n    this.chokidarOptions = chokidarOptions;\n    this.task = task;\n    this.watcher = this.createWatcher(null);\n  }\n\n  close() {\n    this.watcher.close();\n\n    for (const watcher of this.transformWatchers.values()) {\n      watcher.close();\n    }\n  }\n\n  unwatch(id) {\n    this.watcher.unwatch(id);\n    const transformWatcher = this.transformWatchers.get(id);\n\n    if (transformWatcher) {\n      this.transformWatchers.delete(id);\n      transformWatcher.close();\n    }\n  }\n\n  watch(id, isTransformDependency) {\n    var _a;\n\n    if (isTransformDependency) {\n      const watcher = (_a = this.transformWatchers.get(id)) !== null && _a !== void 0 ? _a : this.createWatcher(id);\n      watcher.add(id);\n      this.transformWatchers.set(id, watcher);\n    } else {\n      this.watcher.add(id);\n    }\n  }\n\n  createWatcher(transformWatcherId) {\n    const task = this.task;\n    const isLinux = require$$2.platform() === 'linux';\n    const isTransformDependency = transformWatcherId !== null;\n\n    const handleChange = (id, event) => {\n      const changedId = transformWatcherId || id;\n\n      if (isLinux) {\n        // unwatching and watching fixes an issue with chokidar where on certain systems,\n        // a file that was unlinked and immediately recreated would create a change event\n        // but then no longer any further events\n        watcher.unwatch(changedId);\n        watcher.add(changedId);\n      }\n\n      task.invalidate(changedId, {\n        event,\n        isTransformDependency\n      });\n    };\n\n    const watcher = index.chokidar.watch([], this.chokidarOptions).on('add', id => handleChange(id, 'create')).on('change', id => handleChange(id, 'update')).on('unlink', id => handleChange(id, 'delete'));\n    return watcher;\n  }\n\n}\n\nconst eventsRewrites = {\n  create: {\n    create: 'buggy',\n    delete: null,\n    update: 'create'\n  },\n  delete: {\n    create: 'update',\n    delete: 'buggy',\n    update: 'buggy'\n  },\n  update: {\n    create: 'buggy',\n    delete: 'delete',\n    update: 'update'\n  }\n};\n\nclass Watcher {\n  constructor(configs, emitter) {\n    this.buildDelay = 0;\n    this.buildTimeout = null;\n    this.invalidatedIds = new Map();\n    this.rerun = false;\n    this.running = true;\n    this.emitter = emitter;\n    emitter.close = this.close.bind(this);\n    this.tasks = configs.map(config => new Task(this, config));\n    this.buildDelay = configs.reduce((buildDelay, _ref) => {\n      let {\n        watch\n      } = _ref;\n      return watch && typeof watch.buildDelay === 'number' ? Math.max(buildDelay, watch.buildDelay) : buildDelay;\n    }, this.buildDelay);\n    process.nextTick(() => this.run());\n  }\n\n  async close() {\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n\n    for (const task of this.tasks) {\n      task.close();\n    }\n\n    await this.emitter.emitAndAwait('close');\n    this.emitter.removeAllListeners();\n  }\n\n  invalidate(file) {\n    if (file) {\n      const prevEvent = this.invalidatedIds.get(file.id);\n      const event = prevEvent ? eventsRewrites[prevEvent][file.event] : file.event;\n\n      if (event === 'buggy') {\n        //TODO: throws or warn? Currently just ignore, uses new event\n        this.invalidatedIds.set(file.id, file.event);\n      } else if (event === null) {\n        this.invalidatedIds.delete(file.id);\n      } else {\n        this.invalidatedIds.set(file.id, event);\n      }\n    }\n\n    if (this.running) {\n      this.rerun = true;\n      return;\n    }\n\n    if (this.buildTimeout) clearTimeout(this.buildTimeout);\n    this.buildTimeout = setTimeout(async () => {\n      this.buildTimeout = null;\n\n      try {\n        await Promise.all([...this.invalidatedIds].map(_ref2 => {\n          let [id, event] = _ref2;\n          return this.emitter.emitAndAwait('change', id, {\n            event\n          });\n        }));\n        this.invalidatedIds.clear();\n        this.emitter.emit('restart');\n        this.emitter.removeAwaited();\n        this.run();\n      } catch (error) {\n        this.invalidatedIds.clear();\n        this.emitter.emit('event', {\n          code: 'ERROR',\n          error,\n          result: null\n        });\n        this.emitter.emit('event', {\n          code: 'END'\n        });\n      }\n    }, this.buildDelay);\n  }\n\n  async run() {\n    this.running = true;\n    this.emitter.emit('event', {\n      code: 'START'\n    });\n\n    for (const task of this.tasks) {\n      await task.run();\n    }\n\n    this.running = false;\n    this.emitter.emit('event', {\n      code: 'END'\n    });\n\n    if (this.rerun) {\n      this.rerun = false;\n      this.invalidate();\n    }\n  }\n\n}\n\nclass Task {\n  constructor(watcher, config) {\n    this.cache = {\n      modules: []\n    };\n    this.watchFiles = [];\n    this.closed = false;\n    this.invalidated = true;\n    this.watched = new Set();\n    this.watcher = watcher;\n    this.skipWrite = Boolean(config.watch && config.watch.skipWrite);\n    this.options = mergeOptions.mergeOptions(config);\n    this.outputs = this.options.output;\n    this.outputFiles = this.outputs.map(output => {\n      if (output.file || output.dir) return require$$0.resolve(output.file || output.dir);\n      return undefined;\n    });\n    const watchOptions = this.options.watch || {};\n    this.filter = rollup.createFilter(watchOptions.include, watchOptions.exclude);\n    this.fileWatcher = new FileWatcher(this, { ...watchOptions.chokidar,\n      disableGlobbing: true,\n      ignoreInitial: true\n    });\n  }\n\n  close() {\n    this.closed = true;\n    this.fileWatcher.close();\n  }\n\n  invalidate(id, details) {\n    this.invalidated = true;\n\n    if (details.isTransformDependency) {\n      for (const module of this.cache.modules) {\n        if (!module.transformDependencies.includes(id)) continue; // effective invalidation\n\n        module.originalCode = null;\n      }\n    }\n\n    this.watcher.invalidate({\n      event: details.event,\n      id\n    });\n  }\n\n  async run() {\n    if (!this.invalidated) return;\n    this.invalidated = false;\n    const options = { ...this.options,\n      cache: this.cache\n    };\n    const start = Date.now();\n    this.watcher.emitter.emit('event', {\n      code: 'BUNDLE_START',\n      input: this.options.input,\n      output: this.outputFiles\n    });\n    let result = null;\n\n    try {\n      result = await rollup.rollupInternal(options, this.watcher.emitter);\n\n      if (this.closed) {\n        return;\n      }\n\n      this.updateWatchedFiles(result);\n      this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));\n      this.watcher.emitter.emit('event', {\n        code: 'BUNDLE_END',\n        duration: Date.now() - start,\n        input: this.options.input,\n        output: this.outputFiles,\n        result\n      });\n    } catch (error) {\n      if (!this.closed) {\n        if (Array.isArray(error.watchFiles)) {\n          for (const id of error.watchFiles) {\n            this.watchFile(id);\n          }\n        }\n\n        if (error.id) {\n          this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n        }\n      }\n\n      this.watcher.emitter.emit('event', {\n        code: 'ERROR',\n        error,\n        result\n      });\n    }\n  }\n\n  updateWatchedFiles(result) {\n    const previouslyWatched = this.watched;\n    this.watched = new Set();\n    this.watchFiles = result.watchFiles;\n    this.cache = result.cache;\n\n    for (const id of this.watchFiles) {\n      this.watchFile(id);\n    }\n\n    for (const module of this.cache.modules) {\n      for (const depId of module.transformDependencies) {\n        this.watchFile(depId, true);\n      }\n    }\n\n    for (const id of previouslyWatched) {\n      if (!this.watched.has(id)) {\n        this.fileWatcher.unwatch(id);\n      }\n    }\n  }\n\n  watchFile(id) {\n    let isTransformDependency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!this.filter(id)) return;\n    this.watched.add(id);\n\n    if (this.outputFiles.some(file => file === id)) {\n      throw new Error('Cannot import the generated bundle');\n    } // this is necessary to ensure that any 'renamed' files\n    // continue to be watched following an error\n\n\n    this.fileWatcher.watch(id, isTransformDependency);\n  }\n\n}\n\nexports.Task = Task;\nexports.Watcher = Watcher;","map":{"version":3,"names":["Object","defineProperty","exports","Symbol","toStringTag","value","require$$0","require","process","rollup","mergeOptions","require$$2","index","FileWatcher","constructor","task","chokidarOptions","transformWatchers","Map","watcher","createWatcher","close","values","unwatch","id","transformWatcher","get","delete","watch","isTransformDependency","_a","add","set","transformWatcherId","isLinux","platform","handleChange","event","changedId","invalidate","chokidar","on","eventsRewrites","create","update","Watcher","configs","emitter","buildDelay","buildTimeout","invalidatedIds","rerun","running","bind","tasks","map","config","Task","reduce","Math","max","nextTick","run","clearTimeout","emitAndAwait","removeAllListeners","file","prevEvent","setTimeout","Promise","all","clear","emit","removeAwaited","error","code","result","cache","modules","watchFiles","closed","invalidated","watched","Set","skipWrite","Boolean","options","outputs","output","outputFiles","dir","resolve","undefined","watchOptions","filter","createFilter","include","exclude","fileWatcher","disableGlobbing","ignoreInitial","details","module","transformDependencies","includes","originalCode","start","Date","now","input","rollupInternal","updateWatchedFiles","write","duration","Array","isArray","watchFile","previouslyWatched","depId","has","some","Error"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/rollup/dist/shared/watch.js"],"sourcesContent":["/*\n  @license\n\tRollup.js v2.79.0\n\tWed, 31 Aug 2022 04:52:13 GMT - commit 8477f8ff1fe80086556021542b22942ad27a0a69\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\n'use strict';\n\nObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\nconst require$$0 = require('path');\nconst process = require('process');\nconst rollup = require('./rollup.js');\nconst mergeOptions = require('./mergeOptions.js');\nconst require$$2 = require('os');\nconst index = require('./index.js');\nrequire('perf_hooks');\nrequire('crypto');\nrequire('fs');\nrequire('events');\nrequire('util');\nrequire('stream');\n\nclass FileWatcher {\n    constructor(task, chokidarOptions) {\n        this.transformWatchers = new Map();\n        this.chokidarOptions = chokidarOptions;\n        this.task = task;\n        this.watcher = this.createWatcher(null);\n    }\n    close() {\n        this.watcher.close();\n        for (const watcher of this.transformWatchers.values()) {\n            watcher.close();\n        }\n    }\n    unwatch(id) {\n        this.watcher.unwatch(id);\n        const transformWatcher = this.transformWatchers.get(id);\n        if (transformWatcher) {\n            this.transformWatchers.delete(id);\n            transformWatcher.close();\n        }\n    }\n    watch(id, isTransformDependency) {\n        var _a;\n        if (isTransformDependency) {\n            const watcher = (_a = this.transformWatchers.get(id)) !== null && _a !== void 0 ? _a : this.createWatcher(id);\n            watcher.add(id);\n            this.transformWatchers.set(id, watcher);\n        }\n        else {\n            this.watcher.add(id);\n        }\n    }\n    createWatcher(transformWatcherId) {\n        const task = this.task;\n        const isLinux = require$$2.platform() === 'linux';\n        const isTransformDependency = transformWatcherId !== null;\n        const handleChange = (id, event) => {\n            const changedId = transformWatcherId || id;\n            if (isLinux) {\n                // unwatching and watching fixes an issue with chokidar where on certain systems,\n                // a file that was unlinked and immediately recreated would create a change event\n                // but then no longer any further events\n                watcher.unwatch(changedId);\n                watcher.add(changedId);\n            }\n            task.invalidate(changedId, { event, isTransformDependency });\n        };\n        const watcher = index.chokidar\n            .watch([], this.chokidarOptions)\n            .on('add', id => handleChange(id, 'create'))\n            .on('change', id => handleChange(id, 'update'))\n            .on('unlink', id => handleChange(id, 'delete'));\n        return watcher;\n    }\n}\n\nconst eventsRewrites = {\n    create: {\n        create: 'buggy',\n        delete: null,\n        update: 'create'\n    },\n    delete: {\n        create: 'update',\n        delete: 'buggy',\n        update: 'buggy'\n    },\n    update: {\n        create: 'buggy',\n        delete: 'delete',\n        update: 'update'\n    }\n};\nclass Watcher {\n    constructor(configs, emitter) {\n        this.buildDelay = 0;\n        this.buildTimeout = null;\n        this.invalidatedIds = new Map();\n        this.rerun = false;\n        this.running = true;\n        this.emitter = emitter;\n        emitter.close = this.close.bind(this);\n        this.tasks = configs.map(config => new Task(this, config));\n        this.buildDelay = configs.reduce((buildDelay, { watch }) => watch && typeof watch.buildDelay === 'number'\n            ? Math.max(buildDelay, watch.buildDelay)\n            : buildDelay, this.buildDelay);\n        process.nextTick(() => this.run());\n    }\n    async close() {\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        for (const task of this.tasks) {\n            task.close();\n        }\n        await this.emitter.emitAndAwait('close');\n        this.emitter.removeAllListeners();\n    }\n    invalidate(file) {\n        if (file) {\n            const prevEvent = this.invalidatedIds.get(file.id);\n            const event = prevEvent ? eventsRewrites[prevEvent][file.event] : file.event;\n            if (event === 'buggy') {\n                //TODO: throws or warn? Currently just ignore, uses new event\n                this.invalidatedIds.set(file.id, file.event);\n            }\n            else if (event === null) {\n                this.invalidatedIds.delete(file.id);\n            }\n            else {\n                this.invalidatedIds.set(file.id, event);\n            }\n        }\n        if (this.running) {\n            this.rerun = true;\n            return;\n        }\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        this.buildTimeout = setTimeout(async () => {\n            this.buildTimeout = null;\n            try {\n                await Promise.all([...this.invalidatedIds].map(([id, event]) => this.emitter.emitAndAwait('change', id, { event })));\n                this.invalidatedIds.clear();\n                this.emitter.emit('restart');\n                this.emitter.removeAwaited();\n                this.run();\n            }\n            catch (error) {\n                this.invalidatedIds.clear();\n                this.emitter.emit('event', {\n                    code: 'ERROR',\n                    error,\n                    result: null\n                });\n                this.emitter.emit('event', {\n                    code: 'END'\n                });\n            }\n        }, this.buildDelay);\n    }\n    async run() {\n        this.running = true;\n        this.emitter.emit('event', {\n            code: 'START'\n        });\n        for (const task of this.tasks) {\n            await task.run();\n        }\n        this.running = false;\n        this.emitter.emit('event', {\n            code: 'END'\n        });\n        if (this.rerun) {\n            this.rerun = false;\n            this.invalidate();\n        }\n    }\n}\nclass Task {\n    constructor(watcher, config) {\n        this.cache = { modules: [] };\n        this.watchFiles = [];\n        this.closed = false;\n        this.invalidated = true;\n        this.watched = new Set();\n        this.watcher = watcher;\n        this.skipWrite = Boolean(config.watch && config.watch.skipWrite);\n        this.options = mergeOptions.mergeOptions(config);\n        this.outputs = this.options.output;\n        this.outputFiles = this.outputs.map(output => {\n            if (output.file || output.dir)\n                return require$$0.resolve(output.file || output.dir);\n            return undefined;\n        });\n        const watchOptions = this.options.watch || {};\n        this.filter = rollup.createFilter(watchOptions.include, watchOptions.exclude);\n        this.fileWatcher = new FileWatcher(this, {\n            ...watchOptions.chokidar,\n            disableGlobbing: true,\n            ignoreInitial: true\n        });\n    }\n    close() {\n        this.closed = true;\n        this.fileWatcher.close();\n    }\n    invalidate(id, details) {\n        this.invalidated = true;\n        if (details.isTransformDependency) {\n            for (const module of this.cache.modules) {\n                if (!module.transformDependencies.includes(id))\n                    continue;\n                // effective invalidation\n                module.originalCode = null;\n            }\n        }\n        this.watcher.invalidate({ event: details.event, id });\n    }\n    async run() {\n        if (!this.invalidated)\n            return;\n        this.invalidated = false;\n        const options = {\n            ...this.options,\n            cache: this.cache\n        };\n        const start = Date.now();\n        this.watcher.emitter.emit('event', {\n            code: 'BUNDLE_START',\n            input: this.options.input,\n            output: this.outputFiles\n        });\n        let result = null;\n        try {\n            result = await rollup.rollupInternal(options, this.watcher.emitter);\n            if (this.closed) {\n                return;\n            }\n            this.updateWatchedFiles(result);\n            this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));\n            this.watcher.emitter.emit('event', {\n                code: 'BUNDLE_END',\n                duration: Date.now() - start,\n                input: this.options.input,\n                output: this.outputFiles,\n                result\n            });\n        }\n        catch (error) {\n            if (!this.closed) {\n                if (Array.isArray(error.watchFiles)) {\n                    for (const id of error.watchFiles) {\n                        this.watchFile(id);\n                    }\n                }\n                if (error.id) {\n                    this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n                }\n            }\n            this.watcher.emitter.emit('event', {\n                code: 'ERROR',\n                error,\n                result\n            });\n        }\n    }\n    updateWatchedFiles(result) {\n        const previouslyWatched = this.watched;\n        this.watched = new Set();\n        this.watchFiles = result.watchFiles;\n        this.cache = result.cache;\n        for (const id of this.watchFiles) {\n            this.watchFile(id);\n        }\n        for (const module of this.cache.modules) {\n            for (const depId of module.transformDependencies) {\n                this.watchFile(depId, true);\n            }\n        }\n        for (const id of previouslyWatched) {\n            if (!this.watched.has(id)) {\n                this.fileWatcher.unwatch(id);\n            }\n        }\n    }\n    watchFile(id, isTransformDependency = false) {\n        if (!this.filter(id))\n            return;\n        this.watched.add(id);\n        if (this.outputFiles.some(file => file === id)) {\n            throw new Error('Cannot import the generated bundle');\n        }\n        // this is necessary to ensure that any 'renamed' files\n        // continue to be watched following an error\n        this.fileWatcher.watch(id, isTransformDependency);\n    }\n}\n\nexports.Task = Task;\nexports.Watcher = Watcher;\n//# sourceMappingURL=watch.js.map\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}