{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nconst util_1 = require(\"../util\");\n/**\n * The following is a list of exceptions to the rule\n * Generated via the following script.\n * This is statically defined to save making purposely invalid calls every lint run\n * ```\nSUPPORTED_GLOBALS.flatMap(namespace => {\n  const object = window[namespace];\n    return Object.getOwnPropertyNames(object)\n      .filter(\n        name =>\n          !name.startsWith('_') &&\n          typeof object[name] === 'function',\n      )\n      .map(name => {\n        try {\n          const x = object[name];\n          x();\n        } catch (e) {\n          if (e.message.includes(\"called on non-object\")) {\n            return `${namespace}.${name}`;\n          }\n        }\n      });\n}).filter(Boolean);\n   * ```\n */\n\n\nconst nativelyNotBoundMembers = new Set(['Promise.all', 'Promise.race', 'Promise.resolve', 'Promise.reject', 'Promise.allSettled', 'Object.defineProperties', 'Object.defineProperty', 'Reflect.defineProperty', 'Reflect.deleteProperty', 'Reflect.get', 'Reflect.getOwnPropertyDescriptor', 'Reflect.getPrototypeOf', 'Reflect.has', 'Reflect.isExtensible', 'Reflect.ownKeys', 'Reflect.preventExtensions', 'Reflect.set', 'Reflect.setPrototypeOf']);\nconst SUPPORTED_GLOBALS = ['Number', 'Object', 'String', 'RegExp', 'Symbol', 'Array', 'Proxy', 'Date', 'Infinity', 'Atomics', 'Reflect', 'console', 'Math', 'JSON', 'Intl'];\nconst nativelyBoundMembers = SUPPORTED_GLOBALS.map(namespace => {\n  if (!(namespace in global)) {\n    // node.js might not have namespaces like Intl depending on compilation options\n    // https://nodejs.org/api/intl.html#intl_options_for_building_node_js\n    return [];\n  }\n\n  const object = global[namespace];\n  return Object.getOwnPropertyNames(object).filter(name => !name.startsWith('_') && typeof object[name] === 'function').map(name => `${namespace}.${name}`);\n}).reduce((arr, names) => arr.concat(names), []).filter(name => !nativelyNotBoundMembers.has(name));\n\nconst isNotImported = (symbol, currentSourceFile) => {\n  const {\n    valueDeclaration\n  } = symbol;\n\n  if (!valueDeclaration) {\n    // working around https://github.com/microsoft/TypeScript/issues/31294\n    return false;\n  }\n\n  return !!currentSourceFile && currentSourceFile !== valueDeclaration.getSourceFile();\n};\n\nconst getNodeName = node => node.type === utils_1.AST_NODE_TYPES.Identifier ? node.name : null;\n\nconst getMemberFullName = node => `${getNodeName(node.object)}.${getNodeName(node.property)}`;\n\nconst BASE_MESSAGE = 'Avoid referencing unbound methods which may cause unintentional scoping of `this`.';\nexports.default = util.createRule({\n  name: 'unbound-method',\n  meta: {\n    docs: {\n      description: 'Enforce unbound methods are called with their expected scope',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    messages: {\n      unbound: BASE_MESSAGE,\n      unboundWithoutThisAnnotation: BASE_MESSAGE + '\\n' + 'If your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.'\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        ignoreStatic: {\n          description: 'Whether to skip checking whether `static` methods are correctly bound.',\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }],\n    type: 'problem'\n  },\n  defaultOptions: [{\n    ignoreStatic: false\n  }],\n\n  create(context, _ref) {\n    let [{\n      ignoreStatic\n    }] = _ref;\n    const parserServices = util.getParserServices(context);\n    const checker = parserServices.program.getTypeChecker();\n    const currentSourceFile = parserServices.program.getSourceFile(context.getFilename());\n\n    function checkMethodAndReport(node, symbol) {\n      if (!symbol) {\n        return;\n      }\n\n      const {\n        dangerous,\n        firstParamIsThis\n      } = checkMethod(symbol, ignoreStatic);\n\n      if (dangerous) {\n        context.report({\n          messageId: firstParamIsThis === false ? 'unboundWithoutThisAnnotation' : 'unbound',\n          node\n        });\n      }\n    }\n\n    return {\n      MemberExpression(node) {\n        if (isSafeUse(node)) {\n          return;\n        }\n\n        const objectSymbol = checker.getSymbolAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node.object));\n\n        if (objectSymbol && nativelyBoundMembers.includes(getMemberFullName(node)) && isNotImported(objectSymbol, currentSourceFile)) {\n          return;\n        }\n\n        const originalNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n        checkMethodAndReport(node, checker.getSymbolAtLocation(originalNode));\n      },\n\n      'VariableDeclarator, AssignmentExpression'(node) {\n        const [idNode, initNode] = node.type === utils_1.AST_NODE_TYPES.VariableDeclarator ? [node.id, node.init] : [node.left, node.right];\n\n        if (initNode && idNode.type === utils_1.AST_NODE_TYPES.ObjectPattern) {\n          const tsNode = parserServices.esTreeNodeToTSNodeMap.get(initNode);\n          const rightSymbol = checker.getSymbolAtLocation(tsNode);\n          const initTypes = checker.getTypeAtLocation(tsNode);\n          const notImported = rightSymbol && isNotImported(rightSymbol, currentSourceFile);\n          idNode.properties.forEach(property => {\n            if (property.type === utils_1.AST_NODE_TYPES.Property && property.key.type === utils_1.AST_NODE_TYPES.Identifier) {\n              if (notImported && util.isIdentifier(initNode) && nativelyBoundMembers.includes(`${initNode.name}.${property.key.name}`)) {\n                return;\n              }\n\n              checkMethodAndReport(node, initTypes.getProperty(property.key.name));\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n});\n\nfunction checkMethod(symbol, ignoreStatic) {\n  var _a, _b;\n\n  const {\n    valueDeclaration\n  } = symbol;\n\n  if (!valueDeclaration) {\n    // working around https://github.com/microsoft/TypeScript/issues/31294\n    return {\n      dangerous: false\n    };\n  }\n\n  switch (valueDeclaration.kind) {\n    case ts.SyntaxKind.PropertyDeclaration:\n      return {\n        dangerous: ((_a = valueDeclaration.initializer) === null || _a === void 0 ? void 0 : _a.kind) === ts.SyntaxKind.FunctionExpression\n      };\n\n    case ts.SyntaxKind.MethodDeclaration:\n    case ts.SyntaxKind.MethodSignature:\n      {\n        const decl = valueDeclaration;\n        const firstParam = decl.parameters[0];\n        const firstParamIsThis = (firstParam === null || firstParam === void 0 ? void 0 : firstParam.name.kind) === ts.SyntaxKind.Identifier && (firstParam === null || firstParam === void 0 ? void 0 : firstParam.name.escapedText) === 'this';\n        const thisArgIsVoid = firstParamIsThis && ((_b = firstParam === null || firstParam === void 0 ? void 0 : firstParam.type) === null || _b === void 0 ? void 0 : _b.kind) === ts.SyntaxKind.VoidKeyword;\n        return {\n          dangerous: !thisArgIsVoid && !(ignoreStatic && tsutils.hasModifier((0, util_1.getModifiers)(valueDeclaration), ts.SyntaxKind.StaticKeyword)),\n          firstParamIsThis\n        };\n      }\n  }\n\n  return {\n    dangerous: false\n  };\n}\n\nfunction isSafeUse(node) {\n  const parent = node.parent;\n\n  switch (parent === null || parent === void 0 ? void 0 : parent.type) {\n    case utils_1.AST_NODE_TYPES.IfStatement:\n    case utils_1.AST_NODE_TYPES.ForStatement:\n    case utils_1.AST_NODE_TYPES.MemberExpression:\n    case utils_1.AST_NODE_TYPES.SwitchStatement:\n    case utils_1.AST_NODE_TYPES.UpdateExpression:\n    case utils_1.AST_NODE_TYPES.WhileStatement:\n      return true;\n\n    case utils_1.AST_NODE_TYPES.CallExpression:\n      return parent.callee === node;\n\n    case utils_1.AST_NODE_TYPES.ConditionalExpression:\n      return parent.test === node;\n\n    case utils_1.AST_NODE_TYPES.TaggedTemplateExpression:\n      return parent.tag === node;\n\n    case utils_1.AST_NODE_TYPES.UnaryExpression:\n      // the first case is safe for obvious\n      // reasons. The second one is also fine\n      // since we're returning something falsy\n      return ['typeof', '!', 'void', 'delete'].includes(parent.operator);\n\n    case utils_1.AST_NODE_TYPES.BinaryExpression:\n      return ['instanceof', '==', '!=', '===', '!=='].includes(parent.operator);\n\n    case utils_1.AST_NODE_TYPES.AssignmentExpression:\n      return parent.operator === '=' && (node === parent.left || node.type === utils_1.AST_NODE_TYPES.MemberExpression && node.object.type === utils_1.AST_NODE_TYPES.Super && parent.left.type === utils_1.AST_NODE_TYPES.MemberExpression && parent.left.object.type === utils_1.AST_NODE_TYPES.ThisExpression);\n\n    case utils_1.AST_NODE_TYPES.ChainExpression:\n    case utils_1.AST_NODE_TYPES.TSNonNullExpression:\n    case utils_1.AST_NODE_TYPES.TSAsExpression:\n    case utils_1.AST_NODE_TYPES.TSTypeAssertion:\n      return isSafeUse(parent);\n\n    case utils_1.AST_NODE_TYPES.LogicalExpression:\n      if (parent.operator === '&&' && parent.left === node) {\n        // this is safe, as && will return the left if and only if it's falsy\n        return true;\n      } // in all other cases, it's likely the logical expression will return the method ref\n      // so make sure the parent is a safe usage\n\n\n      return isSafeUse(parent);\n  }\n\n  return false;\n}","map":{"version":3,"mappings":"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","names":["nativelyNotBoundMembers","Set","SUPPORTED_GLOBALS","nativelyBoundMembers","map","namespace","global","object","Object","getOwnPropertyNames","filter","name","startsWith","reduce","arr","names","concat","has","isNotImported","symbol","currentSourceFile","valueDeclaration","getSourceFile","getNodeName","node","type","utils_1","Identifier","getMemberFullName","property","BASE_MESSAGE","exports","util","createRule","meta","docs","description","recommended","requiresTypeChecking","messages","unbound","unboundWithoutThisAnnotation","schema","properties","ignoreStatic","additionalProperties","defaultOptions","create","context","parserServices","getParserServices","checker","program","getTypeChecker","getFilename","checkMethodAndReport","dangerous","firstParamIsThis","checkMethod","report","messageId","MemberExpression","isSafeUse","objectSymbol","getSymbolAtLocation","esTreeNodeToTSNodeMap","get","includes","originalNode","idNode","initNode","VariableDeclarator","id","init","left","right","ObjectPattern","tsNode","rightSymbol","initTypes","getTypeAtLocation","notImported","forEach","Property","key","isIdentifier","getProperty","kind","ts","SyntaxKind","PropertyDeclaration","initializer","_a","FunctionExpression","MethodDeclaration","MethodSignature","decl","firstParam","parameters","escapedText","thisArgIsVoid","_b","VoidKeyword","tsutils","hasModifier","StaticKeyword","parent","IfStatement","ForStatement","SwitchStatement","UpdateExpression","WhileStatement","CallExpression","callee","ConditionalExpression","test","TaggedTemplateExpression","tag","UnaryExpression","operator","BinaryExpression","AssignmentExpression","Super","ThisExpression","ChainExpression","TSNonNullExpression","TSAsExpression","TSTypeAssertion","LogicalExpression"],"sources":["../../src/rules/unbound-method.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}