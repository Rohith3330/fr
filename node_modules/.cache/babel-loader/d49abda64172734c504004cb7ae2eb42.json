{"ast":null,"code":"'use strict';\n\nvar _vm = require('vm');\n\nvar _vm2 = _interopRequireDefault(_vm);\n\nvar _docsUrl = require('../docsUrl');\n\nvar _docsUrl2 = _interopRequireDefault(_docsUrl);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: (0, _docsUrl2['default'])('dynamic-import-chunkname')\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        importFunctions: {\n          type: 'array',\n          uniqueItems: true,\n          items: {\n            type: 'string'\n          }\n        },\n        webpackChunknameFormat: {\n          type: 'string'\n        }\n      }\n    }]\n  },\n  create: function () {\n    function create(context) {\n      var config = context.options[0];\n\n      var _ref = config || {},\n          _ref$importFunctions = _ref.importFunctions,\n          importFunctions = _ref$importFunctions === undefined ? [] : _ref$importFunctions;\n\n      var _ref2 = config || {},\n          _ref2$webpackChunknam = _ref2.webpackChunknameFormat,\n          webpackChunknameFormat = _ref2$webpackChunknam === undefined ? '[0-9a-zA-Z-_/.]+' : _ref2$webpackChunknam;\n\n      var paddedCommentRegex = /^ (\\S[\\s\\S]+\\S) $/;\n      var commentStyleRegex = /^( \\w+: ([\"'][^\"']*[\"']|\\d+|false|true),?)+ $/;\n      var chunkSubstrFormat = ' webpackChunkName: [\"\\']' + String(webpackChunknameFormat) + '[\"\\'],? ';\n      var chunkSubstrRegex = new RegExp(chunkSubstrFormat);\n\n      function run(node, arg) {\n        var sourceCode = context.getSourceCode();\n        var leadingComments = sourceCode.getCommentsBefore ? sourceCode.getCommentsBefore(arg) // This method is available in ESLint >= 4.\n        : sourceCode.getComments(arg).leading; // This method is deprecated in ESLint 7.\n\n        if (!leadingComments || leadingComments.length === 0) {\n          context.report({\n            node: node,\n            message: 'dynamic imports require a leading comment with the webpack chunkname'\n          });\n          return;\n        }\n\n        var isChunknamePresent = false;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = leadingComments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var comment = _step.value;\n\n            if (comment.type !== 'Block') {\n              context.report({\n                node: node,\n                message: 'dynamic imports require a /* foo */ style comment, not a // foo comment'\n              });\n              return;\n            }\n\n            if (!paddedCommentRegex.test(comment.value)) {\n              context.report({\n                node: node,\n                message: 'dynamic imports require a block comment padded with spaces - /* foo */'\n              });\n              return;\n            }\n\n            try {\n              // just like webpack itself does\n              _vm2['default'].runInNewContext('(function() {return {' + String(comment.value) + '}})()');\n            } catch (error) {\n              context.report({\n                node: node,\n                message: 'dynamic imports require a \"webpack\" comment with valid syntax'\n              });\n              return;\n            }\n\n            if (!commentStyleRegex.test(comment.value)) {\n              context.report({\n                node: node,\n                message: 'dynamic imports require a leading comment in the form /*' + chunkSubstrFormat + '*/'\n              });\n              return;\n            }\n\n            if (chunkSubstrRegex.test(comment.value)) {\n              isChunknamePresent = true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator['return']) {\n              _iterator['return']();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        if (!isChunknamePresent) {\n          context.report({\n            node: node,\n            message: 'dynamic imports require a leading comment in the form /*' + chunkSubstrFormat + '*/'\n          });\n        }\n      }\n\n      return {\n        ImportExpression: function () {\n          function ImportExpression(node) {\n            run(node, node.source);\n          }\n\n          return ImportExpression;\n        }(),\n        CallExpression: function () {\n          function CallExpression(node) {\n            if (node.callee.type !== 'Import' && importFunctions.indexOf(node.callee.name) < 0) {\n              return;\n            }\n\n            run(node, node.arguments[0]);\n          }\n\n          return CallExpression;\n        }()\n      };\n    }\n\n    return create;\n  }()\n};","map":{"version":3,"mappings":";;AAAA;;;;AACA;;;;;;;;;;AAEAA,OAAOC,OAAPD,GAAiB;EACfE,MAAM;IACJC,MAAM,YADF;IAEJC,MAAM;MACJC,KAAK,0BAAQ,0BAAR;IADD,CAFF;IAKJC,QAAQ,CAAC;MACPH,MAAM,QADC;MAEPI,YAAY;QACVC,iBAAiB;UACfL,MAAM,OADS;UAEfM,aAAa,IAFE;UAGfC,OAAO;YACLP,MAAM;UADD;QAHQ,CADP;QAQVQ,wBAAwB;UACtBR,MAAM;QADgB;MARd;IAFL,CAAD;EALJ,CADS;EAuBfS,MAvBe;IAAA,gBAuBRC,OAvBQ,EAuBC;MACd,IAAMC,SAASD,QAAQE,OAARF,CAAgB,CAAhBA,CAAf;;MADc,WAEmBC,UAAU,EAF7B;MAAA,gCAENN,eAFM;MAAA,IAENA,eAFM,wCAEY,EAFZ;;MAAA,YAG0CM,UAAU,EAHpD;MAAA,kCAGNH,sBAHM;MAAA,IAGNA,sBAHM,yCAGmB,kBAHnB;;MAKd,IAAMK,qBAAqB,mBAA3B;MACA,IAAMC,oBAAoB,+CAA1B;MACA,IAAMC,wDAA8CP,sBAA9CO,cAAN;MACA,IAAMC,mBAAmB,IAAIC,MAAJ,CAAWF,iBAAX,CAAzB;;MAEA,SAASG,GAAT,CAAaC,IAAb,EAAmBC,GAAnB,EAAwB;QACtB,IAAMC,aAAaX,QAAQY,aAARZ,EAAnB;QACA,IAAMa,kBAAkBF,WAAWG,iBAAXH,GACpBA,WAAWG,iBAAXH,CAA6BD,GAA7BC,CADoBA,CACc;QADdA,EAEpBA,WAAWI,WAAXJ,CAAuBD,GAAvBC,EAA4BK,OAFhC,CAFsB,CAImB;;QAEzC,IAAI,CAACH,eAAD,IAAoBA,gBAAgBI,MAAhBJ,KAA2B,CAAnD,EAAsD;UACpDb,QAAQkB,MAARlB,CAAe;YACbS,UADa;YAEbU,SAAS;UAFI,CAAfnB;UAIA;QACD;;QAED,IAAIoB,qBAAqB,KAAzB;QAdsB;QAAA;QAAA;;QAAA;UAgBtB,qBAAsBP,eAAtB,iBAAsBA,EAAtB,2GAAuC;YAAA,IAA5BQ,OAA4B;;YACrC,IAAIA,QAAQ/B,IAAR+B,KAAiB,OAArB,EAA8B;cAC5BrB,QAAQkB,MAARlB,CAAe;gBACbS,UADa;gBAEbU,SAAS;cAFI,CAAfnB;cAIA;YACD;;YAED,IAAI,CAACG,mBAAmBmB,IAAnBnB,CAAwBkB,QAAQE,KAAhCpB,CAAL,EAA6C;cAC3CH,QAAQkB,MAARlB,CAAe;gBACbS,UADa;gBAEbU;cAFa,CAAfnB;cAIA;YACD;;YAED,IAAI;cACF;cACAwB,gBAAGC,eAAHD,kCAA2CH,QAAQE,KAAnD;YACD,CAHD,CAIA,OAAOG,KAAP,EAAc;cACZ1B,QAAQkB,MAARlB,CAAe;gBACbS,UADa;gBAEbU;cAFa,CAAfnB;cAIA;YACD;;YAED,IAAI,CAACI,kBAAkBkB,IAAlBlB,CAAuBiB,QAAQE,KAA/BnB,CAAL,EAA4C;cAC1CJ,QAAQkB,MAARlB,CAAe;gBACbS,UADa;gBAEbU,sEAC6Dd,iBAD7Dc;cAFa,CAAfnB;cAKA;YACD;;YAED,IAAIM,iBAAiBgB,IAAjBhB,CAAsBe,QAAQE,KAA9BjB,CAAJ,EAA0C;cACxCc,qBAAqB,IAArBA;YACD;UAxDmB;QAAA;UAAAO;UAAAC;QAAA;UAAA;YAAA;cAAAC;YAAA;UAAA;YAAA;cAAA;YAAA;UAAA;QAAA;;QA2DtB,IAAI,CAACT,kBAAL,EAAyB;UACvBpB,QAAQkB,MAARlB,CAAe;YACbS,UADa;YAEbU,sEAC6Dd,iBAD7Dc;UAFa,CAAfnB;QAKD;MACF;;MAED,OAAO;QACL8B,gBADK;UAAA,0BACYrB,IADZ,EACkB;YACrBD,IAAIC,IAAJD,EAAUC,KAAKsB,MAAfvB;UAFG;;UAAA;QAAA;QAKLwB,cALK;UAAA,wBAKUvB,IALV,EAKgB;YACnB,IAAIA,KAAKwB,MAALxB,CAAYnB,IAAZmB,KAAqB,QAArBA,IAAiCd,gBAAgBuC,OAAhBvC,CAAwBc,KAAKwB,MAALxB,CAAY0B,IAApCxC,IAA4C,CAAjF,EAAoF;cAClF;YACD;;YAEDa,IAAIC,IAAJD,EAAUC,KAAK2B,SAAL3B,CAAe,CAAfA,CAAVD;UAVG;;UAAA;QAAA;MAAA,CAAP;IArGa;;IAAA;EAAA;AAAA,CAAjBrB","names":["module","exports","meta","type","docs","url","schema","properties","importFunctions","uniqueItems","items","webpackChunknameFormat","create","context","config","options","paddedCommentRegex","commentStyleRegex","chunkSubstrFormat","chunkSubstrRegex","RegExp","run","node","arg","sourceCode","getSourceCode","leadingComments","getCommentsBefore","getComments","leading","length","report","message","isChunknamePresent","comment","test","value","vm","runInNewContext","error","_didIteratorError","_iteratorError","_iterator","ImportExpression","source","CallExpression","callee","indexOf","name","arguments"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\eslint-plugin-import\\src\\rules\\dynamic-import-chunkname.js"],"sourcesContent":["import vm from 'vm';\nimport docsUrl from '../docsUrl';\n\nmodule.exports = {\n  meta: {\n    type: 'suggestion',\n    docs: {\n      url: docsUrl('dynamic-import-chunkname'),\n    },\n    schema: [{\n      type: 'object',\n      properties: {\n        importFunctions: {\n          type: 'array',\n          uniqueItems: true,\n          items: {\n            type: 'string',\n          },\n        },\n        webpackChunknameFormat: {\n          type: 'string',\n        },\n      },\n    }],\n  },\n\n  create(context) {\n    const config = context.options[0];\n    const { importFunctions = [] } = config || {};\n    const { webpackChunknameFormat = '[0-9a-zA-Z-_/.]+' } = config || {};\n\n    const paddedCommentRegex = /^ (\\S[\\s\\S]+\\S) $/;\n    const commentStyleRegex = /^( \\w+: ([\"'][^\"']*[\"']|\\d+|false|true),?)+ $/;\n    const chunkSubstrFormat = ` webpackChunkName: [\"']${webpackChunknameFormat}[\"'],? `;\n    const chunkSubstrRegex = new RegExp(chunkSubstrFormat);\n\n    function run(node, arg) {\n      const sourceCode = context.getSourceCode();\n      const leadingComments = sourceCode.getCommentsBefore\n        ? sourceCode.getCommentsBefore(arg) // This method is available in ESLint >= 4.\n        : sourceCode.getComments(arg).leading; // This method is deprecated in ESLint 7.\n\n      if (!leadingComments || leadingComments.length === 0) {\n        context.report({\n          node,\n          message: 'dynamic imports require a leading comment with the webpack chunkname',\n        });\n        return;\n      }\n\n      let isChunknamePresent = false;\n\n      for (const comment of leadingComments) {\n        if (comment.type !== 'Block') {\n          context.report({\n            node,\n            message: 'dynamic imports require a /* foo */ style comment, not a // foo comment',\n          });\n          return;\n        }\n\n        if (!paddedCommentRegex.test(comment.value)) {\n          context.report({\n            node,\n            message: `dynamic imports require a block comment padded with spaces - /* foo */`,\n          });\n          return;\n        }\n\n        try {\n          // just like webpack itself does\n          vm.runInNewContext(`(function() {return {${comment.value}}})()`);\n        }\n        catch (error) {\n          context.report({\n            node,\n            message: `dynamic imports require a \"webpack\" comment with valid syntax`,\n          });\n          return;\n        }\n\n        if (!commentStyleRegex.test(comment.value)) {\n          context.report({\n            node,\n            message:\n              `dynamic imports require a leading comment in the form /*${chunkSubstrFormat}*/`,\n          });\n          return;\n        }\n\n        if (chunkSubstrRegex.test(comment.value)) {\n          isChunknamePresent = true;\n        }\n      }\n\n      if (!isChunknamePresent) {\n        context.report({\n          node,\n          message:\n            `dynamic imports require a leading comment in the form /*${chunkSubstrFormat}*/`,\n        });\n      }\n    }\n\n    return {\n      ImportExpression(node) {\n        run(node, node.source);\n      },\n\n      CallExpression(node) {\n        if (node.callee.type !== 'Import' && importFunctions.indexOf(node.callee.name) < 0) {\n          return;\n        }\n\n        run(node, node.arguments[0]);\n      },\n    };\n  },\n};\n"]},"metadata":{},"sourceType":"script"}