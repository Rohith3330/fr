{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;\n\nconst code_1 = require(\"./code\");\n\nconst scope_1 = require(\"./scope\");\n\nvar code_2 = require(\"./code\");\n\nObject.defineProperty(exports, \"_\", {\n  enumerable: true,\n  get: function () {\n    return code_2._;\n  }\n});\nObject.defineProperty(exports, \"str\", {\n  enumerable: true,\n  get: function () {\n    return code_2.str;\n  }\n});\nObject.defineProperty(exports, \"strConcat\", {\n  enumerable: true,\n  get: function () {\n    return code_2.strConcat;\n  }\n});\nObject.defineProperty(exports, \"nil\", {\n  enumerable: true,\n  get: function () {\n    return code_2.nil;\n  }\n});\nObject.defineProperty(exports, \"getProperty\", {\n  enumerable: true,\n  get: function () {\n    return code_2.getProperty;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return code_2.stringify;\n  }\n});\nObject.defineProperty(exports, \"regexpCode\", {\n  enumerable: true,\n  get: function () {\n    return code_2.regexpCode;\n  }\n});\nObject.defineProperty(exports, \"Name\", {\n  enumerable: true,\n  get: function () {\n    return code_2.Name;\n  }\n});\n\nvar scope_2 = require(\"./scope\");\n\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.Scope;\n  }\n});\nObject.defineProperty(exports, \"ValueScope\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.ValueScope;\n  }\n});\nObject.defineProperty(exports, \"ValueScopeName\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.ValueScopeName;\n  }\n});\nObject.defineProperty(exports, \"varKinds\", {\n  enumerable: true,\n  get: function () {\n    return scope_2.varKinds;\n  }\n});\nexports.operators = {\n  GT: new code_1._Code(\">\"),\n  GTE: new code_1._Code(\">=\"),\n  LT: new code_1._Code(\"<\"),\n  LTE: new code_1._Code(\"<=\"),\n  EQ: new code_1._Code(\"===\"),\n  NEQ: new code_1._Code(\"!==\"),\n  NOT: new code_1._Code(\"!\"),\n  OR: new code_1._Code(\"||\"),\n  AND: new code_1._Code(\"&&\"),\n  ADD: new code_1._Code(\"+\")\n};\n\nclass Node {\n  optimizeNodes() {\n    return this;\n  }\n\n  optimizeNames(_names, _constants) {\n    return this;\n  }\n\n}\n\nclass Def extends Node {\n  constructor(varKind, name, rhs) {\n    super();\n    this.varKind = varKind;\n    this.name = name;\n    this.rhs = rhs;\n  }\n\n  render(_ref) {\n    let {\n      es5,\n      _n\n    } = _ref;\n    const varKind = es5 ? scope_1.varKinds.var : this.varKind;\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`;\n    return `${varKind} ${this.name}${rhs};` + _n;\n  }\n\n  optimizeNames(names, constants) {\n    if (!names[this.name.str]) return;\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants);\n    return this;\n  }\n\n  get names() {\n    return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};\n  }\n\n}\n\nclass Assign extends Node {\n  constructor(lhs, rhs, sideEffects) {\n    super();\n    this.lhs = lhs;\n    this.rhs = rhs;\n    this.sideEffects = sideEffects;\n  }\n\n  render(_ref2) {\n    let {\n      _n\n    } = _ref2;\n    return `${this.lhs} = ${this.rhs};` + _n;\n  }\n\n  optimizeNames(names, constants) {\n    if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects) return;\n    this.rhs = optimizeExpr(this.rhs, names, constants);\n    return this;\n  }\n\n  get names() {\n    const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names\n    };\n    return addExprNames(names, this.rhs);\n  }\n\n}\n\nclass AssignOp extends Assign {\n  constructor(lhs, op, rhs, sideEffects) {\n    super(lhs, rhs, sideEffects);\n    this.op = op;\n  }\n\n  render(_ref3) {\n    let {\n      _n\n    } = _ref3;\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n;\n  }\n\n}\n\nclass Label extends Node {\n  constructor(label) {\n    super();\n    this.label = label;\n    this.names = {};\n  }\n\n  render(_ref4) {\n    let {\n      _n\n    } = _ref4;\n    return `${this.label}:` + _n;\n  }\n\n}\n\nclass Break extends Node {\n  constructor(label) {\n    super();\n    this.label = label;\n    this.names = {};\n  }\n\n  render(_ref5) {\n    let {\n      _n\n    } = _ref5;\n    const label = this.label ? ` ${this.label}` : \"\";\n    return `break${label};` + _n;\n  }\n\n}\n\nclass Throw extends Node {\n  constructor(error) {\n    super();\n    this.error = error;\n  }\n\n  render(_ref6) {\n    let {\n      _n\n    } = _ref6;\n    return `throw ${this.error};` + _n;\n  }\n\n  get names() {\n    return this.error.names;\n  }\n\n}\n\nclass AnyCode extends Node {\n  constructor(code) {\n    super();\n    this.code = code;\n  }\n\n  render(_ref7) {\n    let {\n      _n\n    } = _ref7;\n    return `${this.code};` + _n;\n  }\n\n  optimizeNodes() {\n    return `${this.code}` ? this : undefined;\n  }\n\n  optimizeNames(names, constants) {\n    this.code = optimizeExpr(this.code, names, constants);\n    return this;\n  }\n\n  get names() {\n    return this.code instanceof code_1._CodeOrName ? this.code.names : {};\n  }\n\n}\n\nclass ParentNode extends Node {\n  constructor() {\n    let nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    super();\n    this.nodes = nodes;\n  }\n\n  render(opts) {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\");\n  }\n\n  optimizeNodes() {\n    const {\n      nodes\n    } = this;\n    let i = nodes.length;\n\n    while (i--) {\n      const n = nodes[i].optimizeNodes();\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n);else if (n) nodes[i] = n;else nodes.splice(i, 1);\n    }\n\n    return nodes.length > 0 ? this : undefined;\n  }\n\n  optimizeNames(names, constants) {\n    const {\n      nodes\n    } = this;\n    let i = nodes.length;\n\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i];\n      if (n.optimizeNames(names, constants)) continue;\n      subtractNames(names, n.names);\n      nodes.splice(i, 1);\n    }\n\n    return nodes.length > 0 ? this : undefined;\n  }\n\n  get names() {\n    return this.nodes.reduce((names, n) => addNames(names, n.names), {});\n  }\n\n}\n\nclass BlockNode extends ParentNode {\n  render(opts) {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n;\n  }\n\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {}\n\nElse.kind = \"else\";\n\nclass If extends BlockNode {\n  constructor(condition, nodes) {\n    super(nodes);\n    this.condition = condition;\n  }\n\n  render(opts) {\n    let code = `if(${this.condition})` + super.render(opts);\n    if (this.else) code += \"else \" + this.else.render(opts);\n    return code;\n  }\n\n  optimizeNodes() {\n    super.optimizeNodes();\n    const cond = this.condition;\n    if (cond === true) return this.nodes; // else is ignored here\n\n    let e = this.else;\n\n    if (e) {\n      const ns = e.optimizeNodes();\n      e = this.else = Array.isArray(ns) ? new Else(ns) : ns;\n    }\n\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes;\n      if (this.nodes.length) return this;\n      return new If(not(cond), e instanceof If ? [e] : e.nodes);\n    }\n\n    if (cond === false || !this.nodes.length) return undefined;\n    return this;\n  }\n\n  optimizeNames(names, constants) {\n    var _a;\n\n    this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n    if (!(super.optimizeNames(names, constants) || this.else)) return;\n    this.condition = optimizeExpr(this.condition, names, constants);\n    return this;\n  }\n\n  get names() {\n    const names = super.names;\n    addExprNames(names, this.condition);\n    if (this.else) addNames(names, this.else.names);\n    return names;\n  }\n\n}\n\nIf.kind = \"if\";\n\nclass For extends BlockNode {}\n\nFor.kind = \"for\";\n\nclass ForLoop extends For {\n  constructor(iteration) {\n    super();\n    this.iteration = iteration;\n  }\n\n  render(opts) {\n    return `for(${this.iteration})` + super.render(opts);\n  }\n\n  optimizeNames(names, constants) {\n    if (!super.optimizeNames(names, constants)) return;\n    this.iteration = optimizeExpr(this.iteration, names, constants);\n    return this;\n  }\n\n  get names() {\n    return addNames(super.names, this.iteration.names);\n  }\n\n}\n\nclass ForRange extends For {\n  constructor(varKind, name, from, to) {\n    super();\n    this.varKind = varKind;\n    this.name = name;\n    this.from = from;\n    this.to = to;\n  }\n\n  render(opts) {\n    const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;\n    const {\n      name,\n      from,\n      to\n    } = this;\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);\n  }\n\n  get names() {\n    const names = addExprNames(super.names, this.from);\n    return addExprNames(names, this.to);\n  }\n\n}\n\nclass ForIter extends For {\n  constructor(loop, varKind, name, iterable) {\n    super();\n    this.loop = loop;\n    this.varKind = varKind;\n    this.name = name;\n    this.iterable = iterable;\n  }\n\n  render(opts) {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);\n  }\n\n  optimizeNames(names, constants) {\n    if (!super.optimizeNames(names, constants)) return;\n    this.iterable = optimizeExpr(this.iterable, names, constants);\n    return this;\n  }\n\n  get names() {\n    return addNames(super.names, this.iterable.names);\n  }\n\n}\n\nclass Func extends BlockNode {\n  constructor(name, args, async) {\n    super();\n    this.name = name;\n    this.args = args;\n    this.async = async;\n  }\n\n  render(opts) {\n    const _async = this.async ? \"async \" : \"\";\n\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts);\n  }\n\n}\n\nFunc.kind = \"func\";\n\nclass Return extends ParentNode {\n  render(opts) {\n    return \"return \" + super.render(opts);\n  }\n\n}\n\nReturn.kind = \"return\";\n\nclass Try extends BlockNode {\n  render(opts) {\n    let code = \"try\" + super.render(opts);\n    if (this.catch) code += this.catch.render(opts);\n    if (this.finally) code += this.finally.render(opts);\n    return code;\n  }\n\n  optimizeNodes() {\n    var _a, _b;\n\n    super.optimizeNodes();\n    (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();\n    (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();\n    return this;\n  }\n\n  optimizeNames(names, constants) {\n    var _a, _b;\n\n    super.optimizeNames(names, constants);\n    (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);\n    (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);\n    return this;\n  }\n\n  get names() {\n    const names = super.names;\n    if (this.catch) addNames(names, this.catch.names);\n    if (this.finally) addNames(names, this.finally.names);\n    return names;\n  }\n\n}\n\nclass Catch extends BlockNode {\n  constructor(error) {\n    super();\n    this.error = error;\n  }\n\n  render(opts) {\n    return `catch(${this.error})` + super.render(opts);\n  }\n\n}\n\nCatch.kind = \"catch\";\n\nclass Finally extends BlockNode {\n  render(opts) {\n    return \"finally\" + super.render(opts);\n  }\n\n}\n\nFinally.kind = \"finally\";\n\nclass CodeGen {\n  constructor(extScope) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._values = {};\n    this._blockStarts = [];\n    this._constants = {};\n    this.opts = { ...opts,\n      _n: opts.lines ? \"\\n\" : \"\"\n    };\n    this._extScope = extScope;\n    this._scope = new scope_1.Scope({\n      parent: extScope\n    });\n    this._nodes = [new Root()];\n  }\n\n  toString() {\n    return this._root.render(this.opts);\n  } // returns unique name in the internal scope\n\n\n  name(prefix) {\n    return this._scope.name(prefix);\n  } // reserves unique name in the external scope\n\n\n  scopeName(prefix) {\n    return this._extScope.name(prefix);\n  } // reserves unique name in the external scope and assigns value to it\n\n\n  scopeValue(prefixOrName, value) {\n    const name = this._extScope.value(prefixOrName, value);\n\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());\n    vs.add(name);\n    return name;\n  }\n\n  getScopeValue(prefix, keyOrRef) {\n    return this._extScope.getValue(prefix, keyOrRef);\n  } // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n\n\n  scopeRefs(scopeName) {\n    return this._extScope.scopeRefs(scopeName, this._values);\n  }\n\n  scopeCode() {\n    return this._extScope.scopeCode(this._values);\n  }\n\n  _def(varKind, nameOrPrefix, rhs, constant) {\n    const name = this._scope.toName(nameOrPrefix);\n\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs;\n\n    this._leafNode(new Def(varKind, name, rhs));\n\n    return name;\n  } // `const` declaration (`var` in es5 mode)\n\n\n  const(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);\n  } // `let` declaration with optional assignment (`var` in es5 mode)\n\n\n  let(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);\n  } // `var` declaration with optional assignment\n\n\n  var(nameOrPrefix, rhs, _constant) {\n    return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);\n  } // assignment code\n\n\n  assign(lhs, rhs, sideEffects) {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects));\n  } // `+=` code\n\n\n  add(lhs, rhs) {\n    return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));\n  } // appends passed SafeExpr to code or executes Block\n\n\n  code(c) {\n    if (typeof c == \"function\") c();else if (c !== code_1.nil) this._leafNode(new AnyCode(c));\n    return this;\n  } // returns code for object literal for the passed argument list of key-value pairs\n\n\n  object() {\n    const code = [\"{\"];\n\n    for (var _len = arguments.length, keyValues = new Array(_len), _key = 0; _key < _len; _key++) {\n      keyValues[_key] = arguments[_key];\n    }\n\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\");\n      code.push(key);\n\n      if (key !== value || this.opts.es5) {\n        code.push(\":\");\n        (0, code_1.addCodeArg)(code, value);\n      }\n    }\n\n    code.push(\"}\");\n    return new code_1._Code(code);\n  } // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n\n\n  if(condition, thenBody, elseBody) {\n    this._blockNode(new If(condition));\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf();\n    } else if (thenBody) {\n      this.code(thenBody).endIf();\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body');\n    }\n\n    return this;\n  } // `else if` clause - invalid without `if` or after `else` clauses\n\n\n  elseIf(condition) {\n    return this._elseNode(new If(condition));\n  } // `else` clause - only valid after `if` or `else if` clauses\n\n\n  else() {\n    return this._elseNode(new Else());\n  } // end `if` statement (needed if gen.if was used only with condition)\n\n\n  endIf() {\n    return this._endBlockNode(If, Else);\n  }\n\n  _for(node, forBody) {\n    this._blockNode(node);\n\n    if (forBody) this.code(forBody).endFor();\n    return this;\n  } // a generic `for` clause (or statement if `forBody` is passed)\n\n\n  for(iteration, forBody) {\n    return this._for(new ForLoop(iteration), forBody);\n  } // `for` statement for a range of values\n\n\n  forRange(nameOrPrefix, from, to, forBody) {\n    let varKind = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let;\n\n    const name = this._scope.toName(nameOrPrefix);\n\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name));\n  } // `for-of` statement (in es5 mode replace with a normal for loop)\n\n\n  forOf(nameOrPrefix, iterable, forBody) {\n    let varKind = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : scope_1.varKinds.const;\n\n    const name = this._scope.toName(nameOrPrefix);\n\n    if (this.opts.es5) {\n      const arr = iterable instanceof code_1.Name ? iterable : this.var(\"_arr\", iterable);\n      return this.forRange(\"_i\", 0, (0, code_1._)`${arr}.length`, i => {\n        this.var(name, (0, code_1._)`${arr}[${i}]`);\n        forBody(name);\n      });\n    }\n\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name));\n  } // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n\n\n  forIn(nameOrPrefix, obj, forBody) {\n    let varKind = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;\n\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);\n    }\n\n    const name = this._scope.toName(nameOrPrefix);\n\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name));\n  } // end `for` loop\n\n\n  endFor() {\n    return this._endBlockNode(For);\n  } // `label` statement\n\n\n  label(label) {\n    return this._leafNode(new Label(label));\n  } // `break` statement\n\n\n  break(label) {\n    return this._leafNode(new Break(label));\n  } // `return` statement\n\n\n  return(value) {\n    const node = new Return();\n\n    this._blockNode(node);\n\n    this.code(value);\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node');\n    return this._endBlockNode(Return);\n  } // `try` statement\n\n\n  try(tryBody, catchCode, finallyCode) {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"');\n    const node = new Try();\n\n    this._blockNode(node);\n\n    this.code(tryBody);\n\n    if (catchCode) {\n      const error = this.name(\"e\");\n      this._currNode = node.catch = new Catch(error);\n      catchCode(error);\n    }\n\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally();\n      this.code(finallyCode);\n    }\n\n    return this._endBlockNode(Catch, Finally);\n  } // `throw` statement\n\n\n  throw(error) {\n    return this._leafNode(new Throw(error));\n  } // start self-balancing block\n\n\n  block(body, nodeCount) {\n    this._blockStarts.push(this._nodes.length);\n\n    if (body) this.code(body).endBlock(nodeCount);\n    return this;\n  } // end the current self-balancing block\n\n\n  endBlock(nodeCount) {\n    const len = this._blockStarts.pop();\n\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\");\n    const toClose = this._nodes.length - len;\n\n    if (toClose < 0 || nodeCount !== undefined && toClose !== nodeCount) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);\n    }\n\n    this._nodes.length = len;\n    return this;\n  } // `function` heading (or definition if funcBody is passed)\n\n\n  func(name) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : code_1.nil;\n    let async = arguments.length > 2 ? arguments[2] : undefined;\n    let funcBody = arguments.length > 3 ? arguments[3] : undefined;\n\n    this._blockNode(new Func(name, args, async));\n\n    if (funcBody) this.code(funcBody).endFunc();\n    return this;\n  } // end function definition\n\n\n  endFunc() {\n    return this._endBlockNode(Func);\n  }\n\n  optimize() {\n    let n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n    while (n-- > 0) {\n      this._root.optimizeNodes();\n\n      this._root.optimizeNames(this._root.names, this._constants);\n    }\n  }\n\n  _leafNode(node) {\n    this._currNode.nodes.push(node);\n\n    return this;\n  }\n\n  _blockNode(node) {\n    this._currNode.nodes.push(node);\n\n    this._nodes.push(node);\n  }\n\n  _endBlockNode(N1, N2) {\n    const n = this._currNode;\n\n    if (n instanceof N1 || N2 && n instanceof N2) {\n      this._nodes.pop();\n\n      return this;\n    }\n\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`);\n  }\n\n  _elseNode(node) {\n    const n = this._currNode;\n\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"');\n    }\n\n    this._currNode = n.else = node;\n    return this;\n  }\n\n  get _root() {\n    return this._nodes[0];\n  }\n\n  get _currNode() {\n    const ns = this._nodes;\n    return ns[ns.length - 1];\n  }\n\n  set _currNode(node) {\n    const ns = this._nodes;\n    ns[ns.length - 1] = node;\n  }\n\n}\n\nexports.CodeGen = CodeGen;\n\nfunction addNames(names, from) {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0);\n\n  return names;\n}\n\nfunction addExprNames(names, from) {\n  return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;\n}\n\nfunction optimizeExpr(expr, names, constants) {\n  if (expr instanceof code_1.Name) return replaceName(expr);\n  if (!canOptimize(expr)) return expr;\n  return new code_1._Code(expr._items.reduce((items, c) => {\n    if (c instanceof code_1.Name) c = replaceName(c);\n    if (c instanceof code_1._Code) items.push(...c._items);else items.push(c);\n    return items;\n  }, []));\n\n  function replaceName(n) {\n    const c = constants[n.str];\n    if (c === undefined || names[n.str] !== 1) return n;\n    delete names[n.str];\n    return c;\n  }\n\n  function canOptimize(e) {\n    return e instanceof code_1._Code && e._items.some(c => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined);\n  }\n}\n\nfunction subtractNames(names, from) {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0);\n}\n\nfunction not(x) {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : (0, code_1._)`!${par(x)}`;\n}\n\nexports.not = not;\nconst andCode = mappend(exports.operators.AND); // boolean AND (&&) expression with the passed arguments\n\nfunction and() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return args.reduce(andCode);\n}\n\nexports.and = and;\nconst orCode = mappend(exports.operators.OR); // boolean OR (||) expression with the passed arguments\n\nfunction or() {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return args.reduce(orCode);\n}\n\nexports.or = or;\n\nfunction mappend(op) {\n  return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;\n}\n\nfunction par(x) {\n  return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;\n}","map":{"version":3,"mappings":";;;;;;;AACA;;AACA;;AAEA;;AAAQA;EAAAC;EAAAC;IAAA;EAAC;AAAD;AAAGF;EAAAC;EAAAC;IAAA;EAAG;AAAH;AAAKF;EAAAC;EAAAC;IAAA;EAAS;AAAT;AAAWF;EAAAC;EAAAC;IAAA;EAAG;AAAH;AAAKF;EAAAC;EAAAC;IAAA;EAAW;AAAX;AAAaF;EAAAC;EAAAC;IAAA;EAAS;AAAT;AAAWF;EAAAC;EAAAC;IAAA;EAAU;AAAV;AAAYF;EAAAC;EAAAC;IAAA;EAAI;AAAJ;;AACpE;;AAAQF;EAAAC;EAAAC;IAAA;EAAK;AAAL;AAAmBF;EAAAC;EAAAC;IAAA;EAAU;AAAV;AAAYF;EAAAC;EAAAC;IAAA;EAAc;AAAd;AAAgCF;EAAAC;EAAAC;IAAA;EAAQ;AAAR;AAQ1DC,oBAAY;EACvBC,EAAE,EAAE,IAAIC,YAAJ,CAAU,GAAV,CADmB;EAEvBC,GAAG,EAAE,IAAID,YAAJ,CAAU,IAAV,CAFkB;EAGvBE,EAAE,EAAE,IAAIF,YAAJ,CAAU,GAAV,CAHmB;EAIvBG,GAAG,EAAE,IAAIH,YAAJ,CAAU,IAAV,CAJkB;EAKvBI,EAAE,EAAE,IAAIJ,YAAJ,CAAU,KAAV,CALmB;EAMvBK,GAAG,EAAE,IAAIL,YAAJ,CAAU,KAAV,CANkB;EAOvBM,GAAG,EAAE,IAAIN,YAAJ,CAAU,GAAV,CAPkB;EAQvBO,EAAE,EAAE,IAAIP,YAAJ,CAAU,IAAV,CARmB;EASvBQ,GAAG,EAAE,IAAIR,YAAJ,CAAU,IAAV,CATkB;EAUvBS,GAAG,EAAE,IAAIT,YAAJ,CAAU,GAAV;AAVkB,CAAZ;;AAab,MAAeU,IAAf,CAAmB;EAGjBC,aAAa;IACX,OAAO,IAAP;EACD;;EAEDC,aAAa,CAACC,MAAD,EAAoBC,UAApB,EAAyC;IACpD,OAAO,IAAP;EACD;;AATgB;;AAgBnB,MAAMC,GAAN,SAAkBL,IAAlB,CAAsB;EACpBM,YAA6BC,OAA7B,EAA6DC,IAA7D,EAAiFC,GAAjF,EAA+F;IAC7F;IAD2B;IAAgC;IAAoB;EAEhF;;EAEDC,MAAM,OAAqB;IAAA,IAApB;MAACC,GAAD;MAAMC;IAAN,CAAoB;IACzB,MAAML,OAAO,GAAGI,GAAG,GAAGE,iBAASC,GAAZ,GAAkB,KAAKP,OAA1C;IACA,MAAME,GAAG,GAAG,KAAKA,GAAL,KAAaM,SAAb,GAAyB,EAAzB,GAA8B,MAAM,KAAKN,GAAG,EAAxD;IACA,OAAO,GAAGF,OAAO,IAAI,KAAKC,IAAI,GAAGC,GAAG,GAA7B,GAAmCG,EAA1C;EACD;;EAEDV,aAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;IAClD,IAAI,CAACD,KAAK,CAAC,KAAKR,IAAL,CAAUU,GAAX,CAAV,EAA2B;IAC3B,IAAI,KAAKT,GAAT,EAAc,KAAKA,GAAL,GAAWU,YAAY,CAAC,KAAKV,GAAN,EAAWO,KAAX,EAAkBC,SAAlB,CAAvB;IACd,OAAO,IAAP;EACD;;EAEQ,IAALD,KAAK;IACP,OAAO,KAAKP,GAAL,YAAoBnB,kBAApB,GAAkC,KAAKmB,GAAL,CAASO,KAA3C,GAAmD,EAA1D;EACD;;AAnBmB;;AAsBtB,MAAMI,MAAN,SAAqBpB,IAArB,CAAyB;EACvBM,YAAqBe,GAArB,EAAuCZ,GAAvC,EAAuEa,WAAvE,EAA4F;IAC1F;IADmB;IAAkB;IAAgC;EAEtE;;EAEDZ,MAAM,QAAgB;IAAA,IAAf;MAACE;IAAD,CAAe;IACpB,OAAO,GAAG,KAAKS,GAAG,MAAM,KAAKZ,GAAG,GAAzB,GAA+BG,EAAtC;EACD;;EAEDV,aAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;IAClD,IAAI,KAAKI,GAAL,YAAoB/B,WAApB,IAA4B,CAAC0B,KAAK,CAAC,KAAKK,GAAL,CAASH,GAAV,CAAlC,IAAoD,CAAC,KAAKI,WAA9D,EAA2E;IAC3E,KAAKb,GAAL,GAAWU,YAAY,CAAC,KAAKV,GAAN,EAAWO,KAAX,EAAkBC,SAAlB,CAAvB;IACA,OAAO,IAAP;EACD;;EAEQ,IAALD,KAAK;IACP,MAAMA,KAAK,GAAG,KAAKK,GAAL,YAAoB/B,WAApB,GAA2B,EAA3B,GAAgC,EAAC,GAAG,KAAK+B,GAAL,CAASL;IAAb,CAA9C;IACA,OAAOO,YAAY,CAACP,KAAD,EAAQ,KAAKP,GAAb,CAAnB;EACD;;AAlBsB;;AAqBzB,MAAMe,QAAN,SAAuBJ,MAAvB,CAA6B;EAC3Bd,YAAYe,GAAZ,EAAwCI,EAAxC,EAAkDhB,GAAlD,EAAiEa,WAAjE,EAAsF;IACpF,MAAMD,GAAN,EAAWZ,GAAX,EAAgBa,WAAhB;IADsC;EAEvC;;EAEDZ,MAAM,QAAgB;IAAA,IAAf;MAACE;IAAD,CAAe;IACpB,OAAO,GAAG,KAAKS,GAAG,IAAI,KAAKI,EAAE,KAAK,KAAKhB,GAAG,GAAnC,GAAyCG,EAAhD;EACD;;AAP0B;;AAU7B,MAAMc,KAAN,SAAoB1B,IAApB,CAAwB;EAEtBM,YAAqBqB,KAArB,EAAgC;IAC9B;IADmB;IADZ,aAAmB,EAAnB;EAGR;;EAEDjB,MAAM,QAAgB;IAAA,IAAf;MAACE;IAAD,CAAe;IACpB,OAAO,GAAG,KAAKe,KAAK,GAAb,GAAmBf,EAA1B;EACD;;AARqB;;AAWxB,MAAMgB,KAAN,SAAoB5B,IAApB,CAAwB;EAEtBM,YAAqBqB,KAArB,EAAiC;IAC/B;IADmB;IADZ,aAAmB,EAAnB;EAGR;;EAEDjB,MAAM,QAAgB;IAAA,IAAf;MAACE;IAAD,CAAe;IACpB,MAAMe,KAAK,GAAG,KAAKA,KAAL,GAAa,IAAI,KAAKA,KAAK,EAA3B,GAAgC,EAA9C;IACA,OAAO,QAAQA,KAAK,GAAb,GAAmBf,EAA1B;EACD;;AATqB;;AAYxB,MAAMiB,KAAN,SAAoB7B,IAApB,CAAwB;EACtBM,YAAqBwB,KAArB,EAAgC;IAC9B;IADmB;EAEpB;;EAEDpB,MAAM,QAAgB;IAAA,IAAf;MAACE;IAAD,CAAe;IACpB,OAAO,SAAS,KAAKkB,KAAK,GAAnB,GAAyBlB,EAAhC;EACD;;EAEQ,IAALI,KAAK;IACP,OAAO,KAAKc,KAAL,CAAWd,KAAlB;EACD;;AAXqB;;AAcxB,MAAMe,OAAN,SAAsB/B,IAAtB,CAA0B;EACxBM,YAAoB0B,IAApB,EAAkC;IAChC;IADkB;EAEnB;;EAEDtB,MAAM,QAAgB;IAAA,IAAf;MAACE;IAAD,CAAe;IACpB,OAAO,GAAG,KAAKoB,IAAI,GAAZ,GAAkBpB,EAAzB;EACD;;EAEDX,aAAa;IACX,OAAO,GAAG,KAAK+B,IAAI,EAAZ,GAAiB,IAAjB,GAAwBjB,SAA/B;EACD;;EAEDb,aAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;IAClD,KAAKe,IAAL,GAAYb,YAAY,CAAC,KAAKa,IAAN,EAAYhB,KAAZ,EAAmBC,SAAnB,CAAxB;IACA,OAAO,IAAP;EACD;;EAEQ,IAALD,KAAK;IACP,OAAO,KAAKgB,IAAL,YAAqB1C,kBAArB,GAAmC,KAAK0C,IAAL,CAAUhB,KAA7C,GAAqD,EAA5D;EACD;;AApBuB;;AAuB1B,MAAeiB,UAAf,SAAkCjC,IAAlC,CAAsC;EACpCM,cAA4C;IAAA,IAAvB4B,KAAuB,uEAAF,EAAE;IAC1C;IADmB;EAEpB;;EAEDxB,MAAM,CAACyB,IAAD,EAAgB;IACpB,OAAO,KAAKD,KAAL,CAAWE,MAAX,CAAkB,CAACJ,IAAD,EAAOK,CAAP,KAAaL,IAAI,GAAGK,CAAC,CAAC3B,MAAF,CAASyB,IAAT,CAAtC,EAAsD,EAAtD,CAAP;EACD;;EAEDlC,aAAa;IACX,MAAM;MAACiC;IAAD,IAAU,IAAhB;IACA,IAAII,CAAC,GAAGJ,KAAK,CAACK,MAAd;;IACA,OAAOD,CAAC,EAAR,EAAY;MACV,MAAMD,CAAC,GAAGH,KAAK,CAACI,CAAD,CAAL,CAASrC,aAAT,EAAV;MACA,IAAIuC,KAAK,CAACC,OAAN,CAAcJ,CAAd,CAAJ,EAAsBH,KAAK,CAACQ,MAAN,CAAaJ,CAAb,EAAgB,CAAhB,EAAmB,GAAGD,CAAtB,EAAtB,KACK,IAAIA,CAAJ,EAAOH,KAAK,CAACI,CAAD,CAAL,GAAWD,CAAX,CAAP,KACAH,KAAK,CAACQ,MAAN,CAAaJ,CAAb,EAAgB,CAAhB;IACN;;IACD,OAAOJ,KAAK,CAACK,MAAN,GAAe,CAAf,GAAmB,IAAnB,GAA0BxB,SAAjC;EACD;;EAEDb,aAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;IAClD,MAAM;MAACiB;IAAD,IAAU,IAAhB;IACA,IAAII,CAAC,GAAGJ,KAAK,CAACK,MAAd;;IACA,OAAOD,CAAC,EAAR,EAAY;MACV;MACA,MAAMD,CAAC,GAAGH,KAAK,CAACI,CAAD,CAAf;MACA,IAAID,CAAC,CAACnC,aAAF,CAAgBc,KAAhB,EAAuBC,SAAvB,CAAJ,EAAuC;MACvC0B,aAAa,CAAC3B,KAAD,EAAQqB,CAAC,CAACrB,KAAV,CAAb;MACAkB,KAAK,CAACQ,MAAN,CAAaJ,CAAb,EAAgB,CAAhB;IACD;;IACD,OAAOJ,KAAK,CAACK,MAAN,GAAe,CAAf,GAAmB,IAAnB,GAA0BxB,SAAjC;EACD;;EAEQ,IAALC,KAAK;IACP,OAAO,KAAKkB,KAAL,CAAWE,MAAX,CAAkB,CAACpB,KAAD,EAAmBqB,CAAnB,KAAyBO,QAAQ,CAAC5B,KAAD,EAAQqB,CAAC,CAACrB,KAAV,CAAnD,EAAqE,EAArE,CAAP;EACD;;AApCmC;;AA2CtC,MAAe6B,SAAf,SAAiCZ,UAAjC,CAA2C;EACzCvB,MAAM,CAACyB,IAAD,EAAgB;IACpB,OAAO,MAAMA,IAAI,CAACvB,EAAX,GAAgB,MAAMF,MAAN,CAAayB,IAAb,CAAhB,GAAqC,GAArC,GAA2CA,IAAI,CAACvB,EAAvD;EACD;;AAHwC;;AAM3C,MAAMkC,IAAN,SAAmBb,UAAnB,CAA6B;;AAE7B,MAAMc,IAAN,SAAmBF,SAAnB,CAA4B;;AACVE,YAAO,MAAP;;AAGlB,MAAMC,EAAN,SAAiBH,SAAjB,CAA0B;EAGxBvC,YAAoB2C,SAApB,EAA+Cf,KAA/C,EAAkE;IAChE,MAAMA,KAAN;IADkB;EAEnB;;EAEDxB,MAAM,CAACyB,IAAD,EAAgB;IACpB,IAAIH,IAAI,GAAG,MAAM,KAAKiB,SAAS,GAApB,GAA0B,MAAMvC,MAAN,CAAayB,IAAb,CAArC;IACA,IAAI,KAAKe,IAAT,EAAelB,IAAI,IAAI,UAAU,KAAKkB,IAAL,CAAUxC,MAAV,CAAiByB,IAAjB,CAAlB;IACf,OAAOH,IAAP;EACD;;EAED/B,aAAa;IACX,MAAMA,aAAN;IACA,MAAMkD,IAAI,GAAG,KAAKF,SAAlB;IACA,IAAIE,IAAI,KAAK,IAAb,EAAmB,OAAO,KAAKjB,KAAZ,CAHR,CAG0B;;IACrC,IAAIkB,CAAC,GAAG,KAAKF,IAAb;;IACA,IAAIE,CAAJ,EAAO;MACL,MAAMC,EAAE,GAAGD,CAAC,CAACnD,aAAF,EAAX;MACAmD,CAAC,GAAG,KAAKF,IAAL,GAAYV,KAAK,CAACC,OAAN,CAAcY,EAAd,IAAoB,IAAIN,IAAJ,CAASM,EAAT,CAApB,GAAoCA,EAApD;IACD;;IACD,IAAID,CAAJ,EAAO;MACL,IAAID,IAAI,KAAK,KAAb,EAAoB,OAAOC,CAAC,YAAYJ,EAAb,GAAkBI,CAAlB,GAAsBA,CAAC,CAAClB,KAA/B;MACpB,IAAI,KAAKA,KAAL,CAAWK,MAAf,EAAuB,OAAO,IAAP;MACvB,OAAO,IAAIS,EAAJ,CAAOM,GAAG,CAACH,IAAD,CAAV,EAAkBC,CAAC,YAAYJ,EAAb,GAAkB,CAACI,CAAD,CAAlB,GAAwBA,CAAC,CAAClB,KAA5C,CAAP;IACD;;IACD,IAAIiB,IAAI,KAAK,KAAT,IAAkB,CAAC,KAAKjB,KAAL,CAAWK,MAAlC,EAA0C,OAAOxB,SAAP;IAC1C,OAAO,IAAP;EACD;;EAEDb,aAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;;;IAClD,KAAKiC,IAAL,GAAY,WAAKA,IAAL,MAAS,IAAT,IAASK,aAAT,GAAS,MAAT,GAASA,GAAErD,aAAF,CAAgBc,KAAhB,EAAuBC,SAAvB,CAArB;IACA,IAAI,EAAE,MAAMf,aAAN,CAAoBc,KAApB,EAA2BC,SAA3B,KAAyC,KAAKiC,IAAhD,CAAJ,EAA2D;IAC3D,KAAKD,SAAL,GAAiB9B,YAAY,CAAC,KAAK8B,SAAN,EAAiBjC,KAAjB,EAAwBC,SAAxB,CAA7B;IACA,OAAO,IAAP;EACD;;EAEQ,IAALD,KAAK;IACP,MAAMA,KAAK,GAAG,MAAMA,KAApB;IACAO,YAAY,CAACP,KAAD,EAAQ,KAAKiC,SAAb,CAAZ;IACA,IAAI,KAAKC,IAAT,EAAeN,QAAQ,CAAC5B,KAAD,EAAQ,KAAKkC,IAAL,CAAUlC,KAAlB,CAAR;IACf,OAAOA,KAAP;EACD;;AA3CuB;;AACRgC,UAAO,IAAP;;AAiDlB,MAAeQ,GAAf,SAA2BX,SAA3B,CAAoC;;AAClBW,WAAO,KAAP;;AAGlB,MAAMC,OAAN,SAAsBD,GAAtB,CAAyB;EACvBlD,YAAoBoD,SAApB,EAAmC;IACjC;IADkB;EAEnB;;EAEDhD,MAAM,CAACyB,IAAD,EAAgB;IACpB,OAAO,OAAO,KAAKuB,SAAS,GAArB,GAA2B,MAAMhD,MAAN,CAAayB,IAAb,CAAlC;EACD;;EAEDjC,aAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;IAClD,IAAI,CAAC,MAAMf,aAAN,CAAoBc,KAApB,EAA2BC,SAA3B,CAAL,EAA4C;IAC5C,KAAKyC,SAAL,GAAiBvC,YAAY,CAAC,KAAKuC,SAAN,EAAiB1C,KAAjB,EAAwBC,SAAxB,CAA7B;IACA,OAAO,IAAP;EACD;;EAEQ,IAALD,KAAK;IACP,OAAO4B,QAAQ,CAAC,MAAM5B,KAAP,EAAc,KAAK0C,SAAL,CAAe1C,KAA7B,CAAf;EACD;;AAjBsB;;AAoBzB,MAAM2C,QAAN,SAAuBH,GAAvB,CAA0B;EACxBlD,YACmBC,OADnB,EAEmBC,IAFnB,EAGmBoD,IAHnB,EAImBC,EAJnB,EAI+B;IAE7B;IALiB;IACA;IACA;IACA;EAGlB;;EAEDnD,MAAM,CAACyB,IAAD,EAAgB;IACpB,MAAM5B,OAAO,GAAG4B,IAAI,CAACxB,GAAL,GAAWE,iBAASC,GAApB,GAA0B,KAAKP,OAA/C;IACA,MAAM;MAACC,IAAD;MAAOoD,IAAP;MAAaC;IAAb,IAAmB,IAAzB;IACA,OAAO,OAAOtD,OAAO,IAAIC,IAAI,IAAIoD,IAAI,KAAKpD,IAAI,IAAIqD,EAAE,KAAKrD,IAAI,KAAtD,GAA8D,MAAME,MAAN,CAAayB,IAAb,CAArE;EACD;;EAEQ,IAALnB,KAAK;IACP,MAAMA,KAAK,GAAGO,YAAY,CAAC,MAAMP,KAAP,EAAc,KAAK4C,IAAnB,CAA1B;IACA,OAAOrC,YAAY,CAACP,KAAD,EAAQ,KAAK6C,EAAb,CAAnB;EACD;;AAnBuB;;AAsB1B,MAAMC,OAAN,SAAsBN,GAAtB,CAAyB;EACvBlD,YACmByD,IADnB,EAEmBxD,OAFnB,EAGmBC,IAHnB,EAIUwD,QAJV,EAIwB;IAEtB;IALiB;IACA;IACA;IACT;EAGT;;EAEDtD,MAAM,CAACyB,IAAD,EAAgB;IACpB,OAAO,OAAO,KAAK5B,OAAO,IAAI,KAAKC,IAAI,IAAI,KAAKuD,IAAI,IAAI,KAAKC,QAAQ,GAA9D,GAAoE,MAAMtD,MAAN,CAAayB,IAAb,CAA3E;EACD;;EAEDjC,aAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;IAClD,IAAI,CAAC,MAAMf,aAAN,CAAoBc,KAApB,EAA2BC,SAA3B,CAAL,EAA4C;IAC5C,KAAK+C,QAAL,GAAgB7C,YAAY,CAAC,KAAK6C,QAAN,EAAgBhD,KAAhB,EAAuBC,SAAvB,CAA5B;IACA,OAAO,IAAP;EACD;;EAEQ,IAALD,KAAK;IACP,OAAO4B,QAAQ,CAAC,MAAM5B,KAAP,EAAc,KAAKgD,QAAL,CAAchD,KAA5B,CAAf;EACD;;AAtBsB;;AAyBzB,MAAMiD,IAAN,SAAmBpB,SAAnB,CAA4B;EAE1BvC,YAAmBE,IAAnB,EAAsC0D,IAAtC,EAAyDC,KAAzD,EAAwE;IACtE;IADiB;IAAmB;IAAmB;EAExD;;EAEDzD,MAAM,CAACyB,IAAD,EAAgB;IACpB,MAAMiC,MAAM,GAAG,KAAKD,KAAL,GAAa,QAAb,GAAwB,EAAvC;;IACA,OAAO,GAAGC,MAAM,YAAY,KAAK5D,IAAI,IAAI,KAAK0D,IAAI,GAA3C,GAAiD,MAAMxD,MAAN,CAAayB,IAAb,CAAxD;EACD;;AATyB;;AACV8B,YAAO,MAAP;;AAWlB,MAAMI,MAAN,SAAqBpC,UAArB,CAA+B;EAG7BvB,MAAM,CAACyB,IAAD,EAAgB;IACpB,OAAO,YAAY,MAAMzB,MAAN,CAAayB,IAAb,CAAnB;EACD;;AAL4B;;AACbkC,cAAO,QAAP;;AAOlB,MAAMC,GAAN,SAAkBzB,SAAlB,CAA2B;EAIzBnC,MAAM,CAACyB,IAAD,EAAgB;IACpB,IAAIH,IAAI,GAAG,QAAQ,MAAMtB,MAAN,CAAayB,IAAb,CAAnB;IACA,IAAI,KAAKoC,KAAT,EAAgBvC,IAAI,IAAI,KAAKuC,KAAL,CAAW7D,MAAX,CAAkByB,IAAlB,CAAR;IAChB,IAAI,KAAKqC,OAAT,EAAkBxC,IAAI,IAAI,KAAKwC,OAAL,CAAa9D,MAAb,CAAoByB,IAApB,CAAR;IAClB,OAAOH,IAAP;EACD;;EAED/B,aAAa;;;IACX,MAAMA,aAAN;IACA,WAAKsE,KAAL,MAAU,IAAV,IAAUhB,aAAV,GAAU,MAAV,GAAUA,GAAEtD,aAAF,EAAV;IACA,WAAKuE,OAAL,MAAY,IAAZ,IAAYC,aAAZ,GAAY,MAAZ,GAAYA,GAAExE,aAAF,EAAZ;IACA,OAAO,IAAP;EACD;;EAEDC,aAAa,CAACc,KAAD,EAAmBC,SAAnB,EAAuC;;;IAClD,MAAMf,aAAN,CAAoBc,KAApB,EAA2BC,SAA3B;IACA,WAAKsD,KAAL,MAAU,IAAV,IAAUhB,aAAV,GAAU,MAAV,GAAUA,GAAErD,aAAF,CAAgBc,KAAhB,EAAuBC,SAAvB,CAAV;IACA,WAAKuD,OAAL,MAAY,IAAZ,IAAYC,aAAZ,GAAY,MAAZ,GAAYA,GAAEvE,aAAF,CAAgBc,KAAhB,EAAuBC,SAAvB,CAAZ;IACA,OAAO,IAAP;EACD;;EAEQ,IAALD,KAAK;IACP,MAAMA,KAAK,GAAG,MAAMA,KAApB;IACA,IAAI,KAAKuD,KAAT,EAAgB3B,QAAQ,CAAC5B,KAAD,EAAQ,KAAKuD,KAAL,CAAWvD,KAAnB,CAAR;IAChB,IAAI,KAAKwD,OAAT,EAAkB5B,QAAQ,CAAC5B,KAAD,EAAQ,KAAKwD,OAAL,CAAaxD,KAArB,CAAR;IAClB,OAAOA,KAAP;EACD;;AA9BwB;;AAqC3B,MAAM0D,KAAN,SAAoB7B,SAApB,CAA6B;EAE3BvC,YAAqBwB,KAArB,EAAgC;IAC9B;IADmB;EAEpB;;EAEDpB,MAAM,CAACyB,IAAD,EAAgB;IACpB,OAAO,SAAS,KAAKL,KAAK,GAAnB,GAAyB,MAAMpB,MAAN,CAAayB,IAAb,CAAhC;EACD;;AAR0B;;AACXuC,aAAO,OAAP;;AAUlB,MAAMC,OAAN,SAAsB9B,SAAtB,CAA+B;EAE7BnC,MAAM,CAACyB,IAAD,EAAgB;IACpB,OAAO,YAAY,MAAMzB,MAAN,CAAayB,IAAb,CAAnB;EACD;;AAJ4B;;AACbwC,eAAO,SAAP;;AAiClB,MAAaC,OAAb,CAAoB;EASlBtE,YAAYuE,QAAZ,EAA2D;IAAA,IAAzB1C,IAAyB,uEAAF,EAAE;IANlD,eAA0B,EAA1B;IAEQ,oBAAyB,EAAzB;IACA,kBAAwB,EAAxB;IAIf,KAAKA,IAAL,GAAY,EAAC,GAAGA,IAAJ;MAAUvB,EAAE,EAAEuB,IAAI,CAAC2C,KAAL,GAAa,IAAb,GAAoB;IAAlC,CAAZ;IACA,KAAKC,SAAL,GAAiBF,QAAjB;IACA,KAAKG,MAAL,GAAc,IAAInE,aAAJ,CAAU;MAACoE,MAAM,EAAEJ;IAAT,CAAV,CAAd;IACA,KAAKK,MAAL,GAAc,CAAC,IAAIpC,IAAJ,EAAD,CAAd;EACD;;EAEDqC,QAAQ;IACN,OAAO,KAAKC,KAAL,CAAW1E,MAAX,CAAkB,KAAKyB,IAAvB,CAAP;EACD,CAlBiB,CAoBlB;;;EACA3B,IAAI,CAAC6E,MAAD,EAAe;IACjB,OAAO,KAAKL,MAAL,CAAYxE,IAAZ,CAAiB6E,MAAjB,CAAP;EACD,CAvBiB,CAyBlB;;;EACAC,SAAS,CAACD,MAAD,EAAe;IACtB,OAAO,KAAKN,SAAL,CAAevE,IAAf,CAAoB6E,MAApB,CAAP;EACD,CA5BiB,CA8BlB;;;EACAE,UAAU,CAACC,YAAD,EAAwCC,KAAxC,EAAwD;IAChE,MAAMjF,IAAI,GAAG,KAAKuE,SAAL,CAAeU,KAAf,CAAqBD,YAArB,EAAmCC,KAAnC,CAAb;;IACA,MAAMC,EAAE,GAAG,KAAKC,OAAL,CAAanF,IAAI,CAAC6E,MAAlB,MAA8B,KAAKM,OAAL,CAAanF,IAAI,CAAC6E,MAAlB,IAA4B,IAAIO,GAAJ,EAA1D,CAAX;IACAF,EAAE,CAACG,GAAH,CAAOrF,IAAP;IACA,OAAOA,IAAP;EACD;;EAEDsF,aAAa,CAACT,MAAD,EAAiBU,QAAjB,EAAkC;IAC7C,OAAO,KAAKhB,SAAL,CAAeiB,QAAf,CAAwBX,MAAxB,EAAgCU,QAAhC,CAAP;EACD,CAxCiB,CA0ClB;EACA;;;EACAE,SAAS,CAACX,SAAD,EAAgB;IACvB,OAAO,KAAKP,SAAL,CAAekB,SAAf,CAAyBX,SAAzB,EAAoC,KAAKK,OAAzC,CAAP;EACD;;EAEDO,SAAS;IACP,OAAO,KAAKnB,SAAL,CAAemB,SAAf,CAAyB,KAAKP,OAA9B,CAAP;EACD;;EAEOQ,IAAI,CACV5F,OADU,EAEV6F,YAFU,EAGV3F,GAHU,EAIV4F,QAJU,EAIQ;IAElB,MAAM7F,IAAI,GAAG,KAAKwE,MAAL,CAAYsB,MAAZ,CAAmBF,YAAnB,CAAb;;IACA,IAAI3F,GAAG,KAAKM,SAAR,IAAqBsF,QAAzB,EAAmC,KAAKjG,UAAL,CAAgBI,IAAI,CAACU,GAArB,IAA4BT,GAA5B;;IACnC,KAAK8F,SAAL,CAAe,IAAIlG,GAAJ,CAAQE,OAAR,EAAiBC,IAAjB,EAAuBC,GAAvB,CAAf;;IACA,OAAOD,IAAP;EACD,CA9DiB,CAgElB;;;EACAgG,KAAK,CAACJ,YAAD,EAA8B3F,GAA9B,EAA6CgG,SAA7C,EAAgE;IACnE,OAAO,KAAKN,IAAL,CAAUtF,iBAAS2F,KAAnB,EAA0BJ,YAA1B,EAAwC3F,GAAxC,EAA6CgG,SAA7C,CAAP;EACD,CAnEiB,CAqElB;;;EACAC,GAAG,CAACN,YAAD,EAA8B3F,GAA9B,EAA8CgG,SAA9C,EAAiE;IAClE,OAAO,KAAKN,IAAL,CAAUtF,iBAAS6F,GAAnB,EAAwBN,YAAxB,EAAsC3F,GAAtC,EAA2CgG,SAA3C,CAAP;EACD,CAxEiB,CA0ElB;;;EACA3F,GAAG,CAACsF,YAAD,EAA8B3F,GAA9B,EAA8CgG,SAA9C,EAAiE;IAClE,OAAO,KAAKN,IAAL,CAAUtF,iBAASC,GAAnB,EAAwBsF,YAAxB,EAAsC3F,GAAtC,EAA2CgG,SAA3C,CAAP;EACD,CA7EiB,CA+ElB;;;EACAE,MAAM,CAACtF,GAAD,EAAYZ,GAAZ,EAA2Ba,WAA3B,EAAgD;IACpD,OAAO,KAAKiF,SAAL,CAAe,IAAInF,MAAJ,CAAWC,GAAX,EAAgBZ,GAAhB,EAAqBa,WAArB,CAAf,CAAP;EACD,CAlFiB,CAoFlB;;;EACAuE,GAAG,CAACxE,GAAD,EAAYZ,GAAZ,EAAyB;IAC1B,OAAO,KAAK8F,SAAL,CAAe,IAAI/E,QAAJ,CAAaH,GAAb,EAAkBjC,kBAAUW,GAA5B,EAAiCU,GAAjC,CAAf,CAAP;EACD,CAvFiB,CAyFlB;;;EACAuB,IAAI,CAAC4E,CAAD,EAAoB;IACtB,IAAI,OAAOA,CAAP,IAAY,UAAhB,EAA4BA,CAAC,GAA7B,KACK,IAAIA,CAAC,KAAKtH,UAAV,EAAe,KAAKiH,SAAL,CAAe,IAAIxE,OAAJ,CAAY6E,CAAZ,CAAf;IACpB,OAAO,IAAP;EACD,CA9FiB,CAgGlB;;;EACAC,MAAM,GAAmD;IACvD,MAAM7E,IAAI,GAAe,CAAC,GAAD,CAAzB;;IADuD,kCAA/C8E,SAA+C;MAA/CA,SAA+C;IAAA;;IAEvD,KAAK,MAAM,CAACC,GAAD,EAAMtB,KAAN,CAAX,IAA2BqB,SAA3B,EAAsC;MACpC,IAAI9E,IAAI,CAACO,MAAL,GAAc,CAAlB,EAAqBP,IAAI,CAACgF,IAAL,CAAU,GAAV;MACrBhF,IAAI,CAACgF,IAAL,CAAUD,GAAV;;MACA,IAAIA,GAAG,KAAKtB,KAAR,IAAiB,KAAKtD,IAAL,CAAUxB,GAA/B,EAAoC;QAClCqB,IAAI,CAACgF,IAAL,CAAU,GAAV;QACA,uBAAWhF,IAAX,EAAiByD,KAAjB;MACD;IACF;;IACDzD,IAAI,CAACgF,IAAL,CAAU,GAAV;IACA,OAAO,IAAI1H,YAAJ,CAAU0C,IAAV,CAAP;EACD,CA7GiB,CA+GlB;;;EACAiF,EAAE,CAAChE,SAAD,EAA4BiE,QAA5B,EAA8CC,QAA9C,EAA8D;IAC9D,KAAKC,UAAL,CAAgB,IAAIpE,EAAJ,CAAOC,SAAP,CAAhB;;IAEA,IAAIiE,QAAQ,IAAIC,QAAhB,EAA0B;MACxB,KAAKnF,IAAL,CAAUkF,QAAV,EAAoBhE,IAApB,GAA2BlB,IAA3B,CAAgCmF,QAAhC,EAA0CE,KAA1C;IACD,CAFD,MAEO,IAAIH,QAAJ,EAAc;MACnB,KAAKlF,IAAL,CAAUkF,QAAV,EAAoBG,KAApB;IACD,CAFM,MAEA,IAAIF,QAAJ,EAAc;MACnB,MAAM,IAAIG,KAAJ,CAAU,0CAAV,CAAN;IACD;;IACD,OAAO,IAAP;EACD,CA3HiB,CA6HlB;;;EACAC,MAAM,CAACtE,SAAD,EAA0B;IAC9B,OAAO,KAAKuE,SAAL,CAAe,IAAIxE,EAAJ,CAAOC,SAAP,CAAf,CAAP;EACD,CAhIiB,CAkIlB;;;EACAC,IAAI;IACF,OAAO,KAAKsE,SAAL,CAAe,IAAIzE,IAAJ,EAAf,CAAP;EACD,CArIiB,CAuIlB;;;EACAsE,KAAK;IACH,OAAO,KAAKI,aAAL,CAAmBzE,EAAnB,EAAuBD,IAAvB,CAAP;EACD;;EAEO2E,IAAI,CAACC,IAAD,EAAYC,OAAZ,EAA2B;IACrC,KAAKR,UAAL,CAAgBO,IAAhB;;IACA,IAAIC,OAAJ,EAAa,KAAK5F,IAAL,CAAU4F,OAAV,EAAmBC,MAAnB;IACb,OAAO,IAAP;EACD,CAhJiB,CAkJlB;;;EACAC,GAAG,CAACpE,SAAD,EAAkBkE,OAAlB,EAAiC;IAClC,OAAO,KAAKF,IAAL,CAAU,IAAIjE,OAAJ,CAAYC,SAAZ,CAAV,EAAkCkE,OAAlC,CAAP;EACD,CArJiB,CAuJlB;;;EACAG,QAAQ,CACN3B,YADM,EAENxC,IAFM,EAGNC,EAHM,EAIN+D,OAJM,EAKqD;IAAA,IAA3DrH,OAA2D,uEAA3C,KAAK4B,IAAL,CAAUxB,GAAV,GAAgBE,iBAASC,GAAzB,GAA+BD,iBAAS6F,GAAG;;IAE3D,MAAMlG,IAAI,GAAG,KAAKwE,MAAL,CAAYsB,MAAZ,CAAmBF,YAAnB,CAAb;;IACA,OAAO,KAAKsB,IAAL,CAAU,IAAI/D,QAAJ,CAAapD,OAAb,EAAsBC,IAAtB,EAA4BoD,IAA5B,EAAkCC,EAAlC,CAAV,EAAiD,MAAM+D,OAAO,CAACpH,IAAD,CAA9D,CAAP;EACD,CAjKiB,CAmKlB;;;EACAwH,KAAK,CACH5B,YADG,EAEHpC,QAFG,EAGH4D,OAHG,EAI2B;IAAA,IAA9BrH,OAA8B,uEAAdM,iBAAS2F,KAAK;;IAE9B,MAAMhG,IAAI,GAAG,KAAKwE,MAAL,CAAYsB,MAAZ,CAAmBF,YAAnB,CAAb;;IACA,IAAI,KAAKjE,IAAL,CAAUxB,GAAd,EAAmB;MACjB,MAAMsH,GAAG,GAAGjE,QAAQ,YAAY1E,WAApB,GAA2B0E,QAA3B,GAAsC,KAAKlD,GAAL,CAAS,MAAT,EAAiBkD,QAAjB,CAAlD;MACA,OAAO,KAAK+D,QAAL,CAAc,IAAd,EAAoB,CAApB,EAAuB,aAAC,GAAGE,GAAG,SAA9B,EAA0C3F,CAAD,IAAM;QACpD,KAAKxB,GAAL,CAASN,IAAT,EAAe,aAAC,GAAGyH,GAAG,IAAI3F,CAAC,GAA3B;QACAsF,OAAO,CAACpH,IAAD,CAAP;MACD,CAHM,CAAP;IAID;;IACD,OAAO,KAAKkH,IAAL,CAAU,IAAI5D,OAAJ,CAAY,IAAZ,EAAkBvD,OAAlB,EAA2BC,IAA3B,EAAiCwD,QAAjC,CAAV,EAAsD,MAAM4D,OAAO,CAACpH,IAAD,CAAnE,CAAP;EACD,CAnLiB,CAqLlB;EACA;;;EACA0H,KAAK,CACH9B,YADG,EAEH+B,GAFG,EAGHP,OAHG,EAI0D;IAAA,IAA7DrH,OAA6D,uEAA7C,KAAK4B,IAAL,CAAUxB,GAAV,GAAgBE,iBAASC,GAAzB,GAA+BD,iBAAS2F,KAAK;;IAE7D,IAAI,KAAKrE,IAAL,CAAUiG,aAAd,EAA6B;MAC3B,OAAO,KAAKJ,KAAL,CAAW5B,YAAX,EAAyB,aAAC,eAAe+B,GAAG,GAA5C,EAAiDP,OAAjD,CAAP;IACD;;IACD,MAAMpH,IAAI,GAAG,KAAKwE,MAAL,CAAYsB,MAAZ,CAAmBF,YAAnB,CAAb;;IACA,OAAO,KAAKsB,IAAL,CAAU,IAAI5D,OAAJ,CAAY,IAAZ,EAAkBvD,OAAlB,EAA2BC,IAA3B,EAAiC2H,GAAjC,CAAV,EAAiD,MAAMP,OAAO,CAACpH,IAAD,CAA9D,CAAP;EACD,CAlMiB,CAoMlB;;;EACAqH,MAAM;IACJ,OAAO,KAAKJ,aAAL,CAAmBjE,GAAnB,CAAP;EACD,CAvMiB,CAyMlB;;;EACA7B,KAAK,CAACA,KAAD,EAAY;IACf,OAAO,KAAK4E,SAAL,CAAe,IAAI7E,KAAJ,CAAUC,KAAV,CAAf,CAAP;EACD,CA5MiB,CA8MlB;;;EACA0G,KAAK,CAAC1G,KAAD,EAAa;IAChB,OAAO,KAAK4E,SAAL,CAAe,IAAI3E,KAAJ,CAAUD,KAAV,CAAf,CAAP;EACD,CAjNiB,CAmNlB;;;EACA2G,MAAM,CAAC7C,KAAD,EAAwB;IAC5B,MAAMkC,IAAI,GAAG,IAAItD,MAAJ,EAAb;;IACA,KAAK+C,UAAL,CAAgBO,IAAhB;;IACA,KAAK3F,IAAL,CAAUyD,KAAV;IACA,IAAIkC,IAAI,CAACzF,KAAL,CAAWK,MAAX,KAAsB,CAA1B,EAA6B,MAAM,IAAI+E,KAAJ,CAAU,wCAAV,CAAN;IAC7B,OAAO,KAAKG,aAAL,CAAmBpD,MAAnB,CAAP;EACD,CA1NiB,CA4NlB;;;EACAkE,GAAG,CAACC,OAAD,EAAiBC,SAAjB,EAAgDC,WAAhD,EAAmE;IACpE,IAAI,CAACD,SAAD,IAAc,CAACC,WAAnB,EAAgC,MAAM,IAAIpB,KAAJ,CAAU,8CAAV,CAAN;IAChC,MAAMK,IAAI,GAAG,IAAIrD,GAAJ,EAAb;;IACA,KAAK8C,UAAL,CAAgBO,IAAhB;;IACA,KAAK3F,IAAL,CAAUwG,OAAV;;IACA,IAAIC,SAAJ,EAAe;MACb,MAAM3G,KAAK,GAAG,KAAKtB,IAAL,CAAU,GAAV,CAAd;MACA,KAAKmI,SAAL,GAAiBhB,IAAI,CAACpD,KAAL,GAAa,IAAIG,KAAJ,CAAU5C,KAAV,CAA9B;MACA2G,SAAS,CAAC3G,KAAD,CAAT;IACD;;IACD,IAAI4G,WAAJ,EAAiB;MACf,KAAKC,SAAL,GAAiBhB,IAAI,CAACnD,OAAL,GAAe,IAAIG,OAAJ,EAAhC;MACA,KAAK3C,IAAL,CAAU0G,WAAV;IACD;;IACD,OAAO,KAAKjB,aAAL,CAAmB/C,KAAnB,EAA0BC,OAA1B,CAAP;EACD,CA5OiB,CA8OlB;;;EACAiE,KAAK,CAAC9G,KAAD,EAAY;IACf,OAAO,KAAKyE,SAAL,CAAe,IAAI1E,KAAJ,CAAUC,KAAV,CAAf,CAAP;EACD,CAjPiB,CAmPlB;;;EACA+G,KAAK,CAACC,IAAD,EAAeC,SAAf,EAAiC;IACpC,KAAKC,YAAL,CAAkBhC,IAAlB,CAAuB,KAAK9B,MAAL,CAAY3C,MAAnC;;IACA,IAAIuG,IAAJ,EAAU,KAAK9G,IAAL,CAAU8G,IAAV,EAAgBG,QAAhB,CAAyBF,SAAzB;IACV,OAAO,IAAP;EACD,CAxPiB,CA0PlB;;;EACAE,QAAQ,CAACF,SAAD,EAAmB;IACzB,MAAMG,GAAG,GAAG,KAAKF,YAAL,CAAkBG,GAAlB,EAAZ;;IACA,IAAID,GAAG,KAAKnI,SAAZ,EAAuB,MAAM,IAAIuG,KAAJ,CAAU,sCAAV,CAAN;IACvB,MAAM8B,OAAO,GAAG,KAAKlE,MAAL,CAAY3C,MAAZ,GAAqB2G,GAArC;;IACA,IAAIE,OAAO,GAAG,CAAV,IAAgBL,SAAS,KAAKhI,SAAd,IAA2BqI,OAAO,KAAKL,SAA3D,EAAuE;MACrE,MAAM,IAAIzB,KAAJ,CAAU,mCAAmC8B,OAAO,OAAOL,SAAS,WAApE,CAAN;IACD;;IACD,KAAK7D,MAAL,CAAY3C,MAAZ,GAAqB2G,GAArB;IACA,OAAO,IAAP;EACD,CApQiB,CAsQlB;;;EACAG,IAAI,CAAC7I,IAAD,EAAgE;IAAA,IAAnD0D,IAAmD,uEAAtC5E,UAAsC;IAAA,IAAjC6E,KAAiC;IAAA,IAAhBmF,QAAgB;;IAClE,KAAKlC,UAAL,CAAgB,IAAInD,IAAJ,CAASzD,IAAT,EAAe0D,IAAf,EAAqBC,KAArB,CAAhB;;IACA,IAAImF,QAAJ,EAAc,KAAKtH,IAAL,CAAUsH,QAAV,EAAoBC,OAApB;IACd,OAAO,IAAP;EACD,CA3QiB,CA6QlB;;;EACAA,OAAO;IACL,OAAO,KAAK9B,aAAL,CAAmBxD,IAAnB,CAAP;EACD;;EAEDuF,QAAQ,GAAM;IAAA,IAALnH,CAAK,uEAAD,CAAC;;IACZ,OAAOA,CAAC,KAAK,CAAb,EAAgB;MACd,KAAK+C,KAAL,CAAWnF,aAAX;;MACA,KAAKmF,KAAL,CAAWlF,aAAX,CAAyB,KAAKkF,KAAL,CAAWpE,KAApC,EAA2C,KAAKZ,UAAhD;IACD;EACF;;EAEOmG,SAAS,CAACoB,IAAD,EAAe;IAC9B,KAAKgB,SAAL,CAAezG,KAAf,CAAqB8E,IAArB,CAA0BW,IAA1B;;IACA,OAAO,IAAP;EACD;;EAEOP,UAAU,CAACO,IAAD,EAAqB;IACrC,KAAKgB,SAAL,CAAezG,KAAf,CAAqB8E,IAArB,CAA0BW,IAA1B;;IACA,KAAKzC,MAAL,CAAY8B,IAAZ,CAAiBW,IAAjB;EACD;;EAEOF,aAAa,CAACgC,EAAD,EAAuBC,EAAvB,EAA4C;IAC/D,MAAMrH,CAAC,GAAG,KAAKsG,SAAf;;IACA,IAAItG,CAAC,YAAYoH,EAAb,IAAoBC,EAAE,IAAIrH,CAAC,YAAYqH,EAA3C,EAAgD;MAC9C,KAAKxE,MAAL,CAAYiE,GAAZ;;MACA,OAAO,IAAP;IACD;;IACD,MAAM,IAAI7B,KAAJ,CAAU,0BAA0BoC,EAAE,GAAG,GAAGD,EAAE,CAACE,IAAI,IAAID,EAAE,CAACC,IAAI,EAAxB,GAA6BF,EAAE,CAACE,IAAI,GAA1E,CAAN;EACD;;EAEOnC,SAAS,CAACG,IAAD,EAAgB;IAC/B,MAAMtF,CAAC,GAAG,KAAKsG,SAAf;;IACA,IAAI,EAAEtG,CAAC,YAAYW,EAAf,CAAJ,EAAwB;MACtB,MAAM,IAAIsE,KAAJ,CAAU,8BAAV,CAAN;IACD;;IACD,KAAKqB,SAAL,GAAiBtG,CAAC,CAACa,IAAF,GAASyE,IAA1B;IACA,OAAO,IAAP;EACD;;EAEgB,IAALvC,KAAK;IACf,OAAO,KAAKF,MAAL,CAAY,CAAZ,CAAP;EACD;;EAEoB,IAATyD,SAAS;IACnB,MAAMtF,EAAE,GAAG,KAAK6B,MAAhB;IACA,OAAO7B,EAAE,CAACA,EAAE,CAACd,MAAH,GAAY,CAAb,CAAT;EACD;;EAEoB,IAAToG,SAAS,CAAChB,IAAD,EAAiB;IACpC,MAAMtE,EAAE,GAAG,KAAK6B,MAAhB;IACA7B,EAAE,CAACA,EAAE,CAACd,MAAH,GAAY,CAAb,CAAF,GAAoBoF,IAApB;EACD;;AAjUiB;;AAApBvI;;AAwUA,SAASwD,QAAT,CAAkB5B,KAAlB,EAAoC4C,IAApC,EAAmD;EACjD,KAAK,MAAMvB,CAAX,IAAgBuB,IAAhB,EAAsB5C,KAAK,CAACqB,CAAD,CAAL,GAAW,CAACrB,KAAK,CAACqB,CAAD,CAAL,IAAY,CAAb,KAAmBuB,IAAI,CAACvB,CAAD,CAAJ,IAAW,CAA9B,CAAX;;EACtB,OAAOrB,KAAP;AACD;;AAED,SAASO,YAAT,CAAsBP,KAAtB,EAAwC4C,IAAxC,EAAsD;EACpD,OAAOA,IAAI,YAAYtE,kBAAhB,GAA8BsD,QAAQ,CAAC5B,KAAD,EAAQ4C,IAAI,CAAC5C,KAAb,CAAtC,GAA4DA,KAAnE;AACD;;AAGD,SAASG,YAAT,CAAsByI,IAAtB,EAAsC5I,KAAtC,EAAwDC,SAAxD,EAA4E;EAC1E,IAAI2I,IAAI,YAAYtK,WAApB,EAA0B,OAAOuK,WAAW,CAACD,IAAD,CAAlB;EAC1B,IAAI,CAACE,WAAW,CAACF,IAAD,CAAhB,EAAwB,OAAOA,IAAP;EACxB,OAAO,IAAItK,YAAJ,CACLsK,IAAI,CAACG,MAAL,CAAY3H,MAAZ,CAAmB,CAAC4H,KAAD,EAAoBpD,CAApB,KAA4C;IAC7D,IAAIA,CAAC,YAAYtH,WAAjB,EAAuBsH,CAAC,GAAGiD,WAAW,CAACjD,CAAD,CAAf;IACvB,IAAIA,CAAC,YAAYtH,YAAjB,EAAwB0K,KAAK,CAAChD,IAAN,CAAW,GAAGJ,CAAC,CAACmD,MAAhB,EAAxB,KACKC,KAAK,CAAChD,IAAN,CAAWJ,CAAX;IACL,OAAOoD,KAAP;EACD,CALD,EAKG,EALH,CADK,CAAP;;EASA,SAASH,WAAT,CAAqBxH,CAArB,EAA4B;IAC1B,MAAMuE,CAAC,GAAG3F,SAAS,CAACoB,CAAC,CAACnB,GAAH,CAAnB;IACA,IAAI0F,CAAC,KAAK7F,SAAN,IAAmBC,KAAK,CAACqB,CAAC,CAACnB,GAAH,CAAL,KAAiB,CAAxC,EAA2C,OAAOmB,CAAP;IAC3C,OAAOrB,KAAK,CAACqB,CAAC,CAACnB,GAAH,CAAZ;IACA,OAAO0F,CAAP;EACD;;EAED,SAASkD,WAAT,CAAqB1G,CAArB,EAAgC;IAC9B,OACEA,CAAC,YAAY9D,YAAb,IACA8D,CAAC,CAAC2G,MAAF,CAASE,IAAT,CACGrD,CAAD,IAAOA,CAAC,YAAYtH,WAAb,IAAqB0B,KAAK,CAAC4F,CAAC,CAAC1F,GAAH,CAAL,KAAiB,CAAtC,IAA2CD,SAAS,CAAC2F,CAAC,CAAC1F,GAAH,CAAT,KAAqBH,SADzE,CAFF;EAMD;AACF;;AAED,SAAS4B,aAAT,CAAuB3B,KAAvB,EAAyC4C,IAAzC,EAAwD;EACtD,KAAK,MAAMvB,CAAX,IAAgBuB,IAAhB,EAAsB5C,KAAK,CAACqB,CAAD,CAAL,GAAW,CAACrB,KAAK,CAACqB,CAAD,CAAL,IAAY,CAAb,KAAmBuB,IAAI,CAACvB,CAAD,CAAJ,IAAW,CAA9B,CAAX;AACvB;;AAGD,SAAgBiB,GAAhB,CAAoB4G,CAApB,EAAsC;EACpC,OAAO,OAAOA,CAAP,IAAY,SAAZ,IAAyB,OAAOA,CAAP,IAAY,QAArC,IAAiDA,CAAC,KAAK,IAAvD,GAA8D,CAACA,CAA/D,GAAmE,aAAC,IAAIC,GAAG,CAACD,CAAD,CAAG,EAArF;AACD;;AAFD9K;AAIA,MAAMgL,OAAO,GAAGC,OAAO,CAACjL,kBAAUU,GAAX,CAAvB,C,CAEA;;AACA,SAAgBwK,GAAhB,GAAmC;EAAA,mCAAZpG,IAAY;IAAZA,IAAY;EAAA;;EACjC,OAAOA,IAAI,CAAC9B,MAAL,CAAYgI,OAAZ,CAAP;AACD;;AAFDhL;AAIA,MAAMmL,MAAM,GAAGF,OAAO,CAACjL,kBAAUS,EAAX,CAAtB,C,CAEA;;AACA,SAAgB2K,EAAhB,GAAkC;EAAA,mCAAZtG,IAAY;IAAZA,IAAY;EAAA;;EAChC,OAAOA,IAAI,CAAC9B,MAAL,CAAYmI,MAAZ,CAAP;AACD;;AAFDnL;;AAMA,SAASiL,OAAT,CAAiB5I,EAAjB,EAAyB;EACvB,OAAO,CAACyI,CAAD,EAAIO,CAAJ,KAAWP,CAAC,KAAK5K,UAAN,GAAYmL,CAAZ,GAAgBA,CAAC,KAAKnL,UAAN,GAAY4K,CAAZ,GAAgB,aAAC,GAAGC,GAAG,CAACD,CAAD,CAAG,IAAIzI,EAAE,IAAI0I,GAAG,CAACM,CAAD,CAAG,EAA5E;AACD;;AAED,SAASN,GAAT,CAAaD,CAAb,EAAoB;EAClB,OAAOA,CAAC,YAAY5K,WAAb,GAAoB4K,CAApB,GAAwB,aAAC,IAAIA,CAAC,GAArC;AACD","names":["Object","enumerable","get","exports","GT","code_1","GTE","LT","LTE","EQ","NEQ","NOT","OR","AND","ADD","Node","optimizeNodes","optimizeNames","_names","_constants","Def","constructor","varKind","name","rhs","render","es5","_n","scope_1","var","undefined","names","constants","str","optimizeExpr","Assign","lhs","sideEffects","addExprNames","AssignOp","op","Label","label","Break","Throw","error","AnyCode","code","ParentNode","nodes","opts","reduce","n","i","length","Array","isArray","splice","subtractNames","addNames","BlockNode","Root","Else","If","condition","else","cond","e","ns","not","_a","For","ForLoop","iteration","ForRange","from","to","ForIter","loop","iterable","Func","args","async","_async","Return","Try","catch","finally","_b","Catch","Finally","CodeGen","extScope","lines","_extScope","_scope","parent","_nodes","toString","_root","prefix","scopeName","scopeValue","prefixOrName","value","vs","_values","Set","add","getScopeValue","keyOrRef","getValue","scopeRefs","scopeCode","_def","nameOrPrefix","constant","toName","_leafNode","const","_constant","let","assign","c","object","keyValues","key","push","if","thenBody","elseBody","_blockNode","endIf","Error","elseIf","_elseNode","_endBlockNode","_for","node","forBody","endFor","for","forRange","forOf","arr","forIn","obj","ownProperties","break","return","try","tryBody","catchCode","finallyCode","_currNode","throw","block","body","nodeCount","_blockStarts","endBlock","len","pop","toClose","func","funcBody","endFunc","optimize","N1","N2","kind","expr","replaceName","canOptimize","_items","items","some","x","par","andCode","mappend","and","orCode","or","y"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\css-minimizer-webpack-plugin\\node_modules\\ajv\\lib\\compile\\codegen\\index.ts"],"sourcesContent":["import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(private readonly varKind: Name, private readonly name: Name, private rhs?: SafeExpr) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(readonly lhs: Code, public rhs: SafeExpr, private readonly sideEffects?: boolean) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(lhs: Code, private readonly op: Code, rhs: SafeExpr, sideEffects?: boolean) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(private condition: Code | boolean, nodes?: ChildNode[]) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(public name: Name, public args: Code, public async?: boolean) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n"]},"metadata":{},"sourceType":"script"}