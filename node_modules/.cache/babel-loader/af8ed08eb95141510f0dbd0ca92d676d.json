{"ast":null,"code":"/**\n * @fileoverview Validate closing bracket location in JSX\n * @author Yannick Croissant\n */\n'use strict';\n\nconst has = require('object.hasown/polyfill')();\n\nconst docsUrl = require('../util/docsUrl');\n\nconst report = require('../util/report'); // ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\n\nconst messages = {\n  bracketLocation: 'The closing bracket must be {{location}}{{details}}'\n};\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce closing bracket location in JSX',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-closing-bracket-location')\n    },\n    fixable: 'code',\n    messages,\n    schema: [{\n      oneOf: [{\n        enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']\n      }, {\n        type: 'object',\n        properties: {\n          location: {\n            enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: 'object',\n        properties: {\n          nonEmpty: {\n            enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]\n          },\n          selfClosing: {\n            enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]\n          }\n        },\n        additionalProperties: false\n      }]\n    }]\n  },\n\n  create(context) {\n    const MESSAGE_LOCATION = {\n      'after-props': 'placed after the last prop',\n      'after-tag': 'placed after the opening tag',\n      'props-aligned': 'aligned with the last prop',\n      'tag-aligned': 'aligned with the opening tag',\n      'line-aligned': 'aligned with the line containing the opening tag'\n    };\n    const DEFAULT_LOCATION = 'tag-aligned';\n    const config = context.options[0];\n    const options = {\n      nonEmpty: DEFAULT_LOCATION,\n      selfClosing: DEFAULT_LOCATION\n    };\n\n    if (typeof config === 'string') {\n      // simple shorthand [1, 'something']\n      options.nonEmpty = config;\n      options.selfClosing = config;\n    } else if (typeof config === 'object') {\n      // [1, {location: 'something'}] (back-compat)\n      if (has(config, 'location')) {\n        options.nonEmpty = config.location;\n        options.selfClosing = config.location;\n      } // [1, {nonEmpty: 'something'}]\n\n\n      if (has(config, 'nonEmpty')) {\n        options.nonEmpty = config.nonEmpty;\n      } // [1, {selfClosing: 'something'}]\n\n\n      if (has(config, 'selfClosing')) {\n        options.selfClosing = config.selfClosing;\n      }\n    }\n    /**\n     * Get expected location for the closing bracket\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @return {String} Expected location for the closing bracket\n     */\n\n\n    function getExpectedLocation(tokens) {\n      let location; // Is always after the opening tag if there is no props\n\n      if (typeof tokens.lastProp === 'undefined') {\n        location = 'after-tag'; // Is always after the last prop if this one is on the same line as the opening bracket\n      } else if (tokens.opening.line === tokens.lastProp.lastLine) {\n        location = 'after-props'; // Else use configuration dependent on selfClosing property\n      } else {\n        location = tokens.selfClosing ? options.selfClosing : options.nonEmpty;\n      }\n\n      return location;\n    }\n    /**\n     * Get the correct 0-indexed column for the closing bracket, given the\n     * expected location.\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @param {String} expectedLocation Expected location for the closing bracket\n     * @return {?Number} The correct column for the closing bracket, or null\n     */\n\n\n    function getCorrectColumn(tokens, expectedLocation) {\n      switch (expectedLocation) {\n        case 'props-aligned':\n          return tokens.lastProp.column;\n\n        case 'tag-aligned':\n          return tokens.opening.column;\n\n        case 'line-aligned':\n          return tokens.openingStartOfLine.column;\n\n        default:\n          return null;\n      }\n    }\n    /**\n     * Check if the closing bracket is correctly located\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @param {String} expectedLocation Expected location for the closing bracket\n     * @return {Boolean} True if the closing bracket is correctly located, false if not\n     */\n\n\n    function hasCorrectLocation(tokens, expectedLocation) {\n      switch (expectedLocation) {\n        case 'after-tag':\n          return tokens.tag.line === tokens.closing.line;\n\n        case 'after-props':\n          return tokens.lastProp.lastLine === tokens.closing.line;\n\n        case 'props-aligned':\n        case 'tag-aligned':\n        case 'line-aligned':\n          {\n            const correctColumn = getCorrectColumn(tokens, expectedLocation);\n            return correctColumn === tokens.closing.column;\n          }\n\n        default:\n          return true;\n      }\n    }\n    /**\n     * Get the characters used for indentation on the line to be matched\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @param {String} expectedLocation Expected location for the closing bracket\n     * @param {Number} [correctColumn] Expected column for the closing bracket. Default to 0\n     * @return {String} The characters used for indentation\n     */\n\n\n    function getIndentation(tokens, expectedLocation, correctColumn) {\n      const newColumn = correctColumn || 0;\n      let indentation;\n      let spaces = [];\n\n      switch (expectedLocation) {\n        case 'props-aligned':\n          indentation = /^\\s*/.exec(context.getSourceCode().lines[tokens.lastProp.firstLine - 1])[0];\n          break;\n\n        case 'tag-aligned':\n        case 'line-aligned':\n          indentation = /^\\s*/.exec(context.getSourceCode().lines[tokens.opening.line - 1])[0];\n          break;\n\n        default:\n          indentation = '';\n      }\n\n      if (indentation.length + 1 < newColumn) {\n        // Non-whitespace characters were included in the column offset\n        spaces = new Array(+correctColumn + 1 - indentation.length);\n      }\n\n      return indentation + spaces.join(' ');\n    }\n    /**\n     * Get the locations of the opening bracket, closing bracket, last prop, and\n     * start of opening line.\n     * @param {ASTNode} node The node to check\n     * @return {Object} Locations of the opening bracket, closing bracket, last\n     * prop and start of opening line.\n     */\n\n\n    function getTokensLocations(node) {\n      const sourceCode = context.getSourceCode();\n      const opening = sourceCode.getFirstToken(node).loc.start;\n      const closing = sourceCode.getLastTokens(node, node.selfClosing ? 2 : 1)[0].loc.start;\n      const tag = sourceCode.getFirstToken(node.name).loc.start;\n      let lastProp;\n\n      if (node.attributes.length) {\n        lastProp = node.attributes[node.attributes.length - 1];\n        lastProp = {\n          column: sourceCode.getFirstToken(lastProp).loc.start.column,\n          firstLine: sourceCode.getFirstToken(lastProp).loc.start.line,\n          lastLine: sourceCode.getLastToken(lastProp).loc.end.line\n        };\n      }\n\n      const openingLine = sourceCode.lines[opening.line - 1];\n      const closingLine = sourceCode.lines[closing.line - 1];\n      const isTab = {\n        openTab: /^\\t/.test(openingLine),\n        closeTab: /^\\t/.test(closingLine)\n      };\n      const openingStartOfLine = {\n        column: /^\\s*/.exec(openingLine)[0].length,\n        line: opening.line\n      };\n      return {\n        isTab,\n        tag,\n        opening,\n        closing,\n        lastProp,\n        selfClosing: node.selfClosing,\n        openingStartOfLine\n      };\n    }\n    /**\n     * Get an unique ID for a given JSXOpeningElement\n     *\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {String} Unique ID (based on its range)\n     */\n\n\n    function getOpeningElementId(node) {\n      return node.range.join(':');\n    }\n\n    const lastAttributeNode = {};\n    return {\n      JSXAttribute(node) {\n        lastAttributeNode[getOpeningElementId(node.parent)] = node;\n      },\n\n      JSXSpreadAttribute(node) {\n        lastAttributeNode[getOpeningElementId(node.parent)] = node;\n      },\n\n      'JSXOpeningElement:exit'(node) {\n        const attributeNode = lastAttributeNode[getOpeningElementId(node)];\n        const cachedLastAttributeEndPos = attributeNode ? attributeNode.range[1] : null;\n        let expectedNextLine;\n        const tokens = getTokensLocations(node);\n        const expectedLocation = getExpectedLocation(tokens);\n        let usingSameIndentation = true;\n\n        if (expectedLocation === 'tag-aligned') {\n          usingSameIndentation = tokens.isTab.openTab === tokens.isTab.closeTab;\n        }\n\n        if (hasCorrectLocation(tokens, expectedLocation) && usingSameIndentation) {\n          return;\n        }\n\n        const data = {\n          location: MESSAGE_LOCATION[expectedLocation]\n        };\n        const correctColumn = getCorrectColumn(tokens, expectedLocation);\n\n        if (correctColumn !== null) {\n          expectedNextLine = tokens.lastProp && tokens.lastProp.lastLine === tokens.closing.line;\n          data.details = ` (expected column ${correctColumn + 1}${expectedNextLine ? ' on the next line)' : ')'}`;\n        }\n\n        report(context, messages.bracketLocation, 'bracketLocation', {\n          node,\n          loc: tokens.closing,\n          data,\n\n          fix(fixer) {\n            const closingTag = tokens.selfClosing ? '/>' : '>';\n\n            switch (expectedLocation) {\n              case 'after-tag':\n                if (cachedLastAttributeEndPos) {\n                  return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]], (expectedNextLine ? '\\n' : '') + closingTag);\n                }\n\n                return fixer.replaceTextRange([node.name.range[1], node.range[1]], (expectedNextLine ? '\\n' : ' ') + closingTag);\n\n              case 'after-props':\n                return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]], (expectedNextLine ? '\\n' : '') + closingTag);\n\n              case 'props-aligned':\n              case 'tag-aligned':\n              case 'line-aligned':\n                return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]], `\\n${getIndentation(tokens, expectedLocation, correctColumn)}${closingTag}`);\n\n              default:\n                return true;\n            }\n          }\n\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["has","require","docsUrl","report","messages","bracketLocation","module","exports","meta","docs","description","category","recommended","url","fixable","schema","oneOf","enum","type","properties","location","additionalProperties","nonEmpty","selfClosing","create","context","MESSAGE_LOCATION","DEFAULT_LOCATION","config","options","getExpectedLocation","tokens","lastProp","opening","line","lastLine","getCorrectColumn","expectedLocation","column","openingStartOfLine","hasCorrectLocation","tag","closing","correctColumn","getIndentation","newColumn","indentation","spaces","exec","getSourceCode","lines","firstLine","length","Array","join","getTokensLocations","node","sourceCode","getFirstToken","loc","start","getLastTokens","name","attributes","getLastToken","end","openingLine","closingLine","isTab","openTab","test","closeTab","getOpeningElementId","range","lastAttributeNode","JSXAttribute","parent","JSXSpreadAttribute","attributeNode","cachedLastAttributeEndPos","expectedNextLine","usingSameIndentation","data","details","fix","fixer","closingTag","replaceTextRange"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-react/lib/rules/jsx-closing-bracket-location.js"],"sourcesContent":["/**\n * @fileoverview Validate closing bracket location in JSX\n * @author Yannick Croissant\n */\n\n'use strict';\n\nconst has = require('object.hasown/polyfill')();\nconst docsUrl = require('../util/docsUrl');\nconst report = require('../util/report');\n\n// ------------------------------------------------------------------------------\n// Rule Definition\n// ------------------------------------------------------------------------------\n\nconst messages = {\n  bracketLocation: 'The closing bracket must be {{location}}{{details}}',\n};\n\nmodule.exports = {\n  meta: {\n    docs: {\n      description: 'Enforce closing bracket location in JSX',\n      category: 'Stylistic Issues',\n      recommended: false,\n      url: docsUrl('jsx-closing-bracket-location'),\n    },\n    fixable: 'code',\n\n    messages,\n\n    schema: [{\n      oneOf: [\n        {\n          enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned'],\n        },\n        {\n          type: 'object',\n          properties: {\n            location: {\n              enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned'],\n            },\n          },\n          additionalProperties: false,\n        }, {\n          type: 'object',\n          properties: {\n            nonEmpty: {\n              enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false],\n            },\n            selfClosing: {\n              enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false],\n            },\n          },\n          additionalProperties: false,\n        },\n      ],\n    }],\n  },\n\n  create(context) {\n    const MESSAGE_LOCATION = {\n      'after-props': 'placed after the last prop',\n      'after-tag': 'placed after the opening tag',\n      'props-aligned': 'aligned with the last prop',\n      'tag-aligned': 'aligned with the opening tag',\n      'line-aligned': 'aligned with the line containing the opening tag',\n    };\n    const DEFAULT_LOCATION = 'tag-aligned';\n\n    const config = context.options[0];\n    const options = {\n      nonEmpty: DEFAULT_LOCATION,\n      selfClosing: DEFAULT_LOCATION,\n    };\n\n    if (typeof config === 'string') {\n      // simple shorthand [1, 'something']\n      options.nonEmpty = config;\n      options.selfClosing = config;\n    } else if (typeof config === 'object') {\n      // [1, {location: 'something'}] (back-compat)\n      if (has(config, 'location')) {\n        options.nonEmpty = config.location;\n        options.selfClosing = config.location;\n      }\n      // [1, {nonEmpty: 'something'}]\n      if (has(config, 'nonEmpty')) {\n        options.nonEmpty = config.nonEmpty;\n      }\n      // [1, {selfClosing: 'something'}]\n      if (has(config, 'selfClosing')) {\n        options.selfClosing = config.selfClosing;\n      }\n    }\n\n    /**\n     * Get expected location for the closing bracket\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @return {String} Expected location for the closing bracket\n     */\n    function getExpectedLocation(tokens) {\n      let location;\n      // Is always after the opening tag if there is no props\n      if (typeof tokens.lastProp === 'undefined') {\n        location = 'after-tag';\n      // Is always after the last prop if this one is on the same line as the opening bracket\n      } else if (tokens.opening.line === tokens.lastProp.lastLine) {\n        location = 'after-props';\n      // Else use configuration dependent on selfClosing property\n      } else {\n        location = tokens.selfClosing ? options.selfClosing : options.nonEmpty;\n      }\n      return location;\n    }\n\n    /**\n     * Get the correct 0-indexed column for the closing bracket, given the\n     * expected location.\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @param {String} expectedLocation Expected location for the closing bracket\n     * @return {?Number} The correct column for the closing bracket, or null\n     */\n    function getCorrectColumn(tokens, expectedLocation) {\n      switch (expectedLocation) {\n        case 'props-aligned':\n          return tokens.lastProp.column;\n        case 'tag-aligned':\n          return tokens.opening.column;\n        case 'line-aligned':\n          return tokens.openingStartOfLine.column;\n        default:\n          return null;\n      }\n    }\n\n    /**\n     * Check if the closing bracket is correctly located\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @param {String} expectedLocation Expected location for the closing bracket\n     * @return {Boolean} True if the closing bracket is correctly located, false if not\n     */\n    function hasCorrectLocation(tokens, expectedLocation) {\n      switch (expectedLocation) {\n        case 'after-tag':\n          return tokens.tag.line === tokens.closing.line;\n        case 'after-props':\n          return tokens.lastProp.lastLine === tokens.closing.line;\n        case 'props-aligned':\n        case 'tag-aligned':\n        case 'line-aligned': {\n          const correctColumn = getCorrectColumn(tokens, expectedLocation);\n          return correctColumn === tokens.closing.column;\n        }\n        default:\n          return true;\n      }\n    }\n\n    /**\n     * Get the characters used for indentation on the line to be matched\n     * @param {Object} tokens Locations of the opening bracket, closing bracket and last prop\n     * @param {String} expectedLocation Expected location for the closing bracket\n     * @param {Number} [correctColumn] Expected column for the closing bracket. Default to 0\n     * @return {String} The characters used for indentation\n     */\n    function getIndentation(tokens, expectedLocation, correctColumn) {\n      const newColumn = correctColumn || 0;\n      let indentation;\n      let spaces = [];\n      switch (expectedLocation) {\n        case 'props-aligned':\n          indentation = /^\\s*/.exec(context.getSourceCode().lines[tokens.lastProp.firstLine - 1])[0];\n          break;\n        case 'tag-aligned':\n        case 'line-aligned':\n          indentation = /^\\s*/.exec(context.getSourceCode().lines[tokens.opening.line - 1])[0];\n          break;\n        default:\n          indentation = '';\n      }\n      if (indentation.length + 1 < newColumn) {\n        // Non-whitespace characters were included in the column offset\n        spaces = new Array(+correctColumn + 1 - indentation.length);\n      }\n      return indentation + spaces.join(' ');\n    }\n\n    /**\n     * Get the locations of the opening bracket, closing bracket, last prop, and\n     * start of opening line.\n     * @param {ASTNode} node The node to check\n     * @return {Object} Locations of the opening bracket, closing bracket, last\n     * prop and start of opening line.\n     */\n    function getTokensLocations(node) {\n      const sourceCode = context.getSourceCode();\n      const opening = sourceCode.getFirstToken(node).loc.start;\n      const closing = sourceCode.getLastTokens(node, node.selfClosing ? 2 : 1)[0].loc.start;\n      const tag = sourceCode.getFirstToken(node.name).loc.start;\n      let lastProp;\n      if (node.attributes.length) {\n        lastProp = node.attributes[node.attributes.length - 1];\n        lastProp = {\n          column: sourceCode.getFirstToken(lastProp).loc.start.column,\n          firstLine: sourceCode.getFirstToken(lastProp).loc.start.line,\n          lastLine: sourceCode.getLastToken(lastProp).loc.end.line,\n        };\n      }\n      const openingLine = sourceCode.lines[opening.line - 1];\n      const closingLine = sourceCode.lines[closing.line - 1];\n      const isTab = {\n        openTab: /^\\t/.test(openingLine),\n        closeTab: /^\\t/.test(closingLine),\n      };\n      const openingStartOfLine = {\n        column: /^\\s*/.exec(openingLine)[0].length,\n        line: opening.line,\n      };\n      return {\n        isTab,\n        tag,\n        opening,\n        closing,\n        lastProp,\n        selfClosing: node.selfClosing,\n        openingStartOfLine,\n      };\n    }\n\n    /**\n     * Get an unique ID for a given JSXOpeningElement\n     *\n     * @param {ASTNode} node The AST node being checked.\n     * @returns {String} Unique ID (based on its range)\n     */\n    function getOpeningElementId(node) {\n      return node.range.join(':');\n    }\n\n    const lastAttributeNode = {};\n\n    return {\n      JSXAttribute(node) {\n        lastAttributeNode[getOpeningElementId(node.parent)] = node;\n      },\n\n      JSXSpreadAttribute(node) {\n        lastAttributeNode[getOpeningElementId(node.parent)] = node;\n      },\n\n      'JSXOpeningElement:exit'(node) {\n        const attributeNode = lastAttributeNode[getOpeningElementId(node)];\n        const cachedLastAttributeEndPos = attributeNode ? attributeNode.range[1] : null;\n\n        let expectedNextLine;\n        const tokens = getTokensLocations(node);\n        const expectedLocation = getExpectedLocation(tokens);\n        let usingSameIndentation = true;\n\n        if (expectedLocation === 'tag-aligned') {\n          usingSameIndentation = tokens.isTab.openTab === tokens.isTab.closeTab;\n        }\n\n        if (hasCorrectLocation(tokens, expectedLocation) && usingSameIndentation) {\n          return;\n        }\n\n        const data = { location: MESSAGE_LOCATION[expectedLocation] };\n        const correctColumn = getCorrectColumn(tokens, expectedLocation);\n\n        if (correctColumn !== null) {\n          expectedNextLine = tokens.lastProp\n            && (tokens.lastProp.lastLine === tokens.closing.line);\n          data.details = ` (expected column ${correctColumn + 1}${expectedNextLine ? ' on the next line)' : ')'}`;\n        }\n\n        report(context, messages.bracketLocation, 'bracketLocation', {\n          node,\n          loc: tokens.closing,\n          data,\n          fix(fixer) {\n            const closingTag = tokens.selfClosing ? '/>' : '>';\n            switch (expectedLocation) {\n              case 'after-tag':\n                if (cachedLastAttributeEndPos) {\n                  return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]],\n                    (expectedNextLine ? '\\n' : '') + closingTag);\n                }\n                return fixer.replaceTextRange([node.name.range[1], node.range[1]],\n                  (expectedNextLine ? '\\n' : ' ') + closingTag);\n              case 'after-props':\n                return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]],\n                  (expectedNextLine ? '\\n' : '') + closingTag);\n              case 'props-aligned':\n              case 'tag-aligned':\n              case 'line-aligned':\n                return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]],\n                  `\\n${getIndentation(tokens, expectedLocation, correctColumn)}${closingTag}`);\n              default:\n                return true;\n            }\n          },\n        });\n      },\n    };\n  },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}