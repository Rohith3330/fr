{"ast":null,"code":"/**\n * @fileoverview Rule to disallow duplicate conditions in if-else-if chains\n * @author Milos Djermanovic\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the first given array is a subset of the second given array.\n * @param {Function} comparator A function to compare two elements, should return `true` if they are equal.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {boolean} `true` if the array `arrA` is a subset of the array `arrB`.\n */\n\n\nfunction isSubsetByComparator(comparator, arrA, arrB) {\n  return arrA.every(a => arrB.some(b => comparator(a, b)));\n}\n/**\n * Splits the given node by the given logical operator.\n * @param {string} operator Logical operator `||` or `&&`.\n * @param {ASTNode} node The node to split.\n * @returns {ASTNode[]} Array of conditions that makes the node when joined by the operator.\n */\n\n\nfunction splitByLogicalOperator(operator, node) {\n  if (node.type === \"LogicalExpression\" && node.operator === operator) {\n    return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];\n  }\n\n  return [node];\n}\n\nconst splitByOr = splitByLogicalOperator.bind(null, \"||\");\nconst splitByAnd = splitByLogicalOperator.bind(null, \"&&\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"Disallow duplicate conditions in if-else-if chains\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-dupe-else-if\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\n     * Determines whether the two given nodes are considered to be equal. In particular, given that the nodes\n     * represent expressions in a boolean context, `||` and `&&` can be considered as commutative operators.\n     * @param {ASTNode} a First node.\n     * @param {ASTNode} b Second node.\n     * @returns {boolean} `true` if the nodes are considered to be equal.\n     */\n\n    function equal(a, b) {\n      if (a.type !== b.type) {\n        return false;\n      }\n\n      if (a.type === \"LogicalExpression\" && (a.operator === \"||\" || a.operator === \"&&\") && a.operator === b.operator) {\n        return equal(a.left, b.left) && equal(a.right, b.right) || equal(a.left, b.right) && equal(a.right, b.left);\n      }\n\n      return astUtils.equalTokens(a, b, sourceCode);\n    }\n\n    const isSubset = isSubsetByComparator.bind(null, equal);\n    return {\n      IfStatement(node) {\n        const test = node.test,\n              conditionsToCheck = test.type === \"LogicalExpression\" && test.operator === \"&&\" ? [test, ...splitByAnd(test)] : [test];\n        let current = node,\n            listToCheck = conditionsToCheck.map(c => splitByOr(c).map(splitByAnd));\n\n        while (current.parent && current.parent.type === \"IfStatement\" && current.parent.alternate === current) {\n          current = current.parent;\n          const currentOrOperands = splitByOr(current.test).map(splitByAnd);\n          listToCheck = listToCheck.map(orOperands => orOperands.filter(orOperand => !currentOrOperands.some(currentOrOperand => isSubset(currentOrOperand, orOperand))));\n\n          if (listToCheck.some(orOperands => orOperands.length === 0)) {\n            context.report({\n              node: test,\n              messageId: \"unexpected\"\n            });\n            break;\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"names":["astUtils","require","isSubsetByComparator","comparator","arrA","arrB","every","a","some","b","splitByLogicalOperator","operator","node","type","left","right","splitByOr","bind","splitByAnd","module","exports","meta","docs","description","recommended","url","schema","messages","unexpected","create","context","sourceCode","getSourceCode","equal","equalTokens","isSubset","IfStatement","test","conditionsToCheck","current","listToCheck","map","c","parent","alternate","currentOrOperands","orOperands","filter","orOperand","currentOrOperand","length","report","messageId"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint/lib/rules/no-dupe-else-if.js"],"sourcesContent":["/**\n * @fileoverview Rule to disallow duplicate conditions in if-else-if chains\n * @author Milos Djermanovic\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Determines whether the first given array is a subset of the second given array.\n * @param {Function} comparator A function to compare two elements, should return `true` if they are equal.\n * @param {Array} arrA The array to compare from.\n * @param {Array} arrB The array to compare against.\n * @returns {boolean} `true` if the array `arrA` is a subset of the array `arrB`.\n */\nfunction isSubsetByComparator(comparator, arrA, arrB) {\n    return arrA.every(a => arrB.some(b => comparator(a, b)));\n}\n\n/**\n * Splits the given node by the given logical operator.\n * @param {string} operator Logical operator `||` or `&&`.\n * @param {ASTNode} node The node to split.\n * @returns {ASTNode[]} Array of conditions that makes the node when joined by the operator.\n */\nfunction splitByLogicalOperator(operator, node) {\n    if (node.type === \"LogicalExpression\" && node.operator === operator) {\n        return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];\n    }\n    return [node];\n}\n\nconst splitByOr = splitByLogicalOperator.bind(null, \"||\");\nconst splitByAnd = splitByLogicalOperator.bind(null, \"&&\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\nmodule.exports = {\n    meta: {\n        type: \"problem\",\n\n        docs: {\n            description: \"Disallow duplicate conditions in if-else-if chains\",\n            recommended: true,\n            url: \"https://eslint.org/docs/rules/no-dupe-else-if\"\n        },\n\n        schema: [],\n\n        messages: {\n            unexpected: \"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.\"\n        }\n    },\n\n    create(context) {\n        const sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether the two given nodes are considered to be equal. In particular, given that the nodes\n         * represent expressions in a boolean context, `||` and `&&` can be considered as commutative operators.\n         * @param {ASTNode} a First node.\n         * @param {ASTNode} b Second node.\n         * @returns {boolean} `true` if the nodes are considered to be equal.\n         */\n        function equal(a, b) {\n            if (a.type !== b.type) {\n                return false;\n            }\n\n            if (\n                a.type === \"LogicalExpression\" &&\n                (a.operator === \"||\" || a.operator === \"&&\") &&\n                a.operator === b.operator\n            ) {\n                return equal(a.left, b.left) && equal(a.right, b.right) ||\n                    equal(a.left, b.right) && equal(a.right, b.left);\n            }\n\n            return astUtils.equalTokens(a, b, sourceCode);\n        }\n\n        const isSubset = isSubsetByComparator.bind(null, equal);\n\n        return {\n            IfStatement(node) {\n                const test = node.test,\n                    conditionsToCheck = test.type === \"LogicalExpression\" && test.operator === \"&&\"\n                        ? [test, ...splitByAnd(test)]\n                        : [test];\n                let current = node,\n                    listToCheck = conditionsToCheck.map(c => splitByOr(c).map(splitByAnd));\n\n                while (current.parent && current.parent.type === \"IfStatement\" && current.parent.alternate === current) {\n                    current = current.parent;\n\n                    const currentOrOperands = splitByOr(current.test).map(splitByAnd);\n\n                    listToCheck = listToCheck.map(orOperands => orOperands.filter(\n                        orOperand => !currentOrOperands.some(currentOrOperand => isSubset(currentOrOperand, orOperand))\n                    ));\n\n                    if (listToCheck.some(orOperands => orOperands.length === 0)) {\n                        context.report({ node: test, messageId: \"unexpected\" });\n                        break;\n                    }\n                }\n            }\n        };\n    }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,oBAAT,CAA8BC,UAA9B,EAA0CC,IAA1C,EAAgDC,IAAhD,EAAsD;EAClD,OAAOD,IAAI,CAACE,KAAL,CAAWC,CAAC,IAAIF,IAAI,CAACG,IAAL,CAAUC,CAAC,IAAIN,UAAU,CAACI,CAAD,EAAIE,CAAJ,CAAzB,CAAhB,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,sBAAT,CAAgCC,QAAhC,EAA0CC,IAA1C,EAAgD;EAC5C,IAAIA,IAAI,CAACC,IAAL,KAAc,mBAAd,IAAqCD,IAAI,CAACD,QAAL,KAAkBA,QAA3D,EAAqE;IACjE,OAAO,CAAC,GAAGD,sBAAsB,CAACC,QAAD,EAAWC,IAAI,CAACE,IAAhB,CAA1B,EAAiD,GAAGJ,sBAAsB,CAACC,QAAD,EAAWC,IAAI,CAACG,KAAhB,CAA1E,CAAP;EACH;;EACD,OAAO,CAACH,IAAD,CAAP;AACH;;AAED,MAAMI,SAAS,GAAGN,sBAAsB,CAACO,IAAvB,CAA4B,IAA5B,EAAkC,IAAlC,CAAlB;AACA,MAAMC,UAAU,GAAGR,sBAAsB,CAACO,IAAvB,CAA4B,IAA5B,EAAkC,IAAlC,CAAnB,C,CAEA;AACA;AACA;;AAEA;;AACAE,MAAM,CAACC,OAAP,GAAiB;EACbC,IAAI,EAAE;IACFR,IAAI,EAAE,SADJ;IAGFS,IAAI,EAAE;MACFC,WAAW,EAAE,oDADX;MAEFC,WAAW,EAAE,IAFX;MAGFC,GAAG,EAAE;IAHH,CAHJ;IASFC,MAAM,EAAE,EATN;IAWFC,QAAQ,EAAE;MACNC,UAAU,EAAE;IADN;EAXR,CADO;;EAiBbC,MAAM,CAACC,OAAD,EAAU;IACZ,MAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB;IAEA;AACR;AACA;AACA;AACA;AACA;AACA;;IACQ,SAASC,KAAT,CAAe1B,CAAf,EAAkBE,CAAlB,EAAqB;MACjB,IAAIF,CAAC,CAACM,IAAF,KAAWJ,CAAC,CAACI,IAAjB,EAAuB;QACnB,OAAO,KAAP;MACH;;MAED,IACIN,CAAC,CAACM,IAAF,KAAW,mBAAX,KACCN,CAAC,CAACI,QAAF,KAAe,IAAf,IAAuBJ,CAAC,CAACI,QAAF,KAAe,IADvC,KAEAJ,CAAC,CAACI,QAAF,KAAeF,CAAC,CAACE,QAHrB,EAIE;QACE,OAAOsB,KAAK,CAAC1B,CAAC,CAACO,IAAH,EAASL,CAAC,CAACK,IAAX,CAAL,IAAyBmB,KAAK,CAAC1B,CAAC,CAACQ,KAAH,EAAUN,CAAC,CAACM,KAAZ,CAA9B,IACHkB,KAAK,CAAC1B,CAAC,CAACO,IAAH,EAASL,CAAC,CAACM,KAAX,CAAL,IAA0BkB,KAAK,CAAC1B,CAAC,CAACQ,KAAH,EAAUN,CAAC,CAACK,IAAZ,CADnC;MAEH;;MAED,OAAOd,QAAQ,CAACkC,WAAT,CAAqB3B,CAArB,EAAwBE,CAAxB,EAA2BsB,UAA3B,CAAP;IACH;;IAED,MAAMI,QAAQ,GAAGjC,oBAAoB,CAACe,IAArB,CAA0B,IAA1B,EAAgCgB,KAAhC,CAAjB;IAEA,OAAO;MACHG,WAAW,CAACxB,IAAD,EAAO;QACd,MAAMyB,IAAI,GAAGzB,IAAI,CAACyB,IAAlB;QAAA,MACIC,iBAAiB,GAAGD,IAAI,CAACxB,IAAL,KAAc,mBAAd,IAAqCwB,IAAI,CAAC1B,QAAL,KAAkB,IAAvD,GACd,CAAC0B,IAAD,EAAO,GAAGnB,UAAU,CAACmB,IAAD,CAApB,CADc,GAEd,CAACA,IAAD,CAHV;QAIA,IAAIE,OAAO,GAAG3B,IAAd;QAAA,IACI4B,WAAW,GAAGF,iBAAiB,CAACG,GAAlB,CAAsBC,CAAC,IAAI1B,SAAS,CAAC0B,CAAD,CAAT,CAAaD,GAAb,CAAiBvB,UAAjB,CAA3B,CADlB;;QAGA,OAAOqB,OAAO,CAACI,MAAR,IAAkBJ,OAAO,CAACI,MAAR,CAAe9B,IAAf,KAAwB,aAA1C,IAA2D0B,OAAO,CAACI,MAAR,CAAeC,SAAf,KAA6BL,OAA/F,EAAwG;UACpGA,OAAO,GAAGA,OAAO,CAACI,MAAlB;UAEA,MAAME,iBAAiB,GAAG7B,SAAS,CAACuB,OAAO,CAACF,IAAT,CAAT,CAAwBI,GAAxB,CAA4BvB,UAA5B,CAA1B;UAEAsB,WAAW,GAAGA,WAAW,CAACC,GAAZ,CAAgBK,UAAU,IAAIA,UAAU,CAACC,MAAX,CACxCC,SAAS,IAAI,CAACH,iBAAiB,CAACrC,IAAlB,CAAuByC,gBAAgB,IAAId,QAAQ,CAACc,gBAAD,EAAmBD,SAAnB,CAAnD,CAD0B,CAA9B,CAAd;;UAIA,IAAIR,WAAW,CAAChC,IAAZ,CAAiBsC,UAAU,IAAIA,UAAU,CAACI,MAAX,KAAsB,CAArD,CAAJ,EAA6D;YACzDpB,OAAO,CAACqB,MAAR,CAAe;cAAEvC,IAAI,EAAEyB,IAAR;cAAce,SAAS,EAAE;YAAzB,CAAf;YACA;UACH;QACJ;MACJ;;IAvBE,CAAP;EAyBH;;AAvEY,CAAjB"},"metadata":{},"sourceType":"script"}