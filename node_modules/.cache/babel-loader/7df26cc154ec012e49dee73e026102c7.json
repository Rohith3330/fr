{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst ts = __importStar(require(\"typescript\"));\n\nconst util = __importStar(require(\"../util\"));\n\nexports.default = util.createRule({\n  name: 'no-unnecessary-qualifier',\n  meta: {\n    docs: {\n      description: 'Disallow unnecessary namespace qualifiers',\n      recommended: false,\n      requiresTypeChecking: true\n    },\n    fixable: 'code',\n    messages: {\n      unnecessaryQualifier: \"Qualifier is unnecessary since '{{ name }}' is in scope.\"\n    },\n    schema: [],\n    type: 'suggestion'\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const namespacesInScope = [];\n    let currentFailedNamespaceExpression = null;\n    const parserServices = util.getParserServices(context);\n    const esTreeNodeToTSNodeMap = parserServices.esTreeNodeToTSNodeMap;\n    const program = parserServices.program;\n    const checker = program.getTypeChecker();\n    const sourceCode = context.getSourceCode();\n\n    function tryGetAliasedSymbol(symbol, checker) {\n      return tsutils.isSymbolFlagSet(symbol, ts.SymbolFlags.Alias) ? checker.getAliasedSymbol(symbol) : null;\n    }\n\n    function symbolIsNamespaceInScope(symbol) {\n      var _a;\n\n      const symbolDeclarations = (_a = symbol.getDeclarations()) !== null && _a !== void 0 ? _a : [];\n\n      if (symbolDeclarations.some(decl => namespacesInScope.some(ns => ns === decl))) {\n        return true;\n      }\n\n      const alias = tryGetAliasedSymbol(symbol, checker);\n      return alias !== null && symbolIsNamespaceInScope(alias);\n    }\n\n    function getSymbolInScope(node, flags, name) {\n      // TODO:PERF `getSymbolsInScope` gets a long list. Is there a better way?\n      const scope = checker.getSymbolsInScope(node, flags);\n      return scope.find(scopeSymbol => scopeSymbol.name === name);\n    }\n\n    function symbolsAreEqual(accessed, inScope) {\n      return accessed === checker.getExportSymbolOfSymbol(inScope);\n    }\n\n    function qualifierIsUnnecessary(qualifier, name) {\n      const tsQualifier = esTreeNodeToTSNodeMap.get(qualifier);\n      const tsName = esTreeNodeToTSNodeMap.get(name);\n      const namespaceSymbol = checker.getSymbolAtLocation(tsQualifier);\n\n      if (typeof namespaceSymbol === 'undefined' || !symbolIsNamespaceInScope(namespaceSymbol)) {\n        return false;\n      }\n\n      const accessedSymbol = checker.getSymbolAtLocation(tsName);\n\n      if (typeof accessedSymbol === 'undefined') {\n        return false;\n      } // If the symbol in scope is different, the qualifier is necessary.\n\n\n      const fromScope = getSymbolInScope(tsQualifier, accessedSymbol.flags, sourceCode.getText(name));\n      return typeof fromScope === 'undefined' || symbolsAreEqual(accessedSymbol, fromScope);\n    }\n\n    function visitNamespaceAccess(node, qualifier, name) {\n      // Only look for nested qualifier errors if we didn't already fail on the outer qualifier.\n      if (!currentFailedNamespaceExpression && qualifierIsUnnecessary(qualifier, name)) {\n        currentFailedNamespaceExpression = node;\n        context.report({\n          node: qualifier,\n          messageId: 'unnecessaryQualifier',\n          data: {\n            name: sourceCode.getText(name)\n          },\n\n          fix(fixer) {\n            return fixer.removeRange([qualifier.range[0], name.range[0]]);\n          }\n\n        });\n      }\n    }\n\n    function enterDeclaration(node) {\n      namespacesInScope.push(esTreeNodeToTSNodeMap.get(node));\n    }\n\n    function exitDeclaration() {\n      namespacesInScope.pop();\n    }\n\n    function resetCurrentNamespaceExpression(node) {\n      if (node === currentFailedNamespaceExpression) {\n        currentFailedNamespaceExpression = null;\n      }\n    }\n\n    function isPropertyAccessExpression(node) {\n      return node.type === utils_1.AST_NODE_TYPES.MemberExpression && !node.computed;\n    }\n\n    function isEntityNameExpression(node) {\n      return node.type === utils_1.AST_NODE_TYPES.Identifier || isPropertyAccessExpression(node) && isEntityNameExpression(node.object);\n    }\n\n    return {\n      TSModuleDeclaration: enterDeclaration,\n      TSEnumDeclaration: enterDeclaration,\n      'ExportNamedDeclaration[declaration.type=\"TSModuleDeclaration\"]': enterDeclaration,\n      'ExportNamedDeclaration[declaration.type=\"TSEnumDeclaration\"]': enterDeclaration,\n      'TSModuleDeclaration:exit': exitDeclaration,\n      'TSEnumDeclaration:exit': exitDeclaration,\n      'ExportNamedDeclaration[declaration.type=\"TSModuleDeclaration\"]:exit': exitDeclaration,\n      'ExportNamedDeclaration[declaration.type=\"TSEnumDeclaration\"]:exit': exitDeclaration,\n\n      TSQualifiedName(node) {\n        visitNamespaceAccess(node, node.left, node.right);\n      },\n\n      'MemberExpression[computed=false]': function (node) {\n        const property = node.property;\n\n        if (isEntityNameExpression(node.object)) {\n          visitNamespaceAccess(node, node.object, property);\n        }\n      },\n      'TSQualifiedName:exit': resetCurrentNamespaceExpression,\n      'MemberExpression:exit': resetCurrentNamespaceExpression\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","docs","description","recommended","requiresTypeChecking","fixable","messages","unnecessaryQualifier","schema","type","defaultOptions","create","context","namespacesInScope","currentFailedNamespaceExpression","parserServices","getParserServices","esTreeNodeToTSNodeMap","program","checker","getTypeChecker","sourceCode","getSourceCode","tryGetAliasedSymbol","symbol","tsutils","isSymbolFlagSet","ts","SymbolFlags","Alias","getAliasedSymbol","symbolIsNamespaceInScope","symbolDeclarations","getDeclarations","_a","some","decl","ns","alias","getSymbolInScope","node","flags","scope","getSymbolsInScope","find","scopeSymbol","symbolsAreEqual","accessed","inScope","getExportSymbolOfSymbol","qualifierIsUnnecessary","qualifier","tsQualifier","get","tsName","namespaceSymbol","getSymbolAtLocation","accessedSymbol","fromScope","getText","visitNamespaceAccess","report","messageId","data","fix","fixer","removeRange","range","enterDeclaration","push","exitDeclaration","pop","resetCurrentNamespaceExpression","isPropertyAccessExpression","utils_1","MemberExpression","computed","isEntityNameExpression","Identifier","object","TSModuleDeclaration","TSEnumDeclaration","TSQualifiedName","left","right","property"],"sources":["../../src/rules/no-unnecessary-qualifier.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}