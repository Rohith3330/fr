{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst isPromiseChainCall = node => {\n  if (node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && node.callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && (0, _utils.isSupportedAccessor)(node.callee.property)) {\n    // promise methods should have at least 1 argument\n    if (node.arguments.length === 0) {\n      return false;\n    }\n\n    switch ((0, _utils.getAccessorValue)(node.callee.property)) {\n      case 'then':\n        return node.arguments.length < 3;\n\n      case 'catch':\n      case 'finally':\n        return node.arguments.length < 2;\n    }\n  }\n\n  return false;\n};\n\nconst findTopMostCallExpression = node => {\n  let topMostCallExpression = node;\n  let {\n    parent\n  } = node;\n\n  while (parent) {\n    if (parent.type === _experimentalUtils.AST_NODE_TYPES.CallExpression) {\n      topMostCallExpression = parent;\n      parent = parent.parent;\n      continue;\n    }\n\n    if (parent.type !== _experimentalUtils.AST_NODE_TYPES.MemberExpression) {\n      break;\n    }\n\n    parent = parent.parent;\n  }\n\n  return topMostCallExpression;\n};\n\nconst isTestCaseCallWithCallbackArg = node => {\n  if (!(0, _utils.isTestCaseCall)(node)) {\n    return false;\n  }\n\n  const isJestEach = (0, _utils.getNodeName)(node).endsWith('.each');\n\n  if (isJestEach && node.callee.type !== _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression) {\n    // isJestEach but not a TaggedTemplateExpression, so this must be\n    // the `jest.each([])()` syntax which this rule doesn't support due\n    // to its complexity (see jest-community/eslint-plugin-jest#710)\n    // so we return true to trigger bailout\n    return true;\n  }\n\n  if (isJestEach || node.arguments.length >= 2) {\n    const [, callback] = node.arguments;\n    const callbackArgIndex = Number(isJestEach);\n    return callback && (0, _utils.isFunction)(callback) && callback.params.length === 1 + callbackArgIndex;\n  }\n\n  return false;\n};\n\nconst isPromiseMethodThatUsesValue = (node, identifier) => {\n  const {\n    name\n  } = identifier;\n\n  if (node.argument === null) {\n    return false;\n  }\n\n  if (node.argument.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && node.argument.arguments.length > 0) {\n    const nodeName = (0, _utils.getNodeName)(node.argument);\n\n    if (['Promise.all', 'Promise.allSettled'].includes(nodeName)) {\n      const [firstArg] = node.argument.arguments;\n\n      if (firstArg.type === _experimentalUtils.AST_NODE_TYPES.ArrayExpression && firstArg.elements.some(nod => (0, _utils.isIdentifier)(nod, name))) {\n        return true;\n      }\n    }\n\n    if (['Promise.resolve', 'Promise.reject'].includes(nodeName) && node.argument.arguments.length === 1) {\n      return (0, _utils.isIdentifier)(node.argument.arguments[0], name);\n    }\n  }\n\n  return (0, _utils.isIdentifier)(node.argument, name);\n};\n/**\n * Attempts to determine if the runtime value represented by the given `identifier`\n * is `await`ed within the given array of elements\n */\n\n\nconst isValueAwaitedInElements = (name, elements) => {\n  for (const element of elements) {\n    if (element.type === _experimentalUtils.AST_NODE_TYPES.AwaitExpression && (0, _utils.isIdentifier)(element.argument, name)) {\n      return true;\n    }\n\n    if (element.type === _experimentalUtils.AST_NODE_TYPES.ArrayExpression && isValueAwaitedInElements(name, element.elements)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Attempts to determine if the runtime value represented by the given `identifier`\n * is `await`ed as an argument along the given call expression\n */\n\n\nconst isValueAwaitedInArguments = (name, call) => {\n  let node = call;\n\n  while (node) {\n    if (node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression) {\n      if (isValueAwaitedInElements(name, node.arguments)) {\n        return true;\n      }\n\n      node = node.callee;\n    }\n\n    if (node.type !== _experimentalUtils.AST_NODE_TYPES.MemberExpression) {\n      break;\n    }\n\n    node = node.object;\n  }\n\n  return false;\n};\n\nconst getLeftMostCallExpression = call => {\n  let leftMostCallExpression = call;\n  let node = call;\n\n  while (node) {\n    if (node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression) {\n      leftMostCallExpression = node;\n      node = node.callee;\n    }\n\n    if (node.type !== _experimentalUtils.AST_NODE_TYPES.MemberExpression) {\n      break;\n    }\n\n    node = node.object;\n  }\n\n  return leftMostCallExpression;\n};\n/**\n * Attempts to determine if the runtime value represented by the given `identifier`\n * is `await`ed or `return`ed within the given `body` of statements\n */\n\n\nconst isValueAwaitedOrReturned = (identifier, body) => {\n  const {\n    name\n  } = identifier;\n\n  for (const node of body) {\n    // skip all nodes that are before this identifier, because they'd probably\n    // be affecting a different runtime value (e.g. due to reassignment)\n    if (node.range[0] <= identifier.range[0]) {\n      continue;\n    }\n\n    if (node.type === _experimentalUtils.AST_NODE_TYPES.ReturnStatement) {\n      return isPromiseMethodThatUsesValue(node, identifier);\n    }\n\n    if (node.type === _experimentalUtils.AST_NODE_TYPES.ExpressionStatement) {\n      // it's possible that we're awaiting the value as an argument\n      if (node.expression.type === _experimentalUtils.AST_NODE_TYPES.CallExpression) {\n        if (isValueAwaitedInArguments(name, node.expression)) {\n          return true;\n        }\n\n        const leftMostCall = getLeftMostCallExpression(node.expression);\n\n        if ((0, _utils.isExpectCall)(leftMostCall) && leftMostCall.arguments.length > 0 && (0, _utils.isIdentifier)(leftMostCall.arguments[0], name)) {\n          const {\n            modifier\n          } = (0, _utils.parseExpectCall)(leftMostCall);\n\n          if ((modifier === null || modifier === void 0 ? void 0 : modifier.name) === _utils.ModifierName.resolves || (modifier === null || modifier === void 0 ? void 0 : modifier.name) === _utils.ModifierName.rejects) {\n            return true;\n          }\n        }\n      }\n\n      if (node.expression.type === _experimentalUtils.AST_NODE_TYPES.AwaitExpression && isPromiseMethodThatUsesValue(node.expression, identifier)) {\n        return true;\n      } // (re)assignment changes the runtime value, so if we've not found an\n      // await or return already we act as if we've reached the end of the body\n\n\n      if (node.expression.type === _experimentalUtils.AST_NODE_TYPES.AssignmentExpression) {\n        var _getNodeName; // unless we're assigning to the same identifier, in which case\n        // we might be chaining off the existing promise value\n\n\n        if ((0, _utils.isIdentifier)(node.expression.left, name) && (_getNodeName = (0, _utils.getNodeName)(node.expression.right)) !== null && _getNodeName !== void 0 && _getNodeName.startsWith(`${name}.`) && isPromiseChainCall(node.expression.right)) {\n          continue;\n        }\n\n        break;\n      }\n    }\n\n    if (node.type === _experimentalUtils.AST_NODE_TYPES.BlockStatement && isValueAwaitedOrReturned(identifier, node.body)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst findFirstBlockBodyUp = node => {\n  let parent = node;\n\n  while (parent) {\n    if (parent.type === _experimentalUtils.AST_NODE_TYPES.BlockStatement) {\n      return parent.body;\n    }\n\n    parent = parent.parent;\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error(`Could not find BlockStatement - please file a github issue at https://github.com/jest-community/eslint-plugin-jest`);\n};\n\nconst isDirectlyWithinTestCaseCall = node => {\n  let parent = node;\n\n  while (parent) {\n    if ((0, _utils.isFunction)(parent)) {\n      var _parent;\n\n      parent = parent.parent;\n      return !!(((_parent = parent) === null || _parent === void 0 ? void 0 : _parent.type) === _experimentalUtils.AST_NODE_TYPES.CallExpression && (0, _utils.isTestCaseCall)(parent));\n    }\n\n    parent = parent.parent;\n  }\n\n  return false;\n};\n\nconst isVariableAwaitedOrReturned = variable => {\n  const body = findFirstBlockBodyUp(variable); // it's pretty much impossible for us to track destructuring assignments,\n  // so we return true to bailout gracefully\n\n  if (!(0, _utils.isIdentifier)(variable.id)) {\n    return true;\n  }\n\n  return isValueAwaitedOrReturned(variable.id, body);\n};\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Ensure promises that have expectations in their chain are valid',\n      recommended: 'error'\n    },\n    messages: {\n      expectInFloatingPromise: \"This promise should either be returned or awaited to ensure the expects in it's chain are called\"\n    },\n    type: 'suggestion',\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    let inTestCaseWithDoneCallback = false; // an array of booleans representing each promise chain we enter, with the\n    // boolean value representing if we think a given chain contains an expect\n    // in it's body.\n    //\n    // since we only care about the inner-most chain, we represent the state in\n    // reverse with the inner-most being the first item, as that makes it\n    // slightly less code to assign to by not needing to know the length\n\n    const chains = [];\n    return {\n      CallExpression(node) {\n        // there are too many ways that the done argument could be used with\n        // promises that contain expect that would make the promise safe for us\n        if (isTestCaseCallWithCallbackArg(node)) {\n          inTestCaseWithDoneCallback = true;\n          return;\n        } // if this call expression is a promise chain, add it to the stack with\n        // value of \"false\", as we assume there are no expect calls initially\n\n\n        if (isPromiseChainCall(node)) {\n          chains.unshift(false);\n          return;\n        } // if we're within a promise chain, and this call expression looks like\n        // an expect call, mark the deepest chain as having an expect call\n\n\n        if (chains.length > 0 && (0, _utils.isExpectCall)(node)) {\n          chains[0] = true;\n        }\n      },\n\n      'CallExpression:exit'(node) {\n        // there are too many ways that the \"done\" argument could be used to\n        // make promises containing expects safe in a test for us to be able to\n        // accurately check, so we just bail out completely if it's present\n        if (inTestCaseWithDoneCallback) {\n          if ((0, _utils.isTestCaseCall)(node)) {\n            inTestCaseWithDoneCallback = false;\n          }\n\n          return;\n        }\n\n        if (!isPromiseChainCall(node)) {\n          return;\n        } // since we're exiting this call expression (which is a promise chain)\n        // we remove it from the stack of chains, since we're unwinding\n\n\n        const hasExpectCall = chains.shift(); // if the promise chain we're exiting doesn't contain an expect,\n        // then we don't need to check it for anything\n\n        if (!hasExpectCall) {\n          return;\n        }\n\n        const {\n          parent\n        } = findTopMostCallExpression(node); // if we don't have a parent (which is technically impossible at runtime)\n        // or our parent is not directly within the test case, we stop checking\n        // because we're most likely in the body of a function being defined\n        // within the test, which we can't track\n\n        if (!parent || !isDirectlyWithinTestCaseCall(parent)) {\n          return;\n        }\n\n        switch (parent.type) {\n          case _experimentalUtils.AST_NODE_TYPES.VariableDeclarator:\n            {\n              if (isVariableAwaitedOrReturned(parent)) {\n                return;\n              }\n\n              break;\n            }\n\n          case _experimentalUtils.AST_NODE_TYPES.AssignmentExpression:\n            {\n              if (parent.left.type === _experimentalUtils.AST_NODE_TYPES.Identifier && isValueAwaitedOrReturned(parent.left, findFirstBlockBodyUp(parent))) {\n                return;\n              }\n\n              break;\n            }\n\n          case _experimentalUtils.AST_NODE_TYPES.ExpressionStatement:\n            break;\n\n          case _experimentalUtils.AST_NODE_TYPES.ReturnStatement:\n          case _experimentalUtils.AST_NODE_TYPES.AwaitExpression:\n          default:\n            return;\n        }\n\n        context.report({\n          messageId: 'expectInFloatingPromise',\n          node: parent\n        });\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_experimentalUtils","require","_utils","isPromiseChainCall","node","type","AST_NODE_TYPES","CallExpression","callee","MemberExpression","isSupportedAccessor","property","arguments","length","getAccessorValue","findTopMostCallExpression","topMostCallExpression","parent","isTestCaseCallWithCallbackArg","isTestCaseCall","isJestEach","getNodeName","endsWith","TaggedTemplateExpression","callback","callbackArgIndex","Number","isFunction","params","isPromiseMethodThatUsesValue","identifier","name","argument","nodeName","includes","firstArg","ArrayExpression","elements","some","nod","isIdentifier","isValueAwaitedInElements","element","AwaitExpression","isValueAwaitedInArguments","call","object","getLeftMostCallExpression","leftMostCallExpression","isValueAwaitedOrReturned","body","range","ReturnStatement","ExpressionStatement","expression","leftMostCall","isExpectCall","modifier","parseExpectCall","ModifierName","resolves","rejects","AssignmentExpression","_getNodeName","left","right","startsWith","BlockStatement","findFirstBlockBodyUp","Error","isDirectlyWithinTestCaseCall","_parent","isVariableAwaitedOrReturned","variable","id","_default","createRule","__filename","meta","docs","category","description","recommended","messages","expectInFloatingPromise","schema","defaultOptions","create","context","inTestCaseWithDoneCallback","chains","unshift","hasExpectCall","shift","VariableDeclarator","Identifier","report","messageId"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-jest/lib/rules/valid-expect-in-promise.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst isPromiseChainCall = node => {\n  if (node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && node.callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && (0, _utils.isSupportedAccessor)(node.callee.property)) {\n    // promise methods should have at least 1 argument\n    if (node.arguments.length === 0) {\n      return false;\n    }\n\n    switch ((0, _utils.getAccessorValue)(node.callee.property)) {\n      case 'then':\n        return node.arguments.length < 3;\n\n      case 'catch':\n      case 'finally':\n        return node.arguments.length < 2;\n    }\n  }\n\n  return false;\n};\n\nconst findTopMostCallExpression = node => {\n  let topMostCallExpression = node;\n  let {\n    parent\n  } = node;\n\n  while (parent) {\n    if (parent.type === _experimentalUtils.AST_NODE_TYPES.CallExpression) {\n      topMostCallExpression = parent;\n      parent = parent.parent;\n      continue;\n    }\n\n    if (parent.type !== _experimentalUtils.AST_NODE_TYPES.MemberExpression) {\n      break;\n    }\n\n    parent = parent.parent;\n  }\n\n  return topMostCallExpression;\n};\n\nconst isTestCaseCallWithCallbackArg = node => {\n  if (!(0, _utils.isTestCaseCall)(node)) {\n    return false;\n  }\n\n  const isJestEach = (0, _utils.getNodeName)(node).endsWith('.each');\n\n  if (isJestEach && node.callee.type !== _experimentalUtils.AST_NODE_TYPES.TaggedTemplateExpression) {\n    // isJestEach but not a TaggedTemplateExpression, so this must be\n    // the `jest.each([])()` syntax which this rule doesn't support due\n    // to its complexity (see jest-community/eslint-plugin-jest#710)\n    // so we return true to trigger bailout\n    return true;\n  }\n\n  if (isJestEach || node.arguments.length >= 2) {\n    const [, callback] = node.arguments;\n    const callbackArgIndex = Number(isJestEach);\n    return callback && (0, _utils.isFunction)(callback) && callback.params.length === 1 + callbackArgIndex;\n  }\n\n  return false;\n};\n\nconst isPromiseMethodThatUsesValue = (node, identifier) => {\n  const {\n    name\n  } = identifier;\n\n  if (node.argument === null) {\n    return false;\n  }\n\n  if (node.argument.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && node.argument.arguments.length > 0) {\n    const nodeName = (0, _utils.getNodeName)(node.argument);\n\n    if (['Promise.all', 'Promise.allSettled'].includes(nodeName)) {\n      const [firstArg] = node.argument.arguments;\n\n      if (firstArg.type === _experimentalUtils.AST_NODE_TYPES.ArrayExpression && firstArg.elements.some(nod => (0, _utils.isIdentifier)(nod, name))) {\n        return true;\n      }\n    }\n\n    if (['Promise.resolve', 'Promise.reject'].includes(nodeName) && node.argument.arguments.length === 1) {\n      return (0, _utils.isIdentifier)(node.argument.arguments[0], name);\n    }\n  }\n\n  return (0, _utils.isIdentifier)(node.argument, name);\n};\n/**\n * Attempts to determine if the runtime value represented by the given `identifier`\n * is `await`ed within the given array of elements\n */\n\n\nconst isValueAwaitedInElements = (name, elements) => {\n  for (const element of elements) {\n    if (element.type === _experimentalUtils.AST_NODE_TYPES.AwaitExpression && (0, _utils.isIdentifier)(element.argument, name)) {\n      return true;\n    }\n\n    if (element.type === _experimentalUtils.AST_NODE_TYPES.ArrayExpression && isValueAwaitedInElements(name, element.elements)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Attempts to determine if the runtime value represented by the given `identifier`\n * is `await`ed as an argument along the given call expression\n */\n\n\nconst isValueAwaitedInArguments = (name, call) => {\n  let node = call;\n\n  while (node) {\n    if (node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression) {\n      if (isValueAwaitedInElements(name, node.arguments)) {\n        return true;\n      }\n\n      node = node.callee;\n    }\n\n    if (node.type !== _experimentalUtils.AST_NODE_TYPES.MemberExpression) {\n      break;\n    }\n\n    node = node.object;\n  }\n\n  return false;\n};\n\nconst getLeftMostCallExpression = call => {\n  let leftMostCallExpression = call;\n  let node = call;\n\n  while (node) {\n    if (node.type === _experimentalUtils.AST_NODE_TYPES.CallExpression) {\n      leftMostCallExpression = node;\n      node = node.callee;\n    }\n\n    if (node.type !== _experimentalUtils.AST_NODE_TYPES.MemberExpression) {\n      break;\n    }\n\n    node = node.object;\n  }\n\n  return leftMostCallExpression;\n};\n/**\n * Attempts to determine if the runtime value represented by the given `identifier`\n * is `await`ed or `return`ed within the given `body` of statements\n */\n\n\nconst isValueAwaitedOrReturned = (identifier, body) => {\n  const {\n    name\n  } = identifier;\n\n  for (const node of body) {\n    // skip all nodes that are before this identifier, because they'd probably\n    // be affecting a different runtime value (e.g. due to reassignment)\n    if (node.range[0] <= identifier.range[0]) {\n      continue;\n    }\n\n    if (node.type === _experimentalUtils.AST_NODE_TYPES.ReturnStatement) {\n      return isPromiseMethodThatUsesValue(node, identifier);\n    }\n\n    if (node.type === _experimentalUtils.AST_NODE_TYPES.ExpressionStatement) {\n      // it's possible that we're awaiting the value as an argument\n      if (node.expression.type === _experimentalUtils.AST_NODE_TYPES.CallExpression) {\n        if (isValueAwaitedInArguments(name, node.expression)) {\n          return true;\n        }\n\n        const leftMostCall = getLeftMostCallExpression(node.expression);\n\n        if ((0, _utils.isExpectCall)(leftMostCall) && leftMostCall.arguments.length > 0 && (0, _utils.isIdentifier)(leftMostCall.arguments[0], name)) {\n          const {\n            modifier\n          } = (0, _utils.parseExpectCall)(leftMostCall);\n\n          if ((modifier === null || modifier === void 0 ? void 0 : modifier.name) === _utils.ModifierName.resolves || (modifier === null || modifier === void 0 ? void 0 : modifier.name) === _utils.ModifierName.rejects) {\n            return true;\n          }\n        }\n      }\n\n      if (node.expression.type === _experimentalUtils.AST_NODE_TYPES.AwaitExpression && isPromiseMethodThatUsesValue(node.expression, identifier)) {\n        return true;\n      } // (re)assignment changes the runtime value, so if we've not found an\n      // await or return already we act as if we've reached the end of the body\n\n\n      if (node.expression.type === _experimentalUtils.AST_NODE_TYPES.AssignmentExpression) {\n        var _getNodeName;\n\n        // unless we're assigning to the same identifier, in which case\n        // we might be chaining off the existing promise value\n        if ((0, _utils.isIdentifier)(node.expression.left, name) && (_getNodeName = (0, _utils.getNodeName)(node.expression.right)) !== null && _getNodeName !== void 0 && _getNodeName.startsWith(`${name}.`) && isPromiseChainCall(node.expression.right)) {\n          continue;\n        }\n\n        break;\n      }\n    }\n\n    if (node.type === _experimentalUtils.AST_NODE_TYPES.BlockStatement && isValueAwaitedOrReturned(identifier, node.body)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nconst findFirstBlockBodyUp = node => {\n  let parent = node;\n\n  while (parent) {\n    if (parent.type === _experimentalUtils.AST_NODE_TYPES.BlockStatement) {\n      return parent.body;\n    }\n\n    parent = parent.parent;\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error(`Could not find BlockStatement - please file a github issue at https://github.com/jest-community/eslint-plugin-jest`);\n};\n\nconst isDirectlyWithinTestCaseCall = node => {\n  let parent = node;\n\n  while (parent) {\n    if ((0, _utils.isFunction)(parent)) {\n      var _parent;\n\n      parent = parent.parent;\n      return !!(((_parent = parent) === null || _parent === void 0 ? void 0 : _parent.type) === _experimentalUtils.AST_NODE_TYPES.CallExpression && (0, _utils.isTestCaseCall)(parent));\n    }\n\n    parent = parent.parent;\n  }\n\n  return false;\n};\n\nconst isVariableAwaitedOrReturned = variable => {\n  const body = findFirstBlockBodyUp(variable); // it's pretty much impossible for us to track destructuring assignments,\n  // so we return true to bailout gracefully\n\n  if (!(0, _utils.isIdentifier)(variable.id)) {\n    return true;\n  }\n\n  return isValueAwaitedOrReturned(variable.id, body);\n};\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Ensure promises that have expectations in their chain are valid',\n      recommended: 'error'\n    },\n    messages: {\n      expectInFloatingPromise: \"This promise should either be returned or awaited to ensure the expects in it's chain are called\"\n    },\n    type: 'suggestion',\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    let inTestCaseWithDoneCallback = false; // an array of booleans representing each promise chain we enter, with the\n    // boolean value representing if we think a given chain contains an expect\n    // in it's body.\n    //\n    // since we only care about the inner-most chain, we represent the state in\n    // reverse with the inner-most being the first item, as that makes it\n    // slightly less code to assign to by not needing to know the length\n\n    const chains = [];\n    return {\n      CallExpression(node) {\n        // there are too many ways that the done argument could be used with\n        // promises that contain expect that would make the promise safe for us\n        if (isTestCaseCallWithCallbackArg(node)) {\n          inTestCaseWithDoneCallback = true;\n          return;\n        } // if this call expression is a promise chain, add it to the stack with\n        // value of \"false\", as we assume there are no expect calls initially\n\n\n        if (isPromiseChainCall(node)) {\n          chains.unshift(false);\n          return;\n        } // if we're within a promise chain, and this call expression looks like\n        // an expect call, mark the deepest chain as having an expect call\n\n\n        if (chains.length > 0 && (0, _utils.isExpectCall)(node)) {\n          chains[0] = true;\n        }\n      },\n\n      'CallExpression:exit'(node) {\n        // there are too many ways that the \"done\" argument could be used to\n        // make promises containing expects safe in a test for us to be able to\n        // accurately check, so we just bail out completely if it's present\n        if (inTestCaseWithDoneCallback) {\n          if ((0, _utils.isTestCaseCall)(node)) {\n            inTestCaseWithDoneCallback = false;\n          }\n\n          return;\n        }\n\n        if (!isPromiseChainCall(node)) {\n          return;\n        } // since we're exiting this call expression (which is a promise chain)\n        // we remove it from the stack of chains, since we're unwinding\n\n\n        const hasExpectCall = chains.shift(); // if the promise chain we're exiting doesn't contain an expect,\n        // then we don't need to check it for anything\n\n        if (!hasExpectCall) {\n          return;\n        }\n\n        const {\n          parent\n        } = findTopMostCallExpression(node); // if we don't have a parent (which is technically impossible at runtime)\n        // or our parent is not directly within the test case, we stop checking\n        // because we're most likely in the body of a function being defined\n        // within the test, which we can't track\n\n        if (!parent || !isDirectlyWithinTestCaseCall(parent)) {\n          return;\n        }\n\n        switch (parent.type) {\n          case _experimentalUtils.AST_NODE_TYPES.VariableDeclarator:\n            {\n              if (isVariableAwaitedOrReturned(parent)) {\n                return;\n              }\n\n              break;\n            }\n\n          case _experimentalUtils.AST_NODE_TYPES.AssignmentExpression:\n            {\n              if (parent.left.type === _experimentalUtils.AST_NODE_TYPES.Identifier && isValueAwaitedOrReturned(parent.left, findFirstBlockBodyUp(parent))) {\n                return;\n              }\n\n              break;\n            }\n\n          case _experimentalUtils.AST_NODE_TYPES.ExpressionStatement:\n            break;\n\n          case _experimentalUtils.AST_NODE_TYPES.ReturnStatement:\n          case _experimentalUtils.AST_NODE_TYPES.AwaitExpression:\n          default:\n            return;\n        }\n\n        context.report({\n          messageId: 'expectInFloatingPromise',\n          node: parent\n        });\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}