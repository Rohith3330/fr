{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = tokenizer;\nvar SINGLE_QUOTE = '\\''.charCodeAt(0);\nvar DOUBLE_QUOTE = '\"'.charCodeAt(0);\nvar BACKSLASH = '\\\\'.charCodeAt(0);\nvar SLASH = '/'.charCodeAt(0);\nvar NEWLINE = '\\n'.charCodeAt(0);\nvar SPACE = ' '.charCodeAt(0);\nvar FEED = '\\f'.charCodeAt(0);\nvar TAB = '\\t'.charCodeAt(0);\nvar CR = '\\r'.charCodeAt(0);\nvar OPEN_SQUARE = '['.charCodeAt(0);\nvar CLOSE_SQUARE = ']'.charCodeAt(0);\nvar OPEN_PARENTHESES = '('.charCodeAt(0);\nvar CLOSE_PARENTHESES = ')'.charCodeAt(0);\nvar OPEN_CURLY = '{'.charCodeAt(0);\nvar CLOSE_CURLY = '}'.charCodeAt(0);\nvar SEMICOLON = ';'.charCodeAt(0);\nvar ASTERISK = '*'.charCodeAt(0);\nvar COLON = ':'.charCodeAt(0);\nvar AT = '@'.charCodeAt(0);\nvar RE_AT_END = /[ \\n\\t\\r\\f{}()'\"\\\\;/[\\]#]/g;\nvar RE_WORD_END = /[ \\n\\t\\r\\f(){}:;@!'\"\\\\\\][#]|\\/(?=\\*)/g;\nvar RE_BAD_BRACKET = /.[\\\\/(\"'\\n]/;\nvar RE_HEX_ESCAPE = /[a-f0-9]/i;\n\nfunction tokenizer(input, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var css = input.css.valueOf();\n  var ignore = options.ignoreErrors;\n  var code, next, quote, lines, last, content, escape;\n  var nextLine, nextOffset, escaped, escapePos, prev, n, currentToken;\n  var length = css.length;\n  var offset = -1;\n  var line = 1;\n  var pos = 0;\n  var buffer = [];\n  var returned = [];\n\n  function position() {\n    return pos;\n  }\n\n  function unclosed(what) {\n    throw input.error('Unclosed ' + what, line, pos - offset);\n  }\n\n  function endOfFile() {\n    return returned.length === 0 && pos >= length;\n  }\n\n  function nextToken(opts) {\n    if (returned.length) return returned.pop();\n    if (pos >= length) return;\n    var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\n    code = css.charCodeAt(pos);\n\n    if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {\n      offset = pos;\n      line += 1;\n    }\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED:\n        next = pos;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === NEWLINE) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n\n        currentToken = ['space', css.slice(pos, next)];\n        pos = next - 1;\n        break;\n\n      case OPEN_SQUARE:\n      case CLOSE_SQUARE:\n      case OPEN_CURLY:\n      case CLOSE_CURLY:\n      case COLON:\n      case SEMICOLON:\n      case CLOSE_PARENTHESES:\n        var controlChar = String.fromCharCode(code);\n        currentToken = [controlChar, controlChar, line, pos - offset];\n        break;\n\n      case OPEN_PARENTHESES:\n        prev = buffer.length ? buffer.pop()[1] : '';\n        n = css.charCodeAt(pos + 1);\n\n        if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {\n          next = pos;\n\n          do {\n            escaped = false;\n            next = css.indexOf(')', next + 1);\n\n            if (next === -1) {\n              if (ignore || ignoreUnclosed) {\n                next = pos;\n                break;\n              } else {\n                unclosed('bracket');\n              }\n            }\n\n            escapePos = next;\n\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1;\n              escaped = !escaped;\n            }\n          } while (escaped);\n\n          currentToken = ['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n          pos = next;\n        } else {\n          next = css.indexOf(')', pos + 1);\n          content = css.slice(pos, next + 1);\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            currentToken = ['(', '(', line, pos - offset];\n          } else {\n            currentToken = ['brackets', content, line, pos - offset, line, next - offset];\n            pos = next;\n          }\n        }\n\n        break;\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE:\n        quote = code === SINGLE_QUOTE ? '\\'' : '\"';\n        next = pos;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            if (ignore || ignoreUnclosed) {\n              next = pos + 1;\n              break;\n            } else {\n              unclosed('string');\n            }\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        content = css.slice(pos, next + 1);\n        lines = content.split('\\n');\n        last = lines.length - 1;\n\n        if (last > 0) {\n          nextLine = line + last;\n          nextOffset = next - lines[last].length;\n        } else {\n          nextLine = line;\n          nextOffset = offset;\n        }\n\n        currentToken = ['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset];\n        offset = nextOffset;\n        line = nextLine;\n        pos = next;\n        break;\n\n      case AT:\n        RE_AT_END.lastIndex = pos + 1;\n        RE_AT_END.test(css);\n\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1;\n        } else {\n          next = RE_AT_END.lastIndex - 2;\n        }\n\n        currentToken = ['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n        pos = next;\n        break;\n\n      case BACKSLASH:\n        next = pos;\n        escape = true;\n\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1;\n          escape = !escape;\n        }\n\n        code = css.charCodeAt(next + 1);\n\n        if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {\n          next += 1;\n\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n              next += 1;\n            }\n\n            if (css.charCodeAt(next + 1) === SPACE) {\n              next += 1;\n            }\n          }\n        }\n\n        currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n        pos = next;\n        break;\n\n      default:\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n          next = css.indexOf('*/', pos + 2) + 1;\n\n          if (next === 0) {\n            if (ignore || ignoreUnclosed) {\n              next = css.length;\n            } else {\n              unclosed('comment');\n            }\n          }\n\n          content = css.slice(pos, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          currentToken = ['comment', content, line, pos - offset, nextLine, next - nextOffset];\n          offset = nextOffset;\n          line = nextLine;\n          pos = next;\n        } else {\n          RE_WORD_END.lastIndex = pos + 1;\n          RE_WORD_END.test(css);\n\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1;\n          } else {\n            next = RE_WORD_END.lastIndex - 2;\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n          buffer.push(currentToken);\n          pos = next;\n        }\n\n        break;\n    }\n\n    pos++;\n    return currentToken;\n  }\n\n  function back(token) {\n    returned.push(token);\n  }\n\n  return {\n    back: back,\n    nextToken: nextToken,\n    endOfFile: endOfFile,\n    position: position\n  };\n}\n\nmodule.exports = exports.default;","map":{"version":3,"mappings":"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","names":["SINGLE_QUOTE","charCodeAt","DOUBLE_QUOTE","BACKSLASH","SLASH","NEWLINE","SPACE","FEED","TAB","CR","OPEN_SQUARE","CLOSE_SQUARE","OPEN_PARENTHESES","CLOSE_PARENTHESES","OPEN_CURLY","CLOSE_CURLY","SEMICOLON","ASTERISK","COLON","AT","RE_AT_END","RE_WORD_END","RE_BAD_BRACKET","RE_HEX_ESCAPE","tokenizer","input","options","css","valueOf","ignore","ignoreErrors","code","next","quote","lines","last","content","escape","nextLine","nextOffset","escaped","escapePos","prev","n","currentToken","length","offset","line","pos","buffer","returned","position","unclosed","what","error","endOfFile","nextToken","opts","pop","ignoreUnclosed","slice","controlChar","String","fromCharCode","indexOf","test","split","lastIndex","charAt","push","back","token"],"sources":["C:\\Users\\Rohith\\mern\\frontend\\node_modules\\resolve-url-loader\\node_modules\\postcss\\lib\\tokenize.es6"],"sourcesContent":["const SINGLE_QUOTE = '\\''.charCodeAt(0)\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0)\nconst BACKSLASH = '\\\\'.charCodeAt(0)\nconst SLASH = '/'.charCodeAt(0)\nconst NEWLINE = '\\n'.charCodeAt(0)\nconst SPACE = ' '.charCodeAt(0)\nconst FEED = '\\f'.charCodeAt(0)\nconst TAB = '\\t'.charCodeAt(0)\nconst CR = '\\r'.charCodeAt(0)\nconst OPEN_SQUARE = '['.charCodeAt(0)\nconst CLOSE_SQUARE = ']'.charCodeAt(0)\nconst OPEN_PARENTHESES = '('.charCodeAt(0)\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0)\nconst OPEN_CURLY = '{'.charCodeAt(0)\nconst CLOSE_CURLY = '}'.charCodeAt(0)\nconst SEMICOLON = ';'.charCodeAt(0)\nconst ASTERISK = '*'.charCodeAt(0)\nconst COLON = ':'.charCodeAt(0)\nconst AT = '@'.charCodeAt(0)\n\nconst RE_AT_END = /[ \\n\\t\\r\\f{}()'\"\\\\;/[\\]#]/g\nconst RE_WORD_END = /[ \\n\\t\\r\\f(){}:;@!'\"\\\\\\][#]|\\/(?=\\*)/g\nconst RE_BAD_BRACKET = /.[\\\\/(\"'\\n]/\nconst RE_HEX_ESCAPE = /[a-f0-9]/i\n\nexport default function tokenizer (input, options = {}) {\n  let css = input.css.valueOf()\n  let ignore = options.ignoreErrors\n\n  let code, next, quote, lines, last, content, escape\n  let nextLine, nextOffset, escaped, escapePos, prev, n, currentToken\n\n  let length = css.length\n  let offset = -1\n  let line = 1\n  let pos = 0\n  let buffer = []\n  let returned = []\n\n  function position () {\n    return pos\n  }\n\n  function unclosed (what) {\n    throw input.error('Unclosed ' + what, line, pos - offset)\n  }\n\n  function endOfFile () {\n    return returned.length === 0 && pos >= length\n  }\n\n  function nextToken (opts) {\n    if (returned.length) return returned.pop()\n    if (pos >= length) return\n\n    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false\n\n    code = css.charCodeAt(pos)\n    if (\n      code === NEWLINE || code === FEED ||\n      (code === CR && css.charCodeAt(pos + 1) !== NEWLINE)\n    ) {\n      offset = pos\n      line += 1\n    }\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED:\n        next = pos\n        do {\n          next += 1\n          code = css.charCodeAt(next)\n          if (code === NEWLINE) {\n            offset = next\n            line += 1\n          }\n        } while (\n          code === SPACE ||\n          code === NEWLINE ||\n          code === TAB ||\n          code === CR ||\n          code === FEED\n        )\n\n        currentToken = ['space', css.slice(pos, next)]\n        pos = next - 1\n        break\n\n      case OPEN_SQUARE:\n      case CLOSE_SQUARE:\n      case OPEN_CURLY:\n      case CLOSE_CURLY:\n      case COLON:\n      case SEMICOLON:\n      case CLOSE_PARENTHESES:\n        let controlChar = String.fromCharCode(code)\n        currentToken = [controlChar, controlChar, line, pos - offset]\n        break\n\n      case OPEN_PARENTHESES:\n        prev = buffer.length ? buffer.pop()[1] : ''\n        n = css.charCodeAt(pos + 1)\n        if (\n          prev === 'url' &&\n          n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE &&\n          n !== SPACE && n !== NEWLINE && n !== TAB &&\n          n !== FEED && n !== CR\n        ) {\n          next = pos\n          do {\n            escaped = false\n            next = css.indexOf(')', next + 1)\n            if (next === -1) {\n              if (ignore || ignoreUnclosed) {\n                next = pos\n                break\n              } else {\n                unclosed('bracket')\n              }\n            }\n            escapePos = next\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1\n              escaped = !escaped\n            }\n          } while (escaped)\n\n          currentToken = ['brackets', css.slice(pos, next + 1),\n            line, pos - offset,\n            line, next - offset\n          ]\n\n          pos = next\n        } else {\n          next = css.indexOf(')', pos + 1)\n          content = css.slice(pos, next + 1)\n\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\n            currentToken = ['(', '(', line, pos - offset]\n          } else {\n            currentToken = ['brackets', content,\n              line, pos - offset,\n              line, next - offset\n            ]\n            pos = next\n          }\n        }\n\n        break\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE:\n        quote = code === SINGLE_QUOTE ? '\\'' : '\"'\n        next = pos\n        do {\n          escaped = false\n          next = css.indexOf(quote, next + 1)\n          if (next === -1) {\n            if (ignore || ignoreUnclosed) {\n              next = pos + 1\n              break\n            } else {\n              unclosed('string')\n            }\n          }\n          escapePos = next\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n            escapePos -= 1\n            escaped = !escaped\n          }\n        } while (escaped)\n\n        content = css.slice(pos, next + 1)\n        lines = content.split('\\n')\n        last = lines.length - 1\n\n        if (last > 0) {\n          nextLine = line + last\n          nextOffset = next - lines[last].length\n        } else {\n          nextLine = line\n          nextOffset = offset\n        }\n\n        currentToken = ['string', css.slice(pos, next + 1),\n          line, pos - offset,\n          nextLine, next - nextOffset\n        ]\n\n        offset = nextOffset\n        line = nextLine\n        pos = next\n        break\n\n      case AT:\n        RE_AT_END.lastIndex = pos + 1\n        RE_AT_END.test(css)\n        if (RE_AT_END.lastIndex === 0) {\n          next = css.length - 1\n        } else {\n          next = RE_AT_END.lastIndex - 2\n        }\n\n        currentToken = ['at-word', css.slice(pos, next + 1),\n          line, pos - offset,\n          line, next - offset\n        ]\n\n        pos = next\n        break\n\n      case BACKSLASH:\n        next = pos\n        escape = true\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\n          next += 1\n          escape = !escape\n        }\n        code = css.charCodeAt(next + 1)\n        if (\n          escape &&\n          code !== SLASH &&\n          code !== SPACE &&\n          code !== NEWLINE &&\n          code !== TAB &&\n          code !== CR &&\n          code !== FEED\n        ) {\n          next += 1\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n              next += 1\n            }\n            if (css.charCodeAt(next + 1) === SPACE) {\n              next += 1\n            }\n          }\n        }\n\n        currentToken = ['word', css.slice(pos, next + 1),\n          line, pos - offset,\n          line, next - offset\n        ]\n\n        pos = next\n        break\n\n      default:\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n          next = css.indexOf('*/', pos + 2) + 1\n          if (next === 0) {\n            if (ignore || ignoreUnclosed) {\n              next = css.length\n            } else {\n              unclosed('comment')\n            }\n          }\n\n          content = css.slice(pos, next + 1)\n          lines = content.split('\\n')\n          last = lines.length - 1\n\n          if (last > 0) {\n            nextLine = line + last\n            nextOffset = next - lines[last].length\n          } else {\n            nextLine = line\n            nextOffset = offset\n          }\n\n          currentToken = ['comment', content,\n            line, pos - offset,\n            nextLine, next - nextOffset\n          ]\n\n          offset = nextOffset\n          line = nextLine\n          pos = next\n        } else {\n          RE_WORD_END.lastIndex = pos + 1\n          RE_WORD_END.test(css)\n          if (RE_WORD_END.lastIndex === 0) {\n            next = css.length - 1\n          } else {\n            next = RE_WORD_END.lastIndex - 2\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1),\n            line, pos - offset,\n            line, next - offset\n          ]\n\n          buffer.push(currentToken)\n\n          pos = next\n        }\n\n        break\n    }\n\n    pos++\n    return currentToken\n  }\n\n  function back (token) {\n    returned.push(token)\n  }\n\n  return {\n    back,\n    nextToken,\n    endOfFile,\n    position\n  }\n}\n"]},"metadata":{},"sourceType":"script"}