{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"@typescript-eslint/utils\");\n\nconst tsutils = __importStar(require(\"tsutils\"));\n\nconst util = __importStar(require(\"../util\"));\n\nconst util_1 = require(\"../util\");\n\nexports.default = util.createRule({\n  name: 'no-unsafe-return',\n  meta: {\n    type: 'problem',\n    docs: {\n      description: 'Disallow returning a value with type `any` from a function',\n      recommended: 'error',\n      requiresTypeChecking: true\n    },\n    messages: {\n      unsafeReturn: 'Unsafe return of an `{{type}}` typed value.',\n      unsafeReturnThis: ['Unsafe return of an `{{type}}` typed value. `this` is typed as `any`.', 'You can try to fix this by turning on the `noImplicitThis` compiler option, or adding a `this` parameter to the function.'].join('\\n'),\n      unsafeReturnAssignment: 'Unsafe return of type `{{sender}}` from function with return type `{{receiver}}`.'\n    },\n    schema: []\n  },\n  defaultOptions: [],\n\n  create(context) {\n    const {\n      program,\n      esTreeNodeToTSNodeMap\n    } = util.getParserServices(context);\n    const checker = program.getTypeChecker();\n    const compilerOptions = program.getCompilerOptions();\n    const isNoImplicitThis = tsutils.isStrictCompilerOptionEnabled(compilerOptions, 'noImplicitThis');\n\n    function getParentFunctionNode(node) {\n      let current = node.parent;\n\n      while (current) {\n        if (current.type === utils_1.AST_NODE_TYPES.ArrowFunctionExpression || current.type === utils_1.AST_NODE_TYPES.FunctionDeclaration || current.type === utils_1.AST_NODE_TYPES.FunctionExpression) {\n          return current;\n        }\n\n        current = current.parent;\n      } // this shouldn't happen in correct code, but someone may attempt to parse bad code\n      // the parser won't error, so we shouldn't throw here\n\n      /* istanbul ignore next */\n\n\n      return null;\n    }\n\n    function checkReturn(returnNode) {\n      let reportingNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : returnNode;\n      const tsNode = esTreeNodeToTSNodeMap.get(returnNode);\n      const anyType = util.isAnyOrAnyArrayTypeDiscriminated(tsNode, checker);\n      const functionNode = getParentFunctionNode(returnNode);\n      /* istanbul ignore if */\n\n      if (!functionNode) {\n        return;\n      } // function has an explicit return type, so ensure it's a safe return\n\n\n      const returnNodeType = util.getConstrainedTypeAtLocation(checker, esTreeNodeToTSNodeMap.get(returnNode));\n      const functionTSNode = esTreeNodeToTSNodeMap.get(functionNode); // function expressions will not have their return type modified based on receiver typing\n      // so we have to use the contextual typing in these cases, i.e.\n      // const foo1: () => Set<string> = () => new Set<any>();\n      // the return type of the arrow function is Set<any> even though the variable is typed as Set<string>\n\n      let functionType = tsutils.isExpression(functionTSNode) ? util.getContextualType(checker, functionTSNode) : checker.getTypeAtLocation(functionTSNode);\n\n      if (!functionType) {\n        functionType = checker.getTypeAtLocation(functionTSNode);\n      } // If there is an explicit type annotation *and* that type matches the actual\n      // function return type, we shouldn't complain (it's intentional, even if unsafe)\n\n\n      if (functionTSNode.type) {\n        for (const signature of functionType.getCallSignatures()) {\n          if (returnNodeType === signature.getReturnType()) {\n            return;\n          }\n        }\n      }\n\n      if (anyType !== util.AnyType.Safe) {\n        // Allow cases when the declared return type of the function is either unknown or unknown[]\n        // and the function is returning any or any[].\n        for (const signature of functionType.getCallSignatures()) {\n          const functionReturnType = signature.getReturnType();\n\n          if (anyType === util.AnyType.Any && util.isTypeUnknownType(functionReturnType)) {\n            return;\n          }\n\n          if (anyType === util.AnyType.AnyArray && util.isTypeUnknownArrayType(functionReturnType, checker)) {\n            return;\n          }\n        }\n\n        let messageId = 'unsafeReturn';\n\n        if (!isNoImplicitThis) {\n          // `return this`\n          const thisExpression = (0, util_1.getThisExpression)(returnNode);\n\n          if (thisExpression && util.isTypeAnyType(util.getConstrainedTypeAtLocation(checker, esTreeNodeToTSNodeMap.get(thisExpression)))) {\n            messageId = 'unsafeReturnThis';\n          }\n        } // If the function return type was not unknown/unknown[], mark usage as unsafeReturn.\n\n\n        return context.report({\n          node: reportingNode,\n          messageId,\n          data: {\n            type: anyType === util.AnyType.Any ? 'any' : 'any[]'\n          }\n        });\n      }\n\n      for (const signature of functionType.getCallSignatures()) {\n        const functionReturnType = signature.getReturnType();\n        const result = util.isUnsafeAssignment(returnNodeType, functionReturnType, checker, returnNode);\n\n        if (!result) {\n          return;\n        }\n\n        const {\n          sender,\n          receiver\n        } = result;\n        return context.report({\n          node: reportingNode,\n          messageId: 'unsafeReturnAssignment',\n          data: {\n            sender: checker.typeToString(sender),\n            receiver: checker.typeToString(receiver)\n          }\n        });\n      }\n    }\n\n    return {\n      ReturnStatement(node) {\n        const argument = node.argument;\n\n        if (!argument) {\n          return;\n        }\n\n        checkReturn(argument, node);\n      },\n\n      'ArrowFunctionExpression > :not(BlockStatement).body': checkReturn\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["exports","util","createRule","name","meta","type","docs","description","recommended","requiresTypeChecking","messages","unsafeReturn","unsafeReturnThis","join","unsafeReturnAssignment","schema","defaultOptions","create","context","program","esTreeNodeToTSNodeMap","getParserServices","checker","getTypeChecker","compilerOptions","getCompilerOptions","isNoImplicitThis","tsutils","isStrictCompilerOptionEnabled","getParentFunctionNode","node","current","parent","utils_1","ArrowFunctionExpression","FunctionDeclaration","FunctionExpression","checkReturn","returnNode","reportingNode","tsNode","get","anyType","isAnyOrAnyArrayTypeDiscriminated","functionNode","returnNodeType","getConstrainedTypeAtLocation","functionTSNode","functionType","isExpression","getContextualType","getTypeAtLocation","signature","getCallSignatures","getReturnType","AnyType","Safe","functionReturnType","Any","isTypeUnknownType","AnyArray","isTypeUnknownArrayType","messageId","thisExpression","isTypeAnyType","report","data","result","isUnsafeAssignment","sender","receiver","typeToString","ReturnStatement","argument"],"sources":["../../src/rules/no-unsafe-return.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}