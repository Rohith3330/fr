{"ast":null,"code":"'use strict';\n\nconst Buffer = require('buffer').Buffer;\n\nconst types = require('./types');\n\nconst rcodes = require('./rcodes');\n\nconst opcodes = require('./opcodes');\n\nconst classes = require('./classes');\n\nconst optioncodes = require('./optioncodes');\n\nconst ip = require('@leichtgewicht/ip-codec');\n\nconst QUERY_FLAG = 0;\nconst RESPONSE_FLAG = 1 << 15;\nconst FLUSH_MASK = 1 << 15;\nconst NOT_FLUSH_MASK = ~FLUSH_MASK;\nconst QU_MASK = 1 << 15;\nconst NOT_QU_MASK = ~QU_MASK;\nconst name = exports.name = {};\n\nname.encode = function (str, buf, offset) {\n  if (!buf) buf = Buffer.alloc(name.encodingLength(str));\n  if (!offset) offset = 0;\n  const oldOffset = offset; // strip leading and trailing .\n\n  const n = str.replace(/^\\.|\\.$/gm, '');\n\n  if (n.length) {\n    const list = n.split('.');\n\n    for (let i = 0; i < list.length; i++) {\n      const len = buf.write(list[i], offset + 1);\n      buf[offset] = len;\n      offset += len + 1;\n    }\n  }\n\n  buf[offset++] = 0;\n  name.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nname.encode.bytes = 0;\n\nname.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const list = [];\n  let oldOffset = offset;\n  let totalLength = 0;\n  let consumedBytes = 0;\n  let jumped = false;\n\n  while (true) {\n    if (offset >= buf.length) {\n      throw new Error('Cannot decode name (buffer overflow)');\n    }\n\n    const len = buf[offset++];\n    consumedBytes += jumped ? 0 : 1;\n\n    if (len === 0) {\n      break;\n    } else if ((len & 0xc0) === 0) {\n      if (offset + len > buf.length) {\n        throw new Error('Cannot decode name (buffer overflow)');\n      }\n\n      totalLength += len + 1;\n\n      if (totalLength > 254) {\n        throw new Error('Cannot decode name (name too long)');\n      }\n\n      list.push(buf.toString('utf-8', offset, offset + len));\n      offset += len;\n      consumedBytes += jumped ? 0 : len;\n    } else if ((len & 0xc0) === 0xc0) {\n      if (offset + 1 > buf.length) {\n        throw new Error('Cannot decode name (buffer overflow)');\n      }\n\n      const jumpOffset = buf.readUInt16BE(offset - 1) - 0xc000;\n\n      if (jumpOffset >= oldOffset) {\n        // Allow only pointers to prior data. RFC 1035, section 4.1.4 states:\n        // \"[...] an entire domain name or a list of labels at the end of a domain name\n        // is replaced with a pointer to a prior occurance (sic) of the same name.\"\n        throw new Error('Cannot decode name (bad pointer)');\n      }\n\n      offset = jumpOffset;\n      oldOffset = jumpOffset;\n      consumedBytes += jumped ? 0 : 1;\n      jumped = true;\n    } else {\n      throw new Error('Cannot decode name (bad label)');\n    }\n  }\n\n  name.decode.bytes = consumedBytes;\n  return list.length === 0 ? '.' : list.join('.');\n};\n\nname.decode.bytes = 0;\n\nname.encodingLength = function (n) {\n  if (n === '.' || n === '..') return 1;\n  return Buffer.byteLength(n.replace(/^\\.|\\.$/gm, '')) + 2;\n};\n\nconst string = {};\n\nstring.encode = function (s, buf, offset) {\n  if (!buf) buf = Buffer.alloc(string.encodingLength(s));\n  if (!offset) offset = 0;\n  const len = buf.write(s, offset + 1);\n  buf[offset] = len;\n  string.encode.bytes = len + 1;\n  return buf;\n};\n\nstring.encode.bytes = 0;\n\nstring.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf[offset];\n  const s = buf.toString('utf-8', offset + 1, offset + 1 + len);\n  string.decode.bytes = len + 1;\n  return s;\n};\n\nstring.decode.bytes = 0;\n\nstring.encodingLength = function (s) {\n  return Buffer.byteLength(s) + 1;\n};\n\nconst header = {};\n\nheader.encode = function (h, buf, offset) {\n  if (!buf) buf = header.encodingLength(h);\n  if (!offset) offset = 0;\n  const flags = (h.flags || 0) & 32767;\n  const type = h.type === 'response' ? RESPONSE_FLAG : QUERY_FLAG;\n  buf.writeUInt16BE(h.id || 0, offset);\n  buf.writeUInt16BE(flags | type, offset + 2);\n  buf.writeUInt16BE(h.questions.length, offset + 4);\n  buf.writeUInt16BE(h.answers.length, offset + 6);\n  buf.writeUInt16BE(h.authorities.length, offset + 8);\n  buf.writeUInt16BE(h.additionals.length, offset + 10);\n  return buf;\n};\n\nheader.encode.bytes = 12;\n\nheader.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  if (buf.length < 12) throw new Error('Header must be 12 bytes');\n  const flags = buf.readUInt16BE(offset + 2);\n  return {\n    id: buf.readUInt16BE(offset),\n    type: flags & RESPONSE_FLAG ? 'response' : 'query',\n    flags: flags & 32767,\n    flag_qr: (flags >> 15 & 0x1) === 1,\n    opcode: opcodes.toString(flags >> 11 & 0xf),\n    flag_aa: (flags >> 10 & 0x1) === 1,\n    flag_tc: (flags >> 9 & 0x1) === 1,\n    flag_rd: (flags >> 8 & 0x1) === 1,\n    flag_ra: (flags >> 7 & 0x1) === 1,\n    flag_z: (flags >> 6 & 0x1) === 1,\n    flag_ad: (flags >> 5 & 0x1) === 1,\n    flag_cd: (flags >> 4 & 0x1) === 1,\n    rcode: rcodes.toString(flags & 0xf),\n    questions: new Array(buf.readUInt16BE(offset + 4)),\n    answers: new Array(buf.readUInt16BE(offset + 6)),\n    authorities: new Array(buf.readUInt16BE(offset + 8)),\n    additionals: new Array(buf.readUInt16BE(offset + 10))\n  };\n};\n\nheader.decode.bytes = 12;\n\nheader.encodingLength = function () {\n  return 12;\n};\n\nconst runknown = exports.unknown = {};\n\nrunknown.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(runknown.encodingLength(data));\n  if (!offset) offset = 0;\n  buf.writeUInt16BE(data.length, offset);\n  data.copy(buf, offset + 2);\n  runknown.encode.bytes = data.length + 2;\n  return buf;\n};\n\nrunknown.encode.bytes = 0;\n\nrunknown.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf.readUInt16BE(offset);\n  const data = buf.slice(offset + 2, offset + 2 + len);\n  runknown.decode.bytes = len + 2;\n  return data;\n};\n\nrunknown.decode.bytes = 0;\n\nrunknown.encodingLength = function (data) {\n  return data.length + 2;\n};\n\nconst rns = exports.ns = {};\n\nrns.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rns.encodingLength(data));\n  if (!offset) offset = 0;\n  name.encode(data, buf, offset + 2);\n  buf.writeUInt16BE(name.encode.bytes, offset);\n  rns.encode.bytes = name.encode.bytes + 2;\n  return buf;\n};\n\nrns.encode.bytes = 0;\n\nrns.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf.readUInt16BE(offset);\n  const dd = name.decode(buf, offset + 2);\n  rns.decode.bytes = len + 2;\n  return dd;\n};\n\nrns.decode.bytes = 0;\n\nrns.encodingLength = function (data) {\n  return name.encodingLength(data) + 2;\n};\n\nconst rsoa = exports.soa = {};\n\nrsoa.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsoa.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2;\n  name.encode(data.mname, buf, offset);\n  offset += name.encode.bytes;\n  name.encode(data.rname, buf, offset);\n  offset += name.encode.bytes;\n  buf.writeUInt32BE(data.serial || 0, offset);\n  offset += 4;\n  buf.writeUInt32BE(data.refresh || 0, offset);\n  offset += 4;\n  buf.writeUInt32BE(data.retry || 0, offset);\n  offset += 4;\n  buf.writeUInt32BE(data.expire || 0, offset);\n  offset += 4;\n  buf.writeUInt32BE(data.minimum || 0, offset);\n  offset += 4;\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rsoa.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nrsoa.encode.bytes = 0;\n\nrsoa.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const data = {};\n  offset += 2;\n  data.mname = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  data.rname = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  data.serial = buf.readUInt32BE(offset);\n  offset += 4;\n  data.refresh = buf.readUInt32BE(offset);\n  offset += 4;\n  data.retry = buf.readUInt32BE(offset);\n  offset += 4;\n  data.expire = buf.readUInt32BE(offset);\n  offset += 4;\n  data.minimum = buf.readUInt32BE(offset);\n  offset += 4;\n  rsoa.decode.bytes = offset - oldOffset;\n  return data;\n};\n\nrsoa.decode.bytes = 0;\n\nrsoa.encodingLength = function (data) {\n  return 22 + name.encodingLength(data.mname) + name.encodingLength(data.rname);\n};\n\nconst rtxt = exports.txt = {};\n\nrtxt.encode = function (data, buf, offset) {\n  if (!Array.isArray(data)) data = [data];\n\n  for (let i = 0; i < data.length; i++) {\n    if (typeof data[i] === 'string') {\n      data[i] = Buffer.from(data[i]);\n    }\n\n    if (!Buffer.isBuffer(data[i])) {\n      throw new Error('Must be a Buffer');\n    }\n  }\n\n  if (!buf) buf = Buffer.alloc(rtxt.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2;\n  data.forEach(function (d) {\n    buf[offset++] = d.length;\n    d.copy(buf, offset, 0, d.length);\n    offset += d.length;\n  });\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rtxt.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nrtxt.encode.bytes = 0;\n\nrtxt.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  let remaining = buf.readUInt16BE(offset);\n  offset += 2;\n  let data = [];\n\n  while (remaining > 0) {\n    const len = buf[offset++];\n    --remaining;\n\n    if (remaining < len) {\n      throw new Error('Buffer overflow');\n    }\n\n    data.push(buf.slice(offset, offset + len));\n    offset += len;\n    remaining -= len;\n  }\n\n  rtxt.decode.bytes = offset - oldOffset;\n  return data;\n};\n\nrtxt.decode.bytes = 0;\n\nrtxt.encodingLength = function (data) {\n  if (!Array.isArray(data)) data = [data];\n  let length = 2;\n  data.forEach(function (buf) {\n    if (typeof buf === 'string') {\n      length += Buffer.byteLength(buf) + 1;\n    } else {\n      length += buf.length + 1;\n    }\n  });\n  return length;\n};\n\nconst rnull = exports.null = {};\n\nrnull.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnull.encodingLength(data));\n  if (!offset) offset = 0;\n  if (typeof data === 'string') data = Buffer.from(data);\n  if (!data) data = Buffer.alloc(0);\n  const oldOffset = offset;\n  offset += 2;\n  const len = data.length;\n  data.copy(buf, offset, 0, len);\n  offset += len;\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rnull.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nrnull.encode.bytes = 0;\n\nrnull.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const len = buf.readUInt16BE(offset);\n  offset += 2;\n  const data = buf.slice(offset, offset + len);\n  offset += len;\n  rnull.decode.bytes = offset - oldOffset;\n  return data;\n};\n\nrnull.decode.bytes = 0;\n\nrnull.encodingLength = function (data) {\n  if (!data) return 2;\n  return (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data)) + 2;\n};\n\nconst rhinfo = exports.hinfo = {};\n\nrhinfo.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rhinfo.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2;\n  string.encode(data.cpu, buf, offset);\n  offset += string.encode.bytes;\n  string.encode(data.os, buf, offset);\n  offset += string.encode.bytes;\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rhinfo.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nrhinfo.encode.bytes = 0;\n\nrhinfo.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const data = {};\n  offset += 2;\n  data.cpu = string.decode(buf, offset);\n  offset += string.decode.bytes;\n  data.os = string.decode(buf, offset);\n  offset += string.decode.bytes;\n  rhinfo.decode.bytes = offset - oldOffset;\n  return data;\n};\n\nrhinfo.decode.bytes = 0;\n\nrhinfo.encodingLength = function (data) {\n  return string.encodingLength(data.cpu) + string.encodingLength(data.os) + 2;\n};\n\nconst rptr = exports.ptr = {};\nconst rcname = exports.cname = rptr;\nconst rdname = exports.dname = rptr;\n\nrptr.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rptr.encodingLength(data));\n  if (!offset) offset = 0;\n  name.encode(data, buf, offset + 2);\n  buf.writeUInt16BE(name.encode.bytes, offset);\n  rptr.encode.bytes = name.encode.bytes + 2;\n  return buf;\n};\n\nrptr.encode.bytes = 0;\n\nrptr.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const data = name.decode(buf, offset + 2);\n  rptr.decode.bytes = name.decode.bytes + 2;\n  return data;\n};\n\nrptr.decode.bytes = 0;\n\nrptr.encodingLength = function (data) {\n  return name.encodingLength(data) + 2;\n};\n\nconst rsrv = exports.srv = {};\n\nrsrv.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsrv.encodingLength(data));\n  if (!offset) offset = 0;\n  buf.writeUInt16BE(data.priority || 0, offset + 2);\n  buf.writeUInt16BE(data.weight || 0, offset + 4);\n  buf.writeUInt16BE(data.port || 0, offset + 6);\n  name.encode(data.target, buf, offset + 8);\n  const len = name.encode.bytes + 6;\n  buf.writeUInt16BE(len, offset);\n  rsrv.encode.bytes = len + 2;\n  return buf;\n};\n\nrsrv.encode.bytes = 0;\n\nrsrv.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf.readUInt16BE(offset);\n  const data = {};\n  data.priority = buf.readUInt16BE(offset + 2);\n  data.weight = buf.readUInt16BE(offset + 4);\n  data.port = buf.readUInt16BE(offset + 6);\n  data.target = name.decode(buf, offset + 8);\n  rsrv.decode.bytes = len + 2;\n  return data;\n};\n\nrsrv.decode.bytes = 0;\n\nrsrv.encodingLength = function (data) {\n  return 8 + name.encodingLength(data.target);\n};\n\nconst rcaa = exports.caa = {};\nrcaa.ISSUER_CRITICAL = 1 << 7;\n\nrcaa.encode = function (data, buf, offset) {\n  const len = rcaa.encodingLength(data);\n  if (!buf) buf = Buffer.alloc(rcaa.encodingLength(data));\n  if (!offset) offset = 0;\n\n  if (data.issuerCritical) {\n    data.flags = rcaa.ISSUER_CRITICAL;\n  }\n\n  buf.writeUInt16BE(len - 2, offset);\n  offset += 2;\n  buf.writeUInt8(data.flags || 0, offset);\n  offset += 1;\n  string.encode(data.tag, buf, offset);\n  offset += string.encode.bytes;\n  buf.write(data.value, offset);\n  offset += Buffer.byteLength(data.value);\n  rcaa.encode.bytes = len;\n  return buf;\n};\n\nrcaa.encode.bytes = 0;\n\nrcaa.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const len = buf.readUInt16BE(offset);\n  offset += 2;\n  const oldOffset = offset;\n  const data = {};\n  data.flags = buf.readUInt8(offset);\n  offset += 1;\n  data.tag = string.decode(buf, offset);\n  offset += string.decode.bytes;\n  data.value = buf.toString('utf-8', offset, oldOffset + len);\n  data.issuerCritical = !!(data.flags & rcaa.ISSUER_CRITICAL);\n  rcaa.decode.bytes = len + 2;\n  return data;\n};\n\nrcaa.decode.bytes = 0;\n\nrcaa.encodingLength = function (data) {\n  return string.encodingLength(data.tag) + string.encodingLength(data.value) + 2;\n};\n\nconst rmx = exports.mx = {};\n\nrmx.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rmx.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2;\n  buf.writeUInt16BE(data.preference || 0, offset);\n  offset += 2;\n  name.encode(data.exchange, buf, offset);\n  offset += name.encode.bytes;\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset);\n  rmx.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nrmx.encode.bytes = 0;\n\nrmx.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const data = {};\n  offset += 2;\n  data.preference = buf.readUInt16BE(offset);\n  offset += 2;\n  data.exchange = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  rmx.decode.bytes = offset - oldOffset;\n  return data;\n};\n\nrmx.encodingLength = function (data) {\n  return 4 + name.encodingLength(data.exchange);\n};\n\nconst ra = exports.a = {};\n\nra.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.alloc(ra.encodingLength(host));\n  if (!offset) offset = 0;\n  buf.writeUInt16BE(4, offset);\n  offset += 2;\n  ip.v4.encode(host, buf, offset);\n  ra.encode.bytes = 6;\n  return buf;\n};\n\nra.encode.bytes = 0;\n\nra.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  offset += 2;\n  const host = ip.v4.decode(buf, offset);\n  ra.decode.bytes = 6;\n  return host;\n};\n\nra.decode.bytes = 0;\n\nra.encodingLength = function () {\n  return 6;\n};\n\nconst raaaa = exports.aaaa = {};\n\nraaaa.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.alloc(raaaa.encodingLength(host));\n  if (!offset) offset = 0;\n  buf.writeUInt16BE(16, offset);\n  offset += 2;\n  ip.v6.encode(host, buf, offset);\n  raaaa.encode.bytes = 18;\n  return buf;\n};\n\nraaaa.encode.bytes = 0;\n\nraaaa.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  offset += 2;\n  const host = ip.v6.decode(buf, offset);\n  raaaa.decode.bytes = 18;\n  return host;\n};\n\nraaaa.decode.bytes = 0;\n\nraaaa.encodingLength = function () {\n  return 18;\n};\n\nconst roption = exports.option = {};\n\nroption.encode = function (option, buf, offset) {\n  if (!buf) buf = Buffer.alloc(roption.encodingLength(option));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const code = optioncodes.toCode(option.code);\n  buf.writeUInt16BE(code, offset);\n  offset += 2;\n\n  if (option.data) {\n    buf.writeUInt16BE(option.data.length, offset);\n    offset += 2;\n    option.data.copy(buf, offset);\n    offset += option.data.length;\n  } else {\n    switch (code) {\n      // case 3: NSID.  No encode makes sense.\n      // case 5,6,7: Not implementable\n      case 8:\n        // ECS\n        // note: do IP math before calling\n        const spl = option.sourcePrefixLength || 0;\n        const fam = option.family || ip.familyOf(option.ip);\n        const ipBuf = ip.encode(option.ip, Buffer.alloc);\n        const ipLen = Math.ceil(spl / 8);\n        buf.writeUInt16BE(ipLen + 4, offset);\n        offset += 2;\n        buf.writeUInt16BE(fam, offset);\n        offset += 2;\n        buf.writeUInt8(spl, offset++);\n        buf.writeUInt8(option.scopePrefixLength || 0, offset++);\n        ipBuf.copy(buf, offset, 0, ipLen);\n        offset += ipLen;\n        break;\n      // case 9: EXPIRE (experimental)\n      // case 10: COOKIE.  No encode makes sense.\n\n      case 11:\n        // KEEP-ALIVE\n        if (option.timeout) {\n          buf.writeUInt16BE(2, offset);\n          offset += 2;\n          buf.writeUInt16BE(option.timeout, offset);\n          offset += 2;\n        } else {\n          buf.writeUInt16BE(0, offset);\n          offset += 2;\n        }\n\n        break;\n\n      case 12:\n        // PADDING\n        const len = option.length || 0;\n        buf.writeUInt16BE(len, offset);\n        offset += 2;\n        buf.fill(0, offset, offset + len);\n        offset += len;\n        break;\n      // case 13:  CHAIN.  Experimental.\n\n      case 14:\n        // KEY-TAG\n        const tagsLen = option.tags.length * 2;\n        buf.writeUInt16BE(tagsLen, offset);\n        offset += 2;\n\n        for (const tag of option.tags) {\n          buf.writeUInt16BE(tag, offset);\n          offset += 2;\n        }\n\n        break;\n\n      default:\n        throw new Error(`Unknown roption code: ${option.code}`);\n    }\n  }\n\n  roption.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nroption.encode.bytes = 0;\n\nroption.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const option = {};\n  option.code = buf.readUInt16BE(offset);\n  option.type = optioncodes.toString(option.code);\n  offset += 2;\n  const len = buf.readUInt16BE(offset);\n  offset += 2;\n  option.data = buf.slice(offset, offset + len);\n\n  switch (option.code) {\n    // case 3: NSID.  No decode makes sense.\n    case 8:\n      // ECS\n      option.family = buf.readUInt16BE(offset);\n      offset += 2;\n      option.sourcePrefixLength = buf.readUInt8(offset++);\n      option.scopePrefixLength = buf.readUInt8(offset++);\n      const padded = Buffer.alloc(option.family === 1 ? 4 : 16);\n      buf.copy(padded, 0, offset, offset + len - 4);\n      option.ip = ip.decode(padded);\n      break;\n    // case 12: Padding.  No decode makes sense.\n\n    case 11:\n      // KEEP-ALIVE\n      if (len > 0) {\n        option.timeout = buf.readUInt16BE(offset);\n        offset += 2;\n      }\n\n      break;\n\n    case 14:\n      option.tags = [];\n\n      for (let i = 0; i < len; i += 2) {\n        option.tags.push(buf.readUInt16BE(offset));\n        offset += 2;\n      }\n\n    // don't worry about default.  caller will use data if desired\n  }\n\n  roption.decode.bytes = len + 4;\n  return option;\n};\n\nroption.decode.bytes = 0;\n\nroption.encodingLength = function (option) {\n  if (option.data) {\n    return option.data.length + 4;\n  }\n\n  const code = optioncodes.toCode(option.code);\n\n  switch (code) {\n    case 8:\n      // ECS\n      const spl = option.sourcePrefixLength || 0;\n      return Math.ceil(spl / 8) + 8;\n\n    case 11:\n      // KEEP-ALIVE\n      return typeof option.timeout === 'number' ? 6 : 4;\n\n    case 12:\n      // PADDING\n      return option.length + 4;\n\n    case 14:\n      // KEY-TAG\n      return 4 + option.tags.length * 2;\n  }\n\n  throw new Error(`Unknown roption code: ${option.code}`);\n};\n\nconst ropt = exports.opt = {};\n\nropt.encode = function (options, buf, offset) {\n  if (!buf) buf = Buffer.alloc(ropt.encodingLength(options));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const rdlen = encodingLengthList(options, roption);\n  buf.writeUInt16BE(rdlen, offset);\n  offset = encodeList(options, roption, buf, offset + 2);\n  ropt.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nropt.encode.bytes = 0;\n\nropt.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const options = [];\n  let rdlen = buf.readUInt16BE(offset);\n  offset += 2;\n  let o = 0;\n\n  while (rdlen > 0) {\n    options[o++] = roption.decode(buf, offset);\n    offset += roption.decode.bytes;\n    rdlen -= roption.decode.bytes;\n  }\n\n  ropt.decode.bytes = offset - oldOffset;\n  return options;\n};\n\nropt.decode.bytes = 0;\n\nropt.encodingLength = function (options) {\n  return 2 + encodingLengthList(options || [], roption);\n};\n\nconst rdnskey = exports.dnskey = {};\nrdnskey.PROTOCOL_DNSSEC = 3;\nrdnskey.ZONE_KEY = 0x80;\nrdnskey.SECURE_ENTRYPOINT = 0x8000;\n\nrdnskey.encode = function (key, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rdnskey.encodingLength(key));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const keydata = key.key;\n\n  if (!Buffer.isBuffer(keydata)) {\n    throw new Error('Key must be a Buffer');\n  }\n\n  offset += 2; // Leave space for length\n\n  buf.writeUInt16BE(key.flags, offset);\n  offset += 2;\n  buf.writeUInt8(rdnskey.PROTOCOL_DNSSEC, offset);\n  offset += 1;\n  buf.writeUInt8(key.algorithm, offset);\n  offset += 1;\n  keydata.copy(buf, offset, 0, keydata.length);\n  offset += keydata.length;\n  rdnskey.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rdnskey.encode.bytes - 2, oldOffset);\n  return buf;\n};\n\nrdnskey.encode.bytes = 0;\n\nrdnskey.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var key = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  key.flags = buf.readUInt16BE(offset);\n  offset += 2;\n\n  if (buf.readUInt8(offset) !== rdnskey.PROTOCOL_DNSSEC) {\n    throw new Error('Protocol must be 3');\n  }\n\n  offset += 1;\n  key.algorithm = buf.readUInt8(offset);\n  offset += 1;\n  key.key = buf.slice(offset, oldOffset + length + 2);\n  offset += key.key.length;\n  rdnskey.decode.bytes = offset - oldOffset;\n  return key;\n};\n\nrdnskey.decode.bytes = 0;\n\nrdnskey.encodingLength = function (key) {\n  return 6 + Buffer.byteLength(key.key);\n};\n\nconst rrrsig = exports.rrsig = {};\n\nrrrsig.encode = function (sig, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rrrsig.encodingLength(sig));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const signature = sig.signature;\n\n  if (!Buffer.isBuffer(signature)) {\n    throw new Error('Signature must be a Buffer');\n  }\n\n  offset += 2; // Leave space for length\n\n  buf.writeUInt16BE(types.toType(sig.typeCovered), offset);\n  offset += 2;\n  buf.writeUInt8(sig.algorithm, offset);\n  offset += 1;\n  buf.writeUInt8(sig.labels, offset);\n  offset += 1;\n  buf.writeUInt32BE(sig.originalTTL, offset);\n  offset += 4;\n  buf.writeUInt32BE(sig.expiration, offset);\n  offset += 4;\n  buf.writeUInt32BE(sig.inception, offset);\n  offset += 4;\n  buf.writeUInt16BE(sig.keyTag, offset);\n  offset += 2;\n  name.encode(sig.signersName, buf, offset);\n  offset += name.encode.bytes;\n  signature.copy(buf, offset, 0, signature.length);\n  offset += signature.length;\n  rrrsig.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rrrsig.encode.bytes - 2, oldOffset);\n  return buf;\n};\n\nrrrsig.encode.bytes = 0;\n\nrrrsig.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var sig = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  sig.typeCovered = types.toString(buf.readUInt16BE(offset));\n  offset += 2;\n  sig.algorithm = buf.readUInt8(offset);\n  offset += 1;\n  sig.labels = buf.readUInt8(offset);\n  offset += 1;\n  sig.originalTTL = buf.readUInt32BE(offset);\n  offset += 4;\n  sig.expiration = buf.readUInt32BE(offset);\n  offset += 4;\n  sig.inception = buf.readUInt32BE(offset);\n  offset += 4;\n  sig.keyTag = buf.readUInt16BE(offset);\n  offset += 2;\n  sig.signersName = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  sig.signature = buf.slice(offset, oldOffset + length + 2);\n  offset += sig.signature.length;\n  rrrsig.decode.bytes = offset - oldOffset;\n  return sig;\n};\n\nrrrsig.decode.bytes = 0;\n\nrrrsig.encodingLength = function (sig) {\n  return 20 + name.encodingLength(sig.signersName) + Buffer.byteLength(sig.signature);\n};\n\nconst rrp = exports.rp = {};\n\nrrp.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rrp.encodingLength(data));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2; // Leave space for length\n\n  name.encode(data.mbox || '.', buf, offset);\n  offset += name.encode.bytes;\n  name.encode(data.txt || '.', buf, offset);\n  offset += name.encode.bytes;\n  rrp.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rrp.encode.bytes - 2, oldOffset);\n  return buf;\n};\n\nrrp.encode.bytes = 0;\n\nrrp.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const data = {};\n  offset += 2;\n  data.mbox = name.decode(buf, offset) || '.';\n  offset += name.decode.bytes;\n  data.txt = name.decode(buf, offset) || '.';\n  offset += name.decode.bytes;\n  rrp.decode.bytes = offset - oldOffset;\n  return data;\n};\n\nrrp.decode.bytes = 0;\n\nrrp.encodingLength = function (data) {\n  return 2 + name.encodingLength(data.mbox || '.') + name.encodingLength(data.txt || '.');\n};\n\nconst typebitmap = {};\n\ntypebitmap.encode = function (typelist, buf, offset) {\n  if (!buf) buf = Buffer.alloc(typebitmap.encodingLength(typelist));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var typesByWindow = [];\n\n  for (var i = 0; i < typelist.length; i++) {\n    var typeid = types.toType(typelist[i]);\n\n    if (typesByWindow[typeid >> 8] === undefined) {\n      typesByWindow[typeid >> 8] = [];\n    }\n\n    typesByWindow[typeid >> 8][typeid >> 3 & 0x1F] |= 1 << 7 - (typeid & 0x7);\n  }\n\n  for (i = 0; i < typesByWindow.length; i++) {\n    if (typesByWindow[i] !== undefined) {\n      var windowBuf = Buffer.from(typesByWindow[i]);\n      buf.writeUInt8(i, offset);\n      offset += 1;\n      buf.writeUInt8(windowBuf.length, offset);\n      offset += 1;\n      windowBuf.copy(buf, offset);\n      offset += windowBuf.length;\n    }\n  }\n\n  typebitmap.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\ntypebitmap.encode.bytes = 0;\n\ntypebitmap.decode = function (buf, offset, length) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var typelist = [];\n\n  while (offset - oldOffset < length) {\n    var window = buf.readUInt8(offset);\n    offset += 1;\n    var windowLength = buf.readUInt8(offset);\n    offset += 1;\n\n    for (var i = 0; i < windowLength; i++) {\n      var b = buf.readUInt8(offset + i);\n\n      for (var j = 0; j < 8; j++) {\n        if (b & 1 << 7 - j) {\n          var typeid = types.toString(window << 8 | i << 3 | j);\n          typelist.push(typeid);\n        }\n      }\n    }\n\n    offset += windowLength;\n  }\n\n  typebitmap.decode.bytes = offset - oldOffset;\n  return typelist;\n};\n\ntypebitmap.decode.bytes = 0;\n\ntypebitmap.encodingLength = function (typelist) {\n  var extents = [];\n\n  for (var i = 0; i < typelist.length; i++) {\n    var typeid = types.toType(typelist[i]);\n    extents[typeid >> 8] = Math.max(extents[typeid >> 8] || 0, typeid & 0xFF);\n  }\n\n  var len = 0;\n\n  for (i = 0; i < extents.length; i++) {\n    if (extents[i] !== undefined) {\n      len += 2 + Math.ceil((extents[i] + 1) / 8);\n    }\n  }\n\n  return len;\n};\n\nconst rnsec = exports.nsec = {};\n\nrnsec.encode = function (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnsec.encodingLength(record));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2; // Leave space for length\n\n  name.encode(record.nextDomain, buf, offset);\n  offset += name.encode.bytes;\n  typebitmap.encode(record.rrtypes, buf, offset);\n  offset += typebitmap.encode.bytes;\n  rnsec.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rnsec.encode.bytes - 2, oldOffset);\n  return buf;\n};\n\nrnsec.encode.bytes = 0;\n\nrnsec.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var record = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  record.nextDomain = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  record.rrtypes = typebitmap.decode(buf, offset, length - (offset - oldOffset));\n  offset += typebitmap.decode.bytes;\n  rnsec.decode.bytes = offset - oldOffset;\n  return record;\n};\n\nrnsec.decode.bytes = 0;\n\nrnsec.encodingLength = function (record) {\n  return 2 + name.encodingLength(record.nextDomain) + typebitmap.encodingLength(record.rrtypes);\n};\n\nconst rnsec3 = exports.nsec3 = {};\n\nrnsec3.encode = function (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnsec3.encodingLength(record));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const salt = record.salt;\n\n  if (!Buffer.isBuffer(salt)) {\n    throw new Error('salt must be a Buffer');\n  }\n\n  const nextDomain = record.nextDomain;\n\n  if (!Buffer.isBuffer(nextDomain)) {\n    throw new Error('nextDomain must be a Buffer');\n  }\n\n  offset += 2; // Leave space for length\n\n  buf.writeUInt8(record.algorithm, offset);\n  offset += 1;\n  buf.writeUInt8(record.flags, offset);\n  offset += 1;\n  buf.writeUInt16BE(record.iterations, offset);\n  offset += 2;\n  buf.writeUInt8(salt.length, offset);\n  offset += 1;\n  salt.copy(buf, offset, 0, salt.length);\n  offset += salt.length;\n  buf.writeUInt8(nextDomain.length, offset);\n  offset += 1;\n  nextDomain.copy(buf, offset, 0, nextDomain.length);\n  offset += nextDomain.length;\n  typebitmap.encode(record.rrtypes, buf, offset);\n  offset += typebitmap.encode.bytes;\n  rnsec3.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rnsec3.encode.bytes - 2, oldOffset);\n  return buf;\n};\n\nrnsec3.encode.bytes = 0;\n\nrnsec3.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var record = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  record.algorithm = buf.readUInt8(offset);\n  offset += 1;\n  record.flags = buf.readUInt8(offset);\n  offset += 1;\n  record.iterations = buf.readUInt16BE(offset);\n  offset += 2;\n  const saltLength = buf.readUInt8(offset);\n  offset += 1;\n  record.salt = buf.slice(offset, offset + saltLength);\n  offset += saltLength;\n  const hashLength = buf.readUInt8(offset);\n  offset += 1;\n  record.nextDomain = buf.slice(offset, offset + hashLength);\n  offset += hashLength;\n  record.rrtypes = typebitmap.decode(buf, offset, length - (offset - oldOffset));\n  offset += typebitmap.decode.bytes;\n  rnsec3.decode.bytes = offset - oldOffset;\n  return record;\n};\n\nrnsec3.decode.bytes = 0;\n\nrnsec3.encodingLength = function (record) {\n  return 8 + record.salt.length + record.nextDomain.length + typebitmap.encodingLength(record.rrtypes);\n};\n\nconst rds = exports.ds = {};\n\nrds.encode = function (digest, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rds.encodingLength(digest));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const digestdata = digest.digest;\n\n  if (!Buffer.isBuffer(digestdata)) {\n    throw new Error('Digest must be a Buffer');\n  }\n\n  offset += 2; // Leave space for length\n\n  buf.writeUInt16BE(digest.keyTag, offset);\n  offset += 2;\n  buf.writeUInt8(digest.algorithm, offset);\n  offset += 1;\n  buf.writeUInt8(digest.digestType, offset);\n  offset += 1;\n  digestdata.copy(buf, offset, 0, digestdata.length);\n  offset += digestdata.length;\n  rds.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rds.encode.bytes - 2, oldOffset);\n  return buf;\n};\n\nrds.encode.bytes = 0;\n\nrds.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  var digest = {};\n  var length = buf.readUInt16BE(offset);\n  offset += 2;\n  digest.keyTag = buf.readUInt16BE(offset);\n  offset += 2;\n  digest.algorithm = buf.readUInt8(offset);\n  offset += 1;\n  digest.digestType = buf.readUInt8(offset);\n  offset += 1;\n  digest.digest = buf.slice(offset, oldOffset + length + 2);\n  offset += digest.digest.length;\n  rds.decode.bytes = offset - oldOffset;\n  return digest;\n};\n\nrds.decode.bytes = 0;\n\nrds.encodingLength = function (digest) {\n  return 6 + Buffer.byteLength(digest.digest);\n};\n\nconst rsshfp = exports.sshfp = {};\n\nrsshfp.getFingerprintLengthForHashType = function getFingerprintLengthForHashType(hashType) {\n  switch (hashType) {\n    case 1:\n      return 20;\n\n    case 2:\n      return 32;\n  }\n};\n\nrsshfp.encode = function encode(record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsshfp.encodingLength(record));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  offset += 2; // The function call starts with the offset pointer at the RDLENGTH field, not the RDATA one\n\n  buf[offset] = record.algorithm;\n  offset += 1;\n  buf[offset] = record.hash;\n  offset += 1;\n  const fingerprintBuf = Buffer.from(record.fingerprint.toUpperCase(), 'hex');\n\n  if (fingerprintBuf.length !== rsshfp.getFingerprintLengthForHashType(record.hash)) {\n    throw new Error('Invalid fingerprint length');\n  }\n\n  fingerprintBuf.copy(buf, offset);\n  offset += fingerprintBuf.byteLength;\n  rsshfp.encode.bytes = offset - oldOffset;\n  buf.writeUInt16BE(rsshfp.encode.bytes - 2, oldOffset);\n  return buf;\n};\n\nrsshfp.encode.bytes = 0;\n\nrsshfp.decode = function decode(buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const record = {};\n  offset += 2; // Account for the RDLENGTH field\n\n  record.algorithm = buf[offset];\n  offset += 1;\n  record.hash = buf[offset];\n  offset += 1;\n  const fingerprintLength = rsshfp.getFingerprintLengthForHashType(record.hash);\n  record.fingerprint = buf.slice(offset, offset + fingerprintLength).toString('hex').toUpperCase();\n  offset += fingerprintLength;\n  rsshfp.decode.bytes = offset - oldOffset;\n  return record;\n};\n\nrsshfp.decode.bytes = 0;\n\nrsshfp.encodingLength = function (record) {\n  return 4 + Buffer.from(record.fingerprint, 'hex').byteLength;\n};\n\nconst renc = exports.record = function (type) {\n  switch (type.toUpperCase()) {\n    case 'A':\n      return ra;\n\n    case 'PTR':\n      return rptr;\n\n    case 'CNAME':\n      return rcname;\n\n    case 'DNAME':\n      return rdname;\n\n    case 'TXT':\n      return rtxt;\n\n    case 'NULL':\n      return rnull;\n\n    case 'AAAA':\n      return raaaa;\n\n    case 'SRV':\n      return rsrv;\n\n    case 'HINFO':\n      return rhinfo;\n\n    case 'CAA':\n      return rcaa;\n\n    case 'NS':\n      return rns;\n\n    case 'SOA':\n      return rsoa;\n\n    case 'MX':\n      return rmx;\n\n    case 'OPT':\n      return ropt;\n\n    case 'DNSKEY':\n      return rdnskey;\n\n    case 'RRSIG':\n      return rrrsig;\n\n    case 'RP':\n      return rrp;\n\n    case 'NSEC':\n      return rnsec;\n\n    case 'NSEC3':\n      return rnsec3;\n\n    case 'SSHFP':\n      return rsshfp;\n\n    case 'DS':\n      return rds;\n  }\n\n  return runknown;\n};\n\nconst answer = exports.answer = {};\n\nanswer.encode = function (a, buf, offset) {\n  if (!buf) buf = Buffer.alloc(answer.encodingLength(a));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  name.encode(a.name, buf, offset);\n  offset += name.encode.bytes;\n  buf.writeUInt16BE(types.toType(a.type), offset);\n\n  if (a.type.toUpperCase() === 'OPT') {\n    if (a.name !== '.') {\n      throw new Error('OPT name must be root.');\n    }\n\n    buf.writeUInt16BE(a.udpPayloadSize || 4096, offset + 2);\n    buf.writeUInt8(a.extendedRcode || 0, offset + 4);\n    buf.writeUInt8(a.ednsVersion || 0, offset + 5);\n    buf.writeUInt16BE(a.flags || 0, offset + 6);\n    offset += 8;\n    ropt.encode(a.options || [], buf, offset);\n    offset += ropt.encode.bytes;\n  } else {\n    let klass = classes.toClass(a.class === undefined ? 'IN' : a.class);\n    if (a.flush) klass |= FLUSH_MASK; // the 1st bit of the class is the flush bit\n\n    buf.writeUInt16BE(klass, offset + 2);\n    buf.writeUInt32BE(a.ttl || 0, offset + 4);\n    offset += 8;\n    const enc = renc(a.type);\n    enc.encode(a.data, buf, offset);\n    offset += enc.encode.bytes;\n  }\n\n  answer.encode.bytes = offset - oldOffset;\n  return buf;\n};\n\nanswer.encode.bytes = 0;\n\nanswer.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const a = {};\n  const oldOffset = offset;\n  a.name = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  a.type = types.toString(buf.readUInt16BE(offset));\n\n  if (a.type === 'OPT') {\n    a.udpPayloadSize = buf.readUInt16BE(offset + 2);\n    a.extendedRcode = buf.readUInt8(offset + 4);\n    a.ednsVersion = buf.readUInt8(offset + 5);\n    a.flags = buf.readUInt16BE(offset + 6);\n    a.flag_do = (a.flags >> 15 & 0x1) === 1;\n    a.options = ropt.decode(buf, offset + 8);\n    offset += 8 + ropt.decode.bytes;\n  } else {\n    const klass = buf.readUInt16BE(offset + 2);\n    a.ttl = buf.readUInt32BE(offset + 4);\n    a.class = classes.toString(klass & NOT_FLUSH_MASK);\n    a.flush = !!(klass & FLUSH_MASK);\n    const enc = renc(a.type);\n    a.data = enc.decode(buf, offset + 8);\n    offset += 8 + enc.decode.bytes;\n  }\n\n  answer.decode.bytes = offset - oldOffset;\n  return a;\n};\n\nanswer.decode.bytes = 0;\n\nanswer.encodingLength = function (a) {\n  const data = a.data !== null && a.data !== undefined ? a.data : a.options;\n  return name.encodingLength(a.name) + 8 + renc(a.type).encodingLength(data);\n};\n\nconst question = exports.question = {};\n\nquestion.encode = function (q, buf, offset) {\n  if (!buf) buf = Buffer.alloc(question.encodingLength(q));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  name.encode(q.name, buf, offset);\n  offset += name.encode.bytes;\n  buf.writeUInt16BE(types.toType(q.type), offset);\n  offset += 2;\n  buf.writeUInt16BE(classes.toClass(q.class === undefined ? 'IN' : q.class), offset);\n  offset += 2;\n  question.encode.bytes = offset - oldOffset;\n  return q;\n};\n\nquestion.encode.bytes = 0;\n\nquestion.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const q = {};\n  q.name = name.decode(buf, offset);\n  offset += name.decode.bytes;\n  q.type = types.toString(buf.readUInt16BE(offset));\n  offset += 2;\n  q.class = classes.toString(buf.readUInt16BE(offset));\n  offset += 2;\n  const qu = !!(q.class & QU_MASK);\n  if (qu) q.class &= NOT_QU_MASK;\n  question.decode.bytes = offset - oldOffset;\n  return q;\n};\n\nquestion.decode.bytes = 0;\n\nquestion.encodingLength = function (q) {\n  return name.encodingLength(q.name) + 4;\n};\n\nexports.AUTHORITATIVE_ANSWER = 1 << 10;\nexports.TRUNCATED_RESPONSE = 1 << 9;\nexports.RECURSION_DESIRED = 1 << 8;\nexports.RECURSION_AVAILABLE = 1 << 7;\nexports.AUTHENTIC_DATA = 1 << 5;\nexports.CHECKING_DISABLED = 1 << 4;\nexports.DNSSEC_OK = 1 << 15;\n\nexports.encode = function (result, buf, offset) {\n  const allocing = !buf;\n  if (allocing) buf = Buffer.alloc(exports.encodingLength(result));\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  if (!result.questions) result.questions = [];\n  if (!result.answers) result.answers = [];\n  if (!result.authorities) result.authorities = [];\n  if (!result.additionals) result.additionals = [];\n  header.encode(result, buf, offset);\n  offset += header.encode.bytes;\n  offset = encodeList(result.questions, question, buf, offset);\n  offset = encodeList(result.answers, answer, buf, offset);\n  offset = encodeList(result.authorities, answer, buf, offset);\n  offset = encodeList(result.additionals, answer, buf, offset);\n  exports.encode.bytes = offset - oldOffset; // just a quick sanity check\n\n  if (allocing && exports.encode.bytes !== buf.length) {\n    return buf.slice(0, exports.encode.bytes);\n  }\n\n  return buf;\n};\n\nexports.encode.bytes = 0;\n\nexports.decode = function (buf, offset) {\n  if (!offset) offset = 0;\n  const oldOffset = offset;\n  const result = header.decode(buf, offset);\n  offset += header.decode.bytes;\n  offset = decodeList(result.questions, question, buf, offset);\n  offset = decodeList(result.answers, answer, buf, offset);\n  offset = decodeList(result.authorities, answer, buf, offset);\n  offset = decodeList(result.additionals, answer, buf, offset);\n  exports.decode.bytes = offset - oldOffset;\n  return result;\n};\n\nexports.decode.bytes = 0;\n\nexports.encodingLength = function (result) {\n  return header.encodingLength(result) + encodingLengthList(result.questions || [], question) + encodingLengthList(result.answers || [], answer) + encodingLengthList(result.authorities || [], answer) + encodingLengthList(result.additionals || [], answer);\n};\n\nexports.streamEncode = function (result) {\n  const buf = exports.encode(result);\n  const sbuf = Buffer.alloc(2);\n  sbuf.writeUInt16BE(buf.byteLength);\n  const combine = Buffer.concat([sbuf, buf]);\n  exports.streamEncode.bytes = combine.byteLength;\n  return combine;\n};\n\nexports.streamEncode.bytes = 0;\n\nexports.streamDecode = function (sbuf) {\n  const len = sbuf.readUInt16BE(0);\n\n  if (sbuf.byteLength < len + 2) {\n    // not enough data\n    return null;\n  }\n\n  const result = exports.decode(sbuf.slice(2));\n  exports.streamDecode.bytes = exports.decode.bytes;\n  return result;\n};\n\nexports.streamDecode.bytes = 0;\n\nfunction encodingLengthList(list, enc) {\n  let len = 0;\n\n  for (let i = 0; i < list.length; i++) len += enc.encodingLength(list[i]);\n\n  return len;\n}\n\nfunction encodeList(list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    enc.encode(list[i], buf, offset);\n    offset += enc.encode.bytes;\n  }\n\n  return offset;\n}\n\nfunction decodeList(list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    list[i] = enc.decode(buf, offset);\n    offset += enc.decode.bytes;\n  }\n\n  return offset;\n}","map":{"version":3,"names":["Buffer","require","types","rcodes","opcodes","classes","optioncodes","ip","QUERY_FLAG","RESPONSE_FLAG","FLUSH_MASK","NOT_FLUSH_MASK","QU_MASK","NOT_QU_MASK","name","exports","encode","str","buf","offset","alloc","encodingLength","oldOffset","n","replace","length","list","split","i","len","write","bytes","decode","totalLength","consumedBytes","jumped","Error","push","toString","jumpOffset","readUInt16BE","join","byteLength","string","s","header","h","flags","type","writeUInt16BE","id","questions","answers","authorities","additionals","flag_qr","opcode","flag_aa","flag_tc","flag_rd","flag_ra","flag_z","flag_ad","flag_cd","rcode","Array","runknown","unknown","data","copy","slice","rns","ns","dd","rsoa","soa","mname","rname","writeUInt32BE","serial","refresh","retry","expire","minimum","readUInt32BE","rtxt","txt","isArray","from","isBuffer","forEach","d","remaining","rnull","null","rhinfo","hinfo","cpu","os","rptr","ptr","rcname","cname","rdname","dname","rsrv","srv","priority","weight","port","target","rcaa","caa","ISSUER_CRITICAL","issuerCritical","writeUInt8","tag","value","readUInt8","rmx","mx","preference","exchange","ra","a","host","v4","raaaa","aaaa","v6","roption","option","code","toCode","spl","sourcePrefixLength","fam","family","familyOf","ipBuf","ipLen","Math","ceil","scopePrefixLength","timeout","fill","tagsLen","tags","padded","ropt","opt","options","rdlen","encodingLengthList","encodeList","o","rdnskey","dnskey","PROTOCOL_DNSSEC","ZONE_KEY","SECURE_ENTRYPOINT","key","keydata","algorithm","rrrsig","rrsig","sig","signature","toType","typeCovered","labels","originalTTL","expiration","inception","keyTag","signersName","rrp","rp","mbox","typebitmap","typelist","typesByWindow","typeid","undefined","windowBuf","window","windowLength","b","j","extents","max","rnsec","nsec","record","nextDomain","rrtypes","rnsec3","nsec3","salt","iterations","saltLength","hashLength","rds","ds","digest","digestdata","digestType","rsshfp","sshfp","getFingerprintLengthForHashType","hashType","hash","fingerprintBuf","fingerprint","toUpperCase","fingerprintLength","renc","answer","udpPayloadSize","extendedRcode","ednsVersion","klass","toClass","class","flush","ttl","enc","flag_do","question","q","qu","AUTHORITATIVE_ANSWER","TRUNCATED_RESPONSE","RECURSION_DESIRED","RECURSION_AVAILABLE","AUTHENTIC_DATA","CHECKING_DISABLED","DNSSEC_OK","result","allocing","decodeList","streamEncode","sbuf","combine","concat","streamDecode"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/dns-packet/index.js"],"sourcesContent":["'use strict'\n\nconst Buffer = require('buffer').Buffer\nconst types = require('./types')\nconst rcodes = require('./rcodes')\nconst opcodes = require('./opcodes')\nconst classes = require('./classes')\nconst optioncodes = require('./optioncodes')\nconst ip = require('@leichtgewicht/ip-codec')\n\nconst QUERY_FLAG = 0\nconst RESPONSE_FLAG = 1 << 15\nconst FLUSH_MASK = 1 << 15\nconst NOT_FLUSH_MASK = ~FLUSH_MASK\nconst QU_MASK = 1 << 15\nconst NOT_QU_MASK = ~QU_MASK\n\nconst name = exports.name = {}\n\nname.encode = function (str, buf, offset) {\n  if (!buf) buf = Buffer.alloc(name.encodingLength(str))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  // strip leading and trailing .\n  const n = str.replace(/^\\.|\\.$/gm, '')\n  if (n.length) {\n    const list = n.split('.')\n\n    for (let i = 0; i < list.length; i++) {\n      const len = buf.write(list[i], offset + 1)\n      buf[offset] = len\n      offset += len + 1\n    }\n  }\n\n  buf[offset++] = 0\n\n  name.encode.bytes = offset - oldOffset\n  return buf\n}\n\nname.encode.bytes = 0\n\nname.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const list = []\n  let oldOffset = offset\n  let totalLength = 0\n  let consumedBytes = 0\n  let jumped = false\n\n  while (true) {\n    if (offset >= buf.length) {\n      throw new Error('Cannot decode name (buffer overflow)')\n    }\n    const len = buf[offset++]\n    consumedBytes += jumped ? 0 : 1\n\n    if (len === 0) {\n      break\n    } else if ((len & 0xc0) === 0) {\n      if (offset + len > buf.length) {\n        throw new Error('Cannot decode name (buffer overflow)')\n      }\n      totalLength += len + 1\n      if (totalLength > 254) {\n        throw new Error('Cannot decode name (name too long)')\n      }\n      list.push(buf.toString('utf-8', offset, offset + len))\n      offset += len\n      consumedBytes += jumped ? 0 : len\n    } else if ((len & 0xc0) === 0xc0) {\n      if (offset + 1 > buf.length) {\n        throw new Error('Cannot decode name (buffer overflow)')\n      }\n      const jumpOffset = buf.readUInt16BE(offset - 1) - 0xc000\n      if (jumpOffset >= oldOffset) {\n        // Allow only pointers to prior data. RFC 1035, section 4.1.4 states:\n        // \"[...] an entire domain name or a list of labels at the end of a domain name\n        // is replaced with a pointer to a prior occurance (sic) of the same name.\"\n        throw new Error('Cannot decode name (bad pointer)')\n      }\n      offset = jumpOffset\n      oldOffset = jumpOffset\n      consumedBytes += jumped ? 0 : 1\n      jumped = true\n    } else {\n      throw new Error('Cannot decode name (bad label)')\n    }\n  }\n\n  name.decode.bytes = consumedBytes\n  return list.length === 0 ? '.' : list.join('.')\n}\n\nname.decode.bytes = 0\n\nname.encodingLength = function (n) {\n  if (n === '.' || n === '..') return 1\n  return Buffer.byteLength(n.replace(/^\\.|\\.$/gm, '')) + 2\n}\n\nconst string = {}\n\nstring.encode = function (s, buf, offset) {\n  if (!buf) buf = Buffer.alloc(string.encodingLength(s))\n  if (!offset) offset = 0\n\n  const len = buf.write(s, offset + 1)\n  buf[offset] = len\n  string.encode.bytes = len + 1\n  return buf\n}\n\nstring.encode.bytes = 0\n\nstring.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf[offset]\n  const s = buf.toString('utf-8', offset + 1, offset + 1 + len)\n  string.decode.bytes = len + 1\n  return s\n}\n\nstring.decode.bytes = 0\n\nstring.encodingLength = function (s) {\n  return Buffer.byteLength(s) + 1\n}\n\nconst header = {}\n\nheader.encode = function (h, buf, offset) {\n  if (!buf) buf = header.encodingLength(h)\n  if (!offset) offset = 0\n\n  const flags = (h.flags || 0) & 32767\n  const type = h.type === 'response' ? RESPONSE_FLAG : QUERY_FLAG\n\n  buf.writeUInt16BE(h.id || 0, offset)\n  buf.writeUInt16BE(flags | type, offset + 2)\n  buf.writeUInt16BE(h.questions.length, offset + 4)\n  buf.writeUInt16BE(h.answers.length, offset + 6)\n  buf.writeUInt16BE(h.authorities.length, offset + 8)\n  buf.writeUInt16BE(h.additionals.length, offset + 10)\n\n  return buf\n}\n\nheader.encode.bytes = 12\n\nheader.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  if (buf.length < 12) throw new Error('Header must be 12 bytes')\n  const flags = buf.readUInt16BE(offset + 2)\n\n  return {\n    id: buf.readUInt16BE(offset),\n    type: flags & RESPONSE_FLAG ? 'response' : 'query',\n    flags: flags & 32767,\n    flag_qr: ((flags >> 15) & 0x1) === 1,\n    opcode: opcodes.toString((flags >> 11) & 0xf),\n    flag_aa: ((flags >> 10) & 0x1) === 1,\n    flag_tc: ((flags >> 9) & 0x1) === 1,\n    flag_rd: ((flags >> 8) & 0x1) === 1,\n    flag_ra: ((flags >> 7) & 0x1) === 1,\n    flag_z: ((flags >> 6) & 0x1) === 1,\n    flag_ad: ((flags >> 5) & 0x1) === 1,\n    flag_cd: ((flags >> 4) & 0x1) === 1,\n    rcode: rcodes.toString(flags & 0xf),\n    questions: new Array(buf.readUInt16BE(offset + 4)),\n    answers: new Array(buf.readUInt16BE(offset + 6)),\n    authorities: new Array(buf.readUInt16BE(offset + 8)),\n    additionals: new Array(buf.readUInt16BE(offset + 10))\n  }\n}\n\nheader.decode.bytes = 12\n\nheader.encodingLength = function () {\n  return 12\n}\n\nconst runknown = exports.unknown = {}\n\nrunknown.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(runknown.encodingLength(data))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(data.length, offset)\n  data.copy(buf, offset + 2)\n\n  runknown.encode.bytes = data.length + 2\n  return buf\n}\n\nrunknown.encode.bytes = 0\n\nrunknown.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n  const data = buf.slice(offset + 2, offset + 2 + len)\n  runknown.decode.bytes = len + 2\n  return data\n}\n\nrunknown.decode.bytes = 0\n\nrunknown.encodingLength = function (data) {\n  return data.length + 2\n}\n\nconst rns = exports.ns = {}\n\nrns.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rns.encodingLength(data))\n  if (!offset) offset = 0\n\n  name.encode(data, buf, offset + 2)\n  buf.writeUInt16BE(name.encode.bytes, offset)\n  rns.encode.bytes = name.encode.bytes + 2\n  return buf\n}\n\nrns.encode.bytes = 0\n\nrns.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n  const dd = name.decode(buf, offset + 2)\n\n  rns.decode.bytes = len + 2\n  return dd\n}\n\nrns.decode.bytes = 0\n\nrns.encodingLength = function (data) {\n  return name.encodingLength(data) + 2\n}\n\nconst rsoa = exports.soa = {}\n\nrsoa.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsoa.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n  name.encode(data.mname, buf, offset)\n  offset += name.encode.bytes\n  name.encode(data.rname, buf, offset)\n  offset += name.encode.bytes\n  buf.writeUInt32BE(data.serial || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.refresh || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.retry || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.expire || 0, offset)\n  offset += 4\n  buf.writeUInt32BE(data.minimum || 0, offset)\n  offset += 4\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rsoa.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrsoa.encode.bytes = 0\n\nrsoa.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.mname = name.decode(buf, offset)\n  offset += name.decode.bytes\n  data.rname = name.decode(buf, offset)\n  offset += name.decode.bytes\n  data.serial = buf.readUInt32BE(offset)\n  offset += 4\n  data.refresh = buf.readUInt32BE(offset)\n  offset += 4\n  data.retry = buf.readUInt32BE(offset)\n  offset += 4\n  data.expire = buf.readUInt32BE(offset)\n  offset += 4\n  data.minimum = buf.readUInt32BE(offset)\n  offset += 4\n\n  rsoa.decode.bytes = offset - oldOffset\n  return data\n}\n\nrsoa.decode.bytes = 0\n\nrsoa.encodingLength = function (data) {\n  return 22 + name.encodingLength(data.mname) + name.encodingLength(data.rname)\n}\n\nconst rtxt = exports.txt = {}\n\nrtxt.encode = function (data, buf, offset) {\n  if (!Array.isArray(data)) data = [data]\n  for (let i = 0; i < data.length; i++) {\n    if (typeof data[i] === 'string') {\n      data[i] = Buffer.from(data[i])\n    }\n    if (!Buffer.isBuffer(data[i])) {\n      throw new Error('Must be a Buffer')\n    }\n  }\n\n  if (!buf) buf = Buffer.alloc(rtxt.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n\n  data.forEach(function (d) {\n    buf[offset++] = d.length\n    d.copy(buf, offset, 0, d.length)\n    offset += d.length\n  })\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rtxt.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrtxt.encode.bytes = 0\n\nrtxt.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n  let remaining = buf.readUInt16BE(offset)\n  offset += 2\n\n  let data = []\n  while (remaining > 0) {\n    const len = buf[offset++]\n    --remaining\n    if (remaining < len) {\n      throw new Error('Buffer overflow')\n    }\n    data.push(buf.slice(offset, offset + len))\n    offset += len\n    remaining -= len\n  }\n\n  rtxt.decode.bytes = offset - oldOffset\n  return data\n}\n\nrtxt.decode.bytes = 0\n\nrtxt.encodingLength = function (data) {\n  if (!Array.isArray(data)) data = [data]\n  let length = 2\n  data.forEach(function (buf) {\n    if (typeof buf === 'string') {\n      length += Buffer.byteLength(buf) + 1\n    } else {\n      length += buf.length + 1\n    }\n  })\n  return length\n}\n\nconst rnull = exports.null = {}\n\nrnull.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnull.encodingLength(data))\n  if (!offset) offset = 0\n\n  if (typeof data === 'string') data = Buffer.from(data)\n  if (!data) data = Buffer.alloc(0)\n\n  const oldOffset = offset\n  offset += 2\n\n  const len = data.length\n  data.copy(buf, offset, 0, len)\n  offset += len\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rnull.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrnull.encode.bytes = 0\n\nrnull.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n  const len = buf.readUInt16BE(offset)\n\n  offset += 2\n\n  const data = buf.slice(offset, offset + len)\n  offset += len\n\n  rnull.decode.bytes = offset - oldOffset\n  return data\n}\n\nrnull.decode.bytes = 0\n\nrnull.encodingLength = function (data) {\n  if (!data) return 2\n  return (Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data)) + 2\n}\n\nconst rhinfo = exports.hinfo = {}\n\nrhinfo.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rhinfo.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n  string.encode(data.cpu, buf, offset)\n  offset += string.encode.bytes\n  string.encode(data.os, buf, offset)\n  offset += string.encode.bytes\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rhinfo.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrhinfo.encode.bytes = 0\n\nrhinfo.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.cpu = string.decode(buf, offset)\n  offset += string.decode.bytes\n  data.os = string.decode(buf, offset)\n  offset += string.decode.bytes\n  rhinfo.decode.bytes = offset - oldOffset\n  return data\n}\n\nrhinfo.decode.bytes = 0\n\nrhinfo.encodingLength = function (data) {\n  return string.encodingLength(data.cpu) + string.encodingLength(data.os) + 2\n}\n\nconst rptr = exports.ptr = {}\nconst rcname = exports.cname = rptr\nconst rdname = exports.dname = rptr\n\nrptr.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rptr.encodingLength(data))\n  if (!offset) offset = 0\n\n  name.encode(data, buf, offset + 2)\n  buf.writeUInt16BE(name.encode.bytes, offset)\n  rptr.encode.bytes = name.encode.bytes + 2\n  return buf\n}\n\nrptr.encode.bytes = 0\n\nrptr.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const data = name.decode(buf, offset + 2)\n  rptr.decode.bytes = name.decode.bytes + 2\n  return data\n}\n\nrptr.decode.bytes = 0\n\nrptr.encodingLength = function (data) {\n  return name.encodingLength(data) + 2\n}\n\nconst rsrv = exports.srv = {}\n\nrsrv.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsrv.encodingLength(data))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(data.priority || 0, offset + 2)\n  buf.writeUInt16BE(data.weight || 0, offset + 4)\n  buf.writeUInt16BE(data.port || 0, offset + 6)\n  name.encode(data.target, buf, offset + 8)\n\n  const len = name.encode.bytes + 6\n  buf.writeUInt16BE(len, offset)\n\n  rsrv.encode.bytes = len + 2\n  return buf\n}\n\nrsrv.encode.bytes = 0\n\nrsrv.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n\n  const data = {}\n  data.priority = buf.readUInt16BE(offset + 2)\n  data.weight = buf.readUInt16BE(offset + 4)\n  data.port = buf.readUInt16BE(offset + 6)\n  data.target = name.decode(buf, offset + 8)\n\n  rsrv.decode.bytes = len + 2\n  return data\n}\n\nrsrv.decode.bytes = 0\n\nrsrv.encodingLength = function (data) {\n  return 8 + name.encodingLength(data.target)\n}\n\nconst rcaa = exports.caa = {}\n\nrcaa.ISSUER_CRITICAL = 1 << 7\n\nrcaa.encode = function (data, buf, offset) {\n  const len = rcaa.encodingLength(data)\n\n  if (!buf) buf = Buffer.alloc(rcaa.encodingLength(data))\n  if (!offset) offset = 0\n\n  if (data.issuerCritical) {\n    data.flags = rcaa.ISSUER_CRITICAL\n  }\n\n  buf.writeUInt16BE(len - 2, offset)\n  offset += 2\n  buf.writeUInt8(data.flags || 0, offset)\n  offset += 1\n  string.encode(data.tag, buf, offset)\n  offset += string.encode.bytes\n  buf.write(data.value, offset)\n  offset += Buffer.byteLength(data.value)\n\n  rcaa.encode.bytes = len\n  return buf\n}\n\nrcaa.encode.bytes = 0\n\nrcaa.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const len = buf.readUInt16BE(offset)\n  offset += 2\n\n  const oldOffset = offset\n  const data = {}\n  data.flags = buf.readUInt8(offset)\n  offset += 1\n  data.tag = string.decode(buf, offset)\n  offset += string.decode.bytes\n  data.value = buf.toString('utf-8', offset, oldOffset + len)\n\n  data.issuerCritical = !!(data.flags & rcaa.ISSUER_CRITICAL)\n\n  rcaa.decode.bytes = len + 2\n\n  return data\n}\n\nrcaa.decode.bytes = 0\n\nrcaa.encodingLength = function (data) {\n  return string.encodingLength(data.tag) + string.encodingLength(data.value) + 2\n}\n\nconst rmx = exports.mx = {}\n\nrmx.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rmx.encodingLength(data))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  offset += 2\n  buf.writeUInt16BE(data.preference || 0, offset)\n  offset += 2\n  name.encode(data.exchange, buf, offset)\n  offset += name.encode.bytes\n\n  buf.writeUInt16BE(offset - oldOffset - 2, oldOffset)\n  rmx.encode.bytes = offset - oldOffset\n  return buf\n}\n\nrmx.encode.bytes = 0\n\nrmx.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.preference = buf.readUInt16BE(offset)\n  offset += 2\n  data.exchange = name.decode(buf, offset)\n  offset += name.decode.bytes\n\n  rmx.decode.bytes = offset - oldOffset\n  return data\n}\n\nrmx.encodingLength = function (data) {\n  return 4 + name.encodingLength(data.exchange)\n}\n\nconst ra = exports.a = {}\n\nra.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.alloc(ra.encodingLength(host))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(4, offset)\n  offset += 2\n  ip.v4.encode(host, buf, offset)\n  ra.encode.bytes = 6\n  return buf\n}\n\nra.encode.bytes = 0\n\nra.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  offset += 2\n  const host = ip.v4.decode(buf, offset)\n  ra.decode.bytes = 6\n  return host\n}\n\nra.decode.bytes = 0\n\nra.encodingLength = function () {\n  return 6\n}\n\nconst raaaa = exports.aaaa = {}\n\nraaaa.encode = function (host, buf, offset) {\n  if (!buf) buf = Buffer.alloc(raaaa.encodingLength(host))\n  if (!offset) offset = 0\n\n  buf.writeUInt16BE(16, offset)\n  offset += 2\n  ip.v6.encode(host, buf, offset)\n  raaaa.encode.bytes = 18\n  return buf\n}\n\nraaaa.encode.bytes = 0\n\nraaaa.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  offset += 2\n  const host = ip.v6.decode(buf, offset)\n  raaaa.decode.bytes = 18\n  return host\n}\n\nraaaa.decode.bytes = 0\n\nraaaa.encodingLength = function () {\n  return 18\n}\n\nconst roption = exports.option = {}\n\nroption.encode = function (option, buf, offset) {\n  if (!buf) buf = Buffer.alloc(roption.encodingLength(option))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const code = optioncodes.toCode(option.code)\n  buf.writeUInt16BE(code, offset)\n  offset += 2\n  if (option.data) {\n    buf.writeUInt16BE(option.data.length, offset)\n    offset += 2\n    option.data.copy(buf, offset)\n    offset += option.data.length\n  } else {\n    switch (code) {\n      // case 3: NSID.  No encode makes sense.\n      // case 5,6,7: Not implementable\n      case 8: // ECS\n        // note: do IP math before calling\n        const spl = option.sourcePrefixLength || 0\n        const fam = option.family || ip.familyOf(option.ip)\n        const ipBuf = ip.encode(option.ip, Buffer.alloc)\n        const ipLen = Math.ceil(spl / 8)\n        buf.writeUInt16BE(ipLen + 4, offset)\n        offset += 2\n        buf.writeUInt16BE(fam, offset)\n        offset += 2\n        buf.writeUInt8(spl, offset++)\n        buf.writeUInt8(option.scopePrefixLength || 0, offset++)\n\n        ipBuf.copy(buf, offset, 0, ipLen)\n        offset += ipLen\n        break\n      // case 9: EXPIRE (experimental)\n      // case 10: COOKIE.  No encode makes sense.\n      case 11: // KEEP-ALIVE\n        if (option.timeout) {\n          buf.writeUInt16BE(2, offset)\n          offset += 2\n          buf.writeUInt16BE(option.timeout, offset)\n          offset += 2\n        } else {\n          buf.writeUInt16BE(0, offset)\n          offset += 2\n        }\n        break\n      case 12: // PADDING\n        const len = option.length || 0\n        buf.writeUInt16BE(len, offset)\n        offset += 2\n        buf.fill(0, offset, offset + len)\n        offset += len\n        break\n      // case 13:  CHAIN.  Experimental.\n      case 14: // KEY-TAG\n        const tagsLen = option.tags.length * 2\n        buf.writeUInt16BE(tagsLen, offset)\n        offset += 2\n        for (const tag of option.tags) {\n          buf.writeUInt16BE(tag, offset)\n          offset += 2\n        }\n        break\n      default:\n        throw new Error(`Unknown roption code: ${option.code}`)\n    }\n  }\n\n  roption.encode.bytes = offset - oldOffset\n  return buf\n}\n\nroption.encode.bytes = 0\n\nroption.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const option = {}\n  option.code = buf.readUInt16BE(offset)\n  option.type = optioncodes.toString(option.code)\n  offset += 2\n  const len = buf.readUInt16BE(offset)\n  offset += 2\n  option.data = buf.slice(offset, offset + len)\n  switch (option.code) {\n    // case 3: NSID.  No decode makes sense.\n    case 8: // ECS\n      option.family = buf.readUInt16BE(offset)\n      offset += 2\n      option.sourcePrefixLength = buf.readUInt8(offset++)\n      option.scopePrefixLength = buf.readUInt8(offset++)\n      const padded = Buffer.alloc((option.family === 1) ? 4 : 16)\n      buf.copy(padded, 0, offset, offset + len - 4)\n      option.ip = ip.decode(padded)\n      break\n    // case 12: Padding.  No decode makes sense.\n    case 11: // KEEP-ALIVE\n      if (len > 0) {\n        option.timeout = buf.readUInt16BE(offset)\n        offset += 2\n      }\n      break\n    case 14:\n      option.tags = []\n      for (let i = 0; i < len; i += 2) {\n        option.tags.push(buf.readUInt16BE(offset))\n        offset += 2\n      }\n    // don't worry about default.  caller will use data if desired\n  }\n\n  roption.decode.bytes = len + 4\n  return option\n}\n\nroption.decode.bytes = 0\n\nroption.encodingLength = function (option) {\n  if (option.data) {\n    return option.data.length + 4\n  }\n  const code = optioncodes.toCode(option.code)\n  switch (code) {\n    case 8: // ECS\n      const spl = option.sourcePrefixLength || 0\n      return Math.ceil(spl / 8) + 8\n    case 11: // KEEP-ALIVE\n      return (typeof option.timeout === 'number') ? 6 : 4\n    case 12: // PADDING\n      return option.length + 4\n    case 14: // KEY-TAG\n      return 4 + (option.tags.length * 2)\n  }\n  throw new Error(`Unknown roption code: ${option.code}`)\n}\n\nconst ropt = exports.opt = {}\n\nropt.encode = function (options, buf, offset) {\n  if (!buf) buf = Buffer.alloc(ropt.encodingLength(options))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const rdlen = encodingLengthList(options, roption)\n  buf.writeUInt16BE(rdlen, offset)\n  offset = encodeList(options, roption, buf, offset + 2)\n\n  ropt.encode.bytes = offset - oldOffset\n  return buf\n}\n\nropt.encode.bytes = 0\n\nropt.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const options = []\n  let rdlen = buf.readUInt16BE(offset)\n  offset += 2\n  let o = 0\n  while (rdlen > 0) {\n    options[o++] = roption.decode(buf, offset)\n    offset += roption.decode.bytes\n    rdlen -= roption.decode.bytes\n  }\n  ropt.decode.bytes = offset - oldOffset\n  return options\n}\n\nropt.decode.bytes = 0\n\nropt.encodingLength = function (options) {\n  return 2 + encodingLengthList(options || [], roption)\n}\n\nconst rdnskey = exports.dnskey = {}\n\nrdnskey.PROTOCOL_DNSSEC = 3\nrdnskey.ZONE_KEY = 0x80\nrdnskey.SECURE_ENTRYPOINT = 0x8000\n\nrdnskey.encode = function (key, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rdnskey.encodingLength(key))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const keydata = key.key\n  if (!Buffer.isBuffer(keydata)) {\n    throw new Error('Key must be a Buffer')\n  }\n\n  offset += 2 // Leave space for length\n  buf.writeUInt16BE(key.flags, offset)\n  offset += 2\n  buf.writeUInt8(rdnskey.PROTOCOL_DNSSEC, offset)\n  offset += 1\n  buf.writeUInt8(key.algorithm, offset)\n  offset += 1\n  keydata.copy(buf, offset, 0, keydata.length)\n  offset += keydata.length\n\n  rdnskey.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rdnskey.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrdnskey.encode.bytes = 0\n\nrdnskey.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var key = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  key.flags = buf.readUInt16BE(offset)\n  offset += 2\n  if (buf.readUInt8(offset) !== rdnskey.PROTOCOL_DNSSEC) {\n    throw new Error('Protocol must be 3')\n  }\n  offset += 1\n  key.algorithm = buf.readUInt8(offset)\n  offset += 1\n  key.key = buf.slice(offset, oldOffset + length + 2)\n  offset += key.key.length\n  rdnskey.decode.bytes = offset - oldOffset\n  return key\n}\n\nrdnskey.decode.bytes = 0\n\nrdnskey.encodingLength = function (key) {\n  return 6 + Buffer.byteLength(key.key)\n}\n\nconst rrrsig = exports.rrsig = {}\n\nrrrsig.encode = function (sig, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rrrsig.encodingLength(sig))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const signature = sig.signature\n  if (!Buffer.isBuffer(signature)) {\n    throw new Error('Signature must be a Buffer')\n  }\n\n  offset += 2 // Leave space for length\n  buf.writeUInt16BE(types.toType(sig.typeCovered), offset)\n  offset += 2\n  buf.writeUInt8(sig.algorithm, offset)\n  offset += 1\n  buf.writeUInt8(sig.labels, offset)\n  offset += 1\n  buf.writeUInt32BE(sig.originalTTL, offset)\n  offset += 4\n  buf.writeUInt32BE(sig.expiration, offset)\n  offset += 4\n  buf.writeUInt32BE(sig.inception, offset)\n  offset += 4\n  buf.writeUInt16BE(sig.keyTag, offset)\n  offset += 2\n  name.encode(sig.signersName, buf, offset)\n  offset += name.encode.bytes\n  signature.copy(buf, offset, 0, signature.length)\n  offset += signature.length\n\n  rrrsig.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rrrsig.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrrrsig.encode.bytes = 0\n\nrrrsig.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var sig = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  sig.typeCovered = types.toString(buf.readUInt16BE(offset))\n  offset += 2\n  sig.algorithm = buf.readUInt8(offset)\n  offset += 1\n  sig.labels = buf.readUInt8(offset)\n  offset += 1\n  sig.originalTTL = buf.readUInt32BE(offset)\n  offset += 4\n  sig.expiration = buf.readUInt32BE(offset)\n  offset += 4\n  sig.inception = buf.readUInt32BE(offset)\n  offset += 4\n  sig.keyTag = buf.readUInt16BE(offset)\n  offset += 2\n  sig.signersName = name.decode(buf, offset)\n  offset += name.decode.bytes\n  sig.signature = buf.slice(offset, oldOffset + length + 2)\n  offset += sig.signature.length\n  rrrsig.decode.bytes = offset - oldOffset\n  return sig\n}\n\nrrrsig.decode.bytes = 0\n\nrrrsig.encodingLength = function (sig) {\n  return 20 +\n    name.encodingLength(sig.signersName) +\n    Buffer.byteLength(sig.signature)\n}\n\nconst rrp = exports.rp = {}\n\nrrp.encode = function (data, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rrp.encodingLength(data))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  offset += 2 // Leave space for length\n  name.encode(data.mbox || '.', buf, offset)\n  offset += name.encode.bytes\n  name.encode(data.txt || '.', buf, offset)\n  offset += name.encode.bytes\n  rrp.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rrp.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrrp.encode.bytes = 0\n\nrrp.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const data = {}\n  offset += 2\n  data.mbox = name.decode(buf, offset) || '.'\n  offset += name.decode.bytes\n  data.txt = name.decode(buf, offset) || '.'\n  offset += name.decode.bytes\n  rrp.decode.bytes = offset - oldOffset\n  return data\n}\n\nrrp.decode.bytes = 0\n\nrrp.encodingLength = function (data) {\n  return 2 + name.encodingLength(data.mbox || '.') + name.encodingLength(data.txt || '.')\n}\n\nconst typebitmap = {}\n\ntypebitmap.encode = function (typelist, buf, offset) {\n  if (!buf) buf = Buffer.alloc(typebitmap.encodingLength(typelist))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var typesByWindow = []\n  for (var i = 0; i < typelist.length; i++) {\n    var typeid = types.toType(typelist[i])\n    if (typesByWindow[typeid >> 8] === undefined) {\n      typesByWindow[typeid >> 8] = []\n    }\n    typesByWindow[typeid >> 8][(typeid >> 3) & 0x1F] |= 1 << (7 - (typeid & 0x7))\n  }\n\n  for (i = 0; i < typesByWindow.length; i++) {\n    if (typesByWindow[i] !== undefined) {\n      var windowBuf = Buffer.from(typesByWindow[i])\n      buf.writeUInt8(i, offset)\n      offset += 1\n      buf.writeUInt8(windowBuf.length, offset)\n      offset += 1\n      windowBuf.copy(buf, offset)\n      offset += windowBuf.length\n    }\n  }\n\n  typebitmap.encode.bytes = offset - oldOffset\n  return buf\n}\n\ntypebitmap.encode.bytes = 0\n\ntypebitmap.decode = function (buf, offset, length) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var typelist = []\n  while (offset - oldOffset < length) {\n    var window = buf.readUInt8(offset)\n    offset += 1\n    var windowLength = buf.readUInt8(offset)\n    offset += 1\n    for (var i = 0; i < windowLength; i++) {\n      var b = buf.readUInt8(offset + i)\n      for (var j = 0; j < 8; j++) {\n        if (b & (1 << (7 - j))) {\n          var typeid = types.toString((window << 8) | (i << 3) | j)\n          typelist.push(typeid)\n        }\n      }\n    }\n    offset += windowLength\n  }\n\n  typebitmap.decode.bytes = offset - oldOffset\n  return typelist\n}\n\ntypebitmap.decode.bytes = 0\n\ntypebitmap.encodingLength = function (typelist) {\n  var extents = []\n  for (var i = 0; i < typelist.length; i++) {\n    var typeid = types.toType(typelist[i])\n    extents[typeid >> 8] = Math.max(extents[typeid >> 8] || 0, typeid & 0xFF)\n  }\n\n  var len = 0\n  for (i = 0; i < extents.length; i++) {\n    if (extents[i] !== undefined) {\n      len += 2 + Math.ceil((extents[i] + 1) / 8)\n    }\n  }\n\n  return len\n}\n\nconst rnsec = exports.nsec = {}\n\nrnsec.encode = function (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnsec.encodingLength(record))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  offset += 2 // Leave space for length\n  name.encode(record.nextDomain, buf, offset)\n  offset += name.encode.bytes\n  typebitmap.encode(record.rrtypes, buf, offset)\n  offset += typebitmap.encode.bytes\n\n  rnsec.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rnsec.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrnsec.encode.bytes = 0\n\nrnsec.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var record = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  record.nextDomain = name.decode(buf, offset)\n  offset += name.decode.bytes\n  record.rrtypes = typebitmap.decode(buf, offset, length - (offset - oldOffset))\n  offset += typebitmap.decode.bytes\n\n  rnsec.decode.bytes = offset - oldOffset\n  return record\n}\n\nrnsec.decode.bytes = 0\n\nrnsec.encodingLength = function (record) {\n  return 2 +\n    name.encodingLength(record.nextDomain) +\n    typebitmap.encodingLength(record.rrtypes)\n}\n\nconst rnsec3 = exports.nsec3 = {}\n\nrnsec3.encode = function (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rnsec3.encodingLength(record))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const salt = record.salt\n  if (!Buffer.isBuffer(salt)) {\n    throw new Error('salt must be a Buffer')\n  }\n\n  const nextDomain = record.nextDomain\n  if (!Buffer.isBuffer(nextDomain)) {\n    throw new Error('nextDomain must be a Buffer')\n  }\n\n  offset += 2 // Leave space for length\n  buf.writeUInt8(record.algorithm, offset)\n  offset += 1\n  buf.writeUInt8(record.flags, offset)\n  offset += 1\n  buf.writeUInt16BE(record.iterations, offset)\n  offset += 2\n  buf.writeUInt8(salt.length, offset)\n  offset += 1\n  salt.copy(buf, offset, 0, salt.length)\n  offset += salt.length\n  buf.writeUInt8(nextDomain.length, offset)\n  offset += 1\n  nextDomain.copy(buf, offset, 0, nextDomain.length)\n  offset += nextDomain.length\n  typebitmap.encode(record.rrtypes, buf, offset)\n  offset += typebitmap.encode.bytes\n\n  rnsec3.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rnsec3.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrnsec3.encode.bytes = 0\n\nrnsec3.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var record = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  record.algorithm = buf.readUInt8(offset)\n  offset += 1\n  record.flags = buf.readUInt8(offset)\n  offset += 1\n  record.iterations = buf.readUInt16BE(offset)\n  offset += 2\n  const saltLength = buf.readUInt8(offset)\n  offset += 1\n  record.salt = buf.slice(offset, offset + saltLength)\n  offset += saltLength\n  const hashLength = buf.readUInt8(offset)\n  offset += 1\n  record.nextDomain = buf.slice(offset, offset + hashLength)\n  offset += hashLength\n  record.rrtypes = typebitmap.decode(buf, offset, length - (offset - oldOffset))\n  offset += typebitmap.decode.bytes\n\n  rnsec3.decode.bytes = offset - oldOffset\n  return record\n}\n\nrnsec3.decode.bytes = 0\n\nrnsec3.encodingLength = function (record) {\n  return 8 +\n    record.salt.length +\n    record.nextDomain.length +\n    typebitmap.encodingLength(record.rrtypes)\n}\n\nconst rds = exports.ds = {}\n\nrds.encode = function (digest, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rds.encodingLength(digest))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const digestdata = digest.digest\n  if (!Buffer.isBuffer(digestdata)) {\n    throw new Error('Digest must be a Buffer')\n  }\n\n  offset += 2 // Leave space for length\n  buf.writeUInt16BE(digest.keyTag, offset)\n  offset += 2\n  buf.writeUInt8(digest.algorithm, offset)\n  offset += 1\n  buf.writeUInt8(digest.digestType, offset)\n  offset += 1\n  digestdata.copy(buf, offset, 0, digestdata.length)\n  offset += digestdata.length\n\n  rds.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rds.encode.bytes - 2, oldOffset)\n  return buf\n}\n\nrds.encode.bytes = 0\n\nrds.decode = function (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  var digest = {}\n  var length = buf.readUInt16BE(offset)\n  offset += 2\n  digest.keyTag = buf.readUInt16BE(offset)\n  offset += 2\n  digest.algorithm = buf.readUInt8(offset)\n  offset += 1\n  digest.digestType = buf.readUInt8(offset)\n  offset += 1\n  digest.digest = buf.slice(offset, oldOffset + length + 2)\n  offset += digest.digest.length\n  rds.decode.bytes = offset - oldOffset\n  return digest\n}\n\nrds.decode.bytes = 0\n\nrds.encodingLength = function (digest) {\n  return 6 + Buffer.byteLength(digest.digest)\n}\n\nconst rsshfp = exports.sshfp = {}\n\nrsshfp.getFingerprintLengthForHashType = function getFingerprintLengthForHashType (hashType) {\n  switch (hashType) {\n    case 1: return 20\n    case 2: return 32\n  }\n}\n\nrsshfp.encode = function encode (record, buf, offset) {\n  if (!buf) buf = Buffer.alloc(rsshfp.encodingLength(record))\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  offset += 2 // The function call starts with the offset pointer at the RDLENGTH field, not the RDATA one\n  buf[offset] = record.algorithm\n  offset += 1\n  buf[offset] = record.hash\n  offset += 1\n\n  const fingerprintBuf = Buffer.from(record.fingerprint.toUpperCase(), 'hex')\n  if (fingerprintBuf.length !== rsshfp.getFingerprintLengthForHashType(record.hash)) {\n    throw new Error('Invalid fingerprint length')\n  }\n  fingerprintBuf.copy(buf, offset)\n  offset += fingerprintBuf.byteLength\n\n  rsshfp.encode.bytes = offset - oldOffset\n  buf.writeUInt16BE(rsshfp.encode.bytes - 2, oldOffset)\n\n  return buf\n}\n\nrsshfp.encode.bytes = 0\n\nrsshfp.decode = function decode (buf, offset) {\n  if (!offset) offset = 0\n  const oldOffset = offset\n\n  const record = {}\n  offset += 2 // Account for the RDLENGTH field\n  record.algorithm = buf[offset]\n  offset += 1\n  record.hash = buf[offset]\n  offset += 1\n\n  const fingerprintLength = rsshfp.getFingerprintLengthForHashType(record.hash)\n  record.fingerprint = buf.slice(offset, offset + fingerprintLength).toString('hex').toUpperCase()\n  offset += fingerprintLength\n  rsshfp.decode.bytes = offset - oldOffset\n  return record\n}\n\nrsshfp.decode.bytes = 0\n\nrsshfp.encodingLength = function (record) {\n  return 4 + Buffer.from(record.fingerprint, 'hex').byteLength\n}\n\nconst renc = exports.record = function (type) {\n  switch (type.toUpperCase()) {\n    case 'A': return ra\n    case 'PTR': return rptr\n    case 'CNAME': return rcname\n    case 'DNAME': return rdname\n    case 'TXT': return rtxt\n    case 'NULL': return rnull\n    case 'AAAA': return raaaa\n    case 'SRV': return rsrv\n    case 'HINFO': return rhinfo\n    case 'CAA': return rcaa\n    case 'NS': return rns\n    case 'SOA': return rsoa\n    case 'MX': return rmx\n    case 'OPT': return ropt\n    case 'DNSKEY': return rdnskey\n    case 'RRSIG': return rrrsig\n    case 'RP': return rrp\n    case 'NSEC': return rnsec\n    case 'NSEC3': return rnsec3\n    case 'SSHFP': return rsshfp\n    case 'DS': return rds\n  }\n  return runknown\n}\n\nconst answer = exports.answer = {}\n\nanswer.encode = function (a, buf, offset) {\n  if (!buf) buf = Buffer.alloc(answer.encodingLength(a))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  name.encode(a.name, buf, offset)\n  offset += name.encode.bytes\n\n  buf.writeUInt16BE(types.toType(a.type), offset)\n\n  if (a.type.toUpperCase() === 'OPT') {\n    if (a.name !== '.') {\n      throw new Error('OPT name must be root.')\n    }\n    buf.writeUInt16BE(a.udpPayloadSize || 4096, offset + 2)\n    buf.writeUInt8(a.extendedRcode || 0, offset + 4)\n    buf.writeUInt8(a.ednsVersion || 0, offset + 5)\n    buf.writeUInt16BE(a.flags || 0, offset + 6)\n\n    offset += 8\n    ropt.encode(a.options || [], buf, offset)\n    offset += ropt.encode.bytes\n  } else {\n    let klass = classes.toClass(a.class === undefined ? 'IN' : a.class)\n    if (a.flush) klass |= FLUSH_MASK // the 1st bit of the class is the flush bit\n    buf.writeUInt16BE(klass, offset + 2)\n    buf.writeUInt32BE(a.ttl || 0, offset + 4)\n\n    offset += 8\n    const enc = renc(a.type)\n    enc.encode(a.data, buf, offset)\n    offset += enc.encode.bytes\n  }\n\n  answer.encode.bytes = offset - oldOffset\n  return buf\n}\n\nanswer.encode.bytes = 0\n\nanswer.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const a = {}\n  const oldOffset = offset\n\n  a.name = name.decode(buf, offset)\n  offset += name.decode.bytes\n  a.type = types.toString(buf.readUInt16BE(offset))\n  if (a.type === 'OPT') {\n    a.udpPayloadSize = buf.readUInt16BE(offset + 2)\n    a.extendedRcode = buf.readUInt8(offset + 4)\n    a.ednsVersion = buf.readUInt8(offset + 5)\n    a.flags = buf.readUInt16BE(offset + 6)\n    a.flag_do = ((a.flags >> 15) & 0x1) === 1\n    a.options = ropt.decode(buf, offset + 8)\n    offset += 8 + ropt.decode.bytes\n  } else {\n    const klass = buf.readUInt16BE(offset + 2)\n    a.ttl = buf.readUInt32BE(offset + 4)\n\n    a.class = classes.toString(klass & NOT_FLUSH_MASK)\n    a.flush = !!(klass & FLUSH_MASK)\n\n    const enc = renc(a.type)\n    a.data = enc.decode(buf, offset + 8)\n    offset += 8 + enc.decode.bytes\n  }\n\n  answer.decode.bytes = offset - oldOffset\n  return a\n}\n\nanswer.decode.bytes = 0\n\nanswer.encodingLength = function (a) {\n  const data = (a.data !== null && a.data !== undefined) ? a.data : a.options\n  return name.encodingLength(a.name) + 8 + renc(a.type).encodingLength(data)\n}\n\nconst question = exports.question = {}\n\nquestion.encode = function (q, buf, offset) {\n  if (!buf) buf = Buffer.alloc(question.encodingLength(q))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  name.encode(q.name, buf, offset)\n  offset += name.encode.bytes\n\n  buf.writeUInt16BE(types.toType(q.type), offset)\n  offset += 2\n\n  buf.writeUInt16BE(classes.toClass(q.class === undefined ? 'IN' : q.class), offset)\n  offset += 2\n\n  question.encode.bytes = offset - oldOffset\n  return q\n}\n\nquestion.encode.bytes = 0\n\nquestion.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  const q = {}\n\n  q.name = name.decode(buf, offset)\n  offset += name.decode.bytes\n\n  q.type = types.toString(buf.readUInt16BE(offset))\n  offset += 2\n\n  q.class = classes.toString(buf.readUInt16BE(offset))\n  offset += 2\n\n  const qu = !!(q.class & QU_MASK)\n  if (qu) q.class &= NOT_QU_MASK\n\n  question.decode.bytes = offset - oldOffset\n  return q\n}\n\nquestion.decode.bytes = 0\n\nquestion.encodingLength = function (q) {\n  return name.encodingLength(q.name) + 4\n}\n\nexports.AUTHORITATIVE_ANSWER = 1 << 10\nexports.TRUNCATED_RESPONSE = 1 << 9\nexports.RECURSION_DESIRED = 1 << 8\nexports.RECURSION_AVAILABLE = 1 << 7\nexports.AUTHENTIC_DATA = 1 << 5\nexports.CHECKING_DISABLED = 1 << 4\nexports.DNSSEC_OK = 1 << 15\n\nexports.encode = function (result, buf, offset) {\n  const allocing = !buf\n\n  if (allocing) buf = Buffer.alloc(exports.encodingLength(result))\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n\n  if (!result.questions) result.questions = []\n  if (!result.answers) result.answers = []\n  if (!result.authorities) result.authorities = []\n  if (!result.additionals) result.additionals = []\n\n  header.encode(result, buf, offset)\n  offset += header.encode.bytes\n\n  offset = encodeList(result.questions, question, buf, offset)\n  offset = encodeList(result.answers, answer, buf, offset)\n  offset = encodeList(result.authorities, answer, buf, offset)\n  offset = encodeList(result.additionals, answer, buf, offset)\n\n  exports.encode.bytes = offset - oldOffset\n\n  // just a quick sanity check\n  if (allocing && exports.encode.bytes !== buf.length) {\n    return buf.slice(0, exports.encode.bytes)\n  }\n\n  return buf\n}\n\nexports.encode.bytes = 0\n\nexports.decode = function (buf, offset) {\n  if (!offset) offset = 0\n\n  const oldOffset = offset\n  const result = header.decode(buf, offset)\n  offset += header.decode.bytes\n\n  offset = decodeList(result.questions, question, buf, offset)\n  offset = decodeList(result.answers, answer, buf, offset)\n  offset = decodeList(result.authorities, answer, buf, offset)\n  offset = decodeList(result.additionals, answer, buf, offset)\n\n  exports.decode.bytes = offset - oldOffset\n\n  return result\n}\n\nexports.decode.bytes = 0\n\nexports.encodingLength = function (result) {\n  return header.encodingLength(result) +\n    encodingLengthList(result.questions || [], question) +\n    encodingLengthList(result.answers || [], answer) +\n    encodingLengthList(result.authorities || [], answer) +\n    encodingLengthList(result.additionals || [], answer)\n}\n\nexports.streamEncode = function (result) {\n  const buf = exports.encode(result)\n  const sbuf = Buffer.alloc(2)\n  sbuf.writeUInt16BE(buf.byteLength)\n  const combine = Buffer.concat([sbuf, buf])\n  exports.streamEncode.bytes = combine.byteLength\n  return combine\n}\n\nexports.streamEncode.bytes = 0\n\nexports.streamDecode = function (sbuf) {\n  const len = sbuf.readUInt16BE(0)\n  if (sbuf.byteLength < len + 2) {\n    // not enough data\n    return null\n  }\n  const result = exports.decode(sbuf.slice(2))\n  exports.streamDecode.bytes = exports.decode.bytes\n  return result\n}\n\nexports.streamDecode.bytes = 0\n\nfunction encodingLengthList (list, enc) {\n  let len = 0\n  for (let i = 0; i < list.length; i++) len += enc.encodingLength(list[i])\n  return len\n}\n\nfunction encodeList (list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    enc.encode(list[i], buf, offset)\n    offset += enc.encode.bytes\n  }\n  return offset\n}\n\nfunction decodeList (list, enc, buf, offset) {\n  for (let i = 0; i < list.length; i++) {\n    list[i] = enc.decode(buf, offset)\n    offset += enc.decode.bytes\n  }\n  return offset\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}