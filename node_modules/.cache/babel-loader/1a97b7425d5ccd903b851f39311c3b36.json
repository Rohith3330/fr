{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _postcssValueParser = _interopRequireDefault(require(\"postcss-value-parser\"));\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction parseNode(atRule, key, options) {\n  // Convert only top-level @import\n  if (atRule.parent.type !== \"root\") {\n    return;\n  }\n\n  if (atRule.raws && atRule.raws.afterName && atRule.raws.afterName.trim().length > 0) {\n    const lastCommentIndex = atRule.raws.afterName.lastIndexOf(\"/*\");\n    const matched = atRule.raws.afterName.slice(lastCommentIndex).match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);\n\n    if (matched && matched[2] === \"true\") {\n      return;\n    }\n  }\n\n  const prevNode = atRule.prev();\n\n  if (prevNode && prevNode.type === \"comment\") {\n    const matched = prevNode.text.match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);\n\n    if (matched && matched[2] === \"true\") {\n      return;\n    }\n  } // Nodes do not exists - `@import url('http://') :root {}`\n\n\n  if (atRule.nodes) {\n    const error = new Error(\"It looks like you didn't end your @import statement correctly. Child nodes are attached to it.\");\n    error.node = atRule;\n    throw error;\n  }\n\n  const rawParams = atRule.raws && atRule.raws[key] && typeof atRule.raws[key].raw !== \"undefined\" ? atRule.raws[key].raw : atRule[key];\n  const {\n    nodes: paramsNodes\n  } = (0, _postcssValueParser.default)(rawParams); // No nodes - `@import ;`\n  // Invalid type - `@import foo-bar;`\n\n  if (paramsNodes.length === 0 || paramsNodes[0].type !== \"string\" && paramsNodes[0].type !== \"function\") {\n    const error = new Error(`Unable to find uri in \"${atRule.toString()}\"`);\n    error.node = atRule;\n    throw error;\n  }\n\n  let isStringValue;\n  let url;\n\n  if (paramsNodes[0].type === \"string\") {\n    isStringValue = true;\n    url = paramsNodes[0].value;\n  } else {\n    // Invalid function - `@import nourl(test.css);`\n    if (paramsNodes[0].value.toLowerCase() !== \"url\") {\n      const error = new Error(`Unable to find uri in \"${atRule.toString()}\"`);\n      error.node = atRule;\n      throw error;\n    }\n\n    isStringValue = paramsNodes[0].nodes.length !== 0 && paramsNodes[0].nodes[0].type === \"string\";\n    url = isStringValue ? paramsNodes[0].nodes[0].value : _postcssValueParser.default.stringify(paramsNodes[0].nodes);\n  }\n\n  url = (0, _utils.normalizeUrl)(url, isStringValue);\n  const {\n    requestable,\n    needResolve\n  } = (0, _utils.isURLRequestable)(url, options);\n  let prefix;\n\n  if (requestable && needResolve) {\n    const queryParts = url.split(\"!\");\n\n    if (queryParts.length > 1) {\n      url = queryParts.pop();\n      prefix = queryParts.join(\"!\");\n    }\n  } // Empty url - `@import \"\";` or `@import url();`\n\n\n  if (url.trim().length === 0) {\n    const error = new Error(`Unable to find uri in \"${atRule.toString()}\"`);\n    error.node = atRule;\n    throw error;\n  }\n\n  const additionalNodes = paramsNodes.slice(1);\n  let supports;\n  let layer;\n  let media;\n\n  if (additionalNodes.length > 0) {\n    let nodes = [];\n\n    for (const node of additionalNodes) {\n      nodes.push(node);\n      const isLayerFunction = node.type === \"function\" && node.value.toLowerCase() === \"layer\";\n      const isLayerWord = node.type === \"word\" && node.value.toLowerCase() === \"layer\";\n\n      if (isLayerFunction || isLayerWord) {\n        if (isLayerFunction) {\n          nodes.splice(nodes.length - 1, 1, ...node.nodes);\n        } else {\n          nodes.splice(nodes.length - 1, 1, {\n            type: \"string\",\n            value: \"\",\n            unclosed: false\n          });\n        }\n\n        layer = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();\n        nodes = [];\n      } else if (node.type === \"function\" && node.value.toLowerCase() === \"supports\") {\n        nodes.splice(nodes.length - 1, 1, ...node.nodes);\n        supports = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();\n        nodes = [];\n      }\n    }\n\n    if (nodes.length > 0) {\n      media = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();\n    }\n  } // eslint-disable-next-line consistent-return\n\n\n  return {\n    atRule,\n    prefix,\n    url,\n    layer,\n    supports,\n    media,\n    requestable,\n    needResolve\n  };\n}\n\nconst plugin = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    postcssPlugin: \"postcss-import-parser\",\n\n    prepare(result) {\n      const parsedAtRules = [];\n      return {\n        AtRule: {\n          import(atRule) {\n            if (options.isCSSStyleSheet) {\n              options.loaderContext.emitError(new Error(atRule.error(\"'@import' rules are not allowed here and will not be processed\").message));\n              return;\n            }\n\n            const {\n              isSupportDataURL,\n              isSupportAbsoluteURL\n            } = options;\n            let parsedAtRule;\n\n            try {\n              parsedAtRule = parseNode(atRule, \"params\", {\n                isSupportAbsoluteURL,\n                isSupportDataURL\n              });\n            } catch (error) {\n              result.warn(error.message, {\n                node: error.node\n              });\n            }\n\n            if (!parsedAtRule) {\n              return;\n            }\n\n            parsedAtRules.push(parsedAtRule);\n          }\n\n        },\n\n        async OnceExit() {\n          if (parsedAtRules.length === 0) {\n            return;\n          }\n\n          const {\n            loaderContext\n          } = options;\n          const resolver = loaderContext.getResolve({\n            dependencyType: \"css\",\n            conditionNames: [\"style\"],\n            mainFields: [\"css\", \"style\", \"main\", \"...\"],\n            mainFiles: [\"index\", \"...\"],\n            extensions: [\".css\", \"...\"],\n            preferRelative: true\n          });\n          const resolvedAtRules = await Promise.all(parsedAtRules.map(async parsedAtRule => {\n            const {\n              atRule,\n              requestable,\n              needResolve,\n              prefix,\n              url,\n              layer,\n              supports,\n              media\n            } = parsedAtRule;\n\n            if (options.filter) {\n              const needKeep = await options.filter(url, media, loaderContext.resourcePath, supports, layer);\n\n              if (!needKeep) {\n                return;\n              }\n            }\n\n            if (needResolve) {\n              const request = (0, _utils.requestify)(url, loaderContext.rootContext);\n              const resolvedUrl = await (0, _utils.resolveRequests)(resolver, loaderContext.context, [...new Set([request, url])]);\n\n              if (!resolvedUrl) {\n                return;\n              }\n\n              if (resolvedUrl === loaderContext.resourcePath) {\n                atRule.remove();\n                return;\n              }\n\n              atRule.remove(); // eslint-disable-next-line consistent-return\n\n              return {\n                url: resolvedUrl,\n                layer,\n                supports,\n                media,\n                prefix,\n                requestable\n              };\n            }\n\n            atRule.remove(); // eslint-disable-next-line consistent-return\n\n            return {\n              url,\n              layer,\n              supports,\n              media,\n              prefix,\n              requestable\n            };\n          }));\n          const urlToNameMap = new Map();\n\n          for (let index = 0; index <= resolvedAtRules.length - 1; index++) {\n            const resolvedAtRule = resolvedAtRules[index];\n\n            if (!resolvedAtRule) {\n              // eslint-disable-next-line no-continue\n              continue;\n            }\n\n            const {\n              url,\n              requestable,\n              layer,\n              supports,\n              media\n            } = resolvedAtRule;\n\n            if (!requestable) {\n              options.api.push({\n                url,\n                layer,\n                supports,\n                media,\n                index\n              }); // eslint-disable-next-line no-continue\n\n              continue;\n            }\n\n            const {\n              prefix\n            } = resolvedAtRule;\n            const newUrl = prefix ? `${prefix}!${url}` : url;\n            let importName = urlToNameMap.get(newUrl);\n\n            if (!importName) {\n              importName = `___CSS_LOADER_AT_RULE_IMPORT_${urlToNameMap.size}___`;\n              urlToNameMap.set(newUrl, importName);\n              options.imports.push({\n                type: \"rule_import\",\n                importName,\n                url: options.urlHandler(newUrl),\n                index\n              });\n            }\n\n            options.api.push({\n              importName,\n              layer,\n              supports,\n              media,\n              index\n            });\n          }\n        }\n\n      };\n    }\n\n  };\n};\n\nplugin.postcss = true;\nvar _default = plugin;\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_postcssValueParser","_interopRequireDefault","require","_utils","obj","__esModule","parseNode","atRule","key","options","parent","type","raws","afterName","trim","length","lastCommentIndex","lastIndexOf","matched","slice","match","WEBPACK_IGNORE_COMMENT_REGEXP","prevNode","prev","text","nodes","error","Error","node","rawParams","raw","paramsNodes","toString","isStringValue","url","toLowerCase","stringify","normalizeUrl","requestable","needResolve","isURLRequestable","prefix","queryParts","split","pop","join","additionalNodes","supports","layer","media","push","isLayerFunction","isLayerWord","splice","unclosed","plugin","postcssPlugin","prepare","result","parsedAtRules","AtRule","import","isCSSStyleSheet","loaderContext","emitError","message","isSupportDataURL","isSupportAbsoluteURL","parsedAtRule","warn","OnceExit","resolver","getResolve","dependencyType","conditionNames","mainFields","mainFiles","extensions","preferRelative","resolvedAtRules","Promise","all","map","filter","needKeep","resourcePath","request","requestify","rootContext","resolvedUrl","resolveRequests","context","Set","remove","urlToNameMap","Map","index","resolvedAtRule","api","newUrl","importName","get","size","set","imports","urlHandler","postcss","_default"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/css-loader/dist/plugins/postcss-import-parser.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _postcssValueParser = _interopRequireDefault(require(\"postcss-value-parser\"));\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parseNode(atRule, key, options) {\n  // Convert only top-level @import\n  if (atRule.parent.type !== \"root\") {\n    return;\n  }\n\n  if (atRule.raws && atRule.raws.afterName && atRule.raws.afterName.trim().length > 0) {\n    const lastCommentIndex = atRule.raws.afterName.lastIndexOf(\"/*\");\n    const matched = atRule.raws.afterName.slice(lastCommentIndex).match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);\n\n    if (matched && matched[2] === \"true\") {\n      return;\n    }\n  }\n\n  const prevNode = atRule.prev();\n\n  if (prevNode && prevNode.type === \"comment\") {\n    const matched = prevNode.text.match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);\n\n    if (matched && matched[2] === \"true\") {\n      return;\n    }\n  } // Nodes do not exists - `@import url('http://') :root {}`\n\n\n  if (atRule.nodes) {\n    const error = new Error(\"It looks like you didn't end your @import statement correctly. Child nodes are attached to it.\");\n    error.node = atRule;\n    throw error;\n  }\n\n  const rawParams = atRule.raws && atRule.raws[key] && typeof atRule.raws[key].raw !== \"undefined\" ? atRule.raws[key].raw : atRule[key];\n  const {\n    nodes: paramsNodes\n  } = (0, _postcssValueParser.default)(rawParams); // No nodes - `@import ;`\n  // Invalid type - `@import foo-bar;`\n\n  if (paramsNodes.length === 0 || paramsNodes[0].type !== \"string\" && paramsNodes[0].type !== \"function\") {\n    const error = new Error(`Unable to find uri in \"${atRule.toString()}\"`);\n    error.node = atRule;\n    throw error;\n  }\n\n  let isStringValue;\n  let url;\n\n  if (paramsNodes[0].type === \"string\") {\n    isStringValue = true;\n    url = paramsNodes[0].value;\n  } else {\n    // Invalid function - `@import nourl(test.css);`\n    if (paramsNodes[0].value.toLowerCase() !== \"url\") {\n      const error = new Error(`Unable to find uri in \"${atRule.toString()}\"`);\n      error.node = atRule;\n      throw error;\n    }\n\n    isStringValue = paramsNodes[0].nodes.length !== 0 && paramsNodes[0].nodes[0].type === \"string\";\n    url = isStringValue ? paramsNodes[0].nodes[0].value : _postcssValueParser.default.stringify(paramsNodes[0].nodes);\n  }\n\n  url = (0, _utils.normalizeUrl)(url, isStringValue);\n  const {\n    requestable,\n    needResolve\n  } = (0, _utils.isURLRequestable)(url, options);\n  let prefix;\n\n  if (requestable && needResolve) {\n    const queryParts = url.split(\"!\");\n\n    if (queryParts.length > 1) {\n      url = queryParts.pop();\n      prefix = queryParts.join(\"!\");\n    }\n  } // Empty url - `@import \"\";` or `@import url();`\n\n\n  if (url.trim().length === 0) {\n    const error = new Error(`Unable to find uri in \"${atRule.toString()}\"`);\n    error.node = atRule;\n    throw error;\n  }\n\n  const additionalNodes = paramsNodes.slice(1);\n  let supports;\n  let layer;\n  let media;\n\n  if (additionalNodes.length > 0) {\n    let nodes = [];\n\n    for (const node of additionalNodes) {\n      nodes.push(node);\n      const isLayerFunction = node.type === \"function\" && node.value.toLowerCase() === \"layer\";\n      const isLayerWord = node.type === \"word\" && node.value.toLowerCase() === \"layer\";\n\n      if (isLayerFunction || isLayerWord) {\n        if (isLayerFunction) {\n          nodes.splice(nodes.length - 1, 1, ...node.nodes);\n        } else {\n          nodes.splice(nodes.length - 1, 1, {\n            type: \"string\",\n            value: \"\",\n            unclosed: false\n          });\n        }\n\n        layer = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();\n        nodes = [];\n      } else if (node.type === \"function\" && node.value.toLowerCase() === \"supports\") {\n        nodes.splice(nodes.length - 1, 1, ...node.nodes);\n        supports = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();\n        nodes = [];\n      }\n    }\n\n    if (nodes.length > 0) {\n      media = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();\n    }\n  } // eslint-disable-next-line consistent-return\n\n\n  return {\n    atRule,\n    prefix,\n    url,\n    layer,\n    supports,\n    media,\n    requestable,\n    needResolve\n  };\n}\n\nconst plugin = (options = {}) => {\n  return {\n    postcssPlugin: \"postcss-import-parser\",\n\n    prepare(result) {\n      const parsedAtRules = [];\n      return {\n        AtRule: {\n          import(atRule) {\n            if (options.isCSSStyleSheet) {\n              options.loaderContext.emitError(new Error(atRule.error(\"'@import' rules are not allowed here and will not be processed\").message));\n              return;\n            }\n\n            const {\n              isSupportDataURL,\n              isSupportAbsoluteURL\n            } = options;\n            let parsedAtRule;\n\n            try {\n              parsedAtRule = parseNode(atRule, \"params\", {\n                isSupportAbsoluteURL,\n                isSupportDataURL\n              });\n            } catch (error) {\n              result.warn(error.message, {\n                node: error.node\n              });\n            }\n\n            if (!parsedAtRule) {\n              return;\n            }\n\n            parsedAtRules.push(parsedAtRule);\n          }\n\n        },\n\n        async OnceExit() {\n          if (parsedAtRules.length === 0) {\n            return;\n          }\n\n          const {\n            loaderContext\n          } = options;\n          const resolver = loaderContext.getResolve({\n            dependencyType: \"css\",\n            conditionNames: [\"style\"],\n            mainFields: [\"css\", \"style\", \"main\", \"...\"],\n            mainFiles: [\"index\", \"...\"],\n            extensions: [\".css\", \"...\"],\n            preferRelative: true\n          });\n          const resolvedAtRules = await Promise.all(parsedAtRules.map(async parsedAtRule => {\n            const {\n              atRule,\n              requestable,\n              needResolve,\n              prefix,\n              url,\n              layer,\n              supports,\n              media\n            } = parsedAtRule;\n\n            if (options.filter) {\n              const needKeep = await options.filter(url, media, loaderContext.resourcePath, supports, layer);\n\n              if (!needKeep) {\n                return;\n              }\n            }\n\n            if (needResolve) {\n              const request = (0, _utils.requestify)(url, loaderContext.rootContext);\n              const resolvedUrl = await (0, _utils.resolveRequests)(resolver, loaderContext.context, [...new Set([request, url])]);\n\n              if (!resolvedUrl) {\n                return;\n              }\n\n              if (resolvedUrl === loaderContext.resourcePath) {\n                atRule.remove();\n                return;\n              }\n\n              atRule.remove(); // eslint-disable-next-line consistent-return\n\n              return {\n                url: resolvedUrl,\n                layer,\n                supports,\n                media,\n                prefix,\n                requestable\n              };\n            }\n\n            atRule.remove(); // eslint-disable-next-line consistent-return\n\n            return {\n              url,\n              layer,\n              supports,\n              media,\n              prefix,\n              requestable\n            };\n          }));\n          const urlToNameMap = new Map();\n\n          for (let index = 0; index <= resolvedAtRules.length - 1; index++) {\n            const resolvedAtRule = resolvedAtRules[index];\n\n            if (!resolvedAtRule) {\n              // eslint-disable-next-line no-continue\n              continue;\n            }\n\n            const {\n              url,\n              requestable,\n              layer,\n              supports,\n              media\n            } = resolvedAtRule;\n\n            if (!requestable) {\n              options.api.push({\n                url,\n                layer,\n                supports,\n                media,\n                index\n              }); // eslint-disable-next-line no-continue\n\n              continue;\n            }\n\n            const {\n              prefix\n            } = resolvedAtRule;\n            const newUrl = prefix ? `${prefix}!${url}` : url;\n            let importName = urlToNameMap.get(newUrl);\n\n            if (!importName) {\n              importName = `___CSS_LOADER_AT_RULE_IMPORT_${urlToNameMap.size}___`;\n              urlToNameMap.set(newUrl, importName);\n              options.imports.push({\n                type: \"rule_import\",\n                importName,\n                url: options.urlHandler(newUrl),\n                index\n              });\n            }\n\n            options.api.push({\n              importName,\n              layer,\n              supports,\n              media,\n              index\n            });\n          }\n        }\n\n      };\n    }\n\n  };\n};\n\nplugin.postcss = true;\nvar _default = plugin;\nexports.default = _default;"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,mBAAmB,GAAGC,sBAAsB,CAACC,OAAO,CAAC,sBAAD,CAAR,CAAhD;;AAEA,IAAIC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAApB;;AAEA,SAASD,sBAAT,CAAgCG,GAAhC,EAAqC;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;IAAEL,OAAO,EAAEK;EAAX,CAArC;AAAwD;;AAE/F,SAASE,SAAT,CAAmBC,MAAnB,EAA2BC,GAA3B,EAAgCC,OAAhC,EAAyC;EACvC;EACA,IAAIF,MAAM,CAACG,MAAP,CAAcC,IAAd,KAAuB,MAA3B,EAAmC;IACjC;EACD;;EAED,IAAIJ,MAAM,CAACK,IAAP,IAAeL,MAAM,CAACK,IAAP,CAAYC,SAA3B,IAAwCN,MAAM,CAACK,IAAP,CAAYC,SAAZ,CAAsBC,IAAtB,GAA6BC,MAA7B,GAAsC,CAAlF,EAAqF;IACnF,MAAMC,gBAAgB,GAAGT,MAAM,CAACK,IAAP,CAAYC,SAAZ,CAAsBI,WAAtB,CAAkC,IAAlC,CAAzB;IACA,MAAMC,OAAO,GAAGX,MAAM,CAACK,IAAP,CAAYC,SAAZ,CAAsBM,KAAtB,CAA4BH,gBAA5B,EAA8CI,KAA9C,CAAoDjB,MAAM,CAACkB,6BAA3D,CAAhB;;IAEA,IAAIH,OAAO,IAAIA,OAAO,CAAC,CAAD,CAAP,KAAe,MAA9B,EAAsC;MACpC;IACD;EACF;;EAED,MAAMI,QAAQ,GAAGf,MAAM,CAACgB,IAAP,EAAjB;;EAEA,IAAID,QAAQ,IAAIA,QAAQ,CAACX,IAAT,KAAkB,SAAlC,EAA6C;IAC3C,MAAMO,OAAO,GAAGI,QAAQ,CAACE,IAAT,CAAcJ,KAAd,CAAoBjB,MAAM,CAACkB,6BAA3B,CAAhB;;IAEA,IAAIH,OAAO,IAAIA,OAAO,CAAC,CAAD,CAAP,KAAe,MAA9B,EAAsC;MACpC;IACD;EACF,CAvBsC,CAuBrC;;;EAGF,IAAIX,MAAM,CAACkB,KAAX,EAAkB;IAChB,MAAMC,KAAK,GAAG,IAAIC,KAAJ,CAAU,gGAAV,CAAd;IACAD,KAAK,CAACE,IAAN,GAAarB,MAAb;IACA,MAAMmB,KAAN;EACD;;EAED,MAAMG,SAAS,GAAGtB,MAAM,CAACK,IAAP,IAAeL,MAAM,CAACK,IAAP,CAAYJ,GAAZ,CAAf,IAAmC,OAAOD,MAAM,CAACK,IAAP,CAAYJ,GAAZ,EAAiBsB,GAAxB,KAAgC,WAAnE,GAAiFvB,MAAM,CAACK,IAAP,CAAYJ,GAAZ,EAAiBsB,GAAlG,GAAwGvB,MAAM,CAACC,GAAD,CAAhI;EACA,MAAM;IACJiB,KAAK,EAAEM;EADH,IAEF,CAAC,GAAG/B,mBAAmB,CAACD,OAAxB,EAAiC8B,SAAjC,CAFJ,CAjCuC,CAmCU;EACjD;;EAEA,IAAIE,WAAW,CAAChB,MAAZ,KAAuB,CAAvB,IAA4BgB,WAAW,CAAC,CAAD,CAAX,CAAepB,IAAf,KAAwB,QAAxB,IAAoCoB,WAAW,CAAC,CAAD,CAAX,CAAepB,IAAf,KAAwB,UAA5F,EAAwG;IACtG,MAAMe,KAAK,GAAG,IAAIC,KAAJ,CAAW,0BAAyBpB,MAAM,CAACyB,QAAP,EAAkB,GAAtD,CAAd;IACAN,KAAK,CAACE,IAAN,GAAarB,MAAb;IACA,MAAMmB,KAAN;EACD;;EAED,IAAIO,aAAJ;EACA,IAAIC,GAAJ;;EAEA,IAAIH,WAAW,CAAC,CAAD,CAAX,CAAepB,IAAf,KAAwB,QAA5B,EAAsC;IACpCsB,aAAa,GAAG,IAAhB;IACAC,GAAG,GAAGH,WAAW,CAAC,CAAD,CAAX,CAAejC,KAArB;EACD,CAHD,MAGO;IACL;IACA,IAAIiC,WAAW,CAAC,CAAD,CAAX,CAAejC,KAAf,CAAqBqC,WAArB,OAAuC,KAA3C,EAAkD;MAChD,MAAMT,KAAK,GAAG,IAAIC,KAAJ,CAAW,0BAAyBpB,MAAM,CAACyB,QAAP,EAAkB,GAAtD,CAAd;MACAN,KAAK,CAACE,IAAN,GAAarB,MAAb;MACA,MAAMmB,KAAN;IACD;;IAEDO,aAAa,GAAGF,WAAW,CAAC,CAAD,CAAX,CAAeN,KAAf,CAAqBV,MAArB,KAAgC,CAAhC,IAAqCgB,WAAW,CAAC,CAAD,CAAX,CAAeN,KAAf,CAAqB,CAArB,EAAwBd,IAAxB,KAAiC,QAAtF;IACAuB,GAAG,GAAGD,aAAa,GAAGF,WAAW,CAAC,CAAD,CAAX,CAAeN,KAAf,CAAqB,CAArB,EAAwB3B,KAA3B,GAAmCE,mBAAmB,CAACD,OAApB,CAA4BqC,SAA5B,CAAsCL,WAAW,CAAC,CAAD,CAAX,CAAeN,KAArD,CAAtD;EACD;;EAEDS,GAAG,GAAG,CAAC,GAAG/B,MAAM,CAACkC,YAAX,EAAyBH,GAAzB,EAA8BD,aAA9B,CAAN;EACA,MAAM;IACJK,WADI;IAEJC;EAFI,IAGF,CAAC,GAAGpC,MAAM,CAACqC,gBAAX,EAA6BN,GAA7B,EAAkCzB,OAAlC,CAHJ;EAIA,IAAIgC,MAAJ;;EAEA,IAAIH,WAAW,IAAIC,WAAnB,EAAgC;IAC9B,MAAMG,UAAU,GAAGR,GAAG,CAACS,KAAJ,CAAU,GAAV,CAAnB;;IAEA,IAAID,UAAU,CAAC3B,MAAX,GAAoB,CAAxB,EAA2B;MACzBmB,GAAG,GAAGQ,UAAU,CAACE,GAAX,EAAN;MACAH,MAAM,GAAGC,UAAU,CAACG,IAAX,CAAgB,GAAhB,CAAT;IACD;EACF,CA5EsC,CA4ErC;;;EAGF,IAAIX,GAAG,CAACpB,IAAJ,GAAWC,MAAX,KAAsB,CAA1B,EAA6B;IAC3B,MAAMW,KAAK,GAAG,IAAIC,KAAJ,CAAW,0BAAyBpB,MAAM,CAACyB,QAAP,EAAkB,GAAtD,CAAd;IACAN,KAAK,CAACE,IAAN,GAAarB,MAAb;IACA,MAAMmB,KAAN;EACD;;EAED,MAAMoB,eAAe,GAAGf,WAAW,CAACZ,KAAZ,CAAkB,CAAlB,CAAxB;EACA,IAAI4B,QAAJ;EACA,IAAIC,KAAJ;EACA,IAAIC,KAAJ;;EAEA,IAAIH,eAAe,CAAC/B,MAAhB,GAAyB,CAA7B,EAAgC;IAC9B,IAAIU,KAAK,GAAG,EAAZ;;IAEA,KAAK,MAAMG,IAAX,IAAmBkB,eAAnB,EAAoC;MAClCrB,KAAK,CAACyB,IAAN,CAAWtB,IAAX;MACA,MAAMuB,eAAe,GAAGvB,IAAI,CAACjB,IAAL,KAAc,UAAd,IAA4BiB,IAAI,CAAC9B,KAAL,CAAWqC,WAAX,OAA6B,OAAjF;MACA,MAAMiB,WAAW,GAAGxB,IAAI,CAACjB,IAAL,KAAc,MAAd,IAAwBiB,IAAI,CAAC9B,KAAL,CAAWqC,WAAX,OAA6B,OAAzE;;MAEA,IAAIgB,eAAe,IAAIC,WAAvB,EAAoC;QAClC,IAAID,eAAJ,EAAqB;UACnB1B,KAAK,CAAC4B,MAAN,CAAa5B,KAAK,CAACV,MAAN,GAAe,CAA5B,EAA+B,CAA/B,EAAkC,GAAGa,IAAI,CAACH,KAA1C;QACD,CAFD,MAEO;UACLA,KAAK,CAAC4B,MAAN,CAAa5B,KAAK,CAACV,MAAN,GAAe,CAA5B,EAA+B,CAA/B,EAAkC;YAChCJ,IAAI,EAAE,QAD0B;YAEhCb,KAAK,EAAE,EAFyB;YAGhCwD,QAAQ,EAAE;UAHsB,CAAlC;QAKD;;QAEDN,KAAK,GAAGhD,mBAAmB,CAACD,OAApB,CAA4BqC,SAA5B,CAAsCX,KAAtC,EAA6CX,IAA7C,GAAoDqB,WAApD,EAAR;QACAV,KAAK,GAAG,EAAR;MACD,CAbD,MAaO,IAAIG,IAAI,CAACjB,IAAL,KAAc,UAAd,IAA4BiB,IAAI,CAAC9B,KAAL,CAAWqC,WAAX,OAA6B,UAA7D,EAAyE;QAC9EV,KAAK,CAAC4B,MAAN,CAAa5B,KAAK,CAACV,MAAN,GAAe,CAA5B,EAA+B,CAA/B,EAAkC,GAAGa,IAAI,CAACH,KAA1C;QACAsB,QAAQ,GAAG/C,mBAAmB,CAACD,OAApB,CAA4BqC,SAA5B,CAAsCX,KAAtC,EAA6CX,IAA7C,GAAoDqB,WAApD,EAAX;QACAV,KAAK,GAAG,EAAR;MACD;IACF;;IAED,IAAIA,KAAK,CAACV,MAAN,GAAe,CAAnB,EAAsB;MACpBkC,KAAK,GAAGjD,mBAAmB,CAACD,OAApB,CAA4BqC,SAA5B,CAAsCX,KAAtC,EAA6CX,IAA7C,GAAoDqB,WAApD,EAAR;IACD;EACF,CAzHsC,CAyHrC;;;EAGF,OAAO;IACL5B,MADK;IAELkC,MAFK;IAGLP,GAHK;IAILc,KAJK;IAKLD,QALK;IAMLE,KANK;IAOLX,WAPK;IAQLC;EARK,CAAP;AAUD;;AAED,MAAMgB,MAAM,GAAG,YAAkB;EAAA,IAAjB9C,OAAiB,uEAAP,EAAO;EAC/B,OAAO;IACL+C,aAAa,EAAE,uBADV;;IAGLC,OAAO,CAACC,MAAD,EAAS;MACd,MAAMC,aAAa,GAAG,EAAtB;MACA,OAAO;QACLC,MAAM,EAAE;UACNC,MAAM,CAACtD,MAAD,EAAS;YACb,IAAIE,OAAO,CAACqD,eAAZ,EAA6B;cAC3BrD,OAAO,CAACsD,aAAR,CAAsBC,SAAtB,CAAgC,IAAIrC,KAAJ,CAAUpB,MAAM,CAACmB,KAAP,CAAa,gEAAb,EAA+EuC,OAAzF,CAAhC;cACA;YACD;;YAED,MAAM;cACJC,gBADI;cAEJC;YAFI,IAGF1D,OAHJ;YAIA,IAAI2D,YAAJ;;YAEA,IAAI;cACFA,YAAY,GAAG9D,SAAS,CAACC,MAAD,EAAS,QAAT,EAAmB;gBACzC4D,oBADyC;gBAEzCD;cAFyC,CAAnB,CAAxB;YAID,CALD,CAKE,OAAOxC,KAAP,EAAc;cACdgC,MAAM,CAACW,IAAP,CAAY3C,KAAK,CAACuC,OAAlB,EAA2B;gBACzBrC,IAAI,EAAEF,KAAK,CAACE;cADa,CAA3B;YAGD;;YAED,IAAI,CAACwC,YAAL,EAAmB;cACjB;YACD;;YAEDT,aAAa,CAACT,IAAd,CAAmBkB,YAAnB;UACD;;QA7BK,CADH;;QAkCL,MAAME,QAAN,GAAiB;UACf,IAAIX,aAAa,CAAC5C,MAAd,KAAyB,CAA7B,EAAgC;YAC9B;UACD;;UAED,MAAM;YACJgD;UADI,IAEFtD,OAFJ;UAGA,MAAM8D,QAAQ,GAAGR,aAAa,CAACS,UAAd,CAAyB;YACxCC,cAAc,EAAE,KADwB;YAExCC,cAAc,EAAE,CAAC,OAAD,CAFwB;YAGxCC,UAAU,EAAE,CAAC,KAAD,EAAQ,OAAR,EAAiB,MAAjB,EAAyB,KAAzB,CAH4B;YAIxCC,SAAS,EAAE,CAAC,OAAD,EAAU,KAAV,CAJ6B;YAKxCC,UAAU,EAAE,CAAC,MAAD,EAAS,KAAT,CAL4B;YAMxCC,cAAc,EAAE;UANwB,CAAzB,CAAjB;UAQA,MAAMC,eAAe,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAYtB,aAAa,CAACuB,GAAd,CAAkB,MAAMd,YAAN,IAAsB;YAChF,MAAM;cACJ7D,MADI;cAEJ+B,WAFI;cAGJC,WAHI;cAIJE,MAJI;cAKJP,GALI;cAMJc,KANI;cAOJD,QAPI;cAQJE;YARI,IASFmB,YATJ;;YAWA,IAAI3D,OAAO,CAAC0E,MAAZ,EAAoB;cAClB,MAAMC,QAAQ,GAAG,MAAM3E,OAAO,CAAC0E,MAAR,CAAejD,GAAf,EAAoBe,KAApB,EAA2Bc,aAAa,CAACsB,YAAzC,EAAuDtC,QAAvD,EAAiEC,KAAjE,CAAvB;;cAEA,IAAI,CAACoC,QAAL,EAAe;gBACb;cACD;YACF;;YAED,IAAI7C,WAAJ,EAAiB;cACf,MAAM+C,OAAO,GAAG,CAAC,GAAGnF,MAAM,CAACoF,UAAX,EAAuBrD,GAAvB,EAA4B6B,aAAa,CAACyB,WAA1C,CAAhB;cACA,MAAMC,WAAW,GAAG,MAAM,CAAC,GAAGtF,MAAM,CAACuF,eAAX,EAA4BnB,QAA5B,EAAsCR,aAAa,CAAC4B,OAApD,EAA6D,CAAC,GAAG,IAAIC,GAAJ,CAAQ,CAACN,OAAD,EAAUpD,GAAV,CAAR,CAAJ,CAA7D,CAA1B;;cAEA,IAAI,CAACuD,WAAL,EAAkB;gBAChB;cACD;;cAED,IAAIA,WAAW,KAAK1B,aAAa,CAACsB,YAAlC,EAAgD;gBAC9C9E,MAAM,CAACsF,MAAP;gBACA;cACD;;cAEDtF,MAAM,CAACsF,MAAP,GAbe,CAaE;;cAEjB,OAAO;gBACL3D,GAAG,EAAEuD,WADA;gBAELzC,KAFK;gBAGLD,QAHK;gBAILE,KAJK;gBAKLR,MALK;gBAMLH;cANK,CAAP;YAQD;;YAED/B,MAAM,CAACsF,MAAP,GA7CgF,CA6C/D;;YAEjB,OAAO;cACL3D,GADK;cAELc,KAFK;cAGLD,QAHK;cAILE,KAJK;cAKLR,MALK;cAMLH;YANK,CAAP;UAQD,CAvDyC,CAAZ,CAA9B;UAwDA,MAAMwD,YAAY,GAAG,IAAIC,GAAJ,EAArB;;UAEA,KAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,IAAIjB,eAAe,CAAChE,MAAhB,GAAyB,CAAtD,EAAyDiF,KAAK,EAA9D,EAAkE;YAChE,MAAMC,cAAc,GAAGlB,eAAe,CAACiB,KAAD,CAAtC;;YAEA,IAAI,CAACC,cAAL,EAAqB;cACnB;cACA;YACD;;YAED,MAAM;cACJ/D,GADI;cAEJI,WAFI;cAGJU,KAHI;cAIJD,QAJI;cAKJE;YALI,IAMFgD,cANJ;;YAQA,IAAI,CAAC3D,WAAL,EAAkB;cAChB7B,OAAO,CAACyF,GAAR,CAAYhD,IAAZ,CAAiB;gBACfhB,GADe;gBAEfc,KAFe;gBAGfD,QAHe;gBAIfE,KAJe;gBAKf+C;cALe,CAAjB,EADgB,CAOZ;;cAEJ;YACD;;YAED,MAAM;cACJvD;YADI,IAEFwD,cAFJ;YAGA,MAAME,MAAM,GAAG1D,MAAM,GAAI,GAAEA,MAAO,IAAGP,GAAI,EAApB,GAAwBA,GAA7C;YACA,IAAIkE,UAAU,GAAGN,YAAY,CAACO,GAAb,CAAiBF,MAAjB,CAAjB;;YAEA,IAAI,CAACC,UAAL,EAAiB;cACfA,UAAU,GAAI,gCAA+BN,YAAY,CAACQ,IAAK,KAA/D;cACAR,YAAY,CAACS,GAAb,CAAiBJ,MAAjB,EAAyBC,UAAzB;cACA3F,OAAO,CAAC+F,OAAR,CAAgBtD,IAAhB,CAAqB;gBACnBvC,IAAI,EAAE,aADa;gBAEnByF,UAFmB;gBAGnBlE,GAAG,EAAEzB,OAAO,CAACgG,UAAR,CAAmBN,MAAnB,CAHc;gBAInBH;cAJmB,CAArB;YAMD;;YAEDvF,OAAO,CAACyF,GAAR,CAAYhD,IAAZ,CAAiB;cACfkD,UADe;cAEfpD,KAFe;cAGfD,QAHe;cAIfE,KAJe;cAKf+C;YALe,CAAjB;UAOD;QACF;;MAjKI,CAAP;IAoKD;;EAzKI,CAAP;AA4KD,CA7KD;;AA+KAzC,MAAM,CAACmD,OAAP,GAAiB,IAAjB;AACA,IAAIC,QAAQ,GAAGpD,MAAf;AACA1D,OAAO,CAACE,OAAR,GAAkB4G,QAAlB"},"metadata":{},"sourceType":"script"}