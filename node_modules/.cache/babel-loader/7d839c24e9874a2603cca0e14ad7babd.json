{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\Rohith\\\\Pictures\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Transform, util } from '@tensorflow/tfjs-core';\nexport function transform(args) {\n  var inputs = args.inputs,\n    attrs = args.attrs,\n    backend = args.backend;\n  var image = inputs.image,\n    transforms = inputs.transforms;\n  var interpolation = attrs.interpolation,\n    fillMode = attrs.fillMode,\n    fillValue = attrs.fillValue,\n    outputShape = attrs.outputShape;\n  var _image$shape = _slicedToArray(image.shape, 4),\n    batch = _image$shape[0],\n    imageHeight = _image$shape[1],\n    imageWidth = _image$shape[2],\n    numChannels = _image$shape[3];\n  var _ref = outputShape != null ? outputShape : [imageHeight, imageWidth],\n    _ref2 = _slicedToArray(_ref, 2),\n    outHeight = _ref2[0],\n    outWidth = _ref2[1];\n  var outShape = [batch, outHeight, outWidth, numChannels];\n  var inStrides = util.computeStrides(image.shape);\n  var batchInStride = inStrides[0];\n  var rowInStride = inStrides[1];\n  var colInStride = inStrides[2];\n  var outStrides = util.computeStrides(outShape);\n  var batchOutStride = outStrides[0];\n  var rowOutStride = outStrides[1];\n  var colOutStride = outStrides[2];\n  var outVals = util.getTypedArrayFromDType(image.dtype, util.sizeFromShape(outShape));\n  outVals.fill(fillValue);\n  var imageVals = backend.data.get(image.dataId).values;\n  var transformVals = backend.data.get(transforms.dataId).values;\n  // Ref TF implementation:\n  // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/image/image_ops.h\n  for (var b = 0; b < batch; ++b) {\n    var _transform = transforms.shape[0] === 1 ? transformVals : transformVals.subarray(b * 8, b * 8 + 8);\n    for (var outY = 0; outY < outHeight; ++outY) {\n      for (var outX = 0; outX < outWidth; ++outX) {\n        for (var channel = 0; channel < numChannels; ++channel) {\n          var val = void 0;\n          var projection = _transform[6] * outX + _transform[7] * outY + 1;\n          if (projection === 0) {\n            // Return the fill value for infinite coordinates,\n            // which are outside the input image\n            continue;\n          }\n          var inX = (_transform[0] * outX + _transform[1] * outY + _transform[2]) / projection;\n          var inY = (_transform[3] * outX + _transform[4] * outY + _transform[5]) / projection;\n          var x = mapCoord(inX, imageWidth, fillMode);\n          var y = mapCoord(inY, imageHeight, fillMode);\n          switch (interpolation) {\n            case 'nearest':\n              val = nearestInterpolation(imageVals, imageHeight, imageWidth, batchInStride, rowInStride, colInStride, b, y, x, channel, fillValue);\n              break;\n            case 'bilinear':\n              val = bilinearInterpolation(imageVals, imageHeight, imageWidth, batchInStride, rowInStride, colInStride, b, y, x, channel, fillValue);\n              break;\n            default:\n              throw new Error(\"Error in Transform: Expect 'nearest' or \" + \"'bilinear', but got \".concat(interpolation));\n          }\n          var ind = b * batchOutStride + outY * rowOutStride + outX * colOutStride + channel;\n          outVals[ind] = val;\n        }\n      }\n    }\n    return backend.makeTensorInfo(outShape, image.dtype, outVals);\n  }\n  var dataId = backend.write(outVals, outShape, image.dtype);\n  return {\n    dataId: dataId,\n    shape: image.shape,\n    dtype: image.dtype\n  };\n}\nexport var transformConfig = {\n  kernelName: Transform,\n  backendName: 'cpu',\n  kernelFunc: transform\n};\nfunction mapCoord(outCoord, len, mode) {\n  switch (mode) {\n    case 'reflect':\n      return mapCoordReflect(outCoord, len);\n    case 'wrap':\n      return mapCoordWrap(outCoord, len);\n    case 'nearest':\n      return mapCoordNearest(outCoord, len);\n    case 'constant':\n    default:\n      return mapCoordConstant(outCoord, len);\n  }\n}\nfunction mapCoordReflect(outCoord, len) {\n  // Reflect [abcd] to [dcba|abcd|dcba].\n  var inCoord = outCoord;\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      var sz2 = 2 * len;\n      if (inCoord < sz2) {\n        inCoord = sz2 * Math.trunc(-inCoord / sz2) + inCoord;\n      }\n      inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1;\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      var _sz = 2 * len;\n      inCoord -= _sz * Math.trunc(inCoord / _sz);\n      if (inCoord >= len) {\n        inCoord = _sz - inCoord - 1;\n      }\n    }\n  }\n  // clamp is necessary because when outCoord = 3.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n  return util.clamp(0, inCoord, len - 1);\n}\nfunction mapCoordWrap(outCoord, len) {\n  // Wrap [abcd] to [abcd|abcd|abcd].\n  var inCoord = outCoord;\n  if (inCoord < 0) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      var sz = len - 1;\n      inCoord += len * (Math.trunc(-inCoord / sz) + 1);\n    }\n  } else if (inCoord > len - 1) {\n    if (len <= 1) {\n      inCoord = 0;\n    } else {\n      var _sz2 = len - 1;\n      inCoord -= len * Math.trunc(inCoord / _sz2);\n    }\n  }\n  // clamp is necessary because when outCoord = -0.5 and len = 4,\n  // inCoord = 3.5 and will be rounded to 4 in nearest interpolation.\n  return util.clamp(0, inCoord, len - 1);\n}\nfunction mapCoordConstant(outCoord, len) {\n  return outCoord;\n}\nfunction mapCoordNearest(outCoord, len) {\n  return util.clamp(0, outCoord, len - 1);\n}\nfunction readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  var ind = batch * batchStride + y * rowStride + x * colStride + channel;\n  if (0 <= y && y < imageHeight && 0 <= x && x < imageWidth) {\n    return imageVals[ind];\n  } else {\n    return fillValue;\n  }\n}\nfunction nearestInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  var $y = Math.round(y);\n  var $x = Math.round(x);\n  return readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, $y, $x, channel, fillValue);\n}\nfunction bilinearInterpolation(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, y, x, channel, fillValue) {\n  var yFloor = Math.floor(y);\n  var xFloor = Math.floor(x);\n  var yCeil = yFloor + 1;\n  var xCeil = xFloor + 1;\n  // f(x, yFloor) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yFloor)\n  //               + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yFloor)\n  var valueYFloor = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yFloor, xCeil, channel, fillValue);\n  // f(x, yCeil) = (xCeil - x) / (xCeil - xFloor) * f(xFloor, yCeil)\n  //             + (x - xFloor) / (xCeil - xFloor) * f(xCeil, yCeil)\n  var valueYCeil = (xCeil - x) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xFloor, channel, fillValue) + (x - xFloor) * readWithFillValue(imageVals, imageHeight, imageWidth, batchStride, rowStride, colStride, batch, yCeil, xCeil, channel, fillValue);\n  // f(x, y) = (yCeil - y) / (yCeil - yFloor) * f(x, yFloor)\n  //         + (y - yFloor) / (yCeil - yFloor) * f(x, yCeil)\n  return (yCeil - y) * valueYFloor + (y - yFloor) * valueYCeil;\n}","map":null,"metadata":{},"sourceType":"module"}