{"ast":null,"code":"'use strict';\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst {\n  visitSkip,\n  detachNodeFromParent\n} = require('../lib/xast.js');\n\nconst {\n  parsePathData\n} = require('../lib/path.js');\n\nconst {\n  intersects\n} = require('./_path.js');\n\nexports.type = 'visitor';\nexports.name = 'removeOffCanvasPaths';\nexports.active = false;\nexports.description = 'removes elements that are drawn outside of the viewbox (disabled by default)';\n/**\n * Remove elements that are drawn outside of the viewbox.\n *\n * @author JoshyPHP\n *\n * @type {import('../lib/types').Plugin<void>}\n */\n\nexports.fn = () => {\n  /**\n   * @type {null | {\n   *   top: number,\n   *   right: number,\n   *   bottom: number,\n   *   left: number,\n   *   width: number,\n   *   height: number\n   * }}\n   */\n  let viewBoxData = null;\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        if (node.name === 'svg' && parentNode.type === 'root') {\n          let viewBox = ''; // find viewbox\n\n          if (node.attributes.viewBox != null) {\n            // remove commas and plus signs, normalize and trim whitespace\n            viewBox = node.attributes.viewBox;\n          } else if (node.attributes.height != null && node.attributes.width != null) {\n            viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;\n          } // parse viewbox\n          // remove commas and plus signs, normalize and trim whitespace\n\n\n          viewBox = viewBox.replace(/[,+]|px/g, ' ').replace(/\\s+/g, ' ').replace(/^\\s*|\\s*$/g, ''); // ensure that the dimensions are 4 values separated by space\n\n          const m = /^(-?\\d*\\.?\\d+) (-?\\d*\\.?\\d+) (\\d*\\.?\\d+) (\\d*\\.?\\d+)$/.exec(viewBox);\n\n          if (m == null) {\n            return;\n          }\n\n          const left = Number.parseFloat(m[1]);\n          const top = Number.parseFloat(m[2]);\n          const width = Number.parseFloat(m[3]);\n          const height = Number.parseFloat(m[4]); // store the viewBox boundaries\n\n          viewBoxData = {\n            left,\n            top,\n            right: left + width,\n            bottom: top + height,\n            width,\n            height\n          };\n        } // consider that any item with a transform attribute is visible\n\n\n        if (node.attributes.transform != null) {\n          return visitSkip;\n        }\n\n        if (node.name === 'path' && node.attributes.d != null && viewBoxData != null) {\n          const pathData = parsePathData(node.attributes.d); // consider that a M command within the viewBox is visible\n\n          let visible = false;\n\n          for (const pathDataItem of pathData) {\n            if (pathDataItem.command === 'M') {\n              const [x, y] = pathDataItem.args;\n\n              if (x >= viewBoxData.left && x <= viewBoxData.right && y >= viewBoxData.top && y <= viewBoxData.bottom) {\n                visible = true;\n              }\n            }\n          }\n\n          if (visible) {\n            return;\n          }\n\n          if (pathData.length === 2) {\n            // close the path too short for intersects()\n            pathData.push({\n              command: 'z',\n              args: []\n            });\n          }\n\n          const {\n            left,\n            top,\n            width,\n            height\n          } = viewBoxData;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n\n          const viewBoxPathData = [{\n            command: 'M',\n            args: [left, top]\n          }, {\n            command: 'h',\n            args: [width]\n          }, {\n            command: 'v',\n            args: [height]\n          }, {\n            command: 'H',\n            args: [left]\n          }, {\n            command: 'z',\n            args: []\n          }];\n\n          if (intersects(viewBoxPathData, pathData) === false) {\n            detachNodeFromParent(node, parentNode);\n          }\n        }\n      }\n    }\n  };\n};","map":{"version":3,"names":["visitSkip","detachNodeFromParent","require","parsePathData","intersects","exports","type","name","active","description","fn","viewBoxData","element","enter","node","parentNode","viewBox","attributes","height","width","replace","m","exec","left","Number","parseFloat","top","right","bottom","transform","d","pathData","visible","pathDataItem","command","x","y","args","length","push","viewBoxPathData"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/postcss-svgo/node_modules/svgo/plugins/removeOffCanvasPaths.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\n\nconst { visitSkip, detachNodeFromParent } = require('../lib/xast.js');\nconst { parsePathData } = require('../lib/path.js');\nconst { intersects } = require('./_path.js');\n\nexports.type = 'visitor';\nexports.name = 'removeOffCanvasPaths';\nexports.active = false;\nexports.description =\n  'removes elements that are drawn outside of the viewbox (disabled by default)';\n\n/**\n * Remove elements that are drawn outside of the viewbox.\n *\n * @author JoshyPHP\n *\n * @type {import('../lib/types').Plugin<void>}\n */\nexports.fn = () => {\n  /**\n   * @type {null | {\n   *   top: number,\n   *   right: number,\n   *   bottom: number,\n   *   left: number,\n   *   width: number,\n   *   height: number\n   * }}\n   */\n  let viewBoxData = null;\n\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        if (node.name === 'svg' && parentNode.type === 'root') {\n          let viewBox = '';\n          // find viewbox\n          if (node.attributes.viewBox != null) {\n            // remove commas and plus signs, normalize and trim whitespace\n            viewBox = node.attributes.viewBox;\n          } else if (\n            node.attributes.height != null &&\n            node.attributes.width != null\n          ) {\n            viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;\n          }\n\n          // parse viewbox\n          // remove commas and plus signs, normalize and trim whitespace\n          viewBox = viewBox\n            .replace(/[,+]|px/g, ' ')\n            .replace(/\\s+/g, ' ')\n            .replace(/^\\s*|\\s*$/g, '');\n          // ensure that the dimensions are 4 values separated by space\n          const m =\n            /^(-?\\d*\\.?\\d+) (-?\\d*\\.?\\d+) (\\d*\\.?\\d+) (\\d*\\.?\\d+)$/.exec(\n              viewBox\n            );\n          if (m == null) {\n            return;\n          }\n          const left = Number.parseFloat(m[1]);\n          const top = Number.parseFloat(m[2]);\n          const width = Number.parseFloat(m[3]);\n          const height = Number.parseFloat(m[4]);\n\n          // store the viewBox boundaries\n          viewBoxData = {\n            left,\n            top,\n            right: left + width,\n            bottom: top + height,\n            width,\n            height,\n          };\n        }\n\n        // consider that any item with a transform attribute is visible\n        if (node.attributes.transform != null) {\n          return visitSkip;\n        }\n\n        if (\n          node.name === 'path' &&\n          node.attributes.d != null &&\n          viewBoxData != null\n        ) {\n          const pathData = parsePathData(node.attributes.d);\n\n          // consider that a M command within the viewBox is visible\n          let visible = false;\n          for (const pathDataItem of pathData) {\n            if (pathDataItem.command === 'M') {\n              const [x, y] = pathDataItem.args;\n              if (\n                x >= viewBoxData.left &&\n                x <= viewBoxData.right &&\n                y >= viewBoxData.top &&\n                y <= viewBoxData.bottom\n              ) {\n                visible = true;\n              }\n            }\n          }\n          if (visible) {\n            return;\n          }\n\n          if (pathData.length === 2) {\n            // close the path too short for intersects()\n            pathData.push({ command: 'z', args: [] });\n          }\n\n          const { left, top, width, height } = viewBoxData;\n          /**\n           * @type {Array<PathDataItem>}\n           */\n          const viewBoxPathData = [\n            { command: 'M', args: [left, top] },\n            { command: 'h', args: [width] },\n            { command: 'v', args: [height] },\n            { command: 'H', args: [left] },\n            { command: 'z', args: [] },\n          ];\n\n          if (intersects(viewBoxPathData, pathData) === false) {\n            detachNodeFromParent(node, parentNode);\n          }\n        }\n      },\n    },\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}