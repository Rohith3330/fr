{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst isExpectAssertionsOrHasAssertionsCall = expression => expression.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && expression.callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && (0, _utils.isSupportedAccessor)(expression.callee.object, 'expect') && (0, _utils.isSupportedAccessor)(expression.callee.property) && ['assertions', 'hasAssertions'].includes((0, _utils.getAccessorValue)(expression.callee.property));\n\nconst isFirstLineExprStmt = functionBody => functionBody[0] && functionBody[0].type === _experimentalUtils.AST_NODE_TYPES.ExpressionStatement;\n\nconst suggestRemovingExtraArguments = (args, extraArgsStartAt) => ({\n  messageId: 'suggestRemovingExtraArguments',\n  fix: fixer => fixer.removeRange([args[extraArgsStartAt].range[0] - Math.sign(extraArgsStartAt), args[args.length - 1].range[1]])\n});\n\nconst suggestions = [['suggestAddingHasAssertions', 'expect.hasAssertions();'], ['suggestAddingAssertions', 'expect.assertions();']];\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Suggest using `expect.assertions()` OR `expect.hasAssertions()`',\n      recommended: false,\n      suggestion: true\n    },\n    messages: {\n      hasAssertionsTakesNoArguments: '`expect.hasAssertions` expects no arguments',\n      assertionsRequiresOneArgument: '`expect.assertions` excepts a single argument of type number',\n      assertionsRequiresNumberArgument: 'This argument should be a number',\n      haveExpectAssertions: 'Every test should have either `expect.assertions(<number of assertions>)` or `expect.hasAssertions()` as its first expression',\n      suggestAddingHasAssertions: 'Add `expect.hasAssertions()`',\n      suggestAddingAssertions: 'Add `expect.assertions(<number of assertions>)`',\n      suggestRemovingExtraArguments: 'Remove extra arguments'\n    },\n    type: 'suggestion',\n    hasSuggestions: true,\n    schema: [{\n      type: 'object',\n      properties: {\n        onlyFunctionsWithAsyncKeyword: {\n          type: 'boolean'\n        },\n        onlyFunctionsWithExpectInLoop: {\n          type: 'boolean'\n        },\n        onlyFunctionsWithExpectInCallback: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    onlyFunctionsWithAsyncKeyword: false,\n    onlyFunctionsWithExpectInLoop: false,\n    onlyFunctionsWithExpectInCallback: false\n  }],\n\n  create(context, _ref) {\n    let [options] = _ref;\n    let expressionDepth = 0;\n    let hasExpectInCallback = false;\n    let hasExpectInLoop = false;\n    let inTestCaseCall = false;\n    let inForLoop = false;\n\n    const shouldCheckFunction = testFunction => {\n      if (!options.onlyFunctionsWithAsyncKeyword && !options.onlyFunctionsWithExpectInLoop && !options.onlyFunctionsWithExpectInCallback) {\n        return true;\n      }\n\n      if (options.onlyFunctionsWithAsyncKeyword) {\n        if (testFunction.async) {\n          return true;\n        }\n      }\n\n      if (options.onlyFunctionsWithExpectInLoop) {\n        if (hasExpectInLoop) {\n          return true;\n        }\n      }\n\n      if (options.onlyFunctionsWithExpectInCallback) {\n        if (hasExpectInCallback) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    const enterExpression = () => inTestCaseCall && expressionDepth++;\n\n    const exitExpression = () => inTestCaseCall && expressionDepth--;\n\n    const enterForLoop = () => inForLoop = true;\n\n    const exitForLoop = () => inForLoop = false;\n\n    return {\n      FunctionExpression: enterExpression,\n      'FunctionExpression:exit': exitExpression,\n      ArrowFunctionExpression: enterExpression,\n      'ArrowFunctionExpression:exit': exitExpression,\n      ForStatement: enterForLoop,\n      'ForStatement:exit': exitForLoop,\n      ForInStatement: enterForLoop,\n      'ForInStatement:exit': exitForLoop,\n      ForOfStatement: enterForLoop,\n      'ForOfStatement:exit': exitForLoop,\n\n      CallExpression(node) {\n        if ((0, _utils.isTestCaseCall)(node)) {\n          inTestCaseCall = true;\n          return;\n        }\n\n        if ((0, _utils.isExpectCall)(node) && inTestCaseCall) {\n          if (inForLoop) {\n            hasExpectInLoop = true;\n          }\n\n          if (expressionDepth > 1) {\n            hasExpectInCallback = true;\n          }\n        }\n      },\n\n      'CallExpression:exit'(node) {\n        if (!(0, _utils.isTestCaseCall)(node)) {\n          return;\n        }\n\n        if (node.arguments.length < 2) {\n          return;\n        }\n\n        const [, testFn] = node.arguments;\n\n        if (!(0, _utils.isFunction)(testFn) || testFn.body.type !== _experimentalUtils.AST_NODE_TYPES.BlockStatement) {\n          return;\n        }\n\n        if (!shouldCheckFunction(testFn)) {\n          return;\n        }\n\n        hasExpectInLoop = false;\n        hasExpectInCallback = false;\n        const testFuncBody = testFn.body.body;\n\n        if (!isFirstLineExprStmt(testFuncBody)) {\n          context.report({\n            messageId: 'haveExpectAssertions',\n            node,\n            suggest: suggestions.map(_ref2 => {\n              let [messageId, text] = _ref2;\n              return {\n                messageId,\n                fix: fixer => fixer.insertTextBeforeRange([testFn.body.range[0] + 1, testFn.body.range[1]], text)\n              };\n            })\n          });\n          return;\n        }\n\n        const testFuncFirstLine = testFuncBody[0].expression;\n\n        if (!isExpectAssertionsOrHasAssertionsCall(testFuncFirstLine)) {\n          context.report({\n            messageId: 'haveExpectAssertions',\n            node,\n            suggest: suggestions.map(_ref3 => {\n              let [messageId, text] = _ref3;\n              return {\n                messageId,\n                fix: fixer => fixer.insertTextBefore(testFuncBody[0], text)\n              };\n            })\n          });\n          return;\n        }\n\n        if ((0, _utils.isSupportedAccessor)(testFuncFirstLine.callee.property, 'hasAssertions')) {\n          if (testFuncFirstLine.arguments.length) {\n            context.report({\n              messageId: 'hasAssertionsTakesNoArguments',\n              node: testFuncFirstLine.callee.property,\n              suggest: [suggestRemovingExtraArguments(testFuncFirstLine.arguments, 0)]\n            });\n          }\n\n          return;\n        }\n\n        if (!(0, _utils.hasOnlyOneArgument)(testFuncFirstLine)) {\n          let {\n            loc\n          } = testFuncFirstLine.callee.property;\n          const suggest = [];\n\n          if (testFuncFirstLine.arguments.length) {\n            loc = testFuncFirstLine.arguments[1].loc;\n            suggest.push(suggestRemovingExtraArguments(testFuncFirstLine.arguments, 1));\n          }\n\n          context.report({\n            messageId: 'assertionsRequiresOneArgument',\n            suggest,\n            loc\n          });\n          return;\n        }\n\n        const [arg] = testFuncFirstLine.arguments;\n\n        if (arg.type === _experimentalUtils.AST_NODE_TYPES.Literal && typeof arg.value === 'number' && Number.isInteger(arg.value)) {\n          return;\n        }\n\n        context.report({\n          messageId: 'assertionsRequiresNumberArgument',\n          node: arg\n        });\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_experimentalUtils","require","_utils","isExpectAssertionsOrHasAssertionsCall","expression","type","AST_NODE_TYPES","CallExpression","callee","MemberExpression","isSupportedAccessor","object","property","includes","getAccessorValue","isFirstLineExprStmt","functionBody","ExpressionStatement","suggestRemovingExtraArguments","args","extraArgsStartAt","messageId","fix","fixer","removeRange","range","Math","sign","length","suggestions","_default","createRule","name","__filename","meta","docs","category","description","recommended","suggestion","messages","hasAssertionsTakesNoArguments","assertionsRequiresOneArgument","assertionsRequiresNumberArgument","haveExpectAssertions","suggestAddingHasAssertions","suggestAddingAssertions","hasSuggestions","schema","properties","onlyFunctionsWithAsyncKeyword","onlyFunctionsWithExpectInLoop","onlyFunctionsWithExpectInCallback","additionalProperties","defaultOptions","create","context","options","expressionDepth","hasExpectInCallback","hasExpectInLoop","inTestCaseCall","inForLoop","shouldCheckFunction","testFunction","async","enterExpression","exitExpression","enterForLoop","exitForLoop","FunctionExpression","ArrowFunctionExpression","ForStatement","ForInStatement","ForOfStatement","node","isTestCaseCall","isExpectCall","arguments","testFn","isFunction","body","BlockStatement","testFuncBody","report","suggest","map","text","insertTextBeforeRange","testFuncFirstLine","insertTextBefore","hasOnlyOneArgument","loc","push","arg","Literal","Number","isInteger"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/eslint-plugin-jest/lib/rules/prefer-expect-assertions.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _experimentalUtils = require(\"@typescript-eslint/experimental-utils\");\n\nvar _utils = require(\"./utils\");\n\nconst isExpectAssertionsOrHasAssertionsCall = expression => expression.type === _experimentalUtils.AST_NODE_TYPES.CallExpression && expression.callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && (0, _utils.isSupportedAccessor)(expression.callee.object, 'expect') && (0, _utils.isSupportedAccessor)(expression.callee.property) && ['assertions', 'hasAssertions'].includes((0, _utils.getAccessorValue)(expression.callee.property));\n\nconst isFirstLineExprStmt = functionBody => functionBody[0] && functionBody[0].type === _experimentalUtils.AST_NODE_TYPES.ExpressionStatement;\n\nconst suggestRemovingExtraArguments = (args, extraArgsStartAt) => ({\n  messageId: 'suggestRemovingExtraArguments',\n  fix: fixer => fixer.removeRange([args[extraArgsStartAt].range[0] - Math.sign(extraArgsStartAt), args[args.length - 1].range[1]])\n});\n\nconst suggestions = [['suggestAddingHasAssertions', 'expect.hasAssertions();'], ['suggestAddingAssertions', 'expect.assertions();']];\n\nvar _default = (0, _utils.createRule)({\n  name: __filename,\n  meta: {\n    docs: {\n      category: 'Best Practices',\n      description: 'Suggest using `expect.assertions()` OR `expect.hasAssertions()`',\n      recommended: false,\n      suggestion: true\n    },\n    messages: {\n      hasAssertionsTakesNoArguments: '`expect.hasAssertions` expects no arguments',\n      assertionsRequiresOneArgument: '`expect.assertions` excepts a single argument of type number',\n      assertionsRequiresNumberArgument: 'This argument should be a number',\n      haveExpectAssertions: 'Every test should have either `expect.assertions(<number of assertions>)` or `expect.hasAssertions()` as its first expression',\n      suggestAddingHasAssertions: 'Add `expect.hasAssertions()`',\n      suggestAddingAssertions: 'Add `expect.assertions(<number of assertions>)`',\n      suggestRemovingExtraArguments: 'Remove extra arguments'\n    },\n    type: 'suggestion',\n    hasSuggestions: true,\n    schema: [{\n      type: 'object',\n      properties: {\n        onlyFunctionsWithAsyncKeyword: {\n          type: 'boolean'\n        },\n        onlyFunctionsWithExpectInLoop: {\n          type: 'boolean'\n        },\n        onlyFunctionsWithExpectInCallback: {\n          type: 'boolean'\n        }\n      },\n      additionalProperties: false\n    }]\n  },\n  defaultOptions: [{\n    onlyFunctionsWithAsyncKeyword: false,\n    onlyFunctionsWithExpectInLoop: false,\n    onlyFunctionsWithExpectInCallback: false\n  }],\n\n  create(context, [options]) {\n    let expressionDepth = 0;\n    let hasExpectInCallback = false;\n    let hasExpectInLoop = false;\n    let inTestCaseCall = false;\n    let inForLoop = false;\n\n    const shouldCheckFunction = testFunction => {\n      if (!options.onlyFunctionsWithAsyncKeyword && !options.onlyFunctionsWithExpectInLoop && !options.onlyFunctionsWithExpectInCallback) {\n        return true;\n      }\n\n      if (options.onlyFunctionsWithAsyncKeyword) {\n        if (testFunction.async) {\n          return true;\n        }\n      }\n\n      if (options.onlyFunctionsWithExpectInLoop) {\n        if (hasExpectInLoop) {\n          return true;\n        }\n      }\n\n      if (options.onlyFunctionsWithExpectInCallback) {\n        if (hasExpectInCallback) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    const enterExpression = () => inTestCaseCall && expressionDepth++;\n\n    const exitExpression = () => inTestCaseCall && expressionDepth--;\n\n    const enterForLoop = () => inForLoop = true;\n\n    const exitForLoop = () => inForLoop = false;\n\n    return {\n      FunctionExpression: enterExpression,\n      'FunctionExpression:exit': exitExpression,\n      ArrowFunctionExpression: enterExpression,\n      'ArrowFunctionExpression:exit': exitExpression,\n      ForStatement: enterForLoop,\n      'ForStatement:exit': exitForLoop,\n      ForInStatement: enterForLoop,\n      'ForInStatement:exit': exitForLoop,\n      ForOfStatement: enterForLoop,\n      'ForOfStatement:exit': exitForLoop,\n\n      CallExpression(node) {\n        if ((0, _utils.isTestCaseCall)(node)) {\n          inTestCaseCall = true;\n          return;\n        }\n\n        if ((0, _utils.isExpectCall)(node) && inTestCaseCall) {\n          if (inForLoop) {\n            hasExpectInLoop = true;\n          }\n\n          if (expressionDepth > 1) {\n            hasExpectInCallback = true;\n          }\n        }\n      },\n\n      'CallExpression:exit'(node) {\n        if (!(0, _utils.isTestCaseCall)(node)) {\n          return;\n        }\n\n        if (node.arguments.length < 2) {\n          return;\n        }\n\n        const [, testFn] = node.arguments;\n\n        if (!(0, _utils.isFunction)(testFn) || testFn.body.type !== _experimentalUtils.AST_NODE_TYPES.BlockStatement) {\n          return;\n        }\n\n        if (!shouldCheckFunction(testFn)) {\n          return;\n        }\n\n        hasExpectInLoop = false;\n        hasExpectInCallback = false;\n        const testFuncBody = testFn.body.body;\n\n        if (!isFirstLineExprStmt(testFuncBody)) {\n          context.report({\n            messageId: 'haveExpectAssertions',\n            node,\n            suggest: suggestions.map(([messageId, text]) => ({\n              messageId,\n              fix: fixer => fixer.insertTextBeforeRange([testFn.body.range[0] + 1, testFn.body.range[1]], text)\n            }))\n          });\n          return;\n        }\n\n        const testFuncFirstLine = testFuncBody[0].expression;\n\n        if (!isExpectAssertionsOrHasAssertionsCall(testFuncFirstLine)) {\n          context.report({\n            messageId: 'haveExpectAssertions',\n            node,\n            suggest: suggestions.map(([messageId, text]) => ({\n              messageId,\n              fix: fixer => fixer.insertTextBefore(testFuncBody[0], text)\n            }))\n          });\n          return;\n        }\n\n        if ((0, _utils.isSupportedAccessor)(testFuncFirstLine.callee.property, 'hasAssertions')) {\n          if (testFuncFirstLine.arguments.length) {\n            context.report({\n              messageId: 'hasAssertionsTakesNoArguments',\n              node: testFuncFirstLine.callee.property,\n              suggest: [suggestRemovingExtraArguments(testFuncFirstLine.arguments, 0)]\n            });\n          }\n\n          return;\n        }\n\n        if (!(0, _utils.hasOnlyOneArgument)(testFuncFirstLine)) {\n          let {\n            loc\n          } = testFuncFirstLine.callee.property;\n          const suggest = [];\n\n          if (testFuncFirstLine.arguments.length) {\n            loc = testFuncFirstLine.arguments[1].loc;\n            suggest.push(suggestRemovingExtraArguments(testFuncFirstLine.arguments, 1));\n          }\n\n          context.report({\n            messageId: 'assertionsRequiresOneArgument',\n            suggest,\n            loc\n          });\n          return;\n        }\n\n        const [arg] = testFuncFirstLine.arguments;\n\n        if (arg.type === _experimentalUtils.AST_NODE_TYPES.Literal && typeof arg.value === 'number' && Number.isInteger(arg.value)) {\n          return;\n        }\n\n        context.report({\n          messageId: 'assertionsRequiresNumberArgument',\n          node: arg\n        });\n      }\n\n    };\n  }\n\n});\n\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}