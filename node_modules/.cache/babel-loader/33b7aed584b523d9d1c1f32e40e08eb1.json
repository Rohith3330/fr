{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n\n_export(exports, {\n  isValidVariantFormatString: () => isValidVariantFormatString,\n  parseVariant: () => parseVariant,\n  getFileModifiedMap: () => getFileModifiedMap,\n  createContext: () => createContext,\n  getContext: () => getContext\n});\n\nconst _fs = /*#__PURE__*/_interopRequireDefault(require(\"fs\"));\n\nconst _url = /*#__PURE__*/_interopRequireDefault(require(\"url\"));\n\nconst _postcss = /*#__PURE__*/_interopRequireDefault(require(\"postcss\"));\n\nconst _dlv = /*#__PURE__*/_interopRequireDefault(require(\"dlv\"));\n\nconst _postcssSelectorParser = /*#__PURE__*/_interopRequireDefault(require(\"postcss-selector-parser\"));\n\nconst _featureFlagsJs = require(\"../featureFlags.js\");\n\nconst _transformThemeValue = /*#__PURE__*/_interopRequireDefault(require(\"../util/transformThemeValue\"));\n\nconst _parseObjectStyles = /*#__PURE__*/_interopRequireDefault(require(\"../util/parseObjectStyles\"));\n\nconst _prefixSelector = /*#__PURE__*/_interopRequireDefault(require(\"../util/prefixSelector\"));\n\nconst _isPlainObject = /*#__PURE__*/_interopRequireDefault(require(\"../util/isPlainObject\"));\n\nconst _escapeClassName = /*#__PURE__*/_interopRequireDefault(require(\"../util/escapeClassName\"));\n\nconst _nameClass = /*#__PURE__*/_interopRequireWildcard(require(\"../util/nameClass\"));\n\nconst _pluginUtils = require(\"../util/pluginUtils\");\n\nconst _bigSign = /*#__PURE__*/_interopRequireDefault(require(\"../util/bigSign\"));\n\nconst _corePlugins = require(\"../corePlugins\");\n\nconst _sharedState = /*#__PURE__*/_interopRequireWildcard(require(\"./sharedState\"));\n\nconst _toPath = require(\"../util/toPath\");\n\nconst _log = /*#__PURE__*/_interopRequireDefault(require(\"../util/log\"));\n\nconst _negateValue = /*#__PURE__*/_interopRequireDefault(require(\"../util/negateValue\"));\n\nconst _isValidArbitraryValue = /*#__PURE__*/_interopRequireDefault(require(\"../util/isValidArbitraryValue\"));\n\nconst _generateRules = require(\"./generateRules\");\n\nconst _cacheInvalidationJs = require(\"./cacheInvalidation.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nlet MATCH_VARIANT = Symbol();\n\nfunction prefix(context, selector) {\n  let prefix = context.tailwindConfig.prefix;\n  return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\n\nfunction parseVariantFormatString(input) {\n  if (input.includes(\"{\")) {\n    if (!isBalanced(input)) throw new Error(`Your { and } are unbalanced.`);\n    return input.split(/{(.*)}/gim).flatMap(line => parseVariantFormatString(line)).filter(Boolean);\n  }\n\n  return [input.trim()];\n}\n\nfunction isBalanced(input) {\n  let count = 0;\n\n  for (let char of input) {\n    if (char === \"{\") {\n      count++;\n    } else if (char === \"}\") {\n      if (--count < 0) {\n        return false // unbalanced\n        ;\n      }\n    }\n  }\n\n  return count === 0;\n}\n\nfunction insertInto(list, value) {\n  let {\n    before = []\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  before = [].concat(before);\n\n  if (before.length <= 0) {\n    list.push(value);\n    return;\n  }\n\n  let idx = list.length - 1;\n\n  for (let other of before) {\n    let iidx = list.indexOf(other);\n    if (iidx === -1) continue;\n    idx = Math.min(idx, iidx);\n  }\n\n  list.splice(idx, 0, value);\n}\n\nfunction parseStyles(styles) {\n  if (!Array.isArray(styles)) {\n    return parseStyles([styles]);\n  }\n\n  return styles.flatMap(style => {\n    let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n    return isNode ? style : (0, _parseObjectStyles.default)(style);\n  });\n}\n\nfunction getClasses(selector, mutate) {\n  let parser = (0, _postcssSelectorParser.default)(selectors => {\n    let allClasses = [];\n\n    if (mutate) {\n      mutate(selectors);\n    }\n\n    selectors.walkClasses(classNode => {\n      allClasses.push(classNode.value);\n    });\n    return allClasses;\n  });\n  return parser.transformSync(selector);\n}\n\nfunction extractCandidates(node) {\n  let state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    containsNonOnDemandable: false\n  };\n  let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let classes = []; // Handle normal rules\n\n  if (node.type === \"rule\") {\n    // Ignore everything inside a :not(...). This allows you to write code like\n    // `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n    // not generated it. But now we will ignore everything inside a `:not`, so\n    // that it still gets generated.\n    function ignoreNot(selectors) {\n      selectors.walkPseudos(pseudo => {\n        if (pseudo.value === \":not\") {\n          pseudo.remove();\n        }\n      });\n    }\n\n    for (let selector of node.selectors) {\n      let classCandidates = getClasses(selector, ignoreNot); // At least one of the selectors contains non-\"on-demandable\" candidates.\n\n      if (classCandidates.length === 0) {\n        state.containsNonOnDemandable = true;\n      }\n\n      for (let classCandidate of classCandidates) {\n        classes.push(classCandidate);\n      }\n    }\n  } else if (node.type === \"atrule\") {\n    node.walkRules(rule => {\n      for (let classCandidate of rule.selectors.flatMap(selector => getClasses(selector))) {\n        classes.push(classCandidate);\n      }\n    });\n  }\n\n  if (depth === 0) {\n    return [state.containsNonOnDemandable || classes.length === 0, classes];\n  }\n\n  return classes;\n}\n\nfunction withIdentifiers(styles) {\n  return parseStyles(styles).flatMap(node => {\n    let nodeMap = new Map();\n    let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node); // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n\n    if (containsNonOnDemandableSelectors) {\n      candidates.unshift(_sharedState.NOT_ON_DEMAND);\n    } // However, it could be that it also contains \"on-demandable\" candidates.\n    // E.g.: `span, .foo {}`, in that case it should still be possible to use\n    // `@apply foo` for example.\n\n\n    return candidates.map(c => {\n      if (!nodeMap.has(node)) {\n        nodeMap.set(node, node);\n      }\n\n      return [c, nodeMap.get(node)];\n    });\n  });\n}\n\nfunction isValidVariantFormatString(format) {\n  return format.startsWith(\"@\") || format.includes(\"&\");\n}\n\nfunction parseVariant(variant) {\n  variant = variant.replace(/\\n+/g, \"\").replace(/\\s{1,}/g, \" \").trim();\n  let fns = parseVariantFormatString(variant).map(str => {\n    if (!str.startsWith(\"@\")) {\n      return _ref => {\n        let {\n          format\n        } = _ref;\n        return format(str);\n      };\n    }\n\n    let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);\n    return _ref2 => {\n      let {\n        wrap\n      } = _ref2;\n      return wrap(_postcss.default.atRule({\n        name,\n        params: params.trim()\n      }));\n    };\n  }).reverse();\n  return api => {\n    for (let fn of fns) {\n      fn(api);\n    }\n  };\n}\n\nfunction buildPluginApi(tailwindConfig, context, _ref3) {\n  let {\n    variantList,\n    variantMap,\n    offsets,\n    classList\n  } = _ref3;\n\n  function getConfigValue(path, defaultValue) {\n    return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n  }\n\n  function applyConfiguredPrefix(selector) {\n    return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n  }\n\n  function prefixIdentifier(identifier, options) {\n    if (identifier === _sharedState.NOT_ON_DEMAND) {\n      return _sharedState.NOT_ON_DEMAND;\n    }\n\n    if (!options.respectPrefix) {\n      return identifier;\n    }\n\n    return context.tailwindConfig.prefix + identifier;\n  }\n\n  function resolveThemeValue(path, defaultValue) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const [pathRoot, ...subPaths] = (0, _toPath.toPath)(path);\n    const value = getConfigValue([\"theme\", pathRoot, ...subPaths], defaultValue);\n    return (0, _transformThemeValue.default)(pathRoot)(value, opts);\n  }\n\n  const theme = Object.assign(function (path) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    return resolveThemeValue(path, defaultValue);\n  }, {\n    withAlpha: (path, opacityValue) => resolveThemeValue(path, undefined, {\n      opacityValue\n    })\n  });\n  let api = {\n    postcss: _postcss.default,\n    prefix: applyConfiguredPrefix,\n    e: _escapeClassName.default,\n    config: getConfigValue,\n    theme,\n    corePlugins: path => {\n      if (Array.isArray(tailwindConfig.corePlugins)) {\n        return tailwindConfig.corePlugins.includes(path);\n      }\n\n      return getConfigValue([\"corePlugins\", path], true);\n    },\n    variants: () => {\n      // Preserved for backwards compatibility but not used in v3.0+\n      return [];\n    },\n\n    addBase(base) {\n      for (let [identifier, rule] of withIdentifiers(base)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n        let offset = offsets.base++;\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offset,\n          layer: \"base\"\n        }, rule]);\n      }\n    },\n\n    /**\n    * @param {string} group\n    * @param {Record<string, string | string[]>} declarations\n    */\n    addDefaults(group, declarations) {\n      const groups = {\n        [`@defaults ${group}`]: declarations\n      };\n\n      for (let [identifier, rule] of withIdentifiers(groups)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, {});\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.base++,\n          layer: \"defaults\"\n        }, rule]);\n      }\n    },\n\n    addComponents(components, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: false\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n\n      for (let [identifier, rule] of withIdentifiers(components)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        classList.add(prefixedIdentifier);\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.components++,\n          layer: \"components\",\n          options\n        }, rule]);\n      }\n    },\n\n    addUtilities(utilities, options) {\n      let defaultOptions = {\n        preserveSource: false,\n        respectPrefix: true,\n        respectImportant: true\n      };\n      options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n\n      for (let [identifier, rule] of withIdentifiers(utilities)) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        classList.add(prefixedIdentifier);\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push([{\n          sort: offsets.utilities++,\n          layer: \"utilities\",\n          options\n        }, rule]);\n      }\n    },\n\n    matchUtilities: function (utilities, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: true\n      };\n      options = { ...defaultOptions,\n        ...options\n      };\n      let offset = offsets.utilities++;\n\n      for (let identifier in utilities) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = utilities[identifier];\n        classList.add([prefixedIdentifier, options]);\n\n        function wrapped(modifier, _ref4) {\n          let {\n            isOnlyPlugin\n          } = _ref4;\n          let {\n            type = \"any\"\n          } = options;\n          type = [].concat(type);\n          let [value, coercedType] = (0, _pluginUtils.coerceValue)(type, modifier, options, tailwindConfig);\n\n          if (value === undefined) {\n            return [];\n          }\n\n          if (!type.includes(coercedType) && !isOnlyPlugin) {\n            return [];\n          }\n\n          if (!(0, _isValidArbitraryValue.default)(value)) {\n            return [];\n          }\n\n          let ruleSets = [].concat(rule(value)).filter(Boolean).map(declaration => ({\n            [(0, _nameClass.default)(identifier, modifier)]: declaration\n          }));\n          return ruleSets;\n        }\n\n        let withOffsets = [{\n          sort: offset,\n          layer: \"utilities\",\n          options\n        }, wrapped];\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    },\n    matchComponents: function (components, options) {\n      let defaultOptions = {\n        respectPrefix: true,\n        respectImportant: false\n      };\n      options = { ...defaultOptions,\n        ...options\n      };\n      let offset = offsets.components++;\n\n      for (let identifier in components) {\n        let prefixedIdentifier = prefixIdentifier(identifier, options);\n        let rule = components[identifier];\n        classList.add([prefixedIdentifier, options]);\n\n        function wrapped(modifier, _ref5) {\n          let {\n            isOnlyPlugin\n          } = _ref5;\n          let {\n            type = \"any\"\n          } = options;\n          type = [].concat(type);\n          let [value, coercedType] = (0, _pluginUtils.coerceValue)(type, modifier, options, tailwindConfig);\n\n          if (value === undefined) {\n            return [];\n          }\n\n          if (!type.includes(coercedType)) {\n            if (isOnlyPlugin) {\n              _log.default.warn([`Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`, `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`]);\n            } else {\n              return [];\n            }\n          }\n\n          if (!(0, _isValidArbitraryValue.default)(value)) {\n            return [];\n          }\n\n          let ruleSets = [].concat(rule(value)).filter(Boolean).map(declaration => ({\n            [(0, _nameClass.default)(identifier, modifier)]: declaration\n          }));\n          return ruleSets;\n        }\n\n        let withOffsets = [{\n          sort: offset,\n          layer: \"components\",\n          options\n        }, wrapped];\n\n        if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n          context.candidateRuleMap.set(prefixedIdentifier, []);\n        }\n\n        context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n      }\n    },\n\n    addVariant(variantName, variantFunctions) {\n      let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      variantFunctions = [].concat(variantFunctions).map(variantFunction => {\n        if (typeof variantFunction !== \"string\") {\n          // Safelist public API functions\n          return api => {\n            let {\n              args,\n              modifySelectors,\n              container,\n              separator,\n              wrap,\n              format\n            } = api;\n            let result = variantFunction(Object.assign({\n              modifySelectors,\n              container,\n              separator\n            }, variantFunction[MATCH_VARIANT] && {\n              args,\n              wrap,\n              format\n            }));\n\n            if (typeof result === \"string\" && !isValidVariantFormatString(result)) {\n              throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n            }\n\n            if (Array.isArray(result)) {\n              return result.filter(variant => typeof variant === \"string\").map(variant => parseVariant(variant));\n            } // result may be undefined with legacy variants that use APIs like `modifySelectors`\n            // result may also be a postcss node if someone was returning the result from `modifySelectors`\n\n\n            return result && typeof result === \"string\" && parseVariant(result)(api);\n          };\n        }\n\n        if (!isValidVariantFormatString(variantFunction)) {\n          throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n        }\n\n        return parseVariant(variantFunction);\n      });\n      insertInto(variantList, variantName, options);\n      variantMap.set(variantName, variantFunctions);\n    }\n\n  };\n\n  if ((0, _featureFlagsJs.flagEnabled)(tailwindConfig, \"matchVariant\")) {\n    api.matchVariant = function (variants, options) {\n      for (let variant in variants) {\n        var ref;\n\n        for (let [k, v] of Object.entries((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {})) {\n          api.addVariant(`${variant}-${k}`, variants[variant](v));\n        }\n\n        api.addVariant(variant, Object.assign(_ref6 => {\n          let {\n            args\n          } = _ref6;\n          return variants[variant](args);\n        }, {\n          [MATCH_VARIANT]: true\n        }), options);\n      }\n    };\n  }\n\n  return api;\n}\n\nlet fileModifiedMapCache = new WeakMap();\n\nfunction getFileModifiedMap(context) {\n  if (!fileModifiedMapCache.has(context)) {\n    fileModifiedMapCache.set(context, new Map());\n  }\n\n  return fileModifiedMapCache.get(context);\n}\n\nfunction trackModified(files, fileModifiedMap) {\n  let changed = false;\n\n  for (let file of files) {\n    var ref;\n    if (!file) continue;\n\n    let parsed = _url.default.parse(file);\n\n    let pathname = parsed.hash ? parsed.href.replace(parsed.hash, \"\") : parsed.href;\n    pathname = parsed.search ? pathname.replace(parsed.search, \"\") : pathname;\n    let newModified = (ref = _fs.default.statSync(decodeURIComponent(pathname), {\n      throwIfNoEntry: false\n    })) === null || ref === void 0 ? void 0 : ref.mtimeMs;\n\n    if (!newModified) {\n      continue;\n    }\n\n    if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n      changed = true;\n    }\n\n    fileModifiedMap.set(file, newModified);\n  }\n\n  return changed;\n}\n\nfunction extractVariantAtRules(node) {\n  node.walkAtRules(atRule => {\n    if ([\"responsive\", \"variants\"].includes(atRule.name)) {\n      extractVariantAtRules(atRule);\n      atRule.before(atRule.nodes);\n      atRule.remove();\n    }\n  });\n}\n\nfunction collectLayerPlugins(root) {\n  let layerPlugins = [];\n  root.each(node => {\n    if (node.type === \"atrule\" && [\"responsive\", \"variants\"].includes(node.name)) {\n      node.name = \"layer\";\n      node.params = \"utilities\";\n    }\n  }); // Walk @layer rules and treat them like plugins\n\n  root.walkAtRules(\"layer\", layerRule => {\n    extractVariantAtRules(layerRule);\n\n    if (layerRule.params === \"base\") {\n      for (let node of layerRule.nodes) {\n        layerPlugins.push(function (_ref7) {\n          let {\n            addBase\n          } = _ref7;\n          addBase(node, {\n            respectPrefix: false\n          });\n        });\n      }\n\n      layerRule.remove();\n    } else if (layerRule.params === \"components\") {\n      for (let node1 of layerRule.nodes) {\n        layerPlugins.push(function (_ref8) {\n          let {\n            addComponents\n          } = _ref8;\n          addComponents(node1, {\n            respectPrefix: false,\n            preserveSource: true\n          });\n        });\n      }\n\n      layerRule.remove();\n    } else if (layerRule.params === \"utilities\") {\n      for (let node2 of layerRule.nodes) {\n        layerPlugins.push(function (_ref9) {\n          let {\n            addUtilities\n          } = _ref9;\n          addUtilities(node2, {\n            respectPrefix: false,\n            preserveSource: true\n          });\n        });\n      }\n\n      layerRule.remove();\n    }\n  });\n  return layerPlugins;\n}\n\nfunction resolvePlugins(context, root) {\n  let corePluginList = Object.entries({ ..._corePlugins.variantPlugins,\n    ..._corePlugins.corePlugins\n  }).map(_ref10 => {\n    let [name, plugin] = _ref10;\n\n    if (!context.tailwindConfig.corePlugins.includes(name)) {\n      return null;\n    }\n\n    return plugin;\n  }).filter(Boolean);\n  let userPlugins = context.tailwindConfig.plugins.map(plugin => {\n    if (plugin.__isOptionsFunction) {\n      plugin = plugin();\n    }\n\n    return typeof plugin === \"function\" ? plugin : plugin.handler;\n  });\n  let layerPlugins = collectLayerPlugins(root); // TODO: This is a workaround for backwards compatibility, since custom variants\n  // were historically sorted before screen/stackable variants.\n\n  let beforeVariants = [_corePlugins.variantPlugins[\"pseudoElementVariants\"], _corePlugins.variantPlugins[\"pseudoClassVariants\"]];\n  let afterVariants = [_corePlugins.variantPlugins[\"directionVariants\"], _corePlugins.variantPlugins[\"reducedMotionVariants\"], _corePlugins.variantPlugins[\"prefersContrastVariants\"], _corePlugins.variantPlugins[\"darkVariants\"], _corePlugins.variantPlugins[\"printVariant\"], _corePlugins.variantPlugins[\"screenVariants\"], _corePlugins.variantPlugins[\"orientationVariants\"]];\n  return [...corePluginList, ...beforeVariants, ...userPlugins, ...afterVariants, ...layerPlugins];\n}\n\nfunction registerPlugins(plugins, context) {\n  let variantList = [];\n  let variantMap = new Map();\n  let offsets = {\n    defaults: 0n,\n    base: 0n,\n    components: 0n,\n    utilities: 0n,\n    user: 0n\n  };\n  let classList = new Set();\n  let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n    variantList,\n    variantMap,\n    offsets,\n    classList\n  });\n\n  for (let plugin of plugins) {\n    if (Array.isArray(plugin)) {\n      for (let pluginItem of plugin) {\n        pluginItem(pluginApi);\n      }\n    } else {\n      plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);\n    }\n  }\n\n  let highestOffset = (args => args.reduce((m, e) => e > m ? e : m))([offsets.base, offsets.defaults, offsets.components, offsets.utilities, offsets.user]);\n\n  let reservedBits = BigInt(highestOffset.toString(2).length); // A number one less than the top range of the highest offset area\n  // so arbitrary properties are always sorted at the end.\n\n  context.arbitraryPropertiesSort = (1n << reservedBits << 0n) - 1n;\n  context.layerOrder = {\n    defaults: 1n << reservedBits << 0n,\n    base: 1n << reservedBits << 1n,\n    components: 1n << reservedBits << 2n,\n    utilities: 1n << reservedBits << 3n,\n    user: 1n << reservedBits << 4n\n  };\n  reservedBits += 5n;\n  let offset = 0;\n  context.variantOrder = new Map(variantList.map((variant, i) => {\n    let variantFunctions = variantMap.get(variant).length;\n    let bits = 1n << BigInt(i + offset) << reservedBits;\n    offset += variantFunctions - 1;\n    return [variant, bits];\n  }).sort((_ref11, _ref12) => {\n    let [, a] = _ref11;\n    let [, z] = _ref12;\n    return (0, _bigSign.default)(a - z);\n  }));\n  context.minimumScreen = [...context.variantOrder.values()].shift(); // Build variantMap\n\n  for (let [variantName, variantFunctions] of variantMap.entries()) {\n    let sort = context.variantOrder.get(variantName);\n    context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx) => [sort << BigInt(idx), variantFunction]));\n  }\n\n  var _safelist;\n\n  let safelist = ((_safelist = context.tailwindConfig.safelist) !== null && _safelist !== void 0 ? _safelist : []).filter(Boolean);\n\n  if (safelist.length > 0) {\n    let checks = [];\n\n    for (let value of safelist) {\n      if (typeof value === \"string\") {\n        context.changedContent.push({\n          content: value,\n          extension: \"html\"\n        });\n        continue;\n      }\n\n      if (value instanceof RegExp) {\n        _log.default.warn(\"root-regex\", [\"Regular expressions in `safelist` work differently in Tailwind CSS v3.0.\", \"Update your `safelist` configuration to eliminate this warning.\", \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"]);\n\n        continue;\n      }\n\n      checks.push(value);\n    }\n\n    if (checks.length > 0) {\n      let patternMatchingCount = new Map();\n      let prefixLength = context.tailwindConfig.prefix.length;\n\n      for (let util of classList) {\n        let utils = Array.isArray(util) ? (() => {\n          let [utilName, options] = util;\n          var ref;\n          let values = Object.keys((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {});\n          let classes = values.map(value => (0, _nameClass.formatClass)(utilName, value));\n\n          if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {\n            // This is the normal negated version\n            // e.g. `-inset-1` or `-tw-inset-1`\n            classes = [...classes, ...classes.map(cls => \"-\" + cls)]; // This is the negated version *after* the prefix\n            // e.g. `tw--inset-1`\n            // The prefix is already attached to util name\n            // So we add the negative after the prefix\n\n            classes = [...classes, ...classes.map(cls => cls.slice(0, prefixLength) + \"-\" + cls.slice(prefixLength))];\n          }\n\n          if ([].concat(options === null || options === void 0 ? void 0 : options.type).includes(\"color\")) {\n            classes = [...classes, ...classes.flatMap(cls => Object.keys(context.tailwindConfig.theme.opacity).map(opacity => `${cls}/${opacity}`))];\n          }\n\n          return classes;\n        })() : [util];\n\n        for (let util1 of utils) {\n          for (let {\n            pattern,\n            variants = []\n          } of checks) {\n            // RegExp with the /g flag are stateful, so let's reset the last\n            // index pointer to reset the state.\n            pattern.lastIndex = 0;\n\n            if (!patternMatchingCount.has(pattern)) {\n              patternMatchingCount.set(pattern, 0);\n            }\n\n            if (!pattern.test(util1)) continue;\n            patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n            context.changedContent.push({\n              content: util1,\n              extension: \"html\"\n            });\n\n            for (let variant of variants) {\n              context.changedContent.push({\n                content: variant + context.tailwindConfig.separator + util1,\n                extension: \"html\"\n              });\n            }\n          }\n        }\n      }\n\n      for (let [regex, count] of patternMatchingCount.entries()) {\n        if (count !== 0) continue;\n\n        _log.default.warn([`The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`, \"Fix this pattern or remove it from your `safelist` configuration.\", \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\"]);\n      }\n    }\n  } // A list of utilities that are used by certain Tailwind CSS utilities but\n  // that don't exist on their own. This will result in them \"not existing\" and\n  // sorting could be weird since you still require them in order to make the\n  // host utitlies work properly. (Thanks Biology)\n\n\n  let parasiteUtilities = new Set([prefix(context, \"group\"), prefix(context, \"peer\")]);\n\n  context.getClassOrder = function getClassOrder(classes) {\n    let sortedClassNames = new Map();\n\n    for (let [sort, rule] of (0, _generateRules.generateRules)(new Set(classes), context)) {\n      if (sortedClassNames.has(rule.raws.tailwind.candidate)) continue;\n      sortedClassNames.set(rule.raws.tailwind.candidate, sort);\n    }\n\n    return classes.map(className => {\n      var ref;\n      let order = (ref = sortedClassNames.get(className)) !== null && ref !== void 0 ? ref : null;\n\n      if (order === null && parasiteUtilities.has(className)) {\n        // This will make sure that it is at the very beginning of the\n        // `components` layer which technically means 'before any\n        // components'.\n        order = context.layerOrder.components;\n      }\n\n      return [className, order];\n    });\n  }; // Generate a list of strings for autocompletion purposes, e.g.\n  // ['uppercase', 'lowercase', ...]\n\n\n  context.getClassList = function getClassList() {\n    let output = [];\n\n    for (let util of classList) {\n      if (Array.isArray(util)) {\n        let [utilName, options] = util;\n        let negativeClasses = [];\n        var ref;\n\n        for (let [key, value] of Object.entries((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {})) {\n          output.push((0, _nameClass.formatClass)(utilName, key));\n\n          if ((options === null || options === void 0 ? void 0 : options.supportsNegativeValues) && (0, _negateValue.default)(value)) {\n            negativeClasses.push((0, _nameClass.formatClass)(utilName, `-${key}`));\n          }\n        }\n\n        output.push(...negativeClasses);\n      } else {\n        output.push(util);\n      }\n    }\n\n    return output;\n  };\n}\n\nfunction createContext(tailwindConfig) {\n  let changedContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _postcss.default.root();\n  let context = {\n    disposables: [],\n    ruleCache: new Set(),\n    classCache: new Map(),\n    applyClassCache: new Map(),\n    notClassCache: new Set(),\n    postCssNodeCache: new Map(),\n    candidateRuleMap: new Map(),\n    tailwindConfig,\n    changedContent: changedContent,\n    variantMap: new Map(),\n    stylesheetCache: null\n  };\n  let resolvedPlugins = resolvePlugins(context, root);\n  registerPlugins(resolvedPlugins, context);\n  return context;\n}\n\nlet contextMap = _sharedState.contextMap;\nlet configContextMap = _sharedState.configContextMap;\nlet contextSourcesMap = _sharedState.contextSourcesMap;\n\nfunction getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n  let sourcePath = result.opts.from;\n  let isConfigFile = userConfigPath !== null;\n  _sharedState.env.DEBUG && console.log(\"Source path:\", sourcePath);\n  let existingContext;\n\n  if (isConfigFile && contextMap.has(sourcePath)) {\n    existingContext = contextMap.get(sourcePath);\n  } else if (configContextMap.has(tailwindConfigHash)) {\n    let context = configContextMap.get(tailwindConfigHash);\n    contextSourcesMap.get(context).add(sourcePath);\n    contextMap.set(sourcePath, context);\n    existingContext = context;\n  }\n\n  let cssDidChange = (0, _cacheInvalidationJs.hasContentChanged)(sourcePath, root); // If there's already a context in the cache and we don't need to\n  // reset the context, return the cached context.\n\n  if (existingContext) {\n    let contextDependenciesChanged = trackModified([...contextDependencies], getFileModifiedMap(existingContext));\n\n    if (!contextDependenciesChanged && !cssDidChange) {\n      return [existingContext, false];\n    }\n  } // If this source is in the context map, get the old context.\n  // Remove this source from the context sources for the old context,\n  // and clean up that context if no one else is using it. This can be\n  // called by many processes in rapid succession, so we check for presence\n  // first because the first process to run this code will wipe it out first.\n\n\n  if (contextMap.has(sourcePath)) {\n    let oldContext = contextMap.get(sourcePath);\n\n    if (contextSourcesMap.has(oldContext)) {\n      contextSourcesMap.get(oldContext).delete(sourcePath);\n\n      if (contextSourcesMap.get(oldContext).size === 0) {\n        contextSourcesMap.delete(oldContext);\n\n        for (let [tailwindConfigHash1, context1] of configContextMap) {\n          if (context1 === oldContext) {\n            configContextMap.delete(tailwindConfigHash1);\n          }\n        }\n\n        for (let disposable of oldContext.disposables.splice(0)) {\n          disposable(oldContext);\n        }\n      }\n    }\n  }\n\n  _sharedState.env.DEBUG && console.log(\"Setting up new context...\");\n  let context2 = createContext(tailwindConfig, [], root);\n  trackModified([...contextDependencies], getFileModifiedMap(context2)); // ---\n  // Update all context tracking state\n\n  configContextMap.set(tailwindConfigHash, context2);\n  contextMap.set(sourcePath, context2);\n\n  if (!contextSourcesMap.has(context2)) {\n    contextSourcesMap.set(context2, new Set());\n  }\n\n  contextSourcesMap.get(context2).add(sourcePath);\n  return [context2, true];\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","isValidVariantFormatString","parseVariant","getFileModifiedMap","createContext","getContext","_fs","_interopRequireDefault","require","_url","_postcss","_dlv","_postcssSelectorParser","_featureFlagsJs","_transformThemeValue","_parseObjectStyles","_prefixSelector","_isPlainObject","_escapeClassName","_nameClass","_interopRequireWildcard","_pluginUtils","_bigSign","_corePlugins","_sharedState","_toPath","_log","_negateValue","_isValidArbitraryValue","_generateRules","_cacheInvalidationJs","obj","__esModule","default","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","MATCH_VARIANT","Symbol","prefix","context","selector","tailwindConfig","parseVariantFormatString","input","includes","isBalanced","Error","split","flatMap","line","filter","Boolean","trim","count","char","insertInto","list","before","concat","length","push","idx","other","iidx","indexOf","Math","min","splice","parseStyles","styles","Array","isArray","style","isNode","getClasses","mutate","parser","selectors","allClasses","walkClasses","classNode","transformSync","extractCandidates","node","state","containsNonOnDemandable","depth","classes","type","ignoreNot","walkPseudos","pseudo","remove","classCandidates","classCandidate","walkRules","rule","withIdentifiers","nodeMap","Map","containsNonOnDemandableSelectors","candidates","unshift","NOT_ON_DEMAND","map","c","format","startsWith","variant","replace","fns","str","params","exec","wrap","atRule","reverse","api","fn","buildPluginApi","variantList","variantMap","offsets","classList","getConfigValue","path","defaultValue","applyConfiguredPrefix","prefixIdentifier","identifier","options","respectPrefix","resolveThemeValue","opts","pathRoot","subPaths","toPath","theme","assign","undefined","withAlpha","opacityValue","postcss","e","config","corePlugins","variants","addBase","base","prefixedIdentifier","offset","candidateRuleMap","sort","layer","addDefaults","group","declarations","groups","addComponents","components","defaultOptions","preserveSource","respectImportant","add","addUtilities","utilities","matchUtilities","wrapped","modifier","isOnlyPlugin","coercedType","coerceValue","ruleSets","declaration","withOffsets","matchComponents","warn","addVariant","variantName","variantFunctions","variantFunction","args","modifySelectors","container","separator","result","flagEnabled","matchVariant","ref","k","v","entries","values","fileModifiedMapCache","trackModified","files","fileModifiedMap","changed","file","parsed","parse","pathname","hash","href","search","newModified","statSync","decodeURIComponent","throwIfNoEntry","mtimeMs","extractVariantAtRules","walkAtRules","nodes","collectLayerPlugins","root","layerPlugins","each","layerRule","node1","node2","resolvePlugins","corePluginList","variantPlugins","plugin","userPlugins","plugins","__isOptionsFunction","handler","beforeVariants","afterVariants","registerPlugins","defaults","user","Set","pluginApi","pluginItem","highestOffset","reduce","m","reservedBits","BigInt","toString","arbitraryPropertiesSort","layerOrder","variantOrder","i","bits","a","z","minimumScreen","shift","_safelist","safelist","checks","changedContent","content","extension","RegExp","patternMatchingCount","prefixLength","util","utils","utilName","keys","formatClass","supportsNegativeValues","cls","slice","opacity","util1","pattern","lastIndex","test","regex","parasiteUtilities","getClassOrder","sortedClassNames","generateRules","raws","tailwind","candidate","className","order","getClassList","output","negativeClasses","disposables","ruleCache","classCache","applyClassCache","notClassCache","postCssNodeCache","stylesheetCache","resolvedPlugins","contextMap","configContextMap","contextSourcesMap","userConfigPath","tailwindConfigHash","contextDependencies","sourcePath","from","isConfigFile","env","DEBUG","console","log","existingContext","cssDidChange","hasContentChanged","contextDependenciesChanged","oldContext","delete","size","tailwindConfigHash1","context1","disposable","context2"],"sources":["C:/Users/Rohith/mern/frontend/node_modules/tailwindcss/lib/lib/setupContextUtils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    isValidVariantFormatString: ()=>isValidVariantFormatString,\n    parseVariant: ()=>parseVariant,\n    getFileModifiedMap: ()=>getFileModifiedMap,\n    createContext: ()=>createContext,\n    getContext: ()=>getContext\n});\nconst _fs = /*#__PURE__*/ _interopRequireDefault(require(\"fs\"));\nconst _url = /*#__PURE__*/ _interopRequireDefault(require(\"url\"));\nconst _postcss = /*#__PURE__*/ _interopRequireDefault(require(\"postcss\"));\nconst _dlv = /*#__PURE__*/ _interopRequireDefault(require(\"dlv\"));\nconst _postcssSelectorParser = /*#__PURE__*/ _interopRequireDefault(require(\"postcss-selector-parser\"));\nconst _featureFlagsJs = require(\"../featureFlags.js\");\nconst _transformThemeValue = /*#__PURE__*/ _interopRequireDefault(require(\"../util/transformThemeValue\"));\nconst _parseObjectStyles = /*#__PURE__*/ _interopRequireDefault(require(\"../util/parseObjectStyles\"));\nconst _prefixSelector = /*#__PURE__*/ _interopRequireDefault(require(\"../util/prefixSelector\"));\nconst _isPlainObject = /*#__PURE__*/ _interopRequireDefault(require(\"../util/isPlainObject\"));\nconst _escapeClassName = /*#__PURE__*/ _interopRequireDefault(require(\"../util/escapeClassName\"));\nconst _nameClass = /*#__PURE__*/ _interopRequireWildcard(require(\"../util/nameClass\"));\nconst _pluginUtils = require(\"../util/pluginUtils\");\nconst _bigSign = /*#__PURE__*/ _interopRequireDefault(require(\"../util/bigSign\"));\nconst _corePlugins = require(\"../corePlugins\");\nconst _sharedState = /*#__PURE__*/ _interopRequireWildcard(require(\"./sharedState\"));\nconst _toPath = require(\"../util/toPath\");\nconst _log = /*#__PURE__*/ _interopRequireDefault(require(\"../util/log\"));\nconst _negateValue = /*#__PURE__*/ _interopRequireDefault(require(\"../util/negateValue\"));\nconst _isValidArbitraryValue = /*#__PURE__*/ _interopRequireDefault(require(\"../util/isValidArbitraryValue\"));\nconst _generateRules = require(\"./generateRules\");\nconst _cacheInvalidationJs = require(\"./cacheInvalidation.js\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nlet MATCH_VARIANT = Symbol();\nfunction prefix(context, selector) {\n    let prefix = context.tailwindConfig.prefix;\n    return typeof prefix === \"function\" ? prefix(selector) : prefix + selector;\n}\nfunction parseVariantFormatString(input) {\n    if (input.includes(\"{\")) {\n        if (!isBalanced(input)) throw new Error(`Your { and } are unbalanced.`);\n        return input.split(/{(.*)}/gim).flatMap((line)=>parseVariantFormatString(line)).filter(Boolean);\n    }\n    return [\n        input.trim()\n    ];\n}\nfunction isBalanced(input) {\n    let count = 0;\n    for (let char of input){\n        if (char === \"{\") {\n            count++;\n        } else if (char === \"}\") {\n            if (--count < 0) {\n                return false // unbalanced\n                ;\n            }\n        }\n    }\n    return count === 0;\n}\nfunction insertInto(list, value, { before =[]  } = {}) {\n    before = [].concat(before);\n    if (before.length <= 0) {\n        list.push(value);\n        return;\n    }\n    let idx = list.length - 1;\n    for (let other of before){\n        let iidx = list.indexOf(other);\n        if (iidx === -1) continue;\n        idx = Math.min(idx, iidx);\n    }\n    list.splice(idx, 0, value);\n}\nfunction parseStyles(styles) {\n    if (!Array.isArray(styles)) {\n        return parseStyles([\n            styles\n        ]);\n    }\n    return styles.flatMap((style)=>{\n        let isNode = !Array.isArray(style) && !(0, _isPlainObject.default)(style);\n        return isNode ? style : (0, _parseObjectStyles.default)(style);\n    });\n}\nfunction getClasses(selector, mutate) {\n    let parser = (0, _postcssSelectorParser.default)((selectors)=>{\n        let allClasses = [];\n        if (mutate) {\n            mutate(selectors);\n        }\n        selectors.walkClasses((classNode)=>{\n            allClasses.push(classNode.value);\n        });\n        return allClasses;\n    });\n    return parser.transformSync(selector);\n}\nfunction extractCandidates(node, state = {\n    containsNonOnDemandable: false\n}, depth = 0) {\n    let classes = [];\n    // Handle normal rules\n    if (node.type === \"rule\") {\n        // Ignore everything inside a :not(...). This allows you to write code like\n        // `div:not(.foo)`. If `.foo` is never found in your code, then we used to\n        // not generated it. But now we will ignore everything inside a `:not`, so\n        // that it still gets generated.\n        function ignoreNot(selectors) {\n            selectors.walkPseudos((pseudo)=>{\n                if (pseudo.value === \":not\") {\n                    pseudo.remove();\n                }\n            });\n        }\n        for (let selector of node.selectors){\n            let classCandidates = getClasses(selector, ignoreNot);\n            // At least one of the selectors contains non-\"on-demandable\" candidates.\n            if (classCandidates.length === 0) {\n                state.containsNonOnDemandable = true;\n            }\n            for (let classCandidate of classCandidates){\n                classes.push(classCandidate);\n            }\n        }\n    } else if (node.type === \"atrule\") {\n        node.walkRules((rule)=>{\n            for (let classCandidate of rule.selectors.flatMap((selector)=>getClasses(selector))){\n                classes.push(classCandidate);\n            }\n        });\n    }\n    if (depth === 0) {\n        return [\n            state.containsNonOnDemandable || classes.length === 0,\n            classes\n        ];\n    }\n    return classes;\n}\nfunction withIdentifiers(styles) {\n    return parseStyles(styles).flatMap((node)=>{\n        let nodeMap = new Map();\n        let [containsNonOnDemandableSelectors, candidates] = extractCandidates(node);\n        // If this isn't \"on-demandable\", assign it a universal candidate to always include it.\n        if (containsNonOnDemandableSelectors) {\n            candidates.unshift(_sharedState.NOT_ON_DEMAND);\n        }\n        // However, it could be that it also contains \"on-demandable\" candidates.\n        // E.g.: `span, .foo {}`, in that case it should still be possible to use\n        // `@apply foo` for example.\n        return candidates.map((c)=>{\n            if (!nodeMap.has(node)) {\n                nodeMap.set(node, node);\n            }\n            return [\n                c,\n                nodeMap.get(node)\n            ];\n        });\n    });\n}\nfunction isValidVariantFormatString(format) {\n    return format.startsWith(\"@\") || format.includes(\"&\");\n}\nfunction parseVariant(variant) {\n    variant = variant.replace(/\\n+/g, \"\").replace(/\\s{1,}/g, \" \").trim();\n    let fns = parseVariantFormatString(variant).map((str)=>{\n        if (!str.startsWith(\"@\")) {\n            return ({ format  })=>format(str);\n        }\n        let [, name, params] = /@(.*?)( .+|[({].*)/g.exec(str);\n        return ({ wrap  })=>wrap(_postcss.default.atRule({\n                name,\n                params: params.trim()\n            }));\n    }).reverse();\n    return (api)=>{\n        for (let fn of fns){\n            fn(api);\n        }\n    };\n}\nfunction buildPluginApi(tailwindConfig, context, { variantList , variantMap , offsets , classList  }) {\n    function getConfigValue(path, defaultValue) {\n        return path ? (0, _dlv.default)(tailwindConfig, path, defaultValue) : tailwindConfig;\n    }\n    function applyConfiguredPrefix(selector) {\n        return (0, _prefixSelector.default)(tailwindConfig.prefix, selector);\n    }\n    function prefixIdentifier(identifier, options) {\n        if (identifier === _sharedState.NOT_ON_DEMAND) {\n            return _sharedState.NOT_ON_DEMAND;\n        }\n        if (!options.respectPrefix) {\n            return identifier;\n        }\n        return context.tailwindConfig.prefix + identifier;\n    }\n    function resolveThemeValue(path, defaultValue, opts = {}) {\n        const [pathRoot, ...subPaths] = (0, _toPath.toPath)(path);\n        const value = getConfigValue([\n            \"theme\",\n            pathRoot,\n            ...subPaths\n        ], defaultValue);\n        return (0, _transformThemeValue.default)(pathRoot)(value, opts);\n    }\n    const theme = Object.assign((path, defaultValue = undefined)=>resolveThemeValue(path, defaultValue), {\n        withAlpha: (path, opacityValue)=>resolveThemeValue(path, undefined, {\n                opacityValue\n            })\n    });\n    let api = {\n        postcss: _postcss.default,\n        prefix: applyConfiguredPrefix,\n        e: _escapeClassName.default,\n        config: getConfigValue,\n        theme,\n        corePlugins: (path)=>{\n            if (Array.isArray(tailwindConfig.corePlugins)) {\n                return tailwindConfig.corePlugins.includes(path);\n            }\n            return getConfigValue([\n                \"corePlugins\",\n                path\n            ], true);\n        },\n        variants: ()=>{\n            // Preserved for backwards compatibility but not used in v3.0+\n            return [];\n        },\n        addBase (base) {\n            for (let [identifier, rule] of withIdentifiers(base)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                let offset = offsets.base++;\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offset,\n                        layer: \"base\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        /**\n     * @param {string} group\n     * @param {Record<string, string | string[]>} declarations\n     */ addDefaults (group, declarations) {\n            const groups = {\n                [`@defaults ${group}`]: declarations\n            };\n            for (let [identifier, rule] of withIdentifiers(groups)){\n                let prefixedIdentifier = prefixIdentifier(identifier, {});\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.base++,\n                        layer: \"defaults\"\n                    },\n                    rule\n                ]);\n            }\n        },\n        addComponents (components, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: false\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(components)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.components++,\n                        layer: \"components\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        addUtilities (utilities, options) {\n            let defaultOptions = {\n                preserveSource: false,\n                respectPrefix: true,\n                respectImportant: true\n            };\n            options = Object.assign({}, defaultOptions, Array.isArray(options) ? {} : options);\n            for (let [identifier, rule] of withIdentifiers(utilities)){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                classList.add(prefixedIdentifier);\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push([\n                    {\n                        sort: offsets.utilities++,\n                        layer: \"utilities\",\n                        options\n                    },\n                    rule\n                ]);\n            }\n        },\n        matchUtilities: function(utilities, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: true\n            };\n            options = {\n                ...defaultOptions,\n                ...options\n            };\n            let offset = offsets.utilities++;\n            for(let identifier in utilities){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = utilities[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let { type =\"any\"  } = options;\n                    type = [].concat(type);\n                    let [value, coercedType] = (0, _pluginUtils.coerceValue)(type, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!type.includes(coercedType) && !isOnlyPlugin) {\n                        return [];\n                    }\n                    if (!(0, _isValidArbitraryValue.default)(value)) {\n                        return [];\n                    }\n                    let ruleSets = [].concat(rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"utilities\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        matchComponents: function(components, options) {\n            let defaultOptions = {\n                respectPrefix: true,\n                respectImportant: false\n            };\n            options = {\n                ...defaultOptions,\n                ...options\n            };\n            let offset = offsets.components++;\n            for(let identifier in components){\n                let prefixedIdentifier = prefixIdentifier(identifier, options);\n                let rule = components[identifier];\n                classList.add([\n                    prefixedIdentifier,\n                    options\n                ]);\n                function wrapped(modifier, { isOnlyPlugin  }) {\n                    let { type =\"any\"  } = options;\n                    type = [].concat(type);\n                    let [value, coercedType] = (0, _pluginUtils.coerceValue)(type, modifier, options, tailwindConfig);\n                    if (value === undefined) {\n                        return [];\n                    }\n                    if (!type.includes(coercedType)) {\n                        if (isOnlyPlugin) {\n                            _log.default.warn([\n                                `Unnecessary typehint \\`${coercedType}\\` in \\`${identifier}-${modifier}\\`.`,\n                                `You can safely update it to \\`${identifier}-${modifier.replace(coercedType + \":\", \"\")}\\`.`, \n                            ]);\n                        } else {\n                            return [];\n                        }\n                    }\n                    if (!(0, _isValidArbitraryValue.default)(value)) {\n                        return [];\n                    }\n                    let ruleSets = [].concat(rule(value)).filter(Boolean).map((declaration)=>({\n                            [(0, _nameClass.default)(identifier, modifier)]: declaration\n                        }));\n                    return ruleSets;\n                }\n                let withOffsets = [\n                    {\n                        sort: offset,\n                        layer: \"components\",\n                        options\n                    },\n                    wrapped\n                ];\n                if (!context.candidateRuleMap.has(prefixedIdentifier)) {\n                    context.candidateRuleMap.set(prefixedIdentifier, []);\n                }\n                context.candidateRuleMap.get(prefixedIdentifier).push(withOffsets);\n            }\n        },\n        addVariant (variantName, variantFunctions, options = {}) {\n            variantFunctions = [].concat(variantFunctions).map((variantFunction)=>{\n                if (typeof variantFunction !== \"string\") {\n                    // Safelist public API functions\n                    return (api)=>{\n                        let { args , modifySelectors , container , separator , wrap , format  } = api;\n                        let result = variantFunction(Object.assign({\n                            modifySelectors,\n                            container,\n                            separator\n                        }, variantFunction[MATCH_VARIANT] && {\n                            args,\n                            wrap,\n                            format\n                        }));\n                        if (typeof result === \"string\" && !isValidVariantFormatString(result)) {\n                            throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                        }\n                        if (Array.isArray(result)) {\n                            return result.filter((variant)=>typeof variant === \"string\").map((variant)=>parseVariant(variant));\n                        }\n                        // result may be undefined with legacy variants that use APIs like `modifySelectors`\n                        // result may also be a postcss node if someone was returning the result from `modifySelectors`\n                        return result && typeof result === \"string\" && parseVariant(result)(api);\n                    };\n                }\n                if (!isValidVariantFormatString(variantFunction)) {\n                    throw new Error(`Your custom variant \\`${variantName}\\` has an invalid format string. Make sure it's an at-rule or contains a \\`&\\` placeholder.`);\n                }\n                return parseVariant(variantFunction);\n            });\n            insertInto(variantList, variantName, options);\n            variantMap.set(variantName, variantFunctions);\n        }\n    };\n    if ((0, _featureFlagsJs.flagEnabled)(tailwindConfig, \"matchVariant\")) {\n        api.matchVariant = function(variants, options) {\n            for(let variant in variants){\n                var ref;\n                for (let [k, v] of Object.entries((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {})){\n                    api.addVariant(`${variant}-${k}`, variants[variant](v));\n                }\n                api.addVariant(variant, Object.assign(({ args  })=>variants[variant](args), {\n                    [MATCH_VARIANT]: true\n                }), options);\n            }\n        };\n    }\n    return api;\n}\nlet fileModifiedMapCache = new WeakMap();\nfunction getFileModifiedMap(context) {\n    if (!fileModifiedMapCache.has(context)) {\n        fileModifiedMapCache.set(context, new Map());\n    }\n    return fileModifiedMapCache.get(context);\n}\nfunction trackModified(files, fileModifiedMap) {\n    let changed = false;\n    for (let file of files){\n        var ref;\n        if (!file) continue;\n        let parsed = _url.default.parse(file);\n        let pathname = parsed.hash ? parsed.href.replace(parsed.hash, \"\") : parsed.href;\n        pathname = parsed.search ? pathname.replace(parsed.search, \"\") : pathname;\n        let newModified = (ref = _fs.default.statSync(decodeURIComponent(pathname), {\n            throwIfNoEntry: false\n        })) === null || ref === void 0 ? void 0 : ref.mtimeMs;\n        if (!newModified) {\n            continue;\n        }\n        if (!fileModifiedMap.has(file) || newModified > fileModifiedMap.get(file)) {\n            changed = true;\n        }\n        fileModifiedMap.set(file, newModified);\n    }\n    return changed;\n}\nfunction extractVariantAtRules(node) {\n    node.walkAtRules((atRule)=>{\n        if ([\n            \"responsive\",\n            \"variants\"\n        ].includes(atRule.name)) {\n            extractVariantAtRules(atRule);\n            atRule.before(atRule.nodes);\n            atRule.remove();\n        }\n    });\n}\nfunction collectLayerPlugins(root) {\n    let layerPlugins = [];\n    root.each((node)=>{\n        if (node.type === \"atrule\" && [\n            \"responsive\",\n            \"variants\"\n        ].includes(node.name)) {\n            node.name = \"layer\";\n            node.params = \"utilities\";\n        }\n    });\n    // Walk @layer rules and treat them like plugins\n    root.walkAtRules(\"layer\", (layerRule)=>{\n        extractVariantAtRules(layerRule);\n        if (layerRule.params === \"base\") {\n            for (let node of layerRule.nodes){\n                layerPlugins.push(function({ addBase  }) {\n                    addBase(node, {\n                        respectPrefix: false\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"components\") {\n            for (let node1 of layerRule.nodes){\n                layerPlugins.push(function({ addComponents  }) {\n                    addComponents(node1, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        } else if (layerRule.params === \"utilities\") {\n            for (let node2 of layerRule.nodes){\n                layerPlugins.push(function({ addUtilities  }) {\n                    addUtilities(node2, {\n                        respectPrefix: false,\n                        preserveSource: true\n                    });\n                });\n            }\n            layerRule.remove();\n        }\n    });\n    return layerPlugins;\n}\nfunction resolvePlugins(context, root) {\n    let corePluginList = Object.entries({\n        ..._corePlugins.variantPlugins,\n        ..._corePlugins.corePlugins\n    }).map(([name, plugin])=>{\n        if (!context.tailwindConfig.corePlugins.includes(name)) {\n            return null;\n        }\n        return plugin;\n    }).filter(Boolean);\n    let userPlugins = context.tailwindConfig.plugins.map((plugin)=>{\n        if (plugin.__isOptionsFunction) {\n            plugin = plugin();\n        }\n        return typeof plugin === \"function\" ? plugin : plugin.handler;\n    });\n    let layerPlugins = collectLayerPlugins(root);\n    // TODO: This is a workaround for backwards compatibility, since custom variants\n    // were historically sorted before screen/stackable variants.\n    let beforeVariants = [\n        _corePlugins.variantPlugins[\"pseudoElementVariants\"],\n        _corePlugins.variantPlugins[\"pseudoClassVariants\"], \n    ];\n    let afterVariants = [\n        _corePlugins.variantPlugins[\"directionVariants\"],\n        _corePlugins.variantPlugins[\"reducedMotionVariants\"],\n        _corePlugins.variantPlugins[\"prefersContrastVariants\"],\n        _corePlugins.variantPlugins[\"darkVariants\"],\n        _corePlugins.variantPlugins[\"printVariant\"],\n        _corePlugins.variantPlugins[\"screenVariants\"],\n        _corePlugins.variantPlugins[\"orientationVariants\"], \n    ];\n    return [\n        ...corePluginList,\n        ...beforeVariants,\n        ...userPlugins,\n        ...afterVariants,\n        ...layerPlugins\n    ];\n}\nfunction registerPlugins(plugins, context) {\n    let variantList = [];\n    let variantMap = new Map();\n    let offsets = {\n        defaults: 0n,\n        base: 0n,\n        components: 0n,\n        utilities: 0n,\n        user: 0n\n    };\n    let classList = new Set();\n    let pluginApi = buildPluginApi(context.tailwindConfig, context, {\n        variantList,\n        variantMap,\n        offsets,\n        classList\n    });\n    for (let plugin of plugins){\n        if (Array.isArray(plugin)) {\n            for (let pluginItem of plugin){\n                pluginItem(pluginApi);\n            }\n        } else {\n            plugin === null || plugin === void 0 ? void 0 : plugin(pluginApi);\n        }\n    }\n    let highestOffset = ((args)=>args.reduce((m, e)=>e > m ? e : m))([\n        offsets.base,\n        offsets.defaults,\n        offsets.components,\n        offsets.utilities,\n        offsets.user, \n    ]);\n    let reservedBits = BigInt(highestOffset.toString(2).length);\n    // A number one less than the top range of the highest offset area\n    // so arbitrary properties are always sorted at the end.\n    context.arbitraryPropertiesSort = (1n << reservedBits << 0n) - 1n;\n    context.layerOrder = {\n        defaults: 1n << reservedBits << 0n,\n        base: 1n << reservedBits << 1n,\n        components: 1n << reservedBits << 2n,\n        utilities: 1n << reservedBits << 3n,\n        user: 1n << reservedBits << 4n\n    };\n    reservedBits += 5n;\n    let offset = 0;\n    context.variantOrder = new Map(variantList.map((variant, i)=>{\n        let variantFunctions = variantMap.get(variant).length;\n        let bits = 1n << BigInt(i + offset) << reservedBits;\n        offset += variantFunctions - 1;\n        return [\n            variant,\n            bits\n        ];\n    }).sort(([, a], [, z])=>(0, _bigSign.default)(a - z)));\n    context.minimumScreen = [\n        ...context.variantOrder.values()\n    ].shift();\n    // Build variantMap\n    for (let [variantName, variantFunctions] of variantMap.entries()){\n        let sort = context.variantOrder.get(variantName);\n        context.variantMap.set(variantName, variantFunctions.map((variantFunction, idx)=>[\n                sort << BigInt(idx),\n                variantFunction\n            ]));\n    }\n    var _safelist;\n    let safelist = ((_safelist = context.tailwindConfig.safelist) !== null && _safelist !== void 0 ? _safelist : []).filter(Boolean);\n    if (safelist.length > 0) {\n        let checks = [];\n        for (let value of safelist){\n            if (typeof value === \"string\") {\n                context.changedContent.push({\n                    content: value,\n                    extension: \"html\"\n                });\n                continue;\n            }\n            if (value instanceof RegExp) {\n                _log.default.warn(\"root-regex\", [\n                    \"Regular expressions in `safelist` work differently in Tailwind CSS v3.0.\",\n                    \"Update your `safelist` configuration to eliminate this warning.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\", \n                ]);\n                continue;\n            }\n            checks.push(value);\n        }\n        if (checks.length > 0) {\n            let patternMatchingCount = new Map();\n            let prefixLength = context.tailwindConfig.prefix.length;\n            for (let util of classList){\n                let utils = Array.isArray(util) ? (()=>{\n                    let [utilName, options] = util;\n                    var ref;\n                    let values = Object.keys((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {});\n                    let classes = values.map((value)=>(0, _nameClass.formatClass)(utilName, value));\n                    if (options === null || options === void 0 ? void 0 : options.supportsNegativeValues) {\n                        // This is the normal negated version\n                        // e.g. `-inset-1` or `-tw-inset-1`\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>\"-\" + cls)\n                        ];\n                        // This is the negated version *after* the prefix\n                        // e.g. `tw--inset-1`\n                        // The prefix is already attached to util name\n                        // So we add the negative after the prefix\n                        classes = [\n                            ...classes,\n                            ...classes.map((cls)=>cls.slice(0, prefixLength) + \"-\" + cls.slice(prefixLength)), \n                        ];\n                    }\n                    if ([].concat(options === null || options === void 0 ? void 0 : options.type).includes(\"color\")) {\n                        classes = [\n                            ...classes,\n                            ...classes.flatMap((cls)=>Object.keys(context.tailwindConfig.theme.opacity).map((opacity)=>`${cls}/${opacity}`)), \n                        ];\n                    }\n                    return classes;\n                })() : [\n                    util\n                ];\n                for (let util1 of utils){\n                    for (let { pattern , variants =[]  } of checks){\n                        // RegExp with the /g flag are stateful, so let's reset the last\n                        // index pointer to reset the state.\n                        pattern.lastIndex = 0;\n                        if (!patternMatchingCount.has(pattern)) {\n                            patternMatchingCount.set(pattern, 0);\n                        }\n                        if (!pattern.test(util1)) continue;\n                        patternMatchingCount.set(pattern, patternMatchingCount.get(pattern) + 1);\n                        context.changedContent.push({\n                            content: util1,\n                            extension: \"html\"\n                        });\n                        for (let variant of variants){\n                            context.changedContent.push({\n                                content: variant + context.tailwindConfig.separator + util1,\n                                extension: \"html\"\n                            });\n                        }\n                    }\n                }\n            }\n            for (let [regex, count] of patternMatchingCount.entries()){\n                if (count !== 0) continue;\n                _log.default.warn([\n                    `The safelist pattern \\`${regex}\\` doesn't match any Tailwind CSS classes.`,\n                    \"Fix this pattern or remove it from your `safelist` configuration.\",\n                    \"https://tailwindcss.com/docs/content-configuration#safelisting-classes\", \n                ]);\n            }\n        }\n    }\n    // A list of utilities that are used by certain Tailwind CSS utilities but\n    // that don't exist on their own. This will result in them \"not existing\" and\n    // sorting could be weird since you still require them in order to make the\n    // host utitlies work properly. (Thanks Biology)\n    let parasiteUtilities = new Set([\n        prefix(context, \"group\"),\n        prefix(context, \"peer\")\n    ]);\n    context.getClassOrder = function getClassOrder(classes) {\n        let sortedClassNames = new Map();\n        for (let [sort, rule] of (0, _generateRules.generateRules)(new Set(classes), context)){\n            if (sortedClassNames.has(rule.raws.tailwind.candidate)) continue;\n            sortedClassNames.set(rule.raws.tailwind.candidate, sort);\n        }\n        return classes.map((className)=>{\n            var ref;\n            let order = (ref = sortedClassNames.get(className)) !== null && ref !== void 0 ? ref : null;\n            if (order === null && parasiteUtilities.has(className)) {\n                // This will make sure that it is at the very beginning of the\n                // `components` layer which technically means 'before any\n                // components'.\n                order = context.layerOrder.components;\n            }\n            return [\n                className,\n                order\n            ];\n        });\n    };\n    // Generate a list of strings for autocompletion purposes, e.g.\n    // ['uppercase', 'lowercase', ...]\n    context.getClassList = function getClassList() {\n        let output = [];\n        for (let util of classList){\n            if (Array.isArray(util)) {\n                let [utilName, options] = util;\n                let negativeClasses = [];\n                var ref;\n                for (let [key, value] of Object.entries((ref = options === null || options === void 0 ? void 0 : options.values) !== null && ref !== void 0 ? ref : {})){\n                    output.push((0, _nameClass.formatClass)(utilName, key));\n                    if ((options === null || options === void 0 ? void 0 : options.supportsNegativeValues) && (0, _negateValue.default)(value)) {\n                        negativeClasses.push((0, _nameClass.formatClass)(utilName, `-${key}`));\n                    }\n                }\n                output.push(...negativeClasses);\n            } else {\n                output.push(util);\n            }\n        }\n        return output;\n    };\n}\nfunction createContext(tailwindConfig, changedContent = [], root = _postcss.default.root()) {\n    let context = {\n        disposables: [],\n        ruleCache: new Set(),\n        classCache: new Map(),\n        applyClassCache: new Map(),\n        notClassCache: new Set(),\n        postCssNodeCache: new Map(),\n        candidateRuleMap: new Map(),\n        tailwindConfig,\n        changedContent: changedContent,\n        variantMap: new Map(),\n        stylesheetCache: null\n    };\n    let resolvedPlugins = resolvePlugins(context, root);\n    registerPlugins(resolvedPlugins, context);\n    return context;\n}\nlet contextMap = _sharedState.contextMap;\nlet configContextMap = _sharedState.configContextMap;\nlet contextSourcesMap = _sharedState.contextSourcesMap;\nfunction getContext(root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies) {\n    let sourcePath = result.opts.from;\n    let isConfigFile = userConfigPath !== null;\n    _sharedState.env.DEBUG && console.log(\"Source path:\", sourcePath);\n    let existingContext;\n    if (isConfigFile && contextMap.has(sourcePath)) {\n        existingContext = contextMap.get(sourcePath);\n    } else if (configContextMap.has(tailwindConfigHash)) {\n        let context = configContextMap.get(tailwindConfigHash);\n        contextSourcesMap.get(context).add(sourcePath);\n        contextMap.set(sourcePath, context);\n        existingContext = context;\n    }\n    let cssDidChange = (0, _cacheInvalidationJs.hasContentChanged)(sourcePath, root);\n    // If there's already a context in the cache and we don't need to\n    // reset the context, return the cached context.\n    if (existingContext) {\n        let contextDependenciesChanged = trackModified([\n            ...contextDependencies\n        ], getFileModifiedMap(existingContext));\n        if (!contextDependenciesChanged && !cssDidChange) {\n            return [\n                existingContext,\n                false\n            ];\n        }\n    }\n    // If this source is in the context map, get the old context.\n    // Remove this source from the context sources for the old context,\n    // and clean up that context if no one else is using it. This can be\n    // called by many processes in rapid succession, so we check for presence\n    // first because the first process to run this code will wipe it out first.\n    if (contextMap.has(sourcePath)) {\n        let oldContext = contextMap.get(sourcePath);\n        if (contextSourcesMap.has(oldContext)) {\n            contextSourcesMap.get(oldContext).delete(sourcePath);\n            if (contextSourcesMap.get(oldContext).size === 0) {\n                contextSourcesMap.delete(oldContext);\n                for (let [tailwindConfigHash1, context1] of configContextMap){\n                    if (context1 === oldContext) {\n                        configContextMap.delete(tailwindConfigHash1);\n                    }\n                }\n                for (let disposable of oldContext.disposables.splice(0)){\n                    disposable(oldContext);\n                }\n            }\n        }\n    }\n    _sharedState.env.DEBUG && console.log(\"Setting up new context...\");\n    let context2 = createContext(tailwindConfig, [], root);\n    trackModified([\n        ...contextDependencies\n    ], getFileModifiedMap(context2));\n    // ---\n    // Update all context tracking state\n    configContextMap.set(tailwindConfigHash, context2);\n    contextMap.set(sourcePath, context2);\n    if (!contextSourcesMap.has(context2)) {\n        contextSourcesMap.set(context2, new Set());\n    }\n    contextSourcesMap.get(context2).add(sourcePath);\n    return [\n        context2,\n        true\n    ];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}